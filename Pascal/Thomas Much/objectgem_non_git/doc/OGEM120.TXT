                         Die Dokumentation zu

                            ObjectGEM 1.20

                          10. September 1997

                                 von

                             Thomas Much


Inhaltsverzeichnis
==================

 1  Allgemeine Hinweise
 2  Felder und Methoden
 3  Konstanten
 4  Objekte
 5  Objekthierarchie
 6  Prozeduren und Funktionen
 7  Typen und Records
 8  Units
 9  Variablen


Anhang
======

 A  Kontakt
 B  Dank
 C  Literatur



1  Allgemeine Hinweise
**********************


1.1  BubbleHelp
===============

Mit dem "BubbleHelp"-Hilfesystem kann sehr leicht eine kontextsensiti-
ve Hilfe realisiert werden. Dazu kann TControl-, TIcon- und TToolbar-
Objekten (und davon abgeleiteten Objekten) in der jeweiligen Init-
Methode ein String bergeben werden, der von der Dialogbehandlung
ausgewertet wird. Im weiteren braucht dieser Hilfstext nicht weiter
beachtet zu werden, einzig interessant ist noch die Methode SetHelp
zum nachtr„glichen ndern des Textes.

Wenn man in einem Dialog den Mauscursor auf ein solches Dialogelement
bringt und die rechte Maustaste oder <Help> drckt, erscheint an der
Mausposition eine Sprechblase mit dem festgelegten Hilfstext. Die
Sprechblase bleibt mind. eine halbe Sekunde (ObjectGEM-intern festge-
legt) sichtbar, danach kann sie mit einem Mausklick oder einem
Tastendruck geschlossen werden.

Fr die kontextsensitive Hilfe auerhalb von Dialogen steht die
Methode TApplication.BubbleHelp zur Verfgung. Dort ist auch der
Aufbau der Hilfe-Strings beschrieben.

In Zukunft wird es evtl. einen sog. "st„ndigen Hilfemodus" geben, bei
dem eine Sprechblase erscheint, wenn sich der Mauscursor eine gewisse
Zeit ber einem Dialogelement befindet (wie beim Mac System 7).
ObjectGEM legt dafr bereits jetzt den 'BHLP'-Cookie an, dessen Wert
sich aus der Verz”gerung bis zur Aktivierung der Hilfe (unterer
integer, -1=Hilfemodus aus) und der Mindestzeit fr die Sichtbarkeit
der Sprechblase (oberes word) zusammensetzt.


1.2  Clipboard-Verwaltung
=========================

Die Objekte TEdit, TWindow und TApplication besitzen das Feld Clip-
board, das auf ein TClipboard-Objekt zeigt. Normalerweise gibt es nur
ein globales Clipboard-Objekt, falls aber eine Spezialisierung
notwendig sein sollte, steht die Methode GetClipboard zur Verfgung.

Um auf das Clipboard zugreifen zu k”nnen (lesend oder schreibend), mu
man es mit OpenClipboard ”ffnen. Von GetClipboardFilename erh„lt man
eine komplette Pfadangabe incl. Dateinamen fr das Klemmbrett - nur
die Extension fehlt noch (z.B. 'C:\CLIPBRD\SCRAP.'). Mit IsClip-
boardFormatAvailable und GetPriorityClipboardFormat kann man
komfortabel nach bestimmten Dateitypen im Klemmbrett suchen, ansonsten
kann man nun mit den "normalen" Dateifunktionen auf das Klemmbrett
zugreifen. Abschlieend mu man das Klemmbrett mit CloseClipboard
wieder schlieen und damit freigeben.

Hat man den Inhalt des Klemmbretts ver„ndert, sollte man vorher noch
SetClipboardFormat aufrufen, damit die beim Schlieen verschickte
SC_CHANGED-Message korrekt gesetzt werden kann.

Wichtig: Es kann immer nur ein TClipboard-Objekt Zugriff auf das
Klemmbrett haben. Wenn also ein Zugriff immer bereits beim ™ffnen
scheitert, kann es sein, da bei einem anderen Clipboard-Objekt das
Schlieen vergessen wurde.


1.3  Drag&Drop
==============

In ObjectGEM ist das Drag&Drop-Protokoll in der Version 1.1 implemen-
tiert. Der Drag&Drop-Mechanismus steht nur unter MultiTOS und
kompatiblen Betriebssystemen zur verfgung.

Wenn ein Programm Drag&Drop untersttzen soll, mssen zumindest die
Methoden DDHeaderReply und DDReadData (bzw. DDReadArgs) berschrieben
werden. Das Einlesen der Daten mu in letztgenannter Methode selbst
vorgenommen werden. Da w„hrend des Drag&Drop-Protokolls der Bildschirm
nicht blockiert werden darf, erh„lt man nach erfolgreicher Kommunika-
tion in der Methode DDFinished die M”glichkeit, die Daten entsprechend
auszuwerten.

Wenn der Aufbau der Kommunikation nicht unn”tig in die L„nge gezogen
werden soll, mu dafr die Methode DDGetPreferredTypes berschrieben
werden, in der man die m”glichen Dateitypen einschr„nken kann.

Soll das Programm auch auf den 'PATH'-Parameter positiv antworten, mu
DDGetPath effektiv gemacht werden.


1.4  Einbinden der Units
========================

Die ObjectGEM-Units werden wie gewohnt mit der uses-Klausel eingebun-
den. Dabei sollte folgende Reihenfolge eingehalten werden (abgesehen
von nicht ben”tigten Units):


  uses Objects,
       OTypes,
       OProcs,
       OWindows,
       OValidat,
       ODialogs,
       OStdDlgs,
       OStdWnds,
       ODB;


Wenn zus„tzlich noch andere Units eingebunden werden (z.B. Gem, Tos
etc.), sollten diese davor eingebunden werden, es sei denn, die Units
greifen auf Teile von ObjectGEM zurck.

Welche ObjectGEM-Units ben”tigt werden, stellt man am besten mit "try
and error" fest. Zuerst wird nur die Unit OWindows eingebunden, dann
mssen solange die passenden Units dazugenommen werden, bis der
Compiler nicht mehr "meckert".


1.5  Erweiterte Dialogbehandlung
================================

ObjectGEM stellt eine erweiterte Dialogbehandlung zur Verfgung.
Folgende Eigenschaften sind zus„tzlich zu den blichen GEM-M”glichkei-
ten vorhanden:

   ù Der Edit-Cursor kann mit der Maus verschoben werden

   ù Folgende Tastenkombinationen stehen in einem Edit-Feld zur
     Verfgung:


   +-----------------------+-------------------------------------+
   | <Shift>+<Tab>,        |                                     |
   | <Cursor hoch>         | geht zum vorherigen Eingabefeld     |
   +-----------------------+-------------------------------------+
   | <Tab>,                |                                     |
   | <Cursor runter>       | geht zum n„chsten Eingabefeld       |
   +-----------------------+-------------------------------------+
   | <Cursor links>,       |                                     |
   | <Cursor rechts>       | Cursor innerhalb des Feldes bewegen |
   +-----------------------+-------------------------------------+
   | <Shift>+<Crs.li.>     | Cursor an Feldanfang                |
   +-----------------------+-------------------------------------+
   | <Shift>+<Crs.re.>     | Cursor an Feldende                  |
   +-----------------------+-------------------------------------+
   | <ClrHome>,            |                                     |
   | <Shift>+<Crs. hoch>   | Cursor auf erstes Eingabefeld       |
   +-----------------------+-------------------------------------+
   | <Shift>+<ClrHome>,    |                                     |
   | <Shift>+<Crs. runter> | Cursor auf letztes Eingabefeld      |
   +-----------------------+-------------------------------------+
   | <Backspace>           | Zeichen links vom Cursor l”schen    |
   +-----------------------+-------------------------------------+
   | <Delete>              | Zeichen rechts vom Cursor l”schen   |
   +-----------------------+-------------------------------------+
   | <Esc>                 | Feld l”schen                        |
   +-----------------------+-------------------------------------+
   | <Undo>                | s.u.                                |
   +-----------------------+-------------------------------------+

   ù Jedes Eingabefeld, dem ein TEdit-Objekt zugeordnet ist, merkt
     sich die Position des Edit-Cursors bis zur n„chsten Aktivierung.
     Auerdem kann mit <Undo> die letzte nderung rckg„ngig gemacht
     werden.

   ù Dialogelemente, bei denen ein Buchstabe unterstrichen angezeigt
     wird, k”nnen mit <Alternate>+<unterstrichener Buchstabe> akti-
     viert werden.

   ù TDialog-Objekte, bei denen cs_WorkBackground gesetzt ist (das ist
     die Standard-Einstellung), k”nnen auch im Hintergrund bedient
     werden. Um ein solches Dialogfenster wieder in den Vordergrund zu
     holen, mu man einen Doppelklick rechts auf den Arbeitsbereich
     des Fensters ausfhren.

   ù Modale Dialoge k”nnen durch Anklicken eines inaktiven Dialogele-
     ments (z.B. Text oder der Hintergrund) bei gedrckter linker
     Maustaste verschoben werden.

   ù Bei einem Klick auerhalb eines modalen Dialogs wird dieser um
     den Mauszeiger zentriert.

   ù Befindet sich der Mauscursor ber einem Dialogelement, dem ein
     TControl-Objekt zugeordnet ist (das sollte bei den meisten der
     Fall sein), kann mit der rechten Maustaste oder mit <Help> die
     sog. "BubbleHelp" aufgerufen werden.


1.6  Fenster
============

Mit cs_WorkBackground k”nnen Fenster dazu gebracht werden, da man sie
im Hintergrund bedienen kann (unter allen TOS-Versionen). Dies gilt
natrlich nur fr den Arbeitsbereich, die Fensterkomponenten k”nnen
nur im Hintergrund angew„hlt werden, wenn das Betriebssystem dies
untersttzt (z.B. MultiTOS). Solche Fenster k”nnen nur noch durch
Anklicken einer Fensterkomponente (Titelzeile etc.) getoppt werden,
oder - dies ist ein ObjectGEM-spezifisches Feature - mit einem Doppel-
klick rechts im Arbeitsbereich!

In den TWindow-Fensterobjekten sind z.Z. folgende Tastatur-Shortcuts
vorgesehen (#<...> bedeutet, da die Taste im Ziffernblock gemeint
ist):


+-------------------------+----------------------------------------------+
| <Control>+<A>           | W„hlt alle passenden Elemente im Fenster aus |
|                         | (siehe TWindow.SelectAll)                    |
+-------------------------+----------------------------------------------+
| <Control>+<C>           | Fhrt die "Kopieren"-Operation durch         |
|                         | (siehe TWindow.Copy)                         |
+-------------------------+----------------------------------------------+
| <Control>+<P>           | Druckt den Fensterinhalt aus                 |
|                         | (siehe TWindow.Print bzw. TTextWindow.Print) |
+-------------------------+----------------------------------------------+
| <Control>+<U>           | Schliet das Fenster                         |
+-------------------------+----------------------------------------------+
| <Control>+<V>           | Fhrt die "Einfgen"-Operation durch         |
|                         | (siehe TWindow.Paste)                        |
+-------------------------+----------------------------------------------+
| <Control>+<W>           | Wechselt die Fenster der Applikation         |
|                         | zyklisch (mit <Shift> in umgekehrter         |
|                         | Reihenfolge)                                 |
+-------------------------+----------------------------------------------+
| <Control>+<X>           | Fhrt die "Ausschneiden"-Operation durch     |
|                         | (siehe TWindow.Cut)                          |
+-------------------------+----------------------------------------------+
| <Control>+#<*>          | Bringt das Fenster auf Maximalgr”e          |
+-------------------------+----------------------------------------------+
| <Control>+#</>          | Bringt das Fenster in den Hintergrund        |
|                         | (AES 4.0)                                    |
+-------------------------+----------------------------------------------+
| <Control>+<Alt>+<Space> | Ikonifiziert das Fenster                     |
+-------------------------+----------------------------------------------+
| <Delete>                | Fhrt die "Entfernen"-Operation durch        |
|                         | (siehe TWindow.Delete)                       |
+-------------------------+----------------------------------------------+
| <Control>+<Q>           | Verl„t das Programm                         |
|                         | (dies ist eigentlich kein Fenster-Shortcut)  |
+-------------------------+----------------------------------------------+


1.7  Iconification
==================

Ab AES 4.10 untersttzt ObjectGEM Iconification, d.h. GetStyle liefert
zus„tzlich den Wert SMALLER zurck, und im Fenster erscheint links
neben dem Fuller noch der "Verkleinerungsknopf".

Wenn dieser Button angew„hlt wird, wird das entsprechende Fenster
ikonifiziert. Dem Icon-Fenster kann per GetIconTitle ein neuer Titel
zugewiesen werden, auerdem wird bei einem Redraw nun die Methode
IconPaint aufgerufen. Der Status eines Fensters l„t sich mit Is-
Iconified abfragen.

Wenn beim Anklicken des SMALLERs zus„tzlich die <Control>-Taste
gedrckt wird, wird die gesamte Applikation ikonifiziert, d.h. alle
Fenster werden in einem Icon-Fenster zusammengefat. Dafr stehen
„hnliche Funktionen wie bei einem Fenster zur Verfgung. Wichtig:
Hierbei werden die Fenster der Applikation nicht geschlossen, sondern
nur rechts so weit ber den Bildschirmrand geschoben, da man sie
nicht mehr sieht und der Benutzer keine Aktionen mehr an ihnen durch-
fhren kann. Fr die Applikation wird dann ein neues Icon-Fenster
ge”ffnet.

Soll in einem ikonifizierten Fenster automatisch ein Icon angezeigt
werden, mu TWindow.LoadIcon aufgerufen werden. Damit auch bei einem
Applikations-Icon-Fenster ein Icon erscheint, steht die Methode
TApplication.LoadIcon zur Verfgung. Dialoge bernehmen dieses Icon
automatisch, wenn ihnen kein eigenes Icon zugewiesen wird.

Ist ein ICFS-Server installiert, so ist Iconification auch unter alten
TOS-Versionen m”glich. Wird beim Anklicken der CLOSERs die <Alter-
nate>-Taste gedrckt, wird das Fenster ikonifiziert. Das Verkleinern
aller Fenster mit <Control> ist aus technischen Grnden (noch) nicht
m”glich bzw. sinnvoll. In einer sp„teren Version wird es allerdings
auch die ICFS-Iconification mit <Shift> geben (alle Fenster werden
einzeln verkleinert).

Ikonifizierte Fenster oder Applikationen erhalten von ObjectGEM nur
noch Timer- sowie ausgesuchte Message-Events. Evtl. kann in Zukunft
aber ein Flag gesetzt werden, so da auch in einem Icon-Fenster
Aktionen durchgefhrt werden k”nnen.


1.8  Interna
============

   ù Die Unit OWindows installiert eine neue HeapError-Funktion, die
     bei Fehlschlagen einer Speicheranforderung einen nil-Pointer
     zurckgibt.

   ù ExitProc wird von OWindows umgelenkt, so da bei einem aueror-
     dentlichen Programmabbruch noch versucht werden kann, ein evtl.
     angelegtes Applikations-Objekt freizugegeben.

   ù Wenn SpeedoGDOS installiert ist, werden die Speedo-Fehlermeldun-
     gen mittels vst_error() so umgeleitet, da diese nicht mehr auf
     dem Bildschirm angezeigt werden, sondern mit ChkSpeedoError
     abgefragt werden k”nnen.

   ù Ist MiNT oder MultiTOS aktiv, lenkt TApplication.InitGEM die
     Signale SIGTERM und SIGQUIT auf einen eigenen Handler um, damit
     die Applikation korrekt verlassen werden kann.

   ù Wenn appl_getinfo() vorhanden ist, wird diese Auskunftsfunktion
     verwendet, um spezielle Systemeigenschaften zu ermitteln (so wird
     die MagiC-Anpassung realisiert). Fr das Vorhandensein der
     Routine werden AES- bzw. MagiC-Version getestet sowie die ?AGI-
     Methode untersttzt (appl_find('?AGI')=0).

   ù Wenn "Let'em Fly" installiert ist, wird die Dialog-Flugroutine
     sowie die Routine beim Klick auerhalb des Dialogs fr modale
     Dialoge verwendet.

   ù Der 'VSCR'-Cookie (Virtual Screen) wird beachtet.

   ù WINX ab Version 2.2 wird direkt untersttzt, z.B. durch die
     WMArrowed-Methode (Scrollboxen).

   ù Fr die BubbleHelp wird der Cookie 'BHLP' angelegt.

Die GEM-Message GO_PRIVATE ($1235) wird intern mit folgenden Sub-
Opcodes in msg[3] verwendet:


+----------------+-------+--------------------------------------------+
| GOP_GETVERSION |     0 | dient als Aufforderung, eine GOP_VERSION-  |
|                |       | Message zu schicken                        |
+----------------+-------+--------------------------------------------+
| GOP_TOOLBAR    |     1 | siehe TToolbar.TestMessage                 |
+----------------+-------+--------------------------------------------+
| GOP_SETQUIT    |     2 | wird von LoadMenu verschickt, um den Men- |
|                |       | eintrag (msg[4]) und -titel (msg[5]) fr   |
|                |       | das <Control>+<Q>-Objekt zu setzen; beim   |
|                |       | Empfang dieser Message ruft MUMesag die    |
|                |       | Methode SetQuit auf                        |
+----------------+-------+--------------------------------------------+
| GOP_VERSION    | $7fff | wird als Antwort auf GOP_GETVERSION ver-   |
|                |       | schickt; in msg[4] erh„lt man die jewei-   |
|                |       | lige GOVersion                             |
+----------------+-------+--------------------------------------------+


1.9  Kompatibilit„t
===================

Im folgenden ist aufgelistet, bei welchem Versionssprung solche
nderungen vorgenommen wurden, die nicht ganz kompatibel zur Vorg„n-
gerversion waren und daher evtl. Ver„nderungen an eigenen Quelltexten
nach sich ziehen.

 1.17->1.20:

        ù TApplication.ID existiert nicht mehr (!)

        ù es wird kein Applikations-spezifischer Cookie mehr angelegt

        ù GP und UpdateGPValues wurden entfernt (!)

        ù jedes Fenster hat nun eine eigene VDI-Workstation

        ù cs_UserToolbar heit jetzt cs_WindowMenuToolbar

        ù SetMouse heit jetzt SetMousePos

 1.16->1.17:

        ù cs_FullRedraw wird nur noch bei einer Gr”en„nderung
          verschickt

        ù TApplication.MNSelected fragt TWindow.EventList nicht mehr
          ab, wenn das Fenster eine eigene Menleiste besitzt

 1.15->1.16:

        ù der Datentyp von MapKey ist nun word

        ù TApplication.CBUpdate heit nun SCChanged, die CBT-Konstan-
          ten beginnen jetzt mit SCF

        ù TWindow.ChkMin heit ChkSize

        ù TApplication.SendWndMessage wurde erweitert

        ù TWindow.WMArrowed wurde erweitert

        ù die TWindow.WAxxxx-Methoden wurden entfernt (!)

        ù TWindow.ChkMax wurde entfernt (!)

 1.14->1.15: Da PP offensichtlich extreme Probleme mit Objekten hat,
     in denen viele virtuelle Methoden vorkommen, wurden folgende
     Methoden statisch gemacht:

        ù TApplication: IsIconified, GetGPWindow, GetPWindow,
          GetPTopWindow, At, IndexOf, FirstWndThat, ForEachWnd

        ù TCollection: FirstThat, ForEach

        ù TControl: IsFlagSet, Previous, Next

        ù TDialog: FirstThat, ForEach

        ù TEvent: Previous, Next

        ù TWindow: At, DisableAutoCreate, EnableAutoCreate,
          FirstWndThat, ForEachWnd, GetTitle, IndexOf, IsIconified,
          IsModeless, Next, Previous

 1.12->1.14:

        ù bei einigen TApplication-Drag&Drop-Methoden wurde die
          Position der šbergabeparameter korrigiert

 1.11->1.12:

        ù TSortedCollection.Insert gibt den alten Eintrag beim
          Ersetzen nun frei

        ù TDialog.ObjcPaint wurde erweitert

        ù die DDReadData-Methoden wurden erweitert

 1.10->1.11:

        ù wenn ein TScroller-Objekt zum Einsatz kommt, mu dieses nun
          mit TWindow.GetScroller angelegt werden

 1.06->1.10:

        ù einige Mausformen wurden entfernt

        ù die Fenstergr”enberechnung mu nun in der Methode
          TWindow.SetupSize durchgefhrt werden

        ù TApplication.HandleXAcc erh„lt nicht mehr alle XAcc-Messages
          (wg. der autom. Untersttzung)

        ù TWindow.WMDragDrop, TApplication.APDragDrop und
          TApplication.HandleDragDrop wurden erweitert

 1.03->1.04:

        ù BootDevice liefert nur noch char


1.10  Toolbars
==============

Fenster-Toolbars bestehen aus ganz normalen Dialog-B„umen in der
Resource-Datei, die in SetupWindow mittels LoadToolbar mit dem Fenster
verknpft werden. Um eine einfach Bearbeitung zu gew„hrleisten,
sollten danach alle Toolbar-Buttons mit TToolbar-Objekten verknpft
werden, die als Schnittstellenobjekte dienen.

Eine andere M”glichkeit sind Anwender-konfigurierbare Toolbars. Dabei
kann der sp„tere Anwender des Programms sich seine Toolbar-Buttons mit
einem Resource Construction Set zusammenstellen. Diese Buttons werden
nicht mit TToolbar-Objekten verknpft (der Programmierer kann ja nicht
alle Anwenderwnsche bercksichtigen), sondern ber den erweiterten
Objekttyp mit einem Meneintrag in der Menleiste der Applikation.
Dieses ist die einzige Situation, in der die Verwendung des
h”herwertigen Bytes von ob_type unter ObjectGEM gestattet ist!
Wichtig: Wenn sich eine Anwender-konfigurierbare Toolbar auf die
Fenster-Menleiste im selben Fenster beziehen soll, mu das Flag
cs_WindowMenuToolbar gesetzt werden.

Findet der Toolbar-Dispatcher im h”herwertigen Byte eine Null vor (das
sollte bis jetzt immer der Fall sein), passiert gar nichts. Ist dort
allerdings ein Wert ungleich Null eingetragen, wird MNSelected mit
eben diesem Wert als Index des gew„hlten Meneintrags aufgerufen.

Wichtig: Dieser Mechanismus funktioniert auch, wenn TToolbar-Objekte
eingesetzt werden, d.h. der Programmierer kann diesen Effekt bewut
ausnutzen. Der Aufruf erfolgt in diesem Fall nach dem Aufruf der
Work-Methode.

Wenn Anwender-konfigurierbare Toolbars eingesetzt werden, mu der
Programmierer dafr sorgen, da die Indizes der Meneintr„ge
dokumentiert werden. Auerdem w„re es nett, wenn dem Anwender dann
z.B. Mini-Icons fr die wichtigsten Funktionen zur Verfgung gestellt
wrden.


1.11  Popup-Mens
=================

In den TPopup-Mens ist folgende Tastatursteuerung vorgesehen:


     +-----------------------+----------------------------------+
     | <Return>,             | W„hlt den markierten Eintrag aus |
     | <Enter>,              |                                  |
     | <Space>               |                                  |
     +-----------------------+----------------------------------+
     | <Esc>,                | Bricht das Popup-Men ab         |
     | <Undo>                |                                  |
     +-----------------------+----------------------------------+
     | <Home>,               | Markierung auf ersten Eintrag    |
     | <Shift>+<Crs. hoch>   |                                  |
     +-----------------------+----------------------------------+
     | <Shift>+<Home>,       | Markierung auf letzten Eintrag   |
     | <Shift>+<Crs. runter> |                                  |
     +-----------------------+----------------------------------+
     | <Cursor hoch>         | Bewegt die Markierung nach oben  |
     +-----------------------+----------------------------------+
     | <Cursor runter>       | Bewegt die Markierung nach unten |
     +-----------------------+----------------------------------+


1.12  Profiles (INF-Dateien)
============================

Mit den ObjectGEM-Profile-Routinen k”nnen die bei vielen Applikationen
vorhandenen INF-Dateien sehr leicht realisiert werden. Sie haben
auerdem den Vorteil, da sie als ASCII-Texte verwaltet werden, so da
sie - wenn n”tig - auch "von Hand" ver„ndert werden k”nnen.

Auerdem werden - wenn die Environmentvariable HOME und das Flag
as_UseHomeDir gesetzt ist - diese Konfigurationsdateien an einem
zentralen Ort (eben dem User-Home-Verzeichnis) gespeichert, so da
auch eine Multi-User-Umgebung realisierbar ist. Wenn HOME nicht
gesetzt ist, werden die Dateien wie gewohnt im Ordner der Applikation
angelegt.

Ein Profile setzt sich aus Bl”cken zusammen. Jeder Block hat eine
"šberschrift" (in eckigen Klammern, bei den Profile-Routinen auch mit
"Anwendungsname" bezeichnet). Nach diese šberschrift folgen die
Schlsselnamen mit den zugeh”rigen Werten, Leerzeilen sind nur zum
Trennen der Bl”cke erlaubt. Kommentare beginnen mit einem Semikolon
oder # am Zeilenanfang, Kommentarbl”cke werden mit ## eingeschlossen.
Ein Eintrag innerhalb eines Profiles mu durch den Anwendungs- und
Schlsselnamen eindeutig bestimmt sein, ansonsten wird nur das erste
Vorkommen beachtet. Ein Profile k”nnte also z.B. so aussehen:


          ; Das ist ein Kommentar innerhalb eines Profiles
          # das auch
          [Block 1]
          Var_1=Test-Text
          Var_2=42

          ## hier beginnt ein Kommentarblock
          und in der n„chsten Zeile h”rt er auf
          ##
          [n„chster Block]
          Var_2=die hat nichts mit o.g. Variable zu tun
          Var_3=2147483647
          Hallo.Welt=Das ist ein Test!


Zum Auswerten eines Profiles stehen Routinen fr ganze Zahlen
(GetPrivateProfileInt, WritePrivateProfileInt) und fr Zeichenketten
(GetPrivateProfileString, WritePrivateProfileString) zur Verfgung.
Sollen Fliekommazahlen bearbeitet werden, mu man diese in
Zeichenketten umwandeln (z.B. mit ftoa, atof).

Profiles, die direkt auf einer Datei arbeiten, sind recht langsam, vor
allem beim Schreiben. Deshalb besteht die M”glichkeit, ein Profile mit
OpenPrivateProfile in den Speicher zu laden, wo die Bearbeitung
deutlich schneller ist. Da immer nur ein Profile im Speicher verwaltet
werden kann, werden Zugriffe auf andere Profiles weiterhin direkt auf
der Platte (bzw. Diskette) durchgefhrt. ClosePrivateProfile braucht
nicht explizit aufgerufen zu werden, dies geschieht automatisch beim
Programmende. Man sollte allerdings nach dem Schreiben von Daten immer
die Routine SavePrivateProfile aufrufen, da man z.B. bei Accessories
nicht davon ausgehen kann, da die Applikation verlassen werden kann.

Die oben erw„hnten Routinen bearbeiten private Profiles, d.h. Applika-
tions-spezifische Konfigurationsdateien. Da es aber auch wnschenswert
sein kann, bestimmte Werte systemglobal festzulegen, ist z.Z. eine
Datei $HOME/user.inf in der Diskussion, die von allen Applikationen
verwendet werden kann. Fr diese Datei stehen spezielle Routinen zur
Verfgung (GetProfileString etc.). Da die Standardisierung aber noch
nicht abgeschlossen ist, kann sich am Namen, Ort, Inhalt etc. der
Datei noch etwas „ndern.


1.13  Resource-Erstellung
=========================

Folgendes sollte bei der Resource-Erstellung fr ObjectGEM beachtet
werden:

   ù Das h”herwertige Byte von ob_type (AESOBJECT) darf unter
     ObjectGEM weder verwendet noch ver„ndert werden! Abgesehen davon,
     da es eine Zeit lang unter MultiTOS Probleme mit solchen
     Programmen gegeben hat, ben”tigt ObjectGEM dieses Byte fr
     interne Zwecke. Durch den objektorientierten Ansatz und die
     TControl-Schnittstellenobjekte sollte die Verwendung dieses Bytes
     allerdings auch nicht n”tig sein.

   ù Alle mit ObjectGEM verwendeten Resourcen sollten wie folgt
     sortiert sein (eine entsprechende Option sollte in jedem RCS zu
     finden sein):

                         "1 2 3
                          4 5 6"

   ù Die korrekte Gr”e fr Dialogelemente, denen sp„ter ein
     TCheckBox-, TRadioButton- oder TTriState-Objekt zugeordnet werden
     soll, kann wie folgt bestimmt werden: Man nimmt im RCS ein
     BUTTON-Element und ver„ndert den Text wie gewnscht. An den Text
     werden allerdings noch drei (bzw. zwei, wenn eine Shortcut-
     Markierung verwendet wird) Leerzeichen angeh„ngt. Nun wird das
     BUTTON-Element vom RCS entsprechend lang gezeichnet. Zum Schlu
     l”scht man die Leerzeichen wieder, ver„ndert die Gr”e des
     BUTTON-Elements allerdings nicht mehr. Im ObjectGEM-Programm
     werden die neuen Buttons nun korrekt gezeichnet.

   ù Bei den Objekten TCheckBox/TTriState wird der selektierte Zustand
     normalerweise als H„kchen dargestellt. Wenn in der Resource
     allerdings das Flag CROSSED gesetzt ist, werden daraus
     "Ankreuzk„stchen".

   ù Toolbar-Elemente werden unter neueren TOS-Versionen automatisch
     mit 3D-Effekten versehen, wenn sie vom Typ G_BOX, G_BOXTEXT,
     G_BUTTON, G_BOXCHAR oder G_FBOXTEXT sind. Elemente vom Typ
     G_BOXTEXT oder G_FBOXTEXT sollten mit dem kleinen Zeichensatz
     sowie den Stati SHADOWED und OUTLINED versehen werden; dadurch
     haben sie einen Pseudo-3D-Effekt, der ab AES 3.40 automatisch
     durch den "echten" Effekt ausgetauscht wird.

     Wenn ein Toolbar-Button nicht mit einem TToolbar-Objekt verknpft
     wird (s. "Toolbars"), mu in ob_state SELECTABLE gesetzt sein.

   ù Wenn bei InitResource/LoadResource zwei RSC-Dateien fr die
     unterschiedlichen Aufl”sungen verwendet werden, mu man daran
     denken, da die Indizes der Objekte in beiden Dateien gleich sein
     mssen, da nur eine Include-Datei verwendet werden kann.

   ù ObjectGEM kommt auch mit RSC-Dateien zurecht, in denen das
     pe_tvalid-Feld verkrzt ist. Die n”tigen Zeichen der Maske werden
     erg„nzt.

   ù In pe_tvalid stehen folgende Zeichen zus„tzlich zur Verfgung:

        - 'H' fr Hexadezimalzahlen: '0'..'9', 'a'..'f', 'A'..'F'

        - 'D' fr Dezimalzahlen: '0'..'9', '+', '-', ',', '.'

        - '+' fr Vorzeichen: '+', '-'


1.14  XAcc- und AV-Protokoll
============================

ObjectGEM verwendet das XAcc-Protokoll nach der Definition vom
28.11.1992, d.h. auch unter MultiTOS ist die korrekte Proto-
kollbehandlung gesichert.

Als Programmierer braucht man sich nicht um die Einzelheiten des Pro-
tokolls kmmern, sondern man kann direkt das Ergebnis in der XAccList
(z.B. per TApplication.FindApplication) auswerten. Die einzig
interessante "Verwaltungs"-Routine drfte TApplication.XAccInsert
sein.

Die XAcc-Eigenschaften des ObjectGEM-Programms werden in der Methode
TApplication.GetXAccAttr festgelegt. Wenn man also besondere
Eigenschaften kennzeichnen m”chte, mu man diese Methode
berschreiben. Man kann dort auch die "Extended names" festlegen, die
dann von ObjectGEM automatisch korrekt verschickt werden.

Wichtige Methoden fr das XAcc-Protokoll sind diejenigen, mit denen
ein Datenaustausch durchgefhrt werden kann. Dies sind die
TApplication-Methoden XAccText, XAccKey, XAccMeta und XAccIMG. Diese
Methoden dienen zum Empfangen von Daten; ein Verschicken wird z.Z. von
ObjectGEM noch nicht direkt untersttzt.

ObjectGEM wertet auerdem das AV-Protokoll aus. Dies geschieht
ebenfalls automatisch, und es werden die gleichen Datenstrukturen
verwendet. Wie beim XAcc-Protokoll drfte auch nur die Methode
TApplication.AVInsert interessant sein, alle spezifischen AV-Messages
werden weiterhin an TApplication.HandleAV weitergeleitet. Ist ein AV-
Server vorhanden, befindet sich seine AES-ID im Feld
TApplication.AVServer.


1.15  Updates
=============

Updates von ObjectGEM gibt es ausschlielich in den verschiedenen
Netzen:

 per Modem

        ù Maus KA, (0721) 358887, kein Gastdownload von 18 bis 21 Uhr

        ù Maus FR, (0761) 507394, kein Gastdownload von 18 bis 21 Uhr

        ù ASH-Mailbox, (06221) 303671

 per ftp

        ù ftp://ftp.uni-muenster.de/pub/atari/Programming/

        ù ftp://ftp.uni-kl.de/pub/atari/programming/

 im WorldWideWeb

        ù http://wwwrzstud.rz.uni-karlsruhe.de/~uk48/OGEM/index.html

        ù http://www.uni-karlsruhe.de/~Thomas.Much/OGEM

        ù http://www.uni-karlsruhe.de/~Thomas.Much/nbp.html

Falls ObjectGEM auch in anderen Mailboxen etc. st„ndig zum Download
bereitsteht, w„re ich fr eine kurze PM dankbar (Adresse siehe
"Kontakt").

Natrlich sollten Sie auch bei allen bekannten PD-Versendern die
aktuelle ObjectGEM-Version erhalten k”nnen.



2  Felder und Methoden
**********************


2.1  ADialog
============

   ù TIcon.ADialog

   ù TKeyMenu.ADialog

   ù TToolbar.ADialog


2.2  apID
=========

   ù TApplication.apID

   ù TXAccAttr.apID

   ù XAcc.apID


2.3  At
=======

   ù TApplication.At

   ù TCollection.At

   ù TWindow.At


2.4  Attr
=========

   ù TApplication.Attr

   ù TWindow.Attr


2.5  CanClose
=============

   ù TApplication.CanClose

   ù TEdit.CanClose

   ù TWindow.CanClose


2.6  Changed
============

   ù TComboBox.Changed

   ù TControl.Changed

   ù TScrollBar.Changed


2.7  Check
==========

   ù TCheckBox.Check

   ù TIcon.Check

   ù TKeyMenu.Check

   ù TPopup.Check

   ù TToolbar.Check


2.8  Clear
==========

   ù TEdit.Clear

   ù TStatic.Clear

   ù TTextWindow.Clear


2.9  Clipboard
==============

   ù TApplication.Clipboard

   ù TEdit.Clipboard

   ù TWindow.Clipboard


2.10  CloseWindow
=================

   ù TDialog.CloseWindow

   ù TWindow.CloseWindow


2.11  Compare
=============

   ù TSortedCollection.Compare

   ù TStrCollection.Compare

   ù TStringCollection.Compare


2.12  Copy
==========

   ù TApplication.Copy

   ù TDialog.Copy

   ù TEdit.Copy

   ù TTextWindow.Copy

   ù TWindow.Copy


2.13  Create
============

   ù TDialog.Create

   ù TWindow.Create


2.14  Cut
=========

   ù TApplication.Cut

   ù TDialog.Cut

   ù TEdit.Cut

   ù TTextWindow.Cut

   ù TWindow.Cut


2.15  DDFinished
================

   ù TApplication.DDFinished

   ù TWindow.DDFinished


2.16  DDGetPath
===============

   ù TApplication.DDGetPath

   ù TWindow.DDGetPath


2.17  DDGetPreferredTypes
=========================

   ù TApplication.DDGetPreferredTypes

   ù TWindow.DDGetPreferredTypes


2.18  DDHeaderReply
===================

   ù TApplication.DDHeaderReply

   ù TWindow.DDHeaderReply


2.19  DDReadArgs
================

   ù TApplication.DDReadArgs

   ù TWindow.DDReadArgs


2.20  DDReadData
================

   ù TApplication.DDReadData

   ù TWindow.DDReadData


2.21  Deinstall
===============

   ù TButton.Deinstall

   ù TCheckBox.Deinstall


2.22  Delete
============

   ù TApplication.Delete

   ù TCollection.Delete

   ù TDialog.Delete

   ù TWindow.Delete


2.23  Destroy
=============

   ù TDialog.Destroy

   ù TWindow.Destroy


2.24  Disable
=============

   ù TControl.Disable

   ù TKeyMenu.Disable

   ù TPopup.Disable

   ù TToolbar.Disable


2.25  Done
==========

   ù TApplication.Done

   ù TButton.Done

   ù TCollection.Done

   ù TComboBox.Done

   ù TControl.Done

   ù TDialog.Done

   ù TEdit.Done

   ù TEvent.Done

   ù TEventObject.Done

   ù TGroupBox.Done

   ù TIcon.Done

   ù TKeyMenu.Done

   ù TObject.Done

   ù TPopup.Done

   ù TPXPictureValidator.Done

   ù TScroller.Done

   ù TStatic.Done

   ù TStringLookupValidator.Done

   ù TTextWindow.Done

   ù TToolbar.Done

   ù TWindow.Done


2.26  Edit
==========

   ù TComboBox.Edit

   ù TEdit.Edit


2.27  Enable
============

   ù TControl.Enable

   ù TKeyMenu.Enable

   ù TPopup.Enable

   ù TToolbar.Enable


2.28  Error
===========

   ù TApplication.Error

   ù TCollection.Error

   ù TFilterValidator.Error

   ù TPXPictureValidator.Error

   ù TRangeValidator.Error

   ù TStringLookupValidator.Error

   ù TValidator.Error


2.29  Esc
=========

   ù TDialog.Esc


2.30  Execute
=============

   ù TDialog.Execute

   ù TPopup.Execute


2.31  FirstIcon
===============

   ù TApplication.FirstIcon

   ù TWindow.FirstIcon


2.32  FirstThat
===============

   ù TCollection.FirstThat

   ù TDialog.FirstThat


2.33  FirstWndThat
==================

   ù TApplication.FirstWndThat

   ù TWindow.FirstWndThat


2.34  ForEach
=============

   ù TCollection.ForEach

   ù TDialog.ForEach


2.35  ForEachWnd
================

   ù TApplication.ForEachWnd

   ù TWindow.ForEachWnd


2.36  Free
==========

   ù TCollection.Free

   ù TObject.Free


2.37  FreeDialog
================

   ù TDialog.FreeDialog

   ù TWindow.FreeDialog


2.38  FreeIcon
==============

   ù TApplication.FreeIcon

   ù TWindow.FreeIcon


2.39  FreeItem
==============

   ù TCollection.FreeItem

   ù TStrCollection.FreeItem

   ù TStringCollection.FreeItem


2.40  FreeMenu
==============

   ù TApplication.FreeMenu

   ù TWindow.FreeMenu


2.41  GetCheck
==============

   ù TCheckBox.GetCheck

   ù TIcon.GetCheck

   ù TKeyMenu.GetCheck

   ù TPopup.GetCheck

   ù TToolbar.GetCheck


2.42  GetClassName
==================

   ù TDialog.GetClassName

   ù TTextWindow.GetClassName

   ù TWindow.GetClassName


2.43  GetClipboard
==================

   ù TApplication.GetClipboard

   ù TEdit.GetClipboard

   ù TWindow.GetClipboard


2.44  GetHelp
=============

   ù TControl.GetHelp

   ù TIcon.GetHelp

   ù TToolbar.GetHelp


2.45  GetIconTitle
==================

   ù TApplication.GetIconTitle

   ù TWindow.GetIconTitle


2.46  GetScroller
=================

   ù TTextWindow.GetScroller

   ù TWindow.GetScroller


2.47  GetSelection
==================

   ù TComboBox.GetSelection

   ù TPopup.GetSelection


2.48  GetState
==============

   ù TControl.GetState

   ù TKeyMenu.GetState

   ù TPopup.GetState

   ù TToolbar.GetState


2.49  GetStyle
==============

   ù TDialog.GetStyle

   ù TTextWindow.GetStyle

   ù TWindow.GetStyle


2.50  GetText
=============

   ù TButton.GetText

   ù TComboBox.GetText

   ù TGroupBox.GetText

   ù TIcon.GetText

   ù TKeyMenu.GetText

   ù TPopup.GetText

   ù TStatic.GetText


2.51  GetVDIHandle
==================

   ù TDialog.GetVDIHandle

   ù TWindow.GetVDIHandle


2.52  GetWindowClass
====================

   ù TDialog.GetWindowClass

   ù TTextWindow.GetWindowClass

   ù TWindow.GetWindowClass


2.53  GetWorkMax
================

   ù TDialog.GetWorkMax

   ù TWindow.GetWorkMax


2.54  HandleMenu
================

   ù TApplication.HandleMenu

   ù TWindow.HandleMenu


2.55  hbrBackground
===================

   ù TIconWndClass.hbrBackground

   ù TWndClass.hbrBackground


2.56  hCursor
=============

   ù TIconWndClass.hCursor

   ù TWndClass.hCursor


2.57  Hi
========

   ù APPLRECORD.What.Hi

   ù LongRec.Hi

   ù WordRec.Hi


2.58  Hide
==========

   ù TControl.Hide

   ù TIcon.Hide


2.59  Icon
==========

   ù TApplication.Icon

   ù TWindow.Icon


2.60  IconPaint
===============

   ù TApplication.IconPaint

   ù TWindow.IconPaint


2.61  IconSelect
================

   ù TApplication.IconSelect

   ù TWindow.IconSelect


2.62  ID
========

   ù INFOXSSI.id

   ù TControl.ID

   ù TCookie.ID


2.63  IndexOf
=============

   ù TApplication.IndexOf

   ù TCollection.IndexOf

   ù TSortedCollection.IndexOf

   ù TWindow.IndexOf


2.64  Init
==========

   ù TApplication.Init

   ù TButton.Init

   ù TCheckBox.Init

   ù TClipboard.Init

   ù TCollection.Init

   ù TComboBox.Init

   ù TControl.Init

   ù TDialog.Init

   ù TEdit.Init

   ù TEvent.Init

   ù TEventObject.Init

   ù TFilterValidator.Init

   ù TGroupBox.Init

   ù TIcon.Init

   ù TKey.Init

   ù TKeyMenu.Init

   ù TMenu.Init

   ù TObject.Init

   ù TPopup.Init

   ù TPXPictureValidator.Init

   ù TRadioButton.Init

   ù TRangeValidator.Init

   ù TScrollBar.Init

   ù TScroller.Init

   ù TSortedCollection.Init

   ù TStatic.Init

   ù TStringCollection.Init

   ù TStringLookupValidator.Init

   ù TTextWindow.Init

   ù TToolbar.Init

   ù TTriState.Init

   ù TValidator.Init

   ù TWindow.Init


2.65  Insert
============

   ù TCollection.Insert

   ù TSortedCollection.Insert


2.66  Install
=============

   ù TButton.Install

   ù TCheckBox.Install

   ù TRadioButton.Install


2.67  IsDialog
==============

   ù TDialog.IsDialog

   ù TWindow.IsDialog


2.68  IsHelpAvailable
=====================

   ù TControl.IsHelpAvailable

   ù TIcon.IsHelpAvailable

   ù TToolbar.IsHelpAvailable


2.69  IsHidden
==============

   ù TControl.IsHidden

   ù TIcon.IsHidden


2.70  IsIconified
=================

   ù TApplication.IsIconified

   ù TWindow.IsIconified


2.71  IsValid
=============

   ù TEdit.IsValid

   ù TFilterValidator.IsValid

   ù TLookupValidator.IsValid

   ù TPXPictureValidator.IsValid

   ù TRangeValidator.IsValid

   ù TValidator.IsValid


2.72  IsValidInput
==================

   ù TFilterValidator.IsValidInput

   ù TPXPictureValidator.IsValidInput

   ù TRangeValidator.IsValidInput

   ù TValidator.IsValidInput


2.73  Lo
========

   ù APPLRECORD.What.Lo

   ù LongRec.Lo

   ù WordRec.Lo


2.74  LoadDialog
================

   ù TDialog.LoadDialog

   ù TWindow.LoadDialog


2.75  LoadIcon
==============

   ù TApplication.LoadIcon

   ù TWindow.LoadIcon


2.76  LoadMenu
==============

   ù TApplication.LoadMenu

   ù TWindow.LoadMenu


2.77  Lookup
============

   ù TLookupValidator.Lookup

   ù TStringLookupValidator.Lookup


2.78  MakeWindow
================

   ù TDialog.MakeWindow

   ù TWindow.MakeWindow


2.79  Max (Feld)
================

   ù TRangeValidator.Max


2.80  menuID
============

   ù TApplication.menuID

   ù TXAccAttr.menuID

   ù XAcc.menuID


2.81  MenuTree
==============

   ù TApplication.MenuTree

   ù TWndClass.MenuTree


2.82  Min (Feld)
================

   ù TRangeValidator.Min


2.83  MNSelected
================

   ù TApplication.MNSelected

   ù TWindow.MNSelected


2.84  Name
==========

   ù TApplication.Name

   ù TXAccAttr.Name

   ù XAcc.Name


2.85  Next
==========

   ù TControl.Next

   ù TEvent.Next

   ù TWindow.Next


2.86  NextIcon
==============

   ù TApplication.NextIcon

   ù TWindow.NextIcon


2.87  ObjAddr
=============

   ù TControl.ObjAddr

   ù TToolbar.ObjAddr


2.88  ObjIndx
=============

   ù TControl.ObjIndx

   ù TToolbar.ObjIndx


2.89  OpenWindow
================

   ù TDialog.OpenWindow

   ù TWindow.OpenWindow


2.90  Paint
===========

   ù TComboBox.Paint

   ù TControl.Paint

   ù TDialog.Paint

   ù TEdit.Paint

   ù TIcon.Paint

   ù TTextWindow.Paint

   ù TToolbar.Paint

   ù TWindow.Paint


2.91  Parent
============

   ù TClipboard.Parent

   ù TControl.Parent

   ù TEvent.Parent

   ù TWindow.Parent


2.92  Paste
===========

   ù TApplication.Paste

   ù TDialog.Paste

   ù TEdit.Paste

   ù TTextWindow.Paste

   ù TWindow.Paste


2.93  Popup
===========

   ù TApplication.Popup

   ù TComboBox.Popup


2.94  Previous
==============

   ù TControl.Previous

   ù TEvent.Previous

   ù TWindow.Previous


2.95  Print
===========

   ù TTextWindow.Print

   ù TWindow.Print


2.96  SelectAll
===============

   ù TApplication.SelectAll

   ù TTextWindow.SelectAll

   ù TWindow.SelectAll


2.97  SetCheck
==============

   ù TCheckBox.SetCheck

   ù TIcon.SetCheck

   ù TKeyMenu.SetCheck

   ù TPopup.SetCheck

   ù TToolbar.SetCheck


2.98  SetColor
==============

   ù TControl.SetColor

   ù TEdit.SetColor

   ù TTextWindow.SetColor


2.99  SetCursor
===============

   ù TEdit.SetCursor

   ù TWindow.SetCursor


2.100  SetHelp
==============

   ù TControl.SetHelp

   ù TIcon.SetHelp

   ù TToolbar.SetHelp


2.101  SetRange
===============

   ù TScrollBar.SetRange

   ù TScroller.SetRange


2.102  SetSelection
===================

   ù TComboBox.SetSelection

   ù TPopup.SetSelection


2.103  SetState
===============

   ù TControl.SetState

   ù TEdit.SetState

   ù TKeyMenu.SetState

   ù TPopup.SetState

   ù TRadioButton.SetState

   ù TToolbar.SetState


2.104  SetText
==============

   ù TButton.SetText

   ù TComboBox.SetText

   ù TEdit.SetText

   ù TGroupBox.SetText

   ù TIcon.SetText

   ù TKeyMenu.SetText

   ù TPopup.SetText

   ù TStatic.SetText


2.105  SetupSize
================

   ù TDialog.SetupSize

   ù TWindow.SetupSize


2.106  SetupVDI
===============

   ù TApplication.SetupVDI

   ù TTextWindow.SetupVDI

   ù TWindow.SetupVDI


2.107  SetupWindow
==================

   ù TDialog.SetupWindow

   ù TWindow.SetupWindow


2.108  Size
===========

   ù TScrollBar.Size

   ù TWindow.Size


2.109  Status
=============

   ù TApplication.Status

   ù TValidator.Status

   ù TWindowAttr.Status


2.110  Style
============

   ù TControl.Style

   ù TEvent.Style

   ù TGEMAttr.Style

   ù TScroller.Style

   ù TWindowAttr.Style

   ù TWndClass.Style


2.111  TestButton
=================

   ù TEvent.TestButton

   ù TIcon.TestButton


2.112  TestIndex
================

   ù TComboBox.TestIndex

   ù TControl.TestIndex

   ù TScrollBar.TestIndex


2.113  TestKey
==============

   ù TEvent.TestKey

   ù TIcon.TestKey

   ù TKeyMenu.TestKey

   ù TMenu.TestKey

   ù TToolbar.TestKey


2.114  TestMenu
===============

   ù TEvent.TestMenu

   ù TKey.TestMenu

   ù TKeyMenu.TestMenu


2.115  TextMessage
==================

   ù TEvent.TestMessage

   ù TToolbar.TestMessage


2.116  Toggle
=============

   ù TCheckBox.Toggle

   ù TIcon.Toggle

   ù TKeyMenu.Toggle

   ù TPopup.Toggle

   ù TToolbar.Toggle


2.117  Transfer
===============

   ù TCheckBox.Transfer

   ù TComboBox.Transfer

   ù TControl.Transfer

   ù TScrollBar.Transfer

   ù TStatic.Transfer


2.118  Uncheck
==============

   ù TCheckBox.Uncheck

   ù TIcon.Uncheck

   ù TKeyMenu.Uncheck

   ù TPopup.Uncheck

   ù TToolbar.Uncheck


2.119  Undo
===========

   ù TDialog.Undo

   ù TEdit.Undo


2.120  Unhide
=============

   ù TControl.Unhide

   ù TIcon.Unhide


2.121  UpdateDialog
===================

   ù TDialog.UpdateDialog

   ù TWindow.UpdateDialog


2.122  vdiHandle
================

   ù TApplication.vdiHandle

   ù TWindow.vdiHandle


2.123  Version
==============

   ù INFOXSSI.version

   ù TMetaInfo.Version

   ù TXAccAttr.Version

   ù XAcc.Version


2.124  VGHnd
============

   ù TKeyMenu.VGHnd

   ù TToolbar.VGHnd


2.125  VKey
===========

   ù TIcon.VKey

   ù TKeyMenu.VKey

   ù TToolbar.VKey


2.126  VPipe
============

   ù TKeyMenu.VPipe

   ù TToolbar.VPipe


2.127  VStat
============

   ù TIcon.VStat

   ù TKeyMenu.VStat

   ù TToolbar.VStat


2.128  Window
=============

   ù TScroller.Window

   ù TValidator.Window


2.129  WMButton
===============

   ù TDialog.WMButton

   ù TWindow.WMButton


2.130  WMClosed
===============

   ù TDialog.WMClosed

   ù TWindow.WMClosed


2.131  Work
===========

   ù TComboBox.Work

   ù TEvent.Work

   ù TScrollBar.Work

   ù TWindow.Work


2.132  workIn
=============

   ù TApplication.workIn

   ù TWindow.workIn


2.133  workOut
==============

   ù TApplication.workOut

   ù TWindow.workOut


2.134  XPos
===========

   ù TIcon.XPos

   ù TScroller.XPos


2.135  YPos
===========

   ù TIcon.YPos

   ù TScroller.YPos



3  Konstanten
*************


3.1  as_XXXX-Konstanten
=======================

Die folgenden Konstanten des Feldes TApplication.Attr.Style bestimmen
globale Eigenschaften jedes ObjectGEM-Programms.


+--------------------+------+------------------------------------------+
| Konstante          | Wert | Bedeutung                                |
+--------------------+------+------------------------------------------+
| as_LoadFonts       |    1 | fr TApplication.vdiHandle werden die    |
|                    |      | (Speedo)GDOS-Fonts mit vst_load_fonts()  |
|                    |      | nachgeladen (falls GDOS aktiv und Fonts  |
|                    |      | vorhanden)                               |
+--------------------+------+------------------------------------------+
| as_GrowShrink      |    2 | Fenster und Dialogboxen werden incl.     |
|                    |      | Grow- und Shrinkboxen mit form_dial()    |
|                    |      | gezeichnet (default)                     |
+--------------------+------+------------------------------------------+
| as_MenuSeparator   |    4 | die Trennstriche in Drop-Down- und       |
|                    |      | Pop-Up-Mens werden als durchg„ngige     |
|                    |      | Linien gezeichnet (default)              |
+--------------------+------+------------------------------------------+
| as_MoveDials       |    8 | modale Dialoge k”nnen durch Anklicken    |
|                    |      | verschoben werden (default)              |
+--------------------+------+------------------------------------------+
| as_MoveTransparent |   24 | modale Dialoge werden transparent        |
|                    |      | verschoben                               |
+--------------------+------+------------------------------------------+
| as_Rubbox          |   32 | auf dem Desktop kann durch Anklicken     |
|                    |      | und Ziehen ein "Gummiband" aufgezogen    |
|                    |      | werden; wurde das Aufziehen nicht mit    |
|                    |      | der rechten Maustaste abgebrochen, wird  |
|                    |      | danach TApplication.MURubbox aufgerufen  |
+--------------------+------+------------------------------------------+
| as_HandleShutdown  |   64 | gibt an, ob die Applikation korrekt auf  |
|                    |      | einen Shutdown von AES 4.0 reagieren     |
|                    |      | kann (default)                           |
+--------------------+------+------------------------------------------+
| as_3DFlags         |  128 | bewirkt, da unter neueren TOS-Versionen |
|                    |      | (Falcon, MultiTOS) bei Dialogen 3D-      |
|                    |      | Effekte verwendet werden (default)       |
+--------------------+------+------------------------------------------+
| as_XInputMode      |  256 | Tastatureingaben werden nicht an das     |
|                    |      | oberste Fenster weitergeleitet, sondern  |
|                    |      | an das Fenster, ber dem sich der Maus-  |
|                    |      | zeiger befindet (wie unter X/Unix)       |
+--------------------+------+------------------------------------------+
| as_DesktopWindow   |  512 | der Desktop wird in ein Fenster gelegt   |
|                    |      | (bei Accessories default); z.Z. noch     |
|                    |      | ohne Wirkung                             |
+--------------------+------+------------------------------------------+
| as_UseHomeDir      | 1024 | bewirkt, da Profiles ohne Pfadangabe    |
|                    |      | im Verzeichnis $HOME/defaults angelegt   |
|                    |      | werden, wenn die Environment-Variable    |
|                    |      | HOME gesetzt ist und darin der Ordner    |
|                    |      | defaults existiert                       |
+--------------------+------+------------------------------------------+


3.2  bf_XXXX-Konstanten
=======================

Der Status von TControl, TButton, TCheckBox, TTriState, TRadioButton,
TPopup und TKeyMenu wird mit den folgenden Konstanten beschrieben:


+--------------+------+-----------------------------------------------+
| Konstante    | Wert | Bedeutung                                     |
+--------------+------+-----------------------------------------------+
| bf_Unchecked |    1 | Schaltfl„che ist nicht markiert               |
|              |      | (nicht bei TButton und TControl)              |
+--------------+------+-----------------------------------------------+
| bf_Checked   |    2 | Schaltfl„che ist markiert                     |
|              |      | (nicht bei TButton und TControl)              |
+--------------+------+-----------------------------------------------+
| bf_Grayed    |    3 | Schaltfl„che ist grau; wird z.B. fr "Wert    |
|              |      | beibehalten" verwendet (nur TTriState)        |
+--------------+------+-----------------------------------------------+
| bf_Enabled   |    4 | Button ist anw„hlbar                          |
+--------------+------+-----------------------------------------------+
| bf_Disabled  |    5 | Button ist nicht anw„hlbar (hell dargestellt) |
+--------------+------+-----------------------------------------------+


3.3  bs/es/sbs/scs/sts_XXXX-Konstanten
======================================

Diese Werte werden von Dialogelementobjekten in TControl.Style
eingetragen, um einen erweiterten Status anzuzeigen.


+------------------+------+-------------------------------------------+
| Konstante        | Wert | Bedeutung                                 |
+------------------+------+-------------------------------------------+
| bs_DefPushButton | 2048 | TButton tr„gt diesen Wert in das Feld     |
|                  |      | Style ein, wenn es sich bei dem zuge-     |
|                  |      | h”rigen Dialogelement um den Default-     |
|                  |      | PushButton handelt                        |
+------------------+------+-------------------------------------------+
| es_ASCIIOnly     | 2048 | kann gesetzt werden, um bei TEdit nur     |
|                  |      | ASCII-Zeichen (keine Umlaute!) zuzulassen |
+------------------+------+-------------------------------------------+
| es_Undo          | 4096 | gibt an, da TEdit den Undo-Puffer ver-   |
|                  |      | wendet (default); s. TEdit.CanUndo        |
+------------------+------+-------------------------------------------+
| sbs_Horz         | 2048 | wird von TScrollBar eingetragen, wenn es  |
|                  |      | sich um eine horizontale Bildlaufleiste   |
|                  |      | handelt                                   |
+------------------+------+-------------------------------------------+
| sbs_Vert         | 4096 | wird von TScrollBar eingetragen, wenn es  |
|                  |      | sich um eine vertikale Bildlaufleiste     |
|                  |      | handelt                                   |
+------------------+------+-------------------------------------------+
| sts_Fill         | 2048 | wird von TStatic gesetzt; das Textfeld    |
|                  |      | wird dann mit Leerzeichen aufgefllt,     |
|                  |      | bis es eine L„nge von TextLen-1 Zeichen   |
|                  |      | hat, damit beim Neuzeichnen keine         |
|                  |      | Probleme entstehen                        |
+------------------+------+-------------------------------------------+

Eine ganz andere Bedeutung haben die es_XXXX-Konstanten, die im Feld
TEvent.Style eingetragen sein k”nnen. Sie dienen zur Unterscheidung
folgender Objekttypen:


                    +------------+---+----------+
                    | es_KeyMenu | 1 | TKeyMenu |
                    | es_Icon    | 2 | TIcon    |
                    | es_Popup   | 4 | TPopup   |
                    | es_Toolbar | 8 | TToolbar |
                    +------------+---+----------+

Auch TScroller kann mit dem Feld TScroller.Style konfiguriert werden:


+---------------------+---+-----------------------------------------+
| scs_BitbltScrolling | 1 | wird von TTextWindow gesetzt, damit ein |
|                     |   | optimiertes Redraw durchgefhrt wird    |
|                     |   | (funktioniert nur, wenn TrackMode true  |
|                     |   | ist)                                    |
|                     |   | Wichtig: Beim Bitblt-Scrolling werden   |
|                     |   | evtl. vorhandene Icons nicht gezeich-   |
|                     |   | net, deshalb ist diese Konstante nicht  |
|                     |   | standardm„ig gesetzt.                  |
+---------------------+---+-----------------------------------------+


3.4  coXXXX-Konstanten
======================

Die coXXXX-Konstanten werden von TCollection im Fehlerfall als
Parameter Code an die Methode TCollection.Error bergeben.


 +--------------+------+--------------------------------------------+
 | Konstante    | Wert | Bedeutung                                  |
 +--------------+------+--------------------------------------------+
 | coIndexError |   -1 | Bereichsberschreitung des Indizes.        |
 |              |      | Der an die Methode Error bergebene Wert   |
 |              |      | Info entspricht dem ungltigen Index       |
 +--------------+------+--------------------------------------------+
 | coOverflow   |   -2 | šberlauf der Kollektion.                   |
 |              |      | TCollection.SetLimit konnte die Kollektion |
 |              |      | nicht auf die gewnschte Gr”e ausdehnen.  |
 |              |      | Der an die Methode Error bergebene Wert   |
 |              |      | Info gibt die angeforderte Gr”e an        |
 +--------------+------+--------------------------------------------+


3.5  cs_XXXX-Konstanten
=======================

Die cs_XXXX-Konstanten teilen sich in zwei g„nzlich verschiedene
Gruppen auf, die Fensterklassen- und Control-Stile:


+----------------------+-------+----------------------------------------+
| Konstante            |  Wert | Bedeutung                              |
+----------------------+-------+----------------------------------------+
| cs_ByteAlignClient   |     1 | der linke Rand des Fenster-Arbeits-    |
|                      |       | bereichs wird horizontal auf Byte-     |
|                      |       | grenze gebracht                        |
+----------------------+-------+----------------------------------------+
| cs_ByteAlignWindow   |     2 | der linke „uere Fensterrand wird      |
|                      |       | horizontal auf Bytegrenze gebracht     |
+----------------------+-------+----------------------------------------+
| cs_VerAlignClient    |     4 | der obere Rand des Arbeitsbereichs     |
|                      |       | wird auf eine gerade Zeile gebracht    |
+----------------------+-------+----------------------------------------+
| cs_VerAlignWindow    |     8 | der obere „uere Fensterrand wird      |
|                      |       | auf eine gerade Zeile gebracht         |
+----------------------+-------+----------------------------------------+
| cs_FullRedraw        |    16 | wenn die Fenstergr”e ge„ndert wurde   |
|                      |       | und deshalb ein Teil des Fensters neu  |
|                      |       | gezeichnet werden mu, wird automa-    |
|                      |       | tisch ein Redraw ber das komplette    |
|                      |       | Fenster ausgel”st                      |
+----------------------+-------+----------------------------------------+
| cs_HRedraw           |    16 | " (ObjectWindows-Konstante)            |
+----------------------+-------+----------------------------------------+
| cs_VRedraw           |    16 | " (ObjectWindows-Konstante)            |
+----------------------+-------+----------------------------------------+
| cs_SaveBits          |    32 | bei modalen Dialogen wird versucht,    |
|                      |       | den Hintergrund zu retten; dadurch     |
|                      |       | mu dann beim Verlassen des Dialogs    |
|                      |       | kein aufwendiges Redraw durchge-       |
|                      |       | fhrt werden (nur TDialog, default)    |
+----------------------+-------+----------------------------------------+
| cs_Rubbox            |    64 | in dem Fenster kann innerhalb          |
|                      |       | eines angegebenen Bereichs ein         |
|                      |       | "Gummiband" aufgezogen werden;         |
|                      |       | danach wird TWindow.WMRubbox           |
|                      |       | aufgerufen                             |
+----------------------+-------+----------------------------------------+
| cs_WorkBackground    |   128 | Fenster und Dialoge k”nnen auch im     |
|                      |       | Hintergrund bedient werden; statt      |
|                      |       | das Fenster in den Vordergrund zu      |
|                      |       | bringen, wird dann die Methode         |
|                      |       | TWindow.WMButton aufgerufen (bei       |
|                      |       | TDialog default!);                     |
|                      |       | Wichtig: In AES-Versionen unter 4.0    |
|                      |       | werden Doppelklicks links in Hinter-   |
|                      |       | grund-Fenster nicht erkannt, auerdem  |
|                      |       | wird dort ein Klick erst nach Los-     |
|                      |       | lassen der Taste weitergeleitet        |
+----------------------+-------+----------------------------------------+
| cs_DblClks           |   256 | das Fenster kann Doppelklicks ver-     |
|                      |       | arbeiten; in diesem Fall wird dann     |
|                      |       | die Methode TWindow.WMDblClick         |
|                      |       | aufgerufen (default)                   |
+----------------------+-------+----------------------------------------+
| cs_CreateOnAccOpen   |   512 | Fenster/Dialoge, zu denen Schnitt-     |
|                      |       | stellenobjekte existieren, werden bei  |
|                      |       | AC_OPEN automatisch mit Create er-     |
|                      |       | zeugt und ge”ffnet; ansonsten werden   |
|                      |       | nur Fenster bzw. Dialoge ge”ffnet,     |
|                      |       | die schon erzeugt wurden               |
|                      |       | (bei TWindow default)                  |
+----------------------+-------+----------------------------------------+
| cs_CancelOnClose     |  1024 | beim Schlieen des Fenster-Dialogs mit |
|                      |       | dem Schliefeld wird nicht die OK-     |
|                      |       | sondern die Cancel-Methode aufgerufen  |
+----------------------+-------+----------------------------------------+
| cs_AutoCreate        |  2048 | ein Child-Fenster, bei dem dieses      |
|                      |       | Flag gesetzt ist, wird zusammen mit    |
|                      |       | dem Parent-Fenster erzeugt             |
|                      |       | (bei TWindow default)                  |
+----------------------+-------+----------------------------------------+
| cs_AutoOpen          |  4096 | bewirkt, da MakeWindow automatisch    |
|                      |       | aufgerufen wird - bei TWindow von      |
|                      |       | TWindow.SetupWindow, bei TDialog von   |
|                      |       | TDialog.Init (bei TWindow default)     |
+----------------------+-------+----------------------------------------+
| cs_ToolbarOpposite   |  8192 | wird von TWindow.LoadToolbar gesetzt,  |
|                      |       | wenn die Toolbar nicht links oder      |
|                      |       | oben, sondern rechts oder unten        |
|                      |       | gezeichnet werden soll                 |
+----------------------+-------+----------------------------------------+
| cs_QuitOnClose       | 16384 | ist dieses Flag gesetzt, ruft          |
|                      |       | WMClosed TApplication.Quit auf         |
|                      |       | (bei TWindow default)                  |
+----------------------+-------+----------------------------------------+
| cs_WindowMenuToolbar | 32768 | wenn dieses Flag gesetzt ist, be-      |
|                      |       | ziehen sich Anwender-konfigurierbare   |
|                      |       | Toolbars auf die Menleiste im         |
|                      |       | selben Fenster                         |
+----------------------+-------+----------------------------------------+

                   Tabelle 11: TWindow.Class.Style


Die Konstanten cs_ByteAlignClient und cs_ByteAlignWindow bzw.
cs_VerAlignClient und cs_VerAlignWindow drfen nicht zusammen benutzt
werden. cs_ToolbarOpposite darf nur gelesen werden!


    +--------------------+------+-------------------------------+
    | Konstante          | Wert | Bedeutung                     |
    +--------------------+------+-------------------------------+
    | cs_CheckBox        |    1 | wird von TCheckBox gesetzt    |
    +--------------------+------+-------------------------------+
    | cs_AutoCheckBox    |    1 | " (ObjectWindows-Konstante)   |
    +--------------------+------+-------------------------------+
    | cs_3State          |    3 | wird von TTriState gesetzt    |
    +--------------------+------+-------------------------------+
    | cs_Auto3State      |    3 | " (ObjectWindows-Konstante)   |
    +--------------------+------+-------------------------------+
    | cs_RadioButton     |    4 | wird von TRadioButton gesetzt |
    +--------------------+------+-------------------------------+
    | cs_AutoRadioButton |    4 | " (ObjectWindows-Konstante)   |
    +--------------------+------+-------------------------------+
    | cs_PushButton      |    8 | wird von TButton gesetzt      |
    +--------------------+------+-------------------------------+
    | cs_GroupBox        |   16 | wird von TGroupBox gesetzt    |
    +--------------------+------+-------------------------------+
    | cs_Static          |   32 | wird von TStatic gesetzt      |
    +--------------------+------+-------------------------------+
    | cs_Edit            |   64 | wird von TEdit gesetzt        |
    +--------------------+------+-------------------------------+
    | cs_ScrollBar       |  128 | wird von TScrollBar gesetzt   |
    +--------------------+------+-------------------------------+
    | cs_ComboBox        |  256 | wird von TComboBox gesetzt    |
    +--------------------+------+-------------------------------+

                Tabelle 12: TControl.Style (nur lesen)


Abgesehen von cs_CheckBox und cs_3State drfen die Konstanten nicht
zusammen verwendet werden.

Von Kontrollelementen abgeleitete Objekte l”schen den alten Wert (z.B.
l”scht TCheckBox den Wert cs_PushButton und tr„gt erst dann
cs_CheckBox ein).


3.6  em_XXXX-Konstanten
=======================

Die folgenden Konstanten werden von ObjectGEM entweder im Feld
TApplication.Status oder intern gesetzt, um Laufzeitfehler zu
signalisieren. Fatale Fehler k”nnen in Status abgefragt werden und
fhren zum Programmabbruch, interne Fehler werden mit
TApplication.ChkError abgefragt.


+----------------------+------+-------------------------------------------+
| Konstante            | Wert | Bedeutung                                 |
+----------------------+------+-------------------------------------------+
| em_OK                |    0 | kein Fehler aufgetreten; insbesondere     |
|                      |      | wird TApplication.MessageLoop nur         |
|                      |      | aufgerufen, wenn in TApplication.Init     |
|                      |      | kein Fehler auftritt                      |
+----------------------+------+-------------------------------------------+
| em_OutOfMemory       |   -1 | eine Speicheranforderung mit new() oder   |
|                      |      | getmem() konnte nicht erfllt werden;     |
|                      |      | von der ObjectGEM-internen Routine wird   |
|                      |      | dann ein nil-Pointer zurckgegeben        |
|                      |      | und der interne Fehlerstatus auf          |
|                      |      | em_OutOfMemory gesetzt                    |
+----------------------+------+-------------------------------------------+
| em_InvalidWindow     |   -4 | wird von Create gesetzt, wenn ein         |
|                      |      | Schnittstellenobjekt kein GEM-Handle      |
|                      |      | mittels wind_create() belegen konnte      |
+----------------------+------+-------------------------------------------+
| em_InvalidMainWindow |   -5 | fatal; wird standardm„ig von             |
|                      |      | TApplication.InitMainWindow gesetzt,      |
|                      |      | wenn berhaupt kein Fenster ge”ffnet      |
|                      |      | werden konnte; kann und sollte ber-      |
|                      |      | schrieben werden                          |
+----------------------+------+-------------------------------------------+
| em_AccInitFailure    |  -10 | fatal; wird von TApplication.InitGEM      |
|                      |      | gesetzt, wenn bei einem Accessory         |
|                      |      | menu_register() fehlschl„gt               |
+----------------------+------+-------------------------------------------+
| em_GEMInitFailure    |  -11 | fatal; wird von TApplication.InitGEM      |
|                      |      | gesetzt, wenn appl_init() oder            |
|                      |      | v_opnvwk() fehlschl„gt                    |
+----------------------+------+-------------------------------------------+
| em_AESNotActive      |  -12 | fatal; wird von TApplication.InitGEM      |
|                      |      | gesetzt, wenn die Applikation im AUTO-    |
|                      |      | Ordner gestartet wird                     |
+----------------------+------+-------------------------------------------+
| em_RscNotFound       |  -13 | fatal; wird von TApplication.LoadResource |
|                      |      | gesetzt, wenn die Resource-Datei nicht    |
|                      |      | gefunden werden konnte                    |
+----------------------+------+-------------------------------------------+
| em_WOpenFailure      |  -20 | wird von TWindow.OpenWindow gesetzt,      |
|                      |      | wenn wind_open() fehlschl„gt              |
+----------------------+------+-------------------------------------------+
| em_WCloseFailure     |  -21 | wird von TWindow.CloseWindow gesetzt,     |
|                      |      | wenn wind_close() fehlschl„gt             |
+----------------------+------+-------------------------------------------+
| em_WDestroyFailure   |  -22 | wird von TWindow.Destroy gesetzt,         |
|                      |      | wenn wind_delete() fehlschl„gt            |
+----------------------+------+-------------------------------------------+
| em_InvalidMenu       |  -30 | wird von LoadMenu gesetzt, wenn der       |
|                      |      | Menbaum nicht existiert, bereits ein     |
|                      |      | anderes Men aktiv ist oder ein Fehler    |
|                      |      | beim Zeichnen auftritt                    |
+----------------------+------+-------------------------------------------+
| em_InvalidDialog     |  -31 | wird von TApplication.ExecDialog und      |
|                      |      | TApplication.Alert zurckgegeben,         |
|                      |      | wenn ein Fehler aufgetreten ist;          |
|                      |      | ferner setzt LoadDialog diesen Fehler,    |
|                      |      | wenn der Dialogbaum nicht existiert       |
+----------------------+------+-------------------------------------------+
| em_InvalidToolbar    |  -32 | wird von TWindow.LoadToolbar gesetzt,     |
|                      |      | wenn der Objektbaum nicht existiert       |
|                      |      | oder schon eine Toolbar aktiv ist         |
+----------------------+------+-------------------------------------------+
| em_SpeedoLoadFailure |  -40 | wird von TApplication.SetupVDI gesetzt,   |
|                      |      | wenn Speedo-Fonts nicht korrekt geladen   |
|                      |      | werden konnten                            |
+----------------------+------+-------------------------------------------+
| em_Terminate         |  -98 | wird von ObjectGEM intern unter           |
|                      |      | MultiTOS verschickt, um beim Eintreffen   |
|                      |      | der MiNT-Signale SIGTERM und              |
|                      |      | SIGQUIT bzw. beim Shutdown durch          |
|                      |      | AP_TERM das Programm sauber (aber ohne    |
|                      |      | den Benutzer zu fragen) abzubrechen;      |
|                      |      | sollte ansonsten nicht gesetzt werden     |
+----------------------+------+-------------------------------------------+
| em_Quit              |  -99 | das Programm wird beim n„chsten Ende      |
|                      |      | der MessageLoop-Schleife nach Aufruf      |
|                      |      | von TApplication.CanClose verlassen;      |
|                      |      | diese Konstante sollte nicht direkt       |
|                      |      | gesetzt werden, statt dessen sollte       |
|                      |      | TApplication.Quit aufgerufen werden       |
+----------------------+------+-------------------------------------------+


3.7  id_XXXX-Konstanten
=======================

Diese Konstanten werden im Feld TControl.ID gespeichert und
standardm„ig nur von TButton und TScrollBar gesetzt. Anders genutzte
IDs sind weiter unten aufgelistet.


+-----------+------+-------------------------------------------------+
| Konstante | Wert | Bedeutung                                       |
+-----------+------+-------------------------------------------------+
| id_No     |   -1 | der PushButton hat keine besondere Bedeutung    |
+-----------+------+-------------------------------------------------+
| id_OK     |    0 | der Button ist der "OK"-Button; bei Anwahl      |
|           |      | wird die Methode TDialog.OK aufgerufen          |
+-----------+------+-------------------------------------------------+
| id_Cancel |    1 | der Button ist der "Abbruch"-Button; bei Anwahl |
|           |      | wird die Methode TDialog.Cancel aufgerufen      |
+-----------+------+-------------------------------------------------+
| id_Help   |    2 | der Button ist der "Hilfe"-Button; bei Anwahl   |
|           |      | wird die Methode TDialog.Help aufgerufen        |
+-----------+------+-------------------------------------------------+
| id_Undo   |    3 | der Button ist der "Undo"-Button; bei Anwahl    |
|           |      | wird die Methode TDialog.Undo aufgerufen        |
+-----------+------+-------------------------------------------------+
| id_Esc    |    4 | der Button ist der "Esc"-Button; bei Anwahl     |
|           |      | wird die Methode TDialog.Esc aufgerufen         |
+-----------+------+-------------------------------------------------+
| id_NoExit |   42 | nach Anwahl dieses Dialogelements wird der      |
|           |      | Dialog nicht verlassen; wird z.B. von           |
|           |      | TScrollBar gesetzt, da die Applikation          |
|           |      | zwar auf die Bildlaufleiste reagieren,          |
|           |      | den Dialog aber nicht verlassen soll            |
|           |      | (der Button wird also im RCS auf "EXIT"         |
|           |      | gesetzt, da er mehr machen soll, als nur        |
|           |      | seinen Zustand wechseln; andererseits wird      |
|           |      | der Dialog aber von ObjectGEM durch diese       |
|           |      | Konstante nicht verlassen, was sonst nur        |
|           |      | durch šberschreiben von TDialog.ExitDlg         |
|           |      | m”glich w„re); auch TComboBox nutzt dieses      |
|           |      | Flag                                            |
+-----------+------+-------------------------------------------------+

Folgende IDs werden nicht (nur) von TControl verwendet:


+--------------+------+----------------------------------------------+
| Konstante    | Wert | Bedeutung                                    |
+--------------+------+----------------------------------------------+
| id_No        |   -1 | wird von recht vielen Routinen verwendet, um |
|              |      | einen "negativen" Status anzuzeigen          |
+--------------+------+----------------------------------------------+
| id_NewHandle |   -1 | zeigt bei GetVDIHandle an, da eine neue     |
|              |      | Workstation automatisch ge”ffnet werden      |
|              |      | soll                                         |
+--------------+------+----------------------------------------------+


3.8  tf_XXXX-Konstanten
=======================

Die Methode Transfer einiger abgeleiteter TControl-Objekte benutzt
diese Konstanten, um die Datenbertragung zwischen der Applikation und
deren Dialogen mittels TDialog.TransferBuffer zu vereinfachen.


      +-------------+------+----------------------------------+
      | Konstante   | Wert | Bedeutung                        |
      +-------------+------+----------------------------------+
      | tf_GetData  |    0 | ruft Daten aus dem Objekt ab     |
      +-------------+------+----------------------------------+
      | tf_SetData  |    1 | sendet Daten, um den Wert des    |
      |             |      | Objekts zu setzen                |
      +-------------+------+----------------------------------+
      | tf_SizeData |    2 | findet die Anzahl der vom Objekt |
      |             |      | bertragenen Bytes heraus        |
      +-------------+------+----------------------------------+


3.9  voXXXX-Konstanten
======================

Die folgenden Konstanten beschreiben Eigenschaften der TValidator-
Objekte und werden in deren TValidator.Options-Feld gespeichert.


 +------------+------+----------------------------------------------+
 | Konstante  | Wert | Bedeutung                                    |
 +------------+------+----------------------------------------------+
 | voFill     |    1 | an die Eingabe werden evtl. fehlende Werte   |
 |            |      | angeh„ngt; wird von TPXPictureValidator ver- |
 |            |      | wendet                                       |
 +------------+------+----------------------------------------------+
 | voNotEmpty |    2 | das Eingabefeld darf nicht leer sein,        |
 |            |      | sonst kann der Dialog nicht beendet werden   |
 +------------+------+----------------------------------------------+
 | voOnAppend |    4 | wird von TPXPictureValidator gesetzt         |
 +------------+------+----------------------------------------------+
 | voOnEdit   |    8 | ist dieses Flag gesetzt, ruft TEdit.Edit     |
 |            |      | die Methode TValidator.IsValidInput des      |
 |            |      | zugeh”rigen Validators auf, in der der       |
 |            |      | bergebene Text korrigiert werden kann       |
 +------------+------+----------------------------------------------+
 | voReserved |  240 | reserviert fr Softdesign                    |
 +------------+------+----------------------------------------------+


3.10  vsXXXX-Konstanten
=======================

Die folgenden Konstanten zeigen den Zustand von TValidator-Objekten an
und werden in deren TValidator.Status-Feld gespeichert.


    +-----------+------+-----------------------------------------+
    | Konstante | Wert | Bedeutung                               |
    +-----------+------+-----------------------------------------+
    | vsOK      |    0 | alles OK, kein Fehler aufgetreten       |
    +-----------+------+-----------------------------------------+
    | vsSyntax  |    1 | ungltige Maske bei TPXPictureValidator |
    +-----------+------+-----------------------------------------+


3.11  wb_XXXX-Konstanten
========================

Das Feld TControl.Flags beschreibt zus„tzliche Eigenschaften eines
Dialogelementobjekts.


+-------------+------+----------------------------------------------+
| Konstante   | Wert | Bedeutung                                    |
+-------------+------+----------------------------------------------+
| wb_Transfer |    1 | das Dialogelementobjekt nimmt am Transfer-   |
|             |      | Mechanismus teil; standardm„ig wird dieses  |
|             |      | Flag von TCheckBox, TRadioButton, TTriState  |
|             |      | und TEdit gesetzt                            |
+-------------+------+----------------------------------------------+
| wb_Lazy     |    2 | das Dialogelement wird nicht neu gezeichnet, |
|             |      | wenn eine andere Applikation den Bildschirm  |
|             |      | blockiert hat (wichtig fr Statusanzeigen);  |
|             |      | wird von TControl.Paint beachtet             |
+-------------+------+----------------------------------------------+


3.12  ws_XXXX-Konstanten
========================

Diese in TWindow.Attr.Status gespeicherten Werte geben den Zustand
eines Fensters an.


+-------------+------+------------------------------------------------+
| Konstante   | Wert | Bedeutung                                      |
+-------------+------+------------------------------------------------+
| ws_NoWindow |    1 | das Schnittstellenobjekt belegt kein GEM-      |
|             |      | Handle, das Fenster ist also auch nicht offen; |
|             |      | TWindow.Destroy und TWindow.RawDestroy setzen  |
|             |      | diesen ursprnglichen Status zurck            |
+-------------+------+------------------------------------------------+
| ws_Created  |    2 | das Schnittstellenobjekt besitzt ein GEM-      |
|             |      | Handle, das Fenster ist aber noch nicht        |
|             |      | offen; wird von TWindow.Create gesetzt bzw.    |
|             |      | von TWindow.CloseWindow zurckgesetzt          |
+-------------+------+------------------------------------------------+
| ws_Open     |    3 | das Fenster ist offen, es existiert also auch  |
|             |      | ein GEM-Handle; wird von TWindow.OpenWindow    |
|             |      | gesetzt                                        |
+-------------+------+------------------------------------------------+


3.13  ws_ex_XXXX-Konstanten
===========================

Im Gegensatz zum Feld TWindow.Attr.Style, das das Aussehen des
Fensters beschreibt, enth„lt TWindow.Attr.ExStyle die erweiterten
Eigenschaften des Fensters. Die meisten Konstanten werden im
Zusammenhang mit TDialog benutzt.


+-----------------------+-------+--------------------------------------+
| Konstante             |  Wert | Bedeutung                            |
+-----------------------+-------+--------------------------------------+
| ws_ex_Modeless        |     1 | der Dialog mu nicht-modal sein;     |
|                       |       | wenn kein Fenster mehr ge”ffnet      |
|                       |       | werden kann, wird em_InvalidWindow   |
|                       |       | gesetzt (default)                    |
+-----------------------+-------+--------------------------------------+
| ws_ex_TryModeless     |     3 | es wird versucht, den Dialog         |
|                       |       | nicht-modal zu ”ffnen; gelingt dies  |
|                       |       | nicht, wird er modal ausgefhrt      |
|                       |       | (bei TDialog default)                |
+-----------------------+-------+--------------------------------------+
| ws_ex_AppModal        |     4 | der Dialog ist fr die Applikation   |
|                       |       | modal, obwohl er in einem Fenster    |
|                       |       | und damit fr das System nicht-modal |
|                       |       | abgearbeitet wird; d.h. es kann kein |
|                       |       | anderes Fenster der Applikation ge-  |
|                       |       | toppt werden, und die Mens sind     |
|                       |       | gesperrt (z.Z. noch ohne Wirkung!)   |
+-----------------------+-------+--------------------------------------+
| ws_ex_Popup           |     8 | das Fenster erscheint zentriert      |
|                       |       | um die aktuelle Mausposition         |
+-----------------------+-------+--------------------------------------+
| ws_ex_Center          |    16 | das Fenster wird auf dem Desktop     |
|                       |       | zentriert                            |
+-----------------------+-------+--------------------------------------+
| ws_ex_CenterOnce      |    48 | das Fenster wird nur beim ersten     |
|                       |       | Aufruf zentriert, danach merkt es    |
|                       |       | sich seine Position auch nach        |
|                       |       | einem TWindow.CloseWindow            |
|                       |       | (bei TDialog default)                |
+-----------------------+-------+--------------------------------------+
| ws_ex_Center2Parent   |    80 | das Fenster wird relativ zu seinem   |
|                       |       | Parent zentriert; ist dieses nil,    |
|                       |       | wird das Fenster auf dem Desktop     |
|                       |       | zentriert                            |
+-----------------------+-------+--------------------------------------+
| ws_ex_MoveDial        |   128 | ein modaler Dialog kann verschoben   |
|                       |       | werden; wird von TDialog gesetzt,    |
|                       |       | wenn as_MoveDials gesetzt ist        |
+-----------------------+-------+--------------------------------------+
| ws_ex_MoveTransparent |   384 | ein modaler Dialog kann transparent  |
|                       |       | verschoben werden; wird von TDialog  |
|                       |       | gesetzt, wenn as_MoveTransparent     |
|                       |       | gesetzt ist                          |
+-----------------------+-------+--------------------------------------+
| ws_ex_Disabled        |   512 | ab AES 4.0 kann ein Fenster in       |
|                       |       | den Hintergrund gebracht werden;     |
|                       |       | ist dieser Wert gesetzt, wird        |
|                       |       | dies von TWindow.OpenWindow          |
|                       |       | sofort nach dem ™ffnen ausgefhrt    |
+-----------------------+-------+--------------------------------------+
| ws_ex_LoadFonts       |  1024 | fr TWindow.vdiHandle werden GDOS-   |
|                       |       | Fonts nachgeladen, sofern GDOS in-   |
|                       |       | stalliert ist und Fonts vorhanden    |
|                       |       | sind                                 |
+-----------------------+-------+--------------------------------------+
| ws_ex_ReadOnly        | 32768 | wird von TTextWindow und abgelei-    |
|                       |       | teten Objekten genutzt, um anzu-     |
|                       |       | zeigen, da der Text im Fenster      |
|                       |       | nicht ver„ndert werden kann          |
+-----------------------+-------+--------------------------------------+


3.14  ASCII-Steuercodes
=======================


+-----------+------+-------------------------------------------------+
| Konstante | Wert | Bedeutung                                       |
+-----------+------+-------------------------------------------------+
| NUL       |    0 | Nil (Null)                                      |
+-----------+------+-------------------------------------------------+
| EOS       |    0 | Ende der Zeichenkette (End of String)           |
|           |      | kein vordefinierter ASCII-Steuercode!           |
+-----------+------+-------------------------------------------------+
| SOH       |    1 | Anfang des Kopfes (Start of Heading)            |
+-----------+------+-------------------------------------------------+
| STX       |    2 | Anfang des Textes (Start of Text)               |
+-----------+------+-------------------------------------------------+
| ETX       |    3 | Ende des Textes (End of Text)                   |
+-----------+------+-------------------------------------------------+
| EOT       |    4 | Ende der šbertragung (End of Transmission)      |
+-----------+------+-------------------------------------------------+
| ENQ       |    5 | Stationsaufforderung (Enquiry)                  |
+-----------+------+-------------------------------------------------+
| ACK       |    6 | Positive Rckmeldung (Acknowledge)              |
+-----------+------+-------------------------------------------------+
| BEL       |    7 | Klingel (BEL)                                   |
+-----------+------+-------------------------------------------------+
| BS        |    8 | Rckw„rtsschritt (Backspace)                    |
+-----------+------+-------------------------------------------------+
| HT        |    9 | Horizontal-Tabulator (Horizontal Tabulation)    |
+-----------+------+-------------------------------------------------+
| LF        |   10 | Zeilenvorschub (Line Feed)                      |
+-----------+------+-------------------------------------------------+
| VT        |   11 | Vertikal-Tabulator (Vertical Tabulation)        |
+-----------+------+-------------------------------------------------+
| FF        |   12 | Formularvorschub (Form Feed)                    |
+-----------+------+-------------------------------------------------+
| CR        |   13 | Wagenrcklauf (Carriage Return)                 |
+-----------+------+-------------------------------------------------+
| SO        |   14 | Dauerumschaltung (Shift-out)                    |
+-----------+------+-------------------------------------------------+
| SI        |   15 | Rckschaltung (Shift-in)                        |
+-----------+------+-------------------------------------------------+
| DLE       |   16 | Datenbertragungsumschaltung (Data Link Escape) |
+-----------+------+-------------------------------------------------+
| DC1       |   17 | Ger„testeuerung (Device Control)                |
+-----------+------+-------------------------------------------------+
| DC2       |   18 | "                                               |
+-----------+------+-------------------------------------------------+
| DC3       |   19 | "                                               |
+-----------+------+-------------------------------------------------+
| DC4       |   20 | "                                               |
+-----------+------+-------------------------------------------------+
| NAK       |   21 | Negative Rckmeldung (Negative Acknowledge)     |
+-----------+------+-------------------------------------------------+
| SYN       |   22 | Synchronisierung (Synchronous Idle)             |
+-----------+------+-------------------------------------------------+
| ETB       |   23 | Ende des Datenbertragungsblocks                |
|           |      | (End of Transmission Block)                     |
+-----------+------+-------------------------------------------------+
| CAN       |   24 | Ungltig (Cancel)                               |
+-----------+------+-------------------------------------------------+
| EM        |   25 | Ende der Aufzeichnung (End of Medium)           |
+-----------+------+-------------------------------------------------+
| SUB       |   26 | Substitution (Substitute Character)             |
+-----------+------+-------------------------------------------------+
| ESC       |   27 | Umschaltung (Escape)                            |
+-----------+------+-------------------------------------------------+
| FS        |   28 | Hauptgruppen-Trennung (File Separator)          |
+-----------+------+-------------------------------------------------+
| GS        |   29 | Gruppen-Trennung (Group Separator)              |
+-----------+------+-------------------------------------------------+
| RS        |   30 | Untergruppen-Trennung (Record Separator)        |
+-----------+------+-------------------------------------------------+
| US        |   31 | Teilgruppen-Trennung (Unit Separator)           |
+-----------+------+-------------------------------------------------+
| SP        |   32 | Leerzeichen (Space)                             |
|           |      | kein vordefinierter ASCII-Steuercode!           |
+-----------+------+-------------------------------------------------+
| DEL       |  127 | L”schen (Delete)                                |
+-----------+------+-------------------------------------------------+


3.15  L„nderkennungen
=====================

Einen der folgenden aus dem System-Header bzw. dem _AKP-Cookie
ermittelten Werte tr„gt TApplication.Init in das Feld
TApplication.Attr.Country ein:


       +-----------+------+----------------------------------+
       | Konstante | Wert | Bedeutung                        |
       +-----------+------+----------------------------------+
       | USA       |    0 | USA                              |
       +-----------+------+----------------------------------+
       | FRG       |    1 | Bundesrepublik Deutschland       |
       +-----------+------+----------------------------------+
       | FRA       |    2 | Frankreich                       |
       +-----------+------+----------------------------------+
       | UK        |    3 | Grobritannien                   |
       +-----------+------+----------------------------------+
       | SPA       |    4 | Spanien                          |
       +-----------+------+----------------------------------+
       | ITA       |    5 | Italien                          |
       +-----------+------+----------------------------------+
       | SWE       |    6 | Schweden                         |
       +-----------+------+----------------------------------+
       | SWF       |    7 | Schweiz (franz”sisch)            |
       +-----------+------+----------------------------------+
       | SWG       |    8 | Schweiz (deutsch)                |
       +-----------+------+----------------------------------+
       | TUR       |    9 | Trkei                           |
       +-----------+------+----------------------------------+
       | FIN       |   10 | Finnland                         |
       +-----------+------+----------------------------------+
       | NOR       |   11 | Norwegen                         |
       +-----------+------+----------------------------------+
       | DEN       |   12 | D„nemark                         |
       +-----------+------+----------------------------------+
       | SAU       |   13 | Saudi-Arabien                    |
       +-----------+------+----------------------------------+
       | HOL       |   14 | Niederlande                      |
       +-----------+------+----------------------------------+
       | CZE       |   15 | Tschechische Republik & Slowakei |
       +-----------+------+----------------------------------+
       | HUN       |   16 | Ungarn                           |
       +-----------+------+----------------------------------+


3.16  Mausformen
================

ObjectGEM stellt mit SetMouse eine neue graf_mouse()-Routine zur
Verfgung, so da neben den blichen Mausformen auch noch neue, z.T.
Windows-kompatible Formen ausgew„hlt werden k”nnen. Trotzdem sollten
Sie die Maus so selten wie m”glich „ndern (im Hinblick auf MultiTOS).
Auerdem stellt ObjectGEM ihnen einige Routinen zum ndern zur
Verfgung (HideMouse, ShowMouse, ArrowMouse, BusyMouse, LastMouse
etc.), die Sie anstelle von graf_mouse() verwenden sollten.


     +--------------+------+-----------------------------------+
     | Konstante    | Wert | Bedeutung                         |
     +--------------+------+-----------------------------------+
     | IDC_ARROW    |    0 | normaler Pfeil                    |
     +--------------+------+-----------------------------------+
     | IDC_IBEAM    |    1 | Text-Cursor                       |
     +--------------+------+-----------------------------------+
     | IDC_CROSS    |    5 | feines Fadenkreuz                 |
     +--------------+------+-----------------------------------+
     | IDC_WAIT     |  100 | die Windows-Sanduhr               |
     +--------------+------+-----------------------------------+
     | HOURGLASS    |  100 | "                                 |
     +--------------+------+-----------------------------------+
     | IDC_LOAD     |  101 | eine Diskette                     |
     +--------------+------+-----------------------------------+
     | IDC_HELP     |  102 | Pfeil mit Fragezeichen;           |
     |              |      | wird von der BubbleHelp verwendet |
     +--------------+------+-----------------------------------+
     | IDC_PENCIL   |  103 | ein Zeichenstift                  |
     +--------------+------+-----------------------------------+
     | IDC_RUBBER   |  104 | ein Radiergummi                   |
     +--------------+------+-----------------------------------+
     | IDC_SCISSORS |  105 | eine Schere                       |
     +--------------+------+-----------------------------------+
     | IDC_PASTE    |  106 | eine Klebetube                    |
     +--------------+------+-----------------------------------+
     | IDC_SLICE1   |  107 |                                   |
     | IDC_SLICE2   |  108 | vier Konstanten fr die Routinen  |
     | IDC_SLICE3   |  109 | SliceMouse und SliceMouseNext     |
     | IDC_SLICE4   |  110 |                                   |
     +--------------+------+-----------------------------------+


3.17  MiNT-Signale
==================

Im folgenden sind die Signale beschrieben, die MiNT/MultiTOS an
Prozesse schickt (oder die dieses untereinander verschicken).
ObjectGEM reagiert nur auf SIGTERM und SIGQUIT.


+-----------+------+--------------------------------------------------+
| Konstante | Wert | Bedeutung                                        |
+-----------+------+--------------------------------------------------+
| SIGNULL   |    0 | dies ist eigentlich kein Signal, da es nie an    |
|           |      | Prozesse verschickt wird; allerdings kann man    |
|           |      | damit die Pr„senz eines Child-Prozesses testen   |
+-----------+------+--------------------------------------------------+
| SIGHUP    |    1 | das Ein-/Ausgabe-Terminal ist nicht mehr gltig; |
|           |      | wird vom Window Manager (z.B. MW) verschickt,    |
|           |      | wenn der Benutzer das Terminalfenster schliet   |
+-----------+------+--------------------------------------------------+
| SIGINT    |    2 | Unterbrechung;                                   |
|           |      | wird verschickt, wenn der Benutzer <Control>+<C> |
|           |      | drckt; die aktuelle Aktion bzw. das Programm    |
|           |      | soll abgebrochen werden                          |
+-----------+------+--------------------------------------------------+
| SIGQUIT   |    3 | Abbruch;                                         |
|           |      | wird nach Drcken von <Control>+<\> verschickt;  |
|           |      | das Programm soll dringend beendet werden!       |
+-----------+------+--------------------------------------------------+
| SIGILL    |    4 | ein illegaler Assembler-Befehl sollte            |
|           |      | ausgefhrt werden                                |
+-----------+------+--------------------------------------------------+
| SIGTRAP   |    5 | Einzelschrittausfhrung (z.B. fr Debugger)      |
+-----------+------+--------------------------------------------------+
| SIGABRT   |    6 | "Grausamer Fehler"                               |
|           |      | der aufgetretene Fehler ist so schwer, da       |
|           |      | das Programm sofort und ohne "Aufr„umarbeiten"   |
|           |      | verlassen werden sollte (bzw. wird)              |
+-----------+------+--------------------------------------------------+
| SIGPRIV   |    7 | es wurde versucht, einen Supervisor-Befehl       |
|           |      | im User-Modus auszufhren                        |
+-----------+------+--------------------------------------------------+
| SIGFPE    |    8 | Division durch Null oder šberlauf                |
+-----------+------+--------------------------------------------------+
| SIGKILL   |    9 | Prozeabbruch;                                   |
|           |      | kann nicht abgefangen werden; der                |
|           |      | Proze wird unwiderruflich entfernt              |
+-----------+------+--------------------------------------------------+
| SIGBUS    |   10 | Bus-Fehler                                       |
+-----------+------+--------------------------------------------------+
| SIGSEGV   |   11 | Adre-Fehler; es wurde auf eine illegale         |
|           |      | Speicheradresse zugegriffen                      |
+-----------+------+--------------------------------------------------+
| SIGSYS    |   12 | bei einem Systemaufruf wurden falsche            |
|           |      | Werte bergeben                                  |
+-----------+------+--------------------------------------------------+
| SIGPIPE   |   13 | es wurde versucht, in eine nicht existierende    |
|           |      | Pipe zu schreiben, bzw. die Pipe ist zerbrochen  |
+-----------+------+--------------------------------------------------+
| SIGALRM   |   14 | die mit Talarm() gesetzte Zeit ist abgelaufen    |
+-----------+------+--------------------------------------------------+
| SIGTERM   |   15 | Proze bitte beenden;                            |
|           |      | wird z.B. verschickt, wenn ein Proze aus        |
|           |      | U:\PROC auf den Papierkorb gezogen wird          |
+-----------+------+--------------------------------------------------+
| SIGSTOP   |   17 | der Proze wird angehalten                       |
+-----------+------+--------------------------------------------------+
| SIGTSTP   |   18 | der Proze wird "gebeten", anzuhalten            |
+-----------+------+--------------------------------------------------+
| SIGCONT   |   19 | hebt SIGSTOP oder SIGTSTP auf                    |
+-----------+------+--------------------------------------------------+
| SIGCHLD   |   20 | ein Child-Proze wurde beendet                   |
+-----------+------+--------------------------------------------------+
| SIGTTIN   |   21 | Eingabe vom falschen Terminal                    |
+-----------+------+--------------------------------------------------+
| SIGTTOU   |   22 | Ausgabe auf falsches Terminal                    |
+-----------+------+--------------------------------------------------+
| SIGXCPU   |   24 | die erlaubte CPU-Zeit des Prozesses              |
|           |      | wurde berschritten                              |
+-----------+------+--------------------------------------------------+
| SIGWINCH  |   28 | die Fenstergr”e wurde ge„ndert;                 |
|           |      | wird z.B. von MW verschickt                      |
+-----------+------+--------------------------------------------------+
| SIGUSR1   |   29 | User-Signal 1                                    |
+-----------+------+--------------------------------------------------+
| SIGUSR2   |   30 | User-Signal 2                                    |
+-----------+------+--------------------------------------------------+

Die folgenden Konstanten werden an Psignal() statt eines Handlers
bergeben:


      +---------+------------+---------------------------------+
      | SIG_DFL | pointer(0) | setzt fr das angegebene Signal |
      |         |            | wieder die Default-Routine ein  |
      +---------+------------+---------------------------------+
      | SIG_IGN | pointer(1) | das betreffende Signal wird von |
      |         |            | der Applikation ignoriert       |
      +---------+------------+---------------------------------+


3.18  Protokoll-Messages
========================

ObjectGEM erkennt die GEM-Messages des XAcc- und AV-Protokolls.
TApplication.MUMesag leitet die Messages an TApplication.HandleAV und
TApplication.HandleXAcc weiter. Beschreibungen der Protokolle finden
sich u.a in TOS 2/92 (XAcc) und in der Dokumentation zur
Benutzeroberfl„che Gemini (AV). Das Kobold-Protokoll ist in der
Anleitung des Dateikopierers beschrieben. Das Men-Protokoll ist
erstmalig mit ObjectGEM ver”ffentlicht und wird in Zukunft st„rker
untersttzt.


   +----------------------+-------+-------------------------------+
   | Konstante            |  Wert | Bedeutung                     |
   +----------------------+-------+-------------------------------+
   | ACC_ID               | $0400 | s. TApplication.XAccID        |
   | ACC_OPEN             | $0401 |                               |
   | ACC_CLOSE            | $0402 |                               |
   | ACC_ACC              | $0403 | s. TApplication.XAccAcc       |
   | ACC_EXIT             | $0404 | s. TApplication.XAccExit      |
   | ACC_ACK              | $0500 |                               |
   | ACC_TEXT             | $0501 | s. TApplication.XAccText      |
   | ACC_KEY              | $0502 | s. TApplication.XAccKey       |
   | ACC_META             | $0503 | s. TApplication.XAccMeta      |
   | ACC_IMG              | $0504 | s. TApplication.XAccIMG       |
   | ACC_SPECIAL          | $0800 | Beginn der privaten Messages  |
   +----------------------+-------+-------------------------------+
   | AV_PROTOKOLL         | $4700 | s. TApplication.AVProtokoll   |
   | VA_PROTOSTATUS       | $4701 | s. TApplication.VAProtoStatus |
   | AV_GETSTATUS         | $4703 |                               |
   | AV_STATUS            | $4704 |                               |
   | VA_SETSTATUS         | $4705 |                               |
   | AV_SENDKEY           | $4710 | s. TApplication.AVSendKey     |
   | VA_START             | $4711 | s. TApplication.VAStart       |
   | AV_ASKFILEFONT       | $4712 |                               |
   | VA_FILEFONT          | $4713 |                               |
   | AV_ASKCONFONT        | $4714 |                               |
   | VA_CONFONT           | $4715 |                               |
   | AV_ASKOBJECT         | $4716 |                               |
   | VA_OBJECT            | $4717 |                               |
   | AV_OPENCONSOLE       | $4718 |                               |
   | VA_CONSOLEOPEN       | $4719 |                               |
   | AV_OPENWIND          | $4720 |                               |
   | VA_WINDOPEN          | $4721 |                               |
   | AV_STARTPROG         | $4722 | s. TApplication.AVStartProg   |
   | VA_PROGSTART         | $4723 |                               |
   | AV_ACCWINDOPEN       | $4724 |                               |
   | VA_DRAGACCWIND       | $4725 |                               |
   | AV_ACCWINDCLOSED     | $4726 |                               |
   | AV_COPY_DRAGGED      | $4728 |                               |
   | VA_COPY_COMPLETE     | $4729 |                               |
   | AV_PATH_UPDATE       | $4730 |                               |
   | AV_WHAT_IZIT         | $4732 |                               |
   | VA_THAT_IZIT         | $4733 |                               |
   | AV_DRAG_ON_WINDOW    | $4734 |                               |
   | VA_DRAG_COMPLETE     | $4735 |                               |
   | AV_EXIT              | $4736 | s. TApplication.AVExit        |
   +----------------------+-------+-------------------------------+
   | VA_OB_UNKNOWN        |     0 |                               |
   | VA_OB_TRASHCAN       |     1 |                               |
   | VA_OB_SHREDDER       |     2 |                               |
   | VA_OB_CLIPBOARD      |     3 |                               |
   | VA_OB_FILE           |     4 |                               |
   | VA_OB_FOLDER         |     5 |                               |
   | VA_OB_DRIVE          |     6 |                               |
   | VA_OB_WINDOW         |     7 |                               |
   +----------------------+-------+-------------------------------+
   | MSG_SETSTATUS        |     1 |                               |
   | MSG_START            |     2 |                               |
   | MSG_SENDKEY          |     1 |                               |
   | MSG_ASKFILEFONT      |     2 |                               |
   | MSG_ASKCONFONT       |     4 |                               |
   | MSG_ASKOBJECT        |     8 |                               |
   | MSG_OPENWIND         |    16 |                               |
   | MSG_STARTPROG        |    32 |                               |
   | MSG_ACCWINDOPEN      |    64 |                               |
   | MSG_STATUS           |   128 |                               |
   | MSG_COPY_DRAGGED     |   256 |                               |
   | MSG_PATH_UPDATE      |   512 |                               |
   | MSG_EXIT             |  1024 |                               |
   +----------------------+-------+-------------------------------+
   | KOBOLD_JOB           | $2f10 |                               |
   | KOBOLD_JOB_NO_WINDOW | $2f11 |                               |
   | KOBOLD_ANSWER        | $2f12 |                               |
   | KOBOLD_CONFIG        | $2f13 |                               |
   | KOBOLD_FIRST_SLCT    | $2f14 |                               |
   | KOBOLD_NEXT_SLCT     | $2f15 |                               |
   | KOBOLD_CLOSE         | $2f16 |                               |
   | KOBOLD_FREE_DRIVES   | $2f17 |                               |
   +----------------------+-------+-------------------------------+
   | WM_SAVE              | $1000 |                               |
   | WM_SAVEAS            | $1001 |                               |
   | WM_PRINT             | $1002 | s. Print                      |
   | WM_UNDO              | $1003 |                               |
   | WM_CUT               | $1004 | s. Cut                        |
   | WM_COPY              | $1005 | s. Copy                       |
   | WM_PASTE             | $1006 | s. Paste                      |
   | WM_SELECTALL         | $1007 | s. SelectAll                  |
   | WM_FIND              | $1008 |                               |
   | WM_REPLACE           | $1009 |                               |
   | WM_FINDNEXT          | $100a |                               |
   | WM_HELP              | $100b |                               |
   | WM_DELETE            | $100c | s. Delete                     |
   +----------------------+-------+-------------------------------+
   | VIEW_FILE            | $5600 |                               |
   | VIEW_FAILED          | $5601 |                               |
   | VIEW_OPEN            | $5602 |                               |
   | VIEW_CLOSED          | $5603 |                               |
   | VIEW_DATA            | $5604 |                               |
   | VIEW_GETMFDB         | $5610 |                               |
   | VIEW_SETMFDB         | $5611 |                               |
   | VIEW_MFDB            | $5612 |                               |
   +----------------------+-------+-------------------------------+
   | VIEWERR_ERROR        |     0 |                               |
   | VIEWERR_SIZE         |     1 |                               |
   | VIEWERR_COLOR        |     2 |                               |
   | VIEWERR_WID          |     3 |                               |
   | VIEWERR_MEM          |     4 |                               |
   +----------------------+-------+-------------------------------+


3.19  SCF_XXXX-Konstanten
=========================

Folgende Konstanten charakterisieren den Dateityp im Klemmbrett und
k”nnen in der Bitmap von TApplication.SCChanged ausgewertet werden
(die angegebenen Extensions sind nur Beispiele):


+------------+-------+----------------------------------------------+
| Konstante  |  Wert | Bedeutung                                    |
+------------+-------+----------------------------------------------+
| SCF_INDEF  | $0000 | Die Datei pat auf keine der folgenden Typen |
+------------+-------+----------------------------------------------+
| SCF_DBASE  | $0001 | Daten, die in eine Datenbank geladen werden  |
|            |       | k”nnen ('.DBF','.CSV')                       |
+------------+-------+----------------------------------------------+
| SCF_TEXT   | $0002 | Textdateien ('.TXT','.ASC','.RTF','.DOC')    |
+------------+-------+----------------------------------------------+
| SCF_VECTOR | $0004 | Vektorgrafik ('.GEM','.EPS','.CVG')          |
+------------+-------+----------------------------------------------+
| SCF_RASTER | $0008 | Rastergrafik ('.IMG','.TIF','.GIF','.PCX')   |
+------------+-------+----------------------------------------------+
| SCF_SHEET  | $0010 | Tabellenkalkulation ('.DIF','.WKS')          |
+------------+-------+----------------------------------------------+
| SCF_SOUND  | $0020 | Samples, MIDI-Files, Kl„nge ('.MOD')         |
+------------+-------+----------------------------------------------+

Die zugeh”rige Message ist folgendermaen deklariert:


                        +------------+-------+
                        | SC_CHANGED | $0050 |
                        +------------+-------+


3.20  Tastatur-Werte
====================

Die folgenden Werte werden von MapKey zurckgeliefert. Die
Bezeichnungen sollten weitestgehend selbsterkl„rend sein.


   +-----------+-------+-----------------------------------------+
   | Konstante |  Wert | Bedeutung                               |
   +-----------+-------+-----------------------------------------+
   | KsCAPS    | $0010 | Bits zur Kennzeichnung des Shift-Status |
   | KsALT     | $0008 |                                         |
   | KsCONTROL | $0004 |                                         |
   | KsSHIFT   | $0003 |                                         |
   | KsLSHIFT  | $0002 |                                         |
   | KsRSHIFT  | $0001 |                                         |
   | KsNORMAL  | $0000 |                                         |
   +-----------+-------+-----------------------------------------+
   | KbSCAN    | $8000 | Masken fr Status-Bits, die im oberen   |
   | KbNUM     | $4000 | Byte des von MapKey zurckgegebenen     |
   | KbALT     | $0800 | Words plaziert sind                     |
   | KbCONTROL | $0400 |                                         |
   | KbLSHIFT  | $0200 |                                         |
   | KbRSHIFT  | $0100 |                                         |
   +-----------+-------+-----------------------------------------+
   | KbISO     | $0037 | ISO-Taste; erscheint, wenn eine Nicht-  |
   |           |       | US-Tastatur mit US-TOS benutzt wird     |
   +-----------+-------+-----------------------------------------+
   | KbF1      | $003b | Funktionstasten                         |
   | KbF2      | $003c |                                         |
   | KbF3      | $003d |                                         |
   | KbF4      | $003e |                                         |
   | KbF5      | $003f |                                         |
   | KbF6      | $0040 |                                         |
   | KbF7      | $0041 |                                         |
   | KbF8      | $0042 |                                         |
   | KbF9      | $0043 |                                         |
   | KbF10     | $0044 |                                         |
   +-----------+-------+-----------------------------------------+
   | KbF11     | $0054 | Shift-Funktionstasten                   |
   | KbF12     | $0055 |                                         |
   | KbF13     | $0056 |                                         |
   | KbF14     | $0057 |                                         |
   | KbF15     | $0058 |                                         |
   | KbF16     | $0059 |                                         |
   | KbF17     | $005a |                                         |
   | KbF18     | $005b |                                         |
   | KbF19     | $005c |                                         |
   | KbF20     | $005d |                                         |
   +-----------+-------+-----------------------------------------+
   | KbUNDO    | $0061 | Cursor-Bereich                          |
   | KbHELP    | $0062 |                                         |
   | KbINSERT  | $0052 |                                         |
   | KbHOME    | $0047 |                                         |
   | KbUP      | $0048 |                                         |
   | KbDOWN    | $0050 |                                         |
   | KbLEFT    | $004b |                                         |
   | KbRIGHT   | $004d |                                         |
   +-----------+-------+-----------------------------------------+
   | KbAlt1    | $0078 | Alternate-numerische Taste              |
   | KbAlt2    | $0079 |                                         |
   | KbAlt3    | $007a |                                         |
   | KbAlt4    | $007b |                                         |
   | KbAlt5    | $007c |                                         |
   | KbAlt6    | $007d |                                         |
   | KbAlt7    | $007e |                                         |
   | KbAlt8    | $007f |                                         |
   | KbAlt9    | $0080 |                                         |
   | KbAlt0    | $0081 |                                         |
   +-----------+-------+-----------------------------------------+

Folgende Werte erleichtern die Programmierung/Wartung:


                   +----------+-------------------+
                   | K_NORMAL |             $0000 |
                   +----------+-------------------+
                   | K_SHIFT  | K_LSHIFT+K_RSHIFT |
                   +----------+-------------------+

Die folgenden Konstanten werden neu definiert, damit die Konstanten
aus der Unit Gem nicht mit den TDialog-Methoden kollidieren.


                        +--------+----------+
                        | S_Esc  | gem.Esc  |
                        +--------+----------+
                        | S_Undo | gem.Undo |
                        +--------+----------+
                        | S_Help | gem.Help |
                        +--------+----------+


3.21  Sonstige Konstanten
=========================


     +------------+-----------+--------------------------------+
     | Konstante  |      Wert | Bedeutung                      |
     +------------+-----------+--------------------------------+
     | GOVersion  |     $0150 | ObjectGEM-Version (VtoS)       |
     | GODate     | $07251996 | ObjectGEM-Erstellungsdatum     |
     |            |           | (Umwandlung mit DtoS)          |
     +------------+-----------+--------------------------------+
     | DESK       |         0 | bezeichnet Fenster 0 (Desktop) |
     +------------+-----------+--------------------------------+
     | CLIP_ON    |         1 | Konstanten fr vs_clip()       |
     | CLIP_OFF   |         0 |                                |
     +------------+-----------+--------------------------------+
     | PER_ON     |         1 | Konstanten fr vsf_perimeter() |
     | PER_OFF    |         0 |                                |
     +------------+-----------+--------------------------------+
     | ME_DRAW    |         1 | Konstanten fr menu_bar()      |
     | ME_ERASE   |         0 | (ME_INQUIRE erst ab AES 4.0)   |
     | ME_INQUIRE |        -1 |                                |
     +------------+-----------+--------------------------------+
     | ME_CHECK   |         1 | Konstanten fr menu_icheck()   |
     | ME_UNCHECK |         0 |                                |
     +------------+-----------+--------------------------------+
     | ME_DISABLE |         0 | Konstanten fr menu_ienable()  |
     | ME_ENABLE  |         1 |                                |
     +------------+-----------+--------------------------------+
     | ME_NORMAL  |         1 | Konstanten fr menu_tnormal()  |
     | ME_INVERT  |         0 |                                |
     +------------+-----------+--------------------------------+
     | NDC        |         0 | Konstanten fr v_opnvwk()      |
     | RC         |         2 | (normalisiertes oder Raster-   |
     |            |           | koordinatensystem)             |
     +------------+-----------+--------------------------------+


HexArray: array [0..15] of char = ('0','1','2','3','4','5','6','7',
                                   '8','9','a','b','c','d','e','f');




4  Objekte
**********

Diese šbersicht ist eine alphabetische Auflistung aller ObjectGEM-
Objekte. Die Abh„ngigkeiten der Objekte werden in der Objekthierarchie
deutlich.


4.1  TApplication
=================

TApplication ist ein komplettes GEM-Applikations-Objekt, d.h. das
Objekt beachtet automatisch alle GEM-Konventionen bzgl.
Initialisierung etc. Auerdem werden alle Meldungen und Ereignisse
verarbeitet. Da TApplication standardm„ig nur ein leeres Fenster vom
Typ TWindow erzeugt, leitet man normalerweise ein eigenes Applikati-
onsobjekt ab.

Pointer

     PApplication = ^TApplication;

Felder

   ù aesHandle (siehe "TApplication.aesHandle")

   ù apDTA (siehe "TApplication.apDTA")

   ù apID (siehe "TApplication.apID")

   ù apName (siehe "TApplication.apName")

   ù apPath (siehe "TApplication.apPath")

   ù Attr (siehe "TApplication.Attr")

   ù AVServer (siehe "TApplication.AVServer")

   ù Clipboard (siehe "TApplication.Clipboard")

   ù FirstInstance (siehe "TApplication.FirstInstance")

   ù FPUAvailable (siehe "TApplication.FPUAvailable")

   ù GDOSActive (siehe "TApplication.GDOSActive")

   ù Icon (siehe "TApplication.Icon")

   ù IsQSBUsed (siehe "TApplication.IsQSBUsed")

   ù MainWindow (siehe "TApplication.MainWindow")

   ù MemoryProtection (siehe "TApplication.MemoryProtection")

   ù menuID (siehe "TApplication.menuID")

   ù MenuTree (siehe "TApplication.MenuTree")

   ù MessageBLen (siehe "TApplication.MessageBLen")

   ù MessageBuffer (siehe "TApplication.MessageBuffer")

   ù MetaDOS (siehe "TApplication.MetaDOS")

   ù MiNTActive (siehe "TApplication.MiNTActive")

   ù Multitasking (siehe "TApplication.Multitasking")

   ù MultiTOS (siehe "TApplication.MultiTOS")

   ù Name (siehe "TApplication.Name")

   ù OSBAvailable (siehe "TApplication.OSBAvailable")

   ù RscPtr (siehe "TApplication.RscPtr")

   ù SpeedoActive (siehe "TApplication.SpeedoActive")

   ù Status (siehe "TApplication.Status")

   ù vdiHandle (siehe "TApplication.vdiHandle")

   ù workIn (siehe "TApplication.workIn")

   ù workOut (siehe "TApplication.workOut")

   ù XAcc (siehe "TApplication.XAcc")

   ù XAccList (siehe "TApplication.XAccList")

Methoden

   ù Init (siehe "TApplication.Init")

   ù Done (siehe "TApplication.Done")

   ù ACClose (siehe "TApplication.ACClose")

   ù ACOpen (siehe "TApplication.ACOpen")

   ù Alert (siehe "TApplication.Alert")

   ù APDragDrop (siehe "TApplication.APDragDrop")

   ù APTerm (siehe "TApplication.APTerm")

   ù At (siehe "TApplication.At")

   ù AutoFolder (siehe "TApplication.AutoFolder")

   ù AVExit (siehe "TApplication.AVExit")

   ù AVInsert (siehe "TApplication.AVInsert")

   ù AVProtokoll (siehe "TApplication.AVProtokoll")

   ù AVSendKey (siehe "TApplication.AVSendKey")

   ù AVStartProg (siehe "TApplication.AVStartProg")

   ù Broadcast (siehe "TApplication.Broadcast")

   ù BubbleHelp (siehe "TApplication.BubbleHelp")

   ù CanClose (siehe "TApplication.CanClose")

   ù CHExit (siehe "TApplication.CHExit")

   ù ChkError (siehe "TApplication.ChkError")

   ù ChkSpeedoError (siehe "TApplication.ChkSpeedoError")

   ù Copy (siehe "TApplication.Copy")

   ù Cut (siehe "TApplication.Cut")

   ù DDFinished (siehe "TApplication.DDFinished")

   ù DDGetPath (siehe "TApplication.DDGetPath")

   ù DDGetPreferredTypes (siehe "TApplication.DDGetPreferredTypes")

   ù DDHeaderReply (siehe "TApplication.DDHeaderReply")

   ù DDReadArgs (siehe "TApplication.DDReadArgs")

   ù DDReadData (siehe "TApplication.DDReadData")

   ù Delete (siehe "TApplication.Delete")

   ù DeskRedraw (siehe "TApplication.DeskRedraw")

   ù DrawMenu (siehe "TApplication.DrawMenu")

   ù Error (siehe "TApplication.Error")

   ù ExecDialog (siehe "TApplication.ExecDialog")

   ù ExitGEM (siehe "TApplication.ExitGEM")

   ù FindApplication (siehe "TApplication.FindApplication")

   ù FirstApplication (siehe "TApplication.FirstApplication")

   ù FirstIcon (siehe "TApplication.FirstIcon")

   ù FirstWndThat (siehe "TApplication.FirstWndThat")

   ù ForEachWnd (siehe "TApplication.ForEachWnd")

   ù FreeIcon (siehe "TApplication.FreeIcon")

   ù FreeMenu (siehe "TApplication.FreeMenu")

   ù FreeResource (siehe "TApplication.FreeResource")

   ù GetAddr (siehe "TApplication.GetAddr")

   ù GetClipboard (siehe "TApplication.GetClipboard")

   ù GetCrsRect (siehe "TApplication.GetCrsRect")

   ù GetCurrInstance (siehe "TApplication.GetCurrInstance")

   ù GetEvent (siehe "TApplication.GetEvent")

   ù GetFImagePtr (siehe "TApplication.GetFImagePtr")

   ù GetFString (siehe "TApplication.GetFString")

   ù GetFStringPtr (siehe "TApplication.GetFStringPtr")

   ù GetGPWindow (siehe "TApplication.GetGPWindow")

   ù GetIconTitle (siehe "TApplication.GetIconTitle")

   ù GetMenuEntries (siehe "TApplication.GetMenuEntries")

   ù GetMsTimer (siehe "TApplication.GetMsTimer")

   ù GetPTopWindow (siehe "TApplication.GetPTopWindow")

   ù GetPWindow (siehe "TApplication.GetPWindow")

   ù GetXAccAttr (siehe "TApplication.GetXAccAttr")

   ù HandleAV (siehe "TApplication.HandleAV")

   ù HandleButton (siehe "TApplication.HandleButton")

   ù HandleDragDrop (siehe "TApplication.HandleDragDrop")

   ù HandleError (siehe "TApplication.HandleError")

   ù HandleKeybd (siehe "TApplication.HandleKeybd")

   ù HandleM1 (siehe "TApplication.HandleM1")

   ù HandleM2 (siehe "TApplication.HandleM2")

   ù HandleMenu (siehe "TApplication.HandleMenu")

   ù HandleMesag (siehe "TApplication.HandleMesag")

   ù HandleTimer (siehe "TApplication.HandleTimer")

   ù HandleXAcc (siehe "TApplication.HandleXAcc")

   ù IconPaint (siehe "TApplication.IconPaint")

   ù IconSelect (siehe "TApplication.IconSelect")

   ù IndexOf (siehe "TApplication.IndexOf")

   ù InitApplication (siehe "TApplication.InitApplication")

   ù InitGEM (siehe "TApplication.InitGEM")

   ù InitInstance (siehe "TApplication.InitInstance")

   ù InitMainWindow (siehe "TApplication.InitMainWindow")

   ù InitResource (siehe "TApplication.InitResource")

   ù InstallDesktop (siehe "TApplication.InstallDesktop")

   ù InvalidateRect (siehe "TApplication.InvalidateRect")

   ù IsIconified (siehe "TApplication.IsIconified")

   ù LoadIcon (siehe "TApplication.LoadIcon")

   ù LoadMenu (siehe "TApplication.LoadMenu")

   ù LoadResource (siehe "TApplication.LoadResource")

   ù MessageLoop (siehe "TApplication.MessageLoop")

   ù MNSelected (siehe "TApplication.MNSelected")

   ù MUButton (siehe "TApplication.MUButton")

   ù MUKeybd (siehe "TApplication.MUKeybd")

   ù MUM1 (siehe "TApplication.MUM1")

   ù MUM2 (siehe "TApplication.MUM2")

   ù MUMesag (siehe "TApplication.MUMesag")

   ù MURBoxChanged (siehe "TApplication.MURBoxChanged")

   ù MURubbox (siehe "TApplication.MURubbox")

   ù MUTimer (siehe "TApplication.MUTimer")

   ù NextApplication (siehe "TApplication.NextApplication")

   ù NextIcon (siehe "TApplication.NextIcon")

   ù Paste (siehe "TApplication.Paste")

   ù Popup (siehe "TApplication.Popup")

   ù Quit (siehe "TApplication.Quit")

   ù RemoveDesktop (siehe "TApplication.RemoveDesktop")

   ù ResChCompleted (siehe "TApplication.ResChCompleted")

   ù RestoreModalDialog (siehe "TApplication.RestoreModalDialog")

   ù Rubbox (siehe "TApplication.Rubbox")

   ù Run (siehe "TApplication.Run")

   ù SCChanged (siehe "TApplication.SCChanged")

   ù SelectAll (siehe "TApplication.SelectAll")

   ù SendWndMessage (siehe "TApplication.SendWndMessage")

   ù SetQuit (siehe "TApplication.SetQuit")

   ù SetupVDI (siehe "TApplication.SetupVDI")

   ù ShutCompleted (siehe "TApplication.ShutCompleted")

   ù SHWDraw (siehe "TApplication.SHWDraw")

   ù Terminate (siehe "TApplication.Terminate")

   ù VAProtoStatus (siehe "TApplication.VAProtoStatus")

   ù VAStart (siehe "TApplication.VAStart")

   ù XAccAcc (siehe "TApplication.XAccAcc")

   ù XAccExit (siehe "TApplication.XAccExit")

   ù XAccID (siehe "TApplication.XAccID")

   ù XAccIMG (siehe "TApplication.XAccIMG")

   ù XAccInsert (siehe "TApplication.XAccInsert")

   ù XAccKey (siehe "TApplication.XAccKey")

   ù XAccMeta (siehe "TApplication.XAccMeta")

   ù XAccText (siehe "TApplication.XAccText")

Vorfahre

   ù TEventObject

Nachfahren

     -


4.1.1  TApplication.aesHandle
-----------------------------

Deklaration

     aesHandle: integer;  (nur lesen)

Beschreibung

     Enth„lt das Handle der vom AES benutzten VDI-Workstation.
     Wird von TApplication.InitGEM per graf_handle() ermittelt.
     Normalerweise braucht man diesen Wert nicht verwenden, da er
     haupts„chlich fr die (automatisch durchgefhrte) VDI-
     Initialisierung ben”tigt wird.


4.1.2  TApplication.apDTA
-------------------------

Deklaration

     apDTA: DTA;

Beschreibung

     Wenn das Programm nicht als Accessory gestartet wurde, wird
     der Datei-šbertragungs-Puffer von TApplication.Init auf
     apDTA gesetzt, damit z.B. auch zu einem sp„teren Zeitpunkt
     noch auf die Kommandozeile zugegriffen werden kann (diese
     wrde sonst bei Dateioperationen zerst”rt werden).


4.1.3  TApplication.apID
------------------------

Deklaration

     apID: integer;  (nur lesen)

Beschreibung

     Wird von TApplication.InitGEM auf die mit appl_init()
     ermittelte Identifikationsnummer der Applikation gesetzt.
     Ein Wert<0 signalisiert einen Fehler (dann wird das Programm
     allerdings automatisch abgebrochen).


4.1.4  TApplication.apName
--------------------------

Deklaration

     apName: PString;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf den eigenen Namen des
     Programms gesetzt, evtl. mit Leerzeichen auf eine L„nge von
     8 Zeichen gebracht und mit einem Nullbyte abgeschlossen.

     Unter alten TOS-Versionen und bei Accessories kann der Name
     u.U. nicht korrekt ausgewertet werden.


4.1.5  TApplication.apPath
--------------------------

Deklaration

     apPath: PString;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf das Arbeitsverzeichnis des
     Programms (incl. Laufwerksangabe und abschlieendem '\')
     gesetzt.

     Unter alten TOS-Versionen und bei Accessories kann der Name
     u.U. nicht korrekt ausgewertet werden.


4.1.6  TApplication.Attr
------------------------

Deklaration

     Attr: TGEMAttr;

Beschreibung

     Diverse Attribute und Werte der Applikation sind in diesem
     Record zusammengefat. Wird von TApplication.Init
     initialisiert.

     PGEMAttr = ^TGEMAttr;
     TGEMAttr = record
          EventMask,
          Instance   : integer;  (nur lesen)
          Style      : longint;
          Country    : word;
          rpTail,                (nur lesen)
          rpCmd      : PString;  (nur lesen)
          sysFonts,              (nur lesen)
          addFonts,              (nur lesen)
          charSWidth,            (nur lesen)
          charSHeight,           (nur lesen)
          boxSWidth,             (nur lesen)
          boxSHeight,            (nur lesen)
          charWidth,
          charHeight,
          boxWidth,
          boxHeight,
          MaxPX,                 (nur lesen)
          MaxPY,                 (nur lesen)
          PixW,                  (nur lesen)
          PixH,                  (nur lesen)
          Colors,                (nur lesen)
          MaxColors,             (nur lesen)
          Planes     : integer;  (nur lesen)
          PopChar    : char
     end;

     EventMask gibt an, auf welche GEM-Ereignisse das Programm
     mit TApplication.GetEvent warten soll. Wird mit MU_MESAG or
     MU_KEYBD or MU_BUTTON besetzt; wenn MultiTOS aktiv ist, wird
     auch noch MU_TIMER eingefgt (wird intern ben”tigt). Dieses
     Feld kann fr eigene Zwecke ver„ndert werden, allerdings
     sollte man sich genau berlegen, ob dies wirklich sein mu,
     da fast alle Ereignisse schon von ObjectGEM behandelt werden
     (z.B. werden auch MU_M1 und MU_M2 intern tempor„r
     verwendet).

     Instance zeigt an, wie oft sich das Programm im Speicher
     befindet (z.B. gleichzeitig als Accessory und als Programm,
     1=nur einmal). Null bedeutet, da kein korrekter Wert
     ermittelt werden konnte. Siehe hierzu auch
     TApplication.GetCurrInstance und TApplication.FirstInstance.

     In Style werden diverse globale Eigenschaften des Programms
     zusammengefat. Standardm„ig wird hier as_GrowShrink or
     as_MenuSeparator or as_MoveDials or as_HandleShutdown or
     as_DesktopWindow or as_3DFlags or as_UseHomeDir eingetragen.
     Ver„nderungen dieser Bitmap sollten in der Methode
     TApplication.InitInstance vorgenommen werden.

     Country gibt die Landessprache des Betriebssystems an, die
     dann auch von ObjectGEM verwendet wird. Z.Z. werden nur FRG
     und SWG gesondert behandelt, ansonsten werden englische
     Texte verwendet.

     rpTail enth„lt eine dem Programm evtl. bergebene
     Kommandozeile, rpCmd den Namen des Programms incl. Pfad- und
     Laufwerksangabe. nil bedeutet, da der jeweilige Wert nicht
     ermittelt werden konnte. sysFonts gibt die Anzahl der fest
     im System eingebundenen GEM-Fonts an (wird von
     TApplication.Init gesetzt). In addFonts tr„gt
     TApplication.SetupVDI die Anzahl der nachgeladenen
     Zeichens„tze ein. Das Programm kann also auf
     sysFonts+addFonts Zeichens„tze zurckgreifen.

     charSWidth, charSHeight, boxSWidth und boxSHeight werden von
     TApplication.InitGEM auf die Rckgabewerte von graf_handle()
     gesetzt. Die folgenden vier Felder geben die Gr”en des
     aktuell verwendeten Fonts an und sollten bei Font„nderungen
     auf die neuen Werte gesetzt werden.

     MaxPX und MaxPY geben die aktuelle Aufl”sung an. Nach
     M”glichkeit sollte man allerdings andere Werte (z.B.
     GetDesk) verwenden.

     PixW und PixH werden (wie die beiden vorhergehenden Werte)
     von TApplication.Init besetzt; sie geben die Gr”e einen
     Pixels in mm/1000 an. Colors gibt die Anzahl der
     vordefinierten Farben an; diese ist auch unter TrueColor
     nicht h”her als 256! MaxColors gibt die Anzahl aller
     verfgbaren Farben an (0=mehr als 32767, kontinuierliche
     Verteilung; 2=monochrom); hiermit sind alle vorhandenen
     Farbabstufungen gemeint, also Vorsicht! Wenn man beim
     Erkennen einer bestimmten Farbtiefe absolut sicher gehen
     will, mu man Planes auswerten (1=monochrom etc.). Die
     Anzahl der gleichzeitig darstellbaren Farben berechnet sich
     aus 2^Planes.

     PopChar wird von TComboBox fr das Zeichen benutzt, mit dem
     das Popup-Men ge”ffnet werden kann. Atari hat dafr #240
     vorgeschlagen; durchgesetzt hat sich aber #2 (Pfeil nach
     unten), was deshalb auch default ist.


4.1.7  TApplication.FirstInstance
---------------------------------

Deklaration

     FirstInstance: boolean;  (nur lesen)

Beschreibung

     Zeigt mit true an, da diese Instanz des Programms die erste
     im Speicher war; wenn also MYTEST.ACC im Bootlaufwerk
     installiert ist und auf dem Desktop noch MYTEST.PRG
     gestartet wird, ist nur bei dem Accessory FirstInstance auf
     true gesetzt.

     Nur bei der ersten Instanz eines Programms wird
     TApplication.InitApplication aufgerufen, wo dann
     grundlegende Initialisierungen durchgefhrt werden k”nnen.
     Alle anderen Einstellungen, die jede Instanz fr sich
     ben”tigt, mssen daher in der immer aufgerufenen
     TApplication.InitInstance-Methode vorgenommen werden.


4.1.8  TApplication.GDOSActive
------------------------------

Deklaration

     GDOSActive: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf true gesetzt, wenn irgendeine
     GDOS-Erweiterung (NVDI, AMCGDOS etc.) installiert ist, d.h.
     wenn u.a. die erweiterten Routinen fr Bitmap-Fonts
     vorhanden sind.


4.1.9  TApplication.FPUAvailable
--------------------------------

Deklaration

     FPUAvailable: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf true gesetzt, wenn ein
     mathematischer Coprozessor vorhanden ist. Dafr werden ein
     evtl. vorhandener _FPU-Cookie und die Variable Test68881 aus
     der System-Unit ausgewertet. Die Art der FPU (68881/68882)
     ist nicht festgelegt.


4.1.10  TApplication.OSBAvailable
---------------------------------

Deklaration

     OSBAvailable: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf true gesetzt, wenn das VDI
     Offscreen-Bitmaps untersttzt. Das ist z.B. bei NVDI ab
     Version 2.5 der Fall (sowie beim VDI-Enhancer-Patch).


4.1.11  TApplication.Icon
-------------------------

Deklaration

     Icon: PIcon;  (nur lesen)

Beschreibung

     Enth„lt einen Zeiger auf ein TIcon-Objekt, wenn der Applika-
     tion ein Icon mit TApplication.LoadIcon zugewiesen wurde und
     die Applikation gerade ikonifiziert ist.

     Wird von TApplication.Init auf nil gesetzt.


4.1.12  TApplication.IsQSBUsed
------------------------------

Deklaration

     IsQSBUsed: boolean;

Beschreibung

     Ist dieses Feld true, wird der AES-"Quarter Screen Buffer"
     zur Zeit intern von ObjectGEM belegt, d.h. die Applikation
     darf ihn unter gar keinen Umst„nden anderweitig verwenden.
     Zur Verwendung des Puffers mu man folgendermaen vorgehen:

     wind_update(BEG_UPDATE);
     if Application^.IsQSBUsed then
       { Speicher anders anfordern, z.B. mit getmem }
     else
       begin
          GetQSB(p,len);
          if (p<>nil) and (len>=benoetigte_groesse) then
            begin
              Application^.IsQSBUsed:=true;
              { hier kann der Puffer nun benutzt werden;
                es k”nnen auch ObjectGEM-Routinen aufge-
                rufen werden, da diese die Belegung des
                Puffers beachten }
              Application^.IsQSBUsed:=false
            end
          else
            { Speicher anders anfordern }
       end;
     wind_update(END_UPDATE);


4.1.13  TApplication.MainWindow
-------------------------------

Deklaration

     MainWindow: PWindow;  (nur lesen)

Beschreibung

     MainWindow ist die Liste der dem Applikationsobjekt
     untergeordneten Fenster. Das Feld wird mit nil
     initialisiert, und jedes Fenster klinkt sich bei dessen
     Initialisierung hier ein; das "Hauptfenster" der Application
     sollte dies normalerweise in TApplication.InitMainWindow
     tun. Mit den Routinen TApplication.FirstWndThat und
     TApplication.ForEachWnd kann man diese Liste recht einfach
     durchlaufen.


4.1.14  TApplication.menuID
---------------------------

Deklaration

     menuID: integer;  (nur lesen)

Beschreibung

     Wird das Programm als Accessory oder unter MultiTOS
     gestartet, tr„gt es sich mit menu_register() im "Desk"-Men
     ein. Die dort zurckgelieferte Kennung wird in menuID
     eingetragen. -1 bedeutet, da ein Fehler aufgetreten ist,
     was bei einem Accessory zum automatischen Programmabbruch
     fhrt. menuID wird normalerweise nur intern verwendet (z.B.
     von TApplication.ACOpen).


4.1.15  TApplication.MenuTree
-----------------------------

Deklaration

     MenuTree: PTree;  (nur lesen)

Beschreibung

     Zeigt auf den Objektbaum des Dropdown-Mens, wenn der Appli-
     kation ein solches mittels TApplication.LoadMenu zugewiesen
     wurde.


4.1.16  TApplication.MessageBLen
--------------------------------

Deklaration

     MessageBLen: integer;  (nur lesen)

Beschreibung

     Gibt die L„nge in Bytes einer erweiterten GEM-Message an.
     Null bedeutet, da die aktuelle Nachricht eine "normale"
     L„nge von 16 Bytes hat (bzw. da gar keine Nachricht
     vorliegt). Der Wert wird zusammen mit MessageBuffer von
     TApplication.MUMesag gesetzt.


4.1.17  TApplication.MessageBuffer
----------------------------------

Deklaration

     MessageBuffer: pointer;  (nur lesen)

Beschreibung

     Zeigt auf einen Puffer, in dem eine erweiterte GEM-Nachricht
     mit der L„nge MessageBLen steht. nil bedeutet, da keine
     erweiterte Message vorliegt. Der Puffer wird automatisch am
     Anfang von TApplication.MUMesag angelegt und mit appl_read()
     gefllt, wenn eine erweiterte Nachricht erkannt wird. Ein
     evtl. schon vorhandener Puffer wird in diesem Fall wieder
     freigegeben.

     Alle Standard-Nachrichten haben eine normale L„nge von 16
     Bytes, sind also nicht erweitert. Die Auswertung einer
     erweiterten Nachricht sollte in TApplication.HandleMesag
     oder in der Methode TEvent.TestMessage eines abgeleiteten
     TEvent-Objektes erfolgen.


4.1.18  TApplication.MetaDOS
----------------------------

Deklaration

     MetaDOS: PMetaInfo;  (nur lesen)

Beschreibung

     Wenn MetaDOS nil ist, ist kein Meta-DOS installiert.
     Ansonsten zeigt das Feld auf folgende Struktur:

     PMetaInfo = ^TMetaInfo;
     TMetaInfo = record
          Version: string;
          Drives : longint
     end;

     Version bezeichnet den Namen und die Versionsnummer des
     verwendeten Meta-DOS. Drives enth„lt eine Bitmap der Meta-
     DOS-Laufwerke (A=0, B=1 etc.). Wird von TApplication.Init
     gesetzt.


4.1.19  TApplication.MiNTActive
-------------------------------

Deklaration

     MiNTActive: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf true gesetzt, wenn
     MiNTVersion einen Wert gr”er Null zurckgibt, d.h. wenn die
     Multitasking-Erweiterung MiNT installiert ist.

     GEM-Programme sind allerdings normalerweise darauf
     angewiesen, da auch MultiTOS vorhanden ist.


4.1.20  TApplication.MultiTOS
-----------------------------

Deklaration

     MultiTOS: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.InitGEM auf true gesetzt, wenn das
     Multitasking-Betriebssystem MultiTOS installiert ist.

     Wenn das Programm allerdings nur die Dateifunktionen einer
     Multitasking-Umgebung ben”tigt, kann auch MiNTActive
     ausgewertet werden.


4.1.21  TApplication.Multitasking
---------------------------------

Deklaration

     Multitasking: boolean;  (nur lesen)

Beschreibung

     Gibt an, ob das AES mehrere Applikationen gleichzeitig (und
     vor allem gleichberechtigt) ausfhren kann.

     Die Anzahl dieser Applikationen betr„gt mind. 2, ber
     Besonderheiten des Multitasking-Betriebssystems ist hiermit
     nichts gesagt!


4.1.22  TApplication.MemoryProtection
-------------------------------------

Deklaration

     MemoryProtection: boolean;  (nur lesen)

Beschreibung

     Wir von TApplication.Init auf true gesetzt, wenn Mxalloc()
     vorhanden ist und auch mit den Memory-Protection-Flags
     aufgerufen werden darf.

     Dieses Flag sagt nichts ber das Vorhandensein von Memory
     Protection aus, man kann sich lediglich sicher sein, da
     dann ein Aufruf von Mxalloc() keine Bomben produziert!

     Im Moment wird dafr nur die Anwesenheit von MiNT getestet,
     da z.Z. keine weiteren Testm”glichkeiten bestehen. Sp„ter
     wird auch Mag!C bercksichtigt.


4.1.23  TApplication.RscPtr
---------------------------

Deklaration

     RscPtr: PRsFile;  (nur lesen)

Beschreibung

     Zeigt auf die sich im Speicher befindliche Resource-Datei
     des Programms, wenn eine solche mittels
     TApplication.LoadResource geladen bzw. mit
     TApplication.InitResource zugewiesen wurde. Normalerweise
     ben”tigt man diesen Pointer nicht.


4.1.24  TApplication.SpeedoActive
---------------------------------

Deklaration

     SpeedoActive: boolean;  (nur lesen)

Beschreibung

     Wird von TApplication.Init auf true gesetzt, wenn SpeedoGDOS
     installiert ist, d.h. wenn das Programm auf Vektorfonts
     zurckgreifen kann.

     Falls das (nie ausgelieferte) FSM-GDOS installiert ist, wird
     false zurckgegeben.


4.1.25  TApplication.Status
---------------------------

Deklaration

     Status: integer;

Beschreibung

     Enth„lt den Fehler-Status der Applikation. em_OK (bzw.
     irgendein nichtnegativer Wert) bedeutet, da kein Fehler
     aufgetreten ist.

     TApplication.MessageLoop wird nur betreten, wenn Status
     gr”er gleich em_OK ist, und wieder verlassen, sobald Status
     einen Wert kleiner em_OK enth„lt. Damit das Programm nicht
     auch bei evtl. behebbaren Fehlern abbricht, kann die Methode
     TApplication.HandleError berschrieben werden.


4.1.26  TApplication.vdiHandle
------------------------------

Deklaration

     vdiHandle: integer;  (nur lesen)

Beschreibung

     Enth„lt das VDI-Handle der Applikation, das von
     TApplication.InitGEM mit v_opnvwk() ermittelt wird. Mit
     diesem Handle kann das Programm korrekte Grafik-Ausgaben
     machen.

     Ein Wert kleiner Null signalisiert einen Fehler, das
     Programm wird in diesem Fall automatisch beendet.

     TWindow-Objekte besitzen normalerweise eine eigene VDI-
     Workstation im Feld TWindow.vdiHandle!


4.1.27  TApplication.workIn
---------------------------

Deklaration

     workIn: workin_ARRAY;

Beschreibung

     Dieses Array wird von TApplication.InitGEM zum ™ffnen der
     VDI-Workstation ben”tigt. Danach kann es fr eigene Zwecke
     verwendet werden.


4.1.28  TApplication.workOut
----------------------------

Deklaration

     workOut: workout_ARRAY;

Beschreibung

     Dieses Array wird von TApplication.InitGEM fr die
     Rckgabewerte von v_opnvwk() ben”tigt. Danach kann es fr
     eigene Zwecke verwendet werden, da alle wichtigen Werte von
     TApplication.Init anderweitig gespeichert werden.


4.1.29  TApplication.Name
-------------------------

Deklaration

     Name: PString;  (nur lesen)

Beschreibung

     Enth„lt den an TApplication.Init bergebenen Namen der Ap-
     plikation, der u.a. zur genauen Identifikation verwendet
     wird.

     Auerdem verwenden Accessories und Programme unter MultiTOS
     max. 17 Zeichen dieses Namens als Meneintrag (die
     ben”tigten Leerzeichen werden automatisch eingefgt!).


4.1.30  TApplication.XAcc
-------------------------

Deklaration

     XAcc: TXAccAttr;  (nur lesen)

Beschreibung

     XAcc beschreibt die XAcc-Parameter der eigenen Applikation,
     die zum Versenden an andere Applikationen ben”tigt werden.

     Der Record wird in TApplication.Init mittels
     TApplication.GetXAccAttr eingelesen.


4.1.31  TApplication.AVServer
-----------------------------

Deklaration

     AVServer: integer;  (nur lesen)

Beschreibung

     Enth„lt die AES-ID des AV-Servers, wenn ein solcher
     existiert, ansonsten id_No. Unter "normalem" TOS kann nur
     das Hauptprogramm AV-Server sein.

     TApplication.VAProtoStatus ermittelt AVServer, unter
     MultiTOS wird dies von TApplication.Init erledigt: Zun„chst
     wird nach dem Proze "GEMINI" gesucht, dann nach dem Proze
     "AVSERVER". Wenn dies nicht zum Erfolg gefhrt hat, wird
     schlielich noch die Environment-Variable AVSERVER
     ausgewertet.


4.1.32  TApplication.Clipboard
------------------------------

Deklaration

     Clipboard: PClipboard;  (nur lesen)

Beschreibung

     Zeigt auf das mit der Applikation verknpfte TClipboard-
     Objekt (oder ist nil, wenn ein solches nicht existiert).

     Wird mit TApplication.GetClipboard gesetzt.


4.1.33  TApplication.XAccList
-----------------------------

Deklaration

     XAccList: PCollection;  (nur lesen)

Beschreibung

     XAccList enth„lt alle angemeldeten XAcc-Applikationen in
     Form von TXAccAttr-Records. Das Feld wird von
     TApplication.Init zun„chst auf nil gesetzt und dann von
     TApplication.XAccInsert verwaltet. Beim Verlassen des
     Programms wird an alle in dieser Liste eingetragenen Appli-
     kationen eine ACC_EXIT-Message geschickt.

     Wichtig: Auch w„hrend des Programmablaufs kann XAccList nil
     sein, falls z.B. alle anderen XAcc-Programme terminiert
     haben!


4.1.34  TApplication.Init
-------------------------

Deklaration

     constructor Init(AName: string);

Beschreibung

     Ruft den Vorfahren TEventObject.Init auf. Danach wird
     Application auf @self gesetzt und - wenn das Programm nicht
     als Accessory gestartet wurde - der Datei-šbertragungs-
     Puffer auf apDTA. TApplication.Name wird auf AName gesetzt.

     Dann werden die Felder Attr.Country, FPUAvailable,
     OSBAvailable, SpeedoActive sowie MiNTActive ermittelt,
     MetaDOS wird ausgefllt und InitGEM aufgerufen.

     Ist Status an dieser Stelle gr”er gleich em_OK, wird die
     Initialisierung fortgesetzt, und fr alle weiteren Aktionen
     in dieser Methode wird eine wind_update()-Schachtelung
     vorgenommen (wichtig fr Accessories).

     Dann wird XAcc mittels GetXAccAttr eingelesen.
     TApplication.Attr wird komplett ausgefllt, apPath, apName
     und GDOSActive werden ermittelt und TApplication.GetClip-
     board sowie TApplication.SetupVDI aufgerufen. Ist Status
     immer noch gr”er gleich em_OK, wird schlielich
     InitInstance aufgerufen. Handelt es sich allerdings um die
     erste Instanz des Programms im Speicher, wird vorher noch
     InitApplication aufgerufen.

     Unter MultiTOS wird schlielich mit Broadcast die ACC_ID-
     Message an alle AES-Prozesse geschickt, auerdem wird
     AVServer ermittelt.


4.1.35  TApplication.Done
-------------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Alle Fenster der MainWindow-Liste werden freigegeben. Wenn
     die MessageLoop-Schleife mind. einmal durchlaufen wurde,
     wird dann dem Programm mit der Methode
     TApplication.Terminate eine M”glichkeit geboten, evtl.
     Deinstallationen vorzunehmen. Dann wird ClosePrivateProfile
     aufgerufen, damit evtl. vorgenommene nderungen noch
     gespeichert werden. Danach wird an alle in der XAccList
     eingetragenen Programme eine ACC_EXIT-Message geschickt.
     Wenn das Programm als Accessory gestartet wurde und MultiTOS
     nicht installiert ist, verf„llt das Programm an dieser
     Stelle in einer Endlosschleife mittels evnt_timer(),
     ansonsten werden TApplication.ExitGEM und TEventObject.Done
     aufgerufen.


4.1.36  TApplication.ACClose
----------------------------

Deklaration

     function ACClose(mID,Why: integer): integer;
                                            virtual;

Beschreibung

     Wird aufgerufen, wenn das Accessory vom Betriebssystem
     geschlossen wird.

     Wenn mID mit TApplication.menuID bereinstimmt (sollte immer
     der Fall sein, da ObjectGEM-Programme normalerweise nur max.
     einen Meneintrag belegen), werden alle Fenster aus der
     MainWindow-Liste mittels TWindow.RawDestroy freigegeben.

     Mit dem Rckgabewert kann die Methode melden, ob beim
     Schlieen des Accessories irgend etwas schiefgelaufen ist
     (Wert<>0), standardm„ig wird aber em_OK zurckgegeben.

     In Why wird unter MultiTOS der Grund fr das Schlieen des
     Accessories angegeben; unter alten TOS-Versionen bergibt
     TApplication.MUMesag hier einfach AC_CLOSE.

     Zum Schlu wird (unter einem Singletasking-TOS) die XAccList
     freigegeben, AVServer auf id_No gesetzt und an das
     Hauptprogramm eine ACC_ID- und eine AV_PROTOKOLL-Message
     geschickt.


4.1.37  TApplication.ACOpen
---------------------------

Deklaration

     procedure ACOpen(mID: integer); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn der Benutzer
     den Accessory-Eintrag im Desk-Men anw„hlt und das Accessory
     damit ”ffnet.

     Wenn mID mit TApplication.menuID bereinstimmt (sollte immer
     der Fall sein), werden alle bereits erzeugten Fenster
     ge”ffnet; Fenster, die noch nicht erzeugt sind, bei denen
     aber das Flag cs_CreateOnAccOpen gesetzt ist, werden erzeugt
     und ge”ffnet. Anschlieend werden alle modalen Dialoge
     nacheinander mittels TDialog.Execute abgearbeitet.


4.1.38  TApplication.Alert
--------------------------

Deklaration

     function Alert(AParent: PWindow; DefBtn: integer;
       Sign: longint; Txt,Btn: string): integer; virtual;

Beschreibung

     Ersetzt den AES-Aufruf form_alert() durch eine m„chtigere
     Routine. ObjectGEM-Alertboxen sind Tastatur-bedienbar, mit
     der Maus verschiebbar, und sie verwenden nach M”glichkeit
     (ein-)farbige Icons. In AParent kann der Pointer auf das
     Fenster bergeben werden, zu dem die Alertbox geh”rt (sonst
     nil). Die Box wird dann automatisch relativ zu diesem
     Fenster zentriert.

     DefBtn gibt die Nummer (1,2,...) des Buttons an, der mit
     <Return> angew„hlt werden kann. Null bedeutet, da es keinen
     solchen Default-Button gibt. Sign bestimmt das Icon, das in
     der Box verwendet wird (NO_ICON=0, NOTE=1, WAIT=2, STOP=3).
     Wird hier ein Wert gr”er $7fff bergeben, wird er als
     Pointer auf eine BITBLK-Struktur aufgefat, d.h. hiermit
     k”nnen eigene Icons benutzt werden. Wichtig:
     Selbstdefinierte Icons mssen im ger„tespezifischen Format
     (FF_DEVSPEC) vorliegen! Wenn sich diese in der Resourcedatei
     des Programms befinden, nimmt ObjectGEM diese Anpassung
     allerdings automatisch in InitResource bzw. LoadResource
     vor. Txt gibt den Text der Alertbox an. Die einzelnen Zeilen
     werden durch '|' getrennt. Theoretisch k”nnen bis zu 18
     Zeilen mit bis zu 255 Zeichen angezeigt werden, allerdings
     wird ein automatischer Zeilenumbruch durchgefhrt, wenn die
     Alertbox fr die aktuelle Aufl”sung sonst zu breit wrde
     (aus "„sthetischen" Grnden ist auerdem die max. L„nge
     einer Zeile auf 50 Zeichen beschr„nkt). In Btn schlielich
     werden die durch '|' getrennten Buttons bergeben (max. 12,
     wesentlich besser ist aber eine Zahl<=4). Die Hotkeys werden
     - wie bei den Dialogelementen - mit einem vorangestellten
     '&' markiert.

     Die Rckgabe ist id_No, wenn die Alertbox aus irgendeinem
     Grund nicht ausgefhrt werden konnte. Ein Wert gr”er Null
     gibt die Nummer des angew„hlten Buttons an.


4.1.39  TApplication.APDragDrop
-------------------------------

Deklaration

     procedure APDragDrop(PipeID,OrgID,WindID,mX,
                           mY,KStat: integer); virtual;

Beschreibung

     Verteilt eine Drag&Drop-Anfrage an das zust„ndige Fenster
     bzw. die Applikation.

     Wenn dem GEM-Handle WindID ein ObjectGEM-Fenster zugeordnet
     werden kann (das sollte immer der Fall sein), wird die
     entsprechende TWindow.WMDragDrop-Methode aufgerufen;
     ansonsten wird die Anfrage an TApplication.HandleDragDrop
     weitergeleitet. PipeID gibt die Nummer der Pipe an; aus
     dieser Nummer kann der zugeh”rige Dateiname errechnet
     werden. OrgID ist die AES-Applikations-Kennung des
     anfragenden Programms, WindID ist die GEM-Kennung des
     Fensters, auf das gedroppt wurde. ObjectGEM wertet die Daten
     in dieser Methode allerdings bereits aus, so da die
     aufgerufenen Methoden ein Handle der ge”ffneten Pipe
     erhalten.

     mX, mY und KStat geben die Position der Maus und den Zustand
     der Umschalttasten beim Aufruf an. APDragDrop sorgt dafr,
     da w„hrend der in ihr stattfindenden Aktionen das MiNT-
     Signal SIGPIPE ignoriert wird, damit das Programm nicht
     f„lschlicherweise vom Betriebssystem beendet wird. Wichtig:
     Innerhalb dieser Methode ist die von TApplication.MUMesag
     mit wind_update() gesetzte Bildschirm-Sperre ausgeschaltet,
     um einen sonst m”glichen Deadlock zu verhindern.

     Wenn DDReadData oder DDReadArgs aufgerufen wurde und true
     zurckgegeben hat, wird - nachdem die Pipe geschlossen und
     der Bildschirm wieder blockiert wurde - DDFinished
     aufgerufen, wo man nun auf die gelesenenen Daten reagieren
     kann.


4.1.40  TApplication.APTerm
---------------------------

Deklaration

     function APTerm(Why: integer): integer; virtual;

Beschreibung

     Diese Methode wird von TApplication.MUMesag aufgerufen, um
     festzustellen, ob die Applikation (unter MultiTOS) fr einen
     Shutdown beendet werden kann. Wenn em_OK zurckgegeben wird,
     setzt MUMesag das Feld TApplication.Status auf em_Terminate,
     d.h. das Programm wird abgebrochen (ohne den Anwender zu
     fragen). Ansonsten wird dem Betriebssystem das Scheitern des
     Shutdowns gemeldet.

     Standardm„ig macht APTerm nichts anderes, als em_OK
     zurckzugeben.


4.1.41  TApplication.At
-----------------------

Deklaration

     function At(Index: integer): PWindow;

Beschreibung

     Liefert einen Zeiger auf das Fenster mit der fortlaufenden
     Nummer Index in der MainWindow-Liste (begonnen wird bei
     Null).

     Wenn Index negativ oder MainWindow leer ist, wird nil
     zurckgegeben. Bei zu groen Werten wird die Liste zyklisch
     durchlaufen.


4.1.42  TApplication.IndexOf
----------------------------

Deklaration

     function IndexOf(Item: PWindow): integer;

Beschreibung

     Liefert die fortlaufende Nummer des Fensterobjekts, auf das
     Item zeigt, wenn dieses in der MainWindow-Liste vorkommt.
     Ansonsten wird -1 zurckgegeben.


4.1.43  TApplication.AutoFolder
-------------------------------

Deklaration

     function AutoFolder: boolean; virtual;

Beschreibung

     Wird von TApplication.InitGEM aufgerufen, wenn das Programm
     aus dem AUTO-Ordner heraus aufgerufen wurde; hier k”nnen
     dann also evtl. Systeminitialisierungen vorgenommen werden.
     Ist die Rckgabe false, wird eine entsprechende
     Fehlermeldung ausgegeben. Anschlieend wird das Programm auf
     jeden Fall beendet.

     Standardm„ig wird false zurckgegeben.


4.1.44  TApplication.Cut
------------------------

Deklaration

     procedure Cut; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<X> drckt.
     Standardm„ig passiert hier nichts.


4.1.45  TApplication.Delete
---------------------------

Deklaration

     procedure Delete; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Delete> drckt.
     Standardm„ig passiert hier nichts.


4.1.46  TApplication.Copy
-------------------------

Deklaration

     procedure Copy; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<C> drckt.
     Standardm„ig passiert hier nichts.


4.1.47  TApplication.Paste
--------------------------

Deklaration

     procedure Paste; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<V> drckt.
     Standardm„ig passiert hier nichts.


4.1.48  TApplication.SelectAll
------------------------------

Deklaration

     procedure SelectAll; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<A> drckt. Im
     Moment werden dann alle Icons des Desktops mit
     TApplication.IconSelect(true,id_No) angew„hlt.

     Hinweis: Da z.Z. noch kein TDesktop-Objekt existiert, kann
     diese Methode auch noch nicht sinnvoll eingesetzt werden.


4.1.49  TApplication.SendWndMessage
-----------------------------------

Deklaration

     function SendWndMessage(gHnd: integer;
                Msg: pointer; sID,Icn: boolean): boolean;
                                                virtual;

Beschreibung

     Schickt die 16 Bytes lange GEM-Message Msg an die Applikati-
     on, die das Fenster mit dem AES-Handle gHnd besitzt. Wird in
     gHnd ein Wert kleiner gleich Null bergeben, wird die
     Nachricht an die Applikation des Top-Fensters verschickt.

     Msg^[2] wird immer auf Null gesetzt, Msg^[3] auf gHnd (bzw.
     das Handle des Top-Fensters). Ist sID true, wird Msg^[1] auf
     TApplication.apID gesetzt. In Icn kann bergeben werden, ob
     die Message auch an ein ikonifiziertes Fenster geschickt
     werden soll (true). Anhand der Rckgabe kann man
     feststellen, ob die Message verschickt wurde (true) oder
     nicht (false).

     Wird vor allem fr das Men-Protokoll ben”tigt.


4.1.50  TApplication.Broadcast
------------------------------

Deklaration

     procedure Broadcast(Msg: pointer; sID: boolean);
                                                virtual;

Beschreibung

     Verschickt eine 16 Bytes lange GEM-Message an alle
     erreichbaren AES-Prozesse. Nach M”glichkeit wird dazu ein
     AES-Broadcast per shel_write(7,...) verwendet, alternativ
     wird auf appl_search() zurckgegriffen. Ist beides nicht
     vorhanden, wird die XAccList benutzt.

     Msg^[2] wird immer auf Null gesetzt. Ist sID true, wird
     Msg^[1] auf TApplication.apID gesetzt.


4.1.51  TApplication.BubbleHelp
-------------------------------

Deklaration

     procedure BubbleHelp(mX,mY: integer; Delay: word;
                                  Hlp: string); virtual;

Beschreibung

     Zeichnet an der Position mX,mY eine "BubbleHelp"-
     Sprechblase, in der der Hilfstext Hlp ausgegeben wird.

     Vor dem Verlassen der Hilfe wird mind. Delay Millisekunden
     lang gewartet (ObjectGEM verwendet als Standardwert 500),
     danach wird die Hilfe bei Mausklick oder Tastendruck
     verlassen. Der Text in Hlp kann mit '|' auf mehrere Zeilen
     verteilt werden, ansonsten wird aber auch ein automatischer
     Zeilenumbruch abh„ngig von der aktuellen Aufl”sung
     durchgefhrt.


4.1.52  TApplication.CanClose
-----------------------------

Deklaration

     function CanClose: boolean; virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn das
     Programm verlassen werden soll (hervorgerufen z.B. durch
     Quit). CanClose gibt true zurck, falls ein Beenden m”glich
     ist.

     Wurde die Applikation als Accessory unter einem "normalen"
     (nicht-multitasking) TOS gestartet, ist die Rckgabe immer
     false. Ansonsten werden alle offenen Fenster abgefragt; nur
     wenn alle Fenster bei ihrer CanClose-Methode true liefern,
     gibt auch TApplication.CanClose true zurck.


4.1.53  TApplication.SCChanged
------------------------------

Deklaration

     procedure SCChanged(OrgID: integer; Bits: word;
                                 Ext: string); virtual;

Beschreibung

     Die Message SC_CHANGED sollte von einer Applikation an alle
     anderen im System erreichbaren Applikationen verschickt
     werden, nachdem am Klemmbrett nderungen vorgenommen wurden.

     In OrgID erh„lt man die AES-Kennung der ver„ndernden Appli-
     kation, in Bits eine Bitmap der auf dem Klemmbrett
     gespeicherten Dateitypen und in Ext die Datei-Erweiterung
     der "besten" vorhandenen Datei (z.B. '.RTF'), damit beim
     Lesen m”glichst wenig Information verloren geht.

     Durch Auswertung von Bits braucht man das Klemmbrett nur
     auswerten, wenn die angegebenen Dateitypen berhaupt
     Verwendung finden k”nnen.


4.1.54  TApplication.CHExit
---------------------------

Deklaration

     procedure CHExit(ChID,ChRet: integer); virtual;

Beschreibung

     Wird aufgerufen, wenn die Applikation einen Child-Prozess
     gestartet hat und dieser wieder beendet wurde (unter
     MultiTOS).

     In ChID wird die AES-Kennung des Prozesses und in ChRet der
     Rckgabecode des Programms bergeben.


4.1.55  TApplication.ChkError
-----------------------------

Deklaration

     function ChkError: integer; virtual;

Beschreibung

     Liefert den ObjectGEM-Fehlerstatus zurck; eine
     entsprechende Fehlermeldung kann mit der Methode
     TApplication.Error angezeigt werden. Wichtig: Diese Methode
     liefert nicht den Inhalt des TApplication.Status-Feldes
     zurck, in dem nur die schwerwiegenden Fehler registriert
     werden; vielmehr kann man mit dieser Methode alle m”glichen
     ObjectGEM-Fehler abfragen.

     Nach der Abfrage wird der Zustand wieder auf em_OK
     zurckgesetzt.


4.1.56  TApplication.ChkSpeedoError
-----------------------------------

Deklaration

     function ChkSpeedoError: integer; virtual;

Beschreibung

     Wenn SpeedoGDOS installiert ist und bei der Verwendung ein
     Fehler auftritt, wird dieser nicht wie blich direkt auf den
     Bildschirm geschrieben. ObjectGEM f„ngt solche Fehlermeldun-
     gen n„mlich ab und macht sie dem Programm mit dieser Methode
     zug„nglich. Um ganz sicher zu gehen, sollte man theoretisch
     nach jedem Speedo-Aufruf den Fehlerstatus abfragen... Nach
     dem Aufruf wird der Status wieder auf Null gesetzt.

     Folgende Fehler k”nnen z.Z. auftreten:


         +----+--------------------------------------------+
         |  0 | kein Fehler aufgetreten                    |
         +----+--------------------------------------------+
         |  1 | Nicht ausreichend Fontdaten geladen        |
         +----+--------------------------------------------+
         |  3 | Unzul„ssige Font-Spezifikation angefordert |
         +----+--------------------------------------------+
         |  4 | Fontformat-Fehler                          |
         +----+--------------------------------------------+
         |  7 | "Rules requested"                          |
         +----+--------------------------------------------+
         |  8 | Fehler beim Lesen der Datei                |
         +----+--------------------------------------------+
         |  9 | Fehler beim ™ffnen der Datei               |
         +----+--------------------------------------------+
         | 10 | Font nicht angegeben                       |
         +----+--------------------------------------------+
         | 11 | Cache-Speicher voll                        |
         +----+--------------------------------------------+
         | 12 | Zeichendaten nicht verfgbar               |
         +----+--------------------------------------------+
         | 13 | Track-Kerning-Daten nicht verfgbar        |
         +----+--------------------------------------------+
         | 14 | Paar-Kerning-Daten nicht verfgbar         |
         +----+--------------------------------------------+
         | -1 | allgemeiner Speedo-Fehler                  |
         +----+--------------------------------------------+

     SpeedoGDOS ab 5.0 liefert fr Type1-Fehlermeldungen Werte
     zwischen 4000 und 4056, fr TrueType-Fehlermeldungen Werte
     zwischen 4096 und 5632.


4.1.57  TApplication.DDGetPath
------------------------------

Deklaration

     function DDGetPath(WindID: integer): string;
                                            virtual;

Beschreibung

     Wird von TApplication.HandleDragDrop aufgerufen, wenn der
     Sender den Datentyp 'PATH' gew„hlt hat, d.h. wenn er den
     Pfad der Applikation wissen m”chte.

     Im Moment wird hier ein Leerstring zurckgegeben, d.h. die
     Anfrage wird abgewiesen. Durch šberschreiben dieser Methode
     kann aber ein beliebiger Pfad zurckgegeben werden.

     In WindID erh„lt man die Kennung des Fensters, auf das
     gedroppt wurde (hier meist -1).


4.1.58  TApplication.DDGetPreferredTypes
----------------------------------------

Deklaration

     function DDGetPreferredTypes
                     (WindID: integer): string; virtual;

Beschreibung

     Liefert die Extensions der "bevorzugten" Dateien zurck. Es
     drfen maximal 8 Extensions geliefert werden, bei weniger
     Zeichen wird mit Nullbytes aufgefllt.

     Standardm„ig wird ein Leerstring zurckgegeben, d.h. alle
     Dateitypen werden ausprobiert. Eine genauere Rckgabe k”nnte
     z.B. '.RTF.TXT.DOC' lauten.


4.1.59  TApplication.DDHeaderReply
----------------------------------

Deklaration

     function DDHeaderReply(dType,dName,fName: string;
                         dSize: longint; OrgID,WindID,
                         mX,mY,KStat: integer): byte;
                                                virtual;

Beschreibung

     Wird von TApplication.HandleDragDrop aufgerufen, um dem
     Sender auf den vorgeschlagenen Dateityp zu antworten.

     In dType erh„lt man die Extension des vorgeschlagenen
     Dateityps (z.B. '.TXT'), in fName den entsprechenden
     Dateinamen (ohne Pfadangabe). In dName kann noch optional
     ein Name fr die Daten bergeben werden, der vom Empf„nger
     z.B. zum Beschriften eines Icons benutzt werden kann. dSize
     gibt die L„nge der zu bertragenden Datei an. WindID
     bezeichnet die Fenster-Kennung (meist -1), OrgID die AES-
     Kennung des Senders, mX und mY die Position der Maus und
     KStat den Zustand der Umschalttasten beim Aufruf.

     Standardm„ig wird DD_NAK zurckgegeben, folgende Werte sind
     z.Z. definiert:


       +--------------+--------------------------------------+
       | DD_OK        | alles OK; die Daten werden dann mit  |
       |              | TApplication.DDReadData eingelesen   |
       +--------------+--------------------------------------+
       | DD_NAK       | Fehler, Abbruch der Kommunikation    |
       +--------------+--------------------------------------+
       | DD_EXT       | der Sender soll einen anderen        |
       |              | Dateityp vorschlagen                 |
       +--------------+--------------------------------------+
       | DD_LEN       | der Empf„nger kann nicht so viele    |
       |              | Daten gleichzeitig verarbeiten       |
       +--------------+--------------------------------------+
       | DD_TRASH     | Datei wurde auf den Mlleimer ge-    |
       |              | zogen; der Sender mu entsprechend   |
       |              | reagieren                            |
       +--------------+--------------------------------------+
       | DD_PRINTER   | Datei wurde auf das Drucker-Icon     |
       |              | gezogen; der Sender mu entsprechend |
       |              | reagieren                            |
       +--------------+--------------------------------------+
       | DD_CLIPBOARD | Datei wurde auf das Klemmbrett-Icon  |
       |              | gezogen; der Sender mu entsprechend |
       |              | reagieren                            |
       +--------------+--------------------------------------+


4.1.60  TApplication.DDReadData
-------------------------------

Deklaration

     function DDReadData(dType,dName,fName: string;
                          dSize: longint; PipeHnd,
                          OrgID,WindID,mX,mY,
                          KStat: integer): boolean;
                                              virtual;

Beschreibung

     Wird von TApplication.HandleDragDrop aufgerufen, wenn eine
     Drag&Drop-Anfrage positiv beantwortet werden konnte und nun
     die Daten eingelesen werden sollen.

     In dType erh„lt man die Extension des vorgeschlagenen
     Dateityps (z.B. '.TXT'), in fName den entsprechenden
     Dateinamen (ohne Pfadangabe). In dName kann noch optional
     ein Name fr die Daten bergeben werden, der vom Empf„nger
     z.B. zum Beschriften eines Icons benutzt werden kann. dSize
     gibt die L„nge der zu bertragenden Datei an. WindID
     bezeichnet die Fenster-Kennung (meist -1), OrgID die AES-
     Kennung des Senders, mX und mY die Position der Maus und
     KStat den Zustand der Umschalttasten beim Aufruf.

     PipeHnd enth„lt das Dateihandle der ge”ffneten Pipe, auf die
     nun mit Fread() zugegriffen werden kann.

     Wenn die Daten eingelesen werden konnten, sollte true
     zurckgegeben werden, damit die Methode
     TApplication.DDFinished aufgerufen wird.


4.1.61  TApplication.DDReadArgs
-------------------------------

Deklaration

     function DDReadArgs(dSize: longint; PipeHnd,OrgID,
                  WindID,mX,mY,KStat: integer): boolean;
                                                virtual;

Beschreibung

     Wird von TApplication.HandleDragDrop aufgerufen, wenn der
     Sender den 'ARGS'-Datentyp, also eine Kommandozeile
     verschickt hat. In dieser Methode kann diese nun (per
     Fread()) eingelesen werden. Abschlieend mu noch die
     geerbte Methode mit dem um die Anzahl gelesener Zeichen
     verminderten dSize aufgerufen werden, damit die Pipe
     vollst„ndig geleert wird.

     Wenn in der Kommandozeile mehrere Parameter bergeben
     werden, sind die einzelnen Parameter durch ein Leerzeichen
     getrennt. Wenn in einem Parameter ein Leerzeichen vorkommt,
     wird dieser Parameter in einfache Anfhrungszeichen gesetzt.
     Anfhrungszeichen innerhalb des Parameters werden dann
     verdoppelt (z.B. "'Eric''s file'").

     Wenn die Daten eingelesen werden konnten, sollte true
     zurckgegeben werden, damit die Methode
     TApplication.DDFinished aufgerufen wird.


4.1.62  TApplication.DDFinished
-------------------------------

Deklaration

     procedure DDFinished(OrgID,WindID,mX,mY,
                            KStat: integer); virtual;

Beschreibung

     Wird von TApplication.APDragDrop aufgerufen, wenn
     TApplication.DDReadData oder TApplication.DDReadArgs true
     zurckgegeben hat. Der Aufruf erfolgt nach dem Drag&Drop-
     Protokoll, man hat also wieder volle Kontrolle ber den
     Bildschirm.

     In dieser Methode sollten die Eingelesenen Daten ausgewertet
     werden (Anzeige etc.).


4.1.63  TApplication.DeskRedraw
-------------------------------

Deklaration

     procedure DeskRedraw; virtual;

Beschreibung

     Zeichnet den Desktop (d.h. das Fenster mit der Kennung 0
     bzw. DESK) neu. Wird von InstallDesktop und RemoveDesktop
     automatisch aufgerufen.


4.1.64  TApplication.DrawMenu
-----------------------------

Deklaration

     procedure DrawMenu; virtual;

Beschreibung

     Zeichnet die Dropdown-Menleiste neu, wobei die
     Besonderheiten von MultiTOS beachtet werden. Wird von
     TApplication.LoadMenu aufgerufen.


4.1.65  TApplication.Error
--------------------------

Deklaration

     procedure Error(ErrorCode: integer); virtual;

Beschreibung

     Zeigt zu einer von TApplication.ChkError gelieferten
     Fehlernummer die passende Fehlermeldung in einer Alertbox
     an. Dabei wird die in Attr.Country ermittelte Landessprache
     beachtet. Z.Z. werden FRG und SWG gesondert behandelt,
     ansonsten werden englische Texte angezeigt.

     TApplication.Status und der mit ChkError abzufragende
     Fehlercode werden gepuffert.


4.1.66  TApplication.ExecDialog
-------------------------------

Deklaration

     function ExecDialog(ADialog: PDialog): integer;
                                               virtual;

Beschreibung

     Diese Methode dient zur einfachen Behandlung von Dialogen.
     Aufgrund einiger Einschr„nkungen sollten allerdings nach
     M”glichkeit die entsprechenden TDialog-Methoden verwendet
     werden.

     In ADialog wird ein Pointer auf ein bereits initialisiertes
     TDialog-Objekt bergeben. Der Dialog wird automatisch modal
     abgearbeitet und zum Parent-Objekt zentriert. Wichtig: Das
     Dialogobjekt wird nach der Bearbeitung freigegeben! Ein
     positiver Rckgabewert gibt den Index des Dialogelements an,
     mit dem der Dialog verlassen wurde; bei einem Fehler wird
     em_InvalidDialog zurckgegeben.


4.1.67  TApplication.ExitGEM
----------------------------

Deklaration

     procedure ExitGEM; virtual;

Beschreibung

     Wird von TApplication.Done aufgerufen, um das Programm
     korrekt beim Betriebssystem abzumelden. Zun„chst werden
     RemoveDesktop, TApplication.FreeIcon, TApplication.FreeMenu
     und FreeResource aufgerufen. Danach werden evtl. geladene
     GEM-Fonts freigegeben und die VDI-Workstation geschlossen.
     Zum Schlu wird appl_exit() aufgerufen.


4.1.68  TApplication.FindApplication
------------------------------------

Deklaration

     function FindApplication(AName: string;
                              AnID: integer;
                       var XAccAttr: TXAccAttr): boolean;
                                                 virtual;

Beschreibung

     Sucht eine Applikation in der XAccList. Bei erfolgreicher
     Suche wird true zurckgegeben und der in XAccAttr bergebene
     Record ausgefllt, ansonsten erh„lt man false als Rckgabe.

     Wenn AName nicht leer ist, wird der Name zur Suche verwendet
     (Achtung: Das ist der beim XAcc-Protokoll verwendete Name,
     der nicht mit dem Namen der Programmdatei bereinstimmen
     mu!), ansonsten wird die AES-Kennung AnID verwendet.


4.1.69  TApplication.FirstWndThat
---------------------------------

Deklaration

     function FirstWndThat
                (Test: PIterationFunc): PWindow;

Beschreibung

     FirstWndThat ruft fr jedes in der MainWindow-Liste
     eingetragene Fenster die durch Test bestimmte boolesche
     Funktion auf, bis Test true zurckgibt. FirstWndThat gibt
     dann den Zeiger auf das Fensterobjekt zurck, fr den Test
     true zurckgegeben hat, oder nil, falls Test immer false
     geliefert hat. Der Pointer Test sollte eine globale
     (Unterschied zu ObjectWindows!) Funktion sein, der ein
     pointer-Parameter bergeben wird und die boolean zurckgibt.
     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Test-Funktion nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     function IstOffen(p: pointer): boolean;
       { ... }

     IstOffen sollte eine globale Funktion sein.

     p:=Application^.FirstWndThat(@IstOffen);


4.1.70  TApplication.ForEachWnd
-------------------------------

Deklaration

     procedure ForEachWnd(Action: PIterationProc);

Beschreibung

     ForEachWnd ruft fr jedes in der MainWindow-Liste
     eingetragene Fenster die durch Action bestimmte Prozedur
     auf. Der Pointer Action sollte eine globale (Unterschied zu
     ObjectWindows!) Prozedur sein, der ein pointer-Parameter
     bergeben wird. Achtung: Im Gegensatz zu ObjectWindows kann
     bei einer lokalen Prozedur nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     procedure MacheGross(p: pointer);
       { ... }

     MacheGross sollte eine globale Prozedur sein.

     Application^.ForEachWnd(@MacheGross);


4.1.71  TApplication.FreeMenu
-----------------------------

Deklaration

     procedure FreeMenu; virtual;

Beschreibung

     Entfernt ein mit TApplication.LoadMenu installiertes
     Dropdown-Men. Wird von TApplication.ExitGEM automatisch
     aufgerufen.


4.1.72  TApplication.FreeResource
---------------------------------

Deklaration

     procedure FreeResource; virtual;

Beschreibung

     Gibt eine mit TApplication.LoadResource geladene bzw. mit
     TApplication.InitResource eingebundene Resource wieder frei.
     Wird von TApplication.ExitGEM aufgerufen.


4.1.73  TApplication.GetAddr
----------------------------

Deklaration

     function GetAddr(Indx: integer): PTree; virtual;

Beschreibung

     Ermittelt die Adresse des Objektbaumes mit dem Index Indx.
     Man sollte immer diese Methode und nicht rsrc_gaddr()
     verwenden, da GetAddr automatisch beachtet, ob die Resource
     mit InitResource oder mit LoadResource eingebunden wurde.


4.1.74  TApplication.GetClipboard
---------------------------------

Deklaration

     function GetClipboard: PClipboard; virtual;

Beschreibung

     Liefert das TClipboard-Objekt, das mit der Applikation
     verknpft wird. In dieser Methode wird ein TClipboard-Objekt
     neu instantiiert und ein Zeiger darauf zurckgegeben.

     Wird von TApplication.Init aufgerufen.


4.1.75  TApplication.GetCrsRect
-------------------------------

Deklaration

     procedure GetCrsRect(var crect: GRECT); virtual;

Beschreibung

     Liefert den Bereich zurck, in dem der Mauszeiger von
     ObjectGEM ver„ndert werden soll. Dies ist normalerweise der
     Arbeitsbereich des obersten Fensters, wenn bei diesem
     TWindow.Class.hCursor entsprechend gesetzt ist.

     Diese Methode wird intern von TApplication.GetEvent
     aufgerufen und sollte nicht berschrieben werden.


4.1.76  TApplication.GetCurrInstance
------------------------------------

Deklaration

     function GetCurrInstance: integer; virtual;

Beschreibung

     Gibt zurck, wie oft die Applikation im Speicher vorhanden
     ist. W„hrend TApplication.Attr.Instance angibt, als welche
     Instanz das Programm gestartet wurde, liefert
     GetCurrInstance den aktuellen Wert. Dieser kann vom
     Startwert durchaus verschieden sein, da ja zwischenzeitlich
     dasselbe Programm erneut gestartet worden sein k”nnte (z.B.
     unter MultiTOS).


4.1.77  TApplication.GetEvent
-----------------------------

Deklaration

     function GetEvent(var data: TEventData): integer;
                                                 virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, um auf GEM-
     Messages zu warten. Wenn ein Ereignis aufgetreten ist, mu
     die bergebene TEventData-Struktur entsprechend ausgefllt
     werden.

     Normalerweise wird in dieser Methode ein evnt_multi()-Aufruf
     durchgefhrt (siehe Beispiel). Man sollte daran nur etwas
     „ndern, wenn man genau wei, was man tut, und wenn sich dies
     nicht anders bewerkstelligen l„t, da sonst die etwas
     "trickreiche" (aber dennoch saubere) ObjectGEM-Verwaltung
     sehr leicht durcheinanderkommen kann.

Beispiel

     function TApplication.GetEvent(var data: TEventData): integer;
       var crect: GRECT;

       begin
         GetCrsRect(crect);
         GetEvent:=evnt_multi(Attr.EventMask,258,3,0,0,
                     crect.X,crect.Y,crect.W,crect.H,
                     1,crect.X,crect.Y,crect.W,crect.H,
                     data.Pipe,
                     GetMsTimer mod 65536,GetMsTimer div 65536,
                     data.mX,data.mY,
                     data.BStat,data.KStat,data.Key,
                     data.Clicks)
       end;


4.1.78  TApplication.GetFImagePtr
---------------------------------

Deklaration

     function GetFImagePtr(Indx: integer): pointer;
                                              virtual;

Beschreibung

     Ermittelt die Adresse des BITBLK-Elements mit dem Index
     Indx, das sich nicht in einem Dialogbaum befindet.

     Man sollte immer diese Methode und nicht rsrc_gaddr()
     verwenden, da GetFImagePtr automatisch beachtet, ob die
     Resource mit InitResource oder mit LoadResource eingebunden
     wurde.


4.1.79  TApplication.GetFString
-------------------------------

Deklaration

     function GetFString(Indx: integer): string; virtual;

Beschreibung

     Gibt die mit Indx bezeichnete freie Zeichenkette zurck.
     Sollte immer anstelle von GetFreeString verwendet werden.


4.1.80  TApplication.GetFStringPtr
----------------------------------

Deklaration

     function GetFStringPtr(Indx: integer): PChar;
                                             virtual;

Beschreibung

     Ermittelt die Adresse einer sog. "freien" Zeichenkette mit
     dem Index Indx; solche Strings befinden sich in einem
     speziellen Objektbaum und werden fr Texte verwendet, die im
     Programm auerhalb von Dialogen verwendet werden sollen.

     Man sollte immer diese Methode und nicht rsrc_gaddr()
     verwenden, da GetFStringPtr automatisch beachtet, ob die
     Resource mit InitResource oder mit LoadResource eingebunden
     wurde.


4.1.81  TApplication.GetGPWindow
--------------------------------

Deklaration

     function GetGPWindow(gHnd: integer): PWindow;

Beschreibung

     Gibt den Pointer auf das Fensterobjekt mit der GEM-Kenung
     gHnd zurck, wenn ein solches Fenster (mit dem dazugeh”rigen
     Fensterobjekt) existiert, andernfalls nil.


4.1.82  TApplication.FirstApplication
-------------------------------------

Deklaration

     function FirstApplication(AType: TAppTypeMR;
                               GenName: string;
                       var XAccAttr: TXAccAttr): boolean;

Beschreibung

     Sucht auf Grundlage der XAccList nach bestimmten
     Programmtypen im Speicher. Diese Funktion ist haupts„chlich
     fr Multitasking-Systeme interessant, da hiermit eine
     Modularisierung des Systems erreicht werden kann (eine Art
     rudiment„re "Component Ware"). In AType kann ein
     maschinenlesbarer Programmtyp bergeben werden (siehe
     TXAccAttr), in GenName ein sog. "generischer Name". Gesetzte
     Parameter werden fr die Auswertung mit "und" verknpft.
     Wenn AType nicht ausgewertet werden soll, mu ' ' bergeben
     werden; in GenName bergibt man in so einem Fall einen
     Leerstring.

     Wenn keine passende Applikation gefunden wurde, wird false
     zurckgegeben, true sonst.


4.1.83  TApplication.NextApplication
------------------------------------

Deklaration

     function NextApplication
                   (var XAccAttr: TXAccAttr): boolean;

Beschreibung

     Liefert die n„chste auf die bei FirstApplication angegebenen
     Werte passende Applikation im Speicher, wenn eine solche
     vorhanden ist (die Rckgabe ist dann true).

     Wenn keine gewnschte Applikation mehr vorhanden ist, wird
     false zurckgegeben.


4.1.84  TApplication.GetMenuEntries
-----------------------------------

Deklaration

     procedure GetMenuEntries(var Entries: TMenuEntries);
                                                virtual;

Beschreibung

     Diese Methode wird fr das Men-Protokoll ben”tigt. Sie wird
     von TApplication.LoadMenu aufgerufen; standardm„ig wird
     hier die Struktur Entries nur ausgenullt.

     Man kann (und sollte) aber die passenden Indizes von
     Meneintrag und -titel zuweisen, damit man sich nicht mehr
     um das Weiterleiten von z.B. <Control>+<V> an die passende
     Paste-Methode zu kmmern braucht.

     In der Praxis sieht es also so aus, da man die
     entsprechenden Meneintr„ge ("Drucken", "Kopieren",
     "Schlieen" etc.) in der Menleiste der Applikation zur
     Verfgung stellt, in dieser Methode dann die Indizes
     eintr„gt, und ab dann braucht man sich um diese Menpunkte
     nicht mehr zu kmmern!

     Wichtig: Das Men-Protokoll bezieht sich nur auf die Appli-
     kations-Menleiste, nicht aber auf eine Fenster-Menleiste!

     Folgenden Eintr„gen kann z.Z. eine Funktion zugeordnet
     werden (die Namen sollten selbsterkl„rend sein):

     PMenuEntries = ^TMenuEntries;
     TMenuEntries = record
          Close,
          Print,
          Cut,
          Copy,
          Paste,
          Delete,
          SelectAll,
          Quit,
          Full,
          Cycle    : TMenuEntry
     end;

     PMenuEntry = ^TMenuEntry;
     TMenuEntry = record
          Entry,
          Title: integer
     end;


4.1.85  TApplication.GetMsTimer
-------------------------------

Deklaration

     function GetMsTimer: longint; virtual;

Beschreibung

     Gibt die Anzahl der Millisekunden zurck, auf die fr ein
     Timer-Ereignis gewartet werden soll. Standardm„ig ist dies
     genau eine Sekunde. Diese Zahl ist allerdings nur dann
     wirksam, wenn in TApplication.Attr.EventMask das Bit
     MU_TIMER gesetzt ist, was unter MultiTOS der Fall ist (wird
     intern ben”tigt).

     GetMsTimer wird von TApplication.GetEvent aufgerufen.


4.1.86  TApplication.GetPTopWindow
----------------------------------

Deklaration

     function GetPTopWindow: PWindow;

Beschreibung

     Gibt einen Zeiger auf das Fensterobjekt des obersten
     Fensters zurck, wenn dieses zu der ObjectGEM-Applikation
     geh”rt, ansonsten nil.


4.1.87  TApplication.GetPWindow
-------------------------------

Deklaration

     function GetPWindow(Hnd: HWnd): PWindow;

Beschreibung

     Gibt den Pointer auf das Fensterobjekt mit der ObjectGEM-
     Kennung Hnd zurck, wenn ein solches Fensterobjekt
     existiert, andernfalls nil.

     Der Unterschied zu TApplication.GetGPWindow ist, da ein
     Fensterobjekt immer eine ObjectGEM-interne Kennung besitzt,
     aber kein GEM-Handle belegen zu braucht (z.B. modale
     Dialoge). Wenn man nach Fensterobjekten sucht, sollte man
     also GetPWindow verwenden. Ben”tigt man aber unbedingt ein
     zugeh”riges GEM-Fenster, mu man GetGPWindow verwenden.


4.1.88  TApplication.GetXAccAttr
--------------------------------

Deklaration

     procedure GetXAccAttr(var XAccAttr: TXAccAttr);
                                               virtual;

Beschreibung

     Wird von TApplication.Init dazu verwendet, das Feld XAcc
     auszufllen.

     Standardm„ig wird TXAccAttr.Version auf 0, MsgGroups auf 3
     und AppTypeMR auf einen Leerstring gesetzt, TXAccAttr.apID,
     TXAccAttr.menuID und TXAccAttr.Name auf die entsprechenden
     Felder des Applikations-Objekts. Alle anderen Pointer werden
     auf nil gesetzt.

     Protocol wird mit PROTO_XACC+PROTO_AV vorbelegt, AVSrvMsg
     mit MSG_SENDKEY or MSG_STARTPROG or MSG_EXIT und AVAccMsg
     mit MSG_START.

     Diese Methode mu berschrieben werden, wenn dem Programm
     spezielle XAcc-Eigenschaften zugewiesen werden sollen.


4.1.89  TApplication.HandleAV
-----------------------------

Deklaration

     procedure HandleAV(Pipe: Pipearray); virtual;

Beschreibung

     Wird aufgerufen, wenn TApplication.MUMesag eine AV-Proto-
     koll-Meldung erh„lt. ObjectGEM wertet nur die Messages
     AV_PROTOKOLL, VA_PROTOSTATUS und AV_EXIT aus, alle anderen
     Nachrichten mssen - wenn das Protokoll verstanden werden
     soll - in dieser Methode ausgewertet werden.

     Eine Dokumentation des AV-Protokolls findet sich in der
     Beschreibung des Shareware-Desktops GEMINI.


4.1.90  TApplication.HandleButton
---------------------------------

Deklaration

     procedure HandleButton(mX,mY,BStat,KStat,
                             Clicks: integer); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn ein dort
     eintreffender Mausklick nicht verarbeitet werden konnte.
     Standardm„ig werden hier nur evtl. vorhandene Icons mit
     IconSelect deselektiert. In mX und mY wird die Position des
     Klicks, in Clicks die Anzahl, in BStat die gedrckte
     Maustaste (1=links, 2=rechts) und in KStat der Zustand der
     Umschalttasten bergeben.


4.1.91  TApplication.HandleDragDrop
-----------------------------------

Deklaration

     procedure HandleDragDrop(PipeHnd,OrgID,WindID,mX,
                            mY,KStat: integer); virtual;

Beschreibung

     Wird von TApplication.APDragDrop aufgerufen, wenn die
     Drag&Drop-Anfrage keinem Fenster zugeordnet werden konnte.

     Zun„chst wird die Anfrage positiv beantwortet. Dann werden
     die von TApplication.DDGetPreferredTypes gelieferten
     Dateitypen bermittelt. Nachdem sich der Sender auf einen
     Dateityp festgelegt hat, wird darauf mit dem von
     TApplication.DDHeaderReply ermittelten Wert reagiert. Wenn
     sich Sender und Empf„nger einigen konnten, werden dann mit
     TApplication.DDReadData die Daten gelesen, ansonsten wird
     die Drag&Drop-Anfrage abgewiesen oder ein neuer Dateityp
     verlangt.

     Verschickt der Sender den 'ARGS'-Datentyp, wird automatisch
     die Methode TApplication.DDReadArgs aufgerufen. Wenn der
     Sender allerdings den Applikationspfad wissen m”chte, wird
     dieser mit TApplication.DDGetPath zurckgeliefert.

     PipeHnd ist das Dateihandle der ge”ffneten Pipe, auf die mit
     Fwrite(), Fread() etc. zugegriffen werden kann. OrgID ist
     die AES-Applikations-Kennung des Senders, WindID ist die
     GEM-Kennung des Fensters, auf das gedroppt wurde (in dieser
     Methode meist -1, d.h. die Applikation an sich ist gemeint).
     mX, mY und KStat geben die Position der Maus und den Zustand
     der Umschalttasten beim Aufruf an.


4.1.92  TApplication.HandleError
--------------------------------

Deklaration

     procedure HandleError; virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Fehler aufgetreten ist. Falls das Programm den Fehler
     beheben kann, sollte es TApplication.Status auf em_OK
     zurcksetzen, damit es nicht beendet wird.

     Standardm„ig sorgt diese Methode dafr, da em_OutOfMemory
     ignoriert wird.


4.1.93  TApplication.HandleKeybd
--------------------------------

Deklaration

     procedure HandleKeybd(Stat,Key: integer); virtual;

Beschreibung

     Wird von TApplication.MUKeybd aufgerufen, wenn das
     aufgetretene Tastaturereignis nicht verarbeitet werden
     konnte.

     Normalerweise leitet diese Methode den Tastendruck an
     TWindow.WMKeyDown des obersten Fensters weiter (oder, wenn
     as_XInputMode gesetzt ist, an das Fenster unter dem
     Mauszeiger).

     In Stat wird der Status der Umschalttasten und in Key der
     VDI-Tastencode bergeben.

     Wurde der Tastendruck nicht ausgewertet, wird eine
     entsprechende AV_SENDKEY-Message an den AV-Server geschickt.


4.1.94  TApplication.HandleM1
-----------------------------

Deklaration

     procedure HandleM1(mX,mY,BStat,KStat: integer); virtual;

Beschreibung

     Wird von TApplication.MUM1 aufgerufen, wenn das Mausereignis
     dort nicht verarbeitet werden konnte (was normalerweise der
     Fall ist).

     Diese Methode wird intern zum Ver„ndern des Mauscursors ber
     dem Fensterarbeitsbereich verwendet und sollte deshalb nicht
     berschrieben werden.


4.1.95  TApplication.HandleM2
-----------------------------

Deklaration

     procedure HandleM2(mX,mY,BStat,KStat: integer); virtual;

Beschreibung

     Wird von TApplication.MUM2 aufgerufen, wenn das Mausereignis
     dort nicht verarbeitet werden konnte (was normalerweise der
     Fall ist).

     Diese Methode wird intern zum Ver„ndern des Mauscursors ber
     dem Fensterarbeitsbereich verwendet und sollte deshalb nicht
     berschrieben werden.


4.1.96  TApplication.HandleMenu
-------------------------------

Deklaration

     procedure HandleMenu(meNum: integer); virtual;

Beschreibung

     Wird von TApplication.MNSelected aufgerufen, wenn fr den
     Meneintrag mit dem Index meNum kein zugeh”riges TEvent-
     Objekt vorhanden ist.

     Innerhalb dieser Methode kann dann eine case-Abfrage
     durchgefhrt werden. Nach M”glichkeit sollten allerdings
     TEvent-Objekte zum Einsatz kommen.

     HandleMenu macht standardm„ig gar nichts.


4.1.97  TApplication.HandleMesag
--------------------------------

Deklaration

     procedure HandleMesag(Pipe: Pipearray); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn die
     empfangene GEM-Message unbekannt ist und auch kein TEvent-
     Objekt etwas damit anfangen kann. Durch šberschreiben dieser
     Methode k”nnen z.B. eigene Nachrichten (mit Nummern ab
     $5000) verarbeitet werden.


4.1.98  TApplication.HandleTimer
--------------------------------

Deklaration

     procedure HandleTimer; virtual;

Beschreibung

     Wird von TApplication.MUTimer aufgerufen, wenn ein Timer-
     Ereignis auftritt. Standardm„ig passiert in dieser Methode
     nichts.


4.1.99  TApplication.HandleXAcc
-------------------------------

Deklaration

     procedure HandleXAcc(Pipe: Pipearray); virtual;

Beschreibung

     Wird aufgerufen, wenn TApplication.MUMesag eine XAcc-Proto-
     koll-Meldung erh„lt, die nicht von einer spezialisierten
     Methode verarbeitet werden kann. Das sind z.Z. die Meldungen
     ACC_OPEN, ACC_CLOSE und ACC_ACK.


4.1.100  TApplication.GetIconTitle
----------------------------------

Deklaration

     function GetIconTitle: string; virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn die gesamt
     Applikation ikonifiziert werden soll. Die Rckgabe dient als
     Fenstertitel des Icon-Fensters; standardm„ig wird
     TApplication.Name geliefert.

     Von der Rckgabe werden z.Z. allerdings nur die ersten 10
     (bzw. mit ICFS nur 8) Zeichen beachtet!


4.1.101  TApplication.IconPaint
-------------------------------

Deklaration

     procedure IconPaint(Work: GRECT;
                          var PaintInfo: TPaintStruct); virtual;

Beschreibung

     Wird aufgerufen, wenn das Icon-Fenster neu gezeichnet werden
     soll. In Work wird der Arbeitsbereich des Fensters
     bergeben, da das Applikationsobjekt ja keine Angaben ber
     das Icon-Fenster besitzt.

     Standardm„ig wird der Arbeitsbereich einfach nur wei
     gefllt. Die Verfahrensweise ist analog zu TWindow.Paint.


4.1.102  TApplication.IsIconified
---------------------------------

Deklaration

     function IsIconified: boolean;

Beschreibung

     Gibt true zurck, wenn die gesamte Applikation ikonifiziert
     ist, d.h. wenn alle Fenster in einem einzigen Icon-Fenster
     zusammengefat sind (erst ab AES 4.10 m”glich).


4.1.103  TApplication.InitApplication
-------------------------------------

Deklaration

     procedure InitApplication; virtual;

Beschreibung

     Wird von TApplication.Init aufgerufen, wenn es sich um die
     erste Instanz des Programms im Speicher handelt.

     Die Methode setzt zun„chst FirstInstance auf true und
     versucht dann, alle ObjectGEM-Applikationen ber den
     globalen 'GOBJ'-Cookie zu verketten.

     Wenn InitApplication berschrieben wird, sollte in der neuen
     Methode als erstes die geerbte Methode aufgerufen werden.


4.1.104  TApplication.InitGEM
-----------------------------

Deklaration

     procedure InitGEM; virtual;

Beschreibung

     Wird von TApplication.Init aufgerufen, um das Programm beim
     Betriebssystem anzumelden.

     Zun„chst wird TApplication.apID mit appl_init() ermittelt.
     Wenn das AES noch nicht aktiv ist, wird TApplication.Status
     auf em_AESNotActive gesetzt und das Programm damit
     abgebrochen. Vorher wird jedoch noch AutoFolder aufgerufen.

     Ansonsten werden danach unter MiNT/MultiTOS die Signale
     SIGTERM und SIGQUIT abgefangen. Dann werden die
     Kommandozeile und der Name des Programms ermittelt und
     Attr.rpCmd und Attr.rpTail entsprechend gesetzt.

     Schlielich werden aesHandle und TApplication.vdiHandle
     besetzt und somit eine VDI-Workstation ge”ffnet. Tritt hier
     ein Fehler auf, wird Status auf em_GEMInitFailure gesetzt.
     Bei einem Accessory oder einer MultiTOS-Applikation wird
     noch der Desk-Meneintrag auf TApplication.Name ge„ndert und
     TApplication.menuID gesetzt. Ist kein Platz fr ein
     Accessory mehr, wird Status auf em_AccInitFailure gesetzt.


4.1.105  TApplication.InitInstance
----------------------------------

Deklaration

     procedure InitInstance; virtual;

Beschreibung

     In dieser Methode werden normalerweise alle
     programmspezifischen Initialisierungen vorgenommen. Wird von
     TApplication.Init als letzte Aktion aufgerufen. Hier wird
     das TKeyMenu-Objekt zum Verlassen des Programms mit
     <Control>+<Q> installiert. Danach wird - wenn
     as_HandleShutdown gesetzt und MultiTOS aktiv ist - dem
     Betriebssystem die F„higkeit zum korrekten Shutdown
     mitgeteilt. Als letztes wird schlielich
     TApplication.InitMainWindow aufgerufen. Wenn diese Methode
     berschrieben wird, sollte die geerbte Methode dann
     aufgerufen werden, wenn alle Voraussetzungen dafr
     geschaffen sind, da dem ™ffnen des Hauptfensters nichts
     mehr im Weg steht.


4.1.106  TApplication.InitMainWindow
------------------------------------

Deklaration

     procedure InitMainWindow; virtual;

Beschreibung

     Wird von TApplication.InitInstance aufgerufen, um das
     Hauptfenster der Applikation zu ™ffnen. Standardm„ig wird
     ein einfaches TWindow-Objekt erzeugt, d.h. diese Methode
     wird eigentlich immer berschrieben.

     Man kann hier eigene Fenstertypen erzeugen (auch
     Fensterdialoge), oder - wenn das Programm zun„chst kein
     Fenster ”ffnen soll - gar nichts tun.

Beispiel

     procedure TApplication.InitMainWindow;

     begin
       new(PWindow,Init(nil,Name^));
       if (MainWindow=nil) or (ChkError<em_OK) then
         Status:=em_InvalidMainWindow
     end;


4.1.107  TApplication.InitResource
----------------------------------

Deklaration

     procedure InitResource(AddrHiRes,AddrLoRes: pointer); virtual;

Beschreibung

     Verknpft eine im Programm mit $L eingebundene Resource
     (siehe Beispielprogramme) mit der GEM-Applikation. Die
     Objektdateien (*.O) werden mit dem Programm BINOBJ erzeugt,
     das dem PurePascal-Paket beiliegt.

     In AddrHiRes wird der Pointer der Resource fr vertikale
     Aufl”sungen >=400 Pixel angegeben, in AddrLoRes der Pointer
     fr alle kleineren Aufl”sungen. Wenn das Programm nur eine
     Resource besitzt, setzt man den anderen Pointer einfach auf
     nil; ObjectGEM w„hlt immer die bestm”gliche Resource.

     InitResource pat alle Koordinaten an die aktuelle Aufl”sung
     an und wandelt alle Bitmaps in das ger„tespezifische Format.

     Man sollte Resourcedateien nach M”glichkeit direkt in das
     Programm einbinden, damit Accessories keine Probleme mit der
     Speicherplatzanforderung bekommen. Achtung: Wenn zwei
     Resourcedateien verwendet werden, mu man darauf achten, da
     die Indizes der entsprechenden Objekte gleich sind!

Beispiel

     Die Resource-Datei sei MYRSC.RSC, BINOBJ.TTP wird dann mit
     folgender Kommandozeile aufgerufen:

     myrsc.rsc myrsc.o MyResource

     Folgende Zeile wird in das Programm eingefgt:

     procedure MyResource; external; {$L myrsc.o}

     Eingebunden wird die Resource dann in der Methode
     TApplication.InitInstance:

     InitResource(@MyResource,nil);


4.1.108  TApplication.InstallDesktop
------------------------------------

Deklaration

     procedure InstallDesktop(tIndx,oIndx: integer); virtual;

Beschreibung

     Meldet fr die Applikation einen neuen Desktop an, dessen
     Hintergrundobjekt den Index oIndx im Objektbaum tIndx
     besitzt. Anschlieend wird der neue Desktop mit
     TApplication.DeskRedraw gezeichnet. Accessories k”nnen z.Z.
     noch keinen eigenen Desktop anmelden, InstallDesktop wird
     dann einfach ignoriert.

     Sp„ter wird auerdem noch eine automatische Verwaltung von
     Icons, Drag&Drop etc. dazukommen.


4.1.109  TApplication.InvalidateRect
------------------------------------

Deklaration

     procedure InvalidateRect(Wnd: HWnd; Rect: PGRECT); virtual;

Beschreibung

     Zeichnet den in Rect bergebenen Bereich des durch die
     ObjectGEM-Kennung angegebenen Fensters neu. Wird in Rect ein
     nil-Pointer bergeben, wird der gesamte Arbeitsbereich des
     Fensters aktualisiert. Das Neuzeichnen geschieht mit einer
     GEM-Message, wird also erst zu einem sp„teren Zeitpunkt
     durchgefhrt.


4.1.110  TApplication.LoadMenu
------------------------------

Deklaration

     procedure LoadMenu(Indx: integer); virtual;

Beschreibung

     Installiert die Dropdown-Menleiste im Objektbaum Indx.
     Zun„chst wird geprft, ob das Men auf dem Bildschirm
     komplett dargestellt werden kann. Ist dies der Fall, wird
     das Men gezeichnet, ansonsten gibt ChkError em_InvalidMenu
     zurck. Diese Methode sollte - falls ein Dropdown-Men
     verwendet wird - in TApplication.InitInstance aufgerufen
     werden.

     Wenn das Men korrekt installiert werden konnte, wird danach
     GetMenuEntries aufgerufen. Aus kompatibilit„tsgrnden (zu
     SetQuit) wird danach eine GOP_SETQUIT-Message verschickt.


4.1.111  TApplication.LoadResource
----------------------------------

Deklaration

     procedure LoadResource(FileHiRes,FileLoRes: string); virtual;

Beschreibung

     L„dt die Resourcedatei des Programms nach. In FileHiRes wird
     der Dateiname der Resource fr vertikale Aufl”sungen >=400
     Pixel angegeben, in AddrLoRes der Dateiname fr alle
     kleineren Aufl”sungen. Wenn das Programm nur eine Resource
     besitzt, bergibt man als anderen Dateinamen einfach einen
     Leerstring; ObjectGEM w„hlt immer die bestm”gliche Resource.

     LoadResource pat alle Koordinaten an die aktuelle Aufl”sung
     an und wandelt alle Bitmaps in das ger„tespezifische Format.

     Kann die Datei nicht gefunden werden, wird
     TApplication.Status auf em_RscNotFound gesetzt.

     Achtung: Wenn zwei Resourcedateien verwendet werden, mu man
     darauf achten, da die Indizes der entsprechenden Objekte
     gleich sind!


4.1.112  TApplication.LoadIcon
------------------------------

Deklaration

     procedure LoadIcon(icnTree,icnIndx: integer); virtual;

Beschreibung

     Weist das Icon mit dem Index icnIndx im Objektbaum icnTree
     der Applikation zu. Dieses Icon wird, wenn die gesamte Ap-
     plikation ikonifiziert wird, in dem Icon-Fenster
     dargestellt.

     Dialogobjekte nutzen ebenfalls dieses Icon, wenn ihnen kein
     eigenes Icon zugewiesen wurde.


4.1.113  TApplication.FreeIcon
------------------------------

Deklaration

     procedure FreeIcon; virtual;

Beschreibung

     Gibt das Feld TApplication.Icon frei, d.h. in dem Applikati-
     ons-Icon-Fenster wird kein Icon mehr dargestellt.


4.1.114  TApplication.MessageLoop
---------------------------------

Deklaration

     procedure MessageLoop; virtual;

Beschreibung

     Wird von TApplication.Run aufgerufen. Diese Methode ist die
     zentrale "Nachrichtenvermittlungsstelle" von ObjectGEM.

     Solange TApplication.Status gr”er gleich em_OK ist, wird
     mit TApplication.GetEvent auf eine GEM-Message gewartet. Je
     nach Ereignis wird dann MUKeybd, MUButton, MUM1, MUM2,
     MUMesag oder MUTimer aufgerufen. Wenn ein Fehler aufgetreten
     ist, wird zun„chst TApplication.HandleError aufgerufen. Wenn
     der Fehler nicht behoben werden konnte, wird das Programm
     beendet.

     Soll das Programm mit TApplication.Quit verlassen werden,
     wird an dieser Stelle TApplication.CanClose auf Gltigkeit
     berprft.


4.1.115  TApplication.MNSelected
--------------------------------

Deklaration

     procedure MNSelected(meNum,mtNum: integer;
                           Tree: PTree; PrIndx: integer); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn der Benutzer
     einen Meneintrag angew„hlt hat. In meNum wird der Index
     dieses Eintrags, in mtNum der Index des entsprechenden
     Mentitels bergeben.

     Unter neueren AES-Versionen wird in Tree der Zeiger auf den
     zugeh”rigen Objektbaum und in PrIndex der Index des dem
     Eintrag bergeordneten Objekts bergeben; unter alten AES-
     Versionen wird stattdessen nil bzw. 0 bergeben.

     Die Methode versucht, den Meneintrag mit einem TKeyMenu-
     Objekt zu verknpfen; ist fr den Eintrag kein derartiges
     Objekt vorhanden, wird die Methode TApplication.HandleMenu
     aufgerufen.

     MNSelected kmmert sich auerdem um das Invertieren des
     Mentitels.


4.1.116  TApplication.MUButton
------------------------------

Deklaration

     procedure MUButton(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Mausklick registriert wurde. Zuerst werden alle zum Applika-
     tionsobjekt geh”rigen TEvent-Objekte benachrichtigt. Wenn
     keines davon reagieren will, werden anschlieend die
     TEvent-Objekte des obersten Fensters abgefragt. Erst wenn
     auch hier keine positive Antwort erfolgt, wird der Klick an
     die Methode TWindow.WMButton weitergeleitet, wenn in den
     Arbeitsbereich eines Fensters geklickt wurde.

     Wurde stattdessen auf den Desktop geklickt, wird - sofern
     as_Rubbox gesetzt ist - TApplication.Rubbox aufgerufen, und
     dann evtl. TApplication.MURubbox verst„ndigt.

     Trifft keiner der o.g. F„lle zu, wird der Klick an
     TApplication.HandleButton weitergeleitet.


4.1.117  TApplication.MUKeybd
-----------------------------

Deklaration

     procedure MUKeybd(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Tastaturereignis aufgetreten ist. Die Methode versucht, fr
     die gedrckte Taste(nkombination) ein TKeyMenu-Objekt zu
     finden (so werden z.B. die Men-Shortcuts erkannt).

     Konnte kein solches Objekt gefunden werden (was bei
     "normalen" Tasten immer der Fall sein sollte, da diese nicht
     als Shortcuts verwendet werden sollten), wird
     TApplication.HandleKeybd aufgerufen. Standard-Shortcuts (^X,
     ^C, ^V, ^W etc.) werden allerdings abgefangen und geeignet
     interpretiert (d.h. an die zugeh”rigen Methoden
     weitergeleitet).


4.1.118  TApplication.MUM1
--------------------------

Deklaration

     procedure MUM1(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Mausereignis fr das erste Mausrechteck eingetreten ist.
     MUM1 versucht, fr das Ereignis ein TEvent-Objekt zu finden.

     Normalerweise sollte ein solches nicht existieren, da die
     beiden Mausrechtecke fr interne Zwecke verwendet werden. In
     einem solchen Fall wird die Methode TApplication.HandleM1
     aufgerufen.


4.1.119  TApplication.MUM2
--------------------------

Deklaration

     procedure MUM2(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Mausereignis fr das zweite Mausrechteck eingetreten ist.
     MUM2 versucht, fr das Ereignis ein TEvent-Objekt zu finden.

     Normalerweise sollte ein solches nicht existieren, da die
     beiden Mausrechtecke fr interne Zwecke verwendet werden. In
     einem solchen Fall wird die Methode TApplication.HandleM2
     aufgerufen.


4.1.120  TApplication.MUMesag
-----------------------------

Deklaration

     procedure MUMesag(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn das
     Programm eine GEM-Nachricht erh„lt.

     Zun„chst wird mit wind_update() eine Bildschirmblockierung
     fr die gesamte Methode durchgefhrt. Wenn data.Pipe[2]
     einen Wert gr”er Null enth„lt, werden MessageBuffer und
     MessageBLen entsprechend gesetzt, ansonsten sind sie nil
     bzw. 0.

     Danach versucht MUMesag, die in data.Pipe[0] bergebene
     Nachricht einer der folgenden Methoden zuzuordnen: ACClose,
     ACOpen, APDragDrop, APTerm, AVExit, AVProtokoll, CHExit,
     Copy, Cut, HandleAV, HandleXAcc, MNSelected, Paste, Print,
     ResChCompleted, SCChanged, SelectAll, ShutCompleted,
     SHWDraw, VAProtoStatus, WMArrowed, WMBottomed, WMClosed,
     WMFulled, WMHSlid, WMIconify, WMMoved, WMNewTop, WMOnTop,
     WMRedraw, WMShaded, WMSized, WMTopped, WMUniconify,
     WMUnshaded, WMUntopped, WMVSlid, XAccAcc, XAccExit, XAccID,
     XAccIMG, XAccKey, XAccMeta oder XAccText.

     Klappt dies nicht, wird versucht, die Nachricht an ein
     TEvent-Objekt weiterzuleiten. Scheitert auch dies, wird
     schlielich TApplication.HandleMesag aufgerufen.


4.1.121  TApplication.MURBoxChanged
-----------------------------------

Deklaration

     procedure MURBoxChanged(r: GRECT); virtual;

Beschreibung

     Wird von TApplication.Rubbox jedesmal dann aufgerufen, wenn
     sich die Gr”e der vom Benutzer im Fenster aufgezogenenen
     Rubbox „ndert. Dies kann z.B. dazu verwendet werden, um die
     aktuelle Gr”e, die in r bergeben wird, anzuzeigen etc.

     W„hrend des Aufrufs ist die Maus unsichtbar, und es liegt
     eine wind_update()-Schachtelung sowohl mit BEG_UPDATE als
     auch mit BEG_MCTRL vor. Ver„nderte VDI-Attribute mssen
     zurckgesetzt werden.


4.1.122  TApplication.MURubbox
------------------------------

Deklaration

     procedure MURubbox(r: GRECT); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn der Benutzer
     auf dem Desktop eine Rubbox aufgezogen hat. In r wird der
     ausgew„hlte Bereich bergeben.


4.1.123  TApplication.MUTimer
-----------------------------

Deklaration

     procedure MUTimer(data: TEventData); virtual;

Beschreibung

     Wird von TApplication.MessageLoop aufgerufen, wenn ein
     Timer-Ereignis aufgetreten ist. Macht im Moment nichts
     weiter, als TApplication.HandleTimer aufzurufen. Sp„ter
     werden hier allerdings die Fenster-Timer verwaltet.


4.1.124  TApplication.Popup
---------------------------

Deklaration

     function Popup(APopup: PPopup; x,y,
                      Flag: integer): integer; virtual;

Beschreibung

     Erm”glicht die einfache Abarbeitung eines TPopup-Objekts. In
     APopup wird der Pointer auf ein bereits initialisiertes
     Objekt bergeben, in x, y und Flag die Werte fr TPopup.pX,
     TPopup.pY und TPopup.pFlag. Letzterer ist normalerweise
     POP_CENTER. Nach der Bearbeitung wird das TPopup-Objekt
     freigegeben. Die Rckgabe entspricht der von TPopup.Execute.


4.1.125  TApplication.Quit
--------------------------

Deklaration

     procedure Quit; virtual;

Beschreibung

     Mu aufgerufen werden, wenn das Programm beendet werden soll
     (was dann am Ende des aktuellen Durchlaufs von MessageLoop
     geschieht).

     Intern wird TApplication.Status auf em_Quit gesetzt; dies
     sollte man allerdings nie selbst tun, sondern immer Quit
     verwenden!

     Wird von WMClosed aufgerufen, wenn cs_QuitOnClose gesetzt
     ist.


4.1.126  TApplication.RemoveDesktop
-----------------------------------

Deklaration

     procedure RemoveDesktop; virtual;

Beschreibung

     Entfernt einen mit TApplication.InstallDesktop angemeldeten
     Desktop, so da der ursprngliche Desktop wieder sichtbar
     wird.

     Wird von TApplication.ExitGEM aufgerufen.


4.1.127  TApplication.ResChCompleted
------------------------------------

Deklaration

     procedure ResChCompleted(Stat: integer); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn das Programm
     einen Aufl”sungswechsel initiiert hat (mit shel_write()
     Modus 5).

     Ist Stat=1, wurde der Wechsel bis jetzt erfolgreich beendet
     (d.h. keine Anwendung hat sich widersetzt). Nun mu sich das
     Programm nur noch selbst beenden, was ResChCompleted dadurch
     tut, indem TApplication.Status auf em_Terminate gesetzt
     wird. Der Benutzer hat also keine M”glichkeit mehr, dies zu
     Verhindern - wenn man einen Aufl”sungswechsel initiiert,
     sollte man also bereits wissen, ob die eigene Applikation
     beendet werden darf!


4.1.128  TApplication.RestoreModalDialog
----------------------------------------

Deklaration

     procedure RestoreModalDialog(p: PWindow); virtual;

Beschreibung

     Restauriert einen modalen Dialog, wenn aus diesem heraus ein
     weiterer Dialog aufgerufen und wieder beendet wurde. In p
     wird der Pointer auf das entsprechende Dialogobjekt
     bergeben. Nicht-modale Dialoge (und damit auch Fenster)
     werden automatisch beachtet.

     RestoreModalDialog wird von TDialog beim Verlassen eines
     modalen Dialogs und von FileSelect aufgerufen. Normalerweise
     braucht man diese Methode nicht selbst aufzurufen.


4.1.129  TApplication.Rubbox
----------------------------

Deklaration

     function Rubbox(WHnd,x,y,xmin,ymin,xmax,
                      ymax: integer; var r: GRECT): boolean; virtual;

Beschreibung

     Wird von TWindow.WMButton und TApplication.MUButton
     aufgerufen, wenn der Benutzer eine Rubbox ("Gummibandbox")
     aufziehen will. Rubbox kmmert sich um die komplette
     Abarbeitung eines solchen Vorgangs (incl. korrektem Zeichnen
     unter Beachtung der Rechteckliste und dem Selektieren evtl.
     vorhandener TIcon-Objekte).

     In WHnd wird die GEM-Kennung des betreffenden Fensters oder
     DESK fr das Desktop bergeben. x und y geben die Anfangs-
     Mausposition an, xmin, ymin, xmax und ymax die (absoluten)
     Koordinaten des Begrenzungsrechtecks.

     Das Abbrechen des Aufziehens der Rubbox kann durch Drcken
     der rechten Maustaste bei gedrckter linker Maustaste
     erreicht werden.

     Wurde das Aufziehen nicht abgebrochen und ist die Rubbox
     nicht nur ein Pixel gro, enth„lt r anschlieend die
     Endgr”e der Rubbox und die Methode gibt true zurck.
     Ansonsten erh„lt man false, und r wird nicht ver„ndert.

     W„hrend des Aufziehens wird bei einer nderung der Gr”e -
     abh„ngig von WHnd - entweder MURBoxChanged oder
     TWindow.WMRBoxChanged und TWindow.WMRBoxCheck des
     zugeh”rigen Fensters aufgerufen.


4.1.130  TApplication.Run
-------------------------

Deklaration

     procedure Run; virtual;

Beschreibung

     Ist normalerweise die einzige Methode (auer den Methoden
     TApplication.Init und TApplication.Done), die innerhalb des
     Hauptprogramms aufgerufen wird.

     Zuerst wird hier der Mauscursor mit ArrowMouse als Pfeil
     dargestellt. Wenn TApplication.Status einen nichtnegativen
     Wert enth„lt, wird danach TApplication.MessageLoop
     aufgerufen und damit das eigentliche Programm "gestartet".

     Auerdem wird TApplication.Terminate am Ende des Programms
     nur dann aufgerufen, wenn die Programmausfhrung erfolgreich
     bis zu diesem Punkt gelangt ist!

Beispiel

     program Minimal;

       var MyApp: TApplication;

     begin
       MyApp.Init('Minimal');
       MyApp.Run;
       MyApp.Done
     end.


4.1.131  TApplication.SetQuit
-----------------------------

Deklaration

     procedure SetQuit(mNum,tNum: integer); virtual;

Beschreibung

     Erm”glicht es, dem TKeyMenu-Objekt, das in der Methode
     TApplication.InitInstance zum Beenden des Programms durch
     <Control>+<Q> angelegt wird, den Meneintrag und den
     entsprechenden Titel zuzuweisen, mit dem das Programm
     alternativ verlassen werden kann. Als Programmierer braucht
     man sich dann nicht weiter darum zu kmmern. mNum und tNum
     sind die Indizes von Meneintrag und -titel. SetQuit mu -
     sofern es verwendet wird - in InitInstance nach dem Aufruf
     der geerbten Methode und TApplication.LoadMenu aufgerufen
     werden.

     Hinweis: Mittlerweile gibt es im Rahmen des Men-Protokolls
     mit GetMenuEntries eine elegantere L”sung, zu deren Gunsten
     SetQuit nicht mehr verwendet werden sollte!


4.1.132  TApplication.SetupVDI
------------------------------

Deklaration

     procedure SetupVDI; virtual;

Beschreibung

     Wird von TApplication.Init aufgerufen, um die VDI-
     Workstation mit festen Werten zu initialisieren. Zun„chst
     werden jedoch - wenn GDOSActive true und as_LoadFonts
     gesetzt ist - alle verfgbaren GEM-Fonts nachgeladen. Daraus
     folgt, da - wenn die Anwendung auf GEM-Zeichens„tze
     zurckgreifen will - SetupVDI berschrieben werden mu und
     die geerbte Methode erst dann aufgerufen werden darf, wenn
     man as_LoadFonts gesetzt hat!

     Danach werden folgende Werte gesetzt (Schreibweise
     abgekrzt): vswr_mode(MD_REPLACE), vsl_udsty($5555),
     vsl_type(LT_SOLID), vsf_perimeter(PER_ON), vsl_color(Black),
     vsl_ends(LE_SQUARED,LE_SQUARED), vsm_type(MT_DOT),
     vsm_height(1), vsm_color(Black), vst_rotation(0),
     vsf_style(4), vsf_color(Black),
     vst_alignment(TA_LEFT,TA_BASELINE), vsl_width(1),
     vst_color(Black), vsf_interior(FIS_HOLLOW),
     vst_effects(TF_NORMAL).

     Auerdem werden das Clipping auf die Gr”e des gesamten
     Desktops, vst_font() auf den ersten verfgbaren Font (das
     ist normalerweise der Systemzeichensatz) und dieser Font auf
     die "normale" H”he (d.h. die des "groen" Fonts auf dem
     Desktop) gesetzt.


4.1.133  TApplication.ShutCompleted
-----------------------------------

Deklaration

     procedure ShutCompleted(Stat,ErrID,ErrCode: integer); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn das Programm
     das System heruntergefahren hat (mittels shel_write() Modus
     4).

     Ist Stat=1, hat der Shutdown wie gewnscht funktioniert, die
     Applikation kann nun mit ihren Aktionen fortfahren (fr
     entsprechende Reaktionen sollte ShutCompleted daher
     berschrieben werden, da standardm„ig nichts geschieht).

     Andernfalls erh„lt man in ErrID die AES-ID des Programms,
     das den Shutdown nicht korrekt durchfhren konnte, und in
     ErrCode den Grund des Scheiterns in Form eines Fehlercodes.


4.1.134  TApplication.SHWDraw
-----------------------------

Deklaration

     procedure SHWDraw(Drive: integer); virtual;

Beschreibung

     Sollte von Applikationenan die System-Shell (den Desktop)
     geschickt werden, wenn auf einem Laufwerk Dateien ge„ndert
     wurden.

     Wenn man mit ObjectGEM eine Shell realisiert, erh„lt man in
     dieser Methode also eine solche Meldung und kann
     entsprechend z.B. mit dem Update des Laufwerksfensters
     reagieren. In Drive wird die Laufwerksnummer (A=0, B=1 etc.)
     bzw. -1 zum Update aller Laufwerke bergeben.


4.1.135  TApplication.Terminate
-------------------------------

Deklaration

     procedure Terminate; virtual;

Beschreibung

     Wird von TApplication.Done vor dem Verlassen des Programms
     (aber bereits nach dem Schlieen aller Fenster) aufgerufen,
     um eine korrekte Deinstallation zu erm”glichen.

     Diese Methode wird allerdings nur dann aufgerufen, wenn bis
     zum Aufruf von TApplication.Run keine Fehler aufgetreten
     sind, d.h. wenn die Installation geklappt hat.


4.1.136  TApplication.VAProtoStatus
-----------------------------------

Deklaration

     procedure VAProtoStatus(OrgID: integer; Msg: word;
                                 AName: string); virtual;

Beschreibung

     OrgID bezeichnet die AES-Kennung des AV-Servers, Msg ist
     eine Bitmap der verstandenen Nachrichten und AName enth„lt
     den Namen der Programmdatei. Die genaue Funktionsweise steht
     in der AV-Dokumentation und ist auch fr Programmierer an
     dieser Stelle unwichtig, da ObjectGEM die komplette
     Verwaltung bernimmt.


4.1.137  TApplication.AVExit
----------------------------

Deklaration

     procedure AVExit(OrgID: integer); virtual;

Beschreibung

     OrgID bezeichnet die AES-Kennung der Applikation, die nicht
     mehr am AV-Protokoll teilnimmt. Die genaue Funktionsweise
     steht in der AV-Dokumentation und ist auch fr Programmierer
     an dieser Stelle unwichtig, da ObjectGEM die komplette
     Verwaltung bernimmt.


4.1.138  TApplication.AVInsert
------------------------------

Deklaration

     function AVInsert(accID: integer; SrvMsg,
                        AccMsg: word; AName: string): boolean;
                                                        virtual;

Beschreibung

     Diese Methode wird immer dann aufgerufen, wenn sich eine
     neue AV-Applikation angemeldet hat. Wenn die Applikation
     bereits angemeldet ist (sollte nicht vorkommen), wird false
     zurckgegeben. Ansonsten ist die Rckgabe true, die Daten
     werden ausgewertet und in die XAccList eingetragen.

     Wenn man darauf wartet, da sich eine bestimmte Applikation
     ins System einklinkt, sollte man diese Methode berschreiben
     und nach Aufruf der geerbten Methode die XAccList auswerten.


4.1.139  TApplication.AVProtokoll
---------------------------------

Deklaration

     procedure AVProtokoll(OrgID: integer; Msg: word;
                                    AName: string); virtual;

Beschreibung

     OrgID bezeichnet die AES-Kennung des Accessories, Msg ist
     eine Bitmap der verstandenen Nachrichten und AName enth„lt
     den Namen der Programmdatei. Die genaue Funktionsweise steht
     in der AV-Dokumentation und ist auch fr Programmierer an
     dieser Stelle unwichtig, da ObjectGEM die komplette
     Verwaltung bernimmt.


4.1.140  TApplication.AVStartProg
---------------------------------

Deklaration

     procedure AVStartProg(OrgID,Ret: integer;
                            Prg,Cmd: string); virtual;

Beschreibung

     Nach dem Empfang dieser Message wird - sofern das Programm
     kein Acessory ist - die Applikation Prg mit
     Pexec(0,Prg,Cmd,nil) nachgestartet. Nach dem Start wird an
     den Absender der Ursprungsmessage eine VA_PROGSTART-Message
     mit dem Returncode Ret geschickt.


4.1.141  TApplication.AVSendKey
-------------------------------

Deklaration

     procedure AVSendKey(Stat,Key: integer); virtual;

Beschreibung

     Der in dieser Message empfangene Tastendruck wird direkt an
     MUKeybd weitergeleitet.


4.1.142  TApplication.VAStart
-----------------------------

Deklaration

     procedure VAStart(OrgID: integer; Cmd: string); virtual;

Beschreibung

     Das Accessory soll sich ”ffnen. rpTail wird auf Cmd gesetzt,
     danach wird ACOpen(menuID) aufgerufen.

     In OrgID erh„lt man die AES-ID der aufrufenden Shell (z.B.
     Gemini).


4.1.143  TApplication.XAccAcc
-----------------------------

Deklaration

     procedure XAccAcc(accID,mID: integer; Msg,
                        Ver: byte; pName: PChar); virtual;

Beschreibung

     accID bezeichnet die AES-Kennung des bei der
     Hauptapplikation angemeldeten Accessories (bzw. unter
     MultiTOS die Applikations-Kennung selbst). mID, Msg und Ver
     entsprechen den Feldern im Record TXAccAttr, pName zeigt auf
     den Namen des Accessories incl. der "Extended names".

     Die genaue Funktionsweise steht in der XAcc-Dokumentation
     und ist auch fr Programmierer an dieser Stelle unwichtig,
     da ObjectGEM die komplette Verwaltung bernimmt.


4.1.144  TApplication.XAccExit
------------------------------

Deklaration

     procedure XAccExit(OrgID: integer); virtual;

Beschreibung

     OrgID bezeichnet die AES-Kennung der terminierenden Applika-
     tion.

     Die genaue Funktionsweise steht in der XAcc-Dokumentation
     und ist auch fr Programmierer an dieser Stelle unwichtig,
     da ObjectGEM die komplette Verwaltung bernimmt.


4.1.145  TApplication.XAccID
----------------------------

Deklaration

     procedure XAccID(OrgID,mID: integer; Msg,
                       Ver: byte; pName: PChar); virtual;

Beschreibung

     OrgID bezeichnet die AES-Kennung der neu gestarteten Appli-
     kation oder des Accessories. mID, Msg und Ver entsprechen
     den Feldern im Record TXAccAttr, pName zeigt auf den Namen
     des Accessories incl. der "Extended names".

     Die genaue Funktionsweise steht in der XAcc-Dokumentation
     und ist auch fr Programmierer an dieser Stelle unwichtig,
     da ObjectGEM die komplette Verwaltung bernimmt.


4.1.146  TApplication.XAccIMG
-----------------------------

Deklaration

     function XAccIMG(OrgID: integer; pData: pointer;
                       lData: longint; Final: boolean): boolean;
                                                       virtual;

Beschreibung

     Mit dieser Methode k”nnen IMG-Rastergrafiken empfangen
     werden. OrgID bezeichnet die AES-Kennung des Senders, pData
     zeigt auf die Daten (die unter MultiTOS im globalen Speicher
     liegen mssen). Die Grafik mu nicht an einem Stck gesendet
     werden, in diesem Fall ist Final erst dann true, wenn das
     letzte Teil versendet wird. lData gibt die L„nge des zu
     verschickenden Teils in Bytes an. Wenn die Daten verarbeitet
     werden k”nnen, mu true zurckgegeben werden. Standard-
     Rckgabe ist false.

     Wichtig: Um das Einlesen und Verarbeiten innerhalb dieser
     Methode mu man sich selbst kmmern!


4.1.147  TApplication.XAccInsert
--------------------------------

Deklaration

     function XAccInsert(accID,mID: integer; Msg,
                          Ver: byte; pName: PChar): boolean;
                                                   virtual;

Beschreibung

     Diese Methode wird immer dann aufgerufen, wenn sich eine
     neue XAcc-Applikation angemeldet hat. Wenn die Applikation
     bereits angemeldet ist (sollte nicht vorkommen), wird false
     zurckgegeben. Ansonsten ist die Rckgabe true, die Daten
     (incl. der "Extended names") werden ausgewertet und in die
     XAccList eingetragen.

     Wenn man darauf wartet, da sich eine bestimmte Applikation
     (bzw. ein Programmtyp) ins System einklinkt, sollte man
     diese Methode berschreiben und nach Aufruf der geerbten
     Methode die XAccList auswerten.

     Wichtig: Wenn pName einen Zeiger<=$7fff enth„lt, geht die
     Methode davon aus, da ein falscher Pointer bergeben wurde
     und ignoriert den Aufruf!


4.1.148  TApplication.XAccKey
-----------------------------

Deklaration

     function XAccKey(OrgID,Stat,Key: integer): boolean; virtual;

Beschreibung

     Mit dieser Methode kann ein Tastendruck empfangen werden.
     OrgID ist die AES-Kennung der sendenden Applikation, Key
     enth„lt den Scancode der Taste und Stat den Status der
     Umschalttasten. Wenn der Tastendruck verarbeitet werden
     kann, mu true zurckgegeben werden. ObjectGEM leitet die
     Nachricht standardm„ig an MUKeybd weiter.


4.1.149  TApplication.XAccMeta
------------------------------

Deklaration

     function XAccMeta(OrgID: integer; pData: pointer;
                        lData: longint; Final: boolean): boolean;
                                                        virtual;

Beschreibung

     Mit dieser Methode k”nnen GEM-Vektorgrafiken empfangen
     werden. OrgID bezeichnet die AES-Kennung des Senders, pData
     zeigt auf die Daten (die unter MultiTOS im globalen Speicher
     liegen mssen). Die Grafik mu nicht an einem Stck gesendet
     werden, in diesem Fall ist Final erst dann true, wenn das
     letzte Teil versendet wird. lData gibt die L„nge des zu
     verschickenden Teils in Bytes an. Wenn die Daten verarbeitet
     werden k”nnen, mu true zurckgegeben werden. Standard-
     Rckgabe ist false.

     Wichtig: Um das Einlesen und Verarbeiten innerhalb dieser
     Methode mu man sich selbst kmmern!


4.1.150  TApplication.XAccText
------------------------------

Deklaration

     function XAccText(OrgID: integer;
                        pText: pointer): boolean; virtual;

Beschreibung

     Mit dieser Methode k”nnen ASCII-Texte empfangen werden.
     OrgID bezeichnet die AES-Kennung des Senders, pText zeigt
     auf die Textdaten (die unter MultiTOS im globalen Speicher
     liegen mssen). Der Text darf nur ASCII-Codes>=32 enthalten,
     abgesehen von HT (Tab), LF und CR. Andere Steuerzeichen
     drfen nur dann verwendet werden, wenn der Empf„nger diese
     sicher auswerten kann.

     Wichtig: Um das Einlesen und Verarbeiten innerhalb dieser
     Methode mu man sich selbst kmmern!


4.1.151  TApplication.IconSelect
--------------------------------

Deklaration

     procedure IconSelect(OnOff: boolean;
                           OffExc: integer); virtual;

Beschreibung

     Wenn OnOff true ist, werden alle Icons des Desktops
     selektiert. Andernfalls werden die Icons deselektiert (auch
     die der Fenster in der MainWindow-Liste) - mit Ausnahme des
     Fensters mit dem GEM-Handle OffExc (wobei auch DESK
     bergeben werden kann).

     Sollen alle Icons deselektiert werden, mu fr OffExc id_No
     bergeben werden.


4.1.152  TApplication.FirstIcon
-------------------------------

Deklaration

     function FirstIcon(OnAll: boolean): PIcon; virtual;

Beschreibung

     Ist OnAll true, wird ein Pointer auf das erste selektierte
     Icon geliefert. Ansonsten wird das erste von allen Icons
     zurckgegeben. Existiert kein entsprechendes Icon, erh„lt
     man nil.


4.1.153  TApplication.NextIcon
------------------------------

Deklaration

     function NextIcon: PIcon; virtual;

Beschreibung

     Gibt das n„chste selektiert Icon bzw. Icon berhaupt zurck,
     je nachdem, welche Parameter an TApplication.FirstIcon
     bergeben wurden.


4.2  TButton
============

Objekte dieses Typs verwalten sog. Push-Buttons, die normalerweise zum
Verlassen des Dialogs fhren (z.B. "OK", "Abbruch"). Aber auch die
speziellen Aktions-Buttons (z.B. "Help") k”nnen hiermit recht einfach
behandelt werden.

Pointer

     PButton = ^TButton;

Methoden

   ù Init (siehe "TButton.Init")

   ù Done (siehe "TButton.Done")

   ù Deinstall (siehe "TButton.Deinstall")

   ù GetText (siehe "TButton.GetText")

   ù Install (siehe "TButton.Install")

   ù SetText (siehe "TButton.SetText")

Vorfahre

   ù TControl

Nachfahre

   ù TCheckBox


4.2.1  TButton.Init
-------------------

Deklaration

     constructor Init(AParent: PDialog;
                      AnIndx,AnID: integer;
                      UserDef: boolean; Hlp: string);

Beschreibung

     Ruft den Vorfahren TControl.Init auf und setzt
     TControl.Style auf cs_PushButton (or bs_DefPushButton, falls
     es sich um den Default-Exit-Button handelt). Ist UserDef
     true und AnIndx der Index eines G_BUTTON-Objekts, wird
     TButton.Install aufgerufen, UsrDef auf true gesetzt und der
     Button im 3D-Look gezeichnet. Wenn UsrDef false ist und AnID
     eine der Konstanten id_OK..id_Esc enth„lt, wird aus dem
     Button ein spezieller Aktions-Button, der in TDialog
     gesondert behandelt wird. Ist der Button vom Typ G_BOXTEXT,
     wird er im Farbmodus dann automatisch gelb dargestellt. Soll
     dem Button keine spezielle Bedeutung zukommen, mu AnID
     gleich id_No sein.


4.2.2  TButton.Done
-------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Macht alle Ver„nderungen von TButton.Install rckg„ngig und
     ruft den Vorfahren TControl.Done auf.

     Wenn UsrDef true ist, wird vorher noch Deinstall aufgerufen.


4.2.3  TButton.Install
----------------------

Deklaration

     function Install: boolean; virtual;

Beschreibung

     Wenn das Dialogelement vom Typ G_BUTTON ist, wird UsrDef auf
     true gesetzt und ein benutzerdefiniertes 3D-Button-Objekt
     installiert.

     Wenn die Funktion false zurckliefert, wird die Installation
     von TButton.Init abgebrochen. Standardm„ig wird allerdings
     immer true zurckgegeben.


4.2.4  TButton.Deinstall
------------------------

Deklaration

     procedure Deinstall; virtual;

Beschreibung

     Macht die nderungen von TButton.Install rckg„ngig. Wird
     von TButton.Done aufgerufen.


4.2.5  TButton.GetText
----------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Gibt den Text des Dialogelementobjekts zurck.

     Wichtig: Eine evtl. vorhandene Shortcut-Markierung ('&')
     wird aus der Zeichenkette entfernt!


4.2.6  TButton.SetText
----------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     ndert den Text des Buttons. Der Shortcut fr den Button mu
     mit '&' markiert werden (z.B. '&OK'), dieser braucht nicht
     mit dem frheren Shortcut identisch zu sein! Anschlieend
     wird der Button neu gezeichnet.


4.3  TCheckBox
==============

Mit TCheckBox werden Buttons verwaltet, die jeder fr sich einen
Zustand repr„sentieren ("an", "aus"). Der angeschaltete Zustand wird
dabei normalerweise durch ein H„kchen gekennzeichnet.

Pointer

     PCheckBox = ^TCheckBox;

Methoden

   ù Init (siehe "TCheckBox.Init")

   ù Check (siehe "TCheckBox.Check")

   ù Deinstall (siehe "TCheckBox.Deinstall")

   ù GetCheck (siehe "TCheckBox.GetCheck")

   ù Install (siehe "TCheckBox.Install")

   ù SetChecl (siehe "TCheckBox.SetCheck")

   ù Toggle (siehe "TCheckBox.Toggle")

   ù Transfer (siehe "TCheckBox.Transfer")

   ù Uncheck (siehe "TCheckBox.Uncheck")

Vorfahre

   ù TButton

Nachfahren

   ù TRadioButton

   ù TTriState


4.3.1  TCheckBox.Init
---------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx: integer;
                          UserDef: boolean; Hlp: string);

Beschreibung

     Ruft den Vorfahren TButton.Init auf, setzt TControl.Style
     auf cs_CheckBox und schaltet den Transfer-Mechanismus ein.
     Ist UserDef true, wird die Checkbox im 3D-Look gezeichnet.


4.3.2  TCheckBox.Install
------------------------

Deklaration

     function Install: boolean; virtual;

Beschreibung

     Wenn das Dialogelement vom Typ G_BUTTON ist, wird UsrDef auf
     true gesetzt und die Checkbox im 3D-Look gezeichnet.

     Wenn die Funktion false zurckliefert, wird die Installation
     von TCheckBox.Init abgebrochen. Standardm„ig wird
     allerdings immer true zurckgegeben.


4.3.3  TCheckBox.Deinstall
--------------------------

Deklaration

     procedure Deinstall; virtual;

Beschreibung

     Hier k”nnen nderungen von TCheckBox.Install rckg„ngig
     gemacht werden.

     Standardm„ig wird TButton.Deinstall aber nur mit einer
     Leermethode berschrieben und damit ineffektiv gemacht.


4.3.4  TCheckBox.Transfer
-------------------------

Deklaration

     function Transfer(DataPtr: pointer;
                     TransferFlag: word): word; virtual;

Beschreibung

     šbertr„gt den Zustand der Checkbox (siehe bf_XXXX-Konstan-
     ten) vom und in das Word, auf das DataPtr zeigt. Rckgabe
     ist immer 2.


4.3.5  TCheckBox.SetCheck
-------------------------

Deklaration

     procedure SetCheck(CheckFlag: integer); virtual;

Beschreibung

     Setzt den Zustand der Checkbox, d.h. bf_Checked oder
     bf_Unchecked (bzw. bei TTriState evtl. auch bf_Grayed).


4.3.6  TCheckBox.GetCheck
-------------------------

Deklaration

     function GetCheck: integer; virtual;

Beschreibung

     Gibt den Zustand der Checkbox zurck.


4.3.7  TCheckBox.Check
----------------------

Deklaration

     procedure Check; virtual;

Beschreibung

     Ruft SetCheck(bf_Checked) auf und markiert dadurch das
     Dialogelement.


4.3.8  TCheckBox.Uncheck
------------------------

Deklaration

     procedure Uncheck; virtual;

Beschreibung

     Ruft SetCheck(bf_Unchecked) auf und versetzt das
     Dialogelement dadurch in den nichtmarkierten Zustand.


4.3.9  TCheckBox.Toggle
-----------------------

Deklaration

     procedure Toggle; virtual;

Beschreibung

     Der Objektstatus wird zwischen bf_Unchecked und bf_Checked
     gewechselt (bzw. bei TTriState in der Reihenfolge
     bf_Unchecked, bf_Checked, bf_Grayed zyklisch durchlaufen).


4.4  TClipboard
===============

TClipboard regelt den Zugriff auf das globale AES-Klemmbrett. Eine
Beschreibung findet sich unter "Clipboard-Verwaltung".

Pointer

     PClipboard = ^TClipboard;

Felder

   ù Parent (siehe "TClipboard.Parent")

Methoden

   ù Init (siehe "TClipboard.Init")

   ù CloseClipboard (siehe "TClipboard.CloseClipboard")

   ù EmptyClipboard (siehe "TClipboard.EmptyClipboard")

   ù GetClipboardFilename (siehe "TClipboard.GetClipboardFilename")

   ù GetPriorityClipboardFormat (siehe "TClipboard.GetPriorityClip-
     boardFormat")

   ù IsClipboardFormatAvailable (siehe "TClipboard.IsClip-
     boardFormatAvailable")

   ù IsOpen (siehe "TClipboard.IsOpen")

   ù OpenClipboard (siehe "TClipboard.OpenClipboard")

   ù SetClipboardFormat (siehe "TClipboard.SetClipboardFormat")

Vorfahre

   ù TObject

Nachfahre

     -


4.4.1  TClipboard.Parent
------------------------

Deklaration

     Parent: PObject;  (nur lesen)

Beschreibung

     Enth„lt einen Zeiger auf das besitzende Objekt.

     Wird von TClipboard.Init gesetzt.


4.4.2  TClipboard.Init
----------------------

Deklaration

     constructor Init(AParent: PObject);

Beschreibung

     Ruft zun„chst den Vorfahren TObject.Init auf, danach wird
     TClipboard.Parent auf AParent gesetzt.


4.4.3  TClipboard.CloseClipboard
--------------------------------

Deklaration

     function CloseClipboard: boolean; virtual;

Beschreibung

     Schliet das Klemmbrett und gibt es damit wieder frei. Wenn
     schreibend zugegriffen wurde, wird anschlieend eine
     SC_CHANGED-Message verschickt. Damit diese korrekt gesetzt
     wird, sollte vorher SetClipboardFormat aufgerufen werden.
     Wenn das Klemmbrett geschlossen werden konnte, wird true
     zurckgegeben.

     Zus„tzlich werden eine SH_WDRAW- und AV_PATH_UPDATE- Message
     verschickt, wenn das Klemmbrett ver„ndert wurde.


4.4.4  TClipboard.EmptyClipboard
--------------------------------

Deklaration

     function EmptyClipboard: boolean; virtual;

Beschreibung

     L”scht alle 'SCRAP.*'-Dateien im Klemmbrett. Wenn das
     Klemmbrett anschlieend leer ist, wird true zurckgegeben
     und SetClipboardFormat(SCF_INDEF,`) aufgerufen.

     Wird von TClipboard.OpenClipboard aufgerufen.


4.4.5  TClipboard.GetClipboardFilename
--------------------------------------

Deklaration

     function GetClipboardFilename: string; virtual;

Beschreibung

     Gibt den Pfad und Dateinamen (ohne Extension) des
     Klemmbretts zurck (z.B. 'C:\CLIPBRD\SCRAP.') oder einen
     Leerstring, wenn das Clipboard-Objekt keine
     Zugriffsberechtigung besitzt.


4.4.6  TClipboard.GetPriorityClipboardFormat
--------------------------------------------

Deklaration

     function GetPriorityClipboardFormat
                       (PriorityList: string): string; virtual;

Beschreibung

     Sucht in einer Liste von Extensions (durch Punkte getrennt)
     die Extension heraus, die im Klemmbrett vorhanden ist und in
     der Liste am weitesten links steht. Wenn also nur die Datei
     'SCRAP.ASC' im Klemmbrett vorhanden ist und mit
     'TXT.ASC.TEX' als Liste gesucht wird, erh„lt man als
     Rckgabe 'ASC'.


4.4.7  TClipboard.IsClipboardFormatAvailable
--------------------------------------------

Deklaration

     function IsClipboardFormatAvailable
                           (Format: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn die Datei mit der Extension Format
     (mit oder ohne Punkt) im Klemmbrett vorhanden ist.

     Falls das Clipboard-Objekt keine Zugriffsberechtigung
     besitzt, wird immer false zurckgegeben.


4.4.8  TClipboard.IsOpen
------------------------

Deklaration

     function IsOpen: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Klemmbrett mit der Methode TClip-
     board.OpenClipboard ge”ffnet werden konnte, false sonst.


4.4.9  TClipboard.OpenClipboard
-------------------------------

Deklaration

     function OpenClipboard(Write: boolean): boolean; virtual;

Beschreibung

     Holt die Zugriffsberechtigung fr das Klemmbrett.

     Wenn schreibend zugegriffen werden soll, mu in Write true
     bergeben werden - dann wird auerdem EmptyClipboard
     aufgerufen.

     Wenn noch kein Pfad fr das Klemmbrett existiert, wird ein
     geeigneter ermittelt und global gesetzt. Dazu werden nicht
     nur die Systemfunktionen benutzt, sondern auch die
     Environmentvariablen CLIPBRD und SCRAPDIR abgefragt.

     Konnte das Klemmbrett ge”ffnet werden, wird true
     zurckgegeben, ansonsten (wenn z.B. eine andere Applikation
     das Klemmbrett belegt) false.


4.4.10  TClipboard.SetClipboardFormat
-------------------------------------

Deklaration

     procedure SetClipboardFormat(Mask: word;
                                   Ext: string); virtual;

Beschreibung

     Wenn auf das Klemmbrett schreibend zugegriffen wurde, sollte
     mit dieser Methode der geschriebene Dateityp gesetzt werden
     (wird in Ext - mit oder ohne Punkt - bergeben). In Mask
     wird eine der SCF_XXXX-Konstanten eingetragen.

     Wenn in Ext kein Leerstring bergeben wird, wird
     n”tigenfalls ein Punkt vor die Extension gesetzt und die
     Zeichenkette mit Nullbytes aufgefllt.

     Wenn man in Mask SCF_INDEF und in Ext einen Leerstring
     bergibt, zeigt man damit an, da das Klemmbrett gel”scht
     wurde (wird u.a. von EmptyClipboard genutzt).


4.5  TCollection
================

TCollection ist ein Datentyp fr dynamische Arrays, der seine Gr”e
zur Laufzeit automatisch ver„ndern kann. Standardm„ig werden
Nachfahren von TObject verwaltet, abgeleitete Objekte speichern z.B.
Zeichenketten (TStringCollection). Routinen wie das Iterieren von
Elementen erleichtern die Programmierung.

Pointer

     PCollection = ^TCollection;

Felder

   ù Count (siehe "TCollection.Count")

   ù Delta (siehe "TCollection.Delta")

   ù Items (siehe "TCollection.Items")

   ù Limit (siehe "TCollection.Limit")

Methoden

   ù Init (siehe "TCollection.Init")

   ù Done (siehe "TCollection.Done")

   ù At (siehe "TCollection.At")

   ù AtDelete (siehe "TCollection.AtDelete")

   ù AtFree (siehe "TCollection.AtFree")

   ù AtInsert (siehe "TCollection.AtInsert")

   ù AtPut (siehe "TCollection.AtPut")

   ù Delete (siehe "TCollection.Delete")

   ù DeleteAll (siehe "TCollection.DeleteAll")

   ù Error (siehe "TCollection.Error")

   ù FirstThat (siehe "TCollection.FirstThat")

   ù ForEach (siehe "TCollection.ForEach")

   ù Free (siehe "TCollection.Free")

   ù FreeAll (siehe "TCollection.FreeAll")

   ù FreeItem (siehe "TCollection.FreeItem")

   ù IndexOf (siehe "TCollection.IndexOf")

   ù Insert (siehe "TCollection.Insert")

   ù LastThat (siehe "TCollection.LastThat")

   ù Pack (siehe "TCollection.Pack")

   ù SetLimit (siehe "TCollection.SetLimit")

Vorfahre

   ù TObject

Nachfahre

   ù TSortedCollection


4.5.1  TCollection.Items
------------------------

Deklaration

     Items: PItemList;  (nur lesen)

Beschreibung

     Ein Zeiger auf ein Array von Elementzeigern.


4.5.2  TCollection.Limit
------------------------

Deklaration

     Limit: longint;  (nur lesen)

Beschreibung

     Die Anzahl der z.Z. reservierten Element-Eintr„ge in der
     Items-Liste. Ist meistens gr”er als Count (leere
     Eintr„ge!).


4.5.3  TCollection.Count
------------------------

Deklaration

     Count: longint;  (nur lesen)

Beschreibung

     Die tats„chliche Anzahl der z.Z. gespeicherten Elemente in
     der Items-Liste, immer kleiner als MaxCollectionSize.


4.5.4  TCollection.Delta
------------------------

Deklaration

     Delta: longint;  (nur lesen)

Beschreibung

     Die Anzahl der Elemente, um die die Items-Liste vergr”ert
     wird, wenn sie voll ist. Ist Delta=0, kann die Kollektion
     nicht vergr”ert werden, sie ist dann also auf Limit
     beschr„nkt.


4.5.5  TCollection.Init
-----------------------

Deklaration

     constructor Init(ALimit,ADelta: longint);

Beschreibung

     Ruft den Vorfahren TObject.Init auf und setzt Delta auf
     ADelta. Ist ADelta kleiner als Null, wird Delta auf Null
     gesetzt. Danach wird Items mit der Anfangsgr”e von ALimit
     Elementen initialisiert. Die Kollektion kann sich danach bei
     Bedarf mit der Schrittweite Delta vergr”ern, bis kein
     Speicher mehr vorhanden ist oder MaxCollectionSize Elemente
     gespeichert sind.


4.5.6  TCollection.Done
-----------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt alle Elemente mit FreeAll frei und l”scht danach die
     Items-Liste mit SetLimit(0). Zum Schlu wird TObject.Done
     aufgerufen.


4.5.7  TCollection.At
---------------------

Deklaration

     function At(Index: longint): pointer; virtual;

Beschreibung

     Gibt einen Zeiger auf das Element mit der Nummer Index
     zurck, wodurch Items wie ein indiziertes Array behandelt
     werden kann. Ist Index kleiner als Null bzw. gr”er gleich
     Count, wird nil zurckgegeben. Auerdem wird dann
     TCollection.Error mit den Werten coIndexError und Index
     aufgerufen.


4.5.8  TCollection.AtDelete
---------------------------

Deklaration

     procedure AtDelete(Index: longint); virtual;

Beschreibung

     L”scht das Element mit der Nummer Index und schiebt alle
     folgenden Elemente um eine Position nach oben. Count wird um
     eins erniedrigt, Limit wird jedoch beibehalten. Ist Index
     kleiner als Null bzw. gr”er gleich Count, wird
     TCollection.Error mit den Werten coIndexError und Index
     aufgerufen.


4.5.9  TCollection.AtFree
-------------------------

Deklaration

     procedure AtFree(Index: longint); virtual;

Beschreibung

     L”scht das Element mit der Nummer Index und gibt es frei.


4.5.10  TCollection.AtInsert
----------------------------

Deklaration

     procedure AtInsert(Index: longint; Item: pointer);
                                                virtual;

Beschreibung

     Fgt Item an der Position Index in Items ein und verschiebt
     alle folgenden Elemente um eins nach unten. Ist Count vor
     dem Aufruf gleich Limit, wird die Kollektion um Delta
     Elemente vergr”ert. Kann sie nicht vergr”ert werden, wird
     TCollection.Error mit dem Wert coOverflow aufgerufen (kann
     die Kollektion nicht vergr”ert werden, weil Delta=0 ist,
     wird Error mit dem Wert coIndexError aufgerufen). Ist Index
     kleiner als Null bzw. gr”er gleich Count, wird Error mit
     den Werten coIndexError und Index aufgerufen.


4.5.11  TCollection.AtPut
-------------------------

Deklaration

     procedure AtPut(Index: longint; Item: pointer);
                                              virtual;

Beschreibung

     Ersetzt das Element mit der Nummer Index durch Item. Ist
     Index kleiner als Null bzw. gr”er gleich Count, wird
     TCollection.Error mit den Werten coIndexError und Index
     aufgerufen.


4.5.12  TCollection.Delete
--------------------------

Deklaration

     procedure Delete(Item: pointer); virtual;

Beschreibung

     L”scht das Element, auf das Item zeigt, aus der Kollektion.
     Entspricht AtDelete(IndexOf(Item)).


4.5.13  TCollection.DeleteAll
-----------------------------

Deklaration

     procedure DeleteAll; virtual;

Beschreibung

     Setzt Count auf Null und l”scht damit alle Elemente aus der
     Kollektion. Wichtig: Die aktuelle, durch Limit angegebene
     Gr”e bleibt bestehen!


4.5.14  TCollection.Error
-------------------------

Deklaration

     procedure Error(Code,Info: longint); virtual;

Beschreibung

     Wird aufgerufen, wenn z.B. einer Methode ein ungltiger
     Index bergeben wird oder ein Speicherberlauf innerhalb der
     Kollektion auftritt. Standardm„ig erzeugt diese Methode
     einen Laufzeitfehler mit der Nummer 212-Code.


4.5.15  TCollection.FirstThat
-----------------------------

Deklaration

     function FirstThat(Test: PIterationFunc): pointer;

Beschreibung

     FirstThat ruft fr jedes Element der Kollektion die durch
     Test bestimmte boolesche Funktion auf, bis Test true
     zurckgibt. FirstThat gibt dann den Elementzeiger zurck,
     fr den Test true zurckgegeben hat, oder nil, falls Test
     immer false geliefert hat. Der Pointer Test sollte eine
     globale (Unterschied zu ObjectWindows!) Funktion sein, der
     ein pointer-Parameter bergeben wird und die boolean
     zurckgibt.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Test-Funktion nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     function Passt(p: pointer): boolean;
       { ... }

     Passt sollte eine globale Funktion sein. Sei Liste ein
     TCollection-Objekt:

     p:=Liste.FirstThat(@Passt);


4.5.16  TCollection.ForEach
---------------------------

Deklaration

     procedure ForEach(Action: PIterationProc);

Beschreibung

     ForEach ruft fr jedes Element der Kollektion die durch
     Action bestimmte Prozedur auf. Der Pointer Action sollte
     eine GLOBALE (Unterschied zu ObjectWindows!) Prozedur sein,
     der ein pointer-Parameter bergeben wird.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Prozedur nicht auf die Variablen der bergeordneten
     Routine zugegriffen werden!

Beispiel

     procedure ZeigeAn(p: pointer);
       { ... }

     ZeigeAn sollte eine globale Prozedur sein. Sei Liste ein
     TCollection-Objekt:

     Liste.ForEach(@ZeigeAn);


4.5.17  TCollection.Free
------------------------

Deklaration

     procedure Free(Item: pointer);

Beschreibung

     L”scht das Element, auf das Item zeigt, und gibt es frei.
     Entspricht Delete(Item); FreeItem(Item);.


4.5.18  TCollection.FreeAll
---------------------------

Deklaration

     procedure FreeAll; virtual;

Beschreibung

     L”scht alle Elemente und gibt sie frei.


4.5.19  TCollection.FreeItem
----------------------------

Deklaration

     procedure FreeItem(Item: pointer); virtual;

Beschreibung

     Gibt das Element frei, auf das Item zeigt. Standardm„ig
     geht diese Methode davon aus, da die Elemente Nachfahren
     von TObject sind, d.h. das Element wird mit
     Dispose(PObject(Item),Done) freigegeben. Die Methode mu
     berschrieben werden, wenn andere Elemente verwaltet werden
     sollen (z.B. Strings, siehe TStringCollection.FreeItem).

     FreeItem wird von TCollection.Free und FreeAll aufgerufen
     und sollte niemals direkt aufgerufen werden!


4.5.20  TCollection.IndexOf
---------------------------

Deklaration

     function IndexOf(Item: pointer): longint; virtual;

Beschreibung

     Gibt die Nummer des Element zurck, auf das Item zeigt, und
     ist damit das Gegenstck zu TCollection.At. Befindet sich
     Item nicht in der Kollektion, wird -1 zurckgegeben.


4.5.21  TCollection.Insert
--------------------------

Deklaration

     procedure Insert(Item: pointer); virtual;

Beschreibung

     Fgt das Element Item in die Kollektion ein. Standardm„ig
     geschieht dies mit AtInsert(Count,Item) am Ende der
     Kollektion.


4.5.22  TCollection.LastThat
----------------------------

Deklaration

     function LastThat(Test: PIterationFunc): pointer;
                                              virtual;

Beschreibung

     LastThat ruft in umgekehrter Reihenfolge fr jedes Element
     der Kollektion die durch Test bestimmte boolesche Funktion
     auf, bis Test true zurckgibt. LastThat gibt dann den
     Elementzeiger zurck, fr den Test true zurckgegeben hat,
     oder nil, falls Test immer false geliefert hat. Test sollte
     eine globale (Unterschied zu ObjectWindows!) Funktion sein,
     der ein pointer-Parameter bergeben wird und die boolean
     zurckgibt.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Test-Funktion nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     function Passt(p: pointer): boolean;
       { ... }

     Passt sollte eine globale Funktion sein. Sei Liste ein
     TCollection-Objekt:

     p:=Liste.LastThat(@Passt);


4.5.23  TCollection.Pack
------------------------

Deklaration

     procedure Pack; virtual;

Beschreibung

     L”scht alle nil-Zeiger in der Kollektion und setzt danach
     Limit auf den kleinstm”glichen Wert (d.h. auf Count).


4.5.24  TCollection.SetLimit
----------------------------

Deklaration

     procedure SetLimit(ALimit: longint); virtual;

Beschreibung

     Vergr”ert oder Verkleinert die Kollektion auf maximal
     ALimit Elemente. Ist ALimit kleiner als Count, wird die
     Limit auf Count gesetzt, ist ALimit gr”er als
     MaxCollectionSize, wird Limit auf MaxCollectionSize gesetzt.


4.6  TComboBox
==============

TComboBox ist das Dialogelementobjekt fr Popup-Mens innerhalb von
Dialogen. Das Objekt kmmert sich automatisch um die Abarbeitung des
Popups und eines evtl. damit verknpften TEdit-Objekts. Um die
ComboBox kontextsensitiv zu gestalten, mu die Methode TComboBox.Work
berschrieben werden.

Pointer

     PComboBox = ^TComboBox;

Felder

   ù Edit (siehe "TComboBox.Edit")

   ù Popup (siehe "TComboBox.Popup")

Methoden

   ù Init (siehe "TComboBox.Init")

   ù Done (siehe "TComboBox.Done")

   ù Changed (siehe "TComboBox.Changed")

   ù GetEdit (siehe "TComboBox.GetEdit")

   ù GetSelection (siehe "TComboBox.GetSelection")

   ù GetText (siehe "TComboBox.GetText")

   ù Paint (siehe "TComboBox.Paint")

   ù SetSelection (siehe "TComboBox.SetSelection")

   ù SetText (siehe "TComboBox.SetText")

   ù TestIndex (siehe "TComboBox.TestIndex")

   ù Transfer (siehe "TComboBox.Transfer")

   ù Work (siehe "TComboBox.Work")

Vorfahre

   ù TControl

Nachfahre

     -


4.6.1  TComboBox.Edit
---------------------

Deklaration

     Edit: PEdit;  (nur lesen)

Beschreibung

     Wird von TComboBox.Init mit GetEdit belegt, wenn das Popup-
     Men mit einem Eingabefeld verknpft werden soll.


4.6.2  TComboBox.Popup
----------------------

Deklaration

     Popup: PPopup;  (nur lesen)

Beschreibung

     Zeigt auf das TPopup-Objekt der ComboBox. Wird von
     TComboBox.Init gesetzt.


4.6.3  TComboBox.Init
---------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx,CycleIndx,
                         TitleIndx,ptIndx,popIndx: integer;
                       Cycle,Editable: boolean; Hlp: string);

Beschreibung

     Zuerst wird der Vorfahre TControl.Init(AParent,AnIndx,Hlp)
     aufgerufen. Wenn Editable true ist, wird TComboBox.Edit
     danach mit GetEdit belegt, ansonsten zeigt Edit auf nil.
     Danach werden die internen Variablen angepat und zum Schlu
     SetSelection(0) aufgerufen.

     In AnIndx wird der Index des Popup-Wert-Elements bergeben.
     Das ist das Element, das immer mit der aktuellen Auswahl
     sichtbar ist. Wenn in Editable true bergeben wird, mu
     dieses Element ein editierbares Objekt sein.

     In CycleIndx wird das Element bergeben, mit dem der Popup-
     Wert um eins weiter geschaltet wird bzw. mit dem das Popup-
     Men ge”ffnet wird, je nachdem ob Cycle true oder false ist.
     Dieses Objekt sollte vom Typ G_BOXCHAR sein, damit dort
     Attr.PopChar eingetragen werden kann.

     TitleIndx bezeichnet das Objekt, das vor dem Popup-Wert-
     Objekt steht; dies ist quasi der Titel oder die Beschreibung
     des Popups. In diesem String kann auch ein Hotkey (wie
     blich mit '&') festgelegt werden.

     ptIndx und popIndx bezeichnen schlielich das Popup-Men an
     sich, der Aufbau ist unter TPopup beschrieben.


4.6.4  TComboBox.Done
---------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     TComboBox.Popup und TComboBox.Edit werden freigegeben,
     danach wird der Vorfahre TControl.Done aufgerufen.


4.6.5  TComboBox.Changed
------------------------

Deklaration

     procedure Changed(AnIndx: integer; DblClick: boolean); virtual;

Beschreibung

     In dieser Methode findet die gesamte Abarbeitung der
     ComboBox statt. Durch TComboBox.TestIndex wird diese Methode
     bei Anwahl jedes Objektes, das mit dem Popup verknpft ist,
     aufgerufen.

     Wurde die aktuelle Auswahl des Popups ge„ndert, wird
     anschlieend TComboBox.Work aufgerufen.


4.6.6  TComboBox.GetEdit
------------------------

Deklaration

     function GetEdit: PEdit; virtual;

Beschreibung

     Liefert ein TEdit-Objekt zurck, wenn ein solches mit der
     ComboBox verknpft werden soll. Dazu wird diese Methode von
     TComboBox.Init abgefragt.

     Wenn man ein "besonderes" (d.h. abgeleitetes) Eingabefeld
     haben m”chte, mu man diese Methode berschreiben und ein
     entsprechendes Objekt zurckgeben.


4.6.7  TComboBox.GetSelection
-----------------------------

Deklaration

     function GetSelection: integer; virtual;

Beschreibung

     Gibt die Nummer (>=0) der aktuellen Auswahl des Popups
     zurck.


4.6.8  TComboBox.GetText
------------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Liefert die aktuelle Auswahl des Popups als Zeichenkette.
     Wenn die ComboBox mit einem Eingabefeld verknpft ist, wird
     TComboBox.Edit^.GetText zurckgegeben.


4.6.9  TComboBox.Paint
----------------------

Deklaration

     procedure Paint; virtual;

Beschreibung

     Zeichnet den Titel, das Wert-Element und den Cycle-Button
     neu. Wenn ein Eingabefeld mit der ComboBox verknpft ist,
     wird intern TComboBox.Edit^.Paint aufgerufen.


4.6.10  TComboBox.SetSelection
------------------------------

Deklaration

     procedure SetSelection(Sel: integer); virtual;

Beschreibung

     Setzt die Auswahl des Popups auf den Index Sel (>=0), wobei
     die Anzeige etc. automatisch aktualisiert wird.


4.6.11  TComboBox.SetText
-------------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     Setzt den Text des Wert-Element (ObjIndx) auf ATextString.
     Wenn ein Eingabefeld mit der ComboBox verknpft ist, wird
     dazu TComboBox.Edit^.SetText aufgerufen.

     Wichtig: Der Index der Popup-Markierung wird nicht angepat,
     wenn der neue String mit einer Zeichenkette des Popups
     bereinstimmt! Dies mu mit TComboBox.SetSelection geschehen
     (bzw. wird intern automatisch durchgefhrt).


4.6.12  TComboBox.TestIndex
---------------------------

Deklaration

     function TestIndex(AnIndx: integer): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn eines der ComboBox-Elemente (ObjIndx
     [=Wert], Title, Cycle-Button) angew„hlt wurde.

     ObjIndx wird allerdings nur ausgewertet, wenn TComboBox.Edit
     nicht belegt ist, d.h. wenn die ComboBox mit keinem
     Eingabefeld verknpft ist.


4.6.13  TComboBox.Transfer
--------------------------

Deklaration

     function Transfer(DataPtr: pointer;
                         TransferFlag: word): word; virtual;

Beschreibung

     šbertr„gt Daten vom bzw. in das Objekt. Der genaue Aufbau
     der Struktur ist unter TransferBuffer beschrieben.


4.6.14  TComboBox.Work
----------------------

Deklaration

     procedure Work; virtual;

Beschreibung

     Dies ist eine abstrakte Methode, die zun„chst nichts macht.
     Sie wird aber bei jeder Wert„nderung des Popups aufgerufen,
     so da hiermit z.B. andere Buttons kontextsensitiv gemacht
     werden k”nnen.


4.7  TControl
=============

TControl ist das grundlegende Dialogelementobjekt von ObjectGEM, d.h.
jedem Element in einer Resource, das abgefragt oder ver„ndert werden
soll (Buttons, Edit-Felder), sollte ein von TControl abgeleitetes
Objekt zugeordnet werden (durch die TControl.Init-Methode). Dadurch
kann dieses Element dann sehr einfach mit Hilfe der TControl-Methoden
behandelt werden (Status etc.).

Pointer

     PControl = ^TControl;

Felder

   ù ID (siehe "TControl.ID")

   ù Flags (siehe "TControl.Flags")

   ù ObjAddr (siehe "TControl.ObjAddr")

   ù ObjIndx (siehe "TControl.ObjIndx")

   ù Parent (siehe "TControl.Parent")

   ù Style (siehe "TControl.Style")

   ù UsrBlk (siehe "TControl.UsrBlk")

   ù UsrDef (siehe "TControl.UsrDef")

Methoden

   ù Init (siehe "TControl.Init")

   ù Done (siehe "TControl.Done")

   ù Changed (siehe "TControl.Changed")

   ù Disable (siehe "TControl.Disable")

   ù DisableTransfer (siehe "TControl.DisableTransfer")

   ù Enable (siehe "TControl.Enable")

   ù EnableTransfer (siehe "TControl.EnableTransfer")

   ù GetColor (siehe "TControl.GetColor")

   ù GetHelp (siehe "TControl.GetHelp")

   ù GetState (siehe "TControl.GetState")

   ù Hide (siehe "TControl.Hide")

   ù IsFlagSet (siehe "TControl.IsFlagSet")

   ù IsHelpAvailable (siehe "TControl.IsHelpAvailable")

   ù IsHidden (siehe "TControl.IsHidden")

   ù Next (siehe "TControl.Next")

   ù Paint (siehe "TControl.Paint")

   ù Previous (siehe "TControl.Previous")

   ù SetColor (siehe "TControl.SetColor")

   ù SetFlags (siehe "TControl.SetFlags")

   ù SetHelp (siehe "TControl.SetHelp")

   ù SetShortCut (siehe "TControl.SetShortCut")

   ù SetState (siehe "TControl.SetState")

   ù TestID (siehe "TControl.TestID")

   ù TestIndex (siehe "TControl.TestIndex")

   ù TestShortCut (siehe "TControl.TestShortCut")

   ù Transfer (siehe "TControl.Transfer")

   ù Unhide (siehe "TControl.Unhide")

Vorfahre

   ù TObject

Nachfahren

   ù TButton

   ù TComboBox

   ù TGroupBox

   ù TScrollBar

   ù TStatic


4.7.1  TControl.ID
------------------

Deklaration

     ID: integer;

Beschreibung

     Legt fest, ob dem Dialogelementobjekt beim Verlassen des
     Dialogs eine besondere Bedeutung zukommen soll. Wird von
     TControl.Init auf id_No gesetzt und von TButton bzw.
     TScrollBar ver„ndert.


4.7.2  TControl.Flags
---------------------

Deklaration

     Flags: byte;

Beschreibung

     Beschreibt zus„tzliche Eigenschaften des
     Dialogelementobjekts. Wird z.Z. nur von DisableTransfer bzw.
     EnableTransfer direkt ver„ndert. TControl.Init nullt das
     Feld aus.


4.7.3  TControl.ObjAddr
-----------------------

Deklaration

     ObjAddr: PObj;  (nur lesen)

Beschreibung

     TControl.Init setzt hier die zum Dialogelement
     TControl.ObjIndx geh”rige Adresse ein.


4.7.4  TControl.ObjIndx
-----------------------

Deklaration

     ObjIndx: integer;  (nur lesen)

Beschreibung

     Enth„lt die Nummer des Dialogelementobjekts, die an
     TControl.Init bergeben wird. Aus diesem Index kann
     TControl.ObjAddr berechnet werden.


4.7.5  TControl.Parent
----------------------

Deklaration

     Parent: PDialog;  (nur lesen)

Beschreibung

     Enth„lt einen Zeiger auf das zugeh”rige TDialog-Objekt. Dort
     werden alle Dialogelementobjekte in der durch
     TControl.Previous und TControl.Next verketteten Liste
     CtrlList verwaltet.

     Parent wird von TControl.Init gesetzt.


4.7.6  TControl.Style
---------------------

Deklaration

     Style: word;  (nur lesen, s.u.)

Beschreibung

     Wird von TControl.Init ausgenullt. Abgeleitete Objekte
     tragen hier Konstanten ein, durch die die Art des
     Dialogelementobjekts ermittelt werden kann. Abgesehen von
     es_ASCIIOnly und sts_Fill ist dieses Feld nur zum Lesen
     freigegeben.


4.7.7  TControl.UsrBlk
----------------------

Deklaration

     UsrBlk: USERBLK;  (nur lesen)

Beschreibung

     Wenn UsrDef true ist, enth„lt diese Struktur alle n”tigen
     Daten zum Zeichnen des neuen Dialogelements. TControl.Init
     nullt dieses Feld aus.


4.7.8  TControl.UsrDef
----------------------

Deklaration

     UsrDef: boolean;  (nur lesen)

Beschreibung

     Ist dieses Feld true, verwendet das von TControl abgeleitete
     Objekt die UsrBlk-Struktur, d.h. das Dialogelement wird in
     einem ObjectGEM-eigenen Stil gezeichnet.

     Wird von TControl.Init auf false gesetzt.


4.7.9  TControl.Init
--------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx: integer;
                                          Hlp: string);

Beschreibung

     Ruft den Vorfahren TObject.Init auf und setzt
     TControl.ObjIndx auf AnIndx, TControl.ID auf id_No und
     TControl.Parent auf AParent. Hlp wird als Text fr die
     BubbleHelp verwendet, TControl.Style und Flags werden
     ausgenullt und der Shortcut gel”scht, so da TestShortCut
     standardm„ig false zurckliefert. Auerdem wird das
     Dialogelement in die CtrlList des zugeh”rigen TDialog-
     Objekts eingetragen.

     Wenn in AParent nil bergeben wird oder TControl.ObjAddr
     nicht ermittelt werden kann, bricht die Initialisierung ab
     und man erh„lt einen Nullzeiger. Da Flags auf Null gesetzt
     wird, nehmen TControl-Objekte standardm„ig nicht am
     Datentransfermechanismus teil.

     Auerdem werden UsrDef und UsrBlk initialisiert.


4.7.10  TControl.Done
---------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     L”scht das Dialogelement aus der CtrlList des zugeh”rigen
     TDialog-Objekts und ruft TObject.Done auf.


4.7.11  TControl.TestIndex
--------------------------

Deklaration

     function TestIndex(AnIndx: integer): boolean;
                                            virtual;

Beschreibung

     Gibt true zurck, wenn der bergebene Index mit
     TControl.ObjIndx bereinstimmt. Wird benutzt um zu
     berprfen, welches Dialogelement angew„hlt wurde.


4.7.12  TControl.TestID
-----------------------

Deklaration

     function TestID(AnID: integer): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn AnID mit TControl.ID bereinstimmt.
     Wird beim Verlassen des Dialogs benutzt, um evtl. speziell
     auf das Exit-Objekt reagieren zu k”nnen.


4.7.13  TControl.TestShortCut
-----------------------------

Deklaration

     function TestShortCut(Key: integer): boolean;
                                            virtual;

Beschreibung

     Gibt true zurck, wenn Key mit dem Shortcut des
     Dialogelementobjekts bereinstimmt. Key enth„lt dabei den
     ASCII-Wert des Zeichens (ohne Alternate-Status),
     Kleinbuchstaben mssen vorher in Grobuchstaben umgewandelt
     werden. Der Shortcut wird von der TButton.SetText-Methode
     gesetzt.


4.7.14  TControl.SetShortCut
----------------------------

Deklaration

     procedure SetShortCut(Key: char); virtual;

Beschreibung

     Setz den Shortcut fr das TControl-Objekt, mit dem dieses
     (zusammen mit <Alternate>) angew„hlt werden kann.

     Kleinbuchstaben werden automatisch in Grobuchstaben
     umgewandelt. Mit #0 kann der Shortcut gel”scht werden.


4.7.15  TControl.SetFlags
-------------------------

Deklaration

     procedure SetFlags(Mask: byte; OnOff: boolean);
                                              virtual;

Beschreibung

     Setzt oder l”scht die durch Mask angegebenen Bits in Flags,
     je nachdem ob OnOff true oder false ist.


4.7.16  TControl.IsFlagSet
--------------------------

Deklaration

     function IsFlagSet(Mask: byte): boolean;

Beschreibung

     Gibt true zurck, wenn die in Mask angegebenen Bits in Flags
     gesetzt sind.


4.7.17  TControl.SetState
-------------------------

Deklaration

     procedure SetState(StateFlag: integer); virtual;

Beschreibung

     Macht das Dialogelement anw„hlbar bzw. nicht anw„hlbar.
     Zul„ssige Werte fr StateFlag sind bf_Enabled und
     bf_Disabled.


4.7.18  TControl.GetState
-------------------------

Deklaration

     function GetState: integer; virtual;

Beschreibung

     Gibt den Zustand des Dialogelements zurck (bf_Enabled,
     bf_Disabled).


4.7.19  TControl.Disable
------------------------

Deklaration

     procedure Disable; virtual;

Beschreibung

     Ruft SetState(bf_Disabled) auf und macht das Dialogelement
     somit nicht anw„hlbar.


4.7.20  TControl.Enable
-----------------------

Deklaration

     procedure Enable; virtual;

Beschreibung

     Ruft SetState(bf_Enabled) auf und macht das Dialogelement
     dadurch anw„hlbar.


4.7.21  TControl.EnableTransfer
-------------------------------

Deklaration

     procedure EnableTransfer; virtual;

Beschreibung

     Ruft SetFlags(wb_Transfer,true) auf und beteiligt das
     Dialogelement am Datentransfermechanismus.


4.7.22  TControl.DisableTransfer
--------------------------------

Deklaration

     procedure DisableTransfer; virtual;

Beschreibung

     Ruft SetFlags(wb_Transfer,false) auf und nimmt das
     Dialogelement dadurch vom Datentransfermechanismus aus.


4.7.23  TControl.Transfer
-------------------------

Deklaration

     function Transfer(DataPtr: pointer;
                     TransferFlag: word): word; virtual;

Beschreibung

     Dies ist eine abstrakte Methode, die nichts weiter macht als
     Null zurckzuliefern. Sie wird aber von anderen Objekten
     berschrieben, um Daten in das Element bzw. aus dem Element
     heraus zu bertragen. DataPtr zeigt dabei auf die zu
     setzenden Daten bzw. auf einen Puffer, der die ausgelesenen
     Daten aufnimmt. TransferFlag mu eine der tf_XXXX-Konstanten
     enthalten.

     Die Rckgabe entspricht der Anzahl der bertragenen Bytes,
     mu aber immer gerade sein (evtl. aufrunden).


4.7.24  TControl.Changed
------------------------

Deklaration

     procedure Changed(AnIndx: integer;
                         DblClick: boolean); virtual;

Beschreibung

     Wird von TDialog.CallChanged aufgerufen, wenn das
     Dialogelement aufgerufen wird und dadurch seinen Status
     „ndert. Standardm„ig macht diese Methode nichts, durch sie
     k”nnen Dialogboxen aber kontextsensitiv werden, indem z.B.
     in dieser Methode der Zustand eines Buttons etc. in
     Abh„ngigkeit vom Zustand des Dialogelements ge„ndert wird.

     AnIndx gibt den Index des angew„hlten Dialogelements an
     (sollte mit TControl.ObjIndx bereinstimmen), DblClick zeigt
     an, ob das Element mit Doppelklick angew„hlt wurde.


4.7.25  TControl.Paint
----------------------

Deklaration

     procedure Paint; virtual;

Beschreibung

     Ruft Parent (siehe "TControl.Parent")^.ObjcPaint auf, d.h.
     das Dialogelement wird gezeichnet. Befindet sich der
     zugeh”rige Dialog in einem Fenster, wird die Rechteckliste
     automatisch beachtet.

     An ObjcPaint wird der Index des Dialogelements
     (TControl.ObjIndx) und ein boolean-Parameter bergeben, der
     true ist, wenn wb_Lazy gesetzt ist.


4.7.26  TControl.Hide
---------------------

Deklaration

     procedure Hide(Draw: boolean); virtual;

Beschreibung

     Macht das Dialogelement unsichtbar. Ist Draw true, wird dann
     das bergeordnete Dialogelement gezeichnet, damit das
     Element auch auf dem Bildschirm (und nicht nur logisch)
     verschwindet.

     Wenn man allerdings direkt nach Hide ein anderes
     Dialogelement an derselben Stelle mit TControl.Unhide
     sichtbar macht, kann Draw auf false gesetzt werden (Achtung
     allerdings bei Elementen, die nicht deckend gezeichnet
     werden, z.B. Images).


4.7.27  TControl.Unhide
-----------------------

Deklaration

     procedure Unhide; virtual;

Beschreibung

     Macht das Dialogelement sichtbar und zeichnet es.


4.7.28  TControl.IsHidden
-------------------------

Deklaration

     function IsHidden: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Dialogelement unsichtbar ist,
     false sonst.


4.7.29  TControl.GetColor
-------------------------

Deklaration

     function GetColor: integer; virtual;

Beschreibung

     Liefert den Farbindex (0..15) des Dialogelements zurck.
     Wenn es sich nicht um ein G_BOX-, G_IBOX-, G_BOXCHAR-,
     G_TEXT-, G_BOXTEXT-, G_FTEXT-, G_ICON-, G_FBOXTEXT- oder
     G_IMAGE-Objekt handelt, ist die Rckgabe standardm„ig
     Black.


4.7.30  TControl.SetColor
-------------------------

Deklaration

     procedure SetColor(Color: integer); virtual;

Beschreibung

     Setzt die Farbe des Dialogelements neu. In Color wird dazu
     der entsprechende Farbindex (0..15) bergeben.

     Anschlieend wird das Element neu gezeichnet.


4.7.31  TControl.IsHelpAvailable
--------------------------------

Deklaration

     function IsHelpAvailable: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Dialogelementobjekt mit
     TControl.GetHelp einen Hilfstext fr die BubbleHelp liefern
     kann.


4.7.32  TControl.GetHelp
------------------------

Deklaration

     function GetHelp: string; virtual;

Beschreibung

     Gibt einen Hilfstext fr die BubbleHelp zurck.


4.7.33  TControl.SetHelp
------------------------

Deklaration

     procedure SetHelp(Hlp: string); virtual;

Beschreibung

     Weist dem Dialogelementobjekt einen neuen Hilfstext fr die
     BubbleHelp zu.


4.7.34  TControl.Previous
-------------------------

Deklaration

     function Previous: PControl;

Beschreibung

     Gibt einen Zeiger auf das vorhergehende TControl-Objekt in
     der CtrlList des zugeh”rigen TDialog- Objekts zurck. Ist
     kein weiteres Objekt vorhanden, erh„lt man einen nil-Zeiger,
     d.h. in diesem Fall zeigt CtrlList genau auf das aktuelle
     Objekt.


4.7.35  TControl.Next
---------------------

Deklaration

     function Next: PControl;

Beschreibung

     Gibt einen Zeiger auf das n„chste TControl-Objekt in der
     CtrlList des zugeh”rigen TDialog-Objekts zurck. Ist kein
     weiteres Objekt vorhanden, erh„lt man einen nil-Zeiger.


4.8  TDialog
============

TDialog ist der grundlegende Objekttyp fr alle (Fenster-)Dialoge,
d.h. modale und nicht-modale Dialogboxen. Die Abarbeitung erfolgt
normalerweise automatisch, kann aber auch "von Hand" vorgenommen
werden.

Die einfache Bearbeitung eines modalen Dialogs kann auch mit
TApplication.ExecDialog durchgefhrt werden, allerdings sollten
Dialoge nach M”glichkeit im Fenster (also nicht-modal) dargestellt
werden, da sonst das gesamte System blockiert wird, was unter einem
Multitasking-Betriebssystem Probleme bereiten kann.

Pointer

     PDialog = ^TDialog;

Felder

   ù Cont (siehe "TDialog.Cont")

   ù CtrlList (siehe "TDialog.CtrlList")

   ù IsModal (siehe "TDialog.IsModal")

   ù Result (siehe "TDialog.Result")

   ù TransferBuffer (siehe "TDialog.TransferBuffer")

Methoden

   ù Init (siehe "TDialog.Init")

   ù Done (siehe "TDialog.Done")

   ù CallChanged (siehe "TDialog.CallChanged")

   ù Cancel (siehe "TDialog.Cancel")

   ù CloseWindow (siehe "TDialog.CloseWindow")

   ù Copy (siehe "TDialog.Copy")

   ù Create (siehe "TDialog.Create")

   ù Cut (siehe "TDialog.Cut")

   ù Delete (siehe "TDialog.Delete")

   ù Destroy (siehe "TDialog.Destroy")

   ù EndDlg (siehe "TDialog.EndDlg")

   ù Esc (siehe "TDialog.Esc")

   ù Execute (siehe "TDialog.Execute")

   ù ExitDlg (siehe "TDialog.ExitDlg")

   ù FirstThat (siehe "TDialog.FirstThat")

   ù ForEach (siehe "TDialog.ForEach")

   ù FreeDialog (siehe "TDialog.FreeDialog")

   ù GetClassName (siehe "TDialog.GetClassName")

   ù GetDefaultButton (siehe "TDialog.GetDefaultButton")

   ù GetFocus (siehe "TDialog.GetFocus")

   ù GetKBHandler (siehe "TDialog.GetKBHandler")

   ù GetStyle (siehe "TDialog.GetStyle")

   ù GetVDIHandle (siehe "TDialog.GetVDIHandle")

   ù GetWindowClass (siehe "TDialog.GetWindowClass")

   ù GetWorkMax (siehe "TDialog.GetWorkMax")

   ù Help (siehe "TDialog.Help")

   ù InitFocus (siehe "TDialog.InitFocus")

   ù IsDialog (siehe "TDialog.IsDialog")

   ù LoadDialog (siehe "TDialog.LoadDialog")

   ù MakeWindow (siehe "TDialog.MakeWindow")

   ù ObjcPaint (siehe "TDialog.ObjcPaint")

   ù OK (siehe "TDialog.OK")

   ù OpenWindow (siehe "TDialog.OpenWindow")

   ù Paint (siehe "TDialog.Paint")

   ù Paste (siehe "TDialog.Paste")

   ù SetDefaultButton (siehe "TDialog.SetDefaultButton")

   ù SetFocus (siehe "TDialog.SetFocus")

   ù SetupSize (siehe "TDialog.SetupSize")

   ù SetupWindow (siehe "TDialog.SetupWindow")

   ù TransferData (siehe "TDialog.TransferData")

   ù Undo (siehe "TDialog.Undo")

   ù UpdateDialog (siehe "TDialog.UpdateDialog")

   ù WMButton (siehe "TDialog.WMButton")

   ù WMClosed (siehe "TDialog.WMClosed")

Vorfahre

   ù TWindow

Nachfahren

     -


4.8.1  TDialog.Cont
-------------------

Deklaration

     Cont: boolean;

Beschreibung

     Dieses Flag zeigt an, ob die Dialogbearbeitung fortgesetz
     wird (true) oder ob der Dialog beendet werden soll (false).

     Von TDialog.SetupWindow wird es auf false initialisiert, von
     TDialog.OpenWindow auf true und von TDialog.CloseWindow
     wieder auf false gesetzt. Ver„nderungen werden u.a. in
     TDialog.WMButton und im Tastatur-Handler des Dialogs durch
     ObjectGEM-interne form_button()- bzw. form_keybd()-Routinen
     vorgenommen.

     Modale Dialoge nutzen dieses Flag in der Methode
     TDialog.Execute als Abbruchbedingung.

     Normalerweise mu dieses Flag weder beachtet noch
     manipuliert werden, einzig in TDialog.EndDlg kann dadurch
     die Abarbeitung sinnvoll gesteuert werden (aber auch dort
     gibt es genug andere M”glichkeiten, die auch genutzt werden
     sollten).


4.8.2  TDialog.CtrlList
-----------------------

Deklaration

     CtrlList: PControl;  (nur lesen)

Beschreibung

     In dieser Liste werden die Dialogelementobjekte verwaltet.
     TControl-Schnittstellenobjekte tragen sich bei ihrer
     Initialisierung hier ein. Alle Auswertungen der
     Benutzeraktionen werden mit den Objekten in dieser Liste
     durchgefhrt.

     Mit TDialog.FirstThat und TDialog.ForEach kann diese Liste
     recht einfach durchlaufen werden.

     Wird von TDialog.SetupWindow mit nil initialisiert.


4.8.3  TDialog.IsModal
----------------------

Deklaration

     IsModal: boolean;  (nur lesen)

Beschreibung

     Dieses Flag gibt an, ob es sich um einen modalen Dialog
     handelt (true), d.h. das System wird w„hrend der Abarbeitung
     blockiert. Nur dieses Flag darf zur Unterscheidung zwischen
     modalen und nicht-modalen Dialogen verwendet werden!

     Wird von TDialog.SetupWindow gesetzt und von TDialog.Create
     n”tigenfalls korrigiert. Modale Dialoge werden mit
     TDialog.Execute abgearbeitet.


4.8.4  TDialog.Result
---------------------

Deklaration

     Result: integer;

Beschreibung

     In diesem Feld steht nach erfolgreicher Abarbeitung des
     Dialogs der Index des Dialogelements, mit dem die Dialogbox
     verlassen wurde.

     Wird z.B. von den Methoden TApplication.ExecDialog und
     TApplication.Alert ben”tigt, derentwegen normalerweise kein
     direkter Zugriff auf dieses Feld n”tig ist.


4.8.5  TDialog.TransferBuffer
-----------------------------

Deklaration

     TransferBuffer: pointer;

Beschreibung

     Dieses Feld kann auf einen sog. Transfer-Puffer des Dialogs
     zeigen, der das Belegen und Auswerten aller
     Dialogelementobjekte, die am Datentransfermechanismus
     teilnehmen k”nnen, erheblich vereinfacht.

     Wird von TDialog.SetupWindow auf nil gesetzt, d.h. der
     Transfermechanismus ist ausgeschaltet. Will man einen
     Transfer-Puffer installieren, sollte man die Methode
     SetupWindow berschreiben und nach dem Aufruf der geerbten
     Methode TransferBuffer auf diesen Puffer (der schon wie
     gewnscht vorbelegt sein sollte) setzen.

     Ein Transfer-Puffer ist normalerweise ein Record, in dem fr
     alle Dialogelementobjekte in der Reihenfolge ihrer
     Initialisierung (!) Felder vorhanden sind.
     Dialogelementobjekten, die keine Daten bertragen, werden
     auch keine Felder zugewiesen. Folgende Felder sind z.Z.
     notwendig:


       +--------------+--------------------------------------+
       | Objekt       | Transferpuffer-Feld                  |
       +--------------+--------------------------------------+
       | TCheckBox    | ein word (oder integer), das eine    |
       |              | der bf_XXXX-Konstanten enth„lt       |
       +--------------+--------------------------------------+
       | TTriState    | siehe TCheckBox                      |
       +--------------+--------------------------------------+
       | TRadioButton | siehe TCheckBox                      |
       +--------------+--------------------------------------+
       | TScrollBar   | ein TScrollBarTransferRec-Record     |
       |              | zum Speichern des Bereichs und der   |
       |              | Position der Bildlaufleiste          |
       +--------------+--------------------------------------+
       | TStatic      | ein string[x], wobei x:=TextLen-1    |
       |              | ist (d.h. die maximale Anzahl von    |
       |              | Zeichen in diesem Textobjekt ohne    |
       |              | das abschlieende Nullbyte);         |
       |              | ist x gerade, mu x um eins          |
       |              | erh”ht werden!                       |
       +--------------+--------------------------------------+
       | TEdit        | siehe TStatic                        |
       +--------------+--------------------------------------+
       | TComboBox    | wenn die ComboBox mit einem Eingabe- |
       |              | feld verknpft ist, wird zuerst ein  |
       |              | string (siehe TStatic) und dann ein  |
       |              | integer gespeichert; ansonsten wird  |
       |              | nur ein integer verwendet            |
       +--------------+--------------------------------------+

     Von den ObjectGEM-Dialogelementobjekten fhren TControl,
     TButton und TGroupBox keinen Transfer durch. Einzelne
     Objekte k”nnen mit den Methoden TControl.DisableTransfer und
     TControl.EnableTransfer vom Datentransfer ausgenommen bzw.
     daran beteiligt werden.

     Wenn man mit eigenen Dialogelementobjekten neue Feldtypen
     einfhrt, mu man beachten, da jeder Typ eine gerade L„nge
     haben mu, da es sonst frher oder sp„ter zu einem
     Adrefehler kommt...

Beispiel

     type

       SampleTransferRecord = record
         stat1   : string[x];  { zur Berechnung von }
         edit1   : string[y];  { x bzw. y  s.o.     }
         check1  : word;
         radio1  : word;
         tri1    : word;
         scroll1 : TScrollBarTransferRec;
         combed1s: string[z];
         combed1i: integer;
         comb2   : integer
       end;


4.8.6  TDialog.Init
-------------------

Deklaration

     constructor Init(AParent: PWindow; ATitle: string;
                                           Indx: integer);

Beschreibung

     Ruft den Vorfahren TWindow.Init auf und weist dem Objekt
     mittels TDialog.LoadDialog den Dialogbaum mit dem Index Indx
     zu. Zum Schlu wird die Methode TDialog.SetupSize
     aufgerufen.

     Wird in Indx id_No bergeben, wird der Dialogbaum nicht
     gesetzt; man sollte dann so bald wie m”glich die Methoden
     SetDlgTree und SetupSize selbst aufrufen. Diese Option
     sollte normalerweise nicht verwendet werden, allerdings
     k”nnen so im Speicher erzeugte Resourcen verwendet werden
     (das wird z.B. von TApplication.Alert gemacht).


4.8.7  TDialog.Done
-------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt alle Objekte der CtrlList-Liste frei und ruft dann den
     Vorfahren TWindow.Done auf.


4.8.8  TDialog.GetVDIHandle
---------------------------

Deklaration

     function GetVDIHandle: integer; virtual;

Beschreibung

     Gibt TApplication.vdiHandle zurck, d.h. Dialoge besitzen
     standardm„ig keine eigene VDI-Workstation.


4.8.9  TDialog.CallChanged
--------------------------

Deklaration

     procedure CallChanged(Indx: integer; dclk,
                             edt,push: boolean); virtual;

Beschreibung

     Wird immer dann aufgerufen, wenn ein anderes
     Dialogelement(-objekt) aktiv wird. In Indx wird der Index
     des neu aktiven Elements bergeben. dclk ist true, wenn die
     Anwahl durch Doppelklick erfolgt ist; edt ist true, wenn es
     sich bei dem neuen Element um ein Eingabefeld handelt (wird
     - wie push - intern ben”tigt).

     CallChanged versucht, per TControl.TestIndex das zum
     Dialogelement geh”rige Dialogelementobjekt zu finden. War
     die Suche erfolgreich, wird anschlieend TControl.Changed
     des betreffenden Objekts aufgerufen.

     Diese Methode sollte man nicht direkt aufrufen. Allerdings
     kann man sich durch šberschreiben in den Zeitpunkt
     einklinken, an dem die Benutzeraktionen am besten
     "berwacht" werden k”nnen.


4.8.10  TDialog.Cancel
----------------------

Deklaration

     function Cancel: boolean; virtual;

Beschreibung

     Wird aufgerufen, wenn der Dialog abgebrochen werden soll
     (z.B. weil der Benutzer auf <Abbruch> geklickt hat). Die
     Rckgabe ist true (default), wenn der Dialog beendet werden
     darf, false sonst.

     Wenn man diese Methode berschreibt, kann man auf den
     Abbruch angemessen reagieren (standardm„ig passiert
     nichts).


4.8.11  TDialog.CloseWindow
---------------------------

Deklaration

     procedure CloseWindow; virtual;

Beschreibung

     Schliet alle untergeordneten Fenster und beendet die
     Dialogbearbeitung (TDialog.Cont wird auf false gesetzt). Bei
     modalen Dialogen wird der Hintergrund restauriert, bei
     nicht-modalen Dialogen wird TWindow.CloseWindow aufgerufen.


4.8.12  TDialog.Create
----------------------

Deklaration

     procedure Create; virtual;

Beschreibung

     Wird von TDialog.MakeWindow aufgerufen, um den
     (Fenster-)Dialog zu erzeugen; natrlich kann diese Methode
     auch "von Hand" aufgerufen werden. Wenn ws_ex_Modeless nicht
     gesetzt ist oder ws_ex_TryModeless gesetzt, aber kein GEM-
     Fenster mehr verfgbar ist, wird TDialog.IsModal auf false
     gesetzt.

     Ist bis jetzt kein Fehler aufgetreten, wird Attr.Status auf
     ws_Created gesetzt, und die Abmessungen und Position des
     Dialog(fenster)s werden ermittelt, wobei ws_ex_Center,
     ws_ex_Center2Parent, ws_ex_CenterOnce und ein evtl.
     vorhandener virtueller Bildschirm (VSCR-Cookie) beachtet
     werden.

     Schlielich werden noch alle untergeordneten Dialoge
     erzeugt.


4.8.13  TDialog.Destroy
-----------------------

Deklaration

     procedure Destroy; virtual;

Beschreibung

     Zerst”rt zun„chst alle untergeordneten Dialoge. Danach wird
     der Dialog geschlossen (sofern dies noch nicht geschehen
     ist); bei modalen Dialogen wird nun IsModal auf false und
     Attr.Status auf ws_NoWindow gesetzt, bei nicht-modalen
     Dialogen wird TWindow.Destroy aufgerufen.


4.8.14  TDialog.EndDlg
----------------------

Deklaration

     procedure EndDlg(Indx: integer; DblClick: boolean); virtual;

Beschreibung

     Wird von TDialog.WMButton und vom Tastatur-Handler
     aufgerufen, wenn der Benutzer ein Dialogelement angew„hlt
     hat, mit dem der Dialog beendet werden kann. In Indx wird
     der Index des betreffenden Dialogelements bergeben; ist
     DblClick true, erfolgte die Anwahl mit Doppelklick.

     Zun„chst wird TDialog.Result auf Indx gesetzt. Dann wird mit
     TControl.TestID berprft, ob das zum Dialogelement geh”rige
     Objekt eine der Konstanten id_OK, id_Cancel, id_Help,
     id_Undo oder id_Esc enth„lt; ist dies der Fall, wird
     entsprechend OK, Cancel, TDialog.Help, TDialog.Undo oder
     TDialog.Esc aufgerufen. Besitzt das Objekt den Wert
     id_NoExit, wird der Dialog einfach nicht beendet.

     Konnte kein Objekt fr das Dialogelement gefunden werden,
     wird TDialog.ExitDlg gefragt, ob der Dialog beendet werden
     soll.

     Hat EndDlg bis jetzt keine positive Antwort zum Verlassen
     des Dialogs erhalten, wird die Dialogbearbeitung normal
     fortgesetzt. Ansonsten h„ngt das Ende nur noch von
     TWindow.CanClose ab.


4.8.15  TDialog.Esc
-------------------

Deklaration

     function Esc: boolean; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Esc> gedrckt oder ein
     Dialogelement angeklickt hat und ein passendes
     Dialogelementobjekt existiert, das den Wert id_Esc besitzt.

     Die Rckgabe ist true, wenn der Dialog beendet werden soll,
     false sonst (default).

     Wenn man diese Methode berschreibt, kann man z.B. die
     gerade laufende Aktion abbrechen.


4.8.16  TDialog.Execute
-----------------------

Deklaration

     procedure Execute; virtual;

Beschreibung

     Wird von TDialog.MakeWindow aufgerufen, wenn der
     abzuarbeitende Dialog modal ist, da in diesem Fall nicht auf
     die blichen Routinen, die das System nicht blockieren,
     zurckgegriffen werden kann. Solange TDialog.Cont true ist,
     wird mit evnt_multi() auf Ereignisse gewartet, die dann an
     den Tastatur-Handler bzw. an TDialog.WMButton verteilt
     werden.

     Bei modalen Dialogen ist es auerdem m”glich, diese durch
     Anklicken auf ein nicht anw„hlbares Dialogelement (z.B. den
     Hintergrund) auf dem Bildschirm zu verschieben.

     Wichtig: Wenn man Execute direkt aufruft, mu sichergestellt
     sein, da das System sowohl mit wind_update(BEG_UPDATE) als
     auch mit wind_update(BEG_MCTRL) blockiert ist! Normalerweise
     kmmern sich TDialog.OpenWindow/TDialog.CloseWindow darum.


4.8.17  TDialog.ExitDlg
-----------------------

Deklaration

     function ExitDlg(AnIndx: integer): boolean; virtual;

Beschreibung

     Wird von TDialog.EndDlg aufgerufen, wenn der Benutzer ein
     Dialogelement angew„hlt hat, mit dem der Dialog beendet
     werden kann, dem aber keine der id_XXXX-Konstanten
     zugewiesen ist.

     ExitDlg mu nun entscheiden, ob der Dialog verlassen werden
     soll. Standardm„ig wird true zurckgegeben, d.h. der Dialog
     wird beendet.

     In AnIndx wird der Index des angew„hlten Dialogelements
     bergeben.


4.8.18  TDialog.FirstThat
-------------------------

Deklaration

     function FirstThat(Test: PIterationFunc): PControl;

Beschreibung

     FirstThat ruft fr jedes Objekt der CtrlList-Liste die durch
     Test bestimmte boolesche Funktion auf, bis Test true
     zurckgibt. FirstThat gibt dann den Zeiger auf das Objekt
     zurck, fr den Test true zurckgegeben hat, oder nil, falls
     Test immer false geliefert hat. Der Pointer Test sollte eine
     globale (Unterschied zu ObjectWindows!) Funktion sein, der
     ein pointer-Parameter bergeben wird und die boolean
     zurckgibt.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Test-Funktion nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     function IstMarkiert(p: pointer): boolean;
       { ... }

     IstMarkiert sollte eine globale Funktion sein. Sei Dialog
     ein TDialog-Objekt:

     p:=Dialog.FirstThat(@IstMarkiert);


4.8.19  TDialog.ForEach
-----------------------

Deklaration

     procedure ForEach(Action: PIterationProc);

Beschreibung

     ForEach ruft fr jedes Objekt der CtrlList-Liste die durch
     Action bestimmte Prozedur auf. Der Pointer Action sollte
     eine globale (Unterschied zu ObjectWindows!) Prozedur sein,
     der ein pointer-Parameter bergeben wird.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Prozedur nicht auf die Variablen der bergeordneten
     Routine zugegriffen werden!

Beispiel

     procedure Markiere(p: pointer);
       { ... }

     Markiere sollte eine globale Prozedur sein. Sei Dialog ein
     TDialog-Objekt:

     Dialog.ForEach(@Markiere);


4.8.20  TDialog.GetClassName
----------------------------

Deklaration

     function GetClassName: string; virtual;

Beschreibung

     Gibt den Namen der Dialogklasse zurck. Abgeleitete
     Dialogobjekte, die wesentliche Ver„nderungen bzw.
     Erweiterungen gegenber TDialog besitzen, sollten diese
     Methode berschreiben, um einen anderen Namen zu liefern.
     TDialog gibt 'Dialog' zurck.


4.8.21  TDialog.GetFocus
------------------------

Deklaration

     function GetFocus: integer; virtual;

Beschreibung

     Wenn der Dialog mind. ein Eingabefeld besitzt, gibt GetFocus
     den Index des Feldes zurck, in dem sich z.Z. der
     Eingabecursor befindet.

     Besitzt der Dialog kein Eingabefeld oder ist der
     Eingabecursor momentan nicht aktiv, erh„lt man als Rckgabe
     id_No.


4.8.22  TDialog.GetKBHandler
----------------------------

Deklaration

     function GetKBHandler: PEvent; virtual;

Beschreibung

     Gibt einen Pointer auf den Tastatur-Handler des
     Dialogobjekts zurck. Der Handler ist nichts anderes als ein
     TEvent-Objekt, das direkt aufgerufen wird.

     Das Objekt wird in TDialog.SetupWindow initialisiert, vorher
     gibt GetKBHandler nil zurck.

     Als einzige Methode wurde TEvent.TestKey effektiv gemacht
     (d.h. berschrieben). Innerhalb dieser Methode werden die
     Alternate-Shortcuts sowie die <Help>-, <Undo>- und <Esc>-
     Taste ausgewertet. Auerdem wird hier die BubbleHelp
     realisiert.


4.8.23  TDialog.GetStyle
------------------------

Deklaration

     function GetStyle: integer; virtual;

Beschreibung

     Gibt eine Bitmap der GEM-Fensterkomponenten zurck, die fr
     TDialog.Create ben”tigt wird. TDialog.GetStyle liefert NAME
     or CLOSER or MOVER. Sollen andere Fensterelemente benutzt
     werden, mu man diese Methode berschreiben (es ist z.B.
     kein Problem, auch einem Dialogfenster ein SIZER-Element
     zuzuweisen).

     Ab AES 4.10 wird zus„tzlich SMALLER fr die Iconification
     geliefert und, wenn der Backdrop-Mechanismus untersttzt
     wird, BACKDROP (z.Z. nur unter MagiC).


4.8.24  TDialog.GetWindowClass
------------------------------

Deklaration

     procedure GetWindowClass(var AWndClass: TWndClass); virtual;

Beschreibung

     Fllt das Feld Class aus, das die Dialogklasse beschreibt.
     Soll der Fensterdialog andere grundlegende Eigenschaften
     besitzen, mu diese Methode berschrieben werden.

     Wichtig: In diesem Fall mu in der neuen Methode zuerst die
     ursprngliche Methode aufgerufen werden, da es sonst mit
     einiger Sicherheit einen Programmabsturz gibt...

     Von den Werten, die TWindow.GetWindowClass ermittelt, wird
     cs_CreateOnAccOpen gel”scht und cs_SaveBits bzw.
     cs_WorkBackground neu gesetzt. Class.hbrBackground wird auf
     Null gesetzt.

Beispiel

     procedure TD.GetWindowClass(var AWndClass: TWndClass);

       begin
         inherited GetWindowClass(AWndClass);
         { ... }
       end;


4.8.25  TDialog.GetWorkMax
--------------------------

Deklaration

     procedure GetWorkMax(var maxX,maxY: integer); virtual;

Beschreibung

     maxX und maxY werden auf die gr”e des Hintergrundobjekts
     der Dialogbox gesetzt, d.h. bei einem Fensterdialog kann das
     Fenster nie gr”er als die Dialogbox werden.


4.8.26  TDialog.Help
--------------------

Deklaration

     function Help: boolean; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Help> gedrckt oder ein
     Dialogelement angeklickt hat und ein passendes
     Dialogelementobjekt existiert, das den Wert id_Help besitzt.

     Die Rckgabe ist true, wenn der Dialog beendet werden soll,
     false sonst (default).

     Wenn man diese Methode berschreibt, kann man z.B. eine
     gr”ere Hilfe-Dialogbox zum gerade aktuellen Dialog
     anzeigen.


4.8.27  TDialog.InitFocus
-------------------------

Deklaration

     procedure InitFocus; virtual;

Beschreibung

     Initialisiert den Eingabecursor, d.h. dieser wird auf das
     (von der Resource-Hierarchie her) erste Eingabefeld gesetzt.
     Wird von TDialog.SetFocus aufgerufen.


4.8.28  TDialog.IsDialog
------------------------

Deklaration

     function IsDialog: boolean; virtual;

Beschreibung

     Gibt true zurck, d.h. das Fenster ist ein Dialogfenster.
     Wird intern ben”tigt, da TWindow- und TDialog-Objekte in den
     gleichen Listen (MainWindow bzw. ChildList) verwaltet
     werden.


4.8.29  TDialog.LoadDialog
--------------------------

Deklaration

     procedure LoadDialog(Indx: integer); virtual;

Beschreibung

     Wird von TDialog.Init aufgerufen, um den Dialog im
     Objektbaum Indx mit dem Dialogobjekt zu verknpfen.

     Damit der Dialogbaum in beliebig vielen Fenstern
     gleichzeitig verwendet und bearbeitet werden kann, wird der
     komplette Baum umkopiert, so da alle nderungen an einer
     Kopie vorgenommen werden, die von TDialog.FreeDialog wieder
     gel”scht wird. Wenn der bergebene Dialogbaum gltig ist,
     wird anschlieend TWindow.LoadDialog aufgerufen.


4.8.30  TDialog.FreeDialog
--------------------------

Deklaration

     procedure FreeDialog; virtual;

Beschreibung

     Gibt den mit TDialog.LoadDialog installierten Dialogbaum
     (und den dafr allozierten Speicher) wieder frei.


4.8.31  TDialog.MakeWindow
--------------------------

Deklaration

     procedure MakeWindow; virtual;

Beschreibung

     Ruft zuerst TDialog.Create und dann TDialog.OpenWindow auf.
     Handelt es sich um einen modalen Dialog, wird dieser dann
     mit TDialog.Execute abgearbeitet.


4.8.32  TDialog.ObjcPaint
-------------------------

Deklaration

     procedure ObjcPaint(Indx: integer; Lazy: boolean); virtual;

Beschreibung

     Zeichnet das Dialogelement mit dem Index Indx neu. Dabei
     wird beachtet, ob der Dialog ge”ffnet ist und ob er sich in
     einem Fenster befindet.

     Ist Lazy true und AES 4.0 oder h”her vorhanden, wird das
     Dialogelement nur gezeichnet, wenn keine andere Applikation
     den Bildschirm blockiert. So k”nnen z.B. Statusanzeigen
     realisiert werden.

     Wird u.a. von TControl.Paint aufgerufen.


4.8.33  TDialog.OK
------------------

Deklaration

     function OK: boolean; virtual;

Beschreibung

     Wird aufgerufen, wenn der Dialog erfolgreich beendet werden
     soll (z.B. weil der Benutzer auf <OK> geklickt hat). Die
     Rckgabe ist true, wenn der Dialog beendet werden darf,
     false sonst.

     Intern werden zun„chst alle TEdit-Objekte mit deren
     TEdit.CanClose-Methode berprft. Liefern alle true zurck,
     wird anschlieend die Methode TransferData(tf_GetData)
     aufgerufen und true zurckgegeben.


4.8.34  TDialog.OpenWindow
--------------------------

Deklaration

     procedure OpenWindow; virtual;

Beschreibung

     Wird von TDialog.MakeWindow aufgerufen.

     Zun„chst wird geprft, ob ws_ex_Popup gesetzt ist und die
     Dialogposition evtl. korrigiert. Dann wird der Eingabecursor
     initialisiert und TransferData mit dem Parameter tf_SetData
     aufgerufen.

     Wenn es sich um einen modalen Dialog handelt, wird nun eine
     wind_update()-Schachtelung sowohl mit BEG_UPDATE als auch
     mit BEG_MCTRL durchgefhrt. Danach wird Attr.Status auf
     ws_Open gesetzt und der Dialog gezeichnet.

     Ansonsten wird die geerbte TWindow.OpenWindow-Methode
     aufgerufen.


4.8.35  TDialog.Paint
---------------------

Deklaration

     procedure Paint(var PaintInfo: TPaintStruct); virtual;

Beschreibung

     Mittels objc_draw() wird die Dialogbox gezeichnet.
     Anschlieend wird noch der Eingabecursor dargestellt.

     Diese Methode sollte nie direkt aufgerufen werden, sondern
     immer nur mittels ForceRedraw, WMRedraw oder
     TApplication.InvalidateRect. Wer meint, dies dennoch tun zu
     mssen, mu darauf achten, vor dem Aufruf von Paint die
     Methoden TDialog.UpdateDialog und InitPaint sowie nach dem
     Aufruf ExitPaint aufzurufen.


4.8.36  TDialog.SetFocus
------------------------

Deklaration

     procedure SetFocus(Obj: integer); virtual;

Beschreibung

     Setzt den Eingabecursor auf das Eingabefeld mit dem Index
     Obj. Wenn dies kein gltiges Eingabefeld ist (Objekt ist
     versteckt, disabled oder berhaupt gar kein Eingabefeld),
     wird InitFocus aufgerufen.


4.8.37  TDialog.SetupSize
-------------------------

Deklaration

     procedure SetupSize; virtual;

Beschreibung

     Berechnet die Anfangsgr”e des Dialogfensters.

     Nach dem Aufruf von TWindow.SetupSize wird TWindow.Work an
     die Ausmae des Dialogs angepat.

     Wird von TDialog.Init aufgerufen.


4.8.38  TDialog.SetupWindow
---------------------------

Deklaration

     procedure SetupWindow; virtual;

Beschreibung

     In dieser Methode sollten alle Einstellungen, die das
     Dialogfenster (d.h. nicht nur das Dialogobjekt an sich)
     betreffen, vorgenommen werden. Wird von TDialog.Init (bzw.
     TWindow.Init) aufgerufen.

     Wird diese Methode berschrieben, sollte die geerbte Methode
     nach M”glichkeit am Anfang der neuen Methode aufgerufen
     werden.

     Attr.ExStyle wird mit ws_ex_TryModeless+ws_ex_CenterOnce
     initialisiert. Wenn global as_MoveTransparent oder
     as_MoveDials gesetzt ist, dann wird zus„tzlich noch
     ws_ex_MoveTransparent bzw. ws_ex_MoveDial gesetzt.

     Cont, CtrlList, TransferBuffer und IsModal werden
     initialisiert, und drei TKey-Objekte (siehe
     TWindow.SetupWindow) sowie der Tastatur-Handler werden
     installiert.


4.8.39  TDialog.TransferData
----------------------------

Deklaration

     procedure TransferData(Direction: word); virtual;

Beschreibung

     Wenn der Transfermechanismus durch Setzen von TransferBuffer
     auf einen Datentransfer-Puffer eingeschaltet ist, bertr„gt
     diese Methode Daten zwischen dem Puffer und den TControl-
     Objekten, bei denen wb_Transfer gesetzt ist.

     TranferData ruft die Transfer-Methode jedes beteiligten
     Dialogelementobjekts auf und bergibt einen Zeiger auf das
     betreffende Feld des Transfer-Puffers sowie die in Direction
     vorgegebene Richtung.

     Direction mu eine der tf_XXXX-Konstanten enthalten.


4.8.40  TDialog.Undo
--------------------

Deklaration

     function Undo: boolean; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Undo> gedrckt oder ein
     Dialogelement angeklickt hat und ein passendes
     Dialogelementobjekt existiert, das den Wert id_Undo besitzt.

     Die Rckgabe ist true, wenn der Dialog beendet werden soll,
     false sonst (default).

     Wenn man diese Methode berschreibt, kann man z.B. eine
     gerade ausgefhrte Aktion rckg„ngig machen.


4.8.41  TDialog.UpdateDialog
----------------------------

Deklaration

     procedure UpdateDialog; virtual;

Beschreibung

     Wenn der Dialog modal ist, wird zun„chst TWindow.Work auf
     Curr gesetzt. Danach wird die geerbte Methode
     TWindow.UpdateDialog aufgerufen.

     Braucht (und sollte) nicht direkt aufgerufen werden.


4.8.42  TDialog.WMButton
------------------------

Deklaration

     procedure WMButton(mX,mY,BStat,KStat,
                          Clicks: integer); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn der Benutzer
     auf ein Dialogelement geklickt hat.

     In dieser Methode wird im wesentlichen die Benutzeranwahl
     mit einer ObjectGEM-internen form_button()-Routine
     ausgewertet. Auerdem wird hier ein Klick mit der rechten
     Maustaste an den Tastatur-Handler weitergeleitet, der dann -
     wenn vorhanden - eine BubbleHelp anzeigt.

     Bei modalen Dialogen wird hier auch das Verschieben des
     Dialogs durchgefhrt.


4.8.43  TDialog.WMClosed
------------------------

Deklaration

     procedure WMClosed; virtual;

Beschreibung

     Wenn TWindow.CanClose true zurckgibt, wird der Dialog
     beendet und mit TDialog.Destroy freigegeben. Zuvor mu
     allerdings auch OK bzw. - wenn cs_CancelOnClose gesetzt ist
     - Cancel true geliefert haben. Wenn der zu OK bzw. Cancel
     geh”rige Button disabled ist, kann der Dialog nicht
     verlassen werden!

     Kann der Dialog verlassen werden, wird - sofern
     cs_QuitOnClose gesetzt ist - die Applikation beendet.

     Wird von TApplication.MUMesag aufgerufen.


4.8.44  TDialog.Cut
-------------------

Deklaration

     procedure Cut; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<X> drckt.
     Wenn ein Eingabefeld aktiv ist, wird die zugeh”rige
     TEdit.Cut-Methode aufgerufen.


4.8.45  TDialog.Delete
----------------------

Deklaration

     procedure Delete; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Delete> drckt.
     Standardm„ig wird der Tastendruck an den Tastatur-Handler
     weitergeleitet.


4.8.46  TDialog.Copy
--------------------

Deklaration

     procedure Copy; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<C> drckt.
     Wenn ein Eingabefeld aktiv ist, wird die zugeh”rige
     TEdit.Copy-Methode aufgerufen.


4.8.47  TDialog.Paste
---------------------

Deklaration

     procedure Paste; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<V> drckt.
     Wenn ein Eingabefeld aktiv ist, wird die zugeh”rige
     TEdit.Paste-Methode aufgerufen.


4.8.48  TDialog.SetDefaultButton
--------------------------------

Deklaration

     procedure SetDefaultButton(Obj: integer); virtual;

Beschreibung

     Macht das Dialogelement mit dem Index Obj zum neuen
     Default-Button.


4.8.49  TDialog.GetDefaultButton
--------------------------------

Deklaration

     function GetDefaultButton: integer; virtual;

Beschreibung

     Liefert den Dialogelementindex des aktuellen Default-
     Buttons.


4.9  TEdit
==========

Mit TEdit werden einzeilig Eingabefelder verwaltet, die zum Einlesen
von beliebigen Zeichenketten verwendet werden. Zus„tzlich kann eine
Eingabeprfung mit Hilfe der Validierungsobjekte vorgenommen werden.

Pointer

     PEdit = ^TEdit;

Felder

   ù Clipboard (siehe "TEdit.Clipboard")

   ù Validator (siehe "TEdit.Validator")

Methoden

   ù Init (siehe "TEdit.Init")

   ù Done (siehe "TEdit.Done")

   ù CanClose (siehe "TEdit.CanClose")

   ù CanUndo (siehe "TEdit.CanUndo")

   ù Clear (siehe "TEdit.Clear")

   ù ClearModify (siehe "TEdit.ClearModify")

   ù Copy (siehe "TEdit.Copy")

   ù Cut (siehe "TEdit.Cut")

   ù Edit (siehe "TEdit.Edit")

   ù Focus (siehe "TEdit.Focus")

   ù GetClipboard (siehe "TEdit.GetClipboard")

   ù GetCursor (siehe "TEdit.GetCursor")

   ù IsModified (siehe "TEdit.IsModified")

   ù IsValid (siehe "TEdit.IsValid")

   ù Paint (siehe "TEdit.Paint")

   ù Paste (siehe "TEdit.Paste")

   ù SetColor (siehe "TEdit.SetColor")

   ù SetCursor (siehe "TEdit.SetCursor")

   ù SetState (siehe "TEdit.SetState")

   ù SetText (siehe "TEdit.SetText")

   ù SetValidator (siehe "TEdit.SetValidator")

   ù Undo (siehe "TEdit.Undo")

Vorfahre

   ù TStatic

Nachfahren

     -


4.9.1  TEdit.Validator
----------------------

Deklaration

     Validator: PValidator;  (nur lesen)

Beschreibung

     Zeigt auf das mit diesem Objekt verbundene
     Validierungsobjekt. Ist ein solches nicht vorhanden, hat
     Validator den Wert nil.

     Ein Validierungsobjekt sollte einem TEdit-Objekt nur mittels
     SetValidator zugeordnet werden.


4.9.2  TEdit.Clipboard
----------------------

Deklaration

     Clipboard: PClipboard;  (nur lesen)

Beschreibung

     Zeigt auf das mit dem TEdit-Objekt verknpfte TClipboard-
     Objekt (oder ist nil, wenn ein solches nicht existiert).

     Wird mit TEdit.GetClipboard gesetzt.


4.9.3  TEdit.Init
-----------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx,
                        ATextLen: integer; Hlp: string);

Beschreibung

     Ruft den Vorfahren TStatic.Init auf, setzt TControl.Style
     auf cs_Edit+es_Undo und beteiligt das Objekt am
     Transfermechanismus. Danach wird Validator auf nil gesetzt,
     ClearModify aufgerufen und der Undo-Puffer vorbereitet.

     Wenn das zugeh”rige Dialogelement nicht vom Typ G_FTEXT oder
     G_FBOXTEXT ist oder TextLen kleiner als 2 ist, wird die
     Initialisierung abgebrochen. ATextLen gibt die L„nge des
     editierbaren Textes plus 1 an. Wird hier ein zu kleiner Wert
     bergeben, funktioniert die Eingabe u.U. nicht korrekt.


4.9.4  TEdit.Done
-----------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt den Speicher des Undo-Puffers frei, entfernt das
     Validierungsobjekt mit SetValidator(nil) und gibt
     TEdit.Clipboard frei, wenn ein neues Klemmbrett-Objekt
     installiert wurde.

     Zum Schlu wird TStatic.Done aufgerufen.


4.9.5  TEdit.CanClose
---------------------

Deklaration

     function CanClose: boolean; virtual;

Beschreibung

     Liefert normalerweise true zurck, d.h. der Dialog darf
     beendet werden. Gibt allerdings IsValid(true) false zurck
     und ist das Dialogelement nicht disabled, liefert CanClose
     false, und der Cursor wird mittels Focus zu diesem Objekt
     bewegt.


4.9.6  TEdit.CanUndo
--------------------

Deklaration

     function CanUndo: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn der Undo-Puffer Zeichen enth„lt, d.h.
     wenn die letzte Bearbeitung rckg„ngig gemacht werden kann.

     Wenn es_Undo nicht gesetzt ist, wird immer false
     zurckgegeben.


4.9.7  TEdit.Clear
------------------

Deklaration

     procedure Clear; virtual;

Beschreibung

     Ruft den Vorfahren TStatic.Clear auf, beachtet aber
     zus„tzlich den Eingabe-Cursor.


4.9.8  TEdit.Paint
------------------

Deklaration

     procedure Paint; virtual;

Beschreibung

     Ruft den Vorfahren TControl.Paint auf, beachtet aber
     zus„tzlich den Eingabe-Cursor.


4.9.9  TEdit.ClearModify
------------------------

Deklaration

     procedure ClearModify; virtual;

Beschreibung

     Setzt das nderungsflag fr das Eingabefeld zurck.


4.9.10  TEdit.Cut
-----------------

Deklaration

     procedure Cut; virtual;

Beschreibung

     L”scht den Text im Eingabefeld und legt ihn im Klemmbrett
     (siehe "Clipboard-Verwaltung") ab. Wird von TDialog.Cut
     aufgerufen.


4.9.11  TEdit.Copy
------------------

Deklaration

     procedure Copy; virtual;

Beschreibung

     Kopiert den Text des Eingabefeldes ins Klemmbrett (siehe
     "Clipboard-Verwaltung"). Wird von TDialog.Copy aufgerufen.


4.9.12  TEdit.Paste
-------------------

Deklaration

     procedure Paste; virtual;

Beschreibung

     Fgt die erste Zeile des Textes im Klemmbrett (siehe "Clip-
     board-Verwaltung") an der aktuellen Cursorposition im
     Eingabefeld ein. Wird von TDialog.Paste aufgerufen.


4.9.13  TEdit.Edit
------------------

Deklaration

     procedure Edit; virtual;

Beschreibung

     Wird bei jedem Zeichen aufgerufen, das in das Eingabefeld
     eingefgt wird. In dieser Methode wird der Undo-Puffer und
     das nderungsflag gesetzt und das Validierungsobjekt
     abgefragt, wenn bei diesem das Flag voOnEdit gesetzt ist.

     Wenn diese Methode berschrieben wird, mu als erstes die
     ursprngliche Methode aufgerufen werden.


4.9.14  TEdit.Focus
-------------------

Deklaration

     procedure Focus; virtual;

Beschreibung

     Ruft Parent (siehe "TControl.Parent")^.SetFocus(ObjIndx
     (siehe "TControl.ObjIndx")) auf und bewegt damit den
     Eingabe-Cursor auf dieses Dialogelement.


4.9.15  TEdit.GetClipboard
--------------------------

Deklaration

     function GetClipboard: PClipboard; virtual;

Beschreibung

     Liefert das TClipboard-Objekt, das mit dem TEdit-Objekt
     verknpft wird.

     Standardm„ig wird Parent (siehe "TControl.Parent")^.Clip-
     board (siehe "TWindow.Clipboard") zurckgegeben. Will man
     ein spezialisiertes Klemmbrett-Objekt installieren, mu man
     diese Methode berschreiben. Wichtig: Ein solches Objekt
     wird dann von TEdit.Done freigegeben!


4.9.16  TEdit.GetCursor
-----------------------

Deklaration

     function GetCursor: integer; virtual;

Beschreibung

     Gibt die Position des Eingabe-Cursors zurck: 0=ganz am
     Anfang (vor dem Text), Textl„nge=am Ende (hinter dem Text).

     Wichtig: Dies sagt nichts darber aus, ob dieses Eingabefeld
     auch aktiv ist. Dazu mu TControl.ObjIndx mit
     TDialog.GetFocus des zugeh”rigen Dialogobjekts verglichen
     werden, und zus„tzlich mu TDialog.Attr.Status=ws_Open sein.
     ObjectGEM verwaltet n„mlich pro Eingabefeld einen eigenen
     Cursor, und dessen Position wird solange gespeichert, bis
     das entsprechende Dialogelementobjekt aus dem Speicher
     entfernt wird.


4.9.17  TEdit.IsModified
------------------------

Deklaration

     function IsModified: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn der Text im Eingabefeld ge„ndert
     wurde.

     Wichtig: Das nderungsflag wird nicht automatisch auf false
     gesetzt, dazu mu ClearModify aufgerufen werden.


4.9.18  TEdit.IsValid
---------------------

Deklaration

     function IsValid(ReportError: boolean): boolean;
                                                virtual;

Beschreibung

     Gibt true zurck, wenn der Text des Eingabefeldes gltig
     ist. IsValid gibt immer true zurck, wenn kein
     Validierungsobjekt mit diesem TEdit-Objekt verknpft ist.
     Andernfalls wird, wenn ReportError true ist, die Rckgabe
     von TValidator.Valid weitergereicht, ansonsten die von
     TValidator.IsValid.


4.9.19  TEdit.SetColor
----------------------

Deklaration

     procedure SetColor(Color: integer); virtual;

Beschreibung

     Ruft den Vorfahren TControl.SetColor auf, beachtet aber
     zus„tzlich den Eingabe-Cursor.


4.9.20  TEdit.SetCursor
-----------------------

Deklaration

     procedure SetCursor(CPos: integer); virtual;

Beschreibung

     Setzt den Eingabe-Cursor an die Position CPos
     (0..Textl„nge). Wenn es sich um das aktive Eingabefeld eines
     sichtbaren Dialogs handelt, wird der Cursor an der neuen
     Position gezeichnet.


4.9.21  TEdit.SetValidator
--------------------------

Deklaration

     procedure SetValidator(AValid: PValidator); virtual;

Beschreibung

     Gibt das eventuell schon vorhandene Validierungsobjekt frei
     und setzt dann Validator auf AValid.


4.9.22  TEdit.SetState
----------------------

Deklaration

     procedure SetState(StateFlag: integer); virtual;

Beschreibung

     Ruft den Vorfahren TControl.SetState auf, beachtet aber
     zus„tzlich den Eingabecursor.


4.9.23  TEdit.SetText
---------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     Setzt den Text des Eingabefeldes. Mute berschrieben
     werden, damit der Undo-Puffer, das nderungsflag und der
     Cursor korrekt behandelt werden. Intern wird trotzdem noch
     TStatic.SetText aufgerufen (hierbei ist es vielleicht
     interessant zu wissen, da bei TEdit-Objekten sts_Fill
     normalerweise nicht gesetzt ist).


4.9.24  TEdit.Undo
------------------

Deklaration

     procedure Undo; virtual;

Beschreibung

     Macht die letzte nderung rckg„ngig, wenn im Undo-Puffer
     eine entsprechende Zeichenkette vorhanden ist.


4.10  TEvent
============

TEvent berprft die Gltigkeit von GEM-Ereignissen, die an
TApplication- und TWindow-Objekte gemeldet werden. Wenn also z.B. ein
Fenster auf eine spezielle Nachricht reagieren soll, mu diesem
Fenster ein abgeleitetes TEvent-Objekt zugeordnet werden, das (in
diesem Fall) auf TestMessage positiv antwortet. Zur Abfrage einer
Menanwahl existieren spezielle TKeyMenu-Objekte.

Pointer

     PEvent = ^TEvent;

Felder

   ù Parent (siehe "TEvent.Parent")

   ù Style (siehe "TEvent.Style")

Methoden

   ù Init (siehe "TEvent.Init")

   ù Done (siehe "TEvent.Done")

   ù Next (siehe "TEvent.Next")

   ù Previous (siehe "TEvent.Previous")

   ù TestButton (siehe "TEvent.TestButton")

   ù TestKey (siehe "TEvent.TestKey")

   ù TestMenu (siehe "TEvent.TestMenu")

   ù TestMessage (siehe "TEvent.TestMessage")

   ù TestMouse (siehe "TEvent.TestMouse")

   ù Work (siehe "TEvent.Work")

Vorfahre

   ù TObject

Nachfahren

   ù TIcon

   ù TKeyMenu

   ù TPopup

   ù TToolbar


4.10.1  TEvent.Parent
---------------------

Deklaration

     Parent: PEventObject;  (nur lesen)

Beschreibung

     Enth„lt einen Zeiger auf das zugeh”rige TEventObject (d.h.
     TApplication oder TWindow). Wird von TEvent.Init gesetzt.


4.10.2  TEvent.Style
--------------------

Deklaration

     Style: word;  (nur lesen)

Beschreibung

     Wird von TEvent.Init mit Null initialisiert. Abgeleitete
     Objekte k”nnen hier eine der es_XXXX-Konstanten eintragen,
     mit denen wichtige Objekttypen unterschieden werden k”nnen.


4.10.3  TEvent.Init
-------------------

Deklaration

     constructor Init(AParent: PEventObject);

Beschreibung

     Ruft den Vorfahren TObject.Init auf und setzt TEvent.Parent
     auf AParent. Ist AParent=nil, wird Parent auf Application
     gesetzt. Danach installiert sich das Objekt in der EventList
     des durch Parent angegebenen TEventObject. TEvent.Style wird
     auf Null gesetzt.


4.10.4  TEvent.Done
-------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Entfernt sich selbst aus der EventList des durch
     TEvent.Parent angegebenen TEventObject und ruft dann
     TObject.Done auf.


4.10.5  TEvent.Next
-------------------

Deklaration

     function Next: PEvent;

Beschreibung

     Gibt einen Zeiger auf das n„chste TEvent-Objekt in der
     EventList des zugeh”rigen TEventObject zurck. Ist kein
     weiteres Objekt vorhanden, erh„lt man einen nil-Zeiger.


4.10.6  TEvent.Previous
-----------------------

Deklaration

     function Previous: PEvent;

Beschreibung

     Gibt einen Zeiger auf das vorhergehende TEvent-Objekt in der
     EventList des zugeh”rigen TEventObject zurck. Ist kein
     weiteres Objekt vorhanden, erh„lt man einen nil-Zeiger, d.h.
     in diesem Fall zeigt EventList genau auf das aktuelle
     Objekt.


4.10.7  TEvent.TestKey
----------------------

Deklaration

     function TestKey(Stat,Key: integer): boolean;
                                          virtual;

Beschreibung

     Gibt false zurck. Mu berschrieben werden, damit das
     Objekt Tastendrcke berprfen kann. Sollte dann true
     zurckgeben, wenn die in Stat und Key bergebenen Werte die
     gesuchten sind. Key entspricht der Rckgabe von
     evnt_keybd(), Stat dem Tastaturzustand von evnt_button().


4.10.8  TEvent.TestMenu
-----------------------

Deklaration

     function TestMenu(mNum: integer): boolean; virtual;

Beschreibung

     Gibt false zurck. Mu berschrieben werden, damit das
     Objekt die Anwahl eines Meneintrags berprfen kann. Sollte
     dann true zurckgeben, wenn mNum dem gewnschten Index des
     Menbaums entspricht.


4.10.9  TEvent.TestButton
-------------------------

Deklaration

     function TestButton(mX,mY,BStat,KStat,Clicks:
                              integer): boolean; virtual;

Beschreibung

     Gibt false zurck. Mu berschrieben werden, damit das
     Objekt Mausklicks berprfen kann. Sollte dann true
     zurckgeben, wenn die gewnschten Werte bergeben werden.
     Die Variablen entsprechen denen von evnt_button(), Clicks
     gibt die Anzahl der Mausklicks an, die zu dem Ereignis
     gefhrt haben.


4.10.10  TEvent.TestMouse
-------------------------

Deklaration

     function TestMouse(M,mX,mY,BStat,KStat: integer):
                                        boolean; virtual;

Beschreibung

     Gibt false zurck. Mu berschrieben werden, damit das
     Objekt berprfen kann, ob die Maus einen rechteckigen
     Bereich betritt oder verl„t. Die Variablen sind wie bei
     evnt_mouse() belegt, M gibt die Nummer des Rechtecks (MU_M1,
     MU_M2) an (siehe evnt_multi()).

     Wichtig: Diese Methode sollte nicht berschrieben werden, da
     die Rechtecke intern von ObjectGEM fr die Fensterklassen-
     Mauscursor verwendet werden.


4.10.11  TEvent.TestMessage
---------------------------

Deklaration

     function TestMessage(Pipe: Pipearray): boolean;
                                            virtual;

Beschreibung

     Gibt false zurck. Mu berschrieben werden, damit das
     Objekt GEM-Nachrichten berprfen kann. Sollte im
     Erfolgsfall true zurckgeben. Pipearray entspricht dem
     ARRAY_8 von evnt_mesag().


4.10.12  TEvent.Work
--------------------

Deklaration

     procedure Work; virtual;

Beschreibung

     Macht gar nichts. Kann aber z.B. von den TestXXXX-Methoden
     im Falle eines erfolgreichen Tests aufgerufen werden, was
     u.a. von TKeyMenu getan wird. An dieser Stelle steht dann
     z.B. die Abarbeitung einer zu einem Meneintrag geh”rigen
     Dialogbox etc.


4.11  TEventObject
==================

TEventObject definiert ein grundlegendes Objekt, das auf GEM-
Ereignisse ("Events", "Messages") reagieren kann. TEventObject
verwaltet mit EventList TEvent-Objekte, mit deren Methoden die
Gltigkeit eines Ereignisses berprft werden kann.

Pointer

     PEventObject = ^TEventObject;

Felder

   ù EventList (siehe "TEventObject.EventList")

Methoden

   ù Init (siehe "TEventObject.Init")

   ù Done (siehe "TEventObject.Done")

Vorfahre

   ù TObject

Nachfahren

   ù TApplication

   ù TWindow


4.11.1  TEventObject.EventList
------------------------------

Deklaration

     EventList: PEvent;  (nur lesen)

Beschreibung

     EventList ist eine Liste von Zeigern auf TEvent-Objekte.
     Zwischen den Objekten bestehen Verweise mit TEvent.Previous
     und TEvent.Next, EventList zeigt auf das erste Element der
     Liste. TEvent-Objekte tragen sich bei ihrer Initialisierung
     automatisch in diese Liste ein.


4.11.2  TEventObject.Init
-------------------------

Deklaration

     constructor Init;

Beschreibung

     Init ruft den Vorfahren TObject.Init auf und initialisiert
     EventList mit nil.


4.11.3  TEventObject.Done
-------------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Entfernt alle in EventList eingetragenen Objekte mit ihrer
     Free-Methode und ruft dann TObject.Done auf.


4.12  TFilterValidator
======================

Das Objekt TFilterValidator berwacht ein Eingabefeld, in das der
Anwender Zeichen eingibt, und vergleicht die Eingabe mit einem Satz
erlaubter Zeichen. Wurde ein Zeichen eingegeben, das nicht in diesem
Satz enthalten ist, wird eine ungltige Eingabe gemeldet. Teilweise
wird dieses Verhalten schon vom GEM abgedeckt (siehe TEDINFO-
Struktur), allerdings ist dieses Validierungsobjekt wesentlich
flexibler, da eine beliebige Menge an erlaubten Zeichen angegeben
werden kann.

Pointer

     PFilterValidator = ^TFilterValidator;

Felder

   ù ValidChars (siehe "TFilterValidator.ValidChars")

Methoden

   ù Init (siehe "TFilterValidator.Init")

   ù Error (siehe "TFilterValidator.Error")

   ù IsValid (siehe "TFilterValidator.IsValid")

   ù IsValidInput (siehe "TFilterValidator.IsValidInput")

Vorfahre

   ù TValidator

Nachfahre

   ù TRangeValidator


4.12.1  TFilterValidator.ValidChars
-----------------------------------

Deklaration

     ValidChars: TCharSet;

Beschreibung

     Speichert den Satz fr die Eingabe gltiger Zeichen. Sollen
     z.B. nur Ziffern erlaubt sein, mu ValidChars den Wert
     ['0'..'9'] haben.

     Wird von TFilterValidator.Init gesetzt.


4.12.2  TFilterValidator.Init
-----------------------------

Deklaration

     constructor Init(ValidCharSet: TCharSet);

Beschreibung

     Ruft TValidator.Init auf und setzt dann ValidChars auf
     ValidCharSet und Options auf voOnEdit.


4.12.3  TFilterValidator.Error
------------------------------

Deklaration

     procedure Error; virtual;

Beschreibung

     Zeigt die Fehlermeldung an, da die Eingabe ungltige
     Zeichen enth„lt.


4.12.4  TFilterValidator.IsValid
--------------------------------

Deklaration

     function IsValid(s: string): boolean; virtual;

Beschreibung

     Vergleicht jedes Zeichen in s mit ValidChars. Ist jedes
     Zeichen gltig und liefert TValidator.IsValid true, wird
     true zurckgegeben.


4.12.5  TFilterValidator.IsValidInput
-------------------------------------

Deklaration

     function IsValidInput(var s: string;
               SuppressFill: boolean): boolean; virtual;

Beschreibung

     Vergleicht jedes Zeichen in s mit ValidChars. Ist jedes
     Zeichen gltig (evtl. werden dazu Klein- in Grobuchstaben
     umgewandelt), wird true zurckgegeben, sonst false.

     Ist s ein Leerstring, ist die Rckgabe immer true.


4.13  TGroupBox
===============

Macht aus "normalen" Rechteck-Elementen eine Groupbox, d.h. es wird
eine šberschrift ausgegeben. Weitere Aktionen sind von TGroupBox nicht
n”tig, da die durch das Rechteck-Element vorgegebene Hierarchie
automatisch vom GEM-Objekt-Manager beachtet wird.

Pointer

     PGroupBox = ^TGroupBox;

Methoden

   ù Init (siehe "TGroupBox.Init")

   ù Done (siehe "TGroupBox.Done")

   ù GetText (siehe "TGroupBox.GetText")

   ù SetText (siehe "TGroupBox.SetText")

Vorfahre

   ù TControl

Nachfahren

     -


4.13.1  TGroupBox.Init
----------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx: integer;
                                     ATitle,Hlp: string);

Beschreibung

     Ruft den Vorfahren TControl.Init auf. AnIndx mu dabei der
     Index eines G_BOX-Elements sein. ATitle ist der Titel der
     Groupbox. TControl.Style wird auf cs_GroupBox gesetzt.


4.13.2  TGroupBox.Done
----------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Macht aus dem TGroupBox-Objekt wieder ein "normales"
     Rechteck-Element und ruft danach den Vorfahren TControl.Done
     auf.


4.13.3  TGroupBox.SetText
-------------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     Gibt der GroupBox eine neue šberschrift und zeichnet das
     Dialogelement neu.


4.13.4  TGroupBox.GetText
-------------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Liefert den Titel der GroupBox.


4.14  TIcon
===========

Mit diesem Objekttyp werden Icons verwaltet. Jedes Icon sollte mit
einem TIcon-Objekt verknpft werden, da hierdurch eine automatische
Selektion, Verschiebung etc. m”glich ist. Als Nachfahren von TEvent
h„ngen sich die Icons in die EventList ein. Zur Auswertung stehen u.a.
die Methoden IconSelect, FirstIcon und NextIcon zur Verfgung.

Pointer

     PIcon = ^TIcon;

Felder

   ù ADialog (siehe "TIcon.ADialog")

   ù Click (siehe "TIcon.Click")

   ù Shift (siehe "TIcon.Shift")

   ù VKey (siehe "TIcon.VKey")

   ù VStat (siehe "TIcon.VStat")

   ù XPos (siehe "TIcon.XPos")

   ù YPos (siehe "TIcon.YPos")

Methoden

   ù Init (siehe "TIcon.Init")

   ù Done (siehe "TIcon.Done")

   ù Check (siehe "TIcon.Check")

   ù GetCheck (siehe "TIcon.GetCheck")

   ù GetHelp (siehe "TIcon.GetHelp")

   ù GetOutline (siehe "TIcon.GetOutline")

   ù GetText (siehe "TIcon.GetText")

   ù Hide (siehe "TIcon.Hide")

   ù IMMoved (siehe "TIcon.IMMoved")

   ù IsHelpAvailable (siehe "TIcon.IsHelpAvailable")

   ù IsHidden (siehe "TIcon.IsHidden")

   ù IsSelected (siehe "TIcon.IsSelected")

   ù Paint (siehe "TIcon.Paint")

   ù SetCheck (siehe "TIcon.SetCheck")

   ù SetHelp (siehe "TIcon.SetHelp")

   ù SetPos (siehe "TIcon.SetPos")

   ù SetText (siehe "TIcon.SetText")

   ù TestButton (siehe "TIcon.TestButton")

   ù TestKey (siehe "TIcon.TestKey")

   ù Toggle (siehe "TIcon.Toggle")

   ù Uncheck (siehe "TIcon.Uncheck")

   ù Unhide (siehe "TIcon.Unhide")

Vorfahre

   ù TEvent

Nachfahre

          -


4.14.1  TIcon.ADialog
---------------------

Deklaration

     ADialog: PDialog;

Beschreibung

     Dies ist ein universeller Dialog-Pointer, der in TIcon.Init
     zun„chst auf nil gesetzt wird. So ist jedes TIcon-Objekt
     bereits auf die Verwaltung eines Dialogs vorbereitet.

     In der TEvent.Work-Methode kann der Dialog dann
     initialisiert bzw. abgearbeitet werden (siehe
     Beispielprogramme).


4.14.2  TIcon.Click
-------------------

Deklaration

     Click: integer;  (nur lesen)

Beschreibung

     Wenn die TEvent.Work-Methode aufgerufen wird, steht in
     diesem Feld die Anzahl der Mausklicks (kann bei
     Tastaturanwahl auch Null sein!).


4.14.3  TIcon.Shift
-------------------

Deklaration

     Shift: integer;  (nur lesen)

Beschreibung

     Wenn die TEvent.Work-Methode aufgerufen wird, steht in
     diesem Feld der Status der Umschalttasten.


4.14.4  TIcon.VKey
------------------

Deklaration

     VKey: integer;

Beschreibung

     Gibt zusammen mit TIcon.VStat die Taste an, auf die
     TIcon.TestKey positiv reagieren soll. Wird von TIcon.Init
     auf -1 gesetzt, d.h. das Icon ist nicht per Tastatur
     anw„hlbar.


4.14.5  TIcon.VStat
-------------------

Deklaration

     VStat: integer;

Beschreibung

     Gibt zusammen mit TIcon.VKey die Taste an, auf die
     TIcon.TestKey positiv reagieren soll. Wird von TIcon.Init
     auf Null gesetzt.

     Wichtig: Wenn egal ist, ob die linke oder die rechte
     <Shift>-Taste gedrckt ist, sollte hier K_SHIFT eingetragen
     sein.


4.14.6  TIcon.XPos
------------------

Deklaration

     XPos: integer;  (nur lesen)

Beschreibung

     Gibt die X-Position des Icons in Pixel relativ zum Parent
     (siehe "TEvent.Parent") an, d.h. entweder zum zugeh”rigen
     Fenster-Arbeitsbereich oder zum Desktop.


4.14.7  TIcon.YPos
------------------

Deklaration

     YPos: integer;  (nur lesen)

Beschreibung

     Gibt die Y-Position des Icons in Pixel relativ zum Parent
     (siehe "TEvent.Parent") an, d.h. entweder zum zugeh”rigen
     Fenster-Arbeitsbereich oder zum Desktop.


4.14.8  TIcon.Init
------------------

Deklaration

     constructor Init(AParent: PEventObject; ATree,
                      AnIndex,iX,iY: integer; Movable,
                      Selectble: boolean; AName,
                      Hlp: string);

Beschreibung

     Ruft den Vorfahren TEvent.Init auf. Danach wird die Adresse
     des Icons mit ATree und AnIndex berechnet, TEvent.Style wird
     auf es_Icon gesetzt und SetPos(iX,iY) sowie SetText(AName)
     werden aufgerufen.

     Movable gibt an, ob das Icon bewegt werden darf, Selectble
     gilt entsprechend fr die Anwahl. Hlp enth„lt den Text fr
     die BubbleHelp.

     Wichtig: Im Moment sind nur Dialogelemente vom Typ G_IMAGE
     erlaubt. G_ICON, G_CICON und freie Images werden noch
     zurckgewiesen. Auerdem sollten TIcon-Objekte z.Z. nur in
     Fenstern und nicht auf dem Desktop verwendet werden, da das
     Objekt TDesktop noch nicht verfgbar ist.


4.14.9  TIcon.Done
------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Intern ben”tigte Speicherstrukturen werden freigegeben.
     Danach wird TEvent.Done aufgerufen.


4.14.10  TIcon.Check
--------------------

Deklaration

     procedure Check; virtual;

Beschreibung

     Ruft SetCheck(bf_Checked) auf und selektiert damit das Icon.


4.14.11  TIcon.GetCheck
-----------------------

Deklaration

     function GetCheck: integer; virtual;

Beschreibung

     Gibt bf_Checked bzw. bf_Unchecked zurck, je nachdem ob das
     Icon markiert ist oder nicht.


4.14.12  TIcon.GetHelp
----------------------

Deklaration

     function GetHelp: string; virtual;

Beschreibung

     Gibt den Hilfstext fr die BubbleHelp zurck.


4.14.13  TIcon.GetOutline
-------------------------

Deklaration

     function GetOutline(var IcnRect,
                    TxtRect: GRECT): boolean; virtual;

Beschreibung

     Gibt die Umrirechtecke (absolute Koordinaten) fr das Icon
     und den Icontext zurck, was fr die Selektion und das
     Verschieben ben”tigt wird.

     Wenn das Icon keinen Text besitzt, ist die Rckgabe false
     und TxtRect sollte ein Rechteck auerhalb des Bildschirms
     beschreiben (zur einfacheren Auswertung). Stehen in beiden
     GRECTs gltige Rechtecke, wird true zurckgegeben.


4.14.14  TIcon.GetText
----------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Gibt den Text des Icons zurck bzw. einen Leerstring, wenn
     das Icon keinen Text besitzt.


4.14.15  TIcon.Hide
-------------------

Deklaration

     procedure Hide(Draw: boolean); virtual;

Beschreibung

     Macht das Icon unsichtbar. Ist Draw true, wird dann das
     Parent (siehe "TEvent.Parent")-Objekt neu gezeichnet (d.h.
     der Fenster-Arbeitsbereich oder der Desktop), damit das Icon
     auch auf dem Bildschirm (und nicht nur logisch)
     verschwindet.

     Wenn man allerdings mehrere Icons versteckt und das
     komplette Fenster anschlieend neu zeichnet, kann man Draw
     auf false setzen.

     Versteckte Icons k”nnen (natrlich) nicht angew„hlt bzw.
     verschoben werden.


4.14.16  TIcon.IMMoved
----------------------

Deklaration

     procedure IMMoved(X,Y: integer); virtual;

Beschreibung

     Wird aufgerufen, nachdem das Icon vom Benutzer verschoben
     wurde.

     Intern wird SetPos(X,Y,true) aufgerufen.


4.14.17  TIcon.IsHelpAvailable
------------------------------

Deklaration

     function IsHelpAvailable: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn mit TIcon.GetHelp ein Hilfstext fr
     die BubbleHelp geliefert werden kann.


4.14.18  TIcon.IsHidden
-----------------------

Deklaration

     function IsHidden: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Icon unsichtbar ist, false sonst.

     Unsichtbare Icons k”nnen weder angew„hlt noch verschoben
     werden.


4.14.19  TIcon.IsSelected
-------------------------

Deklaration

     function IsSelected(r: GRECT): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn sich das Rechteck in r und mind.
     eines der von GetOutline gelieferten Rechtecke
     berschneiden.

     Wird fr die Selektion per Klick und durch die Methode
     TApplication.Rubbox ben”tigt.


4.14.20  TIcon.Paint
--------------------

Deklaration

     procedure Paint; virtual;

Beschreibung

     Zeichnet das Icon und den dazugeh”rigen Text unter Beachtung
     der jeweiligen Rechteckliste. Fr Dialogelemente vom Typ
     G_IMAGE wird automatisch eine passende "Maske" erzeugt.

     Wenn das Icon unsichtbar ist, passiert in dieser Methode
     nichts!


4.14.21  TIcon.SetCheck
-----------------------

Deklaration

     procedure SetCheck(CheckFlag: integer); virtual;

Beschreibung

     Bestimmt die Markierung des Icons, d.h. bf_Checked oder
     bf_Unchecked.


4.14.22  TIcon.SetHelp
----------------------

Deklaration

     procedure SetHelp(Hlp: string); virtual;

Beschreibung

     Weist dem Icon einen neuen Hilfstext fr die BubbleHelp zu.


4.14.23  TIcon.SetPos
---------------------

Deklaration

     procedure SetPos(iX,iY: integer; Redraw: boolean);
                                                virtual;

Beschreibung

     Bringt das Icon an die neue Position iX,iY. Wenn Redraw true
     ist, wird das Icon vorher an der alten Stelle gel”scht und
     nachher an der neuen Position gezeichnet.


4.14.24  TIcon.SetText
----------------------

Deklaration

     procedure SetText(AName: string); virtual;

Beschreibung

     Weist dem Icon einen neuen Text zu und stellt diesen dar.


4.14.25  TIcon.TestButton
-------------------------

Deklaration

     function TestButton(mX,mY,BStat,KStat,
                      Clicks: integer): boolean; virtual;

Beschreibung

     Kmmert sich um die Icon-Selektion per Maus so, wie sie vom
     MultiTOS-Desktop her bekannt ist, d.h. Anwahl und
     Verschieben.

     Wenn das Icon nicht verschoben wird, wird TEvent.Work
     aufgerufen, nachdem Click und Shift entsprechend gesetzt
     wurden.

     Wurde das Icon mit der rechten Maustaste angeklickt, wird
     hier die BubbleHelp angezeigt.


4.14.26  TIcon.TestKey
----------------------

Deklaration

     function TestKey(Stat,Key: integer): boolean;
                                              virtual;

Beschreibung

     Wenn TIcon.VStat und TIcon.VKey die zu Stat und Key
     passenden Werte enthalten, wird das Icon selektiert und dann
     TEvent.Work aufgerufen. Vorher werden noch Click und Shift
     auf Null gesetzt.


4.14.27  TIcon.Toggle
---------------------

Deklaration

     procedure Toggle; virtual;

Beschreibung

     Wechselt bei dem Icon den Zustand der Markierung.


4.14.28  TIcon.Uncheck
----------------------

Deklaration

     procedure Uncheck; virtual;

Beschreibung

     Ruft SetCheck(bf_Unchecked) auf und deselektiert dadurch das
     Icon.


4.14.29  TIcon.Unhide
---------------------

Deklaration

     procedure Unhide; virtual;

Beschreibung

     Macht das Icon sichtbar und zeichnet es.


4.15  TKey
==========

TKey ist ein spezielles TKeyMenu-Objekt, das nur auf einen
Tastaturshortcut reagiert. Zus„tzlich kann eine GEM-Message bergeben
werden, die bei Aktivierung automatisch verschickt wird.

Pointer

     PKey = ^TKey;

Methoden

   ù Init (siehe "TKey.Init")

   ù TestMenu (siehe "TKey.TestMenu")

Vorfahre

   ù TKeyMenu

Nachfahren

     -


4.15.1  TKey.Init
-----------------

Deklaration

     constructor Init(AParent: PEventObject; Stat,
                       Key: integer; Msg: pointer; GetHnd: boolean);

Beschreibung

     Ruft TKeyMenu.Init auf, wobei die Men-Parameter auf -1
     gesetzt werden, d.h. alle Menfunktionen von TKeyMenu werden
     ausgeschaltet.

     TKeyMenu.VGHnd wird auf GetHnd gesetzt. Wenn Msg<>nil ist,
     sollte der Pointer auf einen 16 Bytes groen Bereich zeigen
     (bequemerweise z.B. ein Pipearray), in dem sich eine
     komplette GEM-Message befindet.

     Diese Message wird dann in TKeyMenu.VPipe umkopiert, wobei
     VPipe^[1] mit TApplication.apID und VPipe^[2] mit 0
     initialisiert wird.


4.15.2  TKey.TestMenu
---------------------

Deklaration

     function TestMenu(mNum: integer): boolean; virtual;

Beschreibung

     Liefert einfach nur false zurck, d.h. das TKey-Objekt
     reagiert nicht mehr auf eine Menanwahl.


4.16  TKeyMenu
==============

TKeyMenu ist ein spezialisiertes TEvent-Objekt, da auf eine
Menanwahl per Maus oder Shortcut reagiert. Jeder Meneintrag sollte
mit einem solchen Objekt verknpft sein, da in diesen Objekten die
eigentlichen Aktionen nach der Anwahl (Abarbeiten von Dialogen etc.)
geschehen sollten.

Wenn entweder auf Maus- oder aber auf Tastaturanwahl verzichtet werden
soll, stehen dafr spezielle Nachfahren von TKeyMenu zur Verfgung.

TKeyMenu kann sowohl fr "normale" Menleisten als auch fr solche im
Fenster verwendet werden.

Pointer

     PKeyMenu = ^TKeyMenu;

Felder

   ù ADialog (siehe "TKeyMenu.ADialog")

   ù VGHnd (siehe "TKeyMenu.VGHnd")

   ù VKey (siehe "TKeyMenu.VKey")

   ù VMNum (siehe "TKeyMenu.VMNum")

   ù VPipe (siehe "TKeyMenu.VPipe")

   ù VStat (siehe "TKeyMenu.VStat")

   ù VTNum (siehe "TKeyMenu.VTNum")

Methoden

   ù Init (siehe "TKeyMenu.Init")

   ù Done (siehe "TKeyMenu.Done")

   ù Check (siehe "TKeyMenu.Check")

   ù Disable (siehe "TKeyMenu.Disable")

   ù Enable (siehe "TKeyMenu.Enable")

   ù GetCheck (siehe "TKeyMenu.GetCheck")

   ù GetState (siehe "TKeyMenu.GetState")

   ù GetText (siehe "TKeyMenu.GetText")

   ù SetCheck (siehe "TKeyMenu.SetCheck")

   ù SetState (siehe "TKeyMenu.SetState")

   ù SetText (siehe "TKeyMenu.SetText")

   ù TestKey (siehe "TKeyMenu.TestKey")

   ù TestMenu (siehe "TKeyMenu.TestMenu")

   ù Toggle (siehe "TKeyMenu.Toggle")

   ù Uncheck (siehe "TKeyMenu.Uncheck")

Vorfahre

   ù TEvent

Nachfahren

   ù TKey

   ù TMenu


4.16.1  TKeyMenu.ADialog
------------------------

Deklaration

     ADialog: PDialog;

Beschreibung

     Dies ist ein universeller Dialog-Pointer, der in
     TKeyMenu.Init zun„chst auf nil gesetzt wird. So ist jedes
     TKeyMenu-Objekt bereits auf die Verwaltung eines Dialogs
     vorbereitet (was in der Praxis auch meistens genutzt wird).

     In der TEvent.Work-Methode kann der Dialog dann
     initialisiert bzw. abgearbeitet werden (siehe
     Beispielprogramme).


4.16.2  TKeyMenu.VGHnd
----------------------

Deklaration

     VGHnd: boolean;

Beschreibung

     Gibt an, ob TKeyMenu.VPipe^[3] unmittelbar vor dem Versenden
     auf das GEM-Handle des bergeordneten Fensters gesetzt
     werden soll (da sich diese Kennung ja „ndern kann). Wenn
     Parent auf das Applikations-Objekt zeigt, wird die Kennung
     des obersten Fensters eingetragen. Wenn wind_get(WF_OWNER)
     vorhanden ist (das ist bei neueren TOS-Versionen der Fall),
     k”nnen so auch Nachrichten an Fenster fremder Applikationen
     verschickt werden.

     Wird von TKeyMenu.Init auf false initialisiert und kann mit
     TKey.Init bzw. TMenu.Init gesetzt werden.


4.16.3  TKeyMenu.VKey
---------------------

Deklaration

     VKey: integer;

Beschreibung

     Gibt zusammen mit TKeyMenu.VStat die Taste an, auf die
     TKeyMenu.TestKey positiv reagieren soll.

     Wird von TKeyMenu.Init gesetzt.


4.16.4  TKeyMenu.VMNum
----------------------

Deklaration

     VMNum: integer;

Beschreibung

     Gibt den Index des Meneintrags an, auf den
     TKeyMenu.TestMenu positiv reagieren soll.

     Wird von TKeyMenu.Init gesetzt.


4.16.5  TKeyMenu.VPipe
----------------------

Deklaration

     VPipe: PPipearray;  (nur lesen)

Beschreibung

     Enth„lt einen Pointer auf eine komplette GEM-Nachricht, die
     von TKeyMenu.TestKey bzw. TKeyMenu.TestMenu bei positiver
     Anwahl verschickt wird.

     TKeyMenu.Init besetzt dieses Feld mit nil, d.h. es wird
     keine Nachricht verschickt. Kann mit TKey.Init oder
     TMenu.Init gesetzt werden.


4.16.6  TKeyMenu.VStat
----------------------

Deklaration

     VStat: integer;

Beschreibung

     Gibt zusammen mit TKeyMenu.VKey die Taste an, auf die
     TKeyMenu.TestKey positiv reagieren soll. Wird von
     TKeyMenu.Init gesetzt.

     Wichtig: Wenn egal ist, ob die linke oder die rechte
     <Shift>-Taste gedrckt ist, sollte hier K_SHIFT eingetragen
     sein.


4.16.7  TKeyMenu.VTNum
----------------------

Deklaration

     VTNum: integer;

Beschreibung

     Enth„lt den Index des Mentitels vom zugeh”rigen Meneintrag
     VMNum.

     Wird von TKeyMenu.Init gesetzt und von TKeyMenu.TestKey
     einzig und allein zum Invertieren des Mentitels ben”tigt.


4.16.8  TKeyMenu.Init
---------------------

Deklaration

     constructor Init(AParent: PEventObject;
                           Stat,Key,mNum,tNum: integer);

Beschreibung

     Ruft den Vorfahren TEvent.Init auf. Dann wird TKeyMenu.VStat
     auf Stat, TKeyMenu.VKey auf Key, VMNum auf mNum und VTNum
     auf tNum gesetzt, sowie TKeyMenu.ADialog und TKeyMenu.VPipe
     mit nil und TKeyMenu.VGHnd mit false initialisiert.


4.16.9  TKeyMenu.Done
---------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt eine evtl. in TKeyMenu.VPipe vorhandene GEM-Message
     frei und ruft den Vorfahren TEvent.Done auf.


4.16.10  TKeyMenu.Check
-----------------------

Deklaration

     procedure Check; virtual;

Beschreibung

     Ruft TKeyMenu.SetCheck(bf_Checked) auf und markiert damit
     den ber VMNum angegebenen Meneintrag mit einem H„kchen.


4.16.11  TKeyMenu.Disable
-------------------------

Deklaration

     procedure Disable; virtual;

Beschreibung

     Ruft TKeyMenu.SetState(bf_Disabled) auf und macht damit den
     Meneintrag mit Index VMNum nicht anw„hlbar.


4.16.12  TKeyMenu.Enable
------------------------

Deklaration

     procedure Enable; virtual;

Beschreibung

     Ruft TKeyMenu.SetState(bf_Enabled) auf und macht damit den
     Meneintrag mit Index VMNum wieder anw„hlbar.


4.16.13  TKeyMenu.GetCheck
--------------------------

Deklaration

     function GetCheck: integer; virtual;

Beschreibung

     Gibt bf_Checked bzw. bf_Unchecked zurck, je nachdem ob der
     Meneintrag mit Index VMNum mit einem H„kchen markiert ist
     oder nicht.

     Ist VMNum kein korrekter Eintrag zugewiesen, erh„lt man als
     Rckgabe id_No.


4.16.14  TKeyMenu.GetState
--------------------------

Deklaration

     function GetState: integer; virtual;

Beschreibung

     Gibt bf_Enabled bzw. bf_Disabled zurck, je nachdem ob der
     Meneintrag mit Index VMNum anw„hlbar ist oder nicht.

     Ist VMNum kein korrekter Eintrag zugewiesen, erh„lt man als
     Rckgabe id_No.


4.16.15  TKeyMenu.GetText
-------------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Gibt den Text des Meneintrags mit Index VMNum zurck bzw.
     einen Leerstring, wenn VMNum kein korrekter Eintrag
     zugewiesen ist.


4.16.16  TKeyMenu.SetCheck
--------------------------

Deklaration

     procedure SetCheck(CheckFlag: integer); virtual;

Beschreibung

     Bestimmt die Markierung des Meneintrags VMNum, d.h.
     bf_Checked oder bf_Unchecked.


4.16.17  TKeyMenu.SetState
--------------------------

Deklaration

     procedure SetState(StateFlag: integer); virtual;

Beschreibung

     Setzt den Zustand des Meneintrags VMNum, d.h. bf_Enabled
     oder bf_Disabled.


4.16.18  TKeyMenu.SetText
-------------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     Weist dem Meneintrag VMNum einen neuen Text zu.

     Wichtig: Man mu selbst darauf achten, da der String nicht
     zu lang ist! Ist der String allerdings zu kurz, wird er mit
     Leerzeichen aufgefllt.


4.16.19  TKeyMenu.TestKey
-------------------------

Deklaration

     function TestKey(Stat,Key: integer): boolean; virtual;

Beschreibung

     Wenn Stat=TKeyMenu.VStat, Key=TKeyMenu.VKey und
     TKeyMenu.GetState<>bf_Disabled ist, liefert TestKey true
     zurck. Auerdem werden dann folgende Aktionen ausgefhrt:
     Der Mentitel VTNum wird invertiert; wenn
     TKeyMenu.VPipe<>nil ist, wird die entsprechende GEM-Message
     verschickt; zum Schlu wird dann noch Work aufgerufen.
     Ansonsten gibt TestKey false zurck.

     Wichtig: Wenn in VStat K_SHIFT eingetragen ist, werden beide
     <Shift>-Tasten gleichwertig behandelt!


4.16.20  TKeyMenu.TestMenu
--------------------------

Deklaration

     function TestMenu(mNum: integer): boolean; virtual;

Beschreibung

     Wenn mNum<>VMNum ist, gibt TestMenu false zurck. Ansonsten
     liefert diese Methode true. Vorher wird noch - wenn
     TKeyMenu.VPipe<>nil ist - die entsprechende GEM-Message
     verschickt und dann Work aufgerufen.


4.16.21  TKeyMenu.Toggle
------------------------

Deklaration

     procedure Toggle; virtual;

Beschreibung

     Wechselt beim Meneintrag VMNum mit TKeyMenu.SetCheck den
     Zustand zwischen gesetztem und nicht gesetztem H„kchen.


4.16.22  TKeyMenu.Uncheck
-------------------------

Deklaration

     procedure Uncheck; virtual;

Beschreibung

     Ruft TKeyMenu.SetCheck(bf_Unchecked) auf und entfernt damit
     ein evtl. vor dem Meneintrag mit Index VMNum vorhandenes
     H„kchen.


4.17  TLookupValidator
======================

TLookupValidator vergleicht einen gegebenen String mit einer Liste
gltiger Werte. Es ist ein abstrakter Objekttyp, d.h. es macht nicht
sehr viel Sinn, ihn zu instantiieren. Er kann aber als Grundlage neuer
Objekttypen verwendet werden, die ber eine entsprechende Liste
gltiger Werte verfgen. Dazu mu dann auch die Methode Lookup
berschrieben werden.

Pointer

     PLookupValidator = ^TLookupValidator;

Methoden

   ù IsValid (siehe "TLookupValidator.IsValid")

   ù Lookup (siehe "TLookupValidator.Lookup")

Vorfahre

   ù TValidator

Nachfahre

   ù TStringLookupValidator


4.17.1  TLookupValidator.IsValid
--------------------------------

Deklaration

     function IsValid(s: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn TLookupValidator.Lookup true liefert.
     Wenn voNotEmpty gesetzt ist, darf die Eingabe auerdem nicht
     leer sein, sonst wird false zurckgegeben.


4.17.2  TLookupValidator.Lookup
-------------------------------

Deklaration

     function Lookup(s: string): boolean; virtual;

Beschreibung

     Vergleicht die Zeichenkette s mit einer Liste gltiger
     Elemente und gibt true zurck, wenn s einem dieser Elemente
     entspricht, sonst false.

     TLookupValidator.Lookup ist allerdings eine abstrakte
     Methode, die immer true zurckgibt.


4.18  TMenu
===========

TMenu ist ein spezielles TKeyMenu-Objekt, das nur auf Mausanwahl eines
Meneintrags reagiert. Zus„tzlich kann eine GEM-Message bergeben
werden, die bei Aktivierung automatisch verschickt wird.

Pointer

     PMenu = ^TMenu;

Methoden

   ù Init (siehe "TMenu.Init")

   ù TestKey (siehe "TMenu.TestKey")

Vorfahre

   ù TKeyMenu

Nachfahren

     -


4.18.1  TMenu.Init
------------------

Deklaration

     constructor Init(AParent: PEventObject;
                       mNum: integer; Msg: pointer; GetHnd: boolean);

Beschreibung

     Ruft TKeyMenu.Init auf, wobei die Tastatur-Parameter und der
     Mentitel auf -1 gesetzt werden, d.h. alle
     Tastaturfunktionen von TKeyMenu werden ausgeschaltet.

     TKeyMenu.VGHnd wird auf GetHnd gesetzt. Wenn Msg<>nil ist,
     sollte der Pointer auf einen 16 Bytes groen Bereich zeigen
     (bequemerweise z.B. ein Pipearray), in dem sich eine
     komplette GEM-Message befindet. Diese Message wird dann in
     TKeyMenu.VPipe umkopiert, wobei VPipe^[1] mit
     TApplication.apID und VPipe^[2] mit 0 initialisiert wird.


4.18.2  TMenu.TestKey
---------------------

Deklaration

     function TestKey(Stat,Key: integer): boolean; virtual;

Beschreibung

     Liefert einfach nur false zurck, d.h. das TMenu-Objekt
     reagiert nicht mehr auf eine Tastaturanwahl.


4.19  TObject
=============

TObject ist das grundlegende Objekt von ObjectGEM. Alle weiteren
Objekte stammen letztendlich von TObject ab. TObject besitzt keinen
Vorfahren.

Pointer

     PObject = ^TObject;

Methoden

   ù Init (siehe "TObject.Init")

   ù Free (siehe "TObject.Free")

   ù Done (siehe "TObject.Done")

Vorfahre

     -

Nachfahren

   ù TClipboard

   ù TCollection

   ù TControl

   ù TEvent

   ù TEventObject

   ù TScroller

   ù TValidator

   ù TXBase


4.19.1  TObject.Init
--------------------

Deklaration

     constructor Init;

Beschreibung

     Initialisiert das Objekt. Wird von den Konstruktoren aller
     abgeleiteten Objekte aufgerufen.


4.19.2  TObject.Free
--------------------

Deklaration

     procedure Free;

Beschreibung

     Ruft den Destruktor Done (siehe "TObject.Done") auf und
     entfernt das Objekt aus dem Speicher.


4.19.3  TObject.Done
--------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt den Speicher von dynamischen Objekten frei.


4.20  TPopup
============

Popup-Mens erscheinen an einer beliebigen Bildschirmposition (z.B.
beim Mauscursor) und lassen den Benutzer aus einer festen Liste von
Werten, Aktionen etc. ausw„hlen. Eine einfache Bearbeitung von Popup-
Mens kann mit TApplication.Popup erfolgen. Eine Beschreibung der
Tastatursteuerung und der weitergehenden Programmierung findet sich
unter "Popup-Mens".

Pointer

     PPopup = ^TPopup;

Felder

   ù pFlag (siehe "TPopup.pFlag")

   ù pIndex (siehe "TPopup.pIndex")

   ù pMax (siehe "TPopup.pMax")

   ù PopTree (siehe "TPopup.PopTree")

   ù pRows (siehe "TPopup.pRows")

   ù pX (siehe "TPopup.pX")

   ù pY (siehe "TPopup.pY")

Methoden

   ù Init (siehe "TPopup.Init")

   ù Done (siehe "TPopup.Done")

   ù Check (siehe "TPopup.Check")

   ù Disable (siehe "TPopup.Disable")

   ù Enable (siehe "TPopup.Enable")

   ù Execute (siehe "TPopup.Execute")

   ù ExitPop (siehe "TPopup.ExitPop")

   ù GetCheck (siehe "TPopup.GetCheck")

   ù GetSelection (siehe "TPopup.GetSelection")

   ù GetState (siehe "TPopup.GetState")

   ù GetText (siehe "TPopup.GetText")

   ù KeyExit (siehe "TPopup.KeyExit")

   ù SetCheck (siehe "TPopup.SetCheck")

   ù SetPopTree (siehe "TPopup.SetPopTree")

   ù SetSelection (siehe "TPopup.SetSelection")

   ù SetState (siehe "TPopup.SetState")

   ù SetText (siehe "TPopup.SetText")

   ù Toggle (siehe "TPopup.Toggle")

   ù Uncheck (siehe "TPopup.Uncheck")

Vorfahre

   ù TEvent

Nachfahren

     -


4.20.1  TPopup.pFlag
--------------------

Deklaration

     pFlag: integer;

Beschreibung

     Gibt an, auf welche Position sich die Koordinaten pX und pY
     beziehen. Wird mit POP_LEFTOP (0) initialisiert, d.h. pX und
     pY entsprechen der linken oberen Ecke des Popup-Mens. Der
     andere m”gliche Wert ist POP_CENTER (1), pX und pY
     entsprechen dann der Mitte des Popups.


4.20.2  TPopup.pIndex
---------------------

Deklaration

     pIndex: integer;  (nur lesen)

Beschreibung

     Entspricht dem Index des Popup-Hintergrundrechtecks im
     Objektbaum PopTree. Wird von TPopup.Init gesetzt. Kann auch
     ROOT sein (dann w„re der gesamte Baum das Popup-Men).


4.20.3  TPopup.pMax
-------------------

Deklaration

     pMax: integer;  (nur lesen)

Beschreibung

     Gibt an, wieviele Eintr„ge das Popup-Men maximal enth„lt.
     Bei den dynamischen Popups kann das Men mehr Eintr„ge
     besitzen, als gerade sichtbar sind!


4.20.4  TPopup.PopTree
----------------------

Deklaration

     PopTree: PTree;  (nur lesen)

Beschreibung

     PopTree zeigt auf den Objektbaum, in dem man
     praktischerweise alle Popup-Mens eines Programms
     zusammenfassen kann (allerdings nicht mu). Die Mens
     bestehen aus einem G_BOX-Objekt als Hintergrund, das von
     oben nach unten sortierte G_STRING-Eintr„ge enth„lt.

     Wird von TPopup.Init gesetzt.


4.20.5  TPopup.pRows
--------------------

Deklaration

     pRows: integer;  (nur lesen)

Beschreibung

     Gibt an, wieviele Eintr„ge angezeigt werden, d.h. aus
     wieviele Zeilen das Popup-Men besteht.

     Beim Entwurf im RCS mu bedacht werden, da nicht mehr als
     z.Z. 19 Eintr„ge erlaubt sind!


4.20.6  TPopup.pX
-----------------

Deklaration

     pX: integer;

Beschreibung

     Gibt die X-Position des Popup-Mens an. Wird mit 0
     initialisiert und sollte deshalb ge„ndert werden (das macht
     z.B. TApplication.Popup).


4.20.7  TPopup.pY
-----------------

Deklaration

     pY: integer;

Beschreibung

     Gibt die Y-Position des Popup-Mens an. Wird mit 0
     initialisiert und sollte deshalb ge„ndert werden (das macht
     z.B. TApplication.Popup).


4.20.8  TPopup.Init
-------------------

Deklaration

     constructor Init(AParent: PEventObject;
                          tIndx,oIndx: integer);

Beschreibung

     Ruft den Vorfahren TEvent.Init auf und setzt dann PopTree
     auf den durch tIndx angegebenen Objektbaum. Danach werden
     pMax und pRows berechnet. Entspricht das Men nicht den
     Konventionen (siehe PopTree und pRows), wird die
     Initialisierung abgebrochen. Schlielich wird noch pIndex
     auf oIndx gesetzt, und pFlag, pX und pY werden
     initialisiert. Wenn in tIndx id_No bergeben wird, kann mit
     der Methode SetPopTree z.B. ein im Speicher erzeugter
     Objektbaum gesetzt werden, andernfalls wird das bergebene
     Men umkopiert! oIndx mu aber trotzdem korrekt gesetzt
     (d.h. gr”er gleich ROOT) sein!


4.20.9  TPopup.Done
-------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt den Speicherplatz der kopierten Resource frei und ruft
     den Vorfahren TEvent.Done auf.


4.20.10  TPopup.Check
---------------------

Deklaration

     procedure Check(nr: integer); virtual;

Beschreibung

     Ruft SetCheck(nr,bf_Checked) auf und markiert damit den
     Eintrag nr mit einem H„kchen.


4.20.11  TPopup.Disable
-----------------------

Deklaration

     procedure Disable(nr: integer); virtual;

Beschreibung

     Ruft SetState(nr,bf_Disabled) auf und macht den Eintrag nr
     damit nicht anw„hlbar (hell dargstellt).


4.20.12  TPopup.Enable
----------------------

Deklaration

     procedure Enable(nr: integer); virtual;

Beschreibung

     Ruft SetState(nr,bf_Enabled) auf und macht den Eintrag nr
     damit wieder anw„hlbar.


4.20.13  TPopup.Execute
-----------------------

Deklaration

     function Execute: integer; virtual;

Beschreibung

     Execute bernimmt die eigentliche Bearbeitung des Popup-
     Mens (Zeichnen, Abarbeiten, Auswerten). Als Rckgabe erh„lt
     man id_No, wenn die Bearbeitung abgebrochen wurde, oder
     einen Wert zwischen 0 und pRows-1 (inklusive), der die
     Nummer des angew„hlten Eintrags angibt.

     Die Anwahl der Eintr„ge kann mit der linken Maustaste,
     <Return>, <Enter> oder <Space> erfolgen. Das Men kann mit
     der rechten Maustaste, <Undo> oder <Esc> abgebrochen werden.
     Zur Steuerung innerhalb des Mens k”nnen (neben der Maus)
     die Tasten <Cursor hoch,runter> und [<Shift>+]<Home> benutzt
     werden.

     Sind in dem Men alle Eintr„ge disabled, wird es zwar
     angezeigt, als Rckgabe erh„lt man aber immer id_No.


4.20.14  TPopup.GetCheck
------------------------

Deklaration

     function GetCheck(nr: integer): integer; virtual;

Beschreibung

     Liefert bf_Checked oder bf_Unchecked, je nachdem ob der
     Men-Eintrag nr markiert ist oder nicht. Ist nr kleiner Null
     oder gr”er gleich pRows, wird id_No zurckgegeben.


4.20.15  TPopup.GetState
------------------------

Deklaration

     function GetState(nr: integer): integer; virtual;

Beschreibung

     Liefert bf_Enabled oder bf_Disabled, je nachdem ob der
     Men-Eintrag nr anw„hlbar ist oder nicht. Ist nr kleiner
     Null oder gr”er gleich pRows, wird id_No zurckgegeben.


4.20.16  TPopup.GetText
-----------------------

Deklaration

     function GetText(nr: integer): string; virtual;

Beschreibung

     Gibt den Text des Men-Eintrags nr zurck. Ist nr kleiner
     Null oder gr”er gleich pRows, wird ein Leerstring
     zurckgegeben.


4.20.17  TPopup.SetCheck
------------------------

Deklaration

     procedure SetCheck(nr,CheckFlag: integer); virtual;

Beschreibung

     Wenn nr im Intervall [0,pRows) liegt, wird der entsprechende
     Men-Eintrag markiert (CheckFlag=bf_Checked) oder die
     Markierung zurckgesetzt (CheckFlag=bf_Unchecked).


4.20.18  TPopup.SetState
------------------------

Deklaration

     procedure SetState(nr,StateFlag: integer); virtual;

Beschreibung

     Wenn nr im Intervall [0,pRows) liegt, wird der entsprechende
     Men-Eintrag anw„hlbar gemacht (StateFlag=bf_Enabled) oder
     nicht (StateFlag=bf_Disabled).


4.20.19  TPopup.SetText
-----------------------

Deklaration

     procedure SetText(nr: integer; ATextString: string);
                                                virtual;

Beschreibung

     Wenn nr im Intervall [0,pRows) liegt, wird dem
     entsprechenden Men-Eintrag der Text ATextString zugewiesen.


4.20.20  TPopup.Toggle
----------------------

Deklaration

     procedure Toggle(nr: integer); virtual;

Beschreibung

     Wenn der Eintrag nr (0..pRows-1) nicht markiert ist, wird er
     markiert, ansonsten wird die Markierung zurckgesetzt.


4.20.21  TPopup.Uncheck
-----------------------

Deklaration

     procedure Uncheck(nr: integer); virtual;

Beschreibung

     Ruft SetCheck(nr,bf_Unchecked) auf und nimmt damit die
     Markierung des Eintrags zurck.


4.20.22  TPopup.SetPopTree
--------------------------

Deklaration

     procedure SetPopTree(tree: PTree); virtual;

Beschreibung

     Setzt den in tree bergebenen Objektbaum als Baum fr das
     Popup-Men. Auerdem werden einige interne Variablen
     ermittelt.

     Wird von TPopup.Init aufgerufen, wenn als Tree-Index ein
     Wert ungleich id_No bergeben wurde. Normalerweise ruft man
     diese Methode nicht selbst auf.


4.20.23  TPopup.ExitPop
-----------------------

Deklaration

     function ExitPop(mX,mY: integer): integer; virtual;

Beschreibung

     Wird von TPopup.Execute aufgerufen, solange sich der
     Mauscursor auerhalb des Popup-Mens befindet. In mX und mY
     erh„lt man die aktuellen Mauskoordinaten. Gibt man einen
     Wert ungleich id_No zurck, wird das Popup-Men mit dem von
     ExitPop gelieferten Wert abgebrochen.


4.20.24  TPopup.KeyExit
-----------------------

Deklaration

     function KeyExit(Stat,Key: integer): integer;
                                            virtual;

Beschreibung

     Wird von TPopup.Execute aufgerufen, wenn eine Taste gedrckt
     wird, die nicht zur Steuerung des Popup-Mens benutzt wird.
     Hier k”nnen solche Tasten nun ausgewertet werden.

     Gibt man einen Wert ungleich id_No zurck, wird das Popup-
     Men mit dem von KeyExit gelieferten Wert abgebrochen.


4.20.25  TPopup.SetSelection
----------------------------

Deklaration

     procedure SetSelection(nr: integer); virtual;

Beschreibung

     Setzt den Mauscursor auf den Popup-Men-Eintrag mit der
     Nummer nr (0..pMax-1).


4.20.26  TPopup.GetSelection
----------------------------

Deklaration

     function GetSelection: integer; virtual;

Beschreibung

     Wenn ein Eintrag des Popup-Mens markiert ist, erh„lt man
     von dieser Routine dessen Nummer (0..pMax-1).

     Ansonsten wird id_No zurckgegeben.


4.21  TPXPictureValidator
=========================

Mit diesem Objekt k”nnen Eingabefelder mit Datenbank-Masken, die
kompatibel zu Paradox (Borland) sind, auf Gltigkeit berprft werden.
Die M”glichkeiten sind sehr komplex und gehen weit ber die vom GEM
bereitgestellten Masken hinaus.

Pointer

     PPXPictureValidator = ^TPXPictureValidator;

Felder

   ù Pic (siehe "TPXPictureValidator.Pic")

Methoden

   ù Init (siehe "TPXPictureValidator.Init")

   ù Done (siehe "TPXPictureValidator.Done")

   ù Error (siehe "TPXPictureValidator.Error")

   ù IsValid (siehe "TPXPictureValidator.IsValid")

   ù IsValidInput (siehe "TPXPictureValidator.IsValidInput")

   ù Picture (siehe "TPXPictureValidator.Picture")

Vorfahre

   ù TValidator

Nachfahren

     -


4.21.1  TPXPictureValidator.Pic
-------------------------------

Deklaration

     Pic: PString;

Beschreibung

     Enth„lt die Paradox-Maske zur šberprfung der Eingabe. Wird
     von TPXPictureValidator.Init gesetzt und von Picture aus
     gewertet.

     Die Masken setzen sich aus folgenden Elementen zusammen:


           +----+----------------------------------------+
           |  # | Akzeptiert nur eine Ziffer             |
           +----+----------------------------------------+
           |  ? | Akzeptiert einen beliebigen Buchstaben |
           +----+----------------------------------------+
           |  & | Akzeptiert Buchstaben und wandelt sie  |
           |    | in Grobuchstaben um                   |
           +----+----------------------------------------+
           |  @ | Akzeptiert jedes Zeichen               |
           +----+----------------------------------------+
           |  ! | Akzeptiert jedes Zeichen und wandelt   |
           |    | Klein- in Grobuchstaben um            |
           +----+----------------------------------------+
           |  ; | Das folgende Zeichen wird buchst„blich |
           |    | bernommen                             |
           +----+----------------------------------------+
           |  * | Wiederholungsz„hler                    |
           +----+----------------------------------------+
           | [] | Der Maskenteil ist optional            |
           +----+----------------------------------------+
           | {} | markiert eine Gruppe, mit              |
           |  , | werden die Alternativen getrennt       |
           +----+----------------------------------------+

     Alle anderen Zeichen werden buchst„blich bernommen. Bei
     Gruppierungen mit Alternativen kann es vorkommen, da
     sp„tere Alternativen nicht erkannt werden, weil die
     jeweilige Eingabe schon als Anfangsteil einer frheren Maske
     aufgetaucht ist. In diesem fall mu man versuchen, die
     Gruppe anders zu sortieren.

Beispiele


       +----------------+------------------------------------+
       | DM*#;,##;@     | Stckpreis, z.B. DM345,67@         |
       +----------------+------------------------------------+
       | ???;;;#        | z.B. ABC;#                         |
       +----------------+------------------------------------+
       | *5#            | fnf Ziffern (#####)               |
       +----------------+------------------------------------+
       | *#             | beliebig viele (auch Null) Ziffern |
       +----------------+------------------------------------+
       | &*?            | Wort mit groem Anfangsbuchstaben  |
       +----------------+------------------------------------+
       | *3{##:}        | = ##:##:##:                        |
       +----------------+------------------------------------+
       | *3{5}#         | = 555#                             |
       +----------------+------------------------------------+
       | *35#           | 35 Wiederholungen von #            |
       +----------------+------------------------------------+
       | {20,75,100}W   | Wattzahlen von Glhbirnen          |
       +----------------+------------------------------------+
       | *{&[*?][@][ ]} | bel. Anzahl W”rter mit groem      |
       |                | Anfangsbuchstaben                  |
       +----------------+------------------------------------+
       | ROT,BLAU       | eines der beiden Worte             |
       +----------------+------------------------------------+
       | ###,##         | zwei- oder dreistellige Zahl;      |
       |                | ##,### h„tte nicht den ge-         |
       |                | wnschten Effekt!                  |
       +----------------+------------------------------------+


4.21.2  TPXPictureValidator.Init
--------------------------------

Deklaration

     constructor Init(APic: string; AutoFill: boolean);

Beschreibung

     Ruft TValidator.Init auf und setzt Pic auf APic. Dann wird
     Options auf voOnAppend und, wenn in AutoFill true bergeben
     wurde, zus„tzlich auf voFill gesetzt. Danach wird die in
     APic bergebene Maske auf Gltigkeit getestet. Wenn ein
     Fehler auftritt, wird TValidator.Status auf vsSyntax
     gesetzt.

     Wichtig: AutoFill hat z.Z. noch keine Wirkung!


4.21.3  TPXPictureValidator.Done
--------------------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Pic wird freigegeben, danach wird der Destruktor des
     Vorfahren aufgerufen.


4.21.4  TPXPictureValidator.Error
---------------------------------

Deklaration

     procedure Error; virtual;

Beschreibung

     Zeigt die Fehlermeldung an, da die Eingabe nicht zur Maske
     in Pic pat.


4.21.5  TPXPictureValidator.IsValid
-----------------------------------

Deklaration

     function IsValid(s: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn die Eingabe korrekt oder leer ist
     (letzteres nur dann, wenn voNotEmpty nicht gesetzt ist).


4.21.6  TPXPictureValidator.IsValidInput
----------------------------------------

Deklaration

     function IsValidInput(var s: string;
             SuppressFill: boolean): boolean; virtual;

Beschreibung

     Liefert true, wenn Pic keine Maske zugewiesen ist oder wenn
     Picture keinen Fehler in der Eingabe feststellen kann.


4.21.7  TPXPictureValidator.Picture
-----------------------------------

Deklaration

     function Picture(var Input: string;
                 AutoFill: boolean): TPicResult; virtual;

Beschreibung

     Prft den in Input bergebenen String auf šbereinstimmung
     mit der Maske in Pic. Dabei werden notfalls Korrekturen
     (z.B. Gro-/Kleinwandlung) vorgenommen. Ist AutoFill true,
     wird die Eingabe mit evtl. fehlenden Zeichen aufgefllt,
     sofern diese eindeutig bestimmt sind. Wichtig: Diese Option
     ist z.Z. noch ohne Wirkung!

     TPicResult ist wie folgt deklariert:

     PPicResult = ^TPicResult;
     TPicResult = (prComplete, prIncomplete, prEmpty,
                   prError, prSyntax, prAmbiguous,
                   prIncompNoFill);

     Als Rckgabe erh„lt man einen der folgenden Werte (nicht
     beschriebene Werte werden nur intern verwendet):


        +--------------+------------------------------------+
        | prComplete   | Die Eingabe ist korrekt            |
        +--------------+------------------------------------+
        | prIncomplete | Die Eingabe ist soweit korrekt,    |
        |              | erfllt die Maske aber nicht voll- |
        |              | st„ndig                            |
        +--------------+------------------------------------+
        | prEmpty      | Die Eingabe ist leer               |
        +--------------+------------------------------------+
        | prError      | Die Eingabe pat nicht zur Maske   |
        +--------------+------------------------------------+
        | prSyntax     | Die Maske ist falsch (meistens     |
        |              | falsche Klammerung)                |
        +--------------+------------------------------------+
        | prAmbiguous  | Tritt auf, wenn die Eingabe die    |
        |              | Maske erfllt, aber am Ende der    |
        |              | Eingabe noch Zeichen brig bleiben |
        +--------------+------------------------------------+


4.22  TRadioButton
==================

RadioButtons werden in RCS-Hierarchiestufen zusammengefat, d.h. alle
Buttons innerhalb eines Rahmens o.„. geh”ren zusammen. Von diesen
Buttons kann dann pro Hierarchiestufe nur einer aktiv sein. Es
empfiehlt sich, den zugeh”rigen Rahmen mit einem TGroupBox-Objekt zu
verknpfen.

Pointer

     PRadioButton = ^TRadioButton;

Methoden

   ù Init (siehe "TRadioButton.Init")

   ù Install (siehe "TRadioButton.Install")

   ù SetState (siehe "TRadioButton.SetState")

Vorfahre

   ù TCheckBox

Nachfahren

     -


4.22.1  TRadioButton.Init
-------------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx: integer;
                          UserDef: boolean; Hlp: string);

Beschreibung

     Ruft den Vorfahren TCheckBox.Init auf und setzt
     TControl.Style auf cs_RadioButton.


4.22.2  TRadioButton.Install
----------------------------

Deklaration

     function Install: boolean;

Beschreibung

     Wenn das Dialogelement vom Typ G_BUTTON ist, wird UsrDef auf
     true gesetzt und der RadioButton im 3D-Look gezeichnet.

     Wenn die Funktion false zurckliefert, wird die Installation
     von TRadioButton.Init abgebrochen. Standardm„ig wird
     allerdings immer true zurckgegeben.


4.22.3  TRadioButton.SetState
-----------------------------

Deklaration

     procedure SetState(StateFlag: integer); virtual;

Beschreibung

     Wenn in StateFlag bf_Disabled bergeben wird, wird zun„chst
     TCheckBox.Uncheck aufgerufen. Danach wird immer der Vorfahre
     TControl.SetState aufgerufen.


4.23  TRangeValidator
=====================

TRangeValidator berprft, ob eine vom Anwender eingegebene Zahl
innerhalb eines festgelegten ganzzahligen Bereichs liegt.

Pointer

     PRangeValidator = ^TRangeValidator;

Felder

   ù Max (siehe "TRangeValidator.Max")

   ù Min (siehe "TRangeValidator.Min")

Methoden

   ù Init (siehe "TRangeValidator.Init")

   ù Error (siehe "TRangeValidator.Error")

   ù IsValid (siehe "TRangeValidator.IsValid")

   ù IsValidInput (siehe "TRangeValidator.IsValidInput")

Vorfahre

   ù TFilterValidator

Nachfahren

     -


4.23.1  TRangeValidator.Min
---------------------------

Deklaration

     Min: longint;

Beschreibung

     Bestimmt den kleinstm”glichen ganzzahligen Wert fr die
     Eingabe.


4.23.2  TRangeValidator.Max
---------------------------

Deklaration

     Max: longint;

Beschreibung

     Bestimmt den gr”tm”glichen ganzzahligen Wert fr die
     Eingabe.


4.23.3  TRangeValidator.Init
----------------------------

Deklaration

     constructor Init(AMin,AMax: longint);

Beschreibung

     Ruft TFilterValidator.Init(['0'..'9','+','-']) auf, d.h. in
     dem Eingabefeld sind nur positive oder negative
     Dezimalzahlen erlaubt. Wenn AMin gr”er gleich Null ist,
     wird '-' aus ValidChars wieder entfernt. Dann wird
     TRangeValidator.Min auf AMin und TRangeValidator.Max auf
     AMax gesetzt und voOnEdit aus Options gel”scht.


4.23.4  TRangeValidator.Error
-----------------------------

Deklaration

     procedure Error; virtual;

Beschreibung

     Zeigt die Fehlermeldung an, da der eingegebene Wert nicht
     innerhalb des zul„ssigen Bereichs liegt.


4.23.5  TRangeValidator.IsValid
-------------------------------

Deklaration

     function IsValid(s: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn s (in eine longint-Zahl umgewandelt)
     innerhalb des Intervalls
     [TRangeValidator.Min,TRangeValidator.Max] liegt und
     TFilterValidator.IsValid ebenfalls true liefert.

     Evtl. vorhandene Leerzeichen werden vor der Umwandlung
     abgeschnitten.


4.23.6  TRangeValidator.IsValidInput
------------------------------------

Deklaration

     function IsValidInput(var s: string;
               SuppressFill: boolean): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn s (in eine longint-Zahl umgewandelt)
     innerhalb des Intervalls
     [TRangeValidator.Min,TRangeValidator.Max] liegt und
     TFilterValidator.IsValidInput ebenfalls true liefert.


4.24  TScrollBar
================

TScrollBar ist das Dialogelementobjekt fr Bildlaufleisten innerhalb
von Dialogen. Das Objekt kmmert sich automatisch um die Abarbeitung
und das Neuzeichnen des Sliders. Soll nach einer nderung des
Sliderwertes eine Aktion ausgefhrt werden, mu die Methode
TScrollBar.Work berschrieben werden.

Pointer

     PScrollBar = ^TScrollBar;

Felder

   ù IsHorizontal (siehe "TScrollBar.IsHorizontal")

   ù LineMagnitude (siehe "TScrollBar.LineMagnitude")

   ù PageMagnitude (siehe "TScrollBar.PageMagnitude")

   ù Size (siehe "TScrollBar.Size")

Methoden

   ù Init (siehe "TScrollBar.Init")

   ù Changed (siehe "TScrollBar.Changed")

   ù DeltaPos (siehe "TScrollBar.DeltaPos")

   ù GetPosition (siehe "TScrollBar.GetPosition")

   ù GetRange (siehe "TScrollBar.GetRange")

   ù GetSBoxMin (siehe "TScrollBar.GetSBoxMin")

   ù SetPosition (siehe "TScrollBar.SetPosition")

   ù SetRange (siehe "TScrollBar.SetRange")

   ù TestIndex (siehe "TScrollBar.TestIndex")

   ù Transfer (siehe "TScrollBar.Transfer")

   ù Work (siehe "TScrollBar.Work")

Vorfahre

   ù TControl

Nachfahren

     -


4.24.1  TScrollBar.IsHorizontal
-------------------------------

Deklaration

     IsHorizontal: boolean;  (nur lesen)

Beschreibung

     Gibt an, ob es sich bei der Bildlaufleiste um einen
     vertikalen (false) oder horizontalen (true) Slider handelt.
     Dieser Wert wird von TScrollBar.Init automatisch aus den
     Abmessungen des Sliders bestimmt.


4.24.2  TScrollBar.LineMagnitude
--------------------------------

Deklaration

     LineMagnitude: longint;

Beschreibung

     Gibt an, um wieviele Einheiten der Slider verschoben wird,
     wenn einer der Pfeile einfach angeklickt wird. Wird von
     TScrollBar.Init auf 1 gesetzt.


4.24.3  TScrollBar.PageMagnitude
--------------------------------

Deklaration

     PageMagnitude: longint;

Beschreibung

     Gibt an, um wieviele Einheiten der Slider verschoben wird,
     wenn der graue (bzw. schraffierte) Bereich einfach
     angeklickt wird. PageMagnitude wird von TScrollBar.Init
     zun„chst auf TScrollBar.Size gesetzt.


4.24.4  TScrollBar.Size
-----------------------

Deklaration

     Size: longint;

Beschreibung

     Size gibt an, wie gro der verschiebbare Kasten im Vergleich
     zum gesamten Slider sein soll. Man kann sich diese Zahl als
     Anzahl der Eintr„ge einer Liste vorstellen, die gleichzeitig
     sichtbar sind. Wenn also fnf Eintr„ge untereinander
     angezeigt werden, sollte Size 5 sein; wenn aber z.B. eine
     Adresse dargestellt wird, ist Size normalerweise 1.

     Size wird durch TScrollBar.Init gesetzt, der kleinstm”gliche
     Wert ist 1.


4.24.5  TScrollBar.Init
-----------------------

Deklaration

     constructor Init(AParent: PDialog; SIndx,DIndx,
                      IIndx: integer; TheSize,
                      TheRange: longint; Hlp: string);

Beschreibung

     Ruft den Vorfahren TControl.Init mit den Parametern AParent,
     SIndx und Hlp auf. SIndx mu der Index eines Dialogelements
     vom Typ G_BOX sein, das den grauen Hintergrund des Sliders
     darstellt. Innerhalb dieses Elements mu sich genau ein
     weiteres G_BOX-Element befinden, das zum Verschieben benutzt
     wird. Je nachdem ob SIndx eine gr”ere Breite bzw. H”he
     besitzt, wird IsHorizontal auf true bzw. false gesetzt und
     das Verschiebe-Element auf die maximale H”he bzw. Breite
     gebracht.

     DIndx und IIndx bezeichnen Elemente vom Typ G_BOXCHAR, die
     fr die Slider-Pfeile verwendet werden. Je nach Slidertyp
     werden die korrekten Pfeile automatisch gesetzt (dies mu
     also nicht im RCS gemacht werden).

     TControl.Style wird auf cs_ScrollBar und eine der sbs_XXXX-
     Konstanten gesetzt, TControl.ID auf id_NoExit,
     TScrollBar.Size auf TheSize, PageMagnitude auf Size und
     LineMagnitude auf 1. TheRange gibt an, wieviele Einheiten
     der gesamte Slider umfat; Minimum ist 1.

     Auch TScrollBar-Objekte nehmen standardm„ig nicht am
     Datentransfermechanismus teil.


4.24.6  TScrollBar.TestIndex
----------------------------

Deklaration

     function TestIndex(AnIndx: integer): boolean;
                                            virtual;

Beschreibung

     Liefert true, wenn eines der vier Slider-Elemente
     (Hintergrund, Verschiebe-Element, zwei Pfeile) angew„hlt
     wurde.


4.24.7  TScrollBar.Transfer
---------------------------

Deklaration

     function Transfer(DataPtr: pointer;
                     TransferFlag: word): word; virtual;

Beschreibung

     šbertr„gt Daten mit Hilfe der Struktur
     TScrollBarTransferRec.


4.24.8  TScrollBar.Changed
--------------------------

Deklaration

     procedure Changed(AnIndx: integer;
                         DblClick: boolean); virtual;

Beschreibung

     In dieser Methode wird der Sliderwert in Abh„ngigkeit vom
     angew„hlten Dialogelement ver„ndert und der Slider evtl. neu
     gezeichnet.

     Der neue Wert wird mit SetPosition gesetzt.


4.24.9  TScrollBar.Work
-----------------------

Deklaration

     procedure Work; virtual;

Beschreibung

     Dies ist eine abstrakte Methode, die zun„chst nichts macht.
     Sie wird aber bei jeder Wert„nderung des Sliders aufgerufen,
     so da hier z.B. die Anzeige des neuen Wertes stattfinden
     kann.


4.24.10  TScrollBar.SetPosition
-------------------------------

Deklaration

     procedure SetPosition(ThumbPos: longint); virtual;

Beschreibung

     Setzt die Bildlaufleiste auf die neue Position ThumbPos. Es
     wird darauf geachtet, da der mit TScrollBar.SetRange
     eingestellte Bereich nicht unter- bzw. berschritten wird.


4.24.11  TScrollBar.GetPosition
-------------------------------

Deklaration

     function GetPosition: longint; virtual;

Beschreibung

     Gibt den aktuellen Wert des Sliders zurck.


4.24.12  TScrollBar.DeltaPos
----------------------------

Deklaration

     function DeltaPos(Delta: longint): longint; virtual;

Beschreibung

     ndert den Wert der Bildlaufleiste mit SetPosition um Delta
     Einheiten. Als Rckgabe erh„lt man den neuen Wert.


4.24.13  TScrollBar.SetRange
----------------------------

Deklaration

     procedure SetRange(LoVal,HiVal: longint); virtual;

Beschreibung

     Setzt den Wertebereich der Bildlaufleiste. In LoVal wird die
     untere, in HiVal die obere Grenze bergeben. Die aktuelle
     Position wird an die neue untere Grenze angepat.

     SetRange(-2,5) setzt z.B. die untere Grenze auf -2 und die
     obere auf 5, d.h. der Slider umfat einen Bereich von acht
     Einheiten.


4.24.14  TScrollBar.GetRange
----------------------------

Deklaration

     function GetRange(var LoVal,HiVal: longint):
                                   longint; virtual;

Beschreibung

     Gibt in LoVal die untere Grenze, in HiVal die obere Grenze
     des Sliders zurck. Die Rckgabe der Funktion ist der
     gesamte Bereich, den die Bildlaufleiste umfat. Dieser Wert
     ist allerdings immer um eins erh”ht, d.h. die Rckgabe
     entspricht (HiVal-LoVal)+2.

     Wird TScrollBar.Init fr TheRange z.B. 100 bergeben, gibt
     GetRange in diesem Fall also 101 zurck.


4.24.15  TScrollBar.GetSBoxMin
------------------------------

Deklaration

     function GetSBoxMin: integer; virtual;

Beschreibung

     Gibt an, wie klein das Verschiebe-Element des Sliders
     minimal werden darf (in Pixeln). Voreingestellt ist z.Z. 8.


4.25  TScroller
===============

TScroller-Objekte werden ber das TWindow.Scroller-Feld verwaltet. Das
Objekt bietet einem Fenster die automatische Bearbeitung der
Bildlaufleisten (Slider), d.h. man braucht sich nicht mehr um die
Abfrage und Aktualisierung der Slider (und standardm„ig auch nicht um
das Neuzeichnen des Fensters) kmmern!

Normalerweise initialisieren und manipulieren Sie TScroller- Objekte
von den Methoden der Fenster-Objekte aus, zu denen Sie geh”ren.

Pointer

     PScroller = ^TScroller;

Felder

   ù HasHScrollBar (siehe "TScroller.HasHScrollBar")

   ù HasVScrollBar (siehe "TScroller.HasVScrollBar")

   ù Style (siehe "TScroller.Style")

   ù TrackMode (siehe "TScroller.TrackMode")

   ù Window (siehe "TScroller.Window")

   ù XLine (siehe "TScroller.XLine")

   ù XPage (siehe "TScroller.XPage")

   ù XPos (siehe "TScroller.XPos")

   ù XRange (siehe "TScroller.XRange")

   ù XUnit (siehe "TScroller.XUnit")

   ù YLine (siehe "TScroller.YLine")

   ù YPage (siehe "TScroller.YPage")

   ù YPos (siehe "TScroller.YPos")

   ù YRange (siehe "TScroller.YRange")

   ù YUnit (siehe "TScroller.YUnit")

Methoden

   ù Init (siehe "TScroller.Init")

   ù Done (siehe "TScroller.Done")

   ù GetXOrg (siehe "TScroller.GetXOrg")

   ù GetYOrg (siehe "TScroller.GetYOrg")

   ù HScroll (siehe "TScroller.HScroll")

   ù IsVisibleRect (siehe "TScroller.IsVisibleRect")

   ù ScrollBy (siehe "TScroller.ScrollBy")

   ù ScrollTo (siehe "TScroller.ScrollTo")

   ù SetPageSize (siehe "TScroller.SetPageSize")

   ù SetRange (siehe "TScroller.SetRange")

   ù SetSBarRange (siehe "TScroller.SetSBarRange")

   ù SetUnits (siehe "TScroller.SetUnits")

   ù VScroll (siehe "TScroller.VScroll")

Vorfahre

   ù TObject

Nachfahren

     -


4.25.1  TScroller.HasHScrollBar
-------------------------------

Deklaration

     HasHScrollBar: boolean;  (nur lesen)

Beschreibung

     Wenn das zugeh”rige Fenster ber einen horizontalen Slider
     verfgt, ist HasHScrollBar true.


4.25.2  TScroller.HasVScrollBar
-------------------------------

Deklaration

     HasVScrollBar: boolean;  (nur lesen)

Beschreibung

     Wenn das zugeh”rige Fenster ber einen vertikalen Slider
     verfgt, ist HasVScrollBar true.


4.25.3  TScroller.Style
-----------------------

Deklaration

     Style: word;

Beschreibung

     Gibt erweiterte F„higkeiten des TScroller-Objektes an. Wird
     von TScroller.Init auf Null gesetzt, z.Z. kann nur
     scs_BitbltScrolling verwendet werden.


4.25.4  TScroller.TrackMode
---------------------------

Deklaration

     TrackMode: boolean;

Beschreibung

     Ist TrackMode true, wird das Fenster bei Ver„nderungen der
     Sliderpositionen automatisch neu gezeichnet, indem
     TScroller-intern eine wind_update()-Schachtelung
     durchgefhrt und WMRedraw direkt aufgerufen wird. Ansonsten
     wird ForceRedraw verwendet. scs_BitbltScrolling funktioniert
     nur, wenn TrackMode true ist.

     Standardm„ig wird TrackMode mit true initialisiert.


4.25.5  TScroller.Window
------------------------

Deklaration

     Window: PWindow;  (nur lesen)

Beschreibung

     Window zeigt auf das Fenster, das TScroller besitzt. Wird
     von TScroller.Init gesetzt.


4.25.6  TScroller.XLine
-----------------------

Deklaration

     XLine: longint;

Beschreibung

     XLine ist die Anzahl der XUnit-Einheiten, um die - als
     Reaktion auf ein Anklicken eines der beiden horizontalen
     Pfeile - der Slider verschoben werden soll. Der
     voreingestellte Wert ist 1.


4.25.7  TScroller.XPage
-----------------------

Deklaration

     XPage: longint;

Beschreibung

     XPage ist die Anzahl von XUnit-Einheiten, um die der
     horizontale Slider verschoben wird, wenn in den grauen
     Bereich geklickt wird.

     Wird von TScroller.Init auf die aktuelle Breite des Fensters
     in XUnit-Einheiten gesetzt und beim ndern der Fenstergr”e
     mittels SetPageSize entsprechend angepat.


4.25.8  TScroller.XPos
----------------------

Deklaration

     XPos: longint;  (nur lesen)

Beschreibung

     XPos ist die aktuelle horizontale Position, angegeben in
     XUnit-Einheiten.


4.25.9  TScroller.XRange
------------------------

Deklaration

     XRange: longint;  (nur lesen)

Beschreibung

     XRange ist die Gesamtzahl von XUnit-Einheiten, um die das
     Fenster horizontal gescrollt werden kann. Wird von
     TScroller.Init gesetzt.


4.25.10  TScroller.XUnit
------------------------

Deklaration

     XUnit: integer;  (nur lesen)

Beschreibung

     XUnit ist die kleinste Anzahl von Pixeln, um die das Fenster
     horizontal gescrollt werden kann. Soll das Fenster Text
     anzeigen, kann XUnit mit SetUnits auf z.B. charWidth gesetzt
     werden. Wird von TScroller.Init gesetzt.


4.25.11  TScroller.YLine
------------------------

Deklaration

     YLine: longint;

Beschreibung

     YLine ist die Anzahl der YUnit-Einheiten, um die - als
     Reaktion auf ein Anklicken eines der beiden vertikalen
     Pfeile - der Slider verschoben werden soll. Der
     voreingestellte Wert ist 1.


4.25.12  TScroller.YPage
------------------------

Deklaration

     YPage: longint;

Beschreibung

     YPage ist die Anzahl von YUnit-Einheiten, um die der
     vertikale Slider verschoben wird, wenn in den grauen Bereich
     geklickt wird.

     Wird von TScroller.Init auf die aktuelle H”he des Fensters
     in YUnit-Einheiten gesetzt und beim ndern der Fenstergr”e
     mittels SetPageSize entsprechend angepat.


4.25.13  TScroller.YPos
-----------------------

Deklaration

     YPos: longint;  (nur lesen)

Beschreibung

     YPos ist die aktuelle vertikale Position, angegeben in
     YUnit-Einheiten.


4.25.14  TScroller.YRange
-------------------------

Deklaration

     YRange: longint;  (nur lesen)

Beschreibung

     YRange ist die Gesamtzahl von YUnit-Einheiten, um die das
     Fenster vertikal gescrollt werden kann. Wird von
     TScroller.Init gesetzt.


4.25.15  TScroller.YUnit
------------------------

Deklaration

     YUnit: integer;  (nur lesen)

Beschreibung

     YUnit ist die kleinste Anzahl von Pixeln, um die das Fenster
     vertikal gescrollt werden kann. Soll das Fenster Text
     anzeigen, kann YUnit mit SetUnits auf z.B. charHeight
     gesetzt werden. Wird von TScroller.Init gesetzt.


4.25.16  TScroller.Init
-----------------------

Deklaration

     constructor Init(TheWindow: PWindow; TheXUnit,
        TheYUnit: integer; TheXRange,TheYRange: longint);

Beschreibung

     Initialisiert ein neues TScroller-Objekt mit Window
     (=TheWindow) als dem besitzenden Fenster, wozu auch
     TObject.Init aufgerufen wird. Danach wird das Scroller-Feld
     des zugeh”rigen Fensters auf @self, TrackMode auf true,
     XLine und YLine auf 1, TScroller.XPos und TScroller.YPos auf
     0, XUnit auf TheXUnit und YUnit auf TheYUnit gesetzt.
     HasHScrollBar und HasVScrollBar werden ermittelt.
     Schlielich werden noch SetPageSize und
     SetRange(TheXRange,TheYRange) aufgerufen, womit alle Felder
     initialisiert w„ren.


4.25.17  TScroller.Done
-----------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Das Scroller-Feld des zugeh”rigen Fensters wird auf nil
     gesetzt, dann wird TObject.Done aufgerufen.


4.25.18  TScroller.GetXOrg
--------------------------

Deklaration

     function GetXOrg: longint; virtual;

Beschreibung

     Gibt den (virtuellen) X-Ursprung relativ zur linken Kante
     des Fenster-Arbeitsbereichs zurck. Wenn der Slider nicht
     ganz links ist, ist die Rckgabe also negativ.

     Wenn die Ausgaben an diesen neuen Ursprung angepat werden,
     kmmert sich TScroller automatisch darum, da immer der
     richtige Ausschnitt im Fenster gezeigt wird!


4.25.19  TScroller.GetYOrg
--------------------------

Deklaration

     function GetYOrg: longint; virtual;

Beschreibung

     Gibt den (virtuellen) Y-Ursprung relativ zur oberen Kante
     des Fenster-Arbeitsbereichs zurck. Wenn der Slider nicht
     ganz oben ist, ist die Rckgabe also negativ.

     Wenn die Ausgaben an diesen neuen Ursprung angepat werden,
     kmmert sich TScroller automatisch darum, da immer der
     richtige Ausschnitt im Fenster gezeigt wird!


4.25.20  TScroller.HScroll
--------------------------

Deklaration

     procedure HScroll; virtual;

Beschreibung

     Berechnet die neue Sliderposition, wenn TScroller.XPos
     ge„ndert wurde. Wird intern von ScrollTo und ScrollBy
     verwendet und braucht nicht direkt aufgerufen werden.


4.25.21  TScroller.IsVisibleRect
--------------------------------

Deklaration

     function IsVisibleRect(X,Y,XExt,
                       YExt: longint): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn ein Teil des in XUnit- bzw. YUnit-
     Einheiten bergebenen Rechtecks gegenw„rtig im
     Arbeitsbereich des besitzenden Fensters sichtbar ist.


4.25.22  TScroller.ScrollBy
---------------------------

Deklaration

     procedure ScrollBy(dX,dY: longint); virtual;

Beschreibung

     Scrollt um den durch dX und dY angegebenen Betrag und
     aktualisiert die Slider. Ist TrackMode true, wird der
     Fensterinhalt sofort neu gezeichnet, ansonsten wird nur
     ForceRedraw des zugeh”rigen Fensters aufgerufen.


4.25.23  TScroller.ScrollTo
---------------------------

Deklaration

     procedure ScrollTo(X,Y: longint); virtual;

Beschreibung

     Scrollt zur Position (X,Y) und aktualisiert die Slider. Ist
     TrackMode true, wird der Fensterinhalt sofort neu
     gezeichnet, ansonsten wird nur die Methode ForceRedraw des
     zugeh”rigen Fensters aufgerufen.


4.25.24  TScroller.SetPageSize
------------------------------

Deklaration

     procedure SetPageSize; virtual;

Beschreibung

     Setzt die Felder XPage und YPage entsprechend der aktuellen
     Breite und H”he des Fensters, die in XUnit- bzw. YUnit-
     Einheiten umgerechnet werden.


4.25.25  TScroller.SetRange
---------------------------

Deklaration

     procedure SetRange(TheXRange,TheYRange: longint);
                                                virtual;

Beschreibung

     Setzt XRange und YRange neu, wobei darauf geachtet wird, da
     die Mindestgr”e von 1 nicht unterschritten wird. Dann wird
     SetSBarRange aufgerufen.


4.25.26  TScroller.SetSBarRange
-------------------------------

Deklaration

     procedure SetSBarRange; virtual;

Beschreibung

     šberprft die TScroller-Werte auf ihre Gltigkeit und pat
     die Slider (Position und Gr”e) dann an diese Werte an. Wenn
     n”tig, wird auch der Fensterinhalt neu gezeichnet.


4.25.27  TScroller.SetUnits
---------------------------

Deklaration

     procedure SetUnits(TheXUnit,TheYUnit: integer);
                                               virtual;

Beschreibung

     Setzt XUnit und YUnit auf die bergebenen Werte, wobei auf
     die Mindestgr”e von 1 geachtet wird. Dann wird der
     Fensterinhalt neu gezeichnet.


4.25.28  TScroller.VScroll
--------------------------

Deklaration

     procedure VScroll; virtual;

Beschreibung

     Berechnet die neue Sliderposition, wenn TScroller.YPos
     ge„ndert wurde. Wird intern von ScrollTo und ScrollBy
     verwendet und braucht nicht direkt aufgerufen werden.


4.26  TSortedCollection
=======================

TSortedCollection ist ein Nachfahre von TCollection, mit dem sortierte
Kollektionen verwaltet werden k”nnen. Die Art der Sortierung wird
durch die Methode Compare bestimmt, die zu diesem Zweck berschrieben
werden mu. TSortedCollection kann Kollektionen mit und ohne doppelte
Schlssel verwalten, was durch Duplicates angegeben wird.

Pointer

     PSortedCollection = ^TSortedCollection;

Felder

   ù Duplicates (siehe "TSortedCollection.Duplicates")

Methoden

   ù Init (siehe "TSortedCollection.Init")

   ù Compare (siehe "TSortedCollection.Compare")

   ù IndexOf (siehe "TSortedCollection.IndexOf")

   ù Insert (siehe "TSortedCollection.Insert")

   ù KeyOf (siehe "TSortedCollection.KeyOf")

   ù Search (siehe "TSortedCollection.Search")

Vorfahre

   ù TCollection

Nachfahre

   ù TStringCollection


4.26.1  TSortedCollection.Duplicates
------------------------------------

Deklaration

     Duplicates: boolean;

Beschreibung

     Duplicates gibt an, ob Elemente mit gleichem Schlssel
     innerhalb der Kollektion erlaubt sind. Standardm„ig wird
     das Feld von TSortedCollection.Init auf false gesetzt, d.h.
     es darf kein Schlssel mehrfach vorkommen.


4.26.2  TSortedCollection.Init
------------------------------

Deklaration

     constructor Init(ALimit,ADelta: longint);

Beschreibung

     Ruft den Vorfahren TCollection.Init auf und setzt Duplicates
     auf false, d.h. es sind keine doppelten Schlssel erlaubt.


4.26.3  TSortedCollection.Compare
---------------------------------

Deklaration

     function Compare(Key1,Key2: pointer): integer;
                                             virtual;

Beschreibung

     Compare ist eine abstrakte Methode, die berschrieben werden
     mu. Dabei werden mit KeyOf aus Key1 und Key2 zwei
     Schlsselwerte ermittelt, die dann verglichen werden. Die
     Rckgabe ist wie folgt definiert:


                          +----+-----------+
                          | -1 | Key1<Key2 |
                          +----+-----------+
                          |  0 | Key1=Key2 |
                          +----+-----------+
                          |  1 | Key1>Key2 |
                          +----+-----------+

     Wird Compare nicht berschrieben, wird die Prozedur Abstract
     aufgerufen, die einen Laufzeitfehler erzeugt.


4.26.4  TSortedCollection.IndexOf
---------------------------------

Deklaration

     function IndexOf(Item: pointer): longint; virtual;

Beschreibung

     Ermittelt mit Search die Nummer des Elements Item. Ist das
     gesuchte Element nicht vorhanden, gibt IndexOf -1 zurck.


4.26.5  TSortedCollection.Insert
--------------------------------

Deklaration

     procedure Insert(Item: pointer); virtual;

Beschreibung

     Wenn das neue Element in der Kollektion noch nicht vorhanden
     ist, wird es an der richtigen Stelle einsortiert. Ist das
     Element schon vorhanden und Duplicates true, wird das
     Element vor dem bereits existierenden Element eingefgt. Ist
     das Element schon vorhanden, Duplicates aber false, wird das
     alte Element durch das neue ersetzt(!). Das alte Element
     wird in diesem Fall mit FreeItem freigegeben.


4.26.6  TSortedCollection.KeyOf
-------------------------------

Deklaration

     function KeyOf(Item: pointer): pointer; virtual;

Beschreibung

     Gibt fr das Element Item einen Zeiger auf den Schlssel des
     Elements zurck. Standardm„ig ist dies Item selbst. Sollen
     andere Daten verwaltet werden (z.B. Records), mu KeyOf
     berschrieben werden, damit ein anderer Zeiger (in diesem
     Fall z.B. auf ein Feld des Records) zurckgegeben werden
     kann.

Beispiel

     type PName = ^TName;
          TName = record
                    Nachname, Vorname: string
                  end;
     { ... }

     function MySColl.KeyOf(Item: pointer): pointer;

       begin
         KeyOf:=@PName(Item)^.Nachname
       end;


4.26.7  TSortedCollection.Search
--------------------------------

Deklaration

     function Search(Key: pointer; var Index: longint):
                                        boolean; virtual;

Beschreibung

     Sucht das Element mit dem Schlssel Key in der Kollektion.
     Konnte dies gefunden werden, liefert Search true zurck, und
     Index enth„lt die Nummer des gefundenen Elements. Ansonsten
     wird false zurckgegeben und Index auf die Position gesetzt,
     bei der das angegebene Element eingefgt wrde.


4.27  TStatic
=============

Mit TStatic k”nnen beliebige Textelemente recht einfach verwaltet
werden. Einfache String-Elemente k”nnen auerdem unterstrichen werden.

Pointer

     PStatic = ^TStatic;

Felder

   ù TextLen (siehe "TStatic.TextLen")

Methoden

   ù Init (siehe "TStatic.Init")

   ù Done (siehe "TStatic.Done")

   ù Clear (siehe "TStatic.Clear")

   ù GetText (siehe "TStatic.GetText")

   ù GetTextLen (siehe "TStatic.GetTextLen")

   ù SetText (siehe "TStatic.SetText")

   ù Transfer (siehe "TStatic.Transfer")

Vorfahre

   ù TControl

Nachfahre

   ù TEdit


4.27.1  TStatic.TextLen
-----------------------

Deklaration

     TextLen: integer;  (nur lesen)

Beschreibung

     Gibt die maximal zul„ssige L„nge des Textes+1 (fr das
     Nullbyte am Ende) an. Wird von TStatic.Init gesetzt.


4.27.2  TStatic.Init
--------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx,
                      ATextLen: integer;
                      UserDef: boolean; Hlp: string);

Beschreibung

     Ruft den Vorfahren TControl.Init auf und setzt TextLen auf
     ATextLen. Wird in ATextLen -1 bergeben und ist das
     Dialogelement ein G_[F][BOX]TEXT-Objekt, wird die L„nge
     automatisch berechnet.

     Ist UserDef true und AnIndx der Index eines G_BUTTON-,
     G_STRING- oder G_TITLE-Objekts, wird UsrDef auf true gesetzt
     und der Text sp„ter unterstrichen ausgegeben. Ansonsten mu
     AnIndx zu einem G_TEXT-, G_BOXTEXT-, G_FTEXT- oder
     G_FBOXTEXT- Element geh”ren.

     TControl.Style wird auf cs_Static und sts_Fill gesetzt.


4.27.3  TStatic.Done
--------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Deinstalliert das Dialogelementobjekt und ruft den Vorfahren
     TControl.Done auf.


4.27.4  TStatic.Clear
---------------------

Deklaration

     procedure Clear; virtual;

Beschreibung

     L”scht den Text des Dialogelementobjekts und zeichnet das
     Objekt neu. sts_Fill wird beachtet.


4.27.5  TStatic.GetText
-----------------------

Deklaration

     function GetText: string; virtual;

Beschreibung

     Gibt den Text des Dialogelementobjekts zurck. Wichtig:
     Leerzeichen, die evtl. wegen sts_Fill angeh„ngt wurden,
     werden nicht abgeschnitten!


4.27.6  TStatic.GetTextLen
--------------------------

Deklaration

     function GetTextLen: integer; virtual;

Beschreibung

     Gibt length(GetText) zurck.


4.27.7  TStatic.SetText
-----------------------

Deklaration

     procedure SetText(ATextString: string); virtual;

Beschreibung

     Setzt den Text eines Dialogelementobjekts neu und zeichnet
     dieses. Ist das zugeh”rige Textobjekt ein formatierter Text
     und das erste Zeichen in AText-String gleich '@', wird der
     Text gel”scht. sts_Fill wird beachtet.


4.27.8  TStatic.Transfer
------------------------

Deklaration

     function Transfer(DataPtr: pointer;
                     TransferFlag: word): word; virtual;

Beschreibung

     šbertr„gt die Daten des Objekts (d.h. den Text) mittels
     TStatic.SetText und TStatic.GetText. Wichtig: Die Rckgabe
     ist immer gerade; bei ungeraden Textl„ngen wird 1 addiert.
     Im TransferBuffer werden die Daten in einem string[x]
     abgelegt, wobei x ungerade sein mu (damit die Stringl„nge
     incl. Nullbyte wieder gerade ist). D.h. x entspricht der
     Textl„nge, wenn diese ungerade ist; ansonsten mu x auf
     Textl„nge+1 gesetzt werden.


4.28  TStrCollection
====================

TStrCollection ist ein Nachfahre von TStringCollection und verwaltet
sortierte Null-terminierte PChar-Zeichenketten.

Pointer

     PStrCollection = ^TStrCollection;

Methoden

   ù Compare (siehe "TStrCollection.Compare")

   ù FreeItem (siehe "TStrCollection.FreeItem")

Vorfahre

   ù TStringCollection

Nachfahren

     -


4.28.1  TStrCollection.Compare
------------------------------

Deklaration

     function Compare(Key1,Key2: pointer): integer;
                                             virtual;

Beschreibung

     Gibt Sgn(StrComp(Key1,Key2)) zurck.


4.28.2  TStrCollection.FreeItem
-------------------------------

Deklaration

     procedure FreeItem(Item: pointer); virtual;

Beschreibung

     L”scht das Element Item aus der Kollektion und gibt es mit
     ChrDispose(PChar(Item)) frei.


4.29  TStringCollection
=======================

TStringCollection ist ein Nachfahre von TSortedCollection und
verwaltet sortierte Pascal-Zeichenketten (Strings).

Pointer

     PStringCollection = ^TStringCollection;

Methoden

   ù Init (siehe "TStringCollection.Init")

   ù Compare (siehe "TStringCollection.Compare")

   ù FreeItem (siehe "TStringCollection.FreeItem")

Vorfahre

   ù TSortedCollection

Nachfahre

   ù TStrCollection


4.29.1  TStringCollection.Init
------------------------------

Deklaration

     constructor Init(ALimit,ADelta: longint);

Beschreibung

     Ruft den Vorfahren TSortedCollection.Init auf und setzt
     Duplicates auf true, d.h. gleiche Zeichenketten k”nnen
     mehrfach gespeichert werden.


4.29.2  TStringCollection.Compare
---------------------------------

Deklaration

     function Compare(Key1,Key2: pointer): integer;
                                             virtual;

Beschreibung

     Vergleicht PString(Key1)^ und PString(Key2)^. Die Rckgabe
     ist bei TSortedCollection.Compare definiert.


4.29.3  TStringCollection.FreeItem
----------------------------------

Deklaration

     procedure FreeItem(Item: pointer); virtual;

Beschreibung

     L”scht das Element Item aus der Kollektion und gibt es mit
     DisposeStr(PString(Item)) frei.


4.30  TStringLookupValidator
============================

TStringLookupValidator vergleicht die Zeichenkette eines TEdit-
Objektes mit einer Liste gltiger Strings, so da eine Eingabe auf
bestimmte, aber evtl. komplett verschiedenen Zeichenketten beschr„nkt
werden kann.

Pointer

     PStringLookupValidator = ^TStringLookupValidator;

Felder

   ù Strings (siehe "TStringLookupValidator.Strings")

Methoden

   ù Init (siehe "TStringLookupValidator.Init")

   ù Done (siehe "TStringLookupValidator.Done")

   ù Error (siehe "TStringLookupValidator.Error")

   ù Lookup (siehe "TStringLookupValidator.Lookup")

   ù NewStringList (siehe "TStringLookupValidator.NewStringList")

Vorfahre

   ù TLookupValidator

Nachfahren

     -


4.30.1  TStringLookupValidator.Strings
--------------------------------------

Deklaration

     Strings: PStringCollection;

Beschreibung

     Zeigt auf eine String-Kollektion, die alle akzeptablen
     Zeichenketten enth„lt. Ist Strings nil, wird jede Eingabe
     zurckgewiesen.

     Wird von TStringLookupValidator.Init gesetzt und kann mit
     NewStringList ersetzt werden.


4.30.2  TStringLookupValidator.Init
-----------------------------------

Deklaration

     constructor Init(AString: PStringCollection);

Beschreibung

     Ruft den geerbten TValidator.Init-Konstruktor auf und setzt
     dann Strings auf AString.


4.30.3  TStringLookupValidator.Done
-----------------------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Ruft NewStringList(nil) auf und gibt damit die Kollektion,
     auf die Strings zeigt, frei.


4.30.4  TStringLookupValidator.Error
------------------------------------

Deklaration

     procedure Error; virtual;

Beschreibung

     Zeigt die Fehlermeldung an, da die Eingabe nicht in der
     Gltigkeitsliste vorhanden ist.


4.30.5  TStringLookupValidator.Lookup
-------------------------------------

Deklaration

     function Lookup(s: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn s einem der in der Kollektion Strings
     gespeicherten Zeichenketten entspricht. Zur Suche wird die
     Kollektion-Methode Search verwendet.

     Ist Strings nil, wird immer false zurckgegeben.


4.30.6  TStringLookupValidator.NewStringList
--------------------------------------------

Deklaration

     procedure NewStringList(AString: PStringCollection);
                                                virtual;

Beschreibung

     Gibt eine evtl. schon vorhandene Gltigkeitsliste frei und
     setzt dann Strings auf AString. Wird in AString nil
     bergeben, besitzt das Validierungsobjekt fortan keine
     Gltigkeitsliste mehr und nimmt somit auch keine Eingabe
     mehr an.


4.31  TTextWindow
=================

TTextWindow ist ein Fensterobjekt, das Textzeilen anzeigen kann. Der
Benutzer kann vollautomatisch durch den Text scrollen (auch mit den
blichen Tastaturshortcuts), eine weitergehende Bearbeitung ist aber
nicht m”glich.

Pointer

     PTextWindow = ^TTextWindow;

Felder

   ù Color (siehe "TTextWindow.Color")

   ù FontID (siehe "TTextWindow.FontID")

   ù FontSize (siehe "TTextWindow.FontSize")

   ù Lines (siehe "TTextWindow.Lines")

   ù RealTabs (siehe "TTextWindow.RealTabs")

   ù TabSize (siehe "TTextWindow.TabSize")

Methoden

   ù Init (siehe "TTextWindow.Init")

   ù Done (siehe "TTextWindow.Done")

   ù AddLine (siehe "TTextWindow.AddLine")

   ù Clear (siehe "TTextWindow.Clear")

   ù Copy (siehe "TTextWindow.Copy")

   ù Cut (siehe "TTextWindow.Cut")

   ù DeletLine (siehe "TTextWindow.DeleteLine")

   ù ExitPrint (siehe "TTextWindow.ExitPrint")

   ù GetClassName (siehe "TTextWindow.GetClassName")

   ù GetLine (siehe "TTextWindow.GetLine")

   ù GetLineLength (siehe "TTextWindow.GetLineLength")

   ù GetNumLines (siehe "TTextWindow.GetNumLines")

   ù GetScroller (siehe "TTextWindow.GetScroller")

   ù GetStyle (siehe "TTextWindow.GetStyle")

   ù GetWindowClass (siehe "TTextWindow.GetWindowClass")

   ù InitPrint (siehe "TTextWindow.InitPrint")

   ù InsertLine (siehe "TTextWindow.InsertLine")

   ù Paint (siehe "TTextWindow.Paint")

   ù Paste (siehe "TTextWindow.Paste")

   ù Print (siehe "TTextWindow.Print")

   ù PrintFilter (siehe "TTextWindow.PrintFilter")

   ù Read (siehe "TTextWindow.Read")

   ù SelectAll (siehe "TTextWindow.SelectAll")

   ù SetColor (siehe "TTextWindow.SetColor")

   ù SetFont (siehe "TTextWindow.SetFont")

   ù SetupVDI (siehe "TTextWindow.SetupVDI")

   ù UpdateSubTitle (siehe "TTextWindow.UpdateSubTitle")

Vorfahre

   ù TWindow

Nachfahre

   ù TEditWindow


4.31.1  TTextWindow.Color
-------------------------

Deklaration

     Color: integer;  (nur lesen)

Beschreibung

     Enth„lt den Farbindex fr die Textzeilen. Wird von
     TTextWindow.GetScroller auf Black gesetzt.

     Wenn man einen neuen Farbindex setzt, mu man danach ein
     Neuzeichnen des Fensterinhalts veranlassen.


4.31.2  TTextWindow.FontID
--------------------------

Deklaration

     FontID: integer;  (nur lesen)

Beschreibung

     Enth„lt die ID des aktuellen Fonts. Wird von der Methode
     TTextWindow.GetScroller auf den ersten Systemfont
     initialisiert und kann mit der Methode TTextWindow.SetFont
     ge„ndert werden.


4.31.3  TTextWindow.FontSize
----------------------------

Deklaration

     FontSize: integer;  (nur lesen)

Beschreibung

     Gibt die Gr”e des aktuellen Fonts an (in Punkten).

     Wird von TTextWindow.GetScroller auf 10 initialisiert und
     kann mit TTextWindow.SetFont ge„ndert werden.


4.31.4  TTextWindow.Lines
-------------------------

Deklaration

     Lines: PStrCollection;  (nur lesen)

Beschreibung

     Mit dieser Kollektion werden die Textzeilen verwaltet. Zum
     Setzen bzw. Auswerten der Zeilen sollten nach M”glichkeit
     nicht die Kollektions- sondern die speziellen TTextWindow-
     Methoden verwendet werden.

     Wird von TTextWindow.Init angelegt.


4.31.5  TTextWindow.RealTabs
----------------------------

Deklaration

     RealTabs: boolean;

Beschreibung

     Dieses Feld wird von TTextWindow.Init auf true gesetzt, d.h.
     Tabulatoren (HT) werden von der Methode TTextWindow.TabXpand
     in die entsprechende Anzahl Leerzeichen umgewandelt.

     Andernfalls werden nur die Tab-Zeichen angezeigt.


4.31.6  TTextWindow.TabSize
---------------------------

Deklaration

     TabSize: integer;

Beschreibung

     Gibt die von TTextWindow.TabXpand ben”tigte Tabulatorweite
     an. Wird von TTextWindow.Init auf 2 gesetzt.


4.31.7  TTextWindow.Init
------------------------

Deklaration

     constructor Init(AParent: PWindow; ATitle: string;
                                 InitLines,ADelta: integer);

Beschreibung

     Ruft den Vorfahren TWindow.Init auf. Danach wird die
     Kollektion Lines mit den Werten InitLines und ADelta
     erzeugt. Der erste Parameter gibt also die maximal m”gliche
     Anzahl von Zeilen an (die st„ndig Speicherplatz belegen),
     die notfalls um ADelta erh”ht wird.

     Hat die Initialisierung funktioniert, wird zum Schlu noch
     UpdateSubTitle aufgerufen und RealTabs, TabSize und
     ws_ex_ReadOnly werden gesetzt.


4.31.8  TTextWindow.Done
------------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt die Kollektion in Lines frei und ruft dann den
     Vorfahren TWindow.Done auf.


4.31.9  TTextWindow.SetupVDI
----------------------------

Deklaration

     procedure SetupVDI; virtual;

Beschreibung

     Setzt die passenden Textattribute und ruft dann den
     Vorfahren TWindow.SetupVDI auf.


4.31.10  TTextWindow.AddLine
----------------------------

Deklaration

     procedure AddLine(NewLine: string); virtual;

Beschreibung

     H„ngt eine Zeile am Ende des Textes an.


4.31.11  TTextWindow.DeleteLine
-------------------------------

Deklaration

     procedure DeleteLine(LineNumber: integer); virtual;

Beschreibung

     L”scht die Zeile mit der Nummer LineNumber (0 bis
     GetNumLines-1).


4.31.12  TTextWindow.ExitPrint
------------------------------

Deklaration

     procedure ExitPrint; virtual;

Beschreibung

     Wird von TTextWindow.Print aufgerufen, nachdem alle
     Textzeilen gedruckt wurden. Z.Z. wird hier ein
     Seitenvorschub durchgefhrt und dem Drucker zum Schlu noch
     ein BEL gesendet.


4.31.13  TTextWindow.GetClassName
---------------------------------

Deklaration

     function GetClassName: string; virtual;

Beschreibung

     Gibt 'TextWindow' zurck.


4.31.14  TTextWindow.GetLine
----------------------------

Deklaration

     function GetLine(LineNumber: integer): string; virtual;

Beschreibung

     Liefert die Zeile LineNumber (0 bis GetNumLines-1).

     Ist LineNumber nicht gltig, wird ein Leerstring
     zurckgegeben.


4.31.15  TTextWindow.GetLineLength
----------------------------------

Deklaration

     function GetLineLength (LineNumber: integer): integer;
                                                  virtual;

Beschreibung

     Gibt die L„nge der Zeile LineNumber zurck. Intern wird dazu
     TTextWindow.GetLine aufgerufen.


4.31.16  TTextWindow.GetNumLines
--------------------------------

Deklaration

     function GetNumLines: integer; virtual;

Beschreibung

     Gibt die Anzahl der vorhandenen Zeilen zurck, d.h.
     Lines^.Count. Dieser Methode sollte allerdings Vorrang
     gegeben werden.


4.31.17  TTextWindow.GetScroller
--------------------------------

Deklaration

     function GetScroller: PScroller; virtual;

Beschreibung

     Liefert ein TScroller-Objekt zurck. Auerdem wird SetFont
     aufgerufen und Color gesetzt. Fr ein optimiertes Redraw
     wird scs_BitbltScrolling gesetzt.


4.31.18  TTextWindow.GetStyle
-----------------------------

Deklaration

     function GetStyle: integer; virtual;

Beschreibung

     Gibt TWindow.GetStyle zurck, l”scht daraus aber INFO und
     fgt SLIDER hinzu.


4.31.19  TTextWindow.InitPrint
------------------------------

Deklaration

     procedure InitPrint; virtual;

Beschreibung

     Wird von TTextWindow.Print aufgerufen, bevor die
     eigentlichen Textzeilen gedruckt werden. Im Moment passiert
     hier nichts, man k”nnte in dieser Methode aber z.B. den
     Drucker initialisieren.


4.31.20  TTextWindow.InsertLine
-------------------------------

Deklaration

     procedure InsertLine(Index: longint;
                             NewLine: string); virtual;

Beschreibung

     Fgt eine neue Zeile vor der Zeile mit der Nummer Index ein.
     Ist Index kleiner gleich Null, wird die Zeile am Anfang des
     Textes eingefgt; ist Index gr”er gleich GetNumLines, wird
     sie am Ende des Textes angeh„ngt.


4.31.21  TTextWindow.Paint
--------------------------

Deklaration

     procedure Paint(var PaintInfo: TPaintStruct); virtual;

Beschreibung

     Zeigt den Text im Fenster an. Im Moment wird auch beim
     zeilenweisen Scrollen der komplette Fensterinhalt neu
     gezeichnet, fr die Zukunft kann man aber eine optimiertere
     L”sung erwarten.


4.31.22  TTextWindow.SetFont
----------------------------

Deklaration

     procedure SetFont(NewID,NewSize: integer); virtual;

Beschreibung

     Setzt FontID und FontSize neu, wobei die bergebenen Werte
     evtl. korrigiert werden. Anschlieend werden die Slider
     aktualisiert.

     Wird von TTextWindow.GetScroller aufgerufen.


4.31.23  TTextWindow.SetColor
-----------------------------

Deklaration

     procedure TTextWindow.SetColor(NewColor: integer); virtual;

Beschreibung

     Setzt die Textfarbe, die in Color abgefragt werden kann.


4.31.24  TTextWindow.UpdateSubTitle
-----------------------------------

Deklaration

     procedure UpdateSubTitle; virtual;

Beschreibung

     Aktualisiert die Info-Zeile (sofern vorhanden). Z.Z. wird
     darin nur die Anzahl der Zeilen angezeigt.

     Wird von allen Methoden aufgerufen, die die Anzahl der
     Textzeilen ver„ndern.


4.31.25  TTextWindow.GetWindowClass
-----------------------------------

Deklaration

     procedure GetWindowClass(var AWndClass: TWndClass); virtual;

Beschreibung

     L”scht cs_QuitOnClose aus Class.Style, d.h. die Applikation
     wird beim Schlieen des Fensters nicht beendet.

     cs_ByteAlignClient wird gesetzt, damit das Scrolling
     beschleunigt wird.


4.31.26  TTextWindow.TabXpand
-----------------------------

Deklaration

     function TabXpand(s: string): string; virtual;

Beschreibung

     Wandelt Tabulatorzeichen in s in die entsprechende Anzahl
     Leerzeichen um, wenn TTextWindow.RealTabs true ist.
     Ansonsten wird s zurckgegeben.


4.31.27  TTextWindow.Read
-------------------------

Deklaration

     procedure Read(AFileName: string); virtual;

Beschreibung

     Fgt die Textdatei AFileName an das Ende des Textes an, wenn
     die Datei existiert. Der alte Text wird also nicht gel”scht!

     Anschlieend wird das Fenster neu gezeichnet.


4.31.28  TTextWindow.Cut
------------------------

Deklaration

     procedure Cut; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<X> drckt.
     Macht z.Z. noch nichts.


4.31.29  TTextWindow.Copy
-------------------------

Deklaration

     procedure Copy; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<C> drckt.
     Macht z.Z. noch nichts.


4.31.30  TTextWindow.Paste
--------------------------

Deklaration

     procedure Paste; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<V> drckt.

     Wenn sich im Klemmbrett eine Datei SCRAP.TXT oder SCRAP.ASC
     befindet, wird diese an den Text im Fenster angeh„ngt.

     Wenn ws_ex_ReadOnly gesetzt ist, kann keine Paste-Operation
     durchgefhrt werden.


4.31.31  TTextWindow.SelectAll
------------------------------

Deklaration

     procedure SelectAll; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<A> drckt.
     Macht z.Z. noch nichts.


4.31.32  TTextWindow.Clear
--------------------------

Deklaration

     procedure Clear; virtual;

Beschreibung

     L”scht den gesamten Text des Fensters ohne
     Sicherheitsabfrage!


4.31.33  TTextWindow.Print
--------------------------

Deklaration

     procedure Print; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<P> drckt.
     Nach einer Sicherheitsabfrage wird der gesamte Text auf der
     parallelen Schnittstelle ausgedruckt.


4.31.34  TTextWindow.PrintFilter
--------------------------------

Deklaration

     function PrintFilter(s: string): string; virtual;

Beschreibung

     Wird von TTextWindow.Print fr jede zu druckende Zeile
     aufgerufen. Hier k”nnen dann bestimmte Zeichen aus s
     ausgefiltert, ge„ndert etc. werden. Standardm„ig wird der
     Atari-Zeichensatz auf den IBM- (bzw. Epson-)
     Druckerzeichensatz abgebildet.


4.32  TToolbar
==============

TToolbar-Objekte werden mit Dialogelementen von Fenster-Toolbars
verknpft, die dem jeweiligen Fenster mit TWindow.LoadToolbar
zugewiesen wurden. Sie sind in ihrer Funktionsweise den TKeyMenu-
Objekten recht „hnlich.

Pointer

     PToolbar = ^TToolbar;

Felder

   ù ADialog (siehe "TToolbar.ADialog")

   ù VKey (siehe "TToolbar.VKey")

   ù VStat (siehe "TToolbar.VStat")

   ù ObjTree (siehe "TToolbar.ObjTree")

   ù ObjIndx (siehe "TToolbar.ObjIndx")

   ù ObjAddr (siehe "TToolbar.ObjAddr")

   ù VPipe (siehe "TToolbar.VPipe")

   ù VGHnd (siehe "TToolbar.VGHnd")

Methoden

   ù Init (siehe "TToolbar.Init")

   ù Done (siehe "TToolbar.Done")

   ù Check (siehe "TToolbar.Check")

   ù ClearMenuIndex (siehe "TToolbar.ClearMenuIndex")

   ù Disable (siehe "TToolbar.Disable")

   ù Enable (siehe "TToolbar.Enable")

   ù GetCheck (siehe "TToolbar.GetCheck")

   ù GetHelp (siehe "TToolbar.GetHelp")

   ù GetMenuIndex (siehe "TToolbar.GetMenuIndex")

   ù GetState (siehe "TToolbar.GetState")

   ù IsHelpAvailable (siehe "TToolbar.IsHelpAvailable")

   ù Paint (siehe "TToolbar.Paint")

   ù SetCheck (siehe "TToolbar.SetCheck")

   ù SetHelp (siehe "TToolbar.SetHelp")

   ù SetMenuIndex (siehe "TToolbar.SetMenuIndex")

   ù SetState (siehe "TToolbar.SetState")

   ù TestKey (siehe "TToolbar.TestKey")

   ù TestMessage (siehe "TToolbar.TestMessage")

   ù Toggle (siehe "TToolbar.Toggle")

   ù Uncheck (siehe "TToolbar.Uncheck")

Vorfahre

   ù TEvent

Nachfahren

     -


4.32.1  TToolbar.ADialog
------------------------

Deklaration

     ADialog: PDialog;

Beschreibung

     Dies ist ein universeller Dialog-Pointer, der in
     TToolbar.Init zun„chst auf nil gesetzt wird. So ist jedes
     TToolbar-Objekt bereits auf die Verwaltung eines Dialogs
     vorbereitet (was in der Praxis auch meistens genutzt wird).

     In der Work-Methode kann der Dialog dann initialisiert bzw.
     abgearbeitet werden (siehe Beispielprogramme).


4.32.2  TToolbar.VGHnd
----------------------

Deklaration

     VGHnd: boolean;

Beschreibung

     Gibt an, ob TToolbar.VPipe^[3] unmittelbar vor dem Versenden
     auf das GEM-Handle des bergeordneten Fensters gesetzt
     werden soll (da sich diese Kennung ja „ndern kann).

     Wird von TToolbar.Init gesetzt.


4.32.3  TToolbar.VKey
---------------------

Deklaration

     VKey: integer;

Beschreibung

     Gibt zusammen mit TToolbar.VStat die Taste an, auf die
     TToolbar.TestKey positiv reagieren soll. Wird von
     TToolbar.Init gesetzt.


4.32.4  TToolbar.VPipe
----------------------

Deklaration

     VPipe: PPipearray;  (nur lesen)

Beschreibung

     Enth„lt einen Pointer auf eine komplette GEM-Nachricht, die
     von TToolbar.TestKey bzw. TToolbar.TestMessage bei positiver
     Anwahl verschickt wird.

     Kann mit TToolbar.Init gesetzt werden.


4.32.5  TToolbar.VStat
----------------------

Deklaration

     VStat: integer;

Beschreibung

     Gibt zusammen mit TToolbar.VKey die Taste an, auf die
     TToolbar.TestKey positiv reagieren soll. Wird von
     TToolbar.Init gesetzt.

     Wichtig: Wenn egal ist, ob die linke oder die rechte
     <Shift>-Taste gedrckt ist, sollte hier K_SHIFT eingetragen
     sein.


4.32.6  TToolbar.ObjAddr
------------------------

Deklaration

     ObjAddr: PObj;  (nur lesen)

Beschreibung

     TToolbar.Init setzt hier die zum Dialogelement
     TToolbar.ObjIndx geh”rige Adresse ein.


4.32.7  TToolbar.ObjIndx
------------------------

Deklaration

     ObjIndx: integer;  (nur lesen)

Beschreibung

     Enth„lt die Nummer des Dialogelementobjekts, die an
     TToolbar.Init bergeben wird. Aus diesem Index kann
     TToolbar.ObjAddr berechnet werden.


4.32.8  TToolbar.ObjTree
------------------------

Deklaration

     ObjTree: integer;  (nur lesen)

Beschreibung

     Enth„lt den Index des Objektbaums der Toolbar, zu der das
     TToolbar-Objekt geh”rt. Wird fr TToolbar.Paint und
     TToolbar.TestMessage ben”tigt und von TToolbar.Init gesetzt.


4.32.9  TToolbar.Init
---------------------

Deklaration

     constructor TToolbar.Init(AParent: PWindow; ATree,
                            AnIndx,Stat,Key: integer; Msg: pointer;
                             GetHnd,Switch: boolean; Hlp: string);

Beschreibung

     Ruft den Vorfahren TEvent.Init auf. Dann wird TToolbar.VStat
     auf Stat, TToolbar.VKey auf Key, TToolbar.VGHnd auf GetHnd
     und TToolbar.ADialog auf nil gesetzt sowie TToolbar.VPipe
     angelegt, wenn Msg<>nil ist.

     ATree und AnIndx geben den Objektbaum und den Objektindex
     des Toolbar-Elements an, mit dem das TToolbar-Objekt
     verknpft werden soll. Der Objektbaum mu deshalb angegeben
     werden, da eine Toolbar ja zur Laufzeit gewechselt werden
     kann, es aber recht umst„ndlich w„re, dann auch jedesmal
     alle TToolbar-Objekte auszutauschen.

     Switch legt fest, ob das Toolbar-Element ein Pushbutton
     (false) ist, der also eine Aktion ausl”st, oder ob das
     Element einen Zustand darstellt (true).

     Hlp enth„lt den Hilfstext fr die BubbleHelp.


4.32.10  TToolbar.Done
----------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt eine evtl. in TToolbar.VPipe vorhandene GEM-Message
     frei und ruft den Vorfahren TEvent.Done auf.


4.32.11  TToolbar.TestMessage
-----------------------------

Deklaration

     function TestMessage(Pipe: Pipearray): boolean; virtual;

Beschreibung

     Wird von TWindow.WMToolbar aufgerufen, wenn ein Toolbar-
     Element angew„hlt wurde. Die Methode berprft, ob es sich
     dabei um das eigene Objekt handelt, und gibt dann true
     zurck, ansonsten false.

     Work wird in dieser Methode nicht aufgerufen, dies wird von
     WMToolbar erledigt!

     Die bergebene Message hat folgendes Format:

     [0]: GO_PRIVATE ($1235)
     [1]: apID
     [2]: 0
     [3]: GOP_TOOLBAR (1)
     [4]: Objektbaum-Index der aktiven Toolbar
     [5]: Index des angew„hlten Elements
     [6]: Status der Umschalttasten
     [7]: Anzahl der Mausklicks


4.32.12  TToolbar.Check
-----------------------

Deklaration

     procedure Check; virtual;

Beschreibung

     Ruft TToolbar.SetCheck(bf_Checked) auf und markiert damit
     das mit TToolbar.ObjIndx und TToolbar.ObjAddr angegebene
     Toolbar-Element.


4.32.13  TToolbar.Disable
-------------------------

Deklaration

     procedure Disable; virtual;

Beschreibung

     Ruft TToolbar.SetState(bf_Disabled) auf und macht damit das
     zugeh”rige Toolbar-Element nicht anw„hlbar.


4.32.14  TToolbar.Enable
------------------------

Deklaration

     procedure Enable; virtual;

Beschreibung

     Ruft TToolbar.SetState(bf_Enabled) auf und macht damit das
     zugeh”rige Toolbar-Element wieder anw„hlbar.


4.32.15  TToolbar.GetCheck
--------------------------

Deklaration

     function GetCheck: integer; virtual;

Beschreibung

     Gibt bf_Checked bzw. bf_Unchecked zurck, je nachdem ob das
     zugeh”rige Toolbar-Element markiert ist oder nicht.


4.32.16  TToolbar.GetState
--------------------------

Deklaration

     function GetState: integer; virtual;

Beschreibung

     Gibt bf_Enabled bzw. bf_Disabled zurck, je nachdem ob das
     zugeh”rige Toolbar-Element anw„hlbar ist oder nicht.


4.32.17  TToolbar.SetCheck
--------------------------

Deklaration

     procedure SetCheck(CheckFlag: integer); virtual;

Beschreibung

     Bestimmt die Markierung des zugeh”rigen Toolbar-Elements,
     d.h. bf_Checked oder bf_Unchecked.


4.32.18  TToolbar.SetState
--------------------------

Deklaration

     procedure SetState(StateFlag: integer); virtual;

Beschreibung

     Setzt den Zustand des zugeh”rigen Toolbar-Elements, d.h.
     bf_Enabled oder bf_Disabled.


4.32.19  TToolbar.TestKey
-------------------------

Deklaration

     function TestKey(Stat,Key: integer): boolean; virtual;

Beschreibung

     Wenn Stat=TToolbar.VStat, Key=TToolbar.VKey und
     TToolbar.GetState<>bf_Disabled ist, liefert TestKey true
     zurck. Auerdem werden dann folgende Aktionen ausgefhrt:
     Das zugeh”rige Toolbar-Element wird entsprechend markiert,
     Work wird aufgerufen, und wenn TToolbar.VPipe<>nil ist, wird
     die darin enthaltene GEM-Message verschickt. Ansonsten gibt
     TestKey false zurck.

     Wichtig: Wenn in VStat K_SHIFT eingetragen ist, werden beide
     <Shift>-Tasten gleichwertig behandelt!


4.32.20  TToolbar.Toggle
------------------------

Deklaration

     procedure Toggle; virtual;

Beschreibung

     Wechselt beim zugeh”rigen Toolbar-Element mit der Methode
     TToolbar.SetCheck den Zustand der Markierung.


4.32.21  TToolbar.Uncheck
-------------------------

Deklaration

     procedure Uncheck; virtual;

Beschreibung

     Ruft TToolbar.SetCheck(bf_Unchecked) auf und nimmt damit
     eine evtl. vorhandene Markierung des zugeh”rigen Toolbar-
     Elements zurck.


4.32.22  TToolbar.Paint
-----------------------

Deklaration

     procedure Paint; virtual;

Beschreibung

     Zeichnet das zugeh”rige Toolbar-Element neu, wenn die aktive
     Toolbar mit ObjTree bereinstimmt. Die Rechteckliste des
     Fensters wird automatisch beachtet.


4.32.23  TToolbar.IsHelpAvailable
---------------------------------

Deklaration

     function IsHelpAvailable: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das mit TToolbar.GetHelp ein Hilfs-
     text fr die BubbleHelp geliefert werden kann.


4.32.24  TToolbar.GetHelp
-------------------------

Deklaration

     function GetHelp: string; virtual;

Beschreibung

     Gibt einen Hilfstext fr die BubbleHelp zurck.


4.32.25  TToolbar.SetHelp
-------------------------

Deklaration

     procedure SetHelp(Hlp: string); virtual;

Beschreibung

     Weist dem Toolbarelement-Objekt einen neuen Hilfstext fr
     die BubbleHelp zu.


4.32.26  TToolbar.ClearMenuIndex
--------------------------------

Deklaration

     procedure ClearMenuIndex; virtual;

Beschreibung

     Ruft SetMenuIndex(0) auf und l”scht damit eine evtl.
     bestehende Verknpfung zu einem Men-Eintrag.


4.32.27  TToolbar.GetMenuIndex
------------------------------

Deklaration

     function GetMenuIndex: byte; virtual;

Beschreibung

     Liefert den Index des Men-Eintrags zurck, mit dem dieses
     Objekt verknpft ist. Null bedeutet, da keine Verknpfung
     besteht.

     Die Rckgabe entspricht dem h”herwertigen Byte des
     Objekttyps ob_type.


4.32.28  TToolbar.SetMenuIndex
------------------------------

Deklaration

     procedure SetMenuIndex(Indx: byte); virtual;

Beschreibung

     Verknpft das Objekt mit dem Men-Eintrag Indx.

     Hiermit k”nnen Anwender-konfigurierbare Toolbars realisiert
     werden, da statt des Aufrufs dieser Methode das h”herwertige
     Byte von ob_type auch direkt ge„ndert werden darf.

     Wenn sich die Verknpfung auf eine Fenster-Menleiste im
     selben Fenster beziehen soll, mu cs_WindowMenuToolbar
     gesetzt werden.


4.33  TTriState
===============

TTriState verh„lt sich genauso wie eine Checkbox. Zus„tzlich gibt es
allerdings noch einen dritten Zustand (bf_Grayed), der z.B. fr "Wert
nicht ver„ndert" benutzt werden kann.

Pointer

     PTriState = ^TTriState;

Methoden

   ù Init (siehe "TTriState.Init")

   ù Gray (siehe "TTriState.Gray")

Vorfahre

   ù TCheckBox

Nachfahren

     -


4.33.1  TTriState.Init
----------------------

Deklaration

     constructor Init(AParent: PDialog; AnIndx: integer;
                                            Hlp: string);

Beschreibung

     Ruft den Vorfahren TCheckBox.Init auf und setzt
     TControl.Style auf cs_3State.


4.33.2  TTriState.Gray
----------------------

Deklaration

     procedure Gray; virtual;

Beschreibung

     Ruft SetCheck(bf_Grayed) auf und versetzt die Checkbox damit
     in den "neutralen" Zustand.


4.34  TValidator
================

TValidator definiert ein weitestgehend abstraktes Validierungsobjekt.
Es ist nicht sinnvoll, dieses Objekt zu instantiieren, auer man
m”chte nur verhindern, da das zugeh”rige Eingabefeld leer ist (s.
voNotEmpty). Jedoch bietet es die Basis fr weiterreichende
Validierungsobjekte, da es die wichtigsten dafr notwendigen Methoden
vordefiniert.

Pointer

     PValidator = ^TValidator;

Felder

   ù Options (siehe "TValidator.Options")

   ù Status (siehe "TValidator.Status")

   ù Window (siehe "TValidator.Window")

Methoden

   ù Init (siehe "TValidator.Init")

   ù Error (siehe "TValidator.Error")

   ù IsValid (siehe "TValidator.IsValid")

   ù IsValidInput (siehe "TValidator.IsValidInput")

   ù Valid (siehe "TValidator.Valid")

Vorfahre

   ù TObject

Nachfahren

   ù TFilterValidator

   ù TLookupValidator

   ù TPXPictureValidator


4.34.1  TValidator.Options
--------------------------

Deklaration

     Options: word;

Beschreibung

     Options ist ein Bitmap-Feld, das die Optionen fr
     verschiedene Nachkommen von TValidator kontrolliert.
     Standardm„ig wird Options mit 0 initialisiert.


4.34.2  TValidator.Status
-------------------------

Deklaration

     Status: word;

Beschreibung

     Bezeichnet den Status des Validierungsobjekts. Ist Status
     gleich vsOK, wurde das Objekt korrekt initialisiert. Jeder
     andere Wert bedeutet, da ein Fehler aufgetreten ist.


4.34.3  TValidator.Window
-------------------------

Deklaration

     Window: PDialog;

Beschreibung

     Wird zun„chst mil nil initialisiert und dann von
     TEdit.SetValidator mit einem Zeiger auf den Dialog besetzt,
     zu dem das Eingabefeld geh”rt.


4.34.4  TValidator.Init
-----------------------

Deklaration

     constructor Init;

Beschreibung

     Ruft TObject.Init auf und setzt danach Options auf Null,
     TValidator.Status auf vsOK und TValidator.Window auf nil.


4.34.5  TValidator.Error
------------------------

Deklaration

     procedure Error; virtual;

Beschreibung

     Error wird von Valid aufgerufen, wenn diese Methode
     feststellt, da der Anwender ungltige Werte eingegeben hat.
     Diese Instanz vor Error zeigt eine Fehlermeldung an, wenn
     voNotEmpty gesetzt ist, die Eingabe aber leer ist.


4.34.6  TValidator.IsValid
--------------------------

Deklaration

     function IsValid(s: string): boolean; virtual;

Beschreibung

     Gibt an, ob die in s bergebene Zeichenkette eine gltige
     Eingabe fr das zugeh”rige Eingabefeld darstellt.

     Normalerweise gibt IsValid true zurck, nur wenn voNotEmpty
     gesetzt ist, wird vorher noch geprft, ob s nicht leer ist.


4.34.7  TValidator.IsValidInput
-------------------------------

Deklaration

     function IsValidInput(var s: string;
               SuppressFill: boolean): boolean; virtual;

Beschreibung

     Ein Eingabefeld, das mit einem Validierungsobjekt verbunden
     ist, ruft, wenn bei letzterem voOnEdit gesetzt ist,
     IsValidInput auf, w„hrend es in seiner TEdit.Edit-Methode
     die Eingabe eines Zeichens bearbeitet. Dadurch haben
     Validierungsobjekte die M”glichkeit, fehlerhafte Eingaben zu
     ermitteln (und zu korrigieren), bevor der Anwender die
     Eingabe abgeschlossen hat.

     TValidator.IsValidInput selbst gibt immer true zurck. Um
     dieses Verhalten zu „ndern, d.h. eine šberprfung zu
     erm”glichen, mu die Methode berschrieben werden.

     s ist der aktuelle Eingabestring. SuppressFill legt fest, ob
     das Validierungsobjekt vor der šberprfung evtl. fehlende
     Zeichen erg„nzen soll (z.B. Leerzeichen, Datumsformatierung
     etc.).

     Ist SuppressFill true, wird s unver„ndert geprft, ansonsten
     sollten vom Objekt - sofern dies vorgesehen ist - die
     entsprechenden nderungen vorgenommen werden.

     Da s ein var-Parameter ist, kann ihn IsValidInput ver„ndern
     (z.B. Klein- in Grobuchstaben umwandeln). Es sollten jedoch
     niemals ungltige Zeichen aus dem String gel”scht werden.
     Dadurch, da in diesem Fall false zurckgegeben wird,
     erf„hrt das Eingabefeld von der Existenz ungltiger Zeichen
     und kann sich selbst um deren Eliminierung kmmern.


4.34.8  TValidator.Valid
------------------------

Deklaration

     function Valid(s: string): boolean; virtual;

Beschreibung

     Gibt true zurck, wenn auch IsValid(s) true zurckgibt.
     Andernfalls wird TValidator.Error aufgerufen und false
     geliefert. Wird von TEdit.IsValid aufgerufen.


4.35  TWindow
=============

TWindow definiert das grundlegende Fensterobjekt, das sich um die
komplette GEM-Fensterverwaltung kmmert. Standardm„ig wird ein leeres
Fenster erzeugt, das aber bereits auf Maus- und Tastaturereignisse
reagiert. Durch šberschreiben der entsprechenden Methoden k”nnen
Fenster fr bestimmte Aufgaben spezialisiert werden.

Pointer

     PWindow = ^TWindow;

Felder

   ù Attr (siehe "TWindow.Attr")

   ù ChildList (siehe "TWindow.ChildList")

   ù Class (siehe "TWindow.Class")

   ù Clipboard (siehe "TWindow.Clipboard")

   ù Curr (siehe "TWindow.Curr")

   ù DlgTree (siehe "TWindow.DlgTree")

   ù Full (siehe "TWindow.Full")

   ù Icon (siehe "TWindow.Icon")

   ù IconClass (siehe "TWindow.IconClass")

   ù Parent (siehe "TWindow.Parent")

   ù Scroller (siehe "TWindow.Scroller")

   ù vdiHandle (siehe "TWindow.vdiHandle")

   ù Work (siehe "TWindow.Work")

   ù workIn (siehe "TWindow.workIn")

   ù workOut (siehe "TWindow.workOut")

Methoden

   ù Init (siehe "TWindow.Init")

   ù Done (siehe "TWindow.Done")

   ù At (siehe "TWindow.At")

   ù Calc (siehe "TWindow.Calc")

   ù CanClose (siehe "TWindow.CanClose")

   ù ChkAlign (siehe "TWindow.ChkAlign")

   ù ChkSize (siehe "TWindow.ChkSize")

   ù CloseWindow (siehe "TWindow.CloseWindow")

   ù Copy (siehe "TWindow.Copy")

   ù Create (siehe "TWindow.Create")

   ù CreateChildren (siehe "TWindow.CreateChildren")

   ù Cut (siehe "TWindow.Cut")

   ù DDFinished (siehe "TWindow.DDFinished")

   ù DDGetPath (siehe "TWindow.DDGetPath")

   ù DDGetPreferredTypes (siehe "TWindow.DDGetPreferredTypes")

   ù DDHeaderReply (siehe "TWindow.DDHeaderReply")

   ù DDReadArgs (siehe "TWindow.DDReadArgs")

   ù DDReadData (siehe "TWindow.DDReadData")

   ù Delete (siehe "TWindow.Delete")

   ù Destroy (siehe "TWindow.Destroy")

   ù DisableAutoCreate (siehe "TWindow.DisableAutoCreate")

   ù EnableAutoCreate (siehe "TWindow.EnableAutoCreate")

   ù ExitPaint (siehe "TWindow.ExitPaint")

   ù FirstIcon (siehe "TWindow.FirstIcon")

   ù FirstWndThat (siehe "TWindow.FirstWndThat")

   ù FirstWorkRect (siehe "TWindow.FirstWorkRect")

   ù ForceRedraw (siehe "TWindow.ForceRedraw")

   ù ForEachWnd (siehe "TWindow.ForEachWnd")

   ù FreeDialog (siehe "TWindow.FreeDialog")

   ù FreeIcon (siehe "TWindow.FreeIcon")

   ù FreeMenu (siehe "TWindow.FreeMenu")

   ù FreeToolbar (siehe "TWindow.FreeToolbar")

   ù FullSize (siehe "TWindow.FullSize")

   ù GetClassName (siehe "TWindow.GetClassName")

   ù GetClipboard (siehe "TWindow.GetClipboard")

   ù GetCurr (siehe "TWindow.GetCurr")

   ù GetDC (siehe "TWindow.GetDC")

   ù GetFull (siehe "TWindow.GetFull")

   ù GetIconTitle (siehe "TWindow.GetIconTitle")

   ù GetIconWindowClass (siehe "TWindow.GetIconWindowClass")

   ù GetScroller (siehe "TWindow.GetScroller")

   ù GetStyle (siehe "TWindow.GetStyle")

   ù GetTitle (siehe "TWindow.GetTitle")

   ù GetVDIHandle (siehe "TWindow.GetVDIHandle")

   ù GetWindowClass (siehe "TWindow.GetWindowClass")

   ù GetWork (siehe "TWindow.GetWork")

   ù GetWorkMax (siehe "TWindow.GetWorkMax")

   ù GetWorkMin (siehe "TWindow.GetWorkMin")

   ù HandleMenu (siehe "TWindow.HandleMenu")

   ù IconPaint (siehe "TWindow.IconPaint")

   ù IconSelect (siehe "TWindow.IconSelect")

   ù IndexOf (siehe "TWindow.IndexOf")

   ù InitPaint (siehe "TWindow.InitPaint")

   ù IsDialog (siehe "TWindow.IsDialog")

   ù IsIconified (siehe "TWindow.IsIconified")

   ù IsModeless (siehe "TWindow.IsModeless")

   ù IsTop (siehe "TWindow.IsTop")

   ù LoadDialog (siehe "TWindow.LoadDialog")

   ù LoadIcon (siehe "TWindow.LoadIcon")

   ù LoadMenu (siehe "TWindow.LoadMenu")

   ù LoadToolbar (siehe "TWindow.LoadToolbar")

   ù MakeWindow (siehe "TWindow.MakeWindow")

   ù MNSelected (siehe "TWindow.MNSelected")

   ù Move (siehe "TWindow.Move")

   ù Next (siehe "TWindow.Next")

   ù NextIcon (siehe "TWindow.NextIcon")

   ù NextWorkRect (siehe "TWindow.NextWorkRect")

   ù OpenWindow (siehe "TWindow.OpenWindow")

   ù Paint (siehe "TWindow.Paint")

   ù Paste (siehe "TWindow.Paste")

   ù Previous (siehe "TWindow.Previous")

   ù Print (siehe "TWindow.Print")

   ù RawDestroy (siehe "TWindow.RawDestroy")

   ù ReleaseDC (siehe "TWindow.ReleaseDC")

   ù SelectAll (siehe "TWindow.SelectAll")

   ù SetCurr (siehe "TWindow.SetCurr")

   ù SetCursor (siehe "TWindow.SetCursor")

   ù SetDlgTree (siehe "TWindow.SetDlgTree")

   ù SetGadgets (siehe "TWindow.SetGadgets")

   ù SetSubTitle (siehe "TWindow.SetSubTitle")

   ù SetTitle (siehe "TWindow.SetTitle")

   ù SetupSize (siehe "TWindow.SetupSize")

   ù SetupWindow (siehe "TWindow.SetupWindow")

   ù SetWork (siehe "TWindow.SetWork")

   ù ShutdownWindow (siehe "TWindow.ShutdownWindow")

   ù Size (siehe "TWindow.Size")

   ù Top (siehe "TWindow.Top")

   ù UpdateDialog (siehe "TWindow.UpdateDialog")

   ù WMArrowed (siehe "TWindow.WMArrowed")

   ù WMBottomed (siehe "TWindow.WMBottomed")

   ù WMButton (siehe "TWindow.WMButton")

   ù WMClick (siehe "TWindow.WMClick")

   ù WMClosed (siehe "TWindow.WMClosed")

   ù WMDblClick (siehe "TWindow.WMDblClick")

   ù WMDragDrop (siehe "TWindow.WMDragDrop")

   ù WMFulled (siehe "TWindow.WMFulled")

   ù WMHSlid (siehe "TWindow.WMHSlid")

   ù WMIconify (siehe "TWindow.WMIconify")

   ù WMKeyDown (siehe "TWindow.WMKeyDown")

   ù WMMoved (siehe "TWindow.WMMoved")

   ù WMNewTop (siehe "TWindow.WMNewTop")

   ù WMOnTop (siehe "TWindow.WMOnTop")

   ù WMRBoxChanged (siehe "TWindow.WMRBoxChanged")

   ù WMRBoxCheck (siehe "TWindow.WMRBoxCheck")

   ù WMRButton (siehe "TWindow.WMRButton")

   ù WMRedraw (siehe "TWindow.WMRedraw")

   ù WMRubbox (siehe "TWindow.WMRubbox")

   ù WMShaded (siehe "TWindow.WMShaded")

   ù WMSized (siehe "TWindow.WMSized")

   ù WMToolbar (siehe "TWindow.WMToolbar")

   ù WMTopped (siehe "TWindow.WMTopped")

   ù WMUniconify (siehe "TWindow.WMUniconify")

   ù WMUnshaded (siehe "TWindow.WMUnshaded")

   ù WMUntopped (siehe "TWindow.WMUntopped")

   ù WMVSlid (siehe "TWindow.WMVSlid")

Vorfahre

   ù TEventObject

Nachfahren

   ù TDialog

   ù TTextWindow


4.35.1  TWindow.Attr
--------------------

Deklaration

     Attr: TWindowAttr;

Beschreibung

     Diverse Attribute und fensterspezifische Werte sind in
     diesem Record zusammengefat. Wird von TWindow.Init
     initialisiert.

     PWindowAttr = ^TWindowAttr;
     TWindowAttr = record
       Title,                (nur lesen)
       SubTitle  : PString;  (nur lesen)
       RBox      : GRECT;
       Handle    : HWnd;     (nur lesen)
       gemHandle,            (nur lesen)
       Status,               (nur lesen)
       Style,                (nur lesen)
       sysFonts,             (nur lesen)
       addFonts,             (nur lesen)
       charWidth,
       charHeight,
       boxWidth,
       boxHeight : integer;
       ExStyle   : longint
     end;

     Title enth„lt einen Zeiger auf den Titel-String des Fensters
     (wird mit dem an TWindow.Init bergebenen Titel besetzt),
     SubTitle einen Zeiger auf die Infozeile (wird mit einem
     Leerstring initialisiert). RBox wird zun„chst ausgenullt,
     hiermit kann der Bereich fr eine evtl. untersttzte Rubbox
     beschr„nkt werden (s. TWindow.WMRubbox).

     Handle enth„lt die ObjectGEM-interne Kennung fr alle
     Fenster und Dialoge (d.h. auch modale Dialoge erhalten eine
     solche). Im Gegensatz dazu bekommt gemHandle von
     TWindow.Create die GEM-Kennung fr ein Fenster bzw. einen
     nicht-modalen Dialog zugewiesen (initialisiert mit -1).

     Status zeigt den Zustand des Fensters an, s. dazu die
     ws_XXXX-Konstanten; Anfangswert ist ws_NoWindow. In Style
     wird der GEM-Fensterstil gespeichert, der mit
     TWindow.GetStyle ermittelt wird.

     ExStyle schlielich beschreibt speziellere Eigenschaften des
     Fensters. Bei TWindow wird mit ws_ex_Modeless initialisiert,
     bei TDialog mit ws_ex_TryModeless+ws_ex_CenterOnce. Wenn
     global as_MoveTransparent oder as_MoveDials gesetzt ist,
     dann wird zus„tzlich noch ws_ex_MoveTransparent bzw.
     ws_ex_MoveDial gesetzt.


4.35.2  TWindow.Parent
----------------------

Deklaration

     Parent: PWindow;  (nur lesen)

Beschreibung

     Zeigt auf das bergeordnete Fenster, wenn dieses existiert.
     Das Fensterobjekt ist dann in der ChildList des
     bergeordneten Fensters eingetragen. Andernfalls ist Parent
     nil, und TApplication ist gewissermaen das Elternobjekt, da
     das Fenster dann in der MainWindow-Liste zu finden ist. Wird
     von TWindow.Init gesetzt.


4.35.3  TWindow.vdiHandle
-------------------------

Deklaration

     vdiHandle: integer;  (nur lesen)

Beschreibung

     Wird von TWindow.Init mit GetVDIHandle ermittelt. Fr
     TWindow-Objekte enth„lt das Feld normalerweise das Handle
     einer eigenen VDI-Workstation! TDialog-Objekte verwenden
     stattdessen eine Kopie des TApplication.vdiHandle-Feldes.


4.35.4  TWindow.Work
--------------------

Deklaration

     Work: GRECT;  (nur lesen)

Beschreibung

     Enth„lt den aktuellen Arbeitsbereich des Fensters. Kann mit
     TWindow.GetWork neu berechnet werden; das sollte allerdings
     nicht notwendig sein, wenn zur Gr”enmanipulation des
     Fensters nut ObjectGEM-Methoden verwendet werden.

     Wichtig: Der Arbeitsbereich sollte nie mittels wind_get()
     erfragt werden, da man sonst zu evtl. Erweiterungen
     (Toolbars, Menleisten etc.) inkompatibel wrde!


4.35.5  TWindow.ChildList
-------------------------

Deklaration

     ChildList: PWindow;  (nur lesen)

Beschreibung

     ChildList ist eine verkettete Liste aller untergeordneten
     Fensterobjekte. ChildList ist nil, wenn keine Child-Fenster
     existieren, sonst zeigt der Pointer auf das erste Objekt in
     der Liste. Untergeordnete Fenster k”nnen relativ bequem mit
     TWindow.FirstWndThat und TWindow.ForEachWnd durchlaufen
     werden.


4.35.6  TWindow.IconClass
-------------------------

Deklaration

     IconClass: TIconWndClass;

Beschreibung

     Mit diesem Record wird die Fensterklasse des Icon-Fensters
     festgelegt. Da ein solches Fenster sehr viel weniger
     Funktionen als ein "richtiges" Fenster hat, sind hier auch
     weniger Informationen als in TWindow.Class gespeichert.

     PIconWndClass         = ^TIconWndClass;
     TIconWndClass         = record
       hCursor      : HCursor;
       hbrBackground: HBrush
     end;

     Mit hCursor wird die Mausform festgelegt, die verwendet
     wird, sobald die Maus den TWindow.Work-Bereich des Icon-
     Fensters betritt. Standardm„ig wird ARROW eingetragen. Ist
     der Wert gr”er als $7fff, wird er als Pointer auf eine
     selbstdefinierte MFORM-Struktur aufgefat. Soll der
     Mauscursor nicht ver„ndert werden, mu id_No eingetragen
     werden. hbrBackground gibt die Farbe an, mit der der
     Arbeitsbereich des Icon-Fensters vor dem Aufruf der
     TWindow.Paint-Methode gel”scht wird. Dabei mu der VDI-
     Farbindex+1 eingetragen werden, da eine Null signalisiert,
     da der Hintergrund nicht gel”scht werden soll. Wird auf
     White+1 gesetzt. Der Record wird von TWindow.Init mit der
     Methode GetIconWindowClass eingelesen.

     Wichtig: Alle anderen Werte werden auch bei Icon-Fenster aus
     dem Feld TWindow.Class genommen - abgesehen von den
     cs_Align-Konstanten, die von Icon-Fenstern generell nicht
     beachtet werden.


4.35.7  TWindow.Class
---------------------

Deklaration

     Class: TWndClass;

Beschreibung

     Mit diesem Record werden sog. "Fensterklassen" festgelegt,
     d.h. die Struktur enth„lt allgemeinere Attribute als
     TWindow.Attr, von denen erwartet werden kann, da sie fr
     mehrere Fenster gelten. Wird von TWindow.Init mittels
     GetWindowClass initialisiert.

     PWndClass = ^TWndClass;
     TWndClass = record
       Style        : word;
       hCursor      : HCursor;
       hbrBackground: HBrush;
       MenuTree,               (nur lesen)
       ToolbarTree  : PTree;   (nur lesen)
       lpszClassName: PString  (nur lesen)
     end;

     Style enth„lt eine der cs_XXXX-Konstanten (bzw. eine
     Kombination davon) und wird mit
     cs_DblClks+cs_CreateOnAccOpen+cs_AutoOpen+cs_QuitOnClose
     (bei TWindow) bzw. mit
     cs_DblClks+cs_WorkBackground+cs_SaveBits (bei TDialog)
     initialisiert. Mit hCursor wird die Mausform festgelegt, die
     verwendet wird, sobald die Maus den TWindow.Work-Bereich des
     Fensters betritt. Standardm„ig wird ARROW eingetragen. Ist
     der Wert gr”er als $7fff, wird er als Pointer auf eine
     selbstdefinierte MFORM- Struktur aufgefat. Soll der
     Mauscursor nicht ver„ndert werden, mu id_No eingetragen
     werden. hbrBackground gibt die Farbe an, mit der der
     Arbeitsbereich des Fensters vor dem Aufruf der
     TWindow.Paint-Methode gel”scht wird. Dabei mu der VDI-
     Farbindex+1 eingetragen werden, da eine Null signalisiert,
     da der Hintergrund nicht gel”scht werden soll. Wird auf
     White+1 gesetzt.

     In MenuTree befindet sich der Zeiger auf den Menbaum des
     Fensters, wenn ein solches mit TWindow.LoadMenu installiert
     wurde. Ansonsten steht nil darin.

     ToolbarTree wird mit nil initialisiert. Wenn dem Fenster mit
     LoadToolbar eine Toolbar zugewiesen wurde, steht in diesem
     Feld dann der Zeiger auf den Objektbaum.

     lpszClassName gibt den Namen der Fensterklasse an, der mit
     GetClassName ermittelt wird. Dieser Name braucht bei
     "einfachen" Fenstern nicht ge„ndert zu werden, wenn
     allerdings ein erheblicher Unterschied besteht (z.B.
     "Window" und "Dialog", "EditWindow", "HelpWindow",
     "FontDialog" etc.), sollte die Methode berschrieben werden.


4.35.8  TWindow.Clipboard
-------------------------

Deklaration

     Clipboard: PClipboard;  (nur lesen)

Beschreibung

     Zeigt auf das mit dem Fenster-Objekt verknpfte TClipboard-
     Objekt (oder ist nil, wenn ein solches nicht existiert).

     Wird mit TWindow.GetClipboard gesetzt.


4.35.9  TWindow.Curr
--------------------

Deklaration

     Curr: GRECT;  (nur lesen)

Beschreibung

     Enth„lt den aktuellen Auenmae des Fensters. Kann mit
     TWindow.GetCurr neu berechnet werden; das sollte allerdings
     nicht notwendig sein, wenn zur Gr”enmanipulation des
     Fensters nur ObjectGEM-Methoden verwendet werden.


4.35.10  TWindow.DlgTree
------------------------

Deklaration

     DlgTree: PTree;  (nur lesen)

Beschreibung

     Zeigt auf das im Fenster anzuzeigende Dialogformular. Wird
     von TWindow.Init mit nil belegt. Wenn DlgTree ge„ndert
     werden soll, mu die Methode LoadDialog aufgerufen werden,
     die intern ihrerseits SetDlgTree aufruft.

     Wenn in DlgTree ein Dialog angegeben ist, wird dieser von
     TWindow.Paint automatisch gezeichnet.


4.35.11  TWindow.Full
---------------------

Deklaration

     Full: GRECT;  (nur lesen)

Beschreibung

     Enth„lt die Maximalgr”e dieses Fensters. Wird von
     TWindow.SetupSize zun„chst auf die Gr”e des Desktop-
     Arbeitsbereichs initialisiert. Wenn das Fenster sp„ter evtl.
     auf volle Gr”e gebracht wird, wird intern GetFull
     aufgerufen, wodurch dann Full unter Beachtung von GetWorkMax
     neu gesetzt wird.


4.35.12  TWindow.Scroller
-------------------------

Deklaration

     Scroller: PScroller;

Beschreibung

     Scroller enth„lt einen Zeiger auf ein TScroller-Objekt, wenn
     ein solches vorhanden ist. Soll einem Fenster ein Scroll-
     Objekt zugewiesen werden, sollte dies im TWindow.Init-
     Konstruktor geschehen.


4.35.13  TWindow.Icon
---------------------

Deklaration

     Icon: PIcon;  (nur lesen)

Beschreibung

     Enth„lt einen Zeiger auf ein TIcon-Objekt, wenn dem Fenster
     ein solches mit TWindow.LoadIcon zugewiesen wurde.

     Wird von TWindow.Init auf nil gesetzt.


4.35.14  TWindow.workIn
-----------------------

Deklaration

     workIn: workin_ARRAY;

Beschreibung

     Dieses Array wird von TWindow.Init zum ™ffnen der VDI-
     Workstation ben”tigt. Danach kann es fr eigene Zwecke
     verwendet werden.


4.35.15  TWindow.workOut
------------------------

Deklaration

     workOut: workout_ARRAY;

Beschreibung

     Dieses Array wird von TWindow.Init fr die Rckgabewerte von
     v_opnvwk() ben”tigt. Danach kann es fr eigene Zwecke
     verwendet werden, da alle wichtigen Werte anderweitig
     gespeichert werden.


4.35.16  TWindow.Init
---------------------

Deklaration

     constructor Init(AParent: PWindow; ATitle: string);

Beschreibung

     Ruft TEventObject.Init auf, setzt TWindow.Parent auf AParent
     und initialisiert TWindow.vdiHandle mit GetVDIHandle sowie
     Attr.

     Wenn GetVDIHandle signalisiert, da eine neue VDI-
     Workstation ge”ffnet werden soll, geschieht dies dann mit
     v_opnvwk().

     ChildList, Scroller und DlgTree werden auf nil gesetzt und
     das Fensterobjekt in die ChildList des bergeordneten
     Fensters eingeh„ngt.

     Dann werden Class mittels GetWindowClass und IconClass mit
     GetIconWindowClass initialisiert, ATitle wird zum
     Fenstertitel, und die Infozeile wird gel”scht.

     Wenn eine neue VDI-Workstation angelegt wurde, wird dann
     TWindow.SetupVDI aufgerufen.

     Danach wird das Feld Scroller mit TWindow.GetScroller und
     TWindow.Clipboard mit TWindow.GetClipboard ermittelt.

     Zum Schlu wird SetupWindow aufgerufen.


4.35.17  TWindow.Done
---------------------

Deklaration

     destructor Done; virtual;

Beschreibung

     Gibt alle untergeordneten Fenster frei, ruft die Methoden
     ShutdownWindow, TWindow.FreeIcon, FreeDialog, FreeToolbar
     und TWindow.FreeMenu auf, schliet das Fenster, gibt die
     Kennung frei (sofern dies noch nicht geschehen ist) und
     entfernt das Fensterobjekt aus der ChildList des
     bergeordneten Fensters.

     Danach werden Scroller und TWindow.Clipboard freigegeben
     (letzteres nur, wenn ein neues Klemmbrett-Objekt installiert
     wurde).

     Wenn TWindow.Init eine neue VDI-Workstation angefordert hat,
     wird diese hier mit v_clsvwk() wieder freigegeben.

     Zum Schlu wird TEventObject.Done aufgerufen.


4.35.18  TWindow.GetVDIHandle
-----------------------------

Deklaration

     function GetVDIHandle: integer; virtual;

Beschreibung

     Wird von TWindow.Init aufgerufen, um TWindow.vdiHandle zu
     ermitteln.

     Standardm„ig wird id_NewHandle geliefert, d.h. fr jedes
     Fenster wird eine eigene VDI-Workstation ge”ffnet.

     Wird ein Wert gr”er gleich Null bergeben, wird dieser als
     gltiges VDI-Handle interpretiert, es wird dann keine neue
     Workstation angefordert!


4.35.19  TWindow.SetupVDI
-------------------------

Deklaration

     procedure SetupVDI; virtual;

Beschreibung

     Wird von TWindow.Init aufgerufen, wenn mit der Methode
     GetVDIHandle dem Fenster eine eigene VDI-Workstation
     zugewiesen wurde, damit hier die passenden Attribute
     eingestellt werden. Zun„chst werden jedoch - wenn GDOSActive
     true und ws_ex_LoadFonts gesetzt ist - alle verfgbaren
     GEM-Fonts nachgeladen. Daraus folgt, da - wenn das Fenster
     auf GEM-Zeichens„tze zurckgreifen will - SetupVDI
     berschrieben werden mu und die geerbte Methode erst dann
     aufgerufen werden darf, wenn man ws_ex_LoadFonts gesetzt
     hat!

     Danach werden folgende Werte gesetzt (Schreibweise
     abgekrzt): vswr_mode(MD_REPLACE), vsl_udsty($5555),
     vsl_type(LT_SOLID), vsf_perimeter(PER_ON), vsl_color(Black),
     vsl_ends(LE_SQUARED,LE_SQUARED), vsm_type(MT_DOT),
     vsm_height(1), vsm_color(Black), vst_rotation(0),
     vsf_style(4), vsf_color(Black),
     vst_alignment(TA_LEFT,TA_BASELINE), vsl_width(1),
     vst_color(Black), vsf_interior(FIS_HOLLOW),
     vst_effects(TF_NORMAL).

     Auerdem werden das Clipping auf die Gr”e des gesamten
     Desktops, vst_font() auf den ersten verfgbaren Font (das
     ist normalerweise der Systemzeichensatz) und dieser Font auf
     die "normale" H”he (d.h. die des "groen" Fonts auf dem
     Desktop) gesetzt.


4.35.20  TWindow.At
-------------------

Deklaration

     function At(Index: integer): PWindow;

Beschreibung

     Liefert einen Zeiger auf das Child-Fenster mit der
     fortlaufenden Nummer Index in der ChildList (begonnen wird
     bei Null).

     Wenn Index negativ oder ChildList leer ist, wird nil
     zurckgegeben. Bei zu groen Werten wird die Liste zyklisch
     durchlaufen.


4.35.21  TWindow.IndexOf
------------------------

Deklaration

     function IndexOf(Item: PWindow): integer;

Beschreibung

     Liefert die fortlaufende Nummer des Fensterobjekts, auf das
     Item zeigt, wenn dieses in der ChildList vorkommt. Ansonsten
     wird -1 zurckgegeben.


4.35.22  TWindow.Calc
---------------------

Deklaration

     procedure Calc(ctype: integer; ri: GRECT;
                               var ro: GRECT); virtual;

Beschreibung

     Berechnet aus den Auenabmessungen des Fensters die Gr”e
     des Arbeitsbereichs und umgekehrt. Die Parameter entsprechen
     denen von wind_calc(), allerdings sollte immer nur Calc
     verwendet werden, um zu sp„teren Erweiterungen (Toolbars,
     Menleisten) kompatibel zu bleiben!


4.35.23  TWindow.CanClose
-------------------------

Deklaration

     function CanClose: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Fenster geschlossen werden darf.
     Das ist standardm„ig dann der Fall, wenn alle offenen
     untergeordneten Fenster bei dieser Methode ebenfalls true
     liefern.

     Durch šberschreiben kann man mit dieser Methode leicht
     Sicherheitsabfragen etc. in eigene Programme einbauen.


4.35.24  TWindow.ChkAlign
-------------------------

Deklaration

     procedure ChkAlign(var r: GRECT); virtual;

Beschreibung

     Korrigiert die Position des Fensters, wenn eine der Konstan-
     ten cs_ByteAlignClient, cs_ByteAlignWindow,
     cs_VerAlignClient oder cs_VerAlignWindow gesetzt ist.
     Auerdem wird evtl. versucht, das Fenster durch Verschieben
     komplett im sichtbaren Bereich darzustellen.

     Wird intern verwendet und braucht nicht direkt aufgerufen zu
     werden.

     Wichtig: Bei Icon-Fenstern wird grunds„tzlich kein Align
     durchgefhrt!


4.35.25  TWindow.ChkSize
------------------------

Deklaration

     procedure ChkSize(var r: GRECT); virtual;

Beschreibung

     Achtet darauf, da der Work-Bereich nicht zu gro bzw. zu
     klein wird. Zur Ermittlung der zul„ssigen Werte werden
     GetWorkMin und GetWorkMax verwendet. Wird intern verwendet
     und braucht nicht direkt aufgerufen zu werden.


4.35.26  TWindow.CloseWindow
----------------------------

Deklaration

     procedure CloseWindow; virtual;

Beschreibung

     Schliet alle untergeordneten Fenster. Danach wird auch
     dieses Fenster - sofern es offen ist - geschlossen und
     Attr.Status auf ws_Created gesetzt, d.h. die GEM-Kennung
     wird nicht freigegeben (dies macht TWindow.Destroy).


4.35.27  TWindow.Create
-----------------------

Deklaration

     procedure Create; virtual;

Beschreibung

     Wenn Attr.Status gleich ws_NoWindow ist, wird das Fenster
     erzeugt (d.h. eine GEM-Kennung erfragt), ansonsten werden
     nur evtl. vorhandene untergeordnete Fenster erzeugt.

     Zun„chst wird versucht, mittels wind_create() eine GEM-
     Kennung zu belegen. Milingt dies, gibt ChkError
     em_InvalidWindow zurck. Ansonsten wird Attr.Status auf
     ws_Created gesetzt, und abh„ngig vom Wert in
     TWindow.Attr.Style werden Fenstertitel und Infozeile festge-
     legt. Danach werden die untergeordneten Fenster erzeugt.

     Bei modalen Dialogen hat Create keine Wirkung.


4.35.28  TWindow.CreateChildren
-------------------------------

Deklaration

     procedure CreateChildren; virtual;

Beschreibung

     Ruft fr alle Fenster der ChildList, bei denen das Flag
     cs_AutoCreate gesetzt ist, Create auf.


4.35.29  TWindow.DDGetPath
--------------------------

Deklaration

     function DDGetPath: string; virtual;

Beschreibung

     Wird von TWindow.WMDragDrop aufgerufen, wenn der Sender den
     Datentyp 'PATH' gew„hlt hat, d.h. wenn er den evtl. zum
     Fenster geh”rigen Pfad (z.B. bei Editor-Fenstern) wissen
     m”chte.

     Im Moment wird hier ein Leerstring zurckgegeben, d.h. die
     Anfrage wird abgewiesen. Durch šberschreiben dieser Methode
     kann aber ein beliebiger Pfad zurckgegeben werden.


4.35.30  TWindow.DDGetPreferredTypes
------------------------------------

Deklaration

     function DDGetPreferredTypes: string; virtual;

Beschreibung

     Liefert die Extensions der "bevorzugten" Dateien zurck. Es
     drfen maximal 8 Extensions geliefert werden, bei weniger
     Zeichen wird mit Nullbytes aufgefllt.

     Standardm„ig wird TApplication.DDGetPreferredTypes
     zurckgegeben. Eine speziellere Rckgabe k”nnte z.B.
     '.IMG.PCX.GIF.TIF' lauten.


4.35.31  TWindow.DDHeaderReply
------------------------------

Deklaration

     function DDHeaderReply(dType,dName,fName: string;
                         dSize: longint; OrgID,
                         mX,mY,KStat: integer): byte;
                                                virtual;

Beschreibung

     Wird von TWindow.WMDragDrop aufgerufen, um dem Sender auf
     den vorgeschlagenen Dateityp zu antworten.

     In dType erh„lt man die Extension des vorgeschlagenen
     Dateityps (z.B. '.TXT'), in fName den entsprechenden
     Dateinamen (ohne Pfadangabe). In dName kann noch optional
     ein Name fr die Daten bergeben werden, der vom Empf„nger
     z.B. zum Beschriften eines Icons benutzt werden kann. dSize
     gibt die L„nge der zu bertragenden Datei an. OrgID
     bezeichnet die AES-Kennung des Senders, mX und mY die
     Position der Maus und KStat den Zustand der Umschalttasten
     beim Aufruf.

     Standardm„ig wird DD_NAK zurckgegeben, folgende Werte sind
     z.Z. definiert:


       +--------------+--------------------------------------+
       | DD_OK        | alles OK; die Daten werden dann mit  |
       |              | TWindow.DDReadData eingelesen        |
       +--------------+--------------------------------------+
       | DD_NAK       | Fehler, Abbruch der Kommunikation    |
       +--------------+--------------------------------------+
       | DD_EXT       | der Sender soll einen anderen        |
       |              | Dateityp vorschlagen                 |
       +--------------+--------------------------------------+
       | DD_LEN       | der Empf„nger kann nicht so viele    |
       |              | Daten gleichzeitig verarbeiten       |
       +--------------+--------------------------------------+
       | DD_TRASH     | Datei wurde auf den Mlleimer ge-    |
       |              | zogen; der Sender mu entsprechend   |
       |              | reagieren                            |
       +--------------+--------------------------------------+
       | DD_PRINTER   | Datei wurde auf das Drucker-Icon     |
       |              | gezogen; der Sender mu entsprechend |
       |              | reagieren                            |
       +--------------+--------------------------------------+
       | DD_CLIPBOARD | Datei wurde auf das Klemmbrett-Icon  |
       |              | gezogen; der Sender mu entsprechend |
       |              | reagieren                            |
       +--------------+--------------------------------------+


4.35.32  TWindow.DDReadData
---------------------------

Deklaration

     function DDReadData(dType,dName,fName: string;
                          dSize: longint; PipeHnd,
                          OrgID,mX,mY,
                          KStat: integer): boolean;
                                              virtual;

Beschreibung

     Wird von TWindow.WMDragDrop aufgerufen, wenn eine
     Drag&Drop-Anfrage positiv beantwortet werden konnte und nun
     die Daten eingelesen werden sollen.

     In dType erh„lt man die Extension des vorgeschlagenen
     Dateityps (z.B. '.TXT'), in fName den entsprechenden
     Dateinamen (ohne Pfadangabe). In dName kann noch optional
     ein Name fr die Daten bergeben werden, der vom Empf„nger
     z.B. zum Beschriften eines Icons benutzt werden kann. dSize
     gibt die L„nge der zu bertragenden Datei an. OrgID
     bezeichnet die AES-Kennung des Senders, mX und mY die
     Position der Maus und KStat den Zustand der Umschalttasten
     beim Aufruf. PipeHnd enth„lt das Dateihandle der ge”ffneten
     Pipe, auf die nun mit Fread() zugegriffen werden kann.

     Wenn die Daten eingelesen werden konnten, sollte true
     zurckgegeben werden, damit die Methode DDFinished
     aufgerufen wird.


4.35.33  TWindow.DDReadArgs
---------------------------

Deklaration

     function DDReadArgs(dSize: longint; PipeHnd,OrgID,
                         mX,mY,KStat: integer): boolean;
                                                virtual;

Beschreibung

     Wird von TWindow.WMDragDrop aufgerufen, wenn der Sender den
     'ARGS'-Datentyp, also eine Kommandozeile verschickt hat. In
     dieser Methode kann diese nun (per Fread()) eingelesen
     werden. Abschlieend mu noch die geerbte Methode mit dem um
     die Anzahl gelesener Zeichen verminderten dSize aufgerufen
     werden, damit die Pipe vollst„ndig geleert wird. Wenn in der
     Kommandozeile mehrere Parameter bergeben werden, sind die
     einzelnen Parameter durch ein Leerzeichen getrennt. Wenn in
     einem Parameter ein Leerzeichen vorkommt, wird dieser
     Parameter in einfache Anfhrungszeichen gesetzt.
     Anfhrungszeichen innerhalb des Parameters werden dann
     verdoppelt (z.B. "'Eric''s file'").

     Wenn die Daten eingelesen werden konnten, sollte true
     zurckgegeben werden, damit die Methode DDFinished
     aufgerufen wird.


4.35.34  TWindow.DDFinished
---------------------------

Deklaration

     procedure DDFinished(OrgID,mX,mY,KStat: integer);
                                                virtual;

Beschreibung

     Wird von TApplication.APDragDrop aufgerufen, wenn
     TWindow.DDReadData oder TWindow.DDReadArgs true
     zurckgegeben hat. Der Aufruf erfolgt nach dem Drag&Drop-
     Protokoll, man hat also wieder volle Kontrolle ber den
     Bildschirm.

     In dieser Methode sollten die Eingelesenen Daten ausgewertet
     werden (Anzeige etc.).


4.35.35  TWindow.EnableAutoCreate
---------------------------------

Deklaration

     procedure EnableAutoCreate;

Beschreibung

     Setzt fr das Fenster das Flag cs_AutoCreate. Wird von
     TWindow.Init aufgerufen.


4.35.36  TWindow.DisableAutoCreate
----------------------------------

Deklaration

     procedure DisableAutoCreate;

Beschreibung

     L”scht das Flag cs_AutoCreate aus Class.Style. Wird von
     TDialog.Init aufgerufen.


4.35.37  TWindow.Destroy
------------------------

Deklaration

     procedure Destroy; virtual;

Beschreibung

     Ruft zun„chst die Destroy-Methode aller untergeordneten
     Fenster auf. Danach wird das Fenster geschlossen (sofern
     dies noch nicht geschehen ist) und die GEM-Kennung
     freigegeben. Schlielich wird Attr.Status auf ws_NoWindow
     und gemHandle auf -1 gesetzt.

     Wenn beim Freigeben ein Fehler auftritt, gibt ChkError
     em_WDestroyFailure zurck.


4.35.38  TWindow.FirstWndThat
-----------------------------

Deklaration

     function FirstWndThat
                  (Test: PIterationFunc): PWindow;

Beschreibung

     FirstWndThat ruft fr jedes untergeordnete Fenster die durch
     Test bestimmte boolesche Funktion auf, bis Test true
     zurckgibt. FirstWndThat gibt dann den Zeiger auf das
     Fensterobjekt zurck, fr den Test true zurckgegeben hat,
     oder nil, falls Test immer false geliefert hat. Der Pointer
     Test sollte eine globale (Unterschied zu ObjectWindows!)
     Funktion sein, der ein pointer-Parameter bergeben wird und
     die boolean zurckgibt.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Test-Funktion nicht auf die Variablen der
     bergeordneten Routine zugegriffen werden!

Beispiel

     function IstOffen(p: pointer): boolean;
       { ... }

     IstOffen sollte eine globale Funktion sein. Sei Fenster ein
     TWindow-Objekt:

     p:=Fenster.FirstWndThat(@IstOffen);


4.35.39  TWindow.ForEachWnd
---------------------------

Deklaration

     procedure ForEachWnd(Action: PIterationProc);

Beschreibung

     ForEachWnd ruft fr jedes untergeordnete Fenster die durch
     Action bestimmte Prozedur auf. Der Pointer Action sollte
     eine globale (Unterschied zu ObjectWindows!) Prozedur sein,
     der ein pointer-Parameter bergeben wird.

     Achtung: Im Gegensatz zu ObjectWindows kann bei einer
     lokalen Prozedur nicht auf die Variablen der bergeordneten
     Routine zugegriffen werden!

Beispiel

     procedure MacheGross(p: pointer);
       { ... }

     MacheGross sollte eine globale Prozedur sein. Sei Fenster
     ein TWindow-Objekt:

     Fenster.ForEachWnd(@MacheGross);


4.35.40  TWindow.ForceRedraw
----------------------------

Deklaration

     procedure ForceRedraw; virtual;

Beschreibung

     Zeichnet das komplette Fenster neu. Dazu schickt das
     Fensterobjekt eine WM_REDRAW-Message an sich selbst. Soll
     das Zeichnen nicht ber die GEM-Message-Queue abgewickelt
     werden (d.h. wenn sofort gezeichnet werden mu, der
     Zeitpunkt also nicht vom GEM bestimmt werden soll), mu
     TWindow.WMRedraw direkt aufgerufen werden.


4.35.41  TWindow.FirstWorkRect
------------------------------

Deklaration

     function FirstWorkRect(var Rect: GRECT): boolean;
                                                virtual;

Beschreibung

     Diese Funktion liefert das erste Rechteck der Rechteckliste.
     Im Gegensatz zu wind_get(WF_FIRSTXYWH...) werden dabei auch
     evtl. vorhandene Toolbars, Menleisten etc. bercksichtigt.
     Auerdem erh„lt man nur wirklich sichtbare Teile des
     Arbeitsbereichs (das Rechteck mu also nicht mehr mit dem
     Desktopbereich geschnitten werden).

     Wenn der Arbeitsbereich des Fensters komplett verdeckt ist,
     ist die Rckgabe false, und Rect.W wird auf Null gesetzt.


4.35.42  TWindow.NextWorkRect
-----------------------------

Deklaration

              function NextWorkRect(var Rect: GRECT): boolean;
                                                        virtual;

Beschreibung

     Diese Funktion liefert das jeweils n„chste Rechteck der
     Rechteckliste des Fensters. Im Gegensatz zu
     wind_get(WF_NEXTXYWH...) werden dabei auch evtl. vorhandene
     Toolbars, Menleisten etc. bercksichtigt. Auerdem erh„lt
     man nur wirklich sichtbare Teile des Arbeitsbereichs (das
     Rechteck mu also nicht mehr mit dem Desktopbereich
     geschnitten werden).

     Wenn kein weiteres Rechteck existiert, ist die Rckgabe
     false, und Rect.W wird auf Null gesetzt.


4.35.43  TWindow.FreeDialog
---------------------------

Deklaration

     procedure FreeDialog; virtual;

Beschreibung

     Entfernt einen evtl. zuvor mit LoadDialog dem Fenster
     zugewiesenen Dialogbaum, d.h. dieser wird nun nicht mehr
     gezeichnet.

     Wird von TWindow.Done aufgerufen.


4.35.44  TWindow.FullSize
-------------------------

Deklaration

     procedure FullSize; virtual;

Beschreibung

     Bringt das Fenster auf volle Gr”e, oder - wenn es diese
     bereits hat - auf die ursprngliche Gr”e. Wenn
     cs_FullRedraw gesetzt ist, wird anschlieend noch
     TWindow.ForceRedraw aufgerufen.


4.35.45  TWindow.GetClassName
-----------------------------

Deklaration

     function GetClassName: string; virtual;

Beschreibung

     Gibt den Namen der Fensterklasse zurck. Abgeleitete
     Fensterobjekte, die wesentliche Ver„nderungen bzw.
     Erweiterungen gegenber TWindow besitzen, sollten diese
     Methode berschreiben, um einen anderen Namen zu liefern.
     TWindow gibt 'Window' zurck.


4.35.46  TWindow.GetClipboard
-----------------------------

Deklaration

     function GetClipboard: PClipboard; virtual;

Beschreibung

     Liefert das TClipboard-Objekt, das mit dem Fenster-Objekt
     verknpft wird.

     Standardm„ig wird Application^.Clipboard zurckgegeben.
     Will man ein spezialisiertes Klemmbrett-Objekt installieren,
     mu man diese Methode berschreiben. Wichtig: Ein solches
     Objekt wird dann von TWindow.Done freigegeben!


4.35.47  TWindow.GetCurr
------------------------

Deklaration

     procedure GetCurr; virtual;

Beschreibung

     Fllt das Feld Curr mit den aktuellen Auenmaen des
     Fensters aus. Wird intern verwendet und braucht nicht direkt
     aufgerufen zu werden, wenn zur Gr”en„nderung des Fensters
     nur die ObjectGEM-Methoden verwendet werden.


4.35.48  TWindow.GetDC
----------------------

Deklaration

     function GetDC: integer; virtual;

Beschreibung

     Dies ist eine an Windows angelehnte "Quick-and-dirty"-
     Funktion, mit der sehr einfach in dem Fenster gezeichnet
     werden kann. Die Funktion reserviert das erste Rechteck der
     Rechteckliste des Fensters fr die Ausgabe, was unter
     gnstigen Umst„nden (die man auch schaffen kann, z.B. mit
     Top) der gesamte Arbeitsbereich ist. Im schlimmsten Fall
     sieht man allerdings gar nichts... Es findet eine
     Schachtelung mit wind_update() statt, die Maus wird
     unsichtbar gemacht und das Clipping gesetzt. Die Rckgabe
     entspricht TWindow.vdiHandle. Nun kann direkt (mit den VDI-
     Funktionen) gezeichnet werden, und am Schlu mu
     TWindow.ReleaseDC aufgerufen werden, um alle Blockierungen
     aufzuheben. Wichtig: Wird -1 zurckgegeben, ist die Funktion
     fehlgeschlagen; es darf weder gezeichnet noch ReleaseDC
     aufgerufen werden!


4.35.49  TWindow.GetFull
------------------------

Deklaration

     procedure GetFull; virtual;

Beschreibung

     Fllt das Feld Full mit der maximal m”glichen Gr”e des
     Fensters aus, wobei GetWorkMax beachtet wird. Wird intern
     verwendet und braucht nicht direkt aufgerufen zu werden.


4.35.50  TWindow.GetScroller
----------------------------

Deklaration

     function GetScroller: PScroller; virtual;

Beschreibung

     Wird von TWindow.Init aufgerufen, um das Scroller-Feld zu
     setzen. Wenn einem Fenster ein TScroller-Objekt zugewiesen
     werden soll, mu diese Methode berschrieben werden, damit
     das Objekt korrekt initialisiert werden kann.

     Standardm„ig wird nil zurckgegeben.


4.35.51  TWindow.GetStyle
-------------------------

Deklaration

     function GetStyle: integer; virtual;

Beschreibung

     Gibt eine Bitmap der GEM-Fensterkomponenten zurck, die fr
     TWindow.Create ben”tigt wird. TWindow.GetStyle liefert NAME
     or INFO or CLOSER or MOVER or FULLER or SIZER. Sollen andere
     Fensterelemente benutzt werden, mu man diese Methode
     berschreiben.

     Ab AES 4.10 wird zus„tzlich SMALLER fr die Iconification
     geliefert und, wenn der Backdrop-Mechanismus untersttzt
     wird, BACKDROP (z.Z. nur unter Mag!C).

     Soll dem Fenster ein TScroller-Objekt zugeordnet werden,
     stehen als Rckgabewerte auch die Konstanten HSLIDER,
     VSLIDER und SLIDER zur Verfgung, die wie folgt definiert
     sind:

     type HSLIDER = LFARROW or RTARROW or HSLIDE;
          VSLIDER = UPARROW or DNARROW or VSLIDE;
          SLIDER  = HSLIDER or VSLIDER;


4.35.52  TWindow.GetIconWindowClass
-----------------------------------

Deklaration

     procedure GetIconWindowClass
                 (var AWndClass: TIconWndClass); virtual;

Beschreibung

     Fllt das Feld IconClass aus, das die Icon-Fensterklasse
     beschreibt. Soll das Icon-Fenster andere Eigenschaften
     besitzen, mu diese Methode berschrieben werden. In diesem
     Fall sollte in der neuen Methode zuerst die ursprngliche
     Methode aufgerufen werdem.

Beispiel

     procedure TW.GetIconWindowClass(var AWndClass: TIconWndClass);

       begin
         inherited GetIconWindowClass(AWndClass);
         { ... }
       end;


4.35.53  TWindow.GetWindowClass
-------------------------------

Deklaration

     procedure GetWindowClass(var AWndClass: TWndClass);
                                                 virtual;

Beschreibung

     Fllt das Feld Class aus, das die Fensterklasse beschreibt.
     Soll das Fenster andere grundlegende Eigenschaften besitzen,
     mu diese Methode berschrieben werden.

     Wichtig: In diesem Fall mu in der neuen Methode zuerst die
     ursprngliche Methode aufgerufen werden, da es sonst mit
     einiger Sicherheit einen Programmabsturz gibt...

Beispiel

     procedure TW.GetWindowClass(var AWndClass: TWndClass);

       begin
         inherited GetWindowClass(AWndClass);
         { ... }
       end;


4.35.54  TWindow.GetWork
------------------------

Deklaration

     procedure GetWork; virtual;

Beschreibung

     Fllt das Feld TWindow.Work mit den aktuellen Auenmaen des
     Fensters aus. Wird intern verwendet und braucht nicht direkt
     aufgerufen zu werden, wenn zur Gr”en„nderung des Fensters
     nur die ObjectGEM-Methoden verwendet werden.


4.35.55  TWindow.GetWorkMax
---------------------------

Deklaration

     procedure GetWorkMax(var maxX,maxY: integer);
                                             virtual;

Beschreibung

     Gibt an, wie gro das Fenster maximal werden darf. Beide
     Werte werden mit maxint besetzt, d.h. die Gr”e wird nur
     durch den Arbeitsbereich des Desktops beschr„nkt.

     Wird von TDialog.GetWorkMax sinnvoll eingesetzt.


4.35.56  TWindow.GetWorkMin
---------------------------

Deklaration

     procedure GetWorkMin(var minX,minY: integer);
                                             virtual;

Beschreibung

     Gibt an, wie klein der Arbeitsbereich des Fensters minimal
     werden darf. Wird z.Z. mit 21 (minX) und 1 (minY) besetzt
     (experimentell ermittelt), da sich bei „lteren GEM-Versionen
     sonst die Fensterelemente berschneiden k”nnen.


4.35.57  TWindow.GetTitle
-------------------------

Deklaration

     function GetTitle: string;

Beschreibung

     GetTitle liefert die Zeichenkette aus Attr.Title, wobei
     allerdings Leerzeichen und ASCII #0 abgeschnitten werden.


4.35.58  TWindow.GetIconTitle
-----------------------------

Deklaration

     function GetIconTitle: string; virtual;

Beschreibung

     Wird von TWindow.WMIconify aufgerufen, wenn das Fenster
     ikonifiziert werden soll. Die Rckgabe dient als
     Fenstertitel des Icon-Fensters; standardm„ig wird
     TWindow.GetTitle geliefert.

     Von der Rckgabe werden z.Z. allerdings nur die ersten 10
     (bzw. mit ICFS nur 8) Zeichen beachtet!


4.35.59  TWindow.IconPaint
--------------------------

Deklaration

     procedure IconPaint(var PaintInfo: TPaintStruct);
                                                virtual;

Beschreibung

     Wird von TWindow.WMRedraw aufgerufen, wenn das Icon-Fenster
     neu gezeichnet werden soll. Standardm„ig wird der
     Arbeitsbereich einfach nur wei gefllt. Die Verfahrensweise
     ist analog zu TWindow.Paint.


4.35.60  TWindow.InitPaint
--------------------------

Deklaration

     procedure InitPaint; virtual;

Beschreibung

     Wird von TWindow.WMRedraw aufgerufen, bevor mit der
     TWindow.Paint-Methode gezeichnet wird. Hier k”nnen also fr
     das Redraw n”tige Initialisierungen vorgenommen werden.


4.35.61  TWindow.ExitPaint
--------------------------

Deklaration

     procedure ExitPaint; virtual;

Beschreibung

     Wird von TWindow.WMRedraw aufgerufen, nachdem alle Rechtecke
     der Rechteckliste mit TWindow.Paint gezeichnet wurden. Hier
     k”nnen evtl. in TWindow.InitPaint vorgenommene
     Initialisierungen rckg„ngig gemacht werden.


4.35.62  TWindow.IsIconified
----------------------------

Deklaration

     function IsIconified: boolean;

Beschreibung

     Gibt true zurck, wenn das Fenster ikonifiziert ist, d.h.
     wenn das Fenster zum "Icon" verkleinert wurde (erst ab AES
     4.10 bzw. mit einem ICFS-Server m”glich).


4.35.63  TWindow.WMIconify
--------------------------

Deklaration

     procedure WMIconify(iX,iY,iW,iH: integer); virtual;

Beschreibung

     Wird von TApplication.MUMesag aufgerufen, wenn das Fenster
     ikonifiziert werden soll.

     In iX,iY,iW,iH steht die Gr”e des Icon-Fensters, mit
     TWindow.GetIconTitle wird der neue Fenstertitel ermittelt.


4.35.64  TWindow.WMUniconify
----------------------------

Deklaration

     procedure WMUniconify(oX,oY,oW,oH: integer);
                                             virtual;

Beschreibung

     Bringt ein ikonifiziertes Fenster auf seine ursprngliche
     Gr”e, die in oX,oY,oW,oH bergeben wird. Auerdem wird
     wieder der alte Fenstertitel gesetzt.

     Wird von TApplication.MUMesag aufgerufen.


4.35.65  TWindow.IsDialog
-------------------------

Deklaration

     function IsDialog: boolean; virtual;

Beschreibung

     Gibt false zurck, d.h. das Fenster ist kein Dialogfenster.
     TDialog berschreibt diese Methode.

     Wird intern ben”tigt, da TWindow- und TDialog-Objekte in den
     gleichen Listen (MainWindow bzw. ChildList) verwaltet
     werden.


4.35.66  TWindow.IsModeless
---------------------------

Deklaration

     function IsModeless: boolean;

Beschreibung

     Gibt true zurck, wenn das Fenster eine GEM-Kennung besitzt,
     wenn es also bereits mit TWindow.Create erzeugt wurde.

     Zur Unterscheidung von modalen und nicht-modalen Dialogen
     sollte allerdings TDialog.IsModal verwendet werden.


4.35.67  TWindow.IsTop
----------------------

Deklaration

     function IsTop: boolean; virtual;

Beschreibung

     Gibt true zurck, wenn das Fenster das oberste ist und wenn
     ansonsten auch keine modaler Dialog aktiv ist.


4.35.68  TWindow.LoadDialog
---------------------------

Deklaration

     procedure LoadDialog(Indx: integer); virtual;

Beschreibung

     Setzt DlgTree mittels SetDlgTree auf den zum Index Indx
     geh”rigen Objektbaum, wenn dieser existiert und dem Fenster
     bisher noch kein Dialog zugewiesen wurde.

     Andernfalls gibt ChkError em_InvalidDialog zurck.


4.35.69  TWindow.LoadIcon
-------------------------

Deklaration

     procedure LoadIcon(Icn: PIcon); virtual;

Beschreibung

     Setzt TWindow.Icon auf Icn. Das Fenster zeichnet dann ab
     sofort das bergebene Icon im ikonifizierten Fenster.


4.35.70  TWindow.FreeIcon
-------------------------

Deklaration

     procedure FreeIcon; virtual;

Beschreibung

     Gibt das Feld TWindow.Icon frei, d.h. das Fenster zeichnet
     in ikonifiziertem Zustand kein Icon mehr.


4.35.71  TWindow.LoadToolbar
----------------------------

Deklaration

     procedure LoadToolbar(Indx: integer;
                            Opposite: boolean); virtual;

Beschreibung

     Setzt Class.ToolbarTree auf den zum Index Indx geh”rigen
     Objektbaum. Je nachdem, ob die Breite oder H”he des
     Toolbar-ROOT-Objekts gr”er ist, wird die Toolbar horizontal
     oder vertikal gezeichnet. Normalerweise befindet sich die
     Toolbar am linken oder oberen Rand des Fensters. Wird
     allerdings in Opposite true bergeben, wird die Toolbar
     rechts bzw. unten gezeichnet. Dann werden auerdem die Flags
     cs_ToolbarOpposite und cs_FullRedraw gesetzt.

     Anschlieend wird noch der Arbeitsbereich neu gezeichnet.

     Wenn Indx keinen gltigen Objektbaum bezeichnet oder das
     Fenster schon eine Toolbar besitzt, gibt ChkError
     em_InvalidToolbar zurck.


4.35.72  TWindow.FreeToolbar
----------------------------

Deklaration

     procedure FreeToolbar; virtual;

Beschreibung

     Entfernt eine mit TWindow.LoadToolbar dem Fenster
     zugewiesene Toolbar. Der Arbeitsbereich wird anschlieend
     neu gezeichnet, und cs_ToolbarOpposite wird gel”scht.

     Wird von TWindow.Done aufgerufen.


4.35.73  TWindow.MakeWindow
---------------------------

Deklaration

     procedure MakeWindow; virtual;

Beschreibung

     Ruft erst TWindow.Create und dann TWindow.OpenWindow auf,
     d.h. das Fenster wird erzeugt und ge”ffnet. Diese Methode
     kann immer dann aufgerufen werden, wenn das Fenster ge”ffnet
     und an oberste Position gebracht werden soll, da automatisch
     darauf geachtet wird, ob es bereits erzeugt wurde.


4.35.74  TWindow.Move
---------------------

Deklaration

     procedure Move(r: GRECT); virtual;

Beschreibung

     Bewegt das Fenster an die neue Position, die in den Feldern
     X,Y,W,H der GRECT-Struktur angegeben ist.


4.35.75  TWindow.Next
---------------------

Deklaration

     function Next: PWindow;

Beschreibung

     Gibt einen Pointer auf das n„chste Fenster in der Liste des
     bergeordneten Fensters zurck bzw. nil, wenn das Fenster
     das letzte in der Liste ist.


4.35.76  TWindow.OpenWindow
---------------------------

Deklaration

     procedure OpenWindow; virtual;

Beschreibung

     Wenn Attr.Status ws_Created enth„lt, wird das Fenster mit
     wind_open() ge”ffnet und ein evtl. vorhandenes TScroller-
     Objekt angepat. Wenn ws_ex_Disabled gesetzt und MultiTOS
     installiert ist, wird das Fenster anschlieend in den
     Hintergrund gebracht. Danach werden alle vorhandenen
     untergeordneten Fenster ge”ffnet.

     Tritt w„hrend des ™ffnens ein Fehler auf, gibt ChkError
     em_WOpenFailure zurck.

     Enth„lt Attr.Status allerdings bereits den Wert ws_Open,
     wird das Fenster nur an oberste Position gebracht (sofern
     ws_ex_Disabled nicht gesetzt ist), und die untergeordneten
     Fenster werden ge”ffnet.


4.35.77  TWindow.Paint
----------------------

Deklaration

     procedure Paint(var PaintInfo: TPaintStruct);
                                             virtual;

Beschreibung

     In dieser Methode sollten normalerweise alle Zeichenroutinen
     des Fensters zusammengefat sein, weshalb sie in eigentlich
     jedem ObjectGEM-Programm berschrieben wird. Man sollte nach
     M”glichkeit wirklich keine Zeichnungen im Fenster auerhalb
     dieser Methode vornehmen...

     Standardm„ig macht Paint nichts, es sei denn, dem Fenster
     wurde mit TWindow.LoadDialog ein Dialogbaum zugewiesen. Dann
     wird der entsprechende Dialog gezeichnet.

     Die Methode sollte nie direkt aufgerufen werden, sondern
     immer nur mittels ForceRedraw, WMRedraw oder
     TApplication.InvalidateRect. Wer meint, dies dennoch tun zu
     mssen, mu darauf achten, vor dem Aufruf von Paint die
     Methoden TWindow.UpdateDialog und InitPaint sowie nach dem
     Aufruf ExitPaint aufzurufen.


4.35.78  TWindow.Previous
-------------------------

Deklaration

     function Previous: PWindow;

Beschreibung

     Gibt einen Pointer auf das vorhergehende Fenster in der
     Liste des bergeordneten Fensters zurck bzw. nil, wenn das
     Fenster das erste in der Liste ist.


4.35.79  TWindow.RawDestroy
---------------------------

Deklaration

     procedure RawDestroy; virtual;

Beschreibung

     Ruft zun„chst fr alle untergeordneten Fenster RawDestroy
     auf. Dann wird Attr.Status auf ws_NoWindow und
     Attr.gemHandle auf -1 gesetzt, ohne irgendwelche GEM-
     Funktionen zum Schlieen bzw. Freigeben des Fensters zu
     verwenden.

     Wird z.B. ben”tigt, wenn ein Accessory geschlossen wird; in
     diesem Fall werden n„mlich alle Fenster automatisch vom
     Betriebssystem freigegeben. RawDestroy braucht normalerweise
     nicht direkt aufgerufen zu werden, stattdessen sollte (bzw.
     mu) man TWindow.Destroy verwenden.


4.35.80  TWindow.ReleaseDC
--------------------------

Deklaration

     procedure ReleaseDC; virtual;

Beschreibung

     Gibt einen zuvor mit TWindow.GetDC angeforderten "device
     context" frei, d.h. das Zeichnen ist beendet und die
     Bildschirm-Blockierung wird aufgehoben. Darf nur aufgerufen
     werden, wenn GetDC erfolgreich war!


4.35.81  TWindow.SetCurr
------------------------

Deklaration

     procedure SetCurr(r: GRECT); virtual;

Beschreibung

     Setzt die neuen Auenmae des Fensters. Intern wird
     TWindow.WMSized(r.X,r.Y,r.W,r.H) aufgerufen.


4.35.82  TWindow.SetCursor
--------------------------

Deklaration

     procedure SetCursor(Crs: HCursor); virtual;

Beschreibung

     ndert das Feld Class.hCursor auf Crs. Wenn das Fenster
     gerade top ist, wird der Mauszeiger entsprechend neu
     gesetzt.

     Wichtig: Das Feld IconClass.hCursor wird nicht ver„ndert,
     dieses kann nur einmal beim Programmstart mit
     GetIconWindowClass gesetzt werden!


4.35.83  TWindow.SetDlgTree
---------------------------

Deklaration

     procedure SetDlgTree(tree: \#PTree\#); virtual;

Beschreibung

     Setzt DlgTree auf den in tree bergebenen Objektbaum. Es
     findet keine šberprfung statt, ob berhaupt ein neuer
     Dialog zugewiesen werden darf! Deshalb sollte man diese
     Methode nie direkt aufrufen, sondern stattdessen
     TWindow.LoadDialog verwenden.


4.35.84  TWindow.SetGadgets
---------------------------

Deklaration

     procedure SetGadgets(Style: integer); virtual;

Beschreibung

     Weist dem Fenster andere Fensterelemente zu (CLOSER, MOVER,
     FULLER etc.). Wenn Style ungleich TWindow.Attr.Style ist,
     wird das Fenster dazu geschlossen und freigegeben und dann
     wieder komplett neu erzeugt und ge”ffnet.


4.35.85  TWindow.SetSubTitle
----------------------------

Deklaration

     procedure SetSubTitle(AnInfo: string); virtual;

Beschreibung

     Gibt dem Fenster eine neue Infozeile und zeigt sie an, wenn
     in Attr.Style das Bit INFO gesetzt ist. Der String AnInfo
     darf max. 80 Zeichen lang sein.


4.35.86  TWindow.SetTitle
-------------------------

Deklaration

     procedure SetTitle(ATitle: string); virtual;

Beschreibung

     Gibt dem Fenster einen neuen Titel und zeigt diesen an, wenn
     in Attr.Style das Bit NAME gesetzt ist. Der String ATitle
     darf max. 78 Zeichen lang sein, da vorne und hinten
     automatisch je ein Leerzeichen angefgt wird.


4.35.87  TWindow.SetupSize
--------------------------

Deklaration

     procedure SetupSize; virtual;

Beschreibung

     In dieser Methode wird die Anfangsgr”e des Fensters festge-
     legt. Full und Curr werden auf die Gr”e des Desktops
     gesetzt und daraus TWindow.Work berechnet. Wird von
     TWindow.SetupWindow aufgerufen.


4.35.88  TWindow.SetupWindow
----------------------------

Deklaration

     procedure SetupWindow; virtual;

Beschreibung

     In dieser Methode sollten alle Einstellungen, die das
     Fenster (d.h. nicht nur das Fensterobjekt an sich)
     betreffen, vorgenommen werden.

     Standardm„ig wird zun„chst TWindow.SetupSize aufgerufen.
     Dann werden dem Fenster drei von TKey abgeleitete Objekte
     zugewiesen, die fr das Schlieen des Fensters
     (<Control>+<U>), das ndern der Gr”e (<Control>+<*>) und
     das Wechseln des Fensters (<Control>+<W>) zust„ndig sind.
     Wurde das Programm nicht als Accessory gestartet und ist
     cs_AutoOpen gesetzt, wird zum Schlu noch TWindow.MakeWindow
     aufgerufen.

     Wird diese Methode berschrieben, sollte die ursprngliche
     Methode irgendwo am Ende der neuen Methode aufgerufen
     werden.


4.35.89  TWindow.SetWork
------------------------

Deklaration

     procedure SetWork(r: GRECT); virtual;

Beschreibung

     Bringt den Arbeitsbereich auf die neue Gr”e, die in den
     Feldern X,Y,W,H der GRECT-Struktur angegeben ist. Intern
     werden die Werte mit TWindow.Calc auf die Auenmae
     umgerechnet und dann TWindow.WMSized aufgerufen.


4.35.90  TWindow.ShutdownWindow
-------------------------------

Deklaration

     procedure ShutdownWindow; virtual;

Beschreibung

     Wird von TWindow.Done aufgerufen, nachdem alle Child-Fenster
     geschlossen wurden. In dieser Methode kann also das Fenster
     "ausgewertet" werden, bevor es geschlossen wird.

     ShutdownWindow ist damit das Gegenstck zu
     TWindow.SetupWindow.


4.35.91  TWindow.Size
---------------------

Deklaration

     procedure Size(r: GRECT); virtual;

Beschreibung

     Bringt die Auenmae des Fensters auf die neue Gr”e, die in
     den Feldern X,Y,W,H der GRECT-Struktur angegeben ist.

     Ist cs_FullRedraw gesetzt, wird anschlieend
     TWindow.ForceRedraw aufgerufen.


4.35.92  TWindow.Top
--------------------

Deklaration

     procedure Top; virtual;

Beschreibung

     Wenn das Fenster offen ist, wird es an die oberste Position
     gebracht.


4.35.93  TWindow.UpdateDialog
-----------------------------

Deklaration

     procedure UpdateDialog; virtual;

Beschreibung

     Wenn dem Fenster mit TWindow.LoadDialog ein Dialogbaum
     zugewiesen wurde, wird in dieser Methode das ROOT-Objekt auf
     die neue X- und Y- Position des Fenster-Arbeitsbereichs
     gebracht. Auerdem wird hier eine evtl. verwendete Toolbar
     positioniert.

     Die Methode wird intern verwendet und braucht nicht direkt
     aufgerufen zu werden.


4.35.94  TWindow.WMArrowed
--------------------------

Deklaration

     procedure WMArrowed(waA,SpeedA,waB,SpeedB: integer);
                                               virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer in den Sliderbereich
     klickt (Pfeile, grauer Bereich). Normalerweise enth„lt waA
     eine der WA_-Konstanten und SpeedA ist 1 (normale
     Scrollgeschwindigkeit), waB und SpeedB sind Null.

     Wird allerdings unter WINX eine Scrollbox verwendet, kann in
     waB und SpeedB eine zweite (analog aufgebaute)
     Scrollanweisung bergeben werden.

     Wenn ein Scroller vorhanden ist, wird der Fensterinhalt mit
     ScrollBy um die errechneten Werte verschoben.


4.35.95  TWindow.WMBottomed
---------------------------

Deklaration

     procedure WMBottomed; virtual;

Beschreibung

     Wird ab AES 4.10 aufgerufen, wenn der Benutzer das Fenster
     "backdropped", d.h. per Klick auf den Titel in den
     Hintergrund bringt.

     ObjectGEM reagiert darauf mit dem entsprechenden
     wind_set()-Befehl.


4.35.96  TWindow.WMClick
------------------------

Deklaration

     procedure WMClick(mX,mY,KStat: integer); virtual;

Beschreibung

     Wird von TWindow.WMButton aufgerufen, wenn der Benutzer in
     den Arbeitsbereich des Fensters klickt (Einfachklick). In mX
     und mY wird die Klickposition bergeben, KStat gibt den
     Zustand der Umschalttasten zum Zeitpunkt des Klicks an.

     Standardm„ig werden hier nur evtl. vorhandene Icons mit
     IconSelect deselektiert.


4.35.97  TWindow.WMButton
-------------------------

Deklaration

     procedure WMButton(mX,mY,BStat,KStat,
                              Clicks: integer); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn der Benutzer
     in den Arbeitsbereich des Fensters klickt. mX und mY geben
     die Klickposition an, BStat den Mausknopf (1=links,
     2=rechts), Clicks die Anzahl der Klicks und KStat den
     Zustand der Umschalttasten.

     Ist cs_DblClks gesetzt und Clicks=2, ruft WMButton
     TWindow.WMDblClick auf. Ist Clicks=1, wird zun„chst
     berprft, ob cs_Rubbox gesetzt ist. Ist dies der Fall und
     liegt die Klickposition im durch RBox angegebenen Bereich,
     wird TApplication.Rubbox aufgerufen und das Ergebnis an
     TWindow.WMRubbox weitergeleitet. Ansonsten wird
     TWindow.WMClick aufgerufen, oder - wenn mit der rechten
     Maustaste geklickt wurde - TWindow.WMRButton. Diese Methode
     wird normalerweise nicht berschrieben.

     Wichtig: Ein Doppelklick rechts wird nicht weitergeleitet.
     Stattdessen wird das Fenster getoppt!


4.35.98  TWindow.WMClosed
-------------------------

Deklaration

     procedure WMClosed; virtual;

Beschreibung

     Wenn TWindow.CanClose true zurckgibt, wird das Fenster mit
     TWindow.Destroy freigegeben. Ist dabei kein Fehler
     aufgetreten und cs_QuitOnClose gesetzt, wird das Programm
     mit TApplication.Quit beendet.

     Wenn das Schlieen eines Fensters also nicht zum Beenden der
     Applikation fhren soll, mu diese Methode berschrieben
     werden.


4.35.99  TWindow.WMDblClick
---------------------------

Deklaration

     procedure WMDblClick(mX,mY,KStat: integer); virtual;

Beschreibung

     Wird von TWindow.WMButton aufgerufen, wenn der Benutzer
     doppelt in den Arbeitsbereich des Fensters klickt. In mX und
     mY wird die Klickposition bergeben, KStat gibt den Zustand
     der Umschalttasten zum Zeitpunkt des Klicks an.

     Standardm„ig werden hier nur evtl. vorhandene Icons mit
     IconSelect deselektiert.


4.35.100  TWindow.WMDragDrop
----------------------------

Deklaration

     procedure WMDragDrop(PipeHnd,OrgID,mX,mY,
                               KStat: integer); virtual;

Beschreibung

     Wird von TApplication.APDragDrop aufgerufen, wenn der
     Benutzer unter MultiTOS ein Icon auf dieses Fenster gezogen
     hat.

     Zun„chst wird die Anfrage positiv beantwortet. Dann werden
     die von TWindow.DDGetPreferredTypes gelieferten Dateitypen
     bermittelt. Nachdem sich der Sender auf einen Dateityp
     festgelegt hat, wird darauf mit dem von
     TWindow.DDHeaderReply ermittelten Wert reagiert. Wenn sich
     Sender und Empf„nger einigen konnten, werden dann mit
     TWindow.DDReadData die Daten gelesen, ansonsten wird die
     Drag&Drop-Anfrage abgewiesen oder ein neuer Dateityp
     verlangt.

     Verschickt der Sender den 'ARGS'-Datentyp, wird automatisch
     die Methode TWindow.DDReadArgs aufgerufen. Wenn der Sender
     allerdings den Applikationspfad wissen m”chte, wird dieser
     mit TWindow.DDGetPath zurckgeliefert.

     PipeHnd ist das Dateihandle der ge”ffneten Pipe, auf die mit
     Fwrite(), Fread() etc. zugegriffen werden kann. OrgID ist
     die AES-Applikations-Kennung des Senders; mX, mY und KStat
     geben die Position der Maus und den Zustand der
     Umschalttasten beim Aufruf an.


4.35.101  TWindow.WMFulled
--------------------------

Deklaration

     procedure WMFulled; virtual;

Beschreibung

     Ruft TWindow.FullSize auf. Wenn das Fenster ein TScroller-
     Objekt besitzt, wird dieses mit SetPageSize und SetSBarRange
     angepat.


4.35.102  TWindow.WMHSlid
-------------------------

Deklaration

     procedure WMHSlid(Value: integer); virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer den horizontalen Slider
     verschoben hat. In Value befindet sich die neue
     Sliderposition in Promille.

     Wenn ein TScroller-Objekt existiert, wird dieses an die neue
     Position angepat.


4.35.103  TWindow.WMKeyDown
---------------------------

Deklaration

     function WMKeyDown(Stat,Key: integer): boolean;
                                               virtual;

Beschreibung

     Wird von TApplication.HandleKeybd aufgerufen, wenn das
     Fenster an oberster Position ist und das Applikations-Objekt
     das aufgetretene Tastaturereignis nicht verarbeiten konnte.

     In Stat steht der Zustand der Umschalttasten, in Key der
     Tastaturcode. Wenn das Fenster die Taste verarbeiten konnte,
     mu true zurckgegeben werden. Standardm„ig ist die
     Rckgabe false.


4.35.104  TWindow.WMMoved
-------------------------

Deklaration

     procedure WMMoved(X,Y,W,H: integer); virtual;

Beschreibung

     Das Fenster wird mit TWindow.Move an die bergebene Position
     gebracht. Wenn ein TScroller-Objekt existiert, wird dieses
     mit SetPageSize und SetSBarRange evtl. angepat.


4.35.105  TWindow.WMNewTop
--------------------------

Deklaration

     procedure WMNewTop; virtual;

Beschreibung

     Ruft TWindow.WMUntopped auf.


4.35.106  TWindow.WMOnTop
-------------------------

Deklaration

     procedure WMOnTop; virtual;

Beschreibung

     Wird aufgerufen, wenn das Fenster vom AES (Screen-Manager)
     an oberste Position gebracht wurde. Intern wird die
     Cursorsteuerung angepat.


4.35.107  TWindow.WMRBoxChanged
-------------------------------

Deklaration

     procedure WMRBoxChanged(r: GRECT); virtual;

Beschreibung

     Wird von TApplication.Rubbox jedesmal dann aufgerufen, wenn
     sich die Gr”e der vom Benutzer im Fenster aufgezogenenen
     Rubbox „ndert. Dies kann z.B. dazu verwendet werden, um die
     aktuelle Gr”e, die in r bergeben wird, anzuzeigen etc.

     W„hrend des Aufrufs ist die Maus unsichtbar, und es liegt
     eine wind_update()-Schachtelung sowohl mit BEG_UPDATE als
     auch mit BEG_MCTRL vor. Ver„nderte VDI-Attribute mssen
     zurckgesetzt werden.


4.35.108  TWindow.WMRBoxCheck
-----------------------------

Deklaration

     procedure WMRBoxCheck(x,y,xmin,ymin,xmax,
                    ymax: integer; var mx,my: integer);
                                                virtual;

Beschreibung

     Wird von TApplication.Rubbox jedesmal dann aufgerufen, wenn
     sich die Gr”e der vom Benutzer im Fenster aufgezogenenen
     Rubbox „ndert. Im Gegensatz zu TWindow.WMRBoxChanged erfolgt
     der Aufruf noch vor dem Zeichnen. In x und y wird der feste
     Eckpunkt der Rubbox bergeben, in mx und my der variable.
     Letzterer kann mit dieser Methode an eigene Bedrfnisse
     angepat werden, aber Achtung: Der Aufruf erfolgt erst,
     nachdem der Punkt schon an die Werte von RBox angepat
     wurde. Wenn man also nderungen vornimmt, sollte man danach
     mx und my mit Hilfe von xmin..ymax clippen.


4.35.109  TWindow.WMRButton
---------------------------

Deklaration

     procedure WMRButton(mX,mY,KStat,Clicks: integer);
                                                virtual;

Beschreibung

     Wird von TWindow.WMButton aufgerufen, wenn mit der rechten
     Maustaste geklickt wurde. In mX und mY wird die Position
     bergeben, in Clicks die Anzahl der Klicks und in KStat der
     Status der Umschalttasten.

     Wichtig: Bei einem Doppelklick rechts erfolgt kein Aufruf!


4.35.110  TWindow.WMRedraw
--------------------------

Deklaration

     procedure WMRedraw(X,Y,W,H: integer); virtual;

Beschreibung

     Zeichnet die Teile des Arbeitsbereichs neu, die sich mit dem
     bergebenen Bereich berschneiden. Dazu wird fr alle
     betroffenen Rechtecke der Fenster-Rechteckliste
     TWindow.Paint bzw. - wenn das Fenster ikonifiziert ist -
     TWindow.IconPaint aufgerufen.

     Vorher wird jeweils der zu bergebende TPaintStruct-Record
     ausgefllt und der Hintergrund mit der gewnschten Farbe
     gel”scht, wenn Class.hbrBackground einen Wert gr”er Null
     enth„lt.

     Das Clipping wird jeweils korrekt gesetzt und die Maus ist
     unsichtbar. Wichtig: WMRedraw nimmt keine Blockierung des
     Bildschirms mit wind_update() vor, dies mu man - wenn die
     Methode "von Hand" aufgerufen wird - selbst durchfhren. Bei
     allen internen Aufrufen (z.B. von TApplication.MUMesag)
     kmmert sich ObjectGEM allerdings automatisch darum.

     Nach dem Abarbeiten der Rechteckliste werden alle
     vorhandenen Icons mit TIcon.Paint dargestellt. Bevor
     gezeichnet wird, ruft WMRedraw die Methoden UpdateDialog und
     InitPaint auf, nach dem Zeichnen dann ExitPaint.


4.35.111  TWindow.WMRubbox
--------------------------

Deklaration

     procedure WMRubbox(r: GRECT); virtual;

Beschreibung

     Wird von TWindow.WMButton aufgerufen, wenn der Benutzer im
     Fenster eine Rubbox aufgezogen hat. In r wird der
     ausgew„hlte Bereich bergeben, der z.Z. nicht gr”er als der
     sichtbare Arbeitsbereich sein kann.

     Der Bereich kann allerdings noch mit den Feldern X1,Y1,X2,Y2
     von RBox eingeschr„nkt werden. Ist dort ein Wert ungleich
     Null eingetragen, wird dieser auf der entsprechenden Achse
     vom sichtbaren Arbeitsbereich abgezogen. Wenn also z.B. X2
     den Wert 16 hat, kann die Rubbox bis maximal 16 Pixel vor
     dem rechten Rand des Arbeitsbereichs aufgezogen werden.

     Wichtig: Die Ver„nderung von RBox sollte z.B. in
     TWindow.SetupWindow erfolgen. Auerdem drfen die
     gewnschten Werte nicht direkt eingetragen werden, sondern
     mssen zum vorhandenen Wert addiert werden
     ("inc(RBox.X2,16);").


4.35.112  TWindow.WMSized
-------------------------

Deklaration

     procedure WMSized(X,Y,W,H: integer); virtual;

Beschreibung

     Das Fenster wird mit TWindow.Size auf die bergebene Gr”e
     gebracht. Wenn ein TScroller-Objekt existiert, wird dieses
     mit SetPageSize und SetSBarRange angepat.


4.35.113  TWindow.WMShaded
--------------------------

Deklaration

     procedure WMShaded; virtual;

Beschreibung

     Wird unter WINX ab Version 2.3 aufgerufen, wenn das Fenster
     mit einem Mausklick rechts eingeklappt wird.

     Dient nur zur Information, hier passiert sonst nichts
     weiter.


4.35.114  TWindow.WMUnshaded
----------------------------

Deklaration

     procedure WMUnshaded; virtual;

Beschreibung

     Wird unter WINX ab Version 2.3 aufgerufen, wenn das Fenster
     wieder aufgeklappt wird.

     Dient nur zur Information, hier passiert sonst weiter
     nichts.


4.35.115  TWindow.WMToolbar
---------------------------

Deklaration

     procedure WMToolbar(Indx,BStat,KStat,
                            Clicks: integer); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn auf ein
     Element der Toolbar geklickt wurde. WMToolbar versucht, mit
     TToolbar.TestMessage ein passendes TToolbar-Objekt zu
     finden. Ist die Suche erfolgreich, wird die zugeh”rige
     TEvent.Work-Methode aufgerufen bzw. - wenn die Anwahl mit
     der rechten Maustaste erfolgte - ein evtl. vorhandener
     BubbleHelp-Hilfstext angezeigt.

     Wichtig: Bei einem Doppelklick rechts erfolgt kein Aufruf,
     stattdessen wird das Fenster getoppt!


4.35.116  TWindow.WMTopped
--------------------------

Deklaration

     procedure WMTopped; virtual;

Beschreibung

     Ruft TWindow.Top auf und bringt das Fenster damit an oberste
     Position.


4.35.117  TWindow.WMUntopped
----------------------------

Deklaration

     procedure WMUntopped; virtual;

Beschreibung

     Sollte vom GEM aufgerufen werden, wenn ein anderes Fenster
     an die oberste Position kommt. Intern wird dann die
     Mauscursor-Verwaltung angepat.


4.35.118  TWindow.WMVSlid
-------------------------

Deklaration

     procedure WMVSlid(Value: integer); virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer den vertikalen Slider
     verschoben hat. In Value befindet sich die neue
     Sliderposition in Promille.

     Wenn ein TScroller-Objekt existiert, wird dieses an die neue
     Position angepat.


4.35.119  TWindow.Print
-----------------------

Deklaration

     procedure Print; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<P> drckt.
     Standardm„ig passiert hier nichts.


4.35.120  TWindow.Cut
---------------------

Deklaration

     procedure Cut; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<X> drckt.
     Standardm„ig wird dann TApplication.Cut aufgerufen.


4.35.121  TWindow.Delete
------------------------

Deklaration

     procedure Delete; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Delete> drckt.
     Standardm„ig wird dann TApplication.Delete aufgerufen.


4.35.122  TWindow.Copy
----------------------

Deklaration

     procedure Copy; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<C> drckt.
     Standardm„ig wird dann TApplication.Copy aufgerufen.


4.35.123  TWindow.Paste
-----------------------

Deklaration

     procedure Paste; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<V> drckt.
     Standardm„ig wird dann TApplication.Paste aufgerufen.


4.35.124  TWindow.SelectAll
---------------------------

Deklaration

     procedure SelectAll; virtual;

Beschreibung

     Wird aufgerufen, wenn der Benutzer <Control>+<A> drckt. Im
     Moment werden dann alle Icons des Fensters mit
     TWindow.IconSelect(true,id_No) angew„hlt.


4.35.125  TWindow.IconSelect
----------------------------

Deklaration

     procedure IconSelect(OnOff: boolean;
                            OffExc: integer); virtual;

Beschreibung

     Wenn OnOff true ist, werden alle Icons des Fensters
     selektiert. Andernfalls werden die Icons deselektiert (auch
     die der Fenster in der ChildList) - mit Ausnahme des
     Fensters mit dem GEM-Handle OffExc.

     Sollen alle Icons deselektiert werden, mu fr OffExc id_No
     bergeben werden.


4.35.126  TWindow.FirstIcon
---------------------------

Deklaration

     function FirstIcon(OnAll: boolean): PIcon; virtual;

Beschreibung

     Ist OnAll true, wird ein Pointer auf das erste selektierte
     Icon geliefert. Ansonsten wird das erste von allen Icons
     zurckgegeben.

     Existiert kein entsprechendes Icon, erh„lt man nil.


4.35.127  TWindow.LoadMenu
--------------------------

Deklaration

     procedure LoadMenu(Indx: integer); virtual;

Beschreibung

     Installiert die Pulldown-Menleiste im Objektbaum Indx.
     Zun„chst wird geprft, ob das Men auf dem Bildschirm
     komplett dargestellt werden kann. Ist dies der Fall, wird
     das Men gezeichnet, ansonsten gibt ChkError em_InvalidMenu
     zurck. Diese Methode sollte - falls ein Pulldown-Men
     verwendet wird - in TWindow.SetupWindow aufgerufen werden.

     Wenn das Men korrekt installiert werden konnte, wird danach
     das "DESK"-Men an Stelle der nicht benutzbaren Acessory-
     Eintr„ge mit diversen Funktionen versehen.


4.35.128  TWindow.FreeMenu
--------------------------

Deklaration

     procedure FreeMenu; virtual;

Beschreibung

     Entfernt ein mit TWindow.LoadMenu installiertes Pulldown-
     Men. Wird von TWindow.Done automatisch aufgerufen.


4.35.129  TWindow.HandleMenu
----------------------------

Deklaration

     procedure HandleMenu(meNum: integer); virtual;

Beschreibung

     Wird von TWindow.MNSelected aufgerufen, wenn fr den
     Meneintrag mit dem Index meNum kein zugeh”riges TEvent-
     Objekt vorhanden ist. Innerhalb dieser Methode kann dann
     eine case-Abfrage durchgefhrt werden. Nach M”glichkeit
     sollten allerdings TEvent-Objekte zum Einsatz kommen.

     HandleMenu leitet die Anwahl des "šber..."-Meneintrags an
     TApplication.MNSelected weiter, ansonsten passiert hier
     nichts.


4.35.130  TWindow.MNSelected
----------------------------

Deklaration

     procedure MNSelected(meNum,mtNum: integer;
                 Tree: PTree; PrIndx: integer); virtual;

Beschreibung

     Wird von TApplication.MUButton aufgerufen, wenn der Benutzer
     einen Meneintrag angew„hlt hat. In meNum wird der Index
     dieses Eintrags, in mtNum der Index des entsprechenden
     Mentitels bergeben.

     In Tree wird der Zeiger auf den zugeh”rigen Objektbaum und
     in PrIndex der Index des dem Eintrag bergeordneten Objekts
     bergeben; wenn diese Werte nicht ermittelt werden k”nnen,
     wird stattdessen nil bzw. 0 bergeben.

     Die Methode versucht, den Meneintrag mit einem TKeyMenu-
     Objekt zu verknpfen; ist fr den Eintrag kein derartiges
     Objekt vorhanden, wird die Methode TWindow.HandleMenu
     aufgerufen.


4.35.131  TWindow.NextIcon
--------------------------

Deklaration

     function NextIcon: PIcon; virtual;

Beschreibung

     Gibt das n„chste selektiert Icon bzw. Icon berhaupt zurck,
     je nachdem, welche Parameter an TWindow.FirstIcon bergeben
     wurden.



5  Objekthierarchie
*******************

In diesem Diagramm stehen die Nachfahren eines Objekts rechts unter
diesem Objekt auf gleicher Stufe. So sind TCollection, TControl,
TEvent etc. direkte Nachfahren von TObject.

Eine alphabetische Liste erhalten Sie unter "Objekte".


     TObject
          TCollection
               TSortedCollection
                    TStringCollection
                         TStrCollection
          TControl
               TButton
                    TCheckBox
                         TRadioButton
                         TTriState
               TComboBox
               TGroupBox
               TNotepad
               TScrollBar
               TStatic
                    TEdit
          TClipboard
          TEvent
               TIcon
               TKeyMenu
                    TKey
                    TMenu
               TPopup
               TToolbar
          TEventObject
               TApplication
               TWindow
                    TDialog
                         TColorDialog
                         TIndicatorWindow
                    TTextWindow
                         TEditWindow
          TScroller
          TValidator
               TFilterValidator
                    TRangeValidator
               TLookupValidator
                    TStringLookupValidator
               TPXPictureValidator
          TXBase




6  Prozeduren und Funktionen
****************************


6.1  Cookie-Routinen
====================


6.1.1  ChangeCookie
-------------------

Deklaration

     function ChangeCookie(cookie: TCookieID;
                             newval: longint): boolean;

Beschreibung

     ndert den Wert des in cookie bergebenen Cookies auf
     newval. Wenn kein CookieJar existiert oder der angegebene
     Cookie nicht vorhanden ist, wird false zurckgegeben, sonst
     true.


6.1.2  GetCookie
----------------

Deklaration

     function GetCookie(cookie: TCookieID;
                           var value: longint): boolean;

Beschreibung

     Gibt in value den Wert des Cookies cookie zurck, wenn
     dieser existiert. Die Rckgabe ist dann true. Ansonsten wird
     false zurckgegeben und value nicht ver„ndert.


6.1.3  NewCookie
----------------

Deklaration

     function NewCookie(cookie: TCookieID;
                            value: longint): boolean;

Beschreibung

     Legt einen neuen Cookie mit Kennung cookie und Wert value
     an, wenn ein CookieJar existiert und noch mind. ein Platz
     darun frei ist. Die Rckgabe ist dann true.


6.1.4  RemoveCookie
-------------------

Deklaration

     function RemoveCookie(cookie: TCookieID): boolean;

Beschreibung

     Entfernt den Cookie mit Kennung cookie aus dem CookieJar.
     Existiert kein CookieJar oder ist der angegebene Cookie
     nicht vorhanden, wird false zurckgegeben.


6.2  Datei-Routinen
===================


6.2.1  BootDevice
-----------------

Deklaration

     function BootDevice: char;

Beschreibung

     Liefert die Laufwerksbezeichnung des Boot-Laufwerks ("A",
     "B" etc.). Dazu wird die Systemvariable _bootdev ($446)
     ausgewertet.


6.2.2  Exist
------------

Deklaration

     function Exist(FileName: string): boolean;

Beschreibung

     Gibt an, ob die Datei FileName existiert. Die DTA der Appli-
     kation wird nicht ver„ndert! Aus Sicherheitsgrnden wird
     intern eine wind_update()-Schachtelung vorgenommen.


6.2.3  FileSelect
-----------------

Deklaration

     function FileSelect(AParent: PWindow; ATitle,
                 AMask: string; var APath,AFile: string;
                 ForceExist: boolean): boolean;

Beschreibung

     Erm”glicht eine einfache Bearbeitung des Dateiauswahl-
     Dialogs. Wenn die Fileselectbox aus einer Dialogbox heraus
     aufgerufen wird, sollte AParent auf diesen Dialog zeigen
     (mittels @self), damit die Dialogbox, wenn sie modal sein
     sollte, korrekt restauriert werden kann (sonst mu AParent
     nil sein).

     In ATitle wird ein Titel fr die Dateiauswahl bergeben. Es
     wird automatisch darauf geachtet, ob die vorhandene TOS-
     Version fsel_exinput() untersttzt, sonst wird der Titel
     ignoriert (das ABC-GEM wird beachtet, ebenso wie ein FSEL-
     Cookie). In AMask wird die Dateimaske bergeben (z.B.
     '*.TXT','TEST.?A?'). Wird ein Leerstring bergeben, werden
     alle Dateien angezeigt.

     In APath mu der gewnschte Pfad (Leerstring=aktueller Pfad)
     angegeben werden, AFile mu keinen bestimmten Wert enthalten
     (s.u.). Wenn ForceExist auf true gesetzt wird, kann der
     Dialog nicht mit <OK> verlassen werden, wenn die ausgew„hlte
     Datei gar nicht existiert. Wenn eine Datei mit <OK>
     ausgew„hlt wurde, wird true zurckgegeben und APath enth„lt
     den Pfad der Datei, die in AFile geliefert wird (AFile
     enth„lt also keine Pfadangaben). Ansonsten wird false
     geliefert, und AFile und APath werden nicht ver„ndert.

     Aus Sicherheitsgrnden wird intern eine wind_update()-
     Schachtelung vorgenommen.


6.2.4  GetDrives
----------------

Deklaration

     function GetDrives: longint;

Beschreibung

     Liefert Dsetdrv(Dgetdrv) zurck, d.h. die Bitmap aller
     angemeldeten GEMDOS-Laufwerke. Bit 0 entspricht dabei
     Laufwerk A: etc.


6.2.5  GetExtension
-------------------

Deklaration

     function GetExtension(FileName: string): string;

Beschreibung

     Liefert die Datei-Extension von FileName (incl. Punkt). Fr
     'C:\TEST.DB' wrde man also '.DB' erhalten.


6.2.6  GetFilename
------------------

Deklaration

     function GetFilename(FileName: string;
                                Ext: boolean): string;

Beschreibung

     Gibt den Dateinamen von FileName ohne Pfadangabe zurck. Die
     Extension wird nur angeh„ngt, wenn Ext true ist, sonst wird
     sie (incl. Punkt) abgeschnitten.


6.2.7  GetHomeDir
-----------------

Deklaration

     function GetHomeDir(RootDefault: boolean): string;

Beschreibung

     Liefert das User-Home-Verzeichnis als absoluten Pfad (incl.
     Backslash), wozu die Environmentvariable HOME ausgewertet
     wird.

     Wenn HOME nicht gesetzt ist, wird - in Abh„ngigkeit von
     RootDefault - das Boot-Wurzelverzeichnis (true) oder das
     Verzeichnis der Applikation (false) gew„hlt.


6.2.8  GetPath
--------------

Deklaration

     function GetPath(FileName: string): string;

Beschreibung

     Liefert den in FileName enthaltenen Pfad (incl. Backslash).
     Wenn FileName keine Pfadangabe enth„lt, wird ein Leerstring
     zurckgegeben.


6.2.9  GetTempDir
-----------------

Deklaration

     function GetTempDir: string;

Beschreibung

     Liefert das globale tempor„re Verzeichnis als absoluten Pfad
     (incl. Backslash). Dazu wird nach folgenden Environment-
     Variablen gesucht, bis eine davon einen gltigen Pfad
     enth„lt: TMPDIR, TEMPDIR, TMP, TEMP, TRASHDIR. Ist keine
     dieser Variablen gltig, wird das Verzeichnis der Applikati-
     on genommen.


6.2.10  GetTempFilename
-----------------------

Deklaration

     function GetTempFilename: string;

Beschreibung

     Gibt einen Dateinamen zurck (12 Zeichen), der sich aus
     Datum und Uhrzeit zusammensetzt. Dieser Name kann fr
     tempor„re Dateien etc. verwendet werden.

     Z.Z. unterscheiden sich die zurckgelieferten Namen nur
     dann, wenn GetTempFilename im Abstand von mind. 2 Sekunden
     aufgerufen wird.


6.2.11  PathExist
-----------------

Deklaration

     function PathExist(PathName: string): boolean;

Beschreibung

     Gibt an, ob der Pfad (Ordner) PathName existiert. Die DTA
     der Applikation wird nicht ver„ndert! Aus Sicherheitsgrnden
     wird intern eine wind_update()-Schachtelung vorgenommen.

     PathName kann mit oder ohne abschlieenden Backslash ('\')
     angegeben werden. Wird ein Wurzelverzeichnis bergeben (z.B.
     'C:\'), so wird berprft, ob das Laufwerk vorhanden ist.


6.3  Grafik-Routinen
====================


6.3.1  vdi_fix
--------------

Deklaration

     procedure vdi_fix(var pfd: MFDB;
                     theAddr: pointer; w,h: integer);

Beschreibung

     Fllt eine MFDB-Struktur aus. fd_addr wird auf theAddr
     gesetzt, fd_w auf w und fd_h auf h. fd_wdwidth wird aus fd_w
     errechnet. fd_nplanes wird standardm„ig auf 1 gesetzt,
     fd_stand auf FF_STAND; hier sind also evtl. selbst
     nderungen durchzufhren. fd_r1, fd_r2 und fd_r3 werden
     ausgenullt.

     Folgende Konstanten sind fr fd_stand vorgesehen:

     const FF_STAND   = 1;
           FF_DEVSPEC = 0;


6.3.2  vr_convert
-----------------

Deklaration

     procedure vr_convert(handle: integer;
                      psrcMFDB: MFDB; format: integer);

Beschreibung

     Wandelt eine durch psrcMFDB beschriebene Bitmap auf der
     VDI-Workstation handle in das Format format um, wenn sie
     nicht schon in diesem vorliegt (d.h. format sollte ungleich
     fd_stand sein).


6.4  Maus-Routinen
==================


6.4.1  ArrowMouse
-----------------

Deklaration

     procedure ArrowMouse;

Beschreibung

     Wandelt den Mauscursor in den normalen Pfeil um, wenn gleich
     viele (oder mehr) Aufrufe von ArrowMouse gegenber BusyMouse
     (bzw. SliceMouse) gemacht wurden.


6.4.2  BusyMouse
----------------

Deklaration

     procedure BusyMouse;

Beschreibung

     Wandelt den Mauscursor in die Biene um, um anzuzeigen, da
     z.Z. eine Aktion ausgefhrt wird. ObjectGEM merkt sich, wie
     oft BusyMouse aufgerufen wurde. Damit der Mauscursor wieder
     als Pfeil dargestellt wird, mu ArrowMouse mind. genauso oft
     aufgerufen werden, wodurch sich verschachtelte nderungen
     des Mauscursors nicht gegenseitig st”ren. Aus genau diesem
     Grund sollten diese beiden Mausformen nie direkt mit
     graf_mouse() gesetzt werden!


6.4.3  GetMouse
---------------

Deklaration

     procedure GetMouse(var Indx: HCursor;
                                    var Form: MFORM);

Beschreibung

     Liefert die aktuelle Mausform zurck. In Indx erh„lt man die
     Nummer, in Form die evtl. benutzerdefinierten Daten.


6.4.4  HideMouse
----------------

Deklaration

     procedure HideMouse;

Beschreibung

     Macht den Mauscursor unsichtbar.


6.4.5  IsMouseBusy
------------------

Deklaration

     function IsMouseBusy: boolean;

Beschreibung

     Gibt an, ob der Mauscursor z.Z. als Biene dargestellt wird,
     d.h. ob BusyMouse (bzw. SliceMouse) ”fter als ArrowMouse
     aufgerufen wurde.


6.4.6  IsMouseVisible
---------------------

Deklaration

     function IsMouseVisible: boolean;

Beschreibung

     Gibt an, ob der Mauscursor z.Z. sichtbar ist, d.h. ob
     ShowMouse h„ufiger als HideMouse aufgerufen wurde.


6.4.7  LastMouse
----------------

Deklaration

     procedure LastMouse;

Beschreibung

     Stellt den Mauscursor wieder her, der vor dem letzten
     graf_mouse()-Aufruf aktuell war.


6.4.8  SetMouse
---------------

Deklaration

     function SetMouse(Indx: HCursor;
                         Form: MFORMPtr): integer;

Beschreibung

     Entspricht im wesentlichen graf_mouse(), allerdings k”nnen
     zus„tzliche Mausformen verwendet werden. Auerdem kann durch
     Verwendung dieser Routine die aktuelle Einstellung mit
     GetMouse erfragt werden.


6.4.9  SetMousePos
------------------

Deklaration

     procedure SetMousePos(mX,mY: integer);

Beschreibung

     Setzt den Mauscursor an die Position (mY,mY). Intern wird
     appl_tplay() verwendet.


6.4.10  ShowMouse
-----------------

Deklaration

     procedure ShowMouse;

Beschreibung

     Macht den Mauscursor sichtbar.


6.4.11  SliceMouse
------------------

Deklaration

     procedure SliceMouse;

Beschreibung

     Wandelt den Mauscursor in eine schwarz-wei geviertelte
     Scheibe um, die mit SliceMouseNext zum Drehen gebracht
     werden kann.

     ObjectGEM merkt sich, wie oft SliceMouse aufgerufen wurde
     (BusyMouse und SliceMouse benutzen denselben Z„hler). Damit
     der Mauscursor wieder als Pfeil dargestellt wird, mu
     ArrowMouse mind. genauso oft aufgerufen werden, wodurch sich
     verschachtelte nderungen des Mauscursors nicht gegenseitig
     st”ren.


6.4.12  SliceMouseNext
----------------------

Deklaration

     procedure SliceMouseNext;

Beschreibung

     Wechselt bei jedem Aufruf die Mausformen IDC_SLICE1 bis
     IDC_SLICE4 ab, so da man den Fortgang einer Aktion durch
     das Drehen der Scheibe anzeigen kann.

     Darf nur aufgerufen werden, wenn vorher SliceMouse
     aufgerufen wurde.


6.5  Pointer-Routinen
=====================


6.5.1  GetOSHeaderPtr
---------------------

Deklaration

     function GetOSHeaderPtr: pointer;

Beschreibung

     Gibt einen Zeiger auf den OS-Header zurck, d.h. es wird
     _sysbase ($4f2) ausgewertet und dann der Zeiger os_beg bei
     Offset $08 geliefert.


6.5.2  GetQSB
-------------

Deklaration

     procedure GetQSB(var p: pointer; var len: longint);

Beschreibung

     Gibt in p einen Pointer auf den AES-"Quarter Screen Buffer"
     zurck, wenn dieser vorhanden ist, sonst ist p=nil. Im Falle
     der Existenz wird in len die L„nge des Buffers in Bytes
     angegeben.

     Unter MultiTOS wird immer nil zurckgegeben, da dort das
     Zugriffsrecht auf den Puffer nicht definiert ist.


6.5.3  HiWord
-------------

Deklaration

     function HiWord(p: pointer): word;

Beschreibung

     Gibt das High-Word des Pointers p zurck.


6.5.4  LoWord
-------------

Deklaration

     function LoWord(p: pointer): word;

Beschreibung

     Gibt das Low-Word des Pointers p zurck.


6.5.5  Ptr
----------

Deklaration

     function Ptr(hi,lo: word): pointer;

Beschreibung

     Berechnet aus dem High-Word hi und dem Low-Word lo den
     zugeh”rigen Pointer. Ist so eine Art Ersatz fr die von PP
     nicht untersttzte Ptr-Funktion, allerdings hat diese
     Implementierung volle Gltigkeit auf 680xx-Prozessoren.


6.6  Profile-Routinen
=====================


6.6.1  ClosePrivateProfile
--------------------------

Deklaration

     function ClosePrivateProfile: boolean;

Beschreibung

     Schliet eine zuvor mit OpenPrivateProfile ge”ffnete INF-
     Datei. Wenn an dem Profile nderungen vorgenommen wurden,
     wird vorher noch SavePrivateProfile aufgerufen.

     Die Rckgabe ist true, wenn das Profile korrekt geschlossen
     werden konnte, false, wenn gar kein Profile ge”ffnet war
     oder beim Speichern ein Fehler aufgetreten ist.

     Wird von TApplication.Done aufgerufen.


6.6.2  GetPrivateProfileInt
---------------------------

Deklaration

     function GetPrivateProfileInt(AppName,
                     KeyName: string; Default: longint;
                     FileName: string): longint;

Beschreibung

     Diese Funktion ruft den Wert einer Integerschlsselanweisung
     aus der durch FileName angegebenen INF-Datei (z.B.
     'TEST.INF') ab.

     GetPrivateProfileInt sucht die Datei nach einer durch den
     Parameter KeyName bestimmten Schlsselanweisung ab und
     berprft dann die šbereinstimmung von AppName und dem in
     der Datei stehenden Anwendungsnamen.

     Ein Integereintrag in der INF-Datei mu folgende Form haben:

     [Anwendungsname]
     Schlsselanweisung = wert
     ...

     Das k”nnte also z.B. so aussehen:

     [Drucker]
     Kopien=2

     Wird die Schlsselanweisung nicht oder nicht unter dem
     Anwendungsnamen gefunden, wird Default zurckgegeben.
     Ansonsten wird der Wert der Schlsselanweisung geliefert,
     wobei den Ziffern folgende Buchstaben ignoriert werden (z.B.
     gibt 'Kopien=3abc' den Wert 3 zurck).

     Wichtig: Die Gro-/Kleinschreibung bei AppName und KeyName
     wird nicht bercksichtigt.

     Aus Sicherheitsgrnden wird intern eine wind_update()-
     Schachtelung durchgefhrt, auer wenn mit OpenPrivateProfile
     die Profile-Operationen in den Speicher verlagert wurden.


6.6.3  GetPrivateProfileString
------------------------------

Deklaration

     function GetPrivateProfileString(AppName,KeyName,
                      Default,FileName: string): string;

Beschreibung

     Diese Funktion ruft den Wert einer Schlsselanweisung aus
     der durch FileName angegebenen INF-Datei (z.B. 'TEST.INF')
     ab.

     GetPrivateProfileString sucht die Datei nach einer durch den
     Parameter KeyName bestimmten Schlsselanweisung ab und
     berprft dann die šbereinstimmung von AppName und dem in
     der Datei stehenden Anwendungsnamen.

     Ein Stringeintrag in der INF-Datei mu folgende Form haben:

     [Anwendungsname]
     Schlsselanweisung = string
     ...

     Das k”nnte also z.B. so aussehen:

     [Grafik]
     Bildname=TIGER.IMG

     Wird die Schlsselanweisung nicht oder nicht unter dem
     Anwendungsnamen gefunden, wird Default zurckgegeben.
     Ansonsten wird die Zeichenkette hinter den
     Schlsselanweisung geliefert.

     Wichtig: Die Gro-/Kleinschreibung bei AppName und KeyName
     wird nicht bercksichtigt.

     Aus Sicherheitsgrnden wird intern eine wind_update()-
     Schachtelung durchgefhrt, auer wenn mit OpenPrivateProfile
     die Profile-Operationen in den Speicher verlagert wurden.


6.6.4  OpenPrivateProfile
-------------------------

Deklaration

     function OpenPrivateProfile
                           (FileName: string): boolean;

Beschreibung

     L„dt die in FileName angegebene INF-Datei in den Speicher,
     wo sie mit einer TStrCollection verwaltet wird. Alle
     Profile-Operationen, die auf dieser INF-Datei ausgefhrt
     werden, ben”tigen dadurch keine Plattenzugriffe mehr und
     werden so beschleunigt.

     Es kann immer nur ein Profile im Speicher verwaltet werden,
     Zugriffe auf andere Profiles werden direkt auf der Platte
     ausgefhrt.

     OpenPrivateProfile liefert true, wenn die INF-Datei
     eingelesen werden konnte. Existiert die Datei nicht (d.h.
     das Profile wird mit diesem Aufruf neu angelegt) oder trat
     ein Fehler auf, ist die Rckgabe false.

     Wichtig: Die Datei $HOME/user.inf kann mit dieser Routine
     nicht ge”ffnet werden, da diese Datei evtl. eine globale
     Konfigurationsdatei wird.


6.6.5  SavePrivateProfile
-------------------------

Deklaration

     function SavePrivateProfile: boolean;

Beschreibung

     Speichert eine mit OpenPrivateProfile ge”ffnete INF-Datei,
     wenn nderungen vorgenommen wurden. Die Rckgabe ist true,
     wenn beim Speichern kein Fehler aufgetreten ist.

     Aus Sicherheitsgrnden wird eine evtl. schon vorhandene
     INF-Datei erst gel”scht, wenn die neue Datei fehlerfrei
     geschrieben werden konnte. Dazu wird eine tempor„re Datei,
     die mit GetTempFilename ermittelt wird, angelegt.

     Wird von ClosePrivateProfile aufgerufen.


6.6.6  WritePrivateProfileInt
-----------------------------

Deklaration

     function WritePrivateProfileInt(AppName,
                       KeyName: string; Value: longint;
                       FileName: string): boolean;

Beschreibung

     Diese Funktion kopiert den durch den Parameter Value
     bergebenen Wert in die durch FileName angegebene INF-Datei
     (z.B. 'MYAPP.INF'). Sie sucht die Datei nach der
     Schlsselanweisung ab, die durch den Parameter KeyName
     bestimmt ist, der wiederum unter dem Anwendungsnamen AppName
     zu finden ist. Wird keine šbereinstimmung gefunden, fgt die
     Funktion der Datei eine entsprechende Schlsselanweisung
     (und wenn n”tig auch den zugeh”rigen Anwendungsnamen) hinzu.
     Ist die Schlsselanweisung hingegen vorhanden, wird der
     zugeh”rige Wert durch Value ersetzt. Der Rckgabewert ist
     true, wenn die Funktion erfolgreich war, false sonst.

     Weitere Anmerkungen zu den Profiles sind unter
     WritePrivateProfileString zu finden.


6.6.7  WritePrivateProfileString
--------------------------------

Deklaration

     function WritePrivateProfileString(AppName,
               KeyName,Value,FileName: string): boolean;

Beschreibung

     Diese Funktion kopiert den durch den Parameter Value
     bergebenen String in die durch FileName angegebene INF-
     Datei (z.B. 'MYAPP.INF'). Sie sucht die Datei nach der
     Schlsselanweisung ab, die durch den Parameter KeyName
     bestimmt ist, der wiederum unter dem Anwendungsnamen AppName
     zu finden ist. Wird keine šbereinstimmung gefunden, fgt die
     Funktion der Datei eine entsprechende Schlsselanweisung
     (und wenn n”tig auch den zugeh”rigen Anwendungsnamen) hinzu.
     Ist die Schlsselanweisung hingegen vorhanden, wird der
     zugeh”rige String durch Value ersetzt. Der Rckgabewert ist
     true, wenn die Funktion erfolgreich war, false sonst (z.B.
     auch, wenn in AppName oder KeyName ein Leerstring bergeben
     wird).

     Wird in FileName kein absoluter Pfad bergeben, wird der
     Pfad mit GetHomeDir ermittelt. Existiert die Datei noch
     nicht, wird sie neu angelegt.

     Eine Schlsselanweisung kann aus der INF-Datei gel”scht
     werden, indem fr Value ein Leerstring bergeben wird.

     Kommentarzeilen in den Profiles werden mit einem Semikolon
     am Anfang markiert.

     Eine Anwendung sollte eine INF-Datei benutzen, wenn
     irgendwelche Informationen bzgl. der Konfiguration des
     Programms gespeichert werden sollen. Auerdem haben die
     Profiles den Vorteil, da die Informationen darin als
     lesbarer ASCII-Text vorliegen, der - wenn es sein mu - auch
     "von Hand" relativ einfach ge„ndert werden kann. Zum
     Umkopieren des Profiles wird eine tempor„re Datei angelegt,
     die mit GetTempFilename ermittelt wird.

     Aus Sicherheitsgrnden wird intern eine wind_update()-
     Schachtelung durchgefhrt, es sei denn, mit
     OpenPrivateProfile wurden die Profile-Operationen in den
     Speicher verlagert (was aus Geschwindigkeitsgrnden immer zu
     empfehlen ist).

     Ein Beispiel fr den Aufbau eines Profiles ist unter
     GetPrivateProfileString zu finden.


6.6.8  GetProfileInt
--------------------

Deklaration

     function GetProfileInt(AppName,KeyName: string;
                             Default: longint): longint;

Beschreibung

     Entspricht im wesentlichen GetPrivateProfileInt, abgesehen
     davon, da diese Routine immer auf der Datei $HOME/user.inf
     arbeitet.

     Dabei handelt es sich um eine globale Konfigurationsdatei,
     ber die z.Z. gerade diskutiert wird. Deshalb ist auch nicht
     ausgeschlossen, da sich Name, Ort, Inhalt etc. der Datei
     noch „ndern!


6.6.9  GetProfileString
-----------------------

Deklaration

     function GetProfileString(AppName,KeyName,
                              Default: string): string;

Beschreibung

     Entspricht im wesentlichen GetPrivateProfileString,
     abgesehen davon, da diese Routine immer auf der Datei
     $HOME/user.inf arbeitet.

     Dabei handelt es sich um eine globale Konfigurationsdatei,
     ber die z.Z. gerade diskutiert wird. Deshalb ist auch nicht
     ausgeschlossen, da sich Name, Ort, Inhalt etc. der Datei
     noch „ndern!


6.6.10  WriteProfileInt
-----------------------

Deklaration

     function WriteProfileInt(AppName,KeyName: string;
                               Value: longint): boolean;

Beschreibung

     Entspricht im wesentlichen WritePrivateProfileInt, abgesehen
     davon, da diese Routine immer auf der Datei $HOME/user.inf
     arbeitet.

     Dabei handelt es sich um eine globale Konfigurationsdatei,
     ber die z.Z. gerade diskutiert wird. Deshalb ist auch nicht
     ausgeschlossen, da sich Name, Ort, Inhalt etc. der Datei
     noch „ndern!


6.6.11  WriteProfileString
--------------------------

Deklaration

     function WriteProfileString(AppName,KeyName,
                                Value: string): boolean;

Beschreibung

     Entspricht gr”tenteils WritePrivateProfileString, abgesehen
     davon, da diese Routine immer auf der Datei $HOME/user.inf
     arbeitet.

     Dabei handelt es sich um eine globale Konfigurationsdatei,
     ber die z.Z. gerade diskutiert wird. Deshalb ist auch nicht
     ausgeschlossen, da sich Name, Ort, Inhalt etc. der Datei
     noch „ndern!


6.7  Rechteck-Routinen
======================


6.7.1  A2toGR
-------------

Deklaration

     procedure A2toGR(var r: GRECT);

Beschreibung

     Wandelt die absoluten Koordinaten in Breite und H”he des
     Rechtecks um.


6.7.2  GRtoA2
-------------

Deklaration

     procedure GRtoA2(var r: GRECT);

Beschreibung

     Wandelt Breite und H”he des Rechtecks in zwei
     gegenberliegende (absolute) Punkte um.


6.7.3  rc_intersect
-------------------

Deklaration

     function rc_intersect(r1: GRECT;
                            var r2: GRECT): boolean;

Beschreibung

     Gibt true zurck, wenn sich die beiden Rechtecke r1 und r2
     berschneiden. Das Schnitt-Rechteck wird in r2
     zurckgegeben, die GRECT-Struktur wird komplett ausgefllt
     (mit beiden Koordinatenangaben).

     Ansonsten wird false zurckgegeben und r2 nicht ver„ndert.


6.8  Versions-Routinen
======================


6.8.1  DtoS
-----------

Deklaration

     function DtoS(l: longint): string;

Beschreibung

     Wandelt ein Datum, das im Format $mmttjjjj vorliegt (das
     sind z.B. die Systemdaten) in einen "lesbaren" Datumsstring
     um. Ist kein _IDT-Cookie vorhanden, hat der String immer die
     Form 'tt.mm.jjjj'. Ansonsten wird der Cookie-Wert
     analysiert, die Bits 11..8 geben das Datumsformat an:

      0 mm?tt?jjjj

      1 tt?mm?jjjj

      2 jjjj?mm?tt

      3 jjjj?tt?mm

     In den Bits 7..0 ist das Trennzeichen angegeben, #0 wird als
     '/' interpretiert.


6.8.2  GEMDOSVersion
--------------------

Deklaration

     function GEMDOSVersion: word;

Beschreibung

     Gibt die GEMDOS-Version zurck.


6.8.3  GEMVersion
-----------------

Deklaration

     function GEMVersion: word;

Beschreibung

     Liefert die GEM-(AES-)Version bzw. Null, wenn kein Applika-
     tionsobjekt instantiiert wurde.


6.8.4  MiNTVersion
------------------

Deklaration

     function MiNTVersion: word;

Beschreibung

     Gibt die MiNT-Version zurck, wenn dieses installiert ist,
     andernfalls Null.


6.8.5  TOSDate
--------------

Deklaration

     function TOSDate: longint;

Beschreibung

     Liefert das Datum der verwendeten TOS-Version.


6.8.6  TOSVersion
-----------------

Deklaration

     function TOSVersion: word;

Beschreibung

     Gibt die verwendete TOS-Version zurck.


6.8.7  VtoS
-----------

Deklaration

     function VtoS(w: word): string;

Beschreibung

     Wandelt eine Versionsangabe, die im Format $0hll vorliegt
     (das sind z.B. alle von den ObjectGEM-Versions-Routinen
     gelieferten Zahlen), in den String 'h.ll' um.


6.9  Zeichenketten-Routinen
===========================


6.9.1  atof
-----------

Deklaration

     function atof(s: string): real;

Beschreibung

     Wandelt eine Zeichenkette in eine Fliekommazahl um.
     Leerzeichen werden automatisch abgeschnitten, ein un„res
     Plus wird beachtet.


6.9.2  atol
-----------

Deklaration

     function atol(s: string): longint;

Beschreibung

     Wandelt eine Zeichenkette in eine Integer-Zahl um.
     Leerzeichen werden automatisch abgeschnitten, ein un„res
     Plus wird beachtet.


6.9.3  ChrDispose
-----------------

Deklaration

     procedure ChrDispose(var p: PChar);

Beschreibung

     Gibt die mit ChrNew allozierte Zeichenkette wieder frei und
     setzt p auf nil.


6.9.4  ChrNew
-------------

Deklaration

     function ChrNew(s: string): PChar;

Beschreibung

     Wandelt den String s in eine nullterminierte Zeichenkette um
     und alloziert den ben”tigten Speicher. Im Gegensatz zu
     StrNew wird auch eine leere Zeichenkette umgewandelt.

     Als Rckgabe erh„lt man einen Pointer auf die neue
     Zeichenkette oder nil, falls der Speicher nicht alloziert
     werden konnte.

     Darf nur mit ChrDispose wieder freigegeben werden!


6.9.5  DisposeStr
-----------------

Deklaration

     procedure DisposeStr(var p: PString);

Beschreibung

     Gibt den mit NewStr angelegten String wieder frei.


6.9.6  ftoa
-----------

Deklaration

     function ftoa(f: real): string;

Beschreibung

     Wandelt eine Fliekommazahl in einen String um. Rechts vom
     Komma werden alle Nullen abgeschnitten, wenn es sich nicht
     um die einzige Ziffer nach dem Komma handelt.


6.9.7  LowChar
--------------

Deklaration

     function LowChar(ch: char): char;

Beschreibung

     Wandelt Gro- in Kleinbuchstaben um. Umlaute werden
     bercksichtigt!


6.9.8  ltoa
-----------

Deklaration

     function ltoa(l: longint): string;

Beschreibung

     Wandelt eine Integer-Zahl in einen String um.


6.9.9  NewStr
-------------

Deklaration

     function NewStr(s: string): PString;

Beschreibung

     Legt einen dynamischen String an, es wird entsprechend viel
     Speicher alloziert.

     Als Rckgabe erh„lt man einen Pointer auf den String oder
     nil, wenn nicht genug Speicher vorhanden ist bzw. in s ein
     Leerstring bergeben wurde.


6.9.10  RPos
------------

Deklaration

     function RPos(subStr,Str: string): byte;

Beschreibung

     Die Funktion RPos sucht einen Teilstring subStr rckw„rts in
     einem String Str. Falls Str den Teilstring subStr enth„lt,
     liefert RPos als Resultat den Index des ersten
     bereinstimmenden Zeichens des letzten Vorkommens von subStr
     in Str, sonst Null.


6.9.11  StrLPas
---------------

Deklaration

     function StrLPas(p: PChar; maxc: integer): string;

Beschreibung

     Wandelt die nullterminierte Zeichenkette p in einen String
     um, wobei maximal maxc Zeichen bernommen werden.


6.9.12  StrPLeft
----------------

Deklaration

     function StrPLeft(s: string; c: integer): string;

Beschreibung

     Gibt die c linken Zeichen von s zurck. Wenn c<=0 ist, wird
     ein Leerstring zurckgegeben.


6.9.13  StrPLower
-----------------

Deklaration

     function StrPLower(s: string): string;

Beschreibung

     Gibt den in Kleinbuchstaben umgewandelten String s zurck.
     Umlaute werden bercksichtigt.


6.9.14  StrPRight
-----------------

Deklaration

     function StrPRight(s: string; c: integer): string;

Beschreibung

     Gibt die c rechten Zeichen von s zurck. Wenn c<=0 ist, wird
     ein Leerstring zurckgegeben.


6.9.15  StrPSpace
-----------------

Deklaration

     function StrPSpace(anz: integer): string;

Beschreibung

     Gibt eine Zeichenkette zurck, die aus anz Leerzeichen
     besteht. Fr c<=0 wird ein Leerstring zurckgegeben.


6.9.16  StrPTrim
----------------

Deklaration

     procedure StrPTrim(var s: string);

Beschreibung

     Schneidet bei dem String s links und rechts alle Leerzeichen
     bzw. ASCII #0 ab.


6.9.17  StrPTrimF
-----------------

Deklaration

     function StrPTrimF(s: string): string;

Beschreibung

     Gibt den String s zurck, bei dem links und rechts alle
     Leerzeichen und ASCII #0 abgeschnitten wurden.


6.9.18  StrPUpper
-----------------

Deklaration

     function StrPUpper(s: string): string;

Beschreibung

     Gibt den in Grobuchstaben umgewandelten String s zurck.
     Umlaute werden bercksichtigt.


6.9.19  UpChar
--------------

Deklaration

     function UpChar(ch: char): char;

Beschreibung

     Wandelt Klein- in Grobuchstaben um. Im Gegensatz zu UpCase
     werden die Umlaute bercksichtigt!


6.10  Sonstige Prozeduren und Funktionen
========================================


6.10.1  Abstract
----------------

Deklaration

     procedure Abstract;

Beschreibung

     Ein Aufruf dieser Prozedur beendet das Programm mit dem
     Laufzeitfehler 211 ("Call to abstract method"). Wird ein
     abstrakter Objekttyp implemen- tiert, sollte man Aufrufe von
     Abstract in den- jenigen virtuellen Methoden einsetzen, die
     von Nachkommen des Typs neu definiert werden mssen. Dies
     stellt sicher, da jeder Versuch fehlschl„gt, den abstrakten
     Objekttyp zu instantiieren.


6.10.2  appl_yield
------------------

Deklaration

     procedure appl_yield;

Beschreibung

     Gibt anderen Prozessen (Accessories) Rechenzeit ab, wenn
     z.B. eine langwierige Berechnung durchgefhrt wird. Intern
     wird evnt_timer(1,0) aufgerufen.


6.10.3  Between
---------------

Deklaration

     function Between(x,min,max: longint): boolean;

Beschreibung

     Gibt an, ob sich der Wert x zwischen min und max befindet
     (inklusive).


6.10.4  bTst
------------

Deklaration

     function bTst(value,mask: longint): boolean;

Beschreibung

     Gibt an, ob die Bits, die in mask gesetzt sind, auch in
     value gesetzt sind.


6.10.5  form_box
----------------

Deklaration

     procedure form_box(flag: integer; r: GRECT);

Beschreibung

     Zeichnet sich gr”er werdende bzw. schrumpfende Rechtecke
     mittels form_dial(). In r wird das Rechteck bei seiner
     gr”ten Ausdehnung bergeben, die kleinste Ausdehnung
     berechnet form_box als Mittelpunkt des groen Rechtecks. Fr
     flag k”nnen die Werte FMD_GROW und FMD_SHRINK bergeben
     werden.


6.10.6  GetDesk
---------------

Deklaration

     procedure GetDesk(var r: GRECT);

Beschreibung

     Gibt in r die Koordinaten des Fensters 0, d.h. des Desktops
     zurck. In r liegen danach beide Koordinatenangaben vor.


6.10.7  IsDesktopActive
-----------------------

Deklaration

     function IsDesktopActive: boolean;

Beschreibung

     Gibt true zurck, wenn der GEM-Desktop z.Z. aktiv ist, d.h.
     wenn keine andere Applikation gestartet ist. Dazu wird unter
     einem Singletasking-TOS die lokale GEMDOS-Variable act_pd
     (auf die p_run zeigt) ausgewertet.

     Unter MultiTOS wird mit appl_find() der aktuelle Proze
     ermittelt und mit der Systemshell, die mit appl_search()
     bestimmt wird, verglichen.


6.10.8  MapKey
--------------

Deklaration

     function MapKey(Key: word): word;

Beschreibung

     Dient zur L„nder-unabh„ngigen Auswertung der Tastatur. Wird
     intern vom TDialog-Keyboard-Handler benutzt. Die Funktion
     „ndert eine VDI-Taste (Rckgabe von z.B. evnt_keybd()) in
     ein word-groes, codiertes Zeichen:

     HighByte LowByte
     -------- -------    ACLR sind Shift-Status-Bits
     SxxxACLR CHARCODE = ASCII-(S=0) oder Scan(S=1)-Code

     Die Routine stammt ursprnglich von Ken Badertscher (Atari).


6.10.9  Max
-----------

Deklaration

     function Max(a,b: longint): longint;

Beschreibung

     Gibt die gr”ere Zahl von a und b zurck.


6.10.10  Min
------------

Deklaration

     function Min(a,b: longint): longint;

Beschreibung

     Gibt die kleinere Zahl von a und b zurck.


6.10.11  Sgn
------------

Deklaration

     function Sgn(x: longint): integer;

Beschreibung

     Dies ist die sog. Signum-Funktion, d.h. die Rckgabe ist -1
     fr x<0, 0 fr x=0 und 1 fr x>0.



7  Typen und Records
********************


7.1  einfache Datentypen
========================

     type
       PBoolean = ^boolean;
       PByte    = ^byte;
       PInteger = ^integer;
       PLongint = ^longint;
       PObj     = AESOBJECTPtr;
       PPointer = ^pointer;
       PShort   = ^shortint;
       PString  = ^string;
       PTree    = AESTreePtr;
       PWord    = ^word;

     Folgende Typen sind aus Kompatibilit„tsgrnden zu
     BorlandPascal bzw. Windows/ObjectWindows vorhanden:

     PBool = ^Bool;
     Bool  = word;    (von PurePascal nicht untersttzt)
     PStr  = PChar;


7.2  APPLRECORD
===============

Deklaration

     PAPPLRECORD = ^APPLRECORD;
     APPLRECORD  = record
                     Typ: longint;
                     What: record
                             case boolean of
                               false: (Long: longint);
                               true:  (Hi,Lo: word)
                           end
                   end;

Beschreibung

     Dient zum Speichern von Benutzeraktionen bei appl_trecord()
     und appl_tplay(). Folgende Aktionen sind m”glich:


       +-----------+------+----------------------------------+
       | Typ       | Wert | What                             |
       +-----------+------+----------------------------------+
       | AT_TIMER  |    0 | Anzahl der verstrichenen Milli-  |
       |           |      | sekunden                         |
       +-----------+------+----------------------------------+
       | AT_BUTTON |    1 | Status der Maustaste im unteren  |
       |           |      | Wort (0: nicht gedrckt, 1: ge-  |
       |           |      | drckt); Anzahl der Klicks im    |
       |           |      | oberen Wort                      |
       +-----------+------+----------------------------------+
       | AT_MOUSE  |    2 | X/Y-Koordinaten (oberes/unteres  |
       |           |      | Wort)                            |
       +-----------+------+----------------------------------+
       | AT_KEYBD  |    3 | eingegebenes Zeichen (unteres    |
       |           |      | Wort); Status der Umschalttasten |
       |           |      | (oberes Wort)                    |
       +-----------+------+----------------------------------+


7.3  GRECT
==========

Deklaration

     PGRECT = ^GRECT;
     GRECT  = record
                case integer of
                  0: (g_x,g_y,g_w,g_h    : integer);
                  1: (X,Y,W,H,X1,Y1,X2,Y2: integer);
                  2: (A1,A2              : ARRAY_4)
              end;

Beschreibung

     Enth„lt die Gr”e eines Bildschirmrechtecks. X und Y geben
     die linke obere Ecke des Rechtecks an, W und H die Breite
     und H”he. In X1..Y2 k”nnen die beiden gegenberliegenden
     Eckpunkte als absolute Koordinaten gespeichert werden (die
     meisten ObjectGEM-Routinen speichern beide Arten). In A1 und
     A2 sind die relativen bzw. die absoluten Koordinaten
     zusammengefat. g_x..g_h sind nur aus Kompatibilit„tsgrnden
     zur ursprnglichen C-Deklaration vorhanden.


7.4  HBrush
===========

Deklaration

     HBrush = THandle;

Beschreibung

     Wird zur Speicherung eines "Zeichenstiftes" verwendet. Im
     Moment ist dies ein VDI-Farbindex, mit dem eine Fl„che
     gefllt wird. Sp„ter werden hiermit aber evtl. auch
     verschiedene Muster etc. verwaltet.


7.5  HCursor
============

Deklaration

     HCursor = THandle;

Beschreibung

     Speichert eine Mausform. Dabei kann es sich um eine
     Konstante (ARROW etc.) handeln, oder aber um einen Pointer
     (Wert>$7fff), der auf eine MFORM-Struktur zeigt.


7.6  HWnd
=========

Deklaration

     HWnd = THandle;

Beschreibung

     Wird zur Speicherung der ObjectGEM-internen Kennung eines
     jeden Fensterobjekts verwendet.


7.7  INFOXSSI
=============

Deklaration

     PINFOXSSI = ^INFOXSSI;
     INFOXSSI  = record
                   id       : longint;
                   version  : word;
                   save_stat,
                   prg_stat : integer;
                   vec_stat : longint
                 end;

Beschreibung

     Bildschirmschoner, die das "eXtended ScreenSaver Interface"
     untersttzen, richten einen XSSI-Cookie ein, der auf eine
     INFOXSSI-Struktur zeigt. id enth„lt die Kennung des
     Bildschirmschoners; fr den Aufbau einer solchen Kennung
     gilt dasselbe wie fr XBRA-Kennungen (BeforeDawn: 'DAWN',
     TwiLight: 'DATL', midnight: 'midn'). In version findet man
     die untersttzte XSSI-Version ($0100 oder $0101). save_stat
     gibt an, ob gerade geschont wird (negativer Wert) oder nicht
     (0). Applikationen k”nnen so evtl. ihre Grafikausgabe
     anhalten. Mit prg_stat kann ein Programm dem
     Bildschirmschoner eine Mitteilung schicken:


                 +----+----------------------------+
                 |  0 | ganz normal schonen        |
                 +----+----------------------------+
                 |  1 | sofort aufh”ren zu schonen |
                 +----+----------------------------+
                 | -1 | sofort aktiv werden        |
                 +----+----------------------------+

     vec_stat (ab Version 1.01) ist ein Bitfeld, in dem der
     Status der einzelnen berwachten Vektoren eingetragen ist
     (Bit gesetzt=aktiv):


         +-------+------------------------------------------+
         |   Bit |                                          |
         |     0 | Tastatur                                 |
         +-------+------------------------------------------+
         |     1 | Maus                                     |
         +-------+------------------------------------------+
         |     2 | Joystick                                 |
         +-------+------------------------------------------+
         |     3 | MIDI                                     |
         +-------+------------------------------------------+
         |     4 | Modem 1                                  |
         +-------+------------------------------------------+
         |     5 | Modem 2                                  |
         +-------+------------------------------------------+
         |     6 | Serial 1                                 |
         +-------+------------------------------------------+
         |     7 | Serial 2                                 |
         +-------+------------------------------------------+
         |  8-14 | Reserviert                               |
         +-------+------------------------------------------+
         |    15 | Grafik in Menzeile unterdrcken (Uhren) |
         +-------+------------------------------------------+
         |    16 | AES-Grafikausgaben berwachen            |
         +-------+------------------------------------------+
         | 17,18 | Grafikberwachung:                       |
         |       | 00: Durchlassen                          |
         |       | 01: Unterdrcken                         |
         |       | 10: šberwachen (bei Grafik aufwachen)    |
         |       | 11: reserviert                           |
         +-------+------------------------------------------+
         | 19,20 | Textberwachung (GEMDOS und VDI);        |
         |       | Bits entsprechend der Grafikberwachung  |
         +-------+------------------------------------------+
         | 21-31 | Reserviert                               |
         +-------+------------------------------------------+

     Im Moment wird die Struktur noch nicht ben”tigt, es ist
     jedoch nicht ausgeschlossen, da ObjectGEM sp„ter evtl. den
     XSSI-Cookie automatische beachtet und auswertet.


7.8  IterationFunc
==================

Deklaration

     PIterationFunc = ^IterationProc;
     IterationFunc  = function(p: pointer): boolean;

Beschreibung

     Wird von FirstThat, LastThat und FirstWndThat als
     Standardtyp fr die aufzurufende Funktion verwendet.


7.9  IterationProc
==================

Deklaration

     PIterationProc = ^IterationProc;
     IterationProc  = procedure(p: pointer);

Beschreibung

     Wird von ForEach und ForEachWnd als Standardtyp fr die
     aufzurufende Prozedur verwendet.


7.10  LongRec
=============

Deklaration

     PLongRec = ^LongRec;
     LongRec  = record
                  Hi,Lo: word
                end;

Beschreibung

     Ein Hilfs-Record, der den Zugriff auf das h”her- und
     niederwertige Wort eines longints erm”glicht.


7.11  Pipearray
===============

Deklaration

     PPipearray = ^Pipearray;
     Pipearray  = ARRAY_8;

Beschreibung

     Dies ist ein Array von 8 integer-Werten, das zur Speicherung
     einer GEM-Message verwendet wird. Fr die Nachrichten
     existiert eine Konvention ber die Belegung der einzelnen
     Felder:


          +-----+-----------------------------------------+
          | [0] | Nachrichtennummer                       |
          +-----+-----------------------------------------+
          | [1] | Nummer (apID) des Absenders             |
          +-----+-----------------------------------------+
          | [2] | Anzahl der Bytes, die noch nachtr„glich |
          |     | per appl_read() gelesen werden mssen   |
          |     | (siehe TApplication.MessageBuffer)      |
          +-----+-----------------------------------------+

     Feld 2 enth„lt normalerweise eine Null. Die Belegung der
     anderen Felder h„ngt von der verschickten Nachricht ab.


7.12  TByteArray
================

Deklaration

     PByteArray = ^TByteArray;
     TByteArray = array [0..maxlongint-1] of byte;

Beschreibung

     Ein universeller Byte-Array-Typ; kann z.B. zum Typecasting
     bei Pointern verwendet werden.


7.13  TCharSet
==============

Deklaration

     PCharSet = ^TCharSet;
     TCharSet = set of char;

Beschreibung

     Wird von TFilterValidator zur Speicherung der gltigen
     Zeichen verwendet.


7.14  TCookie
=============

Deklaration

     PCookie = ^TCookie;
     TCookie = record
                 ID:  TCookieID;
                 Val: longint
               end;

Beschreibung

     Enth„lt einen kompletten CookieJar-Eintrag. Dieser besteht
     aus einer (hoffentlich) eindeutigen Kennung und einem Wert,
     der z.B. als Pointer auf eine zugeh”rige Struktur oder fr
     eine Versionsnummer genutzt werden kann.

     Der CookieJar nimmt eine Art programmspezifische
     "Systemvariablen" auf, die von vielen Tools installiert
     werden. Applikationen werten diese Variablen normalerweise
     nur aus.


7.15  TCookieID
===============

Deklaration

     PCookieID = ^TCookieID;
     TCookieID = array [0..3] of char;

Beschreibung

     Dies ist der Datentyp fr eine CookieJar-Kennung. Bei der
     Belegung sollte man folgendes beachten:

        ù Mit "_" beginnende Kennungen sind fr Atari reserviert

        ù Die vier Buchstaben sollten "druckbar" sein, d.h.
          ASCII-Codes zwischen 32 und 126, keine nationalen
          Sonderzeichen!

        ù Die Buchstaben sollten eine Abkrzung ergeben, aus der
          man auf das zugeh”rige Programm schlieen kann.
          Varianten der W”rter "Cookie", "Vector" u.„. geh”ren
          nicht dazu!


7.16  TEventData
================

Deklaration

     PEventData = ^TEventData;
     TEventData = record
                    Pipe       : Pipearray;
                    mX,mY      : integer;
                    BStat,KStat: integer;
                    Key,Clicks : integer
                  end;

Beschreibung

     Dieser Record wird von TApplication.GetEvent und von allen
     von TApplication.MessageLoop aufgerufenen Methoden zur
     Datenbergabe genutzt. Er enth„lt alle wichtigen
     Rckgabewerte von evnt_multi().

     Pipe nimmt eine komplette GEM-Message auf. In mX und mY wird
     die Mausposition, in BStat die gedrckte Maustaste (1=links,
     2=rechts) und in Clicks die Anzahl der Mausklicks
     gespeichert. KStat enth„lt den Status der Umschalttasten,
     Key den eigentlichen Tastencode.

     Je nach aufgetretenem Ereignis werden nicht immer alle
     Felder gleichzeitig gefllt.


7.17  TGEMAttr
==============


7.18  THandle
=============

Deklaration

     THandle = longint;

Beschreibung

     THandle definiert einen generischen Handle-Typ. Wichtig:
     Unter ObjectWindows ist dieser als word deklariert!


7.19  TIconWndClass
===================


7.20  TItemList
===============

Deklaration

     PItemList = ^TItemList;
     TItemList = array [0..MaxCollectionSize-1]
                                        of pointer;

Beschreibung

     Ein Array von generischen Zeigern, die intern von
     TCollection-Objekten verwendet werden. Im Gegensatz zu
     ObjectWindows k”nnen allerdings wesentlich mehr Elemente
     gespeichert werden!

     MaxCollectionSize ist festgelegt als

     const MaxCollectionSize = 536870911;


7.21  TMenuEntries
==================


7.22  TMenuEntry
================


7.23  TMetaInfo
===============


7.24  TPaintStruct
==================

Deklaration

     PPaintStruct = ^TPaintStruct;
     TPaintStruct = record
                      fErase : boolean;
                      feColor: HBrush;
                      rcPaint: GRECT
                    end;

Beschreibung

     Diese Struktur wird von TWindow.WMRedraw ausgefllt und von
     TWindow.Paint ausgewertet.

     fErase gibt an, ob der Fensterhintergrund vor dem Aufruf der
     Paint-methode gel”scht wurde (d.h. Class.hbrBackground ist
     gr”er als Null). feColor enth„lt dann die entsprechende
     Farbe.

     rcPaint ist das wohl wichtigste Feld, in ihm wird n„mlich
     der neu zu zeichnende Bereich bergeben.


7.25  TPicResult
================


7.26  TRsFile
=============

Deklaration

     PRsFile = ^TRsFile;
     TRsFile = record
                 case boolean of
                   false: (rsh: RSHDR);
                   true:  (rsd: array [0..65535] of byte)
               end;

Beschreibung

     Mit diesem Record kann entweder komfortabel auf den Header
     einer Resource-Datei oder aber auf jedes einzelne Byte
     dieser Datei zugegriffen werden. Der Header ist in der Unit
     Gem folgendermaen deklariert:

     RSHDRPtr = ^RSHDR;
     RSHDR    = record
                  rsh_vrsn   : word;
                  rsh_object : word;
                  rsh_tedinfo: word;
                  rsh_iconblk: word;
                  rsh_bitblk : word;
                  rsh_frstr  : word;
                  rsh_string : word;
                  rsh_imdata : word;
                  rsh_frimg  : word;
                  rsh_trindex: word;
                  rsh_nobs   : word;
                  rsh_ntree  : word;
                  rsh_nted   : word;
                  rsh_nib    : word;
                  rsh_nbb    : word;
                  rsh_nstring: word;
                  rsh_nimages: word;
                  rsh_rssize : word
                end;

     Die Struktur wird ObjectGEM-intern verwendet und braucht
     normalerweise anderweitig nicht verwendet werden.


7.27  TScrollBarTransferRec
===========================

Deklaration

     PScrollBarTransferRec = ^TScrollBarTransferRec;
     TScrollBarTransferRec = record
                               LowValue : longint;
                               HighValue: longint;
                               Position : longint
                             end;

Beschreibung

     Speichert den Bereich und die Position einer Bildlaufleiste
     (Slider). Wird fr den Datentransfermechanismus verwendet.


7.28  TWindowAttr
=================


7.29  TWndClass
===============


7.30  TWordArray
================

Deklaration

     PWordArray = ^TWordArray;
     TWordArray = array [0..1073741822] of word;

Beschreibung

     Ein universeller Word-Array-Typ; kann z.B. zum Typecasting
     bei Pointern verwendet werden.


7.31  TXAccAttr
===============

Deklaration

     PXAccAttr = ^TXAccAttr;
     TXAccAttr = record
       Version,
       MsgGroups,
       Protocol   : byte;
       AppTypeMR  : TAppTypeMR; (s.u.)
       AppTypeHR,
       ExtFeatures,
       GenericName,
       Name       : PString;
       apID,
       menuID     : integer;
       AVSrvMsg,
       AVAccMsg   : word;
       pXDSC      : PChar
     end;

Beschreibung

     Enth„lt die Beschreibung einer Applikation mit allen fr das
     XAcc-Protokoll wichtigen Daten. Version bezeichnet die
     Programmversion und kann beliebig gesetzt werden. MsgGroups
     enth„lt eine Bitmap der verstandenen XAcc-Message-Groups.
     Bit 0 entspricht Gruppe 1 und umfat die Messages ACC_TEXT
     und ACC_KEY. Bit 1 entspricht Gruppe 2 mit den Messages
     ACC_META und ACC_IMG. Protocol ist eine Bitmap der
     untersttzten Protokolle, z.Z. k”nnen PROTO_XACC (Bit 0) und
     PROTO_AV (Bit 1) eingetragen sein.

     In Name ist der (XAcc-)Name des Programms gespeichert, der
     nichts mit dem Dateinamen zu tun haben mu! apID und menuID
     geben AES-Kennung und die Nummer des Desk-Meneintrags an.

     AppTypeMR gibt den maschinenlesbaren Programmtyp an (s.u.),
     AppTypeHR den dazugeh”rigen "menschenlesbaren". Wenn
     AppTypeHR nicht angegeben ist, versucht ObjectGEM diesen aus
     AppTypeMR zu ermitteln.

     ExtFeatures enth„lt zus„tzliche Eigenschaften einer Applika-
     tion. Diese sind nicht genormt und k”nnen daher nur von
     Programmen ausgewertet werden, die sich gegenseitig
     "kennen".

     GenericName gibt den sog. generischen Namen einer Applikati-
     on an. Dieser kann z.B. dann gesetzt werden, wenn Programme
     mit gleicher Funktionalit„t verschiedene Namen benutzen,
     aber irgendwie als zusammengeh”rig erkannt werden mssen.

     pXDSC ist ein Zeiger auf die "Extended names" einer Applika-
     tion. Die Auswertung ist aber nur dann n”tig, wenn mehr als
     ein "extended feature" ben”tigt wird, da ObjectGEM nur das
     erste Feature in ExtFeatures eintr„gt. Der genaue XDSC-
     Aufbau ist in der XAcc-Dokumentation beschrieben. Wenn keine
     "Extended names" vorhanden sind, ist pXDSC nil!

     Folgende maschinenlesbaren Programmtypen sind bisher
     definiert:


                 +----+----------------------------+
                 | WP | Textverarbeitung           |
                 +----+----------------------------+
                 | DP | DTP                        |
                 +----+----------------------------+
                 | ED | Texteditor                 |
                 +----+----------------------------+
                 | DB | Datenbank                  |
                 +----+----------------------------+
                 | SS | Tabellenkalkulation        |
                 +----+----------------------------+
                 | RG | Rastergrafikprogramm       |
                 +----+----------------------------+
                 | VG | Vektorgrafikprogramm       |
                 +----+----------------------------+
                 | GG | allgemeines Grafikprogramm |
                 +----+----------------------------+
                 | MU | Musikanwendung             |
                 +----+----------------------------+
                 | CD | CAD                        |
                 +----+----------------------------+
                 | DC | Datenkommunikation         |
                 +----+----------------------------+
                 | DT | Desktop                    |
                 +----+----------------------------+
                 | PE | Programmierumgebung        |
                 +----+----------------------------+

     AVSrvMsg und AVAccMsg werden fr Applikationen benutzt, die
     das AV-Protokoll untersttzen. Je nachdem, ob der Record den
     Server oder ein anderes AV-Accessory beschreibt, ist der
     jeweils andere Wert Null. Die Bits in AVSrvMsg haben
     folgende Bedeutung (gesetztes Bit=Message wird verstanden):


             +------+----------------------------------+
             |    1 | AV_SENDKEY                       |
             +------+----------------------------------+
             |    2 | AV_ASKFILEFONT                   |
             +------+----------------------------------+
             |    4 | AV_ASKCONFONT, AV_OPENCONSOLE    |
             +------+----------------------------------+
             |    8 | AV_ASKOBJECT                     |
             +------+----------------------------------+
             |   16 | AV_OPENWIND                      |
             +------+----------------------------------+
             |   32 | AV_STARTPROG                     |
             +------+----------------------------------+
             |   64 | AV_ACCWINDOPEN, AV_ACCWINDCLOSED |
             +------+----------------------------------+
             |  128 | AV_STATUS, AV_GETSTATUS          |
             +------+----------------------------------+
             |  256 | AV_COPY_DRAGGED                  |
             +------+----------------------------------+
             |  512 | AV_PATH_UPDATE, AV_WHAT_IZIT,    |
             |      | AV_DRAG_ON_WINDOW                |
             +------+----------------------------------+
             | 1024 | AV_EXIT                          |
             +------+----------------------------------+

     Die Bits in AVAccMsg bedeuten folgendes:


                         +---+--------------+
                         | 1 | VA_SETSTATUS |
                         +---+--------------+
                         | 2 | VA_START     |
                         +---+--------------+

     Wenn eine Applikation nur das AV-Protokoll untersttzt,
     werden die XAcc-spezifischen Parameter ausgenullt; wenn
     beide Protokolle vorhanden sind, haben die Werte des XAcc-
     Protokolls Priorit„t (z.B. der Name).

     TAppTypeMR ist definiert als

     type PAppTypeMR = ^TAppTypeMR;
          TAppTypeMR = string[2];


7.32  WordRec
=============

Deklaration

     PWordRec = ^WordRec;
     WordRec  = record
                  Hi,Lo: byte
                end;

Beschreibung

     Ein Hilfs-Record, der den Zugriff auf das h”her- und
     niederwertige Byte eines words erm”glicht.


7.33  XBRA
==========

Deklaration

     PXBRA = ^XBRA;
     XBRA  = record
               xb_magic : array [0..3] of char;
               xb_id    : array [0..3] of char;
               xb_oldvec: pointer
             end;

Beschreibung

     Speicherresidente, vektorverbiegende Programme setzen das
     sog. XBRA-Verfahren ein, um z.B. doppelte Installationen zu
     verhindern oder sich wieder deinstallieren zu k”nnen.

     GEM-Applikationen werten diese Struktur, die unmittelbar vor
     der neuen Adresse des verbogenen Vektors zu finden ist, -
     wenn berhaupt - nur aus.

     xb_magic mu die Zeichenkette "XBRA" ($58425241) enthalten.
     xb_id enth„lt die Kennung des verbiegenden Programms, die
     aus "druckbaren" ASCII-Zeichen bestehen sollte. In xb_oldvec
     schlielich ist der alte Vektor gespeichert.



8  Units
********


8.1  Objects
============

   ù TObject

   ù TCollection

   ù TSortedCollection

   ù TStrCollection

   ù TStringCollection


8.2  ODB
========

   ù TXBase


8.3  ODialogs
=============

   ù TCheckBox

   ù TComboBox

   ù TGroupBox

   ù TRadioButton

   ù TScrollBar

   ù TTriState


8.4  OProcs
===========

Die Unit OProcs enth„lt die meisten der unter "Prozeduren und
Funktionen" aufgefhrten Routinen.


8.5  OStdDlgs
=============

Die Unit OStdDlgs wird demn„chst die Objekte TFileDialog, TColorDialog
und TFontDialog enthalten. Im Moment sind diese aber noch nicht
effektiv gemacht.


8.6  OStdWnds
=============

   ù TTextWindow

Die Objekte TEditWindow, TFileWindow, THelpWindow und
TIndicatorWindow, die auch zu dieser Unit geh”ren, sind im Moment noch
nicht effektiv gemacht.


8.7  OTypes
===========

   ù Konstanten

   ù Records

   ù Typen


8.8  OValidat
=============

   ù TFilterValidator

   ù TLookupValidator

   ù TPXPictureValidator

   ù TRangeValidator

   ù TStringLookupValidator


8.9  OWindows
=============

   ù TApplication

   ù TButton

   ù TClipboard

   ù TControl

   ù TDialog

   ù TEdit

   ù TEvent

   ù TEventObject

   ù TIcon

   ù TKey

   ù TKeyMenu

   ù TMenu

   ù TPopup

   ù TScroller

   ù TStatic

   ù TToolbar

   ù TValidator

   ù TWindow

Die Unit OWindows enth„lt auerdem einige der unter "Prozeduren und
Funktionen" aufgefhrten Routinen, zus„tzlich noch die Variablen.



9  Variablen
************


9.1  Application
================

Deklaration

     var Application: PApplication;

Beschreibung

     Application ist zun„chst mit nil initialisiert und wird von
     TApplication.Init mit @self besetzt, d.h. zur Laufzeit zeigt
     der Pointer immer auf das aktive (und einzige)
     TApplication-Objekt.

     Normalerweise wird mit dieser Variable von anderen Objekten
     auf die TApplication-Methoden zugegriffen, z.B.
     Application^.Alert.


9.2  pxya
=========

Deklaration

     var pxya: ptsin_ARRAY;

Beschreibung

     pxya ist ein integer-Array, das z.B. fr VDI- und AES-
     Aufrufe tempor„r genutzt werden kann. Nach dem Aufruf
     irgendeiner ObjectGEM-Routine kann sich der Inhalt ge„ndert
     haben!


9.3  SysInfo
============

Deklaration

     var SysInfo: record               (nur lesen)
           BGDefCol,
           SFHeight,
           SFWidth : integer;
           Desktop : GRECT
         end;

Beschreibung

     BGDefCol gibt den Farbindex des Dialoghintergrunds an; wird
     erst ab AES 3.40 verwendet und ist normalerweise LWhite (8).

     SFHeight und SFWidth geben die H”he und Breite des groen
     Systemfonts in Pixel an.

     In Desktop werden die mit GetDesk ermittelten Ausmae des
     Desktop-Hintergrunds eingetragen. Alle Werte werden von
     TApplication.Init gesetzt.




A  Kontakt
**********


Thomas Much, Gerwigstrae 46, D-76131 Karlsruhe, Germany

Fax:   +49 / (0)721 / 62 28 21

EMail: Thomas Much @ KA2                 (MausNet)
       Thomas_Much@ka2.maus.de
       Thomas.Much@stud.uni-karlsruhe.de (Internet)

WWW:   http://www.uni-karlsruhe.de/~Thomas.Much/OGEM
       http://wwwrzstud.rz.uni-karlsruhe.de/~uk48/OGEM/index.html

(siehe auch "Updates")



B  Dank
*******

Ein besonderer Dank geht an

   ù G”tz Hoffart fr so ziemlich alle Dokus zu meinen Programmen
     (abgesehen von dieser ;-)

   ù Jan Pilgenr”der fr seine "ObjectGEM 1.20 Programmiereinfhrung"

   ù delta labs (Whiteline) fr die Vermarktung von ObjectGEM bis
     Version 1.20

   ù ASH/PureSoftware fr PurePascal

   ù Dirk Hagedorn fr UDO6



C  Literatur
************

   ù Bertrand Meyer, "Objektorientierte Softwareentwicklung", Hanser,
     Wien; Prentice Hall, London (1990)

   ù Jankowski, Rabich, Reschke, "Atari Profibuch", 10. Auflage,
     SYBEX, Dsseldorf (1992)

   ù Scott Sanders, "The Atari Compendium", SDS Publishing (1993)

   ù Dieter Gei, Jrgen Gei, "Vom Anf„nger zum GEM-Profi", Hthig
     Buch Verlag, Heidelberg (1990)

   ù Sven Behne, Wilfried Behne, "NVDI-Dokumentation", BELA

   ù Hendricks, Herzlinger, Pittelkow, "Das Buch zum Atari Falcon030",
     1. Auflage, Data Becker, Dsseldorf (1992)

   ù B„r, Bauder, "Windows 3.1 intern", 1. Auflage, Data Becker,
     Dsseldorf (1992)

   ù Ertl, Machholz, "TurboPascal fr Windows - ObjectWindows", SYBEX,
     Dsseldorf (1992)

   ù BorlandPascal 7.0, "ObjectWindows Programmierhandbuch", Borland
     (1992)

   ù Borland C++ 4.0, "ObjectWindows Referenzhandbuch", Borland (1993)

   ù Paradox 4.0, "PAL-Programmierhandbuch", Borland (1992)

   ù Gnter Born, "Referenzhandbuch Dateiformate", 2. Auflage,
     Addison-Wesley, Bonn (1992)

   ù Gnter Born, "Dateiformate Programmierhandbuch", Addison-Wesley,
     Bonn (1993)

   ù Graham, Knuth, Patashnik, "Concrete Mathematics", 7. Auflage,
     Addison-Wesley (1991)

   ù Hermann Engesser (Hrsg.), "Duden Informatik", 2. Auflage,
     Dudenverlag, Mannheim (1993)

   ù Douglas Adams, Per Anhalter durch die Galaxis; Das Restaurant am
     Ende des Universums; Das Leben, das Universum und der ganze Rest;
     Macht's gut und danke fr den Fisch; Dirk Gently's Holistische
     Detektei; Der lange, dunkle Fnfuhrtee der Seele; The Hitch
     Hiker's Guide to the Galaxy; The Restaurant at the End of the
     Universe; Life, the Universe and Everything; So Long, and Thanks
     for all the Fish; Mostly Harmless; Dirk Gently's holistic
     Detective Agency; The long dark Tea-Time of the Soul; The Meaning
     of Liff

   ù Adrian, Temming, Vollers, "Das Teebuch", VMA Verlag, Wiesbaden
     (1989)

   ù Walker, "Red Label", John Walker & Sons, Kilmarnock

   ù Camouflage, "Bodega Bohemia", Metronome (1993)

   ù Tori Amos, "Under the Pink", eastwest (1994)

   ù New Order, "Republic", CentreDate (1993)



UDO6
****

                    Dieser Text wurde erzeugt mit

                                 UDO
                        Release 6 Patchlevel 5
                                 TOS

                  Copyright (c) 1995, 1996, 1997 by
                            Dirk Hagedorn
                            Postfach 8105
                           D-59840 Sundern
                    E-Mail: DHagedorn@t-online.de

 UDO ist ein Programm, welches Textdateien, die im Universal Document
Format erstellt wurden, in das ASCII-, ST-Guide-, LaTeX-, Rich Text-,
Pure-C-Help-, Manualpage-, HTML-, WinHelp-, Texinfo-, Linuxdoc-SGML-,
 LyX-, Apple-QuickView- und Turbo-Vision-Help-Format umwandeln kann.

  Weitere Informationen sowie die aktuellen Versionen findet man im
                         World Wide Web unter
                   http://members.aol.com/DirkHage




