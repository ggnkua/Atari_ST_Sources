Oulu, Finland 1.1.-89                Kari Alakuijala (C) (Copyright)

Chapter II   -SOFTWARE SUPPORT


      This port is supported by ST. To the programmer it is similar to MIDI,
      but much slower in sending greater amounts of data.
        In ST-basic this port can be read from port inp(3) and status from
      inp(-3). The original RS-232 is inp(1), when the keyboard is inp(2).
        Use the VT-52 terminal programme "MIDITERM.TOS" to test drive the
      2nd RS-232 interface. Miditerm.c shows some programming 'examples' to
      use with language C.
        The sending and receiving from this port is similar to sending and
      receiving MIDI or RS -data. Also the transmit/receive buffers are
      provided by the bios. Even the speed control is provided by bios. The
      only thing that is missing is the (DCD/)DTR -control and the word lenght
      & parity control over the interface. These can be achieved by poking the
      values directly into registers on ACIA 6850. Enter the supervisor -mode
      (see your language manual on this) and alter the settings on the MIDI
      ACIA - CONTROL REGISTER found on $FFFC04 (this register is 8-bit). If
      you want to alter 2nd RS -speed, do it with multi function peripheral
      MFP68901 and the till now unused timer A of it.



      2nd RS speed is changed by timer A of MFP68901. See your language manual
      on how to do it. For example (using language C):

        Xbtimer (0, 1, n, -1);

        where:
        -Number 0 stands for timer A of four timers selected.
        -Number 1 stands for a control register value of 1.
        -N is frequency divider. 2nd RS-232 speed is 2.4576 MHz/(2*4*n*16).
        -N must be between 0 and 255.
        -When n is zero it must be replaced by 256 in speed formula.
        -(-1 is an interrupt vector. Not used here.)
        -According to this information the speed can be varied between
         75 bps (n=0) and 19200 bps (n=1).

      Speed change can also be achieved by poking the values direcly into
      their memory locations (in supervisor -mode):

        -The control register value $01 (hex) must be poked into memory
         location $FFFA19 (control register of timer A). When control
         register value is $00 (default) the timer doesn't run.

        -The divider value ($00 - $FF hex) must be poked into memory
         location $FFFA1F (timer A data register). Look at the 2nd RS-232
         speed achieved -formula, which is 15 rows above.



      CONTROL REGISTER (at $FFFC04) on midi chip 6850 according to Motorola's
      datasheets. There are many unimportant bits described:


      bit 1    bit 0     description/purpose
      -----    -----     -------------------
        0        0        RX/TX clock rate/1  (don't use, for synchronous only)
        0        1       >RX/TX clock rate/16 (don't care)
        1        0        RX/TX clock rate/64 (don't care)
        1        1        Reset               (don't care)

      >) default. The RS-232 speed is changed by timer A. At the beginning
         of this memory map -list there was a description of TIMER A on the
         multi function peripheral 68901. Change the speed from there, not
         here.


      bit 4    bit 3   bit 2    description/purpose
      -----    -----   -----    -------------------
        0        0       0       7E2 (7 databits, even parity, 2 stopbits)
        0        0       1       7O2 (odd parity)
        0        1       0       7E1 (1 stopbits)
        0        1       1       7O1
        1        0       0       8N2 (8 databits, no parity, 2 stopbits)
        1        0       1      >8N1 (This is the most usual on BBSes)
        1        1       0       8E1 (even parity)
        1        1       1       8O1 (odd parity)

      >) default (and mostly used).


      bit 6    bit 5     description/purpose
      -----    -----     -------------------
        0        0       >DTR  low,  transmitter IRQ off
        0        1        DTR  low,  transmitter IRQ on
        1        0        DTR* high, transmitter IRQ off
        1        1        DTR  low,  transmitter IRQ off. Sends BREAK.

      *) When you put DTR high and back low again, the caller will be logged
         off. DTR must be LOW (= default), if you want your modem to answer
         incoming calls. DTR must also be connected to modem to enable auto
         answer.

      >) default (auto answer enabled in default position).


      bit 7     description/purpose
      -----     -------------------
        0        Receiver interrupt disabled (used to silence the port)
        1       >Receiver interrupt enabled.

      >) default.


      The same register can also be read from. When read, it is called
      the STATUS REGISTER (i.e. the memory location is the same as the
      one of the control registers). Again THERE ARE MANY UNIMPORTANT
      BITS described to the interested reader:

      bit 0: when RXD register is full, this bit is set. (don't care,
             bios will handle)

      bit 1: when TXD register is empty this register is set. (don't care,
             bios will handle this)


      bit 2: a low -high -transition at DCD sets this input (however, this
             input can't be used, since a low-high transition causes also
             an interrupt and jams ST totally until a character is received 
             via MIDI or 2ND RS port).
             YOU CAN ALSO DETECT THE INCOMING CALLER BY CHECKING THE STATUS
             OF THE RECEIVER BUFFER OF THE MIDI INTERFACE.

      bit 3: status of CTS (not used in this circuit, don't care)

      bit 4: show frame error. (sets when incorrect amount of stop bits.
             Usually, don't care...)

      bit 5: Sets if you forgot to read characters from rx data buffer
             (overrun). (don't care, reading is handled by bios)

      bit 6: Sets on parity error. Usually (when word= 8N1) don't care.

      bit 7: Sets on interrupt. With a help of this line you can connect N
             SERIAL PORTS to your ST (N>>2). Just place N pieces of 6850's
             into different memory locations and hook them into same interrupt
             line. On IRQ, poll the 6850's through and check whether this bit
             is set. You will have to write a new interrupt driver for this.
             Also, the serial ports should each have a buffer of at least 2k,
             since the ST's processing capasity is pulled to the limits when
             there are many users using one ST. There won't become a circuitry
             for this from me, because I am normally using an Intel ?86 based
             computer, sorry. (For standard users: don't care neither about
             bit #7, nor any other of those seven above.)



      DATA REGISTER (you can read and write this) is at $FFFC06. This
      register contains the received data and when you write into it, you
      "send" data. You must, of course, check, that it's empty before trying
      to send something. Normally you don't need to get involved with this
      memory location, but just in case you want to write a new interrupt
      driver for the second RS-232 interface, so it's there for you.
      Width 8 bits. (Standard sysops/users: don't care about this memory
      location, bios will handle it.)


                          -     -     -



There is a Multi_User_BBS -software, GURFF_ST done by my brother utilizing
circuitry described here. It will be available in major BBSes after about
6-12 (?) months of hard (??) programming. Also the C sources of that BBS
will be tried to make available. The programme will be made so small in
size, that there can be 3 USERS ON A STANDARD 1040 ST; also 3 programmes
running simultaneously under MT C -shell (that is UN*X like C shell, a PD
multitasking environment). Also a quick hard disk (faster than the 65ms
SH204 or SH205) is recommended. On a 520 ST three simultaneous users is
a problem. You with a 520 ST should build the 1 MB memory expansion
IMMEDIATELY :-)
      When this document was released (1.1.-89) Noitarumpu_BBS using the
test version of GURFF_ST only had one telephone line, because one costs
about $850 here in Oulu.

      However, we can test drive GURFF on three sessions, since we have a test
terminal attached to the second RS -port. You can try to tell the sysop at
Noitarumpu_BBS to hurry the project up a little, as long as you don't tell
him I advised you to do so.    ;-)
      Let's hope, that this software project doesn't prevent you from making
a multiuser software of your own (a real UN*X?). When you have written the
sources yourself, it's much easier to expand the software. If you make it a
Public Domain multitasking system, you can add these documents (as long as
you add the whole archive RS232-2.ARC) with no cost & permission.


