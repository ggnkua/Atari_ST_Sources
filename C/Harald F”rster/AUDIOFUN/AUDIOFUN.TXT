

                         AUDIOFUN V1.0


1. ALLGEMEINES
--------------

   Mit dem  Programm  AUDIOFUN  k”nnen  Sie  den Soundchip (PSG)
programmieren.   Interessant  ist  es  vor  allem fr Leute, die
Spiele  programmieren,  fr  diese  aber  keine  digitalisierten
Soundeffekte  benutzen wollen oder k”nnen - z.B. wegen Verbrauch
von  Speicherplatz  und/oder Rechenzeit. Der PSG ist aber leider
trotz vorhandenen Hllkurvengenerator keine Ohrenweide.
   Dieses Manko   soll   dieses   Programm  zumindest  zum  Teil
beseitigen.  Fr  jeden der drei Kan„le ist nun eine eigene (und
echte!)  ADSR-Hllkurve  sowie  diverse Effekte verfgbar. Jeder
Kanal  ist  unabh„ngig und kann beliebig gestartet oder gestoppt
werden.  Es ist allerdings nicht m”glich, ellenlanges Gedudel zu
erzeugen.  Vielmehr  kann  zu  Situationen  (Ball berhrt Bande,
Game   over   etc.)  ein  entsprechender  akustischer  Kommentar
gegeben werden.



1.1. Hardware

   Entwickelt habe  ich  dieses  Programm auf einem 1040 STE mit
Farbmonitor.   Da  es  aber  vollst„ndig in GEM eingebunden ist,
sollte  es  mit s„mtlichen Aufl”sungen ab 320x200 zurechtkommen,
egal ob bunt oder monochrom.
   Mit dem  Rechnermodell  sollte  es  eigentlich  ebenso  sein.
Voraussetzung  ist, da sowohl der TIMER_A und natrlich der PSG
vorhanden sind.
   Der Speicherbedarf  von  AUDIOFUN  ist gering und l„uft daher
auch auf kleinsten Modellen.



1.2. Public Domain

   AUDIOFUN ist  ”ffentliches Gut! Das bedeutet fr Sie, da Sie
dieses  Programm  kostenlos  benutzen,  kopieren und verschenken
k”nnen  und  sollen. Wird dieses Programm verkauft, so darf sich
der  Preis  nur  aus  dem  Kopieraufwand,  Porto  und Verpackung
zusammensetzen!
   Trotz sorgf„ltiger  Programmierung  sind  natrlich  Bugs nie
auszuschlieen.   Sollten  also  wider  erwarten  Fehlfunktionen
auftreten,  bin  ich  fr  eine  kurze  schriftliche  Mitteilung
dankbar.  Aber  auch wenn Ihnen dieses Programm nur gef„llt oder
Sie  einen  Verbesserungsvorschlag  haben,  drfen (und sollten)
Sie mir eine (Ansichts-) Karte schicken! Meine Adresse lautet:

                        Harald F”rster
                        Tnkenhagen 1
                        23552 Lbeck



                             - 1 -


                         AUDIOFUN V1.0


1.3. Zwei in Einem

   Dieses Programm  besteht  eigentlich  aus zwei Programmen. Zu
einem   ist   da  natrlich  AUDIOFUN,  welches  mit  Sozobon  C
geschrieben  wurde. Hiermit k”nnen Sie Ihre Sounddaten eingeben,
testen  und  bei  Bedarf „ndern usw. Die fertige Datei wird dann
auf Massenspeicher gesichert.
   Das zweite     Programm     ist    der    SOUNDWORKER,    der
Ausfhrgeschwindigkeit  zuliebe  mit TurboAss entwickelt. Dieses
Programm  ist  in  der von Ihnen gesicherten Datei enthalten und
kann  nun zu Ihrem Programm geladen werden, wobei es keine Rolle
spielt,    welche    Programmiersprache   Sie   verwenden.   Der
SOUNDWORKER  wird alle 20ms gestartet (Interrupt), berechnet die
Sounddaten und schreibt sie in den PSG.
   Da beide  Programme  also  unterschiedliche  Aufgaben  haben,
wird  die  Beschreibung  getrennt erfolgen: erst AUDIOFUN, damit
Sie  wissen,  wie  Sie Kl„nge einstellen und danach SOUNDWORKER,
damit Sie diese Kl„nge auch ins eigene Programm bekommen.





2. AUDIOFUN
-----------

   Nach starten    des   Programms   sollten   Sie   am   oberen
Bildschirmrand eine Menzeile sehen.



2.1. Audiofun

   Wie beim   Desktop   Zugriff   auf   die   Info-Box  und  den
Accessories.



2.2. File

   Ebenfalls kaum  ein  Unterschied  zu  anderen GEM-Programmen,
trotzdem einige Erl„uterungen.


2.2.1. New

   Es wird  eine  im Speicher stehende Datei kommplett gel”scht.
Sollte  diese  noch  ungesichert  sein,  erscheint  vorher  eine
Warnung.  Diese  Funktion  ist  nur  m”glich,  wenn  es etwas zu
l”schen gibt!




                             - 2 -


                         AUDIOFUN V1.0


2.2.2. Load...

   Eine vorher  gesicherte Datei kann wieder geladen werden. Als
Extension  habe  ich "FUN" gew„hlt, kann von Ihnen aber ge„ndert
werden.


2.2.3. Save

   Eine Datei  wird  gesichert. Diese Funktion ist erst m”glich,
wenn  ein gltiger Dateiname existiert, also nach Load oder Save
as.


2.2.4. Save as...

   Wie bei  Save  wird eine Datei gesichert, nur k”nnen Sie hier
ein  anderes Laufwerk ausw„hlen und der Datei einen Namen geben.
Diese Funktion ist erst m”glich, wenn es etwas zu sichern gibt!
   W„hlen Sie  eine  schon  vorhandene  Datei,  die  nichts  mit
AUDIOFUN   zu   tun   hat  (z.B.  DESKTOP.INF),  erscheint  eine
Fehlermeldung.


2.2.5. Save DR

   Diese Funktion  ist  fr  Sie  interessant, wenn Ihr Compiler
das  Linkformat  von  Digital  Research  versteht.  Es  wird ein
Objekt-File  gesichert,  da Sie direkt zu Ihrem Programm linken
k”nnen.
   Eine so gesicherte Datei kann nicht mehr geladen werden!


2.2.6. Quit

   Das Programm  wird  verlassen.  Eine Rckfrage gibt es nicht,
wohl aber eine Warnung im Falle einer ungesicherten Datei.



2.3. Edit

   Unter diesem  Titel  befinden  sich  alle Eintr„ge, die etwas
mit  dem  PSG  zu tun haben. Tats„chlich dienen sie aber nur zum
”ffnen  der  entsprechenden  Fenster.   Pro Eintrag kann nur ein
Fenster  ge”ffnet  werden.  Jedes  kann  getoppt, verschoben und
geschlossen werden.
   Die Einstellungen  selbst  werden  immer  im obersten Fenster
vorgenommen.  Um  etwas zu „ndern, bewegt Sie den Mauscursor auf
einen  der  Pfeile  und  bet„tigen  die linke Maustaste. Je nach
Richtung  des  Pfeils wird nun der Wert erh”ht bzw.  erniedrigt.
Bei  Zahlen mit mehr als zwei Stellen kann auch die rechte Taste


                             - 3 -


                         AUDIOFUN V1.0


benutzt  werden,  wobei statt 1 dann 10 addiert oder subtrahiert
werden.
   Bei der  Erkl„rung  der  einzelnen  Parameter  werde  ich die
m”glichen  Werte  in  eckigen Klammern angeben. Es bedeutet dann
also  [1...999],  da  s„mtliche  Einstellungen  von  1  bis 999
m”glich sind.



2.3.1. Frequency

   Dieses Fenster  ist  nach  Programmstart  schon  ge”ffnet und
eben fr die Frequenzen zust„ndig.


2.3.1.1. Channel [A...C]

   Einer der drei Kan„le A, B oder C kann gew„hlt werden.


2.3.1.2. Part [1...8]

   Zu jedem  Kanal  geh”ren  acht  Parts mit eigenen Frequenzen,
Hllkurven  und Effekten, wobei natrlich pro Kanal nur ein Part
zur  Zeit gespielt werden kann. Sie k”nnen also bis zu 24 Kl„nge
bzw. kurze Melodien eingeben.


2.3.1.3. Tempo [1...2000]

   Dieser Wert   bestimmt   die  Zeitdauer  eines  Taktes.  Jede
Einheit einer Zeitangabe hat immer die L„nge von 20ms.
   Wenn bei  Tempo  z.B.  einen  Wert von 50 steht, hat ein Takt
die L„nge von 50*20ms, also einer Sekunde.


2.3.1.4. Test

   Der eingestellte  Kanal wird gestartet und der Part gespielt.
Wenn  Sie  den Test vorzeitig abbrechen wollen, so verlassen Sie
mit dem Mauspfeil das Testfeld.


2.3.1.5. Sound [0 - 30...4095]

   Jeder Part  ist  maximal  16  Takte lang (Time 0 bis Time F).
Ein  Takt kann die Eintr„ge 30 (h”chster Ton) bis 4095 (tiefster
Ton) annehmen.
   Die 0  hat  hierbei eine besondere Bedeutung. Einerseits wird
berhaupt  kein  Ton  gespielt.  Zum anderen kann man erreichen,
da  ein Ton mehrere Takte lang ist.  Wenn Sie zum Beispiel 100,
200,  0, 0, 100 eingeben, hat der erste Ton die L„nge von Tempo,


                             - 4 -


                         AUDIOFUN V1.0


der  zweite  dagegen  die dreifache. Geben Sie nun 0, 200, 0, 0,
100  ein,  so  ist der Unterschied zum vorigen Beispiel der, da
im ersten Takt kein Ton zu h”ren ist.


2.3.1.6. Noise [0...32]

   Im Prinzip  genau  das  gleiche  wie  bei  Sound. Der Wert 32
entspricht  hier  dem  physikalischen  Wert  0 des PSG (h”chstes
Rauschen).
   Einen wichtigen  Unterschied  gibt  es  aber doch: da der PSG
nur  einen  Rauschgenerator  besitzt,  habe  ich  diesen fest an
Kanal  A  gebunden.  Mit  anderen  Worten:  Rauschen ist auf den
Kan„len B und C nicht m”glich!
   Deshalb k”nnen  Sie  die Noise-Werte auch nur ver„ndern, wenn
der Kanal A eingestellt ist.


2.3.1.7. Hinweise zu Frequency

   šberlegen Sie,  welche  Kl„nge kein Rauschen ben”tigen. Diese
legen Sie vorrangig auf die Kan„le B und C.
   Da bis  zu  drei  Ger„usche  gleichzeitig  erklingen  k”nnen,
verteilen  Sie  diese, die tats„chlich gleichzeitg oder zeitlich
kurz aufeinander vorkommen k”nnen, auf A, B und C.
   Die Ereignisse,  die  nie gleichzeitig auftreten k”nnen (z.B.
Spielstart,  neues  Level  und Game over) geh”ren alle auf einen
Kanal (etwa Part 1 bis 3 auf C).



2.3.2. Envelope

   Mit einer  Hllkurve  wird  der Lautst„rkeverlauf eines Tones
festgelegt.  Aufgrund  der  wenigen  Hllkurven des PSG habe ich
per  Software  eine  komplette  und relativ frei programmierbare
ADSR-Hllkurve  realisiert.  Im  Gegensatz zum PSG hat nun jeder
Kanal  seinen  eigenen Generator, wodurch alle Kan„le vollkommen
unabh„ngig voneinander werden.


2.3.2.1. Rand

   Dieses Feld   ist   fast   identisch  mit  dem  Testfeld.  Im
Unterschied  dazu  werden aber nicht die programmierten, sondern
zuf„llige   Frequenzen   gespielt.  Rauschen  und  alle  anderen
Parameter bleiben unver„ndert.







                             - 5 -


                         AUDIOFUN V1.0


2.3.2.2. Attack

   Der Beginn  einer  Hllkurve  ist  immer Attack. Dabei bewegt
sich  die  Lautst„rke  von  0 auf Maximum. Je nachdem, ob dieser
Anstieg  schnell  oder  langsam  abl„uft, kann man z.B Zupf- von
Streichinstrumenten unterscheiden.


2.3.2.2.1. Attack [1...999]

   Die Zeit,  nach  der  die maximale Lautst„rke erreicht werden
soll.


2.3.2.2.2. Volume [1...15]

   Die Lautst„rke,  die  nach  Beendigung  von  Attack  erreicht
werden soll.


2.3.2.3. Decay

   Wenn Sie   eine   Klaviertaste  drcken  und  diese  gedrckt
halten,  wird  der  Ton  recht  schnell  die  gr”te  Lautst„rke
erreichen   (Attack),   um   anschlieend  langsam  abzuklingen.
Hierfr ist Decay zust„ndig.


2.3.2.3.1. Decay [0...999]

   L„nge der  Decay-Phase.  Ist  dieser  Wert 0, wird kein Decay
ausgefhrt.


2.3.2.3.2. Volume [0...15]

   Lautst„rke, die  nach  Ablauf von Decay erreicht werden soll.
Beachten  Sie, da im Gegensatz zu natrlichen Instrumenten hier
die  Decay-Lautst„rke  auch  gr”er  oder  gleich der von Attack
sein kann.
   Ist die Decay-Dauer 0, wird die Lautst„rke nicht beachtet.


2.3.2.4. Sustain

   Drcken Sie  statt  einer  Klavier-  eine  Orgeltaste, ergibt
sich   ein   anderer   Lautst„rkeverlauf.   Nach  erreichen  der
maximalen  Lautst„rke bleibt diese nun nun solange konstant, bis
die Taste losgelassen wird.





                             - 6 -


                         AUDIOFUN V1.0


2.3.2.4.1. Sustain [0...999]

   Angabe, wie  lange  die  Lautst„rke  von  Attack  oder  Decay
gehalten  werden  soll.  Ist  dieser  Wert 0, wird Sustain nicht
ausgefhrt.


2.3.2.5. Release

   Noch einmal   zum   Klavier.  Wenn  Sie  diesmal  eine  Taste
drcken,  diese  aber  nach  einer kurzen Zeit wieder loslassen,
ergibt  sich  folgender  Hllkurvenverlauf:  Nach Attack beginnt
die  Decay-Phase,  wird  aber  mit dem loslassen der Taste durch
Release  ersetzt. Die Folge ist, da der Ton nicht mehr langsam,
sondern recht schnell ausklingt.


2.3.2.5.1. Release [0...999]

   Dauer, bis  die  Attack- oder Decaylautst„rke 0 erreicht. Ist
der Wert von Release 0, wird diese Funktion nicht ausgefhrt.


2.3.2.6. Hinweise zu Envelope

   Wie Sie  gesehen  haben,  lassen  sich  Hllkurventeile  auch
ausblenden.  Dadurch  mu  nicht  eine  komplette ADSR-Hllkurve
programmiert  werden,  m”glich sind auerdem: A, AD, AS, AR, ADS
sowie ADR.
   Ist die  Gesamtdauer  der Hllkurve (also A+D+S+R) l„nger als
ein  Takt,  so  gehen  die T”ne ineinander ber. Ist dagegen der
Takt l„nger, klingt das ganze abgehackt (staccato).
   Wenn ein   Ton  mehrere  Takte  h”rbar  sein  soll,  mu  die
Gesamtdauer der Hllkurve ein vielfaches von Tempo sein.
   Beim letzten  Ton  h„ngt  die Taktl„nge nicht mehr von Tempo,
sondern von der Hllkurve ab.



2.3.3. Effects

   Auch mit  einer ADSR-Hllkurve klingt der Sound vom PSG immer
noch    recht    langweilig.    Um    diesen    lebendiger   und
abwechslungsreicher  zu gestalten, stehen Ihnen hier noch einige
Effekte zur Verfgung.


2.3.3.1. Tremolo

   Die Hllkurve  wird  amplitudenmoduliert,  d.h.  der Ton wird
abwechselnd lauter und leiser.



                             - 7 -


                         AUDIOFUN V1.0


2.3.3.1.1. Speed [1...15]

   Dieser Wert      bestimmt      die     Geschwindikeit     des
Lautst„rkewechsels,  wobei  die  Werte  8  bis 14 aber identisch
sind.


2.3.3.1.2. Delay [1...2000]

   Mit dieser  Zeitangabe  k”nnen  Sie  den Einsatz des Effektes
verz”gern.  Die Angabe mu aber kleiner als Tempo sein, da sonst
der  Effekt  nicht  ausgefhrt  wird.  Wenn sich der Ton und der
Effekt  ber  mehrere  Takte erstreckt, wird die Verz”gerung nur
im ersten Takt beachtet.


2.3.3.1.3. FEDCBA9876543210

   Die Effekte  k”nnen  Sie  fr  jeden  Takt freigeben (1) oder
sperren  (0).  Diese Zeile gibt die Taktnummern an, in der Zeile
darunter  befinden  sich die dazugeh”rigen Schalter. Bewegen Sie
den  Mauspfeil  auf  die  entsprechende Ziffer und bet„tigen die
linke Taste. Aus einer 0 wird dann eine 1 und umgekehrt.


2.3.3.2. Sound Vibtrato

   Der Ton  wird  frequenzmoduliert. Hierbei pendelt die Tonh”he
periodisch um die Grunfrequenz.


2.3.3.2.1. Add [1...4095]

   Dieser Betrag wird in jedem Interrupt zur Frequenz addiert.


2.3.3.2.2. Count [1...2000]

   Ein Z„hler,  der  die  Vibratofrequenz  bestimmt.  Je  gr”er
dieser Wert ist, desto geringer die Frequenz.
   Add und  Count  stehen  in  einem engen Zusammenhang. Add=100
und  Count=1  ergeben  den  gleichen  Frequenzhub wie Add=25 und
Count=4, nur die Vibratofrequenz ist unterschiedlich.


2.3.3.3. Noise Vibrato

   Vibrato fr   den  Rauschgenerator.  Ver„nderungen  sind  nur
m”glich, wenn Kanal A eingestellt ist.





                             - 8 -


                         AUDIOFUN V1.0


2.3.3.3.1. Add [1...31]

   Gleiche Bedeutung wie bei Sound Vibrato.


2.3.3.3.2. Count [1...2000]

   Da der  Rauschgenerator im PSG nur 5 bit schmal ist, bestimmt
dieser  Eintrag nicht wie bei Sound Vibrato zusammen mit Add den
Hub.  In  diesem  Fall  wird  nur  die  Rauschfrequenz  fr  die
angegebene Zeit gehalten.


2.3.3.4. Sound Pitch Bend

   W„hrend beim  Vibrato  die Frequenz um den Grundton schwankt,
biegt dieser Effekt den Ton in nur eine Richtung.


2.3.3.4.1. Add [1...4095]

   Bestimmt, wieviel  in  jedem  Interrupt  zur Frequenz addiert
wird.  Angaben  bis  2047 ziehen den Ton nach unten, die darber
nach oben.


2.3.3.5. Noise Pitch Bend

   Pitch Bend  fr  den  Rauschgenerator.  Kann ebenfalls nur im
Kanal A ver„ndert werden.


2.3.3.5.1. Add [1...31]

   Bis 15 wird das Rauschen tiefer, sonst h”her.


2.3.3.6. Sound Legato

   Dieser letzte  Effekte ist ebenfalls zur Frequenzbeinflussung
gedacht.  Die  Tonh”he  wird  dabei  auf die des folgenden Tones
gezogen.  Bekannt  drfte  solches  von  der Geige, Posaune oder
Hawaiigitarre sein.
   Zu beachten    ist    hier,    da    dieser   Effekt   immer
zusammenh„ngend  durchgefhrt  wird.   Wenn  ein  Ton  z.B. drei
Takte    dauert,   gibt   es   mehrere   M”glichkeiten,   Legato
einzusetzen.  Es kann nur im ersten Takt erlaubt sein, wobei die
folgenden  beiden  dann  schon  die Frequenz des folgenden Tones
haben.  Auch  kann  Legato  bei  allen  drei  Takten freigegeben
werden,  dann  ist  die  nderung  langsamer.  Fast alle anderen
Kombinationen sind ebenfalls m”glich.
   Nur eines  funktioniert  in  diesem  Beispiel  nicht: Legato,


                             - 9 -


                         AUDIOFUN V1.0


kein  Legato,  Legato!  Nachdem im ersten Takt Legato ausgefhrt
wurde,  hat  der  zweite  Takt  schon  die Frequenz des n„chsten
Tones.  Im  dritten  Takt  kann also kein Legato mehr ausgefhrt
werden.
   Eine M”glichkeit  gibt  es  aber  doch.  Wenn  Sie  zu obigen
Beispiel  zus„tzlich  kein  Pitch  Bend,  Pitch Bend, kein Pitch
Bend  eingeben,  klappt  es.  Nach  dem  ersten  Legato  wird im
zweiten  Takt der Ton verbogen, im dritten Takt kann also erneut
Legato erfolgen.
   Zu guter  letzt:  beim  letzten Ton ist natrlich kein Legato
m”glich!


2.3.3.7. Hinweise zu Effects

   Alle Effekte  sind  auch  untereinander  mischbar. Allerdings
sollten  Sie  es  nicht bertreiben: Legato zusammen mit Vibrato
und Pitch Bend ist des Guten zuviel!



2.3.4. Test all

   In diesem  Fenster  k”nnen Sie alle Kan„le und Parts parallel
testen.  Gestartet  wird  ein  Part, indem der Mauspfeil auf das
entsprechende  Feld  bewegt  und  die linke Taste gedrckt wird.
M”chten  Sie  den Part vorzeitig stoppen, drcken Sie die rechte
Taste.
   Sie k”nnen  auch  -  w„hrend  ein  Part  abgearbeitet  wird -
diesen  erneut  oder  einen  anderen  starten.  Dadurch  hat Ihr
Programm   die   M”glichkeit,  immer  die  aktuellen  Ereignisse
akustisch wiederzugeben.
   W„hrend eines  Lade  -oder  Speichervorganges  wird der Sound
abgestellt.   Anschlieend  k”nnen  Sie  aber wie gewohnt weiter
testen.





3. SOUNDWORKER
--------------

   Nachdem Sie   mhsam  Ihre  Sounddaten  zusammengestellt  und
abgespeichert  haben,  sollen  Sie  jetzt erfahren, wie Sie eine
solche   Datei  in  Ihr  Programm  bekommen  und  von  dort  aus
ansprechen k”nnen.







                             - 10 -


                         AUDIOFUN V1.0


3.1. Binding und Datentypen

   Fr OMIKRON.BASIC  und  Sozobon  C  habe  ich  je ein Binding
geschrieben.  Sollten  Sie  mit einer anderen Programmiersprache
arbeiten,  ist  dieses  kein  Problem.   Schreiben  Sie sich ein
eigenes Binding oder verzichten Sie v”llig auf ein Binding.
   Die folgenden  Funktionen  sind als Deklarationen aufgefhrt,
damit  Sie  wissen,  von  welchem Datentyp die šbergabeparameter
sind.  In  OMIKRON.BASIC bedeutet ein "%" hinter einer Variable,
da  es sich um einen 16 bit Integerwert handelt, "%L" um 32 bit
Integer.
   Steht ein   "R"  vor  einer  Variable,  wird  in  dieser  der
Rckgabewert  abgelegt.   Das  "R"  darf  beim Aufruf aber nicht
angegeben werden.
   Da OMIKRON.BASIC   auf  Zeilennummern  besteht,  beginnt  das
Binding  bei  63000. Wenn eine Biblothek ebenfalls diese Nummern
benutzt, mssen Sie das Binding umnummerieren.



3.2. Deklarationen

   Mit den  folgenden  Deklarationen  k”nnen Sie den SOUNDWORKER
aus  Ihrem Programm ansprechen. Es kann sein, da Sie nicht alle
M”glichkeiten  nutzen.  In  diesem Fall streichen Sie alle nicht
ben”tigten Funktionen im Binding.


3.2.1. Load

   Eine Datei   wird   zum   Programm   geladen.  Der  ben”tigte
Speicherplatz wird dabei reserviert.

Deklaration:   Swk_Load(R Lret%, Filename$)

               int swk_load(char *filename)

  Parameter:   Dateiname

   Rckgabe:   1 bzw. TRUE  alles OK
               sonst        Fehler

   Den Rckgabewert  sollten  Sie  auf  jeden  Fall abfragen. Es
k”nnte  ja sein, da die Datei nicht gefunden wurde oder es sich
um  eine  fremde  Datei  handelt.  In diesem Fall mssen Sie Ihr
Programm mit einer Fehlermeldung abbrechen!
   Wenn Sie  Ihre  Sounddatei mit Save DR gesichert und zu Ihrem
Programm  gelinkt  haben, k”nnen Sie diese Funktion natrlich im
Binding streichen.





                             - 11 -


                         AUDIOFUN V1.0


3.2.2. Start

   Timer_A wird  gestartet.  Bevor  irgendwelche  Daten  an  den
SOUNDWORKER  bergeben  werden,  mu  diese  Funktion aufgerufen
werden!

Deklaration:   Swk_Start

               void swk_start()

  Parameter:   keine

   Rckgabe:   keine



3.2.3. Stop

   Timer_A wird   gestoppt.   Diese   Funktion   mu  immer  vor
Programmende oder laden einer anderen Datei aufgerufen werden!

Deklaration:   Swk_Stop

               void swk_stop()

  Parameter:   keine

   Rckgabe:   keine



3.2.4. Play

   Ein Kanal wird gestartet und der gewnschte Part gespielt.

Deklaration:   Swk_Start(Channel%, Part%)

               void(int channel, int part)

  Parameter:   Kanalnummer 0 bis 2 fr Kan„le A bis C
               Partnummer +/- 1 bis 8 (negativ fr zuf„llige
                                                 Frequenzen)

   Rckgabe:   keine

   Bei einer    ungltigen    Partnummer    wird    der    Kanal
stummgeschaltet.







                             - 12 -


                         AUDIOFUN V1.0


3.2.5. Till

   Nicht immer   m”chte   man   alle   Takte   h”ren.   Bei  den
Zufallsfrequenzen  werden z.B.  immer alle 16 Takte benutzt. Mit
dieser  Funktion  k”nnen  Sie die Anzahl der zu spielenden Takte
vermindern.  Im  Unterschied  zum AUDIOFUN z„hlt der SOUNDWORKER
die  Takte  von  1  bis  16.  Dieser  Aufruf  mu immer vor Play
erfolgen!

Deklaration:   Swk_Till(Channel%, Last%)

               void swk_till(int channel, int last)

  Parameter:   Kanalnummer 0 bis 2 fr Kan„le A bis C
               Nummer des letzten zu spielenden Taktes

   Rckgabe:   keine


3.2.6. Exec

   In bestimmten  Situationen  kann  es sinnvoll sein, zu Beginn
eines   Taktes  eine  Aktion  auszul”sen,  z.B.  den  Bildschirm
invertieren.
   Mit diesem   Aufruf   k”nnen   Sie   die  Startadresse  einer
(kurzen!)   Routine   bergeben,   die   dieses  oder  „hnliches
ausfhrt.  Die  Routine  wird im Supervisor-Modus ausgefhrt und
mu   mit   einem   RTS   abgeschlossen  sein.  Sie  k”nnen  die
XBIOS-Funktionen,   die   mit   dem  Bildschirm  zu  tun  haben,
benutzen.  Die  Aufrufe  sollten  Sie  (Sozobon  C Programmierer
mssen,  also  auf  gar  keinen Fall OSBIND.H benutzen!) aber in
Assembler schreiben.
   Exec mu  vor  Play aufgerufen werden. Ihre Routine kann dann
aber  wieder  Exec  aufrufen. Sie k”nnten so z.B. den Bildschirm
invertieren  und  nach  einigen Takten wieder normal darstellen.
Wahlweise k”nnen Sie auch Till aufrufen.

Deklaration:   Swk_Exec(Channel%, Begin%, Routine%L)

               void swk_exec(int channel, int begin,
                                   long (*routine()))

  Parameter:   Kanalnummer 0 bis 2 fr Kan„le A bis C
               Nummer des Taktes, bei dem die Routine
                  gestartet werden soll. Bei einer  0
                  wird die Routine am Ende  des Parts
                  ausgefhrt.
               Startadresse der Routine.

   Rckgabe:   keine




                             - 13 -


                         AUDIOFUN V1.0


3.2.7. Time

   Diese Funktion  liefert  die  Nummer  des momentan gespielten
Taktes.

Deklaration:   Swk_Time(R Tret%, Channel%)

               int swk_time(int channel)

  Parameter:   Kanalnummer 0 bis 2 fr Kan„le A bis C

   Rckgabe:   Momentane Taktnummer oder 0, wenn Kanal
                  inaktiv

   Wenn Sie  gleich  nach  Play  diese Funktion aufrufen, werden
Sie  aller  Wahrscheinlichkeit nach die Partnummer erhalten, die
Sie  eben  mit  Play  bergeben  haben. Abhilfe: mindestens 20ms
warten oder folgenden Aufruf vorschalten!


3.2.8. Part

   Diese Funktion  liefert  die  Nummer  des momentan gespielten
Parts.

Deklaration:   Swk_Part(R Pret%, Channel%)

               int swk_part(int channel)

  Parameter:   Kanalnummer 0 bis 2 fr Kan„le A bis C

   Rckgabe:   Momentane Partnummer oder 0, wenn Kanal
                  inaktiv

   Part sollten  Sie  immer  vor  Time  verwenden,  um sicher zu
stellen,  da  der  Wert, den Sie erhalten, auch gltig ist. Nur
wenn  es sich um eine Partnummer handelt, ist auf die Taktnummer
verlass.
   Einzige Ausnahme:  Sie  bergeben  bei  Play  eine  ungltige
Partnummer  gr”er  255  und  fragen anschlieend die Partnummer
ab!
   Die Funktionen  Time  und Part k”nnen Sie z.B. dazu benutzen,
da  Ihr Programm bis Erreichen eines bestimmten Taktes in einer
Leerschleife  verharrt  und  somit  der Programmablauf fr diese
Zeit gestoppt wird.


3.2.9. Joy_Start

   Im SOUNDWORKER  ist auch eine Joystickabfrage integriert, die
Sie,  falls  Ihr  Programm mit dem Joystick gesteuert wird, auch
benutzen  sollten.  Damit  stellen  Sie sicher, da Ihr Programm


                             - 14 -


                         AUDIOFUN V1.0


auch unter anderen TOS-Versionen l„uft!
   Dieser Aufruf  startet  die  Abfrage.  Beachten Sie, da dann
die Maus nicht mehr abgefragt werden kann!

Deklaration:   Joy_Start

               void joy_start()

  Parameter:   keine

   Rckgabe:   keine


3.2.10. Joy_Stop

   Die Joystickabfrage  wird  beendet.  Diesen Aufruf k”nnen Sie
verwenden,  um  von  Joystick- auf Mausabfrage umzuschalten. Auf
jeden Fall mu er vor Programmende erfolgen!

Deklaration:   Joy_Stop

               void joy_stop()

  Parameter:   keine

   Rckgabe:   keine


3.2.11. Joy_Last

   Liefert den Wert des zuletzt bewegten Joysticks.

Deklaration:   Joy_Last(R Jlast%)

               int joy_last()

  Parameter:   keine

   Rckgabe:   254 fr Joystick 0 und 255 fr Joystick 1.
               Ist die Abfrage nicht eingeschaltet, erhalten
               Sie eine 0.


3.2.12. Joy_0

   Liefert momentane Stellung von Joystick 0.

Deklaration:   Joy_0(R Stick_0%)

               int joy_0()

  Parameter:   keine


                             - 15 -


                         AUDIOFUN V1.0



   Rckgabe:   Wert fr Joystick 0. Bei gedrckter Feuertaste
               um 128 erh”ht.


3.2.13. Joy_1

   Liefert momentale Stellung von Joystick 1.

Deklaration:   Joy_1(R Stick_1%)

               int joy_1()

  Parameter:   keine

   Rckgabe:   Wert fr Joystick 1. Bei gedrckter Feuertaste
               um 128 erh”ht.



3.3. Andere Sprachen

   Damit Sie   sich  Ihr  eigenes  Binding  schreiben  oder  den
SOUNDWORKER  direkt  ansprechen  k”nnen,  werde  ich  jetzt  den
prinzipiellen Aufbau einer solchen Datei beschreiben.
   Zuerst mssen  Sie  in  Ihrem  Programm (oder Binding) ein 16
bit  Integerfeld  mit  2512  Elementen einrichten, also z.B. DIM
Feld%(2512).  Anschlieend  ermitteln Sie die Anfangsadresse des
Feldes und laden Ihre Sounddatei bin„r dorthin.
   Wenn Sie  die  Datei  zu Ihrem Programm gelinkt haben, mssen
Sie   dieses   Feld  (oder  besser  noch  Struktur)  als  extern
deklarieren.    Der   Feldname   ist   _swk,   wobei   zumindest
C-Programmierer   den   Unterstrich   weglassen  mssen  (extern
swk[2512]).
   Fr die   Kommunikation   mit  dem  SOUNDWORKER  sind  einige
Feldelemente  zust„ndig, die ich nun erkl„ren werde. Dabei nehme
ich  an,  da  das  erste  Element  den Index 0 hat. Wenn in der
Sprache,  die  Sie verwenden, dieses der Index 1 ist, mssen Sie
zu den folgenden Feldangaben immer eine 1 addieren.


3.3.1. ID [Index 0 bis 8]

   In den   ersten  18  Bytes  befindet  sich  die  Dateikennung
"SOUNDWORKER  V1.0"  (ohne  G„nsefchen),  mit  zwei  Nullbytes
abgeschlossen.


3.3.2. Kanal A [Index 9]

   Um den  Kanal  A zu starten, schreiben Sie in dieses Feld die
Nummer  des  gewnschten  Parts. Ist dieser Wert negativ, werden


                             - 16 -


                         AUDIOFUN V1.0


anstelle der programmierten zuf„llige Frequenzen gespielt.
   Erlaubt sind  die  Werte  +/-  1  bis  8.  Alle anderen Werte
schalten den Kanal stumm.
   Beim lesen  erhalten  Sie  im  oberen  Byte  die Part- und im
unteren  die  Taktnummer.   Sind  diese  Werte  0, ist der Kanal
inaktiv.

       Kanal B [Index 10]
       Kanal C [Index 11]


3.3.3. Begin/Last A [Index 12]

   Nummer, ab  welchen  Takt  eine Routine gestartet oder bis zu
welchem   Takt   ein   Part   gespielt   werden  soll.  Fr  die
Entscheidung,  welche  der  beiden M”glichkeiten gltig ist, ist
der folgende Eintrag zust„ndig.
   Dieser Wert   mu  schon  vorhanden  sein,  bevor  der  Kanal
gestartet  wird!  Bei einer 0, die nicht eingetragen werden mu,
wird der Part normal zu Ende gespielt.

       Begin/Last B [Index 13]
       Begin/Last C [Index 14]


3.3.4. Routine A [Index 15 und 16]

   Startadresse der   Routine.   Die   Routine  mu  eine  kurze
Ausfhrungszeit haben, da Sie im Interrupt aufgerufen wird!
   Steht hier  eine  0,die  Sie  nicht  hineinschreiben  mssen,
interpretiert der SOUNDWORKER Begin/Last als Last.
   Es wird  also  der Part bis zum angegebenen Takt gespielt und
keine Routine aufgerufen.
   Bei einem  Wert  ungleich  0 wird dieser als Startadresse der
Routine  gewertet.   Diese  wird bei Erreichen der Taktnummer in
Begin/Last aufgerufen.

       Routine B High-Word [Index 17]
       Routine B  Low-Word [Index 18]
       Routine C High-Word [Index 19]
       Routine C  Low-Word [Index 20]


3.3.5. Joy_Last [Index 21]

   Hier steht  der  Wert  fr den zuletzt bewegten Joystick. 254
bedeutet Joystick 0 und 255 Joystick 1.







                             - 17 -


                         AUDIOFUN V1.0


3.3.6. Joy_0 [Index 22]

   Stellung von  Joystick  0.  Bei  gedrckter Feuertaste um 128
erh”ht.


3.3.7. Joy_1 [Index 23]

   Stellung von  Joystick  1.  Bei  gedrckter Feuertaste um 128
erh”ht.


3.3.8. Start/Stop

   Von den   vier   folgenden   Feldelementen   mssen  Sie  die
jeweiligen   Adressen   (also   die   absoluten   Adressen   der
Speicherpl„tze,  an denen sie sich befinden) ermitteln und diese
an Supexec (XBIOS 38) bergeben.
   Supexec ruft   eine  von  den  vier  Routinen  auf,  die  den
SOUNDWORKER  oder  die Joystickabfrage starten bzw. stoppen. Sie
sollten  diese  Routinen  nur  mit  Supexec  aufrufen, da einige
Registerinhalte   ver„ndert  werden  und  die  Routinen  nur  im
Supervisor-Modus funktionieren!


3.3.8.1. Swk_Start [Index 24]

   Der Timer_A  wird  gestartet  und daduch der SOUNDWORKER alle
20ms   aufgerufen.    Bevor   Sie  also  irgend  etwas  mit  dem
SOUNDWORKER anfangen k”nnen, mu der TIMER gestartet werden!


3.3.8.2. Swk_Stop [Index 26]

   Der Timer  wird  gestoppt. Dieses mssen Sie vor Programmende
immer machen!


3.3.8.3. Joy_Start [Index 28]

   Die Joystickabfrage  wird eingeschaltet. Das Arbeiten mit der
Maus ist dann nicht mehr m”glich!


3.3.8.4. Joy_Stop [Index 30]

   Die Joystickabfrage    wird   abgeschaltet.   Ebenfalls   vor
Programmende nicht vergessen!






                             - 18 -

