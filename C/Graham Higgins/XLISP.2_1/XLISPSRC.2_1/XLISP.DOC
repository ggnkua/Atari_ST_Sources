





                         XLISP: An Object-oriented Lisp

                                  Version 2.0

                                February 6, 1988


                                       by
                               David Michael Betz
                                127 Taylor Road
                             Peterborough, NH 03458

                             (603) 924-6936 (home)
                             (603) 882-1599 (BBS)

                   Copyright (c) 1988, by David Michael Betz
                              All Rights Reserved
           Permission is granted for unrestricted non-commercial use













































        XLISP                  TABLE OF CONTENTS                  Page 2


                               Table of Contents


                TABLE OF CONTENTS                        2

                INTRODUCTION                             4

                A NOTE FROM THE AUTHOR                   5

                XLISP COMMAND LOOP                       6

                BREAK COMMAND LOOP                       7

                DATA TYPES                               8

                THE EVALUATOR                            9

                LEXICAL CONVENTIONS                     10

                READTABLES                              11

                LAMBDA LISTS                            12

                OBJECTS                                 14

                SYMBOLS                                 17

                EVALUATION FUNCTIONS                    18

                SYMBOL FUNCTIONS                        19

                PROPERTY LIST FUNCTIONS                 21

                ARRAY FUNCTIONS                         22

                LIST FUNCTIONS                          23

                DESTRUCTIVE LIST FUNCTIONS              26

                PREDICATE FUNCTIONS                     27

                CONTROL CONSTRUCTS                      29

                LOOPING CONSTRUCTS                      31

                THE PROGRAM FEATURE                     32

                DEBUGGING AND ERROR HANDLING            33

                ARITHMETIC FUNCTIONS                    34

                BITWISE LOGICAL FUNCTIONS               36

                STRING FUNCTIONS                        37









        XLISP                  TABLE OF CONTENTS                  Page 3


                CHARACTER FUNCTIONS                     39

                INPUT/OUTPUT FUNCTIONS                  41

                THE FORMAT FUNCTION                     42

                FILE I/O FUNCTIONS                      43

                STRING STREAM FUNCTIONS                 44

                SYSTEM FUNCTIONS                        45

                EXAMPLES                                47


















































        XLISP                     INTRODUCTION                    Page 4


        INTRODUCTION

        XLISP is an experimental programming language combining some of
        the features of Common Lisp with an object-oriented extension
        capability.  It was implemented to allow experimentation with
        object-oriented programming on small computers.

        There are currently implementations of XLISP running on the IBM-
        PC and clones under MS-DOS, on the Macintosh, the Atari-ST and
        the Amiga.  It is completely written in the programming language
        'C' and is easily extended with user written built-in functions
        and classes.  It is available in source form to non-commercial
        users.

        Many Common Lisp functions are built into XLISP.  In addition,
        XLISP defines the objects 'Object' and 'Class' as primitives.
        'Object' is the only class that has no superclass and hence is
        the root of the class heirarchy tree.  'Class' is the class of
        which all classes are instances (it is the only object that is
        an instance of itself).

        This document is a brief description of XLISP.  It assumes some
        knowledge of LISP and some understanding of the concepts of
        object-oriented programming.

        I recommend the book "LISP" by Winston and Horn and published by
        Addison Wesley for learning Lisp.  The first edition of this
        book is based on MacLisp and the second edition is based on
        Common Lisp.  XLISP will continue to migrate towards
        compatibility with Common Lisp.

        You will probably also need a copy of "Common Lisp: The
        Language" by Guy L. Steele, Jr., published by Digital Press to
        use as a reference for some of the Common Lisp functions that
        are described only briefly in this document.




























        XLISP                A NOTE FROM THE AUTHOR               Page 5


        A NOTE FROM THE AUTHOR

        If you have any problems with XLISP, feel free to contact me for
        help or advice.  Please remember that since XLISP is available
        in source form in a high level language, many users have been
        making versions available on a variety of machines.  If you call
        to report a problem with a specific version, I may not be able
        to help you if that version runs on a machine to which I don't
        have access.  Please have the version number of the version that
        you are running readily accessible before calling me.

        If you find a bug in XLISP, first try to fix the bug yourself
        using the source code provided.  If you are successful in fixing
        the bug, send the bug report along with the fix to me.  If you
        don't have access to a C compiler or are unable to fix a bug,
        please send the bug report to me and I'll try to fix it.

        Any suggestions for improvements will be welcomed.  Feel free to
        extend the language in whatever way suits your needs.  However,
        PLEASE DO NOT RELEASE ENHANCED VERSIONS WITHOUT CHECKING WITH ME
        FIRST!!  I would like to be the clearing house for new features
        added to XLISP.  If you want to add features for your own
        personal use, go ahead.  But, if you want to distribute your
        enhanced version, contact me first.  Please remember that the
        goal of XLISP is to provide a language to learn and experiment
        with LISP and object-oriented programming on small computers.  I
        don't want it to get so big that it requires megabytes of memory
        to run.



































        XLISP                 XLISP COMMAND LOOP                  Page 6


        XLISP COMMAND LOOP

        When XLISP is started, it first tries to load the workspace
        "xlisp.wks" from the current directory.  If that file doesn't
        exist, XLISP builds an initial workspace, empty except for the
        built-in functions and symbols.

        Then XLISP attempts to load "init.lsp" from the current
        directory.  It then loads any files named as parameters on the
        command line (after appending ".lsp" to their names).

        XLISP then issues the following prompt:

        >

        This indicates that XLISP is waiting for an expression to be
        typed.

        When a complete expression has been entered, XLISP attempts to
        evaluate that expression.  If the expression evaluates
        successfully, XLISP prints the result and then returns to the
        initial prompt waiting for another expression to be typed.









































        XLISP                 BREAK COMMAND LOOP                  Page 7


        BREAK COMMAND LOOP

        When XLISP encounters an error while evaluating an expression,
        it attempts to handle the error in the following way:

        If the symbol '*breakenable*' is true, the message corresponding
        to the error is printed.  If the error is correctable, the
        correction message is printed.

        If the symbol '*tracenable*' is true, a trace back is printed.
        The number of entries printed depends on the value of the symbol
        '*tracelimit*'.  If this symbol is set to something other than a
        number, the entire trace back stack is printed.

        XLISP then enters a read/eval/print loop to allow the user to
        examine the state of the interpreter in the context of the
        error.  This loop differs from the normal top-level
        read/eval/print loop in that if the user invokes the function
        'continue', XLISP will continue from a correctable error.  If
        the user invokes the function 'clean-up', XLISP will abort the
        break loop and return to the top level or the next lower
        numbered break loop.  When in a break loop, XLISP prefixes the
        break level to the normal prompt.

        If the symbol '*breakenable*' is nil, XLISP looks for a
        surrounding errset function.  If one is found, XLISP examines
        the value of the print flag.  If this flag is true, the error
        message is printed.  In any case, XLISP causes the errset
        function call to return nil.

        If there is no surrounding errset function, XLISP prints the
        error message and returns to the top level.































        XLISP                      DATA TYPES                     Page 8


        DATA TYPES

        There are several different data types available to XLISP
        programmers.

            o lists
            o symbols
            o strings
            o integers
            o characters
            o floats
            o objects
            o arrays
            o streams
            o subrs (built-in functions)
            o fsubrs (special forms)
            o closures (user defined functions)














































        XLISP                    THE EVALUATOR                    Page 9


        THE EVALUATOR

        The process of evaluation in XLISP:

        Strings, integers, characters, floats, objects, arrays, streams,
        subrs, fsubrs and closures evaluate to themselves.

        Symbols act as variables and are evaluated by retrieving the
        value associated with their current binding.

        Lists are evaluated by examining the first element of the list
        and then taking one of the following actions:

            If it is a symbol, the functional binding of the symbol is
            retrieved.

            If it is a lambda expression, a closure is constructed for
            the function described by the lambda expression.

            If it is a subr, fsubr or closure, it stands for itself.

            Any other value is an error.

        Then, the value produced by the previous step is examined:

            If it is a subr or closure, the remaining list elements are
            evaluated and the subr or closure is called with these
            evaluated expressions as arguments.

            If it is an fsubr, the fsubr is called using the remaining
            list elements as arguments (unevaluated).

            If it is a macro, the macro is expanded using the remaining
            list elements as arguments (unevaluated).  The macro
            expansion is then evaluated in place of the original macro
            call.



























        XLISP                 LEXICAL CONVENTIONS                Page 10


        LEXICAL CONVENTIONS

        The following conventions must be followed when entering XLISP
        programs:

        Comments in XLISP code begin with a semi-colon character and
        continue to the end of the line.

        Symbol names in XLISP can consist of any sequence of non-blank
        printable characters except the following:

                ( ) ' ` , " ;

        Uppercase and lowercase characters are not distinguished within
        symbol names.  All lowercase characters are mapped to uppercase
        on input.

        Integer literals consist of a sequence of digits optionally
        beginning with a '+' or '-'.  The range of values an integer can
        represent is limited by the size of a C 'long' on the machine on
        which XLISP is running.

        Floating point literals consist of a sequence of digits
        optionally beginning with a '+' or '-' and including an embedded
        decimal point.  The range of values a floating point number can
        represent is limited by the size of a C 'float' ('double' on
        machines with 32 bit addresses) on the machine on which XLISP is
        running.

        Literal strings are sequences of characters surrounded by double
        quotes.  Within quoted strings the '\' character is used to
        allow non-printable characters to be included.  The codes
        recognized are:

                \\        means the character '\'
                \n       means newline
                \t       means tab
                \r       means return
                \f       means form feed
                \nnn     means the character whose octal code is nnn























        XLISP                      READTABLES                    Page 11


        READTABLES

        The behaviour of the reader is controlled by a data structure
        called a "readtable".  The reader uses the symbol *READTABLE* to
        locate the current readtable.  This table controls the
        interpretation of input characters.  It is an array with 128
        entries, one for each of the ASCII character codes.  Each entry
        contains one of the following things:

                NIL             Indicating an invalid character
                :CONSTITUENT    Indicating a symbol constituent
                :WHITE-SPACE    Indicating a whitespace character
                (:TMACRO . fun) Terminating readmacro
                (:NMACRO . fun) Non-terminating readmacro
                :SESCAPE        Single escape character ('\')
                :MESCAPE        Multiple escape character ('|')

        In the case of :TMACRO and :NMACRO, the "fun" component is a
        function.  This can either be a built-in readmacro function or a
        lambda expression.  The function should take two parameters.
        The first is the input stream and the second is the character
        that caused the invocation of the readmacro.  The readmacro
        function should return NIL to indicate that the character should
        be treated as white space or a value consed with NIL to indicate
        that the readmacro should be treated as an occurance of the
        specified value.  Of course, the readmacro code is free to read
        additional characters from the input stream.

        XLISP defines several useful read macros:

                '<expr>         == (quote <expr>)
                #'<expr>        == (function <expr>)
                #(<expr>...)    == an array of the specified expressions
                #x<hdigits>     == a hexadecimal number (0-9,A-F)
                #o<odigits>     == an octal number (0-7)
                #b<bdigits>     == a binary number (0-1)
                #\<char> == the ASCII code of the character
                #| ... |#       == a comment
                #:<symbol>      == an uninterned symbol
                `<expr>         == (backquote <expr>)
                ,<expr>         == (comma <expr>)
                ,@<expr>        == (comma-at <expr>)





















        XLISP                     LAMBDA LISTS                   Page 12


        LAMBDA LISTS

        There are several forms in XLISP that require that a "lambda
        list" be specified.  A lambda list is a definition of the
        arguments accepted by a function.  There are four different
        types of arguments.

        The lambda list starts with required arguments.  Required
        arguments must be specified in every call to the function.

        The required arguments are followed by the &optional arguments.
        Optional arguments may be provided or omitted in a call.  An
        initialization expression may be specified to provide a default
        value for an &optional argument if it is omitted from a call.
        If no initialization expression is specified, an omitted
        argument is initialized to NIL.  It is also possible to provide
        the name of a 'supplied-p' variable that can be used to
        determine if a call provided a value for the argument or if the
        initialization expression was used.  If specified, the supplied-
        p variable will be bound to T if a value was specified in the
        call and NIL if the default value was used.

        The &optional arguments are followed by the &rest argument.  The
        &rest argument gets bound to the remainder of the argument list
        after the required and &optional arguments have been removed.

        The &rest argument is followed by the &key arguments.  When a
        keyword argument is passed to a function, a pair of values
        appears in the argument list.  The first expression in the pair
        should evaluate to a keyword symbol (a symbol that begins with a
        ':').  The value of the second expression is the value of the
        keyword argument.  Like &optional arguments, &key arguments can
        have initialization expressions and supplied-p variables.  In
        addition, it is possible to specify the keyword to be used in a
        function call.  If no keyword is specified, the keyword obtained
        by adding a ':' to the beginning of the keyword argument symbol
        is used.  In other words, if the keyword argument symbol is
        'foo', the keyword will be ':foo'.

        The &key arguments are followed by the &aux variables.  These
        are local variables that are bound during the evaluation of the
        function body.  It is possible to have initialization
        expressions for the &aux variables.




















        XLISP                     LAMBDA LISTS                   Page 13


        Here is the complete syntax for lambda lists:

                (<rarg>...
                 [&optional [<oarg> | (<oarg> [<init> [<svar>]])]...]
                 [&rest <rarg>]
                 [&key
                   [<karg> | ([<karg> | (<key> <karg>)] [<init> [<svar>]])]...
                   &allow-other-keys]
                 [&aux
                   [<aux> | (<aux> [<init>])]...])

            where:

                <rarg>  is a required argument symbol
                <oarg>  is an &optional argument symbol
                <rarg>  is the &rest argument symbol
                <karg>  is a &key argument symbol
                <key>   is a keyword symbol
                <aux>   is an auxiliary variable symbol
                <init>  is an initialization expression
                <svar>  is a supplied-p variable symbol










































        XLISP                       OBJECTS                      Page 14


        OBJECTS

        Definitions:

            o selector - a symbol used to select an appropriate method
            o message - a selector and a list of actual arguments
            o method - the code that implements a message

        Since XLISP was created to provide a simple basis for
        experimenting with object-oriented programming, one of the
        primitive data types included is 'object'.  In XLISP, an object
        consists of a data structure containing a pointer to the
        object's class as well as an array containing the values of the
        object's instance variables.

        Officially, there is no way to see inside an object (look at the
        values of its instance variables).  The only way to communicate
        with an object is by sending it a message.

        You can send a message to an object using the 'send' function.
        This function takes the object as its first argument, the
        message selector as its second argument (which must be a symbol)
        and the message arguments as its remaining arguments.

        The 'send' function determines the class of the receiving object
        and attempts to find a method corresponding to the message
        selector in the set of messages defined for that class.  If the
        message is not found in the object's class and the class has a
        super-class, the search continues by looking at the messages
        defined for the super-class.  This process continues from one
        super-class to the next until a method for the message is found.
        If no method is found, an error occurs.

        A message can also be sent from the body of a method by using
        the current object, but the method lookup starts with the
        object's superclass rather than its class.  This allows a
        subclass to invoke a standard method in its parent class even
        though it overrides that method with its own specialized
        version.

        When a method is found, the evaluator binds the receiving object
        to the symbol 'self' and evaluates the method using the
        remaining elements of the original list as arguments to the
        method.  These arguments are always evaluated prior to being
        bound to their corresponding formal arguments.  The result of
        evaluating the method becomes the result of the expression.

















        XLISP                       OBJECTS                      Page 15


        THE 'Object' CLASS

        Classes:

        Object  THE TOP OF THE CLASS HEIRARCHY

            Messages:

                :show  SHOW AN OBJECT'S INSTANCE VARIABLES
                    returns     the object

                :class  RETURN THE CLASS OF AN OBJECT
                    returns     the class of the object

                :isnew  THE DEFAULT OBJECT INITIALIZATION ROUTINE
                    returns     the object

                :sendsuper <sel> <args>...  SEND SUPERCLASS A MESSAGE
                    <sel>       the message selector
                    <args>      the message arguments
                    returns     the result of sending the message










































        XLISP                       OBJECTS                      Page 16


        THE 'Class' CLASS

        Class   THE CLASS OF ALL OBJECT CLASSES (including itself)

            Messages:

                :new  CREATE A NEW INSTANCE OF A CLASS
                    returns     the new class object

                :isnew <ivars> [<cvars> [<super>]]  INITIALIZE A NEW CLASS
                    <ivars>     the list of instance variable symbols
                    <cvars>     the list of class variable symbols
                    <super>     the superclass (default is Object)
                    returns     the new class object

                :answer <msg> <fargs> <code>  ADD A MESSAGE TO A CLASS
                    <msg>       the message symbol
                    <fargs>     the formal argument list (lambda list)
                    <code>      a list of executable expressions
                    returns     the object


        When a new instance of a class is created by sending the message
        ':new' to an existing class, the message ':isnew' followed by
        whatever parameters were passed to the ':new' message is sent to
        the newly created object.

        When a new class is created by sending the ':new' message to the
        object 'Class', an optional parameter may be specified
        indicating the superclass of the new class.  If this parameter
        is omitted, the new class will be a subclass of 'Object'.  A
        class inherits all instance variables, class variables, and
        methods from its super-class.






























        XLISP                       SYMBOLS                      Page 17


        SYMBOLS

            o self - the current object (within a method context)
            o *obarray* - the object hash table
            o *standard-input* - the standard input stream
            o *standard-output* - the standard output stream
            o *error-output* - the error output stream
            o *trace-output* - the trace output stream
            o *debug-io* - the debug i/o stream
            o *breakenable* - flag controlling entering break loop on errors
            o *tracelist* - list of names of functions to trace
            o *tracenable* - enable trace back printout on errors
            o *tracelimit* - number of levels of trace back information
            o *evalhook* - user substitute for the evaluator function
            o *applyhook* - (not yet implemented)
            o *readtable* - the current readtable
            o *unbound* - indicator for unbound symbols
            o *gc-flag* - controls the printing of gc messages
            o *gc-hook* - function to call after garbage collection
            o *integer-format* - format for printing integers ("%d" or "%ld")
            o *float-format* - format for printing floats ("%g")
            o *print-case* - symbol output case (:upcase or :downcase)

        There are several symbols maintained by the read/eval/print
        loop.  The symbols '+', '++', and '+++' are bound to the most
        recent three input expressions.  The symbols '*', '**' and '***'
        are bound to the most recent three results.  The symbol '-' is
        bound to the expression currently being evaluated.  It becomes
        the value of '+' at the end of the evaluation.


































        XLISP                 EVALUATION FUNCTIONS               Page 18


        EVALUATION FUNCTIONS

        (eval <expr>)  EVALUATE AN XLISP EXPRESSION
            <expr>      the expression to be evaluated
            returns     the result of evaluating the expression

        (apply <fun> <args>)  APPLY A FUNCTION TO A LIST OF ARGUMENTS
            <fun>       the function to apply (or function symbol)
            <args>      the argument list
            returns     the result of applying the function to the arguments

        (funcall <fun> <arg>...)  CALL A FUNCTION WITH ARGUMENTS
            <fun>       the function to call (or function symbol)
            <arg>       arguments to pass to the function
            returns     the result of calling the function with the arguments

        (quote <expr>)  RETURN AN EXPRESSION UNEVALUATED
            <expr>      the expression to be quoted (quoted)
            returns     <expr> unevaluated

        (function <expr>)  GET THE FUNCTIONAL INTERPRETATION
            <expr>      the symbol or lambda expression (quoted)
            returns     the functional interpretation

        (backquote <expr>)  FILL IN A TEMPLATE
            <expr>      the template
            returns     a copy of the template with comma and comma-at
                        expressions expanded

        (lambda <args> <expr>...)  MAKE A FUNCTION CLOSURE
            <args>      formal argument list (lambda list) (quoted)
            <expr>      expressions of the function body
            returns     the function closure

        (get-lambda-expression <closure>)  GET THE LAMBDA EXPRESSION
            <closure>   the closure
            returns     the original lambda expression

        (macroexpand <form>)  RECURSIVELY EXPAND MACRO CALLS
            <form>      the form to expand
            returns     the macro expansion

        (macroexpand-1 <form>)  EXPAND A MACRO CALL
            <form>      the macro call form
            returns     the macro expansion


















        XLISP                   SYMBOL FUNCTIONS                 Page 19


        SYMBOL FUNCTIONS

        (set <sym> <expr>)  SET THE VALUE OF A SYMBOL
            <sym>       the symbol being set
            <expr>      the new value
            returns     the new value

        (setq [<sym> <expr>]...)  SET THE VALUE OF A SYMBOL
            <sym>       the symbol being set (quoted)
            <expr>      the new value
            returns     the new value

        (psetq [<sym> <expr>]...)  PARALLEL VERSION OF SETQ
            <sym>       the symbol being set (quoted)
            <expr>      the new value
            returns     the new value

        (setf [<place> <expr>]...)  SET THE VALUE OF A FIELD
            <place>     the field specifier (quoted):
                          <sym>                   set value of a symbol
                          (car <expr>)            set car of a cons node
                          (cdr <expr>)            set cdr of a cons node
                          (nth <n> <expr>)        set nth car of a list
                          (aref <expr> <n>)       set nth element of an array
                          (get <sym> <prop>)      set value of a property
                          (symbol-value <sym>)    set value of a symbol
                          (symbol-function <sym>) set functional value of a symbol
                          (symbol-plist <sym>)    set property list of a symbol
            <value>     the new value
            returns     the new value

        (defun <sym> <fargs> <expr>...)  DEFINE A FUNCTION
        (defmacro <sym> <fargs> <expr>...)  DEFINE A MACRO
            <sym>       symbol being defined (quoted)
            <fargs>     formal argument list (lambda list) (quoted)
            <expr>      expressions constituting the body of the
                        function (quoted)
            returns     the function symbol

        (gensym [<tag>])  GENERATE A SYMBOL
            <tag>       string or number
            returns     the new symbol

        (intern <pname>)  MAKE AN INTERNED SYMBOL
            <pname>     the symbol's print name string
            returns     the new symbol

        (make-symbol <pname>)  MAKE AN UNINTERNED SYMBOL
            <pname>     the symbol's print name string
            returns     the new symbol

        (symbol-name <sym>)  GET THE PRINT NAME OF A SYMBOL
            <sym>       the symbol
            returns     the symbol's print name









        XLISP                   SYMBOL FUNCTIONS                 Page 20


        (symbol-value <sym>)  GET THE VALUE OF A SYMBOL
            <sym>       the symbol
            returns     the symbol's value

        (symbol-function <sym>)  GET THE FUNCTIONAL VALUE OF A SYMBOL
            <sym>       the symbol
            returns     the symbol's functional value

        (symbol-plist <sym>)  GET THE PROPERTY LIST OF A SYMBOL
            <sym>       the symbol
            returns     the symbol's property list

        (hash <sym> <n>)  COMPUTE THE HASH INDEX FOR A SYMBOL
            <sym>       the symbol or string
            <n>         the table size (integer)
            returns     the hash index (integer)















































        XLISP               PROPERTY LIST FUNCTIONS              Page 21


        PROPERTY LIST FUNCTIONS

        (get <sym> <prop>)  GET THE VALUE OF A PROPERTY
            <sym>       the symbol
            <prop>      the property symbol
            returns     the property value or nil

        (putprop <sym> <val> <prop>)  PUT A PROPERTY ONTO A PROPERTY LIST
            <sym>       the symbol
            <val>       the property value
            <prop>      the property symbol
            returns     the property value

        (remprop <sym> <prop>)  REMOVE A PROPERTY
            <sym>       the symbol
            <prop>      the property symbol
            returns     nil














































        XLISP                   ARRAY FUNCTIONS                  Page 22


        ARRAY FUNCTIONS

        (aref <array> <n>)  GET THE NTH ELEMENT OF AN ARRAY
            <array>     the array
            <n>         the array index (integer)
            returns     the value of the array element

        (make-array <size>)  MAKE A NEW ARRAY
            <size>      the size of the new array (integer)
            returns     the new array

        (vector <expr>...)  MAKE AN INITIALIZED VECTOR
            <expr>      the vector elements
            returns     the new vector

















































        XLISP                    LIST FUNCTIONS                  Page 23


        LIST FUNCTIONS

        (car <expr>)  RETURN THE CAR OF A LIST NODE
            <expr>      the list node
            returns     the car of the list node

        (cdr <expr>)  RETURN THE CDR OF A LIST NODE
            <expr>      the list node
            returns     the cdr of the list node

        (cxxr <expr>)  ALL CxxR COMBINATIONS
        (cxxxr <expr>)  ALL CxxxR COMBINATIONS
        (cxxxxr <expr>)  ALL CxxxxR COMBINATIONS

        (first <expr>)   A SYNONYM FOR CAR
        (second <expr>)  A SYNONYM FOR CADR
        (third <expr>)   A SYNONYM FOR CADDR
        (fourth <expr>)  A SYNONYM FOR CADDDR
        (rest <expr>)    A SYNONYM FOR CDR

        (cons <expr1> <expr2>)  CONSTRUCT A NEW LIST NODE
            <expr1>     the car of the new list node
            <expr2>     the cdr of the new list node
            returns     the new list node

        (list <expr>...)  CREATE A LIST OF VALUES
            <expr>      expressions to be combined into a list
            returns     the new list

        (append <expr>...)  APPEND LISTS
            <expr>      lists whose elements are to be appended
            returns     the new list

        (reverse <expr>)  REVERSE A LIST
            <expr>      the list to reverse
            returns     a new list in the reverse order

        (last <list>)  RETURN THE LAST LIST NODE OF A LIST
            <list>      the list
            returns     the last list node in the list

        (member <expr> <list> &key :test :test-not)  FIND AN EXPRESSION IN A LIST
            <expr>      the expression to find
            <list>      the list to search
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     the remainder of the list starting with the expression

        (assoc <expr> <alist> &key :test :test-not)  FIND AN EXPRESSION IN AN A-LIST
            <expr>      the expression to find
            <alist>     the association list
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     the alist entry or nil









        XLISP                    LIST FUNCTIONS                  Page 24


        (remove <expr> <list> &key :test :test-not)  REMOVE ELEMENTS FROM A LIST
            <expr>      the element to remove
            <list>      the list
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     copy of list with matching expressions removed

        (remove-if <test> <list>)  REMOVE ELEMENTS THAT PASS TEST
            <test>      the test predicate
            <list>      the list
            returns     copy of list with matching elements removed

        (remove-if-not <test> <list>)  REMOVE ELEMENTS THAT FAIL TEST
            <test>      the test predicate
            <list>      the list
            returns     copy of list with non-matching elements removed

        (length <expr>)  FIND THE LENGTH OF A LIST, VECTOR OR STRING
            <expr>      the list, vector or string
            returns     the length of the list, vector or string

        (nth <n> <list>)  RETURN THE NTH ELEMENT OF A LIST
            <n>         the number of the element to return (zero origin)
            <list>      the list
            returns     the nth element or nil if the list isn't that long

        (nthcdr <n> <list>)  RETURN THE NTH CDR OF A LIST
            <n>         the number of the element to return (zero origin)
            <list>      the list
            returns     the nth cdr or nil if the list isn't that long

        (mapc <fcn> <list1> <list>...)  APPLY FUNCTION TO SUCCESSIVE CARS
            <fcn>       the function or function name
            <listn>     a list for each argument of the function
            returns     the first list of arguments

        (mapcar <fcn> <list1> <list>...)  APPLY FUNCTION TO SUCCESSIVE CARS
            <fcn>       the function or function name
            <listn>     a list for each argument of the function
            returns     a list of the values returned

        (mapl <fcn> <list1> <list>...)  APPLY FUNCTION TO SUCCESSIVE CDRS
            <fcn>       the function or function name
            <listn>     a list for each argument of the function
            returns     the first list of arguments

        (maplist <fcn> <list1> <list>...)  APPLY FUNCTION TO SUCCESSIVE CDRS
            <fcn>       the function or function name
            <listn>     a list for each argument of the function
            returns     a list of the values returned













        XLISP                    LIST FUNCTIONS                  Page 25


        (subst <to> <from> <expr> &key :test :test-not)  SUBSTITUTE EXPRESSIONS
            <to>        the new expression
            <from>      the old expression
            <expr>      the expression in which to do the substitutions
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     the expression with substitutions

        (sublis <alist> <expr> &key :test :test-not)  SUBSTITUTE WITH AN A-LIST
            <alist>     the association list
            <expr>      the expression in which to do the substitutions
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     the expression with substitutions








        XLISP              DESTRUCTIVE LIST FUNCTIONS            Page 26


        DESTRUCTIVE LIST FUNCTIONS

        (rplaca <list> <expr>)  REPLACE THE CAR OF A LIST NODE
            <list>      the list node
            <expr>      the new value for the car of the list node
            returns     the list node after updating the car

        (rplacd <list> <expr>)  REPLACE THE CDR OF A LIST NODE
            <list>      the list node
            <expr>      the new value for the cdr of the list node
            returns     the list node after updating the cdr

        (nconc <list>...)  DESTRUCTIVELY CONCATENATE LISTS
            <list>      lists to concatenate
            returns     the result of concatenating the lists

        (delete <expr> &key :test :test-not)  DELETE ELEMENTS FROM A LIST
            <expr>      the element to delete
            <list>      the list
            :test       the test function (defaults to eql)
            :test-not   the test function (sense inverted)      
            returns     the list with the matching expressions deleted

        (delete-if <test> <list>)  DELETE ELEMENTS THAT PASS TEST
            <test>      the test predicate
            <list>      the list
            returns     the list with matching elements deleted

        (delete-if-not <test> <list>)  DELETE ELEMENTS THAT FAIL TEST
            <test>      the test predicate
            <list>      the list
            returns     the list with non-matching elements deleted

        (sort <list> <test>)  SORT A LIST
            <list>      the list to sort
            <test>      the comparison function
            returns     the sorted list


























        XLISP                 PREDICATE FUNCTIONS                Page 27


        PREDICATE FUNCTIONS

        (atom <expr>)  IS THIS AN ATOM?
            <expr>      the expression to check
            returns     t if the value is an atom, nil otherwise

        (symbolp <expr>)  IS THIS A SYMBOL?
            <expr>      the expression to check
            returns     t if the expression is a symbol, nil otherwise

        (numberp <expr>)  IS THIS A NUMBER?
            <expr>      the expression to check
            returns     t if the expression is a number, nil otherwise

        (null <expr>)  IS THIS AN EMPTY LIST?
            <expr>      the list to check
            returns     t if the list is empty, nil otherwise

        (not <expr>)  IS THIS FALSE?
            <expr>      the expression to check
            return      t if the value is nil, nil otherwise

        (listp <expr>)  IS THIS A LIST?
            <expr>      the expression to check
            returns     t if the value is a cons or nil, nil otherwise

        (endp <list>)  IS THIS THE END OF A LIST
            <list>      the list
            returns     t if the value is nil, nil otherwise

        (consp <expr>)  IS THIS A NON-EMPTY LIST?
            <expr>      the expression to check
            returns     t if the value is a cons, nil otherwise

        (integerp <expr>)  IS THIS AN INTEGER?
            <expr>      the expression to check
            returns     t if the value is an integer, nil otherwise

        (floatp <expr>)  IS THIS A FLOAT?
            <expr>      the expression to check
            returns     t if the value is a float, nil otherwise

        (stringp <expr>)  IS THIS A STRING?
            <expr>      the expression to check
            returns     t if the value is a string, nil otherwise

        (characterp <expr>)  IS THIS A CHARACTER?
            <expr>      the expression to check
            returns     t if the value is a character, nil otherwise

        (arrayp <expr>)  IS THIS AN ARRAY?
            <expr>      the expression to check
            returns     t if the value is an array, nil otherwise










        XLISP                 PREDICATE FUNCTIONS                Page 28


        (streamp <expr>)  IS THIS A STREAM?
            <expr>      the expression to check
            returns     t if the value is a stream, nil otherwise

        (objectp <expr>)  IS THIS AN OBJECT?
            <expr>      the expression to check
            returns     t if the value is an object, nil otherwise

        (boundp <sym>)  IS A VALUE BOUND TO THIS SYMBOL?
            <sym>       the symbol
            returns     t if a value is bound to the symbol, nil otherwise

        (fboundp <sym>)  IS A FUNCTIONAL VALUE BOUND TO THIS SYMBOL?
            <sym>       the symbol
            returns     t if a functional value is bound to the symbol,
                        nil otherwise

        (minusp <expr>)  IS THIS NUMBER NEGATIVE?
            <expr>      the number to test
            returns     t if the number is negative, nil otherwise

        (zerop <expr>)  IS THIS NUMBER ZERO?
            <expr>      the number to test
            returns     t if the number is zero, nil otherwise

        (plusp <expr>)  IS THIS NUMBER POSITIVE?
            <expr>      the number to test
            returns     t if the number is positive, nil otherwise

        (evenp <expr>)  IS THIS INTEGER EVEN?
            <expr>      the integer to test
            returns     t if the integer is even, nil otherwise

        (oddp <expr>)  IS THIS INTEGER ODD?
            <expr>      the integer to test
            returns     t if the integer is odd, nil otherwise

        (eq <expr1> <expr2>)  ARE THE EXPRESSIONS IDENTICAL?
            <expr1>     the first expression
            <expr2>     the second expression
            returns     t if they are equal, nil otherwise

        (eql <expr1> <expr2>)  ARE THE EXPRESSIONS IDENTICAL?
                                (WORKS WITH ALL NUMBERS)
            <expr1>     the first expression
            <expr2>     the second expression
            returns     t if they are equal, nil otherwise

        (equal <expr1> <expr2>)  ARE THE EXPRESSIONS EQUAL?
            <expr1>     the first expression
            <expr2>     the second expression
            returns     t if they are equal, nil otherwise











        XLISP                  CONTROL CONSTRUCTS                Page 29


        CONTROL CONSTRUCTS

        (cond <pair>...)  EVALUATE CONDITIONALLY
            <pair>      pair consisting of:
                            (<pred> <expr>...)
                          where
                            <pred>      is a predicate expression
                            <expr>      evaluated if the predicate
                                        is not nil
            returns     the value of the first expression whose predicate
                        is not nil

        (and <expr>...)  THE LOGICAL AND OF A LIST OF EXPRESSIONS
            <expr>      the expressions to be ANDed
            returns     nil if any expression evaluates to nil,
                        otherwise the value of the last expression
                        (evaluation of expressions stops after the first
                         expression that evaluates to nil)

        (or <expr>...)  THE LOGICAL OR OF A LIST OF EXPRESSIONS
            <expr>      the expressions to be ORed
            returns     nil if all expressions evaluate to nil,
                        otherwise the value of the first non-nil expression
                        (evaluation of expressions stops after the first
                         expression that does not evaluate to nil)

        (if <texpr> <expr1> [<expr2>])  EVALUATE EXPRESSIONS CONDITIONALLY
            <texpr>     the test expression
            <expr1>     the expression to be evaluated if texpr is non-nil
            <expr2>     the expression to be evaluated if texpr is nil
            returns     the value of the selected expression

        (when <texpr> <expr>...)  EVALUATE ONLY WHEN A CONDITION IS TRUE
            <texpr>     the test expression
            <expr>      the expression(s) to be evaluted if texpr is non-nil
            returns     the value of the last expression or nil

        (unless <texpr> <expr>...)  EVALUATE ONLY WHEN A CONDITION IS FALSE
            <texpr>     the test expression
            <expr>      the expression(s) to be evaluated if texpr is nil
            returns     the value of the last expression or nil

          (case <expr> <case>...)  SELECT BY CASE
            <expr>      the selection expression
            <case>      pair consisting of:
                            (<value> <expr>...)
                          where:
                            <value>     is a single expression or a list of
                                        expressions (unevaluated)
                            <expr>      are expressions to execute if the
                                        case matches
            returns     the value of the last expression of the matching case











        XLISP                  CONTROL CONSTRUCTS                Page 30


        (let (<binding>...) <expr>...)  CREATE LOCAL BINDINGS
        (let* (<binding>...) <expr>...)  LET WITH SEQUENTIAL BINDING
            <binding>   the variable bindings each of which is either:
                        1)  a symbol (which is initialized to nil)
                        2)  a list whose car is a symbol and whose cadr
                                is an initialization expression
            <expr>      the expressions to be evaluated
            returns     the value of the last expression

        (flet (<binding>...) <expr>...)  CREATE LOCAL FUNCTIONS
        (labels (<binding>...) <expr>...)  FLET WITH RECURSIVE FUNCTIONS
        (macrolet (<binding>...) <expr>...)  CREATE LOCAL MACROS
            <binding>   the function bindings each of which is:
                          (<sym> <fargs> <expr>...)
                        where:
                            <sym>       the function/macro name
                            <fargs>     formal argument list (lambda list)
                            <expr>      expressions constituting the body of
                                        the function/macro
            <expr>      the expressions to be evaluated
            returns     the value of the last expression

        (catch <sym> <expr>...)  EVALUATE EXPRESSIONS AND CATCH THROWS
            <sym>       the catch tag
            <expr>      expressions to evaluate
            returns     the value of the last expression the throw expression

        (throw <sym> [<expr>])  THROW TO A CATCH
            <sym>       the catch tag
            <expr>      the value for the catch to return (defaults to nil)
            returns     never returns

        (unwind-protect <expr> <cexpr>...)  PROTECT EVALUATION OF AN EXPRESSION
            <expr>      the expression to protect
            <cexpr>     the cleanup expressions
            returns     the value of the expression
          Note:  unwind-protect guarantees to execute the cleanup expressions
                 even if a non-local exit terminates the evaluation of the
                 protected expression
























        XLISP                  LOOPING CONSTRUCTS                Page 31


        LOOPING CONSTRUCTS

        (loop <expr>...)  BASIC LOOPING FORM
            <expr>      the body of the loop
            returns     never returns (must use non-local exit)

        (do (<binding>...) (<texpr> <rexpr>...) <expr>...)
        (do* (<binding>...) (<texpr> <rexpr>...) <expr>...)
            <binding>   the variable bindings each of which is either:
                        1)  a symbol (which is initialized to nil)
                        2)  a list of the form: (<sym> <init> [<step>])
                            where:
                                <sym>  is the symbol to bind
                                <init> is the initial value of the symbol
                                <step> is a step expression
            <texpr>     the termination test expression
            <rexpr>     result expressions (the default is nil)
            <expr>      the body of the loop (treated like an implicit prog)
            returns     the value of the last result expression

        (dolist (<sym> <expr> [<rexpr>]) <expr>...)  LOOP THROUGH A LIST
            <sym>       the symbol to bind to each list element
            <expr>      the list expression
            <rexpr>     the result expression (the default is nil)
            <expr>      the body of the loop (treated like an implicit prog)

        (dotimes (<sym> <expr> [<rexpr>]) <expr>...)  LOOP FROM ZERO TO N-1
            <sym>       the symbol to bind to each value from 0 to n-1
            <expr>      the number of times to loop
            <rexpr>     the result expression (the default is nil)
            <expr>      the body of the loop (treated like an implicit prog)
































        XLISP                 THE PROGRAM FEATURE                Page 32


        THE PROGRAM FEATURE

        (prog (<binding>...) <expr>...)  THE PROGRAM FEATURE
        (prog* (<binding>...) <expr>...)  PROG WITH SEQUENTIAL BINDING
            <binding>   the variable bindings each of which is either:
                        1)  a symbol (which is initialized to nil)
                        2)  a list whose car is a symbol and whose cadr
                                is an initialization expression
            <expr>      expressions to evaluate or tags (symbols)
            returns     nil or the argument passed to the return function

        (block <name> <expr>...)  NAMED BLOCK
            <name>      the block name (symbol)
            <expr>      the block body
            returns     the value of the last expression

        (return [<expr>])  CAUSE A PROG CONSTRUCT TO RETURN A VALUE
            <expr>      the value (defaults to nil)
            returns     never returns

        (return-from <name> [<value>])  RETURN FROM A NAMED BLOCK
            <name>      the block name (symbol)
            <value>     the value to return (defaults to nil)
            returns     never returns

        (tagbody <expr>...)  BLOCK WITH LABELS
            <expr>      expression(s) to evaluate or tags (symbols)
            returns     nil

        (go <sym>)  GO TO A TAG WITHIN A TAGBODY OR PROG
            <sym>       the tag (quoted)
            returns     never returns

        (progv <slist> <vlist> <expr>...)  DYNAMICALLY BIND SYMBOLS
            <slist>     list of symbols
            <vlist>     list of values to bind to the symbols
            <expr>      expression(s) to evaluate
            returns     the value of the last expression

        (prog1 <expr1> <expr>...)  EXECUTE EXPRESSIONS SEQUENTIALLY
            <expr1>     the first expression to evaluate
            <expr>      the remaining expressions to evaluate
            returns     the value of the first expression

        (prog2 <expr1> <expr2> <expr>...)  EXECUTE EXPRESSIONS SEQUENTIALLY
            <expr1>     the first expression to evaluate
            <expr2>     the second expression to evaluate
            <expr>      the remaining expressions to evaluate
            returns     the value of the second expression

        (progn <expr>...)  EXECUTE EXPRESSIONS SEQUENTIALLY
            <expr>      the expressions to evaluate
            returns     the value of the last expression (or nil)










        XLISP             DEBUGGING AND ERROR HANDLING           Page 33


        DEBUGGING AND ERROR HANDLING

        (trace <sym>)  ADD A FUNCTION TO THE TRACE LIST
            <sym>       the function to add (quoted)
            returns     the trace list

        (untrace <sym>)  REMOVE A FUNCTION FROM THE TRACE LIST
            <sym>       the function to remove (quoted)
            returns     the trace list

        (error <emsg> [<arg>])  SIGNAL A NON-CORRECTABLE ERROR
            <emsg>      the error message string
            <arg>       the argument expression (printed after the message)
            returns     never returns

        (cerror <cmsg> <emsg> [<arg>])  SIGNAL A CORRECTABLE ERROR
            <cmsg>      the continue message string
            <emsg>      the error message string
            <arg>       the argument expression (printed after the message)
            returns     nil when continued from the break loop

        (break [<bmsg> [<arg>]])  ENTER A BREAK LOOP
            <bmsg>      the break message string (defaults to "**BREAK**")
            <arg>       the argument expression (printed after the message)
            returns     nil when continued from the break loop

        (clean-up)  CLEAN-UP AFTER AN ERROR
            returns     never returns

        (top-level)  CLEAN-UP AFTER AN ERROR AND RETURN TO THE TOP LEVEL
            returns     never returns

        (continue)  CONTINUE FROM A CORRECTABLE ERROR
            returns     never returns

        (errset <expr> [<pflag>])  TRAP ERRORS
            <expr>      the expression to execute
            <pflag>     flag to control printing of the error message
            returns     the value of the last expression consed with nil
                        or nil on error

        (baktrace [<n>])  PRINT N LEVELS OF TRACE BACK INFORMATION
            <n>         the number of levels (defaults to all levels)
            returns     nil

        (evalhook <expr> <ehook> <ahook> [<env>])  EVALUATE WITH HOOKS
            <expr>      the expression to evaluate
            <ehook>     the value for *evalhook*
            <ahook>     the value for *applyhook*
            <env>       the environment (default is nil)
            returns     the result of evaluating the expression












        XLISP                 ARITHMETIC FUNCTIONS               Page 34


        ARITHMETIC FUNCTIONS

        (truncate <expr>)  TRUNCATES A FLOATING POINT NUMBER TO AN INTEGER
            <expr>      the number
            returns     the result of truncating the number

        (float <expr>)  CONVERTS AN INTEGER TO A FLOATING POINT NUMBER
            <expr>      the number
            returns     the result of floating the integer

        (+ <expr>...)  ADD A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the addition

        (- <expr>...)  SUBTRACT A LIST OF NUMBERS OR NEGATE A SINGLE NUMBER
            <expr>      the numbers
            returns     the result of the subtraction

        (* <expr>...)  MULTIPLY A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the multiplication

        (/ <expr>...)  DIVIDE A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the division

        (1+ <expr>)  ADD ONE TO A NUMBER
            <expr>      the number
            returns     the number plus one

        (1- <expr>)  SUBTRACT ONE FROM A NUMBER
            <expr>      the number
            returns     the number minus one

        (rem <expr>...)  REMAINDER OF A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the remainder operation

        (min <expr>...)  THE SMALLEST OF A LIST OF NUMBERS
            <expr>      the expressions to be checked
            returns     the smallest number in the list

        (max <expr>...)  THE LARGEST OF A LIST OF NUMBERS
            <expr>      the expressions to be checked
            returns     the largest number in the list

        (abs <expr>)  THE ABSOLUTE VALUE OF A NUMBER
            <expr>      the number
            returns     the absolute value of the number

        (gcd <n1> <n2>...)  COMPUTE THE GREATEST COMMON DIVISOR
            <n1>        the first number (integer)
            <n2>        the second number(s) (integer)
            returns     the greatest common divisor









        XLISP                 ARITHMETIC FUNCTIONS               Page 35


        (random <n>)  COMPUTE A RANDOM NUMBER BETWEEN 1 and N-1
            <n>         the upper bound (integer)
            returns     a random number

        (sin <expr>)  COMPUTE THE SINE OF A NUMBER
            <expr>      the floating point number
            returns     the sine of the number

        (cos <expr>)  COMPUTE THE COSINE OF A NUMBER
            <expr>      the floating point number
            returns     the cosine of the number

        (tan <expr>)  COMPUTE THE TANGENT OF A NUMBER
            <expr>      the floating point number
            returns     the tangent of the number

        (expt <x-expr> <y-expr>)  COMPUTE X TO THE Y POWER
            <x-expr>    the floating point number
            <y-expr>    the floating point exponent
            returns     x to the y power

        (exp <x-expr>)  COMPUTE E TO THE X POWER
            <x-expr>    the floating point number
            returns     e to the x power

        (sqrt <expr>)  COMPUTE THE SQUARE ROOT OF A NUMBER
            <expr>      the floating point number
            returns     the square root of the number

        (< <n1> <n2>...)  TEST FOR LESS THAN
        (<= <n1> <n2>...)  TEST FOR LESS THAN OR EQUAL TO
        (= <n1> <n2>...)  TEST FOR EQUAL TO
        (/= <n1> <n2>...)  TEST FOR NOT EQUAL TO
        (>= <n1> <n2>...)  TEST FOR GREATER THAN OR EQUAL TO
        (> <n1> <n2>...)  TEST FOR GREATER THAN
            <n1>        the first number to compare
            <n2>        the second number to compare
            returns     the result of comparing <n1> with <n2>...

























        XLISP              BITWISE LOGICAL FUNCTIONS             Page 36


        BITWISE LOGICAL FUNCTIONS

        (logand <expr>...)  THE BITWISE AND OF A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the and operation

        (logior <expr>...)  THE BITWISE INCLUSIVE OR OF A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the inclusive or operation

        (logxor <expr>...)  THE BITWISE EXCLUSIVE OR OF A LIST OF NUMBERS
            <expr>      the numbers
            returns     the result of the exclusive or operation

        (lognot <expr>)  THE BITWISE NOT OF A NUMBER
            <expr>      the number
            returns     the bitwise inversion of number














































        XLISP                   STRING FUNCTIONS                 Page 37


        STRING FUNCTIONS

        (string <expr>)  MAKE A STRING FROM AN INTEGER ASCII VALUE
            <expr>      the integer
            returns     a one character string

        (string-trim <bag> <str>)  TRIM BOTH ENDS OF A STRING
            <bag>       a string containing characters to trim
            <str>       the string to trim
            returns     a trimed copy of the string

        (string-left-trim <bag> <str>)  TRIM THE LEFT END OF A STRING
            <bag>       a string containing characters to trim
            <str>       the string to trim
            returns     a trimed copy of the string

        (string-right-trim <bag> <str>)  TRIM THE RIGHT END OF A STRING
            <bag>       a string containing characters to trim
            <str>       the string to trim
            returns     a trimed copy of the string

        (string-upcase <str> &key :start :end)  CONVERT TO UPPERCASE
            <str>       the string
            :start      the starting offset
            :end        the ending offset + 1
            returns     a converted copy of the string

        (string-downcase <str> &key :start :end)  CONVERT TO LOWERCASE
            <str>       the string
            :start      the starting offset
            :end        the ending offset + 1
            returns     a converted copy of the string

        (nstring-upcase <str> &key :start :end)  CONVERT TO UPPERCASE
            <str>       the string
            :start      the starting offset
            :end        the ending offset + 1
            returns     the converted string (not a copy)

        (nstring-downcase <str> &key :start :end)  CONVERT TO LOWERCASE
            <str>       the string
            :start      the starting offset
            :end        the ending offset + 1
            returns     the converted string (not a copy)

        (strcat <expr>...)  CONCATENATE STRINGS
            <expr>      the strings to concatenate
            returns     the result of concatenating the strings

        (subseq <string> <start> [<end>]) EXTRACT A SUBSTRING
            <string>    the string
            <start>     the starting position (zero origin)
            <end>       the ending position + 1 (defaults to end)
            returns     substring between <start> and <end>









        XLISP                   STRING FUNCTIONS                 Page 38


        (string< <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string<= <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string= <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string/= <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string>= <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string> <str1> <str2> &key :start1 :end1 :start2 :end2)
            <str1>      the first string to compare
            <str2>      the second string to compare
            :start1     first substring starting offset
            :end1       first substring ending offset + 1
            :start2     second substring starting offset
            :end2       second substring ending offset + 1
            returns     t if predicate is true, nil otherwise
          Note: case is significant with these comparison functions.

        (string-lessp <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string-not-greaterp <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string-equalp <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string-not-equalp <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string-not-lessp <str1> <str2> &key :start1 :end1 :start2 :end2)
        (string-greaterp <str1> <str2> &key :start1 :end1 :start2 :end2)
            <str1>      the first string to compare
            <str2>      the second string to compare
            :start1     first substring starting offset
            :end1       first substring ending offset + 1
            :start2     second substring starting offset
            :end2       second substring ending offset + 1
            returns     t if predicate is true, nil otherwise
          Note: case is not significant with these comparison functions.


































        XLISP                 CHARACTER FUNCTIONS                Page 39


        CHARACTER FUNCTIONS

        (char <string> <index>)  EXTRACT A CHARACTER FROM A STRING
            <string>    the string
            <index>     the string index (zero relative)
            returns     the ascii code of the character

        (upper-case-p <chr>)  IS THIS AN UPPER CASE CHARACTER?
            <chr>       the character
            returns     true if the character is upper case, nil otherwise

        (lower-case-p <chr>)  IS THIS A LOWER CASE CHARACTER?
            <chr>       the character
            returns     true if the character is lower case, nil otherwise

        (both-case-p <chr>)  IS THIS AN ALPHABETIC (EITHER CASE) CHARACTER?
            <chr>       the character
            returns     true if the character is alphabetic, nil otherwise

        (digit-char-p <chr>)  IS THIS A DIGIT CHARACTER?
            <chr>       the character
            returns     the digit weight if character is a digit, nil otherwise

        (char-code <chr>)  GET THE ASCII CODE OF A CHARACTER
            <chr>       the character
            returns     the ASCII character code (integer)

        (code-char <code>)  GET THE CHARACTER WITH A SPECFIED ASCII CODE
            <code>      the ASCII code (integer)
            returns     the character with that code or nil

        (char-upcase <chr>)  CONVERT A CHARACTER TO UPPER CASE
            <chr>       the character
            returns     the upper case character

        (char-downcase <chr>)  CONVERT A CHARACTER TO LOWER CASE
            <chr>       the character
            returns     the lower case character

        (digit-char <n>)  CONVERT A DIGIT WEIGHT TO A DIGIT
            <n>         the digit weight (integer)
            returns     the digit character or nil

        (char-int <chr>) CONVERT A CHARACTER TO AN INTEGER
            <chr>       the character
            returns     the ASCII character code

        (int-char <int>) CONVERT AN INTEGER TO A CHARACTER
            <int>       the ASCII character code
            returns     the character with that code













        XLISP                 CHARACTER FUNCTIONS                Page 40


        (char< <chr1> <chr2>...)
        (char<= <chr1> <chr2>...)
        (char= <chr1> <chr2>...)
        (char/= <chr1> <chr2>...)
        (char>= <chr1> <chr2>...)
        (char> <chr1> <chr2>...)
            <chr1>      the first character to compare
            <chr2>      the second character(s) to compare
            returns     t if predicate is true, nil otherwise
          Note: case is significant with these comparison functions.

        (char-lessp <chr1> <chr2>...)
        (char-not-greaterp <chr1> <chr2>...)
        (char-equalp <chr1> <chr2>...)
        (char-not-equalp <chr1> <chr2>...)
        (char-not-lessp <chr1> <chr2>...)
        (char-greaterp <chr1> <chr2>...)
            <chr1>      the first string to compare
            <chr2>      the second string(s) to compare
            returns     t if predicate is true, nil otherwise
          Note: case is not significant with these comparison functions.










































        XLISP                INPUT/OUTPUT FUNCTIONS              Page 41


        INPUT/OUTPUT FUNCTIONS

        (read [<stream> [<eof> [<rflag>]]])  READ AN EXPRESSION
            <stream>    the input stream (default is standard input)
            <eof>       the value to return on end of file (default is nil)
            <rflag>     recursive read flag (default is nil)
            returns     the expression read

        (print <expr> [<stream>])  PRINT AN EXPRESSION ON A NEW LINE
            <expr>      the expression to be printed
            <stream>    the output stream (default is standard output)
            returns     the expression

        (prin1 <expr> [<stream>])  PRINT AN EXPRESSION
            <expr>      the expression to be printed
            <stream>    the output stream (default is standard output)
            returns     the expression

        (princ <expr> [<stream>])  PRINT AN EXPRESSION WITHOUT QUOTING
            <expr>      the expressions to be printed
            <stream>    the output stream (default is standard output)
            returns     the expression

        (pprint <expr> [<stream>])  PRETTY PRINT AN EXPRESSION
            <expr>      the expressions to be printed
            <stream>    the output stream (default is standard output)
            returns     the expression

        (terpri [<stream>])  TERMINATE THE CURRENT PRINT LINE
            <stream>    the output stream (default is standard output)
            returns     nil

        (flatsize <expr>)  LENGTH OF PRINTED REPRESENTATION USING PRIN1
            <expr>      the expression
            returns     the length

        (flatc <expr>)  LENGTH OF PRINTED REPRESENTATION USING PRINC
            <expr>      the expression
            returns     the length
























        XLISP                 THE FORMAT FUNCTION                Page 42


        THE FORMAT FUNCTION

        (format <stream> <fmt> <arg>...)  DO FORMATTED OUTPUT
            <stream>    the output stream
            <fmt>       the format string
            <arg>       the format arguments
            returns     output string if <stream> is nil, nil otherwise

        The format string can contain characters that should be copied
        directly to the output and formatting directives.  The
        formatting directives are:

            ~A          print next argument using princ
            ~S          print next argument using prin1
            ~%          start a new line
            ~~          print a tilde character















































        XLISP                  FILE I/O FUNCTIONS                Page 43


        FILE I/O FUNCTIONS

        (open <fname> &key :direction)  OPEN A FILE STREAM
            <fname>     the file name string or symbol
            :direction  :input or :output (default is :input)
            returns     a stream

        (close <stream>)  CLOSE A FILE STREAM
            <stream>    the stream
            returns     nil

        (read-char [<stream>])  READ A CHARACTER FROM A STREAM
            <stream>    the input stream (default is standard input)
            returns     the character

        (peek-char [<flag> [<stream>]])  PEEK AT THE NEXT CHARACTER
            <flag>      flag for skipping white space (default is nil)
            <stream>    the input stream (default is standard input)
            returns     the character (integer)

        (write-char <ch> [<stream>])  WRITE A CHARACTER TO A STREAM
            <ch>        the character to write
            <stream>    the output stream (default is standard output)
            returns     the character

        (read-line [<stream>])  READ A LINE FROM A STREAM
            <stream>    the input stream (default is standard input)
            returns     the string

        (read-byte [<stream>])  READ A BYTE FROM A STREAM
            <stream>    the input stream (default is standard input)
            returns     the byte (integer)

        (write-byte <byte> [<stream>])  WRITE A BYTE TO A STREAM
            <byte>      the byte to write (integer)
            <stream>    the output stream (default is standard output)
            returns     the byte (integer)


























        XLISP               STRING STREAM FUNCTIONS              Page 44


        STRING STREAM FUNCTIONS

        These functions operate on unnamed streams.  An unnamed output
        stream collects characters sent to it when it is used as the
        destination of any output function.  The functions 'get-output-
        stream-string' and string or a list of characters.

        An unnamed input stream is setup with the 'make-string-input-
        stream' function and returns each character of the string when
        it is used as the source of any input function.

        (make-string-input-stream <str> [<start> [<end>]])
            <str>       the string
            <start>     the starting offset
            <end>       the ending offset + 1
            returns     an unnamed stream that reads from the string

        (make-string-output-stream)
            returns     an unnamed output stream

        (get-output-stream-string <stream>)
            <stream>    the output stream
            returns     the output so far as a string
          Note:  the output stream is emptied by this function

        (get-output-stream-list <stream>)
            <stream>    the output stream
            returns     the output so far as a list
          Note:  the output stream is emptied by this function


































        XLISP                   SYSTEM FUNCTIONS                 Page 45


        SYSTEM FUNCTIONS

        (load <fname> &key :verbose :print)  LOAD A SOURCE FILE
            <fname>     the filename string or symbol
            :verbose    the verbose flag (default is t)
            :print      the print flag (default is nil)
            returns     the filename

        (save <fname>) SAVE WORKSPACE TO A FILE
            <fname>     the filename string or symbol
            returns     t if workspace was written, nil otherwise

        (restore <fname>) RESTORE WORKSPACE FROM A FILE
            <fname>     the filename string or symbol
            returns     nil on failure, otherwise never returns

        (dribble [<fname>])  CREATE A FILE WITH A TRANSCRIPT OF A SESSION
            <fname>     file name string or symbol
                        (if missing, close current transcript)
            returns     t if the transcript is opened, nil if it is closed

        (gc)  FORCE GARBAGE COLLECTION
            returns     nil

        (expand <num>)  EXPAND MEMORY BY ADDING SEGMENTS
            <num>       the number of segments to add
            returns     the number of segments added

        (alloc <num>)  CHANGE NUMBER OF NODES TO ALLOCATE IN EACH SEGMENT
            <num>       the number of nodes to allocate
            returns     the old number of nodes to allocate

        (room)  SHOW MEMORY ALLOCATION STATISTICS
            returns     nil

        (type-of <expr>)  RETURNS THE TYPE OF THE EXPRESSION
            <expr>      the expression to return the type of
            returns     nil if the value is nil otherwise one of the symbols:
                          SYMBOL          for symbols
                          OBJECT          for objects
                          CONS            for conses
                          SUBR            for built-in functions
                          FSUBR           for special forms
                          CLOSURE         for defined functions
                          STRING          for strings
                          FIXNUM          for integers
                          FLONUM          for floating point numbers
                          CHARACTER       for characters
                          FILE-STREAM     for file pointers
                          UNNAMED-STREAM  for unnamed streams
                          ARRAY           for arrays












        XLISP                   SYSTEM FUNCTIONS                 Page 46


        (peek <addrs>)  PEEK AT A LOCATION IN MEMORY
            <addrs>     the address to peek at (integer)
            returns     the value at the specified address (integer)

        (poke <addrs> <value>)  POKE A VALUE INTO MEMORY
            <addrs>     the address to poke (integer)
            <value>     the value to poke into the address (integer)
            returns     the value

        (address-of <expr>)  GET THE ADDRESS OF AN XLISP NODE
            <expr>      the node
            returns     the address of the node (integer)

        (exit)  EXIT XLISP
            returns     never returns
















































        XLISP                       EXAMPLES                     Page 47


        FILE I/O FUNCTIONS

        Input from a File

        To open a file for input, use the OPEN function with the keyword
        argument :DIRECTION set to :INPUT.  To open a file for output,
        use the OPEN function with the keyword argument :DIRECTION set
        to :OUTPUT.  The OPEN function takes a single required argument
        which is the name of the file to be opened.  This name can be in
        the form of a string or a symbol.  The OPEN function returns an
        object of type FILE-STREAM if it succeeds in opening the
        specified file.  It returns the value NIL if it fails.  In order
        to manipulate the file, it is necessary to save the value
        returned by the OPEN function.  This is usually done by
        assigning it to a variable with the SETQ special form or by
        binding it using LET or LET*.  Here is an example:

            (setq fp (open "init.lsp" :direction :input))

        Evaluating this expression will result in the file "init.lsp"
        being opened.  The file object that will be returned by the OPEN
        function will be assigned to the variable "fp".

        It is now possible to use the file for input.  To read an
        expression from the file, just supply the value of the "fp"
        variable as the optional "stream" argument to READ.

            (read fp)

        Evaluating this expression will result in reading the first
        expression from the file "init.lsp".  The expression will be
        returned as the result of the READ function.  More expressions
        can be read from the file using further calls to the READ
        function.  When there are no more expressions to read, the READ
        function will return NIL (or whatever value was supplied as the
        second argument to READ).

        Once you are done reading from the file, you should close it.
        To close the file, use the following expression:

            (close fp)

        Evaluating this expression will cause the file to be closed.




















        XLISP                       EXAMPLES                     Page 48


        Output to a File

        Writing to a file is pretty much the same as reading from one.
        You need to open the file first.  This time you should use the
        OPEN function to indicate that you will do output to the file.
        For example:

            (setq fp (open "test.dat" :direction :output))

        Evaluating this expression will open the file "test.dat" for
        output.  If the file already exists, its current contents will
        be discarded.  If it doesn't already exist, it will be created.
        In any case, a FILE-STREAM object will be returned by the OPEN
        function.  This file object will be assigned to the "fp"
        variable.

        It is now possible to write to this file by supplying the value
        of the "fp" variable as the optional "stream" parameter in the
        PRINT function.

            (print "Hello there" fp)

        Evaluating this expression will result in the string "Hello
        there" being written to the file "test.dat".  More data can be
        written to the file using the same technique.

        Once you are done writing to the file, you should close it.
        Closing an output file is just like closing an input file.

            (close fp)

        Evaluating this expression will close the output file and make
        it permanent.






























        XLISP                       EXAMPLES                     Page 49


        A Slightly More Complicated File Example

        This example shows how to open a file, read each Lisp expression
        from the file and print it.  It demonstrates the use of files
        and the use of the optional "stream" argument to the READ
        function.

            (do* ((fp (open "test.dat" :direction :input))
                  (ex (read fp) (read fp)))
                 ((null ex) nil)
              (print ex))
































































































