
        ===============================================

           OKAMI SHELL VERSION 1.0 - TIPS UND TRICKS

        ===============================================
                      Stand: 29.03.90


        BITTE ERST DIE DATEIEN README UND OKAMI.DOC LESEN!



----------------------------------------------------------------------------
PROFILE

Ich benutze das folgende Profile zum Konfigurieren der Shell im Festplatten-
betrieb.





# Okami-Shell - System-Profile

# Cursor etwas schneller blinkend
cursor +bv 12
# Aktuelles Directory im Prompt anzeigen
PS1=['$CWD'] ^^^$'  '
# Nach Ende der Shell CWD sichern
set +s

# Word Wrap On
echo ^033v

echo ^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n^n
echo 
echo ATARI 1040 STF
echo $LOGNAME Version $VERSION
echo System Profile   *   by wr 18.02.-29.03.1990
echo
# Ausgabe des Datums des letzten Logins
cat lastlog
echo
# Ausgabe des freien Speichers
mem | read a
echo Free RAM: $a Bytes
echo
# Ausgabe in invertierter Schrift
echo ^033pType help for command survey.             ^033q
echo ^033pType shinfo for installed software survey.^033q
echo

# Datum speichern
date | read a
echo Last Login: $a >lastlog

# Letztes CWD zurÅckholen
cat wdir | read a
nd $a

# Lokale Variable freigeben
a=




Durch die Einstellung "set +s" wird die Shell veranlaût, vor dem Programm-
ende das aktuelle Verzeichnis in die Datei $HOME\wdir zu schreiben. Das
Profile benutzt diese Datei, um das aktuelle Verzeichnis wieder auf den
alten Wert einzustellen. So ist man nach dem Start der Shell immer in
dem Verzeichnis, in dem man war, als man die Shell zuletzt verlassen hatte.


----------------------------------------------------------------------------
AUFRUF VON PROGRAMMEN

(Der folgende Abschnitt ist im wesentlichen fÅr Festplattenbenutzer von
Interesse.)

Viele Programme gehen davon aus, das sich gewisse Dateien wie z.B. RSCs im
aktuellen Verzeichnis befinden. Um ein solches Kommando zu starten, muû
man also mit cd in das jeweilige Verzeichnis wechseln, was unter UmstÑnden
einige Tipparbeit macht, vor allem bei einer Festplatte. Mit der Okami-
Shell ist es mîglich, Programme von Åberall, also von jedem beliebigen
aktuellen Verzeichnis aus zu starten.
Es sei z.B. GEMTEST.PRG ein Programm, das im Verzeichnis D:\PROG\GEMTEST
steht und eine RSC-Datei aus dem aktuellen Verzeichnis nachladen muû.
Zum Start des Programms mÅûte man also eingeben

cd d:\prog\gemtest
gemtest

Man kann allerdings auch so vorgehen:
Man erzeugt sich eine Datei namens GEMTEST.SH im Verzeichnis $HOME\bin,
die ungefÑhr so aussieht:


# Aufruf von gemtest

a=$CWD
cd d:\prg\gemtest
cls
cursor -v
d:\prg\gemtest\gemtest.prg
cls
cd $a
a=



Das aktuelle Verzeichnis wird in der Variablen a gespeichert. Danach erfolgt
der Wechsel in das Verzeichnis, in dem gemtest.prg enthalten ist. Es
wird der Bildschirm gelîscht und der Cursor unsichtbar gemacht, danach
wird das Programm gestartet. Nach Programmende wird der Bildschirm noch-
mals gelîscht (durch cls wird auch der Cursor wieder sichtbar), und das
aktuelle Verzeichnis wird auf den gespeicherten Wert zurÅckgesetzt. Danach
wird die lokal verwendete Shell-Variable a freigegeben.

Dadurch, daû sich dieses Shell-Script in dem Verzeichnis $HOME\bin befin-
det, kann es jederzeit durch einfache Eingabe von gemtest aufgerufen 
werden.



----------------------------------------------------------------------------
COMMAND SUBSTITUTION

In Unix kann man die Ausgabe eines Kommandos in eine Eingabe einbauen,
z.B.:

echo Es sind noch `mem` Bytes frei

Das mem-Kommando wird ausgefÅhrt, und seine Ausgabe wird anstelle von
`mem` in die Eingabe eingesetzt. Danach wird das echo-Kommando ausge-
fÅhrt, und es erscheint z.B.:

Es sind noch 865236 Bytes frei

Diese Technik wird in Unix als "Command Substitution" bezeichnet.
In der Okami-Shell ist diese Technik aufgrund der internen Programmlogik
nicht mîglich (allenfalls durch Aufruf einer Subshell), aber sie kann
simuliert werden, und zwar durch die Mîglichkeit des read-Kommandos,
Shell-Variablen von der Standard-Eingabe zu lesen. Anstelle des obigen
Beispiels wÅrde man in der Okami-Shell schreiben:

mem | read a
echo Es sind noch $a Bytes frei
a=

Man kann damit praktisch alle Vorkommnisse von Command Substitution durch
entsprechende Pipe-Read-Kombinationen ersetzen. Wichtig ist nur, daû die
verwendeten Shell-Variablen nach der Benutzung wieder freigegeben werden.



----------------------------------------------------------------------------
MICROSHELL

(Bitte vorher msh.doc lesen.)

Bei Verwendung der Microshell msh.prg blinkt der Cursor nach Ende der Shell
auf dem Desktop weiter. Dies wird verhindert durch folgende Angaben in der
Kommandodatei msh.inf:



# Microshell-Konfigurationsdatei

sh.ttp -
sh.ttp cursor -v



Durch den zweiten Aufruf von sh.ttp wird die Shell nochmals aufgerufen,
und zwar mit dem internen Kommando, das den Cursor unsichtbar macht
(cursor -v).

öberdies sollte man ab sofort als einzige Datei im Auto-Ordner nur noch
msh.prg haben und das System von der Microshell installieren lassen. Dies
hat den groûen Vorteil, daû man die Reihenfolge, in der die Programme
geladen werden, selber bestimmen kann.




----------------------------------------------------------------------------
DIVERSES

Trikolor-Bildschirm:
Durch Verwendung des Kommandos

scr -b ; cursor +bv 1

auf einem Monochrom-Bildschirm blinkt der Cursor so schnell, daû er wie eine
dritte Farbe auf dem Bildschirm wirkt. Dieser Effekt ist jedoch nur bei
dunklem Hintergrund (scr -b) deutlich sichtbar.


Aufruf vom Desktop:

Wenn man sh.ttp vom Desktop aufruft und eine Kommandozeile eingibt, die
von der Shell ausgefÅhrt werden soll, so erscheint nach der AusfÅhrung
dieser Kommandos wieder das Desktop, ohne daû der Anwender Zeit hat,
eventuelle Ausgaben zu lesen.
Um das zu verhindern, kann das read-Kommdando benutzt werden. Um z.B.
fÅr alle angemeldeten Laufwerke die Platzstatistik (mit dem Kommando
df) zu erhalten, klickt man auf sh.ttp und gibt folgende Kommando-
zeile ein:

df ; read

oder

df ; echo Taste: ; read

(Die Leerzeichen um die Strichpunkte sind nicht unbedingt notwendig).
Nach der AusfÅhrung von df wartet die Shell auf eine Eingabe (die durch
Druck auf RETURN beendet sein muû). Im zweiten Beispiel wird auûerdem
noch der Text "Taste:" ausgegeben.
