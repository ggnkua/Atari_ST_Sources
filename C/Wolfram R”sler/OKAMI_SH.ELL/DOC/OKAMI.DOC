
        ===============================================

          OKAMI SHELL VERSION 1.0 - BENUTZERANLEITUNG

        ===============================================
                      Stand: 29.03.90

        
             BITTE ERST DIE DATEI README LESEN!

----------------------------------------------------------------------------
EINFöHRUNG

Die Okami-Shell ist ein (weiterer) Versuch, auf dem Atari ST so etwas wie
Unix-GefÅhle aufkommen zu lassen. Das Programm wendet sich an alle, die
die Mîglichkeiten eines Kommandointerpreters denen des Desktops vorziehen.
Die Shell ist vor allem beim Betrieb mit einer Festplatte ausgesprochen 
nÅtzlich.

Obwohl es schon einige Programme dieser Art gibt, gibt es gewichtige GrÅnde,
die Okami-Shell zu benutzen und sich durch die folgende Anleitung zu
arbeiten.

Meines Wissens ist die Okami-Shell der erste Kommandointerpreter fÅr den
ST, der die Unix-Mîglichkeiten der Ein/Ausgabe-Umleitung und des Pipelinings
auch fÅr die internen (in der Shell eingebauten) Kommandos ermîglicht.
Die Ein/Ausgabe-Umleitung ist die Mîglichkeit, die Standard-Ausgabe eines
Programmes, d.h. alles, was mit printf etc. ausgegeben wird und normaler-
weise auf dem Bildschirm landet, sowie die Standard-Eingabe in eine Datei
oder zu einem GerÑt (z.B. zum Drucker) umzuleiten. Die Umleitung funktio-
niert unter TOS mit dem GEM-Desktop a) nur bei TTP-Programmen, weil man
nur bei diesen die Mîglichkeit hat, eine Kommandozeile einzugeben, und
b) nur bei Programmen, deren Compiler die Umleitung unterstÅtzen. Die
Umleitung der Ausgabe interner Kommandos bedeutet zusÑtzliche Programmier-
arbeit, die sich offenbar noch kein Shell-Programmierer gemacht hat (die
Gulam-Shell eingeschlossen). Dieser Umstand war der eigentliche Grund fÅr
die Entwicklung von Okami.

Bei der Programmierung einer Shell oder eines Kommandointerpreters steht
man immer vor der Frage, ob man fÅr die in der Shell eingebauten Kommandos
Unix-, MS-DOS- oder eine selbstausgedachte Schreibweise benutzen soll, 
d.h. ob man die Kommandos ls oder dir, mv oder rename, cp oder copy nennen
soll oder ob man sich eingene Kommandonamen ausdenkt. Die Okami-Shell ist
an den Unix-Bezeichnungen orientiert, genauer gesagt an dem Unix-Derivat
AIX, das z.B. auf dem IBM RT PC 6150 lÑuft. NatÅrlich mÅssen bei soetwas
Abstriche gemacht werden, der Atari ist schlieûlich keine Unix-Maschine,
und eine Shell ist kein Betriebssystem.

Wer sich in Unix einigermaûen auskennt, kann mit der Okami-Shell wahrschein-
lich sofort loslegen. Die folgende Anleitung stellt die Verwendung der
Shell dar, die ErklÑrung der internen Kommandos mit Syntax befindet sich
in der Datei commands.doc.



----------------------------------------------------------------------------
SUPPORT

Die Okami-Shell ist public domain, d.h. sie kann von jedermann benutzt und
weitergegeben werden, ohne daû jemand etwas dafÅr zu bezahlen hat. Trotz-
dem bitte ich um RÅcksendung der Software-Kontaktkarte, die nach Eingabe
von "contact" von der Shell Åber den Hardcopydrucker ausgegeben wird.

Das Programm wird voll unterstÅtzt, d.h. es wird dynamisch weiterentwickelt,
und jeder Anwender kann bei mir jederzeit die neueste Version bestellen.
Ebenso stehe ich bei Problemen und WÅnschen zur VerfÅgung. Spenden sind
natÅrlich auch willkommen, aber ausdrÅcklich nicht Vorraussetzung fÅr
den Erwerb von neuen Versionen, Anleitungen oder sonstigen Hilfen (dies
ist allen Pd-Programmierern zur Nachahmung empfohlen).

Der Quellcode kann ebenfalls bei mir bestellt werden (ca. 4000 Zeilen C).
Als kleine Spende hÑtte ich hierfÅr allerdings gerne einen Taschenrechner-
mîglichst schîn, am besten alt, notfalls ohne Batterien, aber bitte
funktionsfÑhig. DafÅr gibt es den vollstÑndigen Quellcode mit allen verwen-
deten Includefiles.

Meine Adresse:

        Wolfram Rîsler
        Augustastr. 44-46
        D-5100 Aachen

        Tel. 0241/504290


----------------------------------------------------------------------------
LIEFERUMFANG

Zur Okami-Shell gehîren die folgenden Dateien:

        sh.ttp          Das Haupt-Shellprogramm.
        msh.prg         Die Microshell zum Starten als GEM-Programm.
        msh.inf         Konfigurationsdatei zur Microshell.
        profile         Konfigurationsdatei beim Start der Shell.
        contact.sh      Shellscript mit dem contact-Kommando.
        help            Textdatei mit SyntaxerklÑrungen.
        msh.c           Quellcode der Microshell.
        system.c        Quellcode der system-Funktion
        readme          GrundeinfÅhrung fÅr den Anwender
        *.doc           Anleitungen


----------------------------------------------------------------------------
SYSTEMBEDARF


RAM             Die Shell benîtigt ca. 85 KB an Laufzeitspeicher
                => lauffÑhig auch auf 512KB-Maschinen.
Massespeicher   FÅr die zum Lauf notwendigen Dateien werden minimal ca.
                50 KB benîtigt. Mit allen Hilfsdateien (Microshell,
                Profile,...) werden 80-90 KB benîtigt.
                Die Shell kann jedem Massespeicher betrieben werden. FÅr
                die Verwendung des Pipelinings ist es jedoch notwendig,
                daû auf den jeweiligen Massespeicher geschrieben werden
                kann.
Bildschirm      LÑuft fehlerfrei in hoher und mittlerer Auflîsung. Der
                Betrieb in niedriger Auflîsung ist mîglich, aber einige
                interne Kommandos gehen davon aus, das pro Zeile 80
                Zeichen zur VerfÅgung stehen (z.B. df und hd). Die Be-
                nutzung dieser Kommandos kann dann zu Stîrungen in der
                Bildschirmausgabe fÅhren. In keinem Fall kommt es jedoch
                zu einem Programmabsturz.
GerÑte          Die Shell unterstÅtzt Drucker und die RS232-Schnittstelle.
                Es werden jedoch keine GerÑte auûer Bildschirm und
                Tastatur unbedingt benîtigt (auch nicht die Maus).
Betriebssystem  Die Shell wurde unter Blitter-TOS auf einem Atari 1040 ST
                entwickelt und ist "sauber" programmiert, d.h. es erfolgt
                kein Zugriff auf undokumentierte oder verÑnderliche System-
                adressen o.Ñ. Die Shell sollte daher mit jedem frÅheren
                und zukÅnftigen TOS zusammenarbeiten.
Software        Jedes TOS- und TTP-Programm kann von der Shell als externes
                Kommando aufgerufen werden. GEM-Programme kînnen aufgerufen
                werden, wenn die Shell selber als GEM-Programm gestartet
                wird, was z.B. der Fall ist, wenn msh.prg zum Start der
                Shell benutzt wird.
                Zum VerÑndern der Konfigurationsdateien profile und msh.inf
                ist ein Ascii-Editor erforderlich. Ich empfehle Tempus
                oder den Pd-Editor Edimax.
                (Edimax ist Åber den Pd-Versand oder direkt bei mir er-
                hÑltlich.)                
                




----------------------------------------------------------------------------
INSTALLATION

Die Okami-Shell kann direkt von der Diskette gestartet werden. Siehe hierzu
den folgenden Abschnitt.
Ihre volle Effizienz entwickelt die Shell allerdings erst beim Einsatz
von der Ramdisk oder Festplatte.

INSTALLATION AUF RAMDISK

Ich empfehle die selbstkomprimierende Maxidisk, da sie die optimale Speicher-
ausnutzung garantiert. FÅr die Shell sollten mindestens 50 KB Maxidisk
oder ca. 70 KB einer anderen Ramdisk zur VerfÅgung stehen. Wer genug 
Speicher hat, sollte die Ramdisk auf 100 KB konfigurieren.

FÅr den vollen Betrieb der Shell sollten folgende Dateien auf die Ramdisk
kopiert werden:

        sh.ttp
        profile
        msh.prg
        msh.inf
        help
        contact.sh
        
Wer seine Kontaktkarte bereits abgeschickt hat, braucht die Datei contact.sh
nicht. Die Datei help wird fÅr das Shell-Kommando "help" benutzt; wer diese
Datei ausdruckt und neben den Rechner legt, kann sich den Platz auf der
Ramdisk ebenfalls sparen.
Die Dateien msh.prg und msh.inf gehîren zusammen und werden zum Start der
Shell als GEM-Programm benutzt. Wer von der Shell keine GEM-Programme
starten will, braucht diese Dateien nicht.
Auch auf profile kann man verzichten, allerdings wird die Shell dann mit
den eingebauten Voreinstellungen initialisiert.
=> Die einzige Datei, die man wirklich braucht, ist sh.ttp.

INSTALLATION AUF FESTPLATTE

Bei Verwendung der Okami-Shell mit einer Festplatte kommt echtes Unix-Feeling
auf, vor allem wenn man die Shell nach dem Systemstart automatisch starten
lÑût (ich benutze den Autostarter aus dem Data-Becker-Buch "Atari ST, die
besten Tips und Tricks"). Mit einigen Tricks, die im folgenden erklÑrt
werden, kann man sich z.B. bei jedem Start der Shell Datum und Uhrzeit
des letzten Systemstarts ausgeben lassen oder das aktuelle Arbeitsverzeich-
nis so einstellen, wie man die Shell zuletzt verlassen hat. Dazu kann man
alle Programme, die man auf der Festplatte hat, per Name starten lassen,
egal in welchem Verzeichnis man sich gerade befindet, und es werden sogar
alle RSC-Dateien gefunden.

FÅr die Shell sollte ein eigener Ordner eingerichtet werden, in den die
oben unter INSTALLATION AUF RAMDISK aufgefÅhrten Dateien kopiert werden.
In diesem Ordner erzeugt man einen weiteren Ordner namens "bin", in
den man die Datei SHIP.PRG von der Harddisk-Utility-Diskette kopiert.
Die Datei wird dann umbenannt in SHIP.EXE. So wird beim Herunterfahren
des Rechners mit der Shell (shutdown, siehe commands.doc) auch die
Festplatte automatisch geparkt.


----------------------------------------------------------------------------
START DER SHELL

a) Direkt

Die Shell befindet sich in der Datei sh.ttp. Diese Datei kann vom Desktop
aus per Doppelklick gestartet werden. In der folgenden Eingabebox kann
man folgendes eintragen:

        * Ein Shell-Kommando, dann wird dieses Kommando ausgefÅhrt und
          die Shell wird beendet, d.h. nach der AusfÅhrung erscheint
          sofort wieder das Desktop.
        * Man lÑût die Eingabezeile leer, dann wird die Shell im Dialog-
          modus gestartet, d.h. es erscheint ein Dollarzeichen als Prompt,
          hinter dem dann alle Shellkommandos eingegeben werden kînnen.
          Beendet wird die Shell durch Eingabe von "exit" oder durch
          Druck auf Ctrl V bei der Kommandoeingabe.
        * Man gibt ein Minuszeichen ein, dann startet die Shell ebenfalls
          im Dialogmodus, aber vorher wird festgestellt, ob sich im
          aktuellen Verzeichnis (das, in dem sich sh.ttp befindet) eine
          Datei namens "profile" befindet. Ist dies der Fall, so werden
          aus dieser Datei Shell-Kommandos gelesen und ausgefÅhrt. Mit
          dieser Mîglichkeit kann die Shell beim Start konfiguriert werden.
          Diese Art, die Shell zu starten, heiût in Unix-Manier "Login-
          Shell".

          
b) Indirekt

Die Shell kann indirekt von jedem Programm aus mit der GEMDOS-Funktion
Pexec gestartet werden. Dies geschieht z.B. bei Verwendung der mitgelie-
ferten system-Funktion oder beim Aufruf von der Microshell.
Wenn die Shell als Login-Shell gestartet werden soll und es mîglich sein
soll, GEM-Programme von der Shell aus zu starten, muû die Shell mit der
Microshell (msh.prg) gestartet werden.
Dazu mÅssen folgende Voraussetzungen zutreffen:
1) Im selben Directory wie sh.ttp stehen die Dateien msh.prg und msh.inf.
2) Die Datei msh.inf enthÑlt mindestens die folgende Zeile:
sh.ttp -

Dann wird die Shell nach Doppelklick auf msh.prg automatisch als Login-Shell
gestartet. Es kînnen alle GEM-Programme von der Shell aus ausgefÅhrt werden.
Siehe hierzu auch msh.doc.


----------------------------------------------------------------------------
KONFIGURATION

Wenn der Shell als einziger Parameter ein Minuszeichen Åbergeben wird,
sucht sie nach dem Start im aktuellen Verzeichnis eine Datei mit dem
Namen profile. Wenn eine solche Datei vorhanden ist, wird sie wie ein
Shellscript (siehe dazu weiter unten) ausgefÅhrt.
Das Profile kann eine Einschaltmeldung auf dem Bildschirm ausgeben und
Shellvariablen wie z.B. das Prompt (PS1) setzen. Auûerdem kînnen die
Shell-Flags eingestellt werden (siehe dazu das interne Kommando "set"
in commands.doc). Das Profile kann alle Aktionen ausfÅhren, die ein nor-
males Shellscript auch ausfÅhren kann.



----------------------------------------------------------------------------
KOMMANDOEINGABE

a) Von der Tastatur

Wenn die Shell im Dialogmodus gestartet ist, kînnen nach dem Prompt (i.d.R.
ein Dollarzeichen) Kommandos eingegeben werden. (Das mitgelieferte Profile
stellt das Prompt um, so daû im Prompt immer das augenblickliche aktuelle
Directory zu sehen ist.)
Bei der Eingabe werden folgende Sondertasten benutzt:

        Backspace       das zuletzt eingegebene Zeichen wird gelîscht.
        Pfeil auf       Es wird das zuletzt eingegebene Kommando ange-
                        zeigt. Dieses kann mit ENTER Åbernommen oder
                        mit Backspace editiert werden. Durch wiederholten
                        Druck auf Pfeil auf wird das vorletzte Kommando
                        angezeigt usw. Es werden maximal zehn Kommandos
                        gespeichert (wer mehr braucht, benutze den Soft-
                        ware-Support, um eine entsprechend angepaûte Version
                        der Shell zu erhalten. Ich halte 10 Kommandos fÅr
                        ausreichend.) Diese Eigenschaft der Eingaberoutine
                        nennt man "History".
        Pfeil ab        Zeigt das nÑchste Kommando in der History-Liste an.
                        Mit Pfeil auf und Pfeil ab kann man also in den
                        in der History-Liste gespeicherten Kommandos 
                        blÑttern.
        Control V       Die Shell wird beendet.
        

b) Aus einer Datei

Es ist mîglich, Dateien zu schreiben, die Shell-Kommandos enthalten
und diese Dateien Kommando fÅr Kommando von der Shell ausfÅhren zu 
lassen. Solche Dateien werden als Shell-Scripts (oder in der MS-DOS-Welt
als Batch-Dateien) bezeichnet. Ein Shell-Script kann wiederum weitere
Scripts ausfÅhren usw., wobei die Tiefe der Rekursion durch den zur
VerfÅgung stehenden Speicher und die systembedingte Maximalanzahl offener
Dateien begrenzt ist.
FÅr die Kommandos in Shell-Scripts gelten dieselben Regeln wie fÅr
Kommandos, die Åber die Tastatur eingegeben werden. Leider ist die Aus-
fÅhrung von Shell-Scripts derjenige Punkt, an dem die Okami-Shell und
die normalen Unix-Shells am weitesten auseinanderklaffen, da beim Aufruf
eines Shell-Scripts unter Unix dieses i.d.R. nicht von der Shell selber
ausgefÅhrt wird, sondern die Shell startet sich selber nochmals, um das
Script auszufÅhren (Subshell). Auf dem ST ist diese Vorgehensweise wegen
des begrenzten Speichers nicht zu empfehlen, weswegen jedes Shellscript
von der Shell selber ausgefÅhrt wird. Dies hat Konsequenzen z.B. bei der
Ein/Ausgabeumleitung von Shell-Scripts.


Es gibt drei Arten von Kommandos:
1) interne Kommandos,
2) externe Kommandos,
3) Kommentare.

INTERNE KOMMANDOS
Ein internes Kommando ist ein Kommando, durch das eine Funktion innerhalb
der Shell ausgefÅhrt wird, das also in der Shell eingebaut ist. Interne
Kommandos werden durch Eingabe ihres Namens aufgerufen.

EXTERNE KOMMANDOS
Ein externes Kommando ist nicht in der Shell eingebaut, sondern in einer
Datei auf einer Diskette, Ramdisk oder Festplatte vorhanden. Hierbei kann
es sich sowohl um eine ausfÅhrbare Datei (.PRG, .TOS etc.) als auch um 
ein Shellscript handeln.
Externe Kommandos kînnen durch Eingabe des vollstÑndigen Pfadnamens der
entsprechenden Datei, aber auch durch Eingabe des Kommandonamens (des
Dateinamens ohne Pfad und Extender). Die zugehîrige Datei wird auf den
Pfaden gesucht, die in der Shell-Variablen PATH gespeichert sind.
Externe Kommandos kînnen nur ausgefÅhrt werden, wenn ihr Datei-Extender
einem der in den Shell-Variablen XEXT und SEXT gespeicherten entspricht.
Siehe hierzu auch den Abschnitt Åber externe Kommandos in commands.doc.

Es gehîrt zur Philosophie von Unix, daû man an der reinen Eingabe nicht
erkennen kann, ob es sich bei dem eingegebenen Kommando um ein internes
Kommando, eine ausfÅhrbare Datei oder ein Shellscript handelt. Um das 
herauszufinden, gibt es das interne Kommando type. Siehe hierzu
commands.doc.

KOMMENTARE

Eine Eingabe gilt als Kommentar, wenn sie mit einem Doppelkreuz (#) beginnt
oder wenn sie nur aus einer leeren Zeile besteht. Kommentare werden von
der Shell nicht weiter beachtet und sind nÅtzlich zum Dokumentieren von
Shell-Scripts. Die Tastatureingabe von Kommentaren ist zwar mîglich, aber
nicht unbedingt sinnvoll.



FLAGS UND PARAMETER

Jedem Kommando kînnen Flags und Parameter Åbergeben werden. I.d.R. werden
Parameter benutzt, um festzulegen, womit etwas getan werden soll, und die
Flags legen fest, wie es getan werden soll.
Externen Kommandos werden alle Åbergebenen Flags und Parameter als Kommando-
zeile Åbergeben. Durch eine EinschrÑnkung des Betriebssystems ist die
GesamtlÑnge dieser Parameterzeile auf 39 Zeichen beschrÑnkt.
Den internen Kommandos kînnen beliebig viele Flags und Parameter Åberge-
ben werden, allerdings ist fÅr die meisten Kommandos nur eine beschrÑnkte
Anzahl von Parametern sinnvoll.
Die Flags der internen Kommandos werden durch ein Minus- oder Pluszeichen
eingeleitet. NÑheres siehe commands.doc.

Die Shell benutzt eine Reihe eigener Flags, die mit dem internen Kommando
set eingestellt werden kînnen. Siehe hierzu commands.doc.



VERKETTETE KOMMANDOS

Kommandos kînnen in einer Zeile durch Semikolon getrennt angefÅhrt werden.
Die Kommandos werden von links nach rechts ausgefÅhrt.



----------------------------------------------------------------------------
SHELLVARIABLEN

Eine besondere Art von internem Kommando ist die Zuweisung eines Wertes an
eine Shellvariable. Alle Shellvariablen sind Stringvariablen. Der Name einer
Shellvariablen kann in beliebiger Reihenfolge Buchstaben, Ziffern und Under-
scores (_) enthalten.

BeschrÑnkungen:
        Maximalanzahl der Shellvariablen                50
        MaximallÑnge des Variablennamens                15 Zeichen
        MaximallÑnge des Variablenwertes                80 Zeichen
Wer damit nicht auskommt, benutze den Software-Support, um eine Version
der Shell mit grîûeren KapazitÑten zu erhalten.


DEKLARATION
Shell-Variablen brauchen nicht deklariert zu werden.

ZUWEISUNG
Die Zuweisung eines Wertes an eine Shell-Variable geschieht durch eine
Eingabe der Form
        Variable=Wert
        
z.B.:
        NAME=Okami-Shell
        
Es wird der String "Okami-Shell" der Shellvariablen NAME zugewiesen. In
Unix ist es Åblich, Shell-Variablen in Groûbuchstaben zu schreiben, es
sind allerdings auch Kleinbuchstaben mîglich. NAME und Name sind zwei
unterschiedliche Variablen.
Auûerdem kann das interne Kommando "read" zur Zuweisung von Eingaben an
Shellvariablen benutzt werden. Siehe hierzu commands.doc.


BENUTZUNG
Der Wert einer Shell-Variablen kann durch Angabe des Variablennamens mit
vorgestelltem Dollar-Zeichen angegeben werden. In einer Eingabezeile der
Shell werden erst alle Variablen zu den betreffenden Werten expandiert,
bevor die Zeile ausgefÅhrt wird. Shell-Variablen, an die noch kein Wert
zugewiesen wurde, werden als Leerstrings behandelt.

Beispiele:

NAME=Okami-Shell
echo $NAME

erzeugt die Ausgabe "Okami-Shell".

NAME=Okami-Shell
echo Der Name ist $NAME und nicht anders. 
            
erzeugt die Ausgabe "Der Name ist Okami-Shell und nicht anders."

VAR1=$VAR2

weist der Variablen VAR1 den Wert der Variablen VAR2 zu.

Es ist auch mîglich, Shell-Kommandos an Variablen zuzuweisen und dann aus-
fÅhren zu lassen:

CC=c:\compiler\cc.ttp
$CC test.c

ruft das Programm c:\compiler\cc.ttp mit dem Parameter test.c auf.


LôSCHEN
Durch Zuweisung eines Leerstrings an eine Shell-Variable wird diese Variable
gelîscht. Dies ist notwendig, da die Shell nur Åber eine begrenzte Anzahl
von Variablen verfÅgt. Besonders Shell-Scripts, die Variable  fÅr lokale
Zwecke benutzen, sollten diese Variablen nach der Benutzung wieder frei-
geben.

Beispiel:

NAME=

Die Shell-Variable NAME wird gelîscht.


SAVECWD=$CWD
cd c:\work\test
# Weitere Kommandos
# ...
cd $SAVECWD

Das aktuelle Verzeichnis (das stets in der Variablen CWD steht) wird in die
Variable SAVECWD gesichert. Danach wird das aktuelle Verzeichnis geÑndert
(mit dem internen Kommando "cd"), und es werden weitere Kommandos (angedeu-
tet durch zwei Kommentarzeilen) ausgefÅhrt. Anschlieûend wird das aktuelle
Verzeichnis wieder restauriert.
Diese Technik sollte von allen Shellscripts benutzt werden, die das aktuelle
Verzeichnis Ñndern. Unter Unix werden Shellscripts stets von Subshells
ausgefÅhrt, und das aktuelle Verzeichnis ist eine Eigenschaft eines
Prozesses, weswegen Shellscripts das aktuelle Verzeichnis Ñndern kînnen,
ohne das aktuelle Verzeichnis der aufrufenden Shell zu beeinflussen. Unter
TOS ist das aktuelle Verzeichnis eine Eigenschaft des jeweiligen Laufwerks,
und das aktuelle Laufwerk ist eine globale Eigenschaft des gesamten Sys-
tems. Die Okami-Shell benutzt keine Subshells, und daher kann jedes Shell-
script das aktuelle Verzeichnis der Shell Ñndern, was in der praktischen
Anwendung nicht immer erwÅnscht ist.


SYSTEMVARIABLEN
Eine Reihe von Shellvariablen werden von der Shell selber angelegt und
benutzt. Es ist teilweise mîglich, die Werte dieser Variablen zu verÑndern.
Die Systemvariablen sind:

PS1             Das Eingabeprompt. Kann vom Anwender verÑndert werden (was
                normalerweise im Profile geschieht).
LOGNAME         Der Programmname ("Okami Shell"). Kann nicht verÑndert
                werden.
VERSION         Die Versionsnummer der Shell. Kann nicht verÑndert werden.
CWD             Das aktuelle Verzeichnis. Wird nach jedem Wechsel des
                Verzeichnisses automatisch aktualisiert und sollte nicht
                von Hand verÑndert werden.
HOME            Das Verzeichnis, aus dem die Shell gestartet wurde (genauer
                gesagt das aktuelle Verzeichnis zum Zeitpunkt des Starts
                der Shell). Kann nicht verÑndert werden.
PAGELEN         Die Anzahl der Zeilen auf dem Bildschirm. Wird von dem
                internen Kommando pg benutzt. Kann beliebig eingestellt
                werden. Die Defaulteinstellung ist 23.
NULL            Der Name des GerÑtes oder der Datei, an die die Ausgaben
                geleitet werden, die zum Null-GerÑt (NULL:) umgeleitet
                werden. Kann verÑndert werden. Die Defaulteinstellung 
                ist AUX: (RS232-Schnittstelle).
XEXT            Eine Liste von durch Kommata getrennten Extendern. Dateien
                mit einem der hier aufgefÅhrten Extender kînnen als BinÑr-
                programme gestartet werden. Die Defaulteinstellung ist
                ".prg,.tos,.ttp,.app". Die Punkte vor den Extendern mÅssen
                mit eingegeben werden.
SEXT            Eine Liste von durch Kommata getrennten Extendern. Dateien
                mit einem der hier aufgefÅhrten Extender kînnen als Shell-
                Scripts gestartet werden. Die Defaulteinstellung ist
                ".sh". Die Punkte vor den Extendern mÅssen mit eingegeben
                werden.
PATH            Eine Liste von durch Kommata getrennten Pfaden. Bei der
                Eingabe eines externen Kommandos ohne vollstÑndige Pfadan-
                gabe wird die Datei auf den hier angegebenen Pfaden gesucht.
                Die Defaulteinstellung ist ".,..,$HOME,$HOME\bin".
0               EnthÑlt bei Eingabe eines Kommandos den Namen des Kommandos.
1               EnthÑlt den ersten Parameter der Eingabezeile.
2               EnthÑlt den zweiten Parameter der Eingabezeile usw.
#               EnthÑlt die Anzahl der Parameter der Eingabezeile.
*               EnthÑlt die vollstÑndige Eingabezeile.
?               EnthÑlt den RÅckgabewert des zuletzt ausgefÅhrten Kommandos.



----------------------------------------------------------------------------
EIN/AUSGABE-UMLEITUNG

1) FÅr interne Kommandos

Die Eingabe, Ausgabe und Fehlerausgabe jedes internen Kommandos kann auf
einfache Weise in bzw. aus einer beliebigen Datei oder zu bzw. von einem
GerÑt umgeleitet werden.

Folgende Umleitungsmîglichkeiten stehen zur VerfÅgung:

< Datei                 Umleitung der Eingabe
> Datei                 Umleitung der Ausgabe, die Datei wird vorher gelîscht
>> Datei                AnhÑngen der Ausgabe an die Datei
2> Datei                Umleitung der Fehlerausgabe, die Datei wird vorher
                        gelîscht
2>> Datei               AnhÑngen der Fehlerausgabe an die Datei

Anstelle von "Datei" kînnen auch die folgenden GerÑte angegeben sein:

        CON:            Konsole (Default)
        PRT:            Drucker
        AUX:            RS232-Schnittstelle
        NULL:           ignorieren

Das GerÑt NULL:, auch Null-GerÑt genannt (in Unix: /dev/null), wird nicht
vom Betriebssystem des ST unterstÅtzt, sondern von der Shell simuliert.
Der Zweck eines Null-GerÑtes ist, die Ausgabe oder Fehlerausgabe eines
Kommandos zu unterdrÅcken. Die Shell-Variable NULL gibt an, wo die
Ausgabe, die an NULL: umgeleitet wird, tatsÑchlich landen soll. Die 
Voreinstellung ist die RS232-Schnittstelle, und dies sollte nur geÑndert
werden, wenn diese Schnittstelle belegt ist. Im Notfall kann man als
NULL eine regulÑre Datei auf der Ramdisk oder Festplatte angeben.

Wenn keine Umleitung angegeben ist, geht die Eingabe von der Tastatur
und die Ausgabe und Fehlerausgabe zum Bildschirm (CON:).


Pipelining

Die Idee des Pipelining ist es, die Ausgabe eines Kommandos zur Eingabe
des nÑchsten zu machen. So schreibt z.B. das memex-Kommando einen Speicher-
bereich auf seine Ausgabe, und das hd-Kommando fertigt von seiner Eingabe
ein Hexdump an. Mit dem Pipelining kînnen beide Kommandos verbunden werden,
d.h. man bekommt ein Hexdump eines Speicherauszuges.
Um zwei Kommandos in einer Pipe zu verbinden, wird zwischen sie ein senk-
rechter Strich (|), auch Pipe genannt, gesetzt, z.B.:
hd sh.ttp | pg
Die Ausgabe des hd-Kommandos (ein langer Hexdump) wird zur Eingabe des pg-
Kommandos, wodurch der Hexdump seitenweise angezeigt wird.
Die Schreibweise a | b ist Ñquivalent zu: (a und b sind beliebige Kommandos
incl. ihren Parametern)

tmp=$HOME\pip$$
a > $tmp
chmod +h $tmp
b < $tmp
rm $tmp
tmp=

Daraus folgt, daû das Pipelining nur benutzt werden kann, wenn auf das Lauf-
werk, von dem die Shell geladen wurde ($HOME), geschrieben werden kann.

Dies ist ein wesentlicher Unterschied zu Unix, wo alle an einer Pipe be-
teiligten Kommandos (Prozesse) gleichzeitig laufen. Eine Pipeline ist
unter Unix eine Einrichtung des Betriebssystems, die von der Okami-Shell
nur simuliert wird.


2) FÅr externe Kommandos

Theoretisch funktionieren sÑmtliche Ein/Ausgabe-Umleitungen inklusive der
Pipeline auch mit externen Kommandos. In der Praxis jedoch erlauben nicht
alle Programme diese Mîglichkeit, weil sie die Åbergebene Kommandozeile
(argc/argv) nicht auswerten oder weil der Compiler sich nicht darum
kÅmmert. Manche Programme sprechen auch direkt den Bildschirm bzw. die
Tastatur an, so daû die Umleitung wirkungslos wird.
Die Umleitung sollte mit den meisten in C geschriebenen und sauber pro-
grammierten (d.h. z.B. putc anstelle von Bconout etc.) Programmen funktio-
nieren, da die Umleitung C-Norm ist. Das Pd-Modula 2-System der LTU 
MÅnchen z.B. erlaubt keine Art der Umleitung (es ist auch sonst ein mieses
System, nicht nur was den Support angeht). GEM-Programme sind von vornherein
gegen jede Art der Umleitung immun, da sie den Bildschirm Åber den ent-
sprechenden GEM-GerÑtetreiber ansprechen.





----------------------------------------------------------------------------
GRöûE

1) An die Firma GRP in Aachen, fÅr lebenswichtige Kenntnisse in C und Unix.

2) Wer in Berlin wohnt und am Zen-Dojo in der Zossener Straûe vorbeikommt,
   bestellt bitte Jonas und Wim viele GrÅûe von mir.
