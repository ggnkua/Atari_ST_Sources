
	===============================================

@(#)	  OKAMI SHELL VERSION 1.3 - KOMMANDO-REFERENZ

	===============================================
 			Stand: 29.6.91


	BITTE ERST DIE DATEIEN README UND OKAMI.DOC LESEN!



Dies ist eine Referenzdatei, die man sich einmal kurz durchlesen sollte,
um zu sehen, was die Shell alles zu bieten hat. Danach kann man sie sich
ausdrucken und neben den Rechner legen, die einzelnen Abschnitte k”nnen
aber auch durch die Online-Help-Funktion durch Druck auf die Help-Taste
angesehen werden. Dazu mu der Dateiname dieser Datei in der Shellvariablen
HELPFILE gespeichert sein.
Zum Ausdrucken empfehle ich das Pd-Programm Idealist, das auf einem 9-Nadel-
drucker ca. 250 Zeilen auf eine Seite drucken kann (auf einem 24-Nadel-Drucker
noch mehr).


Zu jedem Kommando wird die Syntax des Kommandos sowie, falls vorhanden, die
zum Laufen des Kommandos notwendigen Dateien angegeben.
Fr die Syntaxschreibweise gilt:
	Angaben in [] (eckigen Klammern) koennen, muessen aber nicht
	angegeben sein.
	Angaben in {} (geschwungenen Klammern) koennen beliebig oft
	(auch null mal) angegeben sein.
	Von durch | (senkrechten Strich) getrennten Angaben wird
	jeweils eine erwartet.
Numerische Werte koennen in folgender Form angegeben werden:
	1234		entspricht der dezimalen Zahl 1234
	01234		entspricht der oktalen Zahl 1234 (=668 dezimal)
	0x1234		entspricht der Hex-Zahl 1234 (=4660 dezimal)
	%1011		entspricht der Bin„rzahl 1011 (=11 dezimal)
	!A		entspricht dem Ascii-Code von A (=65 dezimal)
Vor jedem dieser Formate kann ein Minuszeichen stehen, um eine negative Zahl
anzuzeigen. ACHTUNG: Bei Kommandos, die Flags benutzen, wird dieses Minus-
zeichen als Einleitung der Flags und daher die folgende Zahl als die Flags
angesehen, was normalerweise in einem Syntaxfehler endet. Daher mu in sol-
chen F„llen die Zahl in (einfache oder doppelte) Anfhrungszeichen gesetzt
werden.

Steuersequenzen, z.B. VT52-Codes, k”nnen mit dem Fluchtsymbol ^ (Dach)
benutzt werden. Die Verwendung des Fluchtsymbols ist unter dem internen
Kommando "echo" beschrieben. Das dort gesagte gilt auch fr alle anderen
Kommandos.

Flags k”nnen einzeln, aber auch in Gruppen durch das jeweilige Kennungs-
zeichen eingeleitet werden, z.B. sind „quivalent:
	wc -lcn
und	wc -l -c -n

Dies gilt nicht, wenn die Flags aus mehr als einem Zeichen bestehen oder
wenn zus„tzliche Informationen angegeben werden, wie z.B. bei format oder
rsconf. Auerdem erlauben einige Kommandos nicht die Zusammenfassung oder
die Einzelschreibweise, dies ist dann jeweils angegeben.

Es gibt einige Flags, die sich eingebrgert haben und bei einigen Kommandos
(nicht bei allen) dieselbe Bedeutung haben, diese sind:

	-a (alle)		(das Kommando tut etwas fr alle in Frage
				 kommenden Argumente. Bsp.: pwd, ls)
	-i (interaktiv)		(das Kommando fragt den Anwender nach
				 gewissen Dingen. Bsp.: rm)
	-l (lang)		(gibt zus„tzliche oder ausfhrlichere Informa-
				 tionen. Bsp.: ls, ver)
	-v (verbose)		(das Kommando sagt, was es tut, Bsp.: format)
	-q (quiet)		(das Kommando erzeugt keine Ausgabe, oder:)
	   (query)		(wie -i)
	-f (fast)		(das Kommando umgeht Sicherheitsabfragen u.„.,
				 um so schnell wie m”glich zu laufen. Bsp.:
				 rm, shutdown)
	-r (rekursiv)		(das Kommando l„uft rekursiv ber den Datei-
				 baum. Bsp: rm)

Hinweis: Alle Angaben ber Shellscripts (z.B. "Verwendung nur in Shellscripts
erlaubt") gelten ebenso fr Shellfunktionen.


0) Nicht-dokumentierte Kommandos:

Gibt es, na klar. Sie werden hier nicht erkl„rt, da sie sonst ja nicht mehr
nicht-dokumentiert w„hren. Mit cmds kann man die Namen aller Kommandos heraus-
finden, auch die der nicht-dokumentierten. Man kann sie auch benutzen, aber
man sollte sich nicht darauf verlassen, da sie in sp„teren Versionen der
Shell noch genauso wie in der jetzigen funktionieren oder berhaupt noch vor-
handen sind.
Wer das Zauberwort findet, hat gewonnen.


1) Interne Kommandos:

Interne Kommandos werden aufgerufen, indem man am Shell-Prompt den Namen
des Kommandos, gefolgt von den Parametern, eingibt.

Rckgabewerte:
Jedes interne Kommando gibt einen numerischen Wert zurck, der sich nach Aus-
fhrung des Programms in der Shellvariablen "?" befindet. Auerdem wird
der Rckgabewert von den Kommandos if und while benutzt.
Normalerweise geben die Kommandos -1 zurck, wenn ein Syntaxfehler beim
Aufruf oder ein anderer Fehler aufgetreten ist, und 0, wenn bei der Aus-
fhrung keine Fehler aufgetreten sind. Daher werden die Rckgabewerte der
internen Kommandos im folgenden nur angefhrt, wenn sie von dieser Konven-
tion abweichen.


Folgende interne Kommandos sind implementiert:


-----
. - Ausfhrung einer Datei als Shellscript

Syntax: . Dateiname

Die angegebene Datei wird als Shellscript ausgefhrt. Es mu der voll-
st„ndige Dateiname (relativ oder absolut) angegeben werden. Die Shell-
variablen PATH und SEXT sind ohne Wirkung.
Beispiele:
	. $HOME\profile
		fhrt das Login-Script aus.
	. hallo.sh
		fhrt die Datei hallo.sh als Shellscript aus.
	. hallo
		fhrt die Datei hallo als Shellscript aus.

-----
[ - SIEHE test

-----
adr - Ausgabe von diversen Systemadressen

Syntax: adr

Ausgabe der folgenen Adressen:
	argv		Adresse des Argumentenvektors der Shell
	Command line	Adresse der Kommandozeile (Parameter)
	Environment	Adresse des Environment-Strings der Shell
	VarTable	Adresse der Variablen-Tabelle der Shell
	Commands	Adresse der Kommandotabelle der Shell
	AdrTab		Adresse der Tabelle mit den auszugebenden Adressen
	Physbase	Adresse des physikalischen Bildschirms
	Logbase 	Adresse des logischen Bildschirms
	DTA		Adresse des Disk-Transfer-Bereiches
	Phystop 	Physikalisches Ende des RAM-Speichers
			(Adresse des ersten nicht vorhandenen Bytes)
	Membot		Unterste Adresse des verfgbaren Speichers
	Memtop		Oberste Adresse des verfgbaren Speichers
	Basepage	Adresse der Basepage der Shell
	Cookie Jar	Die Adresse des Cookie Jars.
	_StdIn		Adresse der aktuellen Eingabe-File-Struktur.
	_StdOut		Adresse der aktuellen Ausgabe-File-Struktur.
	_StdErr		Adresse der aktuellen Fehlerausgabe-File-Struktur.
	_shell_p	Adresse der Shell-Funktion.

Diese Adressen sind z.T. nur fr den Programmierer der Shell von Bedeu-
tung (z.T nicht mal das). Die Inhalte der Adressen k”nnen mit memex ausge-
lesen werden.

Siehe auch:	basep
		cookie

-----
alert - Anzeige von GEM-Alertboxen

Syntax: alert Icon Default Boxtext Buttontext [Var]

Dieses Kommando macht die GEM-Alert-Boxen von der Shell aus zug„nglich. Da
es sich um ein AES-Feature handelt, kann dieses Kommando nur benutzt werden,
wenn vorher gon aktiviert wurde.
Die Parameter haben folgende Bedeutung:

	Icon
		das in der Box anzuzeigende Icon. Zul„ssige Werte sind die
		Strings "none", "excl", "ques" und "stop" sowie die Zahlen
		0 bis 3.
	Default
		die Nummer des Default-Buttons, also des Buttons, der durch
		Druck auf Return angew„hlt werden kann. Zul„ssige Werte sind
		1 fr den linken, 2 fr den mittleren und 3 fr den rechten
		Button.
	Boxtext
		der in der Box anzuzeigende Text. Mu in Anfhrungszeichen
		eingeschlossen sein, wenn er Leerzeichen enth„lt. Die Zeilen
		mssen durch ^| getrennt sein. (Nur | gengt nicht, wirkt
		als Pipe!)
	Buttontext
		analog dazu die in den Buttons anzuzeigenden Texte, getrennt
		durch ^|.
	Var
		ein beliebiger Variablenname fr das Ergebnis.

Das Ergebnis der Auswahl, also die Nummer des angwew„hlten Buttons,  wird als
Rckgabewert des Kommandos und, falls angegeben, in der Variablen Var zurck-
gegeben. Es steht 1 fr den linken, 2 fr den mittleren und 3 fr den rechten
Button.

Beispiele:

	Die gleiche Wirkung haben:
alert none 1 "Ich bin die Okami-Shell" "Sch”n"
alert 0 1 "Ich bin die Okami-Shell" Sch”n

	Sicherheitsabfrage:
alert ques 1 "Die Datei $FILE existiert bereits.^|Soll sie gel”scht werden?" ^
"Ja^|Nein" ERG
if [ $ERG = 1 ]
then
  rm $FILE
fi

-----
alias - Erzeugen von einfachen Shellfunktionen

Syntax: alias Name String

Dieses Kommando ist ein Ersatz fr das Alias-Konzept der C-Shell, das von
der Okami-Shell nicht untersttzt wird (da es es in dem Vorbild der Okami-
Shell, der Bourne-Shell, auch nicht gibt). Es dient dazu, Shellscripts aus-
zufhren, die fr eine Shell geschrieben wurde, die ber alias verfgt
(z.B. die Gulam- oder Mastershell).
Das Alias-Konzept sieht einen Makroprozessor vor, der eine eingegebene
Kommandozeile aufgrund der aliasse expandiert. In der Okami-Shell ist dieses
Konzept berflssig, da man jedes alias durch eine Shellfunktion darstellen
kann. (Genauso wie man in C jedes Preprozessor-Makro durch eine Funktion er-
setzen kann, aber nicht umgekehrt.)
Das Kommando "alias Name String" ist „quivalent zu:

	Name()
	{
	  String $*
	}

, d.h. es wird eine Shellfunktion mit dem angegebenen Namen erzeugt, die
den angegebenen String zusammen mit dem Rest der Kommandozeile ausfhrt.

Um den absoluten Namen eines externen Kommandos zu speichern, um die Such-
zeit zu verringern (z.B. "alias cc c:/compiler/cc.ttp"), sollte man statt-
dessen lieber das hash-Kommando benutzen ("hash cc c:/compiler/cc.ttp").

Beispiele:

alias l ls -l		definiert eine Shellfunktion namens l, die sich wie
			ls -l verh„lt. "l *.c" ist dann also „quivalent zu
			"ls -l *.c".
alias cp !cp -v		sorgt dafr, da alle Kopieroperationen im Verbose-
			modus ablaufen. Wichtig ist das Ausrufezeichen vor
			cp im Funktionsrumpf, das dafr sorgt, da hier das
			interne Kommando cp und nicht die Shellfunktion cp
			aufgerufen wird.

Es kann nicht garantiert werden, da sich die mit alias geschaffenen Shell-
funktionen in allen Sonderf„llen (Verschachtelungen etc.) genauso verhalten
wie ein alias auf einer Shell, die alias-Expansion durchfhrt.

Siehe auch:	hash
		unalias (unset)

-----
backup - Sichern von Dateien auf Diskette

Syntax: backup [-nNrq] [Laufwerk]

Dient zum Sichern von Dateien auf Diskette. Es werden von StdIn Datei-
namen eingelesen. Diese Dateien werden auf dem angegebenen Laufwerk oder,
falls kein Laufwerk angegeben ist, nach A:\ gespeichert. Dabei werden alle
ben”tigten Ordner angelegt.
Alle von StdIn eingelesenen Zeilen werden als Dateinamen betrachtet, mit
der Ausnahme von Zeilen, die mit einem Doppelkreuz (#) beginnen. Diese
werden als Kommentarzeilen betrachtet. Leerzeilen werden ignoriert.
Wenn auf dem Ziellaufwerk kein Platz mehr fr weitere Dateien ist, fragt
backup nach der n„chsten Diskette. Die Anfrage wird durch Druck auf ENTER
beantwortet; drckt man stattdessen ESC, wird backup abgebrochen.
Die laufende Nummer der jeweiligen Diskette wird im Bootsektor der
Diskette abgelegt (nur bei Disketten, also Laufwerk A: oder B:.)
Nach dem Ende des Backups wird die Anzahl der Dateien, Bytes und benutzter
Disketten ausgegeben.

Flags:
	-n	Es werden keine Daten in den Bootsektor geschrieben.
	-N	Es werden keine Daten kopiert. Das ist ntzlich, um
		herauszufinden, wieviele Disketten fr ein Backup be-
		n”tigt werden. Die Disketten mssen in der vorgesehenen
		Reihenfolge eingelegt werden, werden aber nicht beschrieben.
		Impliziert -n.
	-r	Es werden keine Ordner auf dem Ziellaufwerk angelegt, alle
		Dateien landen im Wurzelverzeichnis des Ziellaufwerks.
	-q	Es wird angenommen, da die erste Diskette bereits im Lauf-
		werk eingelegt ist, daher entf„llt die Frage nach dem
		Einlegen der ersten Diskette. Dies ist ntzlich, wenn Daten
		statt auf eine Diskette auf eine Festplatte gesichert
		werden.


Beispiele:
	backup <files.lst
		Aus der Datei files.lst werden Namen von Dateien gelesen,
		die auf Diskette A: gesichert werden. Die Datei files.lst
		kann Kommentarzeilen enthalten, die mit # beginnen.

	find d:\ * | backup
		sichert alle Dateien von Partition D: auf Diskette A:.

	ls *.c | backup -q e:\backup\source
		sichert alle C-Quelldateien vom aktuellen Directory in
		das Directory e:\backup\source. Da E: keine Diskette
		ist, werden keine Daten in den Bootsektor geschrieben.
		Es erfolgt keine Nachfrage zum Einlegen einer Diskette.

	find e:\ *.c | backup -N b:
		findet heraus, wieviele Disketten zum Sichern aller C-
		Quelldateien von Partition E: ben”tigt wrden. Es wird
		Diskettenlaufwerk B: benutzt.

Rckgabewert:
	-1	Aufruffehler
	sonst	Anzahl der gesicherten Dateien.

-----
basename - Ermitteln des Dateinamens

Syntax: basename File [Extender]

Ausgabe des reinen Dateinamens ohne Laufwerk und Ordner. Wenn ein Extender
angegeben wird und der Dateiname mit diesem Extender endet, wird der Basis-
name ohne diesen Extender ausgegeben. Datei mu es sich nicht unbedingt um
den 3-Zeichen-TOS-Dateitypextender handeln, sondern um eine beliebig lange
Zeichenkette, die vom Ende des Basisnamens abgeschnitten wird.

Beispiele: 					ergibt:
	basename d:/shell/sh.ttp 		sh.ttp
	basename sh.ttp				sh.ttp
	basename d:/shell/sh.ttp .ttp		sh
	basename d:/compiler iler		comp

Anmerkung: Die Arbeitsweise dieses Kommandos h„ngt in keiner Weise davon ab,
ob die angegebene Datei existiert. Das gilt auch fr die Kommandos dirname,
drvname, extname und fullname.

Siehe auch: dirname
	    drvname
	    extname
	    fullname

-----
basep - Analyse der Basepage

Syntax: basep [-pa] [Adresse]

Mit diesem Kommando kann:
1) die Adresse der Basepage des Shell-Programms herausgefunden werden,
2) diese oder eine andere Basepage analysiert werden,
3) wahlweise stattdessen die Adresse der Parent-Basepage gefunden oder
   diese analysiert werden.

Hierbei bedeutet "analysiert", da die einzelnen in der Basepage enthaltenen
Adressen und sonstigen Angaben ausgegeben werden.

Wenn keine Adresse angegeben ist, wird die Basepage des aktuellen Shell-
Programms benutzt.

Bei der Analyse werden alle Angaben, auch die L„ngenangaben der einzelnen
Programmsegmente, in hexadezimaler Schreibweise ausgegeben. Das interne
Kommando num kann fr die Konvertierung in dezimale Schreibweise benutzt
werden.

Flags:
	-a	Wenn dieses Flag angegeben ist, wird die Analyse der Base-
		page ausgegeben. Ansonsten wird nur die Adresse ausgegeben.
	-p	Wenn dieses Flag angegeben ist, wird die Parent-Basepage
		benutzt.

Beispiele:
1) Herausfinden der aktuellen Basepage-Adresse:
	basep

2) wie 1), aber Umformung ins Dezimalsystem:
	basep | xargs num -d

3) Herausfinden der Adresse der Basepage des aufrufenden Programms:
	basep -p

4) Analyse der Basepage an Adresse 0x65A40:
	basep -a 0x65a40
   Diese Adresse kann z.B. von dem Kommando exec oder ps stammen.

Siehe auch:	exec
		ps

-----
bombs - Erzeugen von Bomben

Syntax: bombs Anzahl

Mit diesem Kommando wird die Shell mit der angegebenen Anzahl von Bomben
beendet. Die Anzahl mu gr”er oder gleich 2 sein. Es erfolgt ein Sprung
an die Adresse, die in dem entsprechenden Vektor (Adresse 4*Anzahl) ange-
geben ist.
Dieses Kommando kann z.B. benutzt werden, um einen Debugger oder eine Umlen-
kung der Exception-Vektoren zu testen.

-----
break - SIEHE while

-----
cat - Anzeige von Dateien

Syntax: cat [-b] {File}

Kopiert Daten von StdIn oder, falls angegeben, von File, nach StdOut.

Wenn das Flag -b angegeben ist, werden die Dateien im Bin„rmodus ge”ffnet,
es findet also keine šbersetzung von CR/LF-Sequenzen statt. Das ist sinn-
voll, wenn man Bin„rdateien wie z.B. ausfhrbare Programmdateien o.„. an-
einanderh„ngen will. Damit das funktioniert, sollte man dann aber auch
das Shell-Flag u setzen (siehe "set").

Bsp.:
1) cat test.dat
gibt den Inhalt der Datei test.dat auf dem Bildschirm aus.

2) cat test.dat >PRT:
druckt die Datei test.dat aus.

3) cat dat.1 dat.2 dat.3 > dat.123
h„ngt die Dateien dat.1 bis dat.3 aneinander und schreibt das Ergebnis
in die Datei dat.123.

4) set +u
   cat -b test1.prg test2.prg >test.bin
arbeitet im Bin„rmodus, wodurch keine šbersetzung von CR/LF-Sequenzen in
den Dateien stattfindet.

Die Verwendung von "cat >file", um Tastatureingaben in eine Datei zu schrei-
ben, ist nicht m”glich, da bei der Eingabe auch das Tastaturecho in die Datei
umgeleitet wrde.

Siehe auch:	raw

-----
cd - Wechsel des aktuellen Directories

Syntax: cd [Pfad]

Setzt das aktuelle Arbeitsverzeichnis auf $HOME oder, falls angegeben,
auf Pfad. Pfad kann erweiterte Wildcards enthalten.
Wenn Pfad nicht mit einem Backslash (\ oder /) beginnt oder ein entsprechendes
Verzeichnis nicht existiert, werden die in der Shellvariablen CDPATH gespei-
cherten Pfade nach einem entsprechenden Verzeichnis durchsucht. Das aktuelle
Arbeitsverzeichnis wird dann auf das erste gefundene Verzeichnis eingestellt.

Beispiele:
	cd
		entspricht cd $HOME
	cd e:\okami\test
		Wechsel von Laufwerk und Verzeichnis
	cd test
		Wechsel in den Ordner "test" im aktuellen Verzeichnis
	cd ..
		Wechsel ins Parent-Directory des aktuellen Verzeichnisses
	cd t*
		Wechsel in den ersten Ordner, dessen Name mit t beginnt

-----
chmod - ndern von Dateiattributen

Syntax: chmod [(+|-)cdrhsvf] File

Flags: Bei Verwendung von + wird das entsprechende Flags gesetzt, bei
       Verwendung von - wird es geloescht. Die Flags bedeuten:
	c	File written and closed (Archivstatus)
	d	Directory		(Ordner)
	r	Read-Only		(nur lesen)
	h	Hidden			(unsichtbar; nur fr Dateien)
	s	System File		(Systemdatei)
	v	Volume Lable		(Diskettenname)
	f	Fastload		(Fastload-Bit des Programmheaders,
					 nur fr ausfhrbare Programmdateien)

Die Flags k”nnen beliebig kombiniert werden, allerdings geben nicht alle
Kombinationen einen Sinn. Das Betriebssystem verbietet gewisse Kombinationen
wie z.B. das Verstecken von Ordnern.

Das Flag f betrifft das Fastload-Bit im Programmheader. Es kann nur fr
ausfhrbare Programmdateien benutzt werden (eine Datei gilt als soche, wenn
ihr erstes Wort 0x60a ist), bei anderen Dateien erscheint eine Fehlermeldung.
Das Fastload-Bit bewirkt, da nach dem Laden des Programms nicht der gesamte
Speicher, sondern nur das BSS-Segment gel”scht wird.

Wenn eine Datei einmal das Volume Label-Flag hat, kann dieses nicht mehr
entfernt werden, da die Datei dadurch von der normalen Dateisuche
(Fsfirst/next) ausgeschlossen ist.

Das Einstellen der Ausfhrbarkeit ist (anders als in Unix) mit chmod nicht
m”glich, da hierfr der Dateinamen-Extender verantwortlich ist.

Die Einstellung der Attribute einer Datei kann mit ls -lf angesehen werden.

-----
clipb - Initialisierung des Clipboards

Syntax: clipb [Pfad]

Das Clipboard (oder Scrap-Directory) ist eine Einrichtung des Betriebssystems,
das die tempor„re Datenablage und den Datenaustausch zwischen mehreren Pro-
grammen untersttzen soll. Es besteht aus nichts weiter als einem Directory,
dessen Name vom AES gespeichert wird. Programme, die das Clipboard benutzen,
mssen sich diesen Namen vom AES mitteilen lassen und k”nnen, wenn sie sich
an einige Konventionen halten, mhelos mit anderen Programmen Dateien aus-
tauschen.

Die Okami-Shell untersttzt das Clipboard auf folgende Weise:

1) Nach Programmstart wird die Shell-Variable CLIPDIR mit dem Wert
   "X:\scrapdir\scrap.*" initialisiert, wobei X: das Bootlaufwerk ist. Das
   Atari-Profibuch schl„gt diesen Pfad als Clipboard vor. Dies hat noch nichts
   mit AES zu tun, da AES zu diesem Zeitpunkt noch gar nicht initialisiert ist.
2) Wenn die Shell mit dem Kommando gon bei AES angemeldet wird, wird der
   tats„chliche Clipboard-Pfad ermittelt und, falls vorhanden, in CLIPDIR ab-
   gelegt. Wenn noch kein Clipboard-Pfad definiert worden ist, wird der
   Inhalt von CLIPDIR als solcher festgelegt.
3) Das Kommando clipb legt (falls vorhanden) seinen Parameter in CLIPDIR
   ab ("clipb c:/scrap/*" beinhaltet also "CLIPDIR=c:/scrap/*"). Falls gon
   aktiv ist, wird danach der (ggfs. neue) Wert von CLIPDIR dem AES als
   Clipboard-Directory mitgeteilt. Auerdem wird der zugeh”rige Pfad an-
   gelegt.

Eine korrekte Initialisierung des Clipboards sieht also so aus:

	gon
	clipb

oder, wenn man den Pfad „ndern will:

	gon
	clipb g:/scrap/scrap.*

Diese Zeilen sollte man in sein Profile setzen, wenn man Programme benutzen
will, die das Clipboard verwenden.
Shellscripts k”nnen das Clipboard ebenfalls einsetzen, indem sie dessen Pfad
der Shell-Variablen CLIPDIR entnehmen.
Achtung: zu dem Clipboard-Pfad geh”rt nicht nur der Name des Ordners, sondern
auch der Name der zu benutzenden Dateien (scrap.*)!

Dieses Kommando benutzt keine Standard-Ein- oder Ausgabe.

Siehe auch:	gon

-----
cls - Bildschirm initialisieren

Syntax: cls

Loescht den Bildschirm, setzt den Cursor auf die erste Spalte in der
ersten Zeile und schaltet den Cursor auf sichtbar. Auerdem wird das
Word Wrap angeschaltet, das dafr sorgt, da Ausgaben, die l„nger als
eine Zeile sind, auf mehrere Zeilen verteilt werden.

-----
cmds - Ausgabe der internen Kommandos

Syntax: cmds [-Ca] {Pattern}

Es werden die Namen aller interner Kommandos ausgegeben, die auf die ange-
gebenen Patterns passen. Dabei gelten die Regeln der erweiterten Wildcards
(siehe okami.doc). Wenn kein Pattern angegeben ist, werden alle internen
Kommandos ausgegeben.

Flags:
	-C	Die Kommandos werden in mehreren Spalten ausgegeben. Auf diese
		Weise passen alle Kommandos auf einmal auf den Bildschirm.
	-a	Es werden auerdem die Startadressen der jeweiligen
		Funktionen ausgegeben (ja, fr den Anwender ist das
		V™LLIG uninteressant)

Beispiele:
	cmds		Ausgabe aller interner Kommandos
	cmds -a t*	Ausgabe aller Komandos, die mit t beginnen, sowie
			die Startadressen.
	cmds [abcd]*e	Ausgabe aller Kommandos, die mit a,b,c oder d beginnen
			und mit e aufh”ren.
	cmds | wc -l	Ausgabe der Anzahl der internen Kommandos.

Rckgabewert: Es wird die Anzahl der ausgegebenen Kommandos zurckgegeben.

-----
continue - SIEHE while

-----
cookie - Auslesen des Cookie-Jars

Syntax: cookie [-xdn0sc] {cookie}

Mit diesem Kommando kann der Cookie-Jar des Betriebssystems ausgelesen werden.
Der Cookie-Jar wird erst ab TOS 1.6 vom Betriebssystem selber genutzt, kann
aber (was die Okami-Shell tut) in allen frheren TOS-Versionen einfach in-
stalliert werden.
In dem Cookie-Jar k”nnen sich Programme mit einer Namenskennung und einer
Versionsnummer eintragen. Die Kennung ist genau 4 Bytes lang, belegt also ge-
nau wie die Versionsnummer ein Langwort (32 bit). Die Kennung der Okami-Shell
ist "OkSh", die Versionsnummer enth„lt bei Version 1.3 eine 1 im oberen und
eine 3 im unteren Byte des ersten Wortes (ist also 0x103).

Es werden alle Cookies ausgegeben, die auf die angefhrten Parameter passen,
wobei dieselben Regeln wie fr die erweiterten Wildcards gelten (siehe 
okami.doc). Wenn keine Parameter angegeben sind, lautet die Defaulteinstellung
"*", es werden also alle Cookies ausgegeben.

Der Rckgabewert ist die Anzahl der so gefundenen Cookies. Das Kommando kann
dadurch benutzt werden, um das Vorhandensein eines bestimmten Cookies nachzu-
prfen.

Flags:
	-x	Die Versionsnummer wird hexadezimal ausgegeben.
	-d	Die Versionsnummer wird dezimal ausgegeben.
	-n	Die Versionsnummer wird in der Form x.y ausgegeben, wobei
		x das obere und y das untere Byte des ersten Wortes darstellt.
		x und y	werden dabei dezimal ausgegeben.
		Dies ist die Default-Einstellung, wenn keine anderen Flags
		angegeben sind.
	-0	Es erfolgt keine Ausgabe. Ist ntzlich beim Testen auf vor-
		handene Cookies, siehe untenstehendes Beispiel.
	-s	Es wird auerdem eine Statistikangabe ber freie und belegte
		Pl„tze im Cookie-Jar ausgegeben.
	-c	Wenn dieses Flag angegeben ist, wird ein neuer Cookiejar ange-
		legt, in den die Shell sich eintr„gt. Dabei wird ein evtl.
		vorhandener Cookiejar berschrieben. Man sollte dieses Flag
		nur benutzen, wenn der Verdacht besteht, da eine unzul„ssige
		Adresse als Basisadresse des Cookiejar eingetragen ist (z.B.
		von einem weggebombtem Programm, das keine Zeit mehr hatte,
		die Adresse zu entfernen).
		Dieses Flag sollte nur in Notf„llen angewandt werden. Wenn
		ein frheres Programm, von dem aus die Shell gestartet wurde,
		einen Cookiejar anlegt und mit cookie -c diese Adresse ver-
		„ndert wird, das Programm das aber nicht bemerkt, kann das
		zum Absturz dieses Programmes fhren, wenn es versucht, den
		betreffenden Speicherbereich wieder freizugeben. (Die Okami-
		Shell ist gegen solche Vorf„lle geschtzt.)

Es kann nur eins der Flags x, d, n angegeben werden. Wenn mehrere dieser Flags
angegeben sind, gilt nur das zuerst stehende.

Beispiele:
	cookie
				Ausgabe aller installierten Eintr„ge.
	cookie -s [A-Z]*
				Ausgabe aller Eintr„ge, die mit einem Gro-
				buchstaben beginnen. Auerdem wird die Sta-
				tistik ausgegeben.
	cookie -x OkSh
				Ausgabe des Okami-Cookies in hexadezimal.
	if cookie -0 MiNT
	then
	  echo MiNT ist installiert.
	else
	  echo MiNT ist nicht installiert.
	fi
				Findet heraus, ob Mint installiert ist. Das
				cookie-Kommando erzeugt in dieser Form keine
				Ausgabe.

Rckgabewert: -2, wenn kein Cookie-Jar installiert ist (was nicht geschehen
drfte), -1 bei einem Syntaxfehler, sonst die Anzahl der gefundenen Cookies.
Wenn -0 angegeben ist, wird, wenn kein Cookie-Jar installiert ist (was hin
und wieder doch geschieht), 0 zurckgegeben.

Die Basisadresse des aktuellen Cookie-Jars kann mit dem Kommando "adr" er-
mittelt werden.

-----
cp - Kopieren von Dateien

Syntax: cp [-avif] Source {Source} Dest

Wenn Dest der Name eines existierenden Ordners ist, werden alle Dateien
Source in diesen Ordner kopiert. Der Dateiname der Kopien ist dann
Dest/`basename Source`.
Wenn Dest nicht der Name eines existierenden Ordners ist, wird die Datei
Source in die Datei Dest kopiert. In diesem Fall darf nur ein Source an-
gegeben sein.
Die Source-Angaben drfen erweiterte Wildcards enthalten. Die Maximalanzahl
der auf diese Weise benutzbaren Source-Dateien ist 100. Es drfen keine
Ordner als Source angegeben werden.

Flags:
	-a	Die Quelldatei wird an die Zieldatei angeh„ngt.
	-v	Bei jeder kopierten Datei wird eine Meldung ausgegeben. Das
		ist ntzlich beim Kopieren von vielen Dateien auf einmal.
	-i	Fragt vor dem šberschreiben bereits vorhandener Zieldateien
		nach, ob diese berschrieben werden drfen.
	-f	šberschreibt keine bereits vorhandenen Dateien.


Beispiele:
cp sh.ttp sh.prg		Kopieren einer Datei.
cp sh.ttp d:/shell		Kopieren einer Datei in einen Ordner, erzeugt
				wird d:/shell/sh.ttp.
cp e:/source/*.c a:/		Kopieren aller C-Dateien auf die Diskette.
cp -f e:/source/*.c a:/		dito, aber bereits vorhandene Dateien werden
				nicht berschrieben.
cp -a file1 file2		wesentlich schneller als `cat file1 >>file2'

-----
crypt - Ver- und Entschlsseln von Daten

Syntax: crypt [Schlssel]

crypt liest Daten von StdIn, verschlsselt sie mit dem angegebenen Schlssel
und schreibt das Ergebnis nach StdOut. Wenn kein Schlssel angegeben ist, wird
der Schlssel des vorigen crypt-Aufrufes benutzt (was allerdings nicht allzu
zuverl„ssig funktioniert, man sollte daher immer einen Schlssel angeben).
Durch erneutes Verschlsseln werden die Daten wieder entschlsselt.

Benutzt wird der Verschlsselungsalgorithmus von MicroEmacs, was bedeutet, da
die Verschlsselung kompatibel ist zu allen MicroEmacs-Versionen auf allen
Rechnern. Die in der Okami-Shell verwendete Verschlsselungsroutine stammt
aus den Quellen von MicroEmacs 3.9+.

Der Verschlsselungsalgorithmus ist so angelegt, da druckbare Ascii-Zeichen
wieder in solche verschlsselt werden. Steuerzeichen (Ascii<32 oder >127)
werden nicht ver„ndert. Dadurch ist die Verschlsselung einer reinen Ascii-
Datei wieder eine reine Ascii-Datei.

Beispiele:
	crypt xyz <secret.txt >secret.crp
		verschlsselt die Datei secret.txt und speichert das Ergebnis
		in der Datei secret.crp. Es wird der Schlssel "xyz" benutzt.
	crypt xyz <secret.crp
		entschlsselt secret.crp und gibt das Ergebnis auf dem Bild-
		schirm aus.
	crypt abc <secret.txt | crypt abc
		hat dieselbe Wirkung wie "cat secret.txt".
	ls -la *.c | crypt dubidu | hd
		erzeugt eine Dateiliste, verschlsselt sie mit dem Schlssel
		"dubidu" und fertigt von dem Ergebnis ein Hexdump an.
	crypt abc secret.txt
		verschlsselt die Tastatureingabe anhand des Schlssels
		"abc secret.txt".

-----
cursor - Konfiguration des VT52-Cursors

Syntax: cursor [(+|-)bv] [Rate]

Beim Aufruf ohne Parameter wird die aktuelle Blinkrate nach StdOut ge-
schrieben.
Wenn Rate angegeben wird, wird die Blinkrate auf Rate gesetzt. Werte fr
Rate: 30 normal, <30: schneller, >30: langsamer, 0: nicht blinkend.
Flags: +v	der Cursor wird sichtbar.
       -v	der Cursor wird unsichtbar.
       +b	der Cursor wird blinkend.
       -b	der Cursor h”rt auf zu blinken (unabh„ngig von Rate).

Beispiel:
Der Cursor soll w„hrend der Ausfhrung eines Programms schneller blinken
und dann auf den alten Wert zurckgestellt werden.

	ALT=`cursor`
	cursor 5
	.....................	(das auszufhrende Programm)
	cursor $ALT
	unset ALT

Rckgabewert: der Ascii-Code des ersten eingegebenen Zeichens.

Siehe auch:	keyb
		mouse
		scr

-----
dark - Bildschirm dunkelschalten

Syntax: dark

Hat dieselbe Wirkung wie ein Druck auf Control-A in der Tastatureingabe
(siehe okami.doc). Der Sinn dieses Kommandos ist, da man von Programmen
aus, die Shellaufrufe ber den _shell_p-Zeiger erm”glichen, den Bildschirm
auf Kommando dunkelschalten kann.

-----
date - Ausgabe der Systemzeit

Syntax: date [+Fmt]

Datum und Uhrzeit werden nach StdOut geschrieben.
Wenn ein mit einem Pluszeichen eingeleiteter Formatstring angegeben ist,
wird das Datum in dem angegebenen Format ausgegeben. In dem Formatstring
k”nnen Formatelemente enthalten sein, die folgendes bedeuten:

	%d	Nummer des Tages im Monat (00...31)
	%h	Abkrzung des Monatsnamens (Jan...Dec)
	%H	Stunde (00...23)
	%m	Nummer des Monats (00...12)
	%M	Minute (00.59)
	%n	erzeugt einen Zeilenvorschub
	%S	Sekunde (00...59)
	%t	erzeugt einen Tabulatorvorschub
	%y	Jahr zweistellig (00...99)
	%Y	Jahr vierstellig (1900...????)
	%%	erzeugt ein Prozentzeichen

Alle anderen Zeichen werden direkt ausgegeben.

Wenn kein Formatstring angegeben ist, lautet die Voreinstellung:
	date +%d.%m.%Y %H:%M:%S

Beispiele:
	Eingabe...			Ausgabe... (z.B.)
	date				06.09.1990 21:38:07
	date +Das Jahr ist %Y		Das Jahr ist 1990
	date +%h. %dth, %Y		Sep. 06th, 1990
	date +Hallo, wie gehts		Hallo, wie gehts

-----
dial - W„hlen von Telefonnummern ber das Modem

Syntax:	dial [-q|-f [Dateiname]|{Nummer|Krzel|-d}]

Dieses Kommando ist fr Besitzer von Modems interessant, an denen ein Telefon
angeschlossen werden kann. Man kann Telefonnummern vom Rechner aus ber das
Modem w„hlen lassen und dann normal telefonieren. Das dial-Kommando erweitert
das vorhandene Telefon um Rufnummernverzeichnis, Tastatur, Display und
Wahlwiederholung.

Wenn kein Parameter angegeben ist, wird die beim letzten Aufruf angegebene
Nummer noch einmal gew„hlt.

Wenn der Parameter -q angegeben ist, wird die beim letzten Aufruf angegebene
Nummer ausgegeben.

Wenn der Parameter -f, gefolgt von einem Dateinamen, angegeben ist, wird die
angegebene Datei als Rufnummerndatei geladen. Wenn -f ohne Dateinamen ange-
geben ist ,wird eine evtl. residente Rufnummerndatei aus dem Speicher ent-
fernt.

Achtung: wenn eins der Flags -f oder -q benutzt wird, so drfen keine anderen
Flags oder Parameter benutzt werden.

Alle anderen Parameter werden als Nummern oder Krzel betrachtet. Als Nummer
gilt alles, was mit einer Ziffer beginnt, als Krzel gilt alles andere. Ein
Underscore als Krzel steht fr die beim letzten Aufruf angegebene Nummer.
Wenn dabei das Flag -d angegeben ist, wird die Nummer nur ausgegeben und
nicht gew„hlt.

Die Krzel werden anhand einer Rufnummerndatei interpretiert. Diese Datei wird
bei ihrer ersten Benutzung in den Speicher geladen und resident gehalten, bis
mit -d eine andere Datei gew„hlt oder die Shell beendet wird. Der Default-
Dateiname ist $ETC/dial.inf .

Die einzelnen Zeilen der Rufnummerndatei enthalten jeweils ein Krzel und eine
Nummer. Krzel und Nummer mssen durch mindestens ein Whitespace-Zeichen 
(Space, Tab...) getrennt sein. Gro/Kleinschreibung ist ohne Bedeutung. Alle
nicht-Ziffern in der Nummer werden ignoriert. Zeilen, die mit einem Doppel-
kreuz beginnen, sowie Leerzeilen gelten als Kommentarzeilen. Whitespace-
Zeichen am Anfang und Ende der Zeilen werden ebenfalls ignoriert.

Die Nummer wird gew„hlt, indem folgende Zeichenketten nacheinander an die
serielle Schnittstelle geschickt werden:

	1) der Inhalt der Shellvariablen DIALPREFIX oder, wenn diese
	   Variable nicht gesetzt ist, die Zeichenkette "ATD",
	2) alle Ziffern der gew„hlten Nummer,
	3) ein CR-Zeichen.

Der Anwender hat selber dafr zu sorgen, da an der Schnittstelle ein Modem
angeschlossen ist und da die Schnittstelle korrekt initialisiert ist.

Wenn bei der Expansion der Krzel ein Fehler auftritt, weil die Rufnummern-
datei nicht ge”ffnet werden kann oder ein unbekanntes Krzel auftritt, wird
das Kommando nicht abgebrochen, sondern es wird das fehlerhafte Krzel ig-
noriert.

Beispiele:

Auszug aus einer Rufnummerndatei:

	# Vorwahlen
	Aachen		0241
	K”ln		0221
	Mnchen		089
	# Nummern
	W.R”sler	534596
	Zeit		1191

Achtung: zwischen dem Krzel (z.B. Aachen) und der Nummer (z.B. 0241-) muss
immer ein Tab-Zeichen stehen!


dial 534596
			die angegebene Nummer wird gew„hlt.
dial 0241 _
			die letzte Nummer wird mit einer Vorwahl versehen.
			Anstelle des Underscores tritt die zuletzt gew„hlte
			Nummer.
dial 0241 534596
			mit Vorwahl.
dial 0241534596
			hat dieselbe Wirkung.
dial 0241-53.45.96
			ebenso. Nicht-Ziffern werden ignoriert.
dial Aachen 123456
			die Vorwahl von Aachen wird aus der Rufnummerndatei
			geholt.
dial Aachen W.R”sler
			Vorwahl und Nummer werden aus der Datei geholt.
dial aachen w.r”sler
			ebenso. Gro/Kleinschreibung ist ohne Bedeutung.
dial -d K”ln 121.345.4-5
			die Nummer wird zusammengebaut und ausgegeben, aber
			nicht gew„hlt (-d).
dial -f mydial
			die Datei mydial wird als Rufnummerndatei geladen. Es
			wird nichts gew„hlt.
dial -f
			eine evtl. residente Rufnummerndatei wird aus dem
			Speicher entfernt.
DIALPREFIX=ATDT
			Einstellen eines anderen Pr„fixes fr die zum Modem
			zu schickende Steuersequenz.
dial
			die letzte Nummer wird noch einmal gew„hlt.
dial -q
			die letzte Nummer wird ausgegeben. Es wird nichts
			gew„hlt.

Siehe auch:	rsconf

-----
df - Anzeige der Belegung der Massespeicher

Syntax: df [-dnmbf] {Drive}

Gibt Informationen ber freie und belegte Bytes und Cluster auf allen
angemeldeten Laufwerken oder, wenn Drive angegeben ist, nur von Laufwerk
Drive. Nur der erste Buchstabe von Drive ist relevant, d.h. fr Informa-
tionen ber Laufwerk A: gengt: df a

Flag:	-d	Es werden fr jedes Laufwerk folgende Daten ausgegeben:
			Anzahl der Cluster,
			Anzahl der Sektoren pro Cluster,
			Anzahl der Bytes pro Sektor,
			Anzahl der freien Cluster.
		Dies entspricht der Rckgabe der Gemdos-Funktion Dfree.
	-n	Es wird keine šberschrift ausgegeben.
	-m	Es wird eine Liste der angeschlossenen Laufwerke ausge-
		geben. -n und -d sind ohne Wirkung.
	-b	Wenn nur ein Laufwerk angeschlossen ist, das sowohl als
		A: als auch als B: angesprochen werden kann, werden, wenn
		dieses Flag angegeben ist, bei der šbersicht (auch bei -m)
		die Angaben von A: und von B: ausgegeben (wenn -m nicht
		angegeben ist, ist also ein Diskettenwechsel n”tig). Wenn
		-b nicht angegeben ist, werden, wenn nur ein Disketten-
		laufwerk vorhanden ist, keine Angaben ber Laufwerk B:
		ausgegeben (auch nicht bei -m).
	-f	Es wird nur die Anzahl der freien Bytes nach StdOut ge-
		schrieben. Mit dieser Option kann z.B. ein Shellscript
		feststellen, ob der Diskette gengend Platz vorhanden ist.

Rckgabewert: (nur fr df -m)
	-1	Aufruffehler.
	sonst	Anzahl der ausgegebenen Laufwerke.

Siehe auch:	du

-----
dirname - Ermitteln des Pfades

Syntax: dirname file

Es wird der Pfad der Datei ausgegeben.
Bsp: dirname a:\okami\sh.ttp ergibt a:\okami.

Siehe auch: basename
	    drvname
	    extname
	    fullname

-----
do - SIEHE while

-----
done - SIEHE while

-----
drive - Festlegen und Auslesen der Laufwerksbezeichnungen

Syntax: drive ["Drive {Drive}" [String]]

Mit diesem Kommando kann jedem Laufwerk eine Bezeichnung zugeordnet werden.
Diese Bezeichnung wird z.B. von dem internen Kommando df ausgegeben.
Wenn keine Parameter angegeben sind, werden alle vorhandenen Bezeichnungen
ausgegeben.
Wenn nur ein Parameter (d.h. ein einziges Wort, ggfs. in doppelten Anfhrungs-
zeichen) angegeben ist, so wird jeder Buchstabe dieses Wortes als Laufwerk be-
trachtet und die Bezeichnung dieses Laufwerks ausgegeben. Zeichen auer A bis
Z und a bis z werden dabei ignoriert.
Wenn ein String ausgegeben ist, wird dieser jedem der angegebenen Lauf-
werke als Laufwerksbezeichnung zugeordnet.

Beispiele:
1) Ausgabe aller Laufwerksbezeichnungen:
	drive

2) Ausgabe der Bezeichnung von Laufwerk A:
	drive A:
   oder
	drive a

3) Ausgabe der Bezeichnungen der Laufwerke A,C und G:
	drive acg
   oder
   	drive "A: C: G:"

4) Setzen der Bezeichnung "Diskette" fr Laufwerk A:
	drive a Diskette

5) Setzen der Bezeichnung "Platte" fr Laufwerke C bis F:
	drive cdef Platte
   oder
	drive "C D E F" Platte
   aber nicht
   	drive C D E F Platte

Eine weitere M”glichkeit, die Laufwerksbezeichnungen zu initialisieren,
ist das interne Kommando rdti, das die Bezeichnungen direkt aus der
desktop.inf-Datei l„dt.

-----
drvname - Ermitteln des Laufwerks

Syntax: drvname file

Es wird der Name des Ger„tes von file ausgegeben.
Bsp: drvname a:\okami\sh.ttp ergibt a:.

Siehe auch: basename
	    dirname
	    extname
	    fullname

-----
du - Ausgabe des Plattenbedarfs

Syntax: du [-brft] {Directory}

du ermittelt zu jedem der angegebenen Directories den Bedarf an Platten-
speicherplatz. Das ist die Summe aus den L„ngen aller in den Directories
enthaltenen Dateien plus der Platzbedarf aller enthaltenen Subdirectories.
Auerdem dient du zur baumartigen Darstellung der Ordnerhierarchie.
Die Ausgabe von du erfolgt in Clustern. Ein Cluster entspricht i.d.R.
einem Kilobyte auf der Platte, die tats„chliche Gr”e wird aus dem Bios-
Parameterblock ermittelt. Der Platzbedarf einer Datei entspricht der Anzahl
der ben”tigten Cluster, ist also i.d.R. gr”er als die Dateil„nge.
Wenn keine Parameter angegeben sind, lautet die Defaulteinstellung "-r .".
Wenn kein Directory angegeben ist, wird das aktuelle Directory benutzt.
	
Flags:
	-b	Es wird nicht der Platzbedarf in Clustern, sondern die
		Dateil„nge in Bytes errechnet und ausgegeben.
	-r	Es wird nur der Platzbedarf der angegebenen Directories
		ausgegeben. Wenn dieses Flag nicht angegeben ist, wird auch
		der Platzbedarf aller enthaltenen Subdirectories ausgegeben.
	-f	Es wird zus„tzlich der Platzbedarf aller enthaltenen Dateien
		ausgegeben. Wenn dieses Flag nicht angegeben ist, wird nur
		der Platzbedarf von Directories ausgegeben.
		Wenn -t angegeben ist, hat dieses Flag die umgekehrte Wirkung:
		es werden dann keine Dateien, sondern nur Directories ausge-
		geben. Dies ist ntzlich fr einen schnellen šberblick ber
		die Ordnerstruktur.
	-t	erzeugt eine baumartige Ausgabe der Ordnerstruktur. Die Flags
		-b und -r sind ohne Wirkung.

Beispiele:

du /okami	ergibt: (Angaben in Cluster)
		1    	bin
		615  	doc
		74   	ok_demo\doc
		125  	ok_demo
		2000 	\okami

du -b /okami	ergibt: (Angaben in Bytes)
		292  	bin
		617210	doc
		73148	ok_demo\doc
		121683	ok_demo
		1978543	\okami

du -r /okami	ergibt: (nur das angegebene Directory)
		2000 	e:\okami

du -f /okami	ergibt: (Ausgabe mit allen Dateien) (Ausschnitt)
		36   	cmds2.c
		27   	utl4.c
		48   	sh.c
		1    	bin\ship.exe
		1    	bin
		2000 	\okami

du -t /okami	ergibt: (Ausgabe als Baum mit Dateien) (Ausschnitt)
		okami\
			cmds2.c
			utl4.c
			sh.c
			bin\
				ship.exe
du -tf /okami	ergibt: (dito ohne Dateien)
		okami\
			bin\
			doc\
			ok_demo\
				doc\

Siehe auch:	df

-----
echo - Ausgabe eines Strings

Syntax: echo String

Schreibt String nach StdOut. String kann leer sein, d.h. echo ohne Para-
meter schreibt eine Leerzeile nach StdOut.
In dem String sind folgende Sonderzeichen erlaubt:
^n	erzeugt ein Newline-Zeichen (in C: '\n')
^t	erzeugt ein Tabulator-Zeichen (in C: '\t')
^ooo	wobei ooo eine dreistellige Oktalzahl ist: erzeugt das Zeichen
	mit dem Ascii-Code ooo.
	Beipiel: echo ^033pHallo^033q schreibt Hallo in invertierter Schrift.
^;	erzeugt ein Semikolon, das nicht als Trenner von Kommandos wirkt.
	Siehe unten.
^>
^<
^|
^`	erzeugen analog dazu Gr”er-, Kleiner-, Pipe- und Accent Grave-Zei-
	chen, die nicht	die Ein/Ausgabeumleitung bzw. Command Substitution
	bewirken.
^c	am Ende des Strings verhindert den Zeilenvorschub, d.h. der Cursor
	bleibt am Ende der Zeile.
^x	wobei x ein beliebiges Zeichen ausser n, t, c, 0..7 ist: erzeugt
	das Zeichen x. Dies ist nuetzlich zum Beenden von Variablenauf-
	rufen. Beispiel:

	VAR=Halli
	echo $VARHallo		gibt den Wert der Variable VARHallo aus
	echo $VAR^Hallo 	gibt die Ausgabe HalliHallo.

^^	erzeugt ein Hoch-Zeichen.

Achtung: Whitespace-Zeichen wie ^t und ^n mssen in doppelten Anfhrungs-
zeichen (") stehen, um wirksam zu werden.

Diese Sonderzeichen gelten nicht nur bei der Angabe von Parametern des echo-
Kommandos, sondern fr alle Kommandos.

Das Hoch-Zeichen hat also die Funktion, die im herkoemmlichen UNIX-"echo"
der Backslash hat. Unter TOS wird der Backslash allerdings (in MS-DOS-
Konvention) als Trennzeichen zwischen Pfad(en) und Dateinamen benutzt
(wofr es in UNIX den normalen Slash gibt). Daher wird in der Okami-Shell
der Backslash durch das Hoch-Zeichen ersetzt. Deswegen mu man in der
Okami-Shell darauf verzichten, das Hoch-Zeichen anstelle des Pipe-Symbols
(|) zu benutzen, was in Unix teilweise blich ist.
(Fazit: Es ist nicht leicht, MS-DOS und Unix unter einen Hut zu bringen,
und TOS ist eine unm”gliche Mischung von beidem)

Beispiele:

1) Ausgabe des aktuellen Directories:
	echo Das aktuelle Directory ist $CWD
        
2) Ausgabe von VT52-Sequenzen:
	echo ^033e		schaltet den Cursor ab
	echo ^033H		setzt den Cursor auf Home-Position etc.

3) Ausgabe eines Semikolons:
	echo Hallo ; ls -l	schreibt "Hallo" und fhrt das Kommando
				"ls -l" aus.
	echo Hallo ^; ls -l	schreibt "Hallo ; ls -l".

4) Benutzung der Sonderzeichen in anderen Shellkommandos: Einstellen eines
   Shellprompts, das aus dem String "Eingabe: >" in invertierter Schrift
   besteht; vor jedem Prompt soll ein Signalton erzeugt werden.
	PS1="^007^033pEingabe: ^>^033q"

-----
else - SIEHE if

-----
env - Ausgabe des Environments der Shell

Syntax: env

Die der Shell bergebenen Environment-Strings werden nach StdOut ausgegeben.
Nach jedem String wird ein Newline-Zeichen eingefgt.
Dieses Kommando arbeitet ausschlielich auf dem der Shell bergebenen
Environment, was bedeutet, da nach dem Start der Shell exportierte Shell-
variablen nicht mit ausgegeben werden. Um alle exportierten Shellvariablen
auszugeben, gibt es das Kommando `vars -ex'.

Siehe auch:	export
		vars

-----
errcode - Analyse von Fehlernummern

Syntax: errcode {Fehlernummer|errno}

errcode liefert zu einer Bios-, XBios- oder Gemdos-Fehlernummer einen er-
kl„renden Text. Als Fehlernummer kan jede beliebige Zahl oder das Wort
"errno" angegeben sein, in letzterem Fall wird der Wert der internen Fehler-
variablen errno benutzt. Fehlernummern k”nnen positiv oder negativ angegeben
werden; da das Betriebssystem nur negative Fehlernummern benutzt, werden posi-
tive Nummern negiert. Die Ausgabe hat die Form
	Nummer: Text
Die Nummer wird dezimal ausgegeben und entspricht dem jeweiligen Parameter
oder dem Inhalt von errno. Der Text ist eine Kurzdefinition der Nummer. Bei
einer unbekannten Nummer lautet der Text "???".
Die Voreinstellung, wenn keine Parameter angegeben sind, lautet "errno".

-----
exec - Ausfhren einer Datei als Bin„rprogramm

Syntax: exec [-(l|b)g] Dateiname {Parameter}
oder	exec -x Basepage-Adresse {Parameter}

Dient zum Laden oder Starten einer Datei als Bin„r-Programmdatei. Entspricht
der Gemdos-Funktion "Pexec".
Es mu der vollst„ndige Dateiname (relativ oder absolut) angegeben werden.
Die Shellvariablen PATH und XEXT sind ohne Wirkung. Die Shellvariable GEXT
entscheidet, ob das Programm als GEM-Programm starten soll. Wenn das Flag -g
angegeben ist, wird das Programm nicht ber die Shellfunktion gemexec ausge-
fhrt, auch wenn der Extender in $GEXT aufgefhrt ist. Dies ist die Art und
Weise, mit der gemexec Programme ausfhrt.
Wenn das Flag -x angegeben ist, werden Programme, die zuvor mit -l geladen
wurden, gestartet. Dazu mu die von -l ermittelte Basepage-Adresse ber-
geben werden.

Achtung: Wenn Flags angegeben sind, so mssen sie zu Beginn, also vor dem
Dateinamen stehen und drfen nicht durch Leerzeichen getrennt sein.

Beispiele:
1)	exec datei.ttp p1 p2 p3
		l„dt und startet die Datei datei.ttp im aktuellen Verzeich-
		nis. Der String "p1 p2 p3" wird als Parameterzeile ber-
		geben.
2)	exec datei.prg
		Wenn der Extender .prg in der Shell-Variablen GEXT gespeichert
		ist, wird die Datei datei.prg ber die Shellfunktion gemexec
		ausgefhrt, ansonsten wird sie geladen und gestartet.
3)	exec -g datei.prg
		Die Datei datei.prg wird geladen und gestartet, auch wenn der
		Extender .prg in GEXT gespeichert ist. Die Funktion gemexec
		wird also nicht aufgerufen.
4)	exec datei.prg -g
		wie 2), aber es wird die Zeichenkette "-g" an das Programm
		bergeben.
5)	exec -l datei.ttp
		Die Datei wird geladen. Die Startadresse der Basepage des
		Programms wird in hexadezimaler Schreibweise auf den Bild-
		schirm geschrieben. Die Adresse der Basepage kann mit
		exec -x oder dem Kommando basep weiterverarbeitet werden.
		Das Angeben von Parametern ist m”glich, aber nicht sinnvoll,
		da diese beim Start des Programms mit exec -x berschrieben
		werden.
6)	exec -b datei.ttp p1 p2 p3
		wie 2), aber es wird die Basepage des Programms erzeugt.
7)	exec -x 0x65abc file.c
		Die zuvor mit exec -l geladene Datei datei.ttp wird ge-
		startet. Die Zeichenkette `file.c' wird als Parameter
		bergeben. exec -l sollte die Ausgabe "0x65ABC" erzeugt haben.

VORSICHT: Wenn bei der Verwendung von exec -x eine falsche Adresse angege-
ben wird, ist ein Absturz der Shell m”glich. Es sollte nur eine Adresse
verwendet werden, die zuvor mit exec -l ermittelt wurde.

Siehe auch:	basep
		gemexec

-----
exit - Beenden der Shell oder eines Shellscripts

Syntax: exit

Im Dialogmodus: beendet die Shell. Hat dieselbe Wirkung wie ein Druck auf
Ctrl V in der Kommandoeingabe.
Nach einem exit wird folgendes getan:
1)  ein evtl. mit trap definiertes Kommando wird ausgefhrt.
2)  wenn gon eingegeben worden ist, aber noch kein goff, wird goff aufgeru-
    fen.
3)  die Speicherbereiche der Shell-Variablen werden freigegeben.
4)  die Speicherbereiche der Tastatur-History werden freigegeben.
5)  der fr getscr/putscr reservierte Speicherbereich wird freigegeben.
6)  ein evtl. residentes Helpfile wird freigegeben.
7)  die Speicherbereiche der Shellfunktionen werden freigegeben.
8)  die Speicherbereiche der Laufwerksbezeichnungen werden freigegeben.
9)  die Speicherbereiche der Tastendefinitionen werden freigegeben.
10) wenn das Shellflag s gesetzt ist, wird das aktuelle Verzeichnis in die
    Datei $HOME\wdir gespeichert und diese Datei unsichtbar gemacht.
11) die DTA wird auf den Zustand vor dem Start der Shell zurckgestellt.
12) der Eintrag im Cookiejar wird entfernt und ggfs. der Speicherbereich des
    Cookiejars freigegeben.
13) alle evtl. noch offenen Umleitungsdateien werden geschlossen.
14) der Speicherbereich der Enviromnent-Stringpointer wird freigegeben.
15) das Programm wird beendet.

Wenn dieses Kommando in einem Shellscript steht, wird nur das Shellscript
beendet. Es wird keine der oben angefhrten Aktionen durchgefhrt.

-----
export - Markieren von Shell-Variablen fr das Environment

Syntax: export [[-] {Variable}]

Alle als exportiert markierten Shellvariablen werden beim Start eines
Bin„rprogrammes als Environment in die Basepage des neuen Programmes ein-
getragen. Dadurch ist es m”glich, eine Umgebung zu schaffen, die beim 
Start weiterer Programme erhalten bleibt.
Beim Aufruf ohne Parameter wird eine Liste aller exportierter Variablen
ausgegeben.
Beim Aufruf mit den Namen von mindestens einer Shellvariablen werden alle
angegebenen Variablen als exportiert markiert. Wenn Variablen angegeben
werden, die noch nicht existieren, so werden diese mit einem leeren Wert
angelegt und exportiert.
Die Namen der Variablen k”nnen dabei im Format der erweiterten Wildcards
angegeben werden, z.B. "export a*" exportiert alle Variablen, deren Name
mit a beginnt. N„heres siehe okami.doc.

Flag:	-	Bei den angegebenen Variablen wird die Exporiert-Markierung
		gel”scht. Damit k”nnen Variablen aus dem Environment ent-
		fernt werden.

Beispiel:
	PS1="Eingabe:"			ndern des Shell-Prompts
	export PS1			šbernahme von PS1 ins Environment
	sh				Wieder-Aufruf der Shell (Subshell)
	echo PS1			Es erscheint "Eingabe:", da die
					Variable PS1 aus dem Environment
					eingestellt wurde.
	exit				Beenden der aufgerufenen Subshell.
	export - PS1			Entfernen von PS1 aus dem Environm.

Siehe auch:	env
		readonly
		vars
Zum Format des Environments siehe okami.doc.

-----
extname - Ermitteln des Dateinamen-Extenders

Syntax: extname filename

Der Extender des angegebenen Filenamen wird nach StdOut geschrieben (incl.
dem Punkt vor dem Extender). Wenn der Dateiname keinen Extender hat, wird
nur ein Zeilenvorschub ausgegeben.
Dies ist eine reine Stringfunktion, das Ergebnis ist unabh„ngig von der
Einstellung des Shell-Flags l (siehe set) und davon, ob die angegebene Datei
existiert oder nicht.

Beispiele:
	extname d:/shell/sh.ttp 	erzeugt die Ausgabe ".ttp".
	extname profile			erzeugt einen Zeilenvorschub.
	EXT=`extname hallo.txt`		einlesen in eine Variable.

Siehe auch: basename
	    dirname
	    drvname
	    fullname

-----
false - Rckgabe von 0

Syntax: false

Dieses Kommando gibt immer eine 0 zurck. Es wird normalerweise mit while
oder if verwendet.

Beispiel: Ausblenden eines Teiles eines Shellscripts. Durch "true" anstelle
von "false" kann der Teil wieder aktiviert werden.

		if false
		then
		  ............. (irgendwelche Kommandos)
		fi

Siehe: if
       while
       true

-----
fcts - Liste der Shellfunktionen

Syntax: fcts [-l]

Es wird eine Liste aller Shellfunktionen ausgegeben. Zu jeder Funktion er-
scheint eine Zeile der Form:

	365  hallo()

Die Zahl ist die Gr”e der Funktion in Bytes.
Nach der Liste wird eine Statistik ausgegeben, die folgende Angaben umfat:
	Summe der Gr”en aller Funktionen,
	Anzahl der Funktionen,
	Maximalanzahl der zu definierenden Funktionen,
	prozentuelle Belegung der Funktionstabelle.

Wenn das Flag -l angegeben ist, werden stattdessen die Definitionen aller
Shellfunktionen ausgegeben, und zwar in einem Format, das sp„ter zur Ins-
tallation der Shellfunktionen benutzt werden kann.

Beispiel:

	trap +fcts -l ^>$ETC/fcts.sh

schreibt bei Ende der Shell die Definitionen aller Funktionen in die Datei
$ETC/fcts.sh . Mit der folgenden Zeile im Profile:

	. $ETC/fcts.sh

werden die Funktionen dann wieder geladen und so auf die alten Werte einge-
stellt.

-----
fgrep - SIEHE grep

-----
fi - SIEHE if

-----
find - Suchen von Dateien

Syntax: find Startdirectory Suchmaske

Findet alle Dateien ab dem angegebenen Startdirectory, die auf die ange-
gebene Suchmaske passen. Es wird rekursiv in allen Ordnern gesucht.

Beispiel:
1) Ausgabe aller Shellscripts, die unter dem Home-Directory liegen:
	find $HOME *.sh
        
2) Listen aller Dateien, die auf einer Festplattenpartition liegen:
	find c:\ *
        
3) Listen aller C-Quelldateien ab dem aktuellen Directory:
	find . *.c


Die Verwendung dieses Kommandos ist ntzlich mit Kommandos, die von ihrer
Eingabe Dateinamen einlesen (z.B. backup). In Verbindung mit xargs k”nnen
auch andere Kommandos fr die entsprechenden Dateien aufgerufen werden.

-----
fsel - eine Datei mit der Fileselect-Box ausw„hlen

Syntax: fsel [Pfad [Default [Variable [Label]]]]

Es wird die AES-Fileselect-Box aufgerufen, um eine Datei auszuw„hlen,
deren Name nach StdOut geschrieben wird. Damit dieser Aufruf funktioniert,
mu die Shell als GEM-Applikation angemeldet werden. Dies geschieht mit
dem Kommando gon, das vor fsel aufgerufen werden mu.

In Pfad kann der Suchpfad und das Suchmuster der darzustellenden Dateien
angegeben werden. In Default kann der als ausgew„hlt voreinzustellende
Dateiname angegeben werden. Label ist die šberschrift fr die Fileselect-
Box. Die Angabe einer šberschrift ist erst ab TOS 1.4 m”glich, bei „lteren
TOS-Versionen ist dieser Parameter ohne Wirkung. Wenn Label Leerzeichen
enth„lt, mu es in Anfhrungszeichen eingeschlossen sein.
Achtung: da die Pfadangabe nicht von der Shell, sondern vom AES ausge-
wertet wird, drfen hier nur Gemdos-Wildcards benutzt werden.
Wenn Pfad, Default oder Label nicht angegeben sind lautet die Voreinstellung:

	Pfad	= ".\*.*"	(alle Dateien im aktuellen Directory)
	Default = ""		(keine Voreinstellung)
	Label   = "Okami Shell"

Wenn der Anwender die Abbruch-Taste der Fileselect-Box anw„hlt, gibt fsel
eine 0 zurck, ansonsten eine 1. Dieser Rckgabewert kann in der Shell-
variablen "?" abgefragt werden.
Wenn als dritter Parameter eine Variable angegeben ist, wird der Rck-
gabewert (0 bei Abbruch, 1 sonst) auch in dieser Variablen abgelegt.
Wenn dieser Parameter, nicht aber der zweite benutzt wird (weil keine Vor-
einstellung gewnscht ist), mu der zweite Parameter . (Punkt) oder ""
(zwei doppelte Anfhrungszeichen) lauten.

Beispiele:
	gon			mu immer zuerst kommen
	fsel			Auswahl aus allen Dateien im aktuellen Dir.
	fsel *.c		Auswahl aus allen C-Dateien
	fsel e:\shell\*.c	Auswahl aus den C-Dateien in e:\shell
	A=`fsel *.c`		Einlesen in eine Variable
	echo $? 		Ausgabe von 0, falls Abbruch, 1 sonst
	fsel *.c sh.c VAR
	echo $VAR		Ergebnis in eine Variable speichern
	fsel *.c sh.c VAR "Bitte eine Datei ausw„hlen"
				Benutzung der šberschrift

Da die Fileselect-Box den von ihr benutzten Bildschirmbereich nicht wieder
restauriert, speichert fsel den gesamten Bildschirm vor dem Aufruf der
Fileselect-Box ab. Daher mssen beim Aufruf von fsel mindestens 32000
Bytes an freiem Speicher verfgbar sein.

Rckgabewert:
	1	Abbruch angew„hlt.
	0	Ok angew„hlt.

-----
fullname - Ermitteln des absoluten Dateinamens

Syntax: fullname file

Ermittelt den vollen, absoluten Dateinamen der angegebenen Datei. Der abso-
lute Dateiname ist von dem Format
	Laufwerk ":\" Pfad "\" Dateiname
z.B. "d:\shell\sh.ttp". Es ist ohne Bedeutung, ob eine Datei mit dem ange-
gebenen Namen existiert.

Beispiele: Es sei D: das aktuelle Laufwerk, d:\shell das aktuelle Directory
von Laufwerk D: und c:\compiler\cc das aktuelle Laufwerk von Laufwerk C:.

	fullname von... 		ergibt...

	c:\files\hallo.txt		c:\files\hallo.txt
	c:test.c			c:\compiler\cc\test.c
	sh.ttp				d:\shell\sh.ttp
	\sh.ttp 			d:\sh.ttp
	bin\ship.exe			d:\shell\bin\ship.exe

Siehe auch: basename
	    dirname
	    drvname
	    extname

-----
gemexec - Shellfunktion zum Starten von GEM-Programmen

Syntax: Programmname {Parameter}

Bei gemexec handelt es sich um eine Shellfunktion, die nicht direkt vom Be-
nutzer, sondern von der Shell selber aufgerufen wird. Der Sinn der Sache ist,
manche Programme, insbesondere GEM-Programme, unter besonderen Bedingungen
aufzurufen. Wenn ein GEM-Programm aufgerufen wird, soll z.B. vorher der Bild-
schirm gel”scht, der Cursor ab- und die Maus eingeschaltet werden, und nach
dem Ende des Programms soll der Bildschirm wieder gel”scht werden. Um diese
Prozedur m”glichst flexibel und vom Anwender konfigurierbar zu gestalten, wer-
den GEM-Programme (das sind per Definition alle externen Kommandos, deren
Extender in der Shellvariablen GEXT gespeichert sind) ber die Shellfunktion
gemexec ausgefhrt. Diese Funktion kann alle weiteren Aktionen durchfhren und
ist auch dafr verantwortlich, da das Programm berhaupt gestartet wird.

Nach dem Start der Shell wird die Funktion folgendermaen initialisiert:

	gemexec()
	{
	  _=$0 $*
	  cursor -v;scr -g
	  exec -g $_
	  cls
	  _=
	}

Beim Aufruf der Funktion gemexec enth„lt die Shellvariable $0 nicht den Namen
der Funktion, sondern den vollst„ndigen Pfadnamen des aufzurufenden Programms.
Die Shellvariable $* enth„lt die zu bergebenen Parameter. Die Funktion kann 
kann vom Anwender beliebig ver„ndert werden, aber um das betreffende Programm
ordnungsgem„ aufzurufen, sollte sie zumindest folgendes tun:

	1) Speichern von $0 und $* in einer Shellvariablen, hier: _
	2) Durchfhrung aller Aktionen vor Programmstart, hier: cls und
	   cursor -v (Bildschirm l”schen und Cursor abschalten).
	3) Aufruf des Programms mit dem Kommando "exec -g $_"
	   Anstelle von $_ kann die in 1) benutzte Variable, aber
	   auch andere Werte stehen.
	   ACHTUNG: Beim Aufruf von exec mu UNBEDINGT das Flag -g angegeben
	   werden!!!!! Ansonsten wird exec die Funktion gemexec nochmal mit
	   denselben Parametern aufrufen => infinite Rekursion.
	4) Die Freigabe der Variablen (hier: _) ist nicht unbedingt notwendig,
	   da sie immer wieder verwendet wird.

Die Funktion gemexec kann wie jede Shellfunktion programmiert werden, was be-
deutet, da sie auch Kontrollstrukturen wie if und while beinhalten kann. Sie
kann den in $0 bergebenen Programmnamen mit basename und extname analysieren
und entsprechende Operationen durchfhren. Sie mu nicht unbedingt das Pro-
gramm, da in $0 bergeben wird, ausfhren; dadurch ist es m”glich, etwas
v”llig anderes als ein Programm auf diese Weise aufzurufen.

In der Datei tricks.doc befindet sich eine gemexec-Funktion, die nach dem
Ende eines GEM Programms den Bildschirm wieder so herstellt, wie er vor dem
Aufruf war, sowie eine, die das "Anwendung anmelden" des Desktop simuliert.

Siehe auch:	exec
		den Abschnitt ber gemexec in tricks.doc

-----
getscr - Sichern/Laden eines Bildschirminhalts

Syntax: getscr [-[Header] Dateiname]

Der Bildschirminhalt wird in einem internen Speicherbereich gesichert. Er
kann mit dem Kommando putscr wiederhergestellt werden.
Wenn das Flag - angegeben ist, wird der Bildschirminhalt aus der angegebenen
Datei gelesen. Dazu kann die L„nge eines Headers angegeben werden, der ber-
lesen wird. Wenn kein Header angegeben wird, wird kein Header berlesen.

Durch nochmaligen Aufruf von getscr wird der zuvor gespeicherte Bildschirm
berschrieben.

Beispiel:
	getscr
			Sichern des aktuellen Bildschirminhaltes
	getscr - <picture.doo
			Laden eines Doodle-Bildes (32000 Bytes)
	getscr -34 <picture.pi3
			Laden eines Degas-PI3-Bildes (32066 Bytes)

Siehe: putscr
       showpic (externes Kommando)

-----
goff - Abmeldung von AES

Syntax: goff

Die Shell meldet sich als Applikation vom AES ab, und der Bildschirm wird
gel”scht. Wird beim Beenden der Shell mit `exit' bei Bedarf automatisch
ausgefhrt.
Wenn vor der Eingabe von goff nicht gon eingegeben worden ist, erscheint
stattdessen eine Fehlermeldung.

Siehe: gon

-----
gon - Anmeldung bei AES

Syntax: gon [-q]

Die Shell meldet sich bei GEM als Applikation an und initialisiert den
Pfadnamen des Clipboards. gon ”ffnet eine Virtual Workstation und ini-
tialisiert daraus die von da an von der Shell benutzten Werte fr die
Bildschirmaufl”sung (Grafik und Text) sowie die Gr”e des Bildschirm-
speichers. Die zu Beginn der Shell initialisierten Werte gehen von einer
Bildaufl”sung von 640x400 Pixeln und 80x25 Zeichen sowie einem Bildschirm-
speicherbedarf von 32000 Bytes aus.
gon liest (mit der AES-Funktion scrp_read) den Pfadnamen des installierten
Clipboards. Falls ein solcher definiert ist, wird er in der Shellvariablen
CLIPDIR abgelegt. Falls nicht, wird umgekehrt der Inhalt von CLIPDIR als
Clipboard-Pfad installiert (mit scrp_write).

Dieses Kommando ist ntzlich bei der Verwendung von GEM-Applikationen.
Auerdem mu es vor der Verwendung einiger interner Kommandos (z.B. fsel
und mouse) benutzt werden.
Auerdem hat gon folgende Konsequenzen:
1) die Tastatureingabe l„uft ber die AES-Funktion evnt_keybd statt ber
   die Gemdos-Funktion Crawcin,
2) das Kommando sleep benutzt die AES-Funktion evnt_timer statt einer
   Warteschleife.
Daraus ergibt sich, da Accessories, die im Multitasking-Betrieb laufen,
bei aktiviertem gon w„hrend der Tastatureingabe und dem sleep-Kommando
aktiviert werden. Ein Accessory, das laufend die Uhrzeit auf den Bild-
schirm schreibt, tut dies also w„hrend der Tastatureingabe, wenn gon
aktiv ist. Dasselbe gilt fr andere Hintergrund-Accessories wie Drucker-
spooler o.„.
Die Tastaturpufferung funktioniert jedoch trotzdem, da die Tastaturein-
gaberoutine erst den Tastenpuffer ausliest, bevor sie weitere Tasten mit
evnt_keybd einliest.

Wird gon mehrfach hintereinander aufgerufen, ohne da zwischendurch goff
aufgerufen wird, erscheint eine Fehlermeldung.

Wenn das Flag -q angegeben ist, meldet sich die Shell nicht als Applikation
an, sondern es wird folgender Rckgabewert (in $?) zurckgeliefert:
	1	wenn gon bereits aktiviert ist,
	0	sonst.
Um Fehlermeldungen zu vermeiden, sollten Shellscripts, die mit Kommandos, die
gon erfordern (z.B. fsel), folgendermaen vorgehen:

	gon -q
	GONSTAT=$?
	if [ $GONSTAT = 0 ]
	then
	  gon
	fi
	
	...................... andere Kommandos
	
	if [ $GONSTAT = 0 ]
	then
	  goff
	fi
	unset GONSTAT

Auf diese Weise wird der Status von gon (aktiv oder nicht) in einer Variablen
(GONSTAT) gespeichert und benutzt, um gon ggfs. zu aktivieren und sp„ter wieder
zu deaktivieren.
Es wird empfohlen, gon als eines der ersten Kommandos im Profile aufzurufen.
Wenn die Shell aus dem Autoordner gestartet wird, sollte dieses Kommando
nicht verwendet werden, da zu dieser Zeit das AES noch nicht initialisiert
ist.

Siehe:	clipb
	goff
	sleep

-----
grep , fgrep - Suchen von Mustern

Syntax: grep|fgrep [-cfsl] Pattern {File}

Sucht in allen angegebenen Dateien oder, falls keine Dateien angegeben sind,
in StdIn nach Zeilen, die auf das Muster Pattern passen. Die gefundenen
Zeilen werden mit dem Dateinamen ausgegeben.

fgrep sucht feste Strings. Es werden alle Zeilen ausgegeben, die den String
Pattern enthalten.

grep sucht Muster nach den Regeln der erweiterten Wildcards (siehe okami.doc).
Es werden alle Zeilen ausgegeben, in denen sich eine Zeichenkette befindet,
die nach den Regeln der erweiterten Wildcards auf Pattern pat.
Wenn Pattern mit einer Tilde (~) beginnt, wird Pattern ab dem Beginn der Zei-
len gesucht. Wenn Pattern mit einem Dollarzeichen ($) endet, wird Pattern am
Ende der Zeilen gesucht. Achtung: in der Eingabe mu das Dollarzeichen in ein-
fachen Anfhrungszeichen ('$') oder hinter einem Dach (^$) stehen, da es sonst
als Einleitung einer Shellvariablen interpretiert wird.

Flags:
	-c	Es werden die Zeilennummern der gefundenen Zeilen mit ausge-
		geben.
	-f	Es wird in jeder Datei nur die erste šbereinstimmung gesucht.
	-s	(nur fr grep) bercksichtigt Whitespace-Zeichen am Zeilen-
		anfang. Wenn -s nicht angegeben ist, werden Whitespace-Zeichen
		am Zeilenanfang ignoriert.
	-l	ignoriert Gro- und Kleinschreibung.

Beispiele:			findet z.B. die Zeile

	grep Hallo		Der Mann sagte "Hallo".
				Hallo, sagte der Mann.
	grep H*o		Der Mann sagte nochmal "Hallo".
				Heute oder morgen.
	grep [hH]allo		hallo
				Hallo
	grep -l hallo		(dito)
				Der Mann sagte zum dritten Mal "Hallo".
	grep Hallo^$		Der Mann sagte zu letztenmal Hallo
	fgrep ~[a-n]*[aAbB]?^$	Hier steht "~[a-n]*[aAbB]?$".

	fgrep printf *.c	sucht alle printf-Aufrufe in allen C-Dateien.
	fgrep "printf *.c"	sucht die Zeichenkette "printf *.c" in StdIn.
	cmds | grep ~[gst]	Ausgabe aller interner Kommandos, die mit g,
				s oder t beginnen.

Rckgabewert:
	-1	Aufruffehler
	sonst	Anzahl der gefundenen šbereinstimmungen.

-----
hardcopy - Ausdrucken des Bildschirminhalts

Syntax: hardcopy

Falls ein Drucker empfangsbereit ist, wird eine Bildschirm-Hardcopy ausge-
druckt (nur bei S/W-Monitor moeglich), ansonsten erscheint eine Fehler-
meldung.

Rckgabewert:
	0	Ok., es ist gedruckt worden.
	-1	Der Drucker war nicht bereit.

-----
hash - Einstellen und Auslesen der Hash-Tabelle

Syntax: hash [Kommando [Pfad]]
oder    hash -r {Pattern}
oder	hash -a {file}

Wenn von der Shell aus ein externes Kommando (Programm oder Shellscript) auf-
gerufen wird, dann wird dieses auf allen in der Shellvariablen PATH gespei-
cherten Pfaden in Verbindung mit allen in XEXT und SEXT gespeicherten Ex-
tendern gesucht. Wenn dann der zu dem Kommando geh”rende vollst„ndige Datei-
name gefunden ist, wird dieser in einer sog. Hash-Tabelle (benannt nach der
zugrundeliegenden Datenstruktur) abgelegt. Beim n„chsten Aufruf desselben
Kommandos wird der Pfad dann der Hash-Tabelle entnommen, wodurch das auf-
wendige Suchen auf der Platte entf„llt.
Ein Eintrag in der Hash-Tabelle besteht aus zwei Teilen: dem Aufruf-Kommando
und dem vollst„ndigen Dateinamen (Pfad).
Mit dem Kommando hash kann diese Hash-Tabelle ausgelesen, ver„ndert und ge-
l”scht werden. Es gibt folgende M”glichkeiten des Aufrufs:

1.	hash
		(keine Parameter) Die Eintr„ge der Hash-Tabelle werden nach
		StdOut ausgegenen. Danach folgt eine Statistik ber den be-
		legten Platz in der Tabelle.
2.	hash Cmd
		(ein Parameter) Es werden die Definitionen aller Tabellen-
		eintr„ge, deren Kommando-Teil auf Cmd pat (laut den Regeln
		fr erweiterte Wildcards), in der Form gltiger hash-Kommandos
		ausgegeben (siehe 3.)
3.	hash Cmd Pfad
		(zwei Parameter) Es wird ein Eintrag in der Hash-Tabelle er-
		zeugt, und zwar mit dem angegebenen Kommando und Parameter.
		Auf diese Weise kann die Hashtabelle ohne den Aufruf von
		Kommandos belegt werden.
4.	hash -r {Pattern}
		Es werden alle Eintr„ge, die auf Pattern passen (laut den Re-
		geln fr erweiterte Wildcards), aus der Tabelle gel”scht-
		Wenn kein Pattern angegeben ist, wird die Tabelle vollst„ndig
		gel”scht.
5.	hash -a {File}
		Alle angegebenen Dateien werden, falls die ausfhrbar sind, in
		die Hashtabelle eingetragen. Als Kommandoname wird der Basis-
		name der Dateien ohne Extender benutzt. Wenn ein Kommando be-
		reits in der Hashtabelle steht, wird der Anwender gefragt, ob
		dessen Definition ersetzt werden soll. Ein Druck auf ENTER oder
		die Eingabe eines Wortes, das mit y oder Y beginnt, heit ja,
		jede andere Eingabe heit nein. Wenn die Eingabe mit q oder Q
		beginnt, wird das hash-Kommando abgebrochen.
		Wenn kein File angegeben ist, werden alle Dateien des aktuellen
		Directories benutzt.

Beispiele:

hash
	Der Inhalt der Hashtabelle wird ausgegeben.

hash a*
	Es werden die Definitionen aller Kommandos ausgegeben, die mit a
	beginnen.

hash cc c:/compiler/cc.ttp
	Fr das Kommando cc wird der Pfad "c:/compiler/cc.ttp" festgelegt.
	In Zukunft wird dieser Pfad durch das Kommando cc angesprochen, ohne
	da auf der Platte gesucht werden mu. Es ist dafr nicht notwendig,
	da c:/compiler in $PATH enthalten ist.

hash -r cc
	Obiger Eintrag wird wieder aus der Tabelle entfernt.

hash -r
	Die Tabelle wird gel”scht.

hash -a c:/bin/* c:/usr/bin/*
	Alle ausfhrbaren Dateien (Shellscripts und Bin„rprogramme) in den
	Directories c:/bin und c:/usr/bin werden in die Hashtabelle einge-
	tragen.

hash * >hash.sh
	Die Hashtabelle wird in eine Datei geschrieben. Diese Datei ist ein
	Shellscript, das, wenn es ausgefhrt wird, die Hashtabelle auf den
	aktuellen Stand restauriert. Dieses Kommando kann z.B. mit trap
	fr das Ende der Shell eingestellt werden, die Datei hash.sh kann
	vom Profile aus gestartet werden.	

-----
hd - Ausgabe eines Hex-Dumps

Syntax: hd [-b] [File]

Gibt einen Hex-Dump von StdIn oder, falls angegeben, von File, nach StdOut.
Der Hexdump ist folgendermaen aufgebaut:

nnnnnn hh hh ..... hh hh aaaaaaaa aaaaaaaa

nnnnnn: Die Byte-Nummer (Hex)
hh:	jeweils ein Byte in Hex (insgesamt 16)
aa...a: die entsprechenden Bytes in Ascii (ein Punkt, falls nicht druckbar.
	Es wird der Punkt mit Ascii-Code 0xfa benutzt.).

Flags:	-b	An der Stelle aa...a werden keine Punkte, sondern immer die
		Ascii-Zeichen ausgegeben, auch wenn diese nicht druckbar
		sind. Eine solche Ausgabe kann man dann z.B. zu dem Kommando
		raw -n pipen.

Um einen flchtigen šberblick ber den bin„ren Inhalt einer Datei zu ge-
winnen, reicht es in manchen F„llen aus, das Kommando raw zu benutzen, das
wesentlich schneller ist und eine krzere Ausgabe erzeugt.

Beispiele:
1) Hex-Dump einer Bin„rdatei:
	hd sh.ttp

2) Hex-Dump der Inhalte der Speicherstellen 0xabc000 bis 0xabcfff:
	memex 0xabc000 0xfff | hd

3) Seitenweiser Hexdump:
	hd sh.ttp | pg

4) Hexdump der Dateien test1.tos, test2.tos und test3.tos in die Datei
   test.hd:
	hd test1.tos test2.tos test3.tos > test.hd


Siehe auch:	raw

-----
help - Kurzanleitung mit Syntaxerkl„rung

Datei:	$ETC/help
Syntax: help

Die Datei Datei $ETC/help wird nach StdOut ausgegeben. Die Ausgabe erfolgt
mit dem Kommando pg.

Siehe: pg

-----
history - Laden und Speichern der History-Tabelle

Syntax: history [-(l|s)]

Wenn kein Parameter angegeben ist, werden alle Eintr„ge der Tastatur-History-
tabelle nach StdOut geschrieben, der zuletzt eingegebene Eintrag zuletzt.
(Das ist, wenn history von der Tastatur eingegeben wurde, das history-Kommando
selber).
Wenn der Parameter -l angegeben ist, werden Zeilen von StdIn eingelesen und
nacheinander in die History-Liste eingefgt, so als ob sie ber die Tastatur
eingegeben wrden.

Wenn das Flag -s angegeben ist, wird nur eine Statistik ber freie und belegte
Pl„tze in der History-Liste ausgegeben. Hierbei ist zu beachten, das die His-
tory-Liste in der Art eines Ringpuffers organisiert ist, was bedeutet, da sie
niemals berlaufen kann.

Mit den folgenden Zeilen im Profile:

	HISTFILE=$ETC/history
	if [ -f $HISTFILE ]
	then
       	  history -l <$HISTFILE
	fi
	trap +history ^>$HISTFILE ^; chmod +h $HISTFILE

wird bei jedem Programmende die History-Liste in die Datei $ETC/history ge-
schrieben (und die Datei unsichtbar gemacht), und bei Programmstart wird die
History aus dieser Datei wiederhergestellt.
Anmerkung: 
1) es gengt:
	trap +history ^>$HISTFILE
   , aber dann ist die Datei nicht unsichtbar.
2) das Pluszeichen vor history verhindert das šberschreiben eines evtl. be-
   reits definierten Trap-Kommandos.

Siehe auch:	trap
		okami.doc zum Thema Tastatureingabe

-----
if, then, else, fi - Bedingte Ausfhrung

Syntax: if Kommando1
	then
	Kommandos2
	[else
	 Kommandos3]
	fi

Mit dieser Befehlsfolge ist es m”glich, Teile eines Shellscripts nur
dann auszufhren, wenn eine bestimmte Bedingung zutrifft. Die Verwen-
dung bei Tastatureingabe ist ebenfalls m”glich, aber nicht unbedingt
sinnvoll.

Wenn der Rckgabewert von Kommando1 ungleich 0 ist, werden die unter
Kommandos2 angegebenen Kommandos ausgefhrt. Wenn der Rckgabewert
von Kommando1 gleich 0 ist, werden die unter Kommandos3 angegebenen
Kommandos ausgefhrt, falls angegeben. Hierbei sind Kommandos2 und
Kommandos3 Folgen von beliebig vielen (auch null) beliebigen Shellkommandos
(auch weitere if-else-fi-Konstruktionen). Es k”nnen ber 32000 if's ge-
schachtelt werden.

Als Kommando1 kann ein beliebiges Shell-Kommando stehen. Die meisten
internen Kommandos geben im Fehlerfall -1, sonst 0 zurck. Bei einigen
Kommandos (z.B. grep) hat der Rckgabewert eine andere Bedeutung.
Typische Kandidaten fr "Kommando1" sind true, false und test (bzw. "[").


Beispiele:

Die folgenden Beispiele sind als Ausschnitte von Shellscripts zu verstehen.

1) Ausgabe der Information, ob eine Datei existiert

	if test -f datei.txt
	then
	  echo datei.txt existiert
	else
	  echo datei.txt existiert nicht
	fi

2) Feststellen, ob ein Muster in einer Datei vorhanden ist
   (Die Ausgabe von grep wird nach NULL: umgeleitet, damit sie nicht die
    Bildschirmausgabe st”rt.)

	if grep Muster datei.dat >NULL:
	then
	  echo Das Muster ist vorhanden.
	else
	  echo Es ist nicht vorhanden.
	fi

3) Sicherheitsabfrage vom Benutzer einholen. Wenn der Benutzer "n" ein-
   gibt, wird das Programm abgebrochen (d.h. das augenblickliche Shell-
   script beendet).

	echo "Soll das Programm fortgesetzt werden? (j/n)"
	read JAODERNEIN
	if [ $JAODERNEIN = n ]
	then
	  exit
	fi

4) Numerische Vergleiche:

	echo Bitte geben Sie ihr Alter ein.
	read ALTER
	if [ $ALTER -ge 18 ]
	then
	  echo Sie sind erwachsen.
	else
	  if [ $ALTER -lt 14 ]
	  then
	    echo Du bist ein Kind.
	    if [ $ALTER -lt 6 ]
	    then
	      echo Du hast geschummelt, mit $ALTER kann man noch nicht lesen.
	    fi
	  else
	    echo Du bist ein Jugendlicher.
	  fi
	fi

5) Das Kommando keydef soll ausgefhrt werden, aber nur, wenn es auch als in-
   ternes Kommando vorhanden ist.

	if [ keydef -t i ]
	then
	  keydef F1 "dir"
	else
	  echo keydef ist nicht vorhanden!
	fi

6) Eine Art Neuimplementation des type-Kommandos, es wird der Typ des Kommandos
   $COM ausgegeben.

	if [ $COM -t f ]
	then
	  echo $COM is a function
	fi
	if [ $COM -t i ]
	then
	  echo $COM is a shell builtin
	fi
	(usw.)

7) Feststellen, ob das Kommando upn extern oder intern ist:

	if [ upn -t sb ]
	then
	  echo upn ist ein externes Kommando
	else
	  echo upn ist intern oder Shellfunktion
	fi


Siehe auch: test
	    true
	    false
	    while

-----
indir - Kommando-Indirektion

Syntax: indir String

Der String wird ausgewertet (Shellvariablen expandiert, Command Substitution
durchgefhrt etc.) und auf StdOut ausgegeben. String wird also insgesamt
zweimal ausgewertet: einmal bei der Eingabe des Kommandos und das Ergebnis
dieser Auswertung nochmal durch das indir-Kommando. Dies ist ntzlich beim
Arbeiten mit Variablen, die andere Variablennamen beinhalten, fr doppelte
Command Substitution usw.

Beispiele:
	VAR=hallo
	POINTER=VAR
	echo $POINTER			ergibt VAR
	echo ^$POINTER			ergibt $POINTER
	indir ^$POINTER			ergibt VAR
	echo ^$$POINTER			ergibt $VAR
	indir ^$$POINTER		ergibt hallo

... also ein Zugriff auf den Inhalt der Variablen VAR ohne direkten Zugriff
auf VAR. indir entspricht also in dieser Verwendung ungef„hr dem Pointer-
Konzept moderner Programmiersprachen.

	VAR=^`echo hallo^`
	echo $VAR			ergibt `echo hallo`
	indir $VAR, wie gehts			ergibt hallo, wie gehts

... also indirekter Zugriff auf Shellkommandos, die z.B. in einer Shellvaria-
blen liegen. In obigem indir-Kommando wird zuerst $VAR zu `echo hallo` expan-
diert, und indir fhrt dann die Command Substitution aus.

	REVON='^033p'		speichern eines VT52-Codes
	echo $REVON		ergibt ^033p
	indir $REVON		fhrt den VT52-Code aus.

-----
keyb - Konfiguration der Tastatur

Syntax: keyb [-]
oder	keyb [(+|-)a] [(+|-)b] [(+|-)c] [-iInit] [-rRepeat]

Mit diesem Kommando wird die Tastatur konfiguriert. Folgende Konfigurationen
sind m”glich:
	Das Auto-Repeat kann ein- und ausgeschaltet werden,
	Das Tastenklicken kann ein- und ausgeschaltet werden,
	Die Klingel bei Ausgabe von Ascii BEL (0x7) kann ein- und ausge-
	schaltet werden,
	Die Zeitspanne bis zum Einsetzen des Auto-Repeat und die Wieder-
	holrate k”nnen eingestellt werden.
In der ersten Form, also beim Aufruf ohne Parameter oder nur mit einem
Minuszeichen, wird die Konfiguration ausgegeben. Wenn als Parameter ein
Minuszeichen angegeben ist, erfolgt die Ausgabe so, da sie sp„ter wieder
als Parameter fr keyb benutzt werden kann, z.B.:
	X=`keyb -`
	....................... sonstige Kommandos
	keyb $X
speichert die Konfiguration und stellt sie danach wieder her.

Bei den Flags a, b und c bedeutet + einschalten und - ausschalten.

	a	Auto-Repeat ein/aus
	b	Ascii-BEL ein/aus
	c	Tastenklick ein/aus

Bei den Flags -i und -r wird die entsprechende Zeitspanne in 1/50 Sekunden
angegeben.

	-i	die Zeitspanne bis zum Einsetzen des Auto-Repeat,
	-r	die Zeitspanne zwischen zwei Wiederholungen.

ACHTUNG: bei diesem Kommando k”nnen die Flags nicht zu Gruppen zusammenge-
fat werden, d.h.
	keyb -abc
ist falsch, es mu
	keyb -a -b -c
heien.

Siehe auch:	cursor
		scr
		mouse

-----
keydef - Umdefinition der Tastatur

Syntax: keydef [+(n|s|c|a)] Scancode [Text|-]
	keydef clear|list|help

Mit diesem Kommando kann die Ausgabe aller Tasten umdefiniert werden. Es ist
damit m”glich, jeder Taste neue Zeichenketten zuzuordnen, die beim Drcken
dieser Taste zu erzeugen sind. Damit kann man z.B. die Buchstabentasten um-
sortieren, aber auch die F-Tasten mit Funktionen belegen.

Jedes keydef-Kommando betrifft eine Taste, die durch den Scancode und die
Steuertaste bestimmt ist (z.B. Ctrl A etc.)

Wenn eins der Flags +n, +s, +c oder +a angegeben ist, bestimmt dieses, fr
welche Steuertaste die Umdefinition wirkt. Es bedeuten:
	+n	keine Steuertaste
	+s	eine der Shift-Tasten
	+c	die Control-Taste
	+a	die Alternate-Taste
Wenn keins dieser Flags angegeben ist, wird +n angenommen.

Der Scancode kann in einem der folgenden Formate angegeben sein:
	1) ein Minuszeichen, gefolgt von einer Zahl; diese repr„sentiert den
	   gewnschten Scancode direkt.
	2) ein Schlsselstring. Eine Liste der m”glichen Schlsselstrings
	   finden Sie in dieser Datei unter dem Stichwort "keydefcode".

Wenn kein Text angegeben ist, wird die betreffende Tastendefinition (falls
vorhanden) ausgegeben.
Wenn der Text aus einem Minuszeichen besteht, wird die betreffende Tasten-
definition (falls vorhanden) gel”scht.
Ansonsten wird der Text als neue Tastendefinition gespeichert, eine evtl. be-
reits vorhandene Definition derselben Taste wird dabei berschrieben.

Wenn der Text Leerzeichen oder Sonderzeichen enth„lt, mu er in Anfhrungs-
zeichen eingeschlossen sein.

Wenn der Text mit einem Pluszeichen beginnt, wird, wenn in der Tastatur-
eingabe die betreffende Taste gedrckt wird, die Eingabezeile durch den Text
ersetzt (ansonsten wird der Text an die bisherige Eingabe angeh„ngt).
Wenn der Text mit "^c" endet, wird nach Druck auf die betreffende Taste die
Eingabezeile ausgefhrt.

Wenn der Text mit einem Ausrufezeichen beginnt, stellt er nicht einen durch
die Taste zu erzeugenden Ascii-String, sondern eine Umdefinition des durch
die Taste zu erzeugenden Shift-, Scan- und Ascii-Codes dar. Das Format
lautet
	![+x]Scancode [Asciicode]
x ist dabei entweder n, s, c oder a und bewirkt die Steuertastenkombination.
Scancode wird wie oben beschrieben angegeben und ist der neue zu erzeugende
Scancode.
Asciicode ist ein einziges Zeichen, das den neuen Ascii-Code der Taste be-
schreibt.

Wenn als einziger Parameter "clear" angegeben ist, werden s„mtliche Tasten-
definitionen gel”scht.
Wenn als einziger Parameter "list" angegeben ist, wird eine Liste aller vor-
handener Definitionen erzeugt, und zwar in Form von keydef-Kommandos.
Wenn als einziger Parameter "help" angegeben ist, wird eine Liste aller Scan-
code-Schlsselstrings erzeugt.

Alle Umdefinitionen betreffen ausschlielich die Tastatureingabe der Shell.

Beispiele:

1) Amerikanische Tastatur durch Vertauschen von y und z.
	keydef y z
	keydef z y
	keydef -s y Z
	keydef -s z Y

   Das jeweils erste y bzw. z ist die Angabe des umzudefinierenden Scancodes.
   Das zweite ist die Ascii-Zeichenkette, die durch die Taste erzeugt werden
   soll.

2) Ausfhren von "dir *.c" bei Druck auf F1:
	keydef f1 "+dir *.c^c"

3) Ausgabe der Definition von Ctrl Help:
	keydef +c help
   oder:
   	keydef +c -0x62
   Einmal wird die Help-Taste durch den Code-String "help" und einmal direkt
   durch den Scancode 0x62 angegeben.

4) L”schen der Definition von Shift F5:
	keydef -s F5 -

5) Ausgabe aller Tastendefinitionen in eine Datei:
	keydef list >keys.sh
   Die Datei keys.sh ist dann ein Shellscript, das, wenn es gestartet wird,
   alle Tastendefinitionen installiert.

6) Ein Druck auf Shift-F6 soll dasselbe bewirken wie Help. Dafr wird der
   von F6 bewirkte Scancode auf den von Help umgebogen.
	keydef +s F6 "!help"

7) Mit Ctrl-Esc wird die Shell beendet, Esc alleine l”scht nur die Eingabe-
   zeile (bernimmt also die Funktion von Clr-Home), Clr-Home l”scht den
   Bildschirm:
	keydef +c ESC "!+c D"
	keydef ESC "!CLR"
	keydef CLR "+cls ^c"
   Das erste keydef belegt Ctrl-Esc mit Ctrl-D, das zweite belegt Esc alleine
   mit der ursprnglichen Funktion der Clr-Home-Taste. Das dritte keydef
   sorgt dafr, da bei Druck auf Clr-Home das Kommando cls ausgefhrt
   wird.
   => Man kann alle vordefinierten Tastenfunktionen beliebig auf neue Tasten
   legen!!!!

8) Ein Druck auf Undo soll ein Z eingeben.
	keydef undo "!Z z"
	keydef +s undo "!+s Z Z"
   Das erste keydef sorgt dafr, da bei Druck auf Undo der Scancode von Z
   und der Ascii-Code von z benutzt wird. Das zweite keydef macht dasselbe
   fr Shift Undo und erzeugt ein groes Z.

9) L”schen aller Tastendefinitionen:
	keydef clear

Siehe auch:	keydefcode

-----
keydefcode - Code-Strings fr Scancode-Angaben des keydef-Kommandos
  
Bei allen Codes ist die Gro/Kleinschreibung ohne Bedeutung. Es gilt:
	* Die Strings A bis Z und 0 bis 9 stehen fr die jeweilige Buchstaben-
	  bzw. Zahlentaste.
	* Die F-Tasten werden durch ein vorgestelltes F gekennzeichnet (z.B.
	  F6, F10,...)
	* Tasten des Zehnerblocks sind durch ein vorgestelltes Z gekenn-
	  zeichnet. Z5 ist also die 5 auf dem Zehnerblock.

	Code		Tastenaufschrift
	----		----------------
						Alpha-Block
	ESC		Esc
	QUES		 ?
	ACC		' `
	HASH		# ^
	BS		Backspace
	TAB		Tab
	AT		@ š \
	PLUS		+ *
	CR		Return (*)
	DEL		Delete
	OB		[ { ™
	CB		] } 
	TIL		~ |
	LESS		< >
	COMMA		, ;
	DOT		. :
	MINUS		- _
	SPC		die Leertaste
						Cursor-Block
	UNDO		Undo
	HELP		Help
	INS		Insert
	CLR		Clr Home
	UPAR		Pfeil auf
	DNAR		Pfeil ab
	LTAR		Pfeil nach links
	RTAR		Pfeil nach rechts
						Zehnerblock
	ZMINUS		-
	ZPLUS		+
	ZOP		(
	ZCP		)
	ZSLASH		/
	ZAST		*
	ZDOT		.
	ZCR		Enter (*)


(*) Eine Umdefinition dieser Tasten ist zwar m”glich, aber bei der Tastatur-
eingabe ohne Wirkung.

-----
logo - Ausgabe des Okami-Logos

Syntax:	logo [x [y]]

Das Okami-Logo wird an die Bildschirmkoordinaten x,y gezeichnet. Die Default-
werte von x und y sind 0. x mu ein Vielfaches von 32 sein.
Bei nicht-monochromer Bildaufl”sung, wenn also nicht jedem Pixel ein Bit im
Bildschirmspeicher zugeordnet ist, erzeugt dieses Kommando keine Ausgabe.
In diesem Fall wird -1 zurckgegeben.
Zu groe oder zu kleine Werte von x und y werden auf die jeweiligen Maximal-
werte der Bildschirmaufl”sung gesetzt.
Um Konflikte mit dem Cursor-Blinken zu vermeiden, sollte, wenn das Logo ber
die aktuelle Cursorposition geschrieben wird, vorher der Cursor mit cursor -v
unsichtbar gemacht werden.

-----
ls - Ausgabe von Dateilisten

Syntax: ls [-adlfkCvi] [-xtbnr] {Filespec}
	ls -! Filespec {Filespec}

Gibt eine Liste aller Dateien, deren Namen auf Filespec passen, nach StdOut
aus. Filespec nicht angegeben bedeutet .\* (alle Dateien im aktuellen Direc-
tory).
Die Namen von Ordnern werden in [] (eckige Klammern) eingefasst.
Die Namen von ausfuerbaren Dateien werden in <> (spitze Klammern) eingefasst.
Flags:
	-a	Auch versteckte und System-Dateien werden ausgegeben.
	-d	Wenn Filespec der Name eines Ordners ist, wird der Ordner
		selber und nicht sein Inhalt ausgegeben.
	-l	Angaben ueber Dateiattribute, Dateilaenge und Datei-
		datum und -zeit werden ausgegeben. Auerdem werden am Ende
		der Liste die Summe aller Dateil„ngen und die Anzahl der
		Dateien ausgegeben (bei mehr als einer Datei). Siehe unten (*).
	-f	Gibt bei -l bei den Dateiattributen mit aus, ob eine aus-
		fhrbare Datei schnellgeladen wird. Siehe unten (*). Ist ohne
		Wirkung, wenn -l nicht angegeben ist.
	-k	Keine [] und <> um Dateinamen.
	-C	Die Dateien werden in mehreren Spalten ausgegeben.
	-v	Es wird nur der Diskettenname ausgegeben.
	-i	Zu jeder Datei wird anhand einer Indexdatei eine Erkl„rung
		ausgegeben. siehe unten (**).
	-x	Die Dateien werden nach Extendern sortiert ausgegeben.
	-t	Die Dateien werden nach dem Anlagezeitpunkt der Datei
		sortiert ausgegeben (die „lteste Datei zuerst).
	-b	Die Dateien werden nach ihrer L„nge sortiert ausge-
		geben (die krzeste Datei zuerst).
	-n	Die Dateien werden in der Reihenfolge ausgegeben, in der
		sie physikalisch gespeichert sind. -r ist ohne Wirkung.
	-r	Die Reihenfolge der Dateien wird umgekehrt (auer bei -n).

(*) Anmerkung zu -l und -f:
Die Dateiattribute werden analog dem chmod-Kommando ausgegeben. Fr ein ge-
setztes Attribut erscheint der entsprechende Buchstabe, fr ein nicht ge-
setztes erscheint ein Minuszeichen.
Wenn die Datei ausfhrbar ist, erscheint als letztes ein x. šber die Ausfhr-
barkeit entscheidet der Dateinamen-Extender und die Shellvariablen XEXT und
GEXT.
Wenn das Flag -f angegeben ist, wird bei ausfhrbaren Programmdateien fest-
gestellt, ob das Fastload-Bit im Programmheader gesetzt ist. Wenn das der
Fall ist, wird statt dem x ein f ausgegeben.
Wenn -f nicht angegeben ist, wird das Fastload-Bit nicht beachtet. Das ist so,
da, um das Fastload-Bit zu ermitteln, auf die Datei selber (und nicht nur auf
den Directory-Eintrag) zugegriffen werden mu, was die Ausgabe von ls be-
sonders bei Disketten sehr verlangsamt.

(**) Anmerkung zu -i:
Wenn sich in demselben Directory wie die auszugebenden Dateien eine Datei
namens `_index' befindet, so wird diese, wenn das Flag -i angegeben ist,
eingelesen. Diese Datei enth„lt erkl„rende Anmerkungen zu den einzelnen
Dateien des Directories, in dem sie sich befindet, und zwar in dem folgenden
Format:
	- Leerzeilen und Zeilen, die mit einem Doppelkreuz beginnen, sind
	  Kommentarzeilen.
	- Alle anderen Zeilen haben die Form
		Pattern Text

Hierbei ist `Pattern' ein Muster nach den Regeln der erweiterten Wildcards,
das `Text' als den auszugebenden Text fr alle Dateien, die auf `Pattern'
passen, festlegt. Leerzeichen am Anfang und Ende der Zeile werden ignoriert,
Text selber darf Leerzeichen enthalten. Pattern und Text mssen durch
mindestens ein Leerzeichen getrennt sein. Beispiel: die Zeile
	*.c C-Quellcode
legt den Text "C-Quellcode" fr alle C-Dateien fest.
Achtung: fr eine Datei ist die _index-Datei zust„ndig, die sich in demselben
Directory wie die Datei befindet. Bei `ls -i ../abc/*.c' wrde also die Datei
`../abc/_index' benutzt.
Sinn dieser Sache ist weniger, Dateien zu klassifizieren, als vielmehr indi-
viduelle Erkl„rungstexte zu den einzelnen Dateien schreiben zu k”nnen. Daher
wird auch in jedem Directory eine eigene Indexdatei verwaltet.

Wenn keins der Flags -x, -t, -b, -n angegeben ist, werden die Dateien nach
dem Dateinamen sortiert ausgegeben (in aufsteigender Reihenfolge). Dann
und bei -x erscheinen die Ordner nach den Dateien.

Wenn als erstes Flag -! angegeben ist, werden alle folgenden Angaben als
Dateispezifikationen betrachtet und von den betreffenden Dateien Attribute
(bin„r), Datum und Uhrzeit (hexadezimal), Dateigr”e (dezimal) und der voll-
st„ndige Dateiname ausgegeben, und zwar in der physikalischen Reihenfolge.
Es k”nnen keine anderen Flags mit -! benutzt werden. Diese Option dient zu
Debug-Zwecken der Shell.

Beispiele:
1) Liste aller Dateien im aktuellen Verzeichnis, Ausgabe in mehreren
   Spalten:
	ls -C

2) Liste aller C-Quelldateien im aktuellen Verzeichnis, sortiert nach
   Anlagedatum, die jngste Datei zuerst:
	ls -tr *.c

3) Liste aller .PRG-Dateien im Ordner d:\shell mit Dateiattributen, Datei-
   l„nge und -Datum:
	ls -l d:\shell\*.prg

4) Liste aller Dateien im Ordner d:\shell mit Attributen, L„nge und Datum,
   sortiert nach Dateil„nge:
	ls -l -b d:\shell

5) Liste von Attributen, L„nge und Datum des Ordners d:\shell:
	ls -ld d:\shell

6) Ausgabe des Diskettennamens von Diskette A:
	ls -v A:\


Rckgabewert:
	-1	Aufruffehler
	sonst	die Anzahl der ausgegebenen Dateien.

Siehe auch:	chmod

-----
mem - Ermitteln des freien Speicherplatzes

Syntax: mem [-b]

Wenn kein Flag angegeben ist, wird die Anzahl der freien RAM-Bytes (genauer:
die L„nge des l„ngsten zusammenh„ngenden Blocks) ausgegeben.
Wenn das Flag -b angegeben ist, wird die Gr”e der Speicherb„nke 0 und 1 sowie
die Gesamtgr”e des RAM-Speichers ausgegeben.

-----
memex - Auslesen des Speichers

Syntax: memex [-acwls] Startadr [Anzahl]

Kopiert eine Anzahl von Speicherstellen nach StdOut. Falls Anzahl nicht
angegeben ist, wird Anzahl=1 gesetzt.

Flags:	-s	Vor dem Auslesen wird der Prozessor in den Supervisor-Modus
		versetzt. Dies ist sinnvoll beim Auslesen von System-
		adressen.
	-a	Liest Anzahl Bytes von Startadr an und gibt die Inhalte
		als Ascii-Zeichen aus. Bei nicht-druckbaren Zeichen werden
		die entsprechenden Ascii-Codes (z.B. NUL, SOH etc.) ausge-
		geben.
	-c	Liest Anzahl Bytes von Startadr an und gibt die Inhalte
		numerisch (im Bereich 0...0xff) aus.
	-w	Liest Anzahl Worte (je 16 bits) von Startadr an und gibt
		die Inhalte numerisch (im Bereich 0...0xffff) aus.
	-l	Liest Anzahl Langworte (je 32 bits) von Startadr an und
		gibt die Inhalte numerisch (im Bereich 0...0xffffffff)
		aus.
	Wenn keins von -a, -c, -w, -l angegeben ist, werden Anzahl Bytes
	von StartAdr an nach StdOut kopiert.
	Wenn bei -w oder -l eine ungerade Adresse angegeben ist, wird diese
	vor Benutzung dekrementiert.

Beispiele:
1. Ermitteln der Anzahl der angeschlossenen Diskettenlaufwerke durch Aus-
   lesen der betreffenden System-Speicherstelle:
   memex -s -w 0x4a6
2. Ausgeben von 100 Bytes von Speicherstelle 0x12345 an als Hexdump:
   memex 0x12345 100 | hd

-----
mkdir - Ordner erzeugen

Syntax: mkdir [-r] Ordner {Ordner}

Erzeugt die angegebenen Ordner. Wenn das Flag -r angegeben ist, werden voll-
st„ndige Pfade erzeugt, ansonsten nur die zuletzt angegebenen Ordner.
Achtung: wenn -r angegeben ist, wird der Basisname als der Name einer Datei
betrachtet und nicht angelegt. Um auch den Basisnamen als Ordner anzulegen,
mu er mit einem Backslash (oder Slash) abgeschlossen sein.

Beispiel:
	mkdir c:/work/test
			erzeugt den Ordner test als Unterordner von c:/work;
			wenn c:/work noch nicht existiert, kommt ein Fehler.
	mkdir -r c:/work/test/data
			erzeugt die Ordner c:/work und c:/work/test, falls
			noch nicht vorhanden. Eine Datei oder Ordner namens
			data wird nicht angelegt.
	mkdir -r c:/work/test/data/
			erzeugt die Ordner c:/work, c:/work/test und
			c:/work/test/data, falls noch nicht vorhanden.
	FILE=d:/data/files/x.out
	mkdir -r $FILE
			legt alle Ordner an, die fr die Datei $FILE be-
			n”tigt werden, also den Pfad d:/data/files. Die Datei
			x.out wird nicht angelegt. Nach diesem Kommando
			k”nnen z.B. Ausgaben nach $FILE umgeleitet werden.

Rckgabewert: Anzahl der erzeugten Ordner (oder Pfade bei -r).

-----
more - SIEHE pg

-----
mouse - Konfiguration und Abfrage der Maus

Syntax: mouse [+|-] [Form] [XVar [YVar]]

Dieses Kommando dient zwei verschiedenen Zwecken: 1) der Konfiguration
des Mauszeigers und 2) der Abfrage der Mauskoordinaten. Das Kommando mu
mit mindestens einem Parameter aufgerufen werden, es k”nnen aber alle
der m”glichen Parameter gleichzeitig benutzt werden.
Es handelt sich hierbei um die Benutzung von AES-Funktionen, weswegen vor
Benutzung von mouse die Shell als Applikation bei GEM angemeldet werden
mu. Dies geschieht mit dem Kommando gon.

Parameter:
	+	der Mauszeiger wird sichtbar gemacht.
	-	der Mauszeiger wird unsichtbar gemacht.
	Form	es wird die Form des Mauszeigers eingestellt. Anstelle von
		Form steht eine Zahl zwischen 0 und 7, es bedeuten:
		0	Pfeil
		1	Cursor (Klammer)
		2	Biene
		3	Hand mit Zeigefinger
		4	flache Hand
		5	dnnes Fadenkreuz
		6	dickes Fadenkreuz
		7	umrahmtes Fadenkreuz
	XVar	der Name der Variablen, in die die x-Koordinate der Maus
		gespeichert werden soll. Anstelle von XVar steht ein belie-
		biger Variablenname auer den Ziffern 0 bis 7 (die als
		Variablennamen vom Benutzer ohnehin nicht ver„ndert werden
		sollten.)
	YVar	analog fr die y-Koordinate.

Beispiel:
	mouse + 0
		Der Mauszeiger wird sichtbar und auf einen Pfeil eingestellt.
	mouse X Y
	echo Die Mauskoordinaten sind $X und $Y
		Abfrage der Mauskoordinaten.

ACHTUNG: Die Einstellung der Maus erfolgt mit der AES-Funktion graf_mouse.
AES verwaltet das Ein- und Ausschalten der Maus in einem Puffer, d.h. wenn
die Maus dreimal ausgeschaltet wird, mu sie auch dreimal wieder eingeschal-
tet werden, bevor sie sichtbar wird. Da mehrfaches Einschalten der Maus zu
Verwirrungen bei GEM-Formularen fhren kann, sollte man hier mit groer
Vorsicht vorgehen. Wenn es zu Problemen kommt, hilft jedoch meistens die
Rckkehr zum Desktop.
Die Mauskoordinaten werden mit der AES-Funktion graf_mkstate bestimmt.
Erfahrungsgem„ fhrt dies regelm„ig zu falschen Werten, da das Bildschirm-
scrolling die Mauskoordinaten beeinflut. Zuverl„ssig sind die Werte zu-
mindest nach einem cls.

Siehe auch:	cursor
		keyb
		scr

-----
mv - Dateien umbenennen oder verschieben

Syntax: mv [-avif] Source {Source} Dest

Wenn Dest der Name eines existierenden Ordners ist, werden alle Dateien
Source in diesen Ordner verschoben. Der neue Dateiname der Dateien ist dann
Dest/`basename Source`.
Wenn Dest nicht der Name eines existierenden Ordners ist, wird die Datei
Source in die Datei Dest umbenannt. In diesem Fall darf nur ein Source an-
gegeben sein.
Die Source-Angaben drfen erweiterte Wildcards enthalten. Die Maximalanzahl
der auf diese Weise benutzbaren Source-Dateien ist 100.
Source und Dest k”nnen in verschiedenen Ordnern und auf verschiedenen Lauf-
werken liegen. Beim Verschieben auf einem Laufwerk werden keine Daten auer
den Directoryeintr„gen bewegt, wodurch das Verschieben sehr schnell geht.
Beim Verschieben auf ein anderes Laufwerk werden die Dateien mit cp kopiert
und dann die Sourcedateien gel”scht.
Ab TOS 1.4 k”nnen mit diesem Kommando auch die Namen von Ordnern ge„ndert
werden. Es k”nnen allerdings keine Ordner verschoben werden.

Flags:
	-a	Die Quelldatei wird an die Zieldatei angeh„ngt.
	-v	Bei jeder bearbeiteten Datei wird eine Meldung ausgegeben.
		Das ist ntzlich beim Kopieren von vielen Dateien auf einmal.
	-i	Fragt vor dem šberschreiben bereits vorhandener Zieldateien
		nach, ob diese berschrieben werden drfen.
	-f	šberschreibt keine bereits vorhandenen Dateien.

Beispiele:
mv sh.ttp sh.prg		Umbenennen einer Datei.
mv sh.ttp d:/shell		Verschieben einer Datei in einen Ordner, der
				neue Name ist d:/shell/sh.ttp.
mv e:/source/*.c a:/		Verschieben aller C-Dateien auf die Diskette.
mv -f e:/source/*.c a:/		dito, aber es werden keine Dateien ber-
				schrieben.
mv docs anleitg			ndern eines Ordnernamens, nur bei >=TOS1.4.

Siehe auch:	cp

-----
num - Ausgabe einer Zahl in verschiedenen Zahlensystemen

Syntax: num [-bodhxa] Zahl {Zahl}

Die Zahlen werden in bin„rer, oktaler, dezimaler und hexadezimaler Form 
sowie als Ascii-Zeichen ausgegeben. Wenn das entsprechende Ascii-Zeichen
nicht druckbar ist, wird die Bezeichnung des Zeichens (z.B. NUL, SOH etc.)
ausgegeben.

Flags:	-b	Die Zahlen werden nur im Bin„rsystem ausgegeben.
	-o	Die Zahlen werden nur im Oktalsystem ausgegeben.
	-d	Die Zahlen werden nur im Dezimalsystem ausgegeben.
	-h	Die Zahlen werden nur im Hexadezimalsystem ausgegeben.
	-x	Wie -h.
	-a	Die Zahlen werden nur als Ascii-Zeichen ausgegeben.

Beispiele: 

1) Ausgabe von 123 (dezimal) in allen Zahlensystemen:
		num 123

2) Ausgabe von 123 (hex) in allen Zahlensystemen:
		num 0x123

3) Ausgabe von -123 (dezimal) in Hex:
		num -x "-123"
   und NICHT: num -x -123

4) Ausgabe der Konsolkonfigurationsbits durch Auslesen einer Systemadresse
   und Umformung ins Bin„rsystem:
		memex -sc 0x484 | xargs num -b


-----
pg, more - Seitenweise Ausgabe von Dateien

Syntax: pg|more {File}

StdOut oder, falls angegeben, File wird in Seiten zu je $PAGELEN Zeilen
ausgegeben. Nach jeder Seite kann der Anwender:
	mit der Leertaste die n„chste Seite anzeigen,
	mit der Taste D die n„chste halbe Seite anzeigen,
	mit der RETURN-Taste die n„chste Zeile anzeigen,
	mit der Taste Q die Ausgabe abbrechen und mit der n„chsten Datei
		fortfahren,
	mit der ESC-Taste das Kommando abbrechen, es werden keine weiteren
		Dateien mehr angezeigt.

-----
pmd - Ausgabe eines Post-Mortem-Dumps

Syntax: pmd

Dieses Kommando kann verwendet werden, um Informationen ber ein Programm zu
erhalten, das von einer Exception durch Bomben beendet wurde. Es erzeugt eine
Ausgabe, die die Inhalte der Register d0 bis d7 und a0 bis a6 sowie des
usp (a7), ssp (a7") und des Programmz„hlers (pc) enth„lt. Auerdem wird die
Nummer der die Bomben ausl”senden Exception ausgegeben und die obersten sechs
16bit-Worte des Stacks, letztere sowohl in Hex- als auch in Ascii-Notation.
Nicht-druckbare Zeichen (solche mit Ascii-Code<32) werden als dicke Punkte
ausgegeben.
Die Nummer der Exception wird dezimal, alle anderen Angaben hexadezimal an-
gegeben. (Da die Nummer der Exception normalerweise kleiner als 10 ist,
macht es keinen Unterschied, ob man sie dezimal oder hexadezimal ausgibt.)

Wenn noch keine Exception aufgetreten ist, durch die Bomben hervorgerufen
wurden, sind die Informationen ungltig. Es erscheint dann vor der Ausgabe
die Meldung "WARNING: Information void".

-----
ps - Ausgabe der laufenden Programme

Syntax: ps [-bfc]

WENN MINT INSTALLIERT IST:
Es wird eine Liste der augenblicklich aktiven Prozesse erzeugt. Dabei handelt
es sich um eine Ausgabe des Inhalts von Pseudo-Laufwerk X:.
Die Ausgabe hat folgendes Format:

000  WEV	00:00:00   4096		mint

	000		Die Prozenummer.
	WEV		Der Prozestatus. Siehe unten.
	00:00:00	Die Laufzeit des Prozesses.
	4096		Der Speicherbedarf des Prozesses in Bytes.
	mint		Der Name des Prozesses.

In diesem Fall w„re der Dateiname des Prozesses also X:\mint.000 .
Folgende Statusangaben sind m”glich:
	RUN	Der Proze ist augenblicklich aktiv.
	RDY	Der Proze ist inaktiv, aber bereit, aktiv zu werden.
	TRS	Der Proze wurde beendet, ist aber noch resident.
	WEV	Der Proze wartet auf ein Ereignis (z.B. auf das Ende eines
		Kindprozesses).
	WIO	Der Proze wartet auf eine Ein/Ausgabe.
	ZOM	Es ist ein Zombie-Proze.
	STP	Der Proze wurde durch ein Signal beendet.

Die ps bergebenen Parameter und Flags werden ignoriert.
	

WENN MINT NICHT INSTALLIERT IST:
Das Kommando ps erzeugt eine Liste der augenblicklich laufenden Programme
(Prozesse). Anders als unter Unix, wo mehrere Prozesse gleichzeitig aktiv
sein k”nnen, ist unter TOS nur jeweils ein Proze aktiv. Dieser kann ein
anderes Programm starten und auf dessen Beendigung warten (mit der Be-
triebssystem-Funktion Pexec). Das so gestartete Programm kann wiederum
ein anderes starten usw. Mit ps wird die so erzeugte Reihe von Programmen
ausgegeben.
Nach Eingabe von ps erscheint eine Liste der Prozesse in der Reihenfolge
des Aufrufs. Der augenblickliche Proze steht oben, der zuerst vom Desk-
top gestartete Proze steht unten. Das Desktop selber erscheint nicht in
der Liste.

Flags:
	-b	Zu jedem Proze wird die Adresse von dessen Basepage aus-
		gegeben.
	-f	Wenn dieses Flag angegeben ist, erscheinen die vollen
		Pfadnamen, unter denen die Programme aufgerufen wurden.
		Wenn -f nicht angegeben ist, erscheint nur der reine
		Dateiname (Basisname).
	-c	Zu jedem Proze wird dessen Kommandozeile ausgegeben.
		VORSICHT: arbeitet unzuverl„ssig, da bei Programmstart die
		DTA auf diesen Bereich zeigt. Programme, die die DTA nicht
		selber „ndern, berschreiben bei jedem DTA-Zugriff diesen
		Bereich.

Der Kern des ps-Kommandos, n„mlich der Schritt von der Adresse der Basepage
zum Aufrufpfad des zugeh”rigen Programms, stammt aus der Datei initargs.c
aus der Library des Sozobon C-Systems.

ACHTUNG: Die einzige Angabe, auf die man sich verlassen kann, ist die
Adresse der Basepage. Da TOS den Aufrufpfad eines Programms nicht in
der Basepage abspeichert, benutzt ps einen Trick: es holt mit Hilfe der
Basepage-Adresse die gespeicherte Adresse des USP (User-Stack-Pointer) des
jeweiligen Programms und bekommt ber diese den ersten Parameter der zu-
letzt aufgerufenen Funktion. Dies ist in jedem Fall Pexec, daher ist der
erste Parameter der Pfadname des aufgerufenen Programms. (Dieser Trick stammt
aus den Libraries von Sozobon C.) Das kann natrlich schiefgehen, man sollte
sich also ber nichts wundern.
Teilweise werden die Aufrufpfade durch das Starten von externen Kommandos
ver„ndert. Beim Programmstart wird die Kommandozeile als DTA benutzt, wenn
ein Programm also seine DTA nicht „ndert, wird die Kommandozeile beim ersten
Aufruf von Fsfirst berschrieben.

Siehe auch:	basep

-----
putscr - Wiederherstellen des Bildschirminhalts

Syntax: putscr [-(f|s Dateiname)]

Ein zuvor mit getscr gespeicherter Bildschirminhalt wird wiederhergestellt.
Es ist m”glich, einen einmal gespeicherten Bildschirm mehrmals zu restau-
rieren.

Flags:
	-f	Der Speicherbereich wird freigegeben. Das Bild wird nicht
		wiederhergestellt.
	-s	Der Speicherbereich wird in die angegebene Datei gespeichert.
		Wenn eine Datei mit dem angegebenen Namen bereits existiert,
		wird sie berschrieben.

Beispiel:
	getscr - titel.doo
	putscr
	read
	cls
	putscr -f
			Mit dieser Befehlsfolge wird ein Doodle-Bild (32000
			Bytes) aus der Datei titel.doo geladen und angezeigt.
			Die Shell wartet auf einen Tastendruck, dann wird der
			Bildschirm gel”scht und der Speicherbereich wieder
			freigegeben.
			Mit dieser Befehlsfolge kann ein Shellscript, z.B.
			das Profile, eine Grafik als Titelbild ausgeben.

	getscr
	putscr -s shell.doo
	putscr -f
			Der aktuelle Bildschirminhalt wird im Doodle-Format
			in die Datei shell.doo gespeichert (Hardcopy).


Siehe auch: getscr
	    showpic (externes Kommando)

-----
pwd - Ermitteln des aktuellen Directories

Syntax: pwd [-a|{Drive}]

Schreibt das aktuelle Verzeichnis der angegebenen Laufwerke oder, wenn
kein Laufwerk angegeben ist, das aktuelle Verzeichnis des aktuellen
Laufwerks nach StdOut. Wenn -a angegeben ist, werden die aktuellen Verzeich-
nisse aller angeschlossenen Laufwerke ausgegeben.
pwd ohne Laufwerksangabe entspricht "echo $CWD".

Beispiele:
	pwd A: B: C: D: E: F:	ist „quivalent zu
	pwd abcdef		oder, wenn das alle Laufwerke sind, zu
	pwd -a

-----
raw - Ausgabe auf der "Raw Console"

Syntax: raw [-bnc] {Datei}

Als "Raw Console" oder RAWCON wird der Bildschirm ohne VT52-Emulator und
Steuerzeicheninterpretation bezeichnet. Die Ausgabe eines CR-Zeichens nach
RAWCON erzeugt also kein Zeilenende, sondern das "CR"-Schriftzeichen. Mit
dem Kommando raw kann eine Datei (oder StdIn, wenn keine Datei angegeben
ist) auf RAWCON ausgegeben werden. Am Ende der Datei wird jedoch ein
Zeilenvorschub eingefgt, damit das n„chste Prompt in einer neuen Zeile
erscheint. Das kann mit dem Flag -c unterbunden werden.

Flags:	-b	die Datei wird bin„r ge”ffnet, es findet also keine šber-
		setzung CR/LF -> LF statt.
	-n	alle CR-Zeichen werden statt ber RAWCON ber den VT52-
		emulator ausgegeben, bewirken also tats„chliche Zeilen-
		vorschbe. Alle anderen Zeichen werden nicht bersetzt.
	-c	die Ausgabe eines Zeilenvorschubs am Ende jeder Datei
		wird unterbunden.

Beispiele:

	raw cmds2.o cmds3.o cmds4.o
gibt die angegebenen Dateien auf RAWCON aus. An Ende jeder Datei wird ein
Zeilenvorschub erzeugt.

	hd -b data.bin | raw -n
Der Hexdump wird auf RAWCON ausgegeben. CR-Zeichen im Hexdump bewirken
tats„chliche Zeilenvorschbe in der Ausgabe.

Bemerkung:
1) Die Ausgabe erfolgt mit der Bios-Funktion Bconout.
2) Dieses Kommando erzeugt keine Ausgabe nach StdOut, kann also nicht
umgeleitet werden.

-----
rdti - Konfiguration der Shell mittels desktop.inf

Syntax: rdti [-dclxv] [Datei]

Mit diesem Kommando ist es m”glich, einige Konfigurationen der Shell direkt
aus der desktop.inf-Datei zu lesen, die vom Desktop beim Systemstart be-
nutzt wird. Diese Informationen sind:
	aktuelles Directory,
	Bezeichnungen der Laufwerke,
	Extender fr ausfhrbare Programme.
Jede dieser Eigenschaften l„t sich mit einem der Flags ausblenden, so
da man sich beim Aufruf von rdti die gewnschten Konfigurationen ein-
stellen kann. Wenn keine Flags angegeben sind, werden alle diese Ini-
tialisierungen durchgefhrt.
Wenn keine Datei angegeben ist, wird die Datei /desktop.inf auf dem
Bootlaufwerk benutzt. Es kann nur eine Datei angegeben werden, Wildcards
sind nicht erlaubt, der Aufruf "rdti c:/desk*.inf" ist also unzul„ssig.

Flags:
	-d	Wenn dieses Flag nicht angegeben ist, wird das Directory
		von jedem ge”ffneten Fenster ausgegeben.
	-c	Wenn dieses Flag nicht angegeben ist, wird ein cd in
		das Directory von jedem ge”ffneten Fenster ausgefhrt.
		Auf diese Weise kann man das aktuelle Directory auf das
		des obersten Fensters einstellen.
	-l	Wenn dieses Flag nicht angegeben ist, liest die Shell die
		Bezeichnungen der Laufwerke (die im Desktop unter den
		Laufwerk-Icons stehen). Diese Bezeichnungen werden z.B.
		von den internen Kommandos drive und df benutzt. Die
		alten Einstellungen der Bezeichnungen gehen dabei ver-
		loren.
	-x	Wenn dieses Flag nicht angegeben ist, initialisiert die
		Shell die Variable XEXT anhand der Extender, die in der
		Datei als Extender von ausfhrbaren Programmen (egal ob
		GEM, TOS oder TTP) eingetragen sind. Der alte Inhalt von
		XEXT geht dabei verloren, es sei denn, in der Datei sind
		keine Extender definiert.
	-v	Wenn dieses Flag angegeben ist, gibt rdti Informationen
		ber den Dateinamen sowie die durchgefhrten Konfigura-
		tionen aus.

Siehe auch:	drive

-----
read - Eingabe von Variablen

Syntax: read [[-] Var]

Eine Zeile wird von StdIn gelesen und, falls vorhanden, in der Variablen
Var abgelegt. Falls eine Variable mit Namen Var bereits existiert, so wird
der alte Wert berschrieben.
Wenn das Flag - angegeben ist, werden in der Eingabe Steuersequenzen und
Shellvariablen expandiert.

Beispiele:
1) Einlesen einer Benutzereingabe:
	echo Bitte geben Sie Ihren Namen ein
	read NAME
	echo Der Name ist $NAME
        
2) Einlesen der Anzahl der freien RAM-Bytes in eine Variable:
	mem | read RAM
	echo Es sind $RAM Bytes frei
   (ist analog zu "RAM=`mem`")

3) Warten auf Druck auf ENTER
	echo Bitte ENTER drcken
	read

4) Benutzung des Flags "-":
	read x
	$PATH				<------------- Eingabe
   speichert die Zeichenkette "$PATH" in der Variablen x.
	read - x
	$PATH				<------------- Eingabe
   speichert den Wert der Shellvariablen PATH in der Variablen x.
   
-----
readonly - Variablen schreibschtzen

Syntax: readonly [[-] {Variable}]

Schreibgeschtzte Variablen k”nnen nicht gel”scht und ihre Werte k”nnen
nicht ver„ndert werden. Mit dem readonly-Kommando kann das Schreibschutz-
Flag von Variablen gesetzt und gel”scht werden.
Wenn readonly ohne Parameter aufgerufen wird, wird eine Liste aller schreib-
geschtzter Variablen ausgegeben.
Ansonsten wird das Schreibschutz-Flag bei allen angegebenen Variablen ge-
setzt oder, wenn - angegeben ist, gel”scht.
Die Namen der Variablen k”nnen dabei im Format der erweiterten Wildcards
angegeben werden, z.B. "readonly a*" betrifft alle Variablen, deren Name
mit a beginnt. N„heres siehe okami.doc.
Es k”nnen nur Variablen schreibgeschtzt werden, die vom Benutzer angelegt
oder ver„ndert worden sind, also den Status "USR" haben (siehe "vars").
Um Variablen schreibzuschtzen, die von der Shell selber angelegt wurden,
z.B. PIPDIR, hilft folgender Trick:
	PIPDIR=$PIPDIR
	readonly PIPDIR
Durch die Zuweisung wird der Wert der Variablen nicht ver„ndert, die
Variable erh„lt aber den USR-Status.

Beispiele:
	readonly
				erzeugt eine Liste aller schreibgeschtzter
				Variablen.
	readonly VAR1 VAR2 KEY
				die Variablen VAR1, VAR2 und KEY werden
				schreibgeschtzt.
	readonly - VAR1 KEY
				der Schreibschutz der Variablen VAR1 und
				KEY wird entfernt.
	readonly *E*
				alle Variablen, deren Name ein E enth„lt,
				werden schreibgeschtzt.

Siehe auch:	export
		vars

-----
rm - L”schen von Dateien

Syntax: rm [-friqv] File {File}

Alle Dateien, die einem der Muster File entsprechen, werden gel”scht.

Flags:	-f	Es werden keine Fehlermeldungen bzgl. fehlenden Dateien
		ausgegeben. Auerdem werden auch Dateien, bei denen das
		Read Only-Flag gesetzt ist, gel”scht.
	-i	Vor dem L”schen werden die Namen aller Dateien angezeigt,
		und der Anwender wird gefragt, ob er diese l”schen will
		oder nicht. Als Ja gelten die Eingabe eines Wortes, das
		mit y oder Y beginnt, sowie ein Druck auf ENTER ohne Eingabe.
		Als Nein gilt jede andere Eingabe.
	-q	Es wird interaktiv gel”scht, d.h. der Anwender wird bei
		jeder Datei gefragt, ob er diese l”schen will oder nicht.
	-r	Es wird rekursiv gel”scht, d.h. wenn Ordner angegeben sind,
		so werden die Ordner mitsamt allen enthaltenen Dateien und
		Unterordnern gel”scht. Wenn das Flag -f nicht gesetzt ist,
		erfolgt bei allen schreibgeschtzten Dateien eine Nachfrage.
		Das Flag -q ist ohne Wirkung!
	-v	Die Namen der gel”schten Dateien werden auf dem Bildschirm
		ausgegeben.

Achtung: Ordner k”nnen mit diesem Kommando nur gel”scht werden, wenn das
Flag -r angegeben ist. Das normale Kommando zum L”schen von Ordnern ist
rmdir.

Beispiele:

rm xyz.bak
			L”schen einer Datei.
rm *.bak
			L”schen aller .bak-Dateien.
rm -f *.bak *.dup *.out
			L”scht auch schreibgeschtzte Dateien.
rm -rf /*
			L”scht ohne Nachfrage alles!
rm -rfv /tmp
			L”scht den Ordner /tmp mit allen enthaltenen Dateien
			und Unterordnern. Die Namen der gel”schten Dateien
			werden auf dem Bildschirm ausgegeben.

Rckgabewert:
	-1	Aufruffehler
	sonst	Anzahl der gel”schten Dateien (und Ordner bei -r).

Siehe auch:	rmdir

-----
rmdir - L”schen von leeren Ordnern

Syntax: rmdir Path {Path}

Die angegebenen Ordner werden gel”scht. Es drfen keine Dateien oder Unter-
ordner in Path enthalten sein. Um einen Ordner mitsamt seinem Inhalt zu
l”schen, gibt es das Kommando rm -r.

Rckgabewert: Anzahl der gel”schten Ordner.

Siehe auch:	rm

-----
rpn - SIEHE upn

-----
rsconf - Konfiguration der RS232-Schnittstelle

Syntax: rsconf [-s(Speed] [(+|-)x] [(+|-)r] [-p(0|1|2)] [-b(Bits)] [-w(Word)]

Die serielle Schnittstelle (Modemport) wird konfiguriert. Die Parameter
haben folgende Bedeutung:

	-s	šbertragungsgeschwindigkeit. M”gliche Werte fr Speed sind:
		19200, 9600,4800,3600,2400,2000,1800,1200,600,300,200,
		150,134,110,75,50 (alles in baud). Der Defaultwert ist 9600.
	-x	XON/XOFF wird abgeschaltet	(Default).
	+x	XON/XOFF wird eingeschaltet.
	-r	RTS/CTS  wird abgeschaltet	(Default).
	+r	RTS/CTS  wird eingeschaltet.
	-p	Parit„t. M”gliche Angaben sind:
		0 (keine Parit„t), 1 (ungerade), 2 (gerade). Der Default-
		wert ist 0.
	-b	Anzahl der Start- und Stopbits. M”gliche Angaben:
		Bits	Startbits	Stopbits	šbertragung
		0	0		0		Synchron  (Default)
		1	1		1		Async.
		1.5	1		1.5		Async.
		2	1		2		Async.
	-w	Wortl„nge. M”gliche Angaben fr Word sind:
		8,7,6,5 (in bits). Der Defaultwert ist 8.

Beispiele:
	rsconf
		stellt ein: 9600 baud, kein XON/XOFF, kein RTS/CTS, keine
		Parit„t, 0 Start- und Stopbits, Wortl„nge 8 bit.
	rsconf -s4800
		wie oben, nur mit 4800 baud.
	rsconf -s19600 +x +r -p1 -b2 -w7
		stellt ein: 19600 baud, XON/XOFF, RTS/CTS, ungerade Pari-
		t„t, 1 Startbit, 2 Stopbits, Wortl„nge 7 bit.

-----
scr - Einstellen der Bildschirmfarbe

Syntax: scr [-bwlhg]

Einstellen von Hinter- und Vordergrundfarbe sowie der Anzahl der Zeilen auf
dem Bildschirm (nur in hoher Aufl”sung sinnvoll).
Flags:	-b (black)	Einstellen von dunklem Hinter- und hellem Vorder-
			grund.
	-w (white)	Einstellen von hellem Hinter- und dunklem Vorder-
			grund.
	-g (gray)	Der Bildschirm wird mit dem grauen Desktop-Hinter-
			grundmuster gefllt. Das ist sinnvoll vor dem Starten
			von Gem-Programmen, z.B. in der Gemexec-Funktion.
	-l (low)	Einstellen von 24 Zeilen (normale Schrift).
	-h (high)	Einstellen von 48 Zeilen (kleine Schrift).

Fr die Einstellung der Zeilenanzahl mit -l und -h gilt:

1) gon mu aktiv sein.
2) Nach der Einstellung wird der Bildschirm gel”scht.
3) Die neue Zeilenanzahl wird in der Shellvariablen COLUMNS abgelegt.
4) Die Einstellung beruht auf einer undokumentierten VDI-Funktion, zu
   der das Profi-Buch sagt: "Verwendung auf eigene Gefahr". Abstrze sind
   m”glich.

Siehe auch:	cursor
		gemexec
		keyb
		mouse

-----
set - Einstellen von Shell-Flags

Syntax: set [-|([+Flags] [-Flags])]

Es wird ein Shell-Flag gesetzt oder gel”scht, oder es wird der Status
aller Shell-Flags ausgegeben.
Bei der Verwendung ohne Parameter wird der Status aller Shell-Flags
mit einer kurzen Erkl„rung des jeweiligen Flags ausgegeben.
Bei der Verwendung mit dem Parameter - wird der Status aller Shell-Flags
in einer Form ausgegeben, die sp„ter als Parameter fr set benutzt werden
kann. Dies ist ntzlich, wenn in einem Shellscript ein Flag lokal ge„ndert
werden soll:
	A=`set -`
	set +x
	................... (irgendwelche Kommandos)
	set $A
	unset A
Der Status der Flags wird in die Variable a eingelesen. Diese Variable wird
sp„ter benutzt, um die nderung (set +x) ggfs. rckg„ngig zu machen.

Bei der Verwendung mit einem anderen Parameter als einem einzelnen Minus-
zeichen wird das entsprechende Flag gesetzt (+) oder zurckgesetzt (-).
Beispiel: set +x setzt das Flag x.
	  set -x l”scht das Flag x.

Die folgenden Flags k”nnen benutzt werden:

	b	Wenn dieses Flag gesetzt ist, wird in einer Eingabezeile
		jeder Slash (/) in einen Backslash (\) umgeformt. Dadurch
		ist es m”glich, Pfadnamen wie in Unix blich mit Slashes
		zu trennen (was einfacher ist, da man auf dem ST fr einen
		Slash zwei, fr einen Backslash aber drei Tasten gleich-
		zeitig drcken mu). Wenn das Flag nicht gesetzt ist, werden
		keine Slashes in Backslashes umgeformt.
		Die Umformung betrifft s„mtliche Eingaben, also auch Zu-
		weisungen an Variablen, Zeilen aus Shellscripts etc.
		Nach dem Start der Shell ist dieses Flag gesetzt.

	l	Wenn dieses Flag gesetzt ist, werden Dateinamen in
		Kleinbuchstaben ausgegeben. Wenn das Flag nicht gesetzt ist,
		werden Dateinamen so ausgegeben, wie sie auf der Diskette
		gespeichert sind (in Grobuchstaben).
		Dieses Flag beeinflut nicht die M”glichkeit, Dateinamen
		in Kleinbuchstaben einzugeben.
		Nach dem Start der Shell ist dieses Flag gesetzt.

	s	Wenn dieses Flag gesetzt ist, schreibt die Shell nach dem
		Programmende durch Eingabe von exit oder shutdown oder 
		durch Druck auf Ctrl V das aktuelle Directory ($CWD) in
		die Datei $HOME\wdir. Die Datei wird unsichtbar gemacht.
		Wenn das Profile ($HOME\profile) folgende Zeilen enth„lt:
			set +s
			read a < $HOME\wdir
			cd $a
		dann wird die Shell nach jedem Aufruf auf das Directory
		eingestellt, in dem sie zuletzt verlassen wurde. Dies ist
		sehr sinnvoll beim Einsatz einer Festplatte.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

	x	Vor dem Ausfhren einer Bin„rdatei (PRG, TOS etc.) wird
		das aktuelle Verzeichnis auf das Verzeichnis umgestellt,
		in dem sich die Datei befindet. Nach der Ausfhrung der
		Datei wird das aktuelle Verzeichnis wieder zurckgesetzt.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

	c	Vor dem Ausfhren eines Shellscripts wird das aktuelle
		Verzeichnis auf das Verzeichnis umgestellt, in dem sich 
		das Shellscript befindet. Nach dem Ende des Scripts wird
		das aktuelle Verzeichnis wieder zurckgesetzt.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

	h	Wenn dieses Flag gesetzt ist, wird die Datei, aus der bei
		Druck auf Help die Hilfstexte zu den einzelnen Kommandos
		gelesen werden (i.d.R. diese Datei, commands.doc), resident
		im Speicher gehalten. Wenn das Flag nicht gesetzt ist, wird
		die Datei bei jedem Druck auf Help neu geladen. Nach dem
		Start der Shell ist dieses Flag gesetzt, und der einzige
		Grund, es zu l”schen, ist Speicherplatzmangel. Um ein resi-
		dentes Helpfile aus dem Speicher zu entfernen, dieses Flag
		l”schen (set -h), ein beliebiges Kommando eingeben und Help
		drcken.
		Nach dem Start der Shell ist dieses Flag gesetzt.

	u	Wenn dieses Flag gesetzt ist, werden die Standard-Streams,
		also die Dateien, die fr die Ein-Ausgabe-Umleitung und
		das Pipelining benutzt werden, im Bin„rmodus ge”ffnet. Das
		bedeutet, da in der Ein- und Ausgabe ber diese Dateien
		die šbersetzung zwischen CR/LR und CR abgeschaltet wird.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

	w	Wenn dieses Flag gesetzt ist, interpretiert die Shell die
		erweiterten Wildcards * und []. Wenn das Flag nicht gesetzt
		ist, werden alle Wildcards wie unter TOS behandelt. Dies be-
		trifft nur die Angabe von Dateinamen, nicht die sonstige Ver-
		wendung der erweiterten Wildcards z.B. bei Verwendung der
		Help-Taste.
		Nach dem Start der Shell ist dieses Flag gesetzt.

	p	Wenn dieses Flag gesetzt ist, wird beim Start von Bin„rpro-
		grammen diesen die Ein/Ausgabeumleitung in der Kommandozeile
		bergeben, und zwar in der Form "<Eingabedatei >Ausgabedatei".
		Vorher wird die Umleitung auf Gemdos-Basis rckg„ngig gemacht.
		Wenn das Flag nicht gesetzt ist, wird die Ein/Ausgabe aus-
		schlielich mit der Gemdos-Funktion Fforce umgeleitet, den
		Bin„rprogrammen wird also kein Dateiname bergeben. Dies ist
		die Normaleinstellung, die nur in extremen Sonderf„llen ge-
		„ndert werden sollte.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

	a	Wenn dieses Flag gesetzt ist, werden jedem von der Shell ge-
		starteten Programm die bergebenen Parameter und der Programm-
		name nach dem xArg-Protokoll bergeben.
		Nach dem Start der Shell ist dieses Flag gesetzt.

	f	Wenn dieses Flag gesetzt ist, wird, wenn in der Tastaturein-
		gabe Dateinamen-Vervollst„ndigung mit Pfeil links oder ESC
		ausgefhrt wird, an den eingegebenen Dateinamen ein `*' an-
		geh„ngt, wodurch dieser als Pr„fix fr die auszuw„hlenden
		Dateien wirkt.
		Nach dem Start der Shell ist dieses Flag nicht gesetzt.

-----
shutdown - Abschalten oder Neubooten von Rechner und Festplatte

Syntax: shutdown [-rRtfv]

Wenn eins der Flags -r und -R angegeben ist, wird nach einer Sicherheits-
abfrage ein Warmstart (bei -r) oder Kaltstart (bei -R) durchgefhrt.

Wenn keins der Flags -r und -R angegeben ist, wird der Rechner bereit zum
Abschalten gemacht. Nach einer Sicherheitsabfrage werden alle Streams ge-
schlossen sowie Maus und Cursor abgeschaltet.
Wenn die Datei $HOME\bin\ship.exe vorhanden ist, wird sie geladen und
ausgefhrt (als Bin„rprogramm). Festplattenbenutzer sollten hierhin
das SHIP.PRG der Harddisk-Utility-Diskette kopieren. Damit wird auch die
Festplatte zum Abschalten bereit gemacht.
Laut Handbuch der Atari-Festplatte kann diese zwar jederzeit abgeschaltet
werden, und SHIP.PRG braucht nur vor einem Transport gestartet zu werden.
Trotzdem ist es sinnvoll, die Platte vor jedem Abschalten zu parken, da
ansonsten der Schreib-Lesekopf wie ein Damoklesschwert ber den empfind-
lichen Daten h„ngt.
Wenn weitere Aktionen beim Shutdown erwnscht sind, kann man ein Programm
schreiben, das diese Aktionen ausfhrt, und dieses nach $HOME\bin\ship.exe
kopieren. Dieses Programm kann das Harddisk-Ship-Programm dann per Pexec
aufrufen.
Danach wird die Meldung "...shutdown completed..." ausgegeben, und das
System l„uft in eine Endlosschleife, die nur durch einen Reset verlassen
werden kann.

Wenn beim Laden und Starten von ship.exe ein Fehler auftritt, wird shutdown
abgebrochen (auer wenn -f angegeben ist). Wenn ship.exe nicht gefunden wird,
erscheint eine Warnung, aber shutdown wird nicht abgebrochen.

Flags:
	-r	Warmstart. Die Festplatte wird nicht geparkt, das Programm
		$HOME\bin\ship.exe wird nicht ausgefhrt.
	-R	Wie -r, aber Kaltstart.
	-t	Wenn dieses Flag angegeben ist, wird vor dem Shutdown bzw.
		Reset das mit trap definierte Kommando ausgefhrt.	
	-f	Es erfolgt keine Sicherheitsabfrage. Wenn beim Laden und
		Starten von ship.exe ein Fehler auftritt, wird shutdown
		nicht abgebrochen.
	-v	Vor jeder Aktion wird eine entsprechende Meldung auf den
		Bildschirm geschrieben. Ist ohne Wirkung bei -r und -R,
		da es hier keine Aktionen gibt, zu denen sich irgendwelche
		Meldungen lohnen wrden, auerdem h„tte man nicht viel
		Zeit, die Meldungen zu lesen.

Siehe auch:	trap

-----
sleep - eine Weile warten

Syntax: sleep [-sm] n

Dieses Kommando legt eine Pause von n Sekunden ein.
Wenn gon aktiv ist, wird zum Warten die AES-Funktion evnt_timer aufgerufen,
wodurch in der Wartezeit die Multitasking-Accessories zum Zuge kommen. Der
Nachteil ist, da hier die Wartezeit nicht allzu genau ist; bei aktivem
gon ergab "time sleep 1" Zeiten zwischen 0.2 und 1.1 Sekunden.
Wenn gon nicht aktiv ist, wird zum Warten eine Warteschleife benutzt, die
den 200-Hz-Systemtimer abfragt. Hierbei kommt "time sleep 1" konstant auf
1.01 Sekunden.

Flag:	-s	Es wird n Timer-Zyklen zu je 1/200 Sekunden gewartet.
		"sleep 1" ist also „quivalent zu "sleep -s 200". Es wird
		in einer Warteschleife gewartet, auch wenn gon aktiv ist.
	-m	Es wird n Millisekunden gewartet. "sleep 1" ist also auch
		„quivalent zu "sleep -m 1000". Dieses Flag hat nur Sinn,
		wenn gon aktiv ist, ansonsten wird nicht n Millisekunden,
		sondern n/5 Timer-Zyklen zu je 1/200 Sekunden gewartet.

-----
sort - Sortieren der Standardeingabe

Syntax: sort [-lnrs]

Das sort-Kommando ist ein Filter, d.h. es liest seine Standard-Eingabe
(StdIn), macht etwas damit und schreibt das Ergebnis zur Standard-Aus-
gabe (StdOut).
sort liest Zeilen von StdIn und gibt sie in sortierter Reihenfolge wieder
aus. Die Maximalanzahl der Zeilen ist 500. (Wer mehr braucht, kann dafr
den Software-Support benutzen. Die tats„chliche Anzahl der Zeilen einer
Shellversion kann mit "ver -l" ermittelt werden.)

Flags:
	-l	Es wird nach der L„nge der Zeilen sortiert, die krzeste
		Zeile kommt zuerst.
	-n	Es wird numerisch sortiert. Die Eingabezeilen werden als
		Zahlenangaben betrachtet (die mit %, 0 und 0x beginnen
		drfen, um bin„re, oktale oder hexadezimale Zahlen zu
		kennzeichnen) und in aufsteigender Reihenfolge sortiert,
		d.h. die kleinste Zahl kommt zuerst.
	-r	Die Sortierreihenfolge wird umgekehrt.
	-s	Die Strings werden nicht verkrzt. Wenn dieses Flag nicht
		angegeben ist, werden fhrende und endende Leer- und
		Tabulatorzeichen entfernt. Dies ist notwendig, wenn z.B
		mit "ls | sort -l" eine Dateiliste nach der L„nge der
		Dateinamen sortiert werden soll, da in der Ausgabe des
		ls-Kommandos alle Dateinamen mit Leerzeichen auf 14 Zeichen
		L„nge gebracht werden. 

Wenn keins der Flags l und n angegeben ist, wird nach lexikographischer
Reihenfolge sortiert (mit der strcmp-Funktion, alle Kleinbuchstaben kommen
daher nach allen Grobuchstaben).
Zum Sortieren wird der Quicksort-Algorithmus benutzt.

-----
split - eine Datei ein kleine Stcke aufteilen

Syntax: split [-bvf] {[-Num] Datei}

Jede der angegebenen Dateien wird in Stcke von maximal Num Zeilen (mit je
max. 80 Zeichen) aufgeteilt. Der Defaultwert fr n ist 80. Die erzeugten
Teildateien haben denselben Namen wie die Quelldatei, wobei Extender von
000 bis maximal 999 erzeugt werden. Wenn mehr als 999 Teilstcke notwendig
werden, wird der Rest der Datei in die Datei mit dem Extender .999 ge-
schrieben.
Wenn die Teildateien bereits existieren, erfolgt eine Sicherheitsnachfrage.
Wird diese mit Nein beantwortet, nimmt split die n„chste Datei usf., bis
eine Datei gefunden ist, die nicht existiert oder zu der der Anwender sein
Einverst„ndnis zum šberschreiben gibt.

Flags:
	-b	Die Datei wird in Stcke zu je max. Num Bytes aufgeteilt.
		Diese Option ist notwendig, um Bin„rdateien zu zerteilen.
	-f	Es erfolgt keine Nachfrage bei schon existierenden Dateien,
		diese werden berschrieben.
	-v	Es wird der Name jeder erzeugten Datei auf dem Bildschirm
		ausgegeben.

Beispiel:
	split -100 commands.doc
		teilt die angegebene Datei in Stcke zu je 100 Zeilen auf.
		Die erzeugten Dateien haben die Namen commands.000,
		commands.001 usw.
	split -10 f1.txt -20 f2.txt -30 f3.txt
		teilt f1.txt in Teile zu 10, f2.txt in Teile zu 20 und
		f3.txt in Teile zu 30 Zeilen auf.
	split long.doc
		teilt long.doc in Teile zu 80 Zeilen auf.
	split -bv -700000 part_c.lzh
		Aufteilen einer langen Archivdatei in Stcke, die auf
		eine Diskette passen. Die Namen der erzeugten Dateien
		werden auf dem Bildschirm ausgegeben.

Achtung: dieses Kommando sollte nur dann auf Bin„rdateien angewandt werden,
wenn das Flag -b benutzt wird.

-----
te - Terminal-Emulator

Syntax: te [-dk] [Dev {file | :string}]

Dies ist ein sehr einfacher und primitiver Terminal-Emulator. Er kann Daten
an eine beliebige Schnittstelle (RS232, Drucker, Midi) schicken und von dort
einlesen sowie Dateien ber die Schnittstelle ausgeben. Seine F„higkeiten
reichen allerdings aus zur Kommunikation mit einem Modem oder zum Ein-
loggen in eine Mailbox. Durch die M”glichkeit, w„hrend einer Mailbox-
sitzung te zu verlassen und andere Shell-Kommandos einzugeben, lassen
sich Up- und Downloads realisieren.
Mit Dev wird die zu benutzende Schnittstelle angegeben. M”gliche Werte sind:

	0	paralelle Schnittstelle (Drucker)
	1	serielle Schnittstelle (Modem) (default)
	2	Konsole (keine gute Idee)
	3	Midi-Schnittstelle
	4	Tastatur (eine sehr schlechte Idee)

Die Voreinstellung ist 1 (serielle Schnittstelle).
Wenn keine Dateien angegeben sind, arbeitet te im Dialogmodus, d.h. es werden
Daten von der Tastatur eingelesen und ber die Schnittstelle geschickt sowie
Daten von der Schnittstelle eingelesen und auf StdOut ausgegeben. Beendet wird
te durch einen Druck auf UNDO.
Wenn Dateinamen angegeben sind, werden alle diese Dateien ber die Schnitt-
stelle geschickt. Eingaben von der Schnittstelle werden ignoriert. Achtung:
in diesem Fall mu als erstes die Schnittstellennummer (Dev) angegeben sein.
Anstelle von Dateinamen k”nnen auch Strings angegeben werden, die direkt auf
die Schnittstelle geschickt werden. Diese Strings mssen mit einem Doppel-
punkt (:) eingeleitet werden. Der Doppelpunkt selber wird nicht mitgeschickt.
Achtung: te fgt am Ende des Strings kein Newline-Zeichen ein!
Wenn der String Leerzeichen enth„lt, mu er in Anfhrungszeichen gesetzt
werden.

Flag:	-d	Wenn dieses Flag angegeben ist, werden alle im Dialogmodus
		von der Schnittstelle eingelesenen Zeichen wieder an selbige
		zurckgeschickt. Das ist ntzlich zum Testen von Schnitt-
		stellenverbindungen.
	-k	Wenn dieses Flag angegeben ist, werden im Dialogmodus alle
		Tastatureingaben auf dem Bildschirm ausgegeben. Das ist
		nur dann notwendig, wenn das an der Schnittstelle ange-
		schlossene Ger„t das nicht selber macht.

Beispiele:
	te
		arbeitet im Dialogmodus.

	te 3
		ebenso, aber ber die Midi-Schnittstelle.

	te 1 file.txt xyz.abc
		schickt die Dateien file.txt und xyz.abc an die serielle
		Schnittstelle.

	te >aux.in
		empf„ngt Daten von der seriellen Schnittstelle und schreibt
		diese in die datei aux.in, solange bis die UNDO-Taste gedrckt
		wird.

	te 1 :"ATD1234^n"
		schickt eine Steuersequenz zum automatischen W„hlen der
		Telefonnummer an das an der seriellen Schnittstelle ange-
		schlossene Modem.

Siehe auch:	dial
		ts

-----
tee - T-Kreuzung der Eingabe

Syntax: tee File

StdIn wird nach StdOut und nach File kopiert.

-----
test - Auswerten von logischen Ausdrcken

Syntax: test Ausdruck
oder	[ Ausdruck ]

Das test-Kommando wird normalerweise in Verbindung mit if oder while benutzt.
Der Rckgabewert ist 1, wenn der Ausdruck wahr ist, und 0 sonst. test er-
zeugt keine Ausgabe.
Der Ausdruck kann eins der folgenden Formate haben:

		Dateioperationen:
-f file 	Wahr, wenn file existiert.
-x file 	Wahr, wenn file ausfhrbar ist.
-d file 	Wahr, wenn file ein Directory ist.
-g file 	Wahr, wenn file ein GEM-Programm ist ($GEXT).
		Variablenoperationen:
+v var		Wahr, wenn var der Name einer gesetzten Shellvariablen ist.
-v var		Wahr, wenn es keine Shellvariable namens var gibt.
		Stringoperationen:
a = b		Wahr, wenn die Strings a und b gleich sind.
a != b		Wahr, wenn die Strings a und b ungleich sind.
a -t b		Wahr, wenn das Kommando a auf eine der Typen b ausgefhrt
		werden kann. M”gliche Typen sind:
			f	Shellfunktion
			i	internes Kommando
			s	Shellscript
			b	Bin„rprogramm
			n	Kommando nicht gefunden
		Es k”nnen beliebig viele dieser Typen angegeben werden.

		Die folgenden numerischen Operationen vergleichen zwei
		Zahlen x und y:
x -eq y 	x =  y
x -ne y 	x != y
x -lt y 	x <  y
x -gt y 	x >  y
x -le y 	x <= y
x -ge y 	x >= y

Achtung: bei -v und +v mu der Name einer Variablen angegeben werden und
nicht der Inhalt, also z.B. "test +v TERM" und nicht "test +v $TERM".

Beispiele: siehe if.

-----
then - SIEHE if

-----
time - Stoppuhr fr Programme

Syntax: time Kommando {Parameter}

Fhrt das Kommando mit den angegebenen Parametern aus und schreibt die
Laufzeit in Minuten, Sekunden und 1/100 Sekunden auf den Bildschirm.
Das Ermitteln der Zeit geschieht mittels des 200 Hz-Systemtimers.

-----
touch - Erneuern oder Anlegen von Dateien

Syntax: touch File {File}

Wenn File bereits existiert, werden Datei-Datum und -Zeit auf die aktuelle
Systemzeit gesetzt. Wenn File noch nicht existiert, wird eine Datei mit
dem Namen File angelegt.

Rckgabewert:
	-1	Aufruffehler
	1	Die Datei ist erzeugt worden.
	0	Das Dateidatum einer existierenden Datei wurde ge„ndert.
Hierbei bezieht sich der Wert auf die letzte behandelte Datei.

-----
tr - Filter

Syntax: tr Filter

Filtert StdIn nach StdOut, abhaengig von den Angaben in Filter.
Jede Zeile in der Datei Filter (bis auf Leerzeilen oder Zeilen, die mit
# (Doppelkreuz) anfangen), bestimmt ein Zeichen. Die Zeilen haben den
Aufbau

s d

wobei s und d in dezimaler, hexadezimaler, oktaler oder Ascii-Schreibweise
angegebene Werte zwischen 0 und 255 sind.
Bsp: um in StdIn jedes A (grosses A) in B (grosses B) zu filtern, kann
z.B. eine der folgenden Zeilen in Filter stehen:

	!A  !B			(Character-Schreibweise)
	65  !B			(dezimale Schreibweise)
	0x41 !B 		(hexadezimale Schreibweise)
	0101 !B 		(oktale Schreibweise)

Auch B kann in jedem der F„lle in jeder der vier Schreibweisen
angegeben werden.

Beispiel:
	tr tab.tr <datei.txt >prt:
filtert die Datei datei.txt mit der Filterdatei tab.tr. Das Ergebnis wird
zum paralellen Drucker (prt:) geschickt.

-----
trap - Definieren eines Kommandos zum Beenden der Shell

Syntax: trap [-|[+]Kommando {Parameter}]

Es wird ein Shell-Kommando definiert, das nach dem Beenden der Shell mit
exit oder Control-V aufgerufen wird. Das Trap-Kommando wird nur beim Beenden
der Shell selber ausgefhrt, nicht beim Beenden eines Shell-Scripts mit exit
oder bei einem shutdown (auer bei shutdown -t).
Beim Aufruf ohne Parameter wird das aktuelle Trap-Kommando ausgegeben.
Beim Aufruf mit einem Minuszeichen wird das Trap-Kommando gel”scht.
Beim Aufruf mit einem anderen Parameter als einem Minuszeichen wird dieser
Parameter als Trap-Kommando gespeichert. Wenn der Parameter mit einem Plus-
zeichen beginnt, wird das Pluszeichen entfernt und der Rest an das bisherige
Trap-Kommando angeh„ngt.

Beispiele:
	trap echo hallo
			definiert "echo hallo" als das Kommando, das nach
			einem exit ausgefhrt werden soll.
	trap
			gibt das zuvor definierte Kommando aus.
	trap -
			l”scht die Einstellung.
	trap cls ^; echo Byebye
			l”scht beim Ende der Shell den Bildschirm und
			schreibt "Byebye". Nach Eingabe von trap ohne
			Parameter erscheint von da an "cls ; echo Byebye".
	trap cls ; echo Byebye
			l”scht beim Ende der Shell nur den Bildschirm,
			"Byebye" wird sofort geschrieben.
	trap `trap` ^; echo Byebye
			h„ngt das Kommando "echo Byebye" an den aktuellen
			trap-String an.
	trap +echo Byebye
			ebenso.

Eine sinnvolle Anwendung ist
	trap cursor -v
im Profile. Dadurch wird verhindert, da nach dem Ende der Shell der
Cursor auf dem Desktop weiterhin sichtbar ist.

Anmerkung: Wer st„ndig mit gon arbeitet, braucht goff nicht durch das trap-
Kommando geben zu lassen, da goff bei Ende der Shell automatisch ausgefhrt
wird.

Siehe auch: 	exit
		history
		shutdown
		"Speichern und Restaurieren der Shell-Einstellungen"
								in tricks.doc

-----
true - Rckgabe von 1

Syntax: true

Dieses Kommando liefert immer eine 1 zurck. Es wird normalerweise mit dem
while-Kommando benutzt.

Beispiel: Programmieren einer Endlosschleife. Sie kann durch "break" im
Schleifenrumpf beendet werden.

		while true
		do
		  ............. (irgendwelche Kommandos)
		done

Siehe auch: while
	    if
	    false

-----
ts - Terminal Server

Syntax: ts [-detrf] [-hHerald] [-lLogin] [-pPasswort] [-mAnzahl] [-bGer„t]

Dieses Kommando verwandelt die Okami-Shell in einen Terminal-Server, der
Kommandos von einer beliebigen Schnittstelle annimmt und ausfhrt. Man kann
den ST also ber eine Modem- oder Kabelverbindung von einem anderen Rechner
aus fernsteuern.
Die Ein/Ausgabe l„uft unter das mit -b angegebene Bios-Ger„t. Folgende
Angaben sind m”glich:

	0	paralelle Schnittstelle (Drucker)
	1	serielle Schnittstelle (Modem) (default)
	2	Konsole (keine gute Idee)
	3	Midi-Schnittstelle
	4	Tastatur (eine sehr schlechte Idee)

Wenn ein Herald (Einschaltmeldung) angegeben ist, wird dieser zuerst ber die
Schnittstelle geschickt. Danach kann der Benutzer am anderen Ende der Leitung
sich ber Login und Passwort, falls angegeben, autentisieren. Die Shell
fragt ber die Schnittstelle "login:" bzw. "Password:", das Kommando wird
nur fortgesetzt, wenn der Benutzer die in der Kommandozeile nach -l bzw. -p
angegebenen Strings eingibt.
(Login und Passwort sind also zwei „quivalente Kennworte. ts verwaltet nicht
wie Unix verschiedene Benutzer-Logins, die jeweils ein eigenes Passwort haben.)

Die nach -m angegebene Anzahl legt fest, wie oft ein fehlerhaftes Login oder
Passwort eingegeben werden darf. Wenn diese Zahl kleiner als 0 ist, darf man
beliebig viele falsche Logins bzw. Passworte eingeben (dies ist die Default-
Einstellung).
Wenn der Benutzer an der Schnittstelle als Login "exit" eingibt, wird ts
beendet.
ts liest von der angegebenen Schnittstelle Kommandos und fhrt diese aus, so-
lange bis auf der Tastatur des ST eine Taste gedrckt oder von der Schnitt-
stelle das Kommando "exit" eingegeben wird. Fšhrende und endende Leerzeichen
der Schnittstellen-Eingaben werden ignoriert. Die Ausgabe der eingelesenen
Kommandos wird wieder ber die Schnittstelle bertragen, wenn nicht das Flag
-r angegeben ist. Alle eingelesenen Kommandos und deren Ausgaben werden auf
dem Bildschirm des ST protokolliert, wenn nicht das Flag -e angegeben ist.
Alle Eingaben des Terminals k”nnen mit Backspace bzw. Ctrl-H korrigiert wer-
den.

Achtung: interaktive Kommandos, die Tastatureingaben ben”tigen, wie rm -i oder
pg, k”nnen auf diese Weise nicht benutzt werden, da diese nur die Tastatur
des ST abfragen!

Flags:	-d	Der Server arbeitet nicht voll-duplex. Wenn dieses Flag nicht
		angegeben ist, werden alle empfangenen Zeichen wieder zurck
		ber die Schnittstelle geschickt. Wenn -d angegeben ist, ge-
		schieht das nicht, das angeschlossene Terminal mu die Zeichen
		also selber ausgeben.
	-e	Die empfangenen Kommandos und deren Ausgaben erscheinen nicht
		auf dem Bildschirm.
	-t	Die empfangenen Kommandos werden nicht ausgefhrt.
	-r	Die Ausgabe der empfangenen Kommandos wird nicht auf die
		Schnittstelle umgeleitet.
	-f	Vor jedem Login wird der Schnittstellenpuffer gel”scht.
	-h	Angabe der Einschaltmeldung, die vor jedem Login ber die
		Schnittstelle geschickt wird.
	-l	Angabe eines optionalen Login-Kennwortes.
	-p	Angabe eines optionalen Passwortes.
	-m	Maximalanzahl der falschen Logins/Kennworte.
	-b	Angabe der zu benutzenden Schnittstelle (Bios-Ger„tenummer).

Beispiel:
Eingabe auf dem ST:	ts -lroot -patari -h"Okami Shell^015^n"
Auf dem (an der seriellen Schnittstelle) angeschlossenen Terminal:

	Ausgabe			Eingabe

	Okami Shell
	login:			root
	password:		atari
	 $			......... (irgendein Shell-Kommando)
	(Ausgabe desselben)	exit
	Okami Shell
	login:			exit 

Durch die Eingabe von "exit" als Login wird ts beendet.
Als Terminal kann z.B. ein Atari Portfolio mit der seriellen Schnittstelle
und dem xterm-Programm von der Diskette des Portfolio-Praxisbuches betrie-
ben werden. Natrlich kann man sich (was vielleicht sinnvoller ist) auch
ber eine Modem-Verbindung auf diese Weise in den ST einloggen.

Siehe auch:	te

-----
type - Ermitteln des Aufrufpfades eines Kommandos

Syntax: type [-fs] Kommando {Kommando}

Es wird ausgegeben, unter welchem Pfad die Shell das Programm zu dem
angegebenen Kommando aufrufen wrde. Wenn es sich um ein internes
Kommando handelt, erscheint die Meldung "... is a shell builtin".
Wenn es sich um eine Shellfunktion handelt, erscheint die Meldung
"... is a function", auerdem wird die Definition der Funktion ausgegeben
(falls das Flag -f nicht angegeben ist).

Benutzt werden die Shellvariablen $PATH fr die Pfade, auf denen das
Kommando gesucht wird, sowie $XEXT und $SEXT fr die zu untersuchenden
Dateinamen-Extender. Wenn ein Kommando in der Hash-Tabelle enthalten ist,
wird die dort gespeicherte Pfad ausgegeben, ohne da auf der Platte gesucht
wird. Es erscheint dann die Ausgabe "... is hashed".

Beispiel: Es sei d:\shell\bin\test.prg eine Programmdatei. $PATH enthalte
den Pfad d:\shell\bin, $XEXT enthalte den Extender .prg (z.B.:
	PATH=.,..,d:\shell,d:\shell\bin
	XEXT=.prg,.tos,.ttp
Dann wird bei der Eingabe von "type test" der vollst„ndige Pfadname
der Datei test.prg ausgegeben. Wenn das aktuelle Directory d:\shell\bin
ist, erzeugt "type test" die Ausgabe "test is .\test.prg".

Flag:	-f	Wenn dieses Flag angegeben ist, wird bei einer Shell-
		funktion nur die Zeile "... is a function" ausgegeben
		und nicht die vollst„ndige Definition der Funktion.
	-s	Es wird nur der vollst„ndige Name der angegebenen Kommandos
		ausgegeben, also nicht "... is a shell builtin" etc. Bei
		internen Kommandos und Shellfunktionen ist das der Name,
		bei externen Kommandos der Aufrufpfad.

Siehe auch:	hash
		den Abschnitt ber externe Kommandos

-----
unalias - SIEHE unset

-----
unset, unalias - Entfernen von Shellfunktionen und -variablen

Syntax: unset|unalias Name {Name}

Alle angegebenen Shellfunktionen und -variablen werden gel”scht. Vorsicht:
wenn es zu einem der angegebenen Namen sowohl eine Funktion als auch eine
Variable gibt, werden beide gel”scht. Daher empfiehlt es sich, sich an die
Konvention zu halten, Variablennamen in Grobuchstaben und Funktionsnamen
in Kleinbuchstaben zu benutzen.
Dieses Kommando kann auch unter dem Namen unalias angesprochen werden, um das
Ausfhren von Shellscripts zu erm”glichen, die fr C-Shell-orientierte Shells
geschrieben wurden.

Siehe auch:	alias

-----
upn, rpn - UPN-Rechner incl. Einheitenumrechner

Syntax: upn|rpn [%Fmt] UPN-Ausdruck

Mit diesem Kommando k”nnen beliebige mathematische Ausdrcke berechnet wer-
den. Die Ausdrcke werden in der umgekehrten polnischen Notation (UPN) an-
gegeben, weil (1) ich ein Fan von HP-Rechnern bin und (2) weil ein Auswerter
fr UPN-Ausdrcke einfacher zu programmieren ist. Wer eher auf die englische
Schreibweise steht, kann dieses Kommando auch unter dem Namen "rpn" aufrufen.

Ein UPN-Ausdruck ist eine Folge von durch Leerzeichen (:= Space, Tab...)
getrennten Zahlen oder Operationen.
Eine Zahl hat das Format
	[-][Vorkommastellen][.Nachkommastellen][E Exponent]
Jede Zahl, die in einem UPN-Ausdruck steht, wird auf einen internen Stack
geschoben. Dieser Stack fat bis zu 32 Zahlen. (Wer mehr braucht, kann den
Software-Support benutzen, um eine erweiterte Version der Shell zu bekommen.
Die tats„chliche Gr”e des Stacks kann mit "ver -l" ermittelt werden.)
Auerdem gelten die Symbole "pi" und "e" als Zahlen und schieben die Kreis-
zahl Pi bzw. die Eulersche Zahl e auf den Stack.
Als Operation gilt alles, was keine Zahl ist. Die Operationen nehmen 0,
1 oder 2 Zahlen vom Stack, machen etwas damit und legen das Ergebnis auf
den Stack zurck.
Nachdem der ganze UPN-Ausdruck auf diese Weise ausgewertet wurde, wird das
oberste Stack-Element auf StdOut ausgegeben. Das dabei verwendete Format
kann angegeben werden; gemeint ist das Format fr die printf-Funktion.
Das Format kann das Ergebnis als long- oder double-Zahl ausgeben, das Resul-
tat bei Verwendung eines anderen Formats (z.B. %s) ist undefiniert. N„heres
siehe ein beliebiges C-Handbuch.
Zus„tzlich zum Stack gibt es einen Speicher, der bis zu 10 Werte fat, die
beliebig geschrieben und gelesen werden.

Achtung:
(1) Es darf nur die Formatangabe gemacht werden, keinen weiteren Text ange-
ben (z.B. "upn '%Das Ergebnis ist %d' 2 2 +" ist falsch - benutze statt-
dessen "echo Das Ergebis ist `upn %ld 2 2 +`")
(2) Bei Integerformaten mu das long-Format angegeben werden, also nicht
"upn %d ...", sondern "upn %ld ...." (analog fr %x). Ebenso sollte nicht %f,
sondern %lf fr Fliekommaformate verwendet werden.

Stack und Speicher sind global und behalten ihren Inhalt ber mehrere Auf-
rufe des upn-Kommandos hinweg. Man kann also z.B. mit "upn 123" eine Zahl
auf den Stack legen, dann weitere Kommandos ausfhren und die Zahl dann
erst mit einem erneuten upn-Aufruf verarbeiten. Der Stack fat maximal
32 Zahlen. (Wer mehr braucht: Software-Support benutzen... Die tats„chliche
Stackgr”e einer Shellversion kann mit "ver -l" ermittelt werden)

Eine Liste aller verfgbaren UPN-Funktionen findet sich in dieser Datei
zu dem Stichwort "upnfkt".

Eine komfortable Schnittstelle zum upn-Kommando ist das externe Kommando
calc (siehe dort).

Rckgabewert: Der ganzzahlige Anteil des obersten Stack-Elements (x).


Siehe auch:	upnfkt
		calc (externes Kommando)

-----
upnfkt - Funktionen des UPN-Rechners

Zur Bedienung des UPN-Rechners siehe das Stichwort upn. Dieser Abschnitt
erkl„rt alle Operationen, die im UPN-Rechner zur Verfgung stehen.

Im folgenden bedeutet x die oberste und y die zweitoberste Zahl auf dem
Stack. "x := x+y" bedeutet, da zwei Zahlen vom Stack genommen und addiert
und da das Ergebnis wieder auf den Stack gelegt wird.


Speicheroperationen:

sto		speichert y in Speicher x. Es wird nichts auf den Stack
		zurckgelegt.
rcl		liefert den Inhalt von Speicher x.

In beiden F„llen wird, wenn x gr”er als 9 ist, (x mod 10) benutzt.
Zu Beginn werden alle Speicherpl„tze zu 0 initialisiert.


Mathematische Operationen:

+,-,*,/,\	x := y +-*/ x		(Grundrechenarten)	(*)
%		x := y % x		(Modulo)
++		x := x+1		(Inkrement)
--		x := x-1		(Dekrement)
chs		x := -x 		(Vorzeichenwechsel)
rcp		x := 1/x		(Reziprokwert)
log		x := log (y) x		(Log. zur Basis y)
ln		x := ln x		(Log. zur Basis e)
lg		x := lg x		(Log. zur Basis 10)
ld		x := ld x		(Log. zur Basis 2)
deg		x := x * (180/Pi)	(Umrechnung Rad.->Deg.) (**)
grad		x := x * (200/Pi)	(Umrechnung Rad.->Grad) (**)
sin		x := sin x		(Sinus)
asin		x := arc sin x		(Arcus-Sinus)
cos		x := cos x		(Cosinus)
acos		x := arc cos x		(Arcus-Cosinus)
tan		x := tan x		(Tangens)
atan		x := arc tan x		(Arcus-Tangens)
sqrt		x := sqrt x		(Quadratwurzel)
sqr		x := x*x		(Quadrat)
exp		x := e hoch x
exp2		x := 2 hoch x
exp10		x := 10 hoch x
abs		x := |x|		(Betrag)
sign		x := signum x		(Vorzeichen: -1, 0, 1)
min		x := min {x,y}		(Minimum)
max		x := max {x,y}		(Maximum)
fact		x := x! 		(Fakult„t)
int		x := int x		(Vorkommastellen)
frac		x := frac x		(Nachkommastellen)
rand		x aus (0,1)		(Zufallszahl)
rnd		x := x gerundet auf 1. Vorkommastelle

Auerdem gibt es die folgenden Einheiten-Umrechenfunktionen, die jeweils
x umrechnen:

	in2mm	mm2in		(inch <-> Millimeter)
	ft2m	m2ft		(Foot <-> Meter)
	mi2km	km2mi		(Meilen <-> Kilometer)
	m2yd	yd2m		(Meter <-> Yards)
	m2nmi	nmi2m		(Meter <-> nautische Meilen)
	m2rod	rod2m		(Meter <-> Rod, was immer das ist)
	m2pc	pc2m		(Meter <-> Parsec)
	gal2l	l2gal		(Gallonen <-> Liter)
	lb2kg	kg2lb		(engl. Pfund <-> Kilogramm)
	kg2oz	oz2kg		(Kilogramm <-> Unzen)
	kg2ozt	ozt2kg		(Kilogramm <-> Troy-Unzen)
	kg2u	u2kg		(Kilogramm <-> Units (atomare Masseeinheit))
	kg2slug	slug2kg		(Kilogramm <-> Slug)
	f2c	c2f		(Fahrenheit <-> Celsius)
	c2k	k2c		(Celsius <-> Kelvin)
	ms2mph	mph2ms		(Meter/Sekunde <-> Meilen pro Stunde)

Die folgenden Gr”enordnungsumrechenfunktionen rechnen x in die jeweilige
Gr”enordnung um. Um 2500 Gramm in Kilogramm umzurechnen, lautet der Aufruf
also "upn 2500 kilo".

	10 hoch i:	10 hoch -i:	i:
	exa		atto		18
	peta		femto		15
	tera		pico		12
	giga		nano		9
	mega		micro		6
	kilo		milli		3
	hecta		centi		2
	deca		deci		1

Die folgenden Gr”enordnungen arbeiten auf Basis 2, z.B. um Bytes in Kilo-
bytes umzurechnen.

	2 hoch i:	2 hoch -i:	i:
	bgiga		bnano		1000
	bmega		bmicro		100
	bkilo		bmilli		10

In den Umrechenfunktionen steht die 2 brigens fr das englische Wort "to",
das genauso ausgesprochen wird wie "two"; "in2mm" liest man also
"inch to millimeter".
Quellen fr die Umrechnungsfaktoren: die Taschenrechner Hewlett-Packard 28C
und Commodore SR9190R.


Sonderfunktionen:

help	Es wird eine Liste aller verfgbarer Operationen ausgegeben. Hinter
	den Operationen erscheint in Klammern die Anzahl der Zahlen, die
	fr die Operation vom Stack genommen werden.

list	Gibt den aktuellen Inhalt des Stacks auf dem Bildschirm aus.

look	Tut nichts. Dient dazu, das oberste Stackelement noch einmal aus-
	zugeben.

swap	Vertauscht die obersten beiden Stackelemente (x und y).

dup	dupliziert das oberste Stackelement.

pop	L”scht das oberste Element vom Stack.

clr	L”scht den gesamten Stack. Der Speicher ist davon nicht betroffen.


ANMERKUNGEN:

(*)	 Zur Division kann sowohl der Slash (/) als auch der Backslash (\)
benutzt werden. Dadurch ist es m”glich, den UPN-Rechner zu benutzen, auch
wenn das Shell-Flag -b gesetzt ist, das alle Slashes in der Eingabe in
Backslashes umformt.

(**)	Die trigonometrischen Funktionen wie sin, cos etc. arbeiten alle
im Gradma (Kreis = 2 Pi Grad). Mit den Operationen deg und grad k”nnen
Winkelangaben in Altgrad (Kreis = 360 Grad) und Neugrad (Kreis = 400 Grad)
umgerechnet werden.


Beispiele:
1) Ausrechnen von 3+4:
	upn 3 4 +
2) Berechnen der Oberfl„che eines Kreises mit Radius 10:
	upn 10 sqr pi *
3) Berechnen der Oberfl„che eines Kreises mit Radius 123 mm in Zoll (inch):
	upn 123 sqr pi * mm2in
4) Umrechnen von 36 Grad Celsius (Temperatur in Aachen am 12.8.1990) in
   Fahrenheit:
	upn 36 c2f
5) Und die Temperatur in Aachen am 7.2.1991:
	upn 12.2 f2c
6) Ab welcher Temperatur in Kelvin f„ngt Papier an zu brennen?
	upn 451 f2c c2k
7) Wieviele Kilometer haben 25 nautische Meilen?
	upn 25 nmi2m kilo
8) Wieviele Gramm hat eine Unze?
	upn 1 oz2kg milli
9) Wieviele Bytes hat ein Kilobyte?
	upn 1 bkilo
10) Und wieviele Bits hat ein Mega-ST 4?
	upn 4 bmega 8 *
11) Benutzung des Formatstrings: Ausgabe der Fakult„t von 12 in Hex:
	upn %lx 12 fact
12) Shellvariablen k”nnen auch beutzt werden:
	echo Geben Sie zwei Zahlen ein:
	read x
	read y
	echo Die gr”ere der Zahlen ist ^c
	upn %ld $x $y max
13) Auflisten aller Operationen:
	upn help
14) Z„hlen der Operationen des UPN-Rechners:
	upn %ld `upn help | wc -w` 2 /
   (zur Erkl„rung: "upn help" gibt fr jede Operation zwei Worte aus, n„mlich
   den Namen der Operation und die Anzahl der Parameter. "upn help | wc -w"
   z„hlt die Worte. Mit dem Ergebnis wird upn nochmals aufgerufen, um es durch
   2 zu teilen und damit die Anzahl der Operationen zu ermitteln.)
15) Wieviel Speicherplatz in Kilobytes belegt eine Shell?
	upn %ld `mem` `sh mem` - bkilo
16) Ausgabe des Ergebnisses der letzten Berechnung:
	upn look
17) Benutzung des Speichers: Berechnen von sin 30, ablegen in Speicher 0,
    berechnen von cos 75, ablegen in Speicher 1, berechnen der Wurzel von
    3, ablegen in Speicher 2 und 3. Danach den Inhalt von Speicher 1 mit dem
    von Speicher 3 multiplizieren, davon den Logarithmus zur Basis Speicher 0
    berechnen und durch Speicher 2 teilen.
    	upn 30 sin 0 sto 75 cos 1 sto 3 sqrt 2 sto 2 rcl 2 sto
	upn 0 rcl 1 rcl 3 rcl * log 2 rcl /

-----
vars - Ausgabe der Shellvariablen

Syntax: vars [-aexs]

Gibt eine Liste der vom Anwender angelegten Shellvariablen nach StdOut.
Die Ausgabe besteht aus dem Variablennamen, dem aktuellen Wert und dem
Variablenstatus. Folgende Status-Angaben sind moeglich:

USR		Die Variable wurde vom Anwender oder von einem Shell-Script
		angelegt oder veraendert.
SYS		Die Variable wird vom System fuer das System angelegt.
R/O		Der Wert der Variablen kann nicht veraendert werden und
		die Variable kann nicht geloescht werden (siehe readonly).
EXP		Die Variable ist exportiert worden (siehe export).

Flags:	-a	Es werden alle Shellvariablen (auch die Systemvariablen)
		ausgegeben.
	-e	Es werden nur Variablen ausgegeben, die sich im Environment
		befinden (Status EXP).
	-x	Die Variablen werden im Deklarationsformat, als in der
		Form "NAME=WERT" ausgegeben. Der Variablenstatus wird
		nicht ausgegeben. Dieses Format kann in ein Shellscript
		bernommen werden.
	-s	Es wird eine Statistik ueber den freien und belegten Platz
		in der Variablentabelle ausgegeben.

Beispiele:

Anlegen einer Variablen:
	VAR=Hallo

"vars" erzeugt eine Ausgabe der Art:

VAR	=Hallo			USR

"vars -x" erzeugt eine Ausgabe der Art:

VAR=Hallo

Siehe auch:	env
		export
		readonly

-----
ver - Anzeige diverser Versionsnummern

Syntax: ver [-oclgtdmMa]

Wenn kein Flag angegeben ist, wird -oc angenommen.

Die Flags haben folgende Bedeutung:

	-o  Ausgabe der Versionsnummer der Shell.
	-c  Ausgabe von Datum und Uhrzeit des Kompilierens der Shell. Damit
	    lassen sich verschiedene Upgrades innerhalb einer Versionsnummer
	    unterscheiden.
	-l  Es wird eine genauere Analyse der M”glichkeiten der vorliegenden
	    Shell-Version ausgegeben, die Angaben ber die Maximalanzahl der
	    Funktionen und Variablen, die Gr”e des UPN-Stacks usw. enth„lt.
	-g  Ausgabe der Gemdos-Versionsnummer. Sie wird mit der Gemdos-Funktion
	    Sversion festgestellt und im Format Hauptnummer.Unternummer ausge-
	    geben.
	-t  Ausgabe der TOS-Version. Stammt aus dem TOS-Systemheader.
	-d  Ausgabe des TOS-Datums. Stammt ebenfalls aus dem TOS-Systemheader
	    und wird wie dort im Format Monat/Tag/Jahr ausgegeben.
	-m  Ausgabe der Versionsnummer des installierten MiNT. Wenn kein MiNT
	    installiert ist, erscheint "none".
	-M  Wie -m, aber es wenn MiNT nicht installiert ist, wird keine Ausgabe
	    erzeugt.
	-a  Es erfolgen alle diese Ausgaben (auer -M und -l).

Beispiel: "ver -a" ergibt auf einem 1040ST mit TOS 1.4 und ohne MiNT
folgende Ausgabe:

	Okami Shell 1.2+ 				[-o]
	compiled Dec. 22, 1990 21:09			[-c]
	GEMDOS Version 0.21				[-g]
	TOS Version 1.4					[-t]
	TOS Date 04/06/1989				[-d]
	MiNT Version: none				[-m]

In eckigen Klammern jeweils das Flag, das die betreffende Zeile erzeugt (er-
scheint nicht in der Ausgabe).
Bei den Flags -o und -c erscheinen natrlich andere Werte, je nach der ver-
wendeten Version der Shell.

"ver -l" gibt bei der Standardversion folgende Ausgabe:

	Max. # of variables      	200
	Max. # of functions      	200
	Max. # of nested while's 	16
	Max. # of lines for sort 	500
	Max. filespec length     	80
	Max. length of input line	400
	Length of history buffer 	100
	Size of hash table		101
	Length of RPN stack      	32
	Size of RPN store		10
	Version supports MiNT

"Max. # of nested while's" ist die Maximalanzahl der while-Schleifen, die
ineinander geschachtelt werden k”nnen.
"Max. # of lines for sort" ist die Maximalanzahl der Zeilen, die mit dem
internen Kommando sort sortiert werden k”nnen.
"Max. filespec length" ist die maximale L„nge eines Dateinamens incl. Pfad.
"Max. length of input line" ist die maximale L„nge einer Eingabezeile nach
der Expansion von Variablen, Command Substitution usw.
"Length of history buffer" ist die Anzahl der Eingabezeilen, die in dem
Ringpuffer der Tastatur-History gespeichert werden k”nnen.
"Size of hash table" ist die Gr”e der internen Hash-Tabelle. Dies sollte
immer eine Primzahl sein.

-----
virus - Aufspren und Entfernen von Bootsektorviren

Syntax: virus [-xvsi] {drive}

Es wird der Bootsektor von jedem angegebenen Laufwerk eingelesen und auf
Ausfhrbarkeit getestet. Ein Bootsektor ist ausfhrbar, wenn seine Prf-
summe 0x1234 betr„gt; nur in diesem Fall kann ein Virus sich beim Booten
dieser Diskette oder Partition im Speicher einnisten. Auf Wunsch wird ein
ausfhrbarer Bootsektor nicht-ausfhrbar gemacht.
Wenn kein Laufwerk angegeben ist, wird nur Laufwerk A: untersucht.

Flags:
	-x	Ein ausfhrbarer Bootsektor wird nicht-ausfhrbar gemacht,
		indem das letzte Byte des Bootsektors inkrementiert wird.
	-v	Es erscheinen Meldungen ber Prfsumme und Ausfhrbarkeit
		zu jedem untersuchten Laufwerk. Wenn dieses Flag nicht an-
		gegeben ist, werden nur Meldungen ber ausfhrbare Boot-
		sektoren ausgegeben.
	-s	Der Bootsektor wird nicht untersucht, sondern nach StdOut
		geschrieben.
	-i	Der Bootsektor wird nicht von dem angegebenen Laufwerk,
		sondern von StdIn eingelesen. Wenn der eingelesene Boot-
		sektor ausfhrbar ist und -x gesetzt ist, wird der Boot-
		sektor auf das angegebene Laufwerk geschrieben.

Beispiele:
	virus
		untersucht Laufwerk A: und gibt eine Warnung aus, wenn der
		Bootsektor ausfhrbar ist, „ndert ihn aber nicht. Dieses
		Kommando kann in Shellscripts stehen, da es sich im
		Normalfall (Bootsektor ist nicht ausfhrbar) "unsichtbar"
		verh„lt.
	virus B: C:
		dasselbe fr Laufwerk B: und Partition C:.
	virus bc
		genauso wie das vorige Beispiel.
	virus -s a: >boot.dat
		der Bootsektor von Laufwerk A: wird in die Datei boot.dat
		geschrieben.
	virus -i -x a: <boot.dat
		der zuvor gesicherte Bootsektor wird auf Ausfhrbarkeit 
		untersucht und ggfs. nicht-ausfhrbar gemacht.
	virus -s c: | hd
		es wird ein Hexdump des Bootsektors von Partition C: er-
		zeugt.

Rckgabewert:
	-1	Aufruffehler
	0	Der Bootsektor ist nicht ausfhrbar (gemacht worden).
	1	Der Bootsektor ist (immer noch!) ausfhrbar.
Hierbei bezieht sich dieser Wert auf das zuletzt untersuchte Laufwerk.

Die Idee zu diesem Kommando stammt aus dem Data-Becker-Buch "Atari ST intern
Band 2" von Martin Pauly, allerdings habe ich die Flags -s und -i hinzu-
gefgt und die Einleseroutinen ge„ndert, damit auch Festplattenpartitionen
untersucht werden k”nnen.

-----
wc - Word Count

Syntax: wc [-lwcn] {File}

Es werden die Anzahl der Zeilen, Worte und Zeichen der angegebenen Datei
oder von StdIn ausgegeben. Ein Wort wird durch Leerzeichen, Tabs oder
Newline-Zeichen begrenzt.

Flags:	-l	Ausgabe der Anzahl der Zeilen
	-w	Ausgabe der Anzahl der Worte
	-c	Ausgabe der Anzahl der Zeichen
	-n	Ausgabe des jeweiligen Dateinamens
Wenn keine Flags angegeben sind, gelten alle Flags als aktiviert.

Beispiel:
1) Ausgabe der Anzahlen der Zeilen und Zeichen aller C-Quell- und Header-
   dateien im aktuellen Directory:
	wc -lcn *.c *.h
        
2) Ausgabe der Anzahl der internen Kommandos:
	cmds | wc -l

Rckgabewert:
	-1	Aufruffehler
	sonst	die Anzahl der gez„hlten Dateien.

-----
what - Identifizieren von Dateien

Syntax: what [-s] {Datei}

Dieses Kommando ist in der Unix-Welt sehr beliebt und geh”rt dort zu dem
Sourcecode-Control-System (SCCS). Der Sinn ist, eine jede Datei, egal ob
Ascii oder bin„r, anhand eines speziellen Codes identifizieren zu k”nnen.
Dieser Code steht irgendwo in der Datei, gefolgt von einer Zeichenkette, die
die Datei, den Autor und die Version kennzeichnet. Der Code ist @(#) (At
Klammer auf Doppelkreuz Klammer zu).
Das Kommando what sucht in jeder angegebenen Datei (oder in StdIn, wenn keine
Datei angegeben ist) nach der Zeichenkette @(#) und gibt alles aus, was
dahinter bis zum n„chsten doppelten Anfhrungszeichen ("), Gr”erzeichen (>),
Zeilenende (\n) oder Nullbyte (\0) kommt.
Die bliche Art, diesen Identifikationsstring in einem Programm unterzubringen,
ist folgende Zeile kurz nach Dateibeginn:

	static char _M_ID_[]="@(#) Okami Shell 1.2 - cmds5.c";

Die Zeichenkette "@(#) Okami Shell 1.2 - cmds5.c" steht dann sowohl in der
C-Quelldatei als auch in dem O-File und dem ausfhrbaren Programm. Wenn alle
Module eines Programms auf diese Weise gekennzeichnet sind, kann man mit
what eine Liste aller Module, auch Librarymodule, bekommen, aus denen ein
Programm zusammengesetzt ist.
Wer die Quellen der Okami-Shell hat, kann mit what die Namen der in den einzel-
nen Modulen enthaltenen Funktionen ermitteln (z.B. "what cmds*.c").

Flag:	-s	Wenn dieses Flag angegeben ist, wird nur das erste @(#) in
		der Datei gesucht.

Beispiel:
	what *.sh	erzeugt eine Liste der Versionen aller Shellscripts
	what -s doc/*	eine Art Inhaltsverzeichnis der Anleitungsdateien
	what sh.ttp	ermittelt die Namen aller Quelldateien der Shell.
			Ggfs. mu sh.ttp vorher ent-pfxgepackt werden.

-----
while , do, continue, break, done - Ausfhren von Kommandos in einer Schleife

Syntax: while Kommando1
	do
	{Kommandos2|continue|break}
	done

Das while-Konstrukt darf nur in Shell-Scripts stehen. Die Ergebnisse bei
der Eingabe von der Tastatur oder einer Schnittstelle sind undefiniert
(was v”llig natrlich ist).

Die Zeilen zwischen "do" und "done" werden ausgefhrt, bis Kommando1
den Rckgabewert 0 liefert. In diesem Fall wird mit der Ausfhrung in der
"done" folgenden Zeile fortgefahren.
Das Kommando "break" beendet die while-Schleife augenblicklich. Es darf in
einem if-fi-Konstrukt stehen (was es normalerweise auch tut).
Das Kommando "continue" springt zurck zum zugeh”rigen "while"-Kommando.
Der aktuelle Schleifendurchlauf wird also beendet, und es beginnt ein
neuer Schleifendurchlauf. Ebenso wie "break" darf auch "continue" in einem
if-fi-Konstrukt stehen.
Die Wirkung von "break" und "continue" ist demnach identisch mit der von
"break" und "continue" in der Programmiersprache C.

Typische Kandidaten fr "Kommando1" sind true, false und test (bzw. "[").

Beispiele:

1) Wiederholen von Anweisungen:

	while [ $X != abc ]
	do
	  echo Bitte abc eingeben.
	  read X
	done


2) Dateien mit der Fileselect-Box einlesen, bis der Anwender "Abbruch"
   anklickt:

	while true
	do
	  fsel *.* . BUTTON
	  if [ $BUTTON = 0 ]
	  then
	    break
	  fi
	done

   "while true" ist also eine Endlosschleife, die nur durch break verlassen
   werden kann.


3) Wie 2), aber es werden nur Dateien akzeptiert, die noch nicht existieren.
   Wenn eine bereits existierende Datei angew„hlt wurde (was mit [ -f $FILE ]
   herausgefunden wird), wird die while-Schleife mit "continue" von vorne
   begonnen.

	while true
	do
	  # den Dateinamen in die Variable FILE einlesen
	  FILE=`fsel *.* datei.txt BUTTON`
	  if [ $BUTTON = 0 ]
	  then
	    break
	  fi
	  if [ -f $FILE ]
	  then
	    continue
	  fi
	  ...................... (mache was mit $FILE)
	done


4) Eine Variable eingeben lassen, solange bis sie wirklich einen Wert
   enth„lt.

	while [ -v VARIABLE ]
	do
	  echo Bitte geben Sie die Variable ein.
	  read VARIABLE
	done


Siehe auch: test
	    true
	    false
	    if

-----
xargs - Eingabe als Parameter fr andere Kommandos

Syntax: xargs [Kommando {Parameter}]

Liest Zeilen von StdIn und fhrt das angegebene Kommando mit den angegebenen
Parametern und den eingelesenen Zeilen aus. Wenn kein Kommando angegeben
ist, wird als Default "echo" benutzt.
Wenn Kommando oder Parameter die Zeichenkette "{}" (”ffnende und schlieende
geschwungene Klammer) enthalten, wird die von StdIn eingelesene Zeile
anstelle dieser Zeichenkette eingesetzt. Ansonsten wird die eingelesene
Zeile nach einem Leerzeichen an den Parameterstring angeh„ngt.

Beispiele:
	ls *.sh | xargs .
		fhrt alle Shellscripts im aktuellen Verzeichnis aus.
	ls *.c | xargs echo Die Datei {} ist da
		Erzeugt als Ausgabe z.B.:
			Die Datei sh.c ist da
			Die Datei cmds.c ist da
			Die Datei cmds2.c ist da
		usw.
	find e:\ *.dup | xargs rm -f
		L”scht alle *.dup-Dateien auf Laufwerk E: ohne Bercksichti-
		gung von Readonly-Dateien (rm -f).
	cmds | xargs echo {}"^t"^c
		Gibt die Namen aller interner Kommandos in mehreren Spalten
		auf dem Bildschirm aus. (Das geht einfacher mit "cmds -C")

==============================================================================

2) Externe Kommandos:

Wenn beim Shell-Prompt ein Kommando eingegeben wird, das keinem internen
Kommando entspricht, wird eine Datei mit dem entsprechenden Namen unter
allen in der Shell-Variablen PATH enthaltenen Pfaden gesucht. Wenn dort
eine Datei mit dem angegebenen Namen und einem der in $XEXT angegebenen
Extendern existiert, wird sie als Bin„rdatei aufgerufen. Wenn dort eine
Datei mit dem angegebenen Namen und einem der in $SEXT angegebenen Exten-
dern existiert, wird sie als Shellscript ausgefhrt.

Beispiel: Es sei
	PATH=.,d:\bin
	XEXT=.prg,.tos
	SEXT=.sh

Nach Eingabe des Kommandos "test" werden die folgenden Dateien gesucht, die
erste gefundene Datei wird ausgefhrt:

	test.prg
	test.tos
	test.sh
	d:\bin\test.prg
	d:\bin\test.tos
	d:\bin\test.sh

Die Dateien, die auf .prg oder .tos enden, werden als Bin„rdateien aufge-
rufen.
Die Dateien, die auf .sh enden, werden als Shellscripts ausgefhrt.
Wenn mehrere der angefhrten Dateien existieren, wird die nur erste
gefundene Datei ausgefhrt.
Durch Eingabe von "type test" kann festgestellt werden, welche Datei
durch das Kommando test ausgefhrt wrde oder ob es sich um ein internes
Kommando handelt.

In der Shell-Variablen GEXT werden analog zu XEXT und SEXT Extender gespei-
chert, die angeben, welche Dateinen als GEM-Programme gestartet werden.
GEM-Programme werden ber die Shellfunktion gemexec gestartet. Diese Funktion
kann vom Anwender frei ver„ndert werden und darber entscheiden, welche Aktio-
nen sie vor und nach dem Start des Programms ausfhrt oder ob sie es berhaupt
startet. Siehe hierzu auch den Abschnitt zu gemexec unter den internen Komman-
dos.

GEXT hat Wirkung auf alle Bin„rprogramme, also auf solche, die ber die
Eingabe ihres Namens und mit XEXT gestartet werden, als auch auf solche,
die mit dem exec-Kommando aufgerufen werden. GEXT ist ohne Wirkung fr
Shell-Scripts, auch wenn einer der Extender in GEXT mit einem der Extender
in SEXT bereinstimmt.

Folgende Werte sind nach Start der Shell voreingestellt:
	PATH=.,..,$HOME,$HOME\bin
	XEXT=.prg,.tos,.ttp,.app
	SEXT=.sh
	GEXT=.prg
Die Variablen k”nnen in der Datei profile ver„ndert oder erweitert werden.

Auerdem ist es m”glich, den vollen Pfadnamen zum Aufruf anzugeben. Dabei
mu jedoch auch der Extender mit angegeben werden. Das Kommando wird nur
ausgefhrt, wenn der Extender einem der in $XEXT oder $SEXT angefhrten
entspricht. (Dies entspricht dem Datei-Attribut "Executable" unter Unix.
In der Okami-Shell wird dieses Attribut durch die Shell-Variablen XEXT und
SEXT simuliert.)


Der Quellcode s„mtlicher externer Kommandos geh”rt zum Lieferumfang.

Folgende externe Kommandos werden mitgeliefert:


-----
calc - Schnittstelle zum UPN-Rechner

Datei:	calc.sh
Syntax: calc

Dieses Shellscript dient dazu, das interne Kommando upn benutzerfreundlich
aufzurufen. Es erscheint das Prompt:
	upn >
Nun k”nnen beliebige upn-Ausdrcke eingegeben werden (siehe das interne
Kommando upn). Jeder Ausdruck wird mit ENTER abgeschlossen. Es k”nnen auch
unvollst„ndige Ausdrcke angegeben werden, z.B. sind „quivalent:

	upn > 2 3 * 4 +

und
	upn > 2 3
	upn > *
	upn > 4 +

In der Eingabe kann die Zeichenkette "$_" (Dollar Underscore) benutzt wer-
den, um das Ergebnis der letzten Eingabezeile zu repr„sentieren. Beispiel:

	upn > 17 4 +
	upn > pi 2 * sin $_ /

berechnet erst 17+4, das Ergebnis wird in der zweiten Zeile benutzt. Achtung:
in $_ wird immer nur der ganzzahlige Anteil gespeichert.

Durch Eingabe von clr wird der Stack gel”scht, durch Eingabe von list wird
der Inhalt des Stacks ausgegeben.

Das Programm wird beendet durch Eingabe von exit. Die Shellvariable "_"
(Underscore) enth„lt dann den ganzzahligen Anteil des letzten Ergebnisses.

Siehe auch:	upn

-----
format - Formatierten von Disketten

Datei:	format.ttp
Source: format.c
Syntax: format -V|[-s(SPT)] [-t(TPD)] [-1] [-i(Interleave)] [-v(Virgin)]
		[-n(VersNr)] [-N] [-B] [-x] [-q] [-l(Diskname)][Drive]

Vor dem Formatieren erfolgt eine Sicherheitsabfrage. Nach Eingabe von y
wird formatiert, nach einer anderen Eingabe oder Druck auf ENTER wird das
Programm abgebrochen.
Ebenso erfolgt eine Sicherheitsabfrage bei eigenartigen Werten (z.B.
anderen Laufwerksnummern als A: und B: etc.)

Die Voreinstellungen der einzelnen Flags sind:
	format -s9 -t80 -i1 -v0xe5e5 -n0x1000001 A:


Flags:
	-V	Die Versionsnummer und das Kompilierungsdatum des Formatier-
		programms werden ausgegeben. Es wird nicht formatiert. Alle
		anderen Parameter sind ohne Wirkung.
	-s	Anzahl der Sektoren pro Track. Default: 9.
	-t	Anzahl der Tracks pro Seite. Default: 80.
	-1	Wenn angegeben, wird die Diskette einseitig formatiert.
		Wenn nicht angegeben, wird die Diskette zweiseitig
		formatiert. Default: zweiseitig.
	-i	Die Anzahl der physikalischen Sektoren zwischen zwei
		logischen Sektoren. Default: 1.
	-v	Der Wert, der in die formatierten Sektoren geschrieben
		wird. Normalerweise 0xe5e5. Unabh„ngig von dieser Ein-
		stellung werden die Spuren 0 und 1 immer mit Nullen ge-
		fllt.
	-n	Die Versionsnummer, die in den Bootsektor geschrieben
		wird. Werte gr”er als 0x1000000 ergeben eine zuf„llige
		Versionsnummer.
	-N	Es wird kein Bootsektor angelegt.
	-B	Es wird nicht formatiert (nur Bootsektor).
	-x	Der Bootsektor wird ausfhrbar gemacht.
	-q	Es erfolgen keine Sicherheitsabfragen.
	-l	Es wird der angegebene Diskettenname (Volume-Label) erzeugt.
	Drive	Das zu formatierende Laufwerk. Es gilt nur der erste 
		Buchstabe, d.h. es sind „quivalent:
			format A:
			format a:
			format a
			format abcdefg
			format
		Default ist Laufwerk A:.


Beispiele:
1) format
	Formatiert die Diskette in Laufwerk A: mit 2 Seiten, 80 Tracks pro
	Seite, 9 Sektoren pro Track mit Interleave 1 und Virgin 0xe5e5. Es
	wird ein nicht-ausfhrbarer Bootsektor angelegt. Es wird kein Dis-
	kettenname erzeugt
	=> der Standardaufruf zum Formatieren von Disketten.
2) format B: -ldisk1
	Formatiert die Diskette in Laufwerk B: mit den unter 1) beschrie-
	benen Standardwerten. Auerdem wird der Diskettenname "disk1" er-
	zeugt.
3) format -s10 B:
	Formatiert die Diskette in Laufwerk B: mit 10 Sektoren pro Track.
4) format -s10 -q B:
	Wie 3), aber ohne Sicherheitsabfrage.
5) format -s10 -v0 -N
	Formatiert die Diskette in Laufwerk A: mit 10 Sektoren pro Track.
	Die Sektoren werden mit Nullen gefllt. Es wird kein Bootsektor
	angelegt. Es erfolgt eine Sicherheitsabfrage wegen eines unge-
	w”hnlichen Virgin-Wertes (-v0).
6) format -s10 -v0 -N -q
	Wie 5), aber ohne Sicherheitsabfrage.


Vorsicht:
	Die Parameter -i (Interleave) und -v (Virgin) sollten nur in
	Sonderf„llen ge„ndert werden. Der Interleave-Faktor mu mit der
	Anzahl der Sektoren pro Track teilerfremd sein (wird vom Pro-
	gramm nicht berprft!!!!)


Laufzeit:
	format		(Standardwerte zweiseitig)
		dauert ca. 1 Minute 38 Sekunden
	format -1	(Standardwerte einseitig)
		dauert ca. 50 Sekunden
	format -B	(Anlegen eines Bootsektors ohne Formatierung)
		dauert ca. 2 Sekunden
	(Alle Zeiten incl. Ladezeit des format-Programms von Festplatte,
	beim Aufruf mit -q [ohne Sicherheitsabfrage]. Gemessen mit dem
	time-Kommando.)

-----
gem - Benutzung der Accessories

Dateien: gem.prg, gem.rsc
Source:  gem.c
Syntax: gem

Es wird ein GEM-Desktop mit Menzeile angezeigt. Von dieser Menzeile aus
k”nnen die installierten Accessories benutzt werden. Auerdem enth„lt
die Menzeile weitere Mens, deren Eintr„ge Shellkommandos sind. Durch
Anw„hlen werden diese Kommandos von der aufrufenden Shell (durch die
system()-Funktion ber den _shell_p-Zeiger) ausgefhrt.
Der Menbaum befindet sich in der Datei gem.rsc. Mit einem Resource
Construction Program k”nnen die Mens ver„ndert werden. Es k”nnen
beliebig viele weitere Mens und Menpunkte hinzugefgt oder alte ge-
l”scht werden. Allerdings darf sich in der RSC-Datei nur ein Objektbaum
befinden.
gem wird durch anklicken eines Meneintrages namens `exit' beendet. Dieser
Eintrag befindet sich normalerweise im Desk-Men, darf sich aber auch in
einem der anderen Mens befinden. Achtung: wenn es keinen Meneintrag
namens `exit' gibt, kann gem nicht beendet werden. Aus diesem Grund sollte
das Desk-Men unver„ndert bleiben.

-----
showpic - Anzeigen von Screenformat-Bildern

Datei: showpic.sh
Syntax: showpic

Dieses Shellscript ist ein Beispiel zur Programmierung der Shell. Es l„t
den Anwender eine Datei in einer Fileselect-Box ausw„hlen und bestimmt
anhand des Dateinamen-Extenders, ob es sich um eine Doodle-Datei (.PIC,
Dateil„nge 32000 Bytes) oder eine Degas-Datei (.PI3, 32066 Bytes) handelt,
und bestimmt entsprechend die L„nge des Dateiheaders (Doodle 0, Degas 34
Bytes). Wenn der Extender weder .PIC noch .PI3 ist, mu der Anwender die
L„nge des Headers eingeben.
Danach wird das Bild geladen und angezeigt. Nach einem Druck auf ENTER wird
der Bildschirm gel”scht, und das ganze beginnt von vorne, bis der Anwender
"Abbruch" anw„hlt.

Das Script demonstriert die vielf„ltigen M”glichkeiten der Shell-Pro-
grammierung mit Variablen, Pipes, Eingaben, Shellflags und dem if- und
while-Kommando.

----------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An diese Stelle k”nnen weitere Erkl„rungen hinzugefgt werden, die bei Druck
auf Help nach einem Kommando erscheinen sollen,  z.B. Erkl„rungen zu eigenen
externen Kommandos oder Abschnitte aus okami.doc. Bitte das Format beachten:
- Zeile aus fnf Minuszeichen
- Zeile, die mit dem Stichwort beginnt
- Erkl„rung geht bis zur n„chsten Zeile aus fnf Minuszeichen (exkl.)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
