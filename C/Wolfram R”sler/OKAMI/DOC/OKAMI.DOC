
	===============================================

@(#)	  OKAMI SHELL VERSION 1.3 - BENUTZERANLEITUNG

	===============================================
			Stand: 29.6.91


		BITTE ERST DIE DATEI README LESEN!

----------------------------------------------------------------------------
EINFšHRUNG

Die Okami-Shell ist ein (weiterer) Versuch, auf dem Atari ST so etwas wie
Unix-Gefhle aufkommen zu lassen. Das Programm wendet sich an alle, die
die M”glichkeiten eines Kommandointerpreters denen des Desktops vorziehen.
Die Shell ist vor allem beim Betrieb mit einer Festplatte ausgesprochen 
ntzlich.

Obwohl es schon einige Programme dieser Art gibt, gibt es gewichtige Grnde,
die Okami-Shell zu benutzen und sich durch die folgende Anleitung zu
arbeiten.

Die Okami-Shell ist einer der Unix-orientierten Kommandointerpreter fr den
ST, der die Unix-M”glichkeiten der Ein/Ausgabe-Umleitung und des Pipelinings
auch fr die internen (in der Shell eingebauten) Kommandos erm”glicht.
Die Ein/Ausgabe-Umleitung ist die M”glichkeit, die Standard-Ausgabe eines
Programmes, d.h. alles, was mit printf etc. ausgegeben wird und normaler-
weise auf dem Bildschirm landet, sowie die Standard-Eingabe in eine Datei
oder zu einem Ger„t (z.B. zum Drucker) umzuleiten. Die Umleitung funktio-
niert unter TOS mit dem GEM-Desktop a) nur bei TTP-Programmen, weil man
nur bei diesen die M”glichkeit hat, eine Kommandozeile einzugeben, und
b) nur bei Programmen, deren Compiler die Umleitung untersttzen. Die Okami-
Shell fhrt die Umleitung selber durch, wodurch auch Programme, die ihre
Kommandozeile nicht beachten (z.B. solche, die mit dem Pd-Modula-2-System
erstellt wurden), umgeleitet werden k”nnen.

Die Okami-Shell kann allerdings noch etwas mehr: sie ist ein universelles
Utility, mit dem man nicht nur Programme starten, sondern auch Programme
schreiben und debuggen usw. kann. Als Bonbon hat sie einen eingebauten UPN-
Rechner mit ca. 80 Funktionen sowie einen Terminal-Emulator. Alles in allem
bietet die Okami-Shell mehr interne Kommandos und Funktionen als jede andere
fr den Atari erh„ltliche Shell.

Bei der Programmierung einer Shell oder eines Kommandointerpreters steht
man immer vor der Frage, ob man fr die in der Shell eingebauten Kommandos
Unix-, MS-DOS- oder eine selbstausgedachte Schreibweise benutzen soll, 
d.h. ob man die Kommandos ls oder dir, mv oder rename, cp oder copy nennen
soll oder ob man sich eingene Kommandonamen ausdenkt. Die Okami-Shell ist
an den Unix-Bezeichnungen orientiert, genauer gesagt an dem Unix-Derivat
AIX, das z.B. auf dem IBM RT PC 6150 l„uft. Natrlich mssen bei soetwas
Abstriche gemacht werden, der Atari ist schlielich keine Unix-Maschine,
und eine Shell ist kein Betriebssystem.

Wer sich in Unix einigermaen auskennt, kann mit der Okami-Shell sofort los-
legen. Die folgende Anleitung stellt die Verwendung der Shell dar, die Er-
kl„rung der internen Kommandos mit Syntax befindet sich in der Datei
commands.doc.

Um die vielen Versionen der Shell unterscheiden zu k”nnen, gibt das Kommando
`ver' eine Information mit Versionsnummer und Kompilierungszeitpunkt aus.
Zur Interpretation der Versionsnummer siehe tricks.doc.


----------------------------------------------------------------------------
SUPPORT

Die Okami-Shell ist public domain, d.h. sie kann von jedermann benutzt und
weitergegeben werden, ohne da jemand etwas dafr zu bezahlen hat. Wer ber
Email zu erreichen ist, sollte mir ber das Maus- oder Fidonetz eine kleine
Nachricht, evtl. mit Kommentaren, Anregungen und Kritik, zukommen lassen.
Adresse siehe autor.doc.

šber den Support ist es jederzeit und fr jeden m”glich:
1) die neueste Version der Shell zu bekommen,
2) konfektionierte  Versionen zu erhalten, in denen die Systembeschr„nkungen
(Anzahl der Variablen, Funktionen etc.) ver„ndert sind. Wer also eine
Version braucht, die bis zu 2000 Variablen verwalten kann, kann eine solche
bekommen. Auerdem k”nnen beliebige Kommandos ausgeblendet werden, um die
Shell kleiner zu machen. Wer also z.B. den UPN-Rechner und das basep-
Kommando nicht braucht, kann eine Shell erhalten, in der diese Kommandos
nicht enthalten sind und die somit entsprechend krzer ist.

Es ist verboten, das Programm zu verkaufen oder es unter einem anderen
Namen als meinem zu vertreiben. Wer irgendwelche Teile des Programms oder
der Quellen in eigenen Programmen benutzen will, darf dies tun, solange
mein Name im Programm und in der Dokumentation erw„hnt wird.
Die Datei `copying' enth„lt genaue Hinweise zum Kopieren und Weitergeben der
Shell.

Das Programm wird voll untersttzt, d.h. es wird dynamisch weiterentwickelt,
und jeder Anwender kann bei mir jederzeit die neueste Version bestellen.
Ebenso stehe ich bei Problemen und Wnschen zur Verfgung. Spenden sind
natrlich auch willkommen, aber ausdrcklich nicht Vorraussetzung fr
den Erwerb von neuen Versionen, Anleitungen oder sonstigen Hilfen (dies
ist allen Pd-Programmierern zur Nachahmung empfohlen).

Der Quellcode kann ebenfalls bei mir bestellt werden (ca. 18000 Zeilen C).
Als kleine Spende h„tte ich hierfr allerdings gerne einen Taschenrechner -
m”glichst sch”n, am besten alt, notfalls ohne Batterien, aber bitte
funktionsf„hig. Dafr gibt es den vollst„ndigen Quellcode mit allen verwen-
deten Includefiles. (Was auch allen Programmierern zur Nachahmung empfohlen
ist. Schlielich sind Quellcodes keine Staatsgeheimnisse, und vielleicht
kann noch jemand etwas aus ihnen lernen.) (Nebenbei: um die Quellen der
Okami-Shell zu kapieren, sollte man schon ziemlich gut C k”nnen und sich
unter folgendem etwas vorstellen k”nnen:
1) Zeiger, 2) Arrays, 3) Zeiger auf Funktionen, 4) Arrays von Zeigern auf
Funktionen, 5) Zeiger auf solche etc.)


Meine Adresse:

	Wolfram R”sler
	Augustastr. 44-46
	D-5100 Aachen
	Tel. +49 (0)241 534596 oder +49 (0)241 504290
	Mausnetz: Wolfram Roesler @ AC2
	Fidonetz: Wolfram Roesler 2:242/40.1
	Usenet:   Wolfram_Roesler@ac2.maus.de

Bitte bei allen Zuschriften die Versionsnummer und das Kompilierungsdatum
der Shell angeben (werden durch Eingabe von "ver" ausgegeben).

Wer irgendwelche Anregungen fr weitere Versionen der Shell hat, kann sich
damit jederzeit an mich wenden.

----------------------------------------------------------------------------
PROGRAMMFEHLER

	"Selbst der  umsichtigste Programmierer kommt manchmal in
	Situationen, wo das Programm nicht richtig funktioniert."
				Texas Instuments, "Individuelles Programmieren"
				Handbuch zu TI 58/58C/59, 1977

Der Software-Support deckt die Beseitigung von Fehlern in der Shell ab. Wer
einen Fehler findet, sollte also nicht die Okami-Diskette in die Ecke schmeien
und sich einer anderen Shell zuwenden (die hat n„mlich auch Fehler), sondern
mir einen Hinweis mit m”glichst genauer Fehlerbeschreibung schicken. Wenn
man eine Diskette und Rckporto beilegt, bekommt man die korrigierte Version
der Shell sobald wie m”glich zurck. Wenn die Shell in Verbindung mit einem
anderen Programm Probleme macht, sollte man dieses Programm gleich mit-
schicken.
Natrlich kann ich keine Verantwortung fr irgendwelche Sch„den, die durch die
Shell, ihre Anwendung oder die Unf„higkeit ihrer Anwendung verursacht werden,
bernehmen. Wer also unbedingt `df -m | xargs rm -r {}/*' ausprobieren mu,
hat das Ergebnis selber auszubaden. 

----------------------------------------------------------------------------
LIEFERUMFANG

Zur Okami-Shell geh”ren die folgenden Dateien:

	KERN:
	sh.ttp		Das Haupt-Shellprogramm.
	msh.prg 	Die Microshell zum Starten als GEM-Programm.
	msh.inf 	Konfigurationsdatei zur Microshell.
	profile 	Konfigurationsdatei beim Start der Shell.
	help		Textdatei mit Syntaxerkl„rungen.
	EXTERNE KOMMANDOS:
	calc.sh 	Benutzerschnittstelle zum eingebauten UPN-Rechner.
	format.ttp	Programm zum Formatieren von Disketten.
	gem.prg 	Programm zur Benutzung von Accessories.
	gem.rsc		Resourcedatei dazu.
	showpic.sh	Demo-Shellscript zur Anzeige von Bilddateien.
	QUELLEN:
	source\msh.c	msh.prg
	source\gem.c 	gem.prg
	source\format.c	format.ttp
	source\system.c	Zum Einbinden der Shell in eigene Programme.
	DOKUMENTATION:
	readme		Grundeinfhrung fr den Anwender.
	doc\*.* 	Anleitungen.
	SONSTIGES:
	okami.pic	Das Titelbild.
	okami.dbl	Ein Icon mit dem Okami-Schriftzeichen zum Einbau 
			in eine Icondesk-Datei.
	altur112.ttp	Eine šberraschung fr den Programmstart.
	_index		Indexdatei fr `ls -i'.


Alle ausfhrbaren Programme wurden mit dem Programm-Packer von Th. Quester
und M. Fritze gepackt.
šber den Urheber der Datei altur112.ttp ist mir nichts bekannt, ich habe sie
auf einer Pd-Diskette von 1987 gefunden. Ausgepackt ist sie brigens ber
22 KB gro.

----------------------------------------------------------------------------
RAM		Die Shell ben”tigt ca. 200 KB an Laufzeitspeicher
		=> lauff„hig auch auf 512KB-Maschinen. Empfohlen werden
		allerdings 1 MB oder mehr.
Massespeicher	Fr die zum Lauf notwendigen Dateien werden minimal ca.
		120 KB ben”tigt. Mit allen Hilfsdateien (Microshell,
		Profile,...) werden ca. 200 KB ben”tigt. Dazu kommen
		noch die ber 300 KB fr die Dokumentation.
		Die Shell kann jedem Massespeicher betrieben werden. Fr
		die Verwendung des Pipelinings ist es jedoch notwendig,
		da auf einen Massespeicher (nicht notwendigerweise den,
		von dem die Shell gestartet wurde) geschrieben werden
		kann. Fr diesen Zweck kann auch eine eigene kleine
		Ramdisk angelegt werden (16-32K).
Bildschirm	L„uft fehlerfrei in hoher und mittlerer Aufl”sung. Der
		Betrieb in niedriger Aufl”sung ist m”glich, aber einige
		interne Kommandos gehen davon aus, das pro Zeile 80
		Zeichen zur Verfgung stehen (z.B. df und hd). Die Be-
		nutzung dieser Kommandos kann dann zu St”rungen in der
		Bildschirmausgabe fhren. In keinem Fall kommt es jedoch
		zu einem Programmabsturz.
		Sollte mit jeder Farb- und Schwarzwei-Emulation funktio-
		nieren.
Hardware	Die Shell untersttzt Maus, Drucker und die RS232-Schnitt-
		stelle. Es werden jedoch keine Ger„te auer Bildschirm und
		Tastatur unbedingt ben”tigt (auch nicht die Maus). (Genau-
		genommen werden nicht einmal Bildschirm und Tastatur unbe-
		dingt ben”tigt.)
Betriebssystem	Die Shell wurde unter TOS 1.2 und 1.4 auf einem Atari 1040 ST
		entwickelt und ist "sauber" programmiert, d.h. es erfolgt
		kein Zugriff auf undokumentierte oder ver„nderliche System-
		adressen o.„. Die Shell sollte daher mit jedem frheren
		und zuknftigen TOS zusammenarbeiten (abgesehen von Betriebs-
		systemfehlern.)
Software	Jedes TOS- und TTP-Programm kann von der Shell als externes
		Kommando aufgerufen werden. GEM-Programme k”nnen aufgerufen
		werden, wenn die Shell selber als GEM-Programm gestartet
		wird, was z.B. der Fall ist, wenn msh.prg zum Start der
		Shell benutzt wird.
		Zum Ver„ndern der Konfigurationsdateien profile und msh.inf
		ist ein Ascii-Editor erforderlich. Ich empfehle Tempus oder
		den Pd-Editor Micro-Emacs.
		(Micro-Emacs ist ber den Pd-Versand oder direkt bei mir er-
		h„ltlich.)


----------------------------------------------------------------------------
INSTALLATION

Die Okami-Shell kann direkt von der Diskette gestartet werden. Siehe hierzu
den folgenden Abschnitt.
Ihre volle Effizienz entwickelt die Shell allerdings erst beim Einsatz
von der Ramdisk oder Festplatte.


INSTALLATION AUF RAMDISK

Ich empfehle die selbstkomprimierende Maxidisk, da sie die optimale Speicher-
ausnutzung garantiert. Fr die Shell sollten mindestens 200 KB Maxidisk
oder ca. 300 KB einer anderen Ramdisk zur Verfgung stehen.

Fr den vollen Betrieb der Shell sollten folgende Dateien (am besten in
einen eigenen Ordner) auf die Ramdisk kopiert werden:

	sh.ttp
	profile
	msh.prg
	msh.inf
	help
	okami.pic
	altur112.ttp
	_index
  in einem Unterordner namens doc:
	commands.doc		<------ aus dem Anleitungsordner
  in einem Unterordner namens bin:
	*.sh
	format.ttp
	gem.prg
	ship.exe		<------ fr Festplattenbenutzer: das
					ship.prg der Harddisk-Utility-Disk


Die Datei help wird fr das Shell-Kommando "help" benutzt; wer diese
Datei ausdruckt und neben den Rechner legt, kann sich den Platz auf der
Ramdisk ebenfalls sparen. Dasselbe gilt fr commands.doc, das auerdem
ziemlich viel Platz beansprucht.
Die Dateien msh.prg und msh.inf geh”ren zusammen und werden zum Start der
Shell als GEM-Programm benutzt. Wer von der Shell keine GEM-Programme
starten will, braucht diese Dateien nicht.
Auf die externen Kommandos wie gem und format kann man natrlich auch
verzichten, nur mu man dann u.U. etwas h„ufiger ins Desktop zurck.
Wer nicht bei jedem Systemstart das Titelbild sehen m”chte, kann die Datei
okami.pic umbenennen oder l”schen. Dasselbe gilt fr altur112.ttp.
Auch auf profile kann man verzichten, allerdings wird die Shell dann mit
den eingebauten Voreinstellungen initialisiert.
=> Die einzige Datei, die man wirklich braucht, ist sh.ttp.

INSTALLATION AUF FESTPLATTE

Bei Verwendung der Okami-Shell mit einer Festplatte kommt echtes Unix-Feeling
auf, vor allem wenn man die Shell nach dem Systemstart automatisch starten
l„t (ich empfehle zum Autostart:
	TOS 1.0		den Autostarter aus dem Data Becker-Buch "Die besten
			Tips&Tricks fr Atari ST", S. 24ff.
	TOS 1.2		den Autostarter "startgem.prg", der zu Superboot 6.0
			geh”rt, siehe PD-Journal 9/90, S. 43ff.
	>= TOS 1.4	msh.prg im Desktop als Autostart-Applikation anmelden)
	
Mit einigen Tricks, die im folgenden erkl„rt werden, kann man sich z.B. bei
jedem Start der Shell Datum und Uhrzeit des letzten Systemstarts ausgeben
lassen oder das aktuelle Arbeitsverzeichnis so einstellen, wie man die Shell
zuletzt verlassen hat.
Auerdem kann man alle Programme, die man auf der Festplatte hat, per Name
starten lassen, egal in welchem Verzeichnis man sich gerade befindet, und es
werden sogar alle RSC-Dateien gefunden.
Man tippt also z.B. ein:
		edit datei.txt
und es erscheint der Editor mit der Datei datei.txt, egal wo im Dateisystem
der Editor sich befindet.

Fr die Shell sollte ein eigener Ordner eingerichtet werden, in den die
oben unter INSTALLATION AUF RAMDISK aufgefhrten Dateien kopiert werden.

Auerdem ist es sinnvoll, eine kleine Ramdisk (16-32K) anzulegen und die
Pipe-Operationen ber diese laufen zu lassen. Siehe dazu weiter unten.

Wenn man sich die Anleitungen der Shell auf die Festplatte kopiert, braucht
man die Datei commands.doc nicht noch einmal in den Shell-Ordner zu kopieren.
Dann mu allerdings der Dateiname von commands.doc in der Shell-Variablen
HELPFILE gespeichert werden. Siehe dazu weiter unten.

Wer sich sein Desktop mit Icondesk von Stefan Becker versch”nert hat, kann
die Icon-Datei okami.dbl direkt in die icons.img-Datei einbauen.


INSTALLATION IM AUTO-ORDNER

Es ist sehr sinnvoll, ein kleines Programm zu schreiben, das im Auto-Ordner
gestartet wird und, wenn eine bestimmte Taste gedrckt ist, die Shell per
Pexec ausfhrt. Wenn dies das erste Programm im Auto-Ordner ist, hat man
immer die Gelegenheit, vor dem Start irgendwelcher Programme in die Shell
zu gelangen und so z.B. defekte Programme, die das korrekte Hochfahren des
Systems verhindern, zu deaktivieren.
Die Shell fhrt keine AES-Aufrufe aus, die beim Start aus dem Auto-Ordner
zu Problemen fhren wrden, da zu dieser Zeit das AES noch nicht initialisiert
ist. Die Shell fhrt AES-Aufrufe erst dann aus, wenn der Anwender sie durch
Eingabe des Kommandos `gon' explizit dazu auffordert. Aus diesem Grund ist
ein Betreiben der Shell aus dem Auto-Ordner problemlos m”glich.


INSTALLATION IM COOKIE-JAR

Der Cookie-Jar ist eine M”glichkeit des Betriebssystems, mit der installierte
Programme dem System ihre Anwesenheit nebst Versionsnummer mitteilen k”nnen.
Der Cookie-Jar wird erst ab TOS 1.6 vom Betriebssystem selber benutzt, kann
aber bei allen frheren TOS-Versionen auch von Programmen installiert werden.
Die Okami-Shell tr„gt sich unter der Kennung "OkSh" in den Cookie-Jar ein.
Vorher installiert sie einen solchen, falls noch keiner vorhanden ist. Die
Versionsnummer ist auf zwei Bytes aufgeteilt, bei Version 1.3 steht eine 3
im niedrigsten und eine 1 im n„chsth”heren Byte.
Mit dem internen Kommando `cookie' kann der Cookie-Jar ausgelesen werden. Siehe
hierzu commands.doc.
Wenn die Shell beendet wird, wird der vorherige Wert wieder als Cookiejar-
Adresse eingetragen. Beim Beenden der Shell mit shutdown wird als Cookie-
jar-Adresse 0 eingetragen.

----------------------------------------------------------------------------
START DER SHELL

a) Direkt

Die Shell befindet sich in der Datei sh.ttp. Diese Datei kann vom Desktop
aus per Doppelklick gestartet werden. In der folgenden Eingabebox kann
man folgendes eintragen:

	* Ein Shell-Kommando, dann wird dieses Kommando ausgefhrt und
	  die Shell wird beendet, d.h. nach der Ausfhrung erscheint
	  sofort wieder das Desktop.
	* Man l„t die Eingabezeile leer, dann wird die Shell im Dialog-
	  modus gestartet, d.h. es erscheint ein Dollarzeichen als Prompt,
	  hinter dem dann alle Shellkommandos eingegeben werden k”nnen.
	  Beendet wird die Shell durch Eingabe von `exit' oder durch
	  Druck auf Ctrl D bei der Kommandoeingabe.
	* Man gibt ein Minuszeichen ein, dann startet die Shell ebenfalls
	  im Dialogmodus, aber vorher wird festgestellt, ob sich im
	  aktuellen Verzeichnis (i.d.R. das, in dem sich sh.ttp befindet)
	  eine Datei namens `profile' befindet. Ist dies der Fall, so wer-
	  den aus dieser Datei Shell-Kommandos gelesen und ausgefhrt. Mit
	  dieser M”glichkeit kann die Shell beim Start konfiguriert werden.
	  Diese Art, die Shell zu starten, heit in Unix-Manier "Login-
	  Shell".

Es ist auch m”glich, erst ein Minuszeichen und dann ein Kommando einzugeben,
z.B.
	- ls -l *.c
Dann wird erst das Profile gestartet, dann das Kommando ausgefhrt und die
Shell beendet.
Wenn die Parameterzeile mit -c beginnt, also z.B.
	-c df a: c:
, dann wird das -c ignoriert. Dies ist z.B. zum Aufruf der Shell aus dem
PD-Editor Micro-Emacs ntzlich.

Anmerkung: šber den Software-Support kann eine Shell bezogen werden, die sich
im Hinblick auf das bergebene Minuszeichen genau andersherum verh„lt, d.h.
sie initialisiert sich mit dem Profile immer, auer es wird ein Minuszeichen
bergeben.


b) Indirekt

Die Shell kann indirekt von jedem Programm aus mit der GEMDOS-Funktion
Pexec gestartet werden. Dies geschieht z.B. beim Aufruf von der Microshell.
Da die Shell den Environment-String benutzt, sollten Programme, die das
nicht tun, als letzten Parameter von Pexec eine NULL bergeben (und nicht
einen Leerstring).
Wenn der Shell dabei ein Parameterstring bergeben wird, so wird dieser als
Kommando ausgefhrt. Er darf mehrere (durch Semikolon getrennte) Kommandos und
I/O-Umleitung enthalten. Der Kommandostring kann, mu aber nicht durch "-c"
eingeleitet sein.
Der Parameterstring kann der Shell auch nach dem xArg-Verfahren bergeben
werden.

Wenn die Shell als Login-Shell gestartet werden soll und es m”glich sein
soll, GEM-Programme von der Shell aus zu starten, mu die Shell mit der
Microshell (msh.prg) gestartet werden.
Dazu mssen folgende Voraussetzungen zutreffen:
1) Im selben Directory wie sh.ttp stehen die Dateien msh.prg und msh.inf.
2) Die Datei msh.inf enth„lt mindestens die folgende Zeile:
sh.ttp -

Dann wird die Shell nach Doppelklick auf msh.prg automatisch als Login-Shell
gestartet. Es k”nnen alle GEM-Programme von der Shell aus ausgefhrt werden.
Siehe hierzu auch msh.doc.

Wenn die Shell auf diese Weise vom Desktop aus gestartet wird, sollte das
Profile die Zeile
	trap cursor -v
enthalten. Dann wird nach dem Ende der Shell automatisch der Cursor abge-
schaltet (auf dem Desktop st”rt er ziemlich). Siehe hierzu auch commands.doc.


c) šber den Shellpointer (_shell_p)

Der Shellpointer befindet sich in Adresse 0x4F6 und enth„lt einen Zeiger
auf eine Funktion, die ein ihr bergebenes Kommando ausfhrt. Auf diese
Weise ist es m”glich, aus einem von der Shell gestarteten Programm aus
Shellkommandos auszufhren, ohne da die Shell nochmal geladen werden mu.
Dies funktioniert z.B. mit Programmen wie Rufus oder der mitgelieferten
system()-Funktion (siehe system.c und system.doc). Ein Beispiel fr die
Verwendung ist das mitgelieferte gem.prg.

Die Funktion, deren Adresse in 0x4F6 hinterlegt wird, hat folgende Syntax:

	int Fct(cmd)
	char *cmd;

cmd ist ein String mit dem auszufhrenden Kommando. Dies kann ein beliebiges
Shell-Kommando sein. Mehrere Kommandos k”nnen durch `;' verkettet werden.
Wenn ein leerer String oder ein NULL-Zeiger bergeben wird, arbeitet die
Shell im Dialogmodus, ansonsten wird nur cmd ausgefhrt.
Zurckgegeben wird der Rckgabewert des Kommandos.

Achtung: Bei dieser Art des Aufrufes wird die bereits laufende Shell ausge-
fhrt. Das bedeutet, da alle Shellvariablen und Shellfunktionen der laufenden
Shell benutzt und ver„ndert werden k”nnen. Die vollst„ndige Reentranz der
Shell kann jedoch nicht garantiert werden. Insbesondere sollten mit einer
auf diese Weise gestarteten interaktiven Shell keine externen Programme aufge-
rufen werden. (was allerdings teilweise m”glich ist und von dem betreffenden
Programm abh„ngt.)


----------------------------------------------------------------------------
KONFIGURATION

Wenn der Shell als einziger Parameter ein Minuszeichen bergeben wird,
sucht sie nach dem Start im aktuellen Verzeichnis eine Datei mit dem
Namen profile. Wenn eine solche Datei vorhanden ist, wird sie wie ein
Shellscript (siehe dazu weiter unten) ausgefhrt.
Das Profile kann eine Einschaltmeldung auf dem Bildschirm ausgeben und
Shellvariablen wie z.B. das Prompt (PS1) setzen. Auerdem k”nnen die
Shell-Flags eingestellt werden (siehe dazu das interne Kommando `set'
in commands.doc). Das Profile kann alle Aktionen ausfhren, die ein nor-
males Shellscript auch ausfhren kann.
Siehe hierzu auch tricks.doc.



----------------------------------------------------------------------------
KOMMANDOEINGABE

a) Von der Tastatur

Wenn die Shell im Dialogmodus gestartet ist, k”nnen nach dem Prompt (i.d.R.
ein Dollarzeichen) Kommandos eingegeben werden. (Das mitgelieferte Profile
stellt das Prompt um, so da im Prompt immer das augenblickliche aktuelle
Directory zu sehen ist.)

Mit dem internen Kommando keydef kann jede beliebige Taste umdefiniert werden.
Das bedeutet, da alle der unten angefhrten Tastenfunktionen ungltig werden
k”nnen, wenn die jeweiligen Tasten redefiniert werden. Die einzigen Funktionen,
die nicht umdefiniert werden k”nnen, sind ENTER und Ctrl Shift Undo. Fr
weitere Informationen siehe commands.doc zum Thema keydef.

Bei der Eingabe werden folgende Sondertasten benutzt:

	Backspace	das zuletzt eingegebene Zeichen wird gel”scht.
	Pfeil auf	Es wird das zuletzt eingegebene Kommando ange-
			zeigt. Dieses kann mit ENTER bernommen oder
			mit Backspace editiert werden. Durch wiederholten
			Druck auf Pfeil auf wird das vorletzte Kommando
			angezeigt usw. Es werden maximal 100 Kommandos
			gespeichert (wer mehr braucht, benutze den Soft-
			ware-Support, um eine entsprechend angepate Version
			der Shell zu erhalten.) Diese Eigenschaft der Eingabe
			nennt man "History".
	Shift Pfeil auf Wie Pfeil auf, aber es wird die letzte Zeile aus der
			History angezeigt, die mit der bisherigen Eingabe
			bereinstimmt. Gibt man also ein "ls " und drckt
			Shift Pfeil auf, dann wird das letzte ls-Kommando
			zurckgeholt. Der Zeiger in der History-Liste steht
			dann hinter dieser Zeile, ein weiterer Druck auf
			Shift Pfeil Auf bringt also das vorletzte ls-Kommando
			zurck usw.
	Ctrl Pfeil auf	Wie Pfeil auf gefolgt von einem Druck auf ENTER, es
			wird also das zuletzt eingegebene Kommando nicht nur
			angezeigt, sondern auch ausgefhrt. Geht auch zusammen
			mit Shift.
	Pfeil ab	Zeigt das n„chste Kommando in der History-Liste an.
			Mit Pfeil auf und Pfeil ab kann man also in den
			in der History-Liste gespeicherten Kommandos 
			bl„ttern.
	Shift Pfeil ab	Analog zu Shift Pfeil auf.
	Ctrl Pfeil ab	Wie Pfeil ab gefolgt von einem Druck auf ENTER, analog
			zu Ctrl Pfeil auf.
	Pfeil links	Dateinamen-Vervollst„ndigung fr alle Dateien, die auf
			ein Suchmuster passen. Siehe unten.
	Esc		Dateinamen-Vervollst„ndigung fr eine Datei. Siehe
			unten.
	Pfeil rechts	Das n„chste Zeichen der vorigen Eingabe wird zurck-
			geholt. Siehe unten.
	Insert		Speichert die aktuelle Position fr Pfeil rechts.
			Siehe unten.
	Clr Home	Die Eingabezeile wird gel”scht.
	Help		Es wird eine Erkl„rung des eingegebenen Kommandos
			ausgegeben. Siehe unten.
	Ctrl Shift Undo	Fr diese Eingabezeile wird die Tasten-Redefinition
			ausgeschaltet. Die Eingabe verh„lt sich also so, als
			ob seit dem Start der Shell keine keydef-Kommandos aus-
			gefhrt worden w„ren. Die Funktion wird durch ein
			Klingelzeichen best„tigt.
	Control F	Es erscheint eine Fileselect-Box, der ausgew„hlte
			Dateiname wird in die Eingabe bernommen. Das geht nur,
			wenn gon aktiv ist (siehe commands.doc zum Stichwort
			gon).
	Control P	Es wird Hardcopy ausgefhrt. Dies geschieht durch Auf-
			ruf der Shellfunktion "screensave". Die Voreinstellung
			dieser Funktion ist ein einfacher Aufruf des internen
			Kommandos "hardcopy", wodurch der Bildschirminhalt auf
			dem Drucker ausgegeben wird. In der Datei tricks.doc
			ist eine screensave-Funktion angegeben, durch die die
			Hardcopy in eine Datei  geschrieben wird.
	Control A	Der Bildschirm wird dunkelgeschaltet. Um diesen Modus
			anzuzeigen, l„uft ein heller Streifen ber den Bild-
			schirm. Nach Druck auf eine der Shifttasten, Control
			oder Alternate kann man weiterarbeiten.
	Control D	Die Shell wird beendet.


Es k”nnen beliebige Ascii-Codes in der Schreibweise `^ooo' eingegeben
werden, wobei ooo eine dreistellige Oktalzahl ist. Um z.B. ein Escape-
zeichen in eine Eingabe einzubauen:
	echo "Jetzt kommt ein Esc: ^033 das war das Esc"
Auf diese Weise k”nnen alle VT52-Sequenzen benutzt werden. Siehe auch
`echo' in commands.doc.


Dateinamen-Vervollst„ndigung (Filename-Completion):

Die Shell bietet die M”glichkeit, nur einen Teil eines Dateinamens einzu-
geben und diesen dann zu dem vollen Dateinamen expandieren zu lassen.
Dazu gibt es zwei M”glichkeiten:

1) Nach Druck auf Taste Pfeil links wird das zuletzt eingegebene Wort zu
allen Dateinamen expandiert, die nach den Regeln der erweiterten Wildcards
auf dieses Wort passen.
Beispiel:
 $ cat *.c<PFEIL LINKS>
erzeugt
 $ cat sh.c cmds.c utl.c ...

2) Nach Druck auf die Taste ESC kann der Anwender aus den auf das letzte
Wort passenden Dateien eine ausw„hlen. Wenn nur eine Datei pat, wird
diese direkt bernommen, ansonsten kann eine Datei mit folgenden Tasten
ausgew„hlt werden:
	Pfeil links/rechts	die jeweils n„chste/vorige Datei.
	Pfeil auf/ab		zum Anfang/Ende der Liste.
	Leertaste		Dateil„nge und Anzahl der passenden Dateien
				werden ausgegeben. Hierbei bedeutet `4/10'
				die vierte Datei von insgesamt zehn.
	Return			der gerade angezeigte Dateiname wird ber-
				nommen.
	ESC			die Auswahl wird abgebrochen, die bisherige
				Eingabe bleibt unver„ndert.
	Clr Home		die Auswahl wird abgebrochen, das Suchmuster
				wird aus der Eingabe entfernt.
	Help			eine Tastenbersicht wird angezeigt.

Sowohl fr Pfeil links als auch fr ESC gilt, da die Funktion des einge-
gebenen Wortes mit dem Shell-Flag f ver„ndert werden kann. Wenn dieses
Flag gesetzt ist (set +f), dann stellt das eingegebene Wort ein Pr„fix
dar, z.B. steht `abc' dann fr alle Dateien, deren Name mit abc anf„ngt.
Wenn das Flag f nicht gesetzt ist (set -f), steht das eingegebene Wort nur
fr die Dateien, die (nach den Regeln fr erweiterte Wildcards) auf dieses
Wort passen, `abc' steht dann also nur fr die Datei abc.


Beispiele zur Verwendung von Pfeil rechts und Insert:

1) Anzeige der Namen aller DOC-Dateien, danach Ausgabe derselben.
   Die Kommandofolge lautet:
	dir *.doc
	cat *.doc
   Nach der Eingabe von "dir *.doc" tippt man "cat" und drckt dann auf
   die Pfeil rechts-Taste: es erscheinen die weiteren Zeichen der vorigen
   Eingabe, also " *.doc".

2) Anzeige der Namen aller C-Dateien, danach Ausgabe der vollst„ndigen Datei-
   liste, nach Dateidatum geordnet.
   Die Kommandofolge lautet:
   ls *.c
   ls -lt *.c
   Nach der Eingabe von "ls *.c" drckt man zweimal auf Pfeil rechts: es
   erscheint "ls". Dann drckt man Insert, um die Position zu speichert,
   tippt " -lt" und drckt dreimal auf Pfeil rechts, um die weiteren
   Zeichen der vorigen Eingabe zurckzuholen.

					*** VERSUCH MACHT KLUCH ***

Zur Benutzung der Help-Taste:

Mit der Help-Taste kann jederzeit, und zwar ohne die Eingabe zu st”ren, zu
einem Kommando die entsprechende Anleitung aus der Datei commands.doc ange-
zeigt werden. Will man z.B. eine Diskette formatieren, so tippt man das
Kommando "format" ein und berlegt dann, wie die Parameter noch waren -
dann hilft ein Druck auf Help, und es erscheint die Anleitung zu format.
Anschlieend kann die Eingabe fortgesetzt werden. Das funktioniert auch,
wenn bereits Parameter nach format eingegeben worden sind.
Wenn man die Help-Taste bei leerer Kommandozeile drckt, wird man nach dem
zu erkl„renden Kommando gefragt.
Bei der Angabe des zu erkl„renden Kommandos gelten die Regeln fr erweiterte
Wildcards, d.h. mit "r*" wird das erste Kommando erkl„rt, das mit r beginnt
usw.

Beispiel:

$ format A: <HELP>					Eingabe

format - Formatieren von Disketten			Ausgabe
..... (usw.)

$ format A: *						weiter gehts

(In diesem Beispiel steht <HELP> fr das Drcken der Help-Taste und * fr
die Cursor-Position am Ende. $ ist das Shell-Prompt.)

Der Pfadname der Datei commands.doc mu in der Shell-Variablen HELPFILE ge-
speichert sein. Die Voreinstellung ist $HOME\doc\commands.doc. Wenn die Vari-
able HELPFILE nicht gesetzt ist, wird die Datei help.txt im aktuellen Directory
benutzt.

Anstelle von commands.doc kann auch jede andere Datei benutzt werden. Damit
ein Kommando in der Datei erkannt wird, mu die Datei folgende Regeln er-
fllen:

1) Vor dem Text, der das Kommando erkl„rt bzw. der zu dem Kommando ausge-
geben werden soll, mu eine Zeile stehen, die mit fnf Minuszeichen beginnt.
2) Direkt nach dieser Zeile mu eine Zeile stehen, die mit dem Kommando
beginnt. Das Kommando geht vom Anfang der Zeile bis (exkl.) zum ersten Nicht-
Buchstaben (Buchstaben sind a-z und A-Z, keine Umlaute, kein ). Danach k”nnen
weitere Informationen stehen, die nicht beachtet werden.
3) Der auszugebene Text beginnt mit der unter 2) beschriebenen Zeile und
geht bis zur n„chsten Zeile, die mit fnf Minuszeichen beginnt (exkl.).


Beispiel:

-----									1)
ls - Anzeigen von Directories						2)
									3)
(Weitere Angaben)							4)
									5)
-----									6)

Bei der Eingabe von "ls <HELP>" werden die Zeilen 2) bis 5) ausgegeben.

Natrlich kann man auch eine Kopie von commands.doc anfertigen und dort
einige weitere beliebige Informationen eintragen, die unter entsprechenden
Stichworten abgefragt werden k”nnen.

Die Ausgabe erfolgt wie mit dem Kommando "pg". Siehe hierzu commands.doc.


TECHNISCHER HINWEIS: (nur fr Programmierer von Interesse)

Wenn die Hilfsdatei im Speicher steht und von der Shell aus ein anderes
Programm gestartet wird, bergibt die Shell diesem in der Environment-
Variablen _HELP_ADR die Adresse eines Pointers auf die geladene Hilfsdatei.
Auf diese Weise kann eine Subshell auf die bereits geladene Datei zugreifen,
ohne diese selber laden zu mssen (was einen nicht unerheblichen Aufwand an
Speicherplatz bedeuten wrde.)
Die Shell liest den Inhalt von _HELP_ADR direkt nach der Initialisierung der
Variablen aus dem Environment und l”scht danach die Shellvariable _HELP_ADR.
Beim Aufruf weiterer Programme wird diese Variable nur w„hrend der Erstellung
des Environments fr das neue Programm angelegt. Die Variable _HELP_ADR ist
also fr den Anwender der Shell niemals sichtbar, befindet sich aber im
Environment aller gestarteten Programme.
Fr die šbergabe ist es notwendig, da noch mindestens ein Platz in der
Variablentabelle frei ist.
Das Format von _HELP_ADR ist
	0xAAAAA:0xBBBBB
, wobei AAAAA die Adresse eines Pointers ist (hexadezimal). Dieser Pointer
zeigt auf den Text der geladenen Datei. 0xBBBBB ist die Adresse einer
internen Indextabelle, die die Shell zum schnellen Zugriff auf die geladenen
Daten benutzt. Diese Indextabelle ist ein Array von Strukturen des Typs
	struct
	{
	  char *Name;
	  long Offset;
	} HelpIdxTyp;
Name ist der Name eines Kommandos und Offset ist die Byte-Entfernung der
Erkl„rung dieses Kommandos von dem Beginn des Textes (der durch den Zeiger
in der Adresse 0xAAAAA angegeben wird). Das Ende dieser Tabelle ist durch
einen Eintrag mit Name=NULL (0L) markiert.
(0xAAAAA ist also vom Typ (char **), w„hrend 0xBBBBB vom Typ (HelpIdxTyp *)
ist.)
ACHTUNG: auf keinen Fall darf der Pointer ver„ndert werden.


b) Aus einer Datei

Es ist m”glich, Dateien zu schreiben, die Shell-Kommandos enthalten
und diese Dateien Kommando fr Kommando von der Shell ausfhren zu 
lassen. Solche Dateien werden als Shell-Scripts (oder in der MS-DOS-Welt
als Batch-Dateien) bezeichnet. Ein Shell-Script kann wiederum weitere
Scripts ausfhren usw., wobei die Tiefe der Schachtelung durch den zur
Verfgung stehenden Speicher und die systembedingte Maximalanzahl offener
Dateien begrenzt ist. Rekursive Shellscripts sind natrlich auch m”glich.
Fr die Kommandos in Shell-Scripts gelten dieselben Regeln wie fr
Kommandos, die ber die Tastatur eingegeben werden. Leider ist die Aus-
fhrung von Shell-Scripts derjenige Punkt, an dem die Okami-Shell und
die normalen Unix-Shells am weitesten auseinanderklaffen, da beim Aufruf
eines Shell-Scripts unter Unix dieses i.d.R. nicht von der Shell selber
ausgefhrt wird, sondern die Shell startet sich selber nochmals, um das
Script auszufhren (Subshell). Auf dem ST ist diese Vorgehensweise wegen
des begrenzten Speichers nicht zu empfehlen, weswegen jedes Shellscript
von der Shell selber ausgefhrt wird. Dies hat Konsequenzen z.B. bei der
Ein/Ausgabeumleitung von Shell-Scripts und den einem Script bergebenen
Parametern. Auerdem kann jedes Script auf alle Shellvariablen der aufrufenden
Shell zugreifen und diese ver„ndern.

Bei der Ausfhrung eines Shellscripts wird das Script erst vollst„ndig in
den Speicher geladen und dann im Speicher ausgefhrt. Das liefert besonders
bei der Ausfhrung von Diskette enorme Geschwindigkeitsvorteile. Gengend
Speicher ist normalerweise immer vorhanden, wenn man bedenkt, da Scripts
i.d.R. kleine Dateien (<5 KB) sind.

Bei Shellscripts gibt es die M”glichkeit, Programmierstrukturen wie if und
while zu benutzen, die bei Tastatureingabe wenig Sinn machen. Damit ist
es in der Tat m”glich, Shellscripts zu schreiben, die wie ein Programm
einer h”heren Programmiersprache laufen. Siehe hierzu showpic.sh und
commands.doc.



Es gibt vier Arten von Kommandos:
	1) interne Kommandos,
	2) externe Kommandos,
	3) Shellfunktionen,
	4) Kommentare.

INTERNE KOMMANDOS
Ein internes Kommando ist ein Kommando, durch das eine Funktion innerhalb
der Shell ausgefhrt wird, das also in der Shell eingebaut ist. Interne
Kommandos werden durch Eingabe ihres Namens aufgerufen.
Genaue Erkl„rungen aller interner Kommandos befinden sich in der Datei
commands.doc.

EXTERNE KOMMANDOS
Ein externes Kommando ist nicht in der Shell eingebaut, sondern in einer
Datei auf einer Diskette, Ramdisk oder Festplatte vorhanden. Hierbei kann
es sich sowohl um eine ausfhrbare Datei (.PRG, .TOS etc.) als auch um 
ein Shellscript handeln.
Externe Kommandos k”nnen durch Eingabe des vollst„ndigen Pfadnamens der
entsprechenden Datei, aber auch durch Eingabe des Kommandonamens (des
Dateinamens ohne Pfad und Extender) gestartet werden. Die zugeh”rige Datei
wird auf den Pfaden gesucht, die in der Shell-Variablen PATH gespeichert sind.
Mit dem hash-Kommando kann der Pfad eines Kommandos der Shell mitgeteilt
werden, ohne da er in $PATH enthalten ist.
Externe Kommandos k”nnen nur ausgefhrt werden, wenn ihr Datei-Extender
einem der in den Shell-Variablen XEXT und SEXT gespeicherten entspricht.
(Es kann jedoch jede Datei, unabh„ngig vom Dateinamen, explizit als Shell-
script oder Bin„rdatei ausgefhrt werden, und zwar mit den Kommandos `.'
und `exec'.) 
Siehe hierzu auch den Abschnitt ber externe Kommandos in commands.doc.

Externen Programmen werden die Parameter nach dem xArg-Verfahren bergeben,
wenn das Shell-Flag `a' gesetzt ist (siehe commands.doc zum Thema `set').
Dies erm”glicht die šbergabe von beliebig vielen Parametern, w„hrend Gemdos
die Parameter auf 125 Zeichen beschr„nkt.
Achtung: einige (wenige) Programme vertragen sich damit nicht und laufen
nur, wenn die xArg-šbergabe mit `set -a' unterbunden wird. Dazu geh”rt z.B.
der Entpacker `unzip'.


SHELLFUNKTIONEN

Shellfunktionen sind Shellscripts, die resident im Speicher gehalten werden.
Sie haben dieselben Eigenschaften wie Shellscripts und k”nnen deshalb auch
genauso programmiert werden. Alles, was ber die Verwendung von Shellscripts
gesagt wird, gilt auch fr Shellfunktionen.
Jede Shellfunktion hat einen Namen, der bis zu 80 Zeichen lang sein darf.
Gro- und Kleinschreibung wird unterschieden, d.h. "hallo" und "Hallo" sind
zwei verschiedene Shellfunktionen.
Bei der Ausfhrung haben Funktionen die oberste Priorit„t, kommen also noch
vor den internen Kommandos. Es ist also m”glich, interne Kommandos umzude-
finieren, indem man eine Shellfunktion mit demselben Namen anlegt. Inner-
halb dieser Funktion kann auf das ursprngliche Kommando zugegriffen werden,
indem man dem Kommando ein Ausrufezeichen (ohne Leerzeichen) vorstellt.
Die Syntax einer Deklaration von Shellfunktionen ist:


[Funktionsname] "(" Dateiname ")"		(1)

	oder

Funktionsname "()"				(2)
"{"
  {Zeilen des Funktionsrumpfes}
"}"

	oder

Funktionsname "()"				(3)
"{}"

(1) In der ersten Fassung wird die angegebene Datei als Shellscript in den
Speicher geladen und unter dem Namen der Funktion abgespeichert. Wenn kein
Funktionsname angegeben ist, wird der Basisname des Dateinamens (ohne Ex-
tender) als Funktionsname benutzt. In dieser Fassung entspricht die Shell-
funktion also einem speicherresidenten Shellscript.
Wenn die angegebene Datei eine ausfhrbare Programmdatei ist, wenn also
ihr erstes Wort 0x601a ist, wird das Programm geladen und eine Shellfunktion
erzeugt, die das Programm mit exec -x startet. Auf diese Weise ist es m”glich,
auch Bin„rprogramme resident im Speicher zu halten und ohne Disketten- oder
Plattenzugriffe beliebig oft zu starten.
ACHTUNG: Die Vorgehensweise dabei beruht auf der F„higkeit der Gemdos-Funktion
Pexec, Bin„rprogramme zu laden und erst zu einem sp„teren Zeitpunkt unter
Angabe der Basepage-Adresse zu starten. Die Dokumentation von Atari zu diesem
Feature ist kurz und eindeutig; sie lautet: "Finger davon". Nichtsdestoweniger
funktioniert es, aber es besteht keine Garantie, da es immer oder mit allen
Programmen oder Betriebssystemversionen funktioniert.

(2) In der zweiten Fassung wird die Funktion von der Tastatur oder dem
Shellscript, in dem die Deklaration steht, gelesen. Wenn bereits eine
Funktion mit dem angegebenen Namen existiert, wird sie umdefiniert. Wenn
der Funktionsrumpf leer ist, wenn also die Zeilen mit { und } direkt auf-
einander folgen, wird die Funktion gel”scht.
In dieser Fassung wird die Eingabe verkrzt, d.h. Leerzeilen, Kommentar-
zeilen und fhrende Leerzeichen werden nicht mit abgespeichert.

(3) In der dritten Fassung wird die Funktion gel”scht. Das geht auch mit dem
Kommando `unset Funktionsname'.

Die zweite und dritte Fassung erwarten also mehr als eine Zeile. Die weiteren
Zeilen der Deklaration werden von der sog. "Sekund„reingabe" erwartet, also
von dem Ger„t oder der Datei, von der augenblicklich Kommandos gelesen
werden (das ist nicht immer die Standardeingabe). Wenn es sich dabei um
die Tastatur handelt, erscheint als Prompt der Inhalt der Shellvariablen
PS2.

ACHTUNG: In keinem Fall darf zwischen Funktionsname und der ge”ffneten Klammer
ein Leerzeichen stehen.


Beispiele:

hallo(hallo.sh)
		initialisiert eine Funktion namens "hallo". Die Funktion
		entspricht dem Shellscript hallo.sh.

hallo (hallo.sh)
		ruft das Kommando hallo mit dem Parameter (hallo.sh) auf,
		ist also KEINE Deklaration einer Shellfunktion. (Schuld
		daran ist das Leerzeichen nach "hallo".)

(c:/bin/test.sh)
		initialisiert eine Funktion aus der Datei c:/bin/test.sh.
		Da kein Funktionsname angegeben ist, wird der Basisname der
		Datei benutzt, es wird also die Shellfunktion "test" er-
		zeugt. (Nebenbei bemerkt: dadurch wird das interne Kommando
		"test" umdefiniert.)

(c:/bin/hallo.prg)
		l„dt das Programm hallo.prg und erzeugt eine Shellfunktion
		namens hallo, die das geladene Programm startet. hallo
		hat dabei folgenden Funktionsrumpf:
			exec -lg c:/bin/hallo.prg 0x8f30a
		wobei 0x8f30a die beim Laden ermittelte Adresse der Basepage
		von hallo.prg ist.

hallo()
{
  echo Hallo, wie gehts?
  read _
  echo Es freut mich, da es Dir $_ geht.
  unset _
}
		definiert die Funktion hallo mit dem angegebenen Funktions-
		rumpf. Die Verwendung von Shellvariablen ist m”glich; in
		diesem Fall wird die Variable _ (Underscore) benutzt, die
		fr tempor„re Verwendungen zur Verfgung steht.
		Diese Deklaration kann sowohl in einem Shellscript stehen
		als auch ber die Tastatur eingegeben werden. Bei Tastatur-
		eingabe erscheint das Prompt $PS2.

ls()
{
  !ls -C $*
}
		Das interne Kommando ls wird so umdefiniert, da die Option
		-C immer aktiv ist. Dies geschieht durch Definition einer
		Shellfunktion mit Namen ls, die das interne Kommando durch
		!ls aufruft.

alias ls !ls -C
		hat dieselbe Wirkung.

hallo()
{}
		Die Shellfunktion hallo wird gel”scht.

hallo()
{
}
		Dito.

unset hallo
		Dito.

()
		(weder Funktions- noch Dateiname angegeben) ist ein Syntax-
		fehler.


Mit dem internen Kommando "fcts" kann eine Liste s„mtlicher Shellfunktionen
erzeugt werden. Die Definition einer beliebigen Shellfunktion kann mit dem
Kommando "type" ausgegeben werden. Siehe hierzu commands.doc.


Es geh”rt zur Philosophie von Unix, da man an der reinen Eingabe nicht
erkennen kann, ob es sich bei dem eingegebenen Kommando um ein internes
Kommando, eine ausfhrbare Datei, ein Shellscript oder eine Shellfunktion
handelt. Um das herauszufinden, gibt es das interne Kommando `type'. Siehe
hierzu commands.doc.


KOMMENTARE

Eine Eingabe gilt als Kommentar, wenn sie mit einem Doppelkreuz (#) beginnt
oder wenn sie nur aus einer leeren Zeile besteht. Kommentare werden von
der Shell nicht weiter beachtet und sind ntzlich zum Dokumentieren von
Shell-Scripts. Die Tastatureingabe von Kommentaren ist zwar m”glich, aber
nicht unbedingt sinnvoll.


ERWEITERTE WILDCARDS

Die Okami-Shell erlaubt fr die Angabe von Dateinamen ein Wildcard-System,
das weit ber das von Gemdos gestellte hinausgeht. Die einzigen Gemdos-
Wildcards sind * und ?, wobei ein ein Dateiname nur einen Stern enthalten
darf, und den nur am Ende von Name oder Extender. Bei "**" gibt es Probleme,
"*hallo*" liefert nicht alle Dateinamen, die "hallo" enthalten usw.
Die erweiterten Wildcards der Okami-Shell orientieren sich an denen, die von
der Original-Unix-Shell zur Verfgung gestellt werden. Es bedeuten:

*	beliebig viele, auch null, beliebige Zeichen.
?	genau ein beliebiges Zeichen.
[abcd]	genau ein Zeichen, und zwar eins der in den Klammern stehenden. Es
	drfen beliebig viele Zeichen angefhrt sein.
[a-g]	genau ein Zeichen, und zwar a, b, ... oder g. Das Minuszeichen bedeutet
	also "bis".
[~abc]	genau ein Zeichen, und zwar ein beliebiges bis auf die Zeichen in den
	eckigen Klammern. Es drfen beliebig viele Zeichen angefhrt sein.

Der Punkt zwischen Dateiname und Extender wird dabei wie jedes andere Zeichen
behandelt, "*" pat also auf alle Dateinamen und nicht nur auf die ohne Ex-
tender.

Beispiele:

*		alle Dateinamen.
*.*		alle Dateinamen, die einen Extender haben.
*.?		alle Dateinamen, deren Extender aus genau einem Zeichen besteht.
*.[co]		alle Dateinamen mit Extender .c oder .o.
*.[~co]		alle Dateinamen auer denen mit Extender .c und .o.
[abcd]*[xyz]	alle Dateinamen, deren erstes Zeichen a, b, c oder d und deren
		letztes Zeichen x, y oder z ist. Der Punkt, der den Extender
		einleitet (falls vorhanden), kann irgendwo dazwischen stehen.
a[0-9]		alle Dateinamen, die aus a, gefolgt von einer Ziffer bestehen,
		also a0, a1, ..., a9.
??[a-z][0-9]	alle Dateinamen, die aus zwei beliebigen Zeichen, gefolgt von
		einem Buchstaben und einer Ziffer bestehen.


Wenn das Shell-Flag w nicht gesetzt ist, sind die erweiterten Wildcards auer
Kraft gesetzt. Die Shell benutzt dann nur die Wildcards, die von TOS zur
Verfgung gestellt werden.
Das Programm fr den Vergleich mit erweiterten Wildcards stammt von Rich Salz
und wurde 1986 geschrieben.


FLAGS UND PARAMETER

Jedem Kommando k”nnen Flags und Parameter bergeben werden. I.d.R. werden
Parameter benutzt, um festzulegen, womit etwas getan werden soll, und die
Flags legen fest, wie es getan werden soll.

Die Shell teilt die Eingabezeile in Worte auf. Worte werden durch Whitespace-
Zeichen (Leerzeichen, Tab, Formfeed) getrennt. Durch doppelte (") oder ein-
fache (') Anfhrungszeichen k”nnen auch Whitespace-Zeichen in Worten benutzt
werden, z.B. ist
	a b c d
vier Worte, w„hrend
	"a b c d"
nur ein Wort ist. Einfache Anfhrungszeichen verhindern auerdem jede Art
von Interpretation, d.h. innerhalb von einfachen Anfhrungszeichen werden
	* keine Shellvariablen expandiert
	* keine Slashes zu Backslash umgeformt
	* keine Escape-Sequenzen (beginnent mit ^) interpretiert
	* keine Command-Substitution ausgefhrt
. Es ergibt also
	$HOME
den Inhalt der Shell-Variablen HOME und
	'$HOME'
den String $HOME.

Externen Kommandos werden alle bergebenen Flags und Parameter als Kommando-
zeile bergeben. Alle exportierten Shell-Variablen werden den externen
Kommandos im Environment bergeben. Das Betriebssystem limitiert die L„nge
der Kommandozeile auf maximal 125 Zeichen. Die šbergabe von mehr Zeichen
ist durch das xArg-Protokoll m”glich.
Den internen Kommandos k”nnen beliebig viele Flags und Parameter berge-
ben werden, allerdings ist fr die meisten Kommandos nur eine beschr„nkte
Anzahl von Parametern sinnvoll.
Die Flags der internen Kommandos werden durch ein Minus- oder Pluszeichen
eingeleitet. N„heres siehe commands.doc.

Die Shell benutzt eine Reihe eigener Flags, die mit dem internen Kommando
set eingestellt werden k”nnen. Siehe hierzu commands.doc.



VERKETTETE KOMMANDOS

Kommandos k”nnen in einer Zeile durch Semikolon getrennt angefhrt werden.
Die Kommandos werden von links nach rechts ausgefhrt.


Wenn eine eingegebene Zeile mit einem Dach (^) endet, wird anstelle des
Daches die Fortsetzung der Zeile von der Sekund„reingabe eingelesen. Das
entspricht dem Backslash in Unix.
Beispiel:
ec^
ho ha^
l^
lo

entspricht "echo hallo". Dabei kann diese Eingabe sowohl von der Tastatur
als auch aus einem Shellscript oder einer Shellfunktion stammen.


----------------------------------------------------------------------------
SHELLVARIABLEN

Eine besondere Art von internem Kommando ist die Zuweisung eines Wertes an
eine Shellvariable. Alle Shellvariablen sind Stringvariablen. Der Name einer
Shellvariablen kann in beliebiger Reihenfolge Buchstaben, Ziffern und Under-
scores (_) enthalten.

Beschr„nkungen:
	Maximalanzahl der Shellvariablen: 200
	Maximall„nge des Variablennamens und -Wertes:
					unbeschr„nkt (80 relevante Stellen)

Wer damit nicht auskommt, benutze den Software-Support, um eine Version
der Shell mit gr”eren Kapazit„ten zu erhalten. Die Maximalanzahl der Vari-
ablen einer Shell kann mit "ver -l" ermittelt werden.

Jede Shell-Variable hat einen Status, der aus beliebigen (auch null) der
folgenden Eigenschaften besteht:

USR (User)	Die Variable wurde vom Benutzer angelegt oder ver„ndert.
SYS (System)	Es handelt sich um eine Systemvariable, die von der Shell
		verwaltet wird. Hierzu geh”ren z.B. die Positionsparameter
		$0, $1..., $#, $? usw.
R/O (Read-Only) Der Wert der Variablen darf nicht ver„ndert und die Variable
		darf nicht gel”scht werden.
EXP (Export)	Die Variable befindet sich im Environment.

Die Eigenschaften USR und SYS k”nnen nicht beeinflut werden. Die Eigen-
schaften R/O und EXP k”nnen mit den Kommandos `readonly' und `export' gesetzt
und gel”scht werden. Siehe hierzu commands.doc.


DEKLARATION
Shell-Variablen brauchen nicht deklariert zu werden.


ZUWEISUNG
Die Zuweisung eines Wertes an eine Shell-Variable geschieht durch eine
Eingabe der Form
	Variable=Wert

z.B.:
	NAME=Okami-Shell

Es wird der String "Okami-Shell" der Shellvariablen NAME zugewiesen. In
Unix ist es blich, Shell-Variablen in Grobuchstaben zu schreiben, es
sind allerdings auch Kleinbuchstaben m”glich. NAME und Name sind zwei
unterschiedliche Variablen.
Auf die folgende Weise kann einer Variablen ein leerer Wert zugewiesen
werden:
	Variable=""
Der Wert der Variablen wird also gel”scht, aber die Variable selber bleibt
bestehen.

Auerdem k”nnen die internes Kommandos "read", "fsel", "alert" und "mouse"
zur Zuweisung von Eingaben an Shellvariablen benutzt werden. Siehe hierzu
commands.doc.


BENUTZUNG
Der Wert einer Shell-Variablen kann durch Angabe des Variablennamens mit
vorgestelltem Dollar-Zeichen angegeben werden. In einer Eingabezeile der
Shell werden erst alle Variablen zu den betreffenden Werten expandiert,
bevor die Zeile ausgefhrt wird. Shell-Variablen, an die noch kein Wert
zugewiesen wurde, werden als Leerstrings behandelt.

Beispiele:

	NAME=Okami-Shell
	echo $NAME

erzeugt die Ausgabe "Okami-Shell".

	NAME=Okami-Shell
	echo Der Name ist $NAME und nicht anders. 

erzeugt die Ausgabe "Der Name ist Okami-Shell und nicht anders."

	VAR1=$VAR2

weist der Variablen VAR1 den Wert der Variablen VAR2 zu.

	VAR1=VAR2
	VAR3=VAR1
	$VAR1=$VAR3

weist der Variablen VAR2 den String VAR1 zu (ja, wirklich.)


Es ist auch m”glich, Shell-Kommandos an Variablen zuzuweisen und dann aus-
fhren zu lassen:

	CC=c:\compiler\cc.ttp
	$CC test.c

ruft das Programm c:\compiler\cc.ttp mit dem Parameter test.c auf.


L™SCHEN
Auf die folgende Weise werden Variablen gel”scht:
	Variable=
Dies ist nicht zu verwechseln mit dem L”schen des Inhalts einer Variablen
(siehe oben). Wenn hinter dem Gleichheitszeichen nichts steht, wird die
Variable vollst„ndig gel”scht und belegt danach keinen Platz mehr in der
Variablentabelle.
Dies ist notwendig, da die Shell nur ber eine begrenzte Anzahl
von Variablen verfgt. Besonders Shell-Scripts, die Variablen fr lokale
Zwecke benutzen, sollten diese Variablen nach der Benutzung wieder frei-
geben.
Shellvariablen k”nnen auerdem mit dem Kommando unset gel”scht werden.
Beim L”schen verliert die Variable natrlich auch ihren Status. Um den Status
zu erhalten, darf nur der Wert der Variablen gel”scht werden (NAME="").


Beispiele:

1.	NAME= 
			Die Shell-Variable NAME wird gel”scht.
2.	unset NAME
			Ebenso.


3.	SAVECWD=$CWD
	cd c:\work\test
	.......................(weitere Kommandos)
	cd $SAVECWD

Das aktuelle Verzeichnis (das stets in der Variablen CWD steht) wird in die
Variable SAVECWD gesichert. Danach wird das aktuelle Verzeichnis ge„ndert
(mit dem internen Kommando "cd"), und es werden weitere Kommandos ausgefhrt.
Anschlieend wird das aktuelle Verzeichnis wieder restauriert.
Diese Technik sollte von allen Shellscripts benutzt werden, die das aktuelle
Verzeichnis „ndern. Unter Unix werden Shellscripts stets von Subshells
ausgefhrt, und das aktuelle Verzeichnis ist eine Eigenschaft eines
Prozesses, weswegen Shellscripts das aktuelle Verzeichnis „ndern k”nnen,
ohne das aktuelle Verzeichnis der aufrufenden Shell zu beeinflussen.
Die Okami-Shell benutzt keine Subshells, und daher kann jedes Shell-
script das aktuelle Verzeichnis der Shell „ndern, was in der praktischen
Anwendung nicht immer erwnscht ist.
Das umst„ndliche Speichern und Restaurieren des aktuellen Verzeichnisses
entf„llt, wenn die Shell-Flags x und c gesetzt sind. Siehe hierzu das
interne Kommando `set' in commands.doc.


Es ist m”glich, eine Shellvariable zu benutzen, deren Name nur aus einem
Underscore (_) besteht. Die Verwendung einer solchen Variablen fr kurz-
zeitige lokale Verwendungen ist z.B. in der Programmiersprache Prolog
blich.  



SYSTEMVARIABLEN
Eine Reihe von Shellvariablen werden von der Shell selber angelegt und
benutzt. Es ist teilweise m”glich, die Werte dieser Variablen zu ver„ndern.
Die Systemvariablen sind:

PS1		Das Eingabeprompt. Kann vom Anwender ver„ndert werden (was
		normalerweise im Profile geschieht). Der Defaultwert ist
		" $ ".
PS2		Das sekund„re Eingabeprompt. Erscheint z.B. bei der Eingabe
		von Shellfunktionen. Kann beliebig ver„ndert werden, der
		Defaultwert ist "> ".
LOGNAME 	Der Programmname ("Okami Shell"). Kann nicht ver„ndert
		werden.
VERSION 	Die Versionsnummer der Shell. Kann nicht ver„ndert werden.
TERM		Der Rechnertyp, kann auf das individuelle Modell (z.B.
		"Atari 1040 STE" oder "Mega ST 4") eingestellt werden.
		Diese Einstellung erfolgt am besten in der Konfigurations-
		datei $HOME\profile. Der Defaultwert ist "Atari ST". Ist
		in der jetzigen Version der Shell noch ohne weitere Be-
		deutung.
CWD		Das aktuelle Verzeichnis. Wird nach jedem Wechsel des
		Verzeichnisses automatisch aktualisiert und sollte nicht
		von Hand ver„ndert werden. (Durch eine Zuweisung an diese
		Variable wird das aktuelle Verzeichnis NICHT ge„ndert.)
HOME		Das Verzeichnis, aus dem die Shell gestartet wurde (genauer
		gesagt das aktuelle Verzeichnis zum Zeitpunkt des Starts
		der Shell). Kann nach Bedarf ver„ndert werden.
ETC		Das Verzeichnis, in dem die Shell Hilfsdateien wie z.B.
		die Textdatei fr das help-Kommando erwartet. Wird bei
		Programmstart auf denselben Wert wie HOME eingestellt und
		kann beliebig ver„ndert werden.
SHELL		Hier soll der vollst„ndige Aufrufpfad des Shellprogramms
		eingetragen sein. Da die Shell diesen nicht mit v”lliger
		Sicherheit selber bestimmen kann, wird hier $HOME\sh.ttp
		eingetragen. Kann beliebig angepat werden, wenn diese An-
		gabe einmal nicht zutrifft.
PAGELEN 	Die Anzahl der Zeilen auf dem Bildschirm. Wird von dem
		internen Kommando pg benutzt. Kann beliebig eingestellt
		werden. Die Defaulteinstellung ist 23.
PIPDIR		Das Laufwerk und der Pfad, auf dem die Hilfsdateien des
		Pipelinings erzeugt werden. Mu auf einem beschreibbaren
		Laufwerk (am besten auf einer Ramdisk) liegen. Die Default-
		einstellung ist $HOME. Kann beliebig ver„ndert werden.
NULL		Der Name des Ger„tes oder der Datei, an die die Ausgaben
		geleitet werden, die zum Null-Ger„t (NULL:) umgeleitet
		werden. Kann ver„ndert werden. Die Defaulteinstellung 
		ist "PRN:" (paralelle Schnittstelle). Wer einen Drucker hat,
		sollte hier eine Datei z.B. auf der Ramdisk eintragen. Die
		Einstellung AUX: fr die serielle Schnittstelle ist nicht
		m”glich, da diese Schnittstelle von der Standard-Fehleraus-
		gabe belegt ist.
XEXT		Eine Liste von durch Kommata oder Semikolons getrennten Ex-
		tendern. Dateien mit einem der hier aufgefhrten Extender
		k”nnen als Bin„rprogramme gestartet werden. Die Default-
		einstellung ist	".prg,.tos,.ttp,.app". Die Punkte vor den
		Extendern mssen mit angegeben werden. Kann beliebig ver„ndert
		werden.
SEXT		Eine Liste von durch Kommata oder Semikolons getrennten Ex-
		tendern. Dateien mit einem der hier aufgefhrten Extender
		k”nnen als Shellscripts gestartet werden. Die Defaultein-
		stellung ist ".sh". Die Punkte vor den Extendern mssen mit
		angegeben werden. Kann beliebig ver„ndert werden.
GEXT		Eine Liste von durch Kommata oder Semikolons getrennten Ex-
		tendern. Bin„rdateien mit einem der hier aufgefhrten Extender
		werden als GEM-Programme, d.h. nicht direkt, sondern ber die
		Shellfunktion gemexec gestartet. Siehe hierzu den Abschnitt
		ber gemexec in commands.doc. Kann beliebig ver„ndert werden.
		Wie in commands.doc erkl„rt, mssen die Extender nicht unbe-
		dingt denen von ausfhrbaren Programmdateien entsprechen.
		Die Defaulteinstellung ist .prg .
PATH		Eine Liste von durch Kommata oder Semikolons getrennten Pfaden.
		Bei der Eingabe eines externen Kommandos ohne vollst„ndige
		Pfadan gabe wird die Datei auf den hier angegebenen Pfaden
		gesucht.
		Die Defaulteinstellung ist ".,..,$HOME,$HOME\bin". Kann be-
		liebg ver„ndert werden.
CDPATH		Eine Liste von durch Kommata oder Semikolons getrennten
		Pfaden. Beim Wechsel des aktuellen Arbeitsverzeichnisses
		mit "cd" wird, wenn der bei cd angegebene Pfad nicht existiert
		und nicht absolut angegeben ist, auf den in CDPATH gespei-
		cherten Pfaden gesucht.
		Die Defaulteinstellung ist "..,\". Kann beliebig ver„ndert
		werden.
HELPFILE	Der Name der Datei, aus der die Erkl„rungen, die bei Druck
		auf die Help-Taste ausgegeben werden, stehen. Die Default-
		einstellung ist "$HOME\doc\commands.doc". Kann beliebig ver-
		„ndert werden.
CLIPDIR		Enth„lt den Pfad des GEM-Clipboards. Wird durch die Kommandos
		gon und clipb initalisiert, die Voreinstellung bei Programm-
		start lautet "X:\scrapdir\scrap.*", wobei X: das Bootlaufwerk
		ist. Diese Shellvariable sollte nur mit dem Kommando clipb
		ver„ndert werden. Siehe hierzu auch commands.doc.
0		Enth„lt bei Eingabe eines Kommandos den Namen des Kommandos
		und beim automatischen Aufruf der Funktion gemexec den voll-
		st„ndigen Pfad des aufzurufenden Programms.
1		Enth„lt den ersten Parameter der Eingabezeile.
2		Enth„lt den zweiten Parameter der Eingabezeile usw.
#		Enth„lt die Anzahl der Parameter der Eingabezeile.
*		Enth„lt die vollst„ndige Eingabezeile.
?		Enth„lt den Rckgabewert des zuletzt ausgefhrten Kommandos.

Die folgenden Shellvariablen werden nur von einzelnen internen Kommandos
benutzt.

COLUMNS 	von `scr': Anzahl der Zeilen auf dem Bildschirm.
DIALPREFIX	fr `dial': Pr„fix des Modem-W„hlkommandos.


Nach dem Start der Shell werden Variablendefinitionen aus dem Environment
gelesen und ausgefhrt. Auf diese Weise k”nnen alle Variablen (auch LOGNAME
usw.) ge„ndert, aber keine gel”scht werden.

----------------------------------------------------------------------------
EIN/AUSGABE-UMLEITUNG

1) Fr interne Kommandos

Die Eingabe, Ausgabe und Fehlerausgabe jedes internen Kommandos kann auf
einfache Weise in bzw. aus einer beliebigen Datei oder zu bzw. von einem
Ger„t umgeleitet werden.

Folgende Umleitungsm”glichkeiten stehen zur Verfgung:

< Datei 		Umleitung der Eingabe
> Datei 		Umleitung der Ausgabe, die Datei wird vorher gel”scht
>> Datei		Anh„ngen der Ausgabe an die Datei
2> Datei		Umleitung der Fehlerausgabe, die Datei wird vorher
			gel”scht
2>> Datei		Anh„ngen der Fehlerausgabe an die Datei


Anstelle von "Datei" k”nnen auch die folgenden Ger„te angegeben sein:

	CON:		Konsole (Default)
	PRT:		parallele Schnittstelle (Drucker)
	AUX:		serielle RS232-Schnittstelle (Modem)
	NULL:		ignorieren

Das Ger„t NULL:, auch Null-Ger„t genannt (in Unix: /dev/null), wird nicht
vom Betriebssystem des ST untersttzt, sondern von der Shell simuliert.
Der Zweck eines Null-Ger„tes ist, die Ausgabe oder Fehlerausgabe eines
Kommandos zu unterdrcken. Die Shell-Variable NULL gibt an, wo die
Ausgabe, die an NULL: umgeleitet wird, tats„chlich landen soll. Normaler-
weise ist das die Druckerschnittstelle; wenn diese von einem Drucker belegt
ist, sollte man eine Datei z.B. auf der Ramdisk angeben (NULL=G:/null).

Beispiel:
	rm *.dup
l”scht s„mtliche dup-Dateien, gibt aber eine Fehlermeldung aus, wenn keine
solchen Dateien vorhanden sind oder wenn sie schreibgeschtzt sind.
Um die Fehlermeldung zu unterdrcken, kann man stattdessen schreiben:
	rm *.dup 2>NULL:
Dadurch werden die Fehlermeldungen an das Null-Ger„t geleitet.
(Nebenbei: bei Verwendung von
	rm -f *.dup
werden auch keine Fehlermeldungen ausgegeben, allerdings werden damit auch
schreibgeschtzte Dateien gel”scht.)


Wenn keine Umleitung angegeben ist, geht die Eingabe von der Tastatur
und die Ausgabe und Fehlerausgabe zum Bildschirm, genauer gesagt zu der
Standard-Ein- und -Ausgabe der Shell selber (die beim Start von sh.ttp
angegeben werden kann).


Pipelining

Die Idee des Pipelining ist es, die Ausgabe eines Kommandos zur Eingabe
des n„chsten zu machen. So schreibt z.B. das memex-Kommando einen Speicher-
bereich auf seine Ausgabe, und das hd-Kommando fertigt von seiner Eingabe
ein Hexdump an. Mit dem Pipelining k”nnen beide Kommandos verbunden werden,
d.h. man bekommt ein Hexdump eines Speicherauszuges.
Um zwei Kommandos in einer Pipeline zu verbinden, wird zwischen sie ein senk-
rechter Strich (|), auch Pipe genannt, gesetzt, z.B.:
	hd sh.ttp | pg
Die Ausgabe des hd-Kommandos (ein langer Hexdump) wird zur Eingabe des pg-
Kommandos, wodurch der Hexdump seitenweise angezeigt wird.
Die Schreibweise a | b ist „quivalent zu: (a und b sind beliebige Kommandos
incl. ihren Parametern)

	TMP=$PIPDIR\pip$$
	a > $TMP
	chmod +h $TMP
	b < $TMP
	rm $TMP
	unset TMP

(mit drei kleinen Unterschieden: 1) zum Bilden eines eindeutigen Dateinamens
wird nicht $$, sondern ein anderer Z„hler benutzt, 2) die Datei wird nach dem
Anlegen und nicht erst nach dem Ende von a unsichtbar gemacht und 3) es wird
keine Shellvariable benutzt.)
Dies ist ein wesentlicher Unterschied zu Unix, wo alle an einer Pipe be-
teiligten Kommandos (Prozesse) gleichzeitig laufen. Eine Pipeline ist
unter Unix eine Einrichtung des Betriebssystems, die von der Okami-Shell
nur simuliert wird. (Wie gesagt, Okami ist eine Shell und kein Betriebs-
system.)

Das Laufwerk und der Ordner, auf dem die Pipe-Dateien erzeugt werden, kann
mit der Shellvariablen PIPDIR eingestellt werden. Die Default-Einstellung
beim Start der Shell ist $HOME. Dadurch bietet sich die M”glichkeit, die
Pipe-Dateien auf ein schnelles Laufwerk zu legen, z.B. auf eine Ramdisk
oder eine wenig benutzte Partition der Festplatte.
VORSICHT: Wenn $PIPDIR auf einen nicht existierenden Ordner oder Laufwerk
eingestellt ist, erscheinen anstelle von Pipe-Operationen nur Fehlermel-
dungen der Form:
	Error: cannot open .....\pip3
(Anstelle von ...... steht der Inhalt von PIPDIR.)
In diesem Fall wird keins der an einer Pipe beteiligten Kommandos ausge-
fhrt.
Abhilfe schafft das Kommando
	mkdir -r $PIPDIR/
im Profile nach dem Einstellen von PIPDIR. Dadurch werden alle zu
$PIPDIR geh”renden Unterverzeichnisse erzeugt.

Die Pipe-Datei kann mit folgendem Kommando sichtbar gemacht werden:
	ls -a $PIPDIR\pip* | cat


Inline-Dokumente

Als Inline- oder Hier-Dokument wird eine spezielle Art der Eingabeumleitung
bezeichnet, bei der die einem Kommando zuzufhrende Eingabe direkt von der
Eingabe oder z.B. dem Shellscript stammt. Beispiel:

	cat <<eof
	Das ist ein Text, der
	zu der Eingabe des cat-
	Kommandos wird.
	eof

Diese Zeilen k”nnen von der Tastatur eingegeben, aber auch in einem Shell-
script oder einer Shellfunktion stehen.
Die Shell betrachtet die Zeichenkette nach "<<" als Terminierungsstring und
schreibt die nachfolgenden Zeilen in eine Datei, die dann als Eingabe des
Kommandos benutzt wird. Das Inline-Dokument wird durch eine Zeile beendet,
die nur (bis auf fhrende Leerzeichen) aus dem Terminierungsstring be-
steht.
Wenn den << direkt ein Minuszeichen folgt, also z.B.
	cat <<-eof
, werden alle fhrenden Leerzeichen der Eingabezeilen entfernt. Das Minus-
Zeichen geh”rt nicht zu dem Terminierungsstring.
Die Shell fhrt auf allen eingelesenen Zeilen Variablensubstitutionen und
Command Substitution aus.

Inline-Dokumente sind sinnvoll in Shellscripts, die mehrzeilige Ausgaben
erzeugen sollen, wodurch sich Reihen von echo-Kommandos vermeiden lassen.


2) Fr externe Kommandos

Theoretisch funktionieren s„mtliche Ein/Ausgabe-Umleitungen inklusive der
Pipeline auch mit externen Kommandos. In der Praxis jedoch erlauben nicht
alle Programme diese M”glichkeit, z.B weil sie Tastatur und Bildschirm direkt
ber die entsprechenden Bios-Funktionen (Bconout etc.) ansprechen, die sich
nicht umleiten lassen.
Die Okami-Shell leitet die Ein/Ausgabe auf Gemdos-Basis um, was bedeutet,
da alle Programme, die fr die Ein/Ausgabe Gemdos-Funktionen (Cconout etc.)
benutzen, umgeleitet werden k”nnen. C-Programme, die die Standard-Streams
stdin und stdout benutzen, werden normalerweise korrekt umgeleitet.
GEM-Programme sind von vornherein gegen jede Art der Umleitung immun, da sie
den Bildschirm ber den entsprechenden GEM-Ger„tetreiber ansprechen.

----------------------------------------------------------------------------
COMMAND SUBSTITUTION

Die Okami-Shell bietet die M”glichkeit, die Ausgabe eines Kommandos in eine
Kommandozeile einzubauen. M”chte man z.B. eine Ausgabe wie "Es sind ... Bytes
frei" erzeugen, in die die Anzahl der freien Bytes (die mit dem Kommando mem
ermittelt werden kann) eingebaut sind, dann kann die Ausgabe von mem auf fol-
gende Weise in das echo-Kommando eingebaut werden:

	echo Es sind `mem` Bytes frei.

Alles, was in einer Eingabezeile zwischen zwei Accent grave (`) steht, wird
als Kommando betrachtet und ausgefhrt. Die Ausgabe wird anstelle der in
Accent grave stehenden Zeichenkette in die Eingabezeile eingesetzt. Dieses
Verfahren wird als Command Substitution bezeichnet.
Wenn die Ausgabe des Kommandos ber mehrere Zeilen geht, wird nur die erste
Zeile (also die Ausgabe bis zum ersten Zeilenende) benutzt.
Als Zwischenspeicher fr die Ausgabe des Kommandos wird eine Datei namens
$PIPDIR/csubXXXX benutzt. XXXX ist hierbei eine laufende Nummer, und $PIPDIR
ist das Laufwerk, ber das auch die Pipelining-Operationen laufen. Diese Datei
wird nach Verwendung gel”scht.

Beispiele:
	Speichern der Shellflags:	SET=`set -`
	Wiederherstellen mit:		set $SET

	Anzeigen einer Datei, die in demselben Ordner liegt wie $FILE1, die
	aber denselben Basisnamen wie $FILE2 hat:
		cat `dirname $FILE1`/`basename $FILE2`

	L”schen der „ltesten Datei mit Nachfrage:
		rm -i `ls -t`

----------------------------------------------------------------------------
ENVIRONMENT

Die Okami-Shell bietet die M”glichkeit, Definitionen von Shell-Variablen
in das Environment zu bernehmen. Diese Definitionen werden dann allen
gestarteten Programmen bergeben. Mit dem internen Kommando export k”nnen
beliebige Shellvariablen in das Environment ausgenommen oder daraus ent-
fernt werden.

In der Basepage eines Programms steht ab Offset 0x2c die Adresse des
Environment-Strings. Diese Adresse wird berechnet als:
	char *BaseAdr;
	char *EnvAdr;
	EnvAdr = *(char **)(BaseAdr+0x2c);
BaseAdr ist die Adresse der Basepage (wird irgendwie vom Compiler zur Ver-
fgung gestellt). EnvAdr ist dann die Adresse des Environment-Strings.
Dieser String hat folgende Syntax: (EBNF, nicht C)

 EnvString	::=  { VarDefinition } "\0"
 VarDefinition	::=  VarName "=" VarWert "\0"
 
Beispiel:
	"a=Variable a\0b=Variable b\0usw=undsoweiter\0\0"
Es werden folgende Variablen gesetzt:
	a   auf  "Variable a"
	b   auf  "Variable b"
	usw auf  "undsoweiter"


----------------------------------------------------------------------------
GRšE

1) An die Firma GRP in Aachen, fr lebenswichtige Kenntnisse in C und Unix.

2) An Goofie Breuer, der mir fr einen Spottpreis zwei Zauberk„sten ver-
   h”kert hat, auf denen "Atari 400" und "Atari 800" steht

3) Fr die Begleitung in zahllosen Stunden voller Lust und Frust vor der
   flimmerfreien Flimmerkiste:
   Mike Oldfield, Little Richard, Bill Haley, Tommy Roe, Lesley Gore, Pat
   Boone, Elvis Presley, Chuck Berry, Del Shannon, Chris Montez, Billy Joe
   Royal, The Box Tops, The Cascades, Trini Lopez, Chris Andrews, Mary Hopkins,
   The Tremoloes, Bobby Vee, The Kinks, The Turtles, The Swinging Blue Jeans,
   Shane Fenton & The Fentones, The Piltdown Men, Helen Shapiro, Cliff Richard,
   The Cowsills, Jerry Lee Lewis, Melanie, Buddy Hollie, The Lovin' Spoonful,
   The Crystals, The Knickerbockers, The Crests, Every Mother's Son, The
   Shangri Las, Bernard Cribbins, The Shadows, Frank Ilfield u.v.a.
   und natrlich The Beatles.
