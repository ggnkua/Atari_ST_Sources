;/*	LONGASM.A86	2/3/84 - 10/09/84	Lee Jay Lorenzen	*/
;/*     for Lattice C ==>  AX=HI, BX=LO
;
;/*
;*       Copyright 1999, Caldera Thin Clients, Inc.                      
;*       This software is licenced under the GNU Public License.         
;*       Please see LICENSE.TXT for further information.                 
;*                                                                       
;*                  Historical Copyright                                 
;*	-------------------------------------------------------------
;*	GEM Desktop					  Version 2.1
;*	Serial No.  XXXX-0000-654321		  All Rights Reserved
;*	Copyright (C) 1985, 1986		Digital Research Inc.
;*	-------------------------------------------------------------
;*/
;
	cseg
;
	PUBLIC	HW
	PUBLIC	LHIWD
	PUBLIC	LSTCPY
	PUBLIC	LSTRLEN
;	PUBLIC	ADDR
	PUBLIC	LLDS
	PUBLIC	LLCS
	PUBLIC	LLSS 
	PUBLIC	LWCOPY
	PUBLIC	LBCOPY
;	PUBLIC	LBGET
;	PUBLIC	LBSET
;	PUBLIC	LWGET
;	PUBLIC	LWSET
;	PUBLIC	LLGET
;	PUBLIC	LLSET
	PUBLIC	LBWMOV
;
;		LONG
;	HW(WORD)	
;						/* coerce short word to	*/
;						/*   high word  of long	*/
HW:
	push	bp
	mov	bp,sp
	mov	ax,4[bp]		; get value into segment reg
	xor 	bx,bx			; clear offset reg
	pop	bp
	cld
	ret

;		WORD
;	LHIWD(LONG)
;						/* return high word of	*/
;						/*   a long value	*/
LHIWD:
	push	bp
	mov	bp,sp
;	mov	ax,4[bp]		; get offset
	mov	ax,6[bp]		; get segment
	pop	bp
	cld
	ret

;		WORD
;	LSTRLEN(long_addr)
;
LSTRLEN:
	push	bp
	mov	bp,sp
	push	ds
	mov	bx,4[bp]
	mov	ax,6[bp]
	mov	ds,ax
	sub	cx,cx
slagain:
	cmp	byte ptr [bx],0
	jz	sldone
	inc	bx
	jmps	slagain
sldone:
	mov	ax,bx
	mov	bx,4[bp]
	sub	ax,bx
	pop	ds
	pop	bp
	cld
	ret
;
;	copy from src to dest until and including a null in the 
;	source string
;
;	len = LSTCPY(pdstoff, pdstseg, psrcoff, psrcseg)
;
LSTCPY:
	push	bp
	mov	bp,sp
	push	ds
	cld			; assume forward
	les	di,4[bp]	; dest off & seg
	lds	si,8[bp]	; src off & seg
	mov	cx,0		; count
	mov	ah,0
lsc_loop:
	lodsb
	cmp	al,0
	je	lsc_done
	inc	cx
	stosb
	jmp	lsc_loop
lsc_done:
	stosb
	mov	ax,cx
	pop	ds
	pop	bp
	cld
	ret
;
;		LONG
;	ADDR(shrt_addr)
;
;ADDR:
;	push	bp
;	mov	bp,sp
;	mov	bx,4[bp]
;	mov	ax,ds
;	pop	bp
;	cld
;	ret
;
;		LONG
;	LLDS()
;
;
LLDS:
	push bp
	mov bp,sp
	sub bx,bx
	mov ax,ds
	pop bp
	cld
	ret
;
;		LONG
;	LLCS()
;
;
LLCS:
	push bp
	mov bp,sp
	sub bx,bx
	mov ax,cs
	pop bp
	cld
	ret
;
;		LONG
;	LLSS()
;
;
LLSS:
	push bp
	mov bp,sp
	sub bx,bx
	mov ax,ss
	pop bp
	cld
	ret
;
;	LWCOPY(pdstoff, pdstseg, psrcoff, psrcseg, numwds)
;
;
LWCOPY:
	push bp
	mov bp,sp
	push di ! push si
	mov di,4[bp]		; dest off
	mov bx,6[bp]		; dest seg
	mov si,8[bp]		; src off
	mov dx,10[bp]		; src seg
	mov cx,12[bp]		; count
	cld			; assume forward
	cmp bx,dx		; if !same seg
	jne lwcopy_mov		;     then dont worry about overlap
	cmp si,di		; if src offs < dest offs
				;     then start from end and go back
				; else normal
	ja lwcopy_mov
	  mov ax,cx
	  shl ax,1
	  add si,ax
	  sub si,2
	  add di,ax
	  sub di,2
	  std			;  go backwards
lwcopy_mov:
	push ds ! push es
	mov ds,dx		; src
	mov es,bx		; dest
	rep movsw
	pop es ! pop ds

	lea sp,-4[bp]
	pop si ! pop di
	pop bp
	cld
	ret
;
;
;	LBCOPY(pdstoff, pdstseg, psrcoff, psrcseg, numbytes)
;
;
LBCOPY:
	push bp
	mov bp,sp
	push di ! push si
	mov di,4[bp]		; dest off
	mov bx,6[bp]		; dest seg
	mov si,8[bp]		; src off
	mov dx,10[bp]		; src seg
	mov cx,12[bp]		; count
	cld			; assume forward
	cmp bx,dx		; if !same seg
	jne lbcopy_mov		;     then dont worry about overlap
	cmp si,di		; if src offs < dest offs
				;     then start from end and go back
				; else normal
	ja lbcopy_mov
	  add si,cx
	  dec si
	  add di,cx
	  dec di
	  std			;  go backwards
lbcopy_mov:
	push ds ! push es
	mov ds,dx		; src
	mov es,bx		; dest
	rep movsb
	pop es ! pop ds

	lea sp,-4[bp]
	pop si ! pop di
	pop bp
	cld
	ret
;
;	expand from bytes to words until you hit a null also return
;	the number of characters moved
;
;	LBWMOV(pdstoff, pdstseg, psrcoff, psrcseg)
;
;
LBWMOV:
	push bp
	mov bp,sp
	push di ! push si
	mov di,4[bp]		; dest off
	mov bx,6[bp]		; dest seg
	mov si,8[bp]		; src off
	mov dx,10[bp]		; src seg
	mov cx,0		; count
	cld			; assume forward
lbw_mov:
	push ds ! push es
	mov ds,dx		; src
	mov es,bx		; dest
	mov ah,0
lbw_loop:
	lodsb
	cmp al,0
	je lbw_done
	inc cx
	stosw
	jmp lbw_loop
lbw_done:
	pop es ! pop ds
	

	lea sp,-4[bp]
	pop si ! pop di
	pop bp
	mov	ax,cx
	cld
	ret
;
;		UBYTE
;	LBGET(lp)
;		LONG		p;
;
;LBGET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	sub	ax,ax
;	mov	al,es:[bx]
;	pop	es
;	pop	bp
;	cld
;	ret
;
;		UBYTE
;	LBSET(lp, abyte)
;		LONG		p;
;		BYTE		abyte;
;
;LBSET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	mov	ax,8[bp]
;	mov	es:[bx],al
;	xor	ah,ah
;	pop	es
;	pop	bp
;	cld
;	ret
;
;		UWORD
;	LWGET(lp)
;		LONG		p;
;
;LWGET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	mov	ax,es:[bx]
;	pop	es
;	pop	bp
;	cld
;	ret
;
;		UWORD
;	LWSET(lp, aword)
;		LONG		p;
;		WORD		aword;
;
;LWSET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	mov	ax,8[bp]
;	mov	es:[bx],ax
;	pop	es
;	pop	bp
;	cld
;	ret
;
;		ULONG
;	LLGET(lp)
;		LONG		p;
;
;LLGET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	mov	ax,es:[bx]
;	inc	bx
;	inc	bx
;	mov	bx,es:[bx]
;	xchg	ax,bx
;	pop	es
;	pop	bp
;	cld
;	ret
;
;		ULONG
;	LLSET(lp, along)
;		LONG		p;
;		LONG		along;
;
;LLSET:
;	push	bp
;	mov	bp,sp
;	push	es
;	les	bx,4[bp]
;	mov	ax,8[bp]
;	mov	es:[bx],ax
;	inc	bx
;	inc	bx
;	mov	cx,10[bp]
;	mov	es:[bx],cx
;	xchg	ax,cx
;	pop	es
;	pop	bp
;	cld
;	ret
 

	end

