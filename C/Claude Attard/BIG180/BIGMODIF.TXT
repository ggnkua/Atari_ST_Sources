   Modifications de BIG : nouveaut‚s de la version 1.07 (28/10/93)

Ce  document  concerne  les changements apport‚s …  le  librairie  BIG 
depuis la version 1.05 (la version 1.06 ‚tait une version beta qui n'a 
pas ‚t‚ diffus‚e). Si vous d‚couvrez BIG vous pouvez vous dispenser de 
sa lecture, pour passer directement … la doc complŠte. Mais si vous le 
connaissez d‚j…,  vous prendrez connaissance des modifications et  des 
ajouts qui ont ‚t‚ effectu‚s.
Les modifications ‚tant d‚crites ici de maniŠre succinte,  elles  sont 
accompagn‚es de renvois … la doc principale qui indiquent le num‚ro de 
la  page  (avec  63  lignes par  page).  Vous  pourrez  ainsi  trouver 
directement   les  explications  d‚taill‚es  qui   vous   int‚ressent. 
Toutefois,   je  vous  conseille  de  relire  le   manuel,   certaines 
explications ayant ‚t‚ reformul‚es pour plus de clart‚ (et pas mal  de 
fautes ayant ‚t‚ corrig‚es).
Certains  d'entre vous reconnaŒtront au passage des nouveaut‚s ou  des 
changements qu'ils m'ont sugg‚r‚s. Merci de votre appui.

>>>>>   Bugs corrig‚s   <<<<<
* BIG fonctionne d‚sormais sous MultiTOS sans problŠmes.
* Supprim‚ 2 bugs des menus hi‚rarchiques en fenˆtre :
  - Quand  on passe "au-dessus" de l'option,  le titre …  pr‚sent  est 
    remis en "normal".
  - Quand  on passe … une autre option du menu sans ˆtre pass‚ par  le 
    hi‚rarchique, il se referme.
* Dans la recherche de raccourcis clavier dans un menu hi‚rarchique de 
menu en fenˆtre,  il y avait un bug qui faisait rechercher le titre du 
menu  de  l'option  B_HIERM … partir de l'adresse  du  menu  principal 
(adr_menu) au lieu de l'adresse du menu de fenˆtre.
* Supprim‚  bug dans le redraw des fenˆtres images avec menu  :  il  y 
avait  un d‚calage si la zone … redessiner ‚tait … cheval sur le  menu 
et la zone de travail.
* Une  impr‚cision a ‚t‚ corrig‚e :  Lorsqu'on clique sur un objet  de 
formulaire, et que le curseur de la souris est d‚plac‚ hors de l'objet 
avant que le bouton soit relƒch‚, l'objet n'est plus activ‚.
* Bug corrig‚ dans les formules de calcul de WM_HSLID et WM_VSLID.
* Si  un  pop-up  de formulaire en fenˆtre  d‚bordait  sur  une  autre 
fenˆtre d'arriŠre-plan,  et qu'on cliquait … cet endroit,  la  fenˆtre 
d'arriŠre-plan ‚tait amen‚e en premier. Ce n'est plus le cas.
* Bug  supprim‚  dans  la  gestion des  menus  hi‚rarchiques  du  menu 
principal  :  Lorsqu'on faisait rapidement "tourner" la  souris  entre 
l'option du menu hi‚rarchique,  le hi‚rarchique et une autre option de 
menu, une des options du hi‚rarchique ‚tait parfois consid‚r‚e cliqu‚e 
lors du retour dans la zone du menu lui-mˆme. Ce n'est plus le cas.
* Sous MultiTOS,  si on faisait un clic droit sans fenˆtre ouverte, il 
n'‚tait pas trait‚.
* La  fonction  Malloc()  du  GEMDOS ‚tant  peu  fiable,  elle  a  ‚t‚ 
remplac‚e par malloc() du C. Mfree() a ‚t‚ remplac‚e par free().

>>>>>   Modifications   <<<<<
* Raccourcis clavier "directs" (sans Control, Shift ou Alternate) dans 
les  menus  supprim‚s  pour ‚viter  des  conflits  avec  d'‚ventuelles 
options du style "Texte 1".
* Les  raccourcis clavier dans les boutons sont comme  avant  signal‚s 
par le soulignement du caractŠre,  mais celui-ci est de plus ‚crit  en 
rouge.
* Dans les fenˆtres avec menus, deux modifs :
  - Le menu est d‚sormais dessin‚ AVANT la zone de travail.
  - Si  c'est  une fenˆtre image vide (la zone de  travail  est  alors 
    "vid‚e"  par un v_bar blanc),  la partie du menu n'est pas  vid‚e, 
    elle est simplement recouverte par le menu.
* Modif  de  la  boŒte  d'infos de la  d‚mo  :  le  "Contact"  et  les 
"Remerciements"  sont  s‚par‚s en deux  B_HELPs.  "Contact"  ‚tant  en 
premier, il est activ‚ par la touche Help, pas l'autre. (page 5)
* La  gestion du timer a ‚t‚ modifi‚e dans la fonction  dialog()  pour 
fonctionner  correctement sous MultiTOS.  Trois  op‚rations  utilisent 
l'‚v‚nement  MU_TIMER :  le clic sur le bouton droit,  la  palette  de 
couleurs et les menus hi‚rarchiques. D‚sormais, au lieu d'effectuer le 
traitement dans le corps de la condition "if (event == MU_TIMER)", des 
flags sont positionn‚s et le traitement est fait aprŠs.
* Suite  …  une  s‚rie  de bugs affectant  les  fonctions  XBIOS  sous 
MultiTOS,  les  palettes  de couleurs ne sont plus  trait‚es  par  les 
fonctions Setpalette (Xbios $06) et Setcolor (Xbios $07), mais par les 
fonctions  VDI  vq_color (VDI 26) et vs_color (VDI  14).  La  variable 
"palette"  est  chang‚e.  C'est  d‚sormais un  pointeur  sur  le  type 
"Palette", d‚fini par "typedef int Palette[3]". (page 26)
* Pour ‚viter des conflits de noms qui pourraient se produire avec les 
bindings du nouvel AES,  la structure "Window" est renomm‚e "BigWind". 
(pages 25 et 26)
* Nouvel ‚l‚ment de la structure BigWind : "int w_icon;". Egal … BLANK 
si  la fenˆtre n'est pas ic“nifi‚e,  … l'index de fenˆtre associ‚e  si 
elle l'est.  Si elle est ic“nifi‚e seule,  c'est son propre index,  si 
c'est un "ALLICONIFY",  c'est l'index de la fenˆtre qui "contient" les 
autres. (page 27)
* Autre nouvel ‚l‚ment : "FNCP w_redicn;" pointeur sur une fonction de 
redraw qui sera utilis‚e si la fenˆtre est ic“nis‚e. Si ZERO, c'est la 
routine  "normale"  qui  est utilis‚e  mˆme  en  cas  d'ic“nification. 
(page 27)
* Pour simplifier,  les ‚l‚ments w_xcurr,  w_ycurr, w_wcurr et w_hcurr 
de la structure BigWind sont remplac‚s par une sous-structure  d‚finie 
par "GRECT w_curr;". (page 25)
* Pour  enregistrer la position et les attributs de la  fenˆtre  avant 
ic“nification,  un nouvel ‚l‚ment est apparu :  "Oldw w_old". La sous-
structure Oldw est d‚finie ainsi:
typedef struct oldw {
  GRECT   w_coord;    /* Anciennes coordonnees */
  int     w_att;      /* Anciens attributs */
} Oldw;
(pages 24 et 25)
* Le flag de fenˆtre BIG "WLAST" est renomm‚ "WFLAST", pour ressembler 
aux autres ! (page 27)
* Nouveau paramŠtre dans l'appel de fonction initial() : "int acc".
Le prototypage devient :
int initial (char *rsc, int menu, int desk, int nb_tree,
             OBJECT *rs_tree, char *rs_str, int n_wind, int acc);
Ce paramŠtre repr‚sente l'index dans le ressource de la chaŒne libre … 
utiliser  par la fonction menu_register() si l'application est  lanc‚e 
comme accessoire (nom de l'accessoire dans le menu Bureau).  Ignor‚ si 
c'est un programme, on peut transmettre "-1". (page 35)
* Le  d‚mo  fonctionne d‚sormais en PRG ou en  ACC,  en  renommant  le 
fichier,   avec  ressource  int‚gr‚  ou  non  (4   combinaisons).   En 
accessoire,  il n'y a pas de gestion du "bureau" pour  simplifier,  le 
menu apparaŒt dans une fenˆtre avec menu (WINDACC). (page 13)
* La  fenˆtre "Texte" de la d‚mo possŠde une ToolBar avec des  radios-
boutons,  deux pop-ups et un s‚lectable. Le texte peut ˆtre affich‚ en 
utilisant  des  fontes SpeedoGDOS.  La toolbar permet  de  choisir  la 
fonte,  la taille et d'autres paramŠtres de pr‚sentation. Les routines 
d'affichage  de la d‚mo ne gŠrent pas totalement les  contraintes  des 
polices  proportionnelles,  des impr‚cisions peuvent ˆtre  constat‚es. 
(page 10)
* Il  est  d‚sormais  possible  de caler  la  position  d'une  fenˆtre 
WTYP_IMAG sur des pixels multiples de 16.
* Il n'est plus obligatoire pour une application d'avoir un bureau  et 
une barre de menu.  Si on d‚sire qu'un de ces ‚l‚ments soit absent, il 
faut  transmettre  BLANK comme paramŠtre correspondant …  la  fonction 
initial().

>>>>>   Nouveaut‚s   <<<<<
* Raccourcis  clavier ajout‚s dans les boutons normaux.  Nouveau  type 
‚tendu :  B_UNDER (30), le caractŠre soulign‚ est pr‚c‚d‚ de '[' comme 
d'habitude.  Le type ‚tendu B_UNDO (31) est suppos‚ avoir un caractŠre 
soulign‚.  La fonction teste s'il y en a bien un.  Le type B_UNDER est 
donc  automatique  pour  les B_UNDO,  il doit ˆtre  pr‚cis‚  pour  les 
B_DEFAULT,  et  peut  ˆtre  mis pour n'importe  quel  type  de  bouton 
ordinaire,  sauf bien s–r ceux qui sont d‚j… B_FNCP,  puisque le  type 
‚tendu est d‚j… utilis‚. (pages 14 et 15)
* Trois nouvelles variables globales :
int n_colors;     Nbre de couleurs affichables. (page 31)
char multitos;    Flag  (TRUE  /  FALSE)  indiquant  si  on  est  sous 
                  environnement multitƒche. (page 31)
int vaes;         Nø de version de l'AES (… tester en hexa, c'est plus 
                  simple). (page 31)
* Des fonctions Cookie ont ‚t‚ ajout‚es.
Voici la structure COOKIE : (page 34)
typedef struct
{
  long ident;  /* Identificateur du Cookie */
  union
  {
    long l;    /* Si la data est un long */
    int i[2];  /* Si la data est deux mots */
    char c[4]; /* Si la data est quatre octets */
  } datack;
} COOKIE;
Voici les trois nouvelles fonctions : (page 42)
COOKIE *first_cookie (void);  /* Le premier cookie */
Retourne un pointeur sur le premier cookie.
COOKIE *next_cookie (COOKIE *ck); /* Cookie suivant */
A  utiliser  avec  first_cookie.  Re‡oit un  pointeur  sur  le  cookie 
pr‚c‚dent, retourne le suivant.
COOKIE *vq_cookie (long id);  /* Cherche un cookie par id */
Re‡oit  sous  forme  de long l'identificateur du  cookie  …  chercher, 
retourne  un pointeur sur ce cookie s'il est trouv‚,  un pointeur  nul 
sinon.
COOKIE *vq_cookie_c (char *c);     /* Cherche un cookie par chaŒne */
Comme  la  pr‚c‚dente,  mais  la recherche se fait par  la  chaŒne  de 
caractŠres de l'identificateur. (page 43)
* Un programme utilisant BIG est par d‚finition un programme sous GEM, 
qui  ne  peut  donc pas ˆtre lanc‚  du  dossier  AUTO.  D‚sormais,  la 
fonction   initial()  effectue  un  test  avant  toute  chose  et   si 
l'application est lanc‚e pendant le boot (AES pas encore install‚), un 
message est affich‚ et une pression de touche est attendue. Le message 
fait partie du ressource inclus. (page 13)
* La gestion de l'ic“nification des fenˆtres … ‚t‚ ajout‚e. (pages 12, 
33 et 60)
Note :  la  version  de  GEM.SYS accompagnant Mint 1.07b  a  des  bugs 
affectant le comportement des fonctions d'ic“nisation des fenˆtres. Le 
bit correspondant au bouton "SMALLER" ‚tait 0x1000. L'AES accompagnant 
Mint 1.08b porte le mˆme num‚ro 4.10,  mais ces bugs ont ‚t‚ corrig‚s. 
Le bit SMALLER est d‚sormais 0x4000.
Les  raccourcis clavier de fenˆtres et les changements de forme de  la 
souris ou de palette sont sans effet sur une fenˆtre ic“nis‚e.
Sous AES >= 4.10 :
  - Ic“nification par clic sur le SMALLER (message WM_ICONIFY), ou par 
    <Control+Esc>.  Utilisation  de la fonction  wind_set(WF_ICONIFY). 
    Par raccourci clavier,  les calculs de coordonn‚es de l'ic“ne sont 
    fait "… la main".
  - D‚sic“nification    par   double-clic   sur    l'ic“ne    (message 
    WM_UNICONIFY),  ou par <Control+Esc>.  Utilisation de la  fonction 
    wind_set(WF_UNICONIFY).  Par  raccourci clavier,  les  calculs  de 
    coordonn‚es de la fenˆtre sont fait "… la main".
  - All  ic“nification  par  <Control+Clic> sur  le  SMALLER  (message 
    WM_ALLICONIFY). Utilisation d'une fonction qui ic“nifie la fenˆtre 
    cliqu‚e et qui ferme les autres.  Chaque "all ic“ne" contient  les 
    fenˆtres  qui ‚taient ouvertes au moment de son ic“nification  (il 
    peut donc y avoir plusieurs "all ic“nes" pour un mˆme programme).
Sous AES < 4.10
  Idem,  mais  le clic sur le SMALLER est remplac‚ par un  clic  droit 
  dans la barre de titre de la fenˆtre, ou un <Control+Clic droit>. La 
  fonction wind_set ne peut ˆtre utilis‚e, tout est fait "… la main".
Nouveaux  paramŠtres  dans  les  appels  des  fonctions  open_window() 
(page 44) et formw_draw() (page 43) :  "FNCP ricn".  Il repr‚sente  un 
pointeur  sur  la fonction … ex‚cuter si le redraw de la  fenˆtre  est 
demand‚,  et qu'elle est ic“nifi‚e.  Transmettre ZERO si on ne  d‚sire 
pas qu'il y ait un redraw particulier dans ce cas.
* Ajout  des scrolls-menus dans les pop-ups,  les menus  hi‚rarchiques 
(de menu principal ou de menu en fenˆtre), et dans les pop-ups libres. 
(pages 8, 9 et 21)
Si le bureau n'est pas assez haut,  la mise en scroll est automatique. 
Un tel menu doit ˆtre construit de la maniŠre suivante :
  - Etre constitu‚ uniquement de G_STRINGs hautes d'un caractŠre.
  - Les num‚ros de ces objets doivent se suivrent de haut en bas.
Dans le cas des pop-ups :
  - Le scroll menu est plac‚ sous le bouton d'appel, s'il y a la place 
    pour au moins 4 options plus les deux flŠches. Sinon, il est plac‚ 
    au-dessus, … partir du haut du bureau.
  - Si  aucune  option ne correspond au texte du  bouton  d'appel,  la 
    premiŠre option du scroll est la premiŠre option du pop-up. Sinon, 
    elle  est check‚e (comme en pop-up normal) et plac‚e  en  premiŠre 
    position  dans le scroll,  … moins que ce soit une  des  derniŠres 
    (option  check‚e + nbre d'options affich‚es > nbre d'options  dans 
    le pop-up).  Dans ce cas,  elle est d‚cal‚e mais apparaŒtra  quand 
    mˆme dans les options visibles dŠs l'affichage.
  - Le  bouton d'appel est un G_BUTTON et doit avoir une hauteur  d'un 
    caractŠre.
Dans  les autres types de scrolls,  la premiŠre option du  pop-up  est 
toujours pr‚sent‚e en premier dans le scroll.
* Ajout  des  pop-listes.  Il s'agit d'un pop-up toujours limit‚  …  8 
options,  dot‚ d'un ascenseur complet … droite des options.  Le bouton 
d'appel  est un B_LIST :  c'est un B_BUTTON SELECTABLE SHADOW avec  le 
type ‚tendu 23.  (Il y a donc un nouveau type ‚tendu :  #define B_LIST 
23). (pages 8, 9 et 18)
Le  bouton  d'appel doit avoir une hauteur d'un caractŠre.  S'il  y  a 
moins  de  9 options,  ce n'est pas une liste avec ascenseur  qui  est 
affich‚e,  mais un pop-up ordinaire.  Le d‚filement au moyen du slider 
se fait "en temp r‚el".
Les formulaires constituant la pop-liste doivent ˆtre construit  comme 
les pop-ups, avec les mˆmes contraintes. Essentiellement, il doit ˆtre 
constitu‚  de G_STRINGs hautes d'un caractŠre et dont les  num‚ros  se 
suivent de haut en bas.
* Les  boutons  pop-up  peuvent ˆtre de  deux  types  :  B_BUTTON  (ou 
G_IMAGE) SELECTABLE SHADOW ou avoir en plus le type ‚tendu B_POPUP (Il 
y a donc un nouveau type ‚tendu :  #define B_POPUP 22),  uniquement si 
se  sont  des  G_BUTTONs.  Dans le  premier  cas,  ils  sont  dessin‚s 
normalement.  Un  clic  d‚roule  le pop-up et un  shift-clic  passe  … 
l'option active suivante,  ou sur la premiŠre si on est au bout.  Dans 
le  second  cas,  une petite ic“ne "option suivante"  est  dessin‚e  … 
l'extr‚mit‚ droite du bouton. Un clic sur la partie principale d‚roule 
le  pop-up,  un  shift-clic ou un clic sur l'ic“ne  passe  …  l'option 
active suivante,  ou sur la premiŠre si on est au bout. Le bouton doit 
avoir  une  hauteur d'un caractŠre.  Les boutons de  type  B_LIST  ont 
toujours l'ic“ne "suivant". (pages 15 et 17)
* Ajout  des  TOOLBARs  (ou  TOOLBOXs).  Il  s'agit  d'un  formulaire, 
g‚n‚ralement  de petite taille,  plac‚ en haut de la zone  de  travail 
d'une fenˆtre,  sous la barre de nom,  ou la ligne d'infos s'il y en a 
une.  BIG force la largeur de la boŒte racine de ce formulaire sur  la 
largeur totale de la fenˆtre (win[index].w_wtot).  Ce formulaire  peut 
contenir tous les types d'objets, avec d'‚ventuels raccourcis clavier, 
la  gestion  en est faite automatiquement comme dans les  autres  cas. 
Toutefois,  des objets EXIT et TOUCHEXIT n'ont pas lieu de se  trouver 
dans ce contexte, pas plus que des champs ‚ditables. (pages 10 et 23)
La gestion des messages WM_xxLINE,  WM_xxPAGE et WM_xSLID tient compte 
de  la pr‚sence de la toolbar.  Le message WM_HSLID  n'entraŒne  aucun 
d‚calage  de  la position de la toolbar.  D'autre  part,  ce  type  de 
formulaire servant essentiellement … effectuer des choix concernant le 
contenu  de  la fenˆtre,  un nouveau type de message est  retourn‚  au 
programme principal en cas de clic sur un bouton radio, un s‚lectable, 
ou  un  pop-up  (ou  pop-liste),  mˆme si l'objet  n'est  pas  EXIT  : 
(page 30)
  BEV_TOOL (Big EVent TOOLbar)
  Un  bouton  a ‚t‚ cliqu‚ dans une fenˆtre  WTYP_TOOL.  Le  programme 
  re‡oit un ‚v‚nement MU_BUTTON.
  Mot 0 : BEV_TOOL (55).
  Mot 3 : Index BIG de la fenˆtre.
  Mot 4 : Num‚ro de l'objet cliqu‚.
Un  nouveau  bit  est utilis‚ dans l'‚l‚ment w_type  de  la  structure 
BigWind  (#define  WTYP_TOOL 0x4000).  Il indique la  pr‚sence  de  la 
toolbar.  Il ne peut y avoir … la fois un menu et une toolbar dans une 
fenˆtre.  L'‚l‚ment w_menu de la structure BigWind est renomm‚  w_bar, 
et  pointe selon le cas sur le menu ou le formulaire.  L'appel  de  la 
fonction open_window devient : (page 44)
int open_window (int index, int type, int attr,
                 int x, int y, int w, int h,
                 int wm, int hm, int wu, int hu,
                 int fa, int fb, int fmouse,
                 FNCP ricn, FNCP redr, FNCP clos,
                 char *title, char *info,
                 long wt, long ht,
                 int fmenu, int ftool, int bar, int intgr);
Le  paramŠtre  "ftool" est un flag signalant que "bar" est  le  num‚ro 
d'objet du formulaire toolbar.
La  fonction zone_work tient compte de la pr‚sence (ou de  l'abscence) 
de menu ou de toolbar dans la fenˆtre. (page 46)
* Ajout  de  la gestion des objets 3D.  Seul le bit  10  de  l'ob_flag 
‚tendu de l'AES >= 4 (bit BackGround) est utilis‚. Il y a une nouvelle 
d‚finition : "#define BKGR 0x400". (pages 20 et 48)
- Le  dessin  des objets de types B_RADIO et  B_COCHE  deviennent  des 
  G_ICONs  dans le ressource inclus de BIG,  afin de pouvoir  utiliser 
  leurs  masques  pour le dessin de l'objet sur un  fond  tram‚.  Leur 
  graphisme a ‚t‚ modifi‚ pour donner une impression de relief (sortis 
  en normal,  enfonc‚s si s‚lectionn‚s). Aucune pr‚cision … faire dans 
  le ressource. (page 20)
- Les  objets  B_FRAME  dont  le bit BackGround  n'est  pas  mis  sont 
  dessin‚s comme des rectangles blancs opaques. Si le bit est mit, ils 
  sont  dessin‚  comme  un rectangle transparent  (afin  que  le  fond 
  apparaŒsse … travers) et sont aggr‚ment‚s de lignes blanches donnant 
  une illusion de relief. (page 20)
- Les champs ‚ditables (B_EDIT ou non) dont le bit BackGround est  mit 
  sont forc‚s en G_FBOXTEX transparent (si c'‚tait un  G_FTEXT),  avec 
  les mˆmes attributs de trame et de couleur que la premiŠre G_BOX qui 
  pr‚cŠde le champ dans l'arborescence.  Les attributs de bordure  (si 
  c'‚tait d‚j… une G_FBOXTEXT) et de couleur de texte sont  conserv‚s. 
  Ainsi,  l'objet semble fusionner dans le fond et il est correctement 
  g‚r‚ par le GEM. (pages 20)
- Les B_POPUPs et les B_LISTs sont ‚galement dessin‚s en  transparents 
  si le bit est mit.  Ils sont aggr‚ment‚s de lignes blanches sur  les 
  c“t‚s  gauche et haut s'il ne sont pas s‚lectionn‚s,  sur les  c“t‚s 
  droit  et  bas s'il le sont.  L'ic“ne "suivant" possŠde  un  masque. 
  (page 20)
- Les B_UNDERs dont le bit est mit sont dessin‚s en  transparent.  Ils 
  sont ‚galement accompagn‚s de lignes blanches,  comme les  B_POPUPs. 
  Mˆme si on ne d‚sire pas leur affecter un raccourci clavier,  mettre 
  les  boutons  DEFAULT en B_UNDER (avec le bit BackGround)  pour  les 
  afficher en 3D. (page 20)
* Nouvelle fonction :
    int match (OBJECT *adr, int button, int intgr);
Cette fonction cherche s'il y a une correspondance entre le texte  (ou 
le motif d'image) d'un bouton pop-up ou pop-liste et un des objets  de 
son formulaire associ‚. (page 38)

         Modifications concernant la version 1.80 du 03/11/93

  Note :  Certaines modifications (et am‚liorations) ont ‚t‚ apport‚es 
par  les  soins  de Marc Abramson le  30/10/1993.  Elles  sont  toutes 
repertori‚es MA_30_10 dans les fichiers BIG.H et BIG.C. Je le remercie 
une fois de plus pour son intervention.

* Plusieurs  petits  bugs  mineurs et  impr‚cision  diverses  ont  ‚t‚ 
corrig‚s.

>>>>>   Modifications   <<<<<
* La  fonction  exist retourne FALSE si le fichier  n'existe  pas,  et 
retourne sa taille cod‚e sur un long s'il existe. (page 41)
* De nombreuses variables globales sont d‚sormais regroup‚es dans  des 
structures.  De  nouvelles  variables sont  apparues.  Ces  structures 
sont :

typedef struct
{
  t_machine la_machine;
  t_proc_graphique proc_graphique;
  t_cpu le_cpu;
  int v_aes;
  int v_tos;
  char multitache;
} t_ident_hard_soft;
  Cette  structure  contient  les informations  hard  sur  la  machine 
(page 31)
typedef struct t_display
{
  int handle;  /* Handle de la station de travail */
  int w;       /* Largeur de l'‚cran */
  int h;       /* Hauteur de l'‚cran */
  int hc;      /* Taille standard des caractŠres */
  t_resolution res; /* la resolution courante */
  int mode;    /* le mode courant si on est sur Falcon */
  char une_palette; /* FALSE: pas de palette TRUE : une palette */
  long    n_color_pal; /* nombre de couleurs affichables */
  long    n_color;  /* nombre de pinceaux disponibles simultan‚ment */
  int n_plane;      /* Nbre de plans de couleur */
  Palette *palette; /* pointeur vers la sauvegarde des pinceaux */
  int nb_bit_coul[3]; /* nombre de bit par couleur */
  int masque_coul[3]; /* masque pour les couleurs */
  void *phys;  /* Adresse physique de l'‚cran */
  void *log;   /* Adresse logique de l'‚cran */
} t_display;
  Cette  structure contient les informations relatives  …  l'affichage 
(page 31)
typedef struct t_desktop
{
  int xd, yd, wd, hd;
} t_desktop;
  Cette strcture contient les coordonn‚es du bureau. (page 32)
  Voici les d‚finitions accompagnant ces structures : (page 34)
typedef enum 
{
  ST,
  STE,
  TT,
  FALCON_030,
  AUTRE_MACHINE
} t_machine;

typedef enum
{
  PG_ST,
  PG_STE,
  PG_TT,
  PG_FALCON_030,
  AUTRE_PG,
} t_proc_graphique;

typedef enum
{       
  PROC_68000,
  PROC_68030,
  AUTRE_PROCESSEUR,
} t_cpu;

typedef enum
{
  ST_BASSE = 0,
  ST_MOYENNE = 1,
  ST_HAUTE = 2,
  VGA_16COL = 4,          /* le VGA TT */
  VGA_256COL = 5,         /* le VGA FALCON */
  R_256C_320_480 = 7,     /* le 320*480 16 col TT */
  TRUE_COLOR_320_480 = 8, /* le 320*480 Falcon sur VGA */
  INCONNU = -1            /* aucune r‚solution normalis‚e */
} t_resolution;

Pour conserver une compatibilit‚ avec la version 1.07 de BIG,  et  les 
anciens noms de variables, il faut d‚finir :
#define _COMPATIBLE_BIG_107_

* D‚sormais,  il  est  possible d'affecter une palette  de  couleur  … 
n'importe  quel  type  de  fenˆtre.   La  sous-structure  w_cont   est 
red‚finie : (pages 23 et 26)
typedef union cont { /* DEFINITION DU CONTENU D'UNE FENETRE */
  Form w_form; /* Si fenˆtre formulaire */
  MFDB w_img;  /* Si image */
  char *w_adr; /* Si texte ou autre adresse donn‚es */
} Cont;

Et  un nouvel ‚l‚ment est ajout‚ … la structure de base  (plac‚  entre 
w_cont et w_bar) :
  Palette *w_pal; /* Pointeur sur la palette de couleurs */
Cet ‚l‚ment est initialis‚ … ZERO. (pages 23 et 26)

* Le  paramŠtre "intgr" qui ‚tait transmis … de  nombreuses  fonctions 
est  remplac‚  par  une variable globale  "int  intgr".  Le  paramŠtre 
disparaŒt donc du prototypage de toutes les fonctions concern‚es.

>>>>>   Nouveaut‚s   <<<<<
* Nouvelle fonction Cookie :
COOKIE *vq_cookie_c (char *c);
Elle s'utilise comme vq_cookie(),  mais permet de rechercher un cookie 
par chaŒne de caractŠre plut“t que par identificateur. (page 43)

* Nouvelle fonction :
void set_popup (OBJECT *adr, int button, int option);
  Elle  permet de "fixer" le texte (ou le motif d'image) d'un  B_POPUP 
ou d'un B_POPLIST sur une des options de son pop-up associ‚. "adr" est 
l'adresse de l'arbre,  "button" le num‚ro du bouton pop-up et "option" 
le num‚ro de l'option dans son pop-up associ‚.  Cette fonction r‚alise 
l'inverse de la fonction match(). (page 38)

* D'autres  nouvelles  fonctions,  internes … BIG,  sont  apparues  en 
liaison  avec  les structures  t_ident_hard_soft  et  t_display,  afin 
de  rendre plus pr‚cis les enregistrements de paramŠtres au  lancement 
du programme et leur restauration en fin d'ex‚cution. La compatibilit‚ 
de BIG avec toutes les machines,  tous les ‚crans et toutes les cartes 
graphiques en est rendue plus fiable.
