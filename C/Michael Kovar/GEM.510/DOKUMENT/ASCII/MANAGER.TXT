





				D  e  r


		G  E  M  -  M  a  n  a  g  e  r







	                                                    

	  B e n u t z e r h a n d b u c h
	                                                    






Funktionsbibliotheken fr Mark Williams C

	   zur Untersttzung der GEM-Programmierung

























Wir weisen darauf hin, da wir fr Sch„den, die mittelbar oder unmittelbar aus dem Gebrauch des GEM-Managers entstehen, nicht haften.



         Michael Kovar          Volker Nawrath
      Waldmannstrae 17      Tirschenreuther Ring 72
       W-1000 Berlin 46        W-1000 Berlin 48


Berlin, 1992

1.	Der GEM-Manager						1-1
	1.1.	Vorwort						1-1
	1.2.	Hard- und Softwarevoraussetzungen		1-1
	1.3.	Bestandteile des GEM-Managers			1-2
	1.4.	Installationshinweise					1-3

2.	Allgemeine Funktionen und Felder (fktpool)		2-1
	2.1.	Globale Felder des GEM-Managers		2-2
	2.2.	Allgemeine Funktionen				2-4
		2.2.1.	Programminitialisierung			2-4
		2.2.2.	Programmende				2-5
		2.2.3.	Bildschirmausschnitte zwischenspeichern	2-6
	2.3.	Cookies						2-11
	2.4.	Rechtecksabfragen					2-12
	2.5.	Funktionsbersicht					2-13
	2.6.	Sonstiges						2-15

3.	Der Event-Manager						3-1
	3.1.	nderungen gegenber Version 1.10		3-1
	3.2.	Programmierung des Event-Managers		3-2
		3.2.1.	Parameterbergabe				3-2
		3.2.2.	Rckgabewerte				3-5
		3.2.3.	Tastaturabfrage mit dem Event-Manager	3-9
		3.2.4.	Funktionsaufruf und Einbindung in
			das Programm				3-14
	3.3.	Funktionsbersicht					3-15
	3.4.	Sonstiges						3-16

4.	Einleitung zum Window-Manager				4-1
	4.1.	Begriffsbestimmung					4-1
		4.1.1.	Fenster und deren Elemente		4-1
		4.1.2.	Sonstige Begriffe				4-4
	4.2.	Einbinden des Window-Managers			4-5
		4.2.1.	Voraussetzungen				4-5
		4.2.2.	Schnittstellen  WM <-> Programm		4-6
	4.3.	Anmelden und ™ffnen eines Fensters		4-9
		4.3.1.	Funktionsbeschreibung fr das ™ffnen
			des Fensters					4-9

		4.3.2	Verarbeitung					4-14
	4.4.	Aufruf des Window-Managers			4-15
		4.4.1.	Ereignisgesteuerte Fenstermanipulation	4-15
		4.4.2.	Programmgesteuerte Fenstermanipulation	4-16
		4.4.3.	Infozeile im Fenster setzen			4-21
		4.4.4.	Umwandlung Handle -> Index		4-22
		4.4.5.	Redrawing eines Fensters			4-22
		4.4.6.	Programm-Redraw				4-23
		4.4.7.	Der automatische Redraw			4-25
	4.5.	Schlieen und L”schen der Fenster		4-26
	4.6.	Allgemeines						4-28
		4.6.1.	automatisches Restaurieren			4-28
		4.6.2.	Sonstiges					4-28

5.	Einleitung zum Form-Manager				5-1
	5.1.	Hard- und Software-Voraussetzungen		5-1
	5.2.	Aufbau der Prozeduren				5-2
	5.3.	Was sie bedenken sollten				5-2
	5.4.	nderungen in den Versionen			5-4
		5.4.1.	nderungen von V. 1.0 zur Version 2.0	5-4
	5.5.	Was hat sich zur Version 3.0 ge„ndert?		5-7
		5.5.1.	Programmstruktur				5-7
		5.5.2.	Programmierung bei Fensterdialogen	5-9
		5.5.3.	Aufbau der Dialog-Message		5-10
	5.6.	Beschreibung der Funktionen			5-11
		5.6.1.	box_draw(tree,x,y,w,h)			5-11
		5.6.2.	box_undraw(tree,x,y,w,h)			5-11
		5.6.3.	objc_update(tree, objc)			5-11
		5.6.4.	objc_position(tree,objc,r)			5-11
		5.6.5.	set_flag(tree,objc,bit)				5-12
		5.6.6.	del_flag(tree,objc,bit)				5-12
		5.6.7.	unsigned int is_flag(tree, objc, bit)		5-12
		5.6.8.	hide(tree, objc) OBJECT *tree; int objc;	5-12
		5.6.9.	unhide(tree, objc)				5-13

		5.6.10.	do_objc(tree,objc bit)			5-13
		5.6.11.	undo_objc(tree,objc,bit)			5-13
		5.6.12.	unsigned int is_objc(tree, objc, bit)		5-13
		5.6.13.	get_dialogtext(tree,objc,text)		5-14
		5.6.14.	put_dialogtext(tree, objc, text)		5-14
		5.6.15.	delete_dialogtext(tree,objc)			5-14
		5.6.16.	do_movedial(baum, dragger, obj)		5-15
		5.6.17.	do_popup(baum, obj) long baum; int obj;	5-15
		5.6.18.	do_dial(baum, obj) long baum; int obj;	5-15
		5.6.19.	movedial(baum, type) long baum; int type;	5-16
		5.6.20.	vor_dial(baum, type) long baum; int type;	5-16
		5.6.21.	draw_dial(baum, type)			5-17
		5.6.22.	nach_dial(baum, type)			5-17
		5.6.23.	get_image_ptr(e) IMAGE *e;		5-17
		5.6.24.	restore_image_ptr(e) IMAGE *e;		5-18
		5.6.25.	dial_init(app_name) char *app_name;	5-18
		5.6.26.	wbox_draw(baum_adr)			5-18
		5.6.27.	wbox_undraw(wm_handle) int wm_handle;	5-19
	5.7.	Hilfsroutinen fr die Desktopverwaltung		5-19
		5.7.1.	draw_deskobjc(tree, objc)			5-19
		5.7.2.	move_deskobjc(tree, objc)			5-20
	5.8.	Nachwort						5-20
	5.9.	Update's						5-20
	5.10.	ben”tigte Erweiterungen				5-21
	5.11.	Wichtiger Hinweis					5-21
	5.12.	Aktuelle Version					5-22

6.	Der Button-Manager						6-1
	6.1.	Allgemeines						6-1
	6.2.	Was macht der Button-Manager?			6-2
	6.3.	Vorbereitungen in der Resource-Datei		6-3
	6.4.	Aufruf des Button-Managers im Programm		6-3
	6.5.	Definition neuer Objekte				6-4
	6.6.	Was wird noch ben”tigt?				6-5

	6.7.	Vertr„glichkeit					6-6
	6.8.	Aktuelle Version					6-6
	6.9.	Sonstiges						6-6

7.	Der Men-Manager						7-1
	7.1.	nderungen gegenber der Version 1.00		7-1
	7.2.	Allgemeines zu Pulldown-Mens			7-1
	7.3.	Die Tastenuntersttzung bei Dropdown-Mens	7-4
		7.3.1.	Prinzip der Tastenuntersttzung in Mens	7-4
		7.3.2.	Realisierung der Tastaturuntersttzung	7-6
		7.3.3.	Funktionsbeschreibung			7-7
	7.4.	Popup-Mens						7-9
		7.4.1.	Funktionsweise unter dem Men-Manager	7-9
		7.4.2.	Funktionsbeschreibung			7-10
		7.4.3.	Programmierhinweise				7-13
		7.4.4.	Einbindung in das eigene Programm	7-14
	7.5.	Sonstiges						7-14

1.	Der GEM-Manager

1.1.	Vorwort

Der GEM-Manager ist eine Zusammenfassung von Funktionen zur Untersttzung der Programmerstellung unter "C". Anfangs mehr oder weniger eine Sammlung von Modulen, die z.T. aus Computerzeitschriften entnommen wurden, ist der GEM-Manager jetzt ein "Paket" unter einer einheitlichen Oberfl„che. Die Funktionen wurden stark erweitert und neuen Entwicklungen angepat. Nichtsdestotrotz sind in den Sources, soweit erforderlich, der ursprngliche Autor bzw. die Zeitschrift aufgefhrt, aus denen die entsprechenden Funktionen entnommen wurden.

Die ersten beiden Kapitel sollten Sie sich unbedingt durchlesen, um sp„tere Miverst„ndnisse und Fehler zu vermeiden. Das erste Kapitel dieses Handbuches beschreibt die Installation der Funktionen und die Voraussetzungen fr ihren Einsatz. Im zweiten Kapitel werden sogenannte allgemeine Funktionen und Felder beschrieben, deren Anwendung bzw. Einbindung fr die Benutzung des GEM-Managers gr”tenteils notwendig sind. Die restlichen Kapitel besch„ftigen sich mit den Bestandteilen des GEM-Managers.

Dieses Handbuch wurde auf einem TT030 mit Tempus Word erstellt und auf einem Canon BJ-300 ausgedruckt. Die hier enthaltenen Bilder wurden mit dem Mortimer - Snapshot erstellt und mit dem Zeichenprogramm STAD+ aufbereitet.


1.2.	Hard- und Softwarevoraussetzungen

Getestet wurden die Funktionen zwar bisher nur auf einem ATARI 1040 ST, Mega ST1 und TT030, die Programmierung h„lt sich aber nur an dokumentierte Betriebssystemfunktionen und bezieht die Systemkonstellation aus diesen. Zus„tzlich wird versucht, den neuesten Entwicklungen gerecht zu werden. Daher kann der GEM-Manager auf jedem ST, STE und TT in allen Aufl”sungen eingesetzt werden. Grunds„tzlich sind die Funktionen unter Multitasking lauff„hig, wie Tests auf MinT Version 0.96 zeigten. Die Fensterverwaltung wurde sogar extra fr den Multitasking-Einsatz vorbereitet. Evtl. Einschr„nkungen lesen Sie bitte in der README-Datei nach.

Der GEM-Manager wurde mit dem Mark Williams C (Version 3.09) erstellt. Eine Anpassung an andere Compiler ist garantiert n”tig, drfte aber nicht zu schwer sein. Damit eine evtl. Anpassung der Konstanten erleichtert wird, sind die Headerdateien des Mark Williams C beigelegt. Sie drfen allerdings weder benutzt noch kopiert werden.


1.3.	Bestandteile des GEM-Managers

Der Inhalt der Diskette ist in der README-Datei aufgefhrt. Der GEM-Manager setzt sich aus folgenden folgenden Bestandteilen zusammen

a) Allgemeine Funktionen:
Allgemein nutzbare bzw. notwendige Funktionen, die keinem anderen Bestandteil des GEM-Managers zugeordnet werden k”nnen. Diese Funktionen werden u.U. aus anderen Teilen des GEM-Managers aufgerufen.

b) Event-Manager:
Funktionen zur Vereinfachung der Abfrage von GEM-Ereignissen

c) Window-Manager:
Funktionen zur Programmierung von Fenstern

d) Form-Manager:
Funktionen zur Programmierung von Dialogboxen


e) Button-Manager:
Funktionen zur Darstellung eigener Buttons in Dialogboxen

f) Men-Manager:
Funktionen zur Tastenuntersttzung in Dropdown-Mens und Programmierung von Popup-Mens.


1.4.	Installationshinweise

Diese Installationshinweise beschreiben Ihnen das erstmalige Einbinden der Funktionen in ihre Bibliotheken. Weitergehende Erl„uterungen, z.B. im Falle eines Updates, entnehmen Sie bitte der README-Datei.

Zuerst kopieren Sie bitte alle Headerdateien (*.H) aus dem Verzeichnis \SOURCES\GEM_LIB in das Include-Verzeichnis Ihres Compilers.

Danach compilieren (ohne linken) Sie bitte folgende Dateien aus dem Verzeichnis EXT_LIB.C:	cc -c EXFORMDO.C
				cc -c F_BUTTON.C
				cc -c F_KEYBD.C
Bei diesen Modulen handelt es sich um Funktionen, die im Mark Williams C nicht enthalten sind, aber vom GEM-Manager gen”tigt werden. Die erzeugten Objektmodule und die Datei CRYSTAL.O sind in die AES-Bibliothek des Compilers einzubinden.

Jetzt k”nnen Sie die Objektmodule aus den Funktionen des GEM-Managers erstellen (Verzeichnis \SOURCES\GEM_LIB) und in Ihre Bibliotheken einbinden:
				cc -c BUT_MNGE.C
				cc -c EVNT_LIB.C
				cc -c FKTPOOL.C
				cc -c MENU_LIB.C
				cc -c MOVEBOX.C

				cc -c POP_LIB.C
				cc -c RESOURCE.C

Nun ist der GEM-Manager "einsatzbereit". Beachten Sie bitte, da ein Beispielprogramm beiliegt, in dem alle Bestandteile des GEM-Managers integriert sind. Drucken Sie sich ruhig den Source aus und nutzen Sie diesen am besten als Beilage zum Handbuch, da vieles in diesem Handbuch evtl. zu abstrakt ist. An diesem Beispielprogramm werden die Zusammenh„nge vielleicht besser verst„ndlich. Auerdem liegt ein Programmgerst bei, das Ihnen bei der Programmerstellung einiges an "Schreibarbeit" abnimmt. Das Handbuch ist keine Einfhrung in die GEM-Programmierung, Kenntnisse in C, dem AES und VDI sollten in Grundzgen vorhanden sein.

2.	Allgemeine Funktionen und Felder (fktpool)

Der GEM-Manager stellt Ihnen eine Reihe von Funktionen bzw. Arbeitsabl„ufen zur Verfgung, mit deren Hilfe Sie z.T. komplexe Sachverhalte relativ einfach programmieren k”nnen. Dazu mssen Sie sich aber an bestimmte Regeln halten, die hier ersteinmal aufgefhrt werden sollen. Im Laufe dieses Kapitels folgen dann die Erl„uterungen:

a)	Am Anfang jeder Programmdatei, in der der GEM-Manager aufgerufen wird, mu die Headerdatei "gemsys.h" eingebunden werden. Sie enth„lt allgemeingltige Definitionen und Konstantendeklarationen.

b)	Der GEM-Manager arbeitet ber Betriebssystemfunktionen, fr deren Aufruf 3 Array's ben”tigt werden. Auerdem mssen globale Felder fr den ordnungsgem„en Ablauf des Programms zur Verfgung gestellt werden. Alle diese Felder sind am Anfang Ihrer Datei, die die Funktion main() beinhaltet, wie folgt global zu definieren:

 	int ap_id, vdi_handle, work_in[12], work_out[57], contrl[12];
	int global[12],intin[128], ptsin[128], intout[128], ptsout[128];
	ACT aktuell, before;

In weiteren Programmdateien sind sie bei Bedarf zu importieren (extern-Deklaration).

c)	Der erste Funktionsaufruf im Hauptprogramm (main()) mu gem_init(), der letzte mu gem_exit() lauten. N„heres zu diesen Funktionen lesen Sie bitte im Kapitel "Programminitialisierung und -ende".

d)	Jeder Bestandteil des GEM-Managers besitzt fr sich eine Headerdatei mit Definitionen usw. Darber hinaus verfgt jeder Teil ber Initialisierungs- und Beendigungsfunktionen, deren Aufgabe in den jeweiligen Kapiteln beschrieben sind.

e)	GDOS wird in dieser Version nicht speziell untersttzt. Die Felder fr Textgr”e und die ensprechenden Ausgabefunktionen des GEM-Managers greifen auf die Gr”e des Systemzeichensatzes der jeweiligen Bildschirmaufl”sung zu.

Die in diesem Kapitel beschriebenen Funktionen und Felder stellen da Grundgerst des GEM-Managers dar und werden von dessen Bestandteilen genutzt bzw. sind fr den ordnungsgem„en Lauf eines GEM-Programms notwendig. Sie k”nnen sie auch von Ihrem Programm aus aufgerufen bzw. deren Inhalte nutzen.

Als erstes werden die Felder beschrieben. Bei der Beschreibung der einzelnen Bestandteile des GEM-Managers wird dann ausfhrlicher auf deren Funktionen eingegangen, hier soll nur ein erster šberblick gegeben werden. Danach werden die Funktionen erl„utert.


2.1.	Globale Felder des GEM-Managers

a) ACT aktuell;
Diese Strukturvariable enth„lt allgemeine Informationen, die entweder w„hrend der Programminitialisierung durch gem_init() oder aber w„hrend des Programmlaufes festgestellt (durch die Bestandteile des GEM-Managers) und gespeichert werden. Im folgenden werden nur die Namen der Member aufgefhrt. Deren Typendefinition ist der Headerdatei "gemsys.h" zu entnehmen:

multitsk = 	TRUE, wenn Programm auf einem Multitasking- System l„uft; ansonsten ist dieser Schalter FALSE
max_user_wind=	Max. zul„ssige Anzahl von Fenstern, die dieses Programm anlegen darf

windanz =	Anzahl der durch den Window-Manager angelegten Fenster
anzahl =	Anzahl der durch den Window-Manager ge”ffneten Fenster
handle =	Handlenummer des gerade ge”ffneten Fensters
text_x =	Breites eines Zeichens in Pixel (Systemzeichensatz)
text_y =	H”he eines Zeichens in Pixel. (Systemzeichensatz)
menu_y =	H”he der Menzeile in Pixel. Entspricht der H”he der Zelle, in der ein Zeichen ausgegeben wird.
aufloesung =	Bildschirmaufl”sung
screen_w =	Breite des Bildschirms in Pixel
screen_h =	H”he des Bildschirms in Pixel
neu_pix =	neu zu zeichnender Bereich im zu restaurierenden Fenster
neu_doc =	Dokumentenposition (Spalte/Zeile) fr zu restaurierenden Bereich im Fenster
monitor =	Memory Form Definition Block fr den virtuellen Bildschirm

b) ACT before;
Entspricht der Strukturvariablen "aktuell". Sie enth„lt deren Inhalt vor einer nderung in "aktuell".

c) int ap_id;
In diesem Feld ist die Applikationsnummer gespeichert. Jedes GEM- Programm mu beim AES angemeldet werden und wird durch diese Nummer identifiziert. Die Anmeldung wird von der Funktion gem_init() vorgenommen, die auch das Feld ap_id versorgt.

d) int vdi_handle;
Dieses Feld enth„lt den VDI-Handle der Arbeitsstation oder des physikalischen Ger„tes, mit dem GEM-AES arbeitet. Im Normalfall ist es der Bildschirm. Dieses Handle mu bei jeder VDI-Funktion angegeben werden, damit das Betriebssystem "wei", wo die Ausgaben "hingeh”ren". vdi_handle wird vom GEM-Manager benutzt, es kann aber auch von Ihnen genutzt werden, wenn Sie VDI-Funktionen benutzen. vdi_handle wird von gem_init() versorgt.

e) int work_in[12],work_out[57],contrl[12],intin[128],ptsin[128],
  global[12],intout[128],ptsout[128]
Das VDI benutzt bei seiner Arbeit die in der šberschrift aufgefhrten, globalen Arrays. Sie werden direkt von Assemblerroutinen manipuliert und werden nicht direkt von C-Programmen benutzt. Sie mssen aber deklariert sein, damit die VDI-Routinen korrekt arbeiten k”nnen.


2.2.	Allgemeine Funktionen

2.2.1.	Programminitialisierung

	int	gem_init()

	šbergabe:	keine
	Rckgabe:	0 = keine Fehler
			-1 = Applikation konnte nicht angemeldet werden.

Jedes GEM-Programm mu ersteinmal ordentlich initialisiert und angemeldet werden. Diese immer wiederkehrenden Arbeiten werden von der Funktion gem_init() erledigt. Darber hinaus werden fr den GEM- Manager wichtige Felder initialisiert. Im Hauptprogramm mu diese Funktion als erstes aufgerufen werden, bevor irgendeine andere Verarbeitung durchgefhrt wird. Hier nun eine verbale Beschreibung dieser Funktion:

(a) Anmelden der Applikation
Jedes GEM-Programm mu beim AES angemeldet werden. Die Applikationsnummer, die beim Anmelden durch appl_init() vom AES zurckgegeben wird, identifiziert das Programm. Sie wird im global definierten Feld ap_id hinterlegt.

(b)  Bildschirmhandle bestimmen
Mit graf_handle() wird der VDI-Handle des Bildschirms bestimmt. Dieses Handle wird in der globalen Variablen vdi_handle gespeichert und mu bei jeder VDI-Funktion angegeben werden.
(c)  virtuelle Arbeitsstation fr VDI ”ffnen
Mit v_opnvwk() ”ffnet die Initialisierungsroutine ein virtuelles Bildschirmger„t.

(d)  globale Strukturvariable "aktuell" versorgen.
Das Betriebssystem liefert mit dem Anmelden beim AES und ™ffnen der virtuellen Arbeitsstation Informationen ber den Zustand des Rechners. Ein Teil von ihnen wird in der Variablen aktuell gespeichert.

(e)  Programmende-Schalter "Prog_End" versorgen
Der GEM-Manager stellt eine Variable zur Verfgung, die zum Beenden eines Programms genutzt werden kann. Wie im Beispielprogramm zu ersehen, besteht das Hauptprogramm im Grund aus einer Schleife, in der auf bestimmte AES-Ereignisse gewartet wird. Die Schleife wird beendet, wenn die Variable auf TRUE gesetzt wird. Dies kann irgendwo im Programm geschehen (mu im entsprechenden Modul mit "extern int Prog_End" deklariert werden). gem_init() setzt diese Variable auf FALSE.


2.2.2.	Programmende

	void	gem_exit()

	šbergabe:	keine
	Rckgabe:	keine


Soll ein Programm beendet werden, mssen gewisse Abschluarbeiten durchgefhrt werden. Diese werden von der Funktion gem_exit() durchgefhrt. Sie mu als letzte Funktion im Hauptprogramm aufgerufen werden. Sie fhrt folgende Verarbeitungen durch:

(a)	virtuellen Bildschirm schlieen
(b)	Applikation abmelden


2.2.3.	Bildschirmausschnitte zwischenspeichern

int	get_image(x0,y0,x1,y1,g_image)	/* Ausschnitt speichern */

	šbergabe:
	int x0,y0		= Koordinaten der linken, oberen Ecke
	int x1,y1		= Koordinaten der linken, unteren Ecke
	IMAGE *g_image	= Zeiger auf Struktur fr gespeicherten
				  Bildschirmausschnitt
	Rckgabe:
	0	= keine Fehler
 	-1	= fehlerhafte Koordinaten
	-2	= nicht gengend Speicher fr Bildschirmausschnitt


int	put_image(x0,y0,x1,y1,x2,y2,p_image,mode) /* auf Screen */

	šbergabe:
	int x0,y0		= Koordinaten der linken, oberen Ecke
	int x1,y1		= Linke, obere Ecke des Teilausschnitts
	int x2,y2		= Rechte, untere Ecke des Teilausschnitts
	IMAGE *p_image	= Zeiger auf gespeicherten Ausschnitt
	int mode		= Modus, in dem Ausschnitt kopiert wird


	Rckgabe:
	0	= keine Fehler
	-1	= Der zu kopierende (Teil-)Ausschnitt ragt ber den
		  Bildschirmrand hinaus
	-2	= unplausible Koordinaten fr Teilausschnitt
	-3	= keine Adresse in IMAGE-Struktur angegeben


int	release_image(r_image)  /* Speicher und Bild freigeben */

	šbergabe:
	IMAGE *r_image	= Zeiger auf Struktur fr gesp. Ausschnitt

	Rckgabe:
	0	= keine Fehler
	-1	= keine Adresse fr gespeicherten Ausschnitt
	-2	= Fehler beim Freigeben des Speichers


Mit diesen Funktionen ist m”glich, beliebig groe Rechtecke vom Bildschirm in den Speicher einzulesen und diese sp„ter wieder an beliebiger Stelle auf den Bildschirm zu bringen. Benutzt wird dabei die VDI-Routine vro_cpyfm(), die beim pixelweisen Verschieben von Grafikbl”cken eine Hauptrolle spielt. Fr weitergehende Erl„uterungen dieser Routine schlagen Sie bitte im Handbuch Ihres C-Compilers nach. Die unten beschriebenen Funktionen reduzieren den Aufwand, der bei vro_cpyfm() anf„llt, auf ein Minimum.

Fr das Kopieren von Grafikbl”cken mssen fr den Quell- und den Zielbereich Memory Form Definition Blocks (MFDB) vorhanden und versorgt sein. Um die Inhalte brauchen Sie sich aber nicht zu kmmern. Der MFDB fr den RAM-Bereich wird lokal in den unten beschriebenen Funktionen initialisiert. Der MFDB fr den Bildschirm ist in der globalen Strukturvariablen aktuell.monitor definiert und wird von gem_init() initialisiert.


Wenn Sie die Kopierfunktionen anwenden, mssen Sie eine Strukturvariable vom Typ IMAGE bereitstellen. Die Struktur ist folgendermaen definiert:

typedef struct image
{
	int	breite;
	int	hoehe;
	long	getbuf;
} IMAGE;

Die Member breite und h”he enthalten die Gr”e des Ausschnitts in Pixel. getbuf enth„lt die Adresse auf den Speicherbereich, in dem der Bildschirmausschnitt gespeichert wird. Ist diese Adresse Null (0L) oder kleiner Null, gehen die Kopierfunktionen davon aus, das kein Ausschnitt gespeichert wurde. Der Bildschirmausschnitt bleibt solange gespeichert, bis der Speicher durch release_image() freigegeben wird.


get_image()

Mit der Funktion get_image() wird ein rechteckiger Bildschirmausschnitt in den Speicher kopiert. Die Parameterbergabe ist denkbar einfach. Es werden die Koordinaten der oberen, linken und unteren, rechten Ecke des Ausschnitts bergeben. Dazu wird ein Pointer auf ein Feld vom Typ "IMAGE" bergeben.

Zuerst werden die Koordinaten geprft. Liegen Sie auerhalb des Bildschirms oder sind die Koordinaten fr die Ecke rechts unten kleiner als die fr links oben, bricht die Funktion mit einem Fehlercode ab.

Fr den Bildschirmausschnitt mu Speicherplatz reserviert werden. Steht keiner mehr zur Verfgung, bricht die Funktion ab und gibt einen Fehlercode zurck. Die Member der IMAGE-Struktur, in denen die Werte fr den gespeicherten Ausschnitt stehen sollten, werden mit Null initialisiert.


put_image()

Die Funktion put_image() bringt einen zuvor gespeicherten Ausschnitt, bzw. einen Teil von ihm wieder auf den Bildschirm zurck. Dazu mssen Sie folgende Parameter bergeben:

-	Koordinaten der linken, oberen Ecke, wo sich der Ausschnitt auf dem Bildschirm befinden soll.

-	Koordinaten des Teiles vom Ausschnitt, der vom Zwischenspeicher in das RAM des Bildschirms kopiert werden soll (linke, obere und rechte, untere Ecke). Sind alle Koordinaten Null, wird der gesamte gespeicherte Ausschnitt auf den Bildschirm gebracht.
Anmerkung: Bei diesen Werten handelt es sich nicht um die absoluten Koordinaten des Bildschirms. Vielmehr liegt der Nullpunkt in der linken oberen Ecke des gespeicherten Ausschnitts.

-	Als n„chste mssen Sie den Pointer auf die entsprechende IMAGE-Struktur bergeben.

-	Schlielich mu der Kopiermodus angegeben werden. In der folgenden Tabelle sind die m”glichen Werte samt Konstanten (in der Headerdatei "obdefs.h" definiert) aufgefhrt. Dabei steht S fr Ursprungspixel und D fr die Zielpixel:

	0  Zielgeb. l”schen		(ALL_WHITE)
	1  S & D			(S_AND_D)
	2  S & !D			(S_AND_NOTD)
	3  S - Ersetzen		(S_ONLY)
	4  !S & D - Ersetzen		(NOTS_AND_D)

	5  D - kein Effekt		(D_ONLY)
	6  S ^ D - XOR		(S_XOR_D)
	7  S | D -Transparent		(S_OR_D)
	8  !(S & D)			(NOT_SORD)
	9  !(S ^ D)	 		(NOT_SXORD)
	10  !D				(D_INVERT)
	11  S | (!D)			(NOT_D)
	12  !S				(S_OR_NOTD)
	13 (!S) | D			(NOTS_OR_D)
	14  !(S & D)			(NOT_SANDD)
	15  1 - Zielgeb.schwarz	(ALL_BLACK)


Die Funktion put_image() bricht mit der Verarbeitung ab, wenn folgende Fehler vorliegen:

-	Der zu kopierende (Teil-)Ausschnitt ragt ber den Bildschirmrand hinaus.

-	Die Koordinaten fr den zu kopierenden Teilausschnitt sind fehlerhaft. Entweder sind die Werte der beiden anzugebenen Ecken unplausibel (Werte fr unten rechts kleiner als fr oben links) oder die Koordinaten fr die Rechte untere Ecke liegen auerhalb der Gr”e des gespeicherten Ausschnitts.

-	Die in der IMAGE-Struktur angegebene Adresse ist kleiner oder gleich Null.


release_image()

Mit der Funktion release_image() wird der Speicher, in dem der Bildschirmausschnitt kopiert wurde, freigegeben. Dazu braucht nur der Zeiger auf die dementsprechende IMAGE-Struktur bergeben werden. Die Member dieses Feldes werden, wenn alles fehlerfrei verl„uft, mit Null initialisiert und der Speicher wird freigegeben. Enth„lt die Adresse auf den gespeicherten Ausschnitt einen Wert gleich oder kleiner Null oder tritt ein allg. Fehler beim Freigeben des Speichers auf, bricht die Funktion mit einem Fehlercode ab.


2.3.	Cookies

int  is_cookie(cookie,value)

	šbergabe:
	long  cookie	= Kennung des Cookie-Eintrages (32 Bit)
	long  *value	= Nullpointer (0L) oder Pointer auf Wert des
			  Cookiejar's; Der Inhalt ist von der Anwendung
			  abh„ngig

	Rckgabe:
	TRUE	= Cookie ist installiert, "value" enth„lt dann den Zeiger
		  auf des Wert des Cookies, wenn nicht 0L bergeben
		  wurde
	FALSE	= Cookie ist nicht installiert.

Beim "Cookie Jar" handelt es sich im Grunde genommen um eine Generalisierung der Systemvariablen. Er ist eine Tabelle, von der nur die Basisadresse bekannt ist. Damit kann sie bei Bedarf verl„ngert und im Speicher umhergeschoben werden. Jeder Eintrag hat eine eindeutige Kennung. Damit hat man die M”glichkeit, auch selbst Eintr„ge fr eigene Zwecke vorzunehmen. "Cookie" hat sich im Atari-Slang eingebrgert und steht meist fr 32 Bits groe Codenummern. Meistens werden sie als vier ASCII-Zeichen interpretiert, die eine Art Abkrzung darstellen. Zu jedem Cookie geh”rt ein 32 Bits groer Eintrag, der je nach Cookie verschiedene Bedeutungen haben kann. Meist handelt es sich um Zeiger auf weitere Strukuren (Parameter u.a.) oder um Versionsnummern. Der "Cookie Jar" ist nichts anderes als ein Array von Cookies und ihren Werten.


Der Funktion is_cookie() mu in "cookie" die Kennung der Anwendung mitgegeben werden. In "value" kann ein Zeiger auf weitere Strukturen (wenn die Anwendung eine bereitstellt) mitgegeben werden. Findet die Funktion die Cookie-Kennung, so wird "value" mit dem dazugeh”renden Wert des Cookies versorgt. N„heres sie dazu das Beispielprogramm.


2.4.	Rechtecksabfragen

int  rect_overlay(a,b)

	šbergabe:
	RECT	*a, *b	= Koord., Breite, H”he der beiden Rechtecke

	Rckgabe:
	TRUE	= Rechtecke berlappen sich, die Schnittfl„che wird in
		  "a" bereitgestellt.
	FALSE= Die Rechtecke besitzen keine gemeinsame Fl„che


int  rect_equal(a,b)

	šbergabe:
	RECT	*a, *b	= Koord., Breite, H”he der beiden Rechtecke

	Rckgabe:
	TRUE	= Die Rechtecke sind deckungsgleich

	FALSE= Die Rechtecke sind ungleich


Die Funktion rect_overlay() berprft, ob sich zwei Rechtecke berlappen. "a" und "b" sind Zeiger auf die Rechtecke, die verglichen werden sollen. Jeder Zeiger ist so definiert, da er auf eine Struktur vom Typ RECT zeigt, die folgendermaen definiert ist:
		g_x	: x-Koordinate
		g_y	: y-Koordinate
		g_w	: Breite des Rechtecks
		g_h	: H”he des Rechtecks

Die Werte der Struktur, die auf "a" zeigt, werden in die Koordianten der Schnittfl„che umge„ndert, wenn eine vorhanden sein sollte. Wenn beide Rechtecke sich nicht berlappen, bleiben die Werte erhalten.


Mit rect_equal() werden zwei Rechtecke verglichen. Die Parameterbergabe ist die gleiche, wie bei rect_overlay(). Bei Gleichheit wird TRUE, ansonsten FALSE zurckgegeben.


2.5.	Funktionsbersicht

void  gem_exit()	"Vorbereitungen zum Programmende"
	šbergabe:	keine
	Rckgabe:	keine

int  gem_init()		"GEM-Programm initialisieren"
	šbergabe:	keine
	Rckgabe:	0 = keine Fehler
			-1 = Applikation konnte nicht angemeldet werden.

int  get_image(x0,y0,x1,y1,g_image)		"Ausschnitt speichern"
	šbergabe:
	int x0,y0		= Koordinaten der linken, oberen Ecke
	int x1,y1		= Koordinaten der linken, unteren Ecke
	IMAGE *g_image	= Zeiger auf Struktur fr gespeicherten
				  Bildschirmausschnitt

	Rckgabe:	0	= keine Fehler
			-1	= fehlerhafte Koordinaten
			-2	= kein Speicher fr Bildschirmausschnitt

int  is_cookie(cookie,value)	"Feststellen, ob Cookie installiert"
	šbergabe:
	long  cookie	= Kennung des Cookie-Eintrages (32 Bit)
	long  *value	= Nullpointer (0L) oder Pointer auf Wert des
			  Cookiejar's; Der Inhalt ist von der Anwendung
			  abh„ngig
	Rckgabe:
	TRUE	= Cookie installiert, "value" enth„lt dann den Zeiger auf
		  Wert des Cookies, wenn nicht 0L bergeben wurde
	FALSE= Cookie ist nicht installiert.

int  put_image(x0,y0,x1,y1,x2,y2,p_image,mode)	"Ausschnitt auf
							 Screen"
	šbergabe:
	int x0,y0		= Koordinaten der linken, oberen Ecke
	int x1,y1		= Linke, obere Ecke des Teilausschnitts
	int x2,y2		= Rechte, untere Ecke des Teilausschnitts
	IMAGE *p_image	= Zeiger auf gespeicherten Ausschnitt
	int mode		= Modus, in dem Ausschnitt kopiert wird
	Rckgabe:	0	= keine Fehler
			-1	= Der zu kopierende (Teil-)Ausschnitt ragt
				  ber den Bildschirmrand hinaus
			-2	= unplausible Koordinaten fr Teilausschnitt
			-3	= keine Adresse in IMAGE-Struktur
				  angegeben

int  rect_overlay(a,b)		"Feststellen, ob Rechteck sich berlappen"
	šbergabe:
	RECT	*a, *b	= Koord., Breite, H”he der beiden Rechtecke

	Rckgabe:
	TRUE	= Rechtecke berlappen sich, die Schnittfl„che wird in
		  "a" bereitgestellt.
	FALSE= Die Rechtecke besitzen keine gemeinsame Fl„che

int  rect_equal(a,b)	"Feststellen, ob zwei Rechtecke gleich sind"
	šbergabe:
	RECT	*a, *b	= Koord., Breite, H”he der beiden Rechtecke
	Rckgabe:
	TRUE	= Die Rechtecke sind deckungsgleich
	FALSE= Die Rechtecke sind ungleich

int	release_image(r_image)	"Speicher und Bild freigeben"
	šbergabe:
	IMAGE *r_image	= Zeiger auf Struktur fr gesp. Ausschnitt
	Rckgabe:
	0	= keine Fehler
	-1	= keine Adresse fr gespeicherten Ausschnitt
	-2	= Fehler beim Freigeben des Speichers



2.6.	Sonstiges

Literatur:	- Handbuch zu Mark Williams C
		- ATARI Profibuch ST-STE-TT





3.	Der Event-Manager

Der Event-Manager untersttzt die Programmierung von Abfragen der AES-Ereignisse. AES ist eine Abkrzung fr application environment services (Routinen, die das Grafikumfeld untersttzen). Das AES ist die h”chste Stufe von GEM und damit die, mit der der Programmierer am meisten zu tun hat. Das AES verwaltet auch die sogenannten Ereignisse, wie Mausbewegung, -knopf, Tastatur, Timer, Manipulation von Fenstern usw. Tritt ein Ereignis auf, wird es in einen Puffer geschrieben, der von der davon bestimmten Applikation (bzw. einem Proze) gelesen werden kann. Der Event-Manager kmmert sich um die Abfrage von aufgetretenen Ereignissen und stellt dementsprechende Schnittstellen zur Verfgung.

	Version 1.11	vom 29.11.92


3.1.	nderungen gegenber Version 1.10

Die Tasten "UNDO" und "HELP" wurden der Gruppe "Cursortasten" zugeordnet.


3.2.	Begriffsbestimmung
Das AES bietet verschiedene M”glichkeiten, Ereignisse abzufragen:

	evnt_button()	:	erwartet ein Mausknopf-Ereignis
	evnt_keybd()	:	erwartet ein Tastatur-Ereignis
	evnt_mesag()	:	erwartet eine Meldung
	evnt_mouse()	:	Rechteck betreten oder verlassen
	evnt_multi()	:	wartet auf mehrere Ereignisse

Mit Hilfe dieser Funktionen k”nnen Sie dem AES mitteilen, auf welche Ereignisse Sie warten m”chten. Tritt dieses Ereignis ein, wird die Kontrolle dem Programm oder besser dem Proze zurckgegeben, der die entsprechende Funktion aufgerufen hat.Sehen Sie bitte in Ihrem C- Handbuch zwecks weiterer Erl„uterungen dieser Funktionen nach.

Ein Programm wird im folgenden auch Applikation bzw. Proze genannt. Es k”nnen sich mehrere dieser Programme im Speicher befinden, wobei immer nur eines abgearbeitet wird. Jede Applikation wird durch eine Nummer identifiziert, die beim Anmelden unter AES durch die Funktion "appl_init()" vergeben wird.


3.2.	Programmierung des Event-Managers
Das Kernstck des Event-Managers ist der Funktionsaufruf evnt_multi(). Diese Funktion wartet auf ein oder mehrere Ereignisse, die vom Programmierer vorgegeben werden mssen. Die Parametereingabe ist zwar in Ihrem C-Handbuch beschrieben, wird aber noch einmal im Rahmen der Schnittstellen erl„utert werden. Auerdem bernimmt der Event-Manager zus„tzlich einige kleine Arbeiten, die Ihnen die Abfrage des aufgetretenen Ereignisses erleichtert.


3.2.1.	Parameterbergabe
Fr die Parameterbergabe steht Ihnen ein global definierter Bereich zur Verfgung. Dieser ist in Form der Struktur "EVNT" definiert, wobei der Event-Manager das Feld "EVENT" erwartet. Dieses Feld mu in Ihrem Programm global definiert werden.

(1) event.event - int
Dies ist ein Flag, das die Ereignisse angibt, auf die der Proze warten soll. Sie k”nnen folgende Werte bergeben:
0x01 MU_KEYBD  Tastaturereignis
Es wird einen Tastendruck gewartet

0x02 MU_BUTTON - Mausknopfereignis
Es wird solange gewartet, bis ein Mausknopf gedrckt wird.


0x04 MU_M1 - 1. Mausereignis / 0x08 MU_M2 - 2. Mausereignis
Es wird solange gewartet, bis der Mauszeiger ein definiertes Rechteck betritt oder verl„t. Es k”nnen zwei Rechtecke berwacht werden.

0x10 MU_MESAG - Meldung von Proze
Es wird solange gewartet, bis eine Meldung von einem Programm geschrieben wird (siehe Rckgabewerte "buffer").

0x20 MU_TIMER - Timerereignis
Es wird solange gewartet, bis ein Zeitintervall vorbei ist.

Die hinter den Zahlenwerten angegebenen Konstanten sind in der Headerdatei fr GEM-Definitionen deklariert (Mark Williams C = gemdefs.h). Der Event-Manager kann auch auf mehrere Ereignisse gleichzeitig warten. Dazu brauchen nur die Werte fr die gewnschten Ereignisse addiert zu werden.

Die folgenden Felder sind jeweils fr ein Ereignis zust„ndig und brauchen dann auch nur fr diese gefllt zu werden.

(2) event.clicks - int
"CLICKS" ist die Anzahl der Mausknopfklicks, auf die gewartet werden soll, wenn MU_BUTTON als Ereignis angegeben wurde.

(3) event.state - int
"STATE" gibt an, welcher Mausknopfzustand erwartet werden soll, wenn MU_BUTTON als Ereignis angegeben wurde. "0" bedeutet, warten bis Knopf losgelassen, "1" bis Knopf gedrckt.

(4) event.button - int
"BUTTON" ist eine Maske, die angibt, welche Mauskn”pfe fr das Mausknopfereignis relevant sind. Soll die linke Maustaste abgefragt werden, mu 0x1 bergeben werden. 0x2 fragt die rechte Maustaste ab. Die šbergabe von 0x3 fhrt dazu, da beide Tasten gedrckt werden mssen, um ein Ereignis hervorzurufen ("UND"-Verbindung). Soll auf die rechte oder linke Maustaste gewartet werden, mssen Sie zu einem Trick greifen. Die Maustastenabfrage im AES ist so programmiert, da eine zus„tzliche "NICHT"-Bedingung mitgegeben werden kann. Sie wird im h”chstwertigen Byte von "clicks" bergeben, indem zu dem ursprnglichen Wert die Zahl 256 addiert wird. Dies sieht folgendermaen aus:

event.clicks	= 1+256 :
	1	= Anzahl Klicks auf die gewartet werden soll;
	256	= "NICHT"-Bedingung;h”chstwertiges Byte;

event.button	= 3	:	Beide Maustasten ("UND"-Verbindung)
event.state	= 0	:	Beide Maustasten losgelassen

Sprachlich ausgedrckt heit es: Warte solange, bis NICHT linke und rechte Maustaste losgelassen.

Achtung:	Diese Vorgehensweise wurde bisher nur unter den TOS- Versionen 1.0, 1.2, 1.4 und 3.05 getestet. Die Buttonabfrage im AES ist nicht dokumentiert, so da das obige Beispiel bei anderen TOS- Versionen nicht mehr zu funktionieren braucht!


(5) event.m1inout - int
"m1inout" zeigt an, ob der Proze darauf warten soll, da der Mauszeiger das definierte Rechteck betritt (= "0") oder es verl„t (= "1").

(6) event.rectangle1 - Rect
"rectangle1" enth„lt das fr das 1. Mausereignis wichtige Rechteck:

event.rectangle1.x	= x-Koordinate der linken oberen Ecke
event.rectangle1.y	= y-Koordinate der linken oberen Ecke
event.rectangle1.w	= Breite des Rechteckes
event.rectangle1.h	= H”he des Reckteckes


(7) event.m2inout - int
Maske fr ein 2. Mausereignis, siehe event.m1inout.

(8) event.rectangle2 - Rect
Rechteck fr ein 2. Mausereignis, siehe event.rectangle1.

(9) event.lowtime, event.hightime - int
"LOWTIME" und "HIGHTIME" sind das untere bzw. obere Wort des Zeitintervalls in Millisekunden. Nach Ablauf dieses Intervalls wird dem lfd. Programm ein Timerereignis gemeldet.


3.2.2.	Rckgabewerte
Tritt ein Ereignis auf, kehrt das AES zum lfd. Programm zurck und bergibt einige Werte, die das Ereignis identifizieren bzw. die beim Auftreten des Ereignisses aktuell waren. Der Event-Manager bereitet diese Werte auf, so da l„stige Routinearbeiten fr Sie entfallen. Die aufbereiteten Rckgabewerte werden in der Struktur "EVNT_RETURN" bergeben. Der Feldname mit dieser Struktur wird vom Event-Manager vorgegeben und lautet "event_return". Alle Member dieser Struktur werden nach Auftreten eines Ereignisses vom Event-Managers immer zuerst mit "0" inititalisiert.

(1) event_return.event - int
Dieses Feld enth„lt das eingetretene Ereignis. Lesen Sie dazu die Beschreibung der Ereignisse in vorigen Kapitel fr das Feld event.event. Treten mehrere Ereignisse gleichzeitig ein, so sind deren Maskenwerte logisch-oder-verknpft.

Die Arten der Ereignisse sind als Makros hinterlegt. Sie liefern den Wert "1" (TRUE), wenn das abgefragte Ereignis eingetreten ist. Andernfalls geben sie den Wert "0" zurck:

EVNT_KEYBD()	/* auf Tastaturereignis untersuchen	 */
EVNT_BUTTON()	/* auf Mausknopfereignis untersuchen*/

EVNT_M1()		/* auf 1. Mausereignis untersuchen	 */
EVNT_M2()		/* auf 2. Mausereignis untersuchen	 */
EVNT_MESAG()	/* auf Meldungsereignis untersuchen	 */
EVNT_TIMER()	/* auf Timerereignis untersuchen	 */

(2) event_return.buffer[8] - char
"BUFFER" ist der Speicher, in dem AES jede Meldung von Applikationen ablegt. Der Inhalt hat folgenden Aufbau:

buffer[0] =	Typ der Meldung:
		10	MN_SELECTED	Menu selektiert
		20	WM_REDRAW		Fenster restaurieren
		21	WM_TOPPED		Fenster selektiert
		22	WM_CLOSED		Fenster geschlossen
		23	WM_FULLED		Fenster auf max. Gr”e
		24	WM_ARROWED	Pfeil-, Scrollbalken
		25	WM_HSLIDE		vertikaler Slider
		26	WM_VSLIDE		horizontaler Slider
		27	WM_SIZED		Fenstergr”e ver„ndert
		28	WM_MOVED		Fensterpos. ver„ndert
		40	AC_OPEN		Accessory ge”ffnet
		41	AC_CLOSE		Accessory geschlossen
buffer[1] =	Handle der Applikation
buffer[2]=	Anzahl der zus„tzlichen Bytes in der Meldung
buffer[3] =	buffer[7] = Inhalt der Meldung

(3) event_return.fl_menu - int
Dieses Flag ist auf "1" gesetzt, wenn ein Menereignis eingetreten ist, ansonsten ist es immer Null.

(4) event_return.fl_acc - int
Dieses Flag ist auf "1" gesetzt, wenn ein Accessory-Ereignis eingetreten ist, ansonsten ist es immer Null.


(5) event_return.fl_window - int
Dieses Flag ist auf "1" gesetzt, wenn ein Fensterereignis eingetreten ist, ansonsten ist es immer Null.

(6) event_return.mouse_x, event_return.mouse_y - int
Koordinaten des Mauszeigers bei Eintreten des Ereignisses

(7) event_return.mouse_b - int
Dieses Feld zeigt den Mausknopfzustand an, der bei Eintreten des Ereignisses vorlag (0 = nicht gedrckt, 1 = gedrckt).

(8) event_return.mouse_k - int
Mit diesem Feld wird der Zustand der Control-, Alt- und der Shifttasten dargestellt. Nachfolgend sind die m”glichen Werte, die Konstanten (in der Datei gemdefs.h definiert) und die Makros des Event-Managers aufgefhrt. Die Makros liefern den Wert 1, wenn die zu untersuchende Zusatztaste gedrckt wurde, ansonsten 0.

0x00				keine Taste wurde gedrckt
0x01	EVNT_RSHIFT()	K_RSHIFT	rechte Shifttaste
0x02	EVNT_L_SHIFT()	K_LSHIFT	linke Shifttaste
0x04	EVNT_CTRL()		K_CTRL	Controltaste
0x08	EVNT_ALT()		K_ALT	Alternatetaste

Die Werte der einzelnen Zusatztasten werden logisch-oder-verknpft, wenn mehr als eine gedrckt wurde.

(9) event_return.times - int
"TIMES" gibt die Anzahl der Mausknopfereignisse wieder (z.B. Einfach-Klick, Doppel-Klick).

(10) event_return.key,event_return.low_key,event_return.high_key - int
Um die Abfrage der Tastatur zu erleichtern, wurden alle Tasten als Pr„prozessorkonstanten definiert. Diese Konstanten k”nne von Ihnen beliebig genutzt werden, auch ohne den Event-Manager. Wenn Sie diesen aber anwenden, steht Ihnen fr jede Taste ein Makro zur Verfgung, welches die speziellen Rckgabefelder abfragt. Mehr dazu siehe Kapitel "Die Tastaturabfrage mit dem Event-Manager". Hier wird nur erl„utert, wie die Tastaturereignisse bergeben werden.

"event_return.key" enth„lt den Code der gedrckten Taste (2 Bytes). Dieser Code bercksichtigt die Zusatztasten Control, Alternate und Shift. [SHIFT] - "A" gibt also einen anderen Wert zurck als "A".

"event_return.low_key" enth„lt das untere Byte des in "event_return.key" enthaltenen Wertes (event_return.key && 255).

"event_return.high_key" enth„lt das obere Byte des Tastaturcodes (event_return.key >> 8). Dieser Wert ist fr die Tastaturabfrage interessant, da er den Scancode der gedrckten Taste enth„lt. Diese Scancodes sind als Konstanten definiert und werden in den Tastaturmakros abgefragt.

(11) event_return.fl_alpha - int
Dieses Flag ist auf "1" gesetzt, wenn eine alphabetische Taste gedrckt wurde. Ansonsten ist dieses Feld immer Null. Weitere Erl„uterungen finden Sie im Kapitel 2.3.3., wo die Tastaturgruppen erkl„rt werden.

(12) event_return.fl_alphanum - int
Dieses Flag ist auf "1" gesetzt, wenn eine alphanumerische Taste gedrckt wurde. Ansonsten ist dieses Feld immer Null.

(13) event_return.fl_num - int
Dieses Flag ist auf "1" gesetzt, wenn eine numerische Taste gedrckt wurde. Ansonsten ist dieses Feld immer Null.

(14) event_return.fl_zifferbl - int
Dieses Flag ist auf "1" gesetzt, wenn eine Taste vom Ziffernblock gedrckt wurde. Ansonsten ist dieses Feld immer Null.


(15) event_return.fl_crsrpos - int
Dieses Flag ist auf "1" gesetzt, wenn eine Taste gedrckt wurde, die den Cursor neu positioniert und keine Zeichen ausgibt.

(16) event_return.fl_crsrtast - int
Dieses Flag ist auf "1" gesetzt, wenn eine Cursortaste gedrckt wurde. Ansonsten ist dieses Feld immer Null.

(17) event_return.fl_fkttast - int
Dieses Flag ist auf "1" gesetzt, wenn eine Funktionstaste gedrckt wurde. Ansonsten ist dieses Feld immer Null.

(18) event_return.fl_sonstig - int
Dieses Flag ist auf "1" gesetzt, wenn eine Taste gedrckt wurde, die keiner der unter 1 - 17 genannten Bedingungen entspricht.


3.2.3.	Tastaturabfrage mit dem Event-Manager
Ein benutzerfreundliches GEM-Programm sollte nicht nur mit der Maus steuerbar sein, sondern die Funktionen sollten meistens auch mit einem Tastendruck aufrufbar sein. Im folgenden wird Ihnen die Funktionsweise des Event-Managers in Bezug auf die Tastaturereignisse gezeigt.

Der Event-Manager teilt die Tasten des Atari in Tastaturgruppen ein. Siehe dazu die Rckgabefelder 11 - 18, die im vorigen Kapitel beschrieben sind:
-	Alphabetische Tasten (A .. Z, , ™, š, )
-	Alphanumerische Tasten (alphabetische Tasten, 0 .. 9)
-	Numerische Tasten (0 .. 9)
-	Taste auf Ziffernblock
-	Taste, die Cursorposition „ndert:
	(Cursortasten, Enter, Return, Delete, Insert, Backspace, Tab, Space)
-	Cursortaste

-	Funktionstaste
-	Sonstige Taste (die keiner sonstigen Gruppe zugeordnet werden kann)

Eine Taste kann mehreren Tastaturgruppen zugeordnet sein, z.B.:
	<A>	= alphabetisch, alphanumerisch
	<1>	= numerisch, alphanumerisch; (evtl. Ziffernblock)

Da die Tastaturabfrage recht umst„ndlich sein kann, wurden die Scancodes der Tasten (Rckgabefeld "event_return.high_key") in Konstanten hinterlegt. Diese bilden die Grundlage fr die Tastaturabfrage im Event-Manager. Die Konstanten k”nnen von Ihnen auch auerhalb des Event-Managers genutzt werden. Sie setzen sich zusammen aus einem Prefix und dem eigentlichen Tastenkrzel. Der Prefix gibt an welcher Tastaturgruppen diese Taste angeh”rt:

K_	: Buchstaben, Zahlen und Funktionstasten
	K_a .. K_z, K_ae (), K_oe (™), K_ue (š), K_sz (), K_0 bis K_1
	K_f1 .. K_f10	: Funktionstasten F1 bis F10

KZ_	: Taste auf Ziffernblock
	KZ_0 .. KZ_9
	KZ_plus		: +
	KZ_punkt		: .
	KZ_minus		: - 
	KZ_klauf		: (
	KZ_klzu		: )
	KZ_strich		: /
	KZ_mult		: *

KC_	: Cursortasten und -positions„nderung
	KC_return		: Return
	KC_enter		: Enter
	KC_crsrdown	: Cursor runter

	KC_crsrup		: Cursor hoch
	KC_crsrleft		: Cursor links
	KC_crsrright		: Cursor rechts
	KC_delete		: Delete
	KC_insert		: Insert
	KC_home		: Home
	KC_backspace		: Backspace
	KC_tab			: Tabulator
	KC_space		: Leertaste

KX_	: Sonderzeichen
	KX_esc		: Escape
	KX_help		: Help
	KX_undo		: Undo
	KX_akz		: '
	KX_nr			: #
	KX_plus		: + (Nicht Ziffernblock)
	KX_klei		: <
	KX_komma		: ,
	KX_punkt		: .
	KX_minus		: - 
	KX_tilde		: ~
	KX_bslash		: \

KA_	: anderer Scancode, wenn die Alternatetaste gedrckt wurde:
	KA_1 .. KA_0
	KA_sz			: 

KS_	: anderen Scancode, wenn die Shifttaste gedrckt wurde:
	KS_f1 .. KS_f10	: Funktionstasten mit Shifttaste

KCT_	: anderer Scancode, wenn die Controltaste gedrckt wurde:
	KCT_home		: Home
	KCT_crsrright	: Cursor links
	KCT_crsrleft	: Cursor rechts


Bis auf Control, Alternate und die Shifttasten erzeugen alle Tasten ein Ereignis, wenn Sie Tastaturereignisse dem Event-Manager vorgegeben haben. Wie Sie vielleicht schon bemerkt haben, ist die ganze Zeit von Tasten die Rede und nicht von Zeichen. Etliche Tasten sind mit mehreren Zeichen belegt, wie z.B. die Zahlenleiste. Die Sonderzeichen ber den Ziffern sind mittels der Shifttaste zu erreichen. Das Ereignis liefert aber fr die Ziffer (z.B. 1) und das darberliegende Sonderzeichen (hier !) den gleichen Scancode. Der Scancode fr fast (!) jede Taste bleibt auch bei Zusatztasten gleich. Eine Ausnahme bilden zum einen die Funktionstasten, deren Scancode sich „ndert, wenn die Shifttaste gedrckt wird. Auerdem „ndert sich der Scancode der Tasten <1> bis <0>, von <> und <'>, wenn die Alternatetaste gedrckt wurde. Daher sind fr diese Tasten zwei Konstanten definiert worden, wobei der Prefix "KS_" fr die Shifttasten und "KA_" fr die Alternatetaste steht. Der Scancode der Tasten <HOME>, <CURSOR links> und <CURSOR rechts> „ndert sich, wenn die Controltaste gedrckt wird (Prefix "KCT_").

Um umst„ndliche Abfragen zu vermeiden (die Feldnamen des Event- Managers sind leider recht lang), existiert fr jede Taste ein Makro, das die entsprechenden Rckgabefelder abfragt. Sie liefern den Wert "1" (TRUE) zurck, wenn die abgefragte Taste gedrckt wurde. Im anderen Fall wird der Wert "0" (FALSE) zurckgegeben.


a) Zusatztasten abfragen (Rckgabefeld "event_return.mouse_k")

EVNT_RSHIFT()	/* auf rechte Shifttaste untersuchen    */
EVNT_LSHIFT()	/* auf linke Shifttaste untersuchen     */
EVNT_SHIFT()		/* auf irgendeine Shifttaste untersuchen */
EVNT_CTRL()		/* auf Control-Taste untersuchen	    */
EVNT_ALT()		/* auf Alternate-Taste untersuchen    */
EVNT_ALTSHIFT()	/* auf Shift- und Alternatetaste prfen  */
EVNT_CTRLSHIFT()	/* auf Control- und Alternatetaste prfen*/



b) Tastatur des ATARI ST
Jede Taste des ATARI ST ist ber ein Makro ansprechbar. Diese Makros bedienen sich der Scancodes der Tastatur. Der Makroname setzt sich folgendermaen zusammen: KEY_<zusatz><tastenkrzel>(). Die Tastenkrzel entsprechen denen der Konstanten fr die Scancodes. Der Zusatz ist fr die Tasten gedacht, deren Scancode sich mit dem Drcken von Zusatztasten „ndert. Hier nun ein Beispiel fr "":

KEY_asz()	Alternate + ""
KEY_nsz()	"" mit oder ohne Zusatztaste, ohne die Alternatetaste
KEY_sz()	""; Makros ohne den Zusatz betreffen die Taste mit allen M”glichkeiten von Zusatztasten, hier also KEY_asz() oder KEY_nsz()

Es werden nur die Tasten aufgefhrt, deren Scancode durch Zusatztasten ge„ndert werden. Das Makro KEY_<tastenkrzel> enth„lt die logische Oder-Verknpfung aller M”glichkeiten der gleichen Taste mit Zusatz und ist unten nicht weiter beschrieben. In der Beschreibung werden folgende Abkrzungen benutzt: ZR = Ziffernreihe ber den Buchstaben; ZB = Ziffern-/Zehnerblock; ALT = Alternate-Taste; SHIFT = Shifttaste:

- Buchstaben	:	KEY_asz() = ALT + 
			KEY_nsz() =  (ohne ALT)

- Ziffern	:	KEY_n<ziffer> = ZR (ohne ALT, nicht ZB)
			KEY_a<ziffer> = ALT + ZR (nicht ZB)

- Fkttasten	 :	KEY_n<fkttaste> = Fkt-taste (ohne SHIFT)
			KEY_s<fkttaste> = SHIFT + Funktionstaste

- Sonderzeichen:	KEY_nstrich()	= /  (SHIFT + 7, nicht ZB)
			KEY_zstrich()	= /  auf ZB
			KEY_nklauf()	= (  (SHIFT + 8, nicht ZB)
			KEY_zklauf()	= (  auf ZB

			KEY_nklzu()	= ) (SHIFT + 9, nicht ZB)
			KEY_zklzu()	= )  auf ZB
			KEY_nplus()	= +  (nicht auf ZB)
			KEY_zplus()	= +  auf ZB
			KEY_nmult()	= *  (SHIFT + <+>,nicht ZB)
			KEY_zmult()	= *  auf ZB
			KEY_npunkt()	= .  (nicht auf ZB)
			KEY_zpunkt()	= .  auf ZB
			KEY_nminus()	= -  (nicht auf ZB)
			KEY_zminus()	= -  auf ZB
			KEY_nreturn()	= Return
			KEY_zreturn()	= Enter
			KEY_return()	= Return oder Enter
			KEY_ccrsrleft() = Control + Cursor left
			KEY_ncrsrleft() = Cursor left, ohne Control
			KEY_ccrsrright() = Control + Cursor right
			KEY_ncrsrright() = Cursor right, ohne Control
			KEY_chome()	= Control + Home
			KEY_nhome()	= Home, ohne Control


3.2.4.	Funktionsaufruf und Einbindung in das Programm
Um den Event-Manager nutzen zu k”nnen, mssen Sie die Headerdatei event.h in Ihr Programm einbinden. Sollten Sie die in der Anleitung angegebenen Konstanten fr gewissen šbergabewerte benutzen, mssen Sie zus„tzlich die Headerdatei gemdefs.h (Mark Williams C) einbinden.

Folgende Felder mssen in Ihrem Programm global definiert werden:

EVNT			event;		/* Parameterbergabe */
EVNT_RETURN	event_return;	/* Rckgabestruktur */



Um alle Felder, die fr die šbergabe und Rckgabe notwendig sind, einheitlich zu initialisieren, sollten Sie die Funktion "v_evntinit()" aufrufen. Sie initialisiert alle numerischen Felder mit "0".

	void	v_evntinit(flag)

Parameterbergabe:
	int	flag;

(1) flag - int
Bei "0" werden alle šbergabefelder (event.) initialisiert, bei "1" die Rckgabefelder (event_return.).

Rckgabeparameter:	keine


Die eigentliche Ereignisabfrage erfolgt mit der Funktion v_event()

	void	v_event()

Parameterbergabe:	keine
Parameterrckgabe:	keine


3.3.	Funktionsbersicht

void	v_event()	"Auf AES-Ereignis warten"
	šbergabe:	keine
	Rckgabe:	keine

void	v_evntinit(flag)	"Felder initialisieren"
	šbergabe:
		0:	šbergabefelder initialisieren
		1:	Rckgabefelder initialisieren
	Rckgabe:	keine



3.4.	Sonstiges

Literatur:	- Handbuch zu Mark Williams C
		- "Tiefen einer Oberfl„che" c't 1990, Heft 5

Autor des Event-Managers	: Volker Nawrath
Handbuch			: Volker Nawrath

4.	Einleitung zum Window-Manager

Der Window-Manager ist eine Bibliothek mit C-Funktionen zur Untersttzung der Fensterverwaltung. Diese sollen (und werden) dem Programmierer die Arbeit mit den Fenstern vereinfachen.

Das Grundgerst zur Fensterverwaltung wurde einem Kurs der ST- Computer (05/89 bis 10/89) entnommen, dessen Autor Andreas L”tscher ist. Auf diesem Gerst aufbauend wurde ein Gesamtpacket entwickelt, da universell in jedem C-Programm auf dem ATARI ST/TT benutzt werden kann.

	Version  3.20 vom 29.11.92


4.1.	nderungen gegenber Version 3.00

Siehe dazu die README-Datei auf der Diskette


4.1.	Begriffsbestimmung

4.1.1.	Fenster und deren Elemente

Die Fenster unter GEM k”nnen eine ganze Reihe von Elementen zur Steuerung bzw. Information enthalten. Da dieses Handbuch ausgiebig auf deren Programmierung und Anwendung eingeht, sollen sie hier grunds„tzlich erl„utert werden.


<< Bild: "BILD_1.IMG" >>



CLOSER	Wird dieser Teil angeklickt, schliet sich das Fenster.

MOVER	Befindet sich der Mauszeiger auf dem grauen Balken und wird die linke Maustaste gedrckt, erscheint ein Rahmen in der Gr”e des Fensters. Bleibt die Maustaste gedrckt, kann das Fenster bewegt werden. Im MOVER-Balken kann ein Text angegeben werden. Dieser wird Fenstername genannt.

INFOZEILE	Die Infozeile kann beliebigen Text aufnehmen.

FULLER	Wird er angeklickt, vergr”ert sich das Fenster auf seine volle Gr”e, bzw. geht auf die ursprngliche Gr”e zurck.


UPARROW	Mit Anklicken wird der Fensterausschnitt um eine Zeile nach oben bewegt.

DNARROW	Mit Anklicken desselbigen wird der Fensterausschnitt um eine Zeile nach unten bewegt.

LFARROW	Wird dieser Pfeil angeklickt, bewegt sich der Fensterausschnitt um eine Spalte nach links.

RTARROW	Der Fensterausschnitt bewegt sich um eine Spalte nach rechts, wenn dieser Pfeil angeklickt wird.

VSLIDE	Der vertikale Schieber/Schiebebalken dient der Verschiebung des Fensterausschnittes um mehr als eine Zeile. Seine Position gibt die Position des Ausschnittes zum Gesamtinhalt an. Je l„nger er ist, umso mehr zeigt der Fensterausschnitt vom Gesamtinhalt. Er kann beliebig nach oben oder unten verschoben werden (Vorgehensweise wie beim MOVER). Wird der graue Bereich darber oder darunter angeklickt, verschiebt sich der Fensterausschnitt um eine Seite nach oben bzw. unten.

HSLIDE	Dies ist der vertikale Schieber/Schiebebalken. Er dient der Verschiebung des Fensterausschnittes um mehr als eine Spalte. Gr”e und Position verhalten sich wie beim VSLIDE. Wird der graue Bereich daneben angeklickt, wird der Fensterausschnitt um eine Seite nach rechts bzw. links verschoben.

SIZER	Mit dem Sizer kann die Gr”e des Fensters ver„ndert werden (Vorgehen wie beim MOVER).



4.1.2.	Sonstige Begriffe

Der Handle ist eine Nummer, die vom AES vergeben wird, um die Fenster identifizieren zu k”nnen. Ein Fenster ist angemeldet, nachdem ein Handle fr dieses Fenster vergeben wurde. Ge”ffnet ist ein Fenster, wenn es auf dem Desktop dargestellt wird. Ein Fenster ist gel”scht, wenn der Handle wieder freigegeben wurde. Es existiert dann keine Fensterbeschreibung fr diese Identifikationsnummer.

Der Window-Manager speichert sich alle fr ihn relevanten Daten im Bereich "windows[]", fr den er extra Speicher reserviert. Dieser Bereich ist ein Array, dessen Gr”e durch die Funktion win_init() festgelegt wird. Nach Auen arbeitet der Window-Manager nicht mit dem Fensterhandle, sondern mit dem Index, unter dem er die Fensterdaten speichert. Der Bereich dieses Index liegt zwischen Null und Gr”e des Array's - 1. Alle Schnittstellen zum Window-Manager verlangen diesen Index, den sie auch benutzen mssen, wenn sie auf die Fensterdaten (windows[]) zugreifen m”chten.

Der Rahmenbereich (die Gesamtgr”e) des Fensters ist durch dessen „uerstern Rand begrenzt. Die Fl„che, in der Texte bzw. Bilder dargestellt werden, ist der Arbeitsbereich bzw. Fensterausschnitt (= Rahmenbereich ohne Fensterelemente). Dieser Bereich stellt einen rechteckigen Ausschnitt des gesamten Fensterinhaltes dar. Dieser Inhalt wird auch Dokument genannt.

Ein Dokument unterteilt sich in Zeilen und Spalten. Diese k”nnen ein oder mehrere Punkte (Pixel) gro sein. Die Anzahl Pixel, die eine Spalte oder Zeile ausmachen, wird Scrollwert genannt. Ein Zeichen im hochaufl”senden ST-Modus hat z.B. einen horizontalen Scrollwert von 8 und einen vertikalen Scrollwert von 16. Der Scrollwert ist die Anzahl von Bildschirmpunkten, um die der Inhalt im Arbeitsbereich verschoben wird.


Das aktuelle Fenster ist das Fenster, in dem alle Ausgaben erfolgen. Ein Fenster "nach oben holen" bedeutet, dieses aktuell zu machen.


4.2.	Einbinden des Window-Managers

Zuerst werden die Voraussetzungen fr die Benutzung des Window-Manager beschrieben. Danach folgen die Erl„uterungen zu den einzelnen Schnittstellen und Arbeitsabl„ufen.

4.2.1.	Voraussetzungen

Sie mssen folgende Vorbereitungen treffen, wenn Sie den Window-Manager nutzen wollen:

a)	Headerdatei window.h einbinden, wo die Funktionen der Fensterverwaltung aufgerufen werden.

b)	Folgende Felder mssen Sie global in Ihrer Programmdatei deklarieren, wenn Sie den Window-Manager nutzen wollen:

	WIND_DATA	*windows; /* Definition im Modul mit dem
					 Hauptprogramm, ansonsten "extern"

	ACT		before;

Der Window-Manager nutzt daneben auch den globalen Bereich aktuell, den Sie im Zuge der Einbindung des GEM-Managers schon deklariert haben sollten.

c)	Die Fensterverwaltung mu ersteinmal initialisiert werden. Dies geschieht mit:
			int  win_init(max_window)
		    int  max_window;


Die Variable "max_window" enth„lt die max. Anzahl von Fenstern, die in diesem Programm angelegt werden drfen. Anhand dieser Zahl wird entsprechend Speicher fr die Fensterdaten reserviert und initialisiert. Tritt kein Fehler auf, gibt die Funktion "0" zurck, im Falle eines Fehlers folgende Werte:
		-1	= falscher Wert in "max_window"
		-2	= es konnte kein Speicher reserviert werden

d)	Vor Programmende mu die Fensterverwaltung abgemeldet werden:
			void  win_exit()

Diese Funktion schliet alle noch offenen Fenster und schliet dann die noch angemeldeten. Danach wird der Speicher fr die Fensterdaten freigegeben. Diese Funktion mu vor gem_exit() aufgerufen werden.


4.2.2.	Schnittstellen  Window-Manager <-> Programm

Der Window-Manager nutzt drei Feldbereiche , aus denen Sie als Programmierer Informationen ber das System entnehmen k”nnen, bzw. in denen die Parameter fr die Fensterverwaltung enthalten sind.

a) ACT aktuell;
Dieser Bereich wird Ihnen schon vom GEM-Manager allgemein zur Verfgung gestellt. Hier sollen nur noch die Felder erl„utert werden, die vom Window-Manager versorgt werden.

int aktuell.max_user_wind;	/* Max. Anzahl von Fensterns */
int aktuell.windanz;		/* Anzahl der vom AES angem. Fenster */
int aktuell.anzahl;		/* Anzahl der ge”ffneten Fenster */

int aktuell.handle;	/* Handle vom gerade aktuellen Fenster */

/* neu zu zeichnender Fensterbereich in Pixel (Redraw) */
RECT	aktuell.neu_pix;

/* neu zu zeichnender Fensterbereich in Zeilen und Spalten */
DOKPOS	aktuell.neu_doc:

b) ACT before;
Dieser Bereich erh„lt die Werte aus dem Bereich "aktuell", bevor das Fensterereignis durch den Window-Manager verarbeitet wird. So haben Sie die Kontrolle, welche Werte sich durch ein Fensterereignis ge„ndert haben, z.B. welches Fenster vor dem Ereignis aktuell war. Der Window-Manager greift in dieser Version nicht auf diesen Bereich zu.

c) Fensterbeschreibung windows[]
Jedes Fenster erh„lt seinen Beschreibungsbereich. Dieser Bereich ist in einer Tabelle enthalten, die oben schon erl„utert wurde. Die Werte dieser Tabelle drfen Sie niemals direkt „ndern, auer Sie sind ein Fan von Programmabstrzen. Der Window-Manager stellt Ihnen dazu Funktionen fr deren Manipulation zur Verfgung. Alle nachfolgend aufgefhrten Feldern sind Member des Feldes "windows[]" und beginnen daher mit "windows[].":

int handle;	/* Fensterhandle					*/
typedef struct RSCDATA	/* Fr Dialogboxen in Fenstern	*/
int fenster;	/* Kz, ob dieses Handle ein Fenster ist
		 * (TRUE =Fenster, FALSE = kein Fenster)	*/
int delclose;	/* Kz, ob Fenster nach Schlieen gel”scht wird
		 * (TRUE = l”schen, FALSE = nur schlieen)	*/
int offen;	/* Kz, ob Fenster offen oder geschlossen
		 * (TRUE  = offen, FALSE = geschlossen)	*/
char name[80];	/* Text fr Fenstername			*/

char info[80];	/* Text fr Infozeile					*/
int wmin;	/* minimale Breite des Fensters			*/
int hmin;	/* minimale H”he des Fensters 			*/
RECT max;	/* maximale Gr”e des Fenster in Pixel		*/
RECT work;	/* Arbeitsbereich des Fensters
		 * ( x/y-Koordinate in Pixel,
		 *  w/h = Breite/ H”he in Spalte und Zeile)	*/
RECT	allpix;	/* Rahmenbereich des Fensters in Pixel		*/
RECT	workpix;	/* Arbeitsbereich des Fensters in Pixel	*/
int elements;		/* Elemente des Fensters			*/
int align;		/* Align-Wert				*/
int snap;		/* Snap-Wert				*/
int full;			/* Kz, ob Fenster auf voller Gr”e
			 * (TRUE  = volle Gr”e,
			 * FALSE = nicht volle Gr”e)		*/
int scroll_x;		/* horizontaler Scroll-Wert in Pixel	*/
int scroll_y;		/* vertikaler Scroll-Wert in Pixel		*/
long doc_x;		/* Dokumentenposition Spalte		*/
long doc_y;		/* Dokumentenposition Zeile		*/
long doc_length;	/* Dokumentenl„nge in Zeilen		*/
long doc_width;	/* Dokumentenbreite in Spalten		*/
void (*w_redraw)();	/*Zeiger auf Redraw-Funktion		*/
IMAGE wsave;	/* Bereich, in dem die erforderlichen Daten
			 * fr den gesicherten Arbeitsbereich des
			 * Fensters stehen; wichtig fr den automa
			 * tischen Redraw				*/
int fl_wsave;		/* Kennzeichen, ob Window-Manager die Re
			 * staurierung des Arbeitsbereiches bernehmen
			 * soll:
			 * = TRUE	Window-Manager restauriert
			 * = FALSE	Programmierer bernimmt Restaurie
			 *		rung vom Fenster		     */
void (*userfkt)();	/* Nachbereitungsfunktion; hat der Window-	
			 * Manager ein Fensterereignis verarbeitet,
			 * so ruft er diese Funktion auf, bevor er

			 * die Kontrolle an das Progr.zurckgibt  */
int fl_userfkt;		/* Flag, ob userfkt() aufgerufen werden soll:
			 * = TRUE	userfkt() aufrufen
			 * = FALSE	userfkt() nicht aufrufen	     */


4.3.	Anmelden und ™ffnen eines Fensters

Bevor ein Fenster dargestellt werden kann, mu es beim AES angemeldet und ge”ffnet werden. Dies geschieht beim Window-Manager mit einem Funktionsaufruf. Dieser Funktion sind alle Daten des neuen Fensters zu bergeben.


4.3.1.	Funktionsbeschreibung fr das ™ffnen des Fensters

Das Anmelden und ™ffnen eines Fensters geschieht durch folgenden Aufruf (bitte lassen Sie sich nicht durch die Parametervielfalt einschchtern):

int	open_window(w_name, w_info, redraw, fl_wsave, was, algn,
			snp, delclose, s_x, s_y, doc_l, doc_w, doc_x,
			doc_y, x1, y1, w1, h1, w_min, h_min,
			x_max, y_max, w_max, h_max,
			userfkt, fl_userfkt				)


šbergabeparameter;
	char	*w_name,*w_info;
	void	(*redraw)();
	int	fl_wsave,was,algn,snp,delclose,s_x,s_y;
	long	doc_l,doc_w,doc_x,doc_y;
	int	 x1,y1,w1,h1,w_min,h_min,x_max,y_max,w_max,h_max;
	void	(*userfkt)();
	int	fl_userfkt;



(1) was - int
Zuallererst mu der Programmierer entscheiden, welche Elemente sein Fenster enthalten soll. Er hat dabei folgende Auswahl:

	0x001	NAME		Titelname
	0x040	UPARROW	Pfeil nach oben
	0x002	CLOSE		Schlieecke
	0x080	DNARROW	Pfeil nach unten
	0x004	FULL		Vollegr”eecke
	0x100	VSLIDE		Vertikaler Schieber
	0x008	MOVER	Schiebebalken	
	0x200	LFARROW	Pfeil nach links
	0x010	INFO		Infozeile
	0x400	RTARROW	Pfeil nach rechts
	0x020	SIZER		Gr”enecke
	0x800	HSLIDE	Horizontaler Schieber

Die gewnschten Elemente werden summiert und als INT-Wert bergeben.

(2) x1,y1,w1,h1,w_min,h_min,x_max,y_max,w_max,h_max,snp - int
Als n„chstes mssen Sie die Gr”e und die Position des Fensters angeben. Diese beziehen sich auf die Gesamtgr”e des Fensters. šbergeben werden die x- und y-Koordinate der linken oberen Ecke und die Breite und H”he in Pixel (x1,y1,w1,h1).
Sie haben die M”glichkeit, eine maximale Gr”e des Fensters durch die Parameter x_max,y_max,w_max,h_max anzugeben. Sie stellen praktisch ein Rechteck dar, dessen Fl„che das Fenster nicht verlassen darf. Sollte dies trotzdem geschehen, werden die Koordinaten und die Gr”e des Fensters automatisch korrigiert. Wird w_max=0 bergeben, stellt der Desktop die max. Gr”e dar (ohne Menuleiste). Die eigentliche Entscheidung, ob die max. Gr”e abgefragt werden soll, geschieht mit dem Parameter "snp". Ist er TRUE, wird die Maximalgr”e beachtet, bei FALSE werden die Werte ignoriert.

Mit den Parametern w_min und h_min kann die minimale Gr”e des Fensters angegeben werden. Wird einer dieser Werte unterschritten, wird die Fenstergr”e korrigiert. Enth„lt einer dieser Parameter Null, so erfolgt fr diesen keine Gr”enkontrolle. Da heit, da das Fenster beliebig schmal bzw. kurz werden kann.

(3) delclose - int
Mit diesem Parameter kann entschieden werden, ob nach dem Schlieen des Fensters dieses gleich gel”scht werden soll. Bei TRUE wird ein Fenster nach dem Schlieen (z.B. durch den Closer) auch gel”scht, bei FALSE wird es nur geschlossen.

(4) algn - int
Dieser Parameter dient dem Ausrichten der x-Koordinate des Arbeitsbereiches an einen bestimmten Wert. Wenn man in einem Fenster z.B. Text ausgeben m”chte, kann dieser Wert auf 8 gesetzt werden. Damit wird dafr gesorgt, da die Fenstergrenzen an Wortgrenzen ausgerichtet sind und die Textausgabe etwas schneller abl„uft. In der Praxis sieht es so aus, da eine Zahl errechnet wird, die ein ganzzahliges Vielfaches von dieser Koordinate ist und der ursprnglichen Koordinaten am n„chsten liegt. Der Nachteil dieser Verfahrensweise liegt darin, da kein pixelgenaues Verschieben des Fensters m”glich ist. Wird algn = 0 bergeben, so findet keine Ausrichtung der x-Koordinate statt.

(5) s_x,s_y - int
Die Werte geben die Gr”e der Zeilen (s_y) und Spalten (s_x) in Punkten an (= Scrollwert). Diese Werte sind wichtig, da der Fensterausschnitt immer nur um Zeilen / Spalten verschoben wird. Wird z.B Text im Fenster bei hoher Aufl”sung dargestellt, mssen die Werte auf s_x=8 und s_y=16 gesetzt werden.

(6) doc_x,doc_y,doc_l,doc_w - long
Die Parameter doc_l und doc_w geben die L„nge und Breite des Gesamtinhaltes in Zeilen und Spalten an. Die Parameter doc_x und doc_y geben die Zeile und Spalte an, deren Schnittpunkt in der linken oberen Ecke des Arbeitsbereiches liegt.

(7) w_name,w_info
Mit dem Parameter w_name wird der Fenstername angegeben, der im MOVER steht. In w_info steht der Text, der in der Infozeile ausgegeben wird.

(8) redraw,fl_wsave
Mit dem Parameter redraw wird ein Zeiger auf die Funktion bergeben, die fr die Ausgabe des Fensterinhaltes zust„ndig ist. Sie mu vom Programmierer erstellt werden (wie sonst?). Jedes Fenster hat so seine eigene Routine, die automatisch vom Window-Manager angesprungen wird. Allerdings k”nnen Sie entscheiden, ob diese Routine jedesmal angesprungen werden soll oder ob der Window-Manager den gr”ten Teil der Restaurierung selbst bernehmen soll. Dies geschieht mit fl_wsave, wobei bei TRUE vorher verdeckte Teile des Arbeitsbereiches vom Window-Manager selbstst„ndig wiederhergestellt werden. Bei FALSE bernimmt die Redraw-Routine des Programmierers die gesamte Ausgabearbeit. Bitte lesen Sie auf alle F„lle das Kapitel ber den automatischen Redraw, da dort genau beschrieben ist, wann er durchgefhrt wird.

(9) userfkt, fl_userfkt
Mit "userfkt" wird ein Zeiger auf eine Funktion bergeben, die nach der Verarbeitung eines Fensterereignisses vom Window-Manager aufgerufen wird. Sie wird Nachbereitungsfunktion genannt. Nach Beendigung dieser Funktion wird die Kontrolle an das lfd. Programm zurckgegeben. Ist das Feld "fl_userfkt" auf FALSE gesetzt, wird der Aufruf der Nachbereitungsfunktion unterdrckt, bei TRUE wird sie immer aufgerufen.

Der Window-Manager gibt beim Aufruf das Ereignis und den Index des Fensters mit, da fr das Auftreten des Ereignisses verantwortlich ist. Sie mssen die Nachbereitungsfunktion also mit zwei Parametern definieren:
	void	userfkt(was,w_index)
		int	was;		/* Ereignis			*/
		int	w_index;	/* Index des Fensters	*/

Der Window-Manager erledigt viele Dinge automatisch und fr das aufrufende Programm unsichtbar. Das Anwendungsprogramm hat also nicht immer die Kontrolle darber, was fr Ereignisse vorliegen und was der Window-Manager fabriziert. Dies betrifft immer die ereignisgesteuerte Fenstermanipulation. So kann z.B. ein Fenster mit der Maus geschlossen werden (CLOSER-Feld), ohne da das aufrufende Programm an der Verarbeitung des Ereignisses beteiligt ist. Fr Sie als Programmierer kann es manchmal von Bedeutung sein, zu wissen, wann ein Fenster geschlossen wird, da noch weitergehende Verarbeitungen notwendig sind.

Zur Verdeutlichung des Nutzens einer Nachbereitungsfunktion, folgt ein Beispiel aus der "Praxis". Betrachten wir das Textverarbeitungsprogramm First Wordplus, wo eine geladene Textdatei in einem Fenster dargestellt wird. Das Schlieen des Fensters durch den "Closer" bewirkt auch das L”schen der Datei aus dem Speicher. Ist kein anderes Fenster ge”ffnet, also keine weitere Datei geladen, werden bestimmte Menpunkte gesperrt (wie Suchfunktionen, Textformatierung usw.). Ohne die Nachbereitungsfunktion h„tten Sie als Programmierer keine M”glichkeit das Schlieen des Fensters durch den "Closer" festzustellen, um die Menpunkte zu sperren.

Achtung	Die Nachbereitungsfunktion wird nach jeder(!) Ereignisverarbeitung aufgerufen. Wenn Sie mehrere Fenster ge”ffnet haben und die Position eines Fensters ver„ndern, so speichert das AES Ereignisse fr die Restaurierung der restl. Fenster. Nach jedem Redraw eines Fensters wird die Nachbereitungsfkt. des Fensters angesprungen!



Parameterrckgabe:
open_window()  >= 0	Verarbeitung OK,
				Index des Fensters wird zurckgegeben
open_window()   = -1	Max. Anzahl der Fenster schon angelegt
				(durch win_init() vorgegeben)
open_window()   = -2	Das AES konnte kein Fenster anlegen


4.3.2.	Verarbeitung

Die Funktion open_window() bernimmt das Anmelden und ™ffnen eines Fensters. Kann das AES diese Fenster anlegen, gibt es den Handle zurck, der das Fenster identifiziert. Dieser Handle, alle Parameter und errechneten Werte werden in der Tabelle "windows[]" abgelegt. Dabei sucht sich die Funktion, von Null beginnend, den ersten freien Tabellenplatz. Der Index dieses Tabelleneintrages wird von open_window() zurckgeben und stellt damit das Ordnungskriterium fr die Kommunikation zwischen Programm und Window-Manager dar.

Die max. Anzahl von gleichzeitig angelegten Fenstern ist einerseits von dem Wert abh„ngig, den Sie durch win_init() vorgeben. Andererseit setzt das AES zur Zeit (November '92) Grenzen. Durch win_init() k”nnen Sie allerdings gr”ere Werte vorgeben, als zur Zeit m”glich sind. open_window() gibt dann entsprechende Fehlermeldungen aus.

Zus„tzlich wird die Dokumentenposition auf ihre Plausibilit„t hin berprft und gegebenenfalls korrigiert. Ebenso werden die Koordinaten und die Gr”e des Fensters an den Alignwert, die Minimal- und Maximalwerte angepat.

L„uft das Programm auf einem Multitasking-System, wird der automatische Redraw in jedem Fall ausgeschaltet, egal welchen Wert Sie open_window() bergeben.



Achtung	Die Funktion open_window() bernimmt nicht das Zeichnen des Fensterinhaltes. Nach dem ™ffnen des Fenster wird beim AES ein Ereignis fr die Ausgabe des gesamten Fensterinhaltes gespeichert. Sie als Programmierer mssen also dafr sorgen, da nach dem ™ffnen des Fensters dieses Ereignis abgearbeitet wird.


4.4.	Aufruf des Window-Managers

Damit Window-Manager aktiv werden kann, mu er aufgerufen werden. Dafr stehen 3 Funktionen zur Auswahl. Die Funktion handle_window() mu aufgerufen werden, wenn die Fenstermanipulation ber AES-Ereignisse geschieht, also mit der Maus gearbeitet wird. Soll das Fenster ohne Maus ver„ndert werden, mssen die Funktionen wm_call() bzw. wind_info_set() aufgerufen werden.


4.4.1.	Ereignisgesteuerte Fenstermanipulation

Klicken Sie mit der Maus ein Element des Fensters an, so wird dies als Ereignis in einem Puffer abgelegt. Das AES kennt verschiedene Ereignisse. Ein Fensterereignis wird als "Meldung von einem Proze" in Form einer Nachricht gespeichert (MU_MESAG). Die Meldung (Nachricht) wird in einem Puffer bergeben. In ihr stehen die Art der "Meldung" und die entsprechenden Rckgabewerte. Eine Funktion, mit der man auf dieses Ereignis warten kann, heit evnt_mesag(buffer). Tritt nun ein solches Ereignis ein, wird die Kontrolle wieder an das Programm bergeben. Nun mu der Window-Manager aufgerufen werden, der die Nachricht analysiert und die entsprechenden nderungen durchfhrt. Dies sieht in der Praxis wie folgt aus:

do	/* Schleife, in der auf Ereignisse gewartet wird*/
{
	evnt_mesag(buffer);	 /* auf Fensterereignis warten */

	handle_window(buffer);/* Window-Manager aufrufen*/

}	while(bedingung);	/* Abbruchbedingung*/

Statt evnt_mesag() kann auch evnt_multi() verwandt werden. Auf alle F„lle sollten beide Funktionen in eine Schleife eingebaut werden, damit alle durch die Fenstermanipulation entstandenen Ereignisse gelesen und vom Window-Manager verarbeitet werden k”nnen. Fr n„here Informationen ber diese Funktionen lesen Sie bitte im Handbuch Ihres Compilers nach.

Der Funktion handle_window() braucht lediglich die Nachricht bergeben werden, der Rest wird vom Window-Manager erledigt.


Funktionsbeschreibung

	void handle_window(buffer)

Parameterbergabe:
	int buffer[8];

(1) buffer[8] - int
Art und Inhalt der Nachricht vom AES

Parameterrckgabe:	keine


4.4.2.	Programmgesteuerte Fenstermanipulation

Der Window-Manager kann die Fenster auch durch Funktionsaufruf manipulieren, ohne da Ereignisse vorliegen mssen. Diese Funktion ist folgendermaen definiert:


	int	wm_call(flag,param,lparam)

Parameterbergabe:
	int	flag;
	int	param[5];
	long	lparam[4];

(1) flag - int
Mit "flag" wird angegeben, was am Fenster ge„ndert werden soll. Unten werden die Werte mit samt den in der Headerdatei window.h definierten Konstanten aufgelistet. Auerdem werden hier vorweg die nderungsparameter beschrieben.

50 WM_OPEN	™ffnen eines angemeldeten Fensters; Das Fenster erh„lt die gleiche Position und Gr”e, die es beim Schlieen vorher eingenommen hatte.
	param[0] = Index des Fensters

51 WM_CLOSE	Schlieen des aktuellen Fensters;
	== keine Parameterbergabe ==

52 WM_DEL	L”schen eines Fensters. Ist das Fenster noch ge”ffnet, so wird es vorher geschlossen;
	param[0] = Index des Fensters

53 WM_POS	Positionieren des aktuellen Fensters. Es sind nur Koordinaten innerhalb des Bildschirms erlaubt, wobei die Menleiste ausgenommen ist (aktuell.menu_y). Darf da Fenster nur innerhalb eines bestimmten Rechteckes liegen, so erfolgt bei šberschreitung automatisch eine Korrektur.
	param[1] = x-Koordinate des Rahmenbereiches

	param[2] = y-Koordinate des Rahmenbereiches

54 WM_SIZE	Neue Gr”e des Rahmenbereiches des aktuellen Fensters. Das Fenster darf nicht gr”er als der Bildschirm sein. Werden eine evtl. Minimal- oder Maximalgr”e unter-/berschritten, so erfolgt automatisch eine Korrektur.
	param[1] = Breite des Rahmenbereichs
	param[2] = H”he des Rahmenbereichs

55 WM_FULL	Aktuelles Fenster auf max. bzw. ursprngl. Gr”e bringen
	== keine Parameterbergabe ==

56 WM_TOP	Fenster nach oben bringen, also zum aktuellen Fenster machen;
	param[0] = Index des Fensters

57 WM_SDOWN	Gibt die n„chste Seite des aktuellen Dokumentes im Arbeitsbereich aus;
	== keine Parameterbergabe ==

58 WM_SUP	Gibt die vorige Seite des aktuellen Dokumentes im Arbeitsbereich aus;
	== keine Parameterbergabe ==

59 WM_SLEFT	Gibt die links neben dem aktuellen Arbeitsbereich liegende Seite aus;
	== keine Parameterbergabe ==

60 WM_SRIGHT	Gibt die rechts neben dem aktuellen Arbeitsbereich liegende Seite aus;
	== keine Parameterbergabe ==


61 WM_LDOWN	Bewegt den aktuellen Arbeitsbereich um eine Zeile im Dokument nach unten;
	== keine Parameterbergabe ==

62 WM_LUP	Bewegt den aktuellen Arbeitsbereich um eine Zeile im Dokument nach oben;
	== keine Parameterbergabe ==

63 WM_LLEFT	Bewegt den aktuelle Arbeitsbereich um eine Spalte im Dokument nach links;
	== keine Parameterbergabe ==

64 WM_LRIGHT	Bewegt den aktuellen Arbeitsbereich um eine Spalte im Dokument nach rechts;
	== keine Parameterbergabe ==

65 WM_TEXT	Positioniert den Arbeitsbereich im Dokument neu, wobei die Zeile und Spalte angegeben werden mssen, die in der linken oberen Ecke des Arbeitsbereichs ausgegeben werden sollen;
	lparam[0] = Textspalte
	lparam[1] = Textzeile

66 WM_MAX_V	Fr das Fenster wird eine neue Dokumentenl„nge in Zeilen angegeben;
	param[0] = Index des Fensters
	lparam[0] = Gesamtl„nge Dokument in Zeilen

67 WM_MAX_H	Fr das Fenster wird eine neue Dokumentenbreite in Spalten angegeben;
	param[0] = Index des Fensters
	lparam[0] = Gesamtbreite Dokument in Spalten


68WM_FREDRAW	Der Fensterinhalt soll neu ausgegeben werden
	param[0] = Index des Fensters

69 WM_CLEAR	Der Arbeitsbereich des Fensters soll gel”scht werden
	param[0] = Index des Fensters

Eine Anmerkung noch zur Positionierung des Arbeitsbereiches im Dokument beim ereignisgesteuerten und programmgesteuerte Positionieren. Bevor der Ausschnitt des Dokumentes im Arbeitsbereich ausgegeben wird, erfolgt eine Prfung, ob das Dokumentenende bzw. der -anfang erreicht wurde. Evtl. šberschreitungen oder Unterschreitungen werden korrigiert, es erfolgen also keine Fehlermeldungen. Der Arbeitsbereich wird so positioniert, da beim seitenweisen Vorw„rtsbl„ttern die jeweils letzte Zeile bzw. Spalte, nach dem Zurckbl„ttern die erste Zeile bzw. Spalte im Arbeitsbereich ist. Auerdem kann nie ber das Dokumentenende hinausgebl„ttert werden. Die letzte Seite eines Dokumentes wird so ausgegeben, das die letzte Zeile/Spalte des Dokumentes in der letzten Zeile/Spalte des Arbeitsbereiches erscheint (Ausnahme: Dokument ist kleiner als der Arbeitsbereich des Fensters).

Die Fensterkoordinaten und und -gr”e werden ebenfalls angepat, je nach Alignwert und Minimal- und Maximalwerte.


(2) param, lparam - int / long
Mit "param"/"lparam" werden die nderungswerte mitgegeben werden. PARAM[0] enth„lt den Index des Fensterns w„hrend PARAM[1 bis 4] und LPARAM[1 bis 4] die nderungswerte enthalten. Dieser Aufbau stellt nur eine allgemeine Aufteilung dar. Es werden nicht immer alle Indizes ben”tigt. So wird z.B. bei mancher nderung das aktuelle Fenster angesprochen, so da kein Fensterindex bergeben werden braucht. Der Window-Manager liest nur die Felder, in denen er Werte erwartet. Die nicht ben”tigten Felder werden ignoriert, so da evtl. dort enthaltene Zahlenwerte keinen Einflu auf den Window- Manager haben.


Parameterrckgabe:
wm_call()	= 0	Verarbeitung korrekt durchgefhrt
wm_call()	= 1	Kein Fenster ge”ffnet
wm_call()	= 2	Index ist kein Fenster
wm_call()	= 3	Fenster ist offen	
wm_call()	= 4	Fenster ist nicht offen
wm_call()	= 5	Koordinaten sind falsch
wm_call()	= 6	Fenstergr”e falsch
wm_call()	= 7	Max. Anzahl von Fenstern schon angelegt
wm_call()	= 8	Fenster schon aktuell


4.4.3.	Infozeile im Fenster setzen

Der Window-Manager beinhaltet eine Funktion, mit der Sie den Text in der Infozeile eines Fensters „ndern k”nnen. Die Funktion sieht folgendermaen aus:

	int	wind_info_set(w_index,text)

Parameterbergabe:
	int	w_index;
	char	*text;

(1) w_index - int
Hiermit wird der Fensterindex bergeben.

(2) text[81] - char
In text wird ein Zeiger auf den String bergeben, der in der Infozeile ausgegeben werden soll. Dabei ist zu beachten, da max. 80 Stellen bercksichtigt werden.



Parameterrckgabe:
wind_info_set()	= 0		kein Fehler
wind_info_set()	= 2		Index ist kein Fenster


4.4.4.	Umwandlung Handle -> Index

Es kann F„lle geben, in denen Sie nur den Fensterhandle und nicht den Index kennen, den der Window-Manager ben”tigt. Als Beispiel sei das Feld "aktuell.handle" genannt. In solchen F„llen mssen Sie zur Umwandlung die Funktion handle_to_index() aufrufen.

	int  handle_to_index(fensterhandle)

	šbergabe:	fensterhandle	= Handle des Fensters
	Rckgabe:	>= 0		= Index zum Fenster
			-1		= Handle ist nicht vorhanden


4.4.5.	Redrawing eines Fensters

Sie mssen eine Funktion bereitstellen, die einen Teil des Dokumentes im Arbeitsbereich ausgibt und deren Zeiger mit open_window() bergeben. Ob die Funktion nur die Ausgabe im gesamten Arbeitsbereich oder auch das Restaurieren von Teilen im Arbeitsbereich bernehmen soll, h„ngt vom Parameter "fl_wsave" bei open_window() ab. Ist er FALSE, mu Ihre Redraw-Funktion das Restaurieren des Fensters auch dann bernehmen, wenn Teile des Fensters verdeckt waren und jetzt wiederhergestellt werden mssen. Ansonsten (bei TRUE) braucht sie nur die Ausgabe im gesamten Arbeitsbereich durchzufhren. Die Restaurierung von ehemals verdeckten Teilen des Arbeitsbereiches nimmt der Window-Manager vor.


Eine Einschr„nkung gibt es allerdings. Auf einem Multitasking-System wird  n i e (!!!) der automatische Redraw ausgefhrt. Der dazugeh”rige Schalter "fl_wsave" wird in solchen F„llen durch open_window() auf FALSE gesetzt. Der Grund dafr ist, da die Fensterelemente (Slider, Pfeile usw.) auch dann aktiv sind, wenn das Fenster (und damit das Programm) nicht aktuell, also getoppt ist. Der Inhalt eines solchen Fensters kann damit bewegt und ge„ndert werden. Beim automatischen Redraw wrde der neue Fensterinhalt dann gespeichert werden, wobei allerdings die Teile der Fenster, die ber dem Arbeitsbereich des zu sichernden Fensters liegen, mit gespeichert werden. Beim Restaurieren wrden diese Teile dann mitgezeichnet werden.


4.4.6.	Programm-Redraw

Beim Programm-Redraw (fl_wsave = FALSE) mssen Sie sich um die Ausgabe des Fensterinhaltes  u n d  die Restaurierung des Arbeitsbereiches kmmern. Dies geschieht mit der Funktion, deren Zeiger Sie mit window_open() bergeben. Sie wird also vom Window- Manager angesprungen, wenn ein Ereignis zur Ausgabe beim AES vorliegt.

Jetzt nun einige Worte zum Redraw. Das AES speichert in einer Liste alle Rechtecke des Arbeitsbereiches, die restauriert werden mssen. Der Window-Manager speichert das gerade gelesene Rechteck im Bereich "aktuell.":
aktuell.neu_pix.g_x =	X-Koordinate des zu restaurierenden Rechtecks
aktuell.neu_pix.g_y =	Y-Koordinate des zu restaurierenden Rechtecks
aktuell.neu_pix.g_w =	Breite des zu restaurierenden Rechtecks (Pixel)
aktuell.neu_pix.g_h =	H”he des zu restaurierenden Rechtecks (Pixel)


Wenn Sie Text ausgeben oder die Zeilen und Spalten benutzen, die mehrere Pixel gro sind, brauchen Sie natrlich die Spalten- und Zeilenwerte. Diese werden im Bereich aktuell.neu_doc die Zeilen und Spalten angegeben.
aktuell.neu_doc.g_x =	erste Spalte im zu restaurierenden Rechteck
aktuell.neu_doc.g_y =	erste Zeile im zu restaurierenden Rechteck
aktuell.neu_doc.g_w =	Anzahl der Spalten im zu rest. Rechteck
aktuell.neu_doc.g_h =	Anzahl der Zeilen im zu rest. Rechteck

Sollten Sie mit Text oder sonstigen Scrollwerten gr”er als Eins arbeiten, mssen Sie die Bildschirmkoordinaten der Spalten und Zeilen wissen. Die Funktion neupix() rechnet den Bereich aktuell.neu_doc in Pixel um und legt die Ergebnisse im Bereich aktuell.neu_pix ab. Neupix() sollte dann die erste Funktion sein, die in Ihrer Redraw-Routine aufgerufen wird. Bild 2 zeigt diesen Zusammenhang auf. Zur n„heren Erl„uterung sehen Sie sich bitte das Listing "win_prob.c" an.


<< Bild: "BILD_2.IMG" >>



4.4.7.	Der automatische Redraw

šbergeben Sie window_open() fl_wsave = TRUE, bernimmt der Window-Manager mit einigen Ausnahmen die Restaurierung des Fensters. Um diese durchfhren zu k”nnen, speichert die Fensterverwaltung den Arbeitsbereich des Fenster zwischen. Dazu mu natrlich Speicher bereitgestellt werden, dessen Umfang von der Gr”e des Fensters abh„ngt. Nach jeder nderung am Fensterinhalt oder der Fenstergr”e wird der alte Speicher freigegeben und der neue Arbeitsbereich gesichert.

Der reservierte Speicher fr ein Fenster wird erst komplett freigegeben, wenn das Fenster geschlossen (WM_CLOSE) oder gel”scht (WM_DEL) wird.


Eine Redraw-Funktion mssen Sie trotzdem bereitstellen. Sie wird in den nachfolgend aufgefhrten F„llen aufgerufen:

a) ™ffnen des Fensters mit open_window()
b) Ver„ndern der Dokumentenposition
c) Gesamter Arbeitsbereich wird restauriert, da er verdeckt war
d) Gr”e des Fensters wurde ver„ndert
e) Das Fenster reicht ber Bildschirmrand hinaus und wird bewegt
f) Fenster wird in den Vordergrund geholt

In allen F„llen wird der gesamte Arbeitsbereich restauriert. Die Bereiche aktuell.neu_doc und aktuell.neu_pix werden so versorgt, wie im vorigen Kapitel beschrieben. Allerdings entf„llt der Aufruf der Funktion neupix(), da beide Bereiche gleich gro sind (= Arbeitsbereich des Fensters).

Achtung	Es kann durchaus vorkommen, da nicht gengend Speicher fr die Sicherung des Fensterinhaltes vorhanden ist. In solch einem Fall unterl„t der Window-Manager das Zwischenspeichern und ruft bei jedem nachfolgenden Redraw, also auch beim Restaurieren, die Funktion auf, die der Programmierer fr die Fensterausgabe bereitstellt. Allerdings versucht der Window-Manager nach jeder nderung am Fensterinhalt oder der Fenstergr”e erneut Speicher zu reservieren. Sollte wieder gengend vorhanden sein, wird der automatische Redraw wieder ausgefhrt.


4.5.	Schlieen und L”schen der Fenster

Hier mu nocheinmal auf den Unterschied zwischen Schlieen und L”schen eines Fensters eingegangen werden. Wird ein Fenster geschlossen, verschwindet es zwar vom Bildschirm, ist aber noch beim AES angemeldet. Da heit, der Fensterhandle und -index ist noch fr dieses Fenster reserviert und die Fensterbeschreibung im AES und im Bereich "windows[]" gespeichert. Durch den Funktionsaufruf wm_call(WM_OPEN, param,lparam) wird das Fenster wieder auf den Bildschirm gebracht. Dieser Funktionsaufruf unterscheidet sich von open_window(), wo ein Fenster angemeldet und ge”ffnet wird.

Ein Fenster wird durch wm_call(WM_CLOSE,param,lparam) geschlossen. Es bleibt aber weiterhin bei AES angemeldet, wenn der Schalter "delclose" in open_window() auf FALSE gesetzt wurde. Ansonsten wird es gel”scht, also die Fensterbeschreibung aus dem AES entfernt und der entsprechende Index der Fensterbeschreibung "windows[]" freigegeben. Fenster k”nnen auch durch wm_call(WM_DEL,param,lparam) direkt gel”scht werden, wobei noch offene Fenster natrlich vorher geschlossen werden.

Der Window-Manager stellt Ihnen noch zwei weitere Funktionen zur Verfgung, mit denen das Schlieen und L”schen vereinfacht werden soll.

	void	close_all_window()
	-	Schlieen aller noch ge”ffneten Fenster
		Parameterbergabe:	keine
		Parameterrckgabe:	keine


	void	delete_all_window()
	-	L”schen aller angemeldeten Fenster.
		Parameterbergabe:	keine
		Parameterrckgabe:	keine
Achtung	Bei allen oben genannten Funktionen wird ein evtl. fr den automatischen Redraw reservierter Speicher freigegeben.



4.6.	Allgemeines

4.6.1.	automatisches Restaurieren

Das automatische Restaurieren durch den Window-Manager erfolgt mit den Funktionen get_image(), put_image() und release_image(). Es wird daher immer nur soviel Speicher reserviert, wie aufgrund der Gr”e des Fensters ben”tigt wird.


4.6.2.	Sonstiges

Literatur:	- "Windows unter GEM"
		  Andreas L”tscher
		  ST Computer 05/89 - 10/89

		- Handbuch zu Mark Williams C  Version 3.09


5.	Einleitung zum Form-Manager

Der Form-Manager stellt dem C-Programmierer einige Routinen zur leichteren Handhabung von Resource-Dateien zur Verfgung. Somit sollte es keine Schwierigkeiten mehr bereiten, Programme in ein passendes GEM-Gewand zu kleiden. Die Routinen wurden unter verschiedenen TOS-Versionen eingesetzt (TOS 1.0, TOS 1.2, Beta-TOS 1.4 (RAM-Version), TOS 1.4, TOS 2.06 und TOS 3.05)) und arbeiten einwandfrei (ganz abgesehen davon, da auch in zuknftigen Versionen keine Probleme auftreten drften!!). Die Grundlagen dieser Routinen wurden der ST-Computer-Zeitschrift entnommen (fr GFA-Basic) und an die  Programmiersprache C angepat. In der vorliegenden Version ist es ohne nderung mit dem Mark Williams C Version 3.09 zu kompilieren. Es drfte jedoch keine groen Probleme bereiten, die Prozeduren an anderen Compiler anzupassen, da nur Betriebssystemroutinen benutzt werden.
Als weiteres Schmankerl ist es nun m”glich, Dialogboxen vollt„ndig in Fenstern darzustellen und zu verwalten. Dies ist bei Verwendung von MagiX und MultiGEM sowie zuknftig MultiTOS sehr ntzlich, da andere Programme durch Bildschirmausgaben nicht gehindert werden. Somit ist es m”glich, mehrere Dialogboxen gleichzeitig am Bildschirm zu bearbeiten. Bedingt durch die Multitasking-Eigenschaften ist es nicht m”glich, Programme einfach durch Erg„nzen der neuen Bibliotheksroutinen dazu zu bringen, ihre Dialogboxen in Fenster zu legen. 

5.1.	Hard- und Software-Voraussetzungen

Die Hard- und Software-Voraussetzungen sind im ersten Kapitel des GEM-Managers beschrieben. Zus„tzlich ben”tigen sie fr die Erstellung von Resourcen ein Resource-Editor (-Construction Set) bzw. - compiler.


5.2.	Aufbau der Prozeduren

S„mtliche Prozeduren des Resource-Helpers arbeiten mit lokalen Variablen, eine Beeinflussung mit gleichlautenden Variablen des Hauptprogramms ist somit ausgeschlossen. Die Originaldatei kann kompiliert werden und anschlieend unabh„ngig in den Linkvorgang zum Hauptprogramm gebunden werden. Man erspart sich somit ein st„ndig neues Compilieren. Beim Mark Williams C wird das durch die Eingabe
cc -c -VCOMPAC resource.c
erreicht. Auf der Platte/Diskette sollte sich jetzt eine Datei resource.o befinden. Diese Datei wird sp„ter nur noch dem Linker mit bergeben. Soll z. B. das Programm Hallo erstellt und der Form-Manager ben”tigt werden, kann dies z. B. mit der Eingabe von
cc -VCOMPAC -VGEM -o hallo.prg hallo.c resource.o 
geschehen.


5.3.	Was sie bedenken sollten

Um mit einer Resource-Datei arbeiten zu k”nnen, mssen Sie sich beim AES anmelden. Das Betriebssystem stellt sich nun darauf ein, da Sie mit GEM arbeiten wollen. Dazu ben”tigen Sie eine Applikationsnummer, die ihnen das TOS (besser gesagt das AES) freundlichst auf Anfrage zur Verfgung stellt: app = appl_init();. Diese Anmeldung wird ihnen von der Funktion gem_init() des GEM-Managers abgenommen. Die Applikationsnummer stellt diese Funktion in der globalen Variablen ap_id zur Verfgung.
Die Funktionen des Form-Managers ben”tigen fr die Ausfhrung ihrer Aufgabe die sogenannte Baum-Adresse der Dialogbox. Diese Baum- Adresse kann durch einen Betriebssystem-Aufruf erfragt werden:
rsrc_gaddr(R_TREE, D_BOX, &baum_adr);
Mit diesem Aufruf wird der Long-Variablen baum_adr die Speicheradresse der Dialogbox D_BOX zugewiesen.

Wenn Sie ihr Programm gerne nach getaner Arbeit beenden m”chten, mssen Sie unbedingt den von der Resource belegten Speicherplatz freigeben. Sollten Sie das vergessen - nun nach einiger Zeit kann ihr ST/TT es ihnen etwas bel nehmen und sie werden in eine Bombenstimmung versetzt. Darum: Am Programmende (vor gem_exit()) immer die Funktion rsrc_free() aufrufen.
Seit der Version 2.0 des Resource-Managers werden auch bewegliche/verschiebbare Dialogboxen untersttzt. Als weiteres Schmankerl dient die Option, da Sie komplette Dialoge auch mit der Tastatur steuern k”nnen (auch Kn”pfe aktivieren, die Abbruch-Taste ber die Taste Undo etc.). Dies setzt voraus, da Ihr pers”nlicher C-Compiler die Funktion exform_do() untersttzt. Dies ist keine offizielle Funktion, sondern sie wurde von dem bew„hrten Team, das die verschiedenen Manager pflegt, zusammengestellt. Nach auen hin verh„lt sich die Funktion wie die Original-Routine form_do(). Der Quelltext der Funktion exform_do() ist sicherlich fr viele interessant, bringt allerdings wenig, da diese Funktion wiederum zwei weitere Funktionen aufruft, die nicht offiziell von Atari dokumentiert wurden und somit von nahezu keinem C-Compiler untersttzt werden. Dazu mten Sie sich ein eigenes Binding dieser Funktionen schreiben, nur um exform_do() zu bersetzten. Besitzer des Mark Williams C in der Version 3.0 k”nnen ein Bibliothek- Update von mir bekommen. Dort sind die Funktionen implementiert und noch zus„tzlich die neuen Funktionen des TOS 1.2 und 1.4. Die Adresse steht am Ende dieser Beschreibung. Fr weitere Fragen stehe ich gern zur Verfgung. Falls Sie die Funktion exform_do() statt der Original-Routine verwenden  wollen, so sollten Sie in der Kommandozeile die Option - DEXTEND setzten. Dabei wird der Aufruf form_do() in den Aufruf exform_do() umgewandelt (gilt nur fr Aufrufe des Form-Managers!).
Wichtig: Die Funktionen zur Bearbeitung von Moveboxen sind nicht ohne weiteres reentrant. Sollen mehrere verschiedene Dialogboxen verschachtelt verwendet werden, so eine interne Struktur zwischenzuspeichern und nach Abarbeitung der verschachtelten Dialogbox korrekt zu restaurieren. Der Resource-Manager stellt dafr zwei Funktionen zur Verfgung.


5.4.	nderungen in den Versionen

5.4.1.	nderungen  von Version 1.0 zur Version 2.0

Im groen und ganzen haben sich alle Funktionen weiterhin mit Erfolg bew„hrt (Ob Sie es glauben oder nicht, wir setzten die diversen Manager ebenfalls in eigenen Projekten ein. Nur so ist gew„hrleistet, da das Produkt auch nahezu fehlerfrei gestaltet werden kann, bzw. immer neue Ideen aufgenommen werden k”nnen.). Wie schon gesagt sind aus Kompatibilt„tsgrnden alle Funktionen der Version 1.0 weiterhin enthalten. Darber hinaus k”nnen auch verschiebbare Dialogboxen realisiert werden. Sie fragen sich sicher, ob das auch fr jede beliebige Aufl”sung realisiert werden kann? Logisch, da der GEM- Manager, in den der Form-Manager eingebunden ist, alle ben”tigten Daten zur Verfgung stellt. Um die MOVEDIAL-Boxen zu bearbeiten (neudeutsch: den Dialog durch zufhren), steht die Standardfunktion do_movedial() zur Verfgung. Sie kann immer dann benutzt werden, wenn keine besonderen Aktionen, wie z. B. das Verstecken diverser Teilobjekte auf Knopfdruck oder „hnliche Spielereien, zu erwarten sind. Das Exit-Objekt wird nach Abschlu des Dialoges automatisch deselektiert. Sollte Ihr pers”nlicher Dialog tats„chlich ber die oben erw„hnten  Sonderbehandlungen verfgen, so mssen Sie nur eine Kleinigkeit beachten:

1.	Sie ermitteln - wie blich - die Baumadresse des Dialogbaumes 

2.	Sie mssen anschlieend die Funktion vor_dial() aufrufen. Mittels dieser Funktion werden vom Betriebssystem einige Bytes angefordert, die fr die Bildschirmrestaurierung ben”tigt werden. Das ganze geschieht - wie nicht anders zu erwarten - dynamisch. Deshalb beachten Sie unbedingt den Rckgabewert (LONG!!!). Bei Rckgabe des Wertes NULL ist ein Fehler aufgetreten und die als MOVEDIAL-Box vorgesehene Dialogbox darf nur als Standardbox auf den Bildschirm gebracht werden (alles ist erlaubt, nur das Bewegen nicht...).

3.	Sie fhren den Dialog mit form_do() bzw. exform_do() durch

4.	Fr die Sonderfunktion sind Sie ebenfalls verantwortlich. Sie k”nnen sich dazu nach herzenslust der Funktionen der Version 1.0 bedienen, mit Ausnahme der Funktion box_draw(), box_undraw und form_dial(). Diese Funktionen sind bei MOVEDIAL-Boxen absolut tabu!!! Wer sich nicht daran h„lt, wird mit ziemlicher Sicherheit mit mindestens 2 Bomben bestraft... Kommen Sie auch nicht auf die Idee, eine MOVEDIAL-Box mit box_draw() auf den Bildschirm zu zeichnen und anschlieend (weil vom Anwender gewnscht) mit movedial() zu verschieben. Auch hier werden Sie mit Bomben bestraft!!! Deshalb nochmals mit aller Klipp- und Deutlichkeit: MOVEDIAL-Boxen werden mit vor_dial() und anschlieendem draw_dial() auf den Bildschirm gezeichnet, mit form_do() bzw. exform_do() verwaltet (Attribute k”nnen wie bei Standarddialogen mit den Funktionen der Version 1.0 ver„ndert, Texte ausgelesen bzw. in die Box geschrieben werden etc.) oder ggf. mit movedial() bearbeitet und zum Schlu mit nach_dial() vom Bildschirm radiert.

5.	Soll die Box verschoben werden, einfach bei gedrckter linker Maustaste die Funktion movedial() aufrufen. Die Bildschirmrestaurierung wird ebenfalls von dieser Funktion erledigt (toll, was?). Das Objekt, da als Bewegungsmelder fungieren soll, mu nur das Flag TOUCHEXIT gesetzt haben (sonst klappt alles nicht, da der Dialog erst verlassen wird, wenn Sie die linke Maustaste loslassen. movedial() dagegen tut nichts, wenn Sie ohne gedrckte linke Maustaste aufgerufen wird;). Fr die Bildschirmrestaurierung wird auf Datenfelder des GEM-Managers zugegriffen, die die Ausgabeeinheit beschreiben. Somit kommt der Resource-Manager mit allen Aufl”sungen klar, die auch von GEM untersttzt werden. Damit die Dialogbox an der neuen Stelle in voller Sch”nheit erscheint, ist nur noch die Funktion draw_dial() zu bemhen.

6.	Bei Ende des Dialoges mssen Sie die Funktion nach_dial() aufrufen Diese Funktion entfernt die Dialogbox vom Bildschirm und schickt eine Redraw-Meldung an alle betroffenen Fenster (falls ge”ffnet...). Weiterhin wird der fr die Bildschirmrestaurierung angeforderte Speicher wieder freigegeben. Wenn Sie dies nicht tun, werden Sie bald merken, wie wenig eigentlich 1 MByte Arbeitsspeicher sind... Rufen Sie die Funktion auf, obwohl Sie bei vor_dial() einen Fehler erhalten haben, so wird fr nichts garantiert... Normalerweise erhalten Sie von der Funktion free(), die intern aufgerufen wird, eine Fehlermeldung und den sofortigen Programmabbruch (weniger erfreulich). Vergessen Sie nicht, da Exit-Objekt zu deselektieren!

Nun stellt sich die Frage, welche Dialogbox-Typen gibt es denn sonst noch und worin unterscheiden sie sich? Die erw„hnten MOVEDIAL- Boxen werden beim ersten Mal in der Mitte des Bildschirms dargestellt. Anschlieend kann Sie vom Anwender an jede beliebige Stelle des Desktops geschoben werden (wie oft haben Sie sich schon ber Dialogboxen ge„rgert, die als Eingabe Werte verlangen, die Sie aus dem darunter liegenden Fenster eigentlich ablesen wollten, welches nun cleverer Weise von der Dialogbox verdeckt wird.). Wird die Dialogbox ein zweites Mal auf den Bildschirm gezeichnet, erscheint sie an der Stelle, wo sie das erste Mal beim Bet„tigen der OK-Taste verlassen wurde.
POPUP-Boxen sind im Prinzip Standard-Dialoge, mit dem Unterschied, da sie an der Stelle des Bildschirms gezeichnet werden, wo sich der Mauszeiger gerade befindet. Dabei wird darauf geachtet, da auch tats„chlich die gesamte Box innerhalb des Bildschirms befindet und nicht nur Teile, falls Sie zuf„llig den Mauszeiger am Bildschirmrand plaziert hatten, als die Dialogbox gezeichnet werden sollte. Besitzer von Grobildschirmen werden Sie sicher in Ihr Herz schlieen, denn Sie brauchen nicht mehr so lange Wege mit der Maus zurckzulegen, nur um die Dialoge auszufllen bzw. Kn”pfe zu aktivieren, vor allem, wenn Sie keinen vernnftigen Mausbeschleuniger ihr Eigen nennen. Standard-Boxen brauchen wohl nicht weiter erw„hnt zu werden, die kennen Sie zur Genge aus sogenannten "einfallslosen" GEM-Programmen. Sie werden prinzipiell in der Mitte des Bildschirmes gezeichnet, ohne Rcksicht auf Anwenderwnsche (zum Leid der Grobildschirm-Besitzer ohne Mausbeschleuniger).

5.5.	Was hat sich zur Version 3.0 ge„ndert?

Mit der Version 3.0 des Resource-Managers ist es m”glich, Dialogboxen in Fenstern zu verwalten. Die Tastatursteuerung aus der Version 2.0 bleibt vollst„ndig erhalten. Um Dialogboxen in Fenstern darzustellen, ist die Verwendung der exform_do()-Funktion unabdingbar. Sie existiert fr herk”mmliche Dialogboxen und als wexform_do() fr die Behandlung von Dialogboxen in Fenstern. Werden Dialogboxen in Fenstern verwaltet, wird auch der Window-Manager ben”tigt! Demzufolge mssen alle globalen Felder des Window-Managers sowie die Datei win_lib.c mit in das eigene Programm eingebunden werden.
Die neuen Routinen fr die Fensterbehandlung sind im Modul movebox.c enthalten. Das Modul exformdo.c enth„lt beide Arten der Extended-Formdo-Routine und mu ebenfalls in das eigene Programm bernommen werden.

5.5.1.	Programmstruktur

Die herk”mmliche Form_do()-Routine des Betriebssystems sowie die exform_do()-Routine des Managers haben die fr Multitasking fatale Eigenschaft, den Bildschirm zu sperren und den Screen-Manager zu entmachten. Somit k”nnen unter MultiTOS, MultiGEM oder MagiX! andere Anwendungen in ihrer Ausfhrung behindert werden (n„mliche immer dann, wenn Bildschirmausgaben in Fenstern vorgenommen werden sollen). Somit wurde eine erweiterte Routine wexform_do() in den Manager aufgenommen. Diese wertet alle fr sie wichtigen Events aus und leitet sie an die Dialogbox weiter, die sich im aktiven Fenster befindet. Befindet sich keine Dialogbox im obersten Fenster, werden die Events an die Applikation weitergereicht, die dann entsprechend durch den Window-Manager bzw. Event-Manager ausgewertet werden k”nnen.
Im Gegensatz zur exform_do()-Routine befindet sich die wexform_do() immer als erste Routine nach dem evnt_multi()-Aufruf. Weiterhin wird der Event-Manger benutzt, d. h. die Eingabe- und Ausgabefelder mssen im Hauptprogramm definiert und entsprechend der Dokumentation versorgt sein! Nur somit ist sichergestellt, da alle Events, die die Applikation ben”tigt, auch wirklich abgefragt werden.
Nach der wexform_do()-Routine werden dann der Men-Handler bzw. der Window-Manager aufgerufen. Ob ein Event zu einer Dialogbox geh”rte, erkennt man am Rckgabewert von wexform_do(). Ist dieser - 1, so konnte der Event nicht ausgewertet werden, -2 deutet auf eine Auswertung von wexform_do() hin.
Dies k”nnte in etwa so aussehen:

main()
{
	gem_init();
	win_init(FENSTERANZAHL);
	rsrc_load(RSC_DATEI);
	.
	.
	do
	{
		v_event();
		if(wexform_do() == -2)
			continue;

		switch(event_return.buffer[0])
		{
			case MN_SELECTED:
			/* Men-Behandlung */
				.

				.
				break;

			case MSG_DIALOG:
			/* Dialogbehandlung */
				.
				.
 				break;

			otherwise:
			/* Fensterbehandlung */
				 			handle_window(event_return.buffer);
			break;
		}

	} while (Endekriterium == TRUE);

	rsrc_free();
	win_exit();
	gem_exit();
}


5.5.2.	Programmierung bei Fensterdialogen

Da Dialogboxen in Fenstern auch Ereignisse behandeln mssen, die sie im Grunde gar nicht betreffen, ist die Dialogstruktur auch hier etwas anders zu programmieren. Die Konstruktion mittels Resource- Construction-Kit bleibt dieselbe, auch das Laden der Resource-Datei in den Arbeitsspeicher. Lediglich die Darstellung und Behandlung sowie Nachbearbeitung sind strukturell unterschiedlich.
Vorarbeiten an der Dialogbox (Baum-Adresse ermitteln, (de)selektieren von Buttons etc) werden „quivalent durchgefhrt. Die ganze Arbeit endet abrupt mit den Programmzeilen:


	windownr = wbox_draw(baum_adr);
	return;

Dieser Aufruf bringt die Dialogbox zentriert in einem Fenster auf den Bildschirm. Die Weiterbearbeitung erfolgt dann in der Hauptschleife des Event-Managers, wo die wexform_do()-Routine angesiedelt ist. Wird ein Exit-Objekt angew„hlt, so bekommt die Applikation eine MESSAGE geschickt, die in event_return.buffer[0] den Wert 100 aufweist (MSG_DIALOG).


5.5.3.	Aufbau der Dialog-Message

Die Nachricht, die die Applikation bekommt, wenn innerhalb einer im Fenster dargestellten Dialogbox ein Exit- bzw. Touchexit-Objekt angew„hlt wurde, hat folgenden Aufbau:
event_return.buffer[]	/* enth„lt die Werte */
[0]:		100 (MSG_DIALOG)
[1]:		Applikations-ID
[2]:		0 (reserviert)
[3]:		Fensterhandle des AES der Dialogbox
[4]:		MSByte Baumadresse der Dialogbox
[5]:		LSByte Baumadresse der Dialogbox
[6]:		Objektnummer des gew„hlten Objektes
[7]:		0 (reserviert)
Mittels dieser Nachricht ist es m”glich, in eine entsprechende Behandlungsroutine zu verzweigen, die die Dialogbox manipuliert.
Normalerweise ist es blich, die ge„nderten Objekte mit objc_draw() neu zu zeichnen. Dies ist bei Fensterdialogen fatal!!! Jedes Neuzeichnen wird ber den Window-Manager mit der Funktion wm_call() veranlat, da nur in diesem Fall ein Zerst”ren fremder Fensterinhalte vermieden wird! 


5.6.	Beschreibung der Funktionen

5.6.1.	box_draw(tree,x,y,w,h) OBJECT *tree; int x, y, w, h;

Diese Funktion zeichnet eine Dialogbox auf den Bildschirm, tree ist die Baum- Adresse der Dialogbox. Die anderen Parameter bestimmen den Anfangspunkt der sich ”ffnenden Box. Sind alle Koordinaten 0, so beginnt die Dialogbox sich von dem eingestellten Nullpunkt unter GEM zu ”ffnen. Standardm„ig ist die Bildschirmmitte der Nullpunkt. Die Dialogbox wird immer zentriert auf dem Bildschirm ausgegeben. Soll eine Dialogbox in den Bildschirm "reinfliegen", so k”nnen sie folgenden Aufruf benutzen:

box_draw(baum_adr, 10, 10, 5, 5);

5.6.2.	box_undraw(tree,x,y,w,h) OBJECT *tree; int x,y,w,h;

Diese Funktion restauriert den Bildschirm von einer durch box_draw gezeichneten Dialogbox, sie bildet quasi das Gegenstck. Die Parameter sind mit der Funktion box_draw() identisch.

5.6.3.	objc_update(tree, objc) OBJECT *tree; int objc;

Das Objekt objc der durch tree bezeichneten Dialogbox wird auf dem Bildschirm neu gezeichnet. Dies ist immer dann wichtig, wenn Eingabefel der durch das Programm neu belegt werden und die Dialogbox schon auf dem Bildschirm gezeichnet ist.

5.6.4.	objc_position(tree,objc,r)
	OBJECT *tree;int objc;Rect *r;

Diese Funktion ermittelt die Bildschirmkoordinaten des Objektes objc innerhalb der Dialogbox tree. Das Ergebnis wird in der Struktur r abgelegt. Die Einzelelemente dieser Struktur lauten r.x, r.y, r.w und r.h und geben x- sowie y-Koordinate mit Breite und H”he an.


5.6.5.	set_flag(tree,objc,bit)
	OBJECT *tree; int objc; unsigned int bit;

Hiermit lassen sich die Charakteristika von Objekten einer Dialogbox ver„ndern. Beispielsweise lassen sich Texte von editierbar nach anw„hlbar ver„ndern. Genaueres ist ihrem C-Compiler-Benutzerhandbuch unter dem Thema Objekt-Strukturen zu entnehmen. Sollen mehere Bit's gleichzeitig manipuliert werden, so sind die Wertigkeiten zu addieren und dem Parameter bit zuzuweisen. Die angegeben Bit's des Objektes objc werden durch diese Funktion gesetzt. 

5.6.6.	del_flag(tree,objc,bit)
	OBJECT *tree; int objc; unsigned int bit;

Diese Funktion bildet das Gegenstck zu der Funktion set_flag(). Die in bit angegebenen Bit's des Objektes objc werden gel”scht.

5.6.7.	unsigned int is_flag(tree, objc, bit)
	OBJECT *tree ; int objc; unsigned int bit;

Mit dieser Funktion kann ermittelt werden, ob ein bestimmtes Objekt-Flag gesetzt ist. Sollen mehrere Bit's abgefragt werden, so sind die Wertigkeiten vorher zu addieren und dem Parameter bit zu bergeben. Als Rckgabewert erh„lt man die Summe der Bits, die im Parameter bit enthalten und auch im Objekt gesetzt sind.

5.6.8.	hide(tree, objc) OBJECT *tree; int objc;

Diese Funktion versteckt einzelne Objekte einer Dialogbox. Diese Funktion kann auch auf editierbare Objekte angewendet werden. Soll ein editierbares Objekt versteckt werden, so wird im Objekt-Flag des Objekts objc ein in GEM nicht benutztes Bit (0x200) als Merker gesetzt und das Editier-Flag mittles del_flag() gel”scht. Somit erscheint bei Abarabeitung der Dialogbox der Cursor nicht mehr auf dem ursprnglich vorhandenen Eingabefeld.

5.6.9.	unhide(tree, objc) OBJECT *tree; int objc;

Hier wird Ihnen das Gegenstck zu Funktion hide() pr„sentiert. Objekte, die versteckt wurden, k”nnen hiermit wieder sichtbar gemacht werden. Editierbare Objekte, die mit hide() versteckt wurden, werden korrekt behandelt, d. h. sie sind nach unhide() sichtbar und auch editierbar! Die Funktion erkennt dies am Bit 0x200, welches durch die hide()-Funktion gesetzt wurde, von GEM aber nicht benutzt wird. Dieses Bit wird anschlieend automatisch zurckgesetzt.

5.6.10.	do_objc(tree,objc bit)
		OBJECT *tree; int objc; unsigned int bit;

Mittels dieser Funktion k”nnen Bits im Objekt-Status objc gesetzt werden. Ein Button kann z. B. vorselektiert werden (dem Parameter bit das Argument SELECTED bergeben).

5.6.11.		undo_objc(tree,objc,bit)
		OBJECT *tree; int objc; unsigned int bit;

Hier wird wieder das Gegenstck zu do_objc() aufgefhrt, mit der Ausnahme, da die Bits des Parameters bit nicht gesetzt sondern gel”scht werden.

5.6.12.	unsigned int is_objc(tree, objc, bit)
		OBJECT *tree ; int objc; unsigned int bit;

Diese Funktion kann zur Abfrage des Objekt-Status eingesetzt werden. Man kann z. B. abfragen, ob das Objekt - falls es SELECTABLE ist - auch durch die Maus angew„hlt wurde (bit = SELECTED). Als Rckgabe erh„lt man die Summe der Wertigkeiten der Bits, die sowohl im Parameter bit und auch im Objekt-Status gesetzt sind.

5.6.13.	get_dialogtext(tree,objc,text)
		OBJECT *tree; int objc; char *text;

Mit dieser Funktion l„t sich ein editierbarer Text aus einer Dialogbox auslesen. Objc bestimmt dazu das auszulesende Objekt. Text mu gro genug sein, um den gesamten Inhalt des Objektes aufnehmen zu k”nnen. Es erfolgt keine Abfrage bezglich der Maximall„nge des Parameters text und dem Objekt!! Der Objekttyp STRING kann nicht mit dieser Funktion ausgelesen werden.

5.6.14.	put_dialogtext(tree, objc, text)
		OBJECT *tree; int objc; char *text;

Diese Funktion schreibt den Inhalt von text in das Objekt objc. Es erfolgt auch hier ebenfalls keine šberprfung der L„ngen der Parameter text und objc. Beachten Sie bitte, da der Objekttyp STRING nicht mit dieser Funktion bearbeitet werden kann.

5.6.15.	delete_dialogtext(tree,objc) OBJECT *tree; int objc;

Mit dieser Funktion kann das Eingabefeld objc gel”scht werden. Der Cursor steht bei der Eingabe linksbndig in dem gel”schten Feld. Bitte beachten Sie, da das Eingabefeld durch das Zeichen @ gel”scht wird. Wird ein leeres Eingabefeld ausgelesen, so bekommt man tats„chlich das Zeichen @ zugewiesen. Deshalb mu der Test auf eine erfolgte Eingabe in der Form

	get_dialogtext(baum_adr, OBJECT, feld); 
	if(strcmp(feld, "@")) verarbeitung();

erfolgen! Dies ist eine der h„ufigsten Fehlerquellen.


5.6.16.	do_movedial(baum, dragger, obj)
		long baum; int dragger, obj;

Diese Funktion fhrt einen kompletten Dialog durch, wobei beim ersten Aufruf die Dialogbox in der Bildschirmmitte erzeugt wird. Wird das Objekt mit dem Index dragger - welches das Attribut TOUCHEXIT besitzen mu - an, so k”nnen Sie die Dialogbox bei gedrckter linker Maustaste an eine beliebige Stelle des Bildschirms schieben und den Dialog zu Ende fhren. Wird die gleiche Dialogbox ein weiteres Mal aufgerufen, so wird sie nun an der Stelle des Bildschirms positioniert, wo sie das letzte Mal "zurckgelassen" wurde. Der Parameter obj enth„lt das erste zu editierende Objekt und sollte im Normalfall auf Null gesetzt werden. Der Parameter baum enth„lt die Adresse des Dialogbaumes. Als Rckgabewert enth„lt man den Objektindex, der zum Verlassen des  Dialoges fhrte. Das Attribut SELECTED des Abschluobjektes wird ggf. automatisch von der Funktion zurckgesetzt.

5.6.17.	do_popup(baum, obj) long baum; int obj;

Die Funktion fhrt ebenfalls einen kompletten Dialog durch, nur erscheint die Dialogbox unter der momentanen Mausposition. Der Parameter baum enth„lt wiederum die Startadresse des Objektbaumes, der Parameter obj den Index des zuerst editierbaren Feldes. Im Normalfall sollte der Wert Null sein. Als Rckgabewert erh„lt man den Index fr das Objekt, das den Dialog beendete. Das Attribut Selected des Abschluobjektes wird ggf. automatisch von der Funktion zurckgesetzt.

5.6.18.	do_dial(baum, obj) long baum; int obj;

Die Funktion fhrt einen Standard-Dialog durch, wie man ihn von allen blichen Programmen gewohnt ist. Beim Abschluobjekt wird ggf. das Attribut SELECTED automatisch zurckgesetzt und der Index des zum Abschlu fhrenden Objektes als Rckgabewert zur Verfgung gestellt.

5.6.19.	movedial(baum, type) long baum; int type;

Diese Funktion ist fr das Verschieben von Dialogboxen auf dem Bildschirm zust„ndig. Sie erwartet als Parameter die Objektbaumadresse und als Type den Wert 1. Werte ungleich 1 fhren zum sofortigen Abbruch der Funktion und es kann keine Verschiebung erfolgen. Es werden automatisch die Maximalkoordinaten fr den Desktop ermittelt, eine Verschiebung ist nur innerhalb dieses Bereiches zul„ssig. Beachten Sie bitte, da die Funktion nur mit gedrckter linker Maustaste aufgerufen werden sollte, da sonst die Funktion nicht den gewnschten Effekt liefert. Es existiert kein Rckgabewert.

5.6.20.	vor_dial(baum, type) long baum; int type;

Diese Funktion leitet die Verwaltung von Standard-, Popup- und Moveboxen ein. Sie mu auf jeden Fall fr Popup- und Moveboxen verwendet werden! Fr Standard-Dialoge kann auch die alte Funktion box_draw() eingesetzt werden. Die Funktion allokiert analog der Bildschirmbeschreibung des Window Managers den erforderlichen Speicherplatz fr Moveboxen und bereitet das System auf die Dialogverarbeitung vor. Type kann die Werte 0, 1 oder 2 enthalten. Sie stehen stellvertretend fr die Dialogarten Standard-, Moveboxen und Popupboxen. Als Rckgabewert erhalten sie entweder 0L (Longword!!!), was einen Fehler bekanntgibt (eigentlich den Nullzeiger NULL) bzw. die Startadresse des Bildschirmzwischenspeichers. Diese Angaben gelten nur bei der Verwendung von MOVEBOXEN!!! Fr die anderen Box-Typen ist der Rckgabewert nicht von Bedeutung. Der Parameter baum beinhaltet die Baumadresse der darzustellenden  Dialogbox.


5.6.21.	draw_dial(baum, type) long baum; int type

Diese Funktion ist im Prinzip eine Nachbildung der Funktion box_draw(). Sie zeichnet einen Dialog an der durch vor_dial() eingestellten Bildschirmkoordinate auf den Bildschirm. Der Parameter baum enth„lt die Baumadresse der darzustellenden Dialogbox, type den Dialogtyp (1 = Standard; 2 = Movebox; 3 = Popup). Die Funktion mu verwendet werden, wenn es sich um Moveboxen bzw. Popupboxen handelt, da box_draw() die Dialogbox immer in der Bildschirmmitte plaziert! Die Funktion hat keinen Rckgabewert.

5.6.22.	nach_dial(baum, type) long baum; int type;

Diese Funktion fhrt abschlieende Arbeiten aus, die die Dialogverwaltung so mit sich bringt. Fr Standarddialoge kann auch stellvertretend die Funktion box_undraw() benutzt werden. Fr Moveboxen und Popupboxen ist diese Funktion zwingend, da sie den angeforderten Speicher  fr die Zwischenspeicherung des Bildschirmhintergrundes freigibt. Type kann wieder die Werte 0, 1 oder 2 annehmen, stellvertretend fr Standard-, Move- und Popup-Dialoge. Baum beinhaltet die Startadresse des Objektbaumes.

5.6.23.	get_image_ptr(e) IMAGE *e;

Die Funktion exportiert die intern verwendete Strukturvariable zum Zwischenspeichern des Dialoghintergrundes bei Verwendung von Moveboxen. Dies ist dann notwendig, wenn zwei Moveboxen in verschachtelter Form benutzt werden. Vorher ist get_image_ptr() aufzurufen, nach schlieen der zweiten Box restore_image_ptr(). Der Parameter e ist ein Zeiger auf eine Struktur, die die internen Werte zwischenspeichern kann.


5.6.24.	restore_image_ptr(e) IMAGE *e;

Die Funktion restauriert die interne Variable zur Bildschirmrestaurierung bei Verwendung verschachtelter Moveboxen. Es ist jeweils auf die Hirarchie-Ebene Rcksicht zu nehmen (Stapel nach dem LIFO- Prinzip). Eine šberprfung der Hirarchie-Ebene wird nicht durchgefhrt. Der Parameter e enth„lt die zu restaurierenden Werte.

5.6.25.	dial_init(app_name) char *app_name;

Dialogboxen in Fenstern sind in einer Multi-Tasking-Umgebung besonders sinnvoll, da sie andere Prozesse kaum behindern. Da es denkbar ist, da mehrer Prozesse ihre Dialogboxen in Fenstern ausgeben, sollte man schon wissen, welche Dialogbox zu welcher Applikation geh”rt. Aus diesem Grunde wird als Fenstertitel der Applikationsname eingeblendet. Die Funktion dial_init() setzt den Applikationsnamen ein, der bei Fensterdialogen benutzt werden soll. Der Name darf max. 10 Zeichen lang sein und mu mit einem NULL-Zeichen enden. (C-String). 



5.6.26.	wbox_draw(baum_adr) OBJECT *baum_adr;

Die Routine zeichnet eine Dialogbox in einem Fenster zentriert auf den Bildschirm. Die Dialogbox verh„lt sich wie eine "normale" Dialogbox, kann auch mit der Tastatur gesteuert werden, wenn das Fenster das oberste Fenster ist (aktiv). Andernfalls werden die Events an die Applikation weitergeleitet! Die Routine macht meldet intern ein Fenster beim Window-Manager an und berl„t die komplette Verwaltung diesem Modul. Bei Benutzung dieser Dialogart sind alle anderen Funktionen tabu, die sich mit Neuzeichnen von Objekten innerhalb Dialogen befassen. Die Manipulationsroutinen k”nnen benutzt werden (Objekte selektieren, Flags abfragen etc.) Ein Neuzeichen mu ber wm_call() des Window-Managers veranlat werden (siehe dort).

Die Routine gibt den Fenster-Index des Window-Managers zurck (>= 0) bzw. einen negativen Fehlercode des Window-Managers.

5.6.27.	wbox_undraw(wm_handle) int wm_handle;

Eine Fenster-Dialogbox wird vom Bildschirm genommen und das Fenster beim AES abgemeldet. Der Parameter wm_handle ist die Fenster-Indexnummer des Window-Managers, nicht zu verwechseln mit dem AES-Handle des Fensters!!!

5.7.	Hilfsroutinen fr die Desktopverwaltung

Fr diejenigen, die ihren eigenen Programmen auch einen eigenen Desktop verschaffen wollen, stehen vor dem Problem, Icon's so zu handhaben, wie es der Atari-Desktop vormacht. Solange nur Dialoge verwaltet werden, ergeben sich weniger Probleme. Diese beginnen jedoch in dem Moment, wo die Verwaltung von Fenstern mit einbezogen wird, z. B. ein Fenster berdeckt einen Teil eines Icons, das zudem noch beweglich ist. Fr die Bewegung des Icons auf dem Desktop als auch fr die Neuzeichnung der einzelnen Objekte sind Klimmzge ber die Rechteckliste des Desktops notwendig. Hier greifen die folgenden Routinen, die die Verwaltungsarbeiten bernehmen.

5.7.1.	draw_deskobjc(tree, objc)

Diese Routine zeichnet das durch objc bezeichnetet Objekt des Desktops neu. Der Parameter tree beinhaltet die Anfangsadresse des Objektbaumes, der als Desktop angemeldet ist. Die Routine zeichnet das Objekt anhand der durch das AES zur Verfgung gestellten Rechteckliste. Diese Routine kann dadurch nicht die Verwaltungsarbeit zum Neuzeichnen von Objekten aus Standard-/Movedial-/ Popupboxen verwendet werden!


5.7.2.	move_deskobjc(tree, objc)

Diese Routine verschiebt das Objekt objc, welches Teilobjekt des durch tree beschriebenen Objektbaumes ist (Desktop), unter Beachtung der Rechteckliste des Desktops. Mit dieser Routine ist es m”glich, Icons (objc) auch unter Fenster zu schieben. Sie werden dabei korrekt neu gezeichnet (nur die Teile, die auch wirklich sichtbar sind). Die Routine darf nicht auf andere Objektb„ume fr Dialogboxen losgelassen werden, da immer die Rechteckliste fr den Desktop abgefragt wird!

5.8.	Nachwort

Diese Kurzbeschreibung soll nicht den Umgang mit GEM und Resource Dateien beschreiben. Der gebte Programmierer wird sich unter den beschriebenen Funktionen zurechtfinden, Anf„ngern wird ein Grundlagenbuch ber GEM empfohlen. Ein gutes Nachschlagewerk kann auch das Handbuch zum jeweiligen C-Compiler sein. Beim Mark Wiliams C kann im Lexikon unter dem Stichwort Objekte alles Wissenswerte entnommen werden. Vielen Dank an den unfreiwilligen Mitarbeiter Matthias Baldauf fr seine  Anregungen in seinem Artikel in der ST-Computer 01/91. 

5.9.	Update's

Diese Routinen werden st„ndig an erweiterte Betriebssystem- Versionen angepat. Sollte es sich als Zweckm„ig erweisen, k”nnen noch weitere ntzliche Funktionen zur Dialogboxverwaltung aufgenommen werden. Updates k”nnen bei

Michael Kovar
Waldmannstr. 17
W-1000 Berlin 46

bezogen werden. 


5.10.	ben”tigte Erweiterungen

Die Prozeduren der Version 1.0 sind eigenst„ndig lauff„hig und ben”tigen auer den mitgelieferten Compiler-Bibliotheken keine Erweiterungen. Die ab der Version 2.0 enthaltenen Prozeduren ben”tigen in jedem Fall den GEM-Manager, da auf einige Funktions- und Objektdefinitionen zurckgegriffen wird. Nur somit ist eine aufl”sungsunabh„ngige Programmierung der Move- und Popupboxen gew„hrleistet. Die Restaurierung von Fensterinhalten wird durch die Bibliothek des Resource-Managers abgedeckt. Der erforderliche Speicherplatz wird dynamisch allokiert. Beachten Sie deshalb unbedingt die Rckgabewerte der jeweiligen Dial-Funktion. Wird ein Fehler mitgeteilt, so drfen die Moveboxen nicht zum Einsatz kommen. Stattdessen mssen die Moveboxen wie "normale" Dialogboxen verwaltet werden. Sie ernten sonst bombige Erfolge...

5.11.	Wichtiger Hinweis

Wenn Sie das Exit-Objekt einer Dialogbox deselektieren wollen, beachten Sie bitte, da das AES das oberste Bit setzt, wenn das Exit-Objekt mittels Doppelklick verlassen wurde! H„ufig wird dies nicht beachtet und der Rckgabewert Funktion form_do() bzw. exform_do() einfach der Funktion undo_objc() bergeben. Sicherer ist es, vor Aufruf das oberste Bit zu l”schen:

rsrc_gaddr(R_TREE, BAUM, &baum);
box_draw(baum, 0, 0, 0, 0);
ex_objc = fom_do(baum, 0);
if(ex_objc & 0x8000)
{
	/* Aktion bei Doppelklick auf Exit-Objekt */
	...;
}
ex_objc &= 0x7fff; /* Oberstes Bit l”schen */
undo_objc(baum, ex_objc, SELECTED);

box_undraw(baum, 0, 0, 0, 0);

5.12.	Aktuelle Version

Die Version 2.0 vom 14.02.1991 des Resource-Managers ersetzt die Version 1.0 vom 30.04.1990. S„mtliche Funktionen der Version 1.0 sind weiterhin implementiert. Weiterhin sind die beweglichen Dialogboxen von Matthias Baldauf implementiert.
Die aktuelle Version 2.1 vom 18.09.1991 des Resource-Managers ersetzt die Version 2.0 vom 14.02.1991. Der Funktionsumfang blieb unver„ndert. nderungen betrafen lediglich das Handbuch. Die noch in der Version 2.0 angestrebte Verwaltung von MAC-Buttons und Checkboxen wurde der besseren šbersichtlichkeit ausgelagert und zum Button-Manager ausgebaut.
Die Aktuelle Version 3.0 vom 29.11.1992 ersetzt die Version 2.1 vom 14.02.1992 vollst„ndig. Der Funktionsumfang erstreckt sich auf die Verwaltung von Dialogboxen in Fenstern.

Letzte Arbeiten am Handbuch: 29.11.1992
(C) 1990-92 by Michael Kovar


6.	Der Button-Manager

6.1.	Allgemeines

Der Button-Manager ist im Prinzip eine Erweiterung des Form- Managers. Mit dieser Erweiterung lassen sich in Dialogboxen eigene selbst kreierte Objekte einbauen - sogenannte USER DEFINED OBJECTS. Die Verwaltung wird vom Button-Manager bernommen. Es mssen lediglich einige Formalien beim Erstellen der Resource-Datei bercksichtigt werden. Das Aussehen der neuen Objekte wird erst zur Laufzeit des Programms ver„ndert. Also nicht verzagen, wenn Sie die Buttons ganz tierisch in den Resource-Dateien suchen - die sehen dort ganz anders aus!!! Ein Beispiel dafr, wie eine Dialogbox mit MAC-Buttons und Checkboxen auf dem Bildschirm aussehen k”nnte:


<< Bild: "BUTMNGE.IMG" >>



Die Grafik zeigt die Dialogbox des Testprogramms des Button-Managers. Das Attribut OUTLINED wurde in der ersten Knopfzeile angewendet. Das Attribut CHECKED macht sich nur akustisch in Form der Klingel bemerkbar.


6.2.	Was macht der Button-Manager?

Zuerst ist zu sagen, da die Objektgr”e auf 16x16 Pixel beschr„nkt ist. Das aussehen dieses Objektes ist Ihnen frei berlassen. Zwei Button-Typen sind schon vordefiniert:

 	- Radio-Buttons … la MAC
 	- Cross-Boxen

Jedes dieser Objekte existiert in der Definition in den Zust„nden "normal" und "selected". Der Button-Manager macht nun nichts weiter als in der Resource-Datei - wenn sie mit rsrc_load() in den Arbeitsspeicher geladen wurde - nach sogenannten Platzhaltern zu suchen und diese dann in die Objektart USER DEFINED zu „ndern. Die Zeichenroutine fr das jeweilige Objekt wird vom Button-Manager mitgebracht. Wird die betreffende Dialogbox auf den Bildschirm gezaubert, so wird statt dem in der Resource-Datei angegebenen Objekt das von Ihnen abge„nderte Objekt gezeichnet. Die Behandlung des Objekts bernimmt GEM, so als ob es dieses neue Objekt schon immer kennen wrde! Zur Zeit untersttzt der Button-Manager die Objekt- Flags:

 	- SELECTABLE incl. RADIO-Button
 	- CHECKED
 	- OUTLINED.



6.3.	Vorbereitungen in der Resource-Datei

Um in einer Dialogbox die neuen Objekte plazieren zu k”nnen, wird ein Standard-Objekt als Platzhalter mibraucht. In diesem Platzhalter-Objekt sind alle Informationen enthalten, die der Button-Manager ben”tigt (und das sind nicht viele...). Der Nachteil liegt sogleich auf der Hand: Wird der Button-Manager verwendet, so kann dieses einfache GEM-Objekt ohne weiteres nicht mehr in dieser Dialogbox verwendet werden, da es ja einen neuen Objekttyp verk”rpert. An die in Frage kommende Stelle in der Dialogbox wird als Platzhalter-Objekt ein BOXCHAR eingesetzt. Ein BOXCHAR bietet die M”glichkeit, einen Buchstaben in seinem Inneren zu beherrbergen. Dieser Buchstabe enth„lt fr den Button-Manager die Information, welches Objekt dafr eingesetzt werden soll. Fr die beiden vordefinierten Objekte gelten folgende Buchstaben:

 	Mac-Buttons:	o (klein)
 	Cross-Boxen:	x (klein)
	Knick-Ecke:	e (klein)

Es werden Gro- und Kleinbuchstaben unterschieden!


6.4.	Aufruf des Button-Managers im Programm

Im Vorlauf des Programms haben Sie auch nicht berm„ig viel zu tun. Der Button-Manager erwartet ein Array, in dem s„mtliche Baumadressen der Dialogboxen eingetragen sind, in denen die Platzhalter- Objekte ersetzt werden sollen. Der Schlu der Liste wird durch 0L gekennzeichnet. Nachdem diese Arbeit erledigt ist, mu nur noch die Funktion init_buttons(liste) init_buttons() aufgerufen werden. So einfach ist das.



6.5.	Definition neuer Objekte

Fr die Definition neuer Objekte gibt es die Datei SWITCHES.BTN. In dieser Datei werden die Bit-Masken der neuen Objekte hinterlegt. Die Standard-Datei des Button-Managers hat folgenden Inhalt:

/* Schalter-Definition */

typedef struct { 	int on[16]; 	int off[16]; } SWITCH;

SWITCH Runder_Knopf = { 0x0000, 0x03c0, 0x0c30, 0x1008, 0x23c4, 0x27e4, 0x4ff2, 0x4ff2, 0x4ff2, 0x4ff2, 0x27e4, 0x23c4, 0x1008, 0x0c30, 0x03c0, 0x0000, 0x0000, 0x03c0, 0x0c30, 0x1008, 0x2004, 0x2004, 0x4002, 0x4002, 0x4002, 0x4002, 0x2004, 0x2004, 0x1008, 0x0c30, 0x03c0, 0x0000 };

SWITCH Eckiger_Knopf = { 0x0000, 0x7ffe, 0x6006, 0x500a, 0x4812, 0x4422, 0x4242, 0x4182, 0x4182, 0x4242, 0x4422, 0x4812, 0x500a, 0x6006, 0x7ffe, 0x0000, 0x0000, 0x7ffe, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x7ffe, 0x0000 }; 

Die Struktur SWITCH beinhaltet die Bitmuster fr den selektierten und den normalen Zustand. In der eigentlichen Definition der Kn”pfe sind jeweils zwei Zeilen fr den selektierten Zustand und die letzten zwei Zeilen fr den normalen Zustand zust„ndig. Um das Aussehen eines Knopfes zu entwerfen benutzen Sie am besten ein kariertes Papier und grenzen sich ein Quadrat mit jeweils 16 K„stchen horizontal und vertikal ab. Innerhalb dieses Gebietes k”nnen sie jetzt Bits setzen um so das Aussehen des Objektes zu definieren. Anschlieend wird Zeile fr Zeile codiert und in eine Variable mit der Struktur SWITCH in die Datei BUTTON.H eingetragen. Der n„chste Schritt besteht darin, dem Button-Manager diese neuen Objekte mitzuteilen. Dazu sind in der Datei BUT_MNGE.C folgende Zeilen abzu„ndern:


char	paten[] = "ox";		/* zwei Schalterarten */

USERBLK	user_defined[] = {
			draw_procedure, (long)(&Runder_Knopf),
			draw_procedure, (long)(&Eckiger_Knopf) };

Im Array paten werden die Buchstaben eingetragen, die sp„ter im Platzhalter-Objekt das neue Objekt spezifizieren. Im Array user_defined steht fr jedes neue Objekt ein Zeiger auf die Zeichenroutine (standardm„ig draw_procedure) sowie die Adresse der SWITCH-Struktur, die die Informationen zum Aussehen des Objekts enth„lt. Der Button-Manager bernimmt die Zuordnung folgendermaen: Trifft er auf ein Objekt des Typs BOXCHAR, so holt er den spezifizierten Buchstaben aus der Objektstruktur. Diesen Buchstaben sucht er im Array paten. Findet er den Objektbuchstaben, so benutzt er den Offset um aus dem Array user_defined die Adresse der Zeichenroutine und die dazugeh”rige Definitionsvariable zu ermitteln. Am Beispiel des Mac-Buttons sieht das folgendermaen aus: Fr den MAC-Button ist der Buchstabe o (klein) vorgesehen. Im Array paten steht der Buchstabe an erster Stelle, hat also den Offset null. Daraufhin wendet er sich dem Array user_defined und benutzt den Offset zur Ermittlung der betreffenden Adressen fr Zeichenroutine und Definitionsdaten. Dies entspricht bei Offset null der ersten Zeile in user_defined. Es werden die Adressen der Standard-Zeichenroutine bergeben als auch die Definition Runder_Knopf.


6.6.	Was wird noch ben”tigt?

Da der Button-Manager so ziemlich mit allen Aufl”sungen zurechtkommen soll, ben”tigt er eine Variable vdi_handle, in der das gleichnamige Handle des VDI bei der Er”ffnung der Workstation eingetragen ist. Da der Button-Manager der Funktion vro_cpyfm() erm„chtigt, empfehlen wir, die Funktion gem_init() der allgemeinen Bibliothek zu benutzen. Sie enth„lt alle notwendigen Initialisierungen des GEM, so k”nnen Sie sich getrost dem eigentlichen Programm widmen.


6.7.	Vertr„glichkeit

Der Button-Manager l„t sich problemlos mit den anderen Managern verwenden, teilweise greift er auf Funktionen und Datenfelder des GEM-Managers zurck. Somit l„uft der Button-Manager unter jeder durch GEM untersttzten Bildschirmaufl”sung.


6.8.	Aktuelle Version

Aktuelle Version 1.0 des Button-Managers vom 18.09.1991. Updates bis jetzt keine. Der Button-Manager wurde sollte zuerst dem Resource-Manager zugefgt werden. Im Laufe der Implementation stellte es sich aber als zweckm„ig heraus, diesen getrennt aufzubauen. Eine nderung der Dokumentation des Resource-Managers beinhaltet lediglich auf einen Verweis auf den Button-Manager. Letzte Arbeiten am Handbuch: 18.09.1991


6.9.	Sonstiges

Der Button-Manager beruht im wesentlichen auf einem Artikel der ST-Computer 2/1991, dessen Autor Hans-Jrgen Richstein ist. Es erfolgte eine Anpassung an den Mark Williams C - Compiler Verion 3.09 sowie Integrierung in das Manager-Paket.


7.	Der Men-Manager

Ein Grund fr die hohe Benutzerfreundlichkeit von GEM-Programmen sind sicher die Dropdown-Mens. Doch wie es allgemein (bzw. bei ATARI) blich ist, werden gute Sachen nur unvollst„ndig gemacht, so da beim Programmierer bzw. Anwender noch viele Wnsche offen bleiben. Die Funktionen des Men-Managers erweitern die Menanwendungen unter GEM und geben dem anspruchsvollen Programmierer somit Werkzeuge in die Hand, mit denen ein Programm noch benutzerfreundlicher gestaltet werden kann.

Der Men-Manager wurde mit dem Mark Williams C Version 3.09 erstellt. Er ist unter allen  g„ngigen TOS-Versionen und Bildschirmaufl”sungen lauff„hig. Getestet wurde er auf einem ATARI ST 1040, MEGA ST1 und ATARI TT 030.

		Version  2.10 vom 29.11.1992


7.1.	nderungen gegenber der Version 1.00

Die interne Abarbeitung der Popup-Mens wurde korrigiert.


7.2.	Allgemeines zu Pulldown-Mens

Dieses Kapitel soll eine allgemeine Einfhrung zu Pulldown-Mens sein und ist fr die Personen unter Ihnen gedacht, die sich einigermaen mit GEM auskennen, ihr Wissen aber noch einmal vom Unterbewutsein hochholen wollen.


<< Bild: "MENU_P_1.IMG" >>


Wie Bild 1 zeigt, ist am oberen Rand des Bildschirm der Menbalken untergebracht. In ihm stehen Mentitel, unter denen sich die Pulldown- Mens ”ffnen, wenn der Mauszeiger in das Feld des Titels bewegt wird.

<< Bild: "MENU_P_2.IMG" >>



Das Men hat, um vom GEM erkannt zu werden, einen Standartaufbau. Im der Menbox ganz links dient der erste Eintrag -falls er angeklickt wird-der Ausgabe von Copyright- oder „hnlichen Informationen zum Programm. Danach folgt eine helle gestrichelte Linie. Danach sind 6 Eintr„ge fr die Accessories eingerichtet. Diese k”nnen beim Einrichten durch ein Resource Construction Set beliebig lauten, da die eigentliche Eintragung erst beim Laden eines Accessories erfolgt. Bild 2 zeigt das aufgeklappte Men. Die Accessorieeintr„ge sind aber nur zu sehen, wenn Accessories geladen sind.

<< Bild: "MENU_P_3.IMG" >>


Der Rest des Mens kann frei gestaltet werden. Unter einem Mentitel weren eine beliebige Anzahl von Strings (= Objekttyp) angefgt, die die Meneintr„ge darstellen. Helle Meneintr„ge sind deselektiert, d.h. sie k”nnen nicht ausgew„hlt werden. Die Eintr„ge sollten bersichtilich angeordnert sein und evtl. in Gruppen eingeteilt werden. Dies wird durch die hellen Striche erreicht.


Nicht alle Meneintr„ge sind jederzeit anw„hlbar. Diejenigen, die nicht ausgew„hlt werden k”nnen, sind in heller Schrift dargestellt. Die Menkontrolle wird beendet, wenn der linke Mausknopf gedrckt wird.

Soviel zur Erstellung eines Mens. Um solch ein Men zu erstellen, ben”tigen Sie einen sogenannten Resource Editor ("Resource Construction Set" ist ein geschtzter Name; so heit der Resource Editor von Digital Research). In seiner Anleitung sind (sollten) alle notwendigen Begriffe und Objekt erl„utert sein, so da hier nicht genauer darauf eingegangen werden mu.


7.3.	Die Tastenuntersttzung bei Dropdown-Mens

Wer schon einmal eine Textverarbeitung besessen hat, die nur ber Dropdown-Mens zu bedienen ist, wei, da solche Benutzeroberfl„chen nicht bei jeder Anwendung unbedingt anwenderfreundlich sein mssen. Es sieht zwar nett aus, wenn man mit der Maus (hoffentlich) ordentlich geordnete Mens aufklappen kann, um so einen Gesamtberblick ber die Funktionen des Programm zu erhalten. Doch gerade bei so tastenintensiven Programmen wie der Textverarbeitung nervt es doch, jedesmal die Hand von der Tastatur zu nehmen, um ber das Dropdown-Men z.B. die Unterstreichung anzustellen. Da liegt es nahe, spezielle Tastencodes zu definieren, ber die die Funktionen eines Programms aufgerufen werden k”nnen (parallel zu den Mens). Dies h”rt sich einfach an, ist aber fr den Programmierer mhsam, da er neben der Menabfrage auch die Tastencodes abprfen mu. Diese Arbeit wird Ihnen vom Men-Manager abgenommen.


7.3.1.	Prinzip der Tastenuntersttzung in Mens

Normalerweise wrde die Tastaturuntersttzung folgendermaen aussehen. Erstens wird mit einem Resource Construction Set wird das Men aufgebaut. In jedem Meneintrag wird neben dem eigentlichen Text auch die Tastenkombination angegeben (siehe dazu Bild 3), mit der die gleiche Aktion aufrufen wird. Dies hat aber nur dokumentarischen Wert, denn die Tastaturabfrage mu noch programmiert werden. Nach jedem Tastaturereignis mu also die Tastenkombination abgefragt werden, um festzustellen, ob eine im Men angegebene Aktion durchgefhrt werden soll. Wird das Menu umstrukturiert (andere Tastenkombinationen usw.), mu evtl. auch das Programm ge„ndert werden. Zus„tzlich mssen die in der GEM-Dokumentation vorgegebenen Aktionen durchgefhrt werden, wie den Mentitel mit "menu_tnormal()" invertieren und nach der Ausfhrung der Funktion diesen Titel mit "menu_tnormal()" wieder normal darstellen.

Wenn man sich das Ganze genauer ansieht, taucht die Frage auf, ob nicht die im Meneintrag hinterlegte Tastenkombination fr die Tastaturabfrage genutzt werden kann. Die Antwort ist ja, denn fr das Programm ist es unwichtig zu wissen, ob ein Meneintrag angeklickt oder ob die entsprechende Tastenkombination gedrckt worden ist. Fr den Programmierer w„re es also angenehm, wenn er die Zuordnung der Meneintr„ge zu den Tastenkombinationen bereits im Resource Editor vornehmen k”nnte, und das AES danach fr das Klicken auf einen Meneintrag oder das Bet„tigen der entsprechenden Tastensequenz dem Programm dieselbe Meldung schicken  wrde. Neuzuweisungen von Tastenkombinationen w„ren dann kein Problem mehr.

Meldungen k”nnen nicht nur vom System an Programme geschickt werden, auch Programme selbst haben die M”glichkeit, Meldungen an andere Applikationen und an sich selbst zu schicken. Genau so funktioniert der Men-Manager. Er wird vom Programm aufgerufen, wenn ein Tastaturereignis eintritt (Funktion menu_search()) und durchsucht die Tastenkombination auf die Zugeh”rigkeit zu einem Meneintrag. Wird die Tastenkombination gefunden, schickt der Men-Manager eine entsprechende Meldung an die eigene Applikation. Danach wird die Funktion des Men-Managers beendet und das Hauptprogramm springt zum Anfang der Ereignisabfrage und wartet auf ein neues Ereignis. Dieses wird die zuvor abgeschickte Meldung sein, worauf das Programm glaubt, der entsprechende Meneintrag sei mit der Maus angeklickt worden und fhrt somit die richtige Funktion aus.


7.3.2.	Realisierung der Tastaturuntersttzung

Der Men-Manager wird mit der Funktion menu_search() aufgerufen. Es werden dabei folgende Tastenkombinationen untersttzt (X steht fr ein beliebiges einzelnes Zeichen):

<< Bild: "MENU_P_4.IMG" >>



Die Eintr„ge fr die Tastenkombinationen mssen ganz rechts im Meneintrag stehen (wie im Bild 3, Kapitel 5.2 zu sehen), wobei die Tastenkombinationen wie oben beschrieben dargestellt werden mssen. Accessory-Eintr„ge sind von der Suche ausgeschlossen (der Eintrag "šber Programm..." wird aber bercksichtigt). Kommt dieselbe Tastenkombination in mehreren Meneintr„gen vor, wird immer der erste gefundene Eintrag genommen.

Der Men-Manager bernimmt die Suche nach šbereinstimmung der bergebenen Tastenkombination mit einem Vermerk im Men. Sie k”nnen also jederzeit die Tastenvermerke im Men „ndern, ohne eine Tastaturabfrage im Programm „ndern zu mssen. Trifft der Men-Manager auf eine šbereinstimmung, so werden von ihm folgende Schritte unternommen:


1.	Der entsprechende Mentitel wird invers dargestellt.

2.	Es wird eine Meldung an die eigene Applikation abgeschickt. Der Message-Buffer sieht dabei folgendermaen aus:

	msg_buffer[0] = 10 (MN_SELECTED)
	msg_buffer[1] = Applikationsnummer
	msg_buffer[2] = 0 (, da L„nge der Meldung < als 16 Bytes)
	msg_buffer[3] = Index des Mentitels
	msg_buffer[4] = Index des Meneintrages

Damit wird exakt die Situation simuliert, wie sie das Hauptprogramm antrifft, wenn derselbe Meneintrag mit der Maus angeklickt worden w„re. Ist ein Meneintrag disabled (hell dargestellt), kann er mit der Maus nicht selektiert werden. Die Routine verschickt in einem solchen Fall keine Meldung. Ist ein Meneintrag disabled, kann das entsprechende Men gar nicht herunterklappen. In diesem Fall ist das ganze Men von der Suche ausgeschlossen.


7.3.3.	Funktionsbeschreibung

Wie schon vorher erw„hnt, wird der Men-Manager durch folgende Funktion aufgerufen:

	int  menu_search(ap_id,menu_tree,kstate,key)

Parameterbergabe
	int		ap_id;
	OBJECT	*menu_tree;
	int		kstate;
	int		key;



(1) ap_id- int
Dies ist die Applikationsnummer des eigenen Programms. Diese ist fr den Men-Manager notwendig, um zu wissen, an wen die Messages fr ein Menereignis geschickt werden mssen. Die Applikationsnummer wird durch die Funktion appl_init() bergeben und ist im global definierten Feld ap_id des GEM-Managers enthalten.

(2) *menu_tree - OBJECT
Struktur fr die Objektbeschreibung des Menbaum. Diese Struktur wird vom Men-Manager ben”tigt, um sich durch den Objektbaum zu "hangeln". Die Struktur wird durch die Funktion rsrc_gaddr() gefllt

(3) kstate - int
Dieses Feld enth„lt den Zustand der Zusatztasten Alternate, Control, Shift. Es kann folgende Werte annehmen:

	0x00			keine Zusatztaste wurde gedrckt
	0x01	K_RSHIFT	rechte Shifttaste
	0x02	K_LSHIFT	linke Shifttaste
	0x04	K_CTRL	Controltaste
	0x08	K_ALT		Alternatetaste

Diese Werte sind logisch-oder-verknpft, wenn mehrere dieser Tasten gleichzeitig gedrckt wurden. Dieser Wert wird von der Funktion evnt_multi() zurckgegeben. Wenn Sie dem Event-Manager nutzen, k”nnen Sie das Feld event_return.mouse_k bergeben.

(4) key - int
Dieses Feld enth„lt den Scan- und ASCII-Code der gedrckten Taste. Dieser Wert wird von der Funktion evnt_multi() zurckgegeben. Sollten Sie den Event-Manager nutzen, k”nnen Sie das Feld event_return.key bergeben.



Parameterrckgabe
	menu_search() = 0	: keine šbereinstimmung gefunden
	menu_search() = 1	: Tastenkombination in Men gefunden


7.4.	Popup-Mens

7.4.1.	Funktionsweise unter dem Men-Manager

Popup-Mens sind vom Aufbau her den Dropdown-Mens gleich, sie besitzen eine Titelzeile und mehrere Meneintr„ge. Der Unterschied zwischen ihnen besteht darin, da Popup-Mens beliebig auf dem Bildschirm plaziert werden k”nnen, w„hrend die Dropdown-Mens immer am oberen Rand des Bildschirms stehen. 

Der Men-Manager bernimmt nach dem entsprechenden Funktionsaufruf das Zeichnen eines Popup-Mens an einer beliebigen Stelle im Bildschirm und dessen šberwachung. Die Meneintr„ge werden mit einem String bergeben, wobei einzelne Eintr„ge hell dargestellt werden k”nnen, also nicht anw„hlbar sind.

Die Meneintr„ge des Popup-Mens k”nnen in mehreren Spalten angeordnet sein. Die Eintr„ge werden vertikal durchnummeriert, d. h. sind sind wie folgt angeordnet:

	Eintrag 1	|	Eintrag 4	|	Eintrag 7
	Eintrag 2	|	Eintrag 5	|	Eintrag 8
	Eintrag 3	|	Eintrag 6	|	Eintrag 9

Der Mauszeiger kann den Bereich des Popup-Mens nicht verlassen. W„hrend das Men gezeichnet ist, werden alle Bildschirmausgaben gesperrt, analog zu den Dropdown-Mens.

Mit dem Drcken der linken Maustaste kehrt der Men-Manager in das Programm und bergibt die Nummer des angew„hlten Meneintrages, eine Null, wenn keiner angew„hlt wurde oder einen Fehlercode. Eine genaue Beschreibung erfolgt mit der Auflistung der šbergabeparameter in der Funktionsbeschreibung.


7.4.2.	Funktionsbeschreibung

	int	popup_menu(x,y,columns,text)

Parameterbergabe:
	int	x,y;
	int	columns
	char	*text

(1) x,y - int
Koordinaten der linken, oberen Ecke des Popup-Mens. Ragt das Men aus dem Bildschirm hinaus, werden die Koordinaten automatisch korrigiert.

(2) columns - int
Mit columns wird die Anzahl der Spalten angegeben, in denen die Meneintr„ge angeordnet werden. Mindestens mu eine "1", maximal darf die Anzahl der Meneintr„ge bergeben werden.

(3) text - *char
Mit text wird ein Stringfeld bergeben, das die Texte der einzelnen Menpunkte enth„lt. Der String mu einem genau festgelegten Aufbau entsprechen. Zuerst mu der Mentitel angegeben werden. Ihm folgen die Meneintr„ge, wobei das Stringende auch das Ende des Mens anzeigt.

Alle Meneintr„ge mssen durch das Zeichen "|" voneinander getrennt werden. Soll ein Eintrag hell dargestellt werden, also nicht anw„hlbar sein, mu als erstes Zeichen ein "-" im entsprechenden Eintrag stehen. Dieses wird natrlich nicht in das Men geschrieben, sondern dient lediglich als Sonderzeichen.

Der Titel wird durch eine Linie von den restl. Eintr„gen getrennt und in der horizontalen Mitte des Popup-Mens plaziert. Sollen die Eintr„ge in mehreren Spalten angeordnet werden, werden diese Spalten durch senkrechte Striche getrennt.

Es folgt nun ein Beispiel eines Menstrings und der dazugeh”rigen Ausgabe dieses Popup-Mens:

	strcp(menutext,"DATEI|");
	strcat(menutext,"  Neuladen...			^L  |");
	strcat(menutext,"  Hinzuladen...			^H  |");
	strcat(menutext,"------------------------------------------|");
	strcat(menutext,"  Speichern			^S  |");
	strcat(menutext,"  Speichern unter...		*S  |");
	strcat(menutext,"  Block speichern...		^B  |");
	strcat(menutext,"------------------------------------------|");
	strcat(menutext,"  Datei drucken			^D  |");
	strcat(menutext,"  Drucken in Datei...		*D  |");
	strcat(menutext,"-===================================|");
	strcat(menutext,"  Ende				^Q");



<< Bild: "MENU_P_5.IMG" >>



Parameterrckgabe
popup_menu() > 0	Nummer des Meneintrages, der ausgew„hlt wurde
             = 0	Kein Men ausgew„hlt; entweder befand sich der Mauszeiger auerhalb des Mens oder berhalb eines Leereintrages oder der Meneintrag war nicht anw„hlbar
             = -1	Die Anzahl der Spalten ist Null
             = -2	Es wurden keine Meneintrage bergeben
             = -3	Die Menbox ist gr”er als der Desktop
             = -4	Die Anzahl Spalten ist gr”er als die Anzahl der Meneintr„ge
             = -5	Die Koordinaten x,y sind ungltig, d.h. sie liegen auerhalb des Desktops oder im Bereich der Titelzeile fr die Dropdown-Mens
             = -6	Nicht gengend Speicher fr das Sichern des Hintergrundes



7.4.3.	Programmierhinweise

Dieses Kapitel sollten Sie auf alle F„lle durchlesen, da die Anwendung der Popup-Mens Auswirkungen auf Ihre Programmierung haben kann.

Die Popup-Mens unter dem Men-Manager werden mit VDI-Funktionen gezeichnet. Sollten Sie in Ihrem Programm ebenfalls mit VDI-Funktionen arbeiten, sollten Sie beachten, da nach Aufruf der Funktion "popup_menu()" die VDI-Attribute ge„ndert wurden.

Um ein Popup-Men nach Beendigung ordnungsgem„ vom Bildschirm zu entfernen, mu der Hintergrund vor dem Zeichnen zwischengespeichert werden. Dies geschieht mit der Funktionen "get_image()", die ebenfalls Bestandteil des GEM-Managers ist. Dafr wird natrlich Speicherplatz ben”tigt, der aber nach Beendigung von "popup_menu()" wieder freigegeben wird.

Der Men-Manager benutzt den Event-Manager fr die Ereignisverwaltung in den Popup-Mens und ver„ndert damit die šbergabefelder (event.xxxx). Diese šbergabefelder werden vor dem Zeichnen der Menbox gesichtert und nach Beendigung wieder in den šbergabebereich geschrieben. Dadurch ist gew„hrleistet, da Ihre Ereignisverwaltung unbeeinflut bleibt.

Der Men-Manager arbeitet unabh„ngig von der Bildschirmaufl”sung und des Systemzeichensatzes. Da heit, da sich mit der Gr”e der Zeichen auch die Gr”e der Box „ndert (Benutzung der Felder aktuell.text_x, aktuell.text_y). Sie sollten daher darauf achten, da das Popup-Men in allen Aufl”sungen, unter denen Ihr Programm laufen soll, auch auf den Bildschirm pat.



7.4.4.	Einbindung in das eigene Programm

Das dem GEM-Manager beiliegende Beispielprogramm beinhaltet auch die Menverwaltung und ein Popup-Men. Daran drfte die Benutzung des Men-Managers klar werden.


7.5.	Sonstiges

Literatur:	- "Tastenuntersttung in Dropdown-Mens"
		  Urs Mller
		  ST Computer 11/89

		- Handbuch zu Mark Williams C  Version 3.09

		- Handbuch zum Mark Williams Resource Editor
