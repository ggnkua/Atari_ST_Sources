
 ST Color Palette
 Displays the ST's 512 colors

 by Tom Hudson

 Most new Atari 520ST owners, if they're like me, want to see what kind of fancy
graphic "tricks" their computer can do. Here's a short program, written in
Digital Research C and 68000 assembly language, which displays all the ST's 512
colors on your computer screen at once. The ST Color Palette (STCP) also allows
you to determine the color register settings needed to use that color in your
own programs, by simply moving the mouse. If you don't have a C compiler or
assembler, don't worry - the compiled program will be available on the ANALOG
Computing (TCS).

 The colors of the ST.

 Inside the ST computer are sixteen hardware "registers", each of which contains
a code for producing a particular color on the monitor. The code is very
simple. Each color seen by the human eye is made up of various amounts of red,
green and blue light, which are produced by the ST's RGB (Red-Green-Blue)
monitor.

 The ST is able to set each of the red, green and blue color components to one
of eight levels, numbered from 0 through 7. A level of 0 indicates that the
color is not present; a level of 7 indicates that the color is at its brightest
setting. The three colors,with eight values each, give the ST 8x8x8, or 512,
colors.

 Normally, the ST can display only sixteen colors on the screen at one time
(there are only sixteen color registers in the computer). The user must pick
the sixteen colors he or she needs most and set the color registers
accordingly.

 Fortunately for game designers and graphics aficionados like myself, the ST has
an interesting ability hidden under that gray exterior - an ability similar to
the display list interrupts (DLIs) of the 8-bit Atari computers. By using it,
the advanced programmer can change the ST color registers at any point on the
screen, giving the ST the power to display far more than 16 colors on the
screen at one time - even up to the system's limit of 512!

 Before I go any further, I must explain that the STCP was developed by trial
and error, working with the hardware registers in the ST, and some of the
functions of the machine language subroutine cannot be fully documented without
complete information from Atari.

 However, the macine language routine is documented enough for you to change it
to suit your needs. As more information about this capability is released by
Atari, ANALOG Computing will report it. I don't recommend using this procedure
in commercial programs, for some of the memory locations used are not yet
documented by Atari and may change in future revisions of the ST.
The full palette.

 If you have a C compiler and assembler, type in, compile and link the programs
in Listings 1 and 2. If not, the ANALOG Computing TCS will have the compiled
program available to TCS subscribers.

 This program must be executed in the 16-color, low-resolution mode, or it won't
work properly.

 After loading the program, you'll see the 512 colors of the ST displayed on the
screen in 8 columns of 64 boxes. You can move the arrow on the screen, using
the mouse, and point to any color you like. That color's red, green and blue
settings will be shown in the lower right corner.

 The program may be stopped at any time, and you can return to the GEM desktop
by pressing the SPACE BAR.

 If you're not an advanced programmer - and don't want to be - enjoy the STCP.
If you are, read on for the details on how the ST can display its true colors.
It takes two.

 As mentioned earlier, this program is made up of two parts: C language
initialization and control program and an assembly language section, which
contains special interrupt routines to enable the 512-color display.

 The C control program, shown in Listing 1, gets everything started. Let's look
at the program and note the points of special interest.

 +----------------------------------------------------------------------------+
 | GEM Color Number    ST Pixel Value      Gem Color Number    ST Pixel Value |
 +----------------------------------------------------------------------------+
 |        0                   0                   8                   7       |
 |        1                  15                   9                   8       |
 |        2                   1                  10                   9       |
 |        3                   2                  11                  10       |
 |        4                   4                  12                  12       |
 |        5                   6                  13                  14       |
 |        6                   3                  14                  11       |
 |        7                   5                  15                  13       |
 +----------------------------------------------------------------------------+

 Take a look at Figure 1 above. In the ST, the value of a pixel indicates which
color register is to be used for that color. To use color register 5, the
pixel's value should be 5.

 Because GEM's color register numbering is not the same as the ST's pixel
numbers (GEM's color 5 gives a pixel value of 6, which uses color register 6),
it's necessary to translate the pixel values we want into their GEM
counterparts. This is done with the 8-member COFSET array. If we want the pixel
value to be 1, we tell GEM to use the first color index in the array, which is
2. If we want a pixel value of 3, we use the third index in the array, or 6.
This is a confusing way to set up the color registers, but the authors of GEM
must have had a good reason for doing it this way. Once this is done, though,
we don't have to worry about it anymore.

 In order to tell the user the level of red, blue and green light present in
each color, we next set up the REDVAL, GRNVAL and BLUVAL text areas. Each of
these fields is two characters long, allowing for one digit and a terminating
character, the ASCII null (0). The null is the standard End-Of-Line (EOL)
character in ST text-handling routines.

 A little further down, we SAVE the settings of the color palette so that they
may be restored before returning to the GEM desktop. I suggest that you always
do this, if you're going to change the colors in your programs - the user will
appreciate having the normal desktop colors restored. This operation uses the
BIOS SETCOLOR call, which, along with the other calls used in this program, is
documented in the "Hitchhiker's guide to the BIOS" manual from Atari. The
routines to call the BIOS are included in the machine language program in
Listing 2.

 The next section of the program initializes the CIABLE array, which contains
the 512 2-byte integer values that define all the various colors available on
the ST. The STCP goes through three FOR loops to initialize the table, each
loop altering the red, green or blue component.

 Note that the color values are added together with various multiplication
factors, to form a number such as $707 (7 red, 0 green, 7 blue), then added to
$F888. The resulting value is ready to be loaded into the ST's hardware color
register, and ranges from $F888 (black) to $FFFF (white). The CTABLE table is
externally defined, in the machine language portion of the program.

 The next section of STCP draws 512 boxes on the screen, starting with color 1
on the left and ending with color 8 on the right. You'll see the columns of
boxes drawn on the screen, all the boxes in the same column being the same
color. When the machine language routine is called, the screen colors will be
changed every three scan lines, resulting in 512 colors on the screen instead
of 8!

 After changing the colors to white for the arrow, and red, green and blue for
the color number readouts, the title message is printed and the arrowis shown
on the screen. We're now ready to start the colors!

 To start the 512-color display, STCP issues a call to the machine languag GO.
This initializes and starts the 512-color display.

 The next portion of the program reads the position of the arrow with the
VQ_MOUSE routine and gives a constant readout of the color register settings of
the color the arrow's pointing at. This is a handy way to figure out which
colors you want to use in a program - just point to the color you want, and the
red, green and blue digits in the lower right corner of the screen will tell
you what color settings to use.

 The color register setting values are printed whenever the mouse moves to a new
color on-screen. When this happens, the digits representing the red, green and
blue values are placed in the REDVAL, GRNVAL and BLUVAL text messages, and are
printed to the screen in the corresponding color with the VST_COLOR and V_GTEXT
calls.

 The keyboard is constantly monitored by the BCONSTAT and BCONIN functions - if
the SPACE BAR is pressed, the program exits.

 Before exiting, STCP calls the machine language routine labeled STOP, shutting
off the routines we started earlier and restoring the system to normal
operation.

 Finally, the color palette is returned to normal by using the SETPALLETE
(that's the way it's spelled in the "Hitchhiker's Guide...") routine to reset
the color registers to the values we saved when the program started.

 The machine language routine.

 Without adequate documentation from Atari, I can't guarantee the accuracy of
some of the assumptions I've made in the explanation of this machine language
routine. Many of the locations' functions listed are educated guesses, made by
removing the instructions and observing the results. This code is, however,
useful in exploring the use of horizontal blank interrupts on the ST, a
function similar to the DLI structure on the 8-bit Atari machines.

 Unlike the 8-bit Atari computers, the 520ST doesn't have a "display list", the
special program that tells the display how to act. It does, however, have a
powerful ability to generate an interrupt which will perform a set of
instructions at various points on the screen. This interrupt can be programmed
to occur on every scan line, every two scan lines, every three scan lines, and
so forth. This is termed a horizontal blank (HBLANK) interrupt. We will also
use the vertical blank (VBLANK) interrupt ability to handle the control of the
HBLANK.

 Listing 2 shows the machine language code used for the STCP. It consists of
four main routines: the initialization and startup code for the VBLANK and
HBLANK routines, the shutdown code for the VBLANK and HBLANK routines, the
HBLANK and VBLANK routines themselves, and the BIOS calls used by the C
program.

 There are several equates defined at the start of the program. VBVEC is the
location of the vertical blank interrupt vector, a LONG (4-byte) location which
contains the address the system JMPs to on a vertical blank interrupt. HBVEC,
also a LONG value, tells the system where to JMP to on a horizontal blank
interrupt.

 KEYVEC is apparently the vector used when the ST's intelligent keyboard
generates a message to the system (for a keyboard, mouse or joystick event).
The COLOR0-COLOR9 equates are the addresses of the color registers. COLOR0 is
at $FF8240, COLOR1 at $FF8242, and so on.

 The first section of STCP, labeled GO, calls the SETUP routine in SUPERVISOR
MODE, a special configuration of the 68000 processor. In this mode, the program
may access any portion of memory, without restriction. Normally, a user's
program cannot access memory outside itself.

 SETUP changes the background color (COLOR0) to black ($F888). It then saves the
registers we're going to alter in the HOLD locations and the SAVE locations.

 After saving the important registers, STCP alters the registers we need. The
keyboard vector is altered to point to KEYVEC, the HBLANK vector (HBVEC) is
altered to point to our HBLANK routine, and the VBLANK vector (VBVEC) is
altered to point to VBLANK.

 Several other registers are also changed, including $FFFA09, which shuts off
the keyclick to avoid interfering with the interrupt timing. The functions of
$FFFA07 and $FFFA13 are not yet understood, but the masking of $FFFA07 before
and after changing HBVEC seems to indicate that its low-order bit is an HBLANK
enable bit.

 After setting up these registers, SETUP performs an RTS to return to the
calling program.

 The next routine, STOP, once again calls a routine in supervisor mode. This
time, it calls RESTORE. RESTORE is responsible for replacing the values we
changed earlier, when we installed our own VBLANK and HBLANK routines. This is
an important operation, as it restores the original system configuration,
preventing system crashes when new programs are loaded into memory later. After
restoring the registers, RESTORE returns to the calling program with an RTS.

 The next routine, MYKEY, is a short routine of one instruction added to
the@start of the keyboard interrupt handler. It simply changes the 68000 status
register to $2500, setting the priority of the keyboard handler to a lower
level, 5. This prevents keyboard or mouse events (key pressed or mouse moved)
from interrupting the HBLANK interrupt. Try removing this instruction, and
you'll see glitches on the color palette whenever you move the mouse or anytime
you press a key!

 Note that the KEYSAVE location follows this routine - when the keyboard
interrupt occurs, it will set the status register to $2500, then use the $4EF9
as a JMP instruction to the address in KEYSAVE, which was the old keyboard
interrupt routine. We simply forced the system to execute our instruction
before performing its normal duties. This same technique is used on the VBLANK
routine.

 The HBLANK routine is a simple routine, similar to a DLI routine on the 8-bit
Ataris. First, it saves the registers used (interrupts must do this), then gets
eight color values from the CTABLE [8 2-byte integers (WORDs) = 4 4-byte LONG
values, or 16 bytes], and places them into the color registers 1 through 8.

 By moving the data in 4-byte LONG chunks, the interrupt needs fewer
instructions (4 LONG moves vs. 8 WORD moves). Afterward, it increments the
CTABLE pointer, CIX, by 16 for the next interrupt. It then restores the saved
registers and clears bit 0 in register $FFFA0F (presumably, to clear the
interrupt status), finally exiting the interrupt with the RTE (Return from
Exception) instruction.

 The VBLANK routine, while also simple, contains a very important construct. The
first six lines are essential to setting up the HBLANK control. Remember how I
said we're executing an HBLANK interrupt every three scan lines? Well, this is
the code that determines that interval. The third and fourth lines tell the
system how often to generate the HBLANK interrupt, with the #3 value. Change
both of these to #4, and the interrupt will occur every four scan lines; change
them to #1, and the interrupt will occur every scan line. The surrounding code,
MOVE.B #0,$FFFA1B through MOVE.B #8,$FFFA1B, is necessary for proper
operation.

 The next six lines of code grab the first eight color values from the CTABLE
array and place them inthe color registers. This sets the color for the first
line of boxes on the screen. Afterward, CIX is set to 16, ready for the HBLANK
routine. Remember, this code is executed every time the electron beam of the
monitor is at the top of the screen.

 Finally, the VBLANK code adds 1 to color register 9, causing the title message
printed by the C program to cycle through various colors. The VBLANK code then
JMPs to the normal system VBLANK code, by using the $4FE9 (the JMP instruction)
followed by the saved VBLANK vector, VBSAVE.

 The last portion of STCP is the code which allows the C program to call the
various BIOS routines via the 68000 TRAP statement.

 After the program code is finished, the .DATA section defines the variables and
tables used by the program.

 Have fun!

 Although I'm not entirely sure of some of the functions of the registers used
by this program, I hope that it will encourage ST programmers to try
experimenting with the HBLANK feature of the 520ST. Like its counterpart on the
8-bit machines, this feature may be used to add color to many programs.

 If you're not an advanced programmer, you can still use the ST Color Palette to
find color register settings and impress your friends with the colorful 520ST.

                                                                   