                  Documentation de la librairie GEM

                                WinDom

                              version 1
                          13. Septembre 1997

                                  de

                          Dominique B‚r‚ziat
                          13 rue George Sand
                        91120 Palaiseau FRANCE

                     Dominique.Bereziat@inria.fr



Table des matiŠres
==================

 1  Introduction

 2  Conditions d'utilisation

 3  Version minimum

 4  La programmation sous Windom
    4.1  Cr‚ation d'une fenˆtre
    4.2  La routine de dessin de la fenˆtre
         4.2.1  Recommandations
         4.2.2  Fenˆtre proportionnelle
         4.2.3  Fenˆtre non-proportionnelle
    4.3  Destruction d'une fenˆtre
    4.4  La terminaison du programme
    4.5  Les palettes de couleurs
    4.6  Les sliders des fenˆtres
         4.6.1  Les messages WA_?? de l'AES
         4.6.2  Les sliders sous Windom
    4.7  L'ic“nification
         4.7.1  Description
         4.7.2  Les messages d'ic“nifications
         4.7.3  Les fonctions WindGet() et WindSet()
    4.8  Affichage des ic“nes
    4.9  Les formulaires en fenˆtre
         4.9.1  Les formulaires en fenetre
         4.9.2  Les formulaires modaux
    4.10  Mettre un menu en fenˆtre
         4.10.1  Incruster un menu
         4.10.2  G‚rer le menu
         4.10.3  M‚thode directe
         4.10.4  La routine de gestion du menu
    4.11  Les toolbars
    4.12  Les objets de types ‚tendus
         4.12.1  Objet userdef et type ‚tendus
         4.12.2  Compatibilit‚ avec MyDial
         4.12.3  Fonctionnement des ressources ‚tendus
         4.12.4  Utilisation
         4.12.5  Utilisation dans l'‚diteur de ressource
    4.13  Les raccourcis claviers
         4.13.1  Fonctionnement des raccourcis claviers
         4.13.2  Structure des raccourcis claviers
    4.14  Les frames
    4.15  Param‚trage de WinDom
         4.15.1  Les variables concern‚es
         4.15.2  Le fichier de configuration de WinDom
    4.16  Les structures et les variables globales
         4.16.1  Variables globales
         4.16.2  W_FORM
         4.16.3  W_GRAFPORT
         4.16.4  W_MENU
         4.16.5  W_ICON
         4.16.6  FRAME
         4.16.7  FRAMEINFO
         4.16.8  WINDOW
    4.17  Les messages AES ‚mit par WinDom
    4.18  Flags divers
         4.18.1  Flags du champs aes4 de la structure APPvar
         4.18.2  Flags du champs flag de la structure APPvar
         4.18.3  Flags du champs status de la structure WINDOW
         4.18.4  Flags du champs flags de la structure FRAMEINFO

 5  Librairie application
    5.1  ApplInit()
    5.2  ApplExit()
    5.3  ApplName()

 6  Librairie menu
    6.1  MenuBar()
    6.2  MenuTnormal()
    6.3  MenuIcheck()
    6.4  MenuText()
    6.5  MenuDisable()
    6.6  MenuEnable()
    6.7  MenuPopUp()
    6.8  WindSet() avec le mode WF_MENU

 7  Librairie fenˆtre
    7.1  WindCreate()
    7.2  WindOpen()
    7.3  WindClose()
    7.4  WindDelete()
    7.5  WindSet()
    7.6  WindGet()
    7.7  WindSlider()
    7.8  WindCalc()
    7.9  WindHandle()
    7.10  add_windowlist()
    7.11  remove_windowlist()
    7.12  WindClear()
    7.13  AddWindows()
    7.14  RemoveWindows()

 8  Librairie frame
    8.1  FrameCreate()
    8.2  FrameAttach()
    8.3  FrameRemove()
    8.4  FrameSet()
    8.5  FrameFind()
    8.6  FrameSearch()
    8.7  FrameCalc()

 9  Librairie ‚venement
    9.1  EvntWindom()
    9.2  snd_rdw()
    9.3  snd_msg()
    9.4  snd_arrw()
    9.5  give_iconifyxywh()

10  Librairie ressource
   10.1  RsrcLoad()
   10.2  RsrcFree()
   10.3  RsrcXtype()
   10.4  RsrcFixCicon()
   10.5  RsrcFreeCicon()

11  Librairie objet
   11.1  ObjcDraw()
   11.2  ObjcChange()
   11.3  ObjcWindDraw()
   11.4  ObjcWindChange()
   11.5  ObjcDup()
   11.6  ObjcFree()
   11.7  ObjcString()

12  Librairie formulaire
   12.1  FormCreate()
   12.2  FormBegin()
   12.3  FormDo()
   12.4  FormEnd()
   12.5  FormWindBegin()
   12.6  FormWindDo()
   12.7  FormWindEnd()
   12.8  FormSave()
   12.9  FormRestore()
   12.10  FormAttach()

13  Librairie souris
   13.1  MouseObjc()
   13.2  MouseSprite()
   13.3  MouseWork()

14  Librairie s‚lecteur de fichiers
   14.1  FselInput()
   14.2  Appel de Selectric
        14.2.1  slct_extpath()
        14.2.2  slct_morenames()
        14.2.3  slct_first()
        14.2.4  slct_next()
        14.2.5  slct_release()
        14.2.6  Exemple d'utilisation des appels de Selectric

15  Librairie cookies
   15.1  get_cookie()
   15.2  get_cookiejar()
   15.3  new_cookie()
   15.4  set_cookie()

16  Librairie Bubble
   16.1  BubbleCall()
   16.2  BubbleAttach()
   16.3  BubbleEvnt()
   16.4  BubbleFree()
   16.5  BubbleFind()

17  Librairie utils
   17.1  CallStGuide()
   17.2  GrectCenter()
   17.3  rect_set()
   17.4  rc_intersect()
   17.5  w_get_bkgr()
   17.6  w_put_bkgr()

Annexe
======

 A  Syntaxe du fichier windom.cnf

 B  Nouveaut‚s

 C  Comparaison AES/Windom

 D  Diff‚rentes versions de l'AES

 E  Noms et marques cit‚es

 F  R‚f‚rences

 G  Le mot de la fin



Chapitre 1

Introduction
************

WinDom est une librairie pour la programmation GEM. Elle permet de
g‚rer tr‚s facilement les fenˆtres. Ecrite avec Pure C, elle ne
fonctionne qu'avec Pure C, toutefois une version Gcc est en
pr‚prartion. Par contre, la librairie fonctionne sur tout ordinateurs
Atari STF, STE, Mega ST, Mega STE, TT, Falcon030, compatibles TOS, et
dans toutes les r‚solutions.

La librairie de WinDom se compose de deux type de fonctions: les
fonctions GEM r‚‚crite et d'autres fonctions diverses pour faciliter
la programmation.

Les fonction GEM r‚‚crite ne le sont pas vraiment, en fait ce sont
des fonctions dont le nom ressemble … celui des fonctions de l'AES
mais qui les remplacent. Par exemple, sous WinDom, on n'utilise pas
appl_init() mais ApplInit(). Ainsi la programmation ressemble
beaucoup … celui sous GEM. Toutes ces nouvelles fonctions font la
mˆme chose que leur homologue AES avec en plus des petits trucs qui
permette une gestion tr‚s facile de l'AES. L'interˆt est de gagner en
souplesse et de ne pas ˆtre enferm‚ par grosses fonctions obscures
qui limite n“tre champs d'action.

Le principe des gestion de fenˆtres est simple. Chaque fenˆtre
possŠde un descipteur qui est une structure contenant entre autre des
adresses de routines charg‚ de chaque type d'‚venement. Ces routines
sont d‚clench‚ automatiquement par la fonction EvntWindom() qui
remplace la fonction evnt_multi(). Ainsi le gros du travail, pour les
fenˆtres est fait. La plupart des ‚venements ont une gestion standart
et la fonction WindCreate() initialise par defaut des routines de
traitement standart des ‚venements. Si l'on veut changer un
comportement de la fenˆtre, il suffit de r‚‚crire une routine.

WinDom vous permet d'accŠder a pas mal de nouveaux ‚l‚ments de l'AES
4 mˆme sous un TOS 1. WinDom intŠgre en sus de nouveaux ‚l‚ments
comme les menus en fenˆtre et les raccour‡is claviers des menus.
WinDom possŠde aussi une librairie d'objets USERDEF compatible avec
ceux de MyDial.

La grosse nouveaut‚ de cette derniŠre version est la gestion simple
et transparente de frame dans des fenˆtres.

La doc se compose d'un index des fonctions de WinDom regroup‚ par
librairie (pour l'analogie … l'AES) et d'un tutorial expliquant
comment programmer sous WinDom avec pas mal d'exemples. Le r‚pertoire
exemples de la distribution contient quelques exemples de
programmation.



Chapitre 2

Conditions d'utilisation
************************

    WinDom est un produit freeware. C'est … dire, il est libre
    d'utilisation mais l'auteur conserve ses droits. Il est pas
    permit de modifier l'archive WINDOM.ZIP et son contenu sans
    l'accord de son auteur. D'autre part, l'auteur degage toutes
    responsabilit‚es aux vis de forme ou aux problemes caus‚ par le
    pr‚sent produit. Vous avez ‚galement l'obligation de me citer si
    vous utilisez WinDom dans votre developpement (en cas de
    diffusion).

    Cette librarie a ‚t‚ utilis‚ pour d‚velopper:

       ù Awele

       ù Notes

       ù Dom's Viewer

       ù plein d'autre j'espŠre :-)

    WinDom est ‚crit par Dominique B‚r‚ziat. Pour toutes remarques,
    suggestions ou critiques:

    Dominique B‚r‚ziat
    13 rue Georges Sand
    91120 PALAISEAU FRANCE
    E-mail: Dominique.Bereziat@inria.fr


    Les mises … jour peuvent ˆtre trouv‚ sur le site internet:

    http://www-air.inria.fr/People/bereziat/windom.html

    (au passage je remercie l'INRIA ainsi que le projet AIR de
    pouvoir h‚berger cette page Web).

    Merci de votre attention,
    Dominique B‚r‚ziat 1997



Chapitre 3

Version minimum
***************

La librarie existe en version minimum pour les petites applications.
Dans cette version, il n'y a pas de gestion des toolbars ni des menus
en fenˆtre. De plus les raccourcis claviers ne sont pas g‚r‚s.

    WINDOM.LIB La librairie complŠte
    WINDMINI.LIB La librairie minimale




Chapitre 4

La programmation sous Windom
****************************


4.1  Cr‚ation d'une fenˆtre
===========================

Prenons de suite un exemple:

     #include <windom.h>

     void main( void)
     {
          /* Descripteur de fenˆtre */
          WINDOW *win;

          /* Initialisation de Windom */
          ApplInit();

          /* On cr‚e une fenˆtre */
          win = WindCreate( NAME|MOVER|CLOSER,
                                app.x, app.y, app.w, app.h);
          /* On affiche la fenˆtre */
          WindOpen( win, app.x, app.y, app.x+app_w/2, app.y+app.h/2);

          /* Boucle sur les ‚v‚nements */
          while( wglb.first)
               EvntWindom( MU_MESAGE);

          /* Fermeture et destruction de la fenˆtre*/
          WindClose( win);
          WindDelete( win);

          /* On quitte l'environnement Windom */
          ApplExit();
     }

Comme nous le disions dans l'introduction, la programmation sous
WinDom ressemble beaucoup … celle sous GEM. La seule diff‚rence
majeure est que la gestion des ‚venements de l'AES n'apparait pas.
Elle est faite implicitement par EvntWindom() qui d‚clenche les
routines de gestions des ‚venements de la fenˆtre.

WindCreate() attribue par d‚faut des routines standarts. La premiŠre
chose que voudra faire un programmeur sera surement de modifie le
contenu de la fenˆtre. C'est la routine win->redraw qui est appel‚e
pour dessiner le contenu de la fenˆtre.

Un mot sur la boucle. La variable wglb est une variable systŠme qui
donne des informations sur les fenˆtres. En particulier, wglb.first
poŒnte sur l'adresse de la premiŠre fenˆtre. Si celle-ci est nulle,
c'est qu'il n'y a pas de fenˆtre. Donc, la fermeture de la fenˆtre
provoque la terminaison du programme

Voir aussi:
La routine de dessin de la fenˆtre
Destruction d'une fenˆtre
Les variables globales (voir "Variables globales")


4.2  La routine de dessin de la fenˆtre
=======================================


4.2.1  Recommandations
----------------------

Vous allons donner i‡i quelques recommandations pour coder les
routines de dessin de la fenˆtre.

Tout d'abord, il ne faut jamais clipper dans la routine car c'est
windom qui s'en charge. D'autre part, pour les appels de la VDI, il
faut utiliser l'handle de la station de travail virtuelle ouverte
pour la fenˆtre par WindCreate(): c'est la variable win->graf.handle.

Une autre chose tr‚s importante concerne les sliders des fenˆtres. En
effet, le contenu de la fenˆtre depend … priori des positions des
sliders (voir "Les sliders des fenˆtres") mais aussi de la taille de
la fenˆtre (ca peut ˆtre la position relative … la fenˆtre de ce que
l'on affiche ou bien encore un effet de zoom...). Pour cela il faut
utiliser les variables du descripteur de la fenˆtre dedi‚ … la
gestion des sliders. Il s'agit des variables win->xpos, win->ypos,
win->xpos_max et win->ypos_max.

Vous allons voir cela … travers diff‚rents exemples concrets. Nous
allons aussi mettre en ‚vidence l'utilisation du champ win->data et
de la routine de fermeture de la fenˆtre.


4.2.2  Fenˆtre proportionnelle
------------------------------

Dans cet exemple, on veut ouvrir une fenˆtre qui contienne un cercle.
Les sliders n'interviennent pas pour le momment. Le champ data va
pointer sur une structure contenant des informations sur la couleur
du cercle, son motif, etc... Voi‡i cette structure:

     struct cercle{
          int couleur;
          int motif;
     };

Voi‡i la fonction qui d‚truit la fenˆtre:

     void Destroy( WINDOW *win)
     {
          free( win -> data);      /* On libŠre la m‚moire occup‚ */
          WindClose( win);         /* On ferme la fenˆtre */
          WindDelete( win):        /* et on d‚truit son descripteur*/
     }

Et maintenant voi‡i la routine qui dessine le cercle:

     void Draw( WINDOW *win)
     {
          int x, y, w, h;

          WindGet( win, WF_WORKXYWH, &x, &y, &w, &h);
          wind_clear( win);
          vsf_color( win->graf.handle,
                       (struct cercle *)win->data->couleur);
          vsf_interior( win->graf.handle,
                           (struct cercle *)win->data->motif);
          v_circle( win->graf.handle, x+w/2-1, y+h/2-1,
                    min( w, h)/3);
     }

La fonction main() s'‚crit:

     int main()
     {
          WINDOW *win;
          struct cercle *C;

          ApplInit();

          C = (struct cercle *) malloc( (!B)sizeof(!b)( struct cercle));

          win = WindCreate( WAT_ALL, app.x, app.y, app.w, app.h);

          win->data = (void*)C;
          win->redraw = Draw;
          win->destroy = Destroy;

          WindOpen( win, app.x, app.y, app.w/2, app.h/2);
          WindSet( win, WF_NAME, "titre");
          WindSet( win, WF_INFO, "Infos");

          while( wgbl.first)
               evnt_windows( MU_MESAG);

          ApplExit();
          return 0;
     }

a finir ...


4.2.3  Fenˆtre non-proportionnelle
----------------------------------

Dans ce cas les sliders interviennent. Il y a deux ‚tapes:

   ù initialiser les variables sliders,

   ù ‚crire la routine de dessin.

Nous allons prendre un exemple simple et utile : afficher un texte
dans une fenˆtre.

Les donn‚es

Nous devons structurer nos donn‚es et les faire pointer par le champ
data du descripteur de fenˆtre pour que notre routine de dessin
puisse retrouver ses petits facilement.

typedef struct {
     char *buffer; /* l'adresse du texte */
     char **line;  /* les adresses de chaque d‚but de ligne */
     int maxline;  /* le nombre de ligne */
     int wchar,hchar; /* taille d'un caractŠre */
     } TEXT;

On suppose bien-sur que l'on sait charger correctement un texte en
m‚moire que chaque ligne se termine par un octet null.

Les variables xpos et ypos du descripteur de fenˆtre sont cens‚s
representer la position des donn‚es dans la fenˆtre. Logiquement dans
notre cas, xpos repr‚sente la premiŠre colonne affich‚ et ypos la
premiŠre ligne affich‚. Sachant que les variables w_u et h_u
representent successivement la largeur et la hauteur a d‚caler quand
on scrolle la fenˆtre, elles doivent correspondrent … la taille d'une
cellule de caractŠre (voir la gestion des fontes Vdi)! N'oubliez pas
non plus que ces deux variables permet aussi de calculer la taille
des sliders (proportionnelle … ce que l'on voit dans une fenˆtre).

Ecrivons la routine qui ouvre une fenˆtre texte:

WINDOW *OpenText( TEXT *text)
{
     WINDOW *win;
     int attrib[10];

     win = WindCreate( WAT_ALL, app.x, app.y, app.w, app.h);
     WindOpen( win, app.x, app.y, app.w, app.h);

     win -> data = text;
     win -> xpos_max = 255;           /* Largeur maximale d'une ligne */
     win -> ypos_max = text->maxline; /* Nombre de ligne du texte */
     vqt_attributes( app.handle, attrib);
     win -> w_u = attrib[8];  /* Hauteur de la cellule de caractŠre */
     win -> h_u = attrib[9];  /* Largeur de la cellule */
     text-> wchar = attrib[6]; /* Hauteur d'un caractŠre */
     text-> hchar = attrib[7]; /* Largeur d'un caractŠre */
     WindSlider( win, HSLIDER|VSLIDER); /* Mettre … jour les sliders */
     return win;
}

Affichons maintenant notre texte dans la fenˆtre: La trame de la
routine est:

   ù afficher le fond (carr‚ blanc),

   ù afficher les lignes du texte visible dans la fenˆtre, c'est-…-
     dire les lignes … partir de ypos jusqu'… ce que l'on sorte de la
     zone de clippage,

   ù afficher chque ligne qu'… partir de la premiŠre colonne visible
     (donn‚es par xpos).

void draw_text( WINDOW *win)
{
     int x,y,w,h;
     int i;
     int pxy[4];
     TEXT *ptext = (TEXT *)win->data;

     WindGet( win, WF_WORKXYWH, &x, &y, &w, &h);

     /* On affiche le fond de la fenˆtre */
     vswr_mode( win->graf.handle, MD_REPLACE);
     pxy[0]=x; pxy[1]=y; pxy[2]=x+w-1;pxy[3]=y+h-1;
     v_bar( win->graf.handle, pxy);

     /* Le texte maintenant */
     vswr_mode( win->graf.handle, MD_TRANS);
     w = global . hcell - global . hcar;  /* offset verticale du texte
                                           * c'est pour que ‡a soit joli */
     for( i=win->ypos; i<win->ypos_max ; i++) /* ptext->maxline=win->ypos_max
     {                                         * win->ypos_max est la valeur
                                               * maximale admissible de
                                               * win->ypos */
          y += global.hcell;
          if( y < clip.g_y)
               continue;  /* Ici on sort de la zone de clippage
                           * donc pour optimiser le redraw on s'arrˆte ici
                           * (la zone de clippage peut-ˆtre plus petite que la
                           *  la fenˆtre).*/

          /* la ligne est-elle dans la fenetre? */
          if( strlen( ptext->line[ i]) > win->xpos)
               v_gtext(win->graf.handle, x, y - w, ptext->line[ i] + win->xpos);

           /* sort-on de la zone clipp‚? */
          if (y > min(pxy[3], clip.g_y + clip.g_h-1))
               break;
     }
}

Ce cas de gestion de slider les le plus courant. Toutefois, on peut
compliquer les chose si l'on desire faire une fee...;


4.3  Destruction d'une fenˆtre
==============================

La fermeture de la fenˆtre:
Une fenˆtre que re‡oit un message de fermeture (WM_CLOSED) r‚agit en
executant sa routine de fermeture associ‚ dans son descripteur de
fenˆtre (win->closed). La routine standart attribu‚ par WindCreate()
… win->closed r‚agit en emettant … son tour un message WM_DESTROYED
pour d‚truire la fenˆtre. Par convention, la routine win->destroyed
(associ‚ au message WM_DESTROYED) doit d‚truire la fenˆtre ainsi que
les donn‚es qui s'y rattachent. Si vous ne voulez pas que vos donn‚es
soient ‚limin‚es, il suffit de r‚‚crire une nouvelle routine win-
>closed qui ne fermera que la fenˆtre:

void new_closed( WINDOW *win)
{
    WindClose( WINDOW *win);        /* le descripteur est toujours la */
}

et … l'endroit ou vous cr‚er votre fenˆtre:

    {
        WINDOW *win;

        win = WindCreate( ...);
        win->closed = new_closed;
        ...
    }

Remarquez que dans ce cas pr‚cis, on pourrait juste ‚crire:

    win->closed = WindClose;

car WindClose() a le bon prototype!

La destruction de la fenˆtre:
Ce destructeur de fenˆtre devra faire 3 choses:

  1. fermer la fenˆtre,

  2. d‚truire la fenˆtre,

  3. liberer les donn‚es associ‚es … la fenˆtre (s'il y en a).

Par exemple, vous voulez coder un ‚diteur de texte! le champs de
donn‚e de votre fenˆtre (win->data) poŒnte sur votre structure
d‚crivant le texte de la fenˆtre. Le descruteur de la fenˆtre
pourrait s'‚crire:

     void KillTextWindow( WINDOW *win)
     {
          struct text *ptext = (struct text *)win->data;

          if( ptext->not_saved)         /* Sauver le texte sur disque */
               if( AskConfirmSave( ptext)    /* Demander ‚ventuellement
                    SaveText( ptext);         * la confirmation, puis sauver */
          FreeText( ptext);             /* liberer le texte de la m‚moire */
          WindClose( win);    /* fermer, puis d‚truire la fenˆtre */
          WindDelete( win);
     }

Cette maniŠre de programmer permet de gagner du temps et de
rationnaliser les donn‚es. Une donn‚e = une fenˆtre.


4.4  La terminaison du programme
================================

Il n'y a pas une fa‡on unique de terminer un programme WinDom.
Toutefois voici quelques conseils pour terminer proprement une
application. Je vous conseille de proc‚der en trois ‚tapes:

La boucle de gestion des ‚venements
Comment sortir de la boucle centrale? Dans la cas standart, nous
avons:

     do {
          res = EvntWindom( MU_MESAG|MU_KEYBD ...);
          if( res && MU_MESAG) {
               ...
          }
          if( res && MU_KEYBD) {
               ...
          }
          ...
     } while( ?? );

Que mettre dans le while()? Si vous ne gerez que des fenˆtres et pas
de menu, un while( wglb.first) peut suffire. Cela siginifie que l'on
sort de la boucle lorsqu'il n'y pas plus de descripteur de fenˆtres
(donc plus de fenˆtre!). Si vous prevoyez plusieurs fa‡ons de
quitter, une variable auxilliaire peut ˆtre judicieuse: while(
!quit), on quitte lorsque quit=1. La plupart du temps c'est une bonne
solution. Je vous conseille ‚galement de traiter le message AP_TERM.
Ce message, lorsqu'une application la re‡oit, signifie que cette
derniŠre doit se terminer (cela arrive dans les sytŠmes multitƒche
avant un shutdown ou un changement de r‚solution). Voi‡i une trame
plus g‚n‚rale:

     int res, quit = 0;  /* quit peut-ˆtre d‚clar‚e globale
                          * pour ˆtre accessible par des fonctions
                          * de gestion de menu en fenˆtre par
                          * exemple */
     ...
     do {
          res = EvntWindom( MU_MESAG|MU_KEYBD ...);
          if( res && MU_MESAG) {
               switch( evnt.buff[0]) {
               case AP_TERM:  /* Quitter si AP_TERM */
                    quit = 1;
                    break;
               case MN_SELECTED: /* Menu sollicit‚ */
               switch( evnt.buff[4]) {
                    case MN_QUIT:
                         quit = 1; /* Quitter par le menu */
                         break;
                    case ...
                    } /* fin du switch du menu */
               case ...
               } /* fin du switch des messages */
               if( wgbl.first == NULL)  /* Quitter si plus de fenˆtre */
                    quit = 1;
          }
          ...
     } while( !quit);

Dans ce cas, il y 3 fa‡ons de quitter la boucle principale: par le
menu, lorsqu'on re‡oit AP_TERM ou lorsque toutes les fenˆtres sont
ferm‚es. A vous de voir ce qui correspond le mieux … votre
application.

Fermeture des fenˆtres
Lorsqu'on sort de la boucle des ‚vemenents, il faut a priori fermer
toutes les fenˆtres (s'il y en a encore!). Je vous conseille
fortement la m‚thode suivante:

     while( wglb.first) {
          snd_msg( wglb.first, WM_CLOSED, 0, 0, 0, 0);
          EvntWindom( MU_MESAG);
     }

Cette m‚thode a plusieurs avantages:

   ù elle permet de d‚truire correctement les fenˆtres sans passer
     par des WindClose() et WindDelete(). Pour peu que vous ayez cr‚‚
     vos fonctions de destruction de fenˆtre (win->destroyed) sur vos
     fenˆtres sp‚cialis‚es, la fonction snd_msg( , WM_CLOSED, )
     d‚truira correcterment vos fenˆtres.

   ù l'appel de EvntWindom() permet d'une part d'interpret‚ le
     message WM_CLOSED ‚mit par la fonction snd_msg(), mais d'autre
     part, de mettre … jour la liste des rectangle de l'AES. En
     effet, lorsqu'on ferme violement une dizaine de fenˆtre, l'AES
     se met a planter. Cette m‚thode permet d'‚viter ce bug.

Lib‚ration des ressources
Enfin, il ne faut pas oublier de lib‚rer toutes les ressources que
vous avez allou‚es. Les ressources attribu‚es aux fenˆtres ont d‚ja
‚t‚ lib‚r‚ dans la phase pr‚cedente.

     RsrcXtype( 0, NULL, 0);  /* Si vous avez install‚ des types ‚tendues */
     RsrcXtype( 0, tr_index, NUM_TREE); /* Pareil sur les ressources
                                         * int‚gr‚s
                                         */
     RsrcFree();              /* si vous avez chargez un ressource */
     ApplExit();
     /* plus les autres lib‚rations de m‚moires etc ...*/


4.5  Les palettes de couleurs
=============================

Fonctionnement dans WinDom

WinDom attribut … chaque fenˆtre une palette de couleur. Lorsqu'une
fenˆtre est au premier plan, c'est sa palette qui est appliqu‚ …
l'‚cran. La palette est stock‚ dans le champ win->graf.palette. Elle
contient autant de couleur qu'il en existe dans la r‚solution en
cours. Cela peut donc ˆtre 2, 4, 16, 256. En True Color, les palettes
de couleurs n'existent plus. WindCreate() donne une valeur NULL … ce
champ. C'est … dire que la fenˆtre n'a pas de palette. Dans ce cas,
c'est la palette du bureau (app.palette) qui est utilis‚.

Attribution d'une palette

Si vous voulez attribuer une palette … une fenˆtre, il faut r‚server
la m‚moire n‚cessaire et initialiser la palette. La gestion est elle
r‚alis‚ par EvntWindom(). Signalons deux fonctions dans la librairie:

    void w_getpal( W_COLOR *palette)
    void w_setpal( W_COLOR *palette)

La premiŠre recopie la palette courante (celle de la VDI) dans la
variable palette. La seconde applique la palette contenue dans
palette … la VDI.

Pour cr‚er une palette dans une fenˆtre, proc‚dez comme suit:

    void create_palette( WINDOW *win)
    {
        W_COLOR *palette;

        /* 1) r‚server la m‚moire n‚ccessaire */
        palette = (W_COLOR*)malloc(app.color*sizeof(W_COLOR));
        /* 2) initialiser la palette, par exemple:*/
        w_getpal( palette);  /* prendre la palette courante */
        /* 3) attribuer la palette … la fenˆtre */
        win->graf.palette = palette;
    }


De pas oublier de lib‚rer la m‚moire … la fin:

    /* Routine de destruction de la fenˆtre */
    void destroy( WINDOW *win)
    {
        WindClose( win);
        free( win->graf.palette);
        /* autre free ... */
        WindDelete( win);
    }

Bien entendu, WinDom utilise la palette VDI: Les trois composantes
(rouge vert bleu) d'une couleur prennent une valeur entre 0 et 1000.

Le flag NOPALETTE

Le flag NOPALETTE dans la variable app.flag d‚sactive la gestion de
la palette par EvntWindom(). Cette option est pratique pour les
accessoires. En effet, si vous lancez un accessoire (cod‚ avec
WinDom), celui ci installera la palette par d‚faut de la VDI prise au
momment de l'appel de ApplInit(). Si vous changez la palette du
bureau, avec Xcontrol par exemple, et que Xcontrol est lanc‚ aprŠs
notre accessoire, nos fenˆtres r‚tabliront l'ancienne palette (celle
d'avant Xcontrol) ce qui peut ˆtre trŠs d‚sagr‚able. Avec cette
option active, il n'y a plus de problŠme.

Si toutefois l'accessoire utilise les palettes, il suffit de r‚tablir
la bonne palette par d‚faut (celui du bureau) dans la librairie. On
pourra r‚aliser l'appel:

    vs_getpal( app.palette);  /* on recopie la palette de la VDI dans la
                               * la palette par d‚faut de WinDom
                               */

au bon momment! c'est-…-dire lors de la premiŠre ouverture d'une
fenˆtre (pour ˆtre sur d'avoir fini la phase de boot des
accessoires).


4.6  Les sliders des fenˆtres
=============================


4.6.1  Les messages WA_?? de l'AES
----------------------------------

balblabla


4.6.2  Les sliders sous Windom
------------------------------

Windom permet de g‚rer facilement la position et la taille des
sliders. Il suffit d'initialiser correctement les variables utilis‚s
par Windom pour g‚rer ces sliders, le reste ‚tant automatis‚ i.e que
les fonctions de gestion standart des ‚venements relatifs aux sliders
mettent … jours ces variables, la taille et la position des sliders.
A priori, il suffit de faire cette initialisation une bonne fois pour
toute lorsqu'on cr‚e la fenˆtre. Toutefois, si la taille des donn‚es
se modifie au cours du temps, il faut les r‚actualiser pour garder un
comportement coh‚rent des sliders.

Dans la structure WINDOW, on trouve des variables d‚dier … cette
utilisation. Il s'agit des variables xpos, xpos_max, ypos, ypos_max,
h_u et w_u. Ces variables sont g‚n‚ralement utiliser par la fonction
de redraw de la fenˆtre.

 xpos indique la position horizontale des donn‚es par rapport … la
     fenetre,

 xpos_max est la valeur maximale possible pour xpos, plus pr‚cisement
     on a: 0 <= xpos < xpos_max,

 ypos et ypos_max jouent les mˆmes r“les que xpos et xpos_max mais
     concernent la position verticale des donn‚es,

 h_u repr‚sente (en pixel) l'unit‚ de decalage vertical pour un
     scroll,

 w_u repr‚sente elle l'unit‚ de d‚calage horizontal.

Prenons un exemple, celui d'un texte affich‚ dans une fenetre. Tr‚s
naturellement, ypos identique la premiŠre ligne du texte affich‚ dans
la fenˆtre et xpos repr‚sente la premiŠre colonne. La variable
ypos_max repr‚sente donc le nombre de ligne du texte et la variable
xpos_max represente le nombre de colonne. La variable h_u repr‚sente
la hauteur d'une cellule de caractŠre et la variable w_h repr‚sente
la largeur d'une cellule de caractŠre. A priori, lorsqu'on cr‚e la
fenˆtre, on affiche d‚but du texte, donc xpos et ypos doivent ˆtre
nuls.

Notez aussi que h_u et w_u fixe ‚galement le scroll de la fenˆtre. Un
click dans la flŠche bas du slider vertical provoque un d‚calage de
h_u pixel vers le haut.

Comment fixer les tailles et postions des sliders? Normalement ce
sont les fonctions standarts qui s'en chargent par le biais de la
fonction WindSlider(). Cette fonction consiste en un appel
sophistiqu‚ de wind_set() en utilisant les variables d‚crite
pr‚c‚demment.

Toutefois, lors de la cr‚ation de la fenˆtre ou de la modification
des variables des sliders (suite par exemple, … une modification de
la taille des don‚es), il faut appeler soi-mˆme WindSlider() pour
mettre … jour les sliders.


4.7  L'ic“nification
====================


4.7.1  Description
------------------

Windom gŠre l'ic“nification des fenˆtres de la mˆme fa‡on que l'AES
c'est … dire par l'interm‚diaire des messages WF_ICONIFY,
WF_UNICONIFY, WM_ALLICONIFY et par l'interm‚diaire des fonctions
WindSet() et WindGet().

D'autre part l'ic“nification fonctionne quelquesoit la version de
l'AES de votre machine. Normalement seul MultiTos intŠgre la gestion
de l'ic“nification (AES 4.1) cependant lorsque MultiTos (ou un
‚quivalent comme Geneva 4) n'est pas pr‚sent, Windom ‚mule un
m‚canisme d'ic“nification. Dans ce cas, la position des ic“nes se
fait dans le style de MultiTos ( en bas de l'‚cran de gauche …
droite). Cependant la position des ic“nes est locale … notre
application. Pour rem‚dier … cela, Windom utilise le cookie ICFS
(Iconify Server par Dirk Haun) pour placer ses ic“nes. Si ICFS n'est
pas present, Windom utilise sa propre liste d'ic“ne, mais
l'iconification n'aura pas d'effet global. En conclusion, WinDom +
ICFS + AES 4.0 offre une alternative pour l'iconification ‚quivalente
… celle de l'AES 4.1 .

De plus, Windom offre une alternative pour ic“nifier ses fenˆtres
lorsque l'attribut smaller n'est pas pr‚sent: un shift-clique sur le
closer de la fenˆtre d‚clenchera un message d'ic“nification. C'est la
fonction de fermeture standart qui gŠre cela. De mˆme qu'un shift-
alt-clique sur le closer envoit un message d'ic“nification global
(WM_ALLICONIFY). Ainsi si vous ‚crivez v“tre routine de fermeture
pr‚voyer ce cas et utilisez la fonction give_iconifyxywh().


4.7.2  Les messages d'ic“nifications
------------------------------------

Sur reception d'un message WM_ICONIFY, WM_UNICONIFY ou WM_ALLICONIFY,
Windom ‚xecute respectivement et si elles existent les routines win-
>iconified, win->uniconified, win->alliconified de la fenˆtre
concern‚e.

Rappelons la signification de ces messages:

    evnt.buff[ 0] = WM_ICONIFY, WM_UNICONIFY, WM_ALLICONIFY
    evnt.buff[ 1] = ap_id de l'application emettrice
    evnt.buff[ 2] = 0
    evnt.buff[ 3] = handle de la fenˆtre concern‚e
    evnt.buff[ 4] = coordonn‚e x
    evnt.buff[ 5] = coordonn‚e y
    evnt.buff[ 6] = coordonn‚e w
    evnt.buff[ 7] = coordonn‚e h


   ù WF_ICONIFY:

        - signification: une fenˆtre doit ˆtre ic“nifi‚e … la
          position et taille x,y,w,h.

        - origine probable: Diverse selon le systŠme utilis‚. Peut
          ˆtre le smaller de la fenˆtre ou un shifht+click sur le
          closer. Le message peut ˆtre ‚galement envoy‚ manuellement
          par le programme.

        - action: La routine standart attribue par WindCreate() fait
          l'appel: WindSet( win, WF_ICONIFY, x, y, w, h);

   ù WM_UNICONIFY:

        - signification: une fenˆtre ic“nifi‚e doit ˆtre ouverte … la
          position et taille x, y, w, h.

        - origine probable: Double click sur une fenˆtre ic“nifi‚e.

        - action: La routine standart attribue par WindCreate() fait
          l'appel: WindSet( win, WF_UNICONIFY, x, y, w, h);

   ù WM_ALLICONIFY:

        - signification: toutes les fenˆtres de l'application doivent
          ˆtre ic“nifi‚e en une seule … la position et taille x, y,
          w, h.

        - originie probable: sous AES 4.1: control + click smaller

        - action: Il n'y a pas de routine standart. Mais il faut
          fermer toutes les fenˆtres, et cr‚er une unique fenˆtre
          iconifi‚. Les routines std_icn et std_unicn doit prendre en
          compte cela.


4.7.3  Les fonctions WindGet() et WindSet()
-------------------------------------------

A priopri, Windom gŠre completement les m‚canismes d'ic“nification
par le biais des fonctions standarts attribuer par default aux
fenˆtres. Toutefois, si on veut modifier le comportement des fenˆtres
face a ces messages, il conviendra de r‚eecrire ses propres routines.
Les routines concern‚es sont comme nous l'avons d‚j… vu win-
>iconified, win->uniconified et win->alliconified. Pour cela, on aura
besoin tr‚s certainement de faire appels … WindSet() et WindGet().

WindSet( win, WF_ICONIFY, x, y, w, h);

ic“nifie la fenˆtre … la position x, y, w, h. Normalement, ces
coordonn‚es sont fournit par le message WF_ICONIFY. Toutefois si on
desire d‚clencher manuellement une ic“nification, le GEM ne pr‚voit
pas de fournir des coordonn‚es autrement que par le message
WF_ICONIFY. Pour cela utiliser la fonction:

void give_iconifyxywh( int *x, int *y, int *w, int *h);

Si on utilise l'AES 4.1, cette fonction retournera toujours les mˆmes
valeurs car on a aucun moyen de connaitre les positions des ic“nes de
l'AES. WinDom utilise cette fonction pour cr‚er ses propres messages
WM_ICONIFY.

WindSet( win, WF_UNICONIFY, x, y, w, h);

rouvre une fenˆtre ic“nifi‚e … la position et taille x, y, w, h. Ces
coordonn‚es sont fournit par le message WM_UNICONFY, ou bien par
WindGet( win, WF_UNICONIFY, &x, &y, &w, &h).

WindSet( win, WF_UNICONIFYXYWH, x, y, w, h);

sp‚cifie les coordonn‚es originelle d'une fenˆtre ic“nifi‚e. Cela
permet d'indiquer au systŠme comment rouvrir une fenˆtre ic“nifi‚e
(utile dans le cas d'une fenˆtre cr‚e ic“nifi‚e). Sous MultiTos, le
comportement de cette fonction est bizarre, aussi Windom l'‚mule
completement.

L'AES 4.1 n'impl‚mente pas les modes WF_ICONIFY, WF_UNICONFY pour
wind_get() bien que l'Atari Comppendium d‚crive leur action. Aussi
ces modes sont ‚mul‚ dans Windom pour une compatibilit‚ future
 (Cette remarque est aussi valable pour WF_BOTTOM ).

WindGet( win, WF_ICONIFY, &icon, &w, &h);

donne des informations sur une fenˆtre. icon vaut 0 si la fenˆtre
n'est pas ic“nifi‚e, et une valeur differente de 0 sinon. w et h
donne la taille des ic“nes. Cette fonction utilise le bit WS_ICONIFY
de la variable win->status et leur de app.wicon et app.hicon. La
taille standart des fenˆtres ic“nifi‚es est de 72x72. Toutefois dans
le cas o— WinDom ‚mule l'ic“nification, la taille peut ˆtre modifi‚
(voir Param‚trage de WinDom). Si ICFS est pr‚sent, c'est le cookie
ICFS qui gŠre cette taille (le CPX associ‚ permet de modifi‚ cela).

WindGet( win, WF_UNICONIFY, &x, &y, &w, &h):

donne la position et la taille de la fenˆtre originelle pour une
fenˆtre ic“nifi‚e. Cette fonction utilise les valeurs win->icon.x,
win->icon.y, win->icon.w, win->icon.h du descripteur de la fenˆtre.


4.8  Affichage des ic“nes
=========================

Une fois la fenˆtre ic“nifi‚e, on veut pouvoir sans doute changer le
contenu de la fenˆtre. Normalement, une fenˆtre ic“nifi‚e doit
contenir une ic“ne mais on peut faire ce que l'on veut (une ic“ne
anim‚e, etc ...).

Une fenˆtre qui est ic“nifi‚e est toujours la mˆme (a part ses
attributs et sa taille). Donc Windom continue d'y afficher la mˆme
chose. Pour modifier cela il y a deux m‚thodes.

   ù Dans la routine de dessin, on peut detecter si une fenˆtre est
     ic“nifi‚e et modifier l'affichage en consequence.

   ù Utiliser la routine de dessin de l'ic“ne. La structure win->icon
     contient l'adresse d'une routine qui si elle n'est pas nulle est
     utiliser par Windom pour dessin le contenu de la fenˆtre lorsque
     cette derniŠre est ic“nifi‚e.

Prenons le cas une fenˆtre contenant un formulaire. Windom attribut
une routine sp‚cifique pour dessiner le formulaire dans la fenˆtre.
Comme il n'est pas interessant de modifier la routine pour changer
l'affichage de la fenˆtre ic“nifi‚e, l'utilisation de la routine win-
>icon.draw (la routine de dessin de la fenˆtre ic“ne) devient
obligatoire.


4.9  Les formulaires en fenˆtre
===============================

WinDom se charge de la gestion complŠte des formulaires dans les
fenˆtres. La seule chose … la charge du programmeur est la routine de
traitement du formulaire. WinDom vous propose deux type de gestion:

 formulaire en fenˆtre le formulaire vous laisse la main dans
     l'application et le reste du GEM.

 formulaire modal le formulaire bloque le reste de l'application mais
     pas le GEM. Vous avez accŠs aux accessoires et aux autres
     applications si vous ˆtes dans un environnement mulitƒche ou
     multiapplication.


4.9.1  Les formulaires en fenetre
---------------------------------

On distinguera deux stades: l'‚criture de la routine de traitement du
formulaire et ouverture de la fenˆtre formulaire. Toutefois la
routine du traitement du formulaire reste facultative.

Cr‚ation du formulaire

----------------------------------------------------------------------

Pour cr‚er un formulaire, on utilise la fonction FormCreate(). Cette
fonction fait beaucoup de choses. Tout dabord, avant de cr‚er une
fenˆtre, elle v‚rifie si le dialogue n'existe pas d‚ja dans une autre
fenˆtre ferm‚ ou ic“nifi‚. Si c'est le cas elle se contente de
restorer cette fenˆtre. Ainsi, on ne peut a priori pas ouvrir
plusieurs fenˆtres avec un mˆme formulaire et heureusement, les
coordonn‚es des objets ne sont plus neccessairement les mˆmes ainsi
que les ‚tats des objets d'ou cette pr‚caution.

Toutefois, on peut d‚sirer afficher plusieurs fenˆtre avec un mˆme
formulaire. Dans ce cas, il faut dupliquer en m‚moire le formulaire
avec la fonction ObjcDup() et mettre le bit WS_FORMDUP du champ
status de la fenˆtre … 1 (pour que WinDom libŠre la m‚moire allou‚ au
formulaire lors de la destruction de la fenˆtre), ou bien il suffit
de mettre … 1 le paramŠtre dup de FormCreate().

La fonction FormCreate() s'occupe ‚galement d'initialiser le
descripteur de la fenˆtre correctement pour g‚rer les formulaires
(routines ‚venements sp‚cifiques et variables ad‚quates) et d'adapter
la taille de la fenˆtre … celle du formulaire.

Une fois l'appel de la fonction r‚alis‚, vous ne faŒtes plus rien,
c'est WinDom qui travaille!

Gestion du formulaire

----------------------------------------------------------------------

Exemple 1: Gestion dans la boucle principale

Voi‡i un exemple typique, on d‚sire ouvrir un formulaire … la suite
d'un choix dans le menu du bureau:

  while(1)
  {
    EvntWindom( MU_MESAG);
    if( evnt.buff[0] == MN_SELECTED)
    {    /* Le menu a ‚t‚ sollicit‚ */
      switch( evnt.buff[4])
      {
      /* Creation du formulaire */
      case ENTREE_MENU_FORM1:
        rsrc_gaddr( 0, FORM1, &tree);
        FormCreate( MOVER|NAME|SMALLER,    /* Attribut GEM */
                    tree,                 /* le formulaire */
                    NULL,     /* pas de routine de gestion */
                    "Titre fenˆtre",
                    NULL,     /* Centrer le formulaire et
                                 adapter la taille de la
                                 fenˆtre */
                    1,        /* effet graf_box actif */
                    0);  /* Ne pas dupliquer le formulaire */
        break;
        ....
      }
    }
    if( evnt.buff[0] == WM_FORM)
    {
    /* traiter ici les choix du formulaire */
       ...
    }
  }

Exemple 2: Gestion dans une fonction

Voi‡i la structure … respecter obligatoirement dans la routine:

void TraiteDialogue( WINDOWPTR win)
{
  int res = evnt.buff[4];

  switch( res) {
    case BUTTON1:
      ....
      ObjcChange( OC_FORM, win, res, NORMAL, 1); /* tr‚s recommand‚ */
      break;
      ....
  }
}

ObjcChange() est l'‚quivalent de objc_change pour les objets en
fenˆtre.

La cr‚ation du formulaire:


   while(1)
   {
      EvntWindom( MU_MESAG);
      if( evnt.buff[0] == MN_SELECTED)
      {    /* Le menu a ‚t‚ sollicit‚ */
              switch( evnt.buff[4])
         {
           /* Creation du formulaire */
           case ENTREE_MENU_FORM1:
              rsrc_gaddr( 0, FORM1, &tree);
              FormCreate( MOVER|NAME|SMALLER,  /* Attribut GEM */
                          tree,                /* le formulaire */
                          TraiteDialogue, /* la routine de gestion */
                          "Titre fenˆtre",
                          NULL,     /* Centrer le formulaire et
                                       adapter la taille de la
                                       fenˆtre */
                          1,        /* effet graf_box actif */
                          0);  /* Ne pas dupliquer le formulaire */
              break;
           ....
         }
      }
   }

Une derniŠre remarque, si vous voulez cr‚er vous-mˆme un formulaire
sans passer par FormCreate(), vous pouvez utiliser la fonction
FormAttach() pour cela. En gros voi‡i le sh‚ma a respecter:

  1. Dupliquer le formulaire en m‚moire ou rouvrir la fenetre
     contenant le formulaire.

  2. Cr‚er la fenˆtre: win = WindCreate( ... );

  3. Attacher le formulaire: FormAttach( win, ...);

  4. Autre initialisations diverses (nom, menu, etc ...)

  5. Ouvrir la fenˆtre avec la bonne taille, en utilisant la taille
     du formulaire, WindCalc() et aussi form_center() puis finalement
     WindOpen().


4.9.2  Les formulaires modaux
-----------------------------

La gestion de ces formulaires est completement diff‚rent de celui des
formulaires en fenˆtres. En fait, elle est calqu‚ sur la gestion des
formulaires classiques sans fenˆtre. On trouve la structure suivante:

  1. Affichage du formulaire fonction FormWindBegin()

  2. Gestion du formulaire fonction FormWindDo()

  3. Effacement du formulaire fonction FormWindEnd()

Ces trois fonctions suffisent pour gerer complement le formulaire:

void FormWindBegin( OBJECT *form, char *nom);

cr‚e la fenˆtre modal avec son formulaire centr‚e a l'‚cran. Par
convention, ces fenˆtres ont pour seul attribut une barre de
d‚placement. Le formulaire donc donc contenir un objet EXIT ou
TOUCHEXIT.

int FormWindDo( void);

cette fonction retourne l'index de l'objet EXIT ou TOUCHEXIT
s‚lectionn‚. Elle ne rend la main que lorsque ces objets ont ‚t‚
cliqu‚s.

void FormWindEnd( void);

cette fonction ferme la fenˆtre modale.

Un exemple:

Cette fonction affiche un formulaire modal et retourne l'index de
l'objet s‚lectionn‚.

int CallDialog( int index)
{
   OBJECT *dialog;
   int res;

   rsrc_gaddr( 0, index, &dialog);
   FormWindBegin( dialog, "Formulaire");
   res = FormWindDo();
   FormWindEnd();
   return res;
}

Second exemple:

int CallDialog( int index)
{
   OBJECT *dialog;
   int res;

   rsrc_gaddr( 0, index, &dialog);
   FormWindBegin( dialog, "Formulaire");
   do{
      res = FormWindDo( MU_MESAG);
      switch( res)
      {
         case OBJ_TOUCHEXIT1:
            ....
            break;
          ....
      }
   } while( dialog.ob_state & TOUCHEXIT);
   FormWindEnd();
   return res;
}

Dans cet exemple, seuls les objets EXIT permettent de sortir de la
boucle Notez au passage que l'on peut acceder … l'arborescence
d'objet du formulaire soit par dialog, soit par FORM(wgbl.appfront).
En effet la fenˆtre est modale, elle est donc toujours la fenetre en
premier plan de notre application. En utilisant wgbl.appfront, on
peut imbriquer plusieurs formualaires modales. Par contre, on ne peut
pas utiliser wgbl.front qui peut ˆtre NULL si la fenˆtre modale est
recouverte par une fenˆtre d'une autre application.

L'utilisation du bit FORM_EVNT permet, par exemple, de d‚tecter un
ev‚nement AP_TERM. Lorsqu'on traite un formulaire modal, le
traitement est local, on ne passe pas par la boucle principale. Ainsi
les evemenents qui sont g‚rer dans la boucle principale ne le sont
pas forcement dans le formalaire modal:

     int quit = 0;

     rsrc_gaddr( 0, index, &dialog);
     FormWindOpen( dialog, "Formulaire");
     do { /* on est oblig‚ de boucler car le moindre
           * ‚venements de type MU_MESAG nous fait
           * sortir de la fonction FormWindDo()
           */
          res = FormWindDo( MU_MESAG|FORM_EVNT);
          if( res & FORM_EVNT) {  /* A-t-on d‚tect‚ un evenement MU_MESAG? */
               if( res & MU_MESAG && evnt.buff[0] == AP_TERM) {
                    snd_msg( NULL, AP_TERM, 0, 0, 0, 0);
                    quit = 1;
               }
          } else { /* traitement normal du formulaire */
               switch( res) {
               case OK:
                    quit = 1;
                    break;
                    ...
               }
          }
     } while( !quit );
     FormWindEnd();


4.10  Mettre un menu en fenˆtre
===============================


4.10.1  Incruster un menu
-------------------------

Inscruter un menu dans une fenˆtre se fait de fa‡on tr‚s naturelle en
suivant la logique du GEM. Il faut d'abord cr‚er une fenˆtre avec
WindCreate() et WindOpen(). Ensuite il suffit d'installer le menu en
appelant la fonction WindSet() en mode WF_MENU (voir "WindSet() avec
le mode WF_MENU") en donnant comme paramŠtre l'adresse du menu ainsi
que l'adresse de la routine de gestion du menu ou NULL si on ne veut
pas utiliser de routine.

Voi‡i un exemple typique:

          {
               OBJECT *menu;
               WINDOW *win;

               win = WindCreate( NAME|MOVER|CLOSER, app.x, app.y, app.w,
                                        app.h);
               WindOpen( win, app.x+10, app.y+10, app.x+200, app.y+200);
               rsrc_gaddr( 0, MENU1, &tree);
               WindSet( win, WF_MENU, tree, NULL);
          }

Le menu peut ˆtre supprim‚ avec l'appel:

WindSet( win, WF_MENU, NULL);

Remarquons que les menus en fenˆtre sont dupliqu‚ (voir "ObjcDup()")
en m‚moire.


4.10.2  G‚rer le menu
---------------------

Il y a deux m‚thodes pour g‚rer le menu. Soit directement, en
r‚cup‚rant le message AES WM_MNSELECTED qui retourne l'index de
l'entr‚e du menu selectionn‚ et du titre, soit dans une routine que
EvntWindom() d‚clenche automatiqument quand un message WM_MNSELECTED
est g‚n‚r‚. Cette routine est fix‚ par la fonction WindSet().

Voi‡i la structure du message WM_MNSELECTED:

    evnt.buff[0] = WM_MNSELECTED
    evnt.buff[1] = id de l'application
    evnt.buff[2] = 0
    evnt.buff[3] = handle de la fenˆtre concern‚e
    evnt.buff[4] = titre du menu
    evnt.buff[5] = entr‚e du menu



4.10.3  M‚thode directe
-----------------------

     main()
     {
          int res;
          WINDOW *win;  /* fenˆtre … traiter */

          /* cr‚er la fenˆtre et ins‚rer un menu avec WindSet()
               ...
          */

          while(1)
          {
               res = EvntWindom( MU_MESAG);

               if( res & MU_MESAG && evnt.buff[0] == WS_MNSELECTED)
               {
                    if( menuwin->handle == evnt.buff[3])
                    {
                         switch( evnt.buff[5])
                         {
                         case ENTRE1:
                              break;
                         case ENTRE2:
                              break;
                         }
                         MenuTnormal( menuwin, evnt.buff[4], 1);
                    }
               }
          }
     }


4.10.4  La routine de gestion du menu
-------------------------------------

Cette routine sera appel‚, s'il elle existe, par EvntWindom()
lorsqu'elle rencontre un message WM_MENU.

     main()
     {
          int res;
          WINDOW *win;  /* fenˆtre … traiter */
          OBJECT *tree;
          void routine_menu( WINDOW *);

          /* cr‚er la fenˆtre
               ...
          */

          /* On d‚clare le menu dans la fenˆtre et
           * la routine de gestion du menu */
          WindSet( win, WF_MENU, menu, routine_menu);

          while(1)
               res = EvntWindom( MU_MESAG);
     }

     void routine_menu( WINDOW *win)
     {
          switch(( evnt.buff[5])
          {
          case ENTRE1:
               break;
          case ENTRE2:
               break;
          }
          MenuTnormal( win, evnt.buff[4], 1);
     }

La fonction MenuTnormal() remplace la fonction menu_tnormal() pour
les menus en fenˆtre.


4.11  Les toolbars
==================

Les toolbars s'utilisent comme les menus en fenˆtre:

   ù installation du toolbar avec WindSet( win, WF_TOOLBAR, ...),

   ù emission d'un message AES (WM_TOOLBAR) quand on selectionne un
     objet (EXIT ou TOUCHEXIT) du toolbar,

   ù possibilit‚ de traitement du message directe ou via une routine
     sp‚cifique … la fenˆtre.

L'AES, … partir de la version 4.1, intŠgre les toolbars, toutefois
WinDom n'utilise pas cet ‚lement et utilise ses propres routines pour
gerer ces toolbar et cela pour toutes les version de l'AES.

Voici la structure du message WM_TOOLBAR:

    evnt.buff[0] = WM_TOOLBAR
    evnt.buff[1] = id de l'application
    evnt.buff[2] = 0
    evnt.buff[3] = handle de la fenˆtre concern‚e
    evnt.buff[4] = index de l'objet s‚lectionn‚
    evnt.buff[5] = ‚tat du clavier


L'‚criture de la routine de gestion du toolbar ob‚it aux mˆmes
principe que les routines des formulaires en fenˆtre.

Voi‡i un exemple:

     main()
     {
          int res;
          WINDOW *win;  /* fenˆtre … traiter */
          OBJECT *tool;
          void routine_menu( WINDOW *);

          /* cr‚er la fenˆtre
               ...
          */

          WindSet( win, WF_TOOLBAR, tool, routine_toolbar);

          while(1)
               res = EvntWindom( MU_MESAG);
     }

     void routine_toolbar( WINDOW *win)
     {
          switch( evnt.buff[5])
          {
          case ENTRE1:
               break;
          case ENTRE2:
               break;
          }
          ObjcChange( win, evnt.buff[4], 1);
     }


4.12  Les objets de types ‚tendus
=================================


4.12.1  Objet userdef et type ‚tendus
-------------------------------------

Les objets de l'AES possŠde un type ob_type qui les caract‚risent.
Par exemple, les boutons sont du type G_BUTTON. Intelligemment, l'AES
permet de d‚finir ses propres objets. Ce sont les objets dont le type
est G_USERDEF. Lorsque l'AES doit dessiner ces objets, il ‚xecute la
routine poŒnt‚ par ob_spec. De plus, pour identifier ces objets,
l'AES n'utilise et ne teste que l'octet de poid faible de ob_type.
Cette particularit‚ nous permet d'utiliser l'octet de poid fort de
ob_type pour caracteriser nos nouveaux objets userdef. C'est ce qu'on
appelle le type ‚tendu. La plupart des ‚diteurs de ressource permette
d'‚diter ce type. Ceci nous sera donc pr‚cieux.


4.12.2  Compatibilit‚ avec MyDial
---------------------------------

Depuis longtemps, il existe des librairies qui propose une collection
de nouveaux objets. Une des plus c‚lŠbre chez nos amis allemands est
la librairie MyDial qui offre la possibilit‚ int‚ressante de
fonctionner conjoŒntement avec l'‚diteur de ressource Interface.
Interface comprend les types ‚tendus de MyDial et affiche le
v‚ritable look de ces objets. C'est pourquoi les objets ‚tendus de
Windom sont compatible avec ceux de MyDial. De plus, Windom laisse la
possibilit‚ d'utiliser MyDial (dont les objets sont plus
sophifistiqu‚) plut“t que ceux de sa librairie.


4.12.3  Fonctionnement des ressources ‚tendus
---------------------------------------------

Comment windom gŠre cela en pratique? Windom parcourt tous les objets
d'un ressource et examine leur ob_type. Si le type d'un objet est
G_USERDEF, Windom ne fait rien parcequ'il s'agit d'un objet userdef
ext‚rieur … la librarie. Sinon, en fonction du type ‚tendus et du
type normal, Windom cr‚e une structure W_PARAM qui contient les
valeurs de ob_type et ob_spec de l'objet afin de r‚initialis‚
ultŠrieurement les objets lorsqu'on voudra plus utiliser de types
‚tendus. Ensuite Windom assigne … l'objet comme nouveau type
G_USERDEF et comme nouveau ob_spec, une structure USERBLK qui
contient l'adresse de la routine de dessin de l'objet et qui sera
utilis‚ par l'AES pour dessiner l'objet. Cette routine depend bien
entendu du type ‚tendu de l'objet.


4.12.4  Utilisation
-------------------

En pratique, il y a deux cas: le ressource est externe ou bien le
ressource est int‚gr‚. Windom gŠre ces deux cas. Toutefois, dans le
cas d'un ressource int‚gr‚, les ic“nes couleurs doivent ˆtre fix‚ …
la r‚solution de l'‚cran. Dans le cas contraire, c'est l'AES qui s'en
charge.

Cas 1: ressource externe

     #include <windom.h>
     #include "monrsc.h"

     void main(void)
     {
          ApplInit();

          /* Cette fonction remplace rsrc_load() */
          RsrcLoad( "monrsc.rsc");

          /* On installe les types ‚tendus
             le paramŠtre NULL indique que le
             ressource est externe */
          RsrcXtype( 1, NULL, 0);

          /* reste du programme */

          /* On libŠre les types ‚tendus */
          RsrcXtype( 0, NULL, 0);

          RsrcFree();
          ApplExit();
     }

Cas 2: ressource int‚gr‚

     #include <windom.h>
     #include "monrsc.h"
     #include "monrsc.rh"  /* contient les d‚clarations des
                              variables du ressource et les
                              valeurs des constantes NUM_ICB
                              NUM_OBS, NUM_TREE */
     #include(!b) "monrsc.rsh"  /* Le ressource */


     void main(void)
     {
          int dum;
          XRSRCFIX fix;

          ApplInit();

          /* On fixe les coordonn‚es des objets */
          for( dum=0; dum<NUM_OBS; dum++)
               rsrc_obfix( rs_object, dum);

          /* On fixe les types ‚tendus avec cette fois
             l'adresse des objets puisque le ressource
             est int‚gr‚.
             Notez que l'on peut utiliser simultan‚ment
             un ressource externe et plusieurs ressources
             int‚gr‚s. */
          RsrcXtype( 1, rs_trindex, NUM_TREE);

          /* On fixe les ic“nes couleurs du ressource
             Ce n'est pas n‚cc‚ssaire s'il n'y a pas
             d'ic“nes couleurs bien-sur
             fix contient des infos n‚cessaire pour
             lib‚rer ult‚rieument la m‚moire utilis‚ */
          RsrcFixCicon( rs_object, NUM_OBS, NUM_CIB, NULL, &fix);

          /* reste du programme */

          /* On libŠre la m‚moire utilis‚ par les ic“nes*/
          RsrcFreeCicon( &fix);

          /* Lib‚ration des types ‚tendus */
          RsrcXtype( 0, rs_trindex, NUM_TREE);

          ApplExit();
     }


4.12.5  Utilisation dans l'‚diteur de ressource
-----------------------------------------------

C'est dans l'‚diteur que l'on fixe les types d'objets que l'on
souhaite voir s'afficher. Voi‡i la liste de ces objets et la valeurs
des diff‚rents flags … fixer dans l'‚diteur.

! signifie qu'il ne faut pas choisir cette valeur
[] signifie une valeur en option


 +-------------------+-------------+--------+----------+------------+
 |    Description    |   ob_type   | ‚tendu | ob_flag  |  ob_state  |
 +-------------------+-------------+--------+----------+------------+
 +-------------------+-------------+--------+----------+------------+
 | Bouton radio rond |  G_BUTTON   |   18   | RBUTTON  |  [Draw3D]  |
 |                   | ou G_STRING |        |          | [DISABLED] |
 +-------------------+-------------+--------+----------+------------+
 |   Bouton carr‚    |  G_BUTTON   |   18   | !RBUTTON |  [Draw3D]  |
 |                   | ou G_STRING |        |  !EXIT   | [DISABLED] |
 +-------------------+-------------+--------+----------+------------+
 |    Bouton exit    |  G_BUTTON   |   18   |   EXIT   |  [Draw3D]  |
 |                   | ou G_STRING |        | !RBUTTON | [DISABLED] |
 +-------------------+-------------+--------+----------+------------+
 |  Bouton de cycle  |  G_BUTTON   |   22   |          |  [Draw3D]  |
 |                   | ou G_STRING |        |          |            |
 +-------------------+-------------+--------+----------+------------+
 |  Texte soulign‚   |  G_BUTTON   |   19   |          |  [Draw3D]  |
 |                   | ou G_STRING |        |          |            |
 +-------------------+-------------+--------+----------+------------+
 |    Cadre titr‚    |  G_BUTTON   |   20   |          |  [Draw3D]  |
 +-------------------+-------------+--------+----------+------------+
 |   Bouton d'aide   |  G_BUTTON   |   21   |          |            |
 +-------------------+-------------+--------+----------+------------+
 |    Bouton Undo    |  G_BUTTON   |   31   |          |            |
 +-------------------+-------------+--------+----------+------------+
 |    Objet Undo     |      -      |   -    |          |   Flag11   |
 +-------------------+-------------+--------+----------+------------+
 |     Bouton 3D     |      -      |   -    |          |   Draw3D   |
 +-------------------+-------------+--------+----------+------------+

        (Tableau 1: Type ‚tendus dans l'‚diteur de ressource)


Les raccourcis claviers sont utilisables dans les objets de type
‚tendu 18. Un crochet [ pr‚c‚dent la lettre … souligner doit ˆtre
ins‚r‚ dans le texte.


4.13  Les raccourcis claviers
=============================


4.13.1  Fonctionnement des raccourcis claviers
----------------------------------------------

WinDom gŠre automatiquement les raccour‡is dans la fonction
EvntWindom() mˆme si elle ne surveille pas les ‚venements claviers.
Lorsqu'un ‚venement clavier se produit, EvntWindom() l'‚value puis
cherche s'il existe dans un ordre de priorit‚ fix‚. Cet ordre ne peut
pas ˆtre chang‚. Bien-sur cela chaque ‚tape d‚pend si le menu, la
fenˆtre, etc... existe. L'‚valuation stoppe dŠs que le raccourci a
‚t‚ trouv‚. Ensuite, WinDom execute ce raccour‡i en envoyant le bon
message (MN_SELECTED, WM_MNSELECTED, WM_TOOLBAR ou WM_FORM)
concernant le bon objet.

Priorit‚ dans l'‚valuation des raccourcis clavier (par priorit‚
d‚croissante):

   ù menu du bureau,

   ù menu de la fenˆtre,

   ù toolbar de la fenˆtre,

   ù formulaire en fenˆtre.

La fenˆtre cibl‚e d‚pend de la variable globale app.keybd. Si
app.keybd = FRONT_WINDOW ( valeur par d‚faut), la fenˆtre cibl‚ sera
la fenˆtre en premier plan. Si app.keybd = MOUSE_WINDOW, a fenˆtre
cibl‚ sera la fenˆtre sous la souris.


4.13.2  Structure des raccourcis claviers
-----------------------------------------

Bien ‚videmment, les raccour‡is claviers plac‚es dans les menus
doivent ob‚ir … certaines rŠgles.

Menus

Chaque raccourci est d‚limit‚ par des espaces. Ainsi EvntWindom()
peut d‚tecter ‚fficacement la pr‚sence des raccourcis. Par exemple, "
Quitter ^Q ", est valide.

Ensuite le raccour‡i peut contenir au d‚but (donc aprŠs un espace)
les caractŠres:

    ^ pour control
     pour alternate
     pour shift gauche ou shift droit
    ( pour shift gauche
     pour shift droit
     sous-menu ? )


Ces caractŠres sont facultatifs si l'on ne veut pas utiliser les
touches control, alternate et shift.

Ensuite on peut trouver soit un caractere ascii masjuscule A .. Z,
soit l'une des chaŒnes suivantes:

ESC UNDO HELP INSERT HOME TAB BACK DEL F1 ... F10 d‚signant les
touches sp‚ciales du clavier et touche de fonctions.

Exemples

    " Information I "
    " Copier ^C "
    " Compiler C "
    " Centrer F1 "
    " Aide HELP "
    " Effacer ^DEL "


Formulaires

Seul les objets de type ‚tendus 18 (boutons) peuvent poss‚der un
raccourci. Un caractŠre sp‚cial - [ - doit ˆtre ins‚r‚ dans le texte
avant la lettre … souligner.

Ces raccourcis ne sont atteignable que par alternate+la touche du
caractŠre soulign‚.

Exemple

    texte du bouton: "[Sauver la config"
    raccour‡i: alternate S


D'autres objets sont atteignable par le clavier. En voici une liste:

 RETURN ou ENTER agit sur l'objet dont l'ob_flags est DEFAULT,

 UNDO agit sur l'objet dont l'ob_state est FLAGS11 ou sur le bouton
     dont le type ‚tendu est 31,

 HELP agit sur le bouton dont le type ‚tendu est 21.

Champs ‚ditables

WinDom n'intŠgre pas de commande ‚labor‚ d'‚dition dans les champs
‚ditables. Pourquoi? Eh bien parce que WinDom est compatible avec
Let's them fly (sauf pour les raccourci claviers). En effet, ce
programme est pr‚sent sur toutes nos machines et fait presque parti
du TOS alors je vois pas pourquoi il faudrait recoder ce qui est d‚j…
fait. Du coup, on a accŠs aux fonctions d'‚dition de Let's them fly:

 control fleche droite, gauche saut au mot suivant, pr‚c‚dent,

 control fleche haut, bas d‚filement de l'historique,

 shift fleche droite, gauche saut au d‚but, a la fin de la saisie,

 shift insert apparition table ascii pour ‚diter un caractŠre,

 shift undo rappele l'ancienne saisie,

 control C copier dans le clipbord,

 control V coller du clipbord dans le champ,

 escape effacer la saisie.


4.14  Les frames
================

N'importe quelle fenˆtre (formulaire, fenˆtre user) peut ˆtre mise en
frame et cela de fa‡on transparente. C'est-…-dire qu'une unique
fenˆtre peut-etre divis‚ en plusieurs frames chacunes ayant leurs
propres attributs et routines.

Principe:

Une fenˆtre frame est juste une fenˆtre avec des routines
sp‚cifiques. Le champs data poŒnte vers une structure qui contient
entre autre la liste des frames attach‚es … cette fenˆtre. Les
routines standarts de la fenˆtre se chargent juste d'ex‚cuter les
routines de gestion des frames qu'elle contient. La routine de dessin
dessine les cadres puis appelle les routines de dessin de chaque
frame.

Une frame, comme une fenˆtre, est caract‚ris‚ par un descipteur
WINDOW. Toutefois ce descripteur n'existe pas dans la liste des
fenˆtres de WinDom car elle ne correspond pas … une vraie fenˆtre
GEM. Ce descripteur existe seulement pour la fenˆtre qui contient la
frame.

La plupart des fonctions de la librairie peuvent ˆtre utilis‚ sur les
descripteurs de frame. Cela permet d'‚crire des routines de gestions
d'‚vemenents valable pour les fenˆtres comme pour les frames. (Cela
permet aussi d'utiliser des types pr‚d‚finies de fenˆtre en frame).

D‚marche pour cr‚er des frames:

  1. Cr‚ez une fenˆtre qui contiendra les frames: FrameCreate(),

  2. cr‚ez les autres fenˆtres comme d'habitude (celle qui seront
     incrust‚es comme frame),

  3. d‚clarez ces fenˆtres comme frame: FrameAttach(),

  4. ‚ventuellement r‚glez certains paramŠtres avec FrameSet(),

  5. uouvrez la fenˆtre et gerez les ‚venements.


4.15  Param‚trage de WinDom
===========================


4.15.1  Les variables concern‚es
--------------------------------

La variable app fixe certains paramŠtres de l'environnement.

Le champ app.flag gŠre certains comportements de EvntWindom(). C'est
un masque de bits actuellement sur 3 valeurs:

 KEYBD_ON_MOUSE permet de diriger les ‚venements clavier (MU_KEYBD)
     vers la fenˆtre point‚ par la souris au lieu de la fenˆtre en
     premier-plan. Cette option est trŠs pratique avec de grand ‚cran
     ou l'on peut ouvrir plusieurs fenˆtre l'une a cot‚ de l'autre.
     On a plus besoin de cliquer sur une fenˆtre pour la rendre
     active. Cette fa‡on de proc‚der est celle des gestionnaires de
     fenˆtres sous X11.

 BUTTON_ON_MOUSE est la version ‚venement bouton (MU_BUTTON) du flag
     pr‚cedent: tous les ‚venements boutons seront appliqu‚ … la
     fenˆtre plac‚ sous la souris.

 NOPALETTE d‚sactive la gestion de la palette par EvntWindom() (voir
     Les palettes de couleurs).

Remarque concernant le flag BUTTON_ON_MOUSE:

   ù Depuis la version 3.4 de l'AES (TOS Falcon), il existe un moyen
     de transformer un clic souris dans une zone de travail d'une
     fenˆtre en arriŠre-plan (cela generait un evenement WM_TOPPED)
     par un evenement MU_BUTTON. On utilise pour cela un nouveau mode
     de la fonction wind_set() (voir WindSet()). Bien-sur, WinDom
     ‚mule ce mode mˆme pour les vieilles versions de l'AES. La
     valeur MOUSE_WINDOW du paramŠtre app.button offre le mˆme
     comportement mais g‚n‚ralis‚ … toutes les fenˆtres.

   ù Si on veut permettre cela qu'a certaines fenˆtres, il vaut mieux
     utiliser WindSet().

   ù Les formulaires, les menus et les toolbars sont de toutes
     maniŠres, utilisable en arriŠre-plan (faut si une fenetre modale
     les recouvre (voir WindSet()).

Le champ app.key_color fixe la couleurs des raccourcis claviers des
boutons ‚tendus. Cette variable est initialis‚ … 1 (noir) par
ApplInit(). Les valeurs de 0 … 15 sont possible (ce sont les index
des couleurs VDI). Si le bit LTFLY_COLOR (0x0010) de app.key_color
vaut 1, Windom utilise la valeur fix‚ par Let's them fly. Si ce
dernier n'est pas en m‚moire, il est ignor‚. Par exemple:

     app.key_color = LTFLY_COLOR|RED;

donnera la couleur rouge si Let's them fly n'est pas en m‚moire.

Les champs app.wicon et app.hicon fixe la taille des fenˆtres
ic“nifi‚es lorsque le systŠme ne permet pas la gestion des ic“nes
(AES <4.00 sans ICFS). ApplInit() fixe des valeurs par d‚fault.

Le champ menu_effect fixe l'effet de clignotement lorsqu'on
s‚lectionne une entr‚e d'un menu dans une fenˆtre.

En projet: un mode de gestion des stations de travail virtuel VDI


4.15.2  Le fichier de configuration de WinDom
---------------------------------------------

ApplInit() lit un fichier de configuration afin de fixer certains
paramŠtres de la librairie. Ainsi, ces paramŠtres peuvent rester
ininitialis‚ car ils le seront grƒce … ce fichier de configuration.
Ainsi le choix des comportements sera laiss‚ … l'utilisateur (et ‡a
nous ‚vite de coder un formulaire de config dans l'application).

Ce fichier peut ˆtre unique et regrouper les configurations de
plusieurs programmes ainsi qu'une configuration par d‚faut pour les
autres applications. Il s'appelle 'windom.cnf'.

Comme ce fichier est unique, il est cherch‚ dans diff‚rents
r‚pertoires; en voi‡i l'ordre par ordre d‚croissant de priorit‚:

  1. le r‚pertoire courant de l'application,

  2. le r‚pertoire donn‚ par la variable d'environnement AES 'HOME',

  3. les r‚pertoires donn‚s par la variable d'environnement AES
     'PATH'.

Actuellement, ce fichier permet de fixer certaines valeurs de APPvar:

   ù le bit KEYDB_ON_MOUSE de app.flag,

   ù le bit BUTTON_ON_MOUSE de app.flag,

   ù la valeur app.menu_effect,

   ù la valeur app.key_color,

   ù la valeur app.string_color,

   ù la valeur app.button_color,

   ù la valeur app.exit_color,

   ù la taille des fenˆtres ic“nifi‚es,

   ù la taille de la fonte de caractŠre de la station VDI app.handle,

   ù le nom de la fonte de caractŠre de la station VDI app.handle.

Rappelons que app.handle est utilis‚ pour dessiner les ‚l‚ments
graphiques de la librairie (les types ‚tendues, les bords des frames,
les menus).

Les correspondances entre WinDom et les mots-clefs du fichier
windom.cnf sont expliqu‚es dans le tableau suivant:


+-----------------------------------+---------------------------------+
| Mot Clef et syntaxe               | Variable de APPvar              |
+-----------------------------------+---------------------------------+
| xtype_string_color = %d           | app.string_color                |
| xtype_exit_button_color = %d      | app.exit_color                  |
| xtype_other_button_color = %d     | app.button_color                |
| xtype_font_name = "%s"            | vst_font( app.handle, ...)      |
| xtype_fonte_size = %d             | vst_height( app.handle, ...)    |
| xtype_shortcut_color = %d         | app.key_color                   |
| mu_keybd_on_mouse = {true|false}  | bit KEYBD_ON_MOUSE de app.flag  |
| mu_button_on_mouse = {true|false} | bit BUTTON_ON_MOUSE de app.flag |
| icon_geometry = %d,%d             | app.wicon et app.hicon          |
| menu_effect = %d                  | app.menu_effect                 |
+-----------------------------------+---------------------------------+


Voir aussi la Syntaxe du fichier windom.cnf.


4.16  Les structures et les variables globales
==============================================


4.16.1  Variables globales
--------------------------

Les variables globales sont regroup‚es par soucis de clart‚ dans des
structures.

typedef int W_COLOR[3];

W_COLOR est utilis‚ pour la gestion des palettes de couleurs des
fenˆtres et du bureau.

typedef struct {
          int  id;
          int  handle;
          int  aeshdl;
          int  x,y,w,h;
          int  wicon, hicon;
          int  color;
          OBJECT  *menu;
          W_COLOR *palette;
          int  work_in[10];
          int  work_out[57];
          int  aes4;
          int  flag;
          int  key_color;
          int  menu_effect;
          void  (*menu_proc)(void);
     } APPvar;

extern APPvar app;

Cette variables contient des informations globales de l'applications.
Sauf exeptions, ces variables ne peuvent pas ˆtre modifi‚s:

 id          num‚ro AES de l'application,

 handle      handle de la station de travail graphique de
             l'application. Cette station est utilis‚ pour
             l'affichage des menus en fenetres et des objets
             userdefs.

 aeshdl      handle de la stationde travail graphique ouverte par
             l'AES (donn‚ par graf_handle()).

 x,y,w,h     coordonn‚es du bureau.

 wicon,hicon taille des ic“nes. Utilis‚s lorsque l'AES ne gere pas
             l'ic“nification, ces variables fixent la taille des
             ic“nes. Ces valeurs peuvent ˆtre modifi‚es.

 color       nombre de couleur du bureau.

 menu        adresse du menu du bureau.

 palette     palette de couleurs du bureau. Lorsqu'une fenetre en
             premier plan n'a pas de palette, on utilise comme
             palette celle du bureau.

 work_in     tableau d'initialisation de la station de travail
             graphique des fenetres. Initialis‚ dans ApplInit(), elle
             peut ˆtre modifi‚e.

 work_out    tableau de sortie de l'initialisation.

 aes4        cette variable contient des informations sur l'AES ...

 flag        cette variable est un masque de bit d‚terminant certains
             comportements de la librairie:

              KEYBD_ON_MOUSE ce flag force EvntWindom() a attribuer
                             les ‚venements MU_KEYBD … la fenˆtre
                             point‚ par la souris (au lieu de la
                             fenˆtre en premier plan).

              BUTTON_ON_MOUSE ce flag force EvntWindom() a attribuer
                             les ‚venements MU_BUTTON … la fenˆtre
                             point‚ par la souris (au lieu de la
                             fenˆtre en premier plan).

              NOPALETTE      ce flag d‚sactive dans EvntWindom() la
                             gestion de la palette.

 key_color   fixe la couleurs des raccourcis claviers des boutons
             ‚tendus. Cette valeur peut ˆtre modifi‚e.

 menu_proc   adresse de la routine de gestion du menu du bureau.

(voir Param‚trage de WinDom)

typedef struct {
          WINDOW *first;
          WINDOW *front;
          WINDOW *appfront;
     } WINvar;

extern WINvar wglb;

Cette variable est trŠs utile pour g‚rer correctement ses fenˆtres:

 first    poŒnte sur la racine de la liste des descripteur de
          fenˆtre,

 front    poŒnte sur le descripteur de la fenˆtre en premier plan,

 appfront poŒnte sur le descripteur de la fenˆtre en premier plan
          relatif de l'application.

Ces trois variables peuvent ˆtre NULL.

typedef struct {
     int lo_timer, hi_timer;
     int bclick, bmask, bstate;
     int m1_flag, m1_x, m1_y, m1_w, m1_h;
     int m2_flag, m2_x, m2_y, m2_w, m2_h;
     int buff[8];
     int mx, my, mbut, mkstate;
     int keybd, nb_click;
     } EVNTvar;

extern EVNTvar evnt;

Cette variable est utilis‚ par EvntWindom() pour appel‚ evnt_multi().

GRECT clip;

Cette variable contient en permanence les coordonn‚es de la zone
clipp‚ par EvntWindom() lors des redessins des fenˆtres. En
particulier elle peut ˆtre utile dans les fonctions de dessins pour
savoir si on dessine ou pas dans la zone. On peut alors optimiser la
proc‚dure de dessin.


4.16.2  W_FORM
--------------

typedef struct {
          OBJECT *root;
          OBJECT *real;
          void (*proc)( struct _window *);
          int *save;
          int edit, curseur, nb_ob;
     } W_FORM;

Cette structure est utilis‚ par les formulaires en fenˆtre (dans ce
cas win->data pointe sur une structure W_FORM) et par les toolbars
(dans ce cas, les donn‚es sont dans win->toolbar).

 root contient l'adresse de l'arborescence d'objet du formulaire ou
     du toolbar.

 real si l'objet a ‚t‚ dupliqu‚ en m‚moire (via WindSet() ou
     FormCreate()), contient l'adresse de l'arborescense originel,
     sinon, a la mˆme valeur que root.

 proc contient l'adresse de la routine gŠrant le comportement du
     formulaire.

 save est un buffer utilis‚ par les fonctions FormSave() et
     FormRestore().

 edit, curseur, nb_ob sont des variables internes.


4.16.3  W_GRAFPORT
------------------

Cette structure d‚crit le port graphique de la fenˆtre:

typedef struct _grafport{
          int       handle;   /*  Handle station de travail virtuelle */
          W_COLOR *palette;   /* Palette de couleur de la station */
     } W_GRAFPORT;


4.16.4  W_MENU
--------------

Cette structure est utilis‚ pour g‚rer les menus en fenˆtre.

typedef struct {
          OBJECT *root;                      /* Le menu */
          void (*proc)( struct _window *);   /* La fonction qui
                                              * gŠre le menu */
     } W_MENU;


4.16.5  W_ICON
--------------

Cette structure sert … l'ic“nification de la fenˆtre.

typedef struct {
         char *name;          /* Nom de la fenˆtre ic“ne */
          int x, y, w, h;     /* Coordonn‚es originale de la fenˆtre
                               * non-ic“nifi‚e.*/
          void (*draw)(struct _window *); /* routine de dessin
                                           * de la fenˆtre ic“ne */
     } W_ICON;


4.16.6  FRAME
-------------

Cette structure est poŒnt‚e par le champ data des descripteurs de
fenˆtre frame ( ayant le bit WS_FRAME_ROOT du champ status … 1).

typedef struct {
    struct _window *list;   /* liste chaŒn‚e des frames */
    struct _window *front;  /* frame active */
    int border;         /* taille du bord */
    int color;          /* couleur du bord */
    int flags;          /* paramŠtres divers */
    } FRAME;


4.16.7  FRAMEINFO
-----------------

Cette structure apparait dans les descripteurs de fenˆtre depuis la
version de Mai 97. Elle ne concerne que les fenˆtres contenant des
frames ou les frames.

typedef struct {
    int line, col;      /* cellule occup‚ par la frame */
    int x,y,w,h;        /* position de la frame */
    int flags;      /* paramŠtres divers de la frame */
    } FRAMEINFO;


4.16.8  WINDOW
--------------

Voi‡i la structure du descripteur de fenˆtre:

typedef struct _window{
          int handle;
          int attrib;
          int status;
          W_GRAFPORT graf;
          W_MENU  menu;
          W_FORM  tool;
          W_ICON  icon;
          BOOLEAN fullsize;
          GRECT createsize;
          FRAMEINFO frame;
          char *name, *info;
          intt w_max, h_max;
          int w_min, h_min;
          int xpos, ypos;
          int xpos_max, ypos_max;
          int w_u, h_u;
          int wslider, hslider;
          struct _window *next;

          int type;
          void *data;

          /* Les fonctions g‚rant les ‚v‚nements fenˆtres */

          void (*redraw)(struct _window *);
          void (*topped)(struct _window *);
          void (*moved)(struct _window *);
          void (*sized)(struct _window *);
          void (*closed)(struct _window *);
          void (*iconified)(struct _window *);
          void (*uniconified)(struct _window *);
          void (*alliconified)(struct _window *);
          void (*hslided)(struct _window *);
          void (*vslided)(struct _window *);
          void (*fulled)(struct _window *);
          void (*uppaged)(struct _window *);
          void (*dnpaged)(struct _window *);
          void (*uplined)(struct _window *);
          void (*dnlined)(struct _window *);
          void (*lfpaged)(struct _window *);
          void (*rtpaged)(struct _window *);
          void (*lflined)(struct _window *);
          void (*rtlined)(struct _window *);

          /* Les fonctions g‚rants les autres ‚v‚nements AES */

          void (*clicked)(struct _window *);    /* MU_BUTTON */
          void (*keyhited)(struct _window *);   /* MU_KEYBD */
          void (*timed)(struct _window *);      /* MU_TIMER */
          void (*m1)(struct _window *);         /* MU_M1 */
          void (*m2)(struct _window *);         /* MU_M2 */

          /* Les fonctions g‚rants les ‚venements non AES */

          void (*destroy)(struct _window *);
          void (*extramsg)(struct _window *);
     } WINDOW, *WINDOWPTR;


4.17  Les messages AES ‚mit par WinDom
======================================

WinDom utilise de nouveaux messages d'‚venements que nous allons
d‚crire ici en d‚tails.

 WM_DESTROY
     Ce message signifie qu'une fenˆtre doit ˆtre d‚truite. WinDom
     fait la distinction entre WM_CLOSED qui signifie seulement la
     fermeture et WM_DESTROY que signifie sa destruction. L'interˆt
     est de pouvoir centraliser la lib‚ration des ressources allou‚s
     … une fenˆtre (pas seulement la destructiion de la fenˆtre GEM
     mais aussi celle de son descripteur et des donn‚es qui y sont
     rattach‚es ) dans une routine de la fenˆtre.

     Ainsi EvntWindom(), en rencontrant ce message executera la
     routine destroy du descripteur de la fenˆtre correspondante. Il
     existe une routine standart attribu‚ par WindCreate() qui ce
     contente de ferme la fenˆtre et la d‚truire. Certainement, cette
     routine sera a r‚eecrire pour chaque type de fenˆtre.

     La routine de fermeture de la fenˆtre (closed) d‚clench‚ par les
     messages WM_CLOSED rŠgle le comportement de la fenˆtre face au
     clic dans le closer. Ainsi, la routine standart emet soit un
     message d'ic“nification, soit un message de destruction selon si
     on appuie sur shift ...

         evnt.buff[0] = WM_DESTROY
         evnt.buff[1] = ap_id
         evnt.buff[2] = 0
         evnt.buff[3] = win -> handle

 WM_ICONIFY

 WM_UNICONIFY

 WM_ALLICONIFY
     Ces trois messages ne sont pas propre … WinDom puisqu'il sont
     utilis‚s par l'AES 4.1. Toutefois, pour les AES ne supportant
     pas l'ic“nification, WinDom g‚nere et utilise ces messages pour
     ses propres ic“nifications.

 WM_FORM
     Ce message signifie qu'on a cliqu‚ sur un objet EXIT ou
     TOUCHEXIT dans un formulaire en fenˆtre. Si une routine de
     gestion du formulaire est attach‚ … la fenˆtre, EvntWindom()
     d‚clenche cette routine.

         evnt.buff[0] = WM_FORM
         evnt.buff[1] = ap_id
         evnt.buff[2] = 0
         evnt.buff[3] = win -> handle
         evnt.buff[4] = index de l'objet s‚lectionn‚
         evnt.buff[5] = ‚tat du clavier

 WM_MNSELECTED
     Ce message signifie qu'on a s‚lectionn‚ une entr‚e dans un menu
     en fenˆtre. Si une routine de gestion du menu est attach‚ … la
     fenˆtre, EvntWindom() d‚clenche cette routine.

     evnt.buff[0] = WM_MNSELECTED evnt.buff[1] = ap_id evnt.buff[2] =
     0 evnt.buff[3] = win -> handle evnt.buff[4] = titre du menu
     evnt.buff[5] = entr‚e du menu

 WM_TOOLBAR
     Ce message signifie qu'on a s‚lectionn‚ un objet dans un toolbar
     d'une fenˆtre. Si une routine de gestion du toolbar est attach‚
     … la fenˆtre, EvntWindom() d‚clenche cette routine.

         evnt.buff[0] = WM_TOOLBAR
         evnt.buff[1] = ap_id
         evnt.buff[2] = 0
         evnt.buff[3] = win -> handle
         evnt.buff[4] = index de l'objet s‚lectionn‚
         evnt.buff[5] = ‚tat du clavier


4.18  Flags divers
==================

Pour information, voi‡i la signification des divers champs de bits
des structures de WinDom.


4.18.1  Flags du champs aes4 de la structure APPvar
---------------------------------------------------

Le champs aes4 donne quelques informations sur l'AES utile … la
librairie. Ces informations sont obtenues par la fonction
appl_getinfo() impl‚ment‚ par WinDom pour la version Pure C. La
version Gcc l'utilise directement dans la librairie GEM du
compilateur.


+------------------+--------+------------------------------------------+
| Nom              | Valeur | Signification                            |
+------------------+--------+------------------------------------------+
| AES4_BOTTOM      | 0x0001 | L'aes gŠre le message WM_BOTTOM          |
| AES4_ICONIFY     | 0x0002 | L'aes gere les messages WM_(UN)ICONIFY   |
| AES4_ICONIFYXYWH | 0x0004 | L'aes gere le message WM_ICONIFYXYWH     |
| AES4_SMALLER     | 0x0008 | L'attribut SMALLER est disponible        |
| AES4_BOTTOMER    | 0x0010 | L'attribut BOTTOMER est disponible       |
| AES4_APPSEARCH   | 0x0020 | La fonction appl_search() est disponible |
+------------------+--------+------------------------------------------+



4.18.2  Flags du champs flag de la structure APPvar
---------------------------------------------------

Ce flag fixe certains comportement de la fonction EvntWindom():


     +-----------------+--------+-------------------------------+
     | Nom             | Valeur | Signification                 |
     +-----------------+--------+-------------------------------+
     | KEYBD_ON_MOUSE  | 0x0001 | Les ‚venements claviers sont  |
     |                 |        | attribu‚s … la fenˆtre poŒnt‚ |
     |                 |        | par la souris.                |
     | BUTTON_ON_MOUSE | 0x0002 | Les ‚venements claviers sont  |
     |                 |        | attribu‚s … la fenˆtre poŒnt‚ |
     |                 |        | par la souris.                |
     | NOPALETTE       | 0x0004 | La gestion de la palette est  |
     |                 |        | d‚sactiv‚.                    |
     +-----------------+--------+-------------------------------+



4.18.3  Flags du champs status de la structure WINDOW
-----------------------------------------------------


  +---------------+--------+---------------------------------------+
  | Nom           | Valeur | Signification                         |
  +---------------+--------+---------------------------------------+
  | WS_OPEN       | 0x0001 | La fenˆtre est ouverte                |
  | WS_ICONIFY    | 0x0002 | La fenˆtre est iconifi‚e              |
  | WS_MENU       | 0x0004 | La fenˆtre contient un menu           |
  | WS_TOOLBAR    | 0x0008 | La fenˆtre contient un toolbar        |
  | WS_GROW       | 0x0010 | effet graf_grow                       |
  | WS_UNTOPPABLE | 0x0020 | La fenˆtre est untoppable             |
  | WS_FORM       | 0x0040 | La fenˆtre contient un formulaire     |
  | WS_FORMDUP    | 0x0080 | Le formulaire est dupliqu‚ en m‚moire |
  | WS_MODAL      | 0x0100 | La fenˆtre est modale                 |
  | WS_FRAME_ROOT | 0x0200 | La fenˆtre contient des frames        |
  | WS_FRAME      | 0x0400 | La fenˆtre est une frame              |
  +---------------+--------+---------------------------------------+



4.18.4  Flags du champs flags de la structure FRAMEINFO
-------------------------------------------------------

Ces flags concernent uniquement les frames (status WS_FRAME).


+----------------+--------+---------------------------------------------------+
| Nom            | Valeur | Signification                                     |
+----------------+--------+---------------------------------------------------+
| FRAME_VSCALE   | 0x0001 | La hauteur de frame est d‚fini proportionellement |
| FRAME_HSCALE   | 0x0002 | La largeur de frame est d‚fini proportionellement |
| FRAME_VFIX     | 0x0004 | La hauteur de frame est fixe                      |
| FRAME_HFIX     | 0x0008 | La largeur de frame est fixe                      |
| FRAME_NOBORDER | 0x0010 | Le cadre de la frame n'est pas dessinn‚           |
| FRAME_SELECT   | 0x0020 | La frame est activable                            |
+----------------+--------+---------------------------------------------------+




Chapitre 5

Librairie application
*********************


5.1  ApplInit()
===============

 NOM
     ApplInit - Initialisation de l'environnement.

 PROTOTYPAGE
     int ApplInit( void);

 PARAMETRES
     valeur retourn‚e: identificateur de l'application.

 DESCRIPTION
     Cette fonction remplace la fonction AES appl_init(). Elle
     initialise l'AES et l'environnement WinDom en initialisant
     correctement les variables globales. Avant de terminer le
     programme, il faut faire un appel a ApplExit().

 VOIR AUSSI
     ApplExit()


5.2  ApplExit()
===============

 NOM
     ApplExit - lib‚ration de l'environnement.

 PROTOTYPAGE
     int ApplExit( void);

 PARAMETRES
     valeur retourn‚e: code erreur.

 DESCRIPTION
     Cette fonction remplace la fonction AES appl_exit(). Elle libŠre
     les ressources allou‚s … l'application par l'AES et WinDom.
     ApplExit() constitue le dernier appel dans un programme WinDom.

 VOIR AUSSI
     ApplInit()


5.3  ApplName()
===============

 NOM
     ApplName - retourne le nom d'une application GEM.

 PROTOTYPAGE
     int ApplName( char *name, int id);

 PARAMETRES

      name: buffer de 8 octet qui re‡oit le nom,

      id:   identificateur AES de l'application.

      valeur retourn‚e: 1 si succŠs, 0 sinon.

 DESCRIPTION
     Cette fonction retourne le nom d'une application GEM connaissant
     son identificateur AES (celui donn‚ par appl_init()). name est
     iun pointeur sur 8 octets selon la norme AES. ApplName()
     retourne 1 si l'application a bien ‚t‚ identifi‚ 0 sinon.
     Attention, cette fonction utilise appl_search() disponible que
     sur les systŠmes multitƒche. Si appl_search() n'existe pas dans
     l'AES, ApplName() retournera aussi 0. Notez que le bit
     AES4_APPSEARCH de la variable app.aes4 identique la pr‚sence de
     appl_search().

 VOIR AUSSI
     appl_search(), appl_find()



Chapitre 6

Librairie menu
**************


6.1  MenuBar()
==============

 PROTOTYPAGE
     int MenuBar( OBJECT *menu, int mode);

 PARAMETRES

      menu: adresse du menu

      mode: 1 - affiche le menu
            0 - efface le menu

 DESCRIPTION
     Cette fonction remplace la fonction AES menu_bar().

 VOIR AUSSI
     MenuTnormal()


6.2  MenuTnormal()
==================

 PROTOTYPAGE
     int MenuTnormal( WINDOW *win, int title, int mode);

 PARAMETRES

      win:   fenˆtre concern‚ ou NULL

      title: titre du menu

      mode:  1 - affiche en mode video invers‚ le titre 0 - affiche
             en mode normal le titre

 DESCRIPTION
     Cette fonction est l'‚quivalent de la fonction AES
     menu_tnormal() pour les menus en fenˆtre. Si le paramŠtre win
     vaut NULL, alors le menu consid‚r‚ est celui du bureau.

 VOIR AUSSI
     MenuBar()


6.3  MenuIcheck()
=================

 PROTOTYPAGE
     int MenuIcheck( WINDOW *win, int index, int mode);

 PARAMETRES

      win:   fenˆtre concern‚ ou NULL,

      index: index d'une entr‚e du menu,

      mode:  1 - coche le texte de l'entr‚e du menu, 0 - d‚coche le
             texte de l'entr‚e du menu.

 DESCRIPTION
     Cette fonction est l'‚quivalent de la fonction AES menu_icheck()
     pour les menus en fenˆtre. Si le paramŠtre win vaut NULL, alors
     le menu consid‚r‚ est celui du bureau. Cette fonction fonctionne
     sur tout type d'objet.

 VOIR AUSSI
     MenuBar()


6.4  MenuText()
===============

 PROTOTYPAGE
     int MenuText( WINDOW *win, int index, char *txt);

 PARAMETRES

      win:   fenˆtre concern‚ ou NULL,

      index: index d'une entr‚e du menu,

      txt:   nouveau texte a afficher.

 DESCRIPTION
     Cette fonction est l'‚quivalent de la fonction AES menu_text()
     pour les menus en fenˆtre. Si le paramŠtre win vaut NULL, alors
     le menu consid‚r‚ est celui du bureau. Cette fonction fonctionne
     sur tout type d'objet.

 VOIR AUSSI
     MenuBar()


6.5  MenuDisable()
==================

 NOM
     MenuDisable - Invalidation du menu.

 PROTOTYPAGE
     int MenuDisable( void);

 PARAMETRES
     valeur retourn‚e: code erreur.

 DESCRIPTION
     Cette fonction est utilis‚ par Windom pour invalider l'acc‚s au
     menu du bureau sauf les entr‚es correspondant aux acc‚ssoires et
     autres applications si on est sous MultiTos. WinDom utilise
     cette fonction pour les formulaires en fenˆtres modales.

 VOIR AUSSI
     MenuEnable().


6.6  MenuEnable()
=================

 NOM
     MenuEnable - validation du menu.

 PROTOTYPAGE
     int MenuEnable( void);

 PARAMETRES
     valeur retourn‚e: code erreur.

 DESCRIPTION
     Cette fonction est utilis‚ par Windom pour revalider l'acc‚s au
     menu du bureau d‚sactiv‚ pr‚cedemment par la fonction
     MenuEnable. WinDom utilise cette fonction pour les formulaires
     en fenˆtres modales.

 VOIR AUSSI
     MenuDisable().


6.7  MenuPopUp()
================

 NOM
     MenuPopUp - Gestion de menu popup.

 PROTOTYPAGE
     int MenuPopUp( void *data, int xpos, int ypos, int size, int
     seen, int item, int mode);

 PARAMETRES

      data:            les donn‚es du popup (voir le mode P_LIST),

      xpos, ypos:      position o— l'on affiche le menu,

      size:            indique le nombre d'entr‚e pour le mode
                       P_LIST,

      seen:            indique le nom d'entr‚e vue dans le popup en
                       mode P_LIST, les autres entr‚es sont
                       accessible par scroll,

      item:            la position du popup sera calcul‚ de maniŠre
                       telle que l'entr‚e item du popup coincidera
                       avec les coordonn‚es (x,y),

      mode:            masque de bit:

                        P_RDRW Ce bit fixe la fa‡on dont sera
                            redessinner l'arriŠre plan du popup apres
                            la sortie.
                            0 = La portion d'‚cran est sauvegard‚ en
                            m‚moire, puis restorer … la sortie. Ce
                            mode est conseill‚ lorsqu'on appelle le
                            pop-up par dessus une zone non redessin‚e
                            par l'AES ( par exemple, un formulaire
                            GEM).
                            1 = un simple message de REDRAW est
                            envoy‚ … l'AES. Ce mode est conseill‚
                            lorsque les zones cach‚s par le pop-up
                            sont des fenˆtres ou le bureau.


                        P_WNDW Ce bit indique que le popup sera
                            affich‚ dans une fenˆtre. La gestion est
                            assur‚ par une boucle sur les evenements
                            de l'AES par le biais de la fonction
                            EvntWindom(). Ainsi, l'AES n'est plus
                            bloqu‚ pendant le popup, les autres
                            applications peuvent continuer … afficher
                            leur sortie sur l'‚cran.

                        P_RGTH Ce bit permet de g‚rer le popup par le
                            bouton droit de la souris.

                        P_LIST Ce bit indique que data doit pointer
                            sur une liste de chaŒne de caractŠre au
                            lieu de l'adresse d'une arborescence
                            d'objet.

      valeur retourn‚e: index de l'entr‚e du menu s‚lectionn‚ ou -1
                       si rien n'a ‚t‚ s‚lectionn‚.

 DESCRIPTION
     Cette fonction permet d'afficher un popup et de gŠrer les
     ‚lements qui le compose. Au retour, la fonction donne l'‚ventuel
     ‚l‚ment s‚lectionn‚.

     MenuPopUp() accepte soit une arborescence d'objet soit une liste
     de nom c'est-…-dire un pointeur de type "char *ptxt[]". Dans le
     second cas, il faut sp‚cifier le nombre d'‚lement de la liste
     par le paramŠtre size. Le paramŠtre seen ne fonctionne pas
     encore dans cette version de la librairie. Dans cette version de
     WinDom, MenuPopUp() s'arrange, si la taille de la liste d‚passe
     celle du bureau, se formater la liste en plusieurs colonnes.

     MenuPopUp() possŠde un mode (P_WNDW) pr‚emptif qui ne bloque pas
     l'AES. Ce mode est trŠs recommand‚ pour les systŠmes
     multitƒches.

     La s‚lection des ‚lements se fait par la souris ou par la touche
     flŠche-bas qui fait d‚filer vers le bas la s‚lection. Enfin,
     l'utilisation de la souris se fait indiff‚remment avec la souris
     enfonc‚e ou relach‚e (ce qui n'‚tait pas le cas pour les
     anciennes versions de la librairie o— un flag de mode sp‚cifiait
     si la souris devait ˆtre maintenue enfonc‚ ou relach‚. Ce mode
     (P_EXIT) n'existe plus).


6.8  WindSet() avec le mode WF_MENU
===================================

 PROTOTYPAGE
     int WindSet( WINDOW *win, WF_MENU, OBJECT *menu, void
     (*func)(WINDOW *));

 PARAMETRES

      win:  fenˆtre concern‚,

      menu: adresse du menu … inscrust‚ dans la fenˆtre ou NULL pour
            retirer le menu,

      func: adresse de la fonction g‚rant les selections du menu.

 DESCRIPTION
     Cette fonction sert … incruster une barre de menu dans une
     fenˆtre. Si le paramŠtre menu vaut NULL, le menu est enlev‚ de
     la fenˆtre. La fonction func est la fonction appel‚ par
     EvntWindom() lorsqu'un message WM_MNSELECTED est ‚mis ce qui
     signifie qu'un menu dans une fenˆtre a ‚t‚ sollicit‚. Pour
     installer le menu du bureau, il faut utiliser la fonction
     MenuBar(). Le menu incrust‚ est automatiquement dupliqu‚ en
     m‚moire (avec ObjcDup()) cela pour ‚viter les conflict de
     position du menu lorsque plusieurs fenˆtres utilisant le mˆme
     menu sont ouverte. La m‚moire allou‚ est lib‚r‚ lors de la
     destruction de la fenˆtre (par WindDelete()) ou si l'on retire
     le menu de la fenˆtre avec WindSet().

 VOIR AUSSI
     WindSet(), MenuBar(), ObjcDup().



Chapitre 7

Librairie fenˆtre
*****************


7.1  WindCreate()
=================

 NOM
     WindCreate - Cr‚ation d'un descripteur de fenˆtre.

 PROTOTYPAGE
     WINDOW *WindCreate( int attrib, int x, int y, int w, int h);

 PARAMETRES
     Les paramŠtres ont la mˆme signification que la fonction AES
     wind_create(). WindCreate() retourne non pas un handle de la
     fenˆtre mais une structure qui est un descripteur de la fenˆtre.

     Ce descripteur joue le mˆme r“le dans WinDom que le handle dans
     l'AES, c'est-…-dire que tout ce qui ce rapporte … une fenˆtre
     utilise ce descripteur plut“t que le handle.

     L'attribut SMALLER pour l'ic“nification est disponible pour
     toutes les version de l'AES, si seul les versions de l'AES
     post‚rieur … la 4.00 permettent l'utilisation du gadget
     ic“nifieur, l'ic“nification reste possible en shift cliquant sur
     le closer.

     WinDom gŠre ‚galement le message WM_BOTTOMED quelquesoit la
     version de l'AES. Toutefois pour l'AES ne le gerant pas, il
     suffit de shift cliquer sur la barre de d‚placement pour envoyer
     la fenˆtre en arriŠre plan.

 LE ROLE DE WINDCREATE
     Cette fonction remplace completement wind_create(). Mais que
     fait-elle justement? Trois choses principales:

       1. elle cr‚‚ le descripteur de la fenˆtre et l'insŠre dans une
          liste chaŒn‚e ( voir la variable globale wgbl et
          AddWindows()).

       2. elle cr‚‚ la fenˆtre.

       3. enfin elle initialise le descripteur de la fenˆtre , en
          particulier, elle attribut tous les poŒnteurs de fonction
          du descripteur … des fonction standart de gestion des
          ‚venements.

     Ce dernier point est tr‚s important puisque c'est la-dessus que
     ce repose tout le systŠme pour g‚rer tr‚s simplement les
     fenˆtres. En effet, … chaque ‚venement correspond une fonction
     propre … chaque fenˆtre. Ce sont ces fonction qui seront appel‚
     par EvntWindom() … chaque r‚ception d'un ‚venement. Par exemple,
     si EvntWindom() intercepte le message WM_REDRAW, alors elle
     d‚clenche la fonction poŒnt‚ par win->redraw (si win est la
     fenˆtre concern‚ (voir EvntWindom()).

     Bien s–r ces fonctions standarts ne pr‚voient pas tout et si
     vous d‚sirez changer le comportement de v“tre fenˆtre pour tel
     ‚venement, il vous suffit d'‚crire une routine g‚rant cel… et de
     l'affecter au bon champ du descripteur de fenˆtre. Mais la
     plupart du temps, ces comportements sont fixes, et il suffit
     d'‚crire que la routine de dessin et la routine de destruction
     de la fenˆtre.

 LES ROUTINES STANDARTS
     Voi‡i la description des routines standarts que WindCreate()
     donnent aux fenˆtres:


+-----------+--------------+--------------+---------------------------------+
|    Nom    |    WINDOW    |  Evenement   | Description                     |
+-----------+--------------+--------------+---------------------------------+
| WindClear |    redraw    |   M_REDRAW   | Redessinne en blanc le fond de  |
|           |              |              | la fenˆtre.                     |
|  std_cls  |    closed    |   M_CLOSED   | envoi un message WM_DESTROY     |
| std_dstry |   destroy    |  M_DESTROY   | Ferme et d‚truit la fenˆtre     |
|           |              |              | avec WindClose() et             |
|           |              |              | WindDelete(). Elle emet aussi   |
|           |              |              | un message AP_TERM.             |
|  std_tpd  |    topped    |   M_TOPPED   | Met en premier plan la fenˆtre  |
|           |              |              | avec WindSet(,WF_TOP,)          |
|  std_mvd  |    moved     |   M_MOVED    | Place la fenˆtre … la position  |
|           |              |              | requise, win->fullsize vaut 0.  |
|  std_szd  |    sized     |   M_SIZED    | Donne la nouvelle taille a la   |
|           |              |              | fenˆtre. Met a jour les varia-  |
|           |              |              | bles de gestion des ascenseurs. |
|  std_fld  |    fulled    |   M_FULLED   | Selon la valeur de win->fulled, |
|           |              |              | donne l'ancienne taille, ou la  |
|           |              |              | taille pleine ‚cran.Met a jour  |
|           |              |              | les variables de gestion des    |
|           |              |              | ascenseurs.                     |
|  std_icn  |   conified   |  M_ICONIFY   | Ic“nifie la fenˆtre … la place  |
|           |              |              | requise avec WindSet(WF_ICONIFY |
|           |              |              | Communique la position suivante |
|           |              |              | d'ic“nification avec            |
|           |              |              | WindSet( ,WF_UNICONIFYXYWH, )   |
| std_unicn | uniconified  | WM_UNICONIFY | Desic“nifie la fenˆtre avec     |
|           |              |              | WindSet( , WF_UNICONIFY, )      |
|     -     | alliconified | WM_ALLICONFY | Il n'y a pas encore de routine  |
|           |              |              | standart pour ce message.       |
|     -     |      -       |  WM_ARROWED  | Toutes des fonctions de         |
|           |              |              | gestion des ‚venements WA_      |
|           |              |              | mettent … jour les variables    |
|           |              |              | de gestion des ascenseurs et    |
|           |              |              | envoit un message WF_REDRAW     |
|           |              |              | pour les pages ou font des      |
|           |              |              | copies d'‚cran et des appels    |
|           |              |              | directes de win->redraw clipp‚  |
|           |              |              | sur la liste des rectangles     |
|           |              |              | pour les fonctions de lignes.   |
| std_dnpgd |   dnpaged    |  WA_DNPAGE   |                                 |
| std_uppgd |   uppaged    |  WA_UPPAGE   |                                 |
| std_lfpgd |   lfpaged    |  WA_LFPAGE   |                                 |
| std_rtpgd |   rtpaged    |  WA_RTPAGE   |                                 |
| std_dnlnd |   dnlined    |  WA_DNLINE   |                                 |
| std_uplnd |   uplined    |  WA_UPLINE   |                                 |
| std_lflnd |   lflined    |  WA_LFLINE   |                                 |
| std_rtlnd |   rtlined    |  WA_RTLINE   |                                 |
| std_hsld  |   hslided    |   WM_HSLID   | Mise … jours des variables de   |
|           |              |              | gestion des ascenseurs et       |
|           |              |              | envoit du message WF_REDRAW     |
| std_vsld  |   vslided    |   WM_VSLID   | Idem                            |
|   NULL    |   clicked    |  MU_BUTTON   | Pas de fonction en standart     |
|   NULL    |   keyhited   |   MU_KEYBD   | Idem                            |
|   NULL    |    timed     |   MU_TIMER   | Idem                            |
|   NULL    |   extramsg   | Toute autre  | Idem                            |
|           |              |  ‚venement   |                                 |
+-----------+--------------+--------------+---------------------------------+

     (Tableau 7: Routines standarts attribu‚es par WindCreate())


 VOIR AUSSI
     WindOpen(), WindClose(), WindDelete(), WindClear(), WindSet(),
     WindGet(), WindSlider().


7.2  WindOpen()
===============

 NOM
     WindOpen - Ouverture d'une fenˆtre.

 PROTOTYPAGE
     int WindOpen( WINDOW *win, int x, int y , int w, int h);

 PARAMETRES
     Les paramŠtres sont les mˆmes que la fonction wind_open() sauf
     le paramŠtre win qui remplace le paramŠtre handle de
     wind_open(). La valeur retourn‚e est celle retourn‚ par
     wind_open(). Les variables x ou y peuvent valoir -1. Dans ces
     cas WindOpen() calcule x ou y de maniŠre … centrer
     horizontalement ou verticalement la fenˆtre.

     Exemple:

     		WindOpen( win, -1, 20, 400, 200);
     		WindOpen( win, -1, -1, 400, 200);

 DESCRIPTION
     WindOpen() remplace la fonction wind_open(). Elle met le bit
     WS_OPEN de win->status … 1. Notons ‚galement que si le bit
     WS_GROW de win->status vaut 1, WindOpen() appelle la fonction
     graf_growbox(). WindOpen() utilise les variables min_w, min_h,
     max_w, max_h du descripteur de la fenˆtre comme valeur limite
     pour w et h. Ces variables sont aussi utilis‚ par des fonctions
     standart gerant les changement de taille de la fenˆtre. Ces
     quatres variables ont une valeur par d‚faut fix‚ par
     WindCreate(). min_w et min_h sont fix‚ (arbitrairement) … 40
     pixels, max_w et max_h sont intialis‚ par les variables w et h
     pass‚ … la fonction WindCreate(). Vous pouvez modifier ces
     valeurs avant ou aprŠs l'appel … WindOpen().

     Remarque tr‚s importante:
     Pour les versions de l'AES ne supportant pas le message
     WM_BOTTOMED, WinDom gŠre sa propre liste de fenˆtre. Pour cela,
     WindOpen() insŠre le handle de la fenˆtre dans cette liste par
     l'interm‚diaire de la fonction add_windowlist(). Si pour une
     raison ou une autre, on pr‚fŠre utilis‚ wind_open(), il est
     imp‚ratif de faire appel … add_windowlist() sous peine de
     plantage. Si l'AES supporte le message WM_BOTTOMED, WinDom
     exploite directement l'AES pour ce message et la remarque ne
     s'applique plus.

     Mais de toute fa‡ons, il est recommand‚ d'utiliser WindOpen().

 VOIR AUSSI
     WindCreate(), WindClose(), WindDelete(), WindClear(), WindSet(),
     WindGet().


7.3  WindClose()
================

 NOM
     WindClose - fermeture d'une fenˆtre.

 PROTOTYPAGE
     int WindClose( WINDOW *win);

 PARAMETRES

      win:              descripteur de la fenˆtre,

      valeur retourn‚e: celle retourn‚e par wind_close().

 DESCRIPTION
     WindClose() remplace la fonction wind_close(). Elle ferme la
     fenˆtre avec un effet graf-grow si le bit WS_GROW de win->status
     est … 1. Elle met le bit WS_OPEN du mˆme champ … 0 et enlŠve la
     fenˆtre de la liste des fenˆtres pour l'‚mulation du message
     WM_BOTTOM.

     La mˆme remarque faite pour WindOpen() … propos de WM_BOTTOM est
     valable i‡i: pour les versions de l'AES ne supportant pas le
     message WM_BOTTON, WinDom utlise sa propre liste d'ordre de
     fenˆtres et WindClose() dans ce cas appelle la fonction
     remove_windowlist() pour retirer le handle de la fenˆtre de
     cette liste.

 VOIR AUSSI
     WindOpen(), WindCreate(), WindDelete(), WindClear() WindSet(),
     WindGet()


7.4  WindDelete()
=================

 PROTOTYPAGE
     int WindDelete( WINDOW *win);

 PARAMETRES

      win:              descripteur de la fenˆtre,

      valeur retourn‚e: La mˆme que celle de wind_delete().

 DESCRIPTION
     WindDelete() remplace wind_delete(). Notament, elle d‚truit le
     descripteur de la fenˆtre et retire ce descripteur de la liste
     chaŒn‚e des fenˆtres.

 VOIR AUSSI
     WindOpen(), WindClose(), WindCreate(), WindClear(), WindSet(),
     WindGet().


7.5  WindSet()
==============

 NOM
     WindSet - param‚trage des fenˆtres.

 PROTOTYPAGE
     void WindSet( WINDOW *win, int mode, ...);

 PARAMETRES

      win:  Le descripteur de la fenˆtre concern‚e,

      mode: voir MODE DE WINDSET,

      ...:  d‚pend de la valeur de mode.

 DESCRIPTION
     Cette fonction avec WindGet(), remplace wind_set(). Cela permet
     a Windom d'int‚grer ses proprements modifications de l'AES. Par
     exemple, Windom gŠre l'ic“nification des fenˆtres de la mˆme
     fa‡on que l'AES 4.00 la diff‚rence est que la fonctionne pour
     toutes les version de l'AES. Ainsi, la programmation sous Windom
     ressemble a celle sous GEM. Sauf cas tr‚s exeptionnel, on
     passera toujours par WindSet().

 MODE DE WINDSET
     I‡i nous d‚taillons les diff‚rents modes de WindSet() et les
     diff‚rences avec ceux de wind_set().


+-----------------+---------------------------------+-------------------------+
|      Mode       | Description                     | Commentaires            |
+-----------------+---------------------------------+-------------------------+
|     WF_NAME     | Fixe le nom de la fenˆtre dans  | L'AES4.1 ne distingue   |
|                 | parm1 et parm2. Si la fenˆtre   | qu'un seul nom de       |
|                 | est iconifi‚e, cela fixe le nom | fenˆtre. Windom gŠre    |
|                 | de l'ic“ne sans changer le vrai | les deux noms qqsoit    |
|                 | nom de la fenˆtre.              | la version de l'AES.    |
+-----------------+---------------------------------+-------------------------+
|     WF_INFO     | Fixe la barre d'info dans parm1 |                         |
|                 | et parm2.                       |                         |
+-----------------+---------------------------------+-------------------------+
|   WF_WORKXYWH   | Fixe la taille de travail dans  | WindSet() prend en      |
|                 | parm1, parm2, parm3, parm4      | consid‚ration le        |
|                 |                                 | menu et le toolbar      |
+-----------------+---------------------------------+-------------------------+
|     WF_TOP      | Met en premier plan la fenˆtre. | Si AES<4.1 WindSet      |
|                 | Si win vaut NULL, parm1 doit    | met a jour une liste    |
|                 | contenir le handle de la        | de cycle de fenˆtre.    |
|                 | fenˆtre … topper.               |                         |
+-----------------+---------------------------------+-------------------------+
|    WF_BEVENT    | RŠgle certains comportement de  | Le mode B_UNTOPPABLE    |
|                 | la fenˆtre. parm1 est un masque | est support‚ … partir   |
|                 | de bit:                         | de l'AES 3.4. Pour      |
|                 | B_UNTOPPABLE (0x0001) rend la   | les AES ant‚rieurs,     |
|                 | fenˆtre untoppable.             | WinDom ‚mule ce mode    |
|                 | B_MODAL (0x1000) rend la        | le mode B_MODAL est     |
|                 | fenˆtre modale.                 | une extension           |
|                 | Les fenˆtres untoppables ont le | sp‚cifique de WinDom.   |
|                 | bit WS_UNTOPPABLE dans          |                         |
|                 | win->status et les fenˆtres     |                         |
|                 | modales le bit WS_MODAL.        |                         |
+-----------------+---------------------------------+-------------------------+
|    WF_BOTTOM    | Met la fenˆtre derriŠre les     | Si AES<4.1,             |
|                 | autres.                         | Windom utilise sa       |
|                 |                                 | liste de cycle de       |
|                 |                                 | fenˆtre. Sinon,         |
|                 |                                 | l'appel est direct      |
|                 |                                 | a wind_set().           |
+-----------------+---------------------------------+-------------------------+
|   WF_ICONIFY    | Ic“nifie la fenˆtre aux         | Windom gŠre             |
|                 | coordonn‚es donn‚es par parm1,  | l'ic“nification         |
|                 | parm2, parm3, parm4 ( ces       | quelquesoit la          |
|                 | valeurs sont donn‚es dans le    | version de l'AES.       |
|                 | message WM_ICONIFY).            | Si l'AES ne gŠre        |
|                 |                                 | pas cet ‚lement,        |
|                 |                                 | WinDom l'‚mule.(*)      |
+-----------------+---------------------------------+-------------------------+
|  WF_UNICONIFY   | Desic“nifie la fenˆtre aux      | Mˆme remarque que       |
|                 | coordonn‚es donn‚es par parm1,  | pr‚cedemment.           |
|                 | parm2, parm3, parm4 ( ces       |                         |
|                 | valeurs sont donn‚es dans le    |                         |
|                 | message WM_UNICONIFY).          |                         |
| WF_UNICONIFXYWH | parm1,.., parm4 fixe les        | Mˆme remarque que       |
|                 | coordonn‚es de la fenˆtre       | pr‚cedemment.           |
|                 | desic“nifi‚e. Dans le cas d'une |                         |
|                 | fenˆtre qui est ouverte dans un |                         |
|                 | ‚tat iconifi‚, ce mode indique  |                         |
|                 | … l'AES quelle coordonn‚es sont |                         |
|                 | … donner dans le prochain       |                         |
|                 | messahe WF_UNICONIFY concernant |                         |
|                 | cette fenˆtre.                  |                         |
+-----------------+---------------------------------+-------------------------+
|   WF_TOOLBAR    | Impose un toolbar dans une      | Windom gŠre le          |
|                 | fenˆtre. parm1 et parm2         | toolbar quelquesoit     |
|                 | contiennent l'adresse du menu.  | la version de l'AES.    |
|                 | parm3 et parm4 contiennent      | La fonction de gestion  |
|                 | l'adresse de la fonction de     | est propre a WinDom     |
|                 | gestion du menu, ou NULL pour   |                         |
|                 | retirer le toolbar.             |                         |
|   WF_FTOOLBAR   | Equivalent de WF_FIRSTXYWH      | Attention: Windom       |
|                 | pour le toolbar. parm1, ...     | calcule l'intersection  |
|                 | parm4 contiennent les           | entre le 1er rectangle  |
|                 | coordonn‚es du rectangle.       | et la fenˆtre. Cette    |
|                 |                                 | fonction ne peut ˆtre   |
|                 |                                 | appel‚e par une routine |
|                 |                                 | de redraw.              |
|   WF_NTOOLBAR   | Equivalent de WF_NEXTXYWH       | Mˆme remarque, si ce    |
|                 | pour le toolbar. parm1, ...     | n'est qu'on utilise le  |
|                 | parm4 contiennent les           | rectangle suivant de    |
|                 | coordonn‚es du rectangle.       | l'AES.                  |
+-----------------+---------------------------------+-------------------------+
|     WF_MENU     | Impose un menu dans une fenˆtre | Ce mode est un          |
|                 | parm1 et parm2 contiennent      | additif par rapport     |
|                 | l'adresse du menu, parm3 et     | wind_set() et l'AES 4   |
|                 | parm4 l'adresse de la routine   |                         |
|                 | de gestion du menu ou NULL      |                         |
+-----------------+---------------------------------+-------------------------+
|   WF_PREVXYWH   |                                 |                         |
|   WF_CURRXYWH   | TOUS CES MODES FONT DIRECTEMENT |                         |
|  WF_FIRSTXYWH   | APPEL A wind_set()              |                         |
|   WF_NEXTXYWH   |                                 |                         |
|   WF_NEWDESK    |                                 |                         |
|    WF_COLOR     |                                 |                         |
|    WF_DCOLOR    |                                 |                         |
|    WF_OWNER     |                                 |                         |
|    WF_SCREEN    |                                 |                         |
|    WF_HSLIDE    | Pour ces 4 modes, voir          |                         |
|    WF_VSLIDE    | WindSlider()                    |                         |
|   WF_HSLSIZE    |                                 |                         |
|   WF_VSLSIZE    |                                 |                         |
+-----------------+---------------------------------+-------------------------+

                 (Tableau 8: Les modes de WindSet())


     Remarque sur les Toolbar et les menus en fenˆtre
     Il est inutile de redessinner les toolbar ou les menus car
     EvntWindom() s'en charge. Par cons‚quent, les modes WF_FTOOLBAR
     et WF_NTOOLBAR sont un peu inutiles mais il sont la pour une
     compatibilit‚ maximun avec wind_set(). D'autre part les menus et
     les toolbar sont dupliquer en m‚moire avec la fonction ObjcDup()
     pour permettre d'afficher plusieurs fenˆtres avec les mˆmes
     menus ou toolbar. La fonction WindDelete() libŠre par un appel …
     la fonction ObjcFree() la m‚moire allou‚e. L'AES 4.1 gŠre lui
     aussi les ToolBars mais pas de fa‡on complŠte. Aussi, Windom
     utilise sa propre gestion de ToolBar mˆme sous AES 4.1.

 VOIR AUSSI
     WindGet(), WindSlider().


7.6  WindGet()
==============

 NOM
     WindGet() - informations sur une fenˆtre.

 PROTOTYPAGE
     void WindGet( WINDOW *win, int mode, ...);

 PARAMETRES

      win:  fenˆtre concern‚e,

      mode: type d'information,

      ...:  varie selon la valeur de mode.

 DESCRIPTION
     WindGet() remplace la fonction AES wind_get(). Elle travaille
     conjointement avec WindSet(). Elle retourne toute les
     informations pour une fenˆtre tenant compte des nouvelles
     caract‚ristiques de WinDom.

 MODE
     a finir ...

 VOIR AUSSI
     WindSet().


7.7  WindSlider()
=================

 PROTOTYPAGE
     void WindSlider( WINDOW *win, int slider);

 PARAMETRES

      win:    descripteur de la fenˆtre concern‚e,

      slider: mask de bit sur le slider … r‚actualiser:

               HSLIDER slider horizontal,

               VSLIDER slider vertical.

 DESCRIPTION
     WindSlider() met … jour les sliders en fonctions des valeurs des
     variables xpos, ypos, xpos_max, ypos_max, h_u et w_u du
     descripteur de la fenˆtre.

 LES VARIABLES
     xpos indique la position horizontale relativement … la fenˆtre,
     sa valeur varit entre 0 et xpos_max qui doit ˆtre sup‚rieur
     strict ypos, ypos_max jouent les mˆmes r“les pour la position
     verticale h_u, w_u indiquent respectivement en pixel le d‚calage
     vertical et horizontal du contenu de la fenˆtre.

 UTILISATION
     Pour le traitement des ‚venements de scroll de la fenˆtre, son
     appel est inutile puisqu ce sont les fonctions standarts de
     gestions des ‚venments qui s'en chargent. Par contre, si les
     valeurs des variables d‚critent plus haut sont modifi‚, il faut
     appeler WindSlider() pour mettre … jour les sliders.


7.8  WindCalc()
===============

 NOM
     WindCalc - convertion de coordonn‚es de fenˆtre.

 PROTOTYPAGE
     int WindCalc( int type, WINDOW *win,
     int xin, int yin, int win, int hin,
     int *xout, int *yout, int *wout, int *hout);

 PARAMETRES

      type:             voir wind_calc(),

      win:              fenˆtre concern‚,

      xin, ..., hout:   voir wind_calc(),

      valeur retourn‚e: celle retourn‚e par wind_calc().

 DESCRIPTION
     Cette fonction remplace la fonction AES wind_calc(). Elle tient
     compte de la pr‚sence ‚ventuelle de menu ou de toolbar.

 VOIR AUSSI
     wind_calc().


7.9  WindHandle()
=================

 NOM
     WindHandle - recherche de descripteur de fenˆtre.

 PROTOTYPAGE
     WINDOW *WindHandle( int handle);

 PARAMETRES

      handle:           handle d'une fenˆtre,

      valeur retourn‚e: le descripteur de la fenˆtre correspondante.

 DESCRIPTION
     Cette fonction retourne le descripteur correspondant … un handle
     de fenˆtre ou NULL, si ce descripteur n'existe pas ou si la
     fenˆtre n'appartient pas … n“tre application.


7.10  add_windowlist()
======================

 NOM
     add_windowlist() - gestion de la liste des fenˆtres.

 PROTOTYPAGE
     void add_windowlist( int handle);

 PARAMETRES
     handle: handle d'une fenˆtre … ins‚rer dans la liste.

 DESCRIPTION
     Cette fonction sert … g‚rer une liste d'ordonnance de fenˆtre.
     Cette liste est utilis‚ par WinDom pour g‚rer les messages
     WM_BOTTOM lorsque l'AES ne sait pas le faire (AES<4.0). Son
     utilisation est donc inutile sur les systŠme supportant le
     message WM_BOTTOM.

     Cette fonction ne s'applique pas vos fenˆtre car elle est d‚j…
     appel‚ par WindOpen(). Par contre vous pouvez l'utiliser pour
     inclure dans cette liste des fenˆtres d'autres applications, des
     accesoires par exemple. Malheureusement les AES n'implementant
     pas le message WM_BOTTOM ne sont pas capables d'identifier des
     fenˆtres autres que celle de nos applications. Toutefois, avec
     les applications utilisant le protocole AV ( ou d'autres
     protocoles tel que le tube GEM), il est possible de r‚cuperer
     les handles de leurs fenˆtres pour les ins‚rer dans notre liste.

 EXEMPLE


 VOIR AUSSI
     remove_windowlist(), appl_getinfo(), WindSet() et WindGet() avec
     le mode WF_BOTTOM.


7.11  remove_windowlist()
=========================

 NOM
     remove_windowlist() - gestion de la liste des fenˆtres.

 PROTOTYPAGE
     void remove_windowlist( int handle);

 PARAMETRES
     handle: handle d'une fenˆtre … retirer de la liste.

 DESCRIPTION
     Cette fonction enlŠve un handle de fenˆtre de la liste
     d'ordonnnace. Cette fonction doit ˆtre utilis‚ lorsqu'une
     fenˆtre de cette liste est ferm‚, mais elle ne s'applique pas
     aux fenˆtres ouverte par WinDom car la fonction WindClose() s'en
     charge. Elle ne concerne que les autres fenˆtres de cette liste.

 VOIR AUSSI
     add_windowlist().


7.12  WindClear()
=================

… faire ...


7.13  AddWindows()
==================

 NOM
     AddWindow - Gestion de la liste des fenˆtres

 PROTOTYPAGE
     void AddWindow( WINDOW *win)

 PARAMETRE
     win: le descripteur de la fenˆtre … ajout‚.

 DESCRIPTION
     Cette fonction n'est utilis‚ que dans le cas trŠs pr‚cis ou vous
     desirez cr‚er un descripteur de fenˆtre sans utiliser
     WindCreate(). Cette fonction ajoute le descripteur de fenˆtre
     dans la liste des fenˆtres de WinDom. Voyez l'implementation de
     WindCreate() pour bien comprendre la d‚marche … suivre pour
     cr‚er correctement un descripteur de fenˆtre. Dans tous les
     autres cas on utilisera JAMAIS cette fonction car WindCreate()
     doit suffire pour les cas g‚n‚raux.

 VOIR AUSSI
     WindCreate()


7.14  RemoveWindows()
=====================

 NOM
     RemoveWindow - Gestion de la liste des fenˆtres

 PROTOTYPAGE
     void RemoveWindow( WINDOW *win)

 PARAMETRE
     win: le descripteur de la fenˆtre … enlev‚.

 DESCRIPTION
     Cette fonction n'est utilis‚ que dans le cas trŠs pr‚cis ou vous
     desirez d‚truire un descripteur de fenˆtre sans utiliser
     WindDelete(). Cette fonction retire le descripteur de fenˆtre
     dans la liste des fenˆtres de WinDom. Voyez l'implementation de
     WindDelete() pour bien comprendre la d‚marche … suivre pour
     cr‚er correctement un descripteur de fenˆtre. Dans tous les
     autres cas on utilisera JAMAIS cette fonction car WindDelete()
     doit suffire pour les cas g‚n‚raux.

 VOIR AUSSI
     WindDelete()



Chapitre 8

Librairie frame
***************


8.1  FrameCreate()
==================

 NOM
     FrameCreate() - Cr‚ation d'une fenˆtre frame.

 PROTOTYPAGE
     WINDOW *FrameCreate( int attrib);

 PARAMETRES

      item:   attribut GEM de la fenˆtre,

      valeur retourn‚e: descripteur de la fenˆtre cr‚‚.

 DESCRIPTION
     Cette fonction cr‚e une fenˆtre frame et retourne son
     descripteur. La fenˆtre n'est pas ouverte. Elle contiendra
     d'autres frames attribu‚ avec FrameAttach(). Outre les
     param‚trages standarts des fenˆtres de WinDom fix‚ avec
     WindSet(), des param‚tres exclusifs aux fenˆtres frames peuvent
     ˆtre fix‚ avec FrameSet(). La fenˆtre possŠde en outre le bit
     WS_FRAME_ROOT dans son champ status et son champ data poŒnte
     vers une structure FRAME.

 PRINCIPE
     Les routines de gestions d'‚venement de la fenˆtre utilisent
     directement celle des frames que la fenˆtre contient. Certaines
     routines utilisent la frame active. C'est la frame poŒnt‚ par le
     champ front de la structure FRAME. On peut utiliser FrameSet()
     pour indiquer quelle frame doit ˆtre utilis‚. La fonction de
     gestion de la fenˆtre frame

     faire un tableau r‚capitulatif des routines ...

 BUGS


        ù Les gadgets ne pas correctement positionn‚,

        ù le look des gadgets n'est pr‚vu que pour MagiC pour le
          momment,

        ù les sliders sont mal initialis‚s.

        ù la gestion des barres de s‚paration n'est pas termin‚.

 VOIR AUSSI
     FrameAttach(), FrameSet().


8.2  FrameAttach()
==================

 NOM
     FrameAttach() - d‚clarations des frames.

 PROTOTYPAGE
     void FrameAttach( WINDOW *win, WINDOW *frame, int line, int col,
     int w, int h, int mode);

 PARAMETRES

      win:       descripteur de la fenˆtre mŠre,

      frame:     descripteur de la frame … attacher,

      line, col: cellule qui contiendra la frame,

      w, h:      taille de la frame,

      mode:      mode de la frame.

 DESCRIPTION
     Cette fonction incruste une fenˆtre comme une frame dans une
     fenˆtre frame. La fenˆtre frame est enlev‚ de la liste des
     fenˆtres de WinDom. Son champ status possŠde le bit WS_FRAME.
     Les fenˆtres frames sont organis‚ en ligne de cellules. Chaque
     ligne peut poss‚der un nombre variable de cellule. Les variables
     (line, col) attribuent la frame a la cellule (line, col). La
     variable mode fixent les flags de la frame (voir FrameSet()). La
     taille de la frame est donn‚ par (w, h). Cette taille peut ˆtre
     absolue (en pixel) ou relative en pourcentage de la taille de la
     fenˆtre mŠre (voir FrameSet()). La frame cr‚‚ utilisera les
     attributs GEM de frame. Les attributs possibles pour les frames
     sont: INFO, SIZER, HSLIDE, VSLIDE, UPARROW, DNARROW, LFARROW et
     RTARROW. Les autres attributs sont ignor‚s.

 VOIR AUSSI
     FrameCreate(), FrameSet(), FrameRemove().


8.3  FrameRemove()
==================

 NOM
     FrameRemove() - EnlŠve une frame d'une fenˆtre.

 PROTOTYPAGE
     WINDOW *FrameRemove( WINDOW *win, WINDOW *frame, int line, int
     col);

 PARAMETRES

      win:       fenˆtre de frame,

      frame:     frame concern‚e ou NULL

      line, col: cellule concern‚e,

      valeur retourn‚e: descripteur de la frame enlev‚e.

 DESCRIPTION
     Cette fonction enlŠve une frame d'une fenˆtre frame. La frame
     enlev‚e redevient une fenˆtre standart. Si frame  vaut NULL,
     alors la frame a enlever est celle occup‚ par la celulle (line,
     col).

 VOIR AUSSI
     FrameAttach().


8.4  FrameSet()
===============

 NOM
     FrameSet() - Param‚trage des frames.

 PROTOTYPAGE
     void FrameSet( WINDOW *win, int mode, ...);

 PARAMETRES

      win:          fenˆtre ou frame concern‚e,

      mode:         param‚tres … fixer,

      ...:          paramŠtres d‚pendant de mode.

 DESCRIPTION
     Cette fonction fixe les paramŠtres des fenˆtres frames et des
     frames. Voi‡i la liste des mode de FrameSet() et leur
     signification.


+--------------+---------------+-----------------------------+-----------------+
| Mode         | Status        | Paramˆtres                  | Remarques       |
+--------------+---------------+-----------------------------+-----------------+
| FRAME_BORDER | WS_FRAME_ROOT | parm1: ‚paisseur du bord    | en pixel        |
| FRAME_COLOR  | WS_FRAME_ROOT | parm1: couleur du fond      | en index vdi    |
| FRAME_KEYBD  | WS_FRAME_ROOT | parm1=MOUSE_WINDOW: la      | D‚fini le mode  |
|              |               | frame point‚ par la souris  | d'attribution   |
|              |               | re‡oit l'‚venement clavier. | des ‚v‚nements  |
|              |               | parm1=FRONT_WINDOW: la      | MU_KEYBD aux    |
|              |               | frame active re‡oit         | frames.         |
|              |               | l'‚venement.                |                 |
| FRAME_ACTIVE | WS_FRAME_ROOT | parm1 est l'adresse du      | rend une frame  |
|              |               | descripteur de frame …      | active.         |
|              |               | rendre actif.               |                 |
| FRAME_TOPP-  | WS_FRAME_ROOT | parm1: TRUE ou FALSE        | une frame topp‚ |
| ED_ACTIV     |               |                             | devient active  |
+--------------+---------------+-----------------------------+-----------------+
| FRAME_SIZE   | WS_FRAME      | parm1 et parm2: taille      | voir FLAGS      |
|              |               | de la frame                 |                 |
| FRAME_FLAGS  | WS_FRAME      | parm1: flags a fix‚         | Voir plus bas   |
|              |               | parm2: 1 met le bit a 1     | les valeurs     |
|              |               | 0 met le bit a 0            | possible.       |
+--------------+---------------+-----------------------------+-----------------+

             (Tableau 9: Mode de la fonction FrameSet())


     Voici un tableau regroupant les flags des frames.


 +----------------+-------------------------------------------------+
 | FLAGS          | Descriptions                                    |
 +----------------+-------------------------------------------------+
 | FRAME_HSCALE   | La hauteur de la frame est defini               |
 |                | proportionnellement ( en %).                    |
 | FRAME_WSCALE   | La largeur de la frame est defini               |
 |                | proportionnellement ( en %).                    |
 | FRAME_HFIX     | La hauteur de la frame n'est pas modifiable.    |
 | FRAME_WFIX     | La largeur de la frame n'est pas modifiable.    |
 | FRAME_NOBORDER | Le cadre n'est pas dessinn‚ autour de la frame. |
 | FRAME_SELECT   | La frame est activable.                         |
 +----------------+-------------------------------------------------+

   (Tableau 10: Flags des frames (mode FRAME_FLAGS de FrameSet()))



8.5  FrameFind()
================

 NOM
     FrameFind() - recherche de frame.

 PROTOTYPAGE
     WINDOW *FrameFind( WINDOW *win, int x, int y);

 PARAMETRES

      win:  fenˆtre frame concern‚e,

      x, y: coordonn‚es de la souris,

      valeur retourn‚e: descripteur de la frame point‚ par (x,y).

 DESCRIPTION
     Cette fonction cherche le descripteur de la frame point‚ par
     (x,y) dans la fenˆtre frame win.

 VOIR AUSSI
     FrameSearch().


8.6  FrameSearch()
==================

 NOM
     FrameSearch() - Recherche de frame

 PROTOTYPAGE
     WINDOW *FrameSearch( WINDOW *win, int line, int col);

 PARAMETRES

      win:       descripteur de la fenˆtre frame,

      line, col: position de la cellule,

      valeur retourn‚e: descripteur de la frame associ‚ … la cellule.

 DESCRIPTION
     Retourne le descripteur de la frame associ‚ a la cellule
     (line,col) dans la fenetre frame win.

 VOIR AUSSI
     FrameFind().


8.7  FrameCalc()
================

 NOM
     FrameCalc() - Calcul de la zone de travail d'une frame.

 PROTOTYPAGE
     int FrameCalc( WINDOW *win, int mode, int *x, int *y, int *w,
     int *h);

 PARAMETRES

      win:     descripteur de la frame concern‚e,

      mode:    zone courante (1) ou zone de travail (0),

      x,y,w,h: adresse des coordonn‚es de la zone,

      valeur retourn‚e: 0 si pas d'erreur.

 DESCRIPTION
     Cette fonction calcule la zone courante ou de travail d'une
     frame. La zone courante inclue les gadgets de la frame et la
     zone de travail. A moins de travailler sp‚cifiquement sur des
     frames, il vaut mieux utiliser WindGet() qui retourne, elle
     aussi la zone de travail (WF_WORKXYWH) ou courante (WF_CURRXYWH)
     d'une frame. Avec WindGet() les routines de gestion d'‚venements
     de fenˆtre seront compatible pour une fenˆtre ou une frame.

 VOIR AUSSI
     WindGet().



Chapitre 9

Librairie ‚venement
*******************


9.1  EvntWindom()
=================

 NOM
     EvntWindom - gestion des ‚venements.

 PROTOTYPAGE
     int EvntWindom( int event);

 PARAMETRES

      event:            Mask de bit des ‚v‚nements … surveiller,

      valeur retourn‚e: l'‚venement d‚tect‚.

 DESCRIPTION
     Cette fonction remplace evnt_multi(). Le choix du nom n'est pas
     EvntMulti() car cette derniŠre fait partit de la librairie GEM
     de Pure C.

     Cette fonction constitue le point central de Windom. En effet,
     c'est elle qui fait fonctionner l'ensemble de la librairie.
     Voyons donc son fonctionnement en d‚tail.

     En premier lieu, EvntWindom() appelle la fonction evnt_multi()
     en utilisant les champs de la variable evnt. Cette derniŠre est
     une variable globale, c'est une structure donc les ‚l‚ments
     correspondent aux paramŠtres attendu par evnt_multi().

     Ensuite, EvntWindom() applique la palette de la fenˆtre frontale
     … l'‚cran ou la palette par d‚faut (celle du bureau) si
     l'application n'a pas de fenˆtre frontale.

     Viens la gestion des messages. Si un message est d‚tect‚,
     EvntWindom() ‚xecute la routine de gestion de cet ‚venement de
     la fenˆtre frontale. Si la routine est NULL, il ne se passe
     rien.

     Ensuite, EvntWindom() d‚clenche la routine de gestion de clavier
     pour un ‚venement MU_KEYBD de la fenˆtre frontale ou la routine
     de gestion des click souris, timer etc ...

     EvntWindom() s'occupe ‚galement de l'ic“nification, des fenˆtres
     untoppables, des menus et des toolbars en fenˆtres, des
     formulaires en fenˆtres, des racourcis claviers pour le menu de
     l'application et les menus des fenˆtres, et enfin du menu pop-up
     systŠme. EvntWindom() utlise les ‚venements MU_KEYDB et
     MU_BUTTON pour r‚aliser cel…, fait le travail, et emet des
     nouveaux messages.

     Les s‚lections de menu, toolbar, les click dans les fenˆtres
     formulaires, les raccour‡is claviers etc ... deviennent des
     ‚vemenents MU_MESAG.

 NOUVEAUX MESSAGES
     Consid‚rons l'appel suivant:

     res = EvntWindom( MU_MESAG);

     Normalement, EvntWindom() ne d‚tecte que les ‚venements de type
     messages tels que agrandir une fenˆtre, etc ... Mais elle
     intercepte aussi les click souris dans un formulaire et en fait
     un message. Pareil pour les raccour‡is claviers etc... Par
     contre les routines de gestion des claviers, timer et bouton ne
     seront jamais d‚clench‚.

     Voi‡i la liste des nouveaux messages de WinDom:

     WM_DESTROY - destruction de fenˆtre
     Une fenˆtre doit ˆtre d‚truite. L'origine probable est qu'une
     routine de fermeture de la fenˆtre … envoy‚ ce message. Ou
     encore, il peut faire suite a un message AP_TERM qui demande la
     terminaison du programme.

         evnt.buff[0] = WM_DESTROYED
         evnt.buff[3] = handle de la fenˆtre

     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     win -> destroy de la fenˆtre si elle existe.

     WM_FORM - Formulaire en fenˆtre
     Un objet EXIT ou TOUCHEXIT d'un formulaire en fenˆtre … ‚t‚
     selectionn‚.

         evnt.buff[0] = WM_FORM
         evnt.buff[3] = handle de la fenˆtre
         evnt.buff[4] = index de l'objet
         evnt.buff[5] = ‚tat du clavier

     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     ((W_FORM*)win->data)->proc de la fenˆtre si elle existe.

     WM_MNSELECTED - menu en fenˆtre
     Un menu en fenˆtre a ‚t‚ s‚lectionn‚.

         evnt.buff[0] = WM_MNSELECTED
         evnt.buff[3] = handle de la fenˆtre
         evnt.buff[4] = titre du menu
         evnt.buff[5] = entr‚e du menu


     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     win->menu.proc de la fenˆtre si elle existe.

     WM_TOOLBAR - Toolbar
     Un objet EXIT ou TOUCHEXIT d'un toolbar a ‚t‚ s‚lectionn‚.

         evnt.buff[0] = WM_TOOLBAR
         evnt.buff[3] = handle de la fenˆtre
         evnt.buff[4] = index de l'objet
         evnt.buff[5] = ‚tat du clavier

     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     win->tool.proc de la fenˆtre si elle existe.

     WM_BOTTOM - fenˆtre en arriŠre plan
     Une fenˆtre doit ˆtre pass‚ en arriŠre-plan.

         evnt.buff[0] = WM_BOTTOM
         evnt.buff[3] = handle de la fenˆtre


     Lorsque EvntWindom() re‡oit ce message, il passe la fenˆtre en
     arriŠre plan en utilisant WindSet( , WF_BOTTOM, ). Si l'AES ne
     gŠre pas ce message, on peut le d‚clencher en shitf cliquant sur
     la barre de d‚placement de la fenˆtre. Pour le momment, il n'y a
     pas de routine sp‚cifique dans le descripteur de fenˆtre car
     j'ai remarqu‚ que l'AES n'envoit pas de message mais envoit
     directement la fenˆtre en arriŠre plan!

     Remarque:
     Ce message fonctionne quelquesoit la version de l'AES.
     Normalement, seul les versions 4.00 ou sup‚rieure gŠre ce
     message. Pour le cas ou l'AES ne gŠre pas ce message, winDom
     utilise sa propre liste de fenˆtre pour ‚muler ce message mais
     il ne s'applique qu'aux fenˆtres de l'application. Par contre il
     est possible d'ajouter ou de retirer des fenˆtres de cette
     liste. Cela permet d'y inclure par exemple les fenˆtres
     d'acc‚ssoires utilisant le protocole AV. Voir les fonctions
     add_windowlist() remove_windowlist() WindOpen() et WindClose().

     WM_ICONIFY - ic“nification
     Une fenˆtre doit ˆtre ic“nifi‚e.

         evnt.buff[0] = WM_ICONIFY
         evnt.buff[3] = handle de la fenˆtre
         evnt.buff[4] = coordonn‚e x
         evnt.buff[5] = coordonn‚e y
         evnt.buff[6] = coordonn‚e w
         evnt.buff[7] = coordonn‚e h

     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     win->iconify. Ce message est compatible avec celui de l'AES 4.1.
     Pour envoyer un message d'ic“nification, il faut donner dans le
     message (mot 4 … 7) les coordonn‚es pour l'ic“nification ou de
     d‚siconification. Voir pour cela la fonction give_iconifyxywh().

     WM_UNICONIFY - ic“nification
     Une fenˆtre ic“nifi‚e a ‚t‚ double cliqu‚e.

         evnt.buff[0] = WM_UNICONIFY
         evnt.buff[3] = handle de la fenˆtre
         evnt.buff[4] = coordonn‚e x
         evnt.buff[5] = coordonn‚e y
         evnt.buff[6] = coordonn‚e w
         evnt.buff[7] = coordonn‚e h

     Lorsque EvntWindom() re‡oit ce message, il execute la routine
     win->uniconify. Ce message est compatible avec celui de l'AES
     4.1.

     Pour envoyer un message de d‚sic“nification, il faut donner dans
     le message (mot 4 … 7) les coordonn‚es pour la fenˆtre. La
     fonction WindGet( win, WF_UNICONIFY, ...) retourne ces
     coordonn‚es.

     Il n'y a pas encore de routine standart pour le message
     WM_ALLICONIFY.

     Remarque:
     Les messages d'iconification sont g‚r‚ quelauesoit l'AES
     utilis‚. Pour les systŠmes ne supportant pas l'ic“nification on
     peut ic“nifier les fenˆtres en shift cliquant sur le closer de
     la fenˆtre. EvntWindom() repŠre le shift-closer, et au lieu
     d'executer la routine closed de la fenˆtre, envoit un message
     d'ic“nification. Ce message message sera ensuite trait‚ par la
     routine d'ic“nification de la fenˆtre.


9.2  snd_rdw()
==============

 NOM
     snd_rdw - envoi de message.

 PROTOTYPAGE
     void snd_rdw( WINDOW *win);

 PARAMETRES
     win: fenˆtre concern‚e.

 DESCRIPTION
     Cette fonction emet un message de redraw sur la zone de travail
     de la fenˆtre.


9.3  snd_msg()
==============

 NOM
     snd_msg - envoi de message.

 PROTOTYPAGE
     void snd_msg( WINDOW *win, int msg);

 PARAMETRES

      win: fenˆtre concern‚e,

      msg: type de message.

 DESCRIPTION
     Cette fonction emet un message msg sur la fenˆtre win.


9.4  snd_arrw()
===============

 NOM
     snd_arrw - envoi de message WM_ARROWED.

 PROTOTYPAGE
     void snd_arrw( WINDOW *win, int type);

 PARAMETRES

      win: fenˆtre concern‚e,

      msg: type de message.

 DESCRIPTION
     Cette fonction emet un message msg WM_ARROWED sur la fenˆtre
     win. type fixe le type de message (macro WA_?? de aes.h).


9.5  give_iconifyxywh()
=======================

 NOM
     give_iconifyxywh - position des fenˆtres ic“nes.

 PROTOTYPAGE
     void give_iconifyxywh( int *x, int *y, int *w, int *h);

 PARAMETRES
     x,y,w,h: position et taille de la fenˆtre ic“ne

 DESCRIPTION
     Cette fonction vous fournit la taille et la position correcte
     pour ic“nfier une fenˆtre. Normalement, l'AES fournit ces
     valeurs avec le message WM_ICONIFY. Mais cel… fonctionne bien-
     sur que sous AES 4.1 ou ‚quivalent et que si l'on clique sur le
     bouton smaller. Autrement, il n'est pas possible d'obtenir ces
     valeurs de l'AES.

     Cette fonction a diff‚rent comportement suivant les systŠmes: -
     sous AES < 4.1, elle utilise sa propre gestion de position des
     ic“nes. Cette gestion est locale … l'application mais pas …
     l'ensemble des autres applications. - sous AES < 4.1 et si le
     cookie ICFS est pr‚sent, alors elle utilise ICFS pour placer ses
     ic“nes. Ainsi, on peut avoir une gestion globale des
     ic“nification d'autant plus que de plus en plus d'applications
     reconnaissent ce cookie. - sous AES 4.1 ou systŠme supportant
     l'ic“nification (WinDom le verifie avec la fonction
     appl_getinfo()), give_iconifyxywh() retourne une valeur fixe
     parceque pour la raison ‚voqu‚ plus haut.

     A priori, on a pas besoin d'utiliser cette fonction sauf si on
     veut modifier certaines fonctions standarts ou si on veut
     d‚clencher manuellement une ic“nification. La fonction standart
     des closers des fenˆtres l'utilise pour d‚clencher
     l'ic“nification sur shift+click, cela offre une alternative
     d'ic“nification pour les sytŠmes ne supportant pas les smallers.



Chapitre 10

Librairie ressource
*******************


10.1  RsrcLoad()
================

 NOM
     RsrcLoad - Charge un ressource en m‚moire.

 PROTOTYPAGE
     int RsrcLoad( char *rsrcfile);

 PARAMETRE

      rsrcfile: nom du fichier ressource … charger,

      valeur retourn‚e: 0 si pas d'erreur.

 DESCRIPTION
     Cette fonction remplace la fonction AES rsrc_load();

 VOIR AUSSI
     RsrcFree();


10.2  RsrcFree()
================

 NOM RsrcFree - LibŠre de la m‚moire un ressource.

 PROTOTYPAGE
     int RsrcFree( char *rsrcfile);

 PARAMETRE
     valeur retourn‚e: 0 si pas d'erreur.

 DESCRIPTION
     Cette fonction remplace la fonction AES rsrc_free();

 VOIR AUSSI
     RsrcFree();


10.3  RsrcXtype()
=================

 NOM
     RsrcXtype - Fixation des type ‚tendus.

 PROTOTYPAGE
     void RsrcXtype( int mode, OBJECT **trindex, int NUM_TREE);

 PARAMETRES

      mode:     1 - fixe les type ‚tendus,
                0 - libŠre les types ‚tendus,

      trindex:  adresse des arborescences d'objets ou NULL,

      NUM_TREE: nombre d'arborescence.

 DESCRIPTION
     Cette fonction travaille sur les ressources int‚gr‚es et sur les
     ressources externes. Si le ressource est externe, le paramŠtre
     trindex doit ˆtre NULL. Dans le cas de ressource int‚gr‚, les
     paramˆtres trindex et NUM_TREE sont fournis dans le fichier
     ressource … inclure.

     WinDom propose des types ‚tendus d'objets. Ces types sont
     compatibles avec ceux de MyDial mˆme s'ils sont moins ‚volu‚s.
     Cette fonction permet de valider ou non les types ‚tendus ainsi,
     s'il on pr‚fŠre utiliser MyDial, cela reste possible :-).
     D'autre part, l'intˆret d'avoir la mˆme terminologie que MyDial
     est que l'on peut visualiser ces objets sous Interface 2.

     A la fin du programme, les type ‚tendus doivent ˆtre enlev‚ pour
     lib‚rer la m‚moire allou‚e.

 TYPE EXISTANT


     +-----------+-------+-----------------+---------+---------+
     |    Nom    | Xtype | Description     |  Flags  | Options |
     +-----------+-------+-----------------+---------+---------+
     | DCRBUTTON |  18   | Bouton rond     | RBUTTON | Draw3D  |
     |           |       | Bouton carr‚    | RBUTTON | Draw3D  |
     | UNDERLINE |  19   | Soulignement    |    -    | Draw3D  |
     |           |       | de texte        |         |         |
     | TITLEBOX  |  20   | Cadre titr‚     |    -    | Draw3D  |
     |  HELPBUT  |  21   | Bouton help     |    -    |    -    |
     | CIRCLEBUT |  22   | Bouton de cycle |    -    | Draw3D  |
     |           |       | pour pop-up     |         |         |
     |  UNDOBUT  |  31   | Bouton Undo     |    -    |    -    |
     |     -     |   -   | objet undo      | FLAG11  |    -    |
     +-----------+-------+-----------------+---------+---------+

         (Tableau 11: Les types ‚tendus support‚s par WinDom)


     Les types ‚tendus MyDial suivant ne sont pas impl‚ment‚ dans
     WinDom:

         DIALMOVER (17)
         POPUPSTRG (23)
         KPOPUPSTRG (24)
         SLIDEPART (25)
         LONGINPUT (26)

     ainsi que le flag15 ( champ de saisi … ligne multiple)


10.4  RsrcFixCicon()
====================

 NOM
     RsrcFixCicon - fixation des ic“nes couleurs.

 PROTOTYPAGE
     void RsrcFixCicon( OBJECT *tree, int num_obs, int num_cib, int
     *palette[4], XRSRCFIX *fix );

 PARAMETRES

      tree:    arborescence d'objet … fix‚,

      num_obs: nombre d'objet dans l'arborescence,

      num_cib: nombre d'ic“ne couleur,

      palette: palette des ic“nes,

      fix:     adresse de la structure contenant les ic“nes couleurs
               fix‚es.

 DESCRIPTION
     Cette fonction sert … adapter les ic“nes d'un ressource int‚gr‚
     … la r‚solution de l'‚cran. Dans le cas d'un ressource externe,
     les ic“nes sont fix‚e par RsrcLoad().

     Le paramŠtre palette est optionnel, il peut valoir NULL. Dans ce
     cas, c'est la palette de l'AES qui sera utilis‚. Ce paramˆtre
     est fournit dans le fichier ressource C … inclure par certains
     ‚diteurs de ressource telque Interface.

     Le paramŠtre devra ˆtre communiqu‚ … la fonction RsrcFreeCicon()
     pour lib‚rer la m‚moire utilis‚.

 VOIR AUSSI
     RsrcFreeCicon()


10.5  RsrcFreeCicon()
=====================

 NOM
     RsrcFreeCicon - LibŠre de la m‚moire les ic“nes couleurs.

 PROTOTYPAGE
     void RsrcFreeCicon ( XRSRCFIX *fix);

 PARAMETRE
     fix:] pointeur de donn‚e fourni par RsrcFixCicon(),

 DESCRIPTION
     Avant de terminer l'application, vous devez liberer de la
     m‚moire les ic“nes couleurs des ressources int‚gr‚s qui ont ‚t‚
     fix‚s par RsrcFixCicon.

 VOIR AUSSI
     RsrcFixCicon();



Chapitre 11

Librairie objet
***************


11.1  ObjcDraw()
================

 NOM
     ObjcDraw() - dessine un objet dans un formulaire en fenˆtre

 PROTOTYPAGE
     void ObjcDraw( int mode, WINDOW *win, int index, int depth);

 PARAMETRES

      mode:  OC_FORM, concerne un formulaire en fenˆtre,
             OC_TOOL, concerne un toolbar,

      win:   fenˆtre concern‚e,

      index: index de l'objet … dessiner,

      depth: profondeur dans l'aborescence.

 DESCRIPTION
     A chaque fois que vous voudrez redessiner un objet dans un
     toolbar ou dans un formulaire en fenˆtre, utilisez cette
     fonction. Normalement, cette fonction doit ˆtre utilis‚ dans une
     fonction de gestion de formulaire ou de toolbar.

 RECOMMANDATIONS
     Elle ne doit jamais ˆtre utilis‚ dans une routine de dessin
     d'une fenˆtre. En effet, cette fonction utilise la liste des
     rectangles fournit par l'AES. Comme la routine de dessin est
     ‚xectu‚ pour chaque rectangle de la liste, ObjcDraw() peut
     perturber voir planter v“tre programme.

     De toute fa‡ons, vous n'avez g‚n‚ralement pas … utiliser cette
     fonction dans les routines de dessins puisque la routine de
     dessin de formulaire s'en charge. Si toutefois vous voulez
     dessiner des objets dans une fenˆtre - ce cas se presente pour
     dessiner une ic“ne dans un fenˆtre ic“nifi‚e - utiliser
     directement la fonction GEM objc_draw() clipp‚ sur la zone …
     redessiner. Cette zone de clippage est fournit par la variable
     globale clip

     Pour les formulaires classiques, utilisez les fonctions objc_?
     de l'AES.

 VOIR AUSSI
     ObjcChange()


11.2  ObjcChange()
==================

 NOM
     ObjcChange() - change l'‚tat d'un objet dans un formulaire en
     fenˆtre

 PROTOTYPAGE
     void ObjcChange( int mode, WINDOW *win, int index, int state,
     int redraw);

 PARAMETRES

      mode:   OC_FORM, concerne un formulaire en fenˆtre,
              OC_TOOL, concerne un toolbar,

      win:    fenˆtre concern‚e,

      index:  index de l'objet,

      state:  nouvel ob_state de l'objet,

      redraw: si different de 0, on redessine l'objet.

 DESCRIPTION
     Cette fonction est utilis‚ pour changer l'‚tat des objets des
     formulaires en fenˆtres ou des toolbar dans les fonctions de
     gerstion des formulaires et toolbar. Voir ObjcDraw() pour les
     recommandations d'utilisation.

 VOIR AUSSI
     ObjcDraw().


11.3  ObjcWindDraw()
====================

 NOM
     ObjcWindDraw - dessine un objet (quelconque) dans une fenˆtre
     (quelconque)

 PROTOTYPAGE
     void ObjcWindDraw( WINDOW *win, OBJECT *tree, int index, int
     depth, int xclip, int yclip, int wclip, int hclip);

 PARAMETRES

      win:                        fenˆtre concern‚,

      tree:                       arborescence a dessiner,

      index:                      index de l'objet … dessiner,

      depth:                      profondeur,

      xclip, yclip, wclip, hclip: zone … clipper.

 DESCRIPTION
     Cette fonction permet de dessiner un objet dans une fenˆtre
     quelconque. Cette fonction utilise la liste des rectangles de
     l'AES afin de dessiner proprement les objets dans une fenˆtre en
     respectant notamment la zone de travail de la fenˆtres, les
     fenetres qui la recourvrent etc... Cette fonction ne peut ˆtre
     utilis‚ dans les fonctions de dessin des fenetres puisqu'elle
     utilise la liste de rectangle de l'AES.

 VOIR AUSSI
     ObjcWindChange()


11.4  ObjcWindChange()
======================

 NOM
     ObjcWindChange - change l'‚tat d'un objet (quelconque) dans une
     fenˆtre (quelconque)

 PROTOTYPAGE
     void ObjcWindChange( WINDOW *win, OBJECT *tree, int index, int
     xclip, int yclip, int wclip, int hclip, int state);

 PARAMETRES

      win:                        fenˆtre concern‚,

      tree:                       arborescence a dessiner,

      index:                      index de l'objet … dessiner,

      xclip, yclip, wclip, hclip: zone … clipper,

      state:                      nouvel ‚tat de l'objet.

 DESCRIPTION
     Cette fonction permet de changer l'‚tat d'un objet dans une
     fenˆtre quelconque. Cette fonction utilise la liste des
     rectangles de l'AES afin de redessiner proprement les objets
     dans une fenˆtre en respectant notamment la zone de travail de
     la fenˆtres, les fenetres qui la recourvrent etc... Cette
     fonction ne peut ˆtre utilis‚ dans les fonctions de dessin des
     fenˆtres puisqu'elle utilise la liste de rectangle de l'AES.

 VOIR AUSSI
     ObjcWindDraw()


11.5  ObjcDup()
===============

 NOM
     ObjcDup - duplication d'objet en m‚moire.

 PROTOTYPAGE
     OBJECT *ObjcDup( OBJECT *tree);

 PARAMETRES

      tree:             adresse de l'arboresence d'objet … copier,

      valeur retourn‚e: l'adresse de la copie.

 DESCRIPTION
     Cette fonction duplique une arborescence d'objet en m‚moire.
     Pour le moment, seul les objets sont dupliqu‚s mais pas les
     chaŒnes de caractŠres, les images, les tedinfos etc...

     Utilisez cette fonction lorsque vous voulez afficher un mˆme
     formulaire simultan‚ment dans deux fenˆtres. Si vous mettez le
     bit WS_FORMDUP de la variable win->status, la fonction de
     destruction standart des fenˆtres formulaires appelera
     automatiquement ObjcFree() pour lib‚rer la m‚moire.

     Notez toutefois que FormCreate() gŠre le cas ou l'on duplique
     les fenˆtres mais pas FormAttach(). Lorsque vous attribu‚ des
     toolbars et des menus … une fenˆtre avec WindSet(), l'arbre est
     automatiquement dupliqu‚ en m‚moire.

 VOIR AUSSI
     ObjcFree(), FormCreate().


11.6  ObjcFree()
================

 NOM
     ObjcFree - lib‚ration d'objet en m‚moire.

 PROTOTYPAGE
     void ObjcDup( OBJECT *tree);

 PARAMETRES
     tree: adresse de l'arborescence d'objet … lib‚rer.

 DESCRIPTION
     LibŠre de la m‚moire une copie d'objet faite par ObjcDup().

 VOIR AUSSI
     ObjcDup()


11.7  ObjcString()
==================

 NOM
     ObjcString - lecture d'un champ de texte d'un object.

 PROTOTYPAGE
     char *ObjcDup( OBJECT *tree, int index, char *newstr);

 PARAMETRES

      tree:             adresse de l'arborescence d'objet,

      index:            index de l'objet,

      newstr:           nouvelle adresse du texte ou NULL,

      valeur de retour: adresse du texte.

 DESCRIPTION
     Cette permet de lire ou d'affecter un texte d'un objet de type
     quelconque. Ceci est particulierement utile car les objets
     peuvent ˆtre aussi de type ‚tendue. Son utilisation est donc
     recommand‚. Si newstr vaut NULL, la fonction retourne le texte
     actuel de l'objet. Si newstr n'est pas nul, il est utilis‚ comme
     nouveau texte pour l'objet. Enfin, si l'objet ne contient pas de
     texte, la fonction retourne une chaŒne vide.



Chapitre 12

Librairie formulaire
********************


12.1  FormCreate()
==================

 NOM
     FormCreate - Cr‚ation d'un formulaire en fenˆtre.

 PROTOTYPAGE
     WINDOW *FormCreate( OBJECT *tree, int attrib, void (*func)(),
     char *name, GRECT *coord, int grow, int dup);

 PARAMETRES

      tree:   Object a afficher,

      attrib: Attibuts GEM de la fenˆtre,

      func:   Fonction de gestion du dialogue ou NULL,

      name:   Nom de la fenˆtre,

      coord:  Position et taille de la fenˆtre,
              g_x, g_y: position de la fenˆtre,
              g_w, g_h: taille de la zone de travail.
              Si coord est NULL, la fenˆtre est centr‚ … l'‚cran
              par l'interm‚diaire de la fonction form_center().

      grow:   1: effet GrafGrow activ‚,
              0: d‚sactiv‚,

      dup:    1: le formulaire est dupliqu‚ en m‚moire,
              0: le n'est pas dupliqu‚ en m‚moire,

      valeur retourn‚e: Le descripteur de la fenˆtre.

 DESCRIPTION
     Cette fonction cr‚‚ une fenˆtre contenant un formulaire de fa‡on
     trŠs simple. Si une fenˆtre contenant le mˆme formulaire ( mˆme
     adresse) existe d‚j…, cette fenˆtre est remise en premier plan
     si elle est ouverte, ou ouverte si elle est ferm‚e ou ic“nifi‚e.
     En effet, un mˆme formulaire ne peut pas ˆtre affich‚ dans deux
     fenˆtres diff‚rents sans ˆtre pertub‚ (coordonn‚ diff‚rents,
     ‚tats des objets diff‚rents).

     Pour ouvrir le mˆme formulaire dans diff‚rentes fenˆtre, il faut
     le dupliqu‚ en m‚moire, donc on met le paramŠtre dup … 1.
     L'arborescence d'objet sera alors dupliqu‚ avec la fonction
     ObjcDup(). La m‚moire allou‚ sera lib‚r‚ lors de la destruction
     de la fenˆtre (le destructeur de la fenˆtre utilise la fonction
     ObjcFree()). Un flag du champs status du descripteur de fenˆtre
     (WS_FORMDUP) indique que le formulaire est dupliqu‚.

     Le reste de la fonction FormCreate() consiste en gros … une
     bonne initialisation du descripteur de fenˆtre:

        ù le pointeur de donn‚e poŒnte sur une structure W_FORM,

        ù certaines fonctions de gestions d'‚venements sont modifi‚s,

        ù les variables de gestion des ascenseurs sont correctement
          initialis‚,

     (voir DETAILS TECHNIQUES).

 GESTION DU DIALOGUE
     WinDom s'occupe de la gestion du dialogue. Les ‚venements souris
     et claviers sont r‚alis‚ par la fonction EvntWindom() ou
     EvntMesag() et sont consid‚r‚ comme des ‚venements MU_MESAG.
     Quand un objet EXIT ou TOUCHEXIT est s‚lectionn‚, WinDom
     retourne un nouveau message. Le buffer des ‚venements AES
     contient alors:

         evnt.buff[0] = WF_FORM,
         evnt.buff[1] = id de l'application,
         evnt.buff[2] = 0,
         evnt.buff[3] = handle GEM de la fenˆtre concern‚e,
         evnt.buff[4] = num‚ro de l'objet s‚lectionn‚e,
         evnt.buff[5] = ‚tat du clavier.

     Lorsque EvntWindom() re‡oit ce message, il ‚xecute la routine
     func si elle existe. C'est dans cette routine qu'on gŠre le
     r‚sultat du dialogue. Mais on a aussi le choix de g‚rer le
     dialogue en r‚cuperant directement le message WM_FORM.

     Voi‡i la trame de la routine de gestion du dialogue:

          void GereDialog( WINDOW *win)
          {
               int obj;
               OBJECT *tree = FORM(win);
     
               switch( obj = evnt.buff[4])
               {
               case OBJ1:
                    if( tree[ obj].ob_state & SELECETED)
                         ...
     
               }
               ObjcChange( OC_FORM, win, obj, MAX_DEPTH, 1);
          }

     ObjcChange() est l'‚quivalent de la fonction objc_change() pour
     les dialogues en fenˆtre ou les toolbar.

     La macro FORM(win) permet d'acceder … l'adresse de
     l'arborescence d'objet du dialogue (voir paragraphe suivant).

 DETAILS TECHNIQUES
     Cette fonction utilise directement les fonctions WindCreate() et
     WindOpen() pour cr‚er la fenˆtre et son descripteur. Elle
     initialise les fonctions de gestion d'‚v‚nements sur des
     routines sp‚cifique … la gestion de dialogue en fenˆtre en
     appelant la fonction FormAttach(). De plus, elle ajuste la
     taille de la fenˆtre en fonction de la taille du dialogue. La
     routine de gestion du dialogue est la fonction de gestion de
     l'‚vemenemt MU_BUTTON de la fenˆtre. Le champ data de la fenˆtre
     poŒnte sur une structure W_FORM qui contient, entre autre,
     l'adresse de l'arborescence d'objets, d'o— l'existence de la
     macro FORM pour y acc‚der facilement.

     Voi‡i la description des routines ‚venements des formulaires en
     fenˆtre:


+-----------+----------+-------------+--------------------------------+
|    Nom    |  WINDOW  |  Evenement  | Description                    |
+-----------+----------+-------------+--------------------------------+
|  frm_drw  |  redraw  |  WM_REDRAW  | Dessine le formulaire dans la  |
|           |          |             | fenˆtre apr‚s avoir adapt‚ les |
|           |          |             | coordonn‚es de l'objet pŠre …  |
|           |          |             | celle de la fenˆtre.           |
|           |          |             | Positionne le curseur des      |
|           |          |             | champs ‚ditables s'il doit     |
|           |          |             | ˆtre affich‚.                  |
| frm_dstry | destroy  | M_DESTROYED | Ferme et d‚truit la fenˆtre    |
|           |          |             | avec WindClose() et            |
|           |          |             | WindDelete(). Si l'application |
|           |          |             | n'est pas un accessoire ou si  |
|           |          |             | il n'y a plus de fenˆtre, on   |
|           |          |             | quit l'application.            |
|  frm_tpd  |  topped  |  WM_TOPPED  | Met en premier plan la fenˆtre |
|           |          |             | avec WindSet(,WF_TOP,) et      |
|           |          |             | postionne le curseur.          |
|  frm_mvd  |  moved   |  WM_MOVED   | Mˆme action que std_mvd mais   |
|           |          |             | met … jour les coordon‚es de   |
|           |          |             | l'objet pŠre.                  |
| frm_keyhd | keyhited |  MU_KEYBD   | GŠre les boutons DEFAULT, les  |
|           |          |             | objets de types ‚tendus HELP   |
|           |          |             | et UNDO, les fleches dans les  |
|           |          |             | champs ‚ditables.              |
+-----------+----------+-------------+--------------------------------+

        (Tableau 12: Les routines attribu‚es aux formulaires)


     Les autres fonctions sont inchang‚s ...

 VOIR AUSSI
     ObjcChange(), ObjcDraw(), ObjcDup(), FormAttach().


12.2  FormBegin()
=================

 NOM
     FormBegin - affiche un formulaire classique.

 PROTOTYPAGE
     void FormBegin(OBJECT *tree, MFDB *bckgrnd);

 PARAMETRES

      tree:    adresse du formulaire,

      bckgrnd: adresse portion d'‚cran … sauvegarder.

 DESCRIPTION
     Cette fonction permet d'afficher trŠs simplement un formulaire
     dans une boŒte de dialogue GEM classique. Le dialogue est centr‚
     … l'‚cran avec un effet graf_grow (voir "rem 1"). Si bckgrnd est
     NULL, l'‚cran ne sera pas saugegard‚, seul un message de redraw
     sera ‚mit lors de l'‚ffacement de la boŒte.

 VOIR AUSSI
     FormDo() - FormEnd()


rem 1
-----

Je recommande d'utiliser WinDom avec Let's them Fly.
A mon sens, les dialogues (en fenˆtre ou non) devraient
toujours ˆtre centr‚ avec form_center() et avoir des effets
graf_grow car le comportement globale peut ˆtre regl‚ avec
Let's them Fly. Cela peut ˆtre important pour form_center()
sur des ‚cran virtuels (voir Let's then Fly).


12.3  FormDo()
==============

Cette fonction est un alias de la fonction AES form_do().

Voi‡i un exemple d'utilisation:

     {
          MFDB screen;
          OBJECT *tree;
          int res;

          rsrc_gaddr( 0, MY_DIAL, &tree);
          FormBegin( tree, &screen);
          res = FormDo( tree, -1)
          switch(res){
          case OK:
               ...
               break;
          }
          FormEnd( tree, &screen);
     }


12.4  FormEnd()
===============

 NOM
     FormEnd - efface un formulaire classique.

 PROTOTYPAGE
     void FormEnd(OBJECT *tree, MFDB *bckgrnd);

 PARAMETRES

      tree:    adresse du formulaire,

      bckgrnd: adresse portion d'‚cran … restorer.

 DESCRIPTION
     Cette fonction efface le formulaire de l'‚cran et
     eventuellement, si bckgrnd ne vaut pas NULL, restore l'‚cran
     derriŠre le formualaire sinon elle envoit un message de redraw
     sur la zone du formulaire.

 VOIR AUSSI
     FormDo(), FormBegin().


12.5  FormWindBegin()
=====================

 NOM
     FormWindBegin - affiche un formulaire dans une fenˆtre modale.

 PROTOTYPAGE
     int FormWindBegin( OBJECT *dial, char *nom);

 PARAMETRES

      dial: adresse du formulaire,

      nom:  titre de la fenˆtre,

      valeur retourn‚e: 1 si erreur, 0 sinon.

 DESCRIPTION
     Un formulaire modal est un formulaire en fenˆtre qui bloque le
     menu et les fenˆtres de l'application comme un formulaire GEM
     classique. Par contre, il ne bloque pas l'AES: on peut appeler
     les accessoires ou, sous MultiTos, agir sur les fenˆtres des
     autres applications. La gestion du formulaire dans la fenˆtre se
     fait comme pour les formulaires classiques. La fonction
     FormWindDo() attend que l'utilisateur ait cliqu‚ sur un objet
     EXIT ou TOUCHEXIT avant de rendre la main au programme. La
     fonction FormWindEnd() referme la fenˆtre. La fenˆtre ainsi cr‚‚
     a comme attribut une barre de d‚placement, un titre et elle est
     rendu B_MODAL (voir WindSet()).

 VOIR AUSSI
     FormWindDo(), FormWindEnd().


12.6  FormWindDo()
==================

 NOM
     FormWindDo - attend le choix de l'utilisateur dans une fenˆtre
     de formulaire modal.

 PROTOTYPAGE
     int FormWindDo( int evnt);

 PARAMETRES

      evnt: Masque d'‚venements … surveiller,

      valeur retourn‚e: l'index de l'objet s‚l‚ctionn‚ par
       l'utilisateur.

 DESCRIPTION
     Cette fonction gŠre le formulaire modal ouverte par
     FormWindBegin(). Elle attend, en bouclant sur la fonction
     EvntWindom(), que l'utilisateur ai fait son choix dans la
     fenˆtre i.e. que l'on ait cliqu‚ sur un objet EXIT ou TOUCHEXIT.
     Ainsi, le programme ne bloque pas l'AES et l'on peut continuer …
     utiliser les applications ext‚rieures au programme.

     Le choix des ‚venements … surveiller est important. Au minimum,
     on mettra MU_MESAG pour gerer la fenˆtre elle-mˆme, puis les
     autres ‚venements que l'on d‚sire voir s'appliquer sur les
     autres fenˆtres, par exemple un timer.

     On peut aussi surveiller les ‚venements autres que celui des
     selections d'objet. Le bit FORM_EVNT (0x8000) demande …
     FormWindDo() de retourner dans la valeur de retour les
     ‚venements de evnt qu'elle a intercept‚. Dans ce cas,
     FormWindDo() retourne soit l'index de l'ojbet s‚lectionn‚ soit
     si le bit FORM_EVNT vaut 1, un masque de bit des ‚venements
     intercept‚s.

 EXEMPLE
     Cette fonction appelle un dialogue et renvoit l'index de l'objet
     selectionn‚:

     int CallDialog( int index)
     {
          OBJECT *dialog;
          int res;
     
          rsrc_gaddr( 0, index, &dialog);
          FormWindBegin( dialog, "Formulaire");
          res = FormWindDo( MU_MESAG);
          FormWindEnd();
          return res;
     }

 VOIR AUSSI
     FormWindBegin(), FormWindEnd().


12.7  FormWindEnd()
===================

 NOM
     FormWindEnd - ferme une fenˆtre ouverte par FormWindBegin().

 PROTOTYPAGE
     void FormWindEnd( void);

 DESCRIPTION
     Cette fonction doit ˆtre appel‚ aprŠs avoir fini de travailler
     sur le dialogue pour lib‚rer toutes les ressources occup‚s.

 VOIR AUSSI
     FormWindOpen(), FormWindDo().


12.8  FormSave()
================

 NOM
     FormSave - Gestion de formulaire en fenˆtre.

 PROTOTYPAGE
     void FormSave( WINDOW *win, int mode);

 PARAMETRES

      win: fenˆtre concern‚,

      mode: OC_FORM pour un formulaire,
       OC_TOOL pour un toolbar.

 DESCRIPTION
     Cette fonction vous permet de sauvegarde l'‚tat d'un formulaire
     d'une fenˆtre ou d'un toolbar. Par ‚tat, on entend ob_states des
     objets du formulaire. Ces valeurs sont stock‚ dans le champ save
     de la structure W_FORM associ‚ au formulaire ou au toolbar.

 UTILISATION(!nl) Pour sauvegarder le formulaire:

          {
               OBJECT *tree;
               WINDOW *win;
               void (*GereForm)( WINDOW *);  /* d‚fini plus loin */
     
               rsrc_gaddr( 0, MYDIAL, &tree);
               win = FormCreate( tree, MOVER|NAME|SMALLER|CLOSER,
                                     GereForm, "Titre fenˆtre", NULL, 1);
               FormSave( win, OC_FORM);  /* On sauve l'‚tat */
          }

     Pour restorer le formulaire:

     L'utilisation la plus courante est de restorer le formulaire
     lorsqu'on choisit le bouton Annuler du formulaire. Ceci se fait
     donc dans la fonction de gestion du formulaire (GereForm):

          void GereForm( WINDOW *win)
          {
               if( evnt.buff[4] == MYDIAL_ANNUL)
               {
                    Restore( win, OC_FORM);  /* On restore l'‚tat */
                    snd_msg( win, WM_CLOSED);
               }
          }

 DETAILS TECHNIQUES
     FormSave alloue la m‚moire n‚cessaire pour sauver l'‚tat. Pour
     un formulaire cette m‚moire est lib‚r‚ automatiquement lors de
     la destruction de la fenˆtre par le destructeur de la fenˆtre,
     pour un toolbar, elle est lib‚r‚ par la fonction WindDelete().
     D'autre part, si l'on change le formulaire ou si l'on le retire
     par FormAttach() ou par WindSet( , WF_TOOLBAR, ), la m‚moire est
     ‚galement lib‚r‚.

 VOIR AUSSI
     FormRestore().


12.9  FormRestore()
===================

 NOM
     FormRestore - Gestion de formulaire en fenˆtre.

 PROTOTYPAGE
     void FormRestore( WINDOW *win, int mode);

 PARAMETRES

      win: fenˆtre concern‚,

      mode: OC_FORM pour un formulaire,
       OC_TOOL pour un toolbar.

 DESCRIPTION
     Cette fonction restore l'‚tat ( valeur de l'ob_state des objets)
     d'un formulaire en fenˆtre ou d'un toolbar. L'‚tat doit d'abord
     ‚t‚ sauvegard‚ par la fonction FormSave().

 VOIR AUSSI
     FormSave().


12.10  FormAttach()
===================

 NOM
     FormAttach() - attribue un formulaire … une fenˆtre.

 PROTOTYPAGE
     void FormAttach( WINDOW *win, OBJECT *tree, void *func);

 PARAMETRES

      win:  descripteur de la fenˆtre concern‚e,

      tree: adresse de l'arborescence d'objet … attacher,

      func: adresse de la routine de gestion du formulaire,

 DESCRIPTION Cette fonction attache un formulaire et sa routine de
     gestion … une fenˆtre. C'est une sous-routine de FormCreate().
     L'appel:
     FormAttach( win, NULL, NULL);
     retire le formulaire attribu‚e … la fenˆtre.

 VOIR AUSSI FormCreate().



Chapitre 13

Librairie souris
****************


13.1  MouseObjc()
=================

 NOM
     MouseObjc - gestion de la position de la souris

 PROTOTYPAGE
     void MouseObjc( OBJECT *tree, int index);

 PARAMETRES

      tree:  adresse de l'arborescence d'objets consern‚e,

      index: index de l'objet concern‚e.

 DESCRIPTION
     Cette fonction place la souris au centre d'un objet d'un
     formulaire.


13.2  MouseSprite()
===================

 NOM
     MouseSprite - fixe le sprite de la souris

 PROTOTYPAGE
     void MouseSprite( OBJECT *tree, int index);

 PARAMETRES

      tree:  adresse de l'arborescence d'objets consern‚e,

      index: index de l'objet concern‚e.

 DESCRIPTION
     Cette fonction fixe le sprite de la souris … partir d'une ic“ne
     monochrome contenu dans un objet GEM. Les couleurs avant et
     arriŠre plan de l'ic“ne sont ‚galement utilis‚ pour fixes celles
     du sprite de la souris.

 VOIR AUSSI
     graf_mouse()


13.3  MouseWork()
=================

 NOM
     MouseWork - gestion de la souris

 PROTOTYPAGE
     void MouseWork( void);

 DESCRIPTION
     Chaque appel de cette fonction change la forme de souris de
     fa‡ons … l'animer (forme d'un disque tournant) pour indiquer que
     l'on n'a pas la main. Lorsque le travail est termin‚, il faut
     redonner … la souris sa forme initiale par un appel … la
     fonction GEM graf_mouse().

 VOIR AUSSI
     graf_mouse()



Chapitre 14

Librairie s‚lecteur de fichiers
*******************************


14.1  FselInput()
=================

 NOM
     FselInput - Appel du s‚lecteur de fichier GEM.

 PROTOTYPAGE
     int FselInput( char *path, char *name, char *ext, char *title)

 PARAMETRES

      path:  R‚pertoire par d‚faut, puis au retour, le r‚pertoire de
             la selection.

      name:  nom de fichier par d‚faut, puis au retour, le nom du
             fichier s‚lectionn‚,

      ext:   masque de fichier,

      title: titre du s‚lecteur,

             valeur de retour: le bouton s‚lectionn‚ (1 Ok, 0 sinon).

 DESCRIPTION
     Cette fonction permet un appel plus ais‚ du selecteur de fichier
     du GEM. Au retour de la fonction, path et name contiennent
     respectivement le nom du r‚pertoire et le nom du fichier
     s‚lectionn‚. Ainsi, cette fonction peut servir … la fois de
     selecteur de fichier et de s‚lecteur de r‚pertoire.

     Si path = "", le selecteur affichera le r‚pertoire courant de la
     partition courante. Si ext = "", le masque de fichier sera
     "*.*".

     La variable title fixe le titre du s‚lecteur de fichier si la
     version du TOS le permet (>=1.04) ou si le cookie 'FSEL' est
     pr‚sent. Pour les TOS ant‚rieurs … la version 1.04, il n'y aura
     tout simplement pas de titre.

     Enfin, cette fonction n'utilise pas l'environnement WinDom pour
     fonctionner.

 EXEMPLE
     Voi‡i un exemple ou l'on appelle le s‚lecteur de fichier gardant
     en m‚moire le dernier chemin visit‚.

     
          int CallFsel ( name)
          {
               static char path[255]=""; /* Au premier appel, on
                                          * sera dans le r‚pertoire
                                          * courant */
               char completname[255]="";
     
               if( Fsel( path, name, "Load a file", "")) {
                    strpcy( completname, path);
                    strcat( completname, name);
                    strpcy( name, completname); /* On retourne le
                                                 * nom complet */
                    return 1;
               } else return 0;
          }


14.2  Appel de Selectric
========================

WinDom intŠgre des fonctions pour appeler de maniŠre complŠte le
selecteur de fichier Selectric ou d'autres s‚lecteurs comme par
exemple Freedom. Ces fonctions sont directement tir‚ des exemples de
programmations du package Selectric. Ces fonctions n'utilisent donc
pas l'environnement WinDom.


14.2.1  slct_extpath()
----------------------

 NOM
     slct_extpath - configuration de Selectric.

 PROTOTYPAGE
     int slct_extpath(int ext_num, char *(*ext)[], int path_num, char
     *(*paths)[]);

 PARAMETRES


      ext_num:  Nombre d'extensions,

      ext:      liste des extensions,

      path_num: nombre des chemins,

      paths:    liste des chemins,

      valeur de retour: 1 si Selectric est install‚, 0 sinon.

 DESCRIPTION
     Cette fonction permet de fixer les extensions et chemin par
     d‚faut accessible dans les pop-up de Seletric.

 EXEMPLE


     	char *ext[] = {"*.C","*.H","*.PRJ"};
     	char *path[] = {"C:\\SRC\\WINDOM","C:\\SRC"};
     
     	slct_extpath( 3, &ext, 2, &path);


14.2.2  slct_morenames()
------------------------

 NOM
     slct_morenames - choix du mode de s‚lection de Selectric.

 PROTOTYPAGE
     int slct_morenames(int mode, int num, void *ptr);

 PARAMETRES


      mode: fixe le mode:

             1 Selectric retournera les fichiers s‚lectionn‚s dans
                 une chaŒne de caractŠre,

             0 Selectric retournera les fichiers s‚lectionn‚s dans
                 une liste (tableau de nom de fichier),

      num:  nombre maximum de fichier … retourner,

      ptr:  the pointeur sur les donn‚es de retour,

      valeur de retour: 1 si Selectric est install‚, 0 sinon.

 DESCRIPTION


 VOIR AUSSI



14.2.3  slct_first()
--------------------

 NOM


 PROTOTYPAGE


 PARAMETRES


 DESCRIPTION


 VOIR AUSSI



14.2.4  slct_next()
-------------------

 NOM


 PROTOTYPAGE


 PARAMETRES


 DESCRIPTION


 VOIR AUSSI



14.2.5  slct_release()
----------------------

 NOM


 PROTOTYPAGE


 PARAMETRES


 DESCRIPTION


 VOIR AUSSI



14.2.6  Exemple d'utilisation des appels de Selectric
-----------------------------------------------------



Chapitre 15

Librairie cookies
*****************

WinDom vous propose les fonctions n‚c‚ssaire pour manipuler les
cookies:


15.1  get_cookie()
==================

 NOM
     get_cookie() - Cherche un cookie dans le cookiejar

 PROTOTYPAGE
     int get_cookie( long cookie, long *value);

 PARAMETRES

      cookie: identificateur du cookie … rechercher,

      value:  valeur du champ value du cookie. G‚n‚ralement c'est une
              adresse sur une structure de donn‚e ou NULL,

      valeur retourn‚e: 1 si le cookie existe, 0 sinon.

 DESCRIPTION
     Cette fonction cherche si un cookie est pr‚sent en m‚moire dans
     le cookiejar. Pour les vieux TOS qui ne possŠde pas de
     cookiejar, il ne se passera rien mais vous pouvez toutefois
     tester la pr‚sence du cookiejar avec la fonction
     get_cookiejar(). Le paramŠtre cookie re‡oit l'identificateur du
     cookie. Cette identificateur est cod‚ sur 4 octets. Par exemple
     MiNT, installe un cookie en m‚moire. Pour tester sa pr‚sence il
     suffit d'‚crire:

          if( get_cookie( 'MiNT', NULL))
               ; /* MiNT est pr‚sent */
          else
               ; /* MiNT est absent */

     Attention la notation 'MiNT' n'est pas valide avec le Gnu C. Le
     second paramŠtre retourne l'adresse du champ value de la du
     cookie. Ceci permet de d'obtenir d'autre information sur le
     cookie mais qui dependera du cookie consid‚r‚. On peut donner
     NULL comme valeur si on ne veut rien r‚cuperer.

 VOIR AUSSI
     get_cookiejar().


15.2  get_cookiejar()
=====================

 NOM
     get_cookiejar() - Adresse du cookiejar

 PROTOTYPAGE
     long *get_cookie( void);

 PARAMETRES
     valeur retourn‚e: l'adresse du cookiejar ou NULL.

 DESCRIPTION
     Cette fonction retourne l'adresse du cookiejar ou NULL si le
     cookiejar n'existe pas ce qui est le cas des vieux TOS. Sachez
     toutefois qu'il existe des patches qui permettent de cr‚er un
     cookiejar sur un vieux TOS. Le cookiejar est trŠs utile car il
     offre une besace de variables qui restent toujours en m‚moire.
     Ces variables permettent de donner des informations sur le
     systŠme et sont trŠs utilis‚ par beaucoup de programme.

     Voi‡i en gros comment sont organis‚ les cookies dans la m‚moire:
     une variable systŠme (… l'adresse 0x5A0) indique l'adresse du
     cookiejar (ou NULL si le cookiejar n'existe pas. C'est cette
     adresse que retourne get_cookiejar(). A partir de cette adresse
     on trouve une liste de cookie. Chaque cookie occupe 8 octects
     (deux mot long). Le premier mot long sert … identifier le cookie
     (c'est g‚n‚ralement 4 lettres ascii et les cookies placer par le
     TOS commencent par la lettre '_'). Le second mot long d‚pend du
     cookie, c'est g‚n‚ralement une adresse … partir de laquelle on
     peut obtenir diverses informations. Le dernier cookie de la
     liste possŠde un identificateur qui vaut NULL, et son deuxiŠme
     mot long contient le nombre total de cookie dans le cookiejar.

          0x5A0 ----> cookiejar
                         |
                       cookie 1  __ identificateur (4 octects)
                         |       \_ valeur (4 octets)
                       cookie 2  __ identificateur (4 octects)
                         |       \_ valeur (4 octets)
                         .
                         .
                         .
                         |
                       dernier cookie __ identicateur = 0
                         |            \_ valeur = nombre total de cookie (N)
                         .
                         .
                         .
                         |
                       dernier cookie libre (N-iŠme cookie)


15.3  new_cookie()
==================

 NOM
     new_cookie() - insertion d'un cookie dans le cookiejar

 PROTOTYPAGE
     int *new_cookie( long cookie, long value);

 PARAMETRES

      cookie: identificateur du cookie a ins‚rer,

      value:  valeur du cookie a ins‚rer,

      valeur retourn‚e: 0 si echec (cookiejar plein) 1 sinon.

 DESCRIPTION
     Cette fonction insŠre un cookie cookie dans le cookiejar.
     Attention, si le cookiejar est plein, cette fonction ne
     r‚ajustera pas la taille du cookiejar et l'on risquera un
     plantage du systŠme. La r‚allocation du cookiejar est assez
     difficile … faire, il vaut utiliser un patch pour ‚tendre la
     taille du cookiejar.

 VOIR AUSSI
     set_cookie().


15.4  set_cookie()
==================

 NOM
     set_cookie() - modification d'un cookie dans le cookiejar.

 PROTOTYPAGE
     int *set_cookie( long cookie, long value);

 PARAMETRES


      cookie: identificateur du cookie a modifier,

      value:  nouvelle valeur du cookie,

      valeur retourn‚e: 0 si echec (cookie absent) 1 sinon.

 DESCRIPTION
     Cette fonction modifie le champ value du cookie cookie dans le
     cookiejar.

 VOIR AUSSI
     new_cookie().



Chapitre 16

Librairie Bubble
****************

Windom intŠgre des routines pour appeller facilement BubbleGEM
programme qui permet d'afficher des bulles d'aides.


16.1  BubbleCall()
==================

 NOM
     BubbleCall - Appel simple de BubbleGEM

 PROTOTYPAGE
     int BubbleCall( char *help, int x, int y);

 PARAMETRES

            help: le texte de la bulle d'aide,

            x,y: position de la bulle d'aide (g‚n‚ralement celle de
            la souris),

            valeur de retour: 0 si pas d'erreur, voir (CODE
            D'ERREURS).

 CODE D'ERREUR
     BubbleCall renvoit une valeur n‚gative en cas d'erreur:

      -1: BubbleGEM n'est pas en m‚moire,

      -2: la variable d'environnement 'BUBBLE=' est incorrecte,

      -3: erreur d'allocation m‚moire.

 DESCRIPTION
     BubbleCall() envoit un message … BubbleGEM qui affiche
     simplement la bulle d'aide, et ne rend la main que lorsque
     BubbleGEM le lui demande. Si BubbleGEM n'est pas en m‚moire,
     BubbleCall() cherche la variable d'environnement BUBBLE (dans le
     buffer de l'AES). Celle-ci doit indiquer le chemin complet du
     programme BUBBLE.APP. Si cette variable existe, BubbleCall()
     charge lui-mˆme BubbleGEM en m‚moire. Le texte de bulle d'aide
     (point‚ par help) est recopi‚ dans un buffer qui sera lib‚r‚ de
     la m‚moire par BubbleGEM.

 REMARQUES
     Attention, l'AES ne doit pas ˆtre bloqu‚ pour que ce la
     fonctionne. Ainsi ne compter pas appeler BubbleGEM dans un
     formulaire GEM bloquant!

     Cette fonction se contente d'afficher la bulle d'aide. C'est au
     programmeur de decid‚ ou et quand affich‚ la bulle. Par
     convention, l'aide est d‚clench‚ par le bouton droit de la
     souris et depend du contexte ( c'est … dire de l'endroit point‚
     par la souris). Toutefois, les fonctions BubbleAttach() et
     BubbleEvnt() permet d'attribuer des bulles … des objets et de
     d‚clencher leur affichage au bon momment.

 VOIR AUSSI
     La documentation hypertexte de BubbleGEM. (voir "BUBBLE.HYP")
     BubbleAttach(), BubbleEvnt(), BubbleFree().


16.2  BubbleAttach()
====================

 NOM
     BubbleAttach - Attribution de bulle d'aide … des objets.

 PROTOTYPAGE
     int BubbleAttach( OBJECT *tree, int index, char *help);

 PARAMETRES

      tree:  adresse de l'arborescence d'objet,

      index: index de l'objet,

      help:  texte de la bulle d'aide,

      valeur de retour: 0 si pas d'erreur, -1 sinon (erreur m‚moire).

 DESCRIPTION
     Cette fonction attribue une bulle d'aide … un objet dans un
     formulaire ou un toolbar. Les textes sont stock‚ en m‚moire, ils
     seront utilis‚ par BubbleEnvt() pour afficher les bulles
     d'aides. En fin de programme, les bulles devront ˆtre lib‚r‚ de
     la m‚moire par BubbleFree(). Attention!, le texte de la bulle
     d'aide n'est pas recopi‚ en m‚moire.

 VOIR AUSSI
     BubbleEvnt(), BubbleFree(), BubbleFind().


16.3  BubbleEvnt()
==================

 NOM
     BubbleEvnt - gestion des bulles d'aide attribu‚es avec
     BubbleAttach().

 PROTOTYPAGE
     int BubbleEvnt(void);

 PARAMETRES
     valeur de retour:

        ù 0 si aucune bulle d'aide n'a ‚t‚ trouv‚e,

        ù WS_FORM si la bulle a ‚t‚ trouv‚ dans un formulaire,

        ù MW_TOOLBAR si la bulle a ‚t‚ trouv‚ dans un toolbar.

 DESCRIPTION
     Cette fonction cherche parmi les bulles d'aides celle qui
     correspond … l'objet point‚ par la souris au retour d'un
     ‚venement MU_BUTTON (elle utilise les coordonn‚es donn‚es par
     evnt.mx et envt.my), et l'affiche. Cela fonctionnera donc pour
     les formulaires en fenˆtres ou les toolbar mais PAS les
     formulaires bloquant. Notez que BubbleEvnt() utilise la variable
     real de la structure W_FORM pour recherch‚ le bon arbre d'objet
     (c'est ce qui lui permet de fonctionner avec les toolbar car ces
     derniers sont toujours dupliqu‚s en m‚moire par WindSet()).

 EXEMPLE


     int main(void)
     {
     	OBJECT *tree;
     	int res;
     
     	ApplInit();
     	RsrcLoad( "TEST.RSC");
     	rsrc_gaddr( 0, FORM1, &tree);
     
     	/* On attache les bulles aux objets ... */
     	BubbleAttach( tree,  0, "Fond du formulaire"); 	/* FORM1 */
     	BubbleAttach( tree, OK, "Bouton de sortie");  	/* FORM1 */
     
     	/* Cr‚ation d'un formulaire */
     	FormCreate( tree, MOVER|NAME, NULL, "test", NULL, 1, 0);
     
     	/* On gŠre les clicks souris GAUCHE et DROIT */
     	evnt.bclick = 258;
     	evnt.bmask = 0x1|0x2;
     	evnt.bstate = 0;
     
     	do {
     		res = EvntWindom( MU_MESAG|MU_BUTTON);
     		/* bouton droit click‚ ? */
     		if( res & MU_BUTTON && evnt.mbut & 0x2) {
     			BubbleEvnt(); /* Affiche la bonne bulle */
     		}
     	} while( wglb.first);
     
     	BubbleFree();  /* Lib‚rer les bulles! */
     	RsrcFree();
     	ApplExit();
     	return 0;
     }

     Pour les formulaires modaux, on peut aussi gerer les bulles
     d'aides avec BubbleEvnt(), en utilisant le flag
     FORM_EVNT|MU_BUTTON dans la fonction FormWinDo():

     int main(void)
     {
     	OBJECT *tree;
     	int res;
     
     	ApplInit();
     	RsrcLoad( "TEST.RSC");
     	rsrc_gaddr( 0, FORM1, &tree);
     
     	/* On attache les bulles aux objets ... */
     	BubbleAttach( tree,  0, "Fond du formulaire"); 	/* FORM1 */
     	BubbleAttach( tree, OK, "Bouton de sortie");  	/* FORM1 */
     
     	/* On gŠre les clicks souris GAUCHE et DROIT */
     	evnt.bclick = 258;
     	evnt.bmask = 0x1|0x2;
     	evnt.bstate = 0;
     
     	/* Ouvrir le formulaire modal */
     	FormWindBegin(tree, "Formulaire modal");
     
     	do {
     		/* Attendre un objet cliqu‚ ou un ‚venement */
     		res = FormWindDo( MU_MESAG|MU_BUTTON|FORM_EVNT);
     		if( (res & FORM_EVNT) && (res & MU_BUTTON))
     			BubbleEvnt(); /* afficher les bulles */
     	} while( res != OK); /* Sortir si OK cliqu‚ */
     
     	FormWindEnd(); /* Fermer le formulaire */
     	BubbleFree();  /* Lib‚rer les bulles! */
     	RsrcFree();
     	ApplExit();
     	return 0;
     }

 VOIR AUSSI
     BubbleAttach(), BubbleFree(), BubbleFind(), W_FORM.


16.4  BubbleFree()
==================

 NOM
     BubbleFree - lib‚ration m‚moire des bulles d'aide.

 PROTOTYPAGE
     void BubbleFree( void);

 DESCRIPTION
     Cette fonction libŠre de la m‚moire les bulles qui ont ‚t‚
     attach‚es avec BubbleAttach().

 VOIR AUSSI
     BubbleAttach().


16.5  BubbleFind()
==================

 NOM
     BubbleFind - Recherche de bulle d'aide.

 PROTOTYPAGE
     int BubbleFind( OBJECT *tree, int index, char **help)

 PARAMETRES

      tree:  adresse de l'arborescence concern‚e,

      index: index de l'objet dans l'arborescence,

      help:  adresse du pointeur vers le texte de la bulle d'aide,

      valeur de retour: 1, si la bulle a ‚t‚ trouv‚e, 0 sinon.

 DESCRIPTION
     BubbleFind() est une sous fonction de BubbleEvnt(), elle permet
     de trouver le texte de la bulle d'aide qui a ‚t‚ attach‚e … un
     objet par BubbleAttach(). On peut ensuite passer le texte de la
     bulle … BubbleCall() qui l'affichera.

 VOIR AUSSI
     BubbleCall().



Chapitre 17

Librairie utils
***************

Contient diverses fonctions utiles...


17.1  CallStGuide()
===================


17.2  GrectCenter()
===================


17.3  rect_set()
================


17.4  rc_intersect()
====================


17.5  w_get_bkgr()
==================


17.6  w_put_bkgr()
==================




Annexe A

Syntaxe du fichier windom.cnf
*****************************

Ce fichier rŠgle certains paramŠtres de la librairie ( voir
ParamŠtrage de Windom et Le fichier de configuration de WinDom).

Mots clefs

Les espaces et tabulations sont ignor‚s. Les lignes commen‡ant par le
caractŠre '#' sont ignor‚s. La syntaxe g‚n‚rale est:

MOT_CLEF = LISTE_DE_PARAMETRES

Les mots clefs ne sont pas sensible aux majuscules.

Voici la liste des mots clefs existant:

les signes <> n'existent que pour clarifier les notations

# Fixer la couleur des textes soulign‚ et cadres
xtype_string_color = <index VDI de couleur>

# Fixer la couleurs du texte des boutons ‚tendus EXIT
xtype_exit_button_color = <index VDI de couleur>

# Fixer la couleurs du textes des autres boutons ‚tendus
xtype_other_button_color = <index VDI de couleur>

# Fixer la fonte des objets ‚tendues
xtype_font_name = <nom de la fonte entre quote>

# Fixer la taille de la fonte des objets ‚tendues
xtype_fonte_size = <taille en point de la fonte>

# Fixer la couleurs des raccourcis claviers
xtype_shortcut_color = <index VID de couleur>

mu_keybd_on_mouse = {true|false}

mu_button_on_mouse = {true|false}

# Fixer la taille des fenˆtres ic“nes
icon_geometry = <valeur entiŠre,valeur entiŠre>

# Fixer le nombre de clignotement lors de la s‚lection
# des entr‚es des menus en fenˆtre
menu_effect = <valeur entiŠre>

Configuration par programmes

Le fichier est divis‚ en diff‚rentes parties. Chaque partie concerne
un programme. Ces parties ou zones commencent par la balise
"[NOM_APPLI]" et se terminent par la balise "[end]". Le nom des
applications est au format GEM c'est … dire un nom en majuscule sans
extension. Ainsi programmes et accessoires sont indiff‚renci‚s. Il
existe une balise particuliŠre qui permet de fixer la configuration
par d‚faut, c'est-…-dire par les programmes non d‚clar‚s dans le
fichier. Cette balise est: "[Default Settings]"

Exemple de config

#
#	WINDOM.CNF
#

[Default Settings]
xtype_exit_button_color	 = 15
xtype_other_button_color = 14
xtype_string_color		 = 1
xtype_shortcut_color	 = 3

menu_effect				 = 3
[end]

[NOTES]
xtype_exit_button_color	 = 15
xtype_other_button_color = 14
xtype_string_color		 = 1
xtype_shortcut_color	 = 3
xtype_font_name			 = "Comic Sans MS"
xtype_font_size			 = 13 pts
menu_effect				 = 3
[end]

[AWELE]
mu_button_on_mouse		 = true
[end]

#
#	End of file
#



Annexe B

Nouveaut‚s
**********

Version de Aout 97:

   ù Formulaire multiple: ajout du bouton onglet (MLTIFRM).

   ù Ajout du bouton KPOPUPSTR pour donner des raccourcis claviers
     aux popup.

   ù Ajout d'un fichier de configuration des applications WinDom

   ù Ajout de nouveaux champs dans APPvar pour g‚rer la couleurs des
     objets ‚tendus.

   ù disparition des champs test, keybd et button dans APPvar
     remplac‚ par le champ flag organis‚ en champs de bits. Les bits
     libres permettront une extension du systŠme.

   ù ajout des champs m1 et m2 dans WINDOW correspondant aux message
     MU_M1 et MU_M2.

   ù MenuPopUp() est en pleine mutation mais le codage n'est pas
     termin‚

   ù bugs fix‚s dans les routines de gestions des raccourci claviers
     et des champs ‚ditables (elles ne prenaient pas en compte les
     objets HIDETREE)

Version de Mai 97:

   ù ajout de la librairie frame,

   ù ajout de la librairie bubble,

   ù ajout du champ extramsg dans la structure WINDOW,

   ù debugguage divers.



Annexe C

Comparaison AES/Windom
**********************


+----------------+---------------+-------------------------------------------+
|      AES       |    Windom     | Remarques                                 |
+----------------+---------------+-------------------------------------------+
|  appl_init()   |  ApplInit()   | incompatible                              |
|  appl_exit()   |  ApplExit()   | incompatible                              |
|   autres ...   |       -       | inchang‚...                               |
+----------------+---------------+-------------------------------------------+
|  evnt_multi()  | EvntWindom()  | incompatible                              |
|   autres ...   |       -       | possible mais sans gestion des ‚venements |
+----------------+---------------+-------------------------------------------+
|   menu_bar()   |   MenuBar()   | incompatible                              |
| menu_tnormal() | MenuTnormal() | incompatible                              |
|   autres ...   |       -       | inchang‚                                  |
+----------------+---------------+-------------------------------------------+
| objc_change()  | ObjcChange()  | compatible                                |
|  objc_draw()   |  ObjcDraw()   | compatible                                |
|  objc_edit()   |  ObjcEdit()   | en projet ...                             |
|   autres...    |       -       | inchang‚                                  |
+----------------+---------------+-------------------------------------------+
|  form_alert()  |       -       | inchang‚                                  |
|  form_error()  |       -       | inchang‚                                  |
|   autres...    |       -       | obsolŠte (voir fonctions Form)            |
+----------------+---------------+-------------------------------------------+
|  wind_calc()   |  WindCalc()   | compatible                                |
|  wind_close()  |  WindClose()  | incompatible                              |
| wind_create()  | WindCreate()  | incompatible                              |
| wind_delete()  | WindDelete()  | incompatible                              |
|  wind_find()   | WindHandle()  | compl‚mentaire                            |
|   wind_get()   |   WindGet()   | incompatible                              |
|   wind_new()   |   WindNew()   | en projet ...                             |
|  wind_open()   |  WindOpen()   | incompatible                              |
|   wind_set()   |   WindSet()   | incompatible                              |
| wind_update()  |       -       | inchang‚                                  |
+----------------+---------------+-------------------------------------------+
|  rsrc_load()   |  RsrcLoad()   | incompatible                              |
|  rsrc_free()   |  RsrcFree()   | incompatible                              |
|  autres...()   |       -       | inchang‚                                  |
+----------------+---------------+-------------------------------------------+

        (Tableau 13: Comparaisons des fonctions AES et Windom)




Annexe D

Diff‚rentes versions de l'AES
*****************************

L'AES (Application Environment Service) est la partie du systŠme
d'exploitation des compatibles TOS responsable de l'interface
graphique avec l'utilisateur. En ce sens on peut le comparer avec X11
ou encore Windows. L'AES a ‚t‚ developper originellement par les
laboratoires de Digital Research. C'est lui qui s'occupe de gerer les
fenˆtres, les evenements, les ressources graphique. Il peut gerer
aussi le lancement des applications. Voi‡i une petite liste des
diff‚rentes versions de l'AES:



Annexe E

Noms et marques cit‚es
**********************

GEM est une marque d‚pos‚ par Digital Research. Atari et MultiTOS
sont des marques d‚pos‚s par Atari Corp. Unix est une marque d‚pos‚
par Unix Systems Laboratories. Windows est une marque d‚pos‚ par
Microsoft Corp. Finder est une marque d‚pos‚ par Apple Computers.
Nvdi, Magic, MagicMac et MagicPc sont des marques d‚pos‚ par
Applications Systeme. Geneva est une marque d‚pos‚ par Gribnif
Software.

Interface et MyDial sont des logiciels ‚crit par Olaf Meisiek. Let's
them fly est ‚crit par Olivier Scheel et Darryl Pipper. Iconify
Server est ‚crite par Iconify Server par Dirk Haun. BiG est ‚crit par
Claude Attard. EgLib est ‚crit par Christophe Boyanique. BubbleGEM
est ‚crit par Thomas Much.



Annexe F

R‚f‚rences
**********

   ù The Atari Compendium, par Scott Sanders, 1994 ‚dit‚ par SDS
     Publishing,

   ù Le livre du D‚veloppeur, tome 1 et 2 , Micro Application 1989,

   ù Professional GEM, par Tim Orems.



Annexe G

Le mot de la fin
****************

Et enfin, je voudrais terminer par quelques consid‚rations
philosophiques. Cette librarie ainsi que d'autre de la serie (WinVdi,
WinEdit, etc ...) sont encore beta puisqu'elles n'ont pas ‚t‚ test‚
de maniŠre rigoureusement sur tous les sytŠmes TOS existants.
N‚anmoins aprŠs quelque ann‚es d'‚volutions, ces librairies sont bien
stabilis‚ (sur mon Falcon du moins) aussi je vous les livre telles
qu'elles afin qu'elles puissent ˆtre test‚ ET utilis‚ pour les
AMELIORER.

D'autre part, il existe pleins d'autres libraries GEM existantes
principalement fran‡aises et allemandes. J'en ai des batteries
entiŠres dans mes disquettes. Toutefois je ne me suis inspir‚s de que
deux librairies:

   ù BiG uniquement pour l'id‚e des pointeurs de fonctions qui, a
     l'‚poque, n'etait pas trŠs r‚pandu et la gestion des sliders.
     Toutefois la ressemblances avec WinDom s'arrˆte la. Car le
     trouve que BiG a trop de fonctions avec des prototypages
     compliqu‚s et de plus trop haut niveaux ... A part ca il n'y a
     rien a redire puisqu'elle marche vraiment trŠs bien (au vu des
     applications qui l'utilisent), mais l'auteur semble avoir arrˆt‚
     son developpement.

   ù EgLib dont j'ai piqu‚ les routines de chargement de ressource
     pour mon constructeur d'application, routines elles-mˆme
     inspir‚s de xrsrc d'Interface. Cette librarie est trŠs trŠs
     belle. TrŠs complŠte et vraiment pro avec une trŠs bonne aide en
     ligne int‚gr‚, une gestion de la m‚moire et des langues. Les
     fichiers systŠmes et ressources sont centralis‚s dans des
     directory <systŠmes> et le code est vraiment trŠs bien ‚crit
     (c'est b“ l'informatique parfois!). Mais la programmation est la
     encore assez bizarre et je fais le mˆme reproche que pour BiG.

Donc, nous avons en France de trŠs bon programmeurs GEM ‡a c'est sur!
Je ne citerai pas toutes les autres librairies que je connais mais
y'en a bien une quinzaine. J'ai fais le reste avec mes petites mains.
Ma conception de la programmation du GEM est plus orient‚s GEM lui-
mˆme. Pendant l'‚t‚ 96, il y a eu des discutions interessantes avec
des programmeurs GEM sur les news atari fran‡aises. On a senti un
vague desir d'essayer de de standardiser une librairie GEM qui
pourrait ˆtre une sur-couche normalis‚ de GEM lui-mˆme afin de
simplifier la programmation GEM pour faciliter le developpement sur
nos machines. Et c'est dans cette optique que je distribue mes
librairies. Regardez ce que j'ai fais et ce que je peux faire.
Discutons-en! Moi je m'interesse aussi … ce que vous faites et
inutile de reinventer la roue chacun dans son coin! Collaborons
enfin!

Je veux remercier particuliŠrement Olivier Landemarre pour ses
conseils et ses remarques ainsi que pour nos long ‚changes id‚es sur
le net.
