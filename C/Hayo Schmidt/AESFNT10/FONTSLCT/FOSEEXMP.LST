' FOSEEXMP - Multifont-Example
' ΩHayoSoft 1989/90
'
REM Dieses Listing soll keinen Hîhepunkt der Programmierkunst darstellen,
REM sondern Ihnen einige Hinweise geben, wie man mit dem Programm FONTSLCT
REM zusammenarbeiten kann.
REM Ich hoffe, daû sich einige Programmierer inspirieren lassen.
REM
'
RESERVE 10000
DEFMOUSE 0
GRAPHMODE 1
ap_id&=APPL_INIT()
fontselector_id&=APPL_FIND("FONTSLCT")
'
~GRAF_HANDLE()
'
IF GDOS?
  ~VST_LOAD_FONTS(0) ! GDOS muû natÅrlich auch geladen werden
ENDIF
'
DIM menue$(22)
FOR i%=0 TO 22
  READ menue$(i%)
NEXT i%
DATA  ,  FOSEEXMP-Info,-----------------------,1,2,3,4,5,6,
DATA Diverses, Probe,--------------, Font-Daten, FOse struct,--------------, Aufrufen , Execute ,--------------
DATA  Quit ,,éndern, der Font-Daten ,,
'
MENU menue$()
TITLEW #1,"FONTselector-Message-Test"
OPENW #1,0,19,640,300,&X1
CLS
'
IF @getcookie("FOse",cookieptr%,dummy%)
  PRINT "Cookie gefunden"
  IF CHAR{cookieptr%}<>"FOse" ! Sicherungsabfrage
    PRINT "aber ungÅltige Variablenstruktur - Programmabbruch"
    IF GDOS?
      ~VST_UNLOAD_FONTS(0)
    ENDIF
    CLOSEW #1
    EDIT
  ELSE
    fose_struct
    currdata
  ENDIF
  '
ELSE
  PRINT "Kein FOse-Cookie da"
  aes_face&=1                              ! irgendwelche Voreinstellungen
  aes_height&=13
  face&=1
  height&=13
  effect&=0
  '
ENDIF
'
ON MENU GOSUB menueauswertung
ON MENU MESSAGE GOSUB messageauswertung
'
~FORM_DIAL(3,0,0,0,0,0,0,WORK_OUT(0),WORK_OUT(1))
DO
  ON MENU
LOOP
' ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'
PROCEDURE menueauswertung
  '
  IF mode&=1                            ! Hîhe im points mode
    ~@vst_point(V~H,height&,dummy&,set_height&,dummy&,dummy&)
    DEFTEXT ,effect&,,set_height&,face&
  ELSE                                  ! Hîhe im absolute mode
    DEFTEXT ,effect&,,height&,face&     ! Muû 2 mal aufgerufen werden
    DEFTEXT ,effect&,,height&,face&     !             (GFA-Basic Bug)
  ENDIF
  '
  SELECT MENU(0)
    '
  CASE 1  ! Info
    OPENW 1
    PRINT
    PRINT "                 FONTselector-Example ist ein Hilfsprogramm"
    PRINT "                         zum Accessory FONTSLCT"
    PRINT "                       Copyright HayoSoft 1989/90"
    PRINT "        Hayo Schmidt  Grotiusweg 1  2000 Hamburg 55 Tel.: 040/864330"
    '
  CASE 11 ! Probe
    OPENW 1
    REM    Demonstration fÅr die unterschiedlichen Effekte bei der Auswahl
    REM       der Fonts und der beeinfluûten Font-Header (RAM|ROM|ESC)
    CLS
    PRINT AT(1,1);"Das ist ein Beispiel mit Print (GFA-Basic spezifisch)"
    '                                                         ! RAM oder FONT#
    TEXT 0,120,"Das ist ein Beispiel mit Text"                ! RAM oder FONT#
    ATEXT 0,260,2,"Das ist ein Beispiel mit ATEXT"            ! ROM
    CLOSEW 0                              ! Fenster ausschalten
    PRINT AT(1,24);"Das ist ein Beispiel mit Print (Åber Console-Ausgabe, z.B. Cconws())"
    OPENW 1                                                   ! ESC
    '
  CASE 13 ! Daten ansehen
    OPENW 1
    CLS
    PRINT "GegenwÑrtige Font-Einstellungen:"
    PRINT
    GOSUB currdata
    '
  CASE 14 ! FOse-Pointer
    IF fontselector_id&<>-1
      message$=MKI$(&HF05E)+MKI$(ap_id&)+MKI$(0)+MKI$(1)+MKI$(0)+STRING$(6,0)
      ~APPL_WRITE(fontselector_id&,16,V:message$)
    ELSE
      PRINT "Wo ist das FONTSLCT-Accessory ?"
    ENDIF
    '
  CASE 16 ! Send Message
    REM    Senden einer Mitteilung an FONTSLCT.ACC mittels APPL_WRITE()
    IF fontselector_id&<>-1
      sx&=WORK_OUT(0)-sw& ! Koordinaten der FONTselector-Dialogbox
      sy&=WORK_OUT(1)-sh& ! z.B. auf rechte unter Ecke setzen
      '
      PRINT "Sende Message $F05e "
      message$=MKI$(&HF05E)+MKI$(ap_id&)+STRING$(12,0)
      ~WIND_UPDATE(3)
      ~APPL_WRITE(fontselector_id&,16,V:message$)
      ~WIND_UPDATE(2)
    ELSE
      PRINT "Wo ist das FONTSLCT-Accessory ?"
    ENDIF
    '
  CASE 17 ! EXEC
    OPENW 1
    REM                 Aufruf von MULTIFONT als Programm
    IF MALLOC(-1)>80000                                ! genug Speicherplatz ?
      PRINT "EXEC 0,'FONTSLCT.AC?','X',''"
      ~WIND_UPDATE(3)
      fose$="FONTSLCT.AC?"
      ~SHEL_FIND(fose$)
      ret%=EXEC(0,fose$,"X","")  ! "X" = Meldungen unterdrÅcken
      CLS
      PRINT "EXEC 0,'FONTSLCT.AC?','X',''"
      PRINT " RÅckgabecode ";ret%
      ~WIND_UPDATE(2)
    ELSE
      PRINT "Nicht genÅgend Speicherplatz fÅr EXEC"     ! Pech gehabt
    ENDIF
    '
  CASE 19 ! Quit
    sx&=alt_sx&         ! Dialogbox-Koordinaten auf Anfangswert zurÅcksetzen
    sy&=alt_sy&
    '
    IF GDOS?
      ~VST_UNLOAD_FONTS(0)
    ENDIF
    CLOSEW #1
    EDIT
    '
  CASE 22 ! Neue Daten
    OPENW 1
    CLS
    PRINT "Neue Fontdaten eingeben:"
    PRINT "------------------------"
    INPUT "Font-ID: ",face&      ! Diese Daten kînnen verÑndert werden
    INPUT "Font-Hîhe: ",height&  ! und werden von MULTIFONT Åbernommen.
    INPUT "Texteffekt: ",effect& !
    '
    INPUT "Modus Ñndern: J/N ",txt$
    IF UPPER$(txt$)="J"
      IF mode&=1
        mode&=0
      ELSE
        mode&=1
      ENDIF
    ENDIF
    '
    ' INPUT "AES-ID:",aes_face&     ! Dagegen werden diese Daten von MULTIFONT
    ' INPUT "AES-Hîhe:",aes_height& ! spÑter wieder zurÅckgesetzt.
    '
  ENDSELECT
  '
  MENU OFF
RETURN
' ------------------------------------------
PROCEDURE messageauswertung
  WORD{V:fose_msg&}=&HF05E ! <- da GFA-Basic nur signed int hat!
  SELECT MENU(1)
  CASE 20     ! WM_REDRAW
    '
  CASE 21     ! WM_TOPPED
    OPENW 1
    CLS
    '
  CASE fose_msg& ! Fontselector
    IF MENU(2)=fontselector_id& AND MENU(4)=2 ! FOse struct zurÅckgegeben
      OPENW 1
      CLS
      cookieptr%={MENU(-2)+8}
      fose_struct          ! an Struktur anpassen
      PRINT "'FOse' struct ist an $";HEX$(cookieptr%)
      PRINT "Kennung: ";CHAR{cookieptr%}
      PRINT "Version :";HEX$(WORD{cookieptr%+4});".";HEX$(WORD{cookieptr%+6})
    ENDIF
  ENDSELECT
RETURN
' ------------------------------------------
PROCEDURE currdata
  IF cookieptr%>0
    PRINT ,"Font-ID","Hîhe","Effekt","Mode"
    PRINT "FONTselector Version ";HEX$(WORD{cookieptr%+4})+".";HEX$(WORD{cookieptr%+6});":"
    PRINT ,face&,height&,BIN$(effect&,5),mode&
    PRINT "AuswÑhlen -VDI:"
    PRINT ,vdi_face&,vdi_height&,BIN$(vdi_effect&,5),vdi_mode&
    PRINT "AES-Daten:"
    PRINT ,aes_face&,aes_height&,aes_effect&
    PRINT "FONTSLCT VDI-Handle:"
    PRINT ,fose_vdi_hd&
    PRINT "FONTSLCT Window-Handle:"
    PRINT ,fose_wind_hd&
  ELSE
    PRINT "'FOse'-Struktur unbekannt"
  ENDIF
RETURN
' -------------------------------------
FUNCTION getcookie(cookie$,VAR p_value%,max_cookies%)
  $F%
  ' Cookie auslesen
  ' ---------------
  ' cookie$        Kennung
  ' p_value%       Wert programmabhÑngig
  ' max_cookies    Anzahl mîglicher Cookies
  '
  LOCAL jar%
  ' GLOBAL cookiejar%
  cookiejar%=LPEEK(&H5A0)
  IF cookiejar%=0
    max_cookies%=0
  ELSE
    jar%=cookiejar%
    WHILE {jar%}<>0
      ' PRINT CHAR{jar%},{jar%+4} !!! Alle Cookies ausgeben
      jar%=jar%+8
    WEND
    max_cookies%={jar%+4}
    ' PRINT ,max_cookies%,"*"     !!!
    '
    DO                          ! Cookie-Suchschleife
      IF {cookiejar%}={V:cookie$}
        p_value%={cookiejar%+4}
        RETURN TRUE
      ENDIF
      cookiejar%=cookiejar%+8
    LOOP UNTIL {cookiejar%}=0
  ENDIF
  RETURN FALSE
ENDFUNC
' ------------
FUNCTION setcookie(cookie$,p_value%)
  $F%
  ' Cookie einfÅgen (braucht man hier nicht - nur zum besseren VerstÑndnis)
  ' ---------------
  ' cookie$        Kennung
  ' p_value%       Wert programmabhÑngig
  ' max_cookies    Anzahl mîglicher Cookies
  '
  LOCAL new_jar%,jar%,i%,max_cookies%
  ' GLOBAL cookiejar%
  '
  cookiejar%=LPEEK(&H5A0)
  IF cookiejar%=0               ! Keine Cookies vorhanden
    IF @cookie_alloc(8,cookiejar%)=FALSE
      RETURN FALSE
    ENDIF
    {cookiejar%+4}=8
  ENDIF
  '
  jar%=cookiejar%
  i%=1
  WHILE {jar%}<>0
    INC i%
    jar%=jar%+8
  WEND
  max_cookies%={jar%+4}
  '
  IF i%>=max_cookies%           ! Cookie Jar bereits voll
    IF @cookie_alloc(max_cookies%+8,new_jar%)=FALSE
      RETURN FALSE
    ENDIF
    BMOVE cookiejar%,new_jar%,max_cookies%*8
    {new_jar%+(max_cookies%-1)*8+4}=max_cookies%+8
    cookiejar%=new_jar%+(max_cookies%-1)*8
  ELSE
    cookiejar%=jar%
  ENDIF
  '
  {cookiejar%+8}={cookiejar%}   ! NULL-Cookie verschieben
  {cookiejar%+12}={cookiejar%+4}
  {cookiejar%}={V:cookie$}      ! und neuen einfÅgen
  {cookiejar%+4}=p_value%
  '
  RETURN TRUE
ENDFUNC
' ++++++++++++++++++++++++++++++++++
'
FUNCTION cookie_alloc(zahl&,VAR cjar%)
  $F%
  ' Speicher allozieren
  LOCAL i%
  cjar%=MALLOC(zahl&*8) ! ACHTUNG <--> muû resident sein !
  IF cjar%>0
    SLPOKE &H5A0,cjar%
    FOR i%=0 TO zahl&-1 STEP 4
      {cjar%+i%}=0
    NEXT i%
    ' {cjar%+4}=zahl&
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
' --------------------------------------------------
FUNCTION vst_font(vstf_handle&,vstf_font&)
  $F%
  ' nicht benîtigt, da in DEFTEXT einzustellen
  CONTRL(6)=vstf_handle&
  INTIN(0)=vstf_font&
  VDISYS 21,1,0
  RETURN INTOUT(0)
ENDFUNC
' ------------------------------------------
FUNCTION vst_point(vstp_handle&,vstp_point&,VAR vstp_charw&,vstp_charh&,vstp_cellw&,vstp_cellh&)
  REM                     Grîûeneinstellung im points mode
  $F%
  CONTRL(6)=vstp_handle&
  INTIN(0)=vstp_point&
  VDISYS 107,1,0
  vstp_charw&=PTSOUT(0)
  vstp_charh&=PTSOUT(1)
  vstp_cellw&=PTSOUT(2)
  vstp_cellh&=PTSOUT(3)
  RETURN INTOUT(0)
ENDFUNC
' ------------------------------------------
FUNCTION vst_height(vsth_handle&,vsth_height&,VAR vsth_charw&,vsth_charh&,vsth_cellw&,vsth_cellh&)
  REM Wird hier nicht explizit benîtigt, da DEFTEXT diese Funktion aufruft
  $F%
  CONTRL(6)=vsth_handle&
  PTSIN(0)=0
  PTSIN(1)=vsth_height&
  VDISYS 12,0,1
  vsth_charw&=PTSOUT(0)
  vsth_charh&=PTSOUT(1)
  vsth_cellw&=PTSOUT(2)
  vsth_cellh&=PTSOUT(3)
  RETURN 0
ENDFUNC
' ------------------------------------------
PROCEDURE fose_struct
  ' "FOse"                              ! LONG  Kennung
  '  $00000010                          ! LONG  Versionsnummer
  ABSOLUTE face&,cookieptr%+8           ! WORD  VDI Font-ID Beispielfenster
  ABSOLUTE height&,cookieptr%+10        ! WORD  Font-Hîhe   Beispielfenster
  ABSOLUTE effect&,cookieptr%+12        ! WORD  Texteffekt (Schriftart) "
  ABSOLUTE mode&,cookieptr%+14          ! WORD  Modus - points/absolute "
  '
  ABSOLUTE vdi_face&,cookieptr%+16      ! WORD  mit VDI-Feld eingestellte ID
  ABSOLUTE vdi_height&,cookieptr%+18    ! WORD  von VDI-Feld   " Font-Hîhe
  ABSOLUTE vdi_effect&,cookieptr%+20    ! WORD   "   "   "     " Texteffekt
  ABSOLUTE vdi_mode&,cookieptr%+22      ! WORD   "   "   "     " Modus
  '
  ABSOLUTE aes_face&,cookieptr%+24      ! WORD  AES Font-Id
  ABSOLUTE aes_height&,cookieptr%+26    ! WORD  AES Fonthîhe
  ABSOLUTE aes_effect&,cookieptr%+28    ! WORD  AES-Texteffekt
  '
  ABSOLUTE sx&,cookieptr%+30            ! WORD  X-Koordinate Dialogbox
  ABSOLUTE sy&,cookieptr%+32            ! WORD  Y-Koordinate Dialogbox
  ABSOLUTE sw&,cookieptr%+34            ! WORD  Breite
  ABSOLUTE sh&,cookieptr%+36            ! WORD  Hîhe
  '
  ABSOLUTE fose_vdi_hd&,cookieptr%+38   ! WORD  VDI-Handle von FONTselector
  ABSOLUTE fose_wind_hd&,cookieptr%+40  ! WORD  Window-Handle von FONTselector
  '
  alt_sx&=sx& ! Anfangs-Koordinaten der MULTIFONT-Dialogbox merken
  alt_sy&=sy&
  '
RETURN
