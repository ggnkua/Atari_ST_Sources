Kurze Einleitung:
-----------------

Die  vorliegenden  Programmroutinen input und output  ntzen  vor  allem 
  
Elektronikern,  welche eigene Rechenprogramme entwickeln. Wie sch”n w„re 
  
es doch, grosse und kleine Werte an Stelle der gewohnten Exponentialdar-
  
stellung,  mittels Gr”ssenordnungssymbolen einzugeben.  Dies  erm”glicht 
  
die Eingaberoutine.  Die Ausgaberoutine erledigt das Gegenteil. Sie gibt 
  
grosse  und  kleine  Werte an  Stelle  der  Exponentialdarstellung,  mit 
  
Gr”ssenordungssymbolen  ber das  Standartausgabeger„t,  dem  Bildschirm 
  
heraus.
  




Inhaltsverzeichnis
------------------

   Einleitung

   Das Eingabeformat

   Das Ausgabeformat

   Das Gemeinsame des GFA-3.x-BASIC- und TURBO-C-Listing

      Die Testroutine
   
      Die Eingaberoutine

      Die Ausgaberoutine
         Rundungsfehler

   Unterschiede zwischen GFA-3.x-BASIC- und TURBO-C-Listing

      GFA-3.x-BASIC:  Definitionen

      TURBO-C:  Definitionen

      GFA-3.x-BASIC:  Eingaberoutine  eingabe(VAR in)

      TURBO-C:  Eingaberoutine  double eingabe(void)

      GFA-3.x-BASIC:  Ausgaberoutine  ausgabe(in,VAR out)

      TURBO-C:  Ausgaberoutine  char *ausgabe(double in)

      TURBO-C:  Die spezielle Eingabefunktion get_s(char eingabe[])


Einleitung
----------

Die Ein- und Ausgaberoutinen stehen sowohl als GFA-3.x-BASIC-,  als auch 
  
als  TURBO-C-Listing zur Verfgung.  Beide Listings enthalten neben  der 
  
Ein-  und Ausgaberoutine auch eine Testroutine,  welche das  Testen  der 
  
beiden  Erstgenannten erm”glicht.  Aus beiden Listings k”nnen  die  Ein- 
  
und  Ausgaberoutinen in eigenene Programme eingebaut und je nach  Wunsch 
  
erweitert  oder ver„ndert werden.  Eines der Gr”ssenordnungssymbole  ist 
  
das Zeichen æ.  Dieses kann mit der "normalen" Tastatur nicht  eigegeben 
  
werden.  In beiden Listings wird fr diese Eingabe die Funktionstaste F1 
  
verwendet.  Es  ist dem Programmierer  selbstverst„ndlich  freigestellt, 
  
eine  andere  Eingabeform zu programmieren und das  verwendete  Listings 
  
entsprechend umzugestalten.
  






Das Eingabeformat
-----------------

Die Eingabe erfolgt im Stringformat.  Das Gr”ssenordnungssymbol kann  am 
  
Ende des Zahlenwertes (ohne Zwischenraum) erfolgen. Man hat aber zus„tz-
  
lich die M”glichkeit, an Stelle des Dezimalpunktes, das Gr”ssenordnungs-
  
symbol einzusetzen. Die Eingabe eines nicht definierten Gr”ssenordnungs-
  
symboles  wird  nach der Eingabe von <Return> mit einem  Bell  quittiert 
  
und fordert zur erneuten Eingabe auf.  Hier nun ein paar Beispiele,  wie 
  
Zahlenwerte eingegeben werden k”nnen:
  

   0.15  e15   =    150G      oder       .15T   oder        T15 

   820  e6     =    820M      oder       .82G   oder        G82 

   27500       =     27.5k    oder     27k5     oder        M0275

   0.1         =    100m      oder       .1 

   0.0001      =    100æ      oder       .1m    oder        m1

   5.6  e-6    =      5.6æ    oder      5æ6     oder    5600n   

   0.47 e-9    =    470p      oder       .47n   oder        n47

   0.82 e-12   =    820f      oder       .82p   oder        p82


   Der  Eingabebereich  erstreckt sich von 1 e-15 (1f) bis  999.999  e15 
  
   (999T999). Es sind selbstverst„ndlich auch negative Werte zul„ssig.







Das Ausgabeformat
-----------------

Die  Ausgabe  auf dem Bildschirm erfolgt  immer  mit  Dezimalpunkt.  Das 
  
Gr”ssenordnungssymbol  folgt nach einem Leerzeichen am Schluss des  Zah-
  
lenwertes.  Beispiele:
  

   12.85  e12     =     12.85 G

    4.75  e3      =   475 k

   94.77  e-9     =     94.77 n    

    3.3   e-12    =      3.3 p







Das Gemeinsame des GFA-3.x-BASIC- und TURBO-C-Listing
----------------------------------------------------


Die Testroutine.
-----------------

In  einer  Schlaufe folgt zuerst der Sprung in  die  Eingaberoutine.  In 
  
dieser Routine wird u.a.  die Eingabe des Gr”ssenordnungssymboles analy-
  
siert  und der entsprechende Fliesskommazahlenwert  gebildet.  Nach  der 
  
Rckkehr in die Testroutine folgt die direkte Wiedergabe des  Fliesskom-
  
mazahlenwertes.  Nach  dem darauffolgenden Sprung in die  Ausgaberoutine 
  
wird die bertragene Fliesskommazahl analysiert, das entsprechende Gr”s-
  
senordnungssymbol zugeordnet und als String bersetzt,  der  Testroutine 
  
zurckgegeben.  Es  folgt  die Wiedergabe dieses Strings auf  dem  Bild-
  
schirm.  Am Ende der Schlaufe wird entschieden,  ob eine n„chste Eingabe 
  
erwnscht  ist  oder ob die Testroutine verlassen werden  soll.  In  der 
  
Praxis  kann  die  Eingabe- und Ausgaberoutine  auch  einzeln  verwendet 
  
werden.  Sinnvoll  sind beide Routinen in einem Programm  natrlich  nur 
  
dann,  wenn  zwischen ihnen eine Rechenoperation erfolgt,  wie dies  zum 
  
Beispiel in einem Elektronikformelprogramm der Fall ist.
  



Die Eingaberoutine
------------------

Die grosse Schlaufe analysiert, ob als Gr”ssenordnungssymbol ein undefi-
  
niertes  Zeichen  eingegeben wird.  Als falsches Zeichen wird  auch  das 
  
Minussymbol  erkannt,  wenn  dies nicht als  erstes  Zeichen  eingegeben 
  
wird.  Diese  Schlaufe erkennt weiter ein korrektes  Gr”ssenordnungssym-
  
bol,  merkt sich die Dezimalpunktstelle und erzeugt den richtigen  Expo-
  
nenten  zur Basis von Zehn in der Variablen exp.  Es spielt dabei  keine 
  
Rolle,  ob die Dezimalpunktstelle zur Eingabe des  Gr”ssenordnungssymbo-
  
les verwendet wird.  Nach fehlerfreier Eingabe wird die Schlaufe verlas-
  
sen.  Als N„chstes wird der Dezimalpunkt an Stelle des  Gr”ssenordnungs-
  
symboles durch einen Punkt ersetzt,  falls an der Dezimalpunktstelle ein 
  
Gr”ssenordnungssymbol  eingegeben  wurde.  Danach wird  der  vorliegende 
  
String  in  eine  Fliesskommazahl bersetzt und mit  dem  Faktor  10^exp 
  
multipliziert.  Die so erzeugte Fliesskommazahl in wird der  Testroutine 
  
bergeben.
  



Die Ausgaberoutine 
------------------

Diese  Routine beginnt mit der Definition der  Anzahl  Nachkommastellen. 
  
Selbstverst„ndlich  ist es dem Anwender frei  gestellt,  diese  Variable 
  
(nk)  extern  zu definieren und den  Wert  mittels  Parameterbertragung 
  
dieser Routine zu bergeben. Danach wird festgestellt, ob die bertrage-
  
ne  Fliesskommazahl  positiv oder negativ  ist.  Anschliessend  wird  in 
  
einer  if-else-Struktur  entschieden,  ob der Zahlenwert kleiner  als  1 
  
femto,  gr”sser  als  999.999...Tera oder ob der Wert  innerhalb  dieses 
  
Bereiches  liegt  und in einer weiter innen  liegenden  if-else-Struktur 
  
weiterverarbeitet  werden  soll.  Im  letzten Fall wird  auf  Grund  des 
  
Zahlenwertes  entschieden,  welches Gr”ssenordnungssymbol benutzt  wird. 
  
Zus„tzlich  wird  der  richtige  Exponent zur  Basis  von  Zehn  in  der 
  
Variablen exp definiert.  Danach wird die Fliesskommazahl mit dem Faktor 
  
10^exp  multipliziert  und  in einen  String  bersetzt.  Dieser  String 
  
erh„lt  im  Falle einer negativen Zahl am Anfang  ein  Minuszeichen,  im 
  
Falle  einer positiven Zahl ein Leerzeichen und am Schluss ein  Leerzei-
  
chen und das entsprechende Gr”ssenordnungssymbol.  Die so konfektionier-
  
te Stringvariable out wird der Testroutine bergegeben.
  


Rundungsfehler

   In beiden Listings f„llt auf,  dass die innenliegende  if-else-Struk-
  
   tur zus„tzliche Entscheidungskorrekturen enthalten.  Ohne diese  kann 
   
   es  geschehen,  dass bei einem kritischen Zahlenwert  von  z.B.  1000 
   
   falsch entschieden wird.  Dies geschieht dann,  wenn der tats„chliche 
   
   Wert  ganz  geringfgig  unterhalb von 1000  liegt,  wass  zur  Folge 
   
   h„tte,  dass  an  Stelle der Anzeige 1k,  die Anzeige  1000  bei  der 
   
   Wiedergabe auf dem Bildschirm,  erscheinen wrde.  Was die Behandlung 
   
   der  Fliesskommavariable in nach der Entscheidung  betrifft,  besteht 
   
   zwischen  dem  TURBO-C- und dem  GFA-3.x-BASIC-Listing  einen  Unter-
  
   schied. Diesen und weitere Unterschiede sind anschliessend im folgen-
   
   den Kapitel beschrieben.
   


  



Unterschiede zwischen GFA-3.x-BASIC- und TURBO-C-Listing
--------------------------------------------------------


GFA-3.x-BASIC:  Definitionen
----------------------------

Wie  bereits  erw„hnt,  wird die Funktionstaste F1 zur  Eingabe  des  æ-
  
Symboles  verwendet.  Damit  der Befehl INPUT  auf  die  Funktionstasten 
  
reagieren kann,  muss dies mittels KEYPAD definiert werden,  wobei Bit 4 
  
gesetzt  ist.  Dies bedeutet,  dass die Funktionstasten  ohne  Alternate 
  
belegt werden k”nnen.  Mit KEYDEF wird der Funktionstaste F1 das  ASCII-
  
Zeichen  æ  als String zugewiesen.  Nicht  vergessen  werden,  darf  der 
  
Compiler!  Er  erwartet eine spezielle Aufforderung,  damit er  gn„digst 
  
die  Funktionstasten bercksichtigt.  Also ganz wichtig ist  der  Befehl 
  
$I+,  sonst  gibt's  kein æ-Symbol im lauff„hig  kompilierten  Programm. 
  
S„mtliche Definitionen,  welche die Ein- und Ausgabeprozedur  betreffen, 
  
stehen in der Prozedur definitionen.
  



TURBO-C:  Definitionen
----------------------

Wie  jedes C-Programm,  arbeitet auch dieses mit  include-Dateien.  Alle 
  
ben”tigten include-Dateien sind inklusive in diesem C-Programm verwende-
  
ten Definitionen,  in einer include-Datei namens INP_OUTP.H  zusammenge-
  
fasst.
  



GFA-3.x-BASIC:  Eingaberoutine  eingabe(VAR in)
-----------------------------------------------

Der  wichtigste  Unterschied  zwischen dieser  und  der  TURBO-C-Routine 
  
besteht in der Eingabe ber das Keyboard. Unabh„ngig davon, ob die Funk-
  
tionstasten  des Keyboardes gelesen werden mssen oder  nicht,  ist  die 
  
Programmierung  nur unwesentlich komplizierter.  Es wird dazu ganz  ein-
  
fach der INPUT-Befehl verwendet,  der aber mittels KEYPAD und KEYDEF  in 
  
die Lage versetzt wird,  zus„tzlich die Funktionstasten zu lesen.  Diese 
  
Definitionen,  als auch der zugeh”rige Compilerbefehl,  sind weiter oben 
  
in "GFA-3.x-BASIC:  Definitionen" bereits beschrieben. 
  


TURBO-C:  Eingaberoutine  double eingabe(void)
----------------------------------------------

Der  wichtigste Unterschied zwischen dieser und  der  GFA-3.x-BASIC-Rou-
  
tine besteht in der Eingabe ber das Keyboard.  Das Lesen des Keyboardes 
  
ist etwas komplizierter, weil zus„tzlich die Funktionstasten miteinbezo-
  
gen werden.  Um die Funktionstasten lesen zu k”nnen,  mssen die Zeichen 
  
mit der AES-Funktion evnt_keybd() einzeln gelesen werden.  Das  folgende 
  
Kapitel  "Die  spezielle  Eingabefunktion  get_s(char  eingabe[])"   be-
  
schreibt diesen Vorgang detaillierter.
  



GFA-3.x-BASIC:  Ausgaberoutine  ausgabe(in,VAR out)
---------------------------------------------------

Der  wichtigste  Unterschied  zwischen dieser  und  der  TURBO-C-Routine 
  
besteht darin,  dass die Umwandlung der Fliesskommazahl der Variable  in 
  
in  den  Ausgabestring  out$,  mit Hilfe  des  STR$-Befehles  wesentlich 
  
einfacher  geschrieben werden kann.  Dieser STR$-Befehl enth„lt  zus„tz-
  
lich  noch eine Rundungsfunktion,  was einen Ausgleich des in-Wertes  in 
  
der  if-else-Struktur  berflssig macht.  Die  Anzahl  der  erwnschten 
  
Stellen  nach dem Dezimalpunkt,  als auch die Anzahl der Ziffern  werden 
  
STR$  mitgeteilt.  Im Gegesatz zur TURBO-C-Routine ist daher die  Anzahl 
  
Stellen nach dem Dezimalpunkt,  von der Anzahl Ziffern vor dem  Dezimal-
  
punkt unabh„ngig.
  



TURBO-C:  Ausgaberoutine  char *ausgabe(double in)
--------------------------------------------------

Der  wichtigste Unterschied zwischen dieser und  der  GFA-3.x-BASIC-Rou-
  
tine besteht darin,  dass die Schreibweise zur Umwandlung der Fliesskom-
  
mazahl der Variable in in den Ausgabestring out komplizierter  ist.  Die 
  
Variable  in  wird mit der Funktion ecvt(...) in den  String  out  ber-
  
setzt.  Dieser  Umwandlungsfunktion wird die Fliesskommazahl in und  die 
  
maximale  Anzahl Ziffern ndig bergeben.  Zurckgegeben wird die  Stelle 
  
des  Dezimalpunktes dec.  Die Anzahl der Ziffern nach  dem  Dezimalpunkt 
  
ist daher abh„ngig von der Anzahl Ziffern vor dem Dezimalpunkt.  Dies im 
  
Gegensatz zur GFA-3.x-BASIC-Routine.  Die definierte Anzahl Stellen nach 
  
dem  Dezimalpunkt  nk  gilt bei der maximalen  Anzahl  Ziffern  vor  dem 
  
Dezimalpunkt,  was  zwischen 100 und 999 der Fall ist.  Der  String  out 
  
enth„lt  zun„chst nur die Zahl ohne Dezimalpunkt.  Dieser wird  nachfol-
  
gend  an  richtiger Stelle eingesetzt.  Mit Hilfe des  Zusatzstringes  s 
  
wird die Zahl mit der folgenden for-Schlaufe,  ab der  Dezimalpunktstel-
  
le,  um  eine Stelle nach "rechts" verschoben.  Das  freigewordene  Feld 
  
wird mit dem Dezimalpunkt besetzt.  Danach folgt am Schluss des Stringes 
  
ein Leerzeichen und das entsprechende Gr”ssenordnungssymbol.  Nun  fehlt 
  
noch  das  Vorzeichen.  Dazu wird der Stringinhalt  nochmals  mit  einer 
  
weiteren  for-Schlaufe nach "rechts" verschoben und danach  das  Vorzei-
  
chen  an  die erste Stelle gesetzt.  Als letzter Schritt  wird  out  der 
  
Testroutine zu bergeben.
  

Ein  Blick in die innere if-else-Struktur zeigt,  dass die  in-Werte  um 
  
den  Betrag der Korrektur auf der else-if-Zeile kompensiert  wird.  Dies 
  
ist n”tig,  weil die Umwandlungsfunktion ecvt(...) im Gegensatz zu  STR$ 
  
des GFA-3.x-BASIC nicht rundet.
  



TURBO-C:  Die spezielle Eingabefunktion get_s(char eingabe[])
-------------------------------------------------------------

Die folgende Programmausfhrung ist in einer do-while-Struktur eingebet-
  
tet,  die  erst  dann verlassen wird,  wenn mittels Taste  <Return>  die 
  
Eingabe  best„tigt  wird und keine Eingabefehler  erkannt  wurden.  Nach 
  
dieser  Best„tigung  enth„lt  die letzte  Feldeintragung  der  Varibalen 
  
eingabe[i]  das ASCII-Zeichen der Taste <Return>.  Diese  Feldeintragung 
  
wird  durch eine Null ersetzt,  damit der String  korrekt  abgeschlossen 
  
ist.
  

Die Funktion catchkey() leert den Tastaturpuffer,  falls vor der folgen-
  
den  Tastaturabfrage unn”tigerweise das Tastenfeld des Keyboardes  bet„-
  
tigt  wurde.  Der Name dieser Funktion ist aus ihrem  Zweck  abgeleitet: 
  
N„mlich,  unerwnschte Tastatureingaben abzufangen.   Mittels  AES-Funk-
  
tion  evnt_keybd()  erfolgt die Tastatureingabe.  Bei  der  Eingabe  von 
  
"normalen"  Zeichen wird das Low-Order-Byte maskiert und  dessen  Inhalt 
  
als ASCII-Wert weiterverarbeitet.  Wird die Funktionstaste F1  gedrckt, 
  
gilt der Scan-Code des High-Order-Byte.  In diesem Fall wird der Variab-
  
len  ascii den ASCII-Wert des æ-Symboles zugewiesen.  In  der  folgenden 
  
„ussersten if-Struktur wird der zul„ssige Tastaturbereich definiert.  In 
  
der inneren if-else-Struktur folgt einerseits die Wiedergabe des  einge-
  
geben  Zeichens auf dem Bildschirm und die Bildung des zur  Weiterverar-
  
beitung notwendigen Stringes in der Feld-Variablen  eingabe[i].   Ander-
  
seits  folgt  die  korrekte Steuerung des Cursors und  das  L”schen  des 
  
Zeichen  beim Backspace-Vorgang.  In der  folgenden inneren  if-Struktur 
  
wird  durch  die  Bet„tigung der Taste <Escape> die  ganze  Eingabe  ge-
  
l”scht. 
  

- ende -
