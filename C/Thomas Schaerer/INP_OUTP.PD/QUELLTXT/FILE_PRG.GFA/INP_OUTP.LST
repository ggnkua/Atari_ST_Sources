' Filename:   INP_OUTP.GFA
' ------------------------
' Dieses Programm erlaubt Fliesskommazahlenwer-
' te mittels Groessenordnungssymbolen zu lesen
' und nach Verarbeitung mittels irgend einer
' Rechenoperation, ebenfalls wieder mit Groes-
' senordnungssymbolen auszugeben. Genauere Be-
' schreibung siehe begleitender Text.
' Die Eingabe des Mikro-Symboles erfolgt mit
' der Funktionstaste F1.
'
' Autor:     Thomas Schaerer  Im Lindenhof 6
'            CH-Effretikon (Schweiz)
' Datum:     21. August 1992
' Sprache:   GFA-3.5-BASIC
' ===============================================
'
'
'       Testroutine um die Arbeitsweise von
'       'eingabe' und 'ausgabe' zu testen.
'       -------------------------------------
'
'
esc%=27 ! FÅr Escapesequenzen nur fÅr Test nîtig.
'
definitionen
'
CLS
catchkey
REPEAT
  eingabe(in)
  PRINT " Eingaberesultat:   ";
  PRINT USING "-###.#####^^^^",in
  ausgabe(in,out$)
  PRINT " Ausgaberesultat:   ";out$;"    "
  revrs_curs
  PRINT " Weiter: Taste  / Abbruch: <q>"
  norm_curs
  taste
  PRINT
UNTIL key$="q"      ! Programm-Abbruch
CLS
EDIT  ! Falls man im Interpreter arbeitet.....
' Ende des Hauptprogrammes
'
' ==============================================
'     P  R   O   Z   E   D   U    R   E  N
'
'
PROCEDURE definitionen
  mue%=230
  $I+                     ! Funktionstasten
  KEYPAD &X10000          ! ohne <Alterbate>
  KEYDEF 1,CHR$(mue%)     ! Micro-Symbol in F1
RETURN
'
'
'
PROCEDURE eingabe(VAR in)
  LOCAL error%,k%,symb_pos%,exp%,eingabe$
  '
  ' Es wird getestet, ob ein unerlaubtes Grîssen-
  ' ordnungssymbol eingegeben wird.
  ' Falls ja, error%=TRUE.
  ' Wenn ein erlaubtes Grîssenordnungssymbol ein-
  ' gegeben wurde, wird Position im String und
  ' Typ ermittelt und Wert definiert.
  REPEAT
    catchkey
    INPUT " Eingabe: ",eingabe$
    CLR error%
    FOR k%=1 TO LEN(eingabe$) ! k%=Symbolstelle.
      SELECT MID$(eingabe$,k%,1)
      CASE "T"
        exp%=12
        symb_pos%=k%
      CASE "G"
        exp%=9
        symb_pos%=k%
      CASE "M"
        exp%=6
        symb_pos%=k%
      CASE "K","k"
        exp%=3
        symb_pos%=k%
      CASE "m"
        exp%=-3
        symb_pos%=k%
      CASE mue%
        exp%=-6
        symb_pos%=k%
      CASE "n"
        exp%=-9
        symb_pos%=k%
      CASE "p"
        exp%=-12
        symb_pos%=k%
      CASE "f"
        exp%=-15
        symb_pos%=k%
      CASE "."
        symb_pos%=k%
      CASE "0" TO "9"
      DEFAULT
        IF k%=1     ! Wenn '-'Symbol an 1. Stelle ...
          IF MID$(eingabe$,k%,1)<>"-"
            bell    ! gilt es nicht als falsch.
            error%=TRUE
          ENDIF
        ELSE
          bell
          error%=TRUE   ! Falsches Zeichen eingegeben.
        ENDIF
      ENDSELECT
    NEXT k%
  UNTIL error%=NOT TRUE
  '
  ' Falls an Stelle des Kommas (Punkt) das Sym-
  ' bol eingegeben wurde, wird dieses durch den
  ' Dezimalpunkt zwecks Weiterverarbeitung als
  ' Fliesskommazahl ersetzt.
  MID$(eingabe$,symb_pos%)="."
  '
  ' Der Eingabestring wird zur Fliesskommazahl
  ' Åbersetzt und mit dem Faktor entsprechend
  ' dem Grîssenordnungssymbol multipliziert.
  in=(VAL(eingabe$))*(10^exp%)  ! Wirklicher Wert
RETURN
'
'
'
PROCEDURE ausgabe(in,VAR out$)
  LOCAL exp%,unit$,vorz$,nk%
  '
  nk%=6         ! Nachkommastellen
  IF in<0       ! Vorzeichen kehren bei ne-
    in=in*-1    ! gativer Zahl.
    vorz$="-"   ! Neg. Vorzeichen merken.
  ELSE
    vorz$=" "   ! Wenn Zahl positiv.
  ENDIF
  '
  IF in<10^-15-(0.5*10^(-18-nk%))
    bell
    out$="Kleiner als 1 femto !"
  ELSE IF in>=10^15-(0.5*10^(12-nk%))
    bell
    out$="Grîsser als 999.999... Tera !"
  ELSE
    IF in>=10^12-(1/1.8*10^(9-nk%))
      exp%=-12
      unit$="T"
    ELSE IF in>=10^9-(1/1.8*10^(6-nk%))
      exp%=-9
      unit$="G"
    ELSE IF in>10^6-(1/1.8*10^(3-nk%))
      exp%=-6
      unit$="M"
    ELSE IF in>=10^3-(1/1.8*10^(0-nk%))
      exp%=-3
      unit$="k"
    ELSE IF in>=10^0-(1/1.8*10^(-3-nk%))
      exp%=0
      unit$=" "
    ELSE IF in>=10^-3-(1/1.8*10^(-6-nk%))
      exp%=3
      unit$="m"
    ELSE IF in>=10^-6-(1/1.8*10^(-9-nk%))
      exp%=6
      unit$=CHR$(mue%)
    ELSE IF in>=10^-9-(1/1.8*10^(-12-nk%))
      exp%=9
      unit$="n"
    ELSE IF in>=10^-12-(1/1.8*10^(-15-nk%))
      exp%=12
      unit$="p"
    ELSE IF in>=10^-15-(1/1.8*10^(-18-nk%))
      exp%=15
      unit$="f"
    ENDIF
    out$=vorz$+STR$((in*10^exp%),4+nk%,nk%)+" "+unit$
  ENDIF
RETURN
'
'
'
PROCEDURE bell
  OUT 2,7
RETURN
'
PROCEDURE catchkey      ! Tastaturbuffer leeren.
  LOCAL keybuff%
  '
  REPEAT
    KEYTEST keybuff%
  UNTIL keybuff%=0
RETURN
'
'
' ===============================================
' Hilfsprozeduren, nur fÅr Test nîtig.
'
PROCEDURE taste         ! Tastaturabfrage
  catchkey
  key%=INP(2)
  key$=CHR$(key%)
RETURN
'
PROCEDURE norm_curs
  PRINT CHR$(esc%)+"q";
RETURN
'
PROCEDURE revrs_curs
  PRINT CHR$(esc%)+"p";
RETURN
' ################  E N D E  #####################
