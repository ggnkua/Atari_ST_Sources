

               ASS_6502   65(c)02 Cross-Makro-Assembler


 Ass_6502 dient der Erstellung von Programmen der 65xx Prozessoren auf
 dem Atari ST. Geschrieben habe ich dieses Programm, um auf meine Atari
 Programme fÅr einen kleinen Einplatinencomputer zu entwickeln. Die
 vorliegende Version ist mindestens schon die dritte, und mittlerweile
 vollstÑndig in Assembler geschrieben, wodurch, wie ich meine,er eine 
 ganz gute Geschwindigkeit erreicht. Es sollten die meisten Fehler
 beseitigt sein, was aber nicht heiûen soll, das es vielleicht doch
 noch einige gibt. Es ist mir nÑmlich nicht mîglich, rein zeitlich
 gesehen, alle mîglichen und umnmîglichen Test durzufÅhren, aber wenn
 man ihn nicht provoziert, lÑuft er sehr gut. Sollten sie trotzdem Fehler
 entdecken, so zîgern sie nicht, diese mir mitzuteilen. Ich werde versuchen,
 sie dann zu beseitigen. FÅr Anregungen bin ich auch sehr aufgeschlossen.

 Anregungen,WÅnsche und Kritik, letzteres hoffentlich konstruktiv, wenden
 sie sich an :

 Alexander Stauffenberg
 Buchsweilerstr. 8
 1000 Berlin 33
 (030)8313277

===============================================================================

 Aufruf des Assemblers

 Aufruf : ASS_6502 [ Optionen ... ... ] Quelldatei [ Zieldatei ]
 
 Die verschiedenen Parameter mÅssen durch ein Leerzeichen getrennt sein.

 Optionen beginnen mit den Zeichen '-'. Es kînnen mehrere Optionen durch ein 
 Leerzeichen getrennt angegeben werden. Es gibt folgende Optionen :
 
 -B       -> Falls mîglich werden JMP Befehle in BRA umgewandelt. Diese Option
             ist nur im 65c02 Modus wirksam.
 
 -C       -> Schaltet den 65c02 Modus ein, d.h. Befehle der 65c02 CPU sind 
             zulÑssig.
  
 -E       -> Bei Ausgabe eines Listings, werden Include Files mitgelistet.
 
 -H       -> Der Assembierte Code wird als Hexstring ausgegeben. Die ersten
             vier Zeichen geben Startadresse ( Low Byte, High Byte ) an, die 
             vier die Endadresse. Darauf folgt der Code in ASCII Zeichen.
             Wird diese Option nicht angegeben, so wird der Code BinÑr abge-
             speichert. BinÑrer Code erhÑlt ( falls nicht anders angegeben )
             die Extension *.65, ASCII Code *.H65.
 
 -Z       -> Es werden keine kurzen Adressierung mehr verwendet.
 
 -F=Datei -> Es werden die Fehlermeldungen in 'Datei' geschrieben. Das Programm
             wartet nicht mehr auf Tastendruck, und es endet mit Fehlercode 1. 
             Wird diese Option nicht angegeben, so fragt das Programm im Fehler-
             fall, wohin die Meldungen geschrieben werden sollen.
       
 -L=Datei -> Es wird ein Listing in 'Datei' ausgegeben. 

 -S=Datei -> Es wird eine Symbolliste in 'Datei' ausgegeben.
 
 Als Quelldatei muû der Name des Quelltextes angegeben werden.
 
 ZusÑtzlich kann eine Zieldatei angegeben werden. Wird diese nicht angegeben,
 so bildet sich der Name der Zieldatei aus dem Name der Quelldatei mit der
 Extension .65 oder .H65 ( s.o. ).
 
 Werden  die Optionen im Quelltext anders angegeben, so haben diese Vorrang. 
 
===============================================================================

 Quelldatei

 Die Quelldatei kann mit jedem beliebigen ASCII Editor erstellt werden.

===============================================================================

 Textfelder

 Symbole beginnen immer in der ersten Spalte. Alle weiteren Felder kînnen
 an einer beliebigen Spalte beginnen. Getrennt werden sie durch
 Leerzeichen oder Tabulatoren.

 z.B

 Label   lda  #$FF  ; Kommentar  -> Richtig
 Label   lda  # $ff  ; Kommentar -> Falsch ! $ff wird als viertes Feld
                                             erkannt, d.h. als Kommentar

===============================================================================

 Symbole

 Symbole oder Labels mÅssen immer in der ersten Spalte beginnen.
 Symbole mÅssen immer mit einen Buchstaben beginnen. Danach sind
 Buchstaben, Ziffern und '_' erlaubt.
 Der Assembler benutzt alle Zeichen eines Symbols zur unterscheidung.
 Es wird auch zwischen Groû- und Kleinschreibung unterschieden.

 Z.B.  'LABEL' ist nicht gleich zu 'label'

================================================================================

 Mnemonic

 Alle Mnemonic der 8 Bit 65xx Prozessoren sind zugelassen.
 Mnemonics kînnen sowohl in Groûschrift, als auch in Kleinschrift
 geschrieben werden.

 Z.B. 'Lda'  ist genauso zulÑssig wie 'LDA' oder 'lda'.

===============================================================================

 Operanden

 Register kînnen sowohl als 'A','X','Y' angegeben werden, als auch
 als 'a','x','y'. Bei Hexadezimalen Zahlen sind sowohl Groû- als auch
 Kleinschrift zulÑssig.

-------------------------------------------------------------------------------

 AusdrÅcke im Operanden

 Zahlen kînnen in dezimaler,hexadezimaler und binÑrer Darstellung angegeben
 werden. '$' leiten hexadezimale, '%' binÑre Zahlen ein.

 z.B.      1234  =  1234 (logisch ! )
           $ff   =  255
           %1111 =  15


 Eine Zahl oder ein Symbol gefolgt von '.h' oder '.H' liefert das hîherwertige
 Byte. ( Zahl DIV 256 )
 Eine Zahl oder ein Symbol gefolgt von '.l' oder '.L' liefert das niederwertige
 Byte. ( Zahl MOD 256 )

 z.B.      $1234.h = $12
           $1234.l = $34

-------------------------------------------------------------------------------

 RechenausdrÅcke

 Innerhalb des Operanden kînnen RechenausdrÅcke stehen. Es stehen +,-,* und
 / zur VerfÅgung. Es wird stur von links nach rechts gerechnent, d.h. es
 wird keine PrioritÑt berÅcksichtigt. Klamern von AusdrÅcken ist ebenfalls
 nicht mîglich. Es findet kein öberlaufprÅfung statt.
 Komplizierte AusdrÅcke sollte man daher meiden.

===============================================================================

 Kommentare

 Kommntare stehen im vierten Textfeld oder beginnen mit ';'. Alle Zeichen
 die einen ';' folgen werden Åberlesen.

 z.B.   Label  Mne  Operand    Kommentar
        Label  Mne  Operand    ; Kommentar
        Label  Mne             ; Kommentar
        ; Kommentar

===============================================================================

 Codedatei

 Der vom Assembler erzeugte Code wird als BinÑrdatei abegespeichert,
 d.h. es werden keine Zusatzinformation abgespeichert. Deswegen sollte
 man sich die Startadresse des Codes gut meren.
 Die Datei kann als solche direckt in ein EPROM gebrannt werden.
 
 Falls gewÅnscht wird der Code auch als ASCII ausgegeben werden. Die ersten
 vier Zeichen geben Startadresse ( Low Byte, High Byte ) an, die 
 vier die Endadresse. Darauf folgt der Code in ASCII Zeichen.

===============================================================================

 Listing

 Falls gewÅnscht, kann ein Listing vom Assembler erzeugt werden.
 Es hat dann folgendes Format :

 nnnn xxxx yy yy yy   label   mne  operand

 nnnn  - Zeilennummer
 xxxx  - Adresse
 yy    - Code
 label - Label, falls angegeben
 mne   - Mnemonic
 operand - Operand

=============================================================================== 

 Symbolliste

 Ebenfalls kann eine Symbolliste ausgegeben werden. Es werden jedoch immer
 nur die ersten 10 Zeichen eines Symbols ausgegeben. Die Symbole werden
 in der Reihenfolge ihres Vorkommens ausgegeben.

===============================================================================

 Assembler Directiven

-------------------------------------------------------------------------------

 EQU

 Syntax : Label  EQU  Ausdruck

 EQU setzt den Wert von Label gleich dem Ergebnis von Ausdruck.
 Der Ausdruck darf keine VorwÑrts-Refernzen enthalten.

-------------------------------------------------------------------------------

 ORG

 Syntax :         ORG  Ausdruck

 ORG setzt die Adresse fest, ab welcher der Code Assembliert werden soll.
 Der Ausdruck darf keine VorwÑrts-Refernzen enthalten. Ein Label vor ORG
 wird nicht korrekt behandelt, und sollte deswegen vermieden werden. Es
 ist nur ein ORG zulÑssig. Dieses muû vor der ersten Codeerzeugenden Zeile
 stehen.
 
-------------------------------------------------------------------------------

 DFB,DFW,DFA

 Syntax : <Label> DFx  Ausdruck <,Ausdruck...>

 DFx legen Konstanten im Speicher ab. Es sind mehrere AusdrÅcke durch Komma
 getrennt mîglich.
 DFB legt Byte ( Ausdruck MOD 256 ) Werte im Speicher ab. Zeichenketten
 mÅssen zwichen ' stehen.
 DFW legt Word Werte in der Reihenfolge Hi-Byte, Lo-Byte im Speicher ab.
 DFA legt Word Werte in der Reihenfolge Lo-Byte, Hi-Byte im Speicher ab.

-------------------------------------------------------------------------------

 RES

 Syntax : <Label> RES  Ausdruck

 RES fÅllt 'Ausdruck' Bytes mit $FF auf.

-------------------------------------------------------------------------------

 INCLUDE

 Syntax : <Label> INCLUDE Dateiname

 Include fÅgt die Datei 'Dateiname' in den Quelltext ein.

-------------------------------------------------------------------------------

 OUTPUT

 Syntax :         OUTPUT Dateiname

 OUTPUT legt die Ausgabedatei fÅr den Assemblierten Code fest.

-------------------------------------------------------------------------------
 LIST

 Syntax :         LIST Dateiname

 LIST legt die Ausgabedatei fÅr ein Listing fest.
 Mit LIST con: wird das Listing auf den Bildschirm ausgegeben.
 Mit LIST prn: wird das Listing auf den Drucker ausgegeben.

-------------------------------------------------------------------------------

 SYMBOL

 Syntax :         SYMBOL Dateiname

 SYMBOL legt die Ausgabedatei fÅr eine Symbolliste fest.
 Es Werden jedoch nur die Ersten 10 Zeichen eines Symbols ausgegeben.
 Mit SYMBOL con: wird die Liste auf den Bildschirm ausgegeben.
 Mit SYMBOL prn: wird die Liste auf den Drucker ausgegeben.

-------------------------------------------------------------------------------

 OPTION

 Syntax :         OPTION  opt <,opt...>

 Mit Option kann man veschiedene Optionen an bzw. ausschalten.
 opt+ schaltet Die Option an, opt- wieder aus.

 Z - Zeropage Optimierung
     Wo mîglich wird die kurze Adressierung eingesetzt.
     Standard ist an.

 B - Branch Optiemierung
     Wo mîglich wird JMP durch BRA ersetzt ( Nur bei 65C02 mîglich )
     Standard ist aus. Diese Optiemierung ist nur im 65c02 Modus aktiv.

 C - CMOS CPU
     Mit C- lassen sie nur Befehle eines 6502 zu ( Standard ).
     mit C+ sind zusÑtzlich auch noch die Befehle des 65C02
     Prozessors zulÑssig.

 L - Listing
     Mit L- und L+ kînnen Bereiche fÅrs Listing ausgeschlossen werden.
     Standard ist an.

 E - Expandieren
     Mit E- werden Includefiles nicht mit gelistet.
     Standard ist aus. 

 H - Hexcode
     Der Assemblierte Code wird als Ascii Datei ausgegeben. Die ersten
     vier Buchstaben sind Startadresse, die nÑchsten vier die Endadresse
     des Codes ( Low Byte - High Byte )

-------------------------------------------------------------------------------

  FAIL

  Syntax :       FAIL

  Fail erzeugt einen Fehler. Dies kann bei Macros u.U. nÅtzlich sein.

===============================================================================

  Bedingtes Assemblieren

  Syntax :       IFC  Ausdruck1 Vergleich Ausdruck2
                   .
                   .
                   Assemblerblock
                   .
                   .
                 ENDC

  IFC..ENDC erlauben das bedingte Assemblieren eines Codeteils.
  Ist Ausdruck1 Vergleich Ausdruck2 wahr, so wird der Quelltext
  zwischen IFC und ENDC assembliert, andernfalls wird dieses Teil
  öberlesen. IFC..ENDC Blîcke dÅrfen ineinander verschachtelt werden.

  Ausdruck1 und Ausdruck2 dÅrfen keine VorwÑrtsreferenzen enthalten.
  Als Vergleich sind =, #, < und > erlaubt.


===============================================================================

  Macros

-------------------------------------------------------------------------------

  Macrodefinition

  Syntax :   Name   MACRO
                      .
                      .
                      Anweisungsblock
                      .
                      .
                    ENDM

  MACRO leitet das Aufzeichnen eines Macros ein. ENDM beendet die
  Aufzeichnung. 'Name' darf keine Directive oder Mnemonic sein.
  Macros dÅrfen weitere Macroaufrufe enthalten. Ein Macro muû vor
  seinen ersten Auruf Defieniert sein. Labels innerhalb eines Macros
  sind nicht zulÑssig, Strukturblîcke dagegen sind zulÑssig.

-------------------------------------------------------------------------------

  Macroparameter

  Parameter werden innerhalb eines Macros mit \n aufgerufen.
  Es sind max. 10 Parameter mîglich (\0..\9). Parameter dÅrfen
  nur im Operandenfeld stehen. \n wird durch Parameter n im Text
  ersetzt.

  NARG oder narg ist ein vordeieniertes Symbol, daû die Anzahl der
  Åbergebenen Parameter enthÑlt.
  
-------------------------------------------------------------------------------

  Macroaufruf

  Syntax : <Label>   Name  <Parameter,...>

  Ein Macro wird aufgerufen, indem sein Name im Mnemonicfeld steht.
  Die Parameter stehen im Operandenfeld. Als Parameter sind Rechen-
  ausdrÅcke und Zeichenketten zulÑssig.

-------------------------------------------------------------------------------

  Macroabbruch

  Syntax :           MEXIT

  Durch MEXIT ist ein vorzeitiges verlassen des Macros mîglich.


===============================================================================

  Strukturblîcke

  Strukturblîcke erlauben ein Åbersichtlicheres Programieren.
  Strukturblîcke sind nicht mit bedingten Assemblieren zu verwechseln.

  Mîglich sind :

  IF..ENDIF  -  Bedingte ausfÅhrung

  Syntax : <Label>    IF cond
                         .
                         Anweisungsblock
                         .
                      ENDIF

  Code   : <Label>    Bcc Label_0
                       .
                      Anweisungsblock
                       .
            Label_0   weiter im Text

  IF..ELSE..ENDIF - Bedingte AusfÅhrung

  Syntax : <Label>    IF cond
                         .
                         Anweisungsblock
                         .
                      ELSE
                         .
                        Anweisungsblock
                        .
                      ENDIF

  Code   : <Label>    Bcc Label_0
                       .
                      Anweisungsblock
                       .
                      JMP Label_1
            Label_0    .
                      Anweisungsblock
                       .
            Label_1   weiter im Text

  DO..LOOP - Endlosschleife

  Syntax : <Label>    DO
                       .
                       Anweisungsblock
                       .
                      LOOP

  Code   : <Label>    .
                      Anwiesungsblock
                      .
                      JMP <Label>

  REPEAT..UNTIL - Schleife

  Syntax : <Label>    REPEAT
                         .
                        Anweisungsblock
                         .
                      UNTIL cond

  Code   : <Label>    .
                      Anweisungsblock
                      .
                      Bcc <Label>

  BEGIN..WHILE..WEND

  Syntax : <Label>    BEGIN
                         .
                        Anweisungsblock
                         .
                       WHILE cond
                         .
                        Anweisungsblock
                         .
                       WEND

  Code    : <Label>      .
                       Anweisungsblock
                         .
                       bcc Label_0
                         .
                       Anweisungsblock
                         .
                       JMP <Label>
             Label_0   weiter im Text


  Als 'cond' gelten : EQ,NE,CS,CC,PL,MI,VC,VS.
  Im Code wird dann ein Branch mit dem gegenteil eingesetzt.
  Struckturblîcke kînnen verschachtelt werden.

===============================================================================
