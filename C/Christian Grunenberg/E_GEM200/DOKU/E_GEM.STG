@database "EnhancedGEM-Library-Dokumentation"
@subject "Dokumentation/EnhancedGEM"
@author "Christian Grunenberg"
@$VER: e_gem.hyp 2.00
@options -n-s+y

@help "Support"

@node Main "EnhancedGEM-Library Version 2.00"

@{B} EnhancedGEM-Library Version 2.00@{0}

@{Inhalt: ignore}

    1. Rechtliches
    2. Support

    3. FÑhigkeiten der Library
    4. Nutzung der Library

    5. Dokumentation der Library-Mîglichkeiten

    6. EnhancedGEM-Applikationen
    7. Zukunft

@endnode

@pnode EnhancedGEM
@alias EGEM
Es kann nur eine geben...
@endnode

@node Rechtliches

 EnhancedGEM ist inklusive aller Quelltexte in C und Assembler Freeware,
 d.h. jedermann/-frau darf die Library beliebig oft und lang kopieren,
 benutzen und weitergeben.
 Allerdings darf das Archiv nur unverÑndert weitergegeben werden, d.h.
 u.a. dÅrfen keine Dateien gelîscht oder énderungen/Erweiterungen in den
 Sourcen vorgenommen werden. PD-Versender oder kommerzielle Mailboxen,
 welche mit Gewinn arbeiten, dÅrfen EnhancedGEM NICHT verbreiten, solange
 sich diese nicht ein schriftliche Genehmigung bei mir eingeholt haben.

 Eine kommerzielle Nutzung der Library fÅr Share- oder Lîhnware ist unter-
 sagt, sofern sie nicht mit mir abgesprochen wurde! U.a. erwarte ich in
 diesem Fall entweder eine einmalige, geringe "EntschÑdigung" oder
 alternativ eine geringe Beteiligung an der SharewaregebÅhr bzw. dem
 Verkaufspreis (1 bis 2 Mark pro StÅck). FÅr private Projekte sowie
 Freeware-, Fairware- oder PD-Software gelten diese EinschrÑnkungen natÅr-
 lich nicht.

 FÅr die einwandfreie FunktionalitÑt der Library kann und will ich nicht
 garantieren und Åbernehme daher keinerlei Verantwortung fÅr SchÑden jeglicher
 Art, die von der Library verursacht werden.

 @{B}Die Benutzung dieser Library erfolgt somit auf EIGENE Gefahr!@{0}

@endnode

@node Support

 Die neueste Version der Library ist jeweils in der Maus Stuttgart 2
 (Tel.: 0711-6364625) erhÑltlich oder kann direkt bei mir bezogen werden
 (frankierten und adressierten RÅckumschlag an mich senden). Bei Fragen
 und/oder Fehlermeldungen kann man sich ebenfalls an mich wenden.

@index Adresse
     Christian Grunenberg
     Traminerweg  5
     D-71717 Beilstein

     Tel.: 07062 - 5287 (mîglichst nicht vor 12 Uhr)

@index Email
     @{B}E-Mail:@{0}
     Christian Grunenberg@S2 (Mausnet)
     Christian_Grunenberg@S2.maus.de (Usenet)
@endnode

@node "FÑhigkeiten der Library"

    - lÑût sich mit GNU-C, Pure C und Lattice C einsetzen
    - an MultiTOS, Mag!X ab V2.0 sowie Winx ab V2.1 angepaût
    - Definitionen der Protokolle XAcc2, AV, MenÅ, Clipboard und Drag&Drop
    - XAcc2-, AV- und Clipboard-Protokoll werden automatisch unterstÅtzt
    - verbesserte Ereignis-Verwaltung mit 4 Rechteck-, 2 Button- und
      2 Timer-Events
    - beliebig viele Fenster-/fliegende Dialoge gleichzeitig
    - fliegende Dialoge springen zur Mausposition bei Mausklick auûerhalb
      des Dialogs
    - Rechtsklick auf Objekt im Vordergrund-Dialog (bei aktiver Hinter-
      grundbedienung auch im Hintergrund-Dialog) simuliert Doppelklick
    - Fensterdialoge durch zusÑtzlich gedrÅckte rechte Maustaste im
      Hintergrund bedienbar (optional auch ohne rechte Maustaste)
    - Fenster wechseln/schlieûen (Hotkeys und MenÅpunkte definierbar)
    - unmodale/modale Fensterdialoge
    - Tastaturbedienung der Dialoge, wobei in Dialogen mit Edit-Feldern
      zusÑtzlich die Alternate-Taste gedrÅckt werden muû
      (Doppelklick-Simulation durch zusÑtzlich gedrÅckte Shift-Taste)
    - TastendrÅcke optional zum Dialog unter dem Mauszeiger
    - unter MTOS (ab AES 4.1) sowie MagiC 3.0 oder bei vorhandenem ICFS
      kînnen Fenster bzw. Fensterdialoge ikonifiziert werden
      (Hotkey: Ctrl-'*' (Ziffernblock), nur bei ICFS)

    - erweiterte Alert-Funktion:
        - 18 vordefinierten Icons
        - benutzerdefinierte Icons beliebiger Grîûe
        - beliebig langen Zeilen und Buttons
        - maximal 10 Zeilen sowie 5 Buttons
        - Buttons Åber Hotkey anwÑhlbar (auch ohne Alternate-Teste)
        - Buttons linksbÅndig/rechtsbÅndig oder zentriert

    - erweiterte Mîglichkeiten in Eingabe-Feldern
        - exakte Cursorpositionierung per Maus
        - Mauscursor wird Åber Eingabefeldern zum Textcursor
        - erstes/letzes Eingabefeld (Home/Shift-Home, Shift-Up/Down)
        - Wort vor/zurÅck (Ctrl-Left/Right)
        - Anfang/Ende des Eingabesfeldes (Shift-Left/Right)
        - vorheriges Eingabesfeld (Up,Shift-Tab/Enter/Return)
        - nÑchstes Eingabefeld (Down/Tab/Enter)
        - Cursor ein Zeichen nach links/rechts (Left/Right)
        - Eingabefeld lîschen (Esc)
        - Eingabefeld ab Cursor lîschen (Shift-Del)
        - Eingabefeld bis Cursor lîschen (Shift-Backspace)
        - Eingabebox fÅr alle Ascii-Zeichen (Shift-Insert)
        - Sonderzeicheneingabe durch Eingabe des dezimalen ASCII-Wertes
          bei gedrÅckter Alternate-Taste auf dem Ziffernblock
            => sofern der ASCII-Wert nicht eindeutig ist (ASCII<=25), mÅssen
               alle drei Stellen (evtl. mit fÅhrenden Nullen) eingegeben
               werden
        - Undo (Undo bzw. Shift-Undo, sofern Undo-Button vorhanden)
        - History-Funktion der letzten eingegebenen Texte (Ctrl-Up/Down)
            => mit Shift-Taste: Text in History suchen
        - ClipboardunterstÅtzung:
            => mit Shift-Taste: Text an Clipboard/Eingabe-Feld anhÑngen
            -> Ctrl-X: Text ausschneiden und in Clipboard ablegen
            -> Ctrl-C: Text in Clipboard ablegen
            -> Ctrl-V: Text in Eingabefeld einfÅgen
        - EinfÅge-/öberschreibenmodus (Insert)
            => Strich-/Block-Cursor
        - neue zusÑtzliche GÅltigkeitsmasken in Eingabefeldern:
            'c','C': Ziffern "0-9", Komma ".,", Rechenzeichen "+-*/^",
                     Klammern "(){}[]"
            'l','L': LED-Ziffern "0-9"
            '<Ziffer>': Ziffer='0'-'9'
                     alle Ziffern von '0' bis <Ziffer>, z.B.
                     '1': BinÑrziffern
                     '7': Oktalziffernn
                     '9': Dezimalziffern
            'h','H': Hexadezimalziffern "0-9A-F",
                     Umwandlung in Klein/Groûbuchstaben
            'u','U': ASCII 32-127, Umwandlung in Klein-/Groûbuchstaben
            'v','V': ASCII 32-255, Umwandlung in Klein-/Groûbuchstaben
            'w','W': ASCII 32-127
            'y','Y': ASCII 32-255
        - grîûtenteils automatische Anpassung (sofern mîglich) der
          eingegeben Zeichen an GÅltigkeitsmaske
        - kleiner/groûer System-Font kînnen in Eingabefeldern benutzt
          werden
        - Bedeutung von Return wahlweise
            - Return selektiert DEFAULT-Objekt
            - Return springt zum nÑchsten Eingabefeld (zyklisch)
            - Return selektiert beim letzten Eingabefeld das DEFAULT-Objekt

    - Cookie-/Scrap-/Resource- u. Environment-Library
    - erweiterte Rectangle- & Object-Library von PC-GEM 2.0

    - viele erweiterte Objekte:
        - Radio-Buttons
        - Check-Buttons
        - Cycle-Buttons fÅr Popups
        - Help-Button
        - Undo-Button
        - Text mit Attributen
            - unterstrichen,kursiv,umrandet,schattiert,fett,hell,klein/groû
        - Rahmen mit Titel
        - Titel (=unterstrichener Text)
            - beliebige Strichdicke, optional doppelt unterstrichen
        - Flugecke
        - Slider-Arrows (opt. umrandet)
        - Niceline
        - opt. von Eingabefeldern abhÑngiges DEFAULT-Objekt
        - unmodale und modale Objekte, d.h. die Objekte kommen nur in
          (un-) modalen Dialogen vor
        - usw.

    - Echtzeitgummiband/-schieber mit halb- oder vollautomatischer Ver-
      waltung bzw. Ereignisauswertung sowie optionaler Tastaturbedienung
    - variable Popup-MenÅs (vollstÑndig tastaturbedienbar (Hotkeys),
      frei positionierbar)

    - Dialogoptik in weiten Grenzen variierbar:
        - Hintergrundbox (Muster,Farbe,Rahmen)
        - Flugecke wird an Hintergrundbox angepaût
        - Rahmen (Schrift einfach/doppelt umrandet,Schriftgrîûe)
        - Titel-Unterstrich (LÑnge,Dicke,einfach/doppelt unterstrichen)
        - Farben der erweiterten Objekte
        - viele Varianten der Radio-/Check/Cycle-Buttons sowie Sliderpfeile
        - usw.

    - sauber programmiert, d.h. unabhÑngig von
        - Computer (ST/STE/TT/Falcon/Emulator)
        - Auflîsung und Anzahl der Farben
        - Betriebsystem (TOS,MTOS,MagiC,Geneva,MultiGEM)
        - VDI/GDOS-Treiber
        - Grîûe des System-Fonts

    - usw.

@endnode

@node "Nutzung der Library"

 Durch das beiliegende kommentierte Beispielprogramm, welches einen Teil der
 FÑhigkeiten demonstriert, sowie die Dokumentation der meisten Funktionen,
 Variablen und Strukturen bzw. Konstanten in der Datei 'MANUAL.TXT' bzw. dem
 Hypertext 'E_GEM.HYP' sollte die Programmierung unter Verwendung der Library
 kein grîûeres Problem darstellen.

 Eine weitere Hilfe sind sicherlich die verîffentlichten Quelltexte der
 Library sowie der WinLupe als weiteres Beispielprogramm. Sollte jemand den-
 noch Probleme mit oder Fragen bzgl. der Library haben, so kann er sich an
 mich wenden.

@endnode

@node EnhancedGEM-Applikationen

 - Example (kommentiertes Beispielprogramm,PD)
@index WinLupe
 - WinLupe (saubere Bildschirmlupe,PD)
@index LZH-Shell
 - LZH-Shell (Shell zu LHarc,Fairware)

@index ESS-Code
 - ESS-Code (GEM-UUencoder/-decoder,Shareware) von Michel Forget
@index "Before Dawn"
 - Before Dawn (Bildschirmschoner,Shareware) von Arne Rudolph
@index PLZ
 - PLZ (Postleitzahlenkonvertierer,PD) von Andreas Schrell
@index DB-Log
 - DB-Log (Loginstatistik-Programm zur D-Box,PD) von Arne Konopinski
@index PassThru
 - PassThru (Desktoperweiterung,PostCardWare) von Florian Erhard
@index "800XL Deejay"
 - 800XL Deejay (800XL-Laufwerksemulator,PD) von Kolja Koischwitz
@index "Another Crude Player"
 - ACP (Another Crude Player,Freeware) von Carsten Tolkmit
@index Thor
 - Thor (GEM-Variante des Spiels Thor,Shareware) von Jean-Jaques Michel

in Arbeit:
@index Simpl
 - Simpl (Texteditor mit Highlighting,PD) von Frank Laus
@index "Laborant professionell"
 - Laborant professionell (Chemie-Analyseprogramm,PD) von Jens Schulz

@endnode

@node Zukunft

 In AbhÑngigkeit von meiner Lust, der vorhandenen Zeit, der Resonanz auf
 diese Library und der Anzahl der verîffentlichten EnhancedGEM-Appli-
 kationen sind fÅr die Zukunft folgende Dinge geplant:

    - Fenster-MenÅs
    - Font-Selector-Box
    - Listboxen
    - Text-Fenster
    - Toolbars
    - Werteingabefelder
    - scrollbare Eingabefelder
    - Resource-Previewer
    - neue erweiterte Objekttypen
    - UnterstÅtzung der Help- und MenÅ-Protokolle
    - usw...

@endnode

@node "Dokumentation der Library-Mîglichkeiten"

@{Inhalt: ignore}

 I.   Allgemeine Hinweise

        1.  öbersetzung der Library mit Pure C, GNU-C und Lattice C
        2.  Nutzung der Library mit Pure C, GNU-C und Lattice C

 II.  Neue Mîglichkeiten in Eingabefeldern

 III. erweiterte Objekt-Typen sowie Resource-Aufbau

        1.  Debugging
        2.  Highbyte des Objekt-Typs

 IV.  Globale Variablen der Library

 V.   Funktionen, Strukturen und Konstanten der Library

        1.  Routinen zur Verwaltung des Cookie-Jars
        2.  Routinen zur Verwaltung des Environments
        3.  Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        4.  Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        5.  VDI-Attribut- und Clipping-Funktionen
        6.  Erweiterte Scrap-Directory-Routinen
        7.  Erweiterte Grafik-Routinen
        8.  MenÅ-Funktionen
        9.  Dialog-Optionen und -optik setzen
        10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        11. Resource- und Objekt-Initialisierung
        12. Ereignis-Auswertung
        13. Dialog-Funktionen
        14. Fenster-Funktionen
        15. Popup-Funktion
        16. XAcc-2- und AV-Protokoll-Funktionen
        17. Auskunftsfunktionen
        18. Verschiedene Funktionen
        19. Definitionen hÑufig benîtigter (Protokoll-) Konstanten

@endnode

@node "öbersetzung der Library mit Pure C, GNU-C und Lattice C"

    @{B}WICHTIG:@{0}
    Bei der öbersetzung der Library darf keine Stack-öberprÅfung aktiviert
    sein, da einige Library-Funktionen (z.B. benutzerdefinierte Objekte) vom
    AES aufgerufen werden und somit den AES-Stack verwenden.

    a. Pure C

    EnhancedGEM lÑût sich sowohl mit den Pure-C-Libraries als auch mit den
    MiNT-Libraries ab Patchlevel 30 compilieren.
    Hierzu muû jedoch im Header-File AESBIND.H der MiNT-Libraries die Zeile

    __EXTERN int    evnt_timer __PROTO((unsigned long Interval));

    in

    __EXTERN int    evnt_timer __PROTO((int Int_locount,int Int_hicount));

    geÑndert werden.
    Weiterhin muû das Makro __MINT_LIB__ definiert werden (s. E_GEMMNT.PRJ)

    b. GNU-C/Lattice C

    Ebenfalls lÑût sich EnhancedGEM mit GNU-C und Lattice C Åbersetzen,
    wobei allerdings die MiNT-Library sowie die entsprechenden Makefiles
    (Makefile.GCC bzw. Makefile.LCC) benutzt werden mÅssen. Eventuell auf-
    tretende Warnungen bei der öbersetzung sind (hoffentlich) bedeutungslos.

@endnode

@node "Nutzung der Library mit Pure C, GNU-C und Lattice C"

    a. Wurde EnhancedGEM mit Hilfe der MiNT-Libraries Åbersetzt, so MöSSEN
    die MiNT-Libraries und die dazugehîrigen Header-Dateien auch benutzt wer-
    den. Ansonsten sind die Reaktionen nicht vorhersehbar, aber hîchstwahr-
    scheinlich resultieren daraus Fehlfunktionen (auûer evtl. bei GNU-C).

    b. Die Funktionen evnt_multi, EvntMulti (Pure C) sowie evnt_mesag des
    AES sollten nicht mehr benutzt werden! Stattdessen sollte immer die
    Funktion Event_Multi benutzt werden! Weitere Details zur Ereignisver-
    arbeitung s. Funktionen Event_Multi() und Event_Handler().

    c. Alle internen, modulÅbergreifenden globalen Variablen und Funktionen
    der Library beginnen mit einem Unterstrich '_', so daû es zu keinen
    öberschneidungen kommen sollte.

@endnode

@node "Neue Mîglichkeiten in Eingabefeldern"

@index GÅltigkeitsmasken
    - zusÑtzliche @{B}GÅltigkeitsmasken:@{0}
        'c','C': Ziffern "0-9", Komma ".,", Rechenzeichen "+-*/^",
                 Klammern "(){}[]"
        'l','L': LED-Ziffern "0-9"
        '<Ziffer>': Ziffer='0'-'9', alle Ziffern von '0' bis <Ziffer>, z.B.
                 '1': BinÑrziffern '01'
                 '7': Oktalziffernn '01234567'
                 '9': Dezimalziffern '0123456789'
        'h','H': Hexadezimalziffern "0-9A-F",
                 Umwandlung in Klein/Groûbuchstaben
        'u','U': ASCII 32-127, Umwandlung in Klein-/Groûbuchstaben
        'v','V': ASCII 32-255, Umwandlung in Klein-/Groûbuchstaben
        'w','W': ASCII 32-127
        'y','Y': ASCII 32-255

    - kleiner/groûer System-Font kînnen in Eingabefeldern benutzt
      werden

    - ein Eingabefeld darf maximal MAX_EDIT-Zeichen lang werden (ansonsten
      muû die Konstante bei Bedarf in der Datei 'E_GEM.H' geÑndert und die
      Library neu Åbersetzt werden)

@endnode

@node Debugging

    Wird die Library mit definiertem Konstanten-Makro 'DEBUG' (s.a.
    Projekt-Datei 'E_GEM.PRJ' bzw. 'E_GEMMNT.PRJ') Åbersetzt, so gibt die
    Library Fehlermeldungen (Alert-Boxen) aus, wenn Fehler im Resource-
    Aufbau gefunden wurden (z.B. doppelt vergebene Hotkeys, mehr als ein
    Help-/Undo-/Default-Button usw.). Dabei werden die Art des Fehlers und
    die Nummer des fehlerhaften Objekts ausgegeben.

@endnode

@node "Highbyte des Objekt-Typs"

        #define CHECKBOX        1   /* Check-Box */
        #define HEADER          2   /* öberschrift */
        #define RADIO           3   /* Radio-Button */
        #define UNDERLINE       4   /* Unterstrich */
        #define HOTKEY          5   /* Hotkey-Objekt */
        #define CHKHOTKEY       6   /* Check-Box mit Hotkey */
        #define RBHOTKEY        7   /* Radio-Button mit Hotkey */
        #define INDHOTKEY       8   /* Hotkey-Objekt einer Check-Box oder
                                       eines Radio-Buttons */
        #define FLYDIAL         9   /* Flugecke */
        #define TXTDEFAULT      10  /* Status des DEFAULT-Objekts ist von
                                       diesem Text-Objekt abhÑngig */
        #define USERFLY         11  /* beliebiges Flugobjekt */
        #define HELP_BTN        12  /* Help-Button */
        #define ATTR_TEXT       13  /* Text mit Attributen */
        #define CYCLE_BUTTON    14  /* Cycle-Button */
        #define ARROW_LEFT      15  /* Pfeil links */
        #define ARROW_RIGHT     16  /* Pfeil rechts */
        #define ARROW_UP        17  /* Pfeil hoch */
        #define ARROW_DOWN      18  /* Pfeil runter */
        #define UNDO_BTN        19  /* Undo-Button */

    Jedem Objekt kînnen die erweiterten Typen UNDO_BTN, HELP_BTN, HEADER
    und USERFLY zugeordnet werden. Bei ATTR_TEXT sowie TXTDEFAULT muû
    es sich um ein Text-Objekt (auch G_STRING), bei UNDERLINE sollte es
    sich um den Typ G_BOX handeln. Alle anderen erweiterten Typen
    sollten (mÅssen aber nicht) dem Typ G_BOXCHAR zugeordnet werden.

        #define G_UNMODAL   0x4000  /* unmodales Objekt */
        #define G_MODAL     0x8000  /* modales Objekt */

    ZusÑtzlich kînnen alle (!) Objekte durch Setzen von Bit 14 (G_UNMODAL)
    bzw. Bit 15 (G_MODAL) im Objekt-Typ (erweiterter Objekttyp mit 64 bzw.
    128 verodern) zu einem unmodalen oder modalen Objekt deklariert werden,
    welches nur in unmodalen bzw. modalen Dialogen erscheint.

    Nach dem Initialisieren der Resource durch die Library werden der
    Objekttyp und teilweise das obere Byte des Objektstatus der erweiterten
    Objekte verÑndert. Ebenso zeigt 'ob_spec' meistens auf den USERBLK des
    Objekts. Daher sollte man auf diese Variablen nicht mehr zugreifen, wenn
    man sich seiner Sache nicht sicher ist.
    (s.a. Quelltext der Funktion fix_objects())

    Weitere (Kombinations-) Mîglichkeiten s.a. Beispielprogramm sowie
    Startup-Resource (STARTUP.RSC).

@endnode

@node "Globale Variablen der Library"

@index _app
    int _app;
        -> Programm wurde als Applikation (_app!=0) oder Accessory (_app==0)
           gestartet

@index ap_id
    int ap_id:
        -> Applikationsidentifikation (RÅckgabewert von appl_init())
           oder negativer Wert, wenn AES-Initialisierung nicht erfolg-
           reich war

@index menu_id
    int menu_id:
        -> Nummer des Eintrags im Accessory-MenÅ oder negativer Wert

@index grhandle
    int grhandle:
        -> Handle der AES-Workstation (RÅckgabewert von graf_handle)

@index x_handle
    int x_handle:
        -> Handle der Library-Workstation

@index gr_cw
@index gr_ch
    int gr_cw,gr_ch:
        -> Breite/Hîhe des System-Zeichensatzes (IBM) in Pixel

@index gr_bw
@index gr_bh
    int gr_bw,gr_bh:
        -> Breite/Hîhe eines Rechtecks, das jedes einzelne Zeichen
           des System-Zeichensatzes (IBM) vollstÑndig umgibt.

@index gr_sw
@index gr_sh
    int gr_sw,gr_sh:
        -> Breite/Hîhe des kleinen System-Zeichensatzes (SMALL) in Pixel

@index ibm_font
@index ibm_font_id
    int ibm_font,ibm_font_id;
        -> Hîhe des System-Zeichensatzes (IBM) in Punkt sowie Font-ID

@index small_font
@index small_font_id
    int small_font,small_font_id;
        -> Hîhe des kleinen System-Zeichensatzes (SMALL) in Punkt
           sowie Font-ID

@index fonts_loaded
    int fonts_loaded;
        -> GDOS-Fonts wurden geladen (werden die GDOS-Fonts von der
           Anwendung geladen, so muû diese Variable auf einen Wert un-
           gleich Null gesetzt oder die Fonts selbstÑndig entfernt werden)

@index max_w
@index max_h
    int max_w,max_h:
        -> Breite/Hîhe des Bildschirms in Pixel

@index planes
@index colors
    int planes, colors:
        -> Anzahl der Farbebenen sowie Farben

@index screen
    MFDB *screen;
        -> Memory Form Definition Block des Bildschirms

@index desk
    GRECT desk;
@index clip
    VRECT clip;
        -> Ausmaûe des Desktop-Fensters als GRECT bzw. VRECT

@index aes_version
    int aes_version:
        -> AES-Versionsnummer

@index magx
    int magx:
        -> Versionsnummer von MagiC ab Version 2.00

@index winx
    int winx:
        -> Versionsnummer von Winx ab Version 2.10

@index mint
    int mint:
        -> MiNT-Versionsnummer

@index multi
    int multi:
        -> AES-Multitasking-Betriebssystem vorhanden

@index redraw
    int redraw:
        -> Fenster-Dialog wird gerade neugezeichnet

@index AvServer
    int AvServer;
        -> Applikations-ID des AV-Protokoll-Servers oder negativer Wert

@index menu
    OBJECT *menu;
        -> Zeiger auf den Objektbaum der MenÅleiste oder NULL (diese
           Variable sollte von der Anwendung gesetzt werden bzw. wird von
           der Funktion 'menu_install' gesetzt)

@index menu_available
    int menu_available;
        -> Anwendung darf eigene Drop-Down-MenÅleiste anmelden
           (menu_available!=0)

@index iconified
    OBJECT *iconified;
        -> Zeiger auf Objektbaum, der fÅr die Darstellung von ikonifizierten
           Fenstern benutzt wird (ansonsten weiûer Hintergrund des Fensters,
           falls Zeiger nicht gesetzt wurde)

@endnode

@node "Routinen zur Verwaltung des Cookie-Jars"

@index COOKIE
        @{B}COOKIE-Struktur:@{0}

            typedef struct
            {
                long    cookie_id;      /* ID des Cookies */
                long    cookie_value;   /* Wert des Cookies */
            } COOKIE;

@index create_cookie
        void create_cookie(COOKIE *cookie,long id,long value);
            -> Cookie 'cookie' wird mit der Identifikation 'id' und
               dem Wert 'value' initialisiert

@index new_cookie
        boolean new_cookie(COOKIE *cookie);
            -> Cookie 'cookie' in Cookie-Jar einfÅgen (RÅckgabewert
               gleich FALSE, falls Cookie-Jar nicht existiert oder
               keine freien EintrÑge mehr vorhanden sind)

@index get_cookie
        boolean get_cookie(long id,long *value);
            -> Cookie mit der Identifikation 'id' im Cookie-Jar suchen
               und Wert gegebenenfalls in der Variable '*value' sichern
               (sofern value!=NULL)
            -> RÅckgabewert ungleich FALSE, wenn Cookie gefunden wurde

@index remove_cookie
        void remove_cookie(long id);
            -> Cookie mit der Identifikation 'id' aus dem Cookie-Jar
               entfernen

@index move_cookiejar
        void move_cookiejar(long *new_cookie_jar,long size);
            -> neuen Cookie-Jar 'new_cookie_jar' mit Platz fÅr 'size'
               EintrÑge anlegen und alten Cookie-Jar gegebenfalls
               kopieren
            -> neuer Cookie-Jar muû mindestens so viele EintrÑge wie
               der alte Cookie-Jar haben

@index cookie_size
        long cookie_size(void);
            -> Anzahl der maximalen EintrÑge im Cookie-Jar ermitteln
@endnode

@node "Routinen zur Verwaltung des Environments"

@index getenv
        char *getenv(const char *entry);
            -> Variable 'entry' im Environment suchen und im Erfolgsfall
               Zeiger auf Wert der Variable zurÅckgeben (ansonsten NULL)

@index putenv
        int putenv(const char *entry);
            -> Zeichenkette 'entry' ins Environment einfÅgen
            -> RÅckgabewert ungleich Null im Erfolgsfall
@endnode

@node "Erweiterte Objekt-Routinen"

@index ob_dostate
        void ob_dostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

@index ob_undostate
        void ob_undostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

@index ob_isstate
        int ob_isstate(OBJECT *tree,int object,int bit);
            -> Bit 'bit' im Objektstatus des Objekts 'object' im Baum 'tree'
               testen
            -> Bit gesetzt -> RÅckgabewert ungleich Null

@index ob_doflag
        void ob_doflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

@index ob_undoflag
        void ob_undoflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

@index ob_isflag
        int ob_isflag(OBJECT *tree,int object,int bit);
            -> Bit 'bit' der Objektflags des Objekts 'object' im Baum 'tree'
               testen
            -> Bit gesetzt -> RÅckgabewert ungleich Null

@index ob_xywh
        void ob_xywh(OBJECT *tree,int object,GRECT *rect);
            -> Ausmaûe und Koordinaten (relativ zur linken oberen Ecke
               des Dialogs) des Objekts 'object' im Baum 'tree'
               ermitteln und in der GRECT-Struktur 'rect' sichern

@index ob_get_text
        char *ob_get_text(OBJECT *tree,int object,int clear);
            -> Zeiger auf den Text des Objekts 'object' im Baum 'tree'
               ermitteln und Text lîschen, sofern 'clear' ungleich Null
            -> RÅckgabewert gleich NULL, wenn es sich um kein Text-Objekt
               handelt

@index ob_set_text
        void ob_set_text(OBJECT *tree,int object,char *text);
            -> Text des Objekts 'object' im Baum 'tree' auf 'text' setzen

@index ob_set_hotkey
        int ob_set_hotkey(OBJECT *tree,int object,char hotkey);
            -> Hotkey des Objekts 'object' im Baum 'tree' auf den
               Buchstaben 'hotkey' setzen (Hotkey-Unterstrich wird
               automatisch angepaût)
            -> RÅckgabewert ungleich FALSE -> Hotkey konnte gesetzt werden

@index ob_get_hotkey
        char ob_get_hotkey(OBJECT *tree,int object);
            -> Hotkey des Objekts 'object' im Baum 'tree' ermitteln
            -> RÅckgabewert gleich Null, wenn kein Hotkey gesetzt war

@index ob_draw_chg
        int ob_draw_chg(DIAINFO *info,int object,GRECT *area,
                         int new_state,boolean top);
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen und gegebenenfalls Objektstatus Ñndern
               (new_state>=0, s. objc_change)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Ist der Dialog 'info' der oberste Dialog bzw. im obersten
               Fenster, so kann die Ausgabe durch Setzen des Parameters
               'top' auf einen Wert ungleich Null beschleunigt werden
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekt konnte nicht ausgegeben werden

@index ob_draw_list
        int ob_draw_list(DIAINFO *info,int *objects,GRECT *area);
            -> Liste von Objekten 'objects' (und untergeordnete Objekte)
               des Dialogs 'info' darstellen (Abbruch der Liste mit
               negativem Wert oder Null)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Diese Funktion ist schneller als die einzelne Ausgabe
               von mehreren Objekten Åber ob_draw_chg()
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekte konnten nicht ausgegeben werden

@index ob_draw_dialog
        void ob_draw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Dialog 'tree' zentrieren, Bildschirmbereich reservieren,
               eine sich îffnende Box von der Dialogmitte zu den
               Koordinaten (x,y,w,h) zeichnen (sofern Parameter x,y,w,h
               grîûer als Null sind) und Dialog darstellen

@index ob_undraw_dialog
        void ob_undraw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Eine sich schlieûende Box von den Koordinaten (x,y,w,h) zur
               Dialogmitte zeichnen (sofern Parameter x,y,w,h grîûer als
               Null sind) und Bildschirmbereich freigeben

@index ob_radio
        int ob_radio(OBJECT *tree,int parent,int object)
            -> Radio-Buttons innerhalb des Åbergeordneten Objekts 'parent'
               im Baum 'tree' auf neues Objekt 'object' setzen bzw.
               aktuell gesetztes Objekt ermitteln (object<0)
            -> RÅckgabewert: Gesetztes Objekt

@index ob_get_parent
        int ob_get_parent(OBJECT *tree,int object);
            -> Elternobjekt des Objekts 'object' im Baum 'tree' ermitteln

@index redraw_iconified
        void redraw_iconified(int handle,OBJECT *icon,GRECT *area);
            -> Rechteck 'area' des ikonifizierten Fensters 'handle'
               neuzeichnen
            -> icon: Zeiger auf Objektbaum fÅr ikonifizierte Darstellung
               (meistens ein Icon mit weiûem Hintergrund)
@endnode

@node "Erweiterte Rechteck-Routinen"

@index rc_grect_to_array
        void rc_grect_to_array(GRECT *rect,int *array);
            -> Reckteck 'rect' in Koordinaten-Feld 'array' wandeln

@index rc_array_to_grect
        void rc_array_to_grect(int *array,GRECT *rect);
            -> Koordianten-Feld 'array' in Rechteck 'rect' wandeln

@index rc_copy
        int rc_copy(GRECT *src,GRECT *dst);
            -> Rechteck 'src' nach Rechteck 'dst' kopieren
            -> RÅckgabewert ist immer Null

@index rc_equal
        int rc_equal(GRECT *rect1,GRECT *rect1);
            -> Testet die Rechtecke 'rect1' und 'rect2' auf Gleichheit
               (RÅckgabewert ungleich Null)

@index rc_intersect
        int rc_intersect(GRECT *src,GRECT *dst);
            -> schneidet das Rechteck 'src' mit dem Rechteck 'dst'
               und gibt den gemeinsamen Bereich in 'dst' zurÅck
            -> RÅckgabewert gleich Null, sofern die Rechtecke keinen
               gemeinsamen Bereich besitzen

@index rc_inside
        int rc_inside(int x,int y,GRECT *rect);
            -> Testet, ob die Koordinaten (x,y) im Rechteck 'rect'
               liegen (RÅckgabewert ungleich Null)

@index rc_sc_copy
        void rc_sc_copy(GRECT *src,int x,int y,int mode);
            -> Kopiert den Bildschirmbereich 'src' zu den Koordinaten
               (x,y) (Kopiermodus 'mode' s. vro_cpyfm)

@index rc_sc_clear
        void rc_sc_clear(GRECT *rect);
            -> Lîscht den Bildschirmbereich 'rect'

@index rc_sc_invert
        void rc_sc_invert(GRECT *rect);
            -> Invertiert den Bildschirmbereich 'rect'

@endnode

@node "VDI-Attribut- und Clipping-Funktionen"

@index vsf_aespattern
        void vsf_aespattern(int handle, int x, int y, int pattern)
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               Workstation 'handle' setzen

@index vs_attr
        void vs_attr(void);
            -> wurden die Attribute der internen VDI-Workstation x_handle
               nicht Åber Library-Funktionen verÑndert, so muû diese
               Funktion sofort danach aufgerufen werden, um dies der Library
               kenntlich zu machen

@index v_set_text
        void v_set_text(int font,int height,int color,int out[4])
            -> VDI-Text-Attribute der internen Workstation x_handle setzen:
               font:    Font-ID
               height:  Hîhe in Pixel (>0) oder in Punkt (<0)
               color:   Text-Farbe
               out:     Array fÅr RÅckgabewerte von vst_height/vst_point
                        oder NULL

@index v_set_mode
        void v_set_mode(int mode);
            -> Grafikmodus der internen Workstation x_handle auf
               den Wert 'mode' (0-3) setzen

@index v_set_line
        void v_set_line(int color,int width);
            -> VDI-Linien-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color: Linien-Farbe
               width: Linien-Dicke

@index v_set_fill
        void v_set_fill(int color,int interior,int style);
            -> VDI-FÅllmuster-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color:        FÅllmuster-Farbe
               vsf_interior: FÅllmuster-Typ (0-4)
               vsf_style:    FÅllmuster-Stil

@index v_aespattern
        void v_aespattern(int x,int y,int pattern);
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               internen Workstation x_handle setzen

@index save_clipping
        void save_clipping(int *array);
            -> aktuellen Clipping-Bereich im Koordinaten-Feld 'array'
               sichern

@index restore_clipping
        void restore_clipping(int *array);
            -> Clipping-Bereich auf Koordinaten-Feld 'array' setzen

        @{B}HINWEIS:@{0}
        Wird die interne VDI-Workstation benutzt, so muû sichergestellt
        sein, daû entweder Library-Funktionen benutzt oder die Attribute
        in ihren ursprÅnglichen Zustand zurÅckgesetzt werden.
        Ist dies nicht der Fall, muû sofort nach VerÑnderung der Attribute
        die Funktion vs_attr() aufgerufen werden. Allerdings darf auf keinen
        Fall der Clipping-Bereich verÑndert werden, d.h. er ist mit
        save_clipping()/restore_clipping wiederherzustellen.

@endnode

@node "Erweiterte Scrap-Directory-Routinen"

@index scrp_init
        int scrp_init(char *path);
            -> Initialisiert das Scrap-Directory und setzt es gegebenenfalls
               auf den Pfad 'path' (path!=NULL)
            -> RÅckgabewert ungleich Null im Erfolgsfall

@index scrp_clear
        void scrp_clear(int all);
            -> Alle Dateien (all!=0) oder nur die 'SCRAP.*'-Dateien
               im Scrap-Directory lîschen

@index scrp_length
        long scrp_length(void);
            -> Berechnung der LÑnge des Inhalts des Scrap-Directories

@index scrp_find
        int scrp_find(char *extension,char *filename);
            -> Scrap-Datei mit Erweiterung 'extension' im Scrap-
               Directory suchen
            -> String 'filename' enthÑlt im Erfolgsfall (RÅckgabewert
               ungleich Null) den kompletten Pfad der Datei

@index scrp_changed
        void scrp_changed(int format,long best_ext);
            -> Clipboard-Inhalt wurde verÑndert (SC_CHANGED-Nachricht
               wird (per XAccBroadCast) an alle Applikationen gesendet)
            -> format: Bitmap des Dateiformats

@index SCF_INDEF
            #define SCF_INDEF   0x0000  /* undefiniert */
@index SCF_DBASE
            #define SCF_DBASE   0x0001  /* Datenbank */
@index SCF_TEXT
            #define SCF_TEXT    0x0002  /* Text */
@index SCF_VECTOR
            #define SCF_VECTOR  0x0004  /* Vektor-Grafik */
@index SCF_RASTER
            #define SCF_RASTER  0x0008  /* Raster-Grafik */
@index SCF_SHEET
            #define SCF_SHEET   0x0010  /* Tabellen-Kalkulation */
@index SCF_SOUND
            #define SCF_SOUND   0x0020  /* Sound */

            -> best_ext: 4 Zeichen (z.B. ".RTF") fÅr die "beste" der
                         abgespeicherten Dateien

@endnode

@node "Erweiterte Grafik-Routinen"

@index graf_busy_mouse
        void graf_busy_mouse(void);
            -> Maus als rotierende Scheibe darstellen

@index graf_set_slider
        void graf_set_slider(SLINFO *slider,OBJECT *tree,int mode);
            -> Elemente des Sliders 'slider' im Baum 'tree'
               anhand der Werte der SLINFO-Struktur initialisieren und
               gegebenenfalls neuzeichnen
            -> mode: Bitmap der Initialisierung

@index GRAF_SET_ARROWS
            #define GRAF_SET_ARROWS     1
                -> Slider-Pfeile setzen
@index GRAF_SET_SIZE_POS
            #define GRAF_SET_SIZE_POS   2
                -> Grîûe/Position des Schiebers berechnen und setzen
@index GRAF_SET
            #define GRAF_SET            3
                -> wie GRAF_SET_ARROWS und GRAF_SET_SIZE_POS
@index GRAF_DRAW_SLIDER
            #define GRAF_DRAW_SLIDER    4
                -> Slider-Elemente zeichnen
@index GRAF_DRAW
            #define GRAF_DRAW           7
                -> wie GRAF_SET und GRAF_DRAW_SLIDER

@index graf_arrows
        void graf_arrows(SLINFO *slider,OBJECT *tree,int draw);
            -> Pfeile des Sliders 'slider' im Baum 'tree' initialisieren
               und gegebenenfalls neuzeichnen (draw!=0)

@index graf_rt_slidebox
        void graf_rt_slidebox(SLINFO *slider,int object,int double_click);
            -> Echtzeitslider auswerten und darstellen (diese Routine wird
               intern automatisch aufgerufen, wenn die SLINFO-Strukturen
               bei open_dialog() Åbergeben wurden)
            -> Parameter:
                slider: Zeiger auf SLINFO-Struktur des Sliders

@index HOR_SLIDER
                #define HOR_SLIDER      0   /* horizontaler Slider */
@index VERT_SLIDER
                #define VERT_SLIDER     1   /* vertikaler Slider */

@index SL_STEP
                #define SL_STEP         0   /* Einzelschritt */
@index SL_LINEAR
                #define SL_LINEAR       1   /* linear */
@index SL_LOG
                #define SL_LOG          2   /* logarithmisch */
@index SL_EXP
                #define SL_EXP          3   /* exponential */

@index SLKEY
                typedef struct
                {
                    /* Scan-Code des Ereignisses (Highbyte: Scan-Code,
                       Low-Byte: ASCII-Code oder Null) */
                    int     scan;

                    /* Sondertastenstatus */
                    int     state;

                    /* Slider-Kommando (s. Beschreibung des
                       Parameters 'object')
                    int     cmd;
                } SLKEY;

@index SLINFO
                typedef struct
                {
                    /* Zeiger auf DIAINFO-Struktur des Dialogs */
                    DIAINFO *sl_info;

                    /* Nummer des Elternobjekts */
                    int     sl_parent;

                    /* Objektnummer des Schiebers */
                    int     sl_slider;

                    /* Objektnummern der Pfeile oder negative Werte */
                    int     sl_dec,sl_inc;

                    /* Position, SeitenlÑnge und Maximalwert des Schiebers */
                    int     sl_pos,sl_page,sl_max;

                    /* Richtung des Sliders: */
                    char    sl_vh;      /* HOR_SLIDER,VERT_SLIDER  */

                    /* Wiederholungs-Modus der Pfeile */
                    char    sl_mode;    /* SL_STEP,SL_LINEAR,SL_LOG,SL_EXP */

                    /* Verzîgerungsdauer in Milisekunden vor und wÑhrend der
                       Wiederholung */
                    int     sl_delay,sl_speed;

                    /* Zeiger auf Routine (oder NULL), welche nach jeder
                       VerÑnderung des Sliderwerts 'sl_pos' aufgerufen wird */
                    void    (*sl_do)(OBJECT *obj,int pos,int prev,
                                     int max_pos,int top);
                    /* obj:     Zeiger auf das Slider-Objekt
                       pos:     aktuelle Position des Schiebers
                       prev:    vorherige Position des Schiebers
                       max_pos: maximale Position des Schiebers
                       top:     Dialog ist im Vordergrund */

                    /* Zeiger auf Feld mit Slider-Hotkeys oder NULL (wird
                       nur ausgewertet, wenn die SLINFO-Struktur bei
                       open_dialog() Åbergeben wurde) */
                    SLKEY   *sl_keys;

                    /* Anzahl der Hotkeys im Feld 'sl_keys' */
                    int     sl_keys_cnt;
                } SLINFO;

               object: angeklicktes Objekt oder eines der folgenden
                       Kommandos:

@index SL_UP
                        #define SL_UP       -1  /* Zeile hoch */
@index SL_DOWN
                        #define SL_DOWN     -2  /* Zeile runter */
@index SL_PG_UP
                        #define SL_PG_UP    -3  /* Seite hoch */
@index SL_PG_DN
                        #define SL_PG_DN    -4  /* Seite runter */
@index SL_START
                        #define SL_START    -5  /* Slider-Anfang */
@index SL_END
                        #define SL_END      -6  /* Slider-Ende */

               double_click: Objekt wurde per Doppelklick angeklickt

@index graf_rt_rubberbox
        int graf_rt_rubberbox(int s_x,int s_y,GRECT *rect,int *w,int *h,
                              void(*box_do)(int *array));
            -> Echtzeitgummiband innerhalb des Rechtecks 'rect' mit den
               Start-Koordinaten (s_x,s_y) auswerten und darstellen
            -> Im Erfolgsfall (RÅckgabewert!=0) enthalten die Variablen
               '*w' und '*h' die Breite und Hîhe des Rechtecks
            -> 'box_do' enthÑlt einen Zeiger auf eine Funktion (oder NULL),
               welche nach jeder VerÑnderung des Rechtecks mit einem
               Zeiger auf das Koordinaten-Array 'array' des Rechtecks
               aufgerufen wird

@endnode

@node MenÅ-Funktionen

@index menu_install
        int menu_install(OBJECT *menu,int show);
            -> MenÅ-Leiste 'menu' darstellen (show!=0) oder lîschen
               (show==0). Diese Funktion berÅcksichtigt, ob gegebenenfalls
               auch ein Accessory eine MenÅ-Leiste besitzen darf und ini-
               tialisiert die MenÅ-Punkte 'Fenster wechseln' und 'Fenster
               schlieûen'
            -> RÅckgabewert wie bei 'menu_bar'

@index menu_enable
        void menu_enable(OBJECT *menu,boolean enable,boolean show);
            -> MenÅ-Leiste 'menu' aktivieren (enable==TRUE) bzw. de-
               aktivieren (enable==FALSE) und gegebenenfalls neuzeichnen
               (show!=0) Wird die MenÅleiste nicht neugezeichnet (show==0),
               so muû dies von der Anwendung nachgeholt werden, da diese
               Funktion die MenÅleiste in diesem Fall deaktiviert!

@index menu_dropped
        boolean menu_dropped(OBJECT *menu);
            -> Testen, ob ein Pull-Down-MenÅ des MenÅs 'menu' herunter-
               geklappt ist
@endnode

@node "Dialog-Optionen und -optik setzen"

@index dial_colors
        void dial_colors(int dialog_pattern,int dialog_color,
                         int cycle_button,int hotkey,int check_box,
                         int radio_button,int arrow)
            -> Dialog-Optik setzen:
               dialog_pattern: Hintergrundmuster des Dialogs (0-7)
               dialog_color:   Hintergrundfarbe des Dialogs (0-15)
               cycle_button:   Cycle-Button-Farbe (0-15)
               check_box:      Checkbox-Farbe (0-15)
               radio_button:   Radio-Button-Farbe (0-15)
               arrow:          Slider-Arrow-Farbe (0-15)

@index dial_options
        void dial_options(boolean round,boolean title_frame,
                          boolean title_small,boolean niceline,
                          boolean return_default,boolean background,
                          boolean nonselectable,boolean always_keys,
                          boolean toMouse);
            -> verschiedene Optionen setzen:
               round:          Dialogpositionen auf Bytegrenzen (aus Ge-
                               schwindigkeitsgrÅnden) runden
               title_frame:    öberschriften umrahmen
               title_small:    Kleine Schrift (SMALL) fÅr öberschriften
               niceline:       Niceline fÅr Trennstriche in MenÅs/Popups
               return_default: TRUE:  Return selektiert Default-Objekt
                               FALSE: Return springt zum nÑchsten Eingabefeld
                               FAIL:  Return selektiert Default-Objekt beim
                               letzten Eingabefeld (ansonsten wie FALSE)
               background:     Fensterdialoge (sowie mit open_window() ge-
                               îffnete Fenster) kînnen im Hintergrund
                               wie normale Dialoge bedient werden
               nonselectable:  Fliegende Dialoge fliegen auch beim Anklicken
                               von nicht-selektierbaren/editierbaren
                               Objekten
               always_keys:    TastendrÅcke werden auch bei fliegenden
                               oder modalen Dialogen an die Anwendung
                               weitergegeben
               toMouse:        TastendrÅcke an Fensterdialog unter Maus-
                               zeiger senden, sofern oberster Dialog
                               weder modal noch fliegend ist
                               -> zusammen mit 'background' ist somit eine
                                  vollstÑndige Bedienung von Hintergrund-
                                  dialogen mîglich

@index title_options
        void title_options(boolean mode,int color,int size);
            -> Unterstrichenen Text einstellen:
               mode:  Strich wird Åber die ganze Breite des Dialogs (TRUE)
                      oder Åber die im Resource vorgebenen Koordinaten
                      (FALSE) gezeichnet
               color: Strichfarbe (0-15)
               size:  Strickdicke in Pixel oder Null, wenn der Wert aus
                      der Resource-Struktur entnommen werden soll

@index BUTTON
        @{B}BUTTON-Struktur:@{0}

            typedef struct
            {
                /* Zeiger auf monochrome 16x16-Bitmap (32 Bytes) des
                   selektierten und des normalen Buttons im gerÑte-
                   abhÑngigen Format */
                int *but_on,*but_off;
            } BUTTON;

@index radio_image
        void radio_image(int index,BUTTON *radiobutton);
            -> vordefinierte Images (index: 0-7) oder benutzerdefinierten
               Button 'radiobutton' (radiobutton!=NULL) fÅr Radio-Buttons
               auswÑhlen

@index check_image
        void check_image(int index,BUTTON *checkbox);
            -> vordefinierte Images (index: 0-5) oder benutzerdefinierten
               Button 'checkbox' (checkbox!=NULL) fÅr Check-Box auswÑhlen

@index cycle_image
        void cycle_image(int index,BUTTON *cyclebutton);
            -> vordefinierte Images (index: 0-1) oder benutzerdefinierten
               Button 'cyclebutton' (cyclebutton!=NULL) fÅr Cycle-Buttons
               auswÑhlen

@index arrow_image
        void arrow_image(int index,BUTTON *down,BUTTON *up,BUTTON *left,
                         BUTTON *right);
            -> vordefinierte Images (index: 0-2) oder benutzerdefinierte
               Buttons 'down', 'up' 'left', 'right' (sofern ungleich NULL)
               fÅr Slider-Pfeile auswÑhlen

@endnode

@node "Bibliothek (AES,VDI) sowie Resource (de-) initialisieren"

@index open_work
        boolean open_work(int *handle,int *work_out);
            -> virtuelle Bildschirm-Workstation îffnen
            -> RÅckgabewert ungleich FALSE, wenn Workstation geîffnet
               werden konnte
            -> handle:   VDI-Handle im Erfolgsfall
               work_out: work_out[57]-Feld

@index close_work
        void close_work(int handle);
            -> virtuelle Bildschirm-Workstation 'handle' schlieûen

@index init_gem
        boolean init_gem(char *m_entry,char *x_name,char *a_name,
                         int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library
                - Anmeldung beim AES (appl_init)
                - Xacc-2/AV-Protokolle initialisieren
                - interne VDI-Workstation îffnen
                - Scrap-Directory initialisieren
                - globale Variablen sowie interne Strukturen initialisieren
            -> Parameter:
                m_entry:   Eintrag im Accessory-MenÅ (als Accessory oder
                           unter MTOS) oder NULL
                x_name:    (erweiterter) XAcc-2-Programmname
                a_name:    AV-Programmname (8 Zeichen wie bei appl_find)

                av_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht AV_PROTOKOLL

@index MSG_SETSTATUS
                #define MSG_SETSTATUS   0x001 /* VA_SETSTATUS */
@index MSG_START
                #define MSG_START       0x002 /* VA_START */

                va_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht VA_PROTOSTATUS (AV_SENDKEY, AV_EXIT
                           und AV_ACCWINDOPEN sowie AV_ACCWINDCLOSED werden
                           von der Library immer angegeben!)

@index MSG_SENDKEY
                #define MSG_SENDKEY     0x001 /* AV_SENDKEY */
@index MSG_ASKFILEFONT
                #define MSG_ASKFILEFONT 0x002 /* AV_ASKFILEFONT */
@index MSG_ASKCONFONT
                #define MSG_ASKCONFONT  0x004 /* AV_ASKCONFONT,
                                                 AV_OPENCONSOLE */
@index MSG_ASKOBJECT
                #define MSG_ASKOBJECT   0x008 /* AV_ASKOBJECT */
@index MSG_OPENWIND
                #define MSG_OPENWIND    0x010 /* AV_OPENWIND */
@index MSG_STARTPROG
                #define MSG_STARTPROG   0x020 /* AV_STARTPROG */
@index MSG_ACCWINDOPEN
                #define MSG_ACCWINDOPEN 0x040 /* AV_ACCWINDOPEN,
                                                 AV_ACCWINDCLOSED */
@index MSG_STATUS
                #define MSG_STATUS      0x080 /* AV_STATUS, AV_GETSTATUS */
@index MSG_COPY_DRAGGED
                #define MSG_COPY_DRAGGED 0x100 /* AV_COPY_DRAGGED */
@index MSG_PATH_UPDATE
                #define MSG_PATH_UPDATE 0x200 /* AV_PATH_UPDATE,
                                                 AV_WHAT_IZIT,
                                                 AV_DRAG_ON_WINDOW */
@index MSG_EXIT
                #define MSG_EXIT        0x400 /* AV_EXIT */

                xacc_msgs: Bitmap der unterstÅtzten ACC-Nachrichten (alle
                           anderen ACC-Nachrichten werden automatisch
                           ausgewertet)

@index X_MSG_TEXT
                #define X_MSG_TEXT      0x001 /* ACC_TEXT */
@index X_MSG_META
                #define X_MSG_META      0x002 /* ACC_META */
@index X_MSG_IMG
                #define X_MSG_IMG       0x004 /* ACC_IMG */

            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                       schlug fehl

@index exit_gem
        void exit_gem(void);
            -> Deinitialisierung der Library:
                - Dialoge schlieûen
                - Beenden der XAcc-2-/AV-Protokolle
                - geladene GDOS-Fonts wieder entfernen
                - interne VDI-Workstation schlieûen
                - Abmeldung beim AES (appl_exit)

@index open_rsc
        boolean open_rsc((char *rscname,char *m_entry,char *x_name,char *a_name,int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library (s. init_gem()) sowie Resource
               'rscname' laden
            -> Parameter: s. init_gem()
            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                FAIL:  Resource-File konnte nicht geladen werden (Speicher-
                       mangel oder falscher Pfad)

@index close_rsc
        void close_rsc(void);
            -> Resource-Speicher freigeben und Library deinitialisieren
               (s. exit_gem())

@endnode

@node "Resource- und Objekt-Initialisierung"

@index fix_objects
            void fix_objects(OBJECT *tree,int scaling,
                             int orig_cw,int orig_ch);
                -> erweiterte Objekte des Baums 'tree' initialisieren sowie
                   gegebenenfalls Images/Icons skalieren (scale_image)
                   und ins GerÑteformat konvertieren (trans_image)

                -> Parameter:
                   orig_cw: Breite des Entwurfsfonts in Pixel (meistens 8)
                            oder negativer Wert fÅr rsrc_obfix()-kompatible
                            Anpassung
                   orig_ch: Hîhe des Entwurfsfonts in Pixel (meistens 8 oder
                            16) oder negativer Wert fÅr rsrc_obfix()-kompa-
                            tible Anpassung
                   scaling: Bitmap des Skalierungs-Modus

                    #define NO_SCALING      0   /* keine Skalierung */
                    #define SCALING         1   /* Skalierung */
                    #define TEST_SCALING    2   /* Testen, ob Skalierung not-
                                                   wendig ist */
                    #define DARK_SCALING    4   /* dunkle Skalierung */

                    Beispiele:
                    /* Nie skalieren */
                        images = NO_SCALING;

                    /* Immer skalieren */
                        images = SCALING;

                    /* Bei Bedarf (System-Font kleiner als Entwurfsfont)
                       skalieren */
                        images = SCALING|TEST_SCALING;

                    /* Bei Bedarf dunkel skalieren */
                        images = SCALING|TEST_SCALING|DARK_SCALING;

@index scale_image
        void scale_image(OBJECT *object,int scaling,
                         int orig_cw, int orig_ch);
            -> Image/Icon 'object' skalieren
            -> Parameter s. fix_objects()

@index trans_image
        void trans_image(OBJECT *object);
            -> Image/Icon 'object' in GerÑteformat konvertieren

@index rsrc_calc
        void rsrc_calc(OBJECT *tree,int scaling,int orig_cw,int orig_ch);
            -> Koordinaten und Ausmaûe der Objekte des Baums 'tree' an
               Ausmaûe des System-Fonts unter Beachtung der Ausmaûe des
               Fonts, mit welchem die Resource-Datei erstellt wurde, an-
               passen und anschlieûend erweiterte Objekte initialisieren
               (s. fix_objects())
            -> Parameter s. fix_objects()

@index rsrc_init
        void rsrc_init(int n_tree,int n_obs,int n_frstr,int n_frimg,
                       int scaling,char **rs_strings,long *rs_frstr,
                       BITBLK *rs_bitblk,long *rs_frimg,
                       ICONBLK *rs_iconblk,TEDINFO *rs_tedinfo,
                       OBJECT *rs_object,OBJECT **rs_trindex,
                       RS_IMDOPE *rs_imdope,int orig_cw,int orig_ch)
            -> in Quelltext eingebundene Resource-Datei (*.RSH)
               initialisieren

            -> Parameter:
               n_tree:     Anzahl der BÑume (NUM_TREE)
               n_obs:      Anzahl der Objekte (NUM_OBS)
               n_frstr:    Anzahl der freien Strings (NUM_FRSTR)
               n_frimg:    Anzahl der freien Images (NUM_FRIMG)

               rs_strings: String-Array (Pointer zeigen auf alle
                           Zeichenketten der Resource-Datei)
               rs_frstr:   Index-Array (Indizes der freien Strings
                           fÅr das rs_strings-Array)
               rs_bitblk:  BITBLK-Array (enthÑlt alle Bit-Blîcke)
               rs_frimg:   Index-Array (Indizes der freien Images
                           fÅr das rs_bitblk-Array)
               rs_iconblk: ICONBLK-Array (enthÑlt alle icons)
               rs_tedinfo: TEDINFO-Array (enthÑlt alle TEDINFO-Strukturen)
               rs_object:  OBJECT-Array (enthÑlt alle Objekte)
               rs_trindex: Index-Array (Indizes der ObjektbÑume
                           fÅr das rs_object-Array)
               rs_imdope:  RS_IMDOPE-Array

@index RS_IMDOPE
                @{B}RS_IMDOPE-Struktur:@{0}

                typedef struct
                {
                    int dummy;
                    /* Zeiger auf Bitmap (Image) */
                    int *image;
                } RS_IMDOPE;

               scaling: s. fix_objects()
               orig_cw: s. fix_objects()
               orig_ch: s. fix_objects()

               @{B}HINWEIS:@{0}
               An allen Stellen der Resource, an denen normalerweise
               Pointer vorkommen, muû der Element-Index (Long-Wert) des
               entsprechenden Arrays stehen. Die Image-Zeiger der
               Strukturen BITBLK und ICONBLK enthalten den Index des
               zugehîrigen RS_IMDOPE-Elements.

@endnode

@node Ereignis-Auswertung

@index XEVENT
        @{B}XEVENT-Struktur:@{0}

        typedef struct
        {
            /* PARAMETER: */

            /* Bitmap der gewÅnschten Events:
               MU_KEYBD:     Tastatur-Ereignis
               MU_MESAG:     Nachrichten-Ereignis
               MU_TIMER1/2:  Timer-Ereignis 1/2
               MU_BUTTON1/2: Button-Ereignis 1/2
               MU_M1-4:      Rechteck-Ereignis 1-4 */
            int ev_mflags;

            /* Parameter des 1. Button-Events MU_BUTTON1 */
            int ev_mb1clicks,ev_mb1mask,ev_mb1state

            /* Parameter des 1. Mouse-Event-Rechtecks MU_M1 */
            int ev_mm1flags,ev_mm1x,ev_mm1y,ev_mm1width,ev_mm1height,

            /* Parameter des 2. Mouse-Event-Rechtecks MU_M2 */
            int ev_mm2flags,ev_mm2x,ev_mm2y,ev_mm2width,ev_mm2height;

            /* Parameter des 1. Timer-Events MU_TIMER1 */
            unsigned int ev_mtlocount,ev_mthicount;

            /* RöCKGABEWERTE: */

            /* eingetretene Ereignisse */
            int ev_mwich;

            /* Position des Mauszeigers sowie Zustand der Maustasten
               beim Auftreten des Events */
            int ev_mmox,ev_mmoy,ev_mmobutton;

            /* Zustand der Sondertasten beim Auftreten des Events */
            int ev_mmokstate;

            /* Scancode der gedrÅckten Taste (High-Byte: Scan-Code,
               Low-Byte: ASCII-Code oder Null) */
            int ev_mkreturn;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON1) */
            int ev_mbreturn;

            /* Nachrichten-Puffer */
            int ev_mmgpbuf[8];

            /* erweiterte PARAMETER: */
            /* Parameter des 2. Button-Events MU_BUTTON2 */
            int ev_mb2clicks,ev_mb2mask,ev_mb2state;

            /* Parameter des 3. Mouse-Event-Rechtecks MU_M3 */
            int ev_mm3flags,ev_mm3x,ev_mm3y,ev_mm3width,ev_mm3height;

            /* Parameter des 4. Mouse-Event-Rechtecks MU_M4 */
            int ev_mm4flags,ev_mm4x,ev_mm4y,ev_mm4width,ev_mm4height;

            /* Parameter des 2. Timer-Events MU_TIMER2 */
            unsigned int ev_mt2locount,ev_mt2hicount;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events MU_TIMER1
               oder Null fÅr aktuelle System-Zeit */
            long ev_mt1last;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events MU_TIMER2
               oder Null  fÅr aktuelle System-Zeit */
            long ev_m2last;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON2) */
            int ev_mbreturn;
        } XEVENT;

        @{B}KompatibilitÑts-Makros fÅr EVENT-Struktur und AES-Event-Routinen:@{0}

            #define ev_mbclicks     ev_mb1clicks
            #define ev_mbmask       ev_mb1mask
            #define ev_bmask        ev_mb1mask
            #define ev_mbstate      ev_mb1state
            #define ev_mbreturn     ev_mb1return

            #define ev_mtlocount    ev_mt1locount
            #define ev_mthicount    ev_mt1hicount
            #define ev_mtlast       ev_mt1last

            #define MU_TIMER1       MU_TIMER
            #define MU_BUTTON1      MU_BUTTON

@index Event_Multi
        int Event_Multi(XEVENT *event);
            -> Auf Ereignis 'event' warten (benîtigte Parameter der
               Struktur mÅssen initialisiert sein, sofern dies nicht
               die Initialisierungs-Routine von Event_Handler(), s.u.,
               Åbernimmt). Die Library wertet dabei selbstÑndig Nachrichten
               der XAcc-2- und AV-Protokolle aus und wandelt diese ge-
               gebenenfalls um. Ebenso werden Ereignisse, welche Fenster-
               dialoge bzw. allgemein die Library betreffen, ausgewertet.

               @{B}WICHTIG:@{0}
               Es werden nur Ereignisse zurÅckgeliefert, welche nicht
               von der Library ausgewertet wurden. Allerdings werden evtl.
               Ereignisse, welche bereits von dem durch die Funktion
               Event_Handler() definierten Handler ausgewertet wurden, zu-
               rÅckgeliefert!
               Setzt man die Variable 'ev_mflags' auf Null oder Åbergibt man
               den Wert NULL fÅr den Parameter 'event', so werden @{B}KEINE@{0}
               Events zurÅckgeliefert! Alle Ereignisse mÅssen dann vom
               Handler initialisiert und ausgewertet werden!

            -> RÅckgabewert: Bitmap der eingetretenen Ereignisse

@index Event_Timer
        void Event_Timer(int locount,int hicount)
            -> Wartet bis die durch lo_count und hi_count in Millisekunden
               vorgebene Zeit verstrichen ist. Dabei werden allerdings
               noch Nachrichten durch die Library sowie Ereignisse durch den
               Handler ausgewertet!

@index Event_Handler
        void Event_Handler(int (*init)(XEVENT *,int),
                           int (*handler)(XEVENT *));
            -> Routinen zur Ereignisauswertung festlegen, wobei diese Rou-
               tinen diejenigen Ereignisse auswerten, welche nicht auto-
               matisch von der Library bearbeitet wurden. Durch öbergabe
               von NULL kînnen bereits angemeldete Funktionen einzeln wieder
               abgemeldet werden. Ebenso kann man die Routinen beliebig
               oft neu setzen, z.B. fÅr eine lokale Ereignisauswertung.

            -> Parameter:
                int (*init)(XEVENT *event,int available):
                    -> Routine, welche u.a. von X_Form_Do bei jeder
                       Initialisierung eines Dialogs aufgerufen wird. Die
                       Routine gibt eine Bitmap der gewÅnschten Events zu-
                       rÅck und initialisiert gegebenenfalls Variablen der
                       Åbergebenen XEVENT-Struktur 'event'.
                       Angefordert werden kînnen nur die Events, welche in
                       der Bitmap 'available' gesetzt sind.

                int (*handler)(XEVENT *event):
                    -> Routine, welche u.a. von X_Form_Do aufgerufen wird
                       und die Ereignisse, welche von der Library nicht ver-
                       arbeitet wurden, auswertet. ZurÅckgegeben wird eine
                       Bitmap der ausgewerteten Ereignisse. V.a. bei Tasta-
                       tur-Ereignissen, welche nicht ausgewertet wurden,
                       sollte MU_KEYBD nicht gesetzt sein, damit die Library
                       gegebenenfalls den Tastendruck per Xacc-2- oder AV-
                       -Protokoll weiterleiten kann. Dies kann man natÅrlich
                       unterbinden, indem man stÑndig alle Ereignisse zu-
                       rÅckgibt.

                       @{B}WICHTIG:@{0}
                       Diese Routine darf keine Variablen der XEVENT-Struktur
                       (abgesehen von den Ausgabewerten) verÑndern!

@index Nachrichten
                Library-spezifische Nachrichten (MU_MESAG):
                -------------------------------------------

@index OBJC_EDITED
                    -> Eingabefeld wurde verÑndert:
                        msg[0]        = OBJC_EDITED
                        msg[3]        = Nummer des aktuellen Eingabeobjekts
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

@index OBJC_CHANGED
                    -> selektierbares Objekt (kein EXIT-/TOUCHEXIT-Objekt)
                       wurde verÑndert:
                        msg[0]        = OBJC_CHANGED
                        msg[3]        = Nummer des Objekts
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

@index XACC_AV_INIT
                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       angemeldet
                        msg[0]        = XACC_AV_INIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur

@index XACC_AV_EXIT
                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       abgemeldet
                        msg[0]        = XACC_AV_EXIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur (Struktur
                                        ist nach vollstÑndiger Abmeldung
                                        nicht mehr gÅltig
                                        (Struktur-Variable id<0)

@index WIN_CHANGED
                    -> Status eines Fenster hat sich geÑndert (z.B. wurde
                       das Fenster ikonifiziert/deikonifiziert). U.a. kann
                       sich auch das Fenster-Handle Ñndern!
                        msg[0]        = WIN_CHANGED
                        msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                                        Fensters oder NULL, falls alle
                                        Fenster betroffen sind
@endnode


@node Dialog-Funktionen

@index DIAINFO
        @{B}DIAINFO-Struktur:@{0}

        typedef struct
        {
            /* Dialog-Typ
                CLOSED      -> geschlossen
                OPENED      -> normaler Dialog
                FLYING      -> fliegender Dialog
                WINDOW      -> Fenster-Dialog
                WIN_MODAL   -> modaler Fenster-Dialog */
            DIALMODE di_flag;

            /* Zeiger auf Objektbaum */
            OBJECT   *di_tree;

            /* Zeiger auf Fenster-Struktur */
            WIN      *di_win;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } DIAINFO;

@index open_dialog
        boolean open_dialog(OBJECT *tree,DIAINFO *info,char *title,
                boolean center, boolean grow_box,int dialog_mode,int edit,
                SLINFO **slider);
            -> Dialog îffnen (RÅckgabewert ungleich Null, wenn Dialog ge-
               îffnet wurde)
            -> Parameter:
                tree:
                    -> Zeiger auf Objektbaum
                info:
                    -> Zeiger auf DIAINFO-Struktur (wird von dieser
                       Funktion initialisiert)
                title:
                    -> Zeiger auf Fenster-Titel fÅr Fensterdialoge
                center:
                    TRUE  -> Dialog um Mauszeiger zentrieren
                    FALSE -> Dialog in Bildschirmmitte zentrieren
                             (sichtbarer Ausschnitt des Bildschirms
                             wird beachtet)
                    FAIL  -> Dialog an letzter Position îffnen (beim
                             ersten ôffnen analog wie FALSE)
                grow_box:
                    -> sich vergrîûernder Rechtecke zeichnen
                dialog_mode:
                    -> Bitmap des Dialogtyps:
@index FLY_DIAL
                        /* fliegender Dialog */
                        #define FLY_DIAL        1

@index WIN_DIAL
                        /* Fenster-Dialog */
                        #define WIN_DIAL        2

@index AUTO_DIAL
                        /* Fenster-Dialog, sofern Fenster geîffnet werden
                           kann, ansonsten fliegender Dialog
                        #define AUTO_DIAL       (FLY_DIAL|WIN_DIAL)

@index MODAL
                        /* modaler Fensterdialog */
                        #define MODAL           4

@index FRAME
                        /* Fenster-Dialog mit Rahmen */
                        #define FRAME           8

@index NO_ICONIFY
                        /* Fenster-Dialog kann nicht ikonifiziert werden */
                        #define NO_ICONIFY      16

                edit:
                    -> Objektnummer des Eingabefeldes, in welchem sich
                       der Cursor befinden soll (oder negativer Wert)

                slider:
                    -> Zeiger auf Liste mit Adressen der SLINFO-Strukturen
                       (letzter Listen-Eintrag gleich NULL) der Slider des
                       Dialogs oder NULL, wenn die Slider nicht automatisch
                       verwaltet werden sollen

@index close_dialog
        void close_dialog(DIAINFO *dialog,boolean shrink_box);
            -> Dialog 'dialog' schlieûen und gegebenenfalls sich
               verkleinernde Rechtecke zeichnen (shrink_box!=0)

@index X_Form_Do
        int X_Form_Do(DIAINFO **dialog)
            -> Bearbeitung der geîffneten Dialoge
            -> ZurÅckgegeben wird die Nummer des angewÑhlten Exit-Objekts
               (bei Doppelklick ist Bit 15 (0x8000) gesetzt) oder die Werte
@index W_ABANDON
               W_ABANDON -> Abbruch der Dialogbearbeitung, alle Dialoge
                            wurden geschlossen (z.B. durch AC_CLOSE)
@index W_CLOSED
               W_CLOSED  -> Fensterdialog wurde geschlossen
            -> '*dialog' enthÑlt (sofern ungleich NULL) einen Zeiger auf
               die DIAINFO-Struktur des aktuellen Dialogs

@index xdialog
        int xdialog(OBJECT *tree,char *title,boolean center,
                    boolean grow_box,int dialog_mode);
            -> komplette Dialogbearbeitung (Dialog îffnen, bearbeiten und
               schlieûen)
            -> Parameter und RÅckgabewerte s. open_dialog() sowie
               X_Form_Do()

@index xalert
        int xalert(int default,int undo,int icon,BITBLK *user_icon,
                   int center,int width,
                   char *title,char *text,char *buttons)
            -> erweiterte Alertbox darstellen (Index des ausgewÑhlten
                          Buttons wird zurÅckgeliefert)
            -> default:   Index des DEFAULT-Buttons oder negativer Wert
               undo:      Index des UNDO-Buttons oder negativer Wert
               icon:      Nummer des Icons oder negativer Wert

@index X_ICN_NAME
                #define X_ICN_NONE      -1 /* kein Icon */
@index X_ICN_MAX
                #define X_ICN_MAX       17 /* maximale Icon-Nummer */

@index X_ICN_STOP
                #define X_ICN_STOP      7  /* Stop-Schild (Hinweis) */
@index X_ICN_QUESTION
                #define X_ICN_QUESTION  10 /* Fragezeichen (Nachfrage) */
@index X_ICN_ALERT
                #define X_ICN_ALERT     11 /* Ausrufezeichen (Warnung) */
@index X_ICN_DISC_ERR
                #define X_ICN_DISC_ERR  5  /* Disketten-I/O-Fehler */
@index X_ICN_ERROR
                #define X_ICN_ERROR     6  /* Bomben-Fehler */
@index X_ICN_FLOPPY
                #define X_ICN_FLOPPY    8  /* Disketten-Station */
@index X_ICN_DISC
                #define X_ICN_DISC      9  /* Diskette */
@index X_ICN_INFO
                #define X_ICN_INFO      13 /* Informations-Zeichen */
@index X_ICN_PRT_ERR
                #define X_ICN_PRT_ERR   15 /* Drucker-I/O-Fehler */

               user_icon: Zeiger auf benutzerdefiniertes Icon oder NULL
               center:    Ausrichtung der Buttons

@index BUTTONS_CENTERED
                #define BUTTONS_CENTERED    0 /* zentriert */
@index BUTTONS_LEFT
                #define BUTTONS_LEFT        1 /* linksbÅndig */
@index BUTTONS_RIGHT
                #define BUTTONS_RIGHT       2 /* rechtsbÅndig */

               width:     einheitliche Breite der Buttons (width!=0)
               text:      Zeiger auf Text (maximale 10 Zeilen getrennt
                          durch '|')
               buttons:   Button-Text (maximal 6 Buttons getrennt durch
                          '|', Hotkeymarkierung durch '[')
               title:     Zeiger auf Fenster-Titel fÅr Fensterdialoge

@index ascii_box
        char ascii_box(char *title)
            -> Sonderzeicheneingabebox îffnen (Parameter s. open_dialog())
            -> RÅckgabewert: ausgewÑhltes Zeichen

@endnode


@node Fenster-Funktionen

@index WIN
        @{B}WIN-Struktur:@{0}

        typedef struct
        {
             /* Handle des Fensters (handle>0, falls Fenster geîffnet) */
             int handle;

             /* Bitmap der Fensterelemente (s. wind_create) */
             int gadgets;

             /* Bitmap des Fenster-Status */
             int iconified;

                 #define ICONIFIED  1  /* Fenster ikonifiziert (MTOS) */
                 #define SHADE      2  /* Fenster eingeklappt (Winx 2.3) */
                 #define ICFS       4  /* Fenster ikonifiziert (ICFS) */

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } WIN;

@index open_window
        WIN *open_window(char *title,char *info,int gadgets,int box,
                        int x,int y,int w,int h)
            -> Fenster mit den Elementen 'gadgets' an den Koordinaten (x,y)
               mit den Ausmaûen (w,h) îffnen. Das Fenster wird bei einem
               evtl. vorhandenen AV-Server angemeldet (AV_ACCWINDOPEN)
               und evtl. die Hintergrundbedienung aktiviert.
            -> Parameter:
               title: Zeiger auf Fenstertitel oder NULL
               info:  Zeiger auf Infozeile oder NULL
               box:   sich vergrîûernde Rechtecke zeichnen (box!=0)
            -> RÅckgabewert: Zeiger auf WIN-Struktur oder NULL

@index close_window
        int close_window(WIN *window,int box)
            -> Fenster mit der Struktur 'window' schlieûen und gegebenenfalls
               (box!=0) sich verkleinernde Rechtecke zeichnen. Auûerdem wird
               das Fenster bei einem evtl. vorhandenem AV-Server abgemeldet
               (AV_ACCWINDCLOSED).
            -> RÅckgabewert gleich Null, wenn ein Fehler auftrat

@index get_window
        WIN *get_window(int handle)
            -> WIN-Struktur zum Fenster 'handle' ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

@index CycleCloseWindows
        void CycleCloseWindows(char cycle_hot,char close_hot,int cycle_menu,
                               int close_menu)
            -> Hotkeys (+Control-Taste) und MenÅpunkte fÅr die Funktionen
               'Fenster wechseln' sowie 'Fenster schlieûen' definieren.
               Beachtet werden alle Fensterdialoge sowie Fenster, die mit
               den Funktionen open_window() und close_window() geîffnet bzw.
               geschlossen werden. Der MenÅtitel wird nur dann deselektiert,
               wenn der Zeiger auf die MenÅleiste 'menu' gesetzt ist!
            -> Parameter:
                cycle_hot,close_hot:
                  -> Hotkey-Buchstaben oder Null
                cycle_menu,close_menu:
                  -> Objektnummern der Pulldown-MenÅeintrÑge oder neg. Werte

@endnode

@node Popup-Funktion


@index POPUP
        @{B}POPUP-Struktur:@{0}

            typedef struct
            {
                /* Zeiger auf DIAINFO-Struktur des Parent-Dialogs
                   oder NULL */
                DIAINFO *p_info;

                /* Zeiger auf Objektbaum des Popups */
                OBJECT  *p_menu;

                /* Objektnummer des Info-Objekts (meistens Text links vom
                   Popup-Button) oder negativer Wert */
                int     p_parent;

                /* Objektnummer des Popup-Buttons oder negativer Wert */
                int     p_button;

                /* Objektnummer des Cycle-Buttons (dabei muû es sich nicht
                   um den erweiterten Typ CYCLE_BUTTON handeln) oder
                   negativer Wert */
                int     p_cycle;

                /* Beim Erreichen des ersten/letzten Eintrags mit den Cur-
                   sor-Tasten Hoch/Runter wird zum letzten/ersten Eintrag
                   gesprungen */
                boolean p_wrap;

                /* Der Text des Popup-Buttons wird automatisch auf den
                   Wert des aktuellen Eintrags gesetzt und nach dem Ende
                   der Popup-Bearbeitung neugezeichnet */
                boolean p_set;
            } POPUP;

        int Popup(POPUP *popup,int mode,int center,int x,int y,
                  int *index,int select)
            -> Popup 'popup' îffnen, bearbeiten und wieder schlieûen
            -> mode: Popup-Modus

@index POPUP_BTN
                #define POPUP_BTN   0   /* Popup-Button wurde angeklickt */
@index POPUP_CYCLE
                #define POPUP_CYCLE 1   /* Cycle-Button wurde angeklickt */
@index POPUP_CHECK
                #define POPUP_CHECK 2   /* HÑkchen vor aktuellem Eintrag */

@index POPUP_BTN_CHK
                #define POPUP_BTN_CHK   (POPUP_BTN|POPUP_CHECK)
@index POPUP_CYCLE_CHK
                #define POPUP_CYCLE_CHK (POPUP_CYCLE|POPUP_CHECK)
@index POPUP_RADIO
                #define POPUP_RADIO     POPUP_BTN_CHK
@index POPUP_BTN
                #define POPUP_SELECT    POPUP_BTN

            -> center: Position des Popups

@index CENTER
                #define CENTER    1 /* in Bildschirm zentrieren */
@index MOUSEPOS
                #define MOUSEPOS  2 /* um Mauszeiger zentrieren */
@index XPOS
                #define XPOS      3 /* X-Koordinate x, vertikal
                                       um Mauszeiger zentrieren */
@index YPOS
                #define YPOS      4 /* Horizontal um Mauszeiger zentrieren,
                                       Y-Koordinate y */
@index XYPOS
                #define XYPOS     5 /* Koordinaten (x,y) */
@index OBJPOS
                #define OBJPOS    6 /* um aktuellen Eintrag zentrieren oder
                                       wie XYPOS */

            -> select: aktueller Eintrag oder negativer Wert

            -> zurÅckgegeben wird die Objektnummer des selektierten Eintrags
               (oder 0) sowie in '*index' (sofern index!=NULL) der Index
               des selektierten Eintrags. Ist Bit 15 (0x8000) des RÅckgabe-
               wertes gesetzt, so wurde das Objekt per Doppelklick oder bei
               gedrÅckter Shift-Taste ausgewÑhlt

@endnode


@node "XAcc-2- und AV-Protokoll-Funktionen"

        Die Library verwaltet intern alle An- und Abmeldungen der Proto-
        kolle XAcc2 und AV selbstÑndig. Ebenso werden die Nachrichten
        AV_SENDKEY sowie ACC_KEY automatisch in Keyboard-Events umge-
        wandelt bzw. nicht ausgewertete Keyboardevents werden als
        AV_SENDKEY bzw. ACC_KEY an den AV-Server oder die Hauptapplikation
        geschickt. Weiterhin werden nicht unterstÅtzte XAcc2-Nachrichten
        mit einer ACC_ACK-Nachricht beantwortet.

        Alle Fensterdialoge sowie Fenster, die mit den Funktionen
        open_window() und close_window() geîffnet bzw. geschlossen werden,
        werden bei einem eventuell vorhandenen AV-Server an- bzw. abge-
        meldet.

@index XACC
        #define XACC    1   /* XAcc-Protokoll */
@index AV
        #define AV      2   /* AV-Protokoll */

@index XAcc
        @{B}XAcc-Struktur:@{0}

        typedef struct
        {
            /* unterstÅtzte Protokolle (Bit 0: XAcc, Bit 1: AV) */
            int     flag;       /* XACC/AV */

            /* Applikations-Identifikation */
            int     id;         /* XAcc/AV-Protokoll */

            /* Highbyte: Programmversionsnummer
               Lowbyte:  unterstÅtzte Nachrichtengruppen
            int     version;    /* nur XAcc-Protokoll */

            /* ID des MenÅeintrags im Accessory-MenÅ */
            int     menu_id;    /* nur XAcc-Protokoll */

            /* AV-Programmname (8 Zeichen) fÅr appl_find */
            char    name[];     /* nur AV-Protokoll */

            /* (erweiterter) XAcc2-Programmname oder NULL */
            char    *xname;     /* nur XAcc-Protokoll */

            /* Zeiger auf 'XDSC'-Informationen oder NULL */
            char    *xdsc;      /* nur XAcc-Protokoll */
        } XAcc;

@index XAccBroadCast
        void XAccBroadCast(int msg[8])
            -> Nachrichtenpuffer 'msg' an alle erreichbaren Applikationen
               verschicken

@index XAccSendAck
        int XAccSendAck(int sendto, int answer)
            -> ACC_ACK-RÅckmeldung 'answer' an Applikation 'sendto' senden
               (OK: answer!=0, Fehler: answer==0)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

@index XAccSendKey
        int XAccSendKey(int sendto, int scan, int state)
            -> Tasten-Druck (Scancode 'scan', Status der Umschalttasten
               'state') an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

@index XAccSendText
        int XAccSendText(int sendto, char *txt)
            -> Zeichenkette 'txt' an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

@index XAccSendMeta
        int XAccSendMeta(int sendto, int last, char *data, long len)
            -> Metafile-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

@index XAccSendImg
        int XAccSendImg(int sendto, int last, char *data, long len)
            -> GEM-Image-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

@index AvSendMsg
        int AvSendMsg(int sendto,int msg_id,int msg[8])
            -> (AV-) Nachricht 'msg_id' an Applikation 'sendto' senden
               (Message-Puffer msg[3]-msg[7] enthÑlt gegebenenfalls weitere
               Daten)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

@index find_xacc_xdsc
        XAcc *find_xacc_xdsc(int app_id,char *xdsc)
            -> erweiterten XAcc-Programmnamen der Applikation 'app_id' nach
               Zeichenkette 'xdsc' durchsuchen (app<0 -> alle XAcc-Appli-
               kationen durchsuchen)
            -> RÅckgabewert enthÑlt Zeiger auf XAcc-Struktur der
               Applikation, deren XAcc-Programmname die Zeichenkette ent-
               hÑlt, oder NULL, wenn die Zeichenkette nicht gefunden wurde

@index find_id
        XAcc *find_id(int app_id)
            -> XAcc-Struktur der Applikation 'app_id' ermitteln oder NULL,
               wenn es sich um keine XAcc-Applikation handelt

@index find_app
        XAcc *find_app(int first)
            -> XAcc-Struktur der ersten (first!=0) oder der nÑchsten
               (first==0) angemeldeten Applikation ermitteln (RÅckgabewert
               gleich NULL, wenn keine weitere Applikation gefunden wurde)

@index AppLoaded
        int AppLoaded(char *name)
            -> Ermittelt die Applikations-ID der Anwendung mit dem
               Dateinamen 'name', welcher auch Pfad- und Laufwerksangaben
               enthalten darf.
            -> RÅckgabewert: Applikations-ID oder negativer Wert
@endnode


@node Auskunftsfunktionen

@index appl_xgetinfo
        int appl_xgetinfo(int type,int *out1,int *out2,int *out3,int *out4);
            -> erweiterte appl_getinfo()-Routine, welche die Existenz von
               appl_getinfo() selbstÑndig ermittelt
            -> RÅckgabewerte wie bei appl_getinfo()

@index appl_getfontinfo
        int appl_getfontinfo(int font_type,int *height,int *id,int *type)
            -> Informationen Åber groûen (font_type=0) oder kleinen
               System-Font (font_type=1) ermitteln
            -> RÅckgabewerte:
                height: Font-Hîhe in Punkt
                id:     Font-ID
                type:   0 - System-Font
                        1 - FSM-Font

@index wind_xget
        int wind_xget(int w_handle, int w_field, int *w1, int *w2,
                      int *w3,int *w4);
            -> korrigierte wind_get()-Funktion fÅr erweiterte Aufrufe unter
               Winx sowie MTOS und zukÅnftigen Erweiterungen (die in der
               Pure C-GEM-Library bis V1.1 enthaltene, optimierte Routine
               funktioniert nicht mit neueren Aufrufen)

@index get_dialog_info
        int get_dialog_info(int *dialogs,int *wins,DIAINFO **top);
            -> Informationen Åber geîffnete Dialoge ermitteln
            -> RÅckgabewert: TRUE:  Ausgabe in beliebiges Fenster mîglich
                             FALSE: Ausgabe nur in obersten Dialog 'top'
                             FAIL:  Keine Ausgabe mîglich
               *dialogs: Anzahl der geîffneten (fliegenden) Dialoge (sofern
                         dialogs!=NULL)
               *wins:    Anzahl der geîffneten Fenster-Dialoge (sofern
                         wins!=NULL)
               *top:     Zeiger auf obersten Dialog, falls RÅckgabewert
                         gleich FALSE (sofern top!=NULL)

@endnode


@node "Verschiedene Funktionen"

@index scan_2_ascii
        int scan_2_ascii(int scan,int state);
            -> ASCII-Wert aus Scan-Code 'scan' und Status der
               Umschalttasten 'state' ermitteln

@index min
        int min(int val1,int val2);
            -> Minimum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

@index max
        int max(int val1,int val2);
            -> Maximum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

@index Min
        void Min(int *var,int val);
            -> Minimum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

@index Max
        void Max(int *var,int val);
            -> Maximum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

@index mfdb
        void mfdb(MFDB *mfdb,int *bitmap,int width,int height,
                  int standard,int planes)
            -> Memory form definition block 'mfdb' initialisieren
            -> bitmap:       Zeiger auf Start der Bitmap
               width,height: Breite/Hîhe der Bitmap in Pixeln
               standard:     Standardformat (1) oder gerÑteabhÑngiges
                             Format
               planes:       Anzahl der Farbebenen der Bitmap

@index mfdb_size
        long mfdb_size(MFDB *mfdb);
            -> Speicherbedarf der Bitmap des Memory form definition
               block 'mfdb' berechnen

@endnode

@node "Definitionen hÑufig benîtigter (Protokoll-) Konstanten"

@index XAcc-2-Protokoll
        XAcc-2-Protokoll:
        (genaue Bedeutung s. XAcc-2-Dokumentation)

        #define ACC_ID      0x400
        #define ACC_OPEN    0x401
        #define ACC_CLOSE   0x402
        #define ACC_ACC     0x403
        #define ACC_EXIT    0x404

        #define ACC_ACK     0x500
        #define ACC_TEXT    0x501
        #define ACC_KEY     0x502
        #define ACC_META    0x503
        #define ACC_IMG     0x504

@index AV-Protokoll
        AV-Protokoll:
        (genaue Bedeutung s. AV-Dokumentation 'VA_PROTO.H')

        #define AV_PROTOKOLL        0x4700
        #define AV_GETSTATUS        0x4703
        #define AV_STATUS           0x4704
        #define AV_SENDKEY          0x4710
        #define AV_ASKFILEFONT      0x4712
        #define AV_ASKCONFONT       0x4714
        #define AV_ASKOBJECT        0x4716
        #define AV_OPENCONSOLE      0x4718
        #define AV_OPENWIND         0x4720
        #define AV_STARTPROG        0x4722
        #define AV_ACCWINDOPEN      0x4724
        #define AV_ACCWINDCLOSED    0x4726
        #define AV_COPY_DRAGGED     0x4728
        #define AV_PATH_UPDATE      0x4730
        #define AV_WHAT_IZIT        0x4732
        #define AV_DRAG_ON_WINDOW   0x4734
        #define AV_EXIT             0x4736

        #define VA_PROTOSTATUS      0x4701
        #define VA_SETSTATUS        0x4705
        #define VA_START            0x4711
        #define VA_FILEFONT         0x4713
        #define VA_CONFONT          0x4715
        #define VA_OBJECT           0x4717
        #define VA_CONSOLEOPEN      0x4719
        #define VA_WINDOPEN         0x4721
        #define VA_PROGSTART        0x4723
        #define VA_DRAGACCWIND      0x4725
        #define VA_COPY_COMPLETE    0x4729
        #define VA_THAT_IZIT        0x4733
        #define VA_DRAG_COMPLETE    0x4735

        #define VA_OB_UNKNOWN       0
        #define VA_OB_TRASHCAN      1
        #define VA_OB_SHREDDER      2
        #define VA_OB_CLIPBOARD     3
        #define VA_OB_FILE          4
        #define VA_OB_FOLDER        5
        #define VA_OB_DRIVE         6
        #define VA_OB_WINDOW        7

@index Drag&Drop
        MTOS-Drag&Drop-Protokoll:
        (genaue Bedeutung s. MTOS-Entwickler-Dokumentation)

        #define AP_DRAGDROP         63

        #define DD_OK               0
        #define DD_NAK              1
        #define DD_EXT              2
        #define DD_LEN              3
        #define DD_TRASH            4
        #define DD_PRINTER          5
        #define DD_CLIPBOARD        6

        #define DD_TIMEOUT          4000

        #define DD_NUMEXTS          8
        #define DD_EXTSIZE          32L
        #define DD_NAMEMAX          128

        #define DD_HDRMAX           (8+DD_NAMEMAX)

@index MenÅ-Protokoll
        MenÅ-Protokoll:

        #define WM_CLOSED       0x0016
        #define WM_SAVE         0x1000
        #define WM_SAVEAS       0x1001
        #define WM_PRINT        0x1002
        #define WM_UNDO         0x1003
        #define WM_CUT          0x1004
        #define WM_COPY         0x1005
        #define WM_PASTE        0x1006
        #define WM_SELECTALL    0x1007
        #define WM_FIND         0x1008
        #define WM_REPLACE      0x1009
        #define WM_FINDNEXT     0x100a
        #define WM_HELP         0x100b

@index Clipboard-Protokoll
        Clipboard-Protokoll:
        (s.a. Beschreibung der Funktion scrp_changed())

        Aufbau der Nachricht:
            msg[0]          = SC_CHANGED $1234 (4660)
            msg[1]          = apID
            msg[2]          = 0
            msg[3]          = Bitmap des Dateiformats
                              (Parameter 'format' von scrp_changed())
            msg[4],msg[5]   = 4 Zeichen fÅr die "beste" der abgespeicherten
                              Dateien (z.B. ".RTF"), damit beim Lesen mîg-
                              lichst wenig Information verloren geht
                              (Parameter 'best_ext' von scrp_changed())
            msg[6],msg[7]   = reserviert (auf Null setzen!)


@endnode
