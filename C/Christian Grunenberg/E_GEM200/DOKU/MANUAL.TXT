
 0. INHALT:
============

 I.   Allgemeine Hinweise

        1.  öbersetzung der Library mit Pure C, GNU-C und Lattice C
              a. Pure C
              b. GNU-C/Lattice C
        2.  Nutzung der Library mit Pure C, GNU-C und Lattice C

 II.  Neue Mîglichkeiten in Eingabefeldern

 III. erweiterte Objekt-Typen sowie Resource-Aufbau

        1.  Debugging
        2.  Highbyte des Objekt-Typs

 IV.  Globale Variablen der Library

 V.   Funktionen, Strukturen und Konstanten der Library

        1.  Routinen zur Verwaltung des Cookie-Jars
        2.  Routinen zur Verwaltung des Environments
        3.  Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        4.  Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        5.  VDI-Attribut- und Clipping-Funktionen
        6.  Erweiterte Scrap-Directory-Routinen
        7.  Erweiterte Grafik-Routinen
        8.  MenÅ-Funktionen
        9.  Dialog-Optionen und -optik setzen
        10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        11. Resource- und Objekt-Initialisierung
        12. Ereignis-Auswertung
        13. Dialog-Funktionen
        14. Fenster-Funktionen
        15. Popup-Funktion
        16. XAcc-2- und AV-Protokoll-Funktionen
        17. Auskunftsfunktionen
        18. Verschiedene Funktionen
        19. Definitionen hÑufig benîtigter (Protokoll-) Konstanten


 I. Allgemeine Hinweise:
=========================

 1. öbersetzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    WICHTIG:
    Bei der öbersetzung der Library darf keine Stack-öberprÅfung aktiviert
    sein, da einige Library-Funktionen (z.B. benutzerdefinierte Objekte) vom
    AES aufgerufen werden und somit den AES-Stack verwenden.

    a. Pure C

    EnhancedGEM lÑût sich sowohl mit den Pure-C-Libraries als auch mit den
    MiNT-Libraries ab Patchlevel 30 compilieren.
    Hierzu muû jedoch im Header-File AESBIND.H der MiNT-Libraries die Zeile

    __EXTERN int    evnt_timer __PROTO((unsigned long Interval));

    in

    __EXTERN int    evnt_timer __PROTO((int Int_locount,int Int_hicount));

    geÑndert werden.
    Weiterhin muû das Makro __MINT_LIB__ definiert werden (s. E_GEMMNT.PRJ)

    b. GNU-C/Lattice C

    Ebenfalls lÑût sich EnhancedGEM mit GNU-C und Lattice C Åbersetzen,
    wobei allerdings die MiNT-Library sowie die entsprechenden Makefiles
    (Makefile.GCC bzw. Makefile.LCC) benutzt werden mÅssen. Eventuell auf-
    tretende Warnungen bei der öbersetzung sind (hoffentlich) bedeutungslos.

 2. Nutzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    a. Wurde EnhancedGEM mit Hilfe der MiNT-Libraries Åbersetzt, so MöSSEN
    die MiNT-Libraries und die dazugehîrigen Header-Dateien auch benutzt wer-
    den. Ansonsten sind die Reaktionen nicht vorhersehbar, aber hîchstwahr-
    scheinlich resultieren daraus Fehlfunktionen (auûer evtl. bei GNU-C).

    b. Die Funktionen evnt_multi, EvntMulti (Pure C) sowie evnt_mesag des
    AES sollten nicht mehr benutzt werden! Stattdessen sollte immer die
    Funktion Event_Multi benutzt werden! Weitere Details zur Ereignisver-
    arbeitung s. Funktionen Event_Multi() und Event_Handler().

    c. Alle internen, modulÅbergreifenden globalen Variablen und Funktionen
    der Library beginnen mit einem Unterstrich '_', so daû es zu keinen
    öberschneidungen kommen sollte.

 II. Neue Mîglichkeiten in Eingabefeldern:
===========================================

    - zusÑtzliche GÅltigkeitsmasken:
        'c','C': Ziffern "0-9", Komma ".,", Rechenzeichen "+-*/^",
                 Klammern "(){}[]"
        'l','L': LED-Ziffern "0-9"
        '<Ziffer>': Ziffer='0'-'9', alle Ziffern von '0' bis <Ziffer>, z.B.
                 '1': BinÑrziffern '01'
                 '7': Oktalziffernn '01234567'
                 '9': Dezimalziffern '0123456789'
        'h','H': Hexadezimalziffern "0-9A-F",
                 Umwandlung in Klein/Groûbuchstaben
        'u','U': ASCII 32-127, Umwandlung in Klein-/Groûbuchstaben
        'v','V': ASCII 32-255, Umwandlung in Klein-/Groûbuchstaben
        'w','W': ASCII 32-127
        'y','Y': ASCII 32-255

    - kleiner/groûer System-Font kînnen in Eingabefeldern benutzt
      werden

    - ein Eingabefeld darf maximal MAX_EDIT-Zeichen lang werden (ansonsten
      muû die Konstante bei Bedarf in der Datei 'E_GEM.H' geÑndert und die
      Library neu Åbersetzt werden)


 III. erweiterte Objekt-Typen sowie Resource-Aufbau:
=====================================================

    1. Debugging:
    -------------

    Wird die Library mit definiertem Konstanten-Makro 'DEBUG' (s.a.
    Projekt-Datei 'E_GEM.PRJ' bzw. 'E_GEMMNT.PRJ') Åbersetzt, so gibt die
    Library Fehlermeldungen (Alert-Boxen) aus, wenn Fehler im Resource-
    Aufbau gefunden wurden (z.B. doppelt vergebene Hotkeys, mehr als ein
    Help-/Undo-/Default-Button usw.). Dabei werden die Art des Fehlers und
    die Nummer des fehlerhaften Objekts ausgegeben.

    2. Highbyte des Objekt-Typs (s.a. STARTUP.RSC):
    -----------------------------------------------

        #define CHECKBOX        1   /* Check-Box */
        #define HEADER          2   /* öberschrift */
        #define RADIO           3   /* Radio-Button */
        #define UNDERLINE       4   /* Unterstrich */
        #define HOTKEY          5   /* Hotkey-Objekt */
        #define CHKHOTKEY       6   /* Check-Box mit Hotkey */
        #define RBHOTKEY        7   /* Radio-Button mit Hotkey */
        #define INDHOTKEY       8   /* Hotkey-Objekt einer Check-Box oder
                                       eines Radio-Buttons */
        #define FLYDIAL         9   /* Flugecke */
        #define TXTDEFAULT      10  /* Status des DEFAULT-Objekts ist von
                                       diesem Text-Objekt abhÑngig */
        #define USERFLY         11  /* beliebiges Flugobjekt */
        #define HELP_BTN        12  /* Help-Button */
        #define ATTR_TEXT       13  /* Text mit Attributen */
        #define CYCLE_BUTTON    14  /* Cycle-Button */
        #define ARROW_LEFT      15  /* Pfeil links */
        #define ARROW_RIGHT     16  /* Pfeil rechts */
        #define ARROW_UP        17  /* Pfeil hoch */
        #define ARROW_DOWN      18  /* Pfeil runter */
        #define UNDO_BTN        19  /* Undo-Button */

    Jedem Objekt kînnen die erweiterten Typen UNDO_BTN, HELP_BTN, HEADER
    und USERFLY zugeordnet werden. Bei ATTR_TEXT sowie TXTDEFAULT muû
    es sich um ein Text-Objekt (auch G_STRING), bei UNDERLINE sollte es
    sich um den Typ G_BOX handeln. Alle anderen erweiterten Typen
    sollten (mÅssen aber nicht) dem Typ G_BOXCHAR zugeordnet werden.

        #define G_UNMODAL   0x4000  /* unmodales Objekt */
        #define G_MODAL     0x8000  /* modales Objekt */

    ZusÑtzlich kînnen alle (!) Objekte durch Setzen von Bit 14 (G_UNMODAL)
    bzw. Bit 15 (G_MODAL) im Objekt-Typ (erweiterter Objekttyp mit 64 bzw.
    128 verodern) zu einem unmodalen oder modalen Objekt deklariert werden,
    welches nur in unmodalen bzw. modalen Dialogen erscheint.

    Nach dem Initialisieren der Resource durch die Library werden der
    Objekttyp und teilweise das obere Byte des Objektstatus der erweiterten
    Objekte verÑndert. Ebenso zeigt 'ob_spec' meistens auf den USERBLK des
    Objekts. Daher sollte man auf diese Variablen nicht mehr zugreifen, wenn
    man sich seiner Sache nicht sicher ist.
    (s.a. Quelltext der Funktion fix_objects())

    Weitere (Kombinations-) Mîglichkeiten s.a. Beispielprogramm sowie
    Startup-Resource (STARTUP.RSC).

 IV. Globale Variablen der Library:
====================================

    int _app;
        -> Programm wurde als Applikation (_app!=0) oder Accessory (_app==0)
           gestartet

    int ap_id:
        -> Applikationsidentifikation (RÅckgabewert von appl_init())
           oder negativer Wert, wenn AES-Initialisierung nicht erfolg-
           reich war

    int menu_id:
        -> Nummer des Eintrags im Accessory-MenÅ oder negativer Wert

    int grhandle:
        -> Handle der AES-Workstation (RÅckgabewert von graf_handle)

    int x_handle:
        -> Handle der Library-Workstation

    int gr_cw,gr_ch:
        -> Breite/Hîhe des System-Zeichensatzes (IBM) in Pixel

    int gr_bw,gr_bh:
        -> Breite/Hîhe eines Rechtecks, das jedes einzelne Zeichen
           des System-Zeichensatzes (IBM) vollstÑndig umgibt.

    int gr_sw,gr_sh:
        -> Breite/Hîhe des kleinen System-Zeichensatzes (SMALL) in Pixel

    int ibm_font,ibm_font_id;
        -> Hîhe des System-Zeichensatzes (IBM) in Punkt sowie Font-ID

    int small_font,small_font_id;
        -> Hîhe des kleinen System-Zeichensatzes (SMALL) in Punkt
           sowie Font-ID

    int fonts_loaded;
        -> GDOS-Fonts wurden geladen (werden die GDOS-Fonts von der
           Anwendung geladen, so muû diese Variable auf einen Wert un-
           gleich Null gesetzt oder die Fonts selbstÑndig entfernt werden)

    int max_w,max_h:
        -> Breite/Hîhe des Bildschirms in Pixel

    int planes, colors:
        -> Anzahl der Farbebenen sowie Farben

    MFDB *screen;
        -> Memory Form Definition Block des Bildschirms

    GRECT desk;
    VRECT clip;
        -> Ausmaûe des Desktop-Fensters als GRECT bzw. VRECT

    int aes_version:
        -> AES-Versionsnummer

    int magx:
        -> Versionsnummer von MagiC ab Version 2.00

    int winx:
        -> Versionsnummer von Winx ab Version 2.10

    int mint:
        -> MiNT-Versionsnummer

    int multi:
        -> AES-Multitasking-Betriebssystem vorhanden

    int redraw:
        -> Fenster-Dialog wird gerade neugezeichnet

    int AvServer;
        -> Applikations-ID des AV-Protokoll-Servers oder negativer Wert

    OBJECT *menu;
        -> Zeiger auf den Objektbaum der MenÅleiste oder NULL (diese
           Variable sollte von der Anwendung gesetzt werden bzw. wird von
           der Funktion 'menu_install' gesetzt)

    int menu_available;
        -> Anwendung darf eigene Drop-Down-MenÅleiste anmelden
           (menu_available!=0)

    OBJECT *iconified;
        -> Zeiger auf Objektbaum, der fÅr die Darstellung von ikonifizierten
           Fenstern benutzt wird (ansonsten weiûer Hintergrund des Fensters,
           falls Zeiger nicht gesetzt wurde)

 V. Funktionen, Strukturen und Konstanten der Library:
=======================================================

    1. Routinen zur Verwaltung des Cookie-Jars
       ---------------------------------------

        COOKIE-Struktur:
        ----------------
            typedef struct
            {
                long    cookie_id;      /* ID des Cookies */
                long    cookie_value;   /* Wert des Cookies */
            } COOKIE;

        void create_cookie(COOKIE *cookie,long id,long value);
            -> Cookie 'cookie' wird mit der Identifikation 'id' und
               dem Wert 'value' initialisiert

        boolean new_cookie(COOKIE *cookie);
            -> Cookie 'cookie' in Cookie-Jar einfÅgen (RÅckgabewert
               gleich FALSE, falls Cookie-Jar nicht existiert oder
               keine freien EintrÑge mehr vorhanden sind)

        boolean get_cookie(long id,long *value);
            -> Cookie mit der Identifikation 'id' im Cookie-Jar suchen
               und Wert gegebenenfalls in der Variable '*value' sichern
               (sofern value!=NULL)
            -> RÅckgabewert ungleich FALSE, wenn Cookie gefunden wurde

        void remove_cookie(long id);
            -> Cookie mit der Identifikation 'id' aus dem Cookie-Jar
               entfernen

        void move_cookiejar(long *new_cookie_jar,long size);
            -> neuen Cookie-Jar 'new_cookie_jar' mit Platz fÅr 'size'
               EintrÑge anlegen und alten Cookie-Jar gegebenfalls
               kopieren
            -> neuer Cookie-Jar muû mindestens so viele EintrÑge wie
               der alte Cookie-Jar haben

        long cookie_size(void);
            -> Anzahl der maximalen EintrÑge im Cookie-Jar ermitteln

    2. Routinen zur Verwaltung des Environments
       ----------------------------------------

        char *getenv(const char *entry);
            -> Variable 'entry' im Environment suchen und im Erfolgsfall
               Zeiger auf Wert der Variable zurÅckgeben (ansonsten NULL)

        int putenv(const char *entry);
            -> Zeichenkette 'entry' ins Environment einfÅgen
            -> RÅckgabewert ungleich Null im Erfolgsfall

    3. Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -----------------------------------------------------------

        void ob_dostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isstate(OBJECT *tree,int object,int bit);
            -> Bit 'bit' im Objektstatus des Objekts 'object' im Baum 'tree'
               testen
            -> Bit gesetzt -> RÅckgabewert ungleich Null

        void ob_doflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undoflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isflag(OBJECT *tree,int object,int bit);
            -> Bit 'bit' der Objektflags des Objekts 'object' im Baum 'tree'
               testen
            -> Bit gesetzt -> RÅckgabewert ungleich Null

        void ob_xywh(OBJECT *tree,int object,GRECT *rect);
            -> Ausmaûe und Koordinaten (relativ zur linken oberen Ecke
               des Dialogs) des Objekts 'object' im Baum 'tree'
               ermitteln und in der GRECT-Struktur 'rect' sichern

        char *ob_get_text(OBJECT *tree,int object,int clear);
            -> Zeiger auf den Text des Objekts 'object' im Baum 'tree'
               ermitteln und Text lîschen, sofern 'clear' ungleich Null
            -> RÅckgabewert gleich NULL, wenn es sich um kein Text-Objekt
               handelt

        void ob_set_text(OBJECT *tree,int object,char *text);
            -> Text des Objekts 'object' im Baum 'tree' auf 'text' setzen

        int ob_set_hotkey(OBJECT *tree,int object,char hotkey);
            -> Hotkey des Objekts 'object' im Baum 'tree' auf den
               Buchstaben 'hotkey' setzen (Hotkey-Unterstrich wird
               automatisch angepaût)
            -> RÅckgabewert ungleich FALSE -> Hotkey konnte gesetzt werden

        char ob_get_hotkey(OBJECT *tree,int object);
            -> Hotkey des Objekts 'object' im Baum 'tree' ermitteln
            -> RÅckgabewert gleich Null, wenn kein Hotkey gesetzt war

        int ob_draw_chg(DIAINFO *info,int object,GRECT *area,
                         int new_state,boolean top);
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen und gegebenenfalls Objektstatus Ñndern
               (new_state>=0, s. objc_change)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Ist der Dialog 'info' der oberste Dialog bzw. im obersten
               Fenster, so kann die Ausgabe durch Setzen des Parameters
               'top' auf einen Wert ungleich Null beschleunigt werden
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekt konnte nicht ausgegeben werden

        int ob_draw_list(DIAINFO *info,int *objects,GRECT *area);
            -> Liste von Objekten 'objects' (und untergeordnete Objekte)
               des Dialogs 'info' darstellen (Abbruch der Liste mit
               negativem Wert oder Null)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Diese Funktion ist schneller als die einzelne Ausgabe
               von mehreren Objekten Åber ob_draw_chg()
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekte konnten nicht ausgegeben werden

        void ob_draw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Dialog 'tree' zentrieren, Bildschirmbereich reservieren,
               eine sich îffnende Box von der Dialogmitte zu den
               Koordinaten (x,y,w,h) zeichnen (sofern Parameter x,y,w,h
               grîûer als Null sind) und Dialog darstellen

        void ob_undraw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Eine sich schlieûende Box von den Koordinaten (x,y,w,h) zur
               Dialogmitte zeichnen (sofern Parameter x,y,w,h grîûer als
               Null sind) und Bildschirmbereich freigeben

        int ob_radio(OBJECT *tree,int parent,int object)
            -> Radio-Buttons innerhalb des Åbergeordneten Objekts 'parent'
               im Baum 'tree' auf neues Objekt 'object' setzen bzw.
               aktuell gesetztes Objekt ermitteln (object<0)
            -> RÅckgabewert: Gesetztes Objekt

        int ob_get_parent(OBJECT *tree,int object);
            -> Elternobjekt des Objekts 'object' im Baum 'tree' ermitteln

        void redraw_iconified(int handle,OBJECT *icon,GRECT *area);
            -> Rechteck 'area' des ikonifizierten Fensters 'handle'
               neuzeichnen
            -> icon: Zeiger auf Objektbaum fÅr ikonifizierte Darstellung
               (meistens ein Icon mit weiûem Hintergrund)

    4. Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -------------------------------------------------------------

        void rc_grect_to_array(GRECT *rect,int *array);
            -> Reckteck 'rect' in Koordinaten-Feld 'array' wandeln

        void rc_array_to_grect(int *array,GRECT *rect);
            -> Koordianten-Feld 'array' in Rechteck 'rect' wandeln

        int rc_copy(GRECT *src,GRECT *dst);
            -> Rechteck 'src' nach Rechteck 'dst' kopieren
            -> RÅckgabewert ist immer Null

        int rc_equal(GRECT *rect1,GRECT *rect1);
            -> Testet die Rechtecke 'rect1' und 'rect2' auf Gleichheit
               (RÅckgabewert ungleich Null)

        int rc_intersect(GRECT *src,GRECT *dst);
            -> schneidet das Rechteck 'src' mit dem Rechteck 'dst'
               und gibt den gemeinsamen Bereich in 'dst' zurÅck
            -> RÅckgabewert gleich Null, sofern die Rechtecke keinen
               gemeinsamen Bereich besitzen

        int rc_inside(int x,int y,GRECT *rect);
            -> Testet, ob die Koordinaten (x,y) im Rechteck 'rect'
               liegen (RÅckgabewert ungleich Null)

        void rc_sc_copy(GRECT *src,int x,int y,int mode);
            -> Kopiert den Bildschirmbereich 'src' zu den Koordinaten
               (x,y) (Kopiermodus 'mode' s. vro_cpyfm)

        void rc_sc_clear(GRECT *rect);
            -> Lîscht den Bildschirmbereich 'rect'

        void rc_sc_invert(GRECT *rect);
            -> Invertiert den Bildschirmbereich 'rect'

    5. VDI-Attribut- und Clipping-Funktionen
       -------------------------------------

        void vsf_aespattern(int handle, int x, int y, int pattern)
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               Workstation 'handle' setzen

        void vs_attr(void);
            -> wurden die Attribute der internen VDI-Workstation x_handle
               nicht Åber Library-Funktionen verÑndert, so muû diese
               Funktion sofort danach aufgerufen werden, um dies der Library
               kenntlich zu machen

        void v_set_text(int font,int height,int color,int out[4])
            -> VDI-Text-Attribute der internen Workstation x_handle setzen:
               font:    Font-ID
               height:  Hîhe in Pixel (>0) oder in Punkt (<0)
               color:   Text-Farbe
               out:     Array fÅr RÅckgabewerte von vst_height/vst_point
                        oder NULL

        void v_set_mode(int mode);
            -> Grafikmodus der internen Workstation x_handle auf
               den Wert 'mode' (0-3) setzen

        void v_set_line(int color,int width);
            -> VDI-Linien-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color: Linien-Farbe
               width: Linien-Dicke

        void v_set_fill(int color,int interior,int style);
            -> VDI-FÅllmuster-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color:        FÅllmuster-Farbe
               vsf_interior: FÅllmuster-Typ (0-4)
               vsf_style:    FÅllmuster-Stil

        void v_aespattern(int x,int y,int pattern);
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               internen Workstation x_handle setzen

        void save_clipping(int *array);
            -> aktuellen Clipping-Bereich im Koordinaten-Feld 'array'
               sichern

        void restore_clipping(int *array);
            -> Clipping-Bereich auf Koordinaten-Feld 'array' setzen

        HINWEIS:
        Wird die interne VDI-Workstation benutzt, so muû sichergestellt
        sein, daû entweder Library-Funktionen benutzt oder die Attribute
        in ihren ursprÅnglichen Zustand zurÅckgesetzt werden.
        Ist dies nicht der Fall, muû sofort nach VerÑnderung der Attribute
        die Funktion vs_attr() aufgerufen werden. Allerdings darf auf keinen
        Fall der Clipping-Bereich verÑndert werden, d.h. er ist mit
        save_clipping()/restore_clipping wiederherzustellen.

    6. Erweiterte Scrap-Directory-Routinen
       -----------------------------------

        int scrp_init(char *path);
            -> Initialisiert das Scrap-Directory und setzt es gegebenenfalls
               auf den Pfad 'path' (path!=NULL)
            -> RÅckgabewert ungleich Null im Erfolgsfall

        void scrp_clear(int all);
            -> Alle Dateien (all!=0) oder nur die 'SCRAP.*'-Dateien
               im Scrap-Directory lîschen

        long scrp_length(void);
            -> Berechnung der LÑnge des Inhalts des Scrap-Directories

        int scrp_find(char *extension,char *filename);
            -> Scrap-Datei mit Erweiterung 'extension' im Scrap-
               Directory suchen
            -> String 'filename' enthÑlt im Erfolgsfall (RÅckgabewert
               ungleich Null) den kompletten Pfad der Datei

        void scrp_changed(int format,long best_ext);
            -> Clipboard-Inhalt wurde verÑndert (SC_CHANGED-Nachricht
               wird (per XAccBroadCast) an alle Applikationen gesendet)
            -> format: Bitmap des Dateiformats

            #define SCF_INDEF   0x0000  /* undefiniert */
            #define SCF_DBASE   0x0001  /* Datenbank */
            #define SCF_TEXT    0x0002  /* Text */
            #define SCF_VECTOR  0x0004  /* Vektor-Grafik */
            #define SCF_RASTER  0x0008  /* Raster-Grafik */
            #define SCF_SHEET   0x0010  /* Tabellen-Kalkulation */
            #define SCF_SOUND   0x0020  /* Sound */

            -> best_ext: 4 Zeichen (z.B. ".RTF") fÅr die "beste" der
                         abgespeicherten Dateien

    7. Erweiterte Grafik-Routinen
       --------------------------

        void graf_busy_mouse(void);
            -> Maus als rotierende Scheibe darstellen

        void graf_set_slider(SLINFO *slider,OBJECT *tree,int mode);
            -> Elemente des Sliders 'slider' im Baum 'tree'
               anhand der Werte der SLINFO-Struktur initialisieren und
               gegebenenfalls neuzeichnen
            -> mode: Bitmap der Initialisierung

            #define GRAF_SET_ARROWS     1
                -> Slider-Pfeile setzen
            #define GRAF_SET_SIZE_POS   2
                -> Grîûe/Position des Schiebers berechnen und setzen
            #define GRAF_SET            3
                -> wie GRAF_SET_ARROWS und GRAF_SET_SIZE_POS
            #define GRAF_DRAW_SLIDER    4
                -> Slider-Elemente zeichnen
            #define GRAF_DRAW           7
                -> wie GRAF_SET und GRAF_DRAW_SLIDER

        void graf_arrows(SLINFO *slider,OBJECT *tree,int draw);
            -> Pfeile des Sliders 'slider' im Baum 'tree' initialisieren
               und gegebenenfalls neuzeichnen (draw!=0)

        void graf_rt_slidebox(SLINFO *slider,int object,int double_click);
            -> Echtzeitslider auswerten und darstellen (diese Routine wird
               intern automatisch aufgerufen, wenn die SLINFO-Strukturen
               bei open_dialog() Åbergeben wurden)
            -> Parameter:
                slider: Zeiger auf SLINFO-Struktur des Sliders

                #define HOR_SLIDER      0   /* horizontaler Slider */
                #define VERT_SLIDER     1   /* vertikaler Slider */

                #define SL_STEP         0   /* Einzelschritt */
                #define SL_LINEAR       1   /* linear */
                #define SL_LOG          2   /* logarithmisch */
                #define SL_EXP          3   /* exponential */

                typedef struct
                {
                    /* Scan-Code des Ereignisses (Highbyte: Scan-Code,
                       Low-Byte: ASCII-Code oder Null) */
                    int     scan;

                    /* Sondertastenstatus */
                    int     state;

                    /* Slider-Kommando (s. Beschreibung des
                       Parameters 'object')
                    int     cmd;
                } SLKEY;

                typedef struct
                {
                    /* Zeiger auf DIAINFO-Struktur des Dialogs */
                    DIAINFO *sl_info;

                    /* Nummer des Elternobjekts */
                    int     sl_parent;

                    /* Objektnummer des Schiebers */
                    int     sl_slider;

                    /* Objektnummern der Pfeile oder negative Werte */
                    int     sl_dec,sl_inc;

                    /* Position, SeitenlÑnge und Maximalwert des Schiebers */
                    int     sl_pos,sl_page,sl_max;

                    /* Richtung des Sliders: */
                    char    sl_vh;      /* HOR_SLIDER,VERT_SLIDER  */

                    /* Wiederholungs-Modus der Pfeile */
                    char    sl_mode;    /* SL_STEP,SL_LINEAR,SL_LOG,SL_EXP */

                    /* Verzîgerungsdauer in Milisekunden vor und wÑhrend der
                       Wiederholung */
                    int     sl_delay,sl_speed;

                    /* Zeiger auf Routine (oder NULL), welche nach jeder
                       VerÑnderung des Sliderwerts 'sl_pos' aufgerufen wird */
                    void    (*sl_do)(OBJECT *obj,int pos,int prev,
                                     int max_pos,int top);
                    /* obj:     Zeiger auf das Slider-Objekt
                       pos:     aktuelle Position des Schiebers
                       prev:    vorherige Position des Schiebers
                       max_pos: maximale Position des Schiebers
                       top:     Dialog ist im Vordergrund */

                    /* Zeiger auf Feld mit Slider-Hotkeys oder NULL (wird
                       nur ausgewertet, wenn die SLINFO-Struktur bei
                       open_dialog() Åbergeben wurde) */
                    SLKEY   *sl_keys;

                    /* Anzahl der Hotkeys im Feld 'sl_keys' */
                    int     sl_keys_cnt;
                } SLINFO;

               object: angeklicktes Objekt oder eines der folgenden
                       Kommandos:

                        #define SL_UP       -1  /* Zeile hoch */
                        #define SL_DOWN     -2  /* Zeile runter */
                        #define SL_PG_UP    -3  /* Seite hoch */
                        #define SL_PG_DN    -4  /* Seite runter */
                        #define SL_START    -5  /* Slider-Anfang */
                        #define SL_END      -6  /* Slider-Ende */

               double_click: Objekt wurde per Doppelklick angeklickt

        int graf_rt_rubberbox(int s_x,int s_y,GRECT *rect,int *w,int *h,
                              void(*box_do)(int *array));
            -> Echtzeitgummiband innerhalb des Rechtecks 'rect' mit den
               Start-Koordinaten (s_x,s_y) auswerten und darstellen
            -> Im Erfolgsfall (RÅckgabewert!=0) enthalten die Variablen
               '*w' und '*h' die Breite und Hîhe des Rechtecks
            -> 'box_do' enthÑlt einen Zeiger auf eine Funktion (oder NULL),
               welche nach jeder VerÑnderung des Rechtecks mit einem
               Zeiger auf das Koordinaten-Array 'array' des Rechtecks
               aufgerufen wird

    8. MenÅ-Funktionen
       ---------------

        int menu_install(OBJECT *menu,int show);
            -> MenÅ-Leiste 'menu' darstellen (show!=0) oder lîschen
               (show==0). Diese Funktion berÅcksichtigt, ob gegebenenfalls
               auch ein Accessory eine MenÅ-Leiste besitzen darf und ini-
               tialisiert die MenÅ-Punkte 'Fenster wechseln' und 'Fenster
               schlieûen'
            -> RÅckgabewert wie bei 'menu_bar'

        void menu_enable(OBJECT *menu,boolean enable,boolean show);
            -> MenÅ-Leiste 'menu' aktivieren (enable==TRUE) bzw. de-
               aktivieren (enable==FALSE) und gegebenenfalls neuzeichnen
               (show!=0). Wird die MenÅleiste nicht neugezeichnet (show==0),
               so muû dies von der Anwendung nachgeholt werden, da diese
               Funktion die MenÅleiste in diesem Fall deaktiviert!

        boolean menu_dropped(OBJECT *menu);
            -> Testen, ob ein Pull-Down-MenÅ des MenÅs 'menu' herunter-
               geklappt ist

    9. Dialog-Optionen und -optik setzen
       ---------------------------------

        void dial_colors(int dialog_pattern,int dialog_color,
                         int cycle_button,int hotkey,int check_box,
                         int radio_button,int arrow)
            -> Dialog-Optik setzen:
               dialog_pattern: Hintergrundmuster des Dialogs (0-7)
               dialog_color:   Hintergrundfarbe des Dialogs (0-15)
               cycle_button:   Cycle-Button-Farbe (0-15)
               check_box:      Checkbox-Farbe (0-15)
               radio_button:   Radio-Button-Farbe (0-15)
               arrow:          Slider-Arrow-Farbe (0-15)

        void dial_options(boolean round,boolean title_frame,
                          boolean title_small,boolean niceline,
                          boolean return_default,boolean background,
                          boolean nonselectable,boolean always_keys,
                          boolean toMouse);
            -> verschiedene Optionen setzen:
               round:          Dialogpositionen auf Bytegrenzen (aus Ge-
                               schwindigkeitsgrÅnden) runden
               title_frame:    öberschriften umrahmen
               title_small:    Kleine Schrift (SMALL) fÅr öberschriften
               niceline:       Niceline fÅr Trennstriche in MenÅs/Popups
               return_default: TRUE:  Return selektiert Default-Objekt
                               FALSE: Return springt zum nÑchsten Eingabefeld
                               FAIL:  Return selektiert Default-Objekt beim
                               letzten Eingabefeld (ansonsten wie FALSE)
               background:     Fensterdialoge (sowie mit open_window() ge-
                               îffnete Fenster) kînnen im Hintergrund
                               wie normale Dialoge bedient werden
               nonselectable:  Fliegende Dialoge fliegen auch beim Anklicken
                               von nicht-selektierbaren/editierbaren
                               Objekten
               always_keys:    TastendrÅcke werden auch bei fliegenden
                               oder modalen Dialogen an die Anwendung
                               weitergegeben
               toMouse:        TastendrÅcke an Fensterdialog unter Maus-
                               zeiger senden, sofern oberster Dialog
                               weder modal noch fliegend ist
                               -> zusammen mit 'background' ist somit eine
                                  vollstÑndige Bedienung von Hintergrund-
                                  dialogen mîglich

        void title_options(boolean mode,int color,int size);
            -> Unterstrichenen Text einstellen:
               mode:  Strich wird Åber die ganze Breite des Dialogs (TRUE)
                      oder Åber die im Resource vorgebenen Koordinaten
                      (FALSE) gezeichnet
               color: Strichfarbe (0-15)
               size:  Strickdicke in Pixel oder Null, wenn der Wert aus
                      der Resource-Struktur entnommen werden soll

        BUTTON-Struktur:
        ----------------
            typedef struct
            {
                /* Zeiger auf monochrome 16x16-Bitmap (32 Bytes) des
                   selektierten und des normalen Buttons im gerÑte-
                   abhÑngigen Format */
                int *but_on,*but_off;
            } BUTTON;

        void radio_image(int index,BUTTON *radiobutton);
            -> vordefinierte Images (index: 0-7) oder benutzerdefinierten
               Button 'radiobutton' (radiobutton!=NULL) fÅr Radio-Buttons
               auswÑhlen

        void check_image(int index,BUTTON *checkbox);
            -> vordefinierte Images (index: 0-5) oder benutzerdefinierten
               Button 'checkbox' (checkbox!=NULL) fÅr Check-Box auswÑhlen

        void cycle_image(int index,BUTTON *cyclebutton);
            -> vordefinierte Images (index: 0-1) oder benutzerdefinierten
               Button 'cyclebutton' (cyclebutton!=NULL) fÅr Cycle-Buttons
               auswÑhlen

        void arrow_image(int index,BUTTON *down,BUTTON *up,BUTTON *left,
                         BUTTON *right);
            -> vordefinierte Images (index: 0-2) oder benutzerdefinierte
               Buttons 'down', 'up' 'left', 'right' (sofern ungleich NULL)
               fÅr Slider-Pfeile auswÑhlen

    10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        --------------------------------------------------------

        boolean open_work(int *handle,int *work_out);
            -> virtuelle Bildschirm-Workstation îffnen
            -> RÅckgabewert ungleich FALSE, wenn Workstation geîffnet
               werden konnte
            -> handle:   VDI-Handle im Erfolgsfall
               work_out: work_out[57]-Feld

        void close_work(int handle);
            -> virtuelle Bildschirm-Workstation 'handle' schlieûen

        boolean init_gem(char *m_entry,char *x_name,char *a_name,
                         int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library
                - Anmeldung beim AES (appl_init)
                - Xacc-2/AV-Protokolle initialisieren
                - interne VDI-Workstation îffnen
                - Scrap-Directory initialisieren
                - globale Variablen sowie interne Strukturen initialisieren
            -> Parameter:
                m_entry:   Eintrag im Accessory-MenÅ (als Accessory oder
                           unter MTOS) oder NULL
                x_name:    (erweiterter) XAcc-2-Programmname
                a_name:    AV-Programmname (8 Zeichen wie bei appl_find)

                av_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht AV_PROTOKOLL

                #define MSG_SETSTATUS   0x001 /* VA_SETSTATUS */
                #define MSG_START       0x002 /* VA_START */

                va_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht VA_PROTOSTATUS (AV_SENDKEY, AV_EXIT
                           und AV_ACCWINDOPEN sowie AV_ACCWINDCLOSED werden
                           von der Library immer angegeben!)

                #define MSG_SENDKEY     0x001 /* AV_SENDKEY */
                #define MSG_ASKFILEFONT 0x002 /* AV_ASKFILEFONT */
                #define MSG_ASKCONFONT  0x004 /* AV_ASKCONFONT,
                                                 AV_OPENCONSOLE */
                #define MSG_ASKOBJECT   0x008 /* AV_ASKOBJECT */
                #define MSG_OPENWIND    0x010 /* AV_OPENWIND */
                #define MSG_STARTPROG   0x020 /* AV_STARTPROG */
                #define MSG_ACCWINDOPEN 0x040 /* AV_ACCWINDOPEN,
                                                 AV_ACCWINDCLOSED */
                #define MSG_STATUS      0x080 /* AV_STATUS, AV_GETSTATUS */
                #define MSG_COPY_DRAGGED 0x100 /* AV_COPY_DRAGGED */
                #define MSG_PATH_UPDATE 0x200 /* AV_PATH_UPDATE,
                                                 AV_WHAT_IZIT,
                                                 AV_DRAG_ON_WINDOW */
                #define MSG_EXIT        0x400 /* AV_EXIT */

                xacc_msgs: Bitmap der unterstÅtzten ACC-Nachrichten (alle
                           anderen ACC-Nachrichten werden automatisch
                           ausgewertet)

                #define X_MSG_TEXT      0x001 /* ACC_TEXT */
                #define X_MSG_META      0x002 /* ACC_META */
                #define X_MSG_IMG       0x004 /* ACC_IMG */

            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                       schlug fehl

        void exit_gem(void);
            -> Deinitialisierung der Library:
                - Dialoge schlieûen
                - Beenden der XAcc-2-/AV-Protokolle
                - geladene GDOS-Fonts wieder entfernen
                - interne VDI-Workstation schlieûen
                - Abmeldung beim AES (appl_exit)

        boolean open_rsc((char *rscname,char *m_entry,char *x_name,char *a_name,int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library (s. init_gem()) sowie Resource
               'rscname' laden
            -> Parameter: s. init_gem()
            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                FAIL:  Resource-File konnte nicht geladen werden (Speicher-
                       mangel oder falscher Pfad)

        void close_rsc(void);
            -> Resource-Speicher freigeben und Library deinitialisieren
               (s. exit_gem())

    11. Resource- und Objekt-Initialisierung
        ------------------------------------

            void fix_objects(OBJECT *tree,int scaling,
                             int orig_cw,int orig_ch);
                -> erweiterte Objekte des Baums 'tree' initialisieren sowie
                   gegebenenfalls Images/Icons skalieren (scale_image)
                   und ins GerÑteformat konvertieren (trans_image)

                -> Parameter:
                   orig_cw: Breite des Entwurfsfonts in Pixel (meistens 8)
                            oder negativer Wert fÅr rsrc_obfix()-kompatible
                            Anpassung
                   orig_ch: Hîhe des Entwurfsfonts in Pixel (meistens 8 oder
                            16) oder negativer Wert fÅr rsrc_obfix()-kompa-
                            tible Anpassung
                   scaling: Bitmap des Skalierungs-Modus

                    #define NO_SCALING      0   /* keine Skalierung */
                    #define SCALING         1   /* Skalierung */
                    #define TEST_SCALING    2   /* Testen, ob Skalierung not-
                                                   wendig ist */
                    #define DARK_SCALING    4   /* dunkle Skalierung */

                    Beispiele:
                    /* Nie skalieren */
                        images = NO_SCALING;

                    /* Immer skalieren */
                        images = SCALING;

                    /* Bei Bedarf (System-Font kleiner als Entwurfsfont)
                       skalieren */
                        images = SCALING|TEST_SCALING;

                    /* Bei Bedarf dunkel skalieren */
                        images = SCALING|TEST_SCALING|DARK_SCALING;

        void scale_image(OBJECT *object,int scaling,
                         int orig_cw, int orig_ch);
            -> Image/Icon 'object' skalieren
            -> Parameter s. fix_objects()

        void trans_image(OBJECT *object);
            -> Image/Icon 'object' in GerÑteformat konvertieren

        void rsrc_calc(OBJECT *tree,int scaling,int orig_cw,int orig_ch);
            -> Koordinaten und Ausmaûe der Objekte des Baums 'tree' an
               Ausmaûe des System-Fonts unter Beachtung der Ausmaûe des
               Fonts, mit welchem die Resource-Datei erstellt wurde, an-
               passen und anschlieûend erweiterte Objekte initialisieren
               (s. fix_objects())
            -> Parameter s. fix_objects()

        void rsrc_init(int n_tree,int n_obs,int n_frstr,int n_frimg,
                       int scaling,char **rs_strings,long *rs_frstr,
                       BITBLK *rs_bitblk,long *rs_frimg,
                       ICONBLK *rs_iconblk,TEDINFO *rs_tedinfo,
                       OBJECT *rs_object,OBJECT **rs_trindex,
                       RS_IMDOPE *rs_imdope,int orig_cw,int orig_ch)
            -> in Quelltext eingebundene Resource-Datei (*.RSH)
               initialisieren

            -> Parameter:
               n_tree:     Anzahl der BÑume (NUM_TREE)
               n_obs:      Anzahl der Objekte (NUM_OBS)
               n_frstr:    Anzahl der freien Strings (NUM_FRSTR)
               n_frimg:    Anzahl der freien Images (NUM_FRIMG)

               rs_strings: String-Array (Pointer zeigen auf alle
                           Zeichenketten der Resource-Datei)
               rs_frstr:   Index-Array (Indizes der freien Strings
                           fÅr das rs_strings-Array)
               rs_bitblk:  BITBLK-Array (enthÑlt alle Bit-Blîcke)
               rs_frimg:   Index-Array (Indizes der freien Images
                           fÅr das rs_bitblk-Array)
               rs_iconblk: ICONBLK-Array (enthÑlt alle icons)
               rs_tedinfo: TEDINFO-Array (enthÑlt alle TEDINFO-Strukturen)
               rs_object:  OBJECT-Array (enthÑlt alle Objekte)
               rs_trindex: Index-Array (Indizes der ObjektbÑume
                           fÅr das rs_object-Array)
               rs_imdope:  RS_IMDOPE-Array

                RS_IMDOPE-Struktur:
                -------------------

                typedef struct
                {
                    int dummy;
                    /* Zeiger auf Bitmap (Image) */
                    int *image;
                } RS_IMDOPE;

               scaling: s. fix_objects()
               orig_cw: s. fix_objects()
               orig_ch: s. fix_objects()

               HINWEIS:
               An allen Stellen der Resource, an denen normalerweise
               Pointer vorkommen, muû der Element-Index (Long-Wert) des
               entsprechenden Arrays stehen. Die Image-Zeiger der
               Strukturen BITBLK und ICONBLK enthalten den Index des
               zugehîrigen RS_IMDOPE-Elements.

    12. Ereignis-Auswertung
        -------------------

        XEVENT-Struktur:
        ----------------

        typedef struct
        {
            /* PARAMETER: */

            /* Bitmap der gewÅnschten Events:
               MU_KEYBD:     Tastatur-Ereignis
               MU_MESAG:     Nachrichten-Ereignis
               MU_TIMER1/2:  Timer-Ereignis 1/2
               MU_BUTTON1/2: Button-Ereignis 1/2
               MU_M1-4:      Rechteck-Ereignis 1-4 */
            int ev_mflags;

            /* Parameter des 1. Button-Events MU_BUTTON1 */
            int ev_mb1clicks,ev_mb1mask,ev_mb1state

            /* Parameter des 1. Mouse-Event-Rechtecks MU_M1 */
            int ev_mm1flags,ev_mm1x,ev_mm1y,ev_mm1width,ev_mm1height,

            /* Parameter des 2. Mouse-Event-Rechtecks MU_M2 */
            int ev_mm2flags,ev_mm2x,ev_mm2y,ev_mm2width,ev_mm2height;

            /* Parameter des 1. Timer-Events MU_TIMER1 */
            unsigned int ev_mtlocount,ev_mthicount;

            /* RöCKGABEWERTE: */

            /* eingetretene Ereignisse */
            int ev_mwich;

            /* Position des Mauszeigers sowie Zustand der Maustasten
               beim Auftreten des Events */
            int ev_mmox,ev_mmoy,ev_mmobutton;

            /* Zustand der Sondertasten beim Auftreten des Events */
            int ev_mmokstate;

            /* Scancode der gedrÅckten Taste (High-Byte: Scan-Code,
               Low-Byte: ASCII-Code oder Null) */
            int ev_mkreturn;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON1) */
            int ev_mb1return;

            /* Nachrichten-Puffer */
            int ev_mmgpbuf[8];

            /* erweiterte PARAMETER: */
            /* Parameter des 2. Button-Events MU_BUTTON2 */
            int ev_mb2clicks,ev_mb2mask,ev_mb2state;

            /* Parameter des 3. Mouse-Event-Rechtecks MU_M3 */
            int ev_mm3flags,ev_mm3x,ev_mm3y,ev_mm3width,ev_mm3height;

            /* Parameter des 4. Mouse-Event-Rechtecks MU_M4 */
            int ev_mm4flags,ev_mm4x,ev_mm4y,ev_mm4width,ev_mm4height;

            /* Parameter des 2. Timer-Events MU_TIMER2 */
            unsigned int ev_mt2locount,ev_mt2hicount;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events MU_TIMER1
               oder Null fÅr aktuelle System-Zeit */
            long ev_mt1last;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events MU_TIMER2
               oder Null  fÅr aktuelle System-Zeit */
            long ev_m2last;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON2) */
            int ev_mb2return;
        } XEVENT;

        KompatibilitÑts-Makros fÅr EVENT-Struktur und AES-Event-Routinen:
        -----------------------------------------------------------------

            #define ev_mbclicks     ev_mb1clicks
            #define ev_mbmask       ev_mb1mask
            #define ev_bmask        ev_mb1mask
            #define ev_mbstate      ev_mb1state
            #define ev_mbreturn     ev_mb1return

            #define ev_mtlocount    ev_mt1locount
            #define ev_mthicount    ev_mt1hicount
            #define ev_mtlast       ev_mt1last

            #define MU_TIMER1       MU_TIMER
            #define MU_BUTTON1      MU_BUTTON

        int Event_Multi(XEVENT *event);
            -> Auf Ereignis 'event' warten (benîtigte Parameter der
               Struktur mÅssen initialisiert sein, sofern dies nicht
               die Initialisierungs-Routine von Event_Handler(), s.u.,
               Åbernimmt). Die Library wertet dabei selbstÑndig Nachrichten
               der XAcc-2- und AV-Protokolle aus und wandelt diese ge-
               gebenenfalls um. Ebenso werden Ereignisse, welche Fenster-
               dialoge bzw. allgemein die Library betreffen, ausgewertet.

               WICHTIG:
               Es werden nur Ereignisse zurÅckgeliefert, welche nicht
               von der Library ausgewertet wurden. Allerdings werden evtl.
               Ereignisse, welche bereits von dem durch die Funktion
               Event_Handler() definierten Handler ausgewertet wurden, zu-
               rÅckgeliefert!
               Setzt man die Variable 'ev_mflags' auf Null oder Åbergibt man
               den Wert NULL fÅr den Parameter 'event', so werden KEINE
               Events zurÅckgeliefert! Alle Ereignisse mÅssen dann vom
               Handler initialisiert und ausgewertet werden!

            -> RÅckgabewert: Bitmap der eingetretenen Ereignisse

        void Event_Timer(int locount,int hicount)
            -> Wartet bis die durch lo_count und hi_count in Millisekunden
               vorgebene Zeit verstrichen ist. Dabei werden allerdings
               noch Nachrichten durch die Library sowie Ereignisse durch den
               Handler ausgewertet!

        void Event_Handler(int (*init)(XEVENT *,int,int),
                           int (*handler)(XEVENT *));
            -> Routinen zur Ereignisauswertung festlegen, wobei diese Rou-
               tinen diejenigen Ereignisse auswerten, welche nicht auto-
               matisch von der Library bearbeitet wurden. Durch öbergabe
               von NULL kînnen bereits angemeldete Funktionen einzeln wieder
               abgemeldet werden. Ebenso kann man die Routinen beliebig
               oft neu setzen, z.B. fÅr eine lokale Ereignisauswertung.

            -> Parameter:
                int (*init)(XEVENT *event,int available):
                    -> Routine, welche u.a. von X_Form_Do bei jeder
                       Initialisierung eines Dialogs aufgerufen wird. Die
                       Routine gibt eine Bitmap der gewÅnschten Events zu-
                       rÅck und initialisiert gegebenenfalls Variablen der
                       Åbergebenen XEVENT-Struktur 'event'.
                       Angefordert werden kînnen nur die Events, welche in
                       der Bitmap 'available' gesetzt sind.

                int (*handler)(XEVENT *event):
                    -> Routine, welche u.a. von X_Form_Do aufgerufen wird
                       und die Ereignisse, welche von der Library nicht ver-
                       arbeitet wurden, auswertet. ZurÅckgegeben wird eine
                       Bitmap der ausgewerteten Ereignisse. V.a. bei Tasta-
                       tur-Ereignissen, welche nicht ausgewertet wurden,
                       sollte MU_KEYBD nicht gesetzt sein, damit die Library
                       gegebenenfalls den Tastendruck per Xacc-2- oder AV-
                       -Protokoll weiterleiten kann. Dies kann man natÅrlich
                       unterbinden, indem man stÑndig alle Ereignisse zu-
                       rÅckgibt.

                       WICHTIG:
                       Diese Routine darf keine Variablen der XEVENT-Struktur
                       (abgesehen von den Ausgabewerten) verÑndern!


                Library-spezifische Nachrichten (MU_MESAG):
                -------------------------------------------

                    -> Eingabefeld wurde verÑndert:
                        msg[0]        = OBJC_EDITED
                        msg[3]        = Nummer des aktuellen Eingabeobjekts
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

                    -> selektierbares Objekt (kein EXIT-/TOUCHEXIT-Objekt)
                       wurde verÑndert:
                        msg[0]        = OBJC_CHANGED
                        msg[3]        = Nummer des Objekts
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       angemeldet
                        msg[0]        = XACC_AV_INIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur

                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       abgemeldet
                        msg[0]        = XACC_AV_EXIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur (Struktur
                                        ist nach vollstÑndiger Abmeldung
                                        nicht mehr gÅltig
                                        (Struktur-Variable id<0)

                    -> Status eines Fenster hat sich geÑndert (z.B. wurde
                       das Fenster ikonifiziert/deikonifiziert). U.a. kann
                       sich auch das Fenster-Handle Ñndern!
                        msg[0]        = WIN_CHANGED
                        msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                                        Fensters oder NULL, falls alle
                                        Fenster betroffen sind

    13. Dialog-Funktionen
        -----------------

        DIAINFO-Struktur:
        -----------------

        typedef struct
        {
            /* Dialog-Typ
                CLOSED      -> geschlossen
                OPENED      -> normaler Dialog
                FLYING      -> fliegender Dialog
                WINDOW      -> Fenster-Dialog
                WIN_MODAL   -> modaler Fenster-Dialog */
            DIALMODE di_flag;

            /* Zeiger auf Objektbaum */
            OBJECT   *di_tree;

            /* Zeiger auf Fenster-Struktur */
            WIN      *di_win;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } DIAINFO;

        boolean open_dialog(OBJECT *tree,DIAINFO *info,char *title,
                boolean center, boolean grow_box,int dialog_mode,int edit,
                SLINFO **slider);
            -> Dialog îffnen (RÅckgabewert ungleich Null, wenn Dialog ge-
               îffnet wurde)
            -> Parameter:
                tree:
                    -> Zeiger auf Objektbaum
                info:
                    -> Zeiger auf DIAINFO-Struktur (wird von dieser
                       Funktion initialisiert)
                title:
                    -> Zeiger auf Fenster-Titel fÅr Fensterdialoge
                center:
                    TRUE  -> Dialog um Mauszeiger zentrieren
                    FALSE -> Dialog in Bildschirmmitte zentrieren
                             (sichtbarer Ausschnitt des Bildschirms
                             wird beachtet)
                    FAIL  -> Dialog an letzter Position îffnen (beim
                             ersten ôffnen analog wie FALSE)
                grow_box:
                    -> sich vergrîûernder Rechtecke zeichnen
                dialog_mode:
                    -> Bitmap des Dialogtyps:
                        /* fliegender Dialog */
                        #define FLY_DIAL        1

                        /* Fenster-Dialog */
                        #define WIN_DIAL        2

                        /* Fenster-Dialog, sofern Fenster geîffnet werden
                           kann, ansonsten fliegender Dialog
                        #define AUTO_DIAL       (FLY_DIAL|WIN_DIAL)

                        /* modaler Fensterdialog */
                        #define MODAL           4

                        /* Fenster-Dialog mit Rahmen */
                        #define FRAME           8

                        /* Fenster-Dialog kann nicht ikonifiziert werden */
                        #define NO_ICONIFY      16

                edit:
                    -> Objektnummer des Eingabefeldes, in welchem sich
                       der Cursor befinden soll (oder negativer Wert)

                slider:
                    -> Zeiger auf Liste mit Adressen der SLINFO-Strukturen
                       (letzter Listen-Eintrag gleich NULL) der Slider des
                       Dialogs oder NULL, wenn die Slider nicht automatisch
                       verwaltet werden sollen

        void close_dialog(DIAINFO *dialog,boolean shrink_box);
            -> Dialog 'dialog' schlieûen und gegebenenfalls sich
               verkleinernde Rechtecke zeichnen (shrink_box!=0)

        int X_Form_Do(DIAINFO **dialog)
            -> Bearbeitung der geîffneten Dialoge
            -> ZurÅckgegeben wird die Nummer des angewÑhlten Exit-Objekts
               (bei Doppelklick ist Bit 15 (0x8000) gesetzt) oder die Werte
               W_ABANDON -> Abbruch der Dialogbearbeitung, alle Dialoge
                            wurden geschlossen (z.B. durch AC_CLOSE)
               W_CLOSED  -> Fensterdialog wurde geschlossen
            -> '*dialog' enthÑlt (sofern ungleich NULL) einen Zeiger auf
               die DIAINFO-Struktur des aktuellen Dialogs

        int xdialog(OBJECT *tree,char *title,boolean center,
                    boolean grow_box,int dialog_mode);
            -> komplette Dialogbearbeitung (Dialog îffnen, bearbeiten und
               schlieûen)
            -> Parameter und RÅckgabewerte s. open_dialog() sowie
               X_Form_Do()

        int xalert(int default,int undo,int icon,BITBLK *user_icon,
                   int center,int width,
                   char *title,char *text,char *buttons)
            -> erweiterte Alertbox darstellen (Index des ausgewÑhlten
                          Buttons wird zurÅckgeliefert)
            -> default:   Index des DEFAULT-Buttons oder negativer Wert
               undo:      Index des UNDO-Buttons oder negativer Wert
               icon:      Nummer des Icons oder negativer Wert

                #define X_ICN_NONE      -1 /* kein Icon */
                #define X_ICN_MAX       17 /* maximale Icon-Nummer */

                #define X_ICN_STOP      7  /* Stop-Schild (Hinweis) */
                #define X_ICN_QUESTION  10 /* Fragezeichen (Nachfrage) */
                #define X_ICN_ALERT     11 /* Ausrufezeichen (Warnung) */

                #define X_ICN_DISC_ERR  5  /* Disketten-I/O-Fehler */
                #define X_ICN_ERROR     6  /* Bomben-Fehler */
                #define X_ICN_FLOPPY    8  /* Disketten-Station */
                #define X_ICN_DISC      9  /* Diskette */
                #define X_ICN_INFO      13 /* Informations-Zeichen */
                #define X_ICN_PRT_ERR   15 /* Drucker-I/O-Fehler */

               user_icon: Zeiger auf benutzerdefiniertes Icon oder NULL
               center:    Ausrichtung der Buttons

                #define BUTTONS_CENTERED    0 /* zentriert */
                #define BUTTONS_LEFT        1 /* linksbÅndig */
                #define BUTTONS_RIGHT       2 /* rechtsbÅndig */

               width:     einheitliche Breite der Buttons (width!=0)
               text:      Zeiger auf Text (maximale 10 Zeilen getrennt
                          durch '|')
               buttons:   Button-Text (maximal 6 Buttons getrennt durch
                          '|', Hotkeymarkierung durch '[')
               title:     Zeiger auf Fenster-Titel fÅr Fensterdialoge

        char ascii_box(char *title)
            -> Sonderzeicheneingabebox îffnen (Parameter s. open_dialog())
            -> RÅckgabewert: ausgewÑhltes Zeichen

    14. Fenster-Funktionen
        ------------------

        WIN-Struktur:
        -------------

        typedef struct
        {
             /* Handle des Fensters (handle>0, falls Fenster geîffnet) */
             int handle;

             /* Bitmap der Fensterelemente (s. wind_create) */
             int gadgets;

             /* Bitmap des Fenster-Status */
             int iconified;

                 #define ICONIFIED  1  /* Fenster ikonifiziert (MTOS) */
                 #define SHADE      2  /* Fenster eingeklappt (Winx 2.3) */
                 #define ICFS       4  /* Fenster ikonifiziert (ICFS) */

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } WIN;

        WIN *open_window(char *title,char *info,int gadgets,int box,
                        int x,int y,int w,int h)
            -> Fenster mit den Elementen 'gadgets' an den Koordinaten (x,y)
               mit den Ausmaûen (w,h) îffnen. Das Fenster wird bei einem
               evtl. vorhandenen AV-Server angemeldet (AV_ACCWINDOPEN)
               und evtl. die Hintergrundbedienung aktiviert.
            -> Parameter:
               title: Zeiger auf Fenstertitel oder NULL
               info:  Zeiger auf Infozeile oder NULL
               box:   sich vergrîûernde Rechtecke zeichnen (box!=0)
            -> RÅckgabewert: Zeiger auf WIN-Struktur oder NULL

        int close_window(WIN *window,int box)
            -> Fenster mit der Struktur 'window' schlieûen und gegebenenfalls
               (box!=0) sich verkleinernde Rechtecke zeichnen. Auûerdem wird
               das Fenster bei einem evtl. vorhandenem AV-Server abgemeldet
               (AV_ACCWINDCLOSED).
            -> RÅckgabewert gleich Null, wenn ein Fehler auftrat

        WIN *get_window(int handle)
            -> WIN-Struktur zum Fenster 'handle' ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

        void CycleCloseWindows(char cycle_hot,char close_hot,int cycle_menu,
                               int close_menu)
            -> Hotkeys (+Control-Taste) und MenÅpunkte fÅr die Funktionen
               'Fenster wechseln' sowie 'Fenster schlieûen' definieren.
               Beachtet werden alle Fensterdialoge sowie Fenster, die mit
               den Funktionen open_window() und close_window() geîffnet bzw.
               geschlossen werden. Der MenÅtitel wird nur dann deselektiert,
               wenn der Zeiger auf die MenÅleiste 'menu' gesetzt ist!
            -> Parameter:
                cycle_hot,close_hot:
                  -> Hotkey-Buchstaben oder Null
                cycle_menu,close_menu:
                  -> Objektnummern der Pulldown-MenÅeintrÑge oder neg. Werte

    15. Popup-Funktion
        --------------

        POPUP-Struktur:
        ---------------
            typedef struct
            {
                /* Zeiger auf DIAINFO-Struktur des Parent-Dialogs
                   oder NULL */
                DIAINFO *p_info;

                /* Zeiger auf Objektbaum des Popups */
                OBJECT  *p_menu;

                /* Objektnummer des Info-Objekts (meistens Text links vom
                   Popup-Button) oder negativer Wert */
                int     p_parent;

                /* Objektnummer des Popup-Buttons oder negativer Wert */
                int     p_button;

                /* Objektnummer des Cycle-Buttons (dabei muû es sich nicht
                   um den erweiterten Typ CYCLE_BUTTON handeln) oder
                   negativer Wert */
                int     p_cycle;

                /* Beim Erreichen des ersten/letzten Eintrags mit den Cur-
                   sor-Tasten Hoch/Runter wird zum letzten/ersten Eintrag
                   gesprungen */
                boolean p_wrap;

                /* Der Text des Popup-Buttons wird automatisch auf den
                   Wert des aktuellen Eintrags gesetzt und nach dem Ende
                   der Popup-Bearbeitung neugezeichnet */
                boolean p_set;
            } POPUP;

        int Popup(POPUP *popup,int mode,int center,int x,int y,
                  int *index,int select)
            -> Popup 'popup' îffnen, bearbeiten und wieder schlieûen
            -> mode: Popup-Modus

                #define POPUP_BTN   0   /* Popup-Button wurde angeklickt */
                #define POPUP_CYCLE 1   /* Cycle-Button wurde angeklickt */
                #define POPUP_CHECK 2   /* HÑkchen vor aktuellem Eintrag */

                #define POPUP_BTN_CHK   (POPUP_BTN|POPUP_CHECK)
                #define POPUP_CYCLE_CHK (POPUP_CYCLE|POPUP_CHECK)
                #define POPUP_RADIO     POPUP_BTN_CHK
                #define POPUP_SELECT    POPUP_BTN

            -> center: Position des Popups

                #define CENTER    1 /* in Bildschirm zentrieren */
                #define MOUSEPOS  2 /* um Mauszeiger zentrieren */
                #define XPOS      3 /* X-Koordinate x, vertikal
                                       um Mauszeiger zentrieren */
                #define YPOS      4 /* Horizontal um Mauszeiger zentrieren,
                                       Y-Koordinate y */
                #define XYPOS     5 /* Koordinaten (x,y) */
                #define OBJPOS    6 /* um aktuellen Eintrag zentrieren oder
                                       wie XYPOS */

            -> select: aktueller Eintrag oder negativer Wert

            -> zurÅckgegeben wird die Objektnummer des selektierten Eintrags
               (oder 0) sowie in '*index' (sofern index!=NULL) der Index
               des selektierten Eintrags. Ist Bit 15 (0x8000) des RÅckgabe-
               wertes gesetzt, so wurde das Objekt per Doppelklick oder bei
               gedrÅckter Shift-Taste ausgewÑhlt

    16. XAcc-2- und AV-Protokoll-Funktionen
        -----------------------------------

        Die Library verwaltet intern alle An- und Abmeldungen der Proto-
        kolle XAcc2 und AV selbstÑndig. Ebenso werden die Nachrichten
        AV_SENDKEY sowie ACC_KEY automatisch in Keyboard-Events umge-
        wandelt bzw. nicht ausgewertete Keyboardevents werden als
        AV_SENDKEY bzw. ACC_KEY an den AV-Server oder die Hauptapplikation
        geschickt. Weiterhin werden nicht unterstÅtzte XAcc2-Nachrichten
        mit einer ACC_ACK-Nachricht beantwortet.

        Alle Fensterdialoge sowie Fenster, die mit den Funktionen
        open_window() und close_window() geîffnet bzw. geschlossen werden,
        werden bei einem eventuell vorhandenen AV-Server an- bzw. abge-
        meldet.

        #define XACC    1   /* XAcc-Protokoll */
        #define AV      2   /* AV-Protokoll */

        XAcc-Struktur:
        --------------
        typedef struct
        {
            /* unterstÅtzte Protokolle (Bit 0: XAcc, Bit 1: AV) */
            int     flag;       /* XACC/AV */

            /* Applikations-Identifikation */
            int     id;         /* XAcc/AV-Protokoll */

            /* Highbyte: Programmversionsnummer
               Lowbyte:  unterstÅtzte Nachrichtengruppen
            int     version;    /* nur XAcc-Protokoll */

            /* ID des MenÅeintrags im Accessory-MenÅ */
            int     menu_id;    /* nur XAcc-Protokoll */

            /* AV-Programmname (8 Zeichen) fÅr appl_find */
            char    name[];     /* nur AV-Protokoll */

            /* (erweiterter) XAcc2-Programmname oder NULL */
            char    *xname;     /* nur XAcc-Protokoll */

            /* Zeiger auf 'XDSC'-Informationen oder NULL */
            char    *xdsc;      /* nur XAcc-Protokoll */
        } XAcc;

        void XAccBroadCast(int msg[8])
            -> Nachrichtenpuffer 'msg' an alle erreichbaren Applikationen
               verschicken

        int XAccSendAck(int sendto, int answer)
            -> ACC_ACK-RÅckmeldung 'answer' an Applikation 'sendto' senden
               (OK: answer!=0, Fehler: answer==0)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        int XAccSendKey(int sendto, int scan, int state)
            -> Tasten-Druck (Scancode 'scan', Status der Umschalttasten
               'state') an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendText(int sendto, char *txt)
            -> Zeichenkette 'txt' an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendMeta(int sendto, int last, char *data, long len)
            -> Metafile-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendImg(int sendto, int last, char *data, long len)
            -> GEM-Image-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int AvSendMsg(int sendto,int msg_id,int msg[8])
            -> (AV-) Nachricht 'msg_id' an Applikation 'sendto' senden
               (Message-Puffer msg[3]-msg[7] enthÑlt gegebenenfalls weitere
               Daten)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        XAcc *find_xacc_xdsc(int app_id,char *xdsc)
            -> erweiterten XAcc-Programmnamen der Applikation 'app_id' nach
               Zeichenkette 'xdsc' durchsuchen (app<0 -> alle XAcc-Appli-
               kationen durchsuchen)
            -> RÅckgabewert enthÑlt Zeiger auf XAcc-Struktur der
               Applikation, deren XAcc-Programmname die Zeichenkette ent-
               hÑlt, oder NULL, wenn die Zeichenkette nicht gefunden wurde

        XAcc *find_id(int app_id)
            -> XAcc-Struktur der Applikation 'app_id' ermitteln oder NULL,
               wenn es sich um keine XAcc-Applikation handelt

        XAcc *find_app(int first)
            -> XAcc-Struktur der ersten (first!=0) oder der nÑchsten
               (first==0) angemeldeten Applikation ermitteln (RÅckgabewert
               gleich NULL, wenn keine weitere Applikation gefunden wurde)

        int AppLoaded(char *name)
            -> Ermittelt die Applikations-ID der Anwendung mit dem
               Dateinamen 'name', welcher auch Pfad- und Laufwerksangaben
               enthalten darf.
            -> RÅckgabewert: Applikations-ID oder negativer Wert

    17. Auskunftsfunktionen
        -------------------

        int appl_xgetinfo(int type,int *out1,int *out2,int *out3,int *out4);
            -> erweiterte appl_getinfo()-Routine, welche die Existenz von
               appl_getinfo() selbstÑndig ermittelt
            -> RÅckgabewerte wie bei appl_getinfo()

        int appl_getfontinfo(int font_type,int *height,int *id,int *type)
            -> Informationen Åber groûen (font_type=0) oder kleinen
               System-Font (font_type=1) ermitteln
            -> RÅckgabewerte:
                height: Font-Hîhe in Punkt
                id:     Font-ID
                type:   0 - System-Font
                        1 - FSM-Font

        int wind_xget(int w_handle, int w_field, int *w1, int *w2,
                      int *w3,int *w4);
            -> korrigierte wind_get()-Funktion fÅr erweiterte Aufrufe unter
               Winx sowie MTOS und zukÅnftigen Erweiterungen (die in der
               Pure C-GEM-Library bis V1.1 enthaltene, optimierte Routine
               funktioniert nicht mit neueren Aufrufen)

        int get_dialog_info(int *dialogs,int *wins,DIAINFO **top);
            -> Informationen Åber geîffnete Dialoge ermitteln
            -> RÅckgabewert: TRUE:  Ausgabe in beliebiges Fenster mîglich
                             FALSE: Ausgabe nur in obersten Dialog 'top'
                             FAIL:  Keine Ausgabe mîglich
               *dialogs: Anzahl der geîffneten (fliegenden) Dialoge (sofern
                         dialogs!=NULL)
               *wins:    Anzahl der geîffneten Fenster-Dialoge (sofern
                         wins!=NULL)
               *top:     Zeiger auf obersten Dialog, falls RÅckgabewert
                         gleich FALSE (sofern top!=NULL)

    18. Verschiedene Funktionen
        -----------------------

        int scan_2_ascii(int scan,int state);
            -> ASCII-Wert aus Scan-Code 'scan' und Status der
               Umschalttasten 'state' ermitteln

        int min(int val1,int val2);
            -> Minimum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        int max(int val1,int val2);
            -> Maximum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        void Min(int *var,int val);
            -> Minimum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void Max(int *var,int val);
            -> Maximum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void mfdb(MFDB *mfdb,int *bitmap,int width,int height,
                  int standard,int planes)
            -> Memory form definition block 'mfdb' initialisieren
            -> bitmap:       Zeiger auf Start der Bitmap
               width,height: Breite/Hîhe der Bitmap in Pixeln
               standard:     Standardformat (1) oder gerÑteabhÑngiges
                             Format
               planes:       Anzahl der Farbebenen der Bitmap

        long mfdb_size(MFDB *mfdb);
            -> Speicherbedarf der Bitmap des Memory form definition
               block 'mfdb' berechnen

    19. Definitionen hÑufig benîtigter (Protokoll-) Konstanten
        ------------------------------------------------------

        XAcc-2-Protokoll:
        -----------------
        (genaue Bedeutung s. XAcc-2-Dokumentation)

        #define ACC_ID      0x400
        #define ACC_OPEN    0x401
        #define ACC_CLOSE   0x402
        #define ACC_ACC     0x403
        #define ACC_EXIT    0x404

        #define ACC_ACK     0x500
        #define ACC_TEXT    0x501
        #define ACC_KEY     0x502
        #define ACC_META    0x503
        #define ACC_IMG     0x504

        AV-Protokoll:
        -------------
        (genaue Bedeutung s. AV-Dokumentation 'VA_PROTO.H')

        #define AV_PROTOKOLL        0x4700
        #define AV_GETSTATUS        0x4703
        #define AV_STATUS           0x4704
        #define AV_SENDKEY          0x4710
        #define AV_ASKFILEFONT      0x4712
        #define AV_ASKCONFONT       0x4714
        #define AV_ASKOBJECT        0x4716
        #define AV_OPENCONSOLE      0x4718
        #define AV_OPENWIND         0x4720
        #define AV_STARTPROG        0x4722
        #define AV_ACCWINDOPEN      0x4724
        #define AV_ACCWINDCLOSED    0x4726
        #define AV_COPY_DRAGGED     0x4728
        #define AV_PATH_UPDATE      0x4730
        #define AV_WHAT_IZIT        0x4732
        #define AV_DRAG_ON_WINDOW   0x4734
        #define AV_EXIT             0x4736

        #define VA_PROTOSTATUS      0x4701
        #define VA_SETSTATUS        0x4705
        #define VA_START            0x4711
        #define VA_FILEFONT         0x4713
        #define VA_CONFONT          0x4715
        #define VA_OBJECT           0x4717
        #define VA_CONSOLEOPEN      0x4719
        #define VA_WINDOPEN         0x4721
        #define VA_PROGSTART        0x4723
        #define VA_DRAGACCWIND      0x4725
        #define VA_COPY_COMPLETE    0x4729
        #define VA_THAT_IZIT        0x4733
        #define VA_DRAG_COMPLETE    0x4735

        #define VA_OB_UNKNOWN       0
        #define VA_OB_TRASHCAN      1
        #define VA_OB_SHREDDER      2
        #define VA_OB_CLIPBOARD     3
        #define VA_OB_FILE          4
        #define VA_OB_FOLDER        5
        #define VA_OB_DRIVE         6
        #define VA_OB_WINDOW        7

        MTOS-Drag&Drop-Protokoll:
        -------------------------
        (genaue Bedeutung s. MTOS-Entwickler-Dokumentation)

        #define AP_DRAGDROP         63

        #define DD_OK               0
        #define DD_NAK              1
        #define DD_EXT              2
        #define DD_LEN              3
        #define DD_TRASH            4
        #define DD_PRINTER          5
        #define DD_CLIPBOARD        6

        #define DD_TIMEOUT          4000

        #define DD_NUMEXTS          8
        #define DD_EXTSIZE          32L
        #define DD_NAMEMAX          128

        #define DD_HDRMAX           (8+DD_NAMEMAX)

        MenÅ-Protokoll:
        ---------------

        #define WM_CLOSED       0x0016
        #define WM_SAVE         0x1000
        #define WM_SAVEAS       0x1001
        #define WM_PRINT        0x1002
        #define WM_UNDO         0x1003
        #define WM_CUT          0x1004
        #define WM_COPY         0x1005
        #define WM_PASTE        0x1006
        #define WM_SELECTALL    0x1007
        #define WM_FIND         0x1008
        #define WM_REPLACE      0x1009
        #define WM_FINDNEXT     0x100a
        #define WM_HELP         0x100b

        Clipboard-Protokoll:
        --------------------
        (s.a. Beschreibung der Funktion scrp_changed())

        Aufbau der Nachricht:
            msg[0]          = SC_CHANGED $1234 (4660)
            msg[1]          = apID
            msg[2]          = 0
            msg[3]          = Bitmap des Dateiformats
                              (Parameter 'format' von scrp_changed())
            msg[4],msg[5]   = 4 Zeichen fÅr die "beste" der abgespeicherten
                              Dateien (z.B. ".RTF"), damit beim Lesen mîg-
                              lichst wenig Information verloren geht
                              (Parameter 'best_ext' von scrp_changed())
            msg[6],msg[7]   = reserviert (auf Null setzen!)

