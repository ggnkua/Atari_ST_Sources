/*----------------------------------------------------------------------------------------	FileSystem.cp, file system objects and operations		28.9.2000 by Manfred Lippert, mani@mani.de	last change: 7.12.2001----------------------------------------------------------------------------------------*/#include <FileSystem.h>#include <SysInfo.h>#if TARGET_MACOS#include <Resources.h>#include <FinderRegistry.h>#endif#if TARGET_TOS#include <TextEnc.h>#include <gemdos.h>#include <string.h>#endif#if TARGET_TOS// own critical error handler to prevent "insert disc ..." alerts:static asm void TOS_empty_critic_handler() {	move.w 4(sp),d0	ext.l d0	rts}static uint32 TOS_remove_critic_handler(void) {	return (uint32)Setexc(0x101, TOS_empty_critic_handler);}static void TOS_restore_critic_handler(uint32 old_critic_handler) {	Setexc(0x101, (void (*)())old_critic_handler);}#endif/*** FSysInfo ***************************************************************************/Err FSysInfo::get_create_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.createDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysInfo::get_modify_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.contentModDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysInfo::get_attmod_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.attributeModDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysInfo::get_access_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.accessDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysInfo::get_backup_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.backupDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}/*** FSysVolumeInfo *********************************************************************/Err FSysVolumeInfo::get_create_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.createDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysVolumeInfo::get_modify_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.modifyDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysVolumeInfo::get_backup_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.backupDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}Err FSysVolumeInfo::get_checked_time(TimeSpec *spec) {#if TARGET_MACOS	spec->Mac_set_utc(&info.checkedDate);	return OK;#else#pragma unused(spec)// To do ...	return ERR_ERR;#endif}/*** FSysObj ****************************************************************************/#if TARGET_TOSboolean FSysObj::TOS_is_case_insensitiv() const {	boolean back = TRUE;	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		int32 oserr = Dpathconf(path, 6);	// 6 = case sensivity		back = (oserr < 0 || oserr == 1);		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}boolean FSysObj::TOS_is_case_sensitiv() const {	boolean back = FALSE;	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		back = (Dpathconf(path, 6) == 0);	// 6 = case sensivity		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}boolean FSysObj::TOS_is_case_preserving() const {	boolean back = FALSE;	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		back = (Dpathconf(path, 6) == 2);	// 6 = case sensivity		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}boolean FSysObj::TOS_is_case_insensitiv_or_preserving() const {	boolean back = TRUE;	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		int32 oserr = Dpathconf(path, 6);	// 6 = case sensivity		back = (oserr < 0 || oserr == 1 || oserr == 2);		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}size_t FSysObj::TOS_get_max_name_length() const {	size_t back = 12;	// assuming DOS 8.1 on error	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		int32 oserr = Dpathconf(path, 3);	// 3 = name length		if (oserr > 0) {			back = (size_t)oserr;		}		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}boolean FSysObj::TOS_is_truncating() const {	boolean back = TRUE;	// assuming truncating on error	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		int32 oserr = Dpathconf(path, 5);	// 5 = truncating		if (oserr == 0) {			back = FALSE;	// no truncating (error ERANGE with too long file names)		}		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}boolean FSysObj::TOS_is_DOS_truncating() const {	boolean back = TRUE;	// assuming DOS 8.1 truncating on error	if (path) {		char *cut_pos = strrchr(path, FSYS_PATH_DELIMITER);		char remember;		if (cut_pos) {			remember = *(++cut_pos);			*cut_pos = 0;		}		int32 oserr = Dpathconf(path, 5);	// 5 = truncating		if (oserr < 0) {			// error			oserr = Dpathconf(path, 3);		// 3 = name length			if (oserr > 12) {						// longer than 8.1 DOS names?				back = FALSE;						// cannot be DOS truncating			}		} else if (oserr != 2) {			back = FALSE;			// no DOS truncating		}		if (cut_pos) {			*cut_pos = remember;		}	}	return back;}static const int32 DOPENDIR_ERROR = 0xFF000000L;static int32 modified_Freadlink(int16 bufsize, char *buf, char *path) {	size_t len = strlen(path);	boolean had_delimiter = (len > 0 && path[len - 1] == FSYS_PATH_DELIMITER);	if (had_delimiter) {		path[--len] = 0;							// cut off delimiter	}	int32 back;	buf[0] = 0;										// wegen diverser CD-Treiber!	back = Freadlink(bufsize, buf, path);	if (back >= 0 && buf[0] == 0) {			// wegen diverser CD-Treiber!		back = ERROR;	}	if (had_delimiter) {		path[len] = FSYS_PATH_DELIMITER;		// restore delimiter		if (back < 0) {							// if error try again with delimiter			buf[0] = 0;								// wegen diverser CD-Treiber!			back = Freadlink(bufsize, buf, path);			if (back >= 0 && buf[0] == 0) {	// wegen diverser CD-Treiber!				back = ERROR;			}		}	}	return back;}static boolean path_is_alias(char *path) {	char link[MAXPATH0];	// hopefully it fits all needs ... :-(	return (modified_Freadlink(MAXPATH0, link, path) >= 0);}Err FSysObj::TOS_check_path() {	Err err = OK;	if (!path) {		return ERR_ERR;	}	if (path[0] >= 'a' && path[0] <= 'z') {		path[0] -= ('a' - 'A');	}	if (path[0] < 'A' || path[0] > 'Z' || path[1] != ':') {	// valid path?		return ERR_ERR;	}	uint32 old_critic = TOS_remove_critic_handler();	// No disc change alerts// 1. check if it is a file:	boolean it_is_file = FALSE;	size_t len = strlen(path);	if (len > 3) {								// cannot be a file (too short)		if (path[len - 1] == FSYS_PATH_DELIMITER) {			path[--len] = 0;					// remove backslash at end		}		int32 handle = Fopen(path, FO_READ);		if (handle >= 0) {			it_is_file = TRUE;				// it is a file!			Fclose((int16)handle);		}	}	if (!it_is_file) {// 2. It must be a folder - but check it, to be sure, object exists!		if (path[len - 1] != FSYS_PATH_DELIMITER) {			path[len++] = FSYS_PATH_DELIMITER;	// add backslash at end			path[len] = 0;		}		int32 dir = Dopendir(path, 0);			// read directory		if ((dir & DOPENDIR_ERROR) == DOPENDIR_ERROR) {	// could be that the system has no Dopendir			char *path2 = (char *)malloc(len + 4);			if (!path2) {				err = ERR_OOM;							// ERROR: out of memory, cannot check			} else {				memcpy(path2, path, len);				strcpy(path2 + len, "*.*");				dir = Fsfirst(path2, 0x17);		// try it the "old" way				if (dir == EPTHNF || dir == EFILNF || dir == EDRIVE) {					err = ERR_NOTEXIST;				// ERROR: object does not exist!				}				free(path2);			}		} else {			// folder exists - it is a folder!			Dclosedir(dir);		}	}// 3. check if its an alias	if (err == OK) {		alias = path_is_alias(path);	}	TOS_restore_critic_handler(old_critic);				// restore disc change alerts	return err;}#endifFSysObj::FSysObj() {#if TARGET_MACOS	type_cache_mask = 0;	type_cache = 0;#endif#if TARGET_TOS	path = 0;	alias = FALSE;#endif}FSysObj::~FSysObj() {#if TARGET_TOS	dispose();#endif}Err FSysObj::init(const FSysObj *copy) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		ref = copy->ref;		type_cache_mask = copy->type_cache_mask;		type_cache = copy->type_cache;		return OK;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	dispose();	if (copy->path) {		size_t len = strlen(copy->path);		path = (char *)malloc(len + 2);		if (!path) {			return ERR_OOM;		}		memcpy(path, copy->path, len + 1);		alias = copy->alias;	}	return OK;#endif}Err FSysObj::init(FSysObj *parent, const UniString *name) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr;		if (parent == 0) {	// specific volume by name			UniString volume_name;			FSysVolumeIterator iter;			err = iter.open();			if (err == OK) {				while ((err = iter.read(this, 0, 0, &volume_name)) == OK) {					if (name->simple_compare(&volume_name) == 0) {						return OK;					}				}			}			return ERR_NOTFOUND;		} else {			oserr = FSMakeFSRefUnicode(parent ? &parent->ref : 0,												name->get_length(),	// Surrogates?!?												name->dangerous_get_data(),												kTextEncodingUnknown,												&ref);			if (oserr == fnfErr) {				err = ERR_NOTEXIST;			} else if (oserr != noErr) {				err.setOS(oserr);			} else {				type_cache_mask = 0;			}		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	TextEnc dst_enc(	TEXTENC_BASE_US_ASCII,							TEXTENC_VARIANT_DEFAULT,							TEXTENC_FORMAT_DEFAULT);	char *path;	Err err = name->get_cstring(	&dst_enc,											&path);	if (err == OK) {		err = TOS_init(parent, path);		free(path);	}	return err;#endif}#if TARGET_MACOSErr FSysObj::Mac_init_volume(FSVolumeRefNum mac_volref) {#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSGetVolumeInfo(mac_volref,												0,		// volume index												0,		// actual FSVolumeRefNum												0,		// info bitmask												0,		// info												0,		// Unicode HFS name												&ref);		if (oserr != noErr) {			err.setOS(oserr);		} else {			type_cache = (TYPE_VOLUME|TYPE_FOLDER);		// we're sure this is a volume and then also a folder but no alias			type_cache_mask = (TYPE_VOLUME|TYPE_FOLDER|TYPE_ALIAS);	// all three bits are valid now		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;}#endif#if TARGET_MACOS && PPCErr FSysObj::Mac_init_fsref(const FSRef *ref) {	if (sysinfo.has_HFSPlus_APIs) {		this->ref = *ref;		type_cache_mask = 0;		return OK;	}	return ERR_ERR;}#endif#if TARGET_MACOSErr FSysObj::Mac_init_fsspec(const FSSpec *spec) {#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSpMakeFSRef(spec, &ref);		if (oserr != noErr) {			err.setOS(oserr);		} else {			type_cache_mask = 0;		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;}#endif#if TARGET_MACOS && PPCErr FSysObj::Mac_get_fsref(FSRef *out_ref) const {	if (sysinfo.has_HFSPlus_APIs) {		*out_ref = this->ref;		return OK;	}	return ERR_ERR;}#endif#if TARGET_MACOSErr FSysObj::Mac_get_fsspec(FSSpec *out_spec) const {#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSGetCatalogInfo(	&ref,													FSYS_INFO_NONE,													0,													0,													out_spec,													0);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;}#endif#if TARGET_TOSvoid FSysObj::TOS_init_direct(char *path, boolean alias) {	this->path = path;	this->alias = alias;}Err FSysObj::TOS_init(FSysObj *parent, const char *path_part) {// be careful! "this" can be == parent!!!	if (parent && !parent->is_folder()) {		return ERR_ERR;	}	Err err = OK;	FSysObj resolved;	const FSysObj *resolved_parent = parent;	if (parent && parent->is_alias()) {		err = parent->resolve_alias(&resolved);		if (err != OK) {			return err;		}		resolved_parent = &resolved;	}	char *delimiter = strchr(path_part, FSYS_PATH_DELIMITER);	if (delimiter) {		*delimiter = 0;								// get only the first part of the path	}	size_t len1 = resolved_parent ? strlen(resolved_parent->path) : 0;	size_t len2 = strlen(path_part);	char *neu_path = (char *)malloc(len1 + len2 + 2);	if (!neu_path) {		err == ERR_OOM;	} else {		if (resolved_parent) {			strcpy(neu_path, resolved_parent->path);		}		strcpy(neu_path + len1, path_part);		resolved.dispose();	// not needed anymore		dispose();				// so late here because resolved_parent can be "this"!		path = neu_path;		err = TOS_check_path();		if (err != OK) {			free(path);			path = 0;		}	}	if (delimiter) {		*delimiter = FSYS_PATH_DELIMITER;		// restore full path part		if (err == OK && *++delimiter != 0) {			return TOS_init(this, delimiter);	// recursively init all parts		}	}	return err;}Err FSysObj::TOS_init_path(const char *in_path) {	return TOS_init(0, in_path);}Err FSysObj::TOS_init_volume(char drive) {	dispose();	path = (char *)malloc(4);	if (!path) {		return ERR_OOM;	}	path[0] = drive;	path[1] = ':';	path[2] = FSYS_PATH_DELIMITER;	path[3] = 0;	Err err = TOS_check_path();	if (err != OK) {		free(path);		path = 0;	}	return err;}Err FSysObj::TOS_get_drive(char *drive) {	if (!path) {		return ERR_ERR;	}	*drive = path[0];	return OK;}#endifErr FSysObj::find_folder(uint32 def) {	Err err = ERR_NOTFOUND;	switch (def) {	case FSYS_FINDFOLDER_MYSELF:#if TARGET_TOS		init(&sysinfo.startpath);#else		{			FSysObj app_file;			err = app_file.find_file(FSYS_FINDFILE_MYSELF);			if (err == OK) {				err = app_file.get_info(0, 0, 0, this);	// get parent folder of app file/bundle			}		}#endif		break;	case FSYS_FINDFOLDER_RESOURCES:		{			UniString str;#if TARGET_MACOS_IS_BUNDLED// To do: use CFBundleGetMainBundle/CFBundleCopyResourcesDirectoryURL/... to get Resources file!// fallback:			err = find_file(FSYS_FINDFILE_MYSELF);		// is really is a folder (the bundle)			if (err == OK) {				err = str.replace("Contents");				if (err == OK) {					err = init(this, &str);					// in Mac OS bundles we first must enter the "Contents" folder				}			}#else			err = find_folder(FSYS_FINDFOLDER_MYSELF);	// no bundle, just search for the path where the application is#endif			if (err == OK) {				err = str.replace("Resources");				if (err == OK) {					err = init(this, &str);					// now get the "Resources" folder				}			}		}		break;	}	return err;}Err FSysObj::find_file(uint32 def) {	Err err = ERR_NOTFOUND;	switch (def) {	case FSYS_FINDFILE_MYSELF:#if TARGET_MACOS		{			ProcessSerialNumber PSN;			ProcessInfoRec pinfo;			FSSpec pspec;			OSStatus oserr;			// set up process serial number			PSN.highLongOfPSN = 0;			PSN.lowLongOfPSN = kCurrentProcess;//			if (GetProcessBundleLocation(&PSN, &ref) != noErr) {	// first try it this way   Does not exist in CarbonLib 1.4 :-(				// set up info block				pinfo.processInfoLength = sizeof(pinfo);				pinfo.processName = NULL;				pinfo.processAppSpec = &pspec;				// grab the vrefnum and directory				oserr = GetProcessInformation(&PSN, &pinfo);			// second way				if (oserr == noErr) {					err = Mac_init_fsspec(&pspec);#if TARGET_MACOS_IS_BUNDLED					if (err == OK) {						err = get_info(0, 0, 0, this);			// get "MacOS" parent folder						if (err == OK) {							err = get_info(0, 0, 0, this);		// get "Contents" folder							if (err == OK) {								err = get_info(0, 0, 0, this);	// get "xxx.app" folder, the bundle							}						}					}#endif				} else {					err.setOS(oserr);				}//			}		}#endif		break;	}	return err;}void FSysObj::dispose() {#if TARGET_TOS	if (path) {		free(path);		path = 0;	}#endif}// is_alias() corrects automatically file/folder info (if set previous)// thats the reason why is_file() and is_folder() automatically call is_alias()!boolean FSysObj::is_alias() {#if TARGET_MACOS	if ((type_cache_mask & TYPE_ALIAS) == 0) {	// bit not valid?		FSRef ref_duplicate = ref;		Boolean folder_flag = FALSE;		Boolean alias_flag = FALSE;		FSResolveAliasFileWithMountFlags(						&ref_duplicate,						TRUE,				// do chain to get right type (file/folder) of original						&folder_flag,						&alias_flag,						kResolveAliasFileNoUI);// FSIsAlias does not work: it returns always folder_flag == FALSE		type_cache &= ~(TYPE_FOLDER|TYPE_ALIAS);		if (alias_flag) {			type_cache |= TYPE_ALIAS;	// object is alias		}		if (folder_flag) {			type_cache |= TYPE_FOLDER;	// object is folder or alias to folder		}		type_cache_mask |= (TYPE_FOLDER|TYPE_ALIAS);	// these two bits are valid now	}	return ((type_cache & TYPE_ALIAS) != 0);#elif TARGET_TOS	return alias;#endif}// is_file_or_alias() can work faster than is_file()/is_alias()// under Mac OS, each alias is a file first (even it points to a folder)// so we don't need to try to resolve an alias!boolean FSysObj::is_file_or_alias() {#if TARGET_MACOS	if ((type_cache_mask & TYPE_FOLDER) == 0) {	// bit not valid?		FSysInfo info;		if (get_info(FSYS_INFO_NODE_FLAGS, &info, 0, 0) == OK) {			if ((info.info.nodeFlags & kFSNodeIsDirectoryMask) != 0) {	// folder?				type_cache |= TYPE_FOLDER;								// folder				type_cache_mask |= TYPE_FOLDER;						// folder bit is valid now			} else {				type_cache &= ~(TYPE_FOLDER|TYPE_VOLUME);			// no folder and so also not a volume				type_cache_mask |= (TYPE_FOLDER|TYPE_VOLUME);	// folder and volume bits are valid now			}		} else {			return TRUE;	// Error, cannot get type, handle as file		}	}	return ((type_cache & TYPE_FOLDER) == 0);#else	return (is_file() || is_alias());#endif}boolean FSysObj::is_file() {#if TARGET_MACOS	is_alias();	// check for aliases here to be sure that aliases to folders are recognized as folders!	if ((type_cache_mask & TYPE_FOLDER) == 0) {	// bit not valid?		FSysInfo info;		if (get_info(FSYS_INFO_NODE_FLAGS, &info, 0, 0) == OK) {			if ((info.info.nodeFlags & kFSNodeIsDirectoryMask) != 0) {	// folder?				type_cache |= TYPE_FOLDER;								// folder				type_cache_mask |= TYPE_FOLDER;						// folder bit is valid now			} else {				type_cache &= ~(TYPE_FOLDER|TYPE_VOLUME);			// no folder and so also not a volume				type_cache_mask |= (TYPE_FOLDER|TYPE_VOLUME);	// folder and volume bits are valid now			}		} else {			return TRUE;	// Error, cannot get type, handle as file		}	}	return ((type_cache & TYPE_FOLDER) == 0);#elif TARGET_TOS	size_t len = strlen(path);	return (len > 0 && path[len - 1] != FSYS_PATH_DELIMITER);#endif}boolean FSysObj::is_folder() {#if TARGET_MACOS	is_alias();	// check for aliases here to be sure that aliases to folders are recognized as folders!	if ((type_cache_mask & TYPE_FOLDER) == 0) {	// bit not valid?		FSysInfo info;		if (get_info(FSYS_INFO_NODE_FLAGS, &info, 0, 0) == OK) {			if ((info.info.nodeFlags & kFSNodeIsDirectoryMask) != 0) {	// folder?				type_cache |= TYPE_FOLDER;								// folder				type_cache_mask |= TYPE_FOLDER;						// folder bit is valid now			} else {				type_cache &= ~(TYPE_FOLDER|TYPE_VOLUME);			// no folder and so also not a volume				type_cache_mask |= (TYPE_FOLDER|TYPE_VOLUME);	// folder and volume bits are valid now			}		} else {			return FALSE;	// Error, cannot get type, handle as file		}	}	return ((type_cache & TYPE_FOLDER) != 0);#elif TARGET_TOS	size_t len = strlen(path);	return (len > 0 && path[len - 1] == FSYS_PATH_DELIMITER);#endif}boolean FSysObj::is_volume() {#if TARGET_MACOS	if ((type_cache_mask & TYPE_VOLUME) == 0) {	// bit not valid?		FSysInfo info;		if (get_info(FSYS_INFO_PARENT_DIR_ID, &info, 0, 0) == OK) {			if (info.info.parentDirID == fsRtParID) {	// volume?				type_cache |= (TYPE_FOLDER|TYPE_VOLUME);			// volume and so also folder				type_cache_mask |= (TYPE_FOLDER|TYPE_VOLUME);	// volume and folder bit is valid now			} else {				type_cache &= ~(TYPE_VOLUME);							// not a volume				type_cache_mask |= (TYPE_VOLUME);					// volume bitis valid now			}		} else {			return FALSE;	// Error, cannot get type, handle as non-volume		}	}	return ((type_cache & TYPE_VOLUME) != 0);#elif TARGET_TOS	size_t len = strlen(path);	return (len == 3 && path[1] == ':' && path[2] == FSYS_PATH_DELIMITER);#endif}boolean FSysObj::is_equal(const FSysObj *other) const {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		OSErr oserr = FSCompareFSRefs(&ref, &other->ref);		return (oserr == noErr);	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return FALSE;#elif TARGET_TOS	if (path != 0 && other->path != 0) {		if (TOS_is_case_insensitiv_or_preserving()) {			return (stricmp(path, other->path) == 0);		}		return (strcmp(path, other->path) == 0);	}	return FALSE;#endif}Err FSysObj::create_file(const UniString *name, FSysObj *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSCreateFileUnicode(	&ref,														name->get_length(),		// Surrogates?														name->dangerous_get_data(),														0,								// whichInfo														0,								// info														out ? &out->ref : 0,														0);							// FSSpec		if (oserr == dupFNErr) {			err = ERR_EXISTS;		} else if (oserr != noErr) {			err.setOS(oserr);		} else if (out) {			out->type_cache = 0;	// we're sure this is a file, no folder, no volume, no alias			out->type_cache_mask = (TYPE_FOLDER|TYPE_VOLUME|TYPE_ALIAS);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (!is_folder()) {		return ERR_ERR;	}	FSysObj temp;	// cannot use out here, because out maybe "this"	Err err = temp.init(this, name);	temp.dispose();	if (err == OK) {	// object exists already?		return ERR_EXISTS;	}	TextEnc dst_enc(	TEXTENC_BASE_US_ASCII,							TEXTENC_VARIANT_DEFAULT,							TEXTENC_FORMAT_DEFAULT);	size_t len1 = strlen(path);	char *neu_path;	err = name->get_cstring(&dst_enc,									&neu_path,									0,									len1);		// space at beginning for existing path	if (err == OK) {		if (strchr(neu_path + len1, FSYS_PATH_DELIMITER) != 0) {			err = ERR_ERR;			free(neu_path);		} else {			memcpy(neu_path, path, len1);			int32 oserr = Fcreate(neu_path, 0);			if (oserr >= 0) {				Fclose((int16)oserr);				out->TOS_init_direct(neu_path, FALSE);			} else {				err.setOS(oserr);				free(neu_path);			}		}	}	return err;#endif}Err FSysObj::create_folder(const UniString *name, FSysObj *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSCreateDirectoryUnicode(&ref,															name->get_length(),		// Surrogates?															name->dangerous_get_data(),															0,								// whichInfo															0,								// info															out ? &out->ref : 0,															0,								// FSSpec															0);							// DirID		if (oserr == dupFNErr) {			err = ERR_EXISTS;		} else if (oserr != noErr) {			err.setOS(oserr);		} else if (out) {			out->type_cache = TYPE_FOLDER;	// we're sure this is a folder, no volume, no alias			out->type_cache_mask = (TYPE_FOLDER|TYPE_VOLUME|TYPE_ALIAS);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (!is_folder()) {		return ERR_ERR;	}	Err err = out->init(this, name);	out->dispose();	if (err == OK) {	// object exists already?		return ERR_EXISTS;	}	TextEnc dst_enc(	TEXTENC_BASE_US_ASCII,							TEXTENC_VARIANT_DEFAULT,							TEXTENC_FORMAT_DEFAULT);	size_t len1 = strlen(path);	char *neu_path;	err = name->get_cstring(&dst_enc,									&neu_path,									0,									len1,		// space at beginning for existing path									1);		// space for delimiter	if (err == OK) {		if (strchr(neu_path + len1, FSYS_PATH_DELIMITER) != 0) {			err = ERR_ERR;			free(neu_path);		} else {			memcpy(neu_path, path, len1);			int32 oserr = Dcreate(neu_path);			if (oserr < 0) {				err.setOS(oserr);				free(neu_path);			} else {				len1 = strlen(neu_path);				neu_path[len1++] = FSYS_PATH_DELIMITER;				neu_path[len1] = 0;				out->TOS_init_direct(neu_path, FALSE);			}		}	}	return err;#endif}#if 0// Does not work!/* Alco Blom:OSErr MakeHelpAlias(FSSpec* helpFolder, FSSpec* myHelpFolder) {	OSErr err;	AppleEvent event = {typeNull, nil};	AppleEvent reply = {typeNull, nil};	err = MakeFinderEvent(kAECoreSuite, kAECreateElement, &event);	if (err) return err;	// specify class alias	OSType cl = cAliasFile;	AEDesc classDesc = {typeNull, nil};	err = AECreateDesc(typeType, &cl, sizeof(OSType), &classDesc);	if (err) return err;	// add class	err = AEPutParamDesc(&event, keyAEObjectClass, &classDesc);	AEDisposeDesc(&classDesc);	// insert here	if (err == noErr)		err = AEPutParamPtr(&event, keyAEInsertHere, typeFSS, helpFolder, sizeof(FSSpec));	// original	if (err == noErr)		err = AEPutParamPtr(&event, 'to  ', typeFSS, myHelpFolder, sizeof(FSSpec));	if (err == noErr)		err = AESend(&event, &reply, kAENoReply, kAENormalPriority, kNoTimeOut, nil, nil);	AEDisposeDesc(&event);	AEDisposeDesc(&reply);	return err;}*/#if TARGET_MACOSstatic OSErr FindProcessBySignature(const OSType targetType, const OSType targetCreator, ProcessSerialNumberPtr psnPtr) {	OSErr anErr = noErr;	Boolean lookingForProcess = true;	ProcessInfoRec	infoRec;		infoRec.processInfoLength = sizeof(ProcessInfoRec);	infoRec.processName = nil;	infoRec.processAppSpec = nil;		psnPtr->lowLongOfPSN = kNoProcess;	psnPtr->highLongOfPSN = kNoProcess;	while (lookingForProcess) {		anErr = GetNextProcess(psnPtr);		if (anErr != noErr) {			lookingForProcess = false;		} else {			anErr = GetProcessInformation( psnPtr, &infoRec );			if ( ( anErr == noErr )				 	&& ( infoRec.processType == targetType )				 	&& ( infoRec.processSignature == targetCreator ) ) {				lookingForProcess = false;			}		}	}	return anErr;}static OSErr MakeFinderEvent(const AEEventClass eventClass, const AEEventID eventID, AppleEvent *out_event) {	ProcessSerialNumber psn = {kNoProcess, kNoProcess};	OSErr oserr = FindProcessBySignature('FNDR', 'MACS', &psn);	if (oserr == noErr) {		AEDesc targetAppDesc = {typeNull, nil};		oserr = AECreateDesc(typeProcessSerialNumber, &psn, sizeof(ProcessSerialNumber), &targetAppDesc);		if (oserr == noErr) {			oserr = AECreateAppleEvent(eventClass, eventID, &targetAppDesc, kAutoGenerateReturnID, kAnyTransactionID, out_event);			AEDisposeDesc( &targetAppDesc );		}	}	return oserr;}#endifErr FSysObj::create_alias(const FSysObj *original, const UniString *name, FSysObj *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = create_file(name, out);		if (err == OK) {			FSSpec original_spec;			FSSpec alias_spec;			err = original->Mac_get_fsspec(&original_spec);			if (err == OK) {				err = out->Mac_get_fsspec(&alias_spec);				if (err == OK) {					OSErr oserr;					AppleEvent event = {typeNull, nil};					AppleEvent reply = {typeNull, nil};					oserr = MakeFinderEvent(kAECoreSuite, kAECreateElement, &event);					if (oserr != noErr) {						err.setOS(oserr);					} else {						// specify class alias						OSType cl = cAliasFile;						AEDesc classDesc = {typeNull, nil};						oserr = AECreateDesc(typeType, &cl, sizeof(OSType), &classDesc);						if (oserr != noErr) {							err.setOS(oserr);						} else {							// add class							oserr = AEPutParamDesc(&event, keyAEObjectClass, &classDesc);							AEDisposeDesc(&classDesc);							if (oserr != noErr) {								err.setOS(oserr);							} else {								// insert here								oserr = AEPutParamPtr(&event, keyAEInsertHere, typeFSS, &alias_spec, sizeof(FSSpec));								if (oserr != noErr) {									err.setOS(oserr);								} else {									// original									oserr = AEPutParamPtr(&event, 'to  ', typeFSS, &original_spec, sizeof(FSSpec));									if (oserr != noErr) {										err.setOS(oserr);									} else {										oserr = AESend(&event, &reply, kAENoReply, kAENormalPriority, kNoTimeOut, nil, nil);										if (oserr != noErr) {											err.setOS(oserr);										}									}								}							}						}						AEDisposeDesc(&event);						AEDisposeDesc(&reply);					}				}			}			if (err != OK) {				out->kill();			}		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	return ERR_ERR;#endif}#endif#if 0// Does not work!// Mac Apps have to use the finder to create aliases! :-/Err FSysObj::create_alias(const FSysObj *original, const UniString *name, FSysObj *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		err = create_file(name, out);		if (err == OK) {			AliasHandle alias;			OSErr oserr = FSNewAlias(&out->ref, &original->ref, &alias);			if (oserr != noErr) {				err.setOS(oserr);			} else {//				err = out->create_resource_fork();//				if (err == OK) {				FSCreateResFile(	&ref,										(UniCharCount)name->get_length(),										(const UniChar *)name->dangerous_get_data(),										0,										0,										&out->ref,										0);				oserr = ResError();				if (oserr != noErr) {					err.setOS(oserr);				} else {					out->type_cache_mask = 0;	// can be optimized (alias ...)					short resfile = FSOpenResFile(&out->ref, fsCurPerm);					if (resfile < 0) {						err = ERR_FOPEN;					} else {						AddResource((Handle)alias, rAliasType, 0, "\pAlias");// Finder Flag "Alias" must be set, type creator also ...						oserr = ResError();						CloseResFile(resfile);						if (oserr == noErr) {							oserr = ResError();						}						if (oserr != noErr) {							err.setOS(oserr);						}					}				}				DisposeHandle((Handle)alias);			}			if (err != OK) {				out->kill();			}		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	return ERR_ERR;#endif}#endifErr FSysObj::resolve_alias(FSysObj *out) {// be carefull: "this" can be == out!!!	if (!is_alias()) {		return ERR_ERR;	}#if TARGET_MACOS	Err err = OK;	Boolean folder_flag = FALSE;	Boolean alias_flag = FALSE;	out->dispose();	out->ref = ref;	OSErr oserr = FSResolveAliasFileWithMountFlags(							&out->ref,							FALSE,				// do not chain							&folder_flag,							&alias_flag,							kResolveAliasFileNoUI);	if (oserr != noErr) {		err.setOS(oserr);	} else {		out->type_cache = (folder_flag ? TYPE_FOLDER : (uint16)0);		out->type_cache_mask = TYPE_FOLDER;	}	return err;#elif TARGET_TOS	Err err;	if (!path) {		return ERR_ERR;	}	char link[MAXPATH0];	// hopefully it fits all needs ... :-(	int32 oserr = modified_Freadlink(MAXPATH0, link, path);	if (oserr < 0) {		err.setOS(oserr);	} else {		err = out->TOS_init_path(link);	}	return err;#endif}Err FSysObj::kill() {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSDeleteObject(&ref);		if (oserr != noErr) {			err.setOS(oserr);		} else {			dispose();		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	Err err = OK;	if (!path) {		return ERR_ERR;	}	if (is_alias() || is_file()) {		int32 oserr = Fdelete(path);		if (oserr != 0) {			err.setOS(oserr);		}	} else if (is_folder() && !is_volume()) {		int32 oserr = Ddelete(path);		if (oserr != 0) {			err.setOS(oserr);		}	} else {		return ERR_ERR;	}	if (err == OK) {		dispose();	}	return err;#endif}Err FSysObj::move(FSysObj *destination_folder) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSMoveObject(&ref, &destination_folder->ref, &ref);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (!path || !destination_folder->is_folder() || is_volume()) {		return ERR_ERR;	}	Err err = OK;	size_t len = strlen(path);	boolean had_delimiter = (path[len - 1] == FSYS_PATH_DELIMITER);	if (had_delimiter) {		path[--len] = 0;	}	char *name = strrchr(path, FSYS_PATH_DELIMITER);	if (!name) {		err = ERR_ERR;	} else {		size_t name_len = strlen(name);		size_t dest_len = strlen(destination_folder->path);		char *neu_path = (char *)malloc(dest_len + name_len + 1);		if (!neu_path) {			err = ERR_OOM;		} else {			memcpy(neu_path, destination_folder->path, dest_len);			memcpy(neu_path + dest_len, name, name_len + 1);			int16 oserr = Frename(0, path, neu_path);			if (oserr != E_OK) {				err.setOS(oserr);			} else {				err = TOS_init(destination_folder, neu_path + dest_len);				free(neu_path);				return err;			// return here because old "path"-pointer is not valid anymore!			}			free(neu_path);		}	}	if (had_delimiter) {		path[len] = FSYS_PATH_DELIMITER;	}	return err;#endif}Err FSysObj::rename(const UniString *name) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSRenameUnicode(&ref,												name->get_length(),		// Surrogates?												name->dangerous_get_data(),												kTextEncodingUnknown,												&ref);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(name)	if (!path) {		return ERR_ERR;	}	TextEnc dst_enc(	TEXTENC_BASE_US_ASCII,							TEXTENC_VARIANT_DEFAULT,							TEXTENC_FORMAT_DEFAULT);	Err err = OK;	size_t len = strlen(path);	boolean had_delimiter = (path[--len] == FSYS_PATH_DELIMITER);	if (had_delimiter) {		path[len] = 0;							// cut off delimiter	}	char *name_begin = strrchr(path, FSYS_PATH_DELIMITER);	if (name_begin++ == 0) {		name_begin = path;	}	size_t path_len = (size_t)(name_begin - path);	char *neu_path;	err = name->get_cstring(&dst_enc,									&neu_path,									0,									path_len,									1);	if (err == OK) {		if (strchr(neu_path + path_len, FSYS_PATH_DELIMITER) != 0) {	// wrong name (has delimiter in it)			err = ERR_ERR;		} else {			memcpy(neu_path, path, path_len);			int16 oserr = Frename(0, path, neu_path);			if (oserr != E_OK) {				err.setOS(oserr);			}		}		if (err == OK) {			free(path);			path = neu_path;			len = strlen(path);		} else {			free(neu_path);		}	}	if (had_delimiter) {		path[len++] = FSYS_PATH_DELIMITER;	// restore delimiter		path[len] = 0;								// path could have changed, so the 0-byte could be missing	}//	err = TOS_check_path();	// neccessary?	return err;#endif}Err FSysObj::create_data_fork() const {	UniString data_fork;	Err err = FSysObj::get_data_fork_name(&data_fork);	if (err == OK) {		err = create_fork(&data_fork);	}	return err;}Err FSysObj::create_resource_fork() const {	UniString data_fork;	Err err = FSysObj::get_resource_fork_name(&data_fork);	if (err == OK) {		err = create_fork(&data_fork);	}	return err;}Err FSysObj::create_fork(const UniString *fork_name) const {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSCreateFork(&ref,											fork_name->get_length(),		// Surrogates?											fork_name->dangerous_get_data());		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#else#pragma unused(fork_name)	return ERR_ERR;	// no new forks on non-Mac systems#endif}Err FSysObj::kill_data_fork() const {	UniString data_fork;	Err err = FSysObj::get_data_fork_name(&data_fork);	if (err == OK) {		err = kill_fork(&data_fork);	}	return err;}Err FSysObj::kill_fork(const UniString *fork_name) const {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSDeleteFork(&ref,											fork_name->get_length(),		// Surrogates?											fork_name->dangerous_get_data());		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#else#pragma unused(fork_name)	return ERR_ERR;	// deleting forks on non-Mac systems not possible#endif}Err FSysObj::get_info(	uint32 which_info,								FSysInfo *out_info,								UniString *out_name,								FSysObj *out_parent) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		HFSUniStr255 unihfs;		Err err = OK;		if (out_parent && out_info) {					// want parent object?			which_info |= FSYS_INFO_PARENT_DIR_ID;	// here we can quickly check if parent is a volume!		}		OSErr oserr = FSGetCatalogInfo(	&ref,													which_info,													out_info ? &out_info->info : 0,													out_name ? &unihfs : 0,													0,			// FSSpec													out_parent ? &out_parent->ref : 0);		if (oserr == noErr) {			// if possible, cache the folder bit (to avoid another FSGetCatalogInfo call if user e.g. calls "is_folder" in future ...):			if (out_info && (which_info & FSYS_INFO_NODE_FLAGS) != 0) {				// node flags wanted?				if ((out_info->info.nodeFlags & kFSNodeIsDirectoryMask) != 0) {	// folder?					type_cache |= TYPE_FOLDER;								// folder					type_cache_mask |= TYPE_FOLDER;						// folder bit is valid now				} else if ((type_cache_mask & TYPE_ALIAS) == 0) {					// be sure that alias hasn't been resolved					// (can be alias to folder! Then is would here look like a file, but it isn't!)					type_cache &= ~(TYPE_FOLDER|TYPE_VOLUME);			// file					type_cache_mask |= (TYPE_FOLDER|TYPE_VOLUME);	// these bits are valid now (may possible change on is_alias()!)				}			}			if (out_parent) {				if (out_info) {					if (out_info->info.parentDirID == fsRtParID) {	// volume?						out_parent->type_cache = (TYPE_FOLDER|TYPE_VOLUME);	// we're sure it's a volume and so also a folder and no alias					} else {						out_parent->type_cache = TYPE_FOLDER;						// we're sure it's a folder but no volume and no alias					}					out_parent->type_cache_mask = (TYPE_FOLDER|TYPE_VOLUME|TYPE_ALIAS);	// all three bits are valid now				} else {					out_parent->type_cache = TYPE_FOLDER;							// we're only sure it's a folder and no alias					out_parent->type_cache_mask = (TYPE_FOLDER|TYPE_ALIAS);	// two bits are valid now				}			}			if (out_name) {				err = out_name->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));			}		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(which_info, out_info)// To do more ...	Err err = OK;	if (!path) {		return ERR_ERR;	}	if (out_name) {	// dangerous!!! (Multithreading!) :		size_t len = strlen(path);		boolean had_delimiter = (path[--len] == FSYS_PATH_DELIMITER);		if (had_delimiter) {			path[len] = 0;							// cut off delimiter (dangerous!!!)		}		char *begin = strrchr(path, FSYS_PATH_DELIMITER);		if (begin++ == 0) {			begin = path;		}		err.setErr(out_name->replace(begin));		if (had_delimiter) {			path[len] = FSYS_PATH_DELIMITER;	// restore delimiter		}	}	if (out_parent && err == OK) {		out_parent->dispose();		char *last_delimiter = strrchr(path, FSYS_PATH_DELIMITER);		if (last_delimiter) {			size_t len = (size_t)(last_delimiter - path + 1);			char *neu_path = (char *)malloc(len + 1);			if (!neu_path) {				err = ERR_OOM;			} else {				memcpy(neu_path, path, len);				neu_path[len] = 0;				out_parent->TOS_init_direct(neu_path, FALSE);			}		}	}	return err;#endif}Err FSysObj::get_name(UniString *out_name) {	return get_info(0, 0, out_name, 0);}Err FSysObj::get_path(UniString *out_path) {#if TARGET_MACOS	Err err = OK;	UniString name;	FSysInfo info;	FSysObj parent;// if we add FSYS_INFO_NODE_FLAGS, then is_folder() is faster afterwards!//	err = get_info(FSYS_INFO_PARENT_DIR_ID, &info, &name, &parent);	err = get_info(FSYS_INFO_PARENT_DIR_ID|FSYS_INFO_NODE_FLAGS, &info, &name, &parent);	if (err == OK) {		if (info.info.parentDirID != fsRtParID) {	// has parent?			err = parent.get_path(out_path);		} else {			out_path->clear();		}		if (err == OK) {			err = out_path->insert(&name);			if (err == OK && is_folder()) {	// is_folder is faster, when get_info previous get info for FSYS_INFO_NODE_FLAGS!				err = out_path->insert(&FSYS_PATH_DELIMITER, 2);			}		}	}	return err;#elif TARGET_TOS	if (!path) {		return ERR_ERR;	}	return out_path->replace(path);#endif}Err FSysObj::set_info(	uint32 which_info,								const FSysInfo *info) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSSetCatalogInfo(	&ref,													which_info,													&info->info);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(which_info, info)// To do ...	return ERR_ERR;#endif}Err FSysObj::get_volume_info(	uint32 which_info,										FSysVolumeInfo *out_info,										UniString *out_name,										FSysObj *out_volume) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		FSysInfo catinfo;		Err err = get_info(FSYS_INFO_VOLUME, &catinfo, 0, 0);		if (err == OK) {			HFSUniStr255 unihfs;			OSErr oserr = FSGetVolumeInfo(catinfo.info.volume,													0,				// index													0,				// actual FSVolumeRefNum													which_info,													out_info ? &out_info->info : 0,													out_name ? &unihfs : 0,													out_volume ? &out_volume->ref : 0);			if (oserr == noErr) {				if (out_volume) {					out_volume->type_cache = (TYPE_FOLDER|TYPE_VOLUME);	// sure that this is volume and so also folder					out_volume->type_cache_mask = (TYPE_FOLDER|TYPE_VOLUME|TYPE_ALIAS);	// all three bits are valid				}				if (out_name) {					err = out_name->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));				}				return err;			}			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(which_info, out_info, out_name, out_volume)// To do ...	return ERR_ERR;#endif}Err FSysObj::set_volume_info(	uint32 which_info,										const FSysVolumeInfo *info) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		FSysInfo catinfo;		Err err = get_info(FSYS_INFO_VOLUME, &catinfo, 0, 0);		if (err == OK) {			OSErr oserr = FSSetVolumeInfo(catinfo.info.volume,													which_info,													&info->info);			if (oserr != noErr) {				err.setOS(oserr);			}		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(which_info, info)// To do ...	return ERR_ERR;#endif}Err FSysObj::get_data_fork_name(UniString *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		HFSUniStr255 unihfs;		Err err = OK;		OSErr oserr = FSGetDataForkName(&unihfs);		if (oserr == noErr) {			err = out->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#else	out->clear();		// data fork has empty name on all non-Mac systems	return OK;#endif}Err FSysObj::get_resource_fork_name(UniString *out) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		HFSUniStr255 unihfs;		Err err = OK;		OSErr oserr = FSGetResourceForkName(&unihfs);		if (oserr == noErr) {			err = out->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#else#pragma unused(out)	return ERR_ERR;	// no resource fork on non-Mac systems#endif}Err FSysObj::set_type_and_creator(uint32 type, uint32 creator) {#if TARGET_MACOS	FSysInfo info;	Err err = get_info(FSYS_INFO_FINDER_INFO, &info, 0, 0);	if (err == OK) {		info.info.finderInfo[0] = (UInt8)(type >> 24);		info.info.finderInfo[1] = (UInt8)(type >> 16);		info.info.finderInfo[2] = (UInt8)(type >> 8);		info.info.finderInfo[3] = (UInt8)(type);		info.info.finderInfo[4] = (UInt8)(creator >> 24);		info.info.finderInfo[5] = (UInt8)(creator >> 16);		info.info.finderInfo[6] = (UInt8)(creator >> 8);		info.info.finderInfo[7] = (UInt8)(creator);		err = set_info(FSYS_INFO_FINDER_INFO, &info);	}	return err;#else#pragma unused(type, creator)	return OK;#endif}/*** FSysVolumeIterator *****************************************************************/Err FSysVolumeIterator::open() {#if TARGET_MACOS	index = 1;	return OK;#elif TARGET_TOS	volume_bitmask = (uint32)Dsetdrv(Dgetdrv());	index = 0;	return OK;#endif}Err FSysVolumeIterator::read(	FSysObj *out_volume,										uint32 which_info,										FSysVolumeInfo *out_info,										UniString *out_name) {#if TARGET_MACOS#if PPC	if (sysinfo.has_HFSPlus_APIs) {		HFSUniStr255 unihfs;		Err err = OK;		OSErr oserr = FSGetVolumeInfo(kFSInvalidVolumeRefNum,												index++,												0,				// actual FSVolumeRefNum												which_info,												out_info ? &out_info->info : 0,												out_name ? &unihfs : 0,												out_volume ? &out_volume->ref : 0);		if (oserr == noErr) {			if (out_volume) {				out_volume->type_cache = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);	// sure that this is volume and so also folder				out_volume->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME|FSysObj::TYPE_ALIAS);	// all three bits are valid			}			if (out_name) {				err = out_name->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));			}		} else if (oserr == nsvErr) {			err = ERR_FINISHED;		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(which_info, out_info)	Err err = OK;	uint32 index_mask = (((uint32)0x1) << index);	while (index < 32 && (volume_bitmask & index_mask) == 0) {		index++;		index_mask <<= 1;	}	if (index > 31) {		return ERR_FINISHED;	}	uint16 uni[2] = {(uint16)'A', (uint16)':'};	uni[0] = (uint16)'A' + index;	if (out_volume) {		err = out_volume->TOS_init_volume((char)uni[0]);	}	if (out_name) {		err.setErr(out_name->replace(uni, 4));	}	index++;	return OK;#endif}Err FSysVolumeIterator::close() {	return OK;}/*** FSysForkIterator *******************************************************************/FSysForkIterator::FSysForkIterator(FSysObj *obj) {	reset(obj);}Err FSysForkIterator::get_next(UniString *out_fork_name, uint64 *out_fork_size) {#if TARGET_MACOS && PPC	Err err;	HFSUniStr255 unihfs;	OSErr oserr = FSIterateForks(&obj->ref, &iterator, &unihfs, (SInt64 *)out_fork_size, 0);	if (oserr == noErr) {		if (out_fork_name) {			err = out_fork_name->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));		}	} else if (oserr == errFSNoMoreItems) {		err = ERR_FINISHED;	} else {		err.setOS(oserr);	}	return err;#else	if (got_it) {		return ERR_FINISHED;	}	if (out_fork_name) {		out_fork_name->clear();	}	if (out_fork_size) {		// To Do !!!!!!!!!!!!!!!!!!!!!!		return ERR_ERR;	}	got_it = TRUE;	return OK;#endif}Err FSysForkIterator::count(uint16 *out_count) {#if TARGET_MACOS	Err err;		reset(obj);	*out_count = 0;	while ((err = get_next(0)) == OK) {		(*out_count)++;	}	if (err == ERR_FINISHED) {		err = OK;	}	reset(obj);	return err;#else	*out_count = 1;	return OK;	// To Do: Mac OS without HFS+!!!#endif}void FSysForkIterator::reset(FSysObj *obj) {#if TARGET_MACOS && PPC	this->obj = obj;	iterator.initialize = 0;#else#pragma unused(obj)	got_it = FALSE;#endif}/*** FSysPosition ***********************************************************************/FSysPosition::FSysPosition() {	mode = FSYS_POS_AT_MARK;	offset = 0;}FSysPosition::FSysPosition(uint16 mode, int64 offset) {	set(mode, offset);}/*** FSysFork ***************************************************************************/FSysFork::FSysFork() {#if TARGET_MACOS	open_flag = FALSE;#elif TARGET_TOS	handle = -1;#endif}FSysFork::~FSysFork() {#if TARGET_MACOS	if (open_flag) {		close();	}#elif TARGET_TOS	if (handle >= 0) {		close();	}#endif}Err FSysFork::open_data_fork(FSysObj *obj, int8 permissions) {	UniString data_fork;	Err err = FSysObj::get_data_fork_name(&data_fork);	if (err == OK) {		err = open(obj, &data_fork, permissions);	}	return err;}Err FSysFork::open(FSysObj *obj, const UniString *fork_name, int8 permissions) {#if TARGET_MACOS	if (open_flag) {		Err err = close();		if (err != OK) {			return err;		}	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSOpenFork(	&obj->ref,											fork_name->get_length(),		// Surrogates?											fork_name->dangerous_get_data(),											permissions,											&ref);		if (oserr == noErr) {			open_flag = TRUE;		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (!obj->is_file() || fork_name->get_length() != 0) {		return ERR_ERR;	}	Err err = OK;	if (handle >= 0) {		err = close();		if (err != OK) {			return err;		}	}	int32 oserr;/* Oversized!	if (permissions == FSYS_PERM_CURRENT) {		XATTR xattr;		oserr = Fxattr(0, path, &xattr);		if ((oserr & DOPENDIR_ERROR) == DOPENDIR_ERROR) {			err.setOS(oserr);		} else {			// Pgetuid ... oversized!!!		}	}	if (err == OK) {		...*/	oserr = Fopen(obj->path, (int16)permissions);	if (oserr < 0) {		err.setOS(oserr);	} else {		handle = (int16)oserr;	}	return err;#endif}#if TARGET_TOSErr FSysFork::TOS_seek(const FSysPosition *pos) {	uint16 mode = (pos->get_mode() & FSYS_POS_MASK);	if (mode != FSYS_POS_AT_MARK && (pos->get_offset() < (int64)(int32)0x80000000L || pos->get_offset() > (int64)0x7FFFFFFFL)) {		return ERR_SEEK;	}	int32 offset = (int32)pos->get_offset();	int32 oserr = 0;	Err err = OK;	switch (mode) {	case FSYS_POS_AT_MARK:		return OK;	// nothing to do	case FSYS_POS_FROM_START:		oserr = Fseek(offset, handle, SEEK_SET);		break;	case FSYS_POS_FROM_END:		oserr = Fseek(offset, handle, SEEK_END);		break;	case FSYS_POS_FROM_MARK:		oserr = Fseek(offset, handle, SEEK_CUR);		break;	default:		err = ERR_SEEK;	}	if (oserr < 0) {		err.setOS(oserr);	}	return err;}#endifErr FSysFork::read(const FSysPosition *pos, void *buf, size_t size, size_t *out_size) {	if (out_size) {		*out_size = 0;	}#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSReadFork(	ref,											pos->get_mode(),											pos->get_offset(),											size,											buf,											out_size);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (handle < 0) {		return ERR_ERR;	}	Err err = TOS_seek(pos);	if (err == OK) {		size_t has_read = (size_t)Fread(handle, (int32)size, buf);		if (out_size) {			*out_size = has_read;		}		if (has_read != size) {			err = ERR_READ;		}	}	return err;#endif}Err FSysFork::write(const FSysPosition *pos, const void *buf, size_t size, size_t *out_size) {	if (out_size) {		*out_size = 0;	}#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSWriteFork(	ref,											pos->get_mode(),											pos->get_offset(),											size,											buf,											out_size);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (handle < 0) {		return ERR_ERR;	}	Err err = TOS_seek(pos);	if (err == OK) {		size_t written = (size_t)Fwrite(handle, (int32)size, buf);		if (out_size) {			*out_size = written;		}		if (written != size) {			err = ERR_WRITE;		}	}	return err;#endif}Err FSysFork::get_position(uint64 *out) {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSGetForkPosition(	ref,													(SInt64 *)out);	// :-( (Mac-API must be "UInt64 *")		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (handle < 0) {		return ERR_ERR;	}	Err err = OK;	int32 oserr = Fseek(0, handle, SEEK_CUR);	if (oserr < 0) {		err.setOS(oserr);	} else {		*out = (uint64)oserr;	}	return err;#endif}Err FSysFork::set_position(const FSysPosition *pos) {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSSetForkPosition(ref, pos->get_mode(), pos->get_offset());		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	return TOS_seek(pos);#endif}Err FSysFork::get_size(uint64 *out) {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSGetForkSize(	ref,												(SInt64 *)out);	// :-( (Mac-API must be "UInt64 *")		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (handle < 0) {		return ERR_ERR;	}	Err err = OK;	XATTR attr;	int32 oserr = Fcntl(handle, (int32)&attr, FSTAT);	if (oserr == 0) {		*out = (uint64)attr.size;	} else {		int32 oldpos = Fseek(0, handle, SEEK_CUR);		if (oldpos < 0) {			err.setOS(oldpos);		} else {			int32 len = Fseek(0, handle, SEEK_END);			if (len < 0) {				err.setOS(len);			} else {				if (len != oldpos) {					Fseek(oldpos, handle, SEEK_SET);				}				*out = (uint64)len;			}		}	}	return err;#endif}Err FSysFork::set_size(const FSysPosition *pos) {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSSetForkSize(ref, pos->get_mode(), pos->get_offset());		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS#pragma unused(pos)// To do ...	return ERR_ERR;#endif}Err FSysFork::flush() {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSFlushFork(ref);		if (oserr != noErr) {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS// To do ...	return ERR_ERR;#endif}Err FSysFork::close() {#if TARGET_MACOS	if (!open_flag) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSCloseFork(ref);		if (oserr == noErr) {			open_flag = FALSE;		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	if (handle < 0) {		return ERR_ERR;	}	Err err = OK;	int16 oserr = Fclose(handle);	if (oserr != E_OK) {		err.setOS(oserr);	}	handle = -1;	return err;#endif}/*** FSysSearchParams *******************************************************************//*** FSysIterator ***********************************************************************/FSysIterator::FSysIterator() {#if TARGET_MACOS	ref = 0;#elif TARGET_TOS	dir = DOPENDIR_ERROR;	path = 0;#endif}FSysIterator::~FSysIterator() {#if TARGET_MACOS	if (ref) {		close();	}#elif TARGET_TOS	close();#endif}#if TARGET_TOSErr FSysIterator::TOS_open_without_subtree_killing(FSysObj *container, uint32 flags) {	TOS_close_without_subtree_killing();	if (!container->is_folder()) {		return ERR_ERR;	}	subtree_flag = (flags == FSYS_ITER_SUBTREE);	size_t len = strlen(container->path) + 1;	path = (char *)malloc(len);	if (!path) {		return ERR_OOM;	}	memcpy(path, container->path, len);	dir = Dopendir(container->path, 0);	if ((dir & DOPENDIR_ERROR) == DOPENDIR_ERROR) {		free(path);		path = 0;		return ERR_ERR;	}	return OK;}#endifErr FSysIterator::open(FSysObj *container, uint32 flags) {#if TARGET_MACOS	if (ref) {		Err err = close();		if (err != OK) {			return err;		}	}	finished = FALSE;#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSOpenIterator(&container->ref, flags, &ref);		if (oserr != noErr) {			ref = 0;			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	close();	// kills subtree	return TOS_open_without_subtree_killing(container, flags);#endif}Err FSysIterator::read(	uint32 count,								uint32 *out_count,														boolean *changed_flag,								uint32 which_info,								FSysInfo *out_info_array[],								FSysObj *out_obj_array[],								UniString *out_name_array[]) {#if TARGET_MACOS	if (finished) {		return ERR_FINISHED;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr;		Boolean os_changed;		*out_count = 0;			while (count && err == OK) {			uint32 actual_count = count;			FSCatalogInfo *actual_info_array = 0;			FSRef *actual_ref_array = 0;			HFSUniStr255 *actual_name_array = 0;			while (actual_count > 1) {				if (out_info_array) {					actual_info_array = (FSCatalogInfo *)malloc(actual_count * sizeof(FSCatalogInfo));					if (!actual_info_array) {						actual_count >>= 1;						continue;					}				}				if (out_obj_array) {					actual_ref_array = (FSRef *)malloc(actual_count * sizeof(FSRef));					if (!actual_ref_array) {						if (actual_info_array) {							free(actual_info_array);							actual_info_array = 0;						}						actual_count >>= 1;						continue;					}				}				if (out_name_array) {					actual_name_array = (HFSUniStr255 *)malloc(actual_count * sizeof(HFSUniStr255));					if (!actual_name_array) {						if (actual_ref_array) {							free(actual_ref_array);							actual_ref_array = 0;						}						if (actual_info_array) {							free(actual_info_array);							actual_info_array = 0;						}						actual_count >>= 1;						continue;					}				}				break;	// got memory!			}			if (actual_count == 1) {				HFSUniStr255 unihfs;				oserr = FSGetCatalogInfoBulk(	ref,														1,														&actual_count,														&os_changed,														which_info,														out_info_array ? &out_info_array[0]->info : 0,														out_obj_array ? &out_obj_array[0]->ref : 0,														0,		// FSSpec														out_name_array ? &unihfs : 0);				if (oserr == noErr || oserr == errFSNoMoreItems) {					if (oserr == errFSNoMoreItems) {						err = ERR_FINISHED;					}					if (actual_count) {						if (out_obj_array) {							if (out_info_array && (which_info & FSYS_INFO_NODE_FLAGS) != 0) {	// got info about file or folder?								if (out_info_array[0]->info.nodeFlags & kFSNodeIsDirectoryMask) {		// folder									(*out_obj_array)->type_cache = FSysObj::TYPE_FOLDER;									(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);								} else {																					// file									(*out_obj_array)->type_cache = 0;									(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);								}							} else {								(*out_obj_array)->type_cache = 0;								(*out_obj_array)->type_cache_mask = FSysObj::TYPE_VOLUME;							}							out_obj_array++;						}						if (out_info_array) {							out_info_array++;						}						if (out_name_array) {							Err name_err = (*out_name_array++)->replace(unihfs.unicode, (size_t)(unihfs.length + unihfs.length));							if (name_err != OK) {								err = name_err;							}						}					}				} else {					err.setOS(oserr);				}			} else {				oserr = FSGetCatalogInfoBulk(	ref,														actual_count,														&actual_count,														&os_changed,														which_info,														actual_info_array,														actual_ref_array,														0,		// FSSpec														actual_name_array);				if (oserr == noErr || oserr == errFSNoMoreItems) {					if (oserr == errFSNoMoreItems) {						err = ERR_FINISHED;					}					for (uint32 i = 0; i < actual_count; i++) {						if (actual_ref_array) {							(*out_obj_array)->ref = actual_ref_array[i];							if (actual_info_array && (which_info & FSYS_INFO_NODE_FLAGS) != 0) {	// got info about file or folder?								if (actual_info_array[i].nodeFlags & kFSNodeIsDirectoryMask) {		// folder									(*out_obj_array)->type_cache = FSysObj::TYPE_FOLDER;									(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);								} else {																				// file									(*out_obj_array)->type_cache = 0;									(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);								}							} else {								(*out_obj_array)->type_cache = 0;								(*out_obj_array)->type_cache_mask = FSysObj::TYPE_VOLUME;							}							out_obj_array++;						}						if (actual_info_array) {							(*out_info_array++)->info = actual_info_array[i];						}						if (actual_name_array) {							Err name_err = (*out_name_array++)->replace(actual_name_array[i].unicode, (size_t)(actual_name_array[i].length + actual_name_array[i].length));							if (name_err != OK) {								err = name_err;							}						}					}				} else {					err.setOS(oserr);				}				if (actual_name_array) {					free(actual_name_array);				}				if (actual_ref_array) {					free(actual_ref_array);				}				if (actual_info_array) {					free(actual_info_array);				}			}			*out_count += actual_count;			if (changed_flag && os_changed) {				*changed_flag = TRUE;			}			count -= actual_count;		}		if (err == ERR_FINISHED && *out_count) {			err = OK;	// don't give an error if we HAVE items			finished = TRUE;	// frs nchste mal merken (Systemaufruf sparen)		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	Err err = OK;	uint32 got = 0;	while (got < count && err == OK) {		err = read(changed_flag,						which_info,						*out_info_array++,						*out_obj_array++,						*out_name_array++);		if (err == OK) {			got++;		}	}	*out_count = got;	return err;#endif}Err FSysIterator::read(	uint32 count,								void *help_buffer,								uint32 *out_count,														boolean *changed_flag,								uint32 which_info,								FSysInfo *out_info_array[],								FSysObj *out_obj_array[],								UniString *out_name_array[]) {#if TARGET_MACOS	if (finished) {		return ERR_FINISHED;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr;		Boolean os_changed;		uint32 got_count = 0;		FSCatalogInfo *actual_info_array = (FSCatalogInfo *)help_buffer;		FSRef *actual_ref_array = (FSRef *)(actual_info_array + count);		HFSUniStr255 *actual_name_array = (HFSUniStr255 *)(actual_ref_array + count);		if (!out_info_array) {			actual_info_array = 0;		}		if (!out_obj_array) {			actual_ref_array = 0;		}		if (!out_name_array) {			actual_name_array = 0;		}		*out_count = 0;			oserr = FSGetCatalogInfoBulk(	ref,												count,												&got_count,												&os_changed,												which_info,												actual_info_array,												actual_ref_array,												0,		// FSSpec												actual_name_array);		if (oserr == noErr || oserr == errFSNoMoreItems) {			if (oserr == errFSNoMoreItems) {				err = ERR_FINISHED;			}			for (uint32 i = 0; i < got_count; i++) {				if (actual_ref_array) {					(*out_obj_array)->ref = actual_ref_array[i];					if (actual_info_array && (which_info & FSYS_INFO_NODE_FLAGS) != 0) {	// got info about file or folder?						if (actual_info_array[i].nodeFlags & kFSNodeIsDirectoryMask) {		// folder							(*out_obj_array)->type_cache = FSysObj::TYPE_FOLDER;							(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);						} else {																				// file							(*out_obj_array)->type_cache = 0;							(*out_obj_array)->type_cache_mask = (FSysObj::TYPE_FOLDER|FSysObj::TYPE_VOLUME);						}					} else {						(*out_obj_array)->type_cache = 0;						(*out_obj_array)->type_cache_mask = FSysObj::TYPE_VOLUME;					}					out_obj_array++;				}				if (actual_info_array) {					(*out_info_array++)->info = actual_info_array[i];				}				if (actual_name_array) {					Err name_err = (*out_name_array++)->replace(actual_name_array[i].unicode, (size_t)(actual_name_array[i].length + actual_name_array[i].length));					if (name_err != OK) {						err = name_err;					}				}			}		} else {			err.setOS(oserr);		}		*out_count = got_count;		if (changed_flag && os_changed) {			*changed_flag = TRUE;		}		if (err == ERR_FINISHED && got_count) {			err = OK;	// don't give an error if we HAVE items			finished = TRUE;	// frs nchste mal merken (Systemaufruf sparen)		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#else#pragma unused(help_buffer)	return read(count, out_count, changed_flag, which_info, out_info_array, out_obj_array, out_name_array);#endif}Err FSysIterator::read(	boolean *changed_flag,								uint32 which_info,								FSysInfo *out_info,								FSysObj *out_obj,								UniString *out_name) {#if TARGET_MACOS	if (finished) {		return ERR_FINISHED;	}	uint32 out_count_dummy;	return read(1,					&out_count_dummy,					changed_flag,					which_info,					out_info ? &out_info : 0,					out_obj ? &out_obj : 0,					out_name ? &out_name : 0);#elif TARGET_TOS#pragma unused(which_info, out_info)	if ((dir & DOPENDIR_ERROR) == DOPENDIR_ERROR) {		return ERR_ERR;	}	if (changed_flag) {		*changed_flag = FALSE;	// never TRUE in TOS	}	Err err = OK;	char buf[260];	char *name = buf + 4;	XATTR xattr;	int32 xret;	int32 oserr;	do {		oserr = Dxreaddir(260, dir, buf, &xattr, &xret);	} while (oserr == OK && name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0)));	// filter "." and ".."	if (oserr == E_OK) {		size_t len = strlen(name);		if (name[len - 1] == FSYS_PATH_DELIMITER) {			name[--len] = 0;		}		size_t pathlen = strlen(path);		char *neu_path = (char *)malloc(pathlen + len + 2);		if (!neu_path) {			return ERR_OOM;		}		memcpy(neu_path, path, pathlen);		memcpy(neu_path + pathlen, name, len + 1);		boolean folder_flag = FALSE;		boolean alias_flag = ((xattr.mode & S_IFMT) == S_IFLNK);		if (alias_flag) {			XATTR orig_xattr;			oserr = Fxattr(0, neu_path, &orig_xattr);			if ((oserr & DOPENDIR_ERROR) == DOPENDIR_ERROR) {				err.setOS(oserr);			} else {				folder_flag = ((orig_xattr.mode & S_IFMT) == S_IFDIR);			}		} else {			folder_flag = ((xattr.mode & S_IFMT) == S_IFDIR);		}		if (err == OK) {			if (out_name) {				err = out_name->replace(name);			}			if (err == OK && out_obj) {				if (folder_flag) {					len += pathlen;					if (neu_path[len - 1] != FSYS_PATH_DELIMITER) {						neu_path[len++] = FSYS_PATH_DELIMITER;						neu_path[len] = 0;					}				}				out_obj->dispose();				out_obj->TOS_init_direct(neu_path, alias_flag);			} else {				free(neu_path);			}		} else {			free(neu_path);		}	} else if (oserr == ENMFIL) {		err = ERR_FINISHED;	} else {		err.setOS(oserr);	}	if (subtree_flag) {		FSysObjLink *link;		if (err == ERR_FINISHED) {			link = subtree_folder_list.get_first();			if (link) {				subtree_folder_list.remove(link);				err = TOS_open_without_subtree_killing(link, FSYS_ITER_SUBTREE);				delete link;				if (err == OK) {					err = read(changed_flag, which_info, out_info, out_obj, out_name);				}			}		} else if (err == OK && out_obj->is_folder() && !out_obj->is_alias()) {			link = new FSysObjLink();			if (!link) {				err = ERR_OOM;			} else {				err = link->init(out_obj);	// make a copy of the folder				if (err == OK) {					subtree_folder_list.insert(link);				} else {					delete link;				}			}		}	}	return err;#endif}#if TARGET_TOSErr FSysIterator::TOS_close_without_subtree_killing() {	if (path) {		free(path);		path = 0;	}	if ((dir & DOPENDIR_ERROR) == DOPENDIR_ERROR) {		return ERR_ERR;	}	Err err = (Dclosedir(dir) == 0) ? OK : ERR_ERR;	dir = DOPENDIR_ERROR;	return err;}#endifErr FSysIterator::close() {#if TARGET_MACOS	if (!ref) {		return ERR_ERR;	}#if PPC	if (sysinfo.has_HFSPlus_APIs) {		Err err = OK;		OSErr oserr = FSCloseIterator(ref);		if (oserr == noErr) {			ref = 0;		} else {			err.setOS(oserr);		}		return err;	}#endif	// "68k" or "PPC without HFSPlus-APIs":	return ERR_ERR;#elif TARGET_TOS	subtree_folder_list.empty_with_killing();	return TOS_close_without_subtree_killing();#endif}