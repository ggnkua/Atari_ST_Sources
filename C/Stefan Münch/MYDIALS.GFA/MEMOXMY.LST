' XRSRC-/MyDial-Routinen fÅr GFA-Basic, Stefan MÅnch Dez.1992/Jan.93
' Adresse: Stefan MÅnch, Ostenbergstr. 109/129, DW-4600 Dortmund 50
'          E-Mail: Stefan Muench @ UN (Mausnet)
'                  Stefan Muench on 2:245/52.3 (Fidonet)
'
' XRSRC-Routinen-Version:  1.0   6.1.93
' MyDial-Routinen-Version: 1.0   6.1.93
' Demo-Version:            0.54  14.1.93
'
' Une petite demo:
'
RESERVE 500000
'
ON ERROR GOSUB global_exit
ON BREAK GOSUB global_exit
DEFMOUSE 0
KEYPAD 0                    ! Compatibilite wg (ParamËtres clavier standards)
'
init_xrsrc("XRSRC.OVL",TRUE) !  TRUE: il faut les routines XRSRC, car le RSC
'                               a un format Long et utilise des icones couleur
'                               (voir le commentaire de xrsrc_load())
init_mydial("MYDIAL.OVL",0,0,1) ! 1, pour permettre des Grow/Shrink
init_hnumbers
init_rsc("DEMOXRMD.RSC")
'
ON MENU GOSUB menu_event
ON MENU KEY GOSUB key_event
'
DO
  ON MENU 100
LOOP
'
> PROCEDURE menu_event
  menu_evaluation(MENU(4),MENU(5))
RETURN
> PROCEDURE menu_evaluation(menutitle&,menuitem&)
  LOCAL ok!,button&,tree%
  IF menuitem&=h_menu_info&
    ~@handle_dialog(@treeaddress(h_pinfo&),h_pinfo&,0,gv_grow_shrink!,0,0,0,0,ok!)
  ENDIF
  IF menuitem&=h_menu_ende&
    IF gv_ask_quit!
      IF 1=@my_dial_alert(0,"[2][Voulez-vous reellement|quitter ?][[Oui|[Non]",1,2,CHR$(1))
        global_exit
      ENDIF
    ELSE
      global_exit
    ENDIF
  ENDIF
  IF menuitem&=h_menu_dialog&
    tree%=@treeaddress(h_dltest&)
    button&=@handle_dialog(tree%,h_dltest&,0,gv_grow_shrink!,0,0,0,0,ok!)
  ENDIF
  IF menuitem&=h_menu_einstellung&
    tree%=@treeaddress(h_options&)
    select(tree%,h_opti_growshrink&,gv_grow_shrink!)
    select(tree%,h_opti_endefragen&,gv_ask_quit!)
    button&=@handle_dialog(tree%,h_options&,0,gv_grow_shrink!,0,0,0,0,ok!)
    IF button&=h_opti_ok&
      gv_grow_shrink!=@selected(tree%,h_opti_growshrink&)
      gv_ask_quit!=@selected(tree%,h_opti_endefragen&)
    ENDIF
  ENDIF
  '
  ~MENU_TNORMAL(gc_menutree%,menutitle&,1)
RETURN
> PROCEDURE key_event
  LOCAL ks&,kr&
  LOCAL title&,item&
  LOCAL ascii&,nkcc&
  '
  ks&=MENU(13)
  kr&=MENU(14)
  '
  IF @my_my_menu_key(gc_menutree%,ks&,kr&,title&,item&)
    ~MENU_TNORMAL(gc_menutree%,title&,0)
    menu_evaluation(title&,item&)
  ELSE
    nkcc&=@my_normkey(ks&,kr&)
    ascii&=WORD(BYTE(nkcc&))
    ' gestion des codes clavier n'appartenant pas au menu
    ' z.B. if nkcc&=1 and ascii&=4 then do_what_you_want
    PRINT AT(1,10);"Touche pressÈe : nkcc&=";nkcc&;", ascii&=";ascii&;"        "
  ENDIF
RETURN
'
> FUNCTION handle_dialog(tree%,tree&,defedit&,grow_shrink!,x&,y&,w&,h&,VAR ok!)
LOCAL dialinfo$,exitbutton&,helptree%
'
~WIND_UPDATE(1)
ok!=@my_open_dial(tree%,grow_shrink!,x&,y&,w&,h&,dialinfo$)
~@my_dial_draw(dialinfo$)
REPEAT
  exitbutton&=@my_dial_do(defedit&,dialinfo$)
  IF @touchexit(tree%,exitbutton&)
    @touchexit_evaluation(tree&,exitbutton&)
    IF @selected(tree%,exitbutton&)
      select(tree%,exitbutton&,FALSE)
      IF OB_HEAD(tree%,exitbutton&)=-1  ! keine Kinder
        helptree%=tree%
      ELSE
        helptree%=@treeaddress(exitbutton&)
      ENDIF
      ~OBJC_DRAW(helptree%,exitbutton&,8,0,0,0,0)
    ENDIF
  ENDIF
UNTIL NOT @touchexit(tree%,exitbutton&)
~@my_close_dial(grow_shrink!,x&,y&,w&,h&,dialinfo$)
~WIND_UPDATE(0)
select(tree%,exitbutton&,FALSE)
RETURN exitbutton&
ENDFUNC
> PROCEDURE touchexit_evaluation(tree&,obj&)
LOCAL ok!
ok!=TRUE
SELECT tree&
CASE h_dltest&
  SELECT obj&
  CASE h_dlte_help&
    ~@handle_dialog(@treeaddress(h_pinfo&),h_pinfo&,0,gv_grow_shrink!,0,0,0,0,ok!)
  CASE h_dlte_popup&
    ~@my_popup_select(@treeaddress(h_dltest&),h_dlte_popup&,@treeaddress(h_popup&),h_dlte_popbox&,TRUE,0,ok!)
  CASE h_dlte_circle&
    ~@my_popup_select(@treeaddress(h_dltest&),h_dlte_popup&,@treeaddress(h_popup&),h_dlte_popbox&,FALSE,-2,ok!)
  ENDSELECT
ENDSELECT
IF NOT ok!
  ~OBJC_DRAW(@treeaddress(tree&),1,8,0,0,0,0)
ENDIF
RETURN
'
> PROCEDURE main_exit
' Desactiver les menus (tres, tres important)
~MENU_BAR(gc_menutree%,0)
RETURN
> PROCEDURE init_rsc(rscfile$)
'
' exporte   : gc_menutree% (adresse de l'arbre menu)
'             gv_grow_shrink! (dessiner Grow/Shrink ?)
'             gv_ask_quit! (demander a la fin du programme?)
'
IF 0=@xrsrc_load(rscfile$)  ! erreur
  ~FORM_ALERT(1,"[3][|"+rscfile$+@fnf_or_ner$)
  global_exit
ENDIF
'
' Installation et affichage du menu :
gc_menutree%=@treeaddress(h_menu&)
~@my_dial_fix(gc_menutree%,FALSE)  ! False: pas d'arbre dialogue
~MENU_BAR(gc_menutree%,1)
'
' Fix et centrage pour les autres arbres :
~@my_dial_fix(@treeaddress(h_pinfo&),TRUE)
~@my_dial_center(@treeaddress(h_pinfo&))
~@my_dial_fix(@treeaddress(h_dltest&),TRUE)
~@my_dial_center(@treeaddress(h_dltest&))
~@my_dial_fix(@treeaddress(h_options&),TRUE)
~@my_dial_center(@treeaddress(h_options&))
~@my_dial_fix(@treeaddress(h_popup&),TRUE)
~@my_dial_center(@treeaddress(h_popup&))
'
' prÈparer les options pour le RSC:
gv_grow_shrink!=@selected(@treeaddress(h_options&),h_opti_growshrink&)
gv_ask_quit!=@selected(@treeaddress(h_options&),h_opti_endefragen&)
'
'  ~@my_get_sysfnt(V~H,font_id&,gl_point&,gl_wchar&,gl_hchar&)
RETURN
> PROCEDURE init_hnumbers
LET h_menu&=0   ! arbre Menu
LET h_menu_info&=9   !  STRING in Baum MENU
LET h_menu_ende&=18  !  STRING in Baum MENU
LET h_menu_dialog&=20  !  STRING in Baum MENU
LET h_menu_einstellung&=22  !  STRING in Baum MENU
LET h_pinfo&=1   ! Formular/Dialog
LET h_dltest&=2   ! Formular/Dialog
LET h_dlte_check&=3   !  BUTTON in Baum DLTEST
LET h_dlte_radio1&=5   !  BUTTON in Baum DLTEST
LET h_dlte_radio2&=6   !  BUTTON in Baum DLTEST
LET h_dlte_name&=7   !  FTEXT in Baum DLTEST
LET h_dlte_help&=8   !  BOXTEXT in Baum DLTEST
LET h_dlte_abbruch&=9   !  BUTTON in Baum DLTEST
LET h_dlte_ok&=10  !  BUTTON in Baum DLTEST
LET h_dlte_popup&=11  !  BOXTEXT in Baum DLTEST
LET h_dlte_circle&=12  !  BOXCHAR in Baum DLTEST
LET h_dlte_icon&=13  !  USERDEF in Baum DLTEST
LET h_options&=3   ! Formular/Dialog
LET h_opti_abbruch&=1   !  BUTTON in Baum OPTIONS
LET h_opti_ok&=2   !  BUTTON in Baum OPTIONS
LET h_opti_growshrink&=4   !  BUTTON in Baum OPTIONS
LET h_opti_endefragen&=6   !  BUTTON in Baum OPTIONS
LET h_popup&=4   ! Formular/Dialog
LET h_dlte_popbox&=1   !  BOX in Baum POPUP
RETURN
'
> FUNCTION treeaddress(tree&)
LOCAL address%
~@xrsrc_gaddr(0,tree&,address%)
RETURN address%
ENDFUNC
> PROCEDURE select(tree%,obj&,bool!)
IF bool!
OB_STATE(tree%,obj&)=BSET(OB_STATE(tree%,obj&),0)
ELSE
OB_STATE(tree%,obj&)=BCLR(OB_STATE(tree%,obj&),0)
ENDIF
RETURN
DEFFN selected(tree%,obj&)=BTST(OB_STATE(tree%,obj&),0)
DEFFN touchexit(tree%,obj&)=BTST(OB_FLAGS(tree%,obj&),6)
'
'
' ************************************************************************
' **   Routines utiles pour XRSRC et Mydial                             **
' ************************************************************************
DEFFN fnf_or_ner$=" manquant|ou mÈmoire insuffisante.|Programme termine.][OK]"
' fnf_or_ner: '<F>ile <n>ot <f>ound <or> <n>ot <e>nough <R>AM'
' necessaire pour : init_xrsrc(), init_mydial()
'
> FUNCTION compiled
$F% ! 3.1.93 sm
' necesaire   : -
' utilise par : init_xrsrc(), init_mydial()
' Valeur de retour : BOOLEAN (TRUE, si compile, sinon FALSE)
RETURN (BYTE{BASEPAGE+256}<>96)   ! s. ST-Computer 9/91
ENDFUNC
> PROCEDURE global_exit
' necessaire pour: init_xrsrc(), init_mydial()
'
' ici on libere la memoire :
main_exit
'
' ces actions sont importantes, ne pas effacer:
~@xrsrc_free    ! Libere le RSC
exit_mydial     ! Termine les routines MyDial
exit_xrsrc      ! Termine les routines Xrsrc
' Eventuellement inclure d'autres actions qui sont ont ete executee
' avant les routines XRSRC ou/et MyDial
RESERVE         ! Annuler Reserve
END             ! Et tchao
RETURN
'
' ************************************************************************
' **                        XRSRC-Routinen                              **
' ************************************************************************
> PROCEDURE init_xrsrc(file$,essential!)  ! Initialisation de la routine, n'appeler qu'une fois au debut
LOCAL base%,empty$,dummy%
LOCAL scalc%,init%,resident!
'
resident!=FALSE
@xrsrc_global_var(0,scalc%,init%,resident!)
'
empty$=STRING$(100,0)
'
IF NOT @compiled  ! aussi dans l'Interpreteur
IF LONG{BASEPAGE+180}=&H58525343  ! extension "XRSC"
scalc%=LONG{BASEPAGE+184}       ! _en dessous_ de la DTA, pas de panique !!
init%=LONG{BASEPAGE+188}
resident!=TRUE
WORD{init%+4+36}=128          ! Numero d'init
$C+
dummy%=C:scalc%()
$C-
@xrsrc_global_var(0,scalc%,init%,resident!)
GOTO end_init_xrsrc
ENDIF
ENDIF
IF SHEL_FIND(file$)
file$=file$+CHR$(0)
base%=GEMDOS(75,3,L:V:file$,L:V:empty$,L:V:empty$)
'
IF base%>=0
init%={base%+8}
dummy%=0
{init%+4}=V:empty$
$C+
dummy%=C:init%(L:base%)
$C-
IF dummy%=0
  scalc%={init%+42}
  WORD{init%+4+36}=128          ! Numero d'init
  $C+
  dummy%=C:scalc%()
  $C-
  IF dummy%=1
    resident!=TRUE
    @xrsrc_global_var(0,scalc%,init%,resident!)
    IF NOT @compiled
      LONG{BASEPAGE+180}=&H58525343
      LONG{BASEPAGE+184}=scalc%
      LONG{BASEPAGE+188}=init%
    ENDIF
  ENDIF
ENDIF
ENDIF
ENDIF !if shel_find...
IF NOT resident!
IF essential!
~FORM_ALERT(1,"[3][|"+file$+@fnf_or_ner$)
global_exit
ENDIF
ENDIF
end_init_xrsrc:
RETURN
> PROCEDURE exit_xrsrc  ! Deinitialisation des routines, n'appeler qu'une fois a la fin
LOCAL scalc%,init%,resident!
@xrsrc_global_var(1,scalc%,init%,resident!)
IF resident!
WORD{init%+4+36}=129          ! Numero de la fontion
$C+
~C:scalc%()
$C-
resident!=FALSE
ENDIF
RETURN
> PROCEDURE xrsrc_global_var(cmd&,VAR scalc%,init%,resident!)
' La procedure essaye de 'cacher' les variables globales des
' routines XRSRC. Si cmd&=1 alors lecture, sinon ecriture.
LOCAL xrgvadr%
INLINE xrgvadr%,9
IF cmd&=1 !Lesen
scalc%=LONG{xrgvadr%}
init%=LONG{xrgvadr%+4}
resident!=BYTE{xrgvadr%+8}
ELSE
LONG{xrgvadr%}=scalc%
LONG{xrgvadr%+4}=init%
BYTE{xrgvadr%+8}=ABS(resident!)
ENDIF
RETURN
'
> FUNCTION xrsrc_free
$F%
' Valeur de retour: WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=2          ! Numero de la fonction
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_FREE()
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_gaddr(re_gtype&,re_gindex&,VAR re_gaddr%)
$F%
' Valeur de retour: WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=3          ! Numero de la fonction
WORD{init%+4+0}=re_gtype&
WORD{init%+4+2}=re_gindex&
{init%+4+16}=V:re_gaddr%
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_GADDR(re_gtype&,re_gindex&,re_gaddr%)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_load(file$)
$F%
' Valeur de retour: WORD
'
' Sur ma demande (SM) pour xrsrc_load(), Olaf Meisiek a repondu ceci :
' SM> est-ce que xrsrc_load() verifie l'en-tete du fichier RSC (format Long
' SM> ou normal du RSC) ?
' Oui. xrsrc_load charge les ressources Longs et normaux, avec et sans icones
' couleur. Il n'y a pourtant aucune faÁon de le verifier. S'il s'agit d'un
' ressource normal, son en-tete sera transforme en en-tete Long.
' SM> Que fait-il encore ? vr_trnfm() des icones, Images etc., ou pas
' SM>(=Original) ?
' vr_trnfm sera execute pour chaque structure d'icone couleur (CICON *). Les
' structures normales ICONBLK restent, pour des questions de compatibilite, inchangees.
' on doit donc manuellement appeler vr_trnfm pour les transformer.
' Cela est aussi valable pour les structures ICONBLK avec une icone couleur.
'
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
file$=file$+CHR$(0)
WORD{init%+4+36}=1          ! Numero de la fonction
{init%+4+16}=V:file$
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_LOAD(file$)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_obfix(re_gaddr%,re_obj&)
$F%
' Valeur de retour : WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=5          ! Numero de la fonction
WORD{init%+4+0}=re_obj&
{init%+4+16}=re_gaddr%
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_OBFIX(re_gaddr%,re_obj&)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION xrsrc_saddr(re_gtype&,re_gindex&,VAR re_gaddr%)
$F%
' Valeur de retour : WORD
LOCAL scalc%,init%,resident!,r&
@xrsrc_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=4          ! Numero de la fonction
WORD{init%+4+0}=re_gtype&
WORD{init%+4+2}=re_gindex&
{init%+4+16}=V:re_gaddr%
$C+
r&=C:scalc%()
$C-
ELSE
r&=RSRC_SADDR(re_gtype&,re_gindex&,re_gaddr%)
ENDIF
RETURN r&
ENDFUNC
'
' ************************************************************************
' **                        MYDIAL-Routines                             **
' ************************************************************************
> PROCEDURE init_mydial(file$,mnum&,mform%,gs&) ! Initialisation des routines, n'appeler qu'une seule fois au debut
LOCAL empty$,base%,dummy%,im_adr%
LOCAL scalc%,init%,resident!
'
resident!=FALSE
@mydial_global_var(0,scalc%,init%,resident!)
'
INLINE im_adr%,10
WORD{im_adr%}=mnum&
LONG{im_adr%+2}=mform%
WORD{im_adr%+6}=gs&
'
empty$=STRING$(100,0)
'
IF NOT @compiled  ! aussi dans l'interpreteur
IF LONG{BASEPAGE+192}=&H4D59444C ! Extension "MYDL"
scalc%=LONG{BASEPAGE+196}       ! _ en dessous_ de la DTA, Pas de panique !!
init%=LONG{BASEPAGE+200}
resident!=TRUE
@mydial_global_var(0,scalc%,init%,resident!)
{init%+4+24}=im_adr%
{init%+4+28}=im_adr%+2
{init%+4+32}=im_adr%+6
GOTO end_init_mydial
ENDIF
ENDIF
IF SHEL_FIND(file$)
file$=file$+CHR$(0)
base%=GEMDOS(75,3,L:V:file$,L:V:empty$,L:V:empty$)
'
IF base%>=0
init%={base%+8}
dummy%=0
{init%+4}=V:empty$
$C+
dummy%=C:init%(L:base%)
$C-
IF dummy%=0
scalc%={init%+42}
' ~@my_nkcc_init
WORD{init%+4+36}=128          ! Numero de fonction
$C+
~C:scalc%()
$C-
' my_dial_init
WORD{init%+4+36}=31           ! Numero de fonction
{init%+4+24}=im_adr%
{init%+4+28}=im_adr%+2
{init%+4+32}=im_adr%+6
$C+
dummy%=C:scalc%()
$C-
IF dummy%<>0
resident!=TRUE
@mydial_global_var(0,scalc%,init%,resident!)
IF NOT @compiled
LONG{BASEPAGE+192}=&H4D59444C
LONG{BASEPAGE+196}=scalc%
LONG{BASEPAGE+200}=init%
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF !if shel_find...
IF resident!=FALSE
~FORM_ALERT(1,"[3][|"+file$+@fnf_or_ner$)
global_exit
ENDIF
end_init_mydial:
RETURN
> PROCEDURE exit_mydial ! Deinitialisation des routines, n'appeler qu'une fois a la fin.
LOCAL scalc%,init%,resident!
@mydial_global_var(0,scalc%,init%,resident!)
IF resident!
' ~@my_dial_exit  ! termine les routines MyDial
WORD{init%+4+36}=32          ! Numero de fonction
$C+
~C:scalc%()
$C-
' ~@my_nkcc_exit  ! Termine les routines NKCC
WORD{init%+4+36}=129          ! Numero de fonction
$C+
~C:scalc%()
$C-
ENDIF
RETURN
> PROCEDURE mydial_global_var(cmd&,VAR scalc%,init%,resident!)
' La procedure essaye de 'cacher' les variables globales des
' routines Mydial. Si cmd&=1 alors lecture, sinon ecriture.
LOCAL mdgvadr%
INLINE mdgvadr%,9
IF cmd&=1 !Lesen
scalc%=LONG{mdgvadr%}
init%=LONG{mdgvadr%+4}
resident!=BYTE{mdgvadr%+8}
ELSE
LONG{mdgvadr%}=scalc%
LONG{mdgvadr%+4}=init%
BYTE{mdgvadr%+8}=ABS(resident!)
ENDIF
RETURN
'
> FUNCTION my_al_token(f_alert$,VAR st$(),txtnum&,butnum&)
$F%
' 2.3.6.4
' Valeur de retour: WORD
'
' dÇcomposition de la chaine d'alerte en 8 chaines indÇpendantes : 5
' lignes de texte et 3 boutons
' renvoie le numÇro d'icone en retour
'
' attend dans st$ une des 8 chaines dimensionnÇes -> DIM st$(8)
' Les chaines se trouvent donc dans st$(1) jusqu'a st$(8)
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=24          ! Numero de fonction
DIM tmp|(8*100)        ! il faut atteindre 8*50, bug des MyDials ??
'                        ou erreur du Binding ?? peu importe.
f_alert$=f_alert$+CHR$(0)
{init%+4+16}=V:f_alert$
{init%+4+20}=V:tmp|(0)
{init%+4+24}=V:txtnum&
{init%+4+28}=V:butnum&
$C+
r&=C:scalc%()
$C-
st$(1)=CHAR{V:tmp|(0)}
st$(2)=CHAR{V:tmp|(50)}
st$(3)=CHAR{V:tmp|(100)}
st$(4)=CHAR{V:tmp|(150)}
st$(5)=CHAR{V:tmp|(200)}
'
st$(6)=CHAR{V:tmp|(600)}
st$(7)=CHAR{V:tmp|(650)}
st$(8)=CHAR{V:tmp|(700)}
'
ERASE tmp|()
'
RETURN r&
ENDFUNC
> FUNCTION my_ascii_head(header$)
$F%
' 2.3.7.11
' Valeur de retour: VOID (TRUE)
'
' Modifie l'en-tete de la table ASCII. ceci pour l'internationalisation
' des ressource Mydial.
' 40 caracteres maxi seront appliques a header$ (nouveau type).
'
LOCAL scalc%,init%,resident!,mah_adr%
@mydial_global_var(1,scalc%,init%,resident!)
'
INLINE mah_adr%,41
IF header$=""
header$=" ASCII "
ENDIF
header$=LEFT$(header$+STRING$(40,0),40)+CHR$(0)
BMOVE V:header$,mah_adr%,41
'
WORD{init%+4+36}=34          ! Numero de fonction
{init%+4+16}=mah_adr%
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_close_dial(shrink!,x&,y&,w&,h&,VAR dialinfo$)
$F%
' 2.3.2.3
' Valeur de retour: BOOLEAN (immer TRUE)
'
' fermeture de dialogue, appelle Shrinkbox et ensuite dial_end
' si size = NULL alors le point principal de la Shrinkbox est au centre de l'Çcran
'
LOCAL scalc%,init%,resident!,r!,tmp$,shrink&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF shrink!
shrink&=1
ENDIF
WORD{init%+4+36}=28          ! Numero de fonction
WORD{init%+4+0}=shrink&
tmp$=MKI$(x&)+MKI$(y&)+MKI$(w&)+MKI$(h&)
{init%+4+16}=V:tmp$
{init%+4+20}=V:dialinfo$
$C+
r!=C:scalc%()
$C-
RETURN r!
ENDFUNC
> FUNCTION my_dial_alert(alicon%,txt$,defbut&,undobut&,align$)
$F%
' 2.3.6.2
' Valeur de retour: WORD
'
' appel de form_alert Çtendu :
' alicon : appliquer une icone propre; si NULL, l'entrÇe d'icone sera appliquÇe dans la chaine
' string : Alertstring, comme pour form_alert
'          Si un texte d'un bouton commence avec un point, il sera considÇrÇ comme par dÇfaut,
'          Si il commence par un double point, il sera considÇrÇ comme le bouton Undo par dÇfaut.
'          Pour ces 2 cas, les valeurs de defbut et undobut seront ingorÇes.
' defbut : bouton de sortie par dÇfaut (Exitbutton)
' undobut: bouton Undo par dÇfaut, sera activÇ lors de la pression de la touche UNDO
' align  : positionnement du texte d'alerte: ALI_LEFT, ALI_CENTER, ALI_RIGHT, dÇfinis dans VDI.H
'          la position de chaque ligne peut etre changÇe par ALCENTER et ALRIGHT
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF resident!
WORD{init%+4+36}=22          ! Numero de fonction
txt$=txt$+CHR$(0)
WORD{init%+4+0}=defbut&
WORD{init%+4+2}=undobut&
WORD{init%+4+4}=ASC(align$)
{init%+4+16}=alicon%
{init%+4+20}=V:txt$
$C+
r&=C:scalc%()
$C-
ELSE
' die Alternative soll einfach gehalten sein: also lassen wir die
' Steuerzeichen (ALI_xxx, die eckigen Klammern ...) drin. Das Icon
' wird aber auf 3 reduziert, gibt sonst Fehler. Dabei gehen wir
' von nem fehlerfreien String aus: keine eigentlich unnîtigen
' Fehlerabfragen ...
IF INSTR("0123",MID$(txt$,2,1))=0
MID$(txt$,2,1)="3"
ENDIF
r&=FORM_ALERT(defbut&,txt$)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION my_dial_center(tree%)
$F%
' 2.3.2.4
' Valeur de retour: VOID (TRUE)
'
' centrer le dialogue; identique ‡ form_center
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=11          ! Numero de fonction
{init%+4+16}=tree%
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_dial_do(edit_obj&,VAR dialinfo$)
$F%
' 2.3.2.7
' Valeur de retour: WORD
'
' identique ‡ form_do: Appeler un dialogue
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=7          ! Numero de fonction
WORD{init%+4+0}=edit_obj&
{init%+4+16}=V:dialinfo$
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_dial_draw(VAR dialinfo$)
$F%
' 2.3.2.6
' Valeur de retour: VOID (TRUE)
'
' Dessiner un dialogue; identique ‡ objc_draw
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=12          ! Numero de fonction
{init%+4+16}=V:dialinfo$
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_dial_end(VAR dialinfo$)
$F%
' 2.3.2.9
' Valeur de retour: VOID (TRUE)
'
' Restaurer le fond, liberer la memoire
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=10          ! Numero de la fonction
{init%+4+16}=V:dialinfo$
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_dial_fix(tree%,is_dialog!)
$F%
' 2.3.1.3
' Valeur de retour: VOID (TRUE)
'
' insere un objet USERDEF, is_dialog definit s'il s'agit d'une boite de dialogue ou d'un menu
'
LOCAL scalc%,init%,resident!,is_dial&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF is_dialog!
is_dial&=1
ENDIF
WORD{init%+4+36}=30          ! Numero de la fonction
WORD{init%+4+0}=is_dial&
{init%+4+16}=tree%
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_dial_move(x&,y&,w&,h&,VAR dialinfo$)
$F%
' 2.3.2.8
' Valeur de retour: VOID (TRUE)
'
' deplacer une boite de dialogue; x,y,w,h donnent les limites: (bureau sans le menu)
' dial_move sera aussi appelÈ par dial_do
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=8          ! Numero de la fonction
WORD{init%+4+0}=x&
WORD{init%+4+2}=y&
WORD{init%+4+4}=w&
WORD{init%+4+6}=h&
{init%+4+16}=V:dialinfo$
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_dial_start(tree%,VAR dialinfo$)
$F%
' 2.3.2.5
' Valeur de retour: BOOLEAN
'
' remplir une structure DIALINFO avec des valeurs, sauver le fond
'
LOCAL scalc%,init%,resident!,r!
@mydial_global_var(1,scalc%,init%,resident!)
'
dialinfo$=STRING$(38,0)
WORD{init%+4+36}=9          ! Numero de la fonction
{init%+4+16}=tree%
{init%+4+20}=V:dialinfo$
$C+
r!=C:scalc%()
$C-
RETURN r!
ENDFUNC
> FUNCTION my_do_alert(defbut&,txt$)
$F%
' 2.3.6.1
' Valeur de retour: WORD
'
' identique ‡ form_alert, appele dial_alert avec dial_alert (NULL, string, defbut, 0, ALI_LEFT).
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF resident!
'  IF 1=0
WORD{init%+4+36}=21          ! Numero de la fonction
txt$=txt$+CHR$(0)
WORD{init%+4+0}=defbut&
{init%+4+16}=V:txt$
$C+
r&=C:scalc%()
$C-
ELSE
r&=@my_dial_alert(0,text$,defbut&,0,"") ! afin d'avoir l'alternative de ne devoir
'                                     programmer qu'une seule fois (dans dial_alert)
ENDIF
RETURN r&
ENDFUNC
> FUNCTION my_find_next(tree%,obj&)
$F%
' 2.3.4.1
' Valeur de retour: WORD
'
' Ligne suivante d'un champ de saisie ‡ lignes multiples
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=13          ! Numero de la fonction
WORD{init%+4+0}=obj&
{init%+4+16}=tree%
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_find_prev(tree%,obj&)
$F%
' 2.3.4.2
' Valeur de retour: WORD
'
' Ligne prÈcÈdente d'un champ de saisie ‡ lignes multiples
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=14          ! Numero de la fonction
WORD{init%+4+0}=obj&
{init%+4+16}=tree%
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_form_keybd(tree%,edit_obj&,next_obj&,kr&,ks&,VAR onext_obj&,okr&)
$F%
' 2.3.7.7
' Valeur de retour: WORD
'
' remplace form_keybd, appele avec set_Keybd les routines utilisateurs de gestion clavier avec les memes paramËtres.
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=16          ! Numero de la fonction
WORD{init%+4+0}=edit_obj&
WORD{init%+4+2}=next_obj&
WORD{init%+4+4}=kr&
WORD{init%+4+6}=ks&
{init%+4+16}=tree%
{init%+4+20}=V:onext_obj&
{init%+4+24}=V:okr&
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_getcookie(cookie%,VAR p_value%)
$F%
' 2.3.7.1
' Valeur de retour: BOOLEAN
'
' chercher le Cookie ; Si True, le cookie a ete trouve.
'
LOCAL scalc%,init%,resident!,r!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=2          ! Numero de la fonction
{init%+4+16}=cookie%
{init%+4+20}=V:p_value%
$C+
r!=C:scalc%()
$C-
RETURN r!
ENDFUNC
> FUNCTION my_get_icon(icon&)
$F%
' 2.3.6.3
' Valeur de retour: BITBLK (LONG)
'
' indique la structure BITBLK du pointeur d'une icone
'
LOCAL scalc%,init%,resident!,r%
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=23          ! Numero de la fonction
WORD{init%+4+0}=icon&
$C+
r%=C:scalc%()
$C-
RETURN r%
ENDFUNC
> FUNCTION my_get_keybd
$F%
' 2.3.3.1
' Valeur de retour: FORMKEYFUNC (LONG)
'
' RÈcuperer l'adresse d'une routine utilisateur de gestion clavier
'
LOCAL scalc%,init%,resident!,r%
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=19          ! Numero de la fonction
$C+
r%=C:scalc%()
$C-
RETURN r%
ENDFUNC
> FUNCTION my_get_idx(tree%,obj&,cpos&)
$F%
' 2.3.7.6
' Valeur de retour: WORD
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=15          ! Numero de la fonction
WORD{init%+4+0}=obj&
WORD{init%+4+2}=cpos&
{init%+4+16}=tree%
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_get_obspec(tree%,obj&)
$F%
' 2.3.7.3
' Valeur de retour: LONG
'
' rechercher ob_spec  (aussi pour les objets USERDEF)
'
LOCAL scalc%,init%,resident!,r%
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=4          ! Numero de la fonction
WORD{init%+4+0}=obj&
{init%+4+16}=tree%
$C+
r%=C:scalc%()
$C-
RETURN r%
ENDFUNC
> FUNCTION my_get_sysfnt(vdi_handle&,VAR font_id&,gl_point&,gl_wchar&,gl_hchar&)
$F%
' 2.3.7.13
' Valeur de retour: BOOLEAN
'
' RÇcupÇrer les donnÇes de la fonte system et l'installer pour le programme
'
LOCAL scalc%,init%,resident!,r!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=1          ! Numero de la fonction
WORD{init%+4+0}=vdi_handle&
{init%+4+16}=V:font_id&
{init%+4+20}=V:gl_point&
{init%+4+24}=V:gl_wchar&
{init%+4+28}=V:gl_hchar&
$C+
r!=C:scalc%()
$C-
RETURN r!
ENDFUNC
> FUNCTION my_hndldial(tree%,def&,grow_shrink!,x&,y&,w&,h&,VAR ok!)
$F%
' 2.3.2.1
' Valeur de retour: WORD
'
' Gestion compläte du dialogue, appelle open_dial, do_dial, et close_dial
' ok indique que le fond peut etre bufferisÇ
'
LOCAL scalc%,init%,resident!,tmp$,grsh&,ok&,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF grow_shrink!
grsh&=1
ENDIF
WORD{init%+4+36}=29          ! Numero de la fonction
WORD{init%+4+0}=def&
WORD{init%+4+2}=grsh&
tmp$=MKI$(x&)+MKI$(y&)+MKI$(w&)+MKI$(h&)
{init%+4+16}=tree%
{init%+4+20}=V:tmp$
{init%+4+24}=V:ok&
$C+
r&=C:scalc%()
$C-
ok!=ok&
RETURN r&
ENDFUNC
> FUNCTION my_my_menu_key(menu%,ks&,kr&,VAR title&,item&)
$F%
' 2.3.7.12
' Valeur de retour: BOOLEAN
'
' chercher les raccourcis clavier dans un menu Arbre
' menu  : menu Arbre
' mk    : Structure qui dÇcrit la touche pressÇe
' title : le titre du menu de "Item"
' item  : l'entrÇe du menu correspondant au raccourci clavier
' Retour: TRUE = raccourci trouvÇ, sinon : FALSE
'
LOCAL scalc%,init%,resident!,r!,mkinfo$,kret&
@mydial_global_var(1,scalc%,init%,resident!)
'
' remplir MKINFO :
mkinfo$=STRING$(24,0)
WORD{V:mkinfo$+16}=kr&
kret&=@my_normkey(ks&,kr&)
IF BTST(kret&,8) OR BTST(kret&,9) ! si LShift ou RShift
kret&=BSET(kret&,8)               ! Les deux
kret&=BSET(kret&,9)
ENDIF
kret&=BCLR(kret&,12)              ! enlever CapsLock
WORD{V:mkinfo$+10}=kret&
IF BTST(ks&,0) OR BTST(ks&,1)     ! LShift ou RShift
WORD{V:mkinfo$+18}=1
ELSE
WORD{V:mkinfo$+18}=0
ENDIF
IF BTST(ks&,2)                    ! Ctrl
WORD{V:mkinfo$+20}=1
ELSE
WORD{V:mkinfo$+20}=0
ENDIF
IF BTST(ks&,3)                    ! Alt
WORD{V:mkinfo$+22}=1
ELSE
WORD{V:mkinfo$+22}=0
ENDIF
'
WORD{init%+4+36}=35          ! Numero de la fonction
{init%+4+16}=menu%
{init%+4+20}=V:mkinfo$
{init%+4+24}=V:title&
{init%+4+28}=V:item&
$C+
r!=C:scalc%()
$C-
RETURN r!
' *** aus MGLOBAL.H:
' typedef struct
' {
' 0 WORD     mox;                        /* souris X-Position */
' 2 WORD     moy;                        /* souris Y-Position */
' 4 WORD     momask;                     /* Masque souris */
' 6 WORD     mobutton;                   /* bouton souris */
' 8 WORD     kstate;                     /* Statut du clavier */
' 10 UWORD   kreturn;                    /* Keycode de Event-Keyboard */
' 12 WORD    breturn;                    /* nombre de clicks */
' 14 WORD    ascii_code;                 /* ASCII-Code de la touche */
' 16 WORD    scan_code;                  /* Scan-Code de la touche */
' 18 BOOLEAN shift;                      /* Shift actif ? */
' 20 BOOLEAN ctrl;                       /* Control actif ? */
' 22 BOOLEAN alt;                        /* Alternate actif ? */
' } MKINFO;                              /* Mouse-Key-Info */
' *** BOOLEAN est definit dans PORTAB.H comme WORD (1=TRUE/0=FALSE)
ENDFUNC
> FUNCTION my_normkey(ks&,kr&)
$F%
' 2.3.7.5
' Valeur de retour: UWORD (WORD)
'
' transformer evnt_multi kstate et kreturn avec NKCC en KeyCode normalisÇs
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=6          ! Numero de la fonction
WORD{init%+4+0}=ks&
WORD{init%+4+2}=kr&
$C+
r&=WORD(C:scalc%())
$C-
RETURN r&
'
' **** Gestion NKCC :
' 3. The normalized key code format
' NKCC returns key codes as 16 bit integer. The low byte
' contains the ASCII part of the key, the high byte is the
' location for some flags. Here's the complete format:
' Bit #       Symbolic name        Content
' ------------------------------------------------------------
' 0 ... 7                          ASCII code
' 8           NKF_LSH              left Shift key flag
' 9           NKF_RSH              right Shift key flag
' 10          NKF_CTRL             Control key flag
' 11          NKF_ALT              Alternate key flag
' 12          NKF_CAPS             current state of CapsLock key
' 13          NKF_NUM              numeric keypad flag
' 14          NKF_RESVD            reserved(!) for internal purposes
' 15          NKF_FUNC             function flag
' Bits 8...11 speak for themself. Bit 12 reflects the current state
' of the CapsLock key. Bit 13, if set, indicates that the key is
' located on the numeric keypad. Bit 14 is reserved and must be
' ignored. However, it has a special meaning as parameter for the
' function nkc_cmp(), described in the next chapter.
' Finally, the MSB of the key code (bit 15) specifies the key type:
' if set, the key code stands for any function to perform. If not
' set, it contains any printable character. The bit is set when
' a) any of the following "function keys" is pressed:
' Esc (27), Tab (9), Backspace (8), Delete (31), Return (13), Enter (10),
' Help (14), Undo (15), Insert (11), ClrHome (12),
' cursor up (1), cursor down (2), cursor right (3), cursor left (4),
' F1 (16), F2 (17), F3 (18), F4 (19), F5 (20),
' F6 (21), F7 (22), F8 (23), F9 (24), F10 (25)
' The ASCII code for such keys is less than 32 and defined
' as NK_... in the header files (e.g. NK_ESC for Escape).(Werte in Klammern!)
' b) any key is pressed together with Alternate and/or Control
' In this case, NKCC always returns the CapsLock variant of
' a key (e.g. the ASCII part of the key combination Control + A
' is 'A' rather than 'a').
' The function flag was intentionally placed in bit 15 to ease its
' handling:
' IF (keycode<0)
'  perform function
' ELSE
'  use printable character
' The ASCII code of a printable character spans over the whole
' number range of an unsigned byte: from 0 up to 255!!
ENDFUNC
> FUNCTION my_obj_edit(ob_edtree%,ob_edobject&,kstate&,ob_edchar&,ob_edkind&,mode!,winhndl&,VAR ob_edidx&,next_obj&)
$F%
' 2.3.7.9
' Valeur de retour: WORD
'
' MyDial objc_edit interne.
' Si le dialogue se trouve dans la fenetre, winhndl
' doit contenir le numero de la fenetre, sinon NIL.
'
LOCAL scalc%,init%,resident!,r&,mode&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF mode!
mode&=1
ENDIF
WORD{init%+4+36}=20          ! Numero de la fonction
WORD{init%+4+0}=ob_edobject&
WORD{init%+4+2}=kstate&
WORD{init%+4+4}=ob_edchar&
WORD{init%+4+6}=ob_edkind&
WORD{init%+4+8}=mode&
WORD{init%+4+10}=winhndl&
{init%+4+16}=ob_edtree%
{init%+4+20}=V:ob_edidx&
{init%+4+24}=V:next_obj&
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_open_dial(tree%,grow!,x&,y&,w&,h&,VAR dialinfo$)
$F%
' 2.3.2.2
' Valeur de retour: BOOLEAN
'
' les structures n'etant pas realisables en GFA, x&,y&,w&,h& sont donnes
' directement par dialinfo$ avec leur longueur respectives ; ne doit pas
' Ítre modifie dans le programme principal !!!
'
' Ouverture de dialogue, appelle Growbox et dial_start.
' si size = NULL le point de dÇpart de Growbox est le centre de l'Çcran
' la rÇponse indique si le fond peut etre bufferisÇ.
'
'
LOCAL scalc%,init%,resident!,r!,tmp$,grow&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF grow!
grow&=1
ENDIF
WORD{init%+4+36}=27          ! Numero de la fonction
WORD{init%+4+0}=grow&
tmp$=MKI$(x&)+MKI$(y&)+MKI$(w&)+MKI$(h&)
dialinfo$=STRING$(38,0)
{init%+4+16}=tree%
{init%+4+20}=V:tmp$
{init%+4+24}=V:dialinfo$
$C+
r!=C:scalc%()
$C-
RETURN r!
ENDFUNC
> FUNCTION my_parent(tree%,obj&)
$F%
' 2.3.7.2
' Valeur de retour: WORD
'
' recuperer l'objet parent; si ROOT >> NIL (-1)
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=3          ! Numero de la fonction
WORD{init%+4+0}=obj&
{init%+4+16}=tree%
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_popup_menu(tree%,obj&,x&,y&,center_obj&,relative!,bmsk&,VAR ok!)
$F%
' 2.3.5.1
' Valeur de retour: WORD
'
' popup_menu: montrer le menu Popup
' tree      : Adresse de l'arbre objet dans lequel le meu Popup se trouve
' obj       : index du Popup
' x, y      : Position du point en haut Ö gauche du Popup (sinon le centre de l'objet,
'             lorsque center_obj != NIL)
' center_obj: contient l'index de l'entrÇe Popup Ö centrer
' relative  : TRUE: Popup sera tracÇ Ö la position de la souris, x et y
'             doivent alors etre nuls.
' bmsk      : indique le clic souris, qui sert Ö quitter le Popup
'             (1 = gauche, 2 = droite, comme pour l'AES)
' ok        : TRUE=le fond peut etre sauvegardÇ, FALSE=non
' RÇsultat  : entrÇe choisie ou NIL
'
LOCAL scalc%,init%,resident!,r&,ok&,relative&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF relative!
relative&=1
ENDIF
WORD{init%+4+36}=25          ! Numero de la fonction
WORD{init%+4+0}=obj&
WORD{init%+4+2}=x&
WORD{init%+4+4}=y&
WORD{init%+4+6}=center_obj&
WORD{init%+4+8}=relative&
WORD{init%+4+10}=bmsk&
{init%+4+16}=tree%
{init%+4+20}=V:ok&
$C+
r&=C:scalc%()
$C-
ok!=ok&
RETURN r&
ENDFUNC
> FUNCTION my_popup_select(dialtree%,btn&,poptree%,obj&,docheck!,docycle&,VAR ok!)
$F%
' 2.3.5.2
' Valeur de retour: WORD
'
' popup_select: Dialogue avec bouton Popup et bouton Cycle
' dialtree  : Arbre dialogue
' btn       : Index de l'objet appelÇ par le Popup (Types acceptÇs: BoxText, Bouton, Chaine, Userdef-Boxtext ou Userdef-Button))
' poptree   : Adresse de l'arbre objet dans lequel se trouve le menu Popup.
' obj       : Index du Popup
'             Les entrÇes manuelles doivent etre des chaines ou des raccourcis clavier (Userdef 19)
' docheck   : voir les entrÇes Popup actives (avec Button-Text) avec les crochets
' docycle   : DO_POPUP: montrer les Popups; DO_CYCLE, DO_POPNEXT: montrer l'entrÇe
'             suivante ; DO_POPPREV: montrer l'entrÇe prÇcÇdente
' ok        : TRUE=lorsquele fond peut etre sauvÇ , FALSE=non
' RÇsultat  : entrÇe choisie ou NIL
'
LOCAL scalc%,init%,resident!,r&,ok&,docheck&
@mydial_global_var(1,scalc%,init%,resident!)
'
IF docheck!
docheck&=1
ENDIF
WORD{init%+4+36}=26          ! Numero de la fonction
WORD{init%+4+0}=btn&
WORD{init%+4+2}=obj&
WORD{init%+4+4}=docheck&
WORD{init%+4+6}=docycle&
{init%+4+16}=dialtree%
{init%+4+20}=poptree%
{init%+4+24}=V:ok&
$C+
r&=C:scalc%()
$C-
ok!=ok&
RETURN r&
ENDFUNC
> FUNCTION my_scrap_clear
$F%
' 2.3.7.10
' Valeur de retour: WORD
'
' efface le GEM-Clipboard
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=33          ! Numero de la fonction
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
> FUNCTION my_set_keybd(fun%)
$F%
' 2.3.3.2
' Valeur de retour: VOID (TRUE)
'
' routine clavier propre qui s'insäre dans form_Keybd
' lorsque la routine ne trouve pas de touche correspondante, il faut
' renvoyer NIL, sinon la valeur retournÇe de form_button ou form_keybd.
' A la fin du dialogue, la routine sera extraite de form_Keybd
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=18          ! Numero de la fonction
{init%+4+16}=fun%
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_set_obspec(tree%,obj&,obspec%)
$F%
' 2.3.7.4
' Valeur de retour: VOID (TRUE)
'
' modifie ob_spec (aussi pour les objets USERDEF)
'
LOCAL scalc%,init%,resident!
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=5          ! Numero de la fonction
WORD{init%+4+0}=obj&
{init%+4+16}=tree%
{init%+4+20}=obspec%
$C+
~C:scalc%()
$C-
RETURN TRUE
ENDFUNC
> FUNCTION my_shortcut(tree%,startobj&,ks&,kr&)
$F%
' 2.3.7.8
' Valeur de retour: WORD
'
' rechercher le raccourci clavier dans l'arbre objet; retourne l'objet ou NIL
' startobj: arbre de dÇpart pour la recherche des sous-objets
'           normalement ROOT ( Popups)
' ks, kr  : valeur retournÇe par evnt_multi, dÇcrivant le raccourci clavier
'
LOCAL scalc%,init%,resident!,r&
@mydial_global_var(1,scalc%,init%,resident!)
'
WORD{init%+4+36}=17          ! Numero de la fonction
WORD{init%+4+0}=startobj&
WORD{init%+4+2}=ks&
WORD{init%+4+4}=kr&
{init%+4+16}=tree%
$C+
r&=C:scalc%()
$C-
RETURN r&
ENDFUNC
' ************************************************************************
' **                Quelques dÈfinitions sur les MyDials                **
' ************************************************************************
' ALI_CENTER, ALCENTER: chr$(1) (fleche haut)
' ALI_RIGHT,ALRIGHT:    chr$(2) (fleche bas)
' ALI_LEFT, ALLEFT:     ""  (chaine vide, ebend: alignement ‡ gauche par defaut)
'
' NIL           -1
' TRUE (in C)    1
' FALSE (in C)   0
'
' Structure MKINFO    falcultatif,
' Structure DIALINFO: falcultatif
' Structure RECT:     falcultatif, remplace par 'x&,y&,w&,h&'
'
' Types d'objet etendus
' DIALMOVER  0x0011  / 17
' DCRBUTTON  0x0012  / 18
' UNDERLINE  0x0013  / 19
' TITLELINE  0x0014  / 20
' HELPBUT    0x0015  / 21
' CIRCLEBUT  0x0016  / 22
' UNDOBUT    0x001F  / 31
'
' Flags pour popup_select
' DO_POPUP     0
' DO_CYCLE    -2
' DO_POPPREV  -1
' DO_POPNEXT   1
'
' Quelques definitions essentielles
' aus PORTAB.H:
' #define BYTE    signed char                    /* Signed byte
' #define UBYTE   unsigned char                  /* Unsigned byte
' #if LATTICE_C | PCC
'  #define WORD    short                         /* Signed word (16 bits)
'  #define UWORD   unsigned short                /* Unsigned word
' #else
'  #define WORD    int                           /* Signed word (16 bits)
'  #define UWORD   unsigned int                  /* Unsigned word
' #endif
' #define LONG    long                           /* Signed long (32 bits)
' #define ULONG   unsigned long                  /* Unsigned long
' #define BOOLEAN WORD                           /* 2 valued (true/false)
' #define FLOAT   float                          /* Single precision float
' #define DOUBLE  double                         /* Double precision float
' #define INT     int                            /* A machine dependent int
' #define UINT    unsigned int                   /* A machine dependent uint
'
' #define FALSE   (BOOLEAN)0                    /* Function FALSE value
' #define TRUE    (BOOLEAN)1                    /* Function TRUE  value

' Quelques mots de breton :
' Die MyDial- und XRSRC-Routinen werden mit dem Resourceeditor
' Interface geliefert. Dabei werden auch die Files "XRSRC.OVL" und
' "MYDIAL.OVL" geliefert.
'
' Diese Routinen stellen eine Weiterentwicklung bzw. Fehlerkorrektur der
' zuerst mit den Mydials gelieferten GFA-Routinen dar. Der Autor dieser
' stellte allen Mydial-Routinen ein 'my_' im Namen voraus; das habe
' ich (weils Sinn macht) beibehalten. Auch die Parameterreihenfolgen
' wurden groûenteils beibehalten, diese entsprechen den C-Routinen,
' also kann die Mydial-Anleitung hier fast 1:1 herangezogen werden.
' An einigen Stellen waren jedoch énderungen nîtig oder sinnvoll.
' Die énderung der Reihenfolge war grundsÑtzlich da nîtig, wo
' auf call-by-reference-Parameter call-by-value-Parameter folgten
' (in C kann man dies mischen, in GFA-Basic nicht); hier wurde so
' umgestellt, daû wirklich nur die nîtigen Variablen zurÅckgegeben
' werden. Dies hat immerhin den Vorteil, daû man diese Parameter
' mit konstantem Wert aufrufen kann, ohne diesen extra einer Variablen
' zuzuweisen. Auûerdem wurden da, wo mîglich, boolesche Variablen
' verwendet; die unterschiedliche Definition (in C ist TRUE=1, auûerdem
' sind diese Variablen in C Words) wurde berÅcksichtigt.
' Desweiteren:
'
' Die XRSRC-Routinen machen (jeweils) einen Test, ob sie installiert sind;
' sind sie nicht, werden die Original-RSRC_xxx-Routinen aufgerufen.
' Ich habe dies beibehalten: es ist insofern sinnvoll, da man zwar
' am Beginn eines Projektes die Routinen wohl noch nicht braucht
' (kaum jemand fÑngt mit einer RSC >64 kb an ;-), wenn man aber
' irgendwann feststellt, daû die RSC doch grîûer wird, braucht man
' nur beim init_xrsrc-Aufruf den essential!-Parameter mit TRUE
' aufrufen und ansonsten keine VerÑnderungen am Programm vornehmen.
' Die Funktionsnamen hÑtten natÅrlich auf rsrc_xxx (statt xrsrc_xxx)
' geÑndert werden kînnen, da GFA-Basic dies erlaubt; die Voranstellung
' des x is insofern sinnvoll, als damit Tippfehler (vergessener Klammeraffe
' als Zeichen des Funktionsaufrufs) leichter erkannt werden kînnen und
' weil die Bezeichnung sich inzwischen eingebÅrgert hat.
'
' Auch die Mydial-Routinen machten im Original jeweils einen Test,
' ob sie installiert sind. Dies ist rausgeflogen: es ist nicht
' sinnvoll. Wenn man schon testet, mÅûte man bei Nichtinstallation
' die Funktion nachbilden -> das wÑre aber unsinnig, dann kînnte man
' gleich auf die Routinen verzichten und eigene verwenden.
' Bei den beiden Alert-Funktionen der Mydials wurde es beibehalten:
' dies ist sinnvoll, da man so IMMER diese Funktion aufrufen kann
' (auch _vor_ Installation der Routinen !!) und
' da eine Alternative einfach bereitzustellen ist. Auch bei exit_mydial
' wurde es logischerweise beibehalten, da exit_mydial von global_exit
' aufgerufen wird ...
' Statt diesen einzelnen Tests wird von init_mydial im Miûerfolgsfall
' abgebrochen und dazu 'global_exit' aufgerufen.
'
' Auch Routinen, die nichts sinnvolles zurÅckgeben,
' weil sie als VOID in C definiert sind, sind als Funktionen
' definiert. Ich habe davon abgesehen, diese in Prozeduren zu Ñndern;
' Funktionen sind manchmal eleganter zu benutzen. Also nicht
' wundern, wenn eine Funktion fest TRUE zurÅckgibt, ich habe das
' mit Absicht so gemacht.
'
' Beide Sammlungen benîtigen einen Installationsaufruf und einen
' Deinstallationsaufruf. Diese habe ich 'init_xxx' und 'exit_xxx'
' genannt. Die NKCC-Routinen der Mydials werden dort mit abgehandelt,
' darum braucht man sich nicht mehr kÅmmern. Beide Routinensammlungen
' verstecken ihre globalen Variablen mittels Prozeduren 'xxx_global_var';
' ich habe dies eingefÅhrt, damit nicht aus Versehen im Hauptprogramm
' wichtige Variablen der Routinen verÑndert werden kînnen. Dieses
' Verstecken kostet Rechenzeit, logisch; doch der Verlust ist minimal
' (im 1000stel-Sekunden-Bereich), also: keine Panik ! Die
' Deinstallationsaufrufe sollte man in global_exit tÑtigen.
'
' Beide Sammlungen benîtigen die Funktion @compiled und die
' globale Ausgangsprozedur global_exit. Letztere wird benîtigt, um
' aus den init-Prozeduren im Miûerfolgsfall zu einem definierten Ende
' zu springen; man sollte global_exit soweit nîtig um eigene AufrÑum-
' Aktionen ergÑnzen. Die Funktion @compiled wird benîtigt, um im
' Interpreter einen Fehler des Einbindungskonzepts
' (gemeldet von Andreas Frank, thanx!) zu umschiffen:
' die Overlay-Routinen werden mittels EXEC geladen. Das bedeutet aber,
' daû der Speicher von diesen erst bei Verlassen des Interpreters freigegeben
' wird - schlieûlich ist aus GEM-Sicht der Interpreter der aktive Prozeû, und
' nicht das Programm im Interpreter ... die Folge daraus war eine Verkleinerung
' des Speichers bei jedem Start, die Overlays wurden ja immer wieder
' geladen. Abhilfe: im Interpreter wird nach dem ersten Laden in der
' Basepage (des Interpreters) vermerkt, daû die Routine geladen ist
' (und die zugehîrigen Adressen werden gemerkt). Bei jedem
' Programmstart wird in der Basepage nachgesehen, ob die Routinen
' schon geladen sind, und sie werden dann nicht neu geladen.
' Wer genauer wissen will, wie's geht, schaue in die init/exit-Routinen.
' Diese Methode dÅrfte keine Probleme mit sich bringen, und im Compilat
' wird sie eh nicht angewandt. Ansonsten ist das Einbindungskonzept
' Åbrigens sehr sinnvoll !!
' Auûerdem wird noch eine Funktion mit einem Text fÅr die Fehlermeldung
' benîtigt, fÅr den Fall, daû ein Overlayfile nicht gefunden wurde/
' der Speicher nicht reichte. Diese Funktion ist ebenfalls bei den
' benîtigten aufgefÅhrt.
'
' Einige Definitionen zu den Mydials habe ich nach diesen aufgefÅhrt,
' zB ALI_CENTER. Weitere Definitionen sind den beigelieferten .H-Files
' zu entnehmen bzw. den Anleitungen (irgendwo stehen sie halt ;-).
'
' Zu den Kommentaren in den Funktionen: diese stammen zum grîûten
' Teil aus den Original-GFA-Routinen. Ich habe sie dringelassen,
' da sie kaum schaden kînnen, sie aber nicht oder kaum ergÑnzt,
' wo das eigentlich wÅnschenswert gewesen wÑre. Ich habe sie auch
' nicht auf Fehler durchgesehen, also Vorsicht ! Ich hatte schon
' genug zu tun ... und man kann ja auf die Mydial-Anleitung
' zurÅckgreifen !! Was ich ergÑnzt habe, is die Kapitelzahl
' in der Anleitung; in den Funktionen steht jeweils ne Zeile mit
' dieser (da ich die Routinen alphabetisch sortiert habe). Auûerdem
' hab ich die Valeur de retour beschrieben (zB 'Valeur de retour: WORD').
'
' Ich hoffe, daû ich alle Fuûangeln der Routinen gefunden und ausgemerzt
' habe, so daû diese von Ihnen (und mir ;-) als das benutzt werden kînnen,
' als was sie gedacht sind: als 'black boxes', als Routinen, die
' funktionieren, ohne daû man wissen muû, wie. FÅr Fehlermeldungen
' und Kritik ist meine Adresse oben aufgefÅhrt. Von Telefonanrufen
' bitte ich abzusehen; schriftliche Anfragen werden natÅrlich nur
' beantwortet, wenn ein frankierter RÅckumschlag beiliegt. Eine
' Haftung wird in keiner Weise fÅr irgendetwas Åbernommen; ich
' verdiene nichts an diesen Routinen, und entsprechend betrachte
' ich meine Verpflichtung als NULL. Das betrifft auch die Verpflichtung,
' diese Routinen zu pflegen und auf Anfragen zu reagieren; ich sage nicht,
' daû ich dies nicht tun werde, ich sage aber: sollte ich es nicht tun,
' braucht sich niemand wundern.
'
' Noch eine Anmerkung zur Demo: die Variablennamen fÅr die Objektnummern
' haben alle ein 'h_' vorangestellt. Wozu? NatÅrlich zur Unterscheidung
' von anderen Variablen des Hauptprogramms (man bedenke: diese Variablen
' sind ja global!). Doch WIE? Ganz einfach: ich habe in Interface die
' Ausgabe eben mit vorangestelltem 'h_' definiert (da Interface nur ne
' begrenzte NamenslÑnge erlaubt und man das vorangestellte 'h_' sonst
' ev. vergiût). Zur Nachahmung empfohlen, siehe IF_DIF.RSC!
'
' Viel Spaû mit den Mydials !!
'
' Stefan MÅnch im Januar 93
'
' ****************************************************************
