/*----------------------------------------------------------------------*/
/*			   Programmdokumentation zu			*/
/*				dj_grafprint()				*/
/*	   einigermaen universelle Hardcopyfunktion fr HP DeskJet	*/
/*				in Turbo C 2.0				*/
/*			Copyright Sevo Stille 9.12.1990			*/
/*----------------------------------------------------------------------*/
/*									*/
/*	Die Funktion ist auf Lesbarkeit und leichte šbersetzbarkeit	*/ 
/*	in andere Sprachen hin geschrieben, wer will, kann noch viele	*/
/*	Optimierungen durchfhren. Da sie gleich im ersten Anlauf 	*/
/*	fehlerfrei lief, habe ich sie nicht allzu grndlich auf ver-	*/
/*	steckte Fehler untersucht. 					*/
/*									*/ 
/*	Wer Fehler findet, sollte sie mir bitte melden:			*/
/*	Sevo Stille, T”plitzstrasse 7, 6000 Frankfurt 70		*/
/*									*/	
/*	Ich werde diese Funktion noch portabel fr alle C-Compiler 	*/
/*	machen und um Ausschnitte und Kompression erweitern.		*/
/*									*/
/*	Das Bild darf nur ein Bitplane haben, mu in einem zusammen-	*/
/*	h„ngenden Speicherbereich stehen und mu in der Breite auf	*/ 
/*	Bytes aufgehen. In dieser Version k”nnen deshalb Ausschnitte 	*/
/*	nur gedruckt werden, indem man sie vorher diesen Regeln ent-	*/
/*	sprechend in einen Puffer kopiert oder die Routine fr jede  	*/
/*	Zeile einzeln aufruft.						*/
/*									*/
/*----------------------------------------------------------------------*/
/*									*/
/*	Diese Routine soll der Anfang einer PD-Sammlung mit DeskJet	*/
/*	Druckroutinen fr alle wichtigen Sprachen sein.			*/
/*	Sie darf uneingeschr„nkt verwendet und modifiziert werden.	*/
/*	Allerdings sind alle aus ihr entwickelten Druckroutinen 	*/
/*	weiterhin PD und sollten mir zur Ver”ffentlichung zugesandt 	*/
/*	werden. Wer davon unabh„ngig DeskJet-Routinen geschrieben hat,	*/
/*	ist natrlich auch eingeladen, sich am DeskJet-Pool zu be-	*/
/*	teiligen. Damit wrde die Untersttzung des DeskJet/LaserJet	*/
/*	auch durch solche Programmierer, die keinen Zugang zu einem	*/
/*	entsprechenden Drucker haben, wesentlich erleichtert.		*/
/*	Dringend gebraucht werden besonders noch Routinen fr GFA-  	*/
/*	und OMIKRON-BASIC, PASCAL und MODULA.				*/
/*									*/
/*----------------------------------------------------------------------*/ 
/*									*/
/*		Die Variablen und ihre Bedeutung:			*/
/*									*/
/*	->res 		(Druckaufl”sung in dpi [75,100,150,300])	*/
/*	->w   		(Breite des auszudruckenden Bildes in Bytes)	*/
/*	->h   		(H”he des auszudruckenden Bildes in Zeilen)	*/
/*	->imgbase	(Adresse des Bildpuffers)			*/
/*	<-		(0 bei Erfolg, -1 wenn kein Drucker 		*/
/*			angeschlossen, 1 wenn Bild zu gro ist)		*/
/*									*/
/*----------------------------------------------------------------------*/

/*	Dieses Listing ist so ausfhrlich kommentiert, da es jeder, der 
	wei wie er in seiner Sprache die GEMDOS-Funktionen aufrufen kann,
	ohne gr”ere Probleme bersetzen k”nnen mte, ohne auch nur vage
	Kentnisse von C zu haben.					*/








/* includes   - Files mit Funktionsprototypen und Definitionen */

#include <tos.h>
#include <stdlib.h>
#include <string.h>


/* Testprogramm auskommentiert!
Nur zur Demonstration der Druckfunktion ist hier eine kleines und ziemlich nutz- 
loses Testprogramm, das den aktuellen, freilich sehr leeren, Bildschirm druckt: 

#include "dj_graf.h"
int main (void)
{
return dj_grafprint(150,80,400,Physbase());
}
*/


/*	die Funktion	*/

int dj_grafprint(int res, int w, int h, char *imgbase)
{
/*	die automatischen (lokalen) Variablen	*/

int i;				/* Laufvariable der Schleife */
int laenge;			/* wird sp„ter fr Stringl„nge gebraucht */

char *startgraphics;		/* Pointer auf den sp„ter ausgew„hlten Initialisierungsstring	*/

char low[13]="\x1B*t75R\x1B*r0A";	/* Initialisierungsstrings fr die	*/
char mid1[13]="\x1B*t100R\x1B*r0A";	/* einzelnen Aufl”sungen		*/
char mid2[13]="\x1B*t150R\x1B*r0A";
char high[13]="\x1B*t300R\x1B*r0A";

char transfer[9]="\x1B*b";	/* Zeilenanfang-String, die folgenden 	
				   Bestandteile werden mit strcat dort
				   angeh„ngt:				*/
char linewidth[5];		/* Anzahl Bytes/Zeile im Stringformat	
				   wird mit itoa gefllt		*/ 
char endchr[]="W";		/* Abschluzeichen 			*/	

char endgraphics[]="\x1B*rB";	/* Ende der Grafikbertragung		*/

/* 	ab hier gehts richtig los	*/

	if (w>res) return 1;	/* Ein kleiner Trick: Da die maximale 
				   Druckbreite in DIN A4 genau 8" ist,	
				   kann man so einfach auf šberschreitung
				   des rechten Randes testen!*/

	if (!Cprnos()) return -1;	/* Das ntzt am DeskJet nicht viel,
					   also nur ein Test, ob gar kein 
					   Drucker angeschlossen ist!	*/ 			   
	itoa(w,linewidth,10);		/* integer to ascii, Zahlen mssen fr den
					   DeskJet Steuerstring im Stringformat vorliegen	*/
	strcat(transfer,linewidth);	/* string concatenate, h„ngt Strings hinten an andere an, erst die Zahlen	*/
	strcat(transfer,endchr);	/* und dann der Endbuchstabe, der String ist damit fertig zusammengestellt	*/	
	laenge=strlen(transfer);	/* jetzt noch die L„nge ermitteln, das ist n”tig, weil dahinter
					   Grafikdaten folgen. Eine berh„ngende Null, die in anderen 
					   F„llen nichts macht, wrde hier die Grafik verzerren!	*/	
	
	switch(res)		/* fr jede Aufl”sung das passende Start-Kommando. Der Pointer
				   wird auf das sp„ter gesendete Kommando gesetzt	*/
	{
		case 300:startgraphics=high;break;
		case 150:startgraphics=mid2;break;
		case 100:startgraphics=mid1;break;
		case 75:startgraphics=low;break;
	}	
	
	Fwrite(3,12,startgraphics);	/* Fwrite auf Standard-Handle 3=PRN, das ist einfach und schnell genug	*/ 
	
	for (i=0;i<h;i++)		/* Zeile fr Zeile: Eine for-Schleife in C 
					   ( i=0 bedeutet: Startwert 0, i<h bedeutet Endwert h-1,
					   i++ bedeutet: i wird nach jedem Mal um 1 erh”ht )	*/
	{
		Fwrite(3,laenge,transfer);	/* Der Zeilenanfangsbefehl	*/
		Fwrite(3,w,imgbase);		/* Die Grafikdaten der Zeile	*/
		imgbase+=w;		/* n„chste Zeile, w Bytes weiter im Buffer (x+=y entspricht x=x+y)	*/
	}
	Fwrite(3,4,endgraphics);	/* und zu guter Letzt der Schlussbefehl	fr den Drucker	*/
	return 0;			/* bei Erfolg Rckgabewert 0	*/
}

/*	Damit mte auch jeder Basic-Programmierer ohne Kenntnis weiterer Sprachen in der Lage 
	sein, diese Routine umzusetzen. Zugleich drfte klar geworden sein, da C sehr leistungs- 
	f„hig und nicht zwangsl„ufig unverst„ndlich ist. Man kann in C durchaus in einem Stil 
	schreiben, der „hnlich lesbar wie Pascal ist, hat aber, besonders fr die betriebssys-
	temnahe Programmierung, m„chtigere Mittel zur Verfgung.
	
	Optimieren kann man diese Funktion natrlich noch. Sinnvoll ist das allerdings nicht.
	Man kann damit weder die Geschwindigkeit noch die Programmgr”e nennenswert verbes-
	sern. Der Algorithmus ist simpel, aber effizient, und auch Fwrite ist so schnell, da
	die direkte Ausgabe bers BIOS keinen merklichen Gewinn verspricht. Nur der Ersatz von
	Bconout durch eine eigene Routine k”nnte in der Hand eines guten Assemblerprogrammie-
	rers einen deutlichen Zeitgewinn bringen.
	Die naheliegendste Optimierung, das direkte Verwenden der Adresse in der Laufvariable 
	bringt z.B. nur wenig, da im Inneren der Schleife sowieso mehrere Aufrufe einer groen 
	Betriebssystemfunktion stehen, die selbst dann die meiste Zeit verbrauchen wrden, wenn
	der Drucker jederzeit alle Daten sofort annehmen k”nnte. Die „uere Schleife,unsere 
	Funktion, entspricht nur 15 Zeilen Assembler, darin stehen die ungef„hr gleichgroen  
	Assemblerroutinen der Funktionsaufrufe. Diese Befehle werden nur einmal pro Zeile durch-
	laufen. Im inneren Kern aber steht die Assemblerroutine des GEMDOS fr Fwrite(),die 
	wiederum fr jedes Byte, also bei einer normalen Hardcopy achzig Mal pro Zeile, das 
	BIOS aufruft.
	Also kann diese Optimierung unserer Funktion nur wenig bringen, da der tats„chlich durch-
	laufene Code zu ber 90% im Betriebssystem liegt. Die Funktion wrde dadurch im  Wesent-
	lichen nur unleserlicher und weniger pflegeleicht, und das gerade in der Adressarithmetik, 
	wo Fehler besonders leicht bersehen werden k”nnen. 
		 
	Ganz allgemein haben Hobbyprogrammierer, aber auch viele Profis eine fatale Tendenz
	dazu, perfekt optimierten Code mit guten Algorithmen zu verwechseln.  
	Optimierung kann aber blo ganz am Ende nach der Entwicklung und Prfung des besten 
	Algorithmus stehen. Die meistem Programme lassen sich durch bessere Algorithmen und 
	die Umsetzung weniger kritischer Stellen in Assembler sehr viel mehr verbessern, als  
	dies durch die beste Optimierung der Source m”glich w„re. 
	

	
													*/
