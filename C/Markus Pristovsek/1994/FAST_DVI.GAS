|********************************************************************
|**** *schnelle* ausgabe von zeichen im hintergrund  		*****
|********************************************************************

	.globl _prn_byte
	.globl _exstall
	.globl _old_vec
	.globl _shm_name
	.globl _CookieJar


	.text
| **********************************************
| ****	Sucht nach CookieJar (fÅr Dialoge)  ****
Cook:	.long	0
_CookieJar:
	movel	sp@(4),Cook
	pea	SearchCookie
	movew 	#38,a7@-
	trap	#14
	addql	#6,a7
	movel	Cook,d0
	rts

SearchCookie:
	movel	0x5a0,d0
	ble	NoCookie
	moveal	D0,a0
	movel	Cook,d0
cl:	cmpl	a0@,d0
	beq	YesCookie
	tstl	a0@+
	beq	NoCookie
	addql	#4,a0
	bra	cl
YesCookie:
	movel	a0@(4),Cook
	rts
NoCookie:
	clrl	Cook
	rts
| ****	02.09.94    ****


| **** programm durch signal gekillt!
_exstall:
	tstl _ptr
	ble no_ex_
	pea ex_print
	movew #38,a7@-
	trap #14
	addql #6,a7
no_ex_:
	pea _shm_name 	| temporÑre datei wird z.zt. nicht gelîscht!
	movew #0x41,a7@-
	trap #1
	addql #6,a7
	pea killed
	movew #0x9,a7@-
	trap #1
	addql #6,a7
	clrw a7@-
	trap #1
	rts

ex_print:
	clrl _anzahl
	bclr #0,0xfa09:w		 | ausschalten
	bclr #0,0xfa15:w | maskieren
	movel _old_vec,0x100:w
	clrl _old_vec
	rts


| Idee aus ST-Computer 5/92, stark modifizert
_prn_byte:
	movel sp@(8),_anzahl | Anzahl Bytes
	ble no_print
	movel sp@(4),_ptr

	pea i_byte
	movew #38,a7@-
	trap #14
	addql #6,a7
no_print:
	rts

| Interruptroutine in MFP-Busy-Interrupt
| Wenn man positionsunabhaengig schriebe,
| koennte sogar "shared text" unterstuetzt 
| werden
i_byte:	movel #_xbra,a0	| Xbra-Routine bauen
	movel #0x58425241,a0@+	| 'XBRA'
	movel #0x44564952,a0@+	| 'DVIR'
	movel 0x0100:w,a0@+	| alter Vektor
	movel #0x07C0700,a0@+	| ORI #$0700,SR
	movew #0x4EB9,a0@+	| JSR out
	movel #out,a0@+
	movew #0x4E73,a0@+	| RTE
	movel #_int,0x0100:w

	bclr #0,0xfa03:w
	bclr #0,0xfa05:w
	bset #0,0xfa09:w | anschalten
	bset #0,0xfa15:w | demaskieren
	moveb #0xfe,0xfa11:w

	moveb #14,0x8800:w | strobe aus
	moveb 0x8800:w,d0
	bset #5,d0
	moveb d0,0x8802:w

| Hier wird ein Byte ausgegeben
out:
	subql #1,_anzahl
	bmi ende
	moveml d0/a0,a7@-
|	bclr #0,0xfa15:w
	moveb #15,0x8800:w
	movel _ptr,a0
	moveb a0@+,0x8802:w
	movel a0,_ptr

	movew wait1,d0 | damit das Timing der Norm entspricht, bzw
time1:	nop
	dbra d0,time1

	moveb #14,0x8800:w
	moveb 0x8800:w,d0
	bclr #5,d0
	moveb d0,0x8802:w
	bset #5,d0
	movew d0,a0

	movew wait2,d0 | verÑndert werden kann
time2:	nop
	dbra d0,time2
	movew a0,d0
	moveb d0,0x8802:w

	moveml a7@+,d0/a0
|	bset #0,0xfa15:w
	moveb #0xfe,0xfa11:w
	rts



ende:	movel _old_vec,0x100:w
	bclr #0,0xfa09:w | ausschalten
	bclr #0,0xfa15:w | maskieren
	clrl _old_vec
	rts



	.data
	.ascii "PATCH:"
	.even
wait1:	.word 0x0006
wait2:	.word 0x0024
killed: .byte 0x1b,0x48,0x20,7,0

	.data
	.even
	.lcomm _anzahl,4
	.lcomm _ptr,4
	.lcomm _xbra,8
	.comm _old_vec,4
	.lcomm _int,12
