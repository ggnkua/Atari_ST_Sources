README zur 2. Auflage des Buches
================================

"Vom AnfÑnger zum GEM-Profi"

von Dieter & JÅrgen Gei·

(c) 1991 HÅthig Buch-Verlag GmbH


Seit der Erstauflage dieses Buches ist nunmehr etwa ein Jahr verstrichen.
Das Demoprogramm zum Buch (SCRAP) wurde stÑndig weiterentwickelt und liegt
nun in einer Åberarbeiteten Version vor. ZunÑchst einige Schlagworte zu
den wesentlichen énderungen.

- UnterstÅtzung beider Mausknîpfe
- modale und nicht-modale Dialogboxen in echten Fenstern
- erweiterte Alertboxen in echten Fenstern
- blinde Pa·wort-Eingabe
- UnterstÅtzung der TOS 1.4 File-Selector-Box
- Listboxen in Dialogboxen

Au·erdem wurden viele Kleinigkeiten verbessert, von denen die meisten
durch die folgenden ErlÑuterungen klar werden dÅrften.

Die Compiler Digital Research C und Lattice-C werden nicht mehr
unterstÅtzt, d.h. nicht mehr getestet. Dies bedeutet nicht, da· das
Programm SCRAP nicht auch mit diesen Compilern laufen wÅrde. Beim Digital
Research Compiler wÅrden sich allerdings Probleme ergeben, die darauf
zurÅckzufÅhren sind, da· die LÑnge der Bezeichner auf 7 (fÅr externe
Bezeichner) beschrÑnkt ist.

Leider mu·ten wir auch feststellen, da· die modalen und nicht-modalen
Fenster mit dem Megamax Laser C Compiler nicht richtig funktionieren, wenn
sie editierbare Felder beinhalten. Offensichtlich sind die dafÅr
notwendigen und selten benutzten GEM-Bindings "objc_edit", "form_keybd"
und "form_button" nicht richtig implementiert. Arbeitet man mit diesem
Compiler, mu· man also auf die genannten Features verzichten. Da aber auch
die benutzerdefinierbaren Objekte mit diesem Compiler nicht laufen kînnen,
ist ein Umsteigen auf einen anderen Compiler sinnvoll.

Der Turbo C Compiler wird ab der Version 2.0 unterstÅtzt. Es soll noch
erwÑhnt werden, da· das Stack Checking ausgeschaltet sein mu· (wegen der
benutzerdefinierten Objekte) und absolute Calls benutzt werden mÅssen.
Au·erdem sollten Zeichenketten nicht zusammengelegt werden, also

-T aus
-P an
-M an


Im folgenden wird erlÑutert, welche wesentlichen énderungen die einzelnen
Module erfahren haben.


Modul GLOBAL
------------

Folgende Konstanten-Definitionen wurden aufgenommen:

#define FONT_SYSTEM   1
#define FONT_SWISS    2
#define FONT_DUTCH   14

Es handelt sich um den System-Zeichensatz, sowie die beiden ZeichensÑtze,
die von Digital Research zum GEM/3 mitgeliefert werden. Die Konstanten
kînnen bei einem Aufruf von "vst_font" benutzt werden.


#define POS1        0x47
#define PGUP        0x49
#define ENDKEY      0x4F
#define PGDOWN      0x51
#define CNTRL_LEFT  0x73
#define CNTRL_RIGHT 0x74

Die ersten vier Definitionen bezeichnen die Scan-Codes der Tasten eines
AT-Keyboards, die beim Atari ST nicht vorhanden sind. Die beiden letzten
Definitionen wurden aufgenommen, da die Pfeiltasten mit gedrÅckter
Control-Taste einen anderen Scan-Code liefern.


#define UNDO_FLAG   0x0200
#define HELP_FLAG   0x0400
#define NOECHO_FLAG 0x0800

Die drei Flags werden zusÑtzlich zu den OB_FLAGS eines Objektes benutzt.
Da sie nicht interaktiv im Resource-Construction-Set eingegeben werden
kînnen, werden sie im Module RESOURCE "zu Fu·" gesetzt (siehe Modul
RESOURCE).

Das UNDO-Flag gibt an, welcher Knopf (Button) einer Dialogbox mit der
UNDO-Taste aufgerufen wird, falls diese Taste vorhanden ist.

Das HELP-Flag gibt an, welcher Knopf (Button) einer Dialogbox mit der
HELP-Taste aufgerufen wird, falls diese Taste vorhanden ist. Im Programm
wird die Funktionstaste F1 zur zusÑtzlichen Help-Taste.

Das NOECHO-Flag gibt an, welches editierbare Objekt einer Dialogbox kein
Echo haben soll. In ein solches Objekt werden dann anstatt Buchstaben '*'-
Symbole ausgegeben. Dies dient z.B. zur Eingabe von Pa·wîrtern. Ein
Beispiel wird im Modul MENU gegeben. Die dort zu îffnende Dialogbox fÅr
die Systemeinstellungen beinhaltet auch ein Pa·wort. Weitere Informationen
wird in der Beschreibung zur Funktion "edit_noecho" gegeben.


typedef BYTE HUGE *HPTR;
typedef BYTE FAR  *FPTR;

Die beiden Typdefinitionen sind unter MS-DOS zu verwenden. Dort stellen
sie Huge-Pointer bzw. Far-Pointer dar.


typedef struct
{
...
  WORD momask;
...
} MKINFO;

In der Struktur MKINFO (Mouse-Keyboard-Info) ist ein Element dazugekommen.
Es handelt sich um die Komponente "momask". Sie gibt die Maske des
Mausknopfes an, der ein Ereignis ausgelîst hat. FrÅher wurde nur die
Komponente "mobutton" zu Hilfe genommen. Da nun zwei Mausknîpfe
unterstÅtzt werden, benîtigt man zusÑtzliche Information, da man aus der
Belegung der Komponenten "mobutton" mit der Zahl 0 (bei Mausknopf oben)
nicht erkennen kann, welcher Mausknopf nun oben ist.

"momask" kann folgende Werte annehmen:

0x0001: linker Mausknopf hat Ereignis ausgelîst
0x0002: rechter Mausknopf hat Ereignis ausgelîst

"mobutton" nimmt nach wie vor folgende Werte an:

0x0000: Mausknîpfe oben
0x0001: linker Mausknopf unten
0x0002: rechter Mausknopf unten

Damit ergeben sich zur Unterscheidung der einzelnen Ereignisse folgende
Werte:

Ereignis        momask    mobutton
----------------------------------
Klick links     0x0001    0x0000
Drag links      0x0001    0x0001
Klick rechts    0x0002    0x0000
Drag rechts     0x0002    0x0002

Klick bedeutet, da· der Mausknopf sofort wieder losgelassen wird, Drag,
da· der Mausknopf gedrÅckt gehalten wird. Wird ein Mausknopf gedrÅckt,
wird vom Modul EVENT auf ein Loslassen desselben gewartet, so da· ein
durchgehendes DrÅcken nur ein Ereignis auslîst. Soll dies verhindert
werden, so mu· in der Routine, die dieses Ereignis verarbeitet, der Wert
der Variablen "bclicks" auf 0x102 gesetzt werden (siehe auch Modul
DESKTOP, Routine "wi_click").


GLOBAL WORD gl_point;

Die Punktgrî·e des Systemzeichensatzes. Sie kann z.B. in einem Aufruf
"vst_point" benutzt werden. Im allgemeinen hat sie den Wert 10. Auf dem
Atari ST in mittlerer oder niedriger Auflîsung hat sie beispielsweise den
Wert 9.


GLOBAL WORD mousenumber;

Die aktuelle Nummer der Mausform. Wird z.B. im Modul DIALOG benutzt, um
nach der Behandlung einer modalen Dialogbox die ursprÅngliche Mausform
wiederherzustellen.


GLOBAL MFORM *mouseform;

Die aktuelle Form der Maus, falls "mousenumber" den Wert USER_DEF hat.


GLOBAL BOOLEAN updtmenu;

Flag, welches angibt, ob nach einem Ereignis die MenÅs auf den neuesten
Stand gebracht werden sollen. Normalerweise ist dies der Fall, da nach
einem Ereignis meist ein Zustand eintritt, der MenÅs verÑndert bzw.
MenÅeintrÑge ein- oder ausschaltet. Wird die Variable von einer Routine
auf FALSE gesetzt, so wird beim nÑchsten Durchgang das MenÅ nicht auf den
neuesten Stand gebracht.

Der Sinn, der dahinter steckt ist einfach der, Zeit zu sparen, da die
Funktion "updt_menu" oft aufgerufen wird und etwas Zeit kostet. Im
Normalfall macht sich dies aber nicht bemerkbar.

Einige Funktionen des Moduls WINDOWS setzen die Variable auf FALSE, da
sich kein MenÅ Ñndern kann. So wird dies z.B. beim Verschieben eines
Fensters getan oder wenn eine Taste in einem editierbaren Objekt in einer
Dialogbox gedrÅckt wird, die sich in einem Fenster befindet. Dabei Ñndert
sich der Zustand des Programmes im Normalfall nicht.


GLOBAL BYTE **alerts;

Die Variable enthÑlt eine Tabelle von Zeigern auf die Fehlermeldungen.
Fehlermeldungen werden nicht mehr im Resource-Construction-Set angegeben,
da sie dann nicht flexibel genug sind. Die Fehlerbehandlung wird noch
weiter unten erklÑrt.


BOOLEAN is_state (OBJECT *tree, WORD obj, UWORD state);

Es wird geprÅft, ob ein bestimmter Status (z.B. SELECTED) eines Objektes
(ob_state) gesetzt ist.

is_state: TRUE, wenn der geprÅfte Status gesetzt ist, sonst FALSE
tree    : Zeiger auf einen Objektbaum
obj     : Index des Objekts
state   : Status, der geprÅft werden soll


BOOLEAN is_flags (OBJECT *tree, WORD obj, UWORD flags);

Es wird geprÅft, ob ein bestimmtes Flag (z.B. SELECTABLE) eines Objektes
(ob_flags) gesetzt ist.

is_flags: TRUE, wenn das geprÅfte Flag gesetzt ist, sonst FALSE
tree    : Zeiger auf einen Objektbaum
obj     : Index des Objekts
flags   : Flag, welches geprÅft werden soll


WORD find_type (OBJECT *tree, WORD obj, UWORD type);

Sucht ein Objekt eines bestimmten Typs in einem Objektbaum.

find_type: Index des gesuchten Objekts im Objektbaum oder NIL, wenn kein
solches Objekt gefunden wurde
tree     : Zeiger auf einen Objektbaum
obj      : Index des ersten zu untersuchenden Objekts
type     : Typ, den das gesuchte Objekt haben soll


VOID set_checkbox (OBJECT *tree, WORD obj, BOOLEAN selected);

Der Status SELECTED eines Objekts (Checkbox) wird gesetzt oder
zurÅckgesetzt.

tree    : Zeiger auf einen Objektbaum
obj     : Index des Objekts
selected: Ist der Wert TRUE, wird der Status SELECTED gesetzt, sonst
zurÅckgesetzt


BOOLEAN get_checkbox (OBJECT *tree, WORD obj);

Liefert den Status eines Objekts (Checkbox).

get_checkbox: TRUE, wenn der Status SELECTED gesetzt ist, sonst FALSE
tree        : Zeiger auf einen Objektbaum
obj         : Index des Objekts


VOID set_rbutton (OBJECT *tree, WORD obj, WORD lower, WORD upper);

Der Status SELECTED einer Gruppe von Objekten (Radio-Buttons) wird gesetzt
oder zurÅckgesetzt. Dabei wird ein Objekt selektiert, alle anderen
deselektiert.

tree : Zeiger auf einen Objektbaum
obj  : Index des Objekts, welches selektiert werden soll
lower: Index des ersten Objekts (Radio-Buttons)
upper: Index des letzten Objekts (Radio-Buttons)


WORD get_rbutton (OBJECT *tree, WORD obj);

Die Objektnummer eines selektierten Objekts (Radio-Buttons) einer Gruppe
von Objekten wird geliefert. Bei Aufruf der Funktion mu· ein Objekt
selektiert sein.

get_rbutton: Index des ersten gefundenen selektierten Objekts
tree       : Zeiger auf einen Objektbaum
obj        : Index des ersten Objekts, ab dem gesucht werden soll


VOID menu_check (OBJECT *tree, WORD obj, BOOLEAN checkit);

Es handelt sich um die gleiche Funktion wie "menu_icheck", welche vom GEM
bekannt ist. Der Unterschied besteht nur in der wesentlich schnelleren
AusfÅhrung von "menu_check".


VOID menu_enable (OBJECT *tree, WORD obj, BOOLEAN enableit);

Es handelt sich um die gleiche Funktion wie "menu_ienable", welche vom GEM
bekannt ist. Der Unterschied besteht nur in der wesentlich schnelleren
AusfÅhrung von "menu_enable". Dies macht sich vor allem in der Funktion
"updt_menu" bemerkbar, die viele solche Aufrufe tÑtigt.



VOID objc_rect (OBJECT *tree, WORD obj, RECT *rect,
                BOOLEAN calc_border);

Die aktuellen Koordinaten des Rechtecks, das ein Objekt umhÅllt. Das
Ergebnis bezieht sich auf den Koordinatenursprung in der linken oberen
Ecke des Bildschirms (x = 0, y = 0). Es kann au·erdem angegeben werden, ob
der Rand bei Objekten des Typs G_BOX, G_IBOX, G_BOXCHAR mit berÅcksichtigt
werden soll. Zu diesem Rand gehîren auch SHADOWED und OUTLINED.

tree       : Zeiger auf einen Objektbaum
obj        : Index des Objekts
rect       : Zeiger auf das resultierende Rechteck
calc_border: TRUE, wenn der Rand mit berÅcksichtigt werden soll, sonst
FALSE


VOID line_default (WORD vdi_handle);

Setzt Zeichenmodus fÅr Linien auf einen Standardwert. Dieser ist gegeben
durch eine schwarze, durchgezogene Linie mit quadratischen Ecken der
StÑrke eins, welche im Replace-Modus gezeichnet wird.

vdi_handle: Handle der VDI-Arbeitsstation


VOID text_default (WORD vdi_handle);

Setzt Zeichenmodus fÅr Text auf einen Standardwert. Dieser ist gegeben
durch normale schwarze Buchstaben im System-Zeichensatz,
die von links nach rechts im Replace-Modus gezeichnet werden.

vdi_handle: Handle der VDI-Arbeitsstation


VOID v_text (WORD vdi_handle, WORD x, WORD y,
             BYTE *string, WORD charwidth);

Die Funktion Ñhnelt der VDI-Funktion "v_gtext", nur da· damit auch Texte
eines nichtproportionalen Zeichensatzes ausgegeben werden kînnen, welche
lÑnger als 127 Zeichen sein kînnen. Dabei mu· allerdings die Breite eines
Zeichens mit angegeben werden.

vdi_handle: Handle der VDI-Arbeitsstation
x         : X-Koordinate des auszugebenden Textes
y         : Y-Koordinate des auszugebenden Textes
string    : Zeiger auf den auszugebenden Text
charwidth : Breite eines Zeichens (z.B. gl_wbox)


Die Funktion "open_dial" wurde in "opendial" umbenannt, da es eine neue
Funktion "open_dialog" gibt.

Die Funktion "close_dial" wurde in "closedial" umbenannt.

Die Funktion "mem_free" liefert kein Ergebnis mehr zurÅck, da dies nicht
in allen Systemumgebungen garantiert wird.


BOOLEAN select_file (BYTE *name, BYTE *path, BYTE *suffix,
                     BYTE *label, BYTE *filename);

Mit Hilfe der Dateiauswahl-Box von GEM kann eine Datei gewÑhlt werden.
Dabei kann ein Standard-Name (z.B. NAMENLOS.DOC) sowie ein Suffix
angegeben werden (z.B. "*.DOC"). Ab TOS 1.4 kann auch ein Label angegeben
werden. UnterstÅtzt die GEM-Version dies nicht, wird das Label ignoriert.

select_file: TRUE, wenn eine Datei ausgewÑhlt und OK gewÑhlt wurde, sonst
FALSE
name       : Zeiger auf einen Dateinamen der als Default-Namen angeboten
wird
suffix     : Zeiger auf ein Suffix, welches als Default-Suffix angeboten
wird
label      : Zeiger auf eine Zeichenkette, die als Beschriftung dient
filename   : Resultierender kompletter Dateiname

Bei dieser Funktion werden auch die globalen Variablen "fs_path", "fs_sel"
und "fs_button" gesetzt. Ist der Parameter "suffix" nicht leer, so wird er
in die Dateiauswahl-Box gesetzt, ansonsten wird das zuletzt eingestellte
Suffix benutzt.

Ist der Parameter "name" nicht leer, so wird er in die Dateiauswahl-Box
gesetzt, ansonsten wird der zuletzt gewÑhlte Name nicht verÑndert.

Wird zwar der OK-Knopf gewÑhlt, aber keine Datei spezifiziert, so hat dies
dieselbe Wirkung wie das WÑhlen des Abbruch-Knopfes.


Die Funktion "is_menu_key" wurde modifiziert. Das Zeichen fÅr Shift ist
nun nicht mehr "s", sondern der Pfeil nach oben. MenÅkÅrzel sollten also
entsprechend angepa·t werden.


Modul WINDOWS
-------------

In diesem Modul hat sich einiges getan. Dies belegt schon die Tatsache,
da· knapp 40 KB Quellcode dazugekommen sind.

ZunÑchst wurden die Window-Flags erweitert. Es bedeuten:

WI_LOCKED: Das Fenster ist gesperrt. Dieses Flag wird intern benutzt, wenn
modale Dialogboxen aufgerufen werden.

WI_FIRSTDRW: Das Fenster wurde zum erstenmal gezeichnet. Dieses Flag wird
intern benutzt, wenn eine Dialogbox in einem Fenster, welches noch nicht
gezeichnet wurde, bereits einen Mausklick erhÑlt.

WI_DLCLOSE: Das Fenster, welches eine modale oder nicht-modale Dialogbox
enthÑlt, soll geschlossen werden. Dieses Flag wird intern benutzt, wenn
der Anwender auf einen EXIT-Knopf in einer Dialogbox gedrÅckt hat. Dann
wird das Fenster geschlossen. Soll dies verhindert werden, weil
beispielsweise ein Fehlerzustand aufgetreten ist, so da· die Dialogbox
noch weiter geîffnet bleiben soll, kann dieses Flag zurÅckgesetzt werden.
Dies wird gewîhnlich in der Routine geschehen, welche auf einen Mausklick
in der Dialogbox reagiert.

WI_MODAL: Das Fenster stellt eine modale Dialogbox dar. Eine modale
Dialogbox mu· zuerst verlassen werden, bevor das Programm seine weiteren
AusfÅhrungen fortsetzt. Mehr Åber modale Dialogboxen folgt in der
Beschreibung zum Modul DIALOG.

WI_MODELESS: Das Fenster stellt eine nicht-modale (modeless) Dialogbox
dar. Eine nicht-modale Dialogbox existiert wie ein Fenster parallel zum
eigentlichen Programm. Mehr Åber modale Dialogboxen folgt in der
Beschreibung zum Modul DIALOG.

WI_CURSKEYS: Das Fenster scrollt automatisch, wenn die Pfeiltasten
gedrÅckt werden. Es gelten folgende Tastenbelegungen:
  UP: Zeile nach oben
  Shift-UP oder PGUP: Seite nach oben
  LEFT: Zeile nach links
  Shift-LEFT: Seite nach links
  RIGHT: Zeile nach rechts
  Shift-RIGHT: Seite nach rechts
  DOWN: Zeile nach unten
  Shift-DOWN oder PGDOWN: Seite nach unten
  POS1 (HOME): Anfang des Dokumentes
  END: Ende des Dokumentes

WI_MNSCROLL: Das Fenster hat eine scrollbare MenÅzeile. Ist eine MenÅzeile
in ein Fenster eingeklinkt, so ist sie nicht scrollbar, wenn dieses Flag
nicht angegeben wird. Bei kurzen MenÅzeilen kann auf die Pfeile in den
MenÅs verzichtet werden.

WI_TOPMENU: Das MenÅ des Fensters soll nur funktionieren, wenn das Fenster
ganz oben liegt. Im Normalfall kann auch das MenÅ eines unten liegenden
Fensters mit der rechten Maustaste aktiviert werden. Bei Fenstern, die
bestimmte Dinge nur tun kînnen, wenn das Fenster oben liegt, kann es
angebracht sein, mit Hilfe dieses Flags zu verhindern, da· das MenÅ
bedient werden kann, wenn das Fenster nicht oben liegt.


Der Window-Typ wurde ebenfalls erweitert. Er bietet 5 neue Komponenten:

WORD subclass;

Die Unterklasse des Fensters. Es handelt sich um einen weiteren
Bezeichner, der Fenster unterscheiden kann. Man geht davon aus, da· man
zwei Fenster hat, die fast das gleiche erledigen, wobei ein Fenster z.B.
nur eingeschrÑnkte FÑhigkeiten hat. Dann kînnen beide Fenster die gleiche
Klasse bekommen, aber verschiedene Unterklassen besitzen. Beim Aufruf von
"create_window" wird die Unterklasse gleich der Klasse gesetzt. Danach
kann sie von der Applikation geÑndert werden. Im Code, der fÅr beide
Fensterarten gleich ist, kînnen nun mit Hilfe der "subclass" die
FÑhigkeiten eines Fensters z.B. eingeschrÑnkt werden.

Um alle Fenster einer Unterklasse zu bekommen, kann man bei
"search_window" und bei "num_windows" zusÑtzlich das Flag SRCH_SUB
angeben, also z.B.

search_window (CLASS_TRASH, SRCH_OPENED | SRCH_SUB, NIL);

Der Aufruf sucht alle Papierkorbfenster der Unterklasse CLASS_TRASH. Die
Klasse des Papierkorbs kann z.B. CLASS_LIST sein, weil der Papierkorb als
Liste dargestellt wird.

WORD bg_color;

Die Hintergrundfarbe eines Fensters kann gesetzt werden. Dann wird der
Hintergrund des Fensters beim ôffnen noch vor der ersten REDRAW-Message in
dieser Farbe gezeichnet. Voreingestellt ist WHITE. Zum UnterdrÅcken des
Zeichnens mu· eine Zahl kleiner 0 (z.B. -1) angegeben werden.


WORD edit_obj;

Beinhaltet das aktuelle Objekt, in welchem sich der Cursor befindet, wenn
eine modale oder nicht-modale Dialogbox in einem Fenster nach oben kommt.
Ist der Wert <= 0, so befindet sich kein editierbares Objekt in dieser
Dialogbox. Vor jedem ôffnen einer Dialogbox sollte der Wert auf das erste
editierbare Objekt gesetzt werden.

WORD edit_inx;

Aktueller Index im editierten Objekt, d.h. der Buchstabe, hinter dem der
Cursor steht. Vor jedem ôffnen einer Dialogbox sollte der Wert
initialisiert werden. Dabei bedeutet 0, da· der Cursor sich auf dem ersten
Buchstaben befindet. Wird der Wert auf NIL (-1) gesetzt, so wird der
Cursor hinter den letzten Buchstaben gesetzt (Normalfall in GEM).


WORD exit_obj;

Aktuelles Objekt, in welches in einer modalen oder nicht-modalen Dialogbox
geklickt wurde. Meistens handelt es sich um einen Button. Ist es ein EXIT-
Button, so wird das Flag WI_DLCLOSE gesetzt und die Dialogbox geschlossen.
Ausnahmen hierzu siehe die ErlÑuterung zum Flag WI_DLCLOSE. Mit Hilfe von
"edit_obj" und "exit_obj" kann bei Auslîsen eines Tastatur- oder Klick-
Ereignisses einer Dialogbox entsprechend reagiert werden (siehe Beispiel
weiter unten).


BOOLEAN any_open (BOOLEAN incl_desk, BOOLEAN incl_closer,
                  BOOLEAN incl_modal);

Es kann getestet werden, ob irgendwelche Fenster offen sind. Dabei kann
noch spezifiziert werden, ob der Desktop auch zu den offenen Fenstern
zÑhlt (er kann meist nicht geschlossen werden), oder ob das Vorhandensein
der Schlie·box berÅcksichtigt werden soll. Au·erdem kann angegeben werden,
ob modale Dialogboxen ebenfalls zu den offenen Fenstern zÑhlen sollen.

any_open   : TRUE, wenn mindestens ein Fenster dieses Prozesses offen ist,
das auf die Spezifikation zutrifft, sonst FALSE
incl_desk  : TRUE, wenn der Desktop ebenfalls berÅcksichtigt werden soll,
sonst FALSE
incl_closer: TRUE, wenn nur Fenster berÅcksichtigt werden sollen, die auch
eine Schlie·box haben, sonst FALSE
incl_modal : TRUE, wenn modale Dialogboxen ebenfalls als offene Fenster
gezÑhlt werden sollen, sonst FALSE

Von dieser Funktion kann z.B. das Ein/Ausschalten eines MenÅs, welches
"Schlie·en" hei·t, abhÑngig gemacht werden (siehe auch Modul MENU).


WORD num_locked (VOID);

ZÑhlt die Anzahl der gesperrten Fenster. Fenster werden gesperrt, wenn
eine modale Dialogbox (auch Alertbox) geîffnet wird. Die einzigen nicht
gesperrten Fenster sind dann die Dialogbox selbst und ein eventuell
vorhandenes Hilfe-Fenster. Au·erdem natÅrlich sÑmtliche Fenster von
anderen Prozessen, die nach wie vor bedient werden kînnen.

num_locked: Anzahl der gesperrten Fenster

Die Routine wird nur vom Modul DIALOG benutzt, um ganz sicher
festzustellen, ob eine modale Dialogbox beendet wurde.


VOID cycle_window (VOID);

Holt das unterste Fenster nach oben, wenn es nicht der Desktop ist oder
durch eine modale Dialogbox gesperrt ist.


VOID set_cursor (WINDOWP window, WORD obj, WORD inx);

Setzt den Cursor einer modalen oder nicht-modalen offenen Dialogbox auf
ein bestimmtes editierbares Objekt.

window: Zeiger auf das Fenster, welches eine Dialogbox darstellt
obj   : Nummer des editierbaren Objekts, auf das der Cursor gesetzt werden
soll
inx   : Index (Buchstabe) innerhalb des Objekts oder NIL, wenn der Cursor
am Ende des Textes erscheinen soll


VOID drag_boxes (WORD num_objs, CONST RECT *boxes,
                 WINDOWP inv_window, SET inv_objs,
                 RECT *diff, CONST RECT *bound,
                 WORD x_raster, WORD y_raster);

Es kînnen mehrere Rechtecke gleichzeitig verschoben werden. Au·erdem kann
ein Fenster angegeben werden, von welchem Objekte invertiert werden, die
wÑhrend des Zieh-Vorgangs Åberstrichen werden. Ein Raster (z.B. 8 fÅr
Byteraster) gibt an, ob die Rechtecke nur auf einem imaginÑren Raster
erscheinen sollen.

num_objs  : Anzahl der Objekte, die verschoben werden
boxes     : Zeiger auf eine Rechteckliste, die "num_objs" Rechtecke
enthÑlt, welche die zu verschiebenden Rechtecke beschreiben
inv_window: Zeiger auf ein Fenster, von welchem Objekte wÑhrend des
Ziehens invertiert werden
inv_objs  : Objekte, welche innerhalb dieses Fensters selektiert werden
dÅrfen
diff      : Zeiger auf ein Rechteck, welches die Differenz der
verschobenen Rechtecke zum Ausgangspunkt angibt
bound     : Zeiger auf ein Rechteck, in welchem sich die zu verschiebenden
Rechtecke bewegen dÅrfen oder NULL, wenn sich diese innerhalb des gesamten
Desktops bewegen dÅrfen
x_raster  : X-Raster, auf dem sich die Rechtecke bewegen dÅrfen
y_raster  : Y-Raster, auf dem sich die Rechtecke bewegen dÅrfen

Die Funktion simuliert im Prinzip "graf_dragbox" des AES. Allerdings
dÅrfen hier mehrere Rechtecke angegeben werden. Au·erdem kînnen noch
Objekte eines Fensters invertiert werden. Das Zeichnen der Rechtecke ist
eine nichttriviale Aufgabe, da diese auf jedem Hintergrund korrekt
aussehen sollen (schwarze Linien). Dies gilt vor allem fÅr das Muster des
Desktop. Je nach Position des Rechtecks und Zeichenalgoritmus der vier
Linien mÅssen andere Linienmuster benutzt werden. Dieser Algorithmus
funktioniert zumindest fÅr alle Rechner bei denen der linke obere Eckpunkt
(0, 0) beim Desktop-Muster nicht gesetzt ist. Falls ein Grafikprozessor
seine Arbeit verrichtet, der das "Grau" des Desktop invertiert darstellt,
bzw. andere Algorithmen benutzt, um die Linien zu zeichnen, ist die
Routine natÅrlich nicht mehr ganz korrekt. Ein Programm, das z.B. einen
unkorrekten Algorithmus verwendet, ist das Resource-Construction-Set von
Kuma. Bewegt man dort Piktogramme, so erscheinen je nach deren Position
abwechselnd schwarze und wei·e Umrisse.

Als Ergebnis wird in "diff.w" und "diff.h" die Differenz der Boxen nach
dem Ziehvorgang zurÅckgegeben. DarÅberhinaus ist in "diff.x" und "diff.y"
die letzte Mausposition gespeichert. Beispiele fÅr diese Funktion finden
sich in den Modulen CLIPBRD und DESKTOP.


VOID draw_listobj (LISTBOX *list, WORD obj, BOOLEAN flip);

Zeichnet ein Element einer Listbox. Dabei kann noch angegeben werden, ob
das Element umgeschaltet werden soll (von selektiert auf nicht selektiert
und umgekehrt). Die Programmierung von Listboxen einschlie·lich der
Listbox-Struktur wird weiter unten erlÑutert.

list: Zeiger auf eine Listbox-Struktur
obj : Objekt, welches gezeichnet werden soll
flip: TRUE, wenn das Element umgeschaltet werden soll


BOOLEAN listbox (LISTBOX *list, UWORD flags, MKINFO *mk);

Verwaltung einer Listbox. Je nach Angabe eines Flags kînnen drei
unterschiedliche Aufgaben angefordert werden: die Initialisierung, das
Zeichnen und das Hineinklicken.

list : Zeiger auf eine Listbox-Struktur
flags: Einer der folgenden Werte:
       LIST_INIT : Die Listbox wird initialisiert
       LIST_DRAW : Die Listbox wird gezeichnet (nur mit LIST_INIT)
       LIST_CLICK: Es wurde in die Listbox geklickt
mk   : Zeiger auf eine Maus-Keyboard-Info-Struktur, falls "flags"
LIST_CLICK ist, sonst NULL

Das FLag LIST_INIT wird benutzt, um die Listbox zu initialisieren. Dies
kann auch mehrere Male geschehen (siehe Beispiel in Modul MENU). 
Das Flag LIST_DRAW wird nur in Zusammenhang mit LIST_INIT benutzt. Damit
kann man erreichen, da· diese Listbox beim Initialisieren sofort
gezeichnet wird. Dies sollte man tun, wenn sich die Listbox bereits auf
dem Bildschirm befindet und ihre Werte Ñndert (siehe Beispiel in Modul
MENU). Wird das Flag mit LIST_INIT benutzt, so mu· es mit diesem in einer
ODER-Operation verbunden werden (LIST_INIT | LIST_DRAW). Das Zeichnen
selbst geschieht ansonsten durch das Zeichnen des Fensters, in dem sich
die Dialogbox befindet.

Wird das Flag LIST_CLICK angegeben, so mu· in "mk" ein Zeiger auf die
aktuellen Werte der Maus und des Keyboards Åbergeben werden. Diese erhÑlt
man als Parameter, wenn in ein Fenster geklickt wird (siehe Beispiel in
Modul MENU).


VOID edit_noecho (MKINFO *mk, WORD cursor, BYTE *s, WORD maxlen);

Die Routine wird benîtigt, um ein Pa·wort in einer Dialogbox zu editieren.

mk    : Zeiger auf eine MKINFO-Struktur, aus der der ASCII-Code und der
Scan-Code einer Taste benutzt werden
cursor: Aktuelle Position des Schreibcursors
s     : Zeiger auf die versteckte Zeichenkette
maxlen: Maximale Anzahl der Zeichen in der versteckten Zeichenkette

Die Routine mu· immer aufgerufen werden, wenn in einer Dialogbox eine
versteckte Zeichenkette wie z.B. ein Pa·wort editiert werden kann. Der
Grund dafÅr liegt darin, da· im editierbaren GEM-Objekt nur Sternchen '*'
erscheinen sollen. Damit diese auch beim Wiederzeichnen richtig gehandhabt
werden (Dialogboxen kînnen Åberlagert werden), mÅssen im editierbaren
Objekt tatsÑchlich nur '*'-Symbole vorhanden sein. Die eigentliche
Information (z.B. das Pa·wort) mu· an einer anderen Stelle abgelegt werden
(z.B. als statische Zeichenkette im Hauptspeicher).

Jedesmal, wenn eine Taste gedrÅckt wird, wird nun vom Window-Manager ein
'*' in das GEM-Objekt eingetragen. Der Programmierer mu· nun einen
zusÑtzlichen Aufruf tÑtigen, um das eigentliche Pa·wort im Speicher zu
manipulieren. Dies nimmt die Routine "edit_noecho" ab. Sie reagiert auch
auf Sonderzeichen, ESC, BS oder DEL, so da· in der versteckten
Zeichenkette ganz normal editiert werden kann.

Mu· das Pa·wort nun ausgewertet werden, so darf nicht "get_ptext" benutzt
werden, da dieser Aufruf nur die '*'-Symbole liefern wÅrde. Stattdessen
mu· die statische Zeichenkette benutzt werden, in der zu jedem Zeitpunkt
das aktuelle Pa·wort steht.

Bei der Programmierung mu· au·erdem darauf geachtet werden, da· zu jedem
Pa·wort auch eine statische Variable angelegt wird, die den letzten Index
des Cursors in diesem Pa·wort angibt. Der Index wird zwar in der WINDOW-
Struktur festgehalten (edit_inx), aber nach dem DrÅcken beispielsweise
einer Pfeil-rechts Taste wird dieser Index um eins erhîht. Dann ist der
Wert des alten Index nicht mehr aktuell. Dieser mu· aber benutzt werden,
um die letzte Aktion in der Routine "edit_noecho" nachzufÅhren. Im Modul
MENU wird dafÅr ein Beispiel angegeben.


BOOLEAN init_windows (WORD err_nowindow, WORD maxreswind,
                      WORD class_help);

Das Modul WINDOWS wird initialisiert. Dabei wird eine Konstante fÅr die
Fehlermeldung "Keine weiteren Fenster mehr" und die Anzahl maximal zu
erwartender residenter Fenster Åbergeben. Au·erdem wird die Klasse der
Hilfe-Fenster festgelegt.

init_windows: TRUE, wenn die Initialisierung geklappt hat, sonst FALSE
err_nowindow: Index der Alertbox, die vom Window-Manager aufgerufen werden
soll, wenn keine weiteren Fenster mehr erzeugt werden kînnen oder NIL,
wenn keine Meldung erscheinen soll
max_reswind: Maximale Anzahl der zu erwartenden residenten Fenster
class_help : Nummer der Klasse eines Fensters, welche alle Hilfetexte
ausgibt (wird z.B. in der Datenbank PHOENIX benutzt).

Die Initialisierung lÑuft schief, wenn nicht mehr genÅgend Speicher zur
VerfÅgung steht, um genÅgend Strukturen des Typs WINDOW zur VerfÅgung zu
stellen. Die Anzahl der maximal gleichzeitig zur VerfÅgung stehenden
Strukturen werden in "max_reswind" Åbergeben. Eine Struktur bleibt
resident im Speicher, wenn ein Fenster beim Schlie·en nicht gelîscht wird.
Dies ist der Fall, wenn das Flag "WI_RESIDENT" gesetzt ist und es keine
Mîglichkeit gibt, das Fenster komplett zu lîschen (etwa durch eine
Piktogramm-Operation).

Die Anzahl errechnet sich folgenderma·en: Da in GEM maximal sieben Fenster
der gleichen Klasse geîffnet werden kînnen, kînnen pro Klasse, bei der die
Fenster resident bleiben, auch maximal sieben Strukturen im Speicher
stehen. Von den Fenstern, die nicht resident bleiben, kînnen maximal
sieben gleichzeitig geîffnet werden. Da beim Schlie·en auch die
Datenstruktur freigegeben wird, kann sie fÅr das nÑchste Fenster genutzt
werden. Faustregel ist also

7 * "Anzahl der residenten Klassen" + 7 + Anzahl Dialogboxen

Ausnahmen sind Klassen, bei denen nur maximal ein Fenster existieren kann.
Dies sind z.B. der Desktop oder das Papierkorb- bzw. Klemmbrettfenster. In
unserer Beispielapplikation kînnen maximal 21 Fenster existieren (maximal
sieben davon offen bzw. acht bei BerÅcksichtigung des Desktops):

1 Desktop-Fenster
1 Papierkorb-Fenster
1 Klemmbrett-Fenster
7 Grafik-Fenster

Das sind zehn Fenster, die resident im Speicher gehalten werden. Dazu
kommen maximal sieben weitere Fenster, die nicht resident sind und
deswegen nur in geîffnetem Zustand existieren:

7 Meta-Datei-Fenster oder
7 Bit-Image-Datei-Fenster oder
7 Text-Fenster oder
7 Fenster mit mathematischen Potenzen

Diese letzteren vier Klassen sind nicht resident, so da· eine beliebige
Kombination von ihnen (zusammen maximal sieben) gleichzeitig offen sein
kann.

Zu diesen Fenstern kommen alle Dialogboxen (vier bei unserem Programm), da
diese ebenfalls resident gehalten werden. Dadurch wird erreicht, da· sich
die Dialogboxen an der Stelle îffnen, an der sie zum letztenmal
geschlossen wurden. Mîchte man dies nicht, kann man das Flag WI_RESIDENT
bei Dialogboxen ausblenden. In diesem Fall mu· man auch nur ein Fenster
fÅr obige Formel berechnen.

Die Anzahl der Fenster hÑtte auch dynamisch ermittelt werden kînnen, indem
bei jedem ôffnen eines Fensters dynamisch fÅr diese eine Fensterstruktur
Speicherplatz reserviert werden wÅrde. Das hÑtte aber eine ZerstÅckelung
des Hauptspeichers zur Folge (besonders bei Accessories), was wir nicht
anstreben.

Falls man bei der Berechnung Schwierigkeiten hat, sollte man lieber eine
grî·ere Zahl angeben. 50 Fenster wird wohl niemand so schnell erreichen.
Die Grî·e einer Fensterstruktur ist sizeof (WINDOW), was z. Zt. 334 Bytes
entspricht.


Modul EVENT
-----------

Im Modul EVENT ist nun auch die UnterstÅtzung des rechten Mausknopfes
realisiert. Die folgenden globalen Variablen sind erreichbar.

GLOBAL UWORD events;

Gibt die aktuellen Ereignisse an, auf die gewartet werden soll. Die
Variable wird in "init_event" auf den Wert

MU_KEYBD | MU_BUTTON  | MU_M1 | MU_MESAG | MU_TIMER

gesetzt. Soll ein Ereignis (z.B. MU_TIMER) nicht berÅcksichtigt werden, so
kann die Variable nach Aufruf von "init_event" entsprechend modifiziert
werden. Das Ereignis MU_M1 sollte allerdings nur ausgeblendet werden, wenn
kein Fenster eine eigene Mausform hat.


GLOBAL LONG millisecs;

Gibt die aktuellen Millisekunden an, auf die bei einem Zeitereignis
gewartet werden soll. Die Variable wird mit 100 initialisiert.


GLOBAL WORD  bclicks;

Gibt die Klicks an, auf die gewartet werden soll. FrÅher wurde hier der
Wert 2 eingetragen (Doppelklick). Setzt man allerdings das niederwertigste
Bit im hîherwertigen Byte (0x0102), so wird auf die Negation des
Mausknopfereignisses gewartet. Dies bedeutet, wir kînnen beim Button-
Status (s.u.) den Wert 0 angeben. Dieser bedeutet eigentlich, warte auf
Loslassen von Mausknopf 1 und 2 gleichzeitig, da "bmask" auf 3 gesetzt
wird. Die boolesche Negation bedeutet hier also, warte auf DrÅcken von
Mausknopf 1 oder 2. Aus Loslassen wird DrÅcken, aus "und" wird "oder".
Dadurch kann statt auf das DrÅcken beider Knîpfe zusammen auf das DrÅcken
jedes der beiden Knîpfe gewartet werden.


GLOBAL WORD bmask;

Maske, die angibt, auf welche Knîpfe gewartet werden soll. Die Variable
wird auf 0x0003 initialisiert, was bedeutet, da· beide Mausknîpfe benutzt
werden sollen.


GLOBAL WORD bstate;

Maske, die angibt, ob auf DrÅcken oder Loslassen gewartet werden soll.
Durch die oben beschriebene Negation wird der Wert auf 0x0000
initialisiert und nicht mehr geÑndert. ZunÑchst wird somit auf das DrÅcken
der Mausknîpfe gewartet. Ist dies eingetreten, wird durch Wegblenden des
niederwertigsten Bits im hîherwertigen Byte von bclicks erreicht, da· nun
auf das Loslassen gewartet wird.


Die folgenden Routinen sind nun global verfÅgbar, da diese zum Teil im
Modul DIALOG aufgerufen werden.

VOID hndl_events (VOID);
VOID hndl_keybd (MKINFO *mk);
VOID hndl_button (MKINFO *mk);
VOID hndl_mesag (WORD *msgbuff);
VOID hndl_timer (LONG millisecs);

Ihre Beschreibung kann im Buch nachgelesen werden.


Modul DIALOG
------------

Dieses neue Modul wurde konzipiert, um zusammen mit dem Modul WINDOWS
modale und nicht-modale Dialogboxen sowie Alertboxen zu implementieren,
die sich in Fenstern befinden. Dadurch wird eine wesentlich hîhere
FlexibilitÑt erreicht. Beispielsweise kann bei jedem Tastendruck und
Mausklick die Applikation entscheiden, wie in der Dialogbox reagiert
werden soll. Auf diese Weise kann beispielsweise verhindert werden, da·
eine Dialogbox mit einer Fehleingabe verlassen wird.

Die Programmierung solcher Alertboxen wird weiter unten erklÑrt.

Die folgenden Definitionen sind in der Headerdatei zu finden.

#define CLASS_DIALOG  3

Die Klasse eines Dialogfensters (Dialogbox). Dabei ist es unwesentlich, ob
es sich um eine modale oder nicht-modale Dialogbox handelt. Auch
Alertboxen zÑhlen zu dieser Klasse.

#define NUM_SEP       5
#define SEP_OPEN      '['
#define SEP_CLOSE     ']'
#define SEP_LINE      '|'

Die vier Konstanten werden benutzt, um Fehlermeldungen zusammenzubauen.
Das Format der Fehlermeldungen wird bei der Fehlerbehandlung beschrieben.


typedef BOOLEAN (*HELPFUNC) (BYTE *helpmsg);

Es handelt sich um den Typ einer Hilfe-Funktion die aufgerufen wird, wenn
in einer Alertbox die Help-Taste gedrÅckt wird. Diese Hilfe-Funktion kann
mittels der Funktion "set_helpfunc" (s. u.) registriert werden.


BOOLEAN init_dialog (BYTE **alerts, OBJECT *tree,
                     WORD index, BYTE *title);

Initialisiert das Modul DIALOG.

init_dialog: TRUE, wenn das Initialisieren geklappt hat, sonst FALSE
alerts     : Zeiger auf die Tabelle der Fehlermeldungen
tree       : Zeiger auf den Objektbaum, der die Alertbox reprÑsentiert
index      : Resource-Index des obigen Objektbaumes
title      : Zeiger auf die Titelzeile aller Fehlermeldungen

Der Parameter "alerts" ist normalerweise die globale Variable aus
GLOBAL.H.

Die Alertbox fÅr den Parameter "tree" ist in der Resource-Datei SCRAP.RSC
abgelegt. FÅr eigene Anwendungen kann er aus dieser kopiert werden.

Der Parameter "index" ist in der Datei SCRAP.H definiert. Es handelt sich
um den Bezeichner fÅr den Objektbaum.

In jeder Alertbox, die ja in einem echten Fenster dargestellt wird, gibt
es eine Titelzeile (Parameter "title"). Sie soll den Namen der Applikation
wiedergeben. Sie wird nur einmal festgelegt und Ñndert sich im Laufe des
Programmablaufs nicht mehr. Damit wird gewÑhrleitet, da· Fehlermeldungen
von verschiedenen Applikationen und Accessories identifiziert werden
kînnen. Man darf in diesem Zusammenhang nicht vergessen, da· beim
Auftreten eines Fehlers zwar der aktuelle Proze· "gestoppt" wird, bis die
Fehlermeldung quittiert wird, jedoch kînnen andere Appikationen oder
Accessories bedient werden, wenn eines ihrer Fenster nach oben geholt
wird.

Ein Aufruf von "init_dialog" kînnte z.B. folgenderma·en aussehen:

  ok = init_dialog (alerts, alert, ALERT, " SCRAP ");


BOOLEAN term_dialog (VOID);

Das Modul DIALOG wird terminiert.

term_dialog: TRUE, wenn das Terminieren geklappt hat, sonst FALSE.


VOID set_helpfunc (HELPFUNC help);

Setzt die Hilfe-Funktion fÅr Alertboxen.

help: Zeiger auf eine Funktion, die aufgerufen wird, wenn in einer
Alertbox der Hilfe-Knopf gedÅckt wird oder NULL, wenn es keine Hilfe-
Funktion fÅr Alertboxen gibt.

Die Hilfe-Funktion wird aufgerufen, wenn in einer Alertbox die Hilfe-Taste
gedrÅckt wird und gleichzeitig ein Hilfe-Button definiert ist. Der
Funktion wird dann eine Zeichenkette Åbergeben, durch die der genaue
Kontext ersichtlich ist. Diese Zeichenkette kann vom Entwickler selbst
bestimmt werden und befindet sich in der Datei SCRAP.ERR. Deren Aufbau
wird bei der Fehlerbehandlung weiter unten beschrieben.

Der Aufruf von "set_helpfunc" kînnte also folgenderma·en aussehen:

set_helpfunc (appl_help);

Die Funktion "appl_help" mu· vorher deklariert weden und kann dann z.B.
folgenderma·en aussehen:

LOCAL BOOLEAN appl_help (helpmsg)
BYTE *helpmsg;

{
  return (open_help ("SCRAP.HLP", helpmsg));
} /* appl_help */

Die Funktion "open_help" wiederum sollte sich in einem Modul HELP
befinden. Ein solches Fenster hat die Klasse CLASS_HELP und wird damit
beim ôffnen nicht gesperrt. Somit kann beliebig zwischen dem Alert-Fenster
und dem Hilfe-Fenster umgeschaltet werden. Das Hilfe-Fenster kînnte aus
einer Hilfe-Datenbank, die z.B. den Namen SCRAP.HLP trÑgt, die Åbergebene
Zeichenkette heraussuchen und den entsprechenden Hilfetext darstellen. Auf
diese Weise wird bei der relationalen Datenbank PHOENIX verfahren. Die
Hilfe-Datenbank liegt im PHOENIX-Format vor, so da· der Benutzer diese
sogar editieren und erweitern kann.


WINDOWP crt_dialog (OBJECT *obj, OBJECT *menu, WORD icon,
                    BYTE *title, UWORD flags);

Kreiert eine modale oder nicht-modale Dialogbox in einem Fenster.

crt_dialog: Zeiger auf das kreierte Fenster oder NULL, wenn es nicht
kreiert werden konnte
obj       : Zeiger auf einen Objektbaum, der die Dialogbox reprÑsentiert
menu      : Zeiger auf einen Objektbaum, der eine optionale MenÅzeile
reprÑsentiert oder NULL, wenn keine MenÅzeile vorhanden sein soll
icon      : Index des Objektbaumes "obj", welcher in der Resource-Header-
Datei abgelegt ist. Dieser Wert wird in "window->icon" abgelegt
title     : Fenster-Titel der Dialogbox
flags     : ZusÑtzliche Flags, die das Verhalten des Fensters steuern.
StandardmÑ·ig ist WI_RESIDENT vorgegeben. Dazu kann kommen:
            WI_MODAL: Eine modale Dialogbox soll erzeugt werden
            WI_MODELESS: Eine nicht-modale Dialogbox soll erzeugt werden

Beim Kreieren mu· man beachten, da· fÅr modale Dialogboxen zur leichteren
Identifizierung der Schlie·-Knopf ausgeblendet wird. ZusÑtzlich sollte der
Title drei Punkte aufweisen.

Existiert ein Hilfe-Knopf (ist das HELP_FLAG gesetzt), so wird dieser
Hilfe-Knopf abgeschaltet, wenn keine Hilfe-Funktion existiert.

Da das Fenster resident kreiert wird, wird eine Dialogbox immer an der
Stelle erscheinen, an der sie zuletzt geschlossen wurde. Falls dies nicht
gewÅnscht wird, kann nach dem Kreieren das Flag durch den Befehl

window->flags &= ~ WI_RESIDENT;

ausgeblendet werden.


BOOLEAN open_dialog (WORD icon);

Ein Dialogfenster (Dialogbox) wird geîffnet.

open_dialog: TRUE, wenn das Fenster geîffnet werden konnte, sonst FALSE
icon       : Index des Objektbaumes der Dialogbox, welcher in der
Resource-Header-Datei abgelegt ist. Dieser Wert wurde bei crt_dialog in
"window->icon" abgelegt.

Kann die Dialogbox nicht geîffnet werden, so wird keine Fehlermeldung
ausgegeben, da dieses Modul applikationsunabhÑngig programmiert ist. Die
Fehlermeldung mu· vom Aufrufer ausgegeben werden.


WORD hndl_alert (WORD alert_id);

Behandelt eine Fehlermeldung.

hndl_alert: Wert des Knopfes, der zur Beendigung des Fehlerdialoges
gefÅhrt hat, wobei gilt: 1 = erster Knopf, 2 = zweiter Knopf usw.
alert_id  : Nummer der Fehlermeldung aus ERRORS.H

Die Funktion ruft lediglich "open_alert" mit der entsprechenden
Zeichenkette aus SCRAP.ERR auf.


WORD open_alert (BYTE *alertmsg);

ôffnet eine Alertbox und behandelt deren Darstellung und Interaktion.

open_alert: Wert des Knopfes, der zur Beendigung des Fehlerdialoges
gefÅhrt hat, wobei gilt: 1 = erster Knopf, 2 = zweiter Knopf usw.
alertmsg  : Zeiger auf eine Zeichenkette (z.B. aus der Datei SCRAP.ERR),
welche das folgende Format aufweisen mu·:

[Piktogramm][Fehlertext][Knîpfe][Belegung][Hilfetext]

Piktogramm kann die Werte 0 bis 3 annnehmen, wobei gilt:
0: Info-Piktogramm
1: Ausrufezeichen-Piktogramm
2: Fragezeichen-Piktogramm
3: STOP-Piktogramm

Der Fehlertext kann in einzelne Zeilen aufgespalten werden. Dabei werden
die Zeilen mit dem Zeilentrenner (SEP_LINE = '|') getrennt. Es kînnen
maximal 5 Zeilen (NUM_SEP) mit jeweils maximal 40 Zeichen definiert
werden. Ist eine Zeile zu lang, so wird sie abgeschnitten. Auf keinen Fall
ragt sie fÑlschlicherweise in die nÑchste Zeile, wie dies bei den GEM-
Alertboxen der Fall ist.

Der Text der Knîpfe wird wie der Fehlertext beschrieben. Maximal kînnen 5
Knîpfe zu jeweils maximal 12 Buchstaben Platz finden. Nicht benutzte
Knîpfe werden versteckt. Die restlichen Knîpfe werden zentriert
dargestellt.

Die Default-Belegung der Knîpfe wird im nÑchsten Feld angegeben. Sie
besteht immer aus vier Zahlen, die durch einen Separator ('|') getrennt
werden. Die vier Zahlen bedeuten:

Position 1: 1 = Klingelzeichen mit der Fehlermeldung
            2 = Kein Klingelzeichen mit der Fehlermeldung
Position 2: Nummer des Default-Knopfes oder 0, wenn nicht vorhanden
Position 3: Nummer des Abbruch-Knopfes oder 0, wenn nicht vorhanden
Position 4: Nummer des Hilfe-Knopfes oder 0, wenn nicht vorhanden

Im folgenden wird ein Beispiel fÅr eine Alertbox gegeben. In einer Datei
wie SCRAP.ERR stehen alle Alertmeldungen auf jeweils einer ganzen Zeile.
Im folgenden Beispiel mu· wegen der LÑnge die Zeile umbrochen werden.

[2]
[Drucker wird von anderem Prozess|
belegt. Soll der Prozess gespoolt|
oder auf die Freigabe des Druckers|
gewartet werden?]
[Spoolen|Warten|Abbruch|Hilfe]
[0|1|3|4]
[Warnung: Drucker belegt]

Wir haben also eine Alertbox mit Piktogramm 2 (Fragezeichen). Danach folgt
der Text der Alertbox (vier Zeilen). Es gibt vier Knîpfe. Es soll kein
Klingelzeichen ertînen (0), der Default-Knopf ist 1 (Spoolen), der
Abbruch-Knopf ist 3 (Abbruch) und der Hilfe-Knopf ist 4 (Hilfe). Wird
dieser betÑtigt, so wird die Hilfe-Funktion aufgerufen, wobei an sie die
Zeichenkette "Warnung: Drucker belegt" Åbergeben wird. Die Hilfe-Funktion
mu· vorher Åber "set_helpfunc" registriert worden sein. Ist dies nicht der
Fall, so wird der Hilfe-Knopf grau dargestellt.

Erscheint eine solche Alertbox auf dem Bildschirm, so kann sie nach
Belieben verschoben werden, da es sich um ein Fenster handelt. Au·erdem
kann eine Hilfe-Funktion aufgerufen werden, welche den eigentlichen
Programmflu· nicht stîrt. Mîchte man die Alertbox nur mit der Tastatur
bedienen, so kann man die Return-Taste, die Undo-Taste und die Help-Taste
verwenden. Au·erdem besteht die Mîglichkeit, durch die Tab-Taste bzw.
durch Shift-Tab den Default-Knopf zu verÑndern. Dieser wandert dann immer
um eine Position weiter.

Alertboxen sind nicht resident, so da· eine neue Alertbox immer in der
Mitte des Schirmes erscheint.

Tritt der Extremfall auf, da· keine Fenster mehr zur VerfÅgung stehen (7
Fenster bereits geîffnet), kann eine solche Alertbox nicht in einem
Fenster dargestellt werden. Da nun auch die Fehlermeldung "Das Objekt kann
nicht geîffnet werden!" nicht erscheinen darf (Rekursion), wird die
Alertbox als normale GEM-Dialogbox dargestellt. In diesem Fall wird der
Hilfe-Knopf abgeschaltet und die Tabulator-Steuerung sowie die Undo-Taste
funktionieren nicht mehr.


GLOBAL BOOLEAN set_alert (BOOLEAN as_dialog);

Setzt den Alertmodus. Damit kann bestimmt werden, ob Alertboxen im Fenster
oder als GEM-Dialogbox erscheinen sollen.

set_alert: Liefert den alten Alertmodus, also TRUE, wenn Alertboxen als
Dialogboxen behandelt werden sollen, sonst FALSE
as_dialog: TRUE, wenn Alertboxen als GEM-Dialogboxen behandelt werden
sollen, sonst FALSE

Das Setzen des Alertmodus ist nur nîtig, wenn beim Neuzeichnen eines
Fensters ein Fehler auftreten kann. In diesem Fall wÅrde durch eine
normale Fehlerbehandlung erreicht werden, da· beim Schlie·en der Alertbox
eine erneute REDRAW-Message des "fehlerhaften" Fensters gesendet wÅrde.
Diese wÅrde durch das Neuzeichnen eventuell wieder eine Alertbox ansto·en
usw. Durch das Setzen des Alertmodus wird erreicht, da· keine neue REDRAW-
Message gesendet wird, da der Bildschirmhintergrund der nicht-bewegbaren
Dialogbox gerettet wird. 
Ein Setzen des Alertmodus kann ebenfalls sinnvoll sein, wenn man
Statusmeldungen in einer gewîhnlichen Dialogbox ausgibt und wÑhrend dieser
Meldung ein Fehler auftreten kann. Da diese gewîhnliche Dialogbox keine
REDRAW-Message erhÑlt, wÅrde der Bildschirmhintergrund nicht richtig
restauriert werden.

Beim Setzen des Alertmodus geht man so vor, da· man sich in einer
Variablen den alten Wert merkt, und diesen wieder hineinschreibt.

Beispiel:

{
  BOOLEAN old_mode;

  old_mode = set_alert (TRUE);

  /* kritischer Bereich...  */

  set_alert (old_mode);
}

VOID hndl_modal (BOOLEAN use_timer);

Behandelt modale Dialogboxen und Alertboxen. Dabei kann angegeben werden,
ob der Timer ebenfalls berÅcksichtigt werden soll.

use_timer: TRUE, wenn der GEM-Timer berÅcksichtigt werden soll, sonst
FALSE

Die Routine hat eine eigene "evnt_multi" Schleife, die terminiert, wenn
die Situation, die zum modalen Zustand gefÅhrt hat, beendet ist. Eine
solche Situation ist z.B. das ôffnen einer modalen Dialogbox oder einer
Alertbox. Wird diese geschlossen, so terminiert die Schleife und das
Programm wird an der Aufrufstelle fortgesetzt. In der Zwischenzeit kînnen
aber beliebige Nachrichten eintreffen, wie z.B. das Neuzeichnen eines
Fensters. Diese werden ebenfalls berÅcksichtigt.

Nicht berÅcksichtigt werden MenÅ-Ereignisse (die MenÅzeile ist beim
modalen Zustand abgeschaltet) und eventuell Timer-Ereignisse, da wÑhrend
dieser Ereignisse Fehlermeldungen auftreten kînnen. Insbesondere kann
dieses bei Abarbeitung eines Fehlers sein. Es darf aber nur eine Alertbox
auf dem Bildschirm sein, da nur eine Resource dafÅr existiert. Aus diesem
Grund wird eine Alertboxbehandlung ohne Timer durchgefÅhrt.

Ruft man selbst "hndl_modal" auf, nachdem man ein Fenster geîffnet hat, so
ist dieses Fenster modal (es sperrt alle anderen Fenster bis auf das
Hilfe-Fenster) und erst nach Schlie·en desselben wird im Programm
weiterverfahren. In diesem Fall kann man "hndl_modal" mit dem Parameter
TRUE aufrufen. In der Praxis wird man aber auf einen Aufruf von
"hndl_modal" ganz verzichten kînnen, da dies intern schon fÅr modale
Dialogboxen und Alertboxen erledigt wird.

Ist Åbrigens eine modale Dialogbox geîffnet, so dÅrfen daraus weitere
modale Dialogboxen oder Alertboxen geîffnet werden. Der modale Zustand
wird durch einen jeweils neuen Aufruf von "hndl_modal" gestapelt, so da·
erst nach dem Schlie·en der letzten modalen Dialogbox das Programm an der
Ursprungsstelle weiterlÑuft. Bei jedem Aufruf von "hndl_modal" wird die
aktuelle Mausform gerettet und wieder restauriert.


Modul INITERM
-------------

In diesem Modul wurden kleinere énderungen vorgenommen, die aber wichtig
sind.

Die Konstante CLASS_HELP wird als die Ziffer 2 definiert. Normalerweise
wird die Klassenkonstante in der Headerdatei des entsprechenden Moduls
definiert (z.B. HELP.H). Hier haben wir aber aus PlatzgrÅnden auf eine
Implementierung eines eigenen Hilfe-Moduls verzichtet.

Die Konstante ALERT_NAME wird als Zeichenkette "SCRAP.ERR" definiert. Sie
gibt an, wo sich die Datei mit den Fehlermeldungen befinden soll. Sie wird
dann mittels "read_alerts", einer lokalen Funktion, eingelesen.

Der Aufruf "init_windows" wurde geÑndert:

  ok &= init_windows (NOWINDOW, MAX_RESWIND, CLASS_HELP);

Als letzter Parameter soll hier die Klasse des Hilfe-Fensters angegeben
werden. Ein echtes Hilfe-Fenster wurde hier aber nicht implementiert. Es
handelt sich um ein gewîhnliches Fenster, welches Hilfetexte ausgeben
kann. Im Modul WINDOWS wird ein Fenster dieser Klasse aber nicht gesperrt,
wenn z.B. eine modale Dialogbox oder eine Alertbox offen ist, so da· man
eine kontextsensitive Hilfe zu jedem Zeitpunkt implementieren kann. Ein
Beispiel fÅr eine solche Hilfe zeigt das relationale Datenbanksystem
PHOENIX. Dort kann zu jedem Zeitpunkt die Help-Taste bzw. F1 gedrÅckt
werden und es erscheint ein Hilfe-Fenster, das beliebig manipuliert werden
kann - auch wenn eine modale Dialogbox oder eine Alertbox offen ist.


Der Aufruf "init_dialog" wurde hinzugefÅgt:

  ok &= init_dialog (alerts, alert, ALERT,
                     (BYTE *)freetext [FDESKNAM].ob_spec);

Seine Parameter wurden bereits im Modul DIALOG erklÑrt.


ERRORS.H
--------

Die Datei ERRORS.H nimmt die Konstanten aller Fehlermeldungen auf, die in
dem Programm vorkommen kînnen. Die Fehlermeldungen mÅssen bei 0 beginnen
und fortlaufend numeriert sein. Wer mîchte, kann dies auch mit einem enum-
Feld erreichen, so sein Compiler dessen mÑchtig ist.


Modul RESOURCE
--------------

Die benutzerdefinierten Objekte (extended object types, ob_type =
G_USERDEF) haben sich geÑndert. Folgende 3 Typen stehen zur VerfÅgung:

#define DHEADER    0x0020
#define DHEIGHT    0x0040
#define DCRBUTTON  0x0080

DHEADER wird benutzt, um öberschriften fÅr Rahmen zu erzeugen. Der Text
wird um die halbe Hîhe des Systemzeichensatzes nach oben verschoben, was
in jeder Auflîsung funktioniert.

DHEIGHT wird benutzt, um ein Objekt um die halbe Hîhe des
Systemzeichensatzes kleiner zu machen. Die Knîpfe der Dialogboxen werden
mit diesem Typ versehen, damit sie nicht zu gro· erscheinen. Sie sind dann
1.5 Zeichen hoch. Auch die Dialogboxen selbst (ROOT) werden mit diesem Typ
versehen, wenn am unteren Rand Knîpfe erscheinen. Da die Knîpfe ja etwas
kleiner sind, sollte die Dialogbox selbst ebenfalls kleiner sein, um den
Abstand zum unteren Rand nicht zu gro· werden zu lassen.

DCRBUTTON wird benutzt, wenn Objekte Checkboxes oder Radiobuttons sein
sollen. Der Wert ob_flags eines Objekts mu· den Wert RBUTTON beinhalten
(wie das bei "normalen" Radiobuttons ja auch gemacht wird), wenn ein
runder Radiobutton gezeichnet werden soll. Ist RBUTTON nicht gesetzt, so
handelt es sich um eine Checkbox. Checkboxen werden im Dialogfenster
"Einstellungen" benutzt.


Beispiele:

a) Ein Knopf soll um eine halbe Zeichensatzhîhe kleiner gemacht und um
denselben Betrag nach oben verschoben werden. Das obere Byte von ob_type
mu· den Wert DHEADER + DHEIGHT = 0x60 = 96 haben.

b) Ein Radiobutton mu· in ob_flags den Wert RBUTTON besitzen und im oberen
Byte von ob_type den Wert DCRBUTTON = 0x80 = 128.

c) Soll der Radiobutton von b) noch um eine halbe Zeile nach oben
verschoben werden, so ist in ob_type der Wert DHEADER + DCRBUTTON = 0xA0 =
160 zu setzen.

Das obere Byte in ob_type kann in allen neuen Resource Construction Sets
leicht gesetzt werden. Es hei·t dort "Extended type" oder "Extended Object
Type".


Neu ist auch das Setzen von Abbruch/Hilfe-Attributen fÅr die Knîpfe von
Dialogboxen. Au·erdem kann das Attribut NO_ECHO gesetzt werden. Im
Beispiel werden die Knîpfe der Settings-Dialogbox initialisiert.

  do_flags (settings, SPASSWD, NOECHO_FLAG);
  do_flags (settings, SCANCEL, UNDO_FLAG);
  do_flags (settings, SHELP,   HELP_FLAG);

So kann das System bei DrÅcken der UNDO- bzw. HELP-Taste den richtigen
Knopf aus einer Dialogbox auswÑhlen. ZusÑtzlich kann der Window-Manager
das Echo des Passwortes unterdrÅcken.


Programmierung von Dialogboxen in Fenstern
------------------------------------------

Die Mîglichkeiten der Dialoggestaltung wurden erheblich erweitert. Es ist
jetzt mîglich, Dialogboxen in Fenstern darzustellen. Dadurch kînnen
Dialoge frei auf dem Bildschirm bewegt werden.

Des weiteren kînnen sogenannte nicht-modale Dialoge erstellt werden. Das
sind Dialogfenster, die es erlauben weiterzuarbeiten, auch wenn der Dialog
noch nicht beendet ist. Durch das einfache Setzen eines Flags (WI_MODELESS
bzw. WI_MODAL) kann der Modus bestimmt werden.

Die beiden Dialogfenster "Einstellungen" sowie "Schriftauswahl" im Modul
MENU sind nicht-modale Dialoge, die "About"-Box ist ein modaler Dialog.

Dadurch, da· man in beiden Dialogfensterarten (modal und modeless) bei
jedem Tastendruck und bei jedem Mausklick vom Modul WINDOWS aufgerufen
wird, besteht die Mîglichkeit, Dialogfenster "kontextsensitiv" zu
beeinflussen. Vorbei sind die Zeiten, in denen man das Flag "TOUCHEXIT"
setzen mu·te, um den Dialog kurzzeitig zu verlassen, wenn man z.B. den OK-
Button "grau" machen wollte, weil eine Bedingung nicht mehr erfÅllt ist.
Das geht jetzt alles viel eleganter.

Da Dialogfenster wie "normale" Fenster behandelt werden, kann man in die
Fensterstruktur (struct WINDOW) alle zur VerfÅgung stehenden Funktionen
zur Laufzeit einhÑngen, wenn diese benîtigt werden. Meistens werden es die
folgenden Funktionen sein:

- wi_click
- wi_key
- wi_showhelp
- wi_open
- wi_close
- wi_draw (seltener)

Als Beispiel dient hier das Dialogfenster fÅr die Einstellungen. ZunÑchst
folgt das Listing und dann die Beschreibung der einzelnen Funktionen.


LOCAL VOID get_settings ()
{
  STRING s;

  get_ptext (settings, SBLINK, s);
  sscanf (s, "%d", &blinkrate);

  ring_bell   = get_checkbox (settings, SBEEP);
  grow_shrink = get_checkbox (settings, SGROW);
} /* get_settings */

/*******************************************************************/

LOCAL VOID set_settings ()

{
  STRING s;

  sprintf (s, "%d", blinkrate);
  set_ptext (settings, SBLINK, s);

  set_checkbox (settings, SBEEP, ring_bell);
  set_checkbox (settings, SGROW, grow_shrink);

  undo_state (settings, SOK, DISABLED);
} /* set_settings */

/*******************************************************************/

LOCAL VOID click_settings (window, mk)
WINDOWP window;
MKINFO  *mk;

{
  switch (window->exit_obj)
  {
    case SOK     : get_settings ();
                   break;
    case SCANCEL : set_settings ();
                   break;
    case SHELP   : help_settings (NULL, NIL);
                   undo_state (window->object, window->exit_obj,
                               SELECTED);
                   draw_object (window, window->exit_obj);
                   break;
  } /* switch */
} /* click_settings */

/*******************************************************************/

LOCAL BOOLEAN key_settings (window, mk)
WINDOWP window;
MKINFO  *mk;

{
  BYTE *p;

  switch (window->edit_obj)
  {
    case SBLINK :
         p = ((TEDINFO *) settings [SBLINK].ob_spec)->te_ptext;
         if ((*p == EOS) == ! is_state (settings, SOK, DISABLED))
         {
           flip_state (settings, SOK, DISABLED);
           draw_object (window, SOK);
         } /* if */
         break;
  } /* switch */

  return (FALSE);
} /* key_settings */

/*******************************************************************/

LOCAL BOOLEAN help_settings (window, icon)
WINDOWP window;
WORD    icon;

{
  BOOLEAN ok;
  WINDOWP helpwin;

  helpwin = search_window (CLASS_DIALOG, SRCH_ANY, SETHELP);

  if (helpwin == NULL)
  {
    sethelp->ob_x = desk.x + desk.w - sethelp->ob_width;
    sethelp->ob_y = desk.y + desk.h - sethelp->ob_height;

    helpwin = crt_dialog (sethelp, NULL, SETHELP,
              (BYTE *)freetext [FHELPSET].ob_spec, WI_MODELESS);
  } /* if */

  ok = helpwin != NULL;

  if (ok)
  {
    if (helpwin->opened == 0)
    {
      helpwin->work.x = helpwin->scroll.x =
                        desk.x + desk.w - sethelp->ob_width;
      helpwin->work.y = helpwin->scroll.y =
                        desk.y + desk.h - sethelp->ob_height;
    } /* if */

    if (! open_dialog (SETHELP)) hndl_alert (ERR_NOOPEN);
  } /* if */

  return (ok);
} /* help_settings */

/*******************************************************************/

LOCAL VOID msettings ()

{
  WINDOWP window;
  WORD    ret;

  window = search_window (CLASS_DIALOG, SRCH_ANY, SETTINGS);

  if (window == NULL)
  {
    form_center (settings, &ret, &ret, &ret, &ret);
    window = crt_dialog (settings, NULL, SETTINGS,
                        (BYTE *)freetext [FSETTING].ob_spec,
                        WI_MODELESS);

    if (window != NULL)
    {
      window->click    = click_settings;
      window->key      = key_settings;
      window->showhelp = help_settings;

      undo_state (window->object, SHELP, DISABLED);
    } /* if */
  } /* if */

  if (window != NULL)
  {
    if (window->opened == 0)
    {
      window->edit_obj = find_flags (settings, ROOT, EDITABLE);
      window->edit_inx = NIL;

      set_settings ();
    } /* if */

    if (! open_dialog (SETTINGS)) hndl_alert (ERR_NOOPEN);
  } /* if */
} /* msettings */

/*******************************************************************/


LOCAL VOID msettings ()

ZunÑchst wird nachgesehen (search_window), ob das Dialogfenster schon
existiert. Dies ist der Fall, wenn es zuvor schon geîffnet wurde.
Existiert noch keines, so wird es zentriert und dann ein neues Fenster
erzeugt.

Der erste Parameter ist immer der Objektbaum der ja im RCS erstellt wurde.

Der zweite Parameter enthÑlt den Objektbaum einer MenÅleiste.
Dialogfenster kînnen also auch mit MenÅleisten ausgestattet werden (die
Funktionen updt_menu und hndl_menu mÅssen dann eingehÑngt werden, wie dies
beim Modul CLIPBRD gemacht wurde).

Der dritte Parameter ist die Konstante, die im RCS fÅr den Objektbaum
angegeben wurde (SETTINGS).

Der vierte Parameter ist die öberschrift fÅr das Dialogfenster. Sie
erscheint in der Titelzeile des Fensters.

Der letzte Parameter ist das Flag, das angibt, ob der Dialog "modal" oder
"nicht-modal" (modeless) ausgefÅhrt werden soll. In obigem Beispiel
WI_MODELESS.

Konnte das Dialogfenster erzeugt werden, so werden die Funktionen click,
key und help eingehÑngt. Dadurch werden bei einem Mausklick in das
Dialogfenster die Funktion click_settings, bei einer Taste die Funktion
key_settings und bei DrÅcken der Hilfe- bzw. F1-Taste die Funktion
help_settings aufgerufen.

Falls es wie hier eine Hilfe gibt, wird der Hilfe-Knopf selektierbar.
(undo_state...DISABLED).

Ist das Fenster gerade geschlossen (opened == 0), so werden noch 3
Initialisierungen vorgenommen. Das edit_obj wird so eingestellt, da· es
auf das erste Objekt zeigt, das editierbar (EDITABLE) ist. Der edit_inx
wir auf NIL gesetzt, was bedeutet, da· der Cursor fÅr das erste Edit-
Objekt - wie in Dialogboxen Åblich - ans Ende plaziert wird. Hier kînnte
man den Cursor auch anders einstellen.

Schlie·lich wird die Funktion set_settings aufgerufen, die die Werte aus
den globalen Variablen (blinkrate, ring_bell und grow_shrink) in die GEM-
Objekte ÅbertrÑgt. Die inverse Funktion dazu lautet get_settings. Sie holt
die Werte aus der Dialogbox und speichert sie in den entsprechenden
globalen Variablen ab.

Diese beiden Funktionen bekommen noch eine wichtige Bedeutung in der
Funktion key_settings (besonders bei nicht-modalen Dialogfenstern).

Sind die Initialisierungen vorgenommen, wird das Dialogfenster geîffnet
(open_dialog). Bei einem Fehler wird eine entsprechende Fehlermeldung Åber
hndl_alert aufgerufen.

Achtung! Ist der Dialog nicht-modal, so kehrt die Funktion open_dialog
sofort zurÅck, womit auch die Funktion msettings beendet ist. Bei
"modalen" Dialogen wird von open_dialog erst zurÅckgekehrt, wenn der
Dialog beendet ist (z.B. der OK-Knopf wurde gedrÅckt). In diesem Fall
kînnte man noch einige Aktionen unternehmen, je nachdem wie der Dialog
beendet wurde. Z.B. kînnte msettings einen Funktionswert zurÅckliefern.


LOCAL VOID get_settings (VOID)

Wie oben erwÑhnt holt diese Funktion alle Werte aus einem Objektbaum und
legt sie an geeigneter Stelle ab.


LOCAL VOID set_settings (VOID)

Diese Funktion legt die benîtigten Werte im Objektbaum ab. DafÅr eignen
sich besonders die Funktionen set_ptext, set_checkbox (fÅr Checkboxen)
sowie set_rbutton (fÅr Radiobuttons). Hier wird auch der OK-Knopf
zurÅckgesetzt, falls dieser vorher "grau" (DISABLED) war. Das kann dann
der Fall sein, wenn der Dialog vorher in einem ungÅltigen Zustand mit dem
ABBRUCH-Knopf verlassen wurde. Der OK-Knopf war in diesem Fall grau. Dies
tritt ein, wenn der Wert in der Blinkrate gelîscht wird.


LOCAL VOID click_settings (WINDOWP window, MKINFO *mk)

Diese Funktion wird vom Modul WINDOWS aufgerufen, wenn in die Dialogbox
geklickt wurde. Das Dialogfenster (window), sowie die Maus/Keyboard-
Informationen (mk) werden Åbergeben. Das exit-Objekt des Fensters ist das
Objekt, auf das man geklickt hat. In einem switch-Statement kînnen die
FÑlle behandelt werden, die wichtig erscheinen.

Wurde der OK-Knopf (SOK) gedrÅckt, so holt man die Werte aus der Dialogbox
(get_settings). Ist der Dialog "modal" ist er danach beendet. Ist er
nicht-modal und wurde mit der rechten Maustaste OK gedrÅckt, werden die
Werte geholt und fÅr das Gesamt-Programm Åber die globalen Variablen zur
VerfÅgung gestellt, aber das Fenster bleibt geîffnet.

Entsprechendes gilt fÅr den ABBRUCH-Knopf (SCANCEL). Die Funktion
set_settings sorgt bei nicht-modalen Dialogen, bei denen mit der rechten
Maustaste auf Abbruch gedrÅckt wurde dafÅr, da· die alten Werte wieder
erscheinen. Teste Sie es aus, indem Sie z.B. die Blinkrate verstellen
(hier kînnen Sie auch die +/- Tasten verwenden) und mit der rechten
Maustaste auf "Abbruch" klicken.

Wird der HILFE-Knopf gedrÅckt, so wird help_settings aufgerufen.
Anschlie·end wird der HILFE-Knopf, der ja selektiert war, wieder
zurÅckgesetzt (undo_state) und der Knopf Åber draw_object neu gezeichnet.


LOCAL BOOLEAN key_settings (WINDOWP window, MKINFO *mk)

Diese Funktion wird vom Modul WINDOWS aufgerufen, wenn eine Taste gedrÅckt
wurde. Sie mu· hier immer FALSE liefern. Das edit_obj in der WINDOW-
Struktur enthÑlt die Objektnummer an die das Zeichen gegangen ist. In
unserem Fall gibt es nur ein Editobjekt (SBLINK). Wir holen uns den Zeiger
auf den Text des Objekts. Ist der Text leer, so soll der OK-Knopf grau
werden, wenn er es nicht schon ist. Ist der Text nicht leer, so soll der
OK-Knopf schwarz dargestellt werden, um zu signalisieren, da· der
Dialogzustand gÅltig ist.

Diese KontextsensitivitÑt hilft dem Benutzer ungemein. Falsche Eingaben
kînnen schon im Vorfeld verhindert werden. So werden Fehlermeldungen
nahezu ÅberflÅssig. Die Meldung "Undefinierte Blinkrate", die erscheinen
mÅ·te, wenn OK gedrÅckt wird und das Feld Blinkrate leer war, kann
entfallen. Durch die Visualisierung (OK-Knopf grau) erhÑlt der Benutzer
au·erdem sofort ein Feedback fÅr seine Aktionen. Das Datenbanksystem
"PHOENIX", welches  bei Application Systems Heidelberg vertrieben wird und
ebenfalls von uns entwickelt wurde, macht regen Gebrauch von
kontextsensitiven und nicht-modalen Dialogfenstern.

Nur wenn sich der Zustand des OK-Knopfes Ñndert, mu· dieser neu gezeichnet
werden, da es sonst zu einem stÑndigen Flackern bei jeder Taste kommen
wÅrde. Dieser Umstand wird durch die elegante Formulierung

  if ((*p == EOS) == ! is_state (settings, SOK, DISABLED))

herbeigefÅhrt. Die erste Bedingung gibt immer an, wann der Knopf ungÅltig
ist. Die zweite Bedingung gibt an, ob der Knopf gerade gÅltig ist (!
DISABLED). Ist z.B. die Blinkrate leer und der Knopf "schwarz", so ergibt
dies TRUE == TRUE. Genau dann ist es nîtig, den Zustand des Knopfes zu
Ñndern (flip_state) und diesen neu zu zeichnen.

Das gleiche gilt fÅr "Blinkrate nicht leer" und "Knopf grau". Dann ist die
Bedingung FALSE == FALSE ebenfalls erfÅllt und der Zustand mu· geÑndert
werden. Voraussetzung fÅr das Funktionieren des "flip_state"-Trickes ist,
da· der Knopf vor dem Start des Dialoges korrekt eingestellt ist. Solch
eine korrekte Einstellung sollte am Ende von set_... gemacht werden (in
unserem Fall set_settings).


Hinweis: Die Funktionen key_ und click_ werden vom Modul WINDOWS indirekt
angesprungen und erhalten zwei Paramter (window, mk). Oft ist es nîtig, in
diesen beiden Funktionen weitere Informationen Åber das Dialogfenster zur
VerfÅgung zu haben. Was "normalen" Fenstern recht ist, sollte
Dialogfenstern billig sein. Auch hier ist es mîglich, in das Feld window-
>special z.B. einen Zeiger auf eine Struktur einzuhÑngen, die weitere
Informationen beinhaltet. Dieser Zeiger ist dann in den key- und click-
Funktionen verfÅgbar.

Bsp.:

typedef struct
{
  WORD exit_obj;
  WORD blinkrate;
} SET_SPEC;

SET_SPEC set_spec;

...
  window->click    = click_settings;
  window->key      = key_settings;
  window->showhelp = help_settings;
  window->special  = (LONG)&set_spec;
...

Und in click_... hei·t es dann:

SET_SPEC *set_spec;

set_spec = (SET_SPEC *)window->special;


LOCAL BOOLEAN help_settings (WINDOWP window, WORD icon)

In der Help-Funktion wird nach einem vorhandenen Hilfe-Fenster gesucht.
Ist keines da, so wird der Objektbaum auf die rechte untere Ecke des
Bildschirmes gelegt. Dort stîrt das Hilfe-Fenster am wenigsten. Dann wird
der Dialog kreiert (crt_dialog).

Bei erfolgreichem Erzeugen wird, wenn das Fenster nicht offen war, der
Arbeits- sowie der Scrollbereich des Hilfe-Fensters ebenfalls auf den
rechten unteren Bereich des Desktops gesetzt. WÅrde man das nicht tun, so
wÅrde das Hilfe-Fenster, wenn es einmal geschlossen wurde, immer an der
alten Position erscheinen. Das soll beim Hilfe-Fenster aber gerade nicht
passieren.


Programmierung von Listboxen
----------------------------

Das Modul Windows wurde um die Darstellung von Listboxen erweitert. Eine
Listbox besteht aus mehreren Objekten. Das Wurzelobjekt (ROOT) ist eine
Box, die alle Komponenten einer Listbox enthÑlt. Das Objekt ITEMS enthÑlt
alle Textzeilen einer Listbox. Das Objekt PARENT ist eine Box, die die
Elemente der Schieber enthÑlt. Er wird SLIDER genannt, die beiden Pfeile
hei·en UP und DOWN.

Im SCRAP-Programm wurden zwei Listboxen implementiert, um ZeichensÑtze
bzw. Punktgrî·en auszuwÑhlen. Die Objekte der Font-Listbox beginnen mit
SF... (SelFont), die der Punktgrî·en mit SS (SelSize). Beispiel fÅr die
Font-Listbox:


#define SFROOT   3      /* BOX in tree SELFONT */
#define SFITEMS  4      /* BOX in tree SELFONT */
#define SFPARENT 12     /* BOX in tree SELFONT */
#define SFSLIDER 13     /* BOX in tree SELFONT */
#define SFUP     14     /* BOXCHAR in tree SELFONT */
#define SFDOWN   15     /* BOXCHAR in tree SELFONT */


Um weitere Listboxen in anderen Dialogboxen zu benutzen, kopieren Sie sich
eine der beiden Listboxen in Ihre Dialogbox hinein. Um eine Listbox mit
der Maus greifen zu kînnen, gehen Sie im Resource Construction Set wie
folgt vor: DrÅcken Sie die Control-Taste und schieben den gepunkteten
Bereich des Sliders der gewÅnschten Listbox um ein Zeichen nach links
(Durch das DrÅcken der Control-Taste erreichen Sie das Objekt SFPARENT).
Darunter kommt das Wurzelobjekt (SFROOT) der Listbox zum Vorschein. Diese
Objekt kînnen Sie greifen und verschieben oder kopieren. Es beinhaltet
alle Objekte der Listbox. Schieben Sie zum Schlu· den gepunkteten Bereich
des Sliders wieder in die alte Position.

Das Objekt SFITEMS kînnen Sie selektieren, wenn Sie die Control-Taste
betÑtigen und auf irgendeine Textzeile in der Listbox klicken.

Achtung! Sortieren Sie die Listbox nie, da sonst die benîtigte Reihenfolge
der Objekte nicht eingehalten wird!

Nach dem Kopieren von Listboxen geben Sie den 6 o.g. Objekten bitte wieder
neue Namen. Die benîtigen Sie fÅr die Initialisierung der Listbox.


Die Datenstruktur LISTBOX (WINDOWS.H):

#define LIST_INIT   0x01          /* Initialisiere Listbox */
#define LIST_DRAW   0x02          /* Zeichne Listbox */
#define LIST_CLICK  0x04          /* Klick in Listbox */


typedef struct
{
  WINDOWP window;       /* Fenster der Listbox */
  OBJECT  *tree;        /* Objektbaum der Listbox */
  VOID    *itemlist;    /* Liste der Structs aller EintrÑge */
  SIZE_T  itemsize;     /* Grî·e eines Elements */
  BOOLEAN indirect;     /* Elemente sind Zeiger auf Zeichenketten */
  WORD    num_items;    /* Anzahl verfÅgbarer EintrÑge */
  WORD    vis_items;    /* Anzahl sichtbarer EintrÑge  */
  WORD    width;        /* Breite eines Eintrags */
  WORD    first_item;   /* Erster Eintrag in Listbox */
  WORD    active;       /* Aktiver Eintrag in Listbox */
  UWORD   sel_state;    /* Status, mit dem selektiert wird */
  WORD    root;         /* Objektnummer der Listbox */
  WORD    items;        /* Objektnummer der Box mit EintrÑgen */
  WORD    up;           /* Objektnummer des Hoch-Pfeils */
  WORD    down;         /* Objektnummer des Unten-Pfeils */
  WORD    parent;       /* Objnummer des Elternteils des Schiebers */
  WORD    slider;       /* Objektnummer des Schiebers */
} LISTBOX;


Bemerkungen:

Das Feld "itemlist" enthÑlt die Texte aller EintrÑge. Die Texte kînnen
auch aus Strukturen bestehen, die weitere Informationen neben den Texten
enthalten kînnen. Im Font-Beispiel sind die Texte in "fnames" direkt
gespeichert. Der zugehîrige Speicher wird dynamisch alloziert und
freigegeben, wenn das Dialogfenster wieder geschlossen wird. Die Texte in
"itemlist" kînnen breiter sein als der Platz, der in der Dialogbox
reserviert ist. Die Zeichenketten werden vor der Ausgabe entsprechend
gekÅrzt.

Beispiel fÅr eine Struktur:

typedef struct
{
  LONG Nummer;
  BYTE Name [40];
  BYTE Ort [20];
} KUNDE;

KUNDE kunden [100];

Die Initialisierung fÅr eine Namensliste mu· wie folgt aussehen:

  fnames.itemlist  = kunden [0].Name;
  fnames.itemsize  = sizeof (KUNDE);
  fnames.indirect  = FALSE;
  fnames.num_items = 100;


Sind nicht die Namen, sondern nur Zeiger auf die Namen in der Struktur
abgelegt, so mu· das Flag "indirect" auf TRUE gesetzt werden. Beispiel:

typedef struct
{
  LONG Nummer;
  BYTE *Name;
  BYTE *Ort;
} KUNDE;

KUNDE kunden [100];

  ...
  fnames.indirect = TRUE;


Das Feld "sel_state" enthÑlt den Status, der benutzt werden soll, wenn
eine Zeile selektiert wird. Man wird CHECKED oder SELECTED benutzen.
CHECKED zeichnet ein HÑkchen vor das selektierte Objekt (Namen sollten aus
PlatzgrÅnden mit zwei Leerzeichen beginnen). SELECTED invertiert die
aktuell angewÑhlte Zeile.


Initialisierung fÅr das FONT-Beispiel: (siehe MENU.C)

  wnames = selfont [SFITEMS].ob_width / gl_wbox;
  size   = wnames + 1;    /* EOS-Zeichen */
  if (fnames == NULL)
    fnames = mem_alloc ((LONG)num_fonts * size);

  lnames.window     = search_window (CLASS_DIALOG,
                                     SRCH_ANY, SELFONT);
  lnames.tree       = selfont;
  lnames.itemlist   = fnames;
  lnames.itemsize   = size;
  lnames.indirect   = FALSE;
  lnames.num_items  = num_fonts;
  lnames.first_item = (inx >= nlines) ? inx : 0;
  lnames.active     = inx;
  lnames.sel_state  = CHECKED;
  lnames.root       = SFROOT;
  lnames.items      = SFITEMS;
  lnames.up         = SFUP;
  lnames.down       = SFDOWN;
  lnames.parent     = SFPARENT;
  lnames.slider     = SFSLIDER;

  if (fnames != NULL) set_lnames (num_fonts);
  listbox (&lnames, LIST_INIT, NULL);


Ist die Struktur belegt, so ruft man listbox mit dem Befehl LIST_INIT auf.
Der 3. Parameter ist ein Zeiger auf die Struktur MKINFO und wird nur bei
LIST_CLICK benîtigt. In obigem Beispiel setzt die Funktion set_lnames noch
die Namen der Fonts in das Feld "itemlist".


Nachdem die Listbox initialisiert ist, mu· sie auf Mausaktionen reagieren.
In der Funktion click_font wird dies wie folgt erreicht:


  if ((SFROOT <= window->exit_obj) &&
      (window->exit_obj <= SFDOWN))
  {
    active = lnames.active;
    dclick = listbox (&lnames, LIST_CLICK, mk);
    set_fonttable (font_table [lnames.active]);

    if (active != lnames.active)
    {
      lsizes.first_item = 0;
      lsizes.active     = 0;
      sel_point         = point_table [0];
      num_points        = 0;

      while (point_table [num_points] != 0) num_points++;
      set_lsizes (num_points);
      listbox (&lsizes, LIST_INIT | LIST_DRAW, mk);
      draw_font (window);
    } /* if */
  } /* if */


ZunÑchst wird getestet, ob sich das exit_obj im Bereich der Fontliste
befindet (SFROOT bis SFDOWN). Dann merken wir uns den alten selektierten
(aktiven) Wert, um spÑter testen zu kînnen, ob der Benutzer ein anderes
als das schon selektierte Objekt angewÑhlt hat.


Jetzt wird die Funktion listbox aufgerufen. Der Befehl ist LIST_CLICK mit
den aktuellen Mausinformationen (mk). Man erhÑlt zurÅck, ob ein
Doppelklick auf ein selektiertes Objekt angewendet wurde. Die
Zeichensatzgrî·en fÅr den neuen selektierten Font werden berechnet.


Wurde ein neuer Font gewÑhlt (ative != lnames.active), so wird die Listbox
"lsizes", die ja die Punktgrî·en enthÑlt mit den Grî·en des neuen Fonts
initialisiert, die Texte gesetzt (set_lsizes) und die Listbox sowohl
initialisiert, als auch neu gezeichnet (LIST_INIT | LIST_DRAW). Der
Beispieltext wird ebenfalls neu gesetzt (draw_font).


Schauen Sie sich bitte die Funktion draw_font genauer an, falls Sie in
Dialogboxen etwas zeichnen mîchten, was Sie nicht in der Resource-Datei
anlegen kînnen. Sie mÅssen dann Ihre Zeichenfunktion in die
Fensterstruktur der Dialogbox einhÑngen. In mselfont wird dies mit

  window->draw = draw_font

realisiert. In der Funktion draw_font darf das Clipping nur gesetzt
werden, wenn es sich um das oberste Fenster handelt, sonst wird das
Clipping ja durch das redraw vom Window-Manager automatisch gesetzt. Man
mu· es setzen, wenn das Fenster oben ist, da nach einem Scrollen oder
Klicken in eine Listbox das Clipping von der Listbox-Funktion verstellt
wird.


Zusatz zur Bedienung von SCRAP
------------------------------

Die MenÅleiste enthÑlt jetzt unter dem MenÅ "Optionen" die MenÅpunkte


Schriften laden
Schriften freigeben
Schriftauswahl...

Die Texte wurden komplett ins Deutsche Åbersetzt (ehemals Fonts laden
usw.).

Fall Sie GDOS installiert haben, sollten Sie Schriften laden, um besser
mit dem neuen Dialogfenster "Schriftauswahl" experimentieren zu kînnen.

Das Dialogfenster "Schriftauswahl" ist ein sogenannter nicht-modaler
Dialog. Nach der Anwahl des MenÅpunktes "Schriftauswahl..." erscheint das
Fenster in der Mitte des Bildschirms. Dort kînnen Sie mit der Maus eine
neue Schrift oder eine andere Schriftgrî·e auswÑhlen. Ein Beispieltext
zeigt sofort die Auswahl an.

FÅhrt man einen Doppelklick auf eine Schrift oder eine Punktgrî·e aus, so
wird das Dialogfenster mit "OK" verlassen.

Die ausgewÑhlte Schrift wird benutzt, um das nÑchste noch nicht geîffnete
"Power"-Fenster damit anzuzeigen. Ein geîffnetes "Power"-Fenster behÑlt
die Schrift, mit der es zum erstenmal geîffnet wurde, bei.

Da die Schriftauswahl nicht-modal ist, kann man mit der rechten Maustaste
die Knîpfe drÅcken, ohne das Fenster zu schlie·en. DrÅckt man also mit der
rechten Maustaste auf "OK", so wird die gewÑhlte Schrift und Grî·e
Åbernommen und fÅr das nÑchste "Power"-Fenster benutzt. DrÅckt man mit der
rechten Maustaste auf "Abbruch", so wird die letzte Einstellung
zurÅckgeholt. Ein Klicken mit der rechten Maustaste auf die Knîpfe eines
nicht-modalen Dialogfensters bewirkt also das gleiche wie mit der linken
Taste, ohne jedoch den Dialog zu beenden.

Experimentieren Sie doch damit, da· Sie in der Funktion mselfont im Modul
MENU.C statt WI_MODELESS ein WI_MODAL schreiben und die Auswirkungen
beobachten.

Die ausgewÑhlte Schrift, sowie die Schriftgrî·e werden im special-Wert der
"Power"-Window-Struktur im zweiten sowie dritten Byte abgelegt.
