UFSL Universal Fontselector (c) 1991-1993 by Michael ThÑnitz

UFSL ist Freeware.

Wo liegt eigentlich das Problem? Nun ganz einfach, die Einstellung eines
anderen als des Systemfonts ist eigentlich recht trivial. vst_font()
stellt den Font ein, vst_point() stellt die Grî·e ein. Woher wei· man
aber nun welche Fonts es gibt und in welchen Grî·en sie vorliegen?
Auch das ist recht einfach. Man lÑdt die Fonts, klappert alle Fonts nach
Ihren "echten" Grî·en ab und stellt alles in einer Listbox dar.
Tja, und da liegt das Problem. Ist die Abfage der Grî·en schon ein klein
wenig kompliziert, schmei·en bei Listbox die meisten Gelegenheits-
programmierer das Handtuch. Entsprechend bescheiden sind dann auch die
Ergebnisse. Hier springt UFSL nun ein und bietet den gleichen einfach
zu programmierenden Komfort wie bei der Fileselectbox. Einfach die
Fontauswahlbox mit einigen einfach zu erfahrenen Parametern versorgen,
Åber den Cookie aufrufen und man erhÑlt FontId und die Punktgrî·e zurÅck.
Ein entsprechendes Beispiel liegt mit FONTTEST.C vor. Der Programmierer
entscheidet, ob es sich um einen konventionellen Dialog mit Let 'em Fly
UnterstÅtzung oder um einen Fensterdialog handelt.

UFSL darf jedem Programm ohne RÅcksprache kostenlos beigelegt werden.
Trotzdem interessiert es mich natÅrlich, wo UFSL Åberall beiliegt.

UFSL nutzt die Mîglichkeiten von "Let 'em Fly" laut Doku Version 1.17.
UFSL stellt beliebig viele Fonts mit je max. 16 Grîûen dar.

***************************************************************************

Programmierschnittstelle:
-------------------------
UFSL ist eine Fontauswahlbox fÅr den Autoordner. Sie bietet dem
Programmierer eine einfache Programmierschnittstelle Åber einen Cookie.

Der Cookie lautet: 'UFSL'.
Der Cookie liefert einen Zeiger auf folgende Struktur:

typedef struct
{
   unsigned long  id;      /* UFSL ID (UFSL)       */
   unsigned int   version; /* Version (BCD-Format) */
   int dialtyp;            /* 0=Dialog, 1=Fenster  */
   int cdecl (*font_selinit)(void);
   int cdecl (*font_selinput)(
               int vdihandle,
               char *text,    /* eigener Text, max. 34 Zeichen      */
               int ftype,     /* 1=nur monospaced Fonts, 0=alles    */
               int *fretid,   /* eingestellte FontId                */
               int *fretsize  /* eingestellte Fontgrîûe             */
               );
   OBJECT *helpbutton;           /* Typ: BOXTEXT                    */
   void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */

   /**** ab Version 0.91 ********************************************/
   char *examplestr;            /* Beispieltext fÅr Fontdarstellung */

   /**** ab Version 0.96 ********************************************/
   void cdecl (*msgfunc)(int event, int msgbuf[]);/* Redrawfunktion */
} UFSL;

Aufruf:
-------
UFSL *ufsl;
ufsl=(UFSL *)get_cookie('UFSL');
ufsl->helpfunc= my_helpfunc;   /* Hilfefunktion oder NULL */
ufsl->msgfunc = my_msghandler; /* Redrawfunktion oder NULL, Dialtyp beachten */
ufsl->fontsel_input(vdihandle,"Bitte Font auswÑhlen",0,&id,&size);
oder
ufsl->fontsel_input(vdihandle,NULL,0,&id,&size);

Returncodes:
------------
 1 : Alles OK, Werte gÅltig.
 0 : Abbruch gewÑhlt.
-1 : Out of memory.
-2 : UnzulÑssiger Mehrfachaufruf.
-3 : Fontgrîûe konnte nicht identifiziert werden.
-4 : Anzahl Fonts muû grîûer null sein.

Sonderfunktionen:
-----------------
void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */

UFSL kann eine benutzerdefinierbare Hilfefunktion Åber den ebenfalls
optionalen Hilfebutton aufrufen. helpfunc() benîtigt keine Parameter
und liefert auch keinen Wert zurÅck.



void cdecl (*msgfunc)(int event, int msgbuf[]);/* Redrawfunktion */

Bei Verwendung von UFSL als Fensterdialog ist es notwendig eine
Redrawfunktion zur VerfÅgung zu stellen. Sie schickt die anfallenden
Events an das aufrufende Programm zurÅck, damit nach Verschieben
des Dialogs die Hintergrundfenster restauriert werden kînnen.
msgfunc() liefert als ersten Parameter das Ergebnis von evnt_multi()
und als zweiten Parameter die MsgPipe. Ein Returncode wird nicht
benîtigt. Das Anwenderprogramm mu· die nîtigen Routinen zur Fenster-
behandlung zur VerfÅgung stellen. wind_update(..._UPDATE) wird von
UFSL nicht gesetzt, obliegt also dem rufenden Anwenderprogramm.
Prinzipbedingt(?) ist die Memoryprotection von MTOS auszuschalten.

GrundsÑtzlich gilt es zu Åberlegen, ob tatsÑchlich alle Events
entsprechend beantwortet werden sollen. Ein WM_TOPPED, das andere
eigene Fenster nach vorn bringt, sollte wohl nicht beantwortet werden,
da UFSL naturgemÑ· nur applikationsmodal sein kann, da UFSL ja in 
einem eigenen form_do() sprich evnt_multi() kreist.

***************************************************************************

VersionsÅbersicht:
------------------

Version 0.90 vom Mai 1993 (Dezember 1991)
-----------------------------------------
Ich mîchte noch anmerken, das die Cookieinstallation noch recht dÅrftig
ist. Es wird einfach installiert, ohne zu fragen ob Platz ist. Das Profibuch
bietet hierzu eine m.E. fehlerhafte Beschreibung. Es wird von einen Nullcookie
und seines Wertes gesprochen. Das ist m.E. ein Syntaxerror. Wer also
vernÅnftige Cookieroutinen in 'C' hat, mîchte mir doch bitte weiterhelfen.

Dem Fensterdialog mu· noch seine UnmodalitÑt abgewîhnt werden.

Version 0.91 vom Mai 1993
-------------------------
Die Cookiefrage ist geklÑrt durch Assemblerroutinen von Arnd Beissner.
Alle benutzerdefinierten Variablen werden beim Verlassen zurÅckgesetzt.
Fonteinstellung Åber Editfeld mit Mausdoppelklick auf Beispieltext.(Nur
Speedo).

Version 0.92 vom Juni 1993
--------------------------
UFSL erkennt Auflîsungswechsel und initialisiert sein Resourcefile neu.

Version 0.93 vom Juli 1993
--------------------------
Bugfix. appl_init() entfernt. Unter MTOS gabs dabei einen Absturz.

Version 0.94 - 0.95 vom August/September 1993
---------------------------------------------
Erweiterte Returncodes fÅr detailiertere Fehlermeldungen.

Version 0.96 vom November/Dezember 1993
---------------------------------------
Returnwerte fÅr FontId und FontSize bleiben bei ABBRUCH unangetastet.
Das gilt auch fÅr die Attribute des Åbergebenen VdiHandles, weil ein
internes VdiHandle genutzt wird. ufsl->msgfunc(event, msgbuf) ruft
fÅr die programmeigenen Fenster deren Redrawfunktion auf, damit beim
Verschieben von UFSL der Hintergrund restauriert wird. "dummy font"
wird ausgewertet.

***************************************************************************

MfG Michael ThÑnitz

Email: MICHAEL THAENITZ @BI im Mausnetz