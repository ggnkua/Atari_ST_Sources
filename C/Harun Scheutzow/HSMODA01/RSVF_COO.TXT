Datenstruktur zur Abfrage und Anzeige zus„tzlicher M”glichkeiten der 
seriellen (und evtl. sonstiger) Kommunikationsroutinen
====================================================================

Cookie
------
Name: RSVF  (RS232 Version Fast)
Wert: Zeiger auf Datenstruktur
      Zeiger muá <>0 sein und auf gerade Adresse weisen

Datenstruktur
-------------
Beliebig viele Objekte sind als Liste hintereinander abgelegt. An das Ende 
einer Liste kann ber eine Verkettung eine weitere Liste angeh„ngt sein. 
Am Ende der letzten Liste befindet sich eine Ende-Kennung.

Objekt
------
Jedes Objekt ist 8 Byte lang und beginnt auf einer geraden Adresse. 
Byte 0..3 sind ein Zeiger auf den Namen der Schnittstelle (Filename) im 
ASCII-Code. Der Name mu auf einer geraden Adresse beginnen und ist 
nullterminiert.
Byte 4..7 enthalten Angaben ber die Eigenschaften des Objektes (der 
Schnittstelle). Noch nicht definierte Bits/Bytes mssen vom anlegenden 
Programm auf 0 gesetzt werden.
Sollten irgendwann zus„tzliche Informationen n”tig werden, so wird deren 
Vorhandensein auf noch zu definierende Weise in Byte 4..7 angezeigt. Die 
Informationen selbst liegen dann vor dem Namen der Schnittstelle.

Besondere Objekte
-----------------
Bei besonderen Objekten ist Byte4.Bit7 =0.
Ende-Objekt:
 Byte 0..3  0, ein NIL-Zeiger, kennzeichnet das Ende der Datenstuktur  
Verkettungsobjekt:
 Byte 0..3  Zeiger auf die n„chste Liste mit Objekten.

Eigenschaftsdefinitionen im Wert
--------------------------------
Byte 4:
 Bit7  =1: dieser Name ist eine Schnittstelle
 Bit6  =1: Schnittstelle ist dem GEMDOS fr File-I/O bekannt
 Bit5  =1: Schnittstelle ist dem BIOS bekannt (Bco*-Routinen)
 fr den Rest f„llt uns noch was ein (F„higkeiten der Schnittstelle)
Byte 5:
 noch frei 
Byte 6:
 BIOS-Nummer der Schnittstelle (Bco*-Routinen)
Byte 7:
 noch frei


Sinn und Zweck
--------------
Kommunikationsprogramme k”nnen durch RSVF herausfinden, welche 
Schnittstellen fr sie geeignet erscheinen. Auerdem erfahren sie die 
Zuordnung von GEMDOS-Ger„tetreibername (in U:\DEV\) zur BIOS-Ger„tenummer.


Mindestforderung an Treiber bei gesetztem GEMDOS-Bit
----------------------------------------------------
Fopen, Fclose, Fread, Fwrite, Fcntl werden behandelt. Falls eine Funktion 
(oder auch Unterfunktion von Fcntl) nicht vorhanden ist, muá dafr ein 
Fehlercode (mglst. Fehlercode -32 (EINVFN)) geliefert werden.

Fopen darf immer nur mit dem vollen Pfad "U:\DEV\devicename" erfolgen. 
Konstruktionen mit Dsetdrv und Dsetpath sind UNZULSSIG.

Fcntl hat die Funktionsnummer $0104 und die Parameter:
handle, special, subfunction
handle:      16Bit filehandle
special:     32Bit parameter for subfunction
subfunction: 16Bit number of subfunction


MiNT-kompatible Funktionen der Treiber
--------------------------------------
Fopen fr Lesen&Schreiben auf "U:\DEV\MODEM1" und natrlich Fclose.
Fwrite und Fread sind nichtblockierend, d.h. es werden immer nur soviel Byte 
bertragen, wie der serielle Puffer aufnehmen/liefern kann. So sollten auch 
andere Treiber arbeiten.

Rckgabewert der Fcntl-Funktionen ist 0 fr fehlerfreie Durchfhrung oder 
ein negativer Fehlercode (32Bit-Wert), falls nicht extra beschrieben.

Manche Zeilen sind C, manche Kommentar. Bei den angegebenen 
Funktionsaufrufen handelt es sich wirklich um Musteraufrufe, und nicht etwa 
um migestaltete Prototypen.



Ermittlung, wieviel Byte nichtblockierend bertragen werden k”nnen
------------------------------------------------------------------
#define FIONREAD  (('F'<< 8) | 1)
#define FIONWRITE (('F'<< 8) | 2)
long Fcntl( handle, &count, FIONREAD)
long Fcntl( handle, &count, FIONWRITE)
In count wird als 32Bit-Wert die Anzahl der Byte hinterlassen, die beim 
n„chsten Fread/Fwrite mindestens gelesen/geschrieben werden k”nnen. Da aber 
m”glicherweise mehrere Programme auf einen Port schreiben k”nnten, sollte 
man nur den Returnwert von Fread/Fwrite fr voll nehmen. (Anmerkung: meine 
Treiber liefern richtige Werte, mir bekannte MiNT-Versionen aber nur 
entweder 0 oder 1, so da man unter MiNT momentan hiervon nicht viel hat.)


Setzen und Rcksetzen von Break
-------------------------------
#define TIOCCBRK (('T'<< 8) | 20)
#define TIOCSBRK (('T'<< 8) | 21)
Fcntl( handle, dummy, TIOCSBRK); /* Break aktivieren */
Fcntl( handle, dummy, TIOCCBRK); /* Break l”schen */


Setzen/Abfragen der Eingabegeschwindigkeit und Steuerung der DTR-Leitung
------------------------------------------------------------------------
#define TIOCIBAUD (('T'<< 8) | 18)
Fcntl( handle, &speed, TIOCIBAUD);
Setze die Eingabegeschwindigkeit der Schnittstelle. In speed steht ein 
32Bit-Wert, der die gewnschte Geschwindigkeit unkodiert in Bit pro Sekunde 
angibt. speed = 19200 wrde auf 19200bps setzen. In speed wird die 
Geschwindigkeit vor dem Aufruf von TIOCIBAUD zurckgegeben. Ist sie 
unbekannt, wird -1 geliefert. Ist beim Aufruf speed = -1, so wird nur die 
Geschwindigkeit erfragt. Ist speed = 0, so wird das DTR-Signal auf inaktiv 
gebracht (gel”scht), ohne die Geschwindigkeit zu beeinflussen. Bei 
geschwindigkeitssetzendem Aufruf wird DTR automatisch aktiviert. 
Rckgabewert ist ERANGE wenn die Geschwindigkeit nicht einstellbar ist. 
Dann wird als "Ausnahme" in speed die n„chstniedrigere m”gliche 
Geschwindigkeit geliefert. Gibt es keine n„chstniedrige, so wird die 
kleinstm”gliche zurckgegeben.


Setzen/Abfragen der Ausgabegeschwindigkeit und Steuerung der DTR-Leitung 
------------------------------------------------------------------------
#define TIOCOBAUD (('T'<< 8) | 19) Fcntl( handle, &speed, TIOCOBAUD);
Setze die Ausgabegeschwindigkeit der Schnittstelle. Die 
Funktionsbeschreibung ist identisch zu TIOCIBAUD. Untersttzt eine 
Schnittstelle getrennte Ein- und Ausgabegeschwindigkeit nicht, so 
beeinflut jeder Aufruf beide Geschwindigkeiten.


šbertragungsprotokolleinstellungen erfragen
-------------------------------------------
#define TIOCGFLAGS (('T'<< 8) | 22)
Fcntl( handle, &flags, TIOCGFLAGS);
Liefert in flags einen 16Bit-Wert der eingestellten Parameter, die eine 
ODER-Verknpfung der folgenden Werte darstellen. Alle anderen Bit sind 
reserviert. Bei TIOCGFLAGS sollte man sie ignorieren. Sinnvollerweise 
erfragt man mit TIOCGFLAGS, modifiziert die bekannten Werte, und setzt dann 
per TIOCSFLAGS.

/* Anzahl der Stoppbits */
#define TF_STOPBITS 0x0003
/* 0x0000  nicht erlaubt (Anmerkung: Meine Wenigkeit schl„gt vor, damit
           einen evtl. vorhandenen Synchronmode zu aktivieren.) */
#define TF_1STOP   0x0001 /* 1 Stoppbit */
#define TF_15STOP  0x0002 /* 1.5 Stoppbit */
#define	TF_2STOP   0x0003 /* 2 Stoppbit */

/* Anzahl der Bits pro Zeichen */
#define TF_CHARBITS 0x000C
#define TF_8BIT	0x0 /* 8 Bit */
#define TF_7BIT	0x4
#define TF_6BIT	0x8
#define TF_5BIT	0xC /* 5 Bit */

/* Handshakemodi und Parit„t */
#define TF_FLAG  0xF000
#define T_TANDEM 0x1000 /* XON/XOFF (=^Q/^S) Flukontrolle aktiv */
#define T_RTSCTS 0x2000 /* RTS/CTS Flukontrolle aktiv */
#define T_EVENP  0x4000 /* even (gerade) Parit„t aktiv */
#define T_ODDP   0x8000 /* odd (ungerade) Parit„t aktiv */
/* even und odd schlieen sich gegenseitig aus */


šbertragungsprotokolleinstellungen setzen
-----------------------------------------
#define TIOCSFLAGS (('T'<< 8) | 23)
Fcntl( handle, &flags, TIOCSFLAGS);
Setzt die Einstellungen, Beschreibung dieser bei TIOCGFLAGS. Rckgabewert 
ist ERANGE bei illegaler / nicht untersttzer Kombination in flags.


Weitere Funktionen
------------------
Erweiterte Funktionen zum Einstellen der Schnittstelle, zur šberwachung 
der Signalleitungen (z.B. DCD, RING), zum L”schen der Sende- und 
Empfangspuffer sind im Textfile

SERSOFST.TXT

definiert. Einige werden von meinen Treibern schon untersttzt. Siehe 
SERSOFST.TXT zu Einzelheiten und zum Status dieses (noch? nicht 
Atari-offiziellen) Standards. Wer besonders dringend die eine oder andere 
Funktion braucht, darf sich gern mit mir in Verbindung setzen. 


Harun Scheutzow, 16.05.1993
letzte nderung: 21.11.1993

Harun_Scheutzow@B.maus.de

Harun Scheutzow
Dresdener Strae 83
D-10179 Berlin, Deutschland

