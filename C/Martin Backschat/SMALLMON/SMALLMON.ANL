                         ANLEITUNG ZUM SMALLMON V2.X


I.1.)  Einleitung
     SmallMON v2.x wurde am 10. April 1986 von MABA als TOS-Anwendung und
     als DESK-Accessory fertiggestellt. Das Programm ist als Public Domain
     vorgesehen und kann von jedem Interessierten frei weiterkopiert werden.
     Allerdings sollte jeder, dem dieses Programm gef„llt, und der noch
     mehr von diesen frei kopierbaren Programmen haben will, ca. 10.- DM
     an den Autor senden. Falls Sie neue, freie Programme geschickt be-
     kommen wollen, so senden Sie eine Diskette mit.
     Und hier ist die Adresse:
                                      Martin Backschat
                                      Software Foundation (Abt. FreeSoft)
                                      Bergstr.16
                                      8071 Hepberg

I.2.)  šbersicht
     Die Anleitung gliedert sich in folgende Teile auf:
          II.   Erkl„rung der Befehle
          III.  Wie man die C-Datei compiliert
          IV.   Listings der Hilfsprogramme (Batchfiles)
          V.    Neuerscheinungen der 'Software FOUNDATION'


II.) Erkl„rung der Befehle
     Die folgende Auflistung gilt nur fr die Versionen 2.x! Fr alle
     Weiteren wird diese Anleitung dementsprechend erg„nzt.

II.1.)  A - Change to ALL available Memory
            Auf die gr”t m”glichste Speicherkonfiguration umschalten
     Starten Sie den SmallMON, so ist der Bildschirm in drei grobe Teile
     aufgespalten:  oben (Zeile 1 bis 22) befindet sich der Arbeitsbereich,
                    in dem die Speicherbelegungen und sonstige Ausgaben
                    angezeigt werden.

                    in der Mitte (Zeile 23) stellt eine Trennzeile zwischen
                    Teil 1 und 3 dar.

                    unten (Zeile 24 und 25) sind wichtige Programmvariablen
                    ausgegeben, die fr den Anwender ntzlich sind.
                    Die Zeile 25 ist die sog. Dialogzeile, in der der
                    Computer mit dem Benutzer kommuniziert.
     Doch die Mitte enth„lt nicht nur die Trennzeichen, sondern auch am
     rechten Rand eine inverse Information, die mit 'SP' abgekrzt ist.
     Diese Zeichenfolge ist als Abkrzung fr 'Speicherkonfiguration' zu
     verstehen, d.h. er gibt an, wieviel KByte dem Anwender physikalisch
     (d.h. wieviel RAM seine Maschine hat) zur Verfgung stehen. Bei einem
     ST+ sind dies 1024, bei einem einfachen ST deshalb nur 512.

     Allerdings ist der ATARI von seiner Hardware her bef„higt, mit seiner
     einen MMU (Memory Management Unit) 4MB anzusprechen. Sollte einmal
     die Anzeige der Speicherbelegung nicht stimmen, z.B. bei einer auf-
     gersteten 520-Maschine (1024 KB) erscheinen trotzdem nur 512, so
     kann man diesen Sch”nheitsfehler mit 'A' beheben. Aber nicht nur der
     Sch”nheit halber wurde dieser Befehl implementiert, sondern aus einem
     weiteren, sp„ter erw„hnten Befehl ('U'). Kurz soll hier noch erkl„rt
     werden, da der SmallMON automatisch eine Speicherzugriffskontrolle
     macht, die mit der eingestellten Speicherkonfiguration zusammenarbei-
     tet.

     Drcken Sie 'A', so mssen Sie erst einmal best„tigen, ob Sie wirklich
     auf 4 MB schalten wollen. Drcken Sie entweder 'j' oder 'n' fr JA oder
     NEIN.


II.2.)  C - Change Dump Mode (byte, word, longword)
            ndern des eingestellten Modus (Byte, Wort oder Langwort)
     Wie Sie wissen, kann der ATARI ST, oder besser gesagt sein Prozessor,
     der 68000er auer Bytes (8 Bit lang) noch W”rter (16 Bit lang) und
     Langw”rter (32 Bit lang) verarbeiten. So werden z.B. intern alle
     Adresse (bis zu 24 Bit lang -> also max. 16MB) in Langw”rtern gerech-
     net. So werden sie dann halt auch im Speicher abgelegt.
     Wollen Sie nun eine Kolonne von abgelegten Adressen im Speicher lesen,
     so wrden Sie sich mit der voreingestellten Byte-Ausgabe (das bedeutet,
     nach jedem Byte ein Leerzeichen zur šbersicht) doch recht schwer tun.
     Hier hilft nun dieser Befehl; drcken Sie die Taste 'l' fr Langwort,
     so werden alle folgenden Speicherausgaben im Langwort-Modus ausgegeben,
     so da erst nach 4 Byte (= 1 Langwort) ein Leerzeichen eingefgt wird.


II.3.)  D - Display Directory
            Ausgabe des aktuellen Inhaltsverzeichnisses
     Wollen Sie ein Bild oder ein Programm (Befehle werden sp„ter aufge-
     fhrt) in den Speicher laden und den Namen nicht wissen, so hilft Ihnen
     die Ausgabe aller verfgbaren Dateien auf der aktuellen Laufwerk.
     Nachdem Sie den Befehl aufgerufen haben, werden Sie aufgefordert, das
     Namensmuster fr die folgende Inhaltsverzeichnisausgabe einzugeben.
     Um alle Dateien zu bekommen, geben Sie das Muster *.* ein, das durch
     die Wildcards '*' auf beiden Seiten (Name und Extension) jede nur denk-
     bare Zeichenfolge ersetzt. Wollen Sie z.B. aber nur alle Programme auf-
     gefhrt bekommen, so w„re diese M”glichkeit angebracht: *.prg
     Hier werden dann nur auf der Namensseite alle mgl. Zeichenfolgen akzep-
     tiert.
     Nach der Ausgabe drcken Sie nochmals eine Taste (Aufforderung ist er-
     kennbar durch das inverse Wort 'TASTE' rechts in der 24. Zeile) um
     weitere Kommandos eingeben zu k”nnen.


II.4.)  E - Execute Programm
            Programm (von Diskette) aufhren
     Programme k”nnen auf dem ATARI ST auf viele Arten gestartet werden. So
     ist die 'Doppelklick'-Methode jedoch am verbreitesten. Eine weitere
     M”glichkeit w„re das Eintippen des Filenamens mit dem CLI - Command
     Line Interpreter - des CP/M 68K mit dem Namen 'COMMAND.PRG' (Programm
     des Entwicklungspacketes fr den ATARI ST). Auf die gleiche Art und
     Weise werden auch hier Programme gestartet:  erst den Befehl 'e' fr
     Ausfhren und dann (auf Aufforderung) den Namen, der brigens auch
     mit Wildcards (* und ?) gespickt sein kann. Aufpassen mssen Sie aller-
     dings beim Hantieren mit diesen Ersatz, da vor dem gewnschten Pro-
     gramm (in der Inhaltsverzeichnisreihenfolge) keine weitere Datei ist,
     auf die das angegebene Namensmuster passt. So l„dt z.B. *.* unbedingt
     das erste File der Diskette. Weiterhin ist nicht jede Datei auf der
     Diskette (brigens werden auch RAM-Disks akzeptiert) dazu bef„higt,
     als PROGRAMM (Abkrzung im Inhaltsverzeichnis mit PRG) ausgefhrt zu
     werden. Diese Dateien erh”hen normalerweise die Absturzstatistik !
     Dies ist hier nur damit kurz zu erkl„ren:
     Wie auch MS-DOS und andere bekannte anspruchsvolle 16-Bit Betriebs-
     systeme werden darunter erstellte Programme relokatibel abgespeichert,
     so da sie nicht an einer bestimmten Stelle im Speicher liegen mssen,
     sondern ohne Probleme verschoben werden k”nnen. Dies wird dadurch
     effektiv erreicht, da das Programm aus mehreren Teile besteht:
     Textbereich, Datenteil und dem unitialisierten Datenteil
     Wie Sie sehen, reicht es also nicht aus (dieser Hinweis sei den 8-Bit-
     Umsteigern haupts„chl. vom C-64 mit auf dem Weg gegeben) nur einen
     wahllosen Speicher abzuspeichern und dann beim Laden auf eine Reaktion
     des fraglichen Programms zu hoffen!


II.5.)  G - Goto new Memory Address
            Speicherausgabe ab einer neuen Speicheradresse
     Wie Sie zweifellos bemerkt haben, ist der obere Teil dazu 'verdammt'
     fast ausschlieslich (wird auch noch von D - DIR verwendet) Speicher-
     inhalte auszugeben, sei im Byte-, Wort-, oder Langwortmodus. Was jetzt
     nur noch fehlen wrde, w„re halt eine M”glichkeit, ab bestimmten, vom
     Benutzer einzugebende Speicheradresse den Inhalt auszugeben. Oder wie
     sollte es sonst m”glich sein, mal kurz nachzuschauen, was denn ab
     Adresse $ffff liegt? Also, Scharfsinnige werden es schon befrchten,
     dieser Befehl (G - GOTO) ist dazu implementiert, um diese Adres-
     sierungsm”glichkeit zu realisieren. Nach dem Befehl werden Sie aufge-
     fordert, eine Adresse einzugeben; natrlich in hexadzimaler Schreib-
     weise:    .....$1000     springt also nicht nach #1000, sondern viel-
                              mehr nach #4096 - also $1000!
     so auch   .....$ff       ,das nicht nach #?? springt, sondern nach
                              #255.
     Nach dem Quittierung mit einem RETURN, erfolgt sofort die Ausgabe ab
     diesem Bereich im Speicher...

     Hier mal kurz einige interessante Adressen, die man dann auch mit einem
     sp„ter erkl„rten Befehl modifizieren kann:

     $400 - Beginn der Systemvariablen (z.B. Speicherkonfiguration...)
     $444 - Systemvariable, die angibt, ob ein Floppy-Verify gemacht werden
            soll (<> 0) oder nicht (=0)

     ~$7000 - Ab hier ungef„hr befinden Sie sich mitten im Speicherplatz
              schluckenden GEM DOS-Betriebssystem


II.6.)  L - Load Program
            Lade relokatibles Programm
     Diese Funktion „hnelt der 'Ausfhren eines Programms' sehr, da die
     Laderoutine (relokatibles Speicherformat!) identisch ist. Allerdings
     macht sich der Unterschied schon mit Beendigung des Ladevorgangs deut-
     lich. Statt das nun fest (nicht relativ!) im Speicher stehende Programm
     nun auszufhren, werden statt dessen die wichtigsten Programmadressen
     dem Benutzer eingeblendet, so da w„ren:
         -Low TPA (bzw. Startadresse) stellt die unterste, vom Programm be-
          legte Speicheradresse dar, z.B. $da456
         -Hi TPA (bzw. Endadresse) stellt im Gegensatz zu 'Low TPA' die
          oberste Adresse dar, z.B. $e0443
         -L„nge des Programms ist praktisch 'Endadresse - Startadresse'

         -Basisadresse des Textsegmentes:
          Jetzt wird's komplizierter...Wie oben schon mal erkl„rt, beinhal-
          tet ein relokatibel abgespeichertes Programm (von denen wir hier
          die ganze Zeit reden) drei Teile. Einer von diesen ist bekannter-
          weise der Textbereich, in dem vorwiegend, wie der Name schon
          sagt, Texte beinhaltet. Arbeiten Sie mit der Compilersprache C, so
          sei hier noch erw„hnt, da dieser Teil dann den in 68000-Maschin-
          ensprache bersetzten C-Kode enth„lt.
         -Basisadresse des Datensegments:
          Der (initialisierte) Datenteil enth„lt, um bei der Sprache C zu
          bleiben (alle C-Angaben beziehen sich ausschlielich auf den im
          Entwicklungspaket enthaltenen DIGITAL-C), die fr GEM ben”tigten
          Programmvariablen und -konstanten, die Sie allerdings beim Pro-
          grammieren nicht beachten mssen!
         -Basisadresse des unitialisierten Datensegments:
          Dieser Teil ist zwar nach dem Ladevorgang nicht mit Daten belegt,
          wird jedoch bei Ausfhrung des Programms ben”tigt.

     Nachdem Sie nun von SmallMON diese Informationen bekommen haben, mten
     Sie wissen, wo Sie was zu suchen haben...šbrigens, das modifizierte
     Programm kann dann mit 'W - Write Program' wieder gespeichert werden,
     doch dazu empfehle ich Ihnen, den Teil ber 'W' zuerst durchzulesen.

     Nachdem die Sie die Informationsausgabe mit einem Tastendruck beendigt
     haben, befinden Sie sich wieder ganz normal im Kommandomodus des Small-
     MON!


II.7.)  M - Modify Memory
            Ver„ndern der Speicherinhalte
     Nun, bis jetzt k”nnen wir ja schon beliebige Speicherinhalte anschauen,
     doch k”nnen keine dieser Speicherzellen auf neue Werte setzen, wie da
     z.B. mit den Systemvariablen (Verify-Flag) wnschenswert w„re. Dieser
     Befehl nun dient diesem Zweck, und erm”glicht nicht nur die Eingabe von
     Bytes sondern auch von Zeichenketten, Texte genannt. Doch erstmal ganz
     langsam... Nachdem Sie die Kommandotaste 'M' bet„tigt haben, werden Sie
     nach einer Adresse gefragt. Diese gibt dem SmallMON Auskunft, wo er die
     folgenden Eingaben ablegen soll; geben Sie z.B. als Zieladresse den
     Wert $400 ein, so werden die Speicherzellen beginnend ab #1024 ver-
     „ndert. Drcken Sie jetzt RETURN, so k”nnen Sie die Werte im hexadezi-
     malen Format eingeben. M”glichkeiten w„ren z.B.: 55 33 ee ff 22 44...,
     wobei die Leerzeichen nicht ben”tigt werden (sollten jedoch der šber-
     sichtlichkeit halber nicht fehlen). Vergessen Sie nun aber ein Nibble
     (Nibble = 4 Bit), also ein Teil des Bytes, z.B. Sie geben nur 'ff e',
     wobei hier das 2. Byte beginnend mit 'e' unvollst„ndig ist, so wird
     eine dementsprechende Fehlermeldung ausgegeben (die bis dahin einge-
     gebenen Bytes werden jedoch noch bernommen!).
     Nun, Bytes k”nnen wir nun ja schon eingeben, doch wie ist es mit
     Texten? SmallMON ist hier sehr komfortabel; Sie k”nnen ohne weiteres
     Texte in Anfhrungszeichen einbinden: ff ee 33 "Das ist ein Text" 55 33
     Kommt nach dem Text nichts mehr, so ist das zweite Anfhrungszeichen
     nicht von N”ten.

     Hier ein paar Tips:
     - Um das Floppy-Verify auszuschalten, schreiben Sie in $444 den Wert
       00
     - Um Tastatur-Klick, Tastatur-Repeat, und Ton nach CTRL-G einzuschal-
       ten, schreiben Sie in $484 den Wert 7


II.8.)  P - Load & show Picture
            Lade und zeige ein S/W Bild
     Wie st”rend ist es doch oft, wenn man mal kurz ein Bild betrachten
     will, und man mu erst ein Zeichenprogramm reinladen. Oder noch
     schlimmer, Sie wollen ein Bild kopieren, und wissen nicht, wie es
     heit. Hier hilft Ihnen diese Funktion. Geben Sie den vollst„ndigen
     Namen (bzw. mit Wildcards) an und antworten Sie, ob das Bild mit
     DEGAS (Standardzeichenprogramm) gemalt worden ist. Die Unterscheidung
     ob DEGAS oder ein anderes Malprogramm ist n”tig, da DEGAS seine s/w-
     Bilder in einem anderen Format auf Diskette speichert.
     Nun wird der Bildschirm vollst„ndig mit dem gewnschten Bild berladen.
     Haben Sie genug und wollen wieder in den Kommandomodus, so drcken Sie
     eine Taste; der Bildschirm wird nun wieder in den alten (wie vor dem
     Bild) Zustand versetzt.
     šbrigens, die mitgelieferten Bilder 'SMALLMON.PI3' und 'SOFTWARE.PI3'
     sind solche DEGAS-Formate!


II.9.)  R - Read File from Disk into Memory
            Lese eine Diskettendatei in den Speicher
     Sie werden sich nun fragen, was nun dieser anscheinend sinnlose zweite
     Ladebefehl bedeutet. Nun, dieser ist vom Aufbau her total anders und
     wird wahrscheinlich ”fters verwendet als 'L'. Wie Sie unter 'L' schon
     gelesen haben, kann dieser nur (relokatible) Programme (.PRG) in den
     Speicher lesen; bei anderen Datein, z.B. Bilder oder ganz normalen
     Texten, scheitert dieser (der Monitor strzt zwar nicht ab, aber das
     File kann unvollst„ndig im Speicher liegen!).
     Nachdem Sie den gewnschten Namen, der natrlich auch Wildcards ent-
     halten darf, eingegeben haben, wird dieses in einen freien Speicher-
     bereich geladen. Um den Benutzer anzuzeigen, von wo bis wo das ge-
     wnschte File liegt, gibt SmallMON noch nach der Ladeprozedur die
     Start- und Endadresse, sowohl die L„nge (Ende - Start) an.


II.10.)  S - Scrolling
             'Scrollen' der Speicherinhalte
     Bis jetzt k”nnen wir den oberen Teil, dem Arbeitsbereich, nur mit
     'G' ver„ndern. Eine weitere M”glichkeit stellt dieser Befehl dar.
     Nachdem Sie Taste 'S' gedrckt haben, wird der gesamte Bildschirm als
     Arbeitsbereich verwendet, indem die unteren drei Zeile 23 - 25 mit
     oben anschlieenden Speicherausgaben aufgefllt werden. Danach blinkt
     oben in der ersten Zeile der Cursor. Sie befinden sich nun nicht mehr
     im Kommando-, sondern im Scroll-Modus; k”nnen also die Speicherinhalt-
     ausgabe nach oben und nach unten um je 32 Bytes verschieben, d.h. das
     beim 'Hochscrollen' oben eine neue Speicherinhaltszeile und beim
     'Runterscrollen' unten eine neue Speicherinhaltszeile eingefgt wird,
     die sich logisch direkt an die alten anschliet. Dies h”rt sich zwar
     sehr kompliziert an, ist jedoch eine einfache Methode, zum 'Speicher-
     anschauen', die es erm”glicht den Speicherausschnitt (Bildschirm) in
     32 Bytes-Stufen zu ver„ndern.
     Nun aber mit welchen Tasten kann man dies erreichen? Der Autor w„hlte
     hier die Tasten '+' und '-' um das Scrollen zu er”glichen.
     Und wem das Scrolling langweilig wird, der kann jederzeit wieder mit
     der ESC-Taste in den Kommandomodus wechseln...


II.11.)  U - Change to USER-/SUPERVISOR-Mode
             In USER/SUPERVISOR-Modus schalten
     Zuerst mu mal klargestellt werden, da der USER- und SUPERVISOR-Modus
     nicht mit dem Prozessor-Zustand zu verwechseln ist. SmallMON bietet
     die M”glichkeit, eine sog. Adresszugriffskontrolle zu machen, die Sie,
     wenn Sie z.B. den I/O-Bereich ansprechen wollen, bemerken, indem der
     Monitor Ihnen die Fehlermeldung 'Ungltige Adresse' zurck gibt.
     Dieser Modus, SUPERVISOR genannt (zu deutsch: Aufseher), ist von Anfang
     an eingeschalten, was man an der inversen Meldung in der Statuszeile
     erkennen kann (SPVI = SUPERVISOR). Unter dem SUPERVISOR k”nnen Sie nur
     den von Speicherkonfiguration her erm”glichten Speicherbereich, also
     bei einem ST 512 KB und bei einem ST+ 1024 KB, ansprechen. Jeder Sprung
     der eine h”here Adresse anspricht, wird mit einer Fehlermeldung quit-
     tiert.
     Sie werden sich nun fragen, was das fr einen Sinn hat? Nun, wrde es
     diese Kontrolle nicht geben, k”nnte der Anwender wahllos auf den
     Speiche zugreifen, was zwar beim guten alten C-64 nicht weiter schlimm
     ist, doch bei einem ATARI bei einer illegalen Adresse (nicht von dem
     MMU adressierbarer Speicher $400 000 - $fc0 000) zu einem sch”nen, drei
     Mushromms („hnelt einer Bombe!) erzeugenden Systemabsturz fhren wrde.
     Um diese (vorallem von Anf„ngern aus Neugierde gemachten) Fehler zu
     vermeiden ist dieser Modus implementiert.
     Was aber nun, wenn Sie den ROM- und den Modulbereich ansprechen wollen?
     Dies ist mit dem SUPERVISOR-Modus rein unm”glich. Dazu wurde der Moni-
     tor um den USER-Modus erweitert.
     Schalten Sie mit 'U' um, so wird Ihnen eine Warnmeldung ausgegeben, die
     besagt, da im USER-Modus keine Zugriffskontrolle mehr existiert.
     Jetzt haben Sie also die M”glichkeit jede noch so hohe und gef„hrliche
     Adresse anzusprechen, auch der von der MMU nicht erreichbare Bereich!
     Um wieder in sichere Gew„sser zu kommen, also wieder den SUPERVISOR-
     Modus zu aktivieren, drcken Sie ein zweites Mal die Taste 'U'.


II.12.)  V - View File Informations
             Zeige File-Informationen an
     Nachdem Sie ein Programm (Befehl 'L') oder auch eine beliebige Datei
     (Befehl 'R') in den Speicher gelesen haben, wurde Ihnen der vom File
     belegte Bereich angezeigt. Diese Informationen verschwanden jedoch so-
     fort, als Sie eine Taste drckten, um wieder in den Kommando-Modus zu
     gelangen. Dies ist oft sehr „rgerlich, da man sich solch komplexe
     Zahlen nicht ohne weiteres merken kann, und aufschreiben ist auch keine
     L”sung! Eine Wiederholung der Anzeige der Start- und Endadresse er-
     reichen Sie mit der Funktion 'V'; sie zeigt Ihnen die Start- und End-
     adresse an, als auch den Dateinamen, des zuletzt geladenen Files, auf
     die die Informationen zutreffen. Wie Sie gerade lasen, bezieht sich
     'V' also nur auf das zuletzt geladene File!


II.13.)  W - Write Memory to Disk
             Schreibe Speicherausschnitt auf Diskette
     Bisher beschr„nkten wir die Monitorf„higkeiten auf dessen Hauptaufgabe
     Speicher einzulesen und die M”glichkeit zu bieten, diesen zu modifi-
     zieren und anzuzeigen. Doch was ntzt das, wenn alles beim Ausschalten
     hinweg ist. Hierfr ist dieser Befehl zust„ndig. Geben Sie die Anfangs-
     und die Endadresse, als auch den Dateinamen ein.
     Die Anfangsadresse ist die Adresse, ab der der Speicher unter dem Namen
     auf Diskette bis zur Endadresse geschrieben wird. Aufpassen sollte der
     Anwender beim Eingeben des Namen; dieser darf auf keinen Fall irgend-
     welche Wildcards (*,?) enthalten, sonst wird eine Fehlermeldung ausge-
     geben. Auch bei falschen Adressen (Zugriffskontrolle...) wird eine
     Fehlermeldung.


II.14.)  X - Exit SmallMON
             Verlasse den SmallMON
     Ein fast sinnloser Befehl ist 'X'! Mit ihn kann der Benutzer wieder in
     das bergeordnete Programm wechseln; der Monitor wird deaktiviert.


II.15.)  ? - Help
             Gibt Befehlsbersicht aus
     Nachdem Sie diese Anleitung gelesen haben, sollten Sie zwar theoretisch
     aller Befehle m„chtig sein, doch dank der Vielseitigkeit des menschl.
     Gehirns ist die Vergesslichkeit im Praktischen keine Seltenheit. Um
     hier Abhilfe zu schaffen, wird Ihnen mit '?' ein kurzer Erinnerungsan-
     sto gegeben.
     Haben Sie sich alle Befehle sorgf„ltig angesehen, so quittieren Sie mit
     einem RETURN.


II.16.)  : - Change Drive Number
             ndere Laufwerksnummer
     Dieser Befehl ist nur fr diejenigen sinnvoll, die an Ihren ATARI mehr
     als ein Laufwerk (auch Harddisk!), bzw. eine oder mehrere RAM-Disks an-
     geschlossen haben. Denn sonst ist es ja nicht m”glich, ein anderes
     Laufwerk anzusprechen, was mit diesem Befehl ja zu realisieren ist.
     Zuerst wird Ihnen die jetzige Floppy-Nummer angezeigt (nach dem Starten
     das Laufwerk, von welchem Sie SmallMON geladen haben), dann eine
     Alpha-Eingabe als Laufwerksnummer Ihrerseits erwartet. Geben Sie hier
     Buchstaben (gro oder klein) ab 'A' bis 'D' ein; alle gr”eren oder
     kleineren Eingaben werden mit einer Fehlermeldung quittiert.
     Nun werden alle Zugriffe auf das Laufwerk, das durch den Buchstaben
     eindeutig identifiziert ist, vorgenommen.

II.17.)  + - Move one Page forwards
             Eine Seite nach vorne bl„ttern
     Bisher kannten wir zwei M”glichkeiten, den oben dargestellten Speicher-
     ausschnitt zu verschieben, so das ein anderer (oder ein Teil eines
     neuen) Speicherausschnittes eingerckt wurde. Eine weitere, dritte
     M”glichkeit bietet dieser Befehl, der es erlaubt eine Seite, darunter
     ist genau der Speicherausschnitt zu verstehen, der sich von den Adres-
     sen logisch an den dargestellten anschliesst, vorzubl„ttern. In der
     aktuellen Version 2.0 k”nnen auf einmal $160 Bytes dargestellt werden,
     so das, wenn z.B. der Ausschnitt mit der Adresse $2000 beginnt nach dem
     Vorbl„ttern die oberste Adresse genau $2160 ist, also genau der log-
     isch anschliessende!
     Wie auch bei den anderen M”glichkeiten, den Speicherausschnitt zu ver-
     schieben, mu hier erw„hnt werden, das unter dem SUPERVISOR-Modus nur
     im wirklich ansprechbaren und belegten Bereich zugegriffen werden kann!


II.18.) - - Move one Page backwards
            Eine Seite zurckbl„ttern
     Wie Sie wahrscheinlich bemerken, ist dieser Befehl fast mit dem obigen
     '+' identisch, nur das um eine Seite rckw„rts gebl„ttert wird. Auch
     der neue Bereich schliet sich logisch an den alten Speicherausschnitt
     an.



III.)  Wie man die dazugeh”rige C-Datei comiliert
     Auf der Diskette befindet sich ein Ordner, der zwei C-Files ('xxx.C')
     enth„lt, den Sourcecode fr die TOS-Anwendung ('xxx.TOS') und den fr
     das Desk-Accessory. Uns interessiert in diesem Kapitel nur die TOS-An-
     wendung.
     Als C-Compiler sollten Sie sich den DIGITAL-C aus dem ATARI-Entwick-
     lungspaket bereit halten, denn mit diesem wurde der Monitor geschrie-
     ben.
     Sollten Sie auf Ihrer Diskette die unten erw„hnten Programme
     (APSTART.S, APSTART.O, C,L) schon auf Ihrer Diskette haben, so k”nnen
     Sie diese S„tze berspringen!
     Zuerst mu mal das Startprogramm APSTART, welches der Linker braucht,
     modifiziert werden, da einige Neuerungen implementiert wurden. Dazu
     tippen Sie am besten das unten abgelistete Programm APSTART.S ab, und
     Assemblieren dieses fr den Linker, der ja den Objektkode ('xxx.O')
     dessen ben”tigt!
     Nun tippen Sie, falls n”tig, die unten aufgelisteten Batchfiles ab,
     und speichern diese als 'C' fr Compiler und Assembler und als 'L'
     fr den Linker.
     Das Compiler-Batchfile erzeugt nun den n”tigen Objektkode fr den
     Linker, der mit dem 'L'-Batchfile gestartet werden kann.
     Nach dem Beendigen des Linkens existiert ein 'SMALLMON.TOS'-Programm
     auf der Diskette, welches das startf„hige Monitorprogramm darstelllt.
     Die C-Datei ('xxx.C') kann beliebig vom Anwender nach seinen Wnschen
     ver„ndert werden, auch neue Befehle sind leicht zu implementieren;
     doch sollte man doch aufpassen, da nicht zuf„llig wichtige Teile des
     C-Sourcekodes falsch ver„ndert oder gar gel”scht werden!
     Sollten beim Compilieren Fehler auftauchen, die Ansto an dem Syntax
     des Sourcefiles nehmen, so berprfen Sie Ihren abge„nderten Text, da
     die mitgelieferten orginalen C-Datein einwandfrei liefen!
     Bei anderen Fehler (Schreibfehler!) ist zu erw„hnen, da durch die
     enorme L„nge des C-Sourcekodes (ca. 45 KB) auf kleineren Disketten-
     speichern (vorallem bei Einseitigen: 360 KB) der Platz nicht ausreicht,
     um alle dazugeh”rigen Zwischenfiles darauf abspeichern zu k”nnen. In
     diesem Falle ist der Programmierer auf seine eigene Kreativit„t ge-
     stellt; es bleibt nur zu sagen, da MABA mit einer RAM-Disk von einer
     Kapazit„t von ca. 580 KB gearbeitet hat, wobei das Compilieren & As-
     semblieren und das Linken getrennt ablief!



IV.) Listings der Batchfiles
     Das erste Batchfile, ist fr das Compilieren und Assemblieren des C-
     Sourcekodes zust„ndig. Es hinterl„sst zwei Files: den C-Sourcekode und
     den erzeugten Objektkode ('xxx.O'), der vom Linker (zweites Batchfile)
     ben”tigt wird.

     Fr das Compilieren und Assemblieren verantwortliches Batchfile:

cp68 %1.c %1.i
c068 %1.i %1.1 %1.2 %1.3 -f
rm %1.i
c168 %1.1 %1.2 %1.s
rm %1.1
rm %1.2
as68 -l -u %1.s
rm %1.s
wait.prg

     Fr das Linken verantworliche Batchfile:

link68 [u] %1.68k=apstart,gems,%1,osbind,gemlib,libf
relmod %1.68k %1.tos
rm %1.68k
wait

     Das fr das Linken abge„nderte GEM-Startfile APSTART.S, das frs
     Linken noch assembliert werden mu:

*       APSTART.S       4/30/85                 MIKE SCHMAL
*
*       APPLICATION STARTUP PROGRAM
*
* This version only contains what is necessary for a application to run
* All other garbage has been removed as not to waste memory.
*
* Sample application startup code. This must be the first object file in
*  the link statement so that the base page address can be accessed.
*  When a program is executed, GEMDOS gives all available memory to it.
*  If this program needs to do any memory management, then one must first
*  free unused memory by a setblock call. All "segment" lengths in the base
*  page are totaled and 0x100 is added for the base page length for the setblock
*  call.
*

        .text
        .globl  _main
        .globl  _ctrl_cnts
        .globl  _Base_Page

*
*  Must be first object file in link statement
*
        move.l  a7,a5           * save a7 so we can get the base page address
        move.l  #ustk,a7        * set local stack
        move.l  4(a5),a5        * basepage address
        move.l  a5,_Base_Page   * die Variable Base_Page mit dem richtigen Wert fllen
        move.l  $c(a5),d0
        add.l   $14(a5),d0
        add.l   $1c(a5),d0
        add.l   #$100,d0        * skip los pageos baseos
        move.l  d0,-(sp)
        move.l  a5,-(sp)
        move    d0,-(sp)        * junk word
        move    #$4a,-(sp)
        trap    #1
        add.l   #12,sp
*
        jsr     _main           * go to program
        move.l  #0,-(a7)        * back to gemdos
        trap    #1

        .bss
        .even
        .ds.l   256
ustk:   .ds.l   1

*
        .data
        .even
_ctrl_cnts:                             *       Application Manager
        .dc.b   0, 1, 0                 * func 010              
        .dc.b   2, 1, 1                 * func 011              
        .dc.b   2, 1, 1                 * func 012              
        .dc.b   0, 1, 1                 * func 013              
        .dc.b   2, 1, 1                 * func 014              
        .dc.b   1, 1, 1                 * func 015              
        .dc.b   0, 0, 0                 * func 016              
        .dc.b   0, 0, 0                 * func 017              
        .dc.b   0, 0, 0                 * func 008              
        .dc.b   0, 1, 0                 * func 019              

*                                                       Shell Manager
        .dc.b   0, 1, 2                 * func 120
        .dc.b   3, 1, 2                 * func 121
        .dc.b   1, 1, 1                 * func 122
        .dc.b   1, 1, 1                 * func 123
        .dc.b   0, 1, 1                 * func 124
        .dc.b   0, 1, 2                 * func 125
        .end



V.)  Neuerscheinungen der SOFTWARE FOUNDATION
        Sommer 1986:    SmallWORD
                        SmallTERMINAL

        Herbst 1986:    Commic ST (bis Weihnachten)

        Winter 1986:    Cbasic (bis Frhling 87)

     SmallWORD: Eine Textverabeitung, die leistungsf„hig ist
     SmallTERM: SmallWORD kompatibles GEM-untersttzendes Terminalprogramm

