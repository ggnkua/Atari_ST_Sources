
EASY_GEM.LIB ist eine Sammlung von nÅtzlichen Routinen,
die die Programmierung in C unter GEM vereinfachen helfen
sollen.
Dabei werden folgende Schwerpunkte bedient:
   Initialisierung
   Filehandling
             speziell der Umgang mit
             der Fileselectobox
   Graphik   einfache Bedienung der VDI-
             Routinen
   Pixel     Routinen zum direkten Zugriff
             auf den Bildschirmspeicher
   AES       Routinen fÅr Objektbehandlung
   Typen     in EASY_GEM.H definierte Typen
   Diverses


Typen
-----
Die folgenden beiden Typen werden in der Include-Datei
EASY_GEM.H definiert:

typedef enum {FALSE,TRUE} boolean;

typedef struct
{
   int x;
   int y;
}Koordinaten;



Initialisierung
---------------

boolean open_vwork(void);
void    close_vwork(void);
void    rsc_init(char *rsc_file,void (*funktion)());


Prototyp:
   boolean open_vwork(void);

Beschreibung:
   Bevor irgend eine andere Funktion dieser Library
   benutzt werden darf, muû diese Initialisierung-
   routine aufgerufen werden. Dabei wird eine
   virtuelle Workstation erîffnet. In den folgenden
   globalen Variablen werden dabei diverse Parameter
   abgelegt:
   int handle:   Handle der Workstation
   int _sbreite: Breite des AudgabegerÑtes in Pixel
   int _shoehe:  Hîhe               "
   int _splanes: Anzahl der Bitplanes
   int _sbytes:  Byteanzahl einer Bildschirmzeile
   char *_sscreen: logische Adresse des Screens

RÅckgabewert:
   Wenn die Applikation erfolgreich angemeldet werden
   konnte wird TRUE zurÅckgeliefert, sonst FALSE.

--------------------------------------------------------------------
Prototyp:
   void close_vwork(void);

Beschreibung:
   Schlieût eine Applikation wieder. Sollte am Ende eines
   Programms immer aufgerufen werden.

--------------------------------------------------------------------
Prototyp:
   void rsc_init(char *rsc_file,void (*funktion)());

Parameter:
   rsc_file:  Zeiger auf den Namen des Resource-Files
   funktion:  AuszufÅhrende Hauptfunktion

Beschreibung:
   Diese Funktion ruft 'open_vwork()' auf, danach lÑdt
   sie die Resource-Datei mittels 'rsrc_load()' ein.
   Danach wird der Mauszeiger zur Pfeilform umgeschaltet,
   die angegebene Funktion 'funktion()' als Hauptprogramm
   ausgefÅhrt. Schluûendlich wird der Resource-Spreicher
   mittels 'rsrc_free' wieder freigegeben und die
   Applikation durch 'close_vwork()' abgemeldet. Bei
   eventuellen Fehlern wird eine Fehlermeldung auf den
   Bildschirm ausgegeben und abgebrochen.

Beispiel:
   #include <easy_gem.h>

   void do_it(void)
   {
      /* Hauptprogramm */

   }

   int main()
   {
      rsrc_init("DEMO.RSC",do_it);
      return 0;
   }

--------------------------------------------------------------------

Filehandling
------------

char *add_prefix(char *name,char *fix);
int fileselect  (char *name,char *ext,char *title);
int file_in     (char *pfad,char *title,int save);


Prototyp:
   char *add_prefix(char *name,char *fix);

Parameter:
   name: kompletter Pfadname einer Datei
   fix:  anzufÅgender Suffix (z.B. "DAT");

RÅckgabeparameter:
   0:      ungÅltiger Pfadname
   sonst : zeiger auf Variable 'name'

Beschreibung:
   FÅgt an einen Pfadnamen einer Datei einen
   Suffix an. Ist jedoch schon ein Suffix in
   dem Pfadnamen enthalten, wird nichts angefÅgt.
   Es muû genÅgend Speicher fÅr den lÑnger
   werdenden Pfadnamen vorhanden sein, da der
   Suffix einfach hintendran kopiert wird.

--------------------------------------------------------------------
Prototyp:
   int fileselect(char *name,char *ext,char *title);

Parameter:
   name:  kompletter Filename mit Pfad
          (RÅckgabeparameter)
   ext:   Default-Namenssuffix
   title: Zusatzzeile der Fs.box
          (wird erst ab TOS V1.4 dargestellt)

RÅckgabewert:
   OK:      File wurde ausgesucht oder OK-Button angeklickt
   CANCEL:  CANCEL-Button wurde angeklickt

Beschreibung:
   öbernimmt die komplette Verwaltung der File-
   selectbox. Dazu wird das aktuelle Lauferk und
   der aktuelle Pfad eingelesen. Ab TOS Version 1.4
   wird noch eine zusÑtzliche Titelzeile ausgegeben.
   Bevor die Box dargestellt wird, reserviert die
   Routine dynamisch Speicher fÅr einen kompletten
   Bildschirm, der dann gerettet wird (sget() ).

   Nach Aufruf der Box wird der Bildschirm wieder
   mittels sput() restauriert und der Speicher
   wieder freigegeben. Der ausgewÑhlte Pfad wird
   zum aktuellen Pfad gemacht.

--------------------------------------------------------------------
Prototyp:
   int file_in(char *pfad,char *titel,int save);

Parameter:
   pfad:  Defaultpfad
   titel: Zusatzzeile der Fs.box
          (wird erst ab TOS V1.4 dargestellt)
   save:  ein Wert != 0 bewirkt ein Retten des
          von der Box Åberschriebenen Bereichs

RÅckgabewert:
   OK:      File wurde ausgesucht oder OK-Button angeklickt
   CANCEL:  CANCEL-Button wurde angeklickt

Beschreibung:
   öbernimmt die komplette Verwaltung der File-
   selectbox. Im Gegensatz zu 'fileselect()' muû aber
   der Defaultpfad mitangegeben werden und durch den
   Parameter 'save' kann das automatische Hintergrund-
   sichern unterdrÅckt werden (Wichtig fÅr externe
   Grafikkarten, da dies hierbei nicht funktioniert).

   In der globalen Variablen 'char _fname[120]' steht
   nach verlassen der Fs.box der komplette Pfadname.


--------------------------------------------------------------------

Pixel
-----

Diese Routinen greifen direkt auf den
Bildschirmspeicher zu, laufen also am GEM vorbei.
Daher sollten sie nur im Notfall bei besonders
zeitkritischen Aufgaben verwendet werden.
Die Routinen 'set_point()', 'clr_point()' und
'tst_point()' funktionieren nur im Monochrom-Modus.

void sget (char *buffer);
void sput (char *buffer);
void maus_aus (void);
void maus_an (void);
int  maus_get (int *mx,int *my);
void set_maus (int mx,int my);
void set_point (int x,int y);
void clr_point (int x,int y);
int  tst_point (int x,int y);


Prototyp:
   void sget(char *buffer);

Parameter:
   buffer: Zeiger auf Speicher fÅr Bilddaten

Beschreibung:
   Kopiert einen kompletten logischen Bildschirm
   in den vorgesehenen Speicherbereich.

--------------------------------------------------------------------
\>sput\

Prototyp:
   void sput(char *buffer);

Parameter:
   buffer: Zeiger auf Speicher der Bilddaten

Beschreibung:
   Kopiert Speicherbereich in den logischen Bildschirm

--------------------------------------------------------------------
Prototyp:
   void maus_aus(void);

Beschreibung:
   Schaltet mittels 'graf_mouse()' den Mauszeiger aus.

--------------------------------------------------------------------
Prototyp:
   void maus_an(void);

Beschreibung:
   Schaltet mittels 'graf_mouse()' den Mauszeiger an.
   Dabei wird ein ZÑhler mitgefÅhrt, der dafÅr sorgt, daû
   bei verschachtelten Aufrufen von 'maus_aus()' und
   'maus_aus()' die Maus nur einmal ein- bzw. ausgeschaltet wird.

--------------------------------------------------------------------
Prototyp:
   int maus_get(int *mx,int *my);

Parameter: (RÅckgabeparameter)
   mx : X-Position des Mauszeigers
   my : Y-Position des Mauszeigers

RÅckgabeparameter:
   Mausknopf: 1 - linke Taste gedrÅckt
              2 - rechte  "      "
              3 - beide gedrÅckt

Beschreibung:
   liefert den Zustand der Maus. Diese
   Informationen werden durch die AES-Funktion
   'evnt_mouse()' erfragt.


--------------------------------------------------------------------
Prototyp:
   int mausxy(int *mx,int *my);

Parameter: (RÅckgabeparameter)
   mx : X-Position des Mauszeigers
   my : Y-Position des Mauszeigers

RÅckgabeparameter:
   Mausknopf: 1 - linke Taste gedrÅckt
              2 - rechte  "      "
              3 - beide gedrÅckt

Beschreibung:
   liefert den Zustand der Maus, wartet aber, im Gegensatz
   zu 'maus_get()' bis tatsÑchlich eine Maustaste gedrÅckt
   wird.
   Diese Informationen werden durch die AES-Funktion
   'evnt_mouse()' erhalten.

--------------------------------------------------------------------
Prototyp:
   void set_maus(int mx,int my);

Parameter:
   mx : neue X-Position des Mauszeigers
   my : neue Y-Position des Mauszeigers

Beschreibung:
   Setzt den Mauszeiger an eine beliebige
   Position. (Negative Line-A-Variablen)


--------------------------------------------------------------------
Prototyp:
   void set_point(int x,int y);

Parameter:
   x : X-Koordinate des Punkts
   y : Y-Koordinate des Punkts

Beschreibung:
   Es wird ein Bildschirmpunkt gesetzt (direkt
   in den Bildschirmspeicher geschrieben).

Achtung:
   die externe Variable '_sscreen' muû die
   Adresse des logischen Bildschirms enthalten

--------------------------------------------------------------------
Prototyp:
   void clr_point(int x,int y);

Parameter:
   x : X-Koordinate des Punkts
   y : Y-Koordinate des Punkts

Beschreibung:
   Es wird ein Bildschirmpunkt gelîscht (direkt
   in den Bildschirmspeicher geschrieben).

Achtung:
   die externe Variable '_sscreen' muû die
   Adresse des logischen Bildschirms enthalten

--------------------------------------------------------------------
Prototyp:
   int tst_point(int x,int y);

Parameter:
   x : X-Koordinate des Punkts
   y : Y-Koordinate des Punkts

Beschreibung:
   Es wird ein Bildschirmpunkt gelîscht (direkt
   in den Bildschirmspeicher geschrieben).

Achtung:
   die externe Variable '_sscreen' muû die
   Adresse des logischen Bildschirms enthalten

--------------------------------------------------------------------

Graphik
-------

Diese Routinen setzen alle auf den VDI-Routinen auf
und verwenden das Handle,welches bei Aufruf von
'open_vwork()' in der globalen Variablen 'handle'
abgelegt wurde.

Die Namensgebung und die Parameter sind an GFA-Basic
angelehnt.

void deffill(int farbe,int art,int muster);
void deftext(int color,int attribut,int rotation,int size);
void text_size(int size);
void defline(int thick,int art,int start,int ende);
void color(int color);
void defmarker(int color,int typ,int size);
void user_fill(int *muster);
void text(int x,int y,char *txt);         Text
void box(int x1,int y1,int x2,int y2);    Rechteck
void rbox(int x1,int y1,int x2,int y2);       "    mit runden Kanten
void pbox(int x1,int y1,int x2,int y2);   gefÅlltes Rechteck
void prect(int x1,int y1,int x2,int y2);      "        "     ohne Rahmen
void prbox(int x1,int y1,int x2,int y2);      "        " mit runden Kanten
void line(int x1,int y1,int x2,int y2);   Linie
void  setstart(int x,int y);      Setzt den Startpunkt fÅr die Funktion
                                 'drawto()'
void drawto(int x,int y);                 zieht Linie zu einer Koordinate
void polymarker(int anz,int *array);
void clip(int x1,int y1,int x2,int y2);   Clipping setzen
void clip_off(void);                         "     aufheben


Diverses
--------

int  min (int w1, int w2);
int  max (int w1, int w2);
int  random (int von,int bis);
void ende_dia (void);
void form_to_screen (int x,int y,int w,int h,int mode,void *daten);
void screen_to_form (int x,int y,int w,int h,void *daten);
int  *alloc_mem (int w,int h);
int  pop_up (int x,int y,int taste,char *text);
void put_buffer (int x,int y,int mode,void *adr);



Prototyp:
   int random(int von,int bis);

Parameter:
   von: kleinste mîgliche Zufallszahl
   bis: grîsste      "        "

Beschreibung:
   liefert eine Zufallszahl

--------------------------------------------------------------------
Prototyp:
   void ende_dia(void);

Beschreibung:
   Zeichnet einen Effekt zum Beenden des Programms.
   Dabei werden diagonale VDI-Linien gezeichnet,
   sodaû der Bildschirm am Ende grau ist.

--------------------------------------------------------------------
Prototyp:
   void form_to_screen(int x,int y,int w,int h,int mode,void *daten);

Parameter:
   x: Start X-Koordinate
   y: Start Y-Koordinate
   w: Breite des Rechtecks in Pixel
   h: Hîhe
   mode:  VerknÅpfungsmodus (z.B.: S_AND_D, S_ONLY
          S_XOR_D, S_OR_D)
   daten: Bilddaten

Beschreibung:
   Kopiert Bilddaten auf den Bildschirm

--------------------------------------------------------------------
Prototyp:
   void screen_to_form(int x,int y,int w,int h,void *daten);

Parameter:
   x: Start X-Koordinate
   y: Start Y-Koordinate
   w: Breite des Rechtecks in Pixel
   h: Hîhe
   daten: Speicherplatz fÅr Bilddaten

Beschreibung:
   Kopiert einen rechteckigen Bereich des Bildschirms
   in einen Speicherbereich. Diesen Speicher kann man
   sich dynamisch durch die Funktion 'alloc_mem()'
   allokieren.

--------------------------------------------------------------------
Prototyp:
   int *alloc_mem(int w,int h);

Parameter:
   w: Breite des Rechtecks in Pixel
   h: Hîhe

RÅckgabeparameter:
   Zeiger auf allokierten Speicher
   Im Fehlerfall wird NULL zurÅckgeliefert

Beschreibung:
   Reserviert dynamisch Speicher fÅr ein Rechteck
   der gegebenen Grîûe.

--------------------------------------------------------------------
Prototyp:
   int pop_up(int x,int y,int taste,char *text);

Parameter:
   x :    Position der linken oberen Ecke
   y :    des Popup-MenÅs
   taste: Zustand der Maustaste, wÑhrend dem die Auswahl
          der MenÅpunkte mîglich ist.
   text : String mit den einzelnen MenÅpunkten, dabei
          sind die MenÅpunkte Strings die hinereinander
          im Speicher liegen. Das Ende wird durch eine
          doppelte Null markiert, z.B.:
            "laden\\00speichern\\00ende\\00"

RÅckgabeparameter:
   0   : kein MenÅpunkt angewÑhlt
   1-n : MenÅpunkt angewÑhlt

Beschreibung:
   Verwaltung von PopupmenÅs

#include <easy_gem.h>

int main()
{
   int k,x,y;

   open_vwork();

   do{
      k=maus_get(&x,&y);
   }while(k != 1);

   pop_up(x,y,1,"qqqq\\00wwww\\00eeee\\00");

   close_vwork();
   return 0;
}

--------------------------------------------------------------------
Prototyp:
   void put_buffer(int x,int y,int mode,void *adr);

Parameter:
   x & y : linke obere Ecke
   mode  : Bitblt Kopiermodus
   adr   : Bilddaten

Beschreibung:
   Mit dem Programm LUPE kînnen Blîcke als O-Dateien
   abgespeichert werden. diese Routine kann nun solch
   ein gelinktes Modul auf dem Bildschirm darstellen.

Beispiel:
   #include <easy_gem.h>

   extern int BILD[];

   int main()
   {
      open_vwork();
      put_buffer(10,100,3,BILD);
      close_vwork();
      return 0;
   }

--------------------------------------------------------------------

AES
---

Diese Routinen vereinfachen den Umgang mit Objekten
und Formularen des AES.

void draw_tree   (OBJECT *tree,int **adr);
void drawTree    (OBJECT *tree);
void undraw_tree (OBJECT *tree,int *adr);
void undrawTree  (OBJECT *tree);
void objc_select (OBJECT *tree,int index,int state);
void button_zahl (OBJECT *tree,int index,int zahl,int draw);
int  form_verwaltung (OBJECT *tree,int start_ob);
int  rc_intersect(GRECT *r1,GRECT *r2);


Prototyp:
   int rc_intersect(GREC *r1, GRECT *r2);

Parameter:
   r1: Zeiger auf erstes Rechteck
   r2: Zeiger auf zweites Rechteck, zugleich auch
       Ausgaberechteck

RÅckgabeparameter:
   1 : Hîhe und Breite der SchnittflÑche > 0
   sonst 0

Beschreibung:
   Berechnet die SchnittflÑche zwischen zwei
   Rechtecken.

--------------------------------------------------------------------
Prototyp:
   void draw_tree(OBJECT *tree,int **adr);

Parameter:
   tree: Wurzel des Formularbaums
   adr:  Zeiger auf Daten (RÅckgabeparameter)

Beschreibung:
   Zeichnet ein Formular und rettet den Hintergrund.

Beispiel:
   main()
   {
      int *b1;

      open_vwork();
      ...
      draw_tree(tree,&b1);
      ..
      \<undraw_tree\(tree,b1);
      ..
      close_vwork();
   }

--------------------------------------------------------------------
Prototyp:
   void drawTree(OBJECT *tree);

Parameter:
   tree: Wurzel des Formularbaums

Beschreibung:
   Zeichnet ein Formular zentriert, mit
   'grow_box()' ohne den Hintergrund zu retten.


--------------------------------------------------------------------
Prototyp:
   void undraw_tree(OBJECT *tree,int *adr);

Parameter:
   tree: Wurzel des Formularbaums
   adr:  Zeiger auf Daten des geretteten Hinergrund

Beschreibung:
   Lîscht ein Formular und restauriert den Hintergrund.


--------------------------------------------------------------------
Prototyp:
   void undrawTree(OBJECT *tree);

Parameter:
   tree: Wurzel des Formularbaums

Beschreibung:
   Shrink_box() aufrufen und dem AES mitteilen,
   daû der Hintergrund restauriert werden muû.


--------------------------------------------------------------------
Prototyp:
   void objc_select(OBJECT *tree,int index,int state);

Parameter:
   tree: Wurzel des Formularbaums
   index: Nummer des Objekts
   state: neuer Status (1 - SELECTED ; 0 - DESELECTED)

Beschreibung:
   éndert den Status eines Objekts und zeichnet es neu.


--------------------------------------------------------------------
Prototyp:
   void button_zahl(OBJECT *tree,int index,int zahl,int draw);

Parameter:
   tree:  Wurzel des Formularbaums
   index: Nummer des Objekts
   zahl:  einzutragende Zahl
   draw:  1 - Objekt wird gezeichnet ; sonst nicht
Beschreibung:
   TrÑgt in einen Button eine Zahl ein.


--------------------------------------------------------------------
Prototyp:
   int  form_verwaltung(OBJECT *tree,int start_ob);

Parameter:
   tree: Wurzel des Formularbaums
   start_ob: erstes editierbares Objekt

RÅckgabeparameter:
   angewÑhlter Exit-Button

Beschreibung:
   öbernimmt die komplette Verwaltung eines
   Formulars inclusive Zeichnen und Hintergrund
   restaurieren.

