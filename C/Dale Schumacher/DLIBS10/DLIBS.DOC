 _________________________________________________________________________
|                                                                         |
| Replacement standard library functions for Atari ST with Alcyon C v4.14 |
|       Version 1.00.0, by Dale Schumacher, last modified 10/12/87.       |
|_________________________________________________________________________|



CONSTANTS:

        dLibs           Conditional complilation flag   (0x1000)
        TRUE            Boolean true                    (1)
        FALSE           Boolean false                   (0)
        ERROR           General error value             (-1)
        NULL            Null pointer                    ((char *) 0)
        MAXFILES        Maximum number of open streams  (20)
        MAXINT          Maximum signed integer value    (32767)
        MININT          Minimum signed integer value    (-32768)
        BUFSIZ          Standard stream buffer size     (1024)
        PATHSIZE        Maximum size of a pathname      (128)
        EOF             End of file indicator           (-1)
        EOS             End of string character         '\0'


PROCESS CONTROL:

long _STKSIZ = 4096L;

        This variable defines the amount of run-time stack space to be
        reserved.  The default value is 4K, which is more than enough
        for most applications.  Since dynamic memory is NOT allocated
        from the stack, this value need only be large enough to handle
        local variables and deep recursion.

void _main(cmdline, cmdlen)
char *cmdline;
int cmdlen;

        Parses command line, opens standard files, plus other assorted
        general setup. Then calls user's main() function.  If main()
        returns, exit() is called with a 0 return value.  The following
        standard streams are initialized by _main():
                stdin           Standard input, may be redirected
                stdout          Standard output, may be redirected
                stderr          Usually the system console
                stdprn          The standard printer (output only)
                stdaux          The communication port (input/output)
        The _initargs() function is called to process the command line.
        The global variables "_argc", "_argv" and "_envp" are used to
        store the values to be passed to the user's main().

void _initargs(cmdline, cmdlen)
char *cmdline;
int cmdlen;

        Process command line and retrieve the environment string.  This
        function is responsible for allocating space to hold the parsed
        command line arguments, etc.  Values to be passed to the user's
        main() function are stored in the global variables "_argc",
        "_argv" and "_envp".  _main() initiallizes these variables to
        indicate that no arguments are available.  If a program doesn't
        use command line arguments or the environment string, an
        _initargs() function, which does nothing, should be defined in
        the module containing main().  This will result in a smaller
        executable size and a smaller run-time image.  The default
        _initargs() function handles command line redirection, but does
        not expand wildcards.  #ifdef's in the source code provide for
        elimination of redirection processing and/or addition of wildcard
        expansion. If these features are desired, a copy of _initargs(),
        appropriately modified for your application, should be placed
        in the module containing your main() function.

void main(argc, argv, envp)
int argc;
char *argv[];
char *envp;

        This function is not actually in the standard libraries, but
        must be present somewhere in the user's code.  The parameters
        passed to it by _main() are the number of arguments in the
        command line, a pointer to a list of pointers to arguments, and
        a pointer to the environment string.  The return value from
        main() is ignored by _main().  If the program wishes to return
        a status code, it should call exit() directly.

void exit(status)
int status;

        Flushes and closes all open streams.  Returns <status> value to
        the operating system.

void _exit(status)
int status;

        Exits the program immediately, returning <status> to the OS.

void abort()

        Prints the message "Abnormal program termination" to stderr and
        calls _exit() with a status code of 3.

int getpid()

        Return an integer value unique for this process.

char *getenv(var)
register char *var;

        Search for <var> in the environment.  If <var> is found, a pointer
        to it's value is returned.  NULL is returned if <var> is not found.
        WARNING:  The returned pointer points into the environment and
        must not be modified!

int putenv(entry)
char *entry;

        Add <entry> to the environment.  <entry> can be any of the following
        forms:
                <VARIABLE>
                <VARIABLE>=
                <VARIABLE>=<value>
        The first form removes <VARIABLE> from the environment.  getenv()
        will return NULL if looking for this variable.  The second form adds
        <VARIABLE> to the environment, with a null value.  getenv() will
        return a pointer to a '\0' character if looking for this variable.
        Many environment handlers don't support such "tag variables", so
        their use is not recommended.  The final form is the most common,
        and safest to use.  <VARIABLE> is installed (or replaced) with the
        value <value>.  It should be noted that the putenv() function itself
        is not supported in many systems and therefore may not be portable.
        In addition, care should be taken to prevent overflowing the space
        allocated for the environment.  Returns TRUE for success or FALSE
        for failure.  NO OVERFLOW CHECKING IS DONE.

void shell()

        Invoke a command line interface shell.  If the "SHELL" environment
        variable is not defined, a prompt showing the current working
        directory will be given.  Each line entered will then be passed
        to the system() function for execution until the command "exit"
        is entered to terminate the shell.  If "SHELL" is defined, and
        the "_shell_p" variable is valid, the value of "SHELL" will be
        passed to the program pointed to by "_shell_p" in order to allow
        the shell to invoke a command line interaction of its own.  If
        the "_shell_p" variable is not valid, the program defined by
        "SHELL" will be searched for along the "PATH", and executed with
        no arguments.  If the "SHELL" can't be found, the internal command
        line described above will be used.

int system(command)
char *command;

        Attempts to pass <command> to the shell program pointed to by
        the system variable "_shell_p".  If a valid shell can't be found
        there, the "SHELL" environment variable is searched for.  If it
        exists and is not empty, it will be the name of the shell program
        to execute the given command.  If "SHELL" is not valid, the
        "PATH" variable is searched for.  This would specify the paths
        to search for the program name which is the first token of the
        <command>.  If "PATH" is not valid, the current directory is
        searched for the given command.  The extensions tried (if none
        is specified) are ".TTP", ".TOS", ".PRG" and ".APP".

int spawne(program, cmdline, envp)
char *program;
char *cmdline;
char *envp;

        Calls the OS "Pexec" trap with the parameters specified.  Since
        the OS uses a Pascal-like string for the command line, the
        <cmdline> parameter, which is a normal C-string, is used to
        create the actual command line which is passed to the OS trap.
        Returns the value returned by the program, or -1 for errors.

int spawn(program, cmdline)
char *program;
char *cmdline;

        Like spawne() except that NULL is used for the environment pointer.
        This causes the child to inherit a copy of the parent's environment.

int spawnpe(program, cmdline, envp)
char *program;
char *cmdline;
char *envp;

        Operates like spawne() except that the "PATH" environment variable,
        if it is valid, is used to locate the program to be executed.
        Various extensions are tried, as described for system().  Returns
        the value returned by the program, or -1 for errors.

int spawnp(program, cmdline)
char *program;
char *cmdline;

        Like spawnpe() except that NULL is used for the environment pointer.
        This causes the child to inherit a copy of the parent's environment.

long gemdos(func[, arg1, ..., argN])
int func;

        Call operating system trap #1 (GEMDOS) function number <func> with
        the arguments given.  Returned value returned by the trap call.

long bios(func[, arg1, ..., argN])
int func;

        Call operating system trap #13 (BIOS) function number <func> with
        the arguments given.  Returned value returned by the trap call.

long xbios(func[, arg1, ..., argN])
int func;

        Call operating system trap #14 (XBIOS) function number <func> with
        the arguments given.  Returned value returned by the trap call.

int setjmp(context)
jmp_buf context;

        [save <context> for longjmp(). MUST include "SETJMP.H" to use.]

void longjmp(context, rv)
jmp_buf context;
int rv;

        [return <rv> to <context> saved by setjmp().
         MUST include "SETJMP.H" to use.]

int catch(context, func)
jmp_buf context;
int (*func)();

        [execute <func> with saved <context> for throw().
         MUST include "SETJMP.H" to use.]

void throw(context, func)
jmp_buf context;
int rv;

        [return <rv> to <context> saved by catch().
         MUST include "SETJMP.H" to use.]


MEMORY MANAGEMENT:

        You may want to include "MALLOC.H" in your program if you use
        functions in this section, otherwise you may have to declare
        the return types for some functions.

long _BLKSIZ = 65536;

        This variable controls the granularity of system memory allocation
        used by malloc(), et. al.  This is the amount of memory that is
        requested from the system each time a new "heap" is needed to fill
        dynamic memory requests.  To help avoid a GEMDOS bug, only 16
        heaps can be active at a time.  Therefore, (16 * _BLKSIZ) defines
        the maximum amount of memory which can be managed by these routines
        under normal circumstances.  The exception is if any single request
        for memory exceeds _BLKSIZ.  In this case, a heap will be allocated
        larger than _BLKSIZ.

char *malloc(size)
unsigned int size;

        Allocate at least <size> bytes of memory.  A pointer to the
        requested block is returned, or NULL if there is not enough
        free memory available.

char *calloc(n, size)
unsigned int n;
unsigned int size;

        Allocate space for an array of <n> element of <size> bytes each.
        If the storage can be allocated, it is initialized to all zero.
        NULL is returned is there is not enough free memory.

char *lalloc(size)
long size;

        Allocate at least <size> bytes of memory.  A pointer to the
        requested block is returned, or NULL if there is not enough
        free memory available.

char *realloc(addr, size)
char *addr;
unsigned int size;

        Attempt to change the memory block at <addr> to the new <size>.
        Making a block smaller will always work, but making it larger
        may fail if there is not enough free memory.  If there is not
        enough memory, NULL is returned and the block will still reside
        at <addr>.  If realloc() succeeds, a pointer to the (possibly
        moved) new block will be returned.

void free(addr)
char *addr;

        Release the memory block at <addr> back into the free memory pool.
        If <addr> doesn't point to a block allocated by calloc(), malloc(),
        lalloc() or realloc(), very bad, unpredictable things will happen.

long msize(addr)
char *addr;

        Return the size, in bytes, of the memory block at <addr>.  Note
        that the size is a long value, since the block may have been
        allocated by lalloc().

long memavail()

        Return the size, in bytes, of the largest block of free memory
        available for allocation.  Note that this value is a long.


FILE HANDLING:

        You may want to include "IO.H" in your program if you use
        functions in this section, otherwise you may have to declare
        the return types for some functions.  "IO.H" also contains
        the definitions of many symbolic constants used with these
        functions.

int chdir(pathname)
char *pathname;

        Changes the current working directory to <pathname>.  If a
        drive letter is specified in <pathname>, the current working
        directory for that drive is set.  Returns 0 for success, or
        a negative error code.

int mkdir(pathname)
char *pathname;

        Creates a new directory called <pathname>.  A drive letter may
        be specified.  Returns 0 for success, or a negative error code.

int rmdir(pathname)
char *pathname;

        Removes an existing directory called <pathname>.  A drive letter may
        be specified.  Returns 0 for success, or a negative error code.

char *fullpath(full, part)
char *full;
char *part;

        <part> is a (possibly) ambiguous file/path specification.  A
        non-ambiguous file/path spec is created which includes a drive
        letter and all intermediate sub-directories.  If the partial
        specification is not valid, NULL is returned, otherwise a
        pointer to <full> is returned.  If NULL is specified for <full>,
        an internal buffer is used and a pointer to it is returned.

int access(name, amode)
char *name;
int amode;

        Return non-zero if a file with the given <name> can be accessed
        in the given <amode>.  Possible <amode> values are:
                _ACCe           file exists
                _ACCr           file can be read
                _ACCw           file can be written
                _ACCrw          file can be read and written

char *findfile(afn[, ext])
char *afn;
char *ext;

        Return full file spec for <afn> if found. If <afn> has no extension,
        extensions from <ext> are tried until a match is found, or the list
        ends.  <ext> is a list of extensions separated by '\0' characters
        and ending with an additional '\0', ie. "ttp\0tos\0prg\0" (note that
        the final null is added by the compiler to any string constant.  If
        <afn> already has an extension, <ext> is not used.  If no matching
        files are found, NULL is returned.  The pointer returned when a match
        is found points to a buffer which is internal to fullpath().  If you
        want to save the value returned, you must make a copy before the
        buffer is overwritten by subsequent calls.

char *pfindfile(afn[, ext])
char *afn;
char *ext;

        Like findfile() but search all directories listed in the environment
        variable "PATH", if no match is found in the current directory. If
        <afn> specifies a drive or directory, "PATH" is not used.

int stat(name, statbuf)
char *name;
STAT *statbuf;

        Search for file <name> and load <statbuf> with information
        about that file, if it is found.  Return 0 if found, or
        ERROR (-1) if no file/directory matched <name>.  Volume
        labels are not included in the search.

long fsize(name)
char *name;

        Return the size of the file <name> in bytes.  Note that this
        is a long value.  Return -1L if the file is not found.

int isatty(h)
int h;

        Return non-zero if <h> refers to a character device.  Both the
        device handles (-1..-3) and the standard handles (0..5) are
        considered character devices by this function.

int creat(filename, pmode)
char *filename;
int pmode;

        Create a new file with the given <filename>.  If a file with
        the name already exists, it will be truncated to zero bytes.
        Since the OS doesn't do this properly, the file is actually
        deleted and then re-created.  <pmode> specifies the attributes
        initially given to the file.  Valid <pmode> values are:
                _CRErw          read/write
                _CREro          read only
                _CREh           hidden file
                _CREs           system file
                _CREv           volume label
        If _CRErw or _CREv modes are specified, they must be the only
        mode given.  Other modes may be combined with the | operator.

int chmod(filename, pmode)
char *filename;
int pmode;

        Change the mode attribute of <filename> to <pmode>.  Values for
        <pmode> are the same as for the creat() function.  Returns 0 for
        success, or a negative error code.

int open(filename, iomode)
char *filename;
int iomode;

        Attempt to open <filename> with the given <iomode>.  This is a
        direct hook into the OS "Fopen" call.  A file handle is returned
        if the open succeeds.  A negative error code is returned for
        errors.  Valid <iomode> values are:
                _OPNr           read mode
                _OPNw           write mode
                _OPNrw          read/write mode

int close(h)
int h;

        Close file referenced by the file handle <h>.  Return 0 for
        success, or a negative error code.

int dup(handle)
int handle;

        Return a second file handle which refers to the same file as
        the given <handle>.

int dup2(handle1, handle2)
int handle1;
int handle2;

        Force <handle2> to refer to the same file as <handle1>.  Return
        0 for success, or a negative error code.  Both dup() and dup2()
        are direct calls to Fdup() and Fforce() GEMDOS calls.  Refer to
        your GEMDOS documentation for further information.

int unlink(filename)
char *filename;

        Delete <filename>, if it exists.  Return 0 for success, or a
        negative error code.

int rename(oldname, newname)
char *oldname;
char *newname;

        Change the name of file <oldname> to <newname>.  You may use this
        function to move files from one directory (pathname) to another,
        but not from one drive to another.  Return 0 for success, or a
        negative error code.

long lseek(h, offset, origin)
int h;
long offset;
int origin;

        Move file pointer for file <h> to specified location.  <origin>
        specifies the starting point for the <offset> distance.  Valid
        <origin> values are:
                _LSKbeg         from beginning of file  (0)
                _LSKcur         from current location   (1)
                _LSKend         from end of file        (2)
        The <offset> value is the distance in bytes from the origin.
        The final file position, or a negative error code, is returned.

long tell(h)
int h;

        Return the current file position for the file <h>.

FILE *fopen(filename, mode)
char *filename;
char *mode;

        Open <filename> as a stream file.  This is the normal open way
        to open a file.  The <mode> is a string specifying the mode(s)
        that are relevent to the file open.  Valid <mode> characters are:
                r               read mode
                w               write mode
                a               append mode
                b               binary mode
                t               text (translated) mode
        At least one of "r", "w" or "a" must be specified.  "t" is assumed
        and indicates that <nl> is translated to <cr><lf> on output and
        vica-versa on input.  If the stream is a character device, the
        translation is slightly different.  The output translation is the
        same, but on input <cr> and <lf> both become <nl> in all cases.
        The "b", for binary mode, overides "t" and indicated that characters
        are not translated during i/o operations.  "a" represents append
        mode and means that the file pointer will initially be placed at
        the end of the file.  "w" mode will create a file if it doesn't
        exists, or zero an existing file.  If "r" is the only mode specified,
        the file must already exist.  A (FILE *) is returned if the open
        succeeds, or NULL if it fails.

FILE *freopen(filename, mode, fp)
char *filename;
char *mode;
FILE *fp;

        Closes the file associated with <fp> and opens the new file as with
        fopen(), except that a new FILE structure is not created.  The
        existing FILE structure pointed to by <fp> is re-initialized with
        the new file information.  This is typically used to redirect i/o
        to standard streams "stdin", "stdout", "stderr", "stdprn", "stdaux".
        <fp> is returned for success, or NULL for failure.

FILE *fdopen(h, mode)
int h;
char *mode;

        Associates a stream with the already open file <h>.  The <mode>
        values are the same as for fopen(), but MUST be compatible with
        the mode in which <h> was open()ed.  This functions allows use
        of a file opened with the low level open()/creat() calls to be
        used as a buffered/translated stream.  A pointer to a FILE struct
        is returned, or NULL for errors.

int fclose(fp)
FILE *fp;

        Close the stream <fp>, flushing the buffer.  Returns 0 on success.

void setbuf(fp, buf)
FILE *fp;
char *buf;

        If <buf> is NULL, make <fp> unbuffered; else <buf> points to a buffer
        of BUFSIZ characters to be used as the stream buffer for <fp>.

void setvbuf(fp, buf, bmode, size)
FILE *fp;
char *buf;
int bmode;
unsigned int size;

        If <buf> is NULL or <bmode> is _SVBn, make <fp> unbuffered;
        otherwise <buf> points to a buffer of <size> characters to be
        used as the stream buffer for <fp>.  The <bmode> variable
        indicates the type of buffering desired, as follows:
                _SVBn           No buffering
                _SVBf           Full buffering (normal)
                _SVBl           Line buffering (not supported, same as _SVBf)

long fseek(fp, offset, origin)
FILE *fp;
long offset;
int origin;

        Operates like lseek(), except it works on streams.  Note that
        stream file positions may be misleading due to translation of
        <nl> characters during i/o.  ftell() may be used reliably with
        fseek() to reposition a file to a prior location.

void rewind(fp)
FILE *fp;

        Operates like fseek(fp, 0L, _LSKbeg), except it also clears the
        end-of-file and error flags for <fp>.  There is no return value.

long ftell(fp)
FILE *fp;

        Operates like tell(), except it works on streams.  Note that
        stream file positions may be misleading due to translation of
        <nl> characters during i/o.

int fileno(fp)

        Return the file handle associated with the stream <fp>.

int feof(fp)

        Return non-zero if <fp> is at end of file.

int ferror(fp)

        Return non-zero if and error has occurred on <fp>.

void clearerr(fp)

        Clear the error flag on <fp>.


INPUT/OUTPUT FUNCTIONS:

        You may want to include "IO.H" in your program if you use
        functions in this section, otherwise you may have to declare
        the return types for some functions.  "IO.H" also contains
        the definitions of many symbolic constants used with these
        functions.

int read(h, data, length)
int h;
char *data;
int length;

        Read <length> bytes from the file reference by file handle <h>.
        Data is stored in the buffer pointed to by <data>.  The number
        of bytes actually read is returned, 0 for end of file, or a
        negative error code.  Note that the maximum number of bytes
        that can be read by this function is MAXINT.

long lread(h, data, length)
int h;
char *data;
long length;

        Same as read(), but uses a long value for number of bytes to read.

int write(h, data, length)
int h;
char *data;
int length;

        Write <length> bytes to the file reference by file handle <h>.
        Data is written from the buffer pointed to by <data>.  The number
        of bytes actually written is returned, or a negative error code.
        Note that the maximum number of bytes that can be written by
        this function is MAXINT.

long lwrite(h, data, length)
int h;
char *data;
long length;

        Same as write(), but uses a long value for number of bytes to write.

int fread(data, size, count, fp)
char *data;
int size;
int count;
FILE *fp;

        Read <count> items of <size> characters each from stream <fp>.
        Data is stored in the buffer pointed to by <data>.  The number of
        full items actually read is returned, or a negative error code.
        This call DOES NOT translate characters, even if the stream is
        opened in translate mode.

int fwrite(data, size, count, fp)
char *data;
int size;
int count;
FILE *fp;

        Write <count> items of <size> characters each to stream <fp>.
        Data is read from the buffer pointed to by <data>.  The number of
        full items actually written is returned, or a negative error code.
        This call DOES NOT translate characters, even if the stream is
        opened in translate mode.

int fgetc(fp)
FILE *fp;

        Get a character from <fp>.  Returns the character or EOF.

int fungetc(c, fp)
char c;
FILE *fp;

        Push the character <c> back to be gotten by the next fgetc()
        call on <fp>.  Only 1 character may be ungotten at a time on
        each stream.  Subsequent calls to fungetc() will write over
        the currently saved character.

int fputc(c, fp)
char c;
FILE *fp;

        Put the character <c> to the stream <fp>.

int fflush(fp)
FILE *fp;

        Flush the output buffer of the stream <fp>.  The buffer is
        automatically flushed when it is full, the stream is closed,
        or the program terminates through exit().  This function has
        no effect if the stream in unbuffered.

int getc(fp)
FILE *fp;

        Same as fgetc() but implemented as a macro.

int ungetc(c, fp)
char c;
FILE *fp;

        Same as fungetc() but implemented as a macro.

int putc(c, fp)
char c;
FILE *fp;

        Same as fputc() but implemented as a macro.

int getw(fp)
FILE *fp;

        Get a 2-byte value from the stream <fp>.  The high-order byte is
        read first.

int putw(n, fp)
int n;
FILE *fp;

        Put the 2-byte value <n> to the stream <fp>.  The high-order byte
        is written first.

int getchar()

        Same as "fgetc(stdin)".

int ungetchar(c)
char c;

        Same as "fungetc(c, stdin)".  Note that this name will
        conflict with any function beginning "ungetch..." due to
        having only 7 significant characters in Alcyon C v4.14.

int putchar(c)
char c;

        Same as "fputc(c, stdin)".

int cfg_ch(cfg)
int cfg;

        Configure getch()/putch() operation.  The following are legal
        values for <cfg> and may be combined with the | operator:
                _CIOb           Use BIOS level i/o calls
                _CIOch          8-bit character codes only (cf:getch)
                _CIOvt          Enable VT-52 escape sequence processing
        The initial configuration value at run time is _CIOch.

int getch()

        Machine dependent console input function.  This function normally
        gets a character from the keyboard by calling the GEMDOS "Cconin"
        function.  If cfg_ch() is given the _CIOb option, input is gotten
        from the BIOS "Bconin" function instead.  The BIOS level functions
        don't process ^C, ^S or ^Q, while the GEMDOS functions do.  The
        most common use for getch() is when keyboard scan codes are needed
        to process special function keys.  The return value from getch()
        consists of the scan code in the high-order byte, and the ascii
        character code in the low-order byte.  If cfg_ch() is given the
        _CIOch option, the return value is always an 8-bit quantity,
        either the scan code with the 8th bit set, or the ascii code with
        the 8th bit clear.  This is somewhat less informative, since the
        scan code form is returned only if the ascii value is 0, but is the
        default configuration value for compatability with Microsoft C.
        In any case, the global unsigned long variable "_getch" will contain
        the full character code value returned by the OS.

int getche()

        Same as getch() but calls putch() to echo the character.

char putch(c)
char c;

        Machine dependent (typically quite fast) console output function.
        This function normally puts a character to the console by calling
        the GEMDOS "Cconout" function.  If cfg_ch() is given the _CIOb
        option, output is sent to the BIOS "Bconout" function instead.
        The BIOS level functions don't process ^C, ^S or ^Q, while the
        GEMDOS functions do.  At the BIOS level, the _CIOvt option to
        cfg_ch() allows VT-52 escape code processing on output.  The
        GEMDOS function always does VT-52 emulation.  The BIOS function
        defaults to skipping this overhead, but if VT-52 emulation is
        desired, it can still be used through the faster BIOS level
        routine by using the _CIOvt option.  Control codes, like '\b'
        and '\r', are supported even without VT-52 emulation.  The return
        value of this function is simply the character sent.

int kbhit()

        Machine dependent function to detect if input is waiting for the
        getch() function.  Returns non-zero if the console has data ready.

char *getln(ip, get, put, buffer, limit)
char *ip;
int (*get)();
int (*put)();
char *buffer;
int limit;

        Get a line of input from the user.  Allow simple editing of the line
        with BS/DEL, ESC, and CR/LF to terminate input.  Characters are
        retreived by a (*get)(ip) and echoed with (*put)(c).  A pointer to
        <buffer> is returned in any case.

char *fgets(data, limit, fp)
char *data;
int limit;
FILE *fp;

        Get data from <fp> and puts it in the <data> buffer.  At most,
        <limit>-1 characters will be read.  Input will also be terminated
        when a newline is read.  <data> will be '\0' terminated and the
        newline, if read, will be included.  A pointer to the start of
        <data> is returned, or NULL for EOF.

void fputs(data, fp)
char *data;
FILE *fp;

        Write the characters in <data> to the stream <fp>.  A newline
        WILL NOT be added.

char *gets(data)
char *data;

        Get data from stdin and puts it in the <data> buffer.  Input is
        terminated when a newline is read.  The newline will be replaced
        by a '\0' to terminate the string.  A backspace character will
        remove the preceeding character from the buffer, but will not
        backspace past the start of the buffer.  A pointer to the start
        of <data> is returned, or NULL for EOF.

void puts(data)
char *data;

        Write the characters in <data> to stdout.  A newline WILL be
        written after the data.

void cputs(data)
char *data;

        Write the characters in <data> directly to the console using the
        system dependent putch() function.  A newline WILL NOT be written
        after the data.

int fprintf(fp, fmt[, arg1, ..., argN])
FILE *fp;
char *fmt;

        Formatted output to the stream <fp>.  See the _printf() function
        for a description of the <fmt> formatting string.

int printf(fmt[, arg1, ..., argN])
char *fmt;

        Formatted output to the stdout stream.  See the _printf() function
        for a description of the <fmt> formatting string.

int sprintf(buf, fmt[, arg1, ..., argN])
char *buf;
char *fmt;

        Formatted output to the string <s>.  See the _printf() function
        for a description of the <fmt> formatting string.

int cprintf(fmt[, arg1, ..., argN])
char *fmt;

        Formatted output directly to the console.  This functions uses the
        system dependent putch() for output.  See the _printf() function
        for a description of the <fmt> formatting string.

int fscanf(fp, fmt[, arg1, ..., argN])
FILE *fp;
char *fmt;

        Formatted input from the stream <fp>.  See the _scanf() function
        for a description of the <fmt> formatting string.

int scanf(fmt[, arg1, ..., argN])
char *fmt;

        Formatted input from the stdin stream.  See the _scanf() function
        for a description of the <fmt> formatting string.

int sscanf(buf, fmt[, arg1, ..., argN])
char *buf;
char *fmt;

        Formatted input from the string <s>.  See the _scanf() function
        for a description of the <fmt> formatting string.


FORMATTING/TYPE CONVERSION:

int _printf(op, put, fmt, args)
char *op;
int (*put)();
char *fmt;
int *args;

        <fmt> points to a format control string.  <args> pointers to a
        list of arguments.  The format string is used to create and output
        stream with the arguments.  The <put> function is used to output
        each character.  The <op> parameter is given to the <put> function
        to specify the output stream.  Calls to <put> are of the form:
        "(*put)(c, op);" where <c> is the character to output.  The format
        string is composed of characters and format specifications.  The
        '%' character introduces a format specifier.  The general form of
        a format specifier is:
            %[-][ |+][0][<width>|*][.[<precision>|*]][l]{d|i|u|o|x|b|c|s}
        The '-' specifies left justification.  The ' ' or '+' specifies
        the character which preceeds positive numeric values.  The '0'
        specifies that numeric fields will be padded with '0' rather than
        ' '.  The <width> field is a numeric value specifying a minimum
        field width.  The <precision> field is a numeric value specifying
        the maximum number of data characters to display.  If '*' is
        specified for the width or the precision, an "int" value is taken
        from the argument list and used for that value.  If no width is
        specified, the field width varies according to the data width.  If
        no precision is specified, all data characters are included in the
        data width.  If the data width exceeds the field width, the field
        width will expand to allow all data characters to be printed.
        Including the 'l' or capitalizing the trailing character specifies
        that the associated value is a "long" type.  The trailing character
        specifies the format type, as follows:
                d       Signed decimal integer
                i       same as 'd'
                u       Unsigned decimal integer
                o       Unsigned octal integer
                x       Unsigned hexadecimal integer
                b       Unsigned binary integer
                c       Character
                s       String
        If the character following the '%' is not recognized, it is
        simply passed along to the output stream, thus "%%" is used to
        print a single '%' character.

char *ltoa(n, buffer, radix)
long n;
char *buffer;
int radix;

        Convert the long value <n> to a string in <buf> using <radix>
        as the number base.  If <n> is negative, '-' will be the first
        character in <buf>.  A pointer to <buf> is returned.

char *ultoa(n, buffer, radix)
unsigned long n;
char *buffer;
int radix;

        Convert the unsigned long value <n> to a string in <buf> using
        <radix> as the number base.  A pointer to <buf> is returned.

char *itoa(n, buffer, radix)
int n;
char *buffer;
int radix;

        Convert the integer value <n> to a string in <buf> using <radix>
        as the number base.  If <n> is negative, '-' will be the first
        character in <buf>.  A pointer to <buf> is returned.

long atol(number)
char *number;

        Convert the string <number> to a long value.  Leading whitespace
        is ignored, a leading +/- is optional.  Characters are processed
        until a non-digit is reached.  Return value is undefined in an
        overflow situation.

int atoi(number)
char *number;

        Convert the string <number> to an int value.  Leading whitespace
        is ignored, a leading +/- is optional.  Characters are processed
        until a non-digit is reached.  Return value is undefined in an
        overflow situation.

int _scanf(ip, get, unget, fmt, args)
char *ip;
int (*get)();
int (*unget)();
char *fmt;
char **args;

        <fmt> points to a format control string.  <args> pointers to a
        list of arguments, each of which is the address of a variable in
        which input data may be stored.  The format string is used to
        control reading of characters from the <get> function.  As each
        character is needed <get> is called in the form "c = (*get)(ip);"
        where <c> is the character read (negative for errors) and <ip> is
        the auxiliary pointer specified by the <ip> parameter.  If a
        character needs to be un-gotten, a call to <unget> of the form
        "(*unget)(c, ip);" is made.  The format string is composed of
        characters and format specifications.  Any characters in <fmt>,
        except whitespace characters, which are not part of a format
        specifier are expected to be matched one-to-one by characters in
        the input stream.  Scanning terminates if a mismatch occurs or if
        any call to <get> results in an error.  Whitespace characters
        match 0 or more whitespace characters in the input stream.  The
        '%' character introduces a format specifier.  The general form
        of a format specifier is:
                 %[*][<width>][l|h]{d|u|o|x|b|i|c|s}
        The '*' specifies that a field is to be scanned by not stored.
        No variable pointer should be provided for non-stored format
        specs.  The <width> field specifies that maximum number of
        characters to be process to fill the given format type.  Less
        than <width> characters will be processed if the field ends
        before <width> characters have been processed.  A field ends when
        either a whitespace character, or a character which does not fit
        the specified format, is read.  The preceding 'l' specifies that
        the associated variable is a "long" type.  The trailing character
        specifies the format type, as follows:
                d Signed decimal integer
                u Unsigned decimal integer
                o Unsigned octal integer
                x Unsigned hexadecimal integer
                b Unsigned binary integer
                i Unsigned decimal/octal/hexadecimal/binary integer
                c Character
                s String
        If a <width> is specified with the 'c' format, exactly <width>
        characters (including whitespace) are read from the input stream,
        and written to a string.  No '\0' character is added If the
        character following the '%' is not recognized, it is expected to
        match the input stream as a non-format character, thus "%%" is
        used to match a single '%' character.  One additional conversion is
        the brace-format.  Shown as "%[...]", the '...' represent a list of
        characters.  If the first character in the list is a '^', the field
        contains any characters NOT in the list (starting with the 1st
        character after the '^').  If the first character of the list is
        not a '^', then the field will only contain those characters found
        in the list.  The field will be stored as a null terminated string.
        Unlike most of the other formats, this conversion does allow the
        programmer to specify that whitespace characters will be included
        in the resulting string.

char *ctlcnv(string)
char *string;

        Convert \<char> notation in <string> to actual characters.  This
        is useful for reading strings from a stream when you want to allow
        insertion of control character or other characters that may have
        special meaning otherwise, or may not otherwise be allowed.  The
        following formats are supported:
                \n              newline or linefeed
                \r              carriage return
                \0              null character (value 0)
                \b              backspace
                \t              horizontal tab
                \v              vertical tab
                \f              form feed
                \a              alarm (bell)
                \\              backslash
                \'              single quote
                \"              double quote
                \NNN            octal constant
                \xNN            hexadecimal constant
                \<nl>           "folded" line (both characters removed)
        A pointer to the modified <string> is returned.


STRING MANIPULATION:

        You may want to include "STRING.H" in your program if you use
        functions in this section, otherwise you'll have to declare the
        return types for any functions you use.

char *blkcpy(dest, source, len)
char *dest;
char *source;
int len;

        Copies the <source> block to the <dest>.  <len> bytes are
        always copied.  No terminator is added to <dest>.  A pointer
        to <dest> is returned.  Overlap checking IS done.

char *lblkcpy(dest, source, len)
char *dest;
char *source;
long len;

        Same as blkcpy() except a long value is used for <len>.

char *blkfill(dest, data, len)
char *dest;
char data;
int len;

        Fill <dest> will <len> bytes of <data>.  A pointer to <dest>
        is returned.

int blkcmp(blk1, blk2, len)
char *blk1;
char *blk2;
int len;

        Lexicographically compare the two blocks.  Return a value
        indicating the relationship between the blocks.  Possible
        return values are:
                negative        blk1 < blk2
                0               blk1 == blk2
                positive        blk1 > blk2
        <len> bytes are always compared.

int blkicmp(blk1, blk2, len)
char *blk1;
char *blk2;
int len;

        Compare blocks as with blkcmp(), but ignore the case of any
        alphabetic characters.

char *memcpy(dst, src, cnt)
char *dst;
char *src;
int cnt;

        Same as blkcpy().

char *memccpy(dst, src, c, cnt)
char *dst;
char *src;
char c;
int cnt;

        Copy bytes from <src> to <dst> until either <cnt> bytes have been
        copied, or the character <c> has been copied.  Returns <dst>.

char *memset(dst, c, cnt)
char *dst;
char c;
int cnt;

        Same as blkfill().

char *memchr(buf, c, cnt)
char *buf;
char c;
int cnt;

        Search the first <cnt> bytes of <buf> for <c>.  Returns a pointer to
        the matching character, or NULL if not found.

int memcmp(buf1, buf2, cnt)
char *buf1;
char *buf2;
int cnt;

        Same as blkcmp().

int memicmp(buf1, buf2, cnt)
char *buf1;
char *buf2;
int cnt;

        Same as blkicmp().

int strlen(string)
char *string;

        Returns the number of characters in a string, not including the
        terminating '\0'.

char *strcpy(dest, source)
char *dest;
char *source;

        Copies the <source> string to the <dest> including the '\0'.  A
        pointer to the start of <dest> is returned.

char *strncpy(dest, source, limit)
char *dest;
char *source;
int limit;

        Copies the <source> string to the <dest>.  At most, <limit>
        characters are copied.  If <source> ends before <limit> characters
        have been copied, the '\0' is copied, otherwise <dest> is not
        terminated by the copy.

char *strdup(string)
char *string;

        Create a copy of <string> and return a pointer to the copy.

char *strset(string, c)
char *string;
char c;

        Fill <string> with <c> up the the terminating '\0' of <string>.

char *strnset(string, c, n)
char *string;
char c;
int n;

        Fill at most <n> characters of <string> with <c>, up the the
        terminating '\0' of <string>.

char *substr(dest, source, start, end)
char *dest;
char *source;
int start;
int end;

        Copy characters from <source> to <dest> starting with character
        <start> and ending with <end>.  A pointer to <dest>, which will
        be '\0' terminated, is returned.

char *subnstr(dest, source, start, length)
char *dest;
char *source;
int start;
int length;

        Copy <length> characters from <source> to <dest> starting with
        character <start>.  A pointer to <dest>, which will be '\0'
        terminated, is returned.

char *strcat(dest, source)
char *dest;
char *source;

        Concatenate <source> on the end of <dest>.  The terminator of
        <dest> will be overwritten by the first character of <source>.
        The termintor from <source> will be copied.  A pointer to
        the modified <dest> is returned.

char *strncat(dest, source, limit)
char *dest;
char *source;
int limit;

        Concatenate <limit> characters from <source> onto <dest>.  If
        <source> contains less than <limit> characters, the length of
        source is used for <limit>.  The terminating '\0' is always
        added.  A pointer to <dest> is returned.

char *strupr(string)
char *string;

        Convert all alphabetic characters in <string> to upper case.

char *strlwr(string)
char *string;

        Convert all alphabetic characters in <string> to lower case.

char *strrev(string)
char *string;

        Reverse the order of the characters in <string> in place.

int strcmp(str1, str2)
char *str1;
char *str2;

        Lexicographically compare the two strings.  Return a value
        indicating the relationship between the strings.  Possible
        return values are:
                negative        str1 < str2
                0               str1 == str2
                positive        str1 > str2

int strncmp(str1, str2, limit)
char *str1;
char *str2;
int limit;

        Compare strings as with strcmp(), but limit comparison to the
        <limit> characters.

int stricmp(str1, str2)
char *str1;
char *str2;

        Compare strings as with strcmp(), but ignore the case of any
        alphabetic characters.

int strnicmp(str1, str2, limit)
char *str1;
char *str2;
int limit;

        Compare strings as with strncmp(), but ignore the case of any
        alphabetic characters.

char *strstr(string, pattern)
char *string;
char *pattern;

        Return a pointer to the first occurance of <pattern> in <string>.
        NULL is returned if <pattern> is not found.

char *stristr(string, pattern)
char *string;
char *pattern;

        Same as strstr(), but ignore the case of any alphabetic characters.

char *strchr(string, symbol)
char *string;
char symbol;

        Return a pointer to the first occurance of <symbol> in <string>.
        NULL is returned if <symbol> is not found.

char *strrchr(string, symbol)
char *string;
char symbol;

        Return a pointer to the last occurance of <symbol> in <string>.
        NULL is returned if <symbol> is not found.

int strpos(string, symbol)
char *string;
char symbol;

        Return the index of the first occurance of <symbol> in <string>.
        -1 is returned if <symbol> is not found.

int strrpos(string, symbol)
char *string;
char symbol;

        Return the index of the last occurance of <symbol> in <string>.
        -1 is returned if <symbol> is not found.

int strspn(string, set)
char *string;
char *set;

        Return the length of the sub-string of <string> that consists
        entirely of characters found in <set>.  The terminating '\0'
        in <set> is not considered part of the match set.  If the first
        character if <string> is not in <set>, 0 is returned.

int strcspn(string, symbol)
char *string;
char *set;

        Return the length of the sub-string of <string> that consists
        entirely of characters not found in <set>.  The terminating '\0'
        in <set> is not considered part of the match set.  If the first
        character if <string> is in <set>, 0 is returned.

char *strpbrk(string, set)
char *string;
char *set;

        Return a pointer to the first occurace in <string> of any
        character in <set>.

char *strrpbrk(string, set)
char *string;
char *set;

        Return a pointer to the last occurace in <string> of any
        character in <set>.

char *strtok(string, delim)
char *string;
char *delim;

        Return a token from <string>.  If <string> is not NULL, it is
        the beginning of a string from which tokens are to be extracted.
        Characters found in <delim> are skipped over to find the start
        of a token, characters are then accumulated until a character in
        <delim> is found, or the terminator of <string> is reached.
        A pointer to the '\0' terminated token is then returned.  Note
        that this function modifies <string> (by inserting '\0's) in
        the process.  Subsequent calls to strtok() may specify NULL as
        the <string> argument, in which case subsequent tokens are
        returned, or NULL if there are no more tokens.

char *strtrim(string, junk)
char *string;
char *junk;

        Remove leading and trailing characters found in <junk>
        from <string>.  Return a pointer to the modified <string>.

char *stradj(string, dir)
char *string;
int dir;

        Adjust <string> by adding space if <dir> is positive, or removing
        space if <dir> is negative.  The magnitude of <dir> is the number
        of character positions to add or remove.  Characters are added or
        removed at the beginning of <string>.  A pointer to the modified
        <string> is returned.

int strrpl(string, ptrn, rpl, n)
char *string;
char *ptrn;
char *rpl;
int n;

        Replace at most <n> occurances of <ptrn> in <string> with <rpl>.
        If <n> is -1, replace all.  Return the number of replacments.

int strirpl(string, ptrn, rpl, n)
char *string;
char *ptrn;
char *rpl;
int n;

        Same as strrpl() except ignore the case of alphabetic characters.


CHARACTER FUNCTIONS:

        To use the functions in this section, you must include "CTYPE.H"
        in your source file.  Please note that the isXXXX() functions,
        except isascii(), only have defined results if isascii() is true.
        (ie. they only work properly on values 0x00 through 0x7F)

int toupper(c)
int c;

        Convert <c> to upper case, if alphabetic.  This is implemeted
        as a macro and also as a function.  You may force use of the
        function version rather than the macro (which evaluates its
        argument twice) by using the "#undef toupper" directive.

int tolower(c)
int c;

        Convert <c> to lower case, if alphabetic.  This is implemeted
        as a macro and also as a function.  You may force use of the
        function version rather than the macro (which evaluates its
        argument twice) by using the "#undef tolower" directive.

int _toupper(c)
int c;

        This macro should be used only if <c> is known to be lower case.
        It converts <c> to upper case.  Results are undefined if converting
        a character which is not lower case.

int _tolower(c)
int c;

        This macro should be used only if <c> is known to be upper case.
        It converts <c> to lower case.  Results are undefined if converting
        a character which is not upper case.

int toascii(c)
int c;

        Convert <c> to 7-bit ascii, putting it into the range 0x00..0x7F.

int isalnum(c)
int c;

        Return non-zero if <c> is '0'..'9','A'..'Z','a'..'z'.

int isalpha(c)
int c;

        Return non-zero if <c> is 'A'..'Z','a'..'z'.

int isascii(c)
int c;

        Return non-zero if <c> is 0x00..0x7F.

int iscntrl(c)
int c;

        Return non-zero if <c> is 0x00..0x1F,0x7F.

int isdigit(c)
int c;

        Return non-zero if <c> is '0'..'9'.

int islower(c)
int c;

        Return non-zero if <c> is 'a'..'z'.

int isprint(c)
int c;

        Return non-zero if <c> is 0x20..0x7E.

int ispunct(c)
int c;

        Return non-zero if <c> is not iscntrl(), isalnum() or isspace().

int isspace(c)
int c;

        Return non-zero if <c> is 0x09..0x0D,0x20.

int isupper(c)
int c;

        Return non-zero if <c> is 'A'..'Z'.

int isxdigit(c)
int c;

        Return non-zero if <c> is '0'..'9','A'..'F','a'..'f'.


DATE/TIME FUNCTIONS:

        To use the functions in this section, you must include "TIME.H"
        in your source file.

long time(rawtime)
long *rawtime;

        Get the current system clock date/time value.  Under many systems,
        this function returns the number of seconds since 00:00:00 GMT on
        Jan 1, 1970.  This implementation returns an encoded date/time
        value instead.  Therefore any programs which depend on this value
        being a number of seconds will not work properly.  However, other
        functions in this section which make use of the raw time value
        returned by time() are implemented to be compatible with this
        encoding, and will work properly.  In addition to returning the
        raw time value, if the <rawtime> pointer is not NULL, the value
        is stored in the long <rawtime> points to.

char *ctime(rawtime)
long *rawtime;

        Convert <rawtime> to a string.  A 26 character fixed field string
        is created from the raw time value.  The following is an example
        of what this string might look like:
                "Wed Jul 08 18:43:07 1987\n\0"
        A 24-hour clock is used, and due to a limitation in the ST system
        clock value, only a resolution of 2 seconds is possible.  A pointer
        to the formatted string, which is held in an internal buffer, is
        returned.

struct tm *gmtime(rawtime)
long *rawtime;

        Convert <rawtime> to fill time structure fields.  A pointer to an
        internal structure is returned.  Refer to "TIME.H" for the values
        of the various structure fields.

struct tm *localtime(rawtime)
long *rawtime;

        Since there is not concept of "time zone" on the ST, this function
        is identical to gmtime().

char *asctime(time)
struct tm *time;

        Convert <time> structure value to a string.  The same format, and
        the same internal buffer, as for ctime() is used for this function.

long cnvtime(rawtime, time)
long *rawtime;
struct tm *time;

        Convert <time> structure value to raw time format.  In addition to
        returning the raw time value, if the <rawtime> pointer in not NULL,
        the value is stored in the long <rawtime> points to. (cf: time)

void stime(rawtime)
long *rawtime;

        Set the system clock to <rawtime>.

int utime(pathname, rawtime)
char *pathname;
long *rawtime;

        Set the modification date of <pathname> to <rawtime>.  Returns zero
        for success, or a negative error code.

long start_timer(t)
TIMER *t;

        Start a 200Hz timer.  This timer value can later be checked with
        time_since() to determine elapsed time.  These functions provide
        a very low-overhead way of timing events.

long time_since(t)
TIMER *t;

        Returns the number of 200Hz ticks since start_timer() was called
        for timer <t>.

void sleep(dt)
int dt;

        Suspend operation for <dt> seconds.  This is implemented as a
        start_timer()/time_since() tight loop waiting for the specified
        amount of time to pass.  In a multi-tasking environment, this
        function should be replaced by a call which will de-activate
        this task for a period of time, allowing other tasks to run.


SEARCHING AND SORTING:

void qsort(base, num, size, cmp)
char *base;
int num;
int size;
int (*cmp)();

        Perform a recursive quick-sort on an array starting at <base>
        containing <num> elements of <size> bytes each.  The function
        pointed to by <cmp> is used to compare elements.  Pointers to
        two items in the array are passed to the function, which must
        return a number representing their relationship as follows:
                negative        item1 < item2
                0               item1 == item2
                positive        item1 > item2
        The qsort() function requires the use of a temporary data area
        that is large enough to hold <size> bytes.  The default space
        provided is 128 bytes large.  If your record size is larger than
        128 bytes, YOU MUST provide an alternative storage area.  The
        global variable "_qbuf" points to the storage qsort() will use.
        Setting "_qbuf" to NULL restores use of the internal buffer.
        This routine is optimized to avoid N*N sort times for ordered data.

void hsort(base, num, size, cmp)
char *base;
int num;
int size;
int (*cmp)();

        Perform an N*log(N) heap-sort on an array starting at <base>
        containing <num> elements of <size> bytes each.  The function
        pointed to by <cmp> is used to compare elements.  Pointers to
        two items in the array are passed to the function, which must
        return a number representing their relationship as follows:
                negative        item1 < item2
                0               item1 == item2
                positive        item1 > item2
        The hsort() function requires no extra storage, is not recursive,
        and has an almost constant N*log(N) sort time.  In the average
        case, it is about half as fast as qsort() on random data.  If
        portability is a concern, it should be noted that qsort() is
        almost always available, but hsort() is not.

char *bsearch(key, base, num, size, cmp)
char *key;
char *base;
int num;
int size;
int (*cmp)();

        Perform a binary search for <key> on the sorted data at <base>.
        <num>, <size> and <cmp> are like the corresponding parameters
        to qsort().  A pointer to the matching element is returned for
        success, or NULL for failure.  The global variable "_bsearch"
        will contain the index of either the matching element, or the
        place where <key> value should be inserted.  The use of "_bsearch"
        is not supported by many implementations of bsearch().

char *lsearch(key, base, num, size, cmp)
char *key;
char *base;
int num;
int size;
int (*cmp)();

        Perform a linear search for <key> on the data at <base>. The
        <num>, <size> and <cmp> parameters are like the corresponding
        parameters to qsort().  A pointer to the first matching element
        is returned for success, or NULL for failure.  If <key> is not
        found, it will be added to the end of the array.

char *lfind(key, base, num, size, cmp)
char *key;
char *base;
int num;
int size;
int (*cmp)();

        Like lsearch(), but do not add elements which are not found.


MISCELLANEOUS FUNCTIONS:

int rand()

        Return a pseudorandom number in the range 0..32767

void srand(seed)
unsigned int seed;

        Seed the random number generator.  This function is #defined as
        a comment, since no seeding is possible for this implementation
        of rand().

MACRO abs(x)

        Return the absolute value of <x>.  This macro evalutes it's
        argument twice. ((x)<0?(-(x)):(x))

MACRO max(x,y)

        Return the larger of <x> and <y>.  This macro evaluates the
        larger argument twice and the smaller argument once.

MACRO min(x,y)

        Return the smaller of <x> and <y>.  This macro evaluates the
        smaller argument twice and the larger argument once.

MACRO swap(a,b)

        Exchange <a> and <b> by chained XORs.  The macro evaluates
        each argument several times.


----- END OF FILE -----
