*** ../arg.h	Mon Nov 11 10:44:40 1991
--- arg.h	Fri Nov 15 14:50:56 1991
***************
*** 286,292 ****
--- 286,296 ----
  #define O_REWINDDIR 263
  #define O_CLOSEDIR 264
  #define O_SYSCALL 265
+ #ifdef atarist
+ #define PERL_O_PIPE 266
+ #else
  #define O_PIPE 266
+ #endif
  #define O_TRY 267
  #define O_EVALONCE 268
  #define MAXO 269
*** ../doarg.c	Fri Nov 15 10:13:32 1991
--- doarg.c	Fri Nov 15 14:50:57 1991
***************
*** 1666,1672 ****
--- 1666,1676 ----
      register STR **st = stack->ary_array;
      register int sp = arglast[1];
      register int items = arglast[2] - sp;
+ #ifdef atarist
+     unsigned long arg[14]; /* yes, we really need that many ! */
+ #else
      unsigned long arg[8];
+ #endif
      register int i = 0;
      int retval = -1;
  
***************
*** 1723,1728 ****
--- 1727,1758 ----
  	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
  	  arg[7]);
  	break;
+ #ifdef atarist
+     case 9:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8]);
+ 	break;
+     case 10:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8], arg[9]);
+ 	break;
+     case 11:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8], arg[9], arg[10]);
+ 	break;
+     case 12:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8], arg[9], arg[10], arg[11]);
+ 	break;
+     case 13:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12]);
+ 	break;
+     case 14:
+ 	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
+ 	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12], arg[13]);
+ 	break;
+ #endif /* atarist */
      }
      return retval;
  #else
*** ../doio.c	Mon Nov 11 10:38:04 1991
--- doio.c	Fri Nov 15 14:50:58 1991
***************
*** 100,105 ****
--- 100,106 ----
      FILE *saveofp = Nullfp;
      char savetype = ' ';
  
+     mode[0] = mode[1] = mode[2] = '\0';
      name = myname;
      forkprocess = 1;		/* assume true if no fork */
      while (len && isSPACE(name[len-1]))
***************
*** 384,390 ****
  		    }
  #endif
  #ifdef HAS_RENAME
! #ifndef MSDOS
  		    if (rename(oldname,str->str_ptr) < 0) {
  			warn("Can't rename %s to %s: %s, skipping file",
  			  oldname, str->str_ptr, strerror(errno) );
--- 385,391 ----
  		    }
  #endif
  #ifdef HAS_RENAME
! #ifndef MSDOS_OR_ATARI
  		    if (rename(oldname,str->str_ptr) < 0) {
  			warn("Can't rename %s to %s: %s, skipping file",
  			  oldname, str->str_ptr, strerror(errno) );
***************
*** 411,417 ****
  #endif
  		}
  		else {
! #ifndef MSDOS
  		    if (UNLINK(oldname) < 0) {
  			warn("Can't rename %s to %s: %s, skipping file",
  			  oldname, str->str_ptr, strerror(errno) );
--- 412,418 ----
  #endif
  		}
  		else {
! #ifndef MSDOS_OR_ATARI
  		    if (UNLINK(oldname) < 0) {
  			warn("Can't rename %s to %s: %s, skipping file",
  			  oldname, str->str_ptr, strerror(errno) );
***************
*** 700,706 ****
      }
      else {
  	retval = (int)str_gnum(argstr);
! #ifdef MSDOS
  	s = (char*)(long)retval;		/* ouch */
  #else
  	s = (char*)retval;		/* ouch */
--- 701,707 ----
      }
      else {
  	retval = (int)str_gnum(argstr);
! #ifdef MSDOS_OR_ATARI
  	s = (char*)(long)retval;		/* ouch */
  #else
  	s = (char*)retval;		/* ouch */
***************
*** 711,717 ****
      if (optype == O_IOCTL)
  	retval = ioctl(fileno(stio->ifp), func, s);
      else
! #ifdef MSDOS
  	fatal("fcntl is not implemented");
  #else
  #ifdef HAS_FCNTL
--- 712,718 ----
      if (optype == O_IOCTL)
  	retval = ioctl(fileno(stio->ifp), func, s);
      else
! #ifdef MSDOS_OR_ATARI
  	fatal("fcntl is not implemented");
  #else
  #ifdef HAS_FCNTL
***************
*** 2469,2475 ****
  int effective;
  register struct stat *statbufp;
  {
! #ifdef MSDOS
      /* [Comments and code from Len Reed]
       * MS-DOS "user" is similar to UNIX's "superuser," but can't write
       * to write-protected files.  The execute permission bit is set
--- 2470,2476 ----
  int effective;
  register struct stat *statbufp;
  {
! #ifdef MSDOS_OR_ATARI
      /* [Comments and code from Len Reed]
       * MS-DOS "user" is similar to UNIX's "superuser," but can't write
       * to write-protected files.  The execute permission bit is set
***************
*** 2488,2493 ****
--- 2489,2497 ----
       *		Sun's PC-NFS.]
       */
  
+      /* Atari stat() does pretty much the same thing. we set x_bit_set_in_stat
+       * too so it will actually look into the files for magic numbers
+       */
       return (bit & statbufp->st_mode) ? TRUE : FALSE;
  
  #else /* ! MSDOS */
*** ../eval.c	Mon Nov 11 10:38:05 1991
--- eval.c	Fri Nov 15 14:51:00 1991
***************
*** 390,396 ****
  	    old_rschar = rschar;
  	    old_rslen = rslen;
  	    rslen = 1;
! #ifdef MSDOS
  	    rschar = 0;
  #else
  #ifdef CSH
--- 390,396 ----
  	    old_rschar = rschar;
  	    old_rslen = rslen;
  	    rslen = 1;
! #ifdef MSDOS_OR_ATARI
  	    rschar = 0;
  #else
  #ifdef CSH
***************
*** 433,439 ****
  			(void) interp(str,stab_val(last_in_stab),sp);
  			st = stack->ary_array;
  			tmpstr = Str_new(55,0);
! #ifdef MSDOS
  			str_set(tmpstr, "perlglob ");
  			str_scat(tmpstr,str);
  			str_cat(tmpstr," |");
--- 433,439 ----
  			(void) interp(str,stab_val(last_in_stab),sp);
  			st = stack->ary_array;
  			tmpstr = Str_new(55,0);
! #ifdef MSDOS_OR_ATARI
  			str_set(tmpstr, "perlglob ");
  			str_scat(tmpstr,str);
  			str_cat(tmpstr," |");
***************
*** 2862,2869 ****
  	    stab = stabent(str_get(st[1]),TRUE);
  	if (!stab || !(stio = stab_io(stab)) || !(fp = stio->ifp))
  	    goto say_undef;
! #ifdef MSDOS
  	str_set(str, (setmode(fileno(fp), O_BINARY) != -1) ? Yes : No);
  #else
  	str_set(str, Yes);
  #endif
--- 2862,2879 ----
  	    stab = stabent(str_get(st[1]),TRUE);
  	if (!stab || !(stio = stab_io(stab)) || !(fp = stio->ifp))
  	    goto say_undef;
! #ifdef MSDOS_OR_ATARI
! #ifdef atarist
! 	if(fflush(fp))
! 	   str_set(str, No);
! 	else
! 	{
! 	    fp->_flag |= _IOBIN;
! 	    str_set(str, Yes);
! 	}
! #else
  	str_set(str, (setmode(fileno(fp), O_BINARY) != -1) ? Yes : No);
+ #endif
  #else
  	str_set(str, Yes);
  #endif
***************
*** 2938,2944 ****
--- 2948,2958 ----
      case O_SYSCALL:
  	value = (double)do_syscall(arglast);
  	goto donumset;
+ #ifdef atarist
+     case PERL_O_PIPE:
+ #else
      case O_PIPE:
+ #endif
  #ifdef HAS_PIPE
  	if ((arg[1].arg_type & A_MASK) == A_WORD)
  	    stab = arg[1].arg_ptr.arg_stab;
*** ../handy.h	Mon Nov 11 10:45:27 1991
--- handy.h	Fri Nov 15 14:51:00 1991
***************
*** 74,80 ****
--- 74,84 ----
  #define isLOWER(c) (isascii(c) && islower(c))
  #endif
  
+ #ifdef STANDARD_C
+ #define MEM_SIZE size_t
+ #else
  #define MEM_SIZE unsigned int
+ #endif
  
  /* Line numbers are unsigned, 16 bits. */
  typedef unsigned short line_t;
*** ../malloc.c	Mon Nov 11 10:39:14 1991
--- malloc.c	Fri Nov 15 14:51:00 1991
***************
*** 120,130 ****
  
  MALLOCPTRTYPE *
  malloc(nbytes)
! 	register unsigned nbytes;
  {
    	register union overhead *p;
    	register int bucket = 0;
!   	register unsigned shiftr;
  
  #ifdef safemalloc
  #ifdef DEBUGGING
--- 120,130 ----
  
  MALLOCPTRTYPE *
  malloc(nbytes)
! 	register unsigned long nbytes;
  {
    	register union overhead *p;
    	register int bucket = 0;
!   	register unsigned long shiftr;
  
  #ifdef safemalloc
  #ifdef DEBUGGING
***************
*** 220,254 ****
    	register union overhead *op;
    	register int rnu;       /* 2^rnu bytes will be requested */
    	register int nblks;     /* become nblks blocks of the desired size */
! 	register int siz;
  
    	if (nextf[bucket])
    		return;
  	/*
  	 * Insure memory is allocated
  	 * on a page boundary.  Should
  	 * make getpageize call?
  	 */
!   	op = (union overhead *)sbrk(0);
  #ifndef I286
!   	if ((int)op & 0x3ff)
!   		(void)sbrk(1024 - ((int)op & 0x3ff));
  #else
  	/* The sbrk(0) call on the I286 always returns the next segment */
  #endif
  
! #ifndef I286
  	/* take 2k unless the block is bigger than that */
    	rnu = (bucket <= 8) ? 11 : bucket + 3;
  #else
  	/* take 16k unless the block is bigger than that 
! 	   (80286s like large segments!)		*/
    	rnu = (bucket <= 11) ? 14 : bucket + 3;
  #endif
    	nblks = 1 << (rnu - (bucket + 3));  /* how many blocks to get */
    	if (rnu < bucket)
  		rnu = bucket;
! 	op = (union overhead *)sbrk(1 << rnu);
  	/* no more room! */
    	if ((int)op == -1)
    		return;
--- 220,256 ----
    	register union overhead *op;
    	register int rnu;       /* 2^rnu bytes will be requested */
    	register int nblks;     /* become nblks blocks of the desired size */
! 	register long siz;
  
    	if (nextf[bucket])
    		return;
+ #ifndef atarist /* on the atari we dont have to worry about this */
  	/*
  	 * Insure memory is allocated
  	 * on a page boundary.  Should
  	 * make getpageize call?
  	 */
!   	op = (union overhead *)sbrk(0L);
  #ifndef I286
!   	if ((unsigned int)op & 0x3ff)
!   		(void)sbrk((long)(1024L - ((int)op & 0x3ff)));
  #else
  	/* The sbrk(0) call on the I286 always returns the next segment */
  #endif
+ #endif /* atarist */
  
! #if !(defined(I286) || defined(atarist))
  	/* take 2k unless the block is bigger than that */
    	rnu = (bucket <= 8) ? 11 : bucket + 3;
  #else
  	/* take 16k unless the block is bigger than that 
! 	   (80286s like large segments!), probably good on the atari too */
    	rnu = (bucket <= 11) ? 14 : bucket + 3;
  #endif
    	nblks = 1 << (rnu - (bucket + 3));  /* how many blocks to get */
    	if (rnu < bucket)
  		rnu = bucket;
! 	op = (union overhead *)sbrk(1L << rnu);
  	/* no more room! */
    	if ((int)op == -1)
    		return;
***************
*** 280,286 ****
  free(mp)
  	MALLOCPTRTYPE *mp;
  {   
!   	register int size;
  	register union overhead *op;
  	char *cp = (char*)mp;
  
--- 282,288 ----
  free(mp)
  	MALLOCPTRTYPE *mp;
  {   
!   	register long size;
  	register union overhead *op;
  	char *cp = (char*)mp;
  
***************
*** 339,345 ****
  MALLOCPTRTYPE *
  realloc(mp, nbytes)
  	MALLOCPTRTYPE *mp; 
! 	unsigned nbytes;
  {   
    	register u_int onb;
  	union overhead *op;
--- 341,347 ----
  MALLOCPTRTYPE *
  realloc(mp, nbytes)
  	MALLOCPTRTYPE *mp; 
! 	unsigned long nbytes;
  {   
    	register u_int onb;
  	union overhead *op;
*** ../perl.c	Fri Nov 15 10:14:00 1991
--- perl.c	Fri Nov 15 14:51:01 1991
***************
*** 239,245 ****
  	scriptname = e_tmpname;
      }
  
! #ifdef MSDOS
  #define PERLLIB_SEP ';'
  #else
  #define PERLLIB_SEP ':'
--- 239,245 ----
  	scriptname = e_tmpname;
      }
  
! #ifdef MSDOS_OR_ATARI
  #define PERLLIB_SEP ';'
  #else
  #define PERLLIB_SEP ':'
***************
*** 296,314 ****
  
  	bufend = s + strlen(s);
  	while (*s) {
! #ifndef MSDOS
  	    s = cpytill(tokenbuf,s,bufend,':',&len);
  #else
  	    for (len = 0; *s && *s != ';'; tokenbuf[len++] = *s++);
  	    tokenbuf[len] = '\0';
  #endif
  	    if (*s)
  		s++;
! #ifndef MSDOS
  	    if (len && tokenbuf[len-1] != '/')
  #else
  	    if (len && tokenbuf[len-1] != '\\')
  #endif
  		(void)strcat(tokenbuf+len,"/");
  	    (void)strcat(tokenbuf+len,scriptname);
  #ifdef DEBUGGING
--- 296,323 ----
  
  	bufend = s + strlen(s);
  	while (*s) {
! #ifndef MSDOS_OR_ATARI
  	    s = cpytill(tokenbuf,s,bufend,':',&len);
  #else
+ #ifdef atarist
+ 	    for (len = 0; *s && *s != ',' && *s != ';'; tokenbuf[len++] = *s++);
+ 	    tokenbuf[len] = '\0';
+ #else
  	    for (len = 0; *s && *s != ';'; tokenbuf[len++] = *s++);
  	    tokenbuf[len] = '\0';
  #endif
+ #endif
  	    if (*s)
  		s++;
! #ifndef MSDOS_OR_ATARI
  	    if (len && tokenbuf[len-1] != '/')
  #else
+ #ifdef atarist
+ 	    if (len && ((tokenbuf[len-1] != '\\') || (tokenbuf[len-1] != '/')))
+ #else
  	    if (len && tokenbuf[len-1] != '\\')
  #endif
+ #endif
  		(void)strcat(tokenbuf+len,"/");
  	    (void)strcat(tokenbuf+len,scriptname);
  #ifdef DEBUGGING
***************
*** 361,367 ****
   -e '/^#[ 	]*endif/b' \
   -e 's/^[ 	]*#.*//' \
   %s | %s -C %s %s",
! #ifdef MSDOS
  	  "",
  #else
  	  "/bin/",
--- 370,376 ----
   -e '/^#[ 	]*endif/b' \
   -e 's/^[ 	]*#.*//' \
   %s | %s -C %s %s",
! #ifdef MSDOS_OR_ATARI
  	  "",
  #else
  	  "/bin/",
***************
*** 1305,1310 ****
--- 1314,1322 ----
          stdout);
  #endif
  #endif
+ #ifdef atarist
+         fputs("atariST series port, ++jrb  bammi@cadence.com\n", stdout);
+ #endif
  	fputs("\n\
  Perl may be copied only under the terms of either the Artistic License or the\n\
  GNU General Public License, which may be found in the Perl 4.0 source kit.\n",stdout);
***************
*** 1346,1352 ****
  	fprintf(stderr, "unexec of %s into %s failed!\n", perlpath, dumpname);
      exit(status);
  #else
! #ifdef MSDOS
      abort();	/* nothing else to do */
  #else /* ! MSDOS */
  #   ifndef SIGABRT
--- 1358,1364 ----
  	fprintf(stderr, "unexec of %s into %s failed!\n", perlpath, dumpname);
      exit(status);
  #else
! #ifdef MSDOS_OR_ATARI
      abort();	/* nothing else to do */
  #else /* ! MSDOS */
  #   ifndef SIGABRT
*** ../perl.h	Fri Nov 15 11:41:42 1991
--- perl.h	Fri Nov 15 14:51:02 1991
***************
*** 53,59 ****
  char Error[1];
  #endif
  
! #ifdef MSDOS
  /* This stuff now in the MS-DOS config.h file. */
  #else /* !MSDOS */
  
--- 53,64 ----
  char Error[1];
  #endif
  
! /* define this once if either system, instead of cluttering up the src */
! #if defined(MSDOS) || defined(atarist)
! #define MSDOS_OR_ATARI 1
! #endif
! 
! #ifdef MSDOS_OR_ATARI
  /* This stuff now in the MS-DOS config.h file. */
  #else /* !MSDOS */
  
***************
*** 457,463 ****
--- 462,472 ----
  #   endif
  #endif
  
+ #if STANDARD_C
+ typedef size_t STRLEN;
+ #else
  typedef unsigned int STRLEN;
+ #endif
  
  typedef struct arg ARG;
  typedef struct cmd CMD;
***************
*** 553,559 ****
  
  #define GROWSTR(pp,lp,len) if (*(lp) < (len)) growstr(pp,lp,len)
  
! #ifndef MSDOS
  #define STR_GROW(str,len) if ((str)->str_len < (len)) str_grow(str,len)
  #define Str_Grow str_grow
  #else
--- 562,568 ----
  
  #define GROWSTR(pp,lp,len) if (*(lp) < (len)) growstr(pp,lp,len)
  
! #ifndef MSDOS_OR_ATARI
  #define STR_GROW(str,len) if ((str)->str_len < (len)) str_grow(str,len)
  #define Str_Grow str_grow
  #else
***************
*** 561,567 ****
  #define STR_GROW(str,len) if ((str)->str_len < (unsigned long)len) \
  		str_grow(str,(unsigned long)len)
  #define Str_Grow(str,len) str_grow(str,(unsigned long)(len))
! #endif /* MSDOS */
  
  #ifndef BYTEORDER
  #define BYTEORDER 0x1234
--- 570,576 ----
  #define STR_GROW(str,len) if ((str)->str_len < (unsigned long)len) \
  		str_grow(str,(unsigned long)len)
  #define Str_Grow(str,len) str_grow(str,(unsigned long)(len))
! #endif /* MSDOS_OR_ATARI */
  
  #ifndef BYTEORDER
  #define BYTEORDER 0x1234
***************
*** 828,834 ****
  EXT bool tainted INIT(FALSE);		/* using variables controlled by $< */
  #endif
  
! #ifndef MSDOS
  #define TMPPATH "/tmp/perl-eXXXXXX"
  #else
  #define TMPPATH "plXXXXXX"
--- 837,843 ----
  EXT bool tainted INIT(FALSE);		/* using variables controlled by $< */
  #endif
  
! #ifndef MSDOS_OR_ATARI
  #define TMPPATH "/tmp/perl-eXXXXXX"
  #else
  #define TMPPATH "plXXXXXX"
*** ../regcomp.c	Mon Nov 11 10:45:28 1991
--- regcomp.c	Fri Nov 15 14:51:03 1991
***************
*** 86,92 ****
--- 86,96 ----
  #define	ISMULT1(c)	((c) == '*' || (c) == '+' || (c) == '?')
  #define	ISMULT2(s)	((*s) == '*' || (*s) == '+' || (*s) == '?' || \
  	((*s) == '{' && regcurly(s)))
+ #ifdef atarist
+ #define	PERL_META	"^$.[()|?+*\\"
+ #else
  #define	META	"^$.[()|?+*\\"
+ #endif
  
  #ifdef SPSTART
  #undef SPSTART		/* dratted cpp namespace... */
*** ../str.c	Mon Nov 11 10:40:46 1991
--- str.c	Fri Nov 15 14:51:04 1991
***************
*** 81,87 ****
  char *
  str_grow(str,newlen)
  register STR *str;
! #ifndef MSDOS
  register int newlen;
  #else
  unsigned long newlen;
--- 81,87 ----
  char *
  str_grow(str,newlen)
  register STR *str;
! #ifndef MSDOS_OR_ATARI
  register int newlen;
  #else
  unsigned long newlen;
*** ../toke.c	Fri Nov 15 10:14:26 1991
--- toke.c	Fri Nov 15 14:51:05 1991
***************
*** 63,69 ****
--- 63,73 ----
  #endif
  #define CLINE (cmdline = (curcmd->c_line < cmdline ? curcmd->c_line : cmdline))
  
+ #ifdef atarist
+ #define PERL_META(c) ((c) | 128)
+ #else
  #define META(c) ((c) | 128)
+ #endif
  
  #define RETURN(retval) return (bufptr = s,(int)retval)
  #define OPERATOR(retval) return (expectterm = TRUE,bufptr = s,(int)retval)
***************
*** 102,110 ****
--- 106,120 ----
  /* This does similarly for list operators, merely by pretending that the
   * paren came before the listop rather than after.
   */
+ #ifdef atarist
+ #define LOP(f) return(CLINE, *s == '(' || (s = skipspace(s), *s == '(') ? \
+ 	(*s = (char) PERL_META('('), bufptr = oldbufptr, '(') : \
+ 	(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP))
+ #else
  #define LOP(f) return(CLINE, *s == '(' || (s = skipspace(s), *s == '(') ? \
  	(*s = (char) META('('), bufptr = oldbufptr, '(') : \
  	(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP))
+ #endif
  /* grandfather return to old style */
  #define OLDLOP(f) return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP)
  
***************
*** 150,156 ****
--- 160,170 ----
      if (*s != '(')
  	s = skipspace(s);
      if (*s == '(') {
+ #ifdef atarist
+ 	*s = PERL_META('(');
+ #else
  	*s = META('(');
+ #endif
  	bufptr = oldbufptr;
  	return '(';
      }
***************
*** 999,1005 ****
--- 1013,1023 ----
  	if (strEQ(d,"package"))
  	    OPERATOR(PACKAGE);
  	if (strEQ(d,"pipe"))
+ #ifdef atarist
+ 	    FOP22(PERL_O_PIPE);
+ #else
  	    FOP22(O_PIPE);
+ #endif
  	break;
      case 'q': case 'Q':
  	SNARFWORD;
*** ../util.c	Fri Nov 15 10:14:27 1991
--- util.c	Fri Nov 15 14:51:06 1991
***************
*** 1372,1378 ****
  VTOH(vtohl,long)
  #endif
  
! #ifndef MSDOS
  FILE *
  mypopen(cmd,mode)
  char	*cmd;
--- 1372,1378 ----
  VTOH(vtohl,long)
  #endif
  
! #ifndef MSDOS_OR_ATARI
  FILE *
  mypopen(cmd,mode)
  char	*cmd;
***************
*** 1446,1453 ****
      forkprocess = pid;
      return fdopen(p[this], mode);
  }
! #endif /* !MSDOS */
  
  #ifdef NOTDEF
  dumpfds(s)
  char *s;
--- 1446,1465 ----
      forkprocess = pid;
      return fdopen(p[this], mode);
  }
! #else
! #ifdef atarist
! FILE *popen();
! FILE *
! mypopen(cmd,mode)
! char	*cmd;
! char	*mode;
! {
!     return popen(cmd, mode);
! }
! #endif
  
+ #endif /* !MSDOS_OR_ATARI */
+ 
  #ifdef NOTDEF
  dumpfds(s)
  char *s;
***************
*** 1488,1494 ****
  }
  #endif
  
! #ifndef MSDOS
  int
  mypclose(ptr)
  FILE *ptr;
--- 1500,1506 ----
  }
  #endif
  
! #ifndef MSDOS_OR_ATARI
  int
  mypclose(ptr)
  FILE *ptr;
***************
*** 1587,1593 ****
  #endif
      return;
  }
! #endif /* !MSDOS */
  
  #ifndef HAS_MEMCMP
  memcmp(s1,s2,len)
--- 1599,1615 ----
  #endif
      return;
  }
! #else
! #ifdef atarist
! int pclose();
! int
! mypclose(ptr)
! FILE *ptr;
! {
!     return pclose(ptr);
! }
! #endif
! #endif /* !MSDOS_OR_ATARI */
  
  #ifndef HAS_MEMCMP
  memcmp(s1,s2,len)
