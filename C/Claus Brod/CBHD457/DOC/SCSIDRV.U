############################################################
# @(#) Die Anleitung zum SCSI-Treiber
# @(#) Copyright (c) 1995 by
# @(#) Steffen Engel
############################################################

#Kopf
!tex %format latexg           %fÅr's Strunk-TeX
!tex %macropackage=lplaing    %fÅr's Lindner-TeX
!tex \documentstyle[a4,11pt,german]{article}
!tex \pagestyle{headings}

!tex \family{cmss} \selectfont

!tex \input graphic     % fÅr die Lindner-Grafikeinbindung

!stg @subject "Dokumentation/Utilities"
!stg @options +zz

!author Steffen Engel
!street Krîppelstr. 2
!town D-38100 Braunschweig
!email MausNet: Steffen Engel @ SZ2

!title Systemglobaler SCSI-Treiber
!program SCSIDRV
!version Release 1.00
#!date $Date: 1995/11/23 10:37:26 $

#!rtf_no_quotes
!rtf_propfont Dutch
!rtf_monofont Typewriter

!tex_lindner
!tex_dpi 100

#!asc_no_effects

# Die Silbenregeln
!include hyphens.ui

!begin_document

!maketitle
!tableofcontents


#****************************************************************************
#
# $Source: f:\kleister.ii\cbhd\doc\RCS\scsidrv.u,v $
#
# $Revision: 1.4 $
#
# $Author: S_Engel $
#
# $Date: 1995/11/23 10:37:26 $
#
# $State: Exp $
#
#****************************************************************************
# History:
#
# Revision 1.3  1995/09/29  08:06:18  S_Engel
# Verhalten unter virtuellem RAM dokumentiert.
#
# Revision 1.2  1995/02/10  00:52:50  S_Engel
# Handlekonzept eingefÅhrt, Doku erweitert
#
# Revision 1.1  1995/02/05  10:40:00  S_Engel
# Initial revision
#
#****************************************************************************


!node Vorwort

  Diese Dokumentation ist nicht kurz, sie ist aber wichtig.
  Ich empfehle, den Text auszudrucken, da er dann wesentlich Åbersichtlicher 
  ist.

  Wesentlich ist der Teil zum Absetzen von SCSI-Kommandos und zur Abfrage der 
  vorhandenen Busse.
  Der Teil zur Installation von Targetroutinen ist nur fÅr spezielle FÑlle 
  nîtig. Die dazugehîrigen Funktionen mÅssen vom Treiber auch nicht 
  bereitgestellt werden.
  Die Existenz der Strukturen und des Treibers lassen also keine RÅckschlÅsse 
  auf die Mîglichkeit zur Installation von Target-Routinen oder Disconnect zu.

  Wer einen Treiber benutzen oder selbst schreiben mîchte, hier sind besonders 
  die Autoren von Festplattentreibern gefragt, sollte als erstes die Funktionen 
  zur Benutzung und Abfrage der SCSI-Schnittstellen beachten.
  Eine eventuelle UnterstÅtzung der Target-Routinen kann spÑter folgen.

  Als Beispiele kann man sich die beiligenden Programme und Quelltexte ansehen.

!node Einleitung

  FÅr den Atari fehlen seit jeher systemglobale SCSI-Routinen.
  Dummerweise muû daher jeder, der SCSI-GerÑte programmieren will, eigene 
  SCSI-Routinen schreiben, was mit jedem neuen Rechner von vorne los geht.

  Desweiteren ist es sinnvoll, mit den echten SCSI-Ports (wie bei TT, Falcon 
  oder der Medusa) auch als Target auftreten zu kînnen.

  Dazu kommen alternative SCSI-Ports, wie sie durch Zusatzkarten in ST, TT oder 
  der Medusa eingesetzt werden.

  Besonders wichtig sind Emulatoren (zB MagiCMac, STonX) oder alternative
  Rechner (Clones), an deren SCSI-Ports man ja nicht herankommt, wenn man die 
  Hardware nicht kennt.

  Daher dieser Entwurf zur Installation eines globalen SCSI-Handlers.
  Potentiell kann der Handler bereits im Betriebssystem installiert werden, 
  womit Plattentreiber auch auf die alternativen SCSI-Ports zugreifen kînnen, 
  ohne Kenntnis von der Implementierung der Hardware zu haben.

  Daraus ergibt sich die folgende Vorgehensweise fÅr alle SCSI nutzenden 
  Programme:

  !begin_itemize
    !item Bei Existenz des SCSI-Cookies sollen die darin zur VerfÅgung 
        gestellten Funktionen verwendet werden.
    !item Existiert der Cookie nicht, sollten, soweit vorhanden, eigene Routinen 
        verwendet werden.

        Bei Programmen, die nur auf den hier verwendeten Routinen aufsetzen und 
        keine eigenen Routinen on board haben, muû dementsprechend mit einer 
        Fehlermeldung abgebrochen werden.
  !end_itemize

  Auch Plattentreiber sollten dies so machen, denn es kînnen SCSI-Treiber 
  rersetfest oder im ROM eingebunden werden, die dann vom Plattentreiber benutzt 
  werden sollten.

  Sollte der Cookie nicht installiert sein, so ist es sinnvoll, wenn 
  Plattentreiber diesen installieren, um ihre eigenen Routinen global zur 
  VerfÅgung zu stellen.

  ErwÅnschter Leistungsumfang des SCSI-Treibers:
  !begin_itemize
    !item FÑhigkeit zu krummen Transferzahlen auf ACSI (Stichwort DMA-fifo-Loch) 
    !item Class 1 Komandos auf ACSI (per ALIA-Technik, Linked-Cmd oder ICD-Technik)
    !item FRB-Transfers (ACSI) sind Aufgabe des Treibers
  !end_itemize

!subnode Strukturen


!begin_verbatim
  XBRA      : SCSI

  Vektoren  : Falcon : MFP-Interrupt 7, Vektor 7 (normal VR $40 -> $11C)
              TT     : TT-MFP-Interrupt 15, Vektor 7 (normal VR $50 -> $17C)
!end_verbatim


  Aufbau des SCSI-Cookies:

  Name des Cookie: SCSI
  Wert des Cookie: Zeiger auf die Struktur tScsiCall
                   (Typen siehe SCSIDEFS.H, SCSIDEFS.D)

!subnode Nomenklatur


!begin_xlist [BOOLEAN:  ]
  !item [BYTE:] 8 Bit (unsigned char)
  !item [UWORD:] 16 Bit ganzzahlig positiv (unsigned word)
  !item [ULONG:] 32 Bit ganzzahlig positiv (unsigned long)
  !item [WORD:] 16 Bit ganzzahlig (word)
  !item [LONG:] 32 Bit ganzzahlig (long)
  !item [BOOLEAN:]
              WORD
              TRUE  : 1
              FALSE : 0
!end_xlist

  benutzte Register in den Routinen:
    D0-D2, A0-A1  (PureC-Konvention)

  ParameterÅbergabe:
    auf dem Stack (cdecl) ( NEIN!! nichts anderes!!! )

!node Funktionen

!subtoc [stg,html,pch]

!subnode In

Sendet ein SCSI-Kommando und empfÑngt die kommenden Daten.

Als Parameter wird ein Zeiger auf eine SCSI-Kommandostruktur Åbergeben, in der 
alle nîtigen Informationen Åber den gewÅnschten Zugriff enthalten sind.

!begin_verbatim
  LONG  cdecl (*In)           (tpSCSICmd  Parms);

  typedef struct
  {
    tHandle Handle;                     /* Handle fÅr Bus und GerÑt             */
    BYTE  *Cmd;                         /* Zeiger auf CmdBlock                  */
    UWORD CmdLen;                       /* LÑnge des Cmd-Block 
    void  *Buffer;                      /* Datenpuffer                          */
    ULONG TransferLen;                  /* öbertragungslÑnge                    */
    BYTE  *SenseBuffer;                 /* Puffer fÅr ReqSense (18 Bytes)       */
    ULONG Timeout;                      /* Timeout in 1/200 sec                 */
    UWORD Flags;                        /* Bitvektor fÅr AblaufwÅnsche          */
      #define Disconnect 0x10           /* versuche disconnect                  */

  }tSCSICmd;
  typedef tSCSICmd *tpSCSICmd;
!end_verbatim

!begin_xlist [SenseBuffer: ]
 !item [Handle:]
        Das Handle des angesprochenen GerÑtes
 !item [Cmd:]
        Zeiger auf den zu Åbertragenden Kommandoblock.
 !item [CmdLen:]
        LÑnge des Kommandoblockes
(!N)Die KommandolÑnge ist eigentlich fÅr einen SCSI-Treiber nicht 
nîtig. Da ACSI jedoch nicht targetgesteuert ablaufen kann, einige 
Plattentreiber dieses Feature auch auf den echten SCSI-Ports nicht verwenden 
und zukÅnftige GerÑtetreiber fÅr Clones (Mac/Gemulator/STOnX) evtl. diesen 
Wert ebenfalls benîtigen, muû er immer angegeben werden.(!n)
 !item [Buffer:]
        Zeiger auf den Transferpuffer
 !item [TransferLen:]
        Anzahl der zu Åbertragenden Bytes.
 !item [SenseBuffer:]
        Puffer fÅr Request Sense Daten.

        Wird automatisch gefÅllt, wenn das GerÑt Check Condition
        meldet.
 !item [Timeout:]
        Maximale Wartezeit fÅr die AusfÅhrung des Kommandos in 1/200 sec.
 !item [Flags:]
        Bitvektor mit Zusatzinformationen/aufforderungen
!end_xlist


Bemerkung: die LÑnge des Kommandoblockes ist eigentlich nur fÅr ACSI nîtig, 
oder fÅr Treiber, die nicht vom Target gesteuert werden. Daher muû sie immer 
korrekt Åbergeben werden
(!N) Laut SCSI-Norm steuert das angesprochene Target die Bus-Phasen. Das heiût, 
das Target fordert solange Kommando-Bytes an, bis es die Anzahl der zu dem 
Kommando gehîrenden Bytes erhalten hat.

Daher ist es fÅr die SCSI-Routinen nicht nîtig, zu wissen, wie lang das 
Kommando ist.

Bei ACSI kann die Busphase nicht abgefragt werden, daher muû die 
KommandolÑnge immer genannt werden.
(!n)

Ergebnis:
!begin_verbatim
  NOSCSIERROR      0L /* Kein Fehler                                   */
  SELECTERROR     -1L /* Fehler beim Selektieren                       */
  STATUSERROR     -2L /* Default-Fehler                                */
  PHASEERROR      -3L /* ungÅltige Phase                               */
  BSYERROR        -4L /* BSY verloren                                  */
  BUSERROR        -5L /* Busfehler bei DMA-öbertragung                 */
  TRANSERROR      -6L /* Fehler beim DMA-Transfer (nichts Åbertragen)  */
  FREEERROR       -7L /* Bus wird nicht mehr freigegeben               */
  TIMEOUTERROR    -8L /* Timeout                                       */
  DATATOOLONG     -9L /* Daten fÅr ACSI-Softtransfer zu lang           */
  LINKERROR      -10L /* Fehler beim Senden des Linked-Command (ACSI)  */
  TIMEOUTARBIT   -11L /* Timeout bei der Arbitrierung                  */
  PENDINGERROR   -12L /* auf diesem handle ist ein Fehler vermerkt     */
  PARITIYERROR   -13L /* Transfer verursachte Parity-Fehler            */

  Wert grîûer Null: Statusbyte des SCSI-GerÑtes, bei Status 2 (Check Condition) 
  befinden sich die RequestSense-Daten im Sensebuffer.

!end_verbatim

BEISPIEL:

Aufruf von Inquiry

!begin_verbatim
WORD Inquiry(tHandle handle, char *inqdata)
{
  tScsiCmd ScsiCmd;
  BYTE CmdBlock[6]={0x12,0,0,0,36,0};   /* Kommand 18, 36 Bytes */
  BYTE ReqBuff[18];

  ScsiCmd.Handle      = handle;       /* GerÑtehandle */
  ScsiCmd.Cmd         = CmdBlock;     /* das Kommando */
  ScsiCmd.CmdLen      = 6;            /* 6-Byte-Kommando */
  ScsiCmd.Buffer      = inqdata;      /* Datenpuffer */
  ScsiCmd.TransLen    = 36;           /* 36 Bytes erwartet */
  ScsiCmd.SenseBuffer = ReqBuff;      /* bei Fehlern dorthin */
  ScsiCmd.Timeout     = 1000;         /* 5 sec */
  ScsiCmd.Flags       = 0;            /* keine Besonderheiten */
 
  return (ScsiCall->In((tpScsiCmd)&ScsiCmd));
}
!end_verbatim

ACHTUNG:
  Bei virtuellem RAM ist selbst auf den Transfer Åber ST-RAM zu achten (s. 
  Abschnitt VIRTUELLES RAM)

!subnode Out

Sendet ein SCSI-Kommando und sendet die Daten.
Parameter wie bei In.

!begin_verbatim
  LONG  cdecl (*Out)           (tpSCSICmd  Parms);

  typedef struct
  {
    tHandle Handle;                     /* Handle fÅr Bus und GerÑt             */
    BYTE  *Cmd;                         /* Zeiger auf CmdBlock                  */
    UWORD CmdLen;                       /* LÑnge des Cmd-Block (fÅr ACSI nîtig) */
    void  *Buffer;                      /* Datenpuffer                          */
    ULONG TransferLen;                  /* öbertragungslÑnge                    */
    BYTE  *SenseBuffer;                 /* Puffer fÅr ReqSense (18 Bytes)       */
    ULONG Timeout;                      /* Timeout in 1/200 sec                 */
    UWORD Flags;                        /* Bitvektor fÅr AblaufwÅnsche          */
      #define Disconnect 0x10           /* versuche disconnect                  */

  }tSCSICmd;
  typedef tSCSICmd *tpSCSICmd;
!end_verbatim


ACHTUNG:
!begin_verbatim
Bei virtuellem RAM ist selbst auf den Transfer Åber ST-RAM zu achten (s. 
Abschnitt VIRTUELLES RAM)
!end_verbatim

!subnode InquireSCSI

!begin_verbatim
  LONG  cdecl (*InquireSCSI)  (WORD       what,
                               tBusInfo  *Info);
    #define cInqFirst  0
    #define cInqNext   1


  typedef struct
  {
    tPrivate Private;
     /* fÅr den Treiber */
    char  BusName[20];
     /* zB 'SCSI', 'ACSI', 'PAK-SCSI' */
    UWORD BusNo;
     /* Nummer, unter der der Bus anzusprechen ist */
    UWORD Features;
        #define cArbit     0x01    /* auf dem Bus wird arbitriert                          */
        #define cAllCmds   0x02    /* hier kînnen ale SCSI-Cmds abgesetzt werden           */
        #define cTargCtrl  0x04    /* Das Target steuert den Ablauf (so soll's sein!)      */
        #define cTarget    0x08    /* auf diesem Bus kann man sich als Target installieren */
        #define cCanDisconnect 0x10 /* Disconnect ist mîglich                             */
        #define cScatterGather 0x20 /* scatter gather bei virtuellem RAM mîglich */
    /* bis zu 16 Features, die der Bus kann, zB Arbit,
     * Full-SCSI (alle SCSI-Cmds im Gegensatz zu ACSI)
     * Target oder Initiator gesteuert
     * kann alle Adressen bedienen (Stichwort: ACSI-Port im TT!)
     * Ein SCSI-Handle ist auch ein Zeiger auf eine Kopie dieser Information!
     */
    ULONG MaxLen;
    /* maximale TransferlÑnge auf diesem Bus (in Bytes)
     * entspricht zB bei ACSI der Grîûe des FRB
     */
  }tBusInfo;
!end_verbatim


Nach vorhandenen Bussen suchen.
Man ruft, Ñhnlich zu Fsfirst/Fsnext, zunÑchst mit InqFirst in what auf, 
danach mit InqNext, bis ein negativer Wert auftritt.
Die Reihenfolge der Meldungen (erst Bus 0, dann 1 dann 2) ist _nicht_ 
gewÑhrleistet, es kann auch sein, daû erst Bus 3, dann Bus 2, dann 0, dann 1 
gemeldet wird.

Es sind maximal 32 Busse mîglich.

Man erhÑlt Informationen Åber den Bus in der Info-Struktur.

Ergebnis:

!begin_verbatim
  = 0   : Ok
  < 0 : Kein weiteres GerÑt
!end_verbatim

ACHTUNG: es muû natÅrlich immer der gleiche Record fÅr Info genommen werden, 
da darin vom Treiber protokolliert wird, welche bereits gemeldet wurden.

Aufgabe: FÅr Konfigurationsdialoge oder auch selbsttÑtige Konfiguration nach 
den vorhandenen Bussen suchen.

Dabei sind vorbelegt die Bus-Nummern 0 (ACSI) und 1 (Standard-SCSI: Falcon, 
TT, Medusa, MagicMac...)

Es sind dennoch keine Annahmen Åber die Anzahl der GerÑte oder die maximale 
GerÑte-Id zulÑssig. Die vorhandenen GerÑte mÅssen mit InquireBus erfragt 
werden.

Beispiel: siehe SRCHDRV.C

!subnode InquireBus

!begin_verbatim
  LONG  cdecl (*InquireBus)   (WORD       what,
                               WORD       BusNo,
                               tDevInfo  *Dev);

  typedef struct
  {
    BYTE Private[32];
    DLONG SCSIId;
  }tDevInfo;

!end_verbatim


Einen Bus nach vorhandenen GerÑten abfragen. Erster Aufruf mit cInqFirst, danach 
mit cInqNext. Liefert 0, bis keine weiteren Ids mehr berichtet werden.

Ergbenis:
!begin_verbatim
  = 0 : Ok
  < 0 : keine weiteren GerÑte
!end_verbatim

Beispiel: siehe SRCHDRV.C

!subnode CheckDev

!begin_verbatim
  LONG  cdecl (*CheckDev)     (WORD         BusNo,
                               const DLONG *SCSIId,
                               char        *Name,
                               UWORD       *Features);
!end_verbatim


Wie InquireSCSI, nur daû explizit nach einem bestimmten Bus und einer 
bestimmten SCSI-ID gefragt wird.

Als Antwort erhÑlt man den Namen des Busses, sowie die Informationen, was mit 
dem genannten GerÑt mîglich ist.

Ergebnis:
!begin_verbatim
  = 0         : Ok
  < 0         : Fehler
   -2 EDRIVNR : Informationen konnten nicht ermittelt werden (zB Kontrolle 
                auf ICD-FÑhigkeit)
  -15 EUNDEV  : Die Busnummer oder die GerÑtenummer wird nicht verwaltet
  -36 EACCDN  : Zugriff nicht mîglich (zB eigene SCSI-Id auf einem 
                arbitrierenden Bus)
!end_verbatim

Dies ist fÅr zwei Dinge sinnvoll:

!begin_itemize
!item Ein Programm lÑdt eine Parameterdatei und kann hiermit kontrollieren ob
  !begin_itemize
    !item der Bus existiert
    !item der Busname verÑndert ist (bei alternativen Bussen kînnen Unterschiede
     vorhanden sein)
    !item das GerÑt ansprechbar ist
  !end_itemize

!item FÅr alternative Hostadapter kontrolliert der Treiber, ob er speziell dieses 
 GerÑt anders ansprechen kann, als auf dem Bus Åblich (zB ICD: voller 
 Kommandosatz auf ACSI auf _diesem_ GerÑt)
!end_itemize

!subnode RescanBus

!begin_verbatim
LONG  cdecl RescanBus  (WORD       BusNo);
!end_verbatim

Der Bus soll vom Treiber erneut auf vorhanden GerÑte kontrolliert werden.

FÅr Applikationen zwei sinnvolle Anwendungen:
!begin_enumerate
!item Tool fÅr Kontrolle auf nachtrÑglich eingeschaltete GerÑte. Beispiel: 
  SCSI.CPX
!item Programm sucht nach einem bestimmten GerÑt und findet es nicht. Einmal 
  RescanBus, danach neue Suche. Beispiel: GEMAR. Wenn kein Streamer gefunden 
  wurde, wird nach einem RescanBus noch mal nach einem Streamer geschaut.
!end_enumerate


!subnode Open

!begin_verbatim
  LONG  cdecl (*Open)         (WORD         BusNo,
                               const DLONG *SCSIId,
                               ULONG       *MaxLen);
!end_verbatim


Ein Handle fÅr ein GerÑt holen.

SCSIId ist die SCSI-Id des GerÑtes, fÅr das das Handle geliefert werden soll.
Die Variable ist 64 Bit groû, um die Vorgaben von SCSI-3 erfÅllen zu kînnen. Bei 
den bisher zur VerfÅgung stehenden Treibern und Bussen werden nur die unteren 8 
Bit (von SCSIId.lo) verwendet. Der Rest muû 0 sein. Es ist nicht zulÑssig, 
irgendwelche anderen Informationen in der SCSI-Id unterzubringen!


Ergebnis
!begin_verbatim
  > 0    : handle (Zeiger auf Featurevektor)
           In MaxLen ist angegeben, welche maximale TransferlÑnge mit einem
           Zugriff Åbertragen werden kann.
  < 0    : Fehler
  ENMHDL : keine Handles mehr frei
  EUNDEV : unbekanntes GerÑt auf diesen Bus/unbekannter Bus
  EACCDN : unerlaubtes GerÑt auf diesem Bus (zB eigene SCSI-Id bei Arbitrierung)
!end_verbatim

!subnode Close

!begin_verbatim
  LONG  cdecl (*Close)        (tHandle    handle);
!end_verbatim


Handle wieder freigeben

Ergebnis:
!begin_verbatim
  = 0 : Ok
  < 0 : Fehler
EINVHDL : ungÅltiges Handle
!end_verbatim

!subnode Error

!begin_verbatim
  LONG  cdecl (*Error)        (tHandle    handle,
                               WORD       rwflag,
                               WORD       ErrNo);
        #define cErrRead   0
        #define cErrWrite  1
          #define cErrMediach  0
          #define cErrReset    1
!end_verbatim


Fehlerstatus auf dem GerÑt abfragen/setzen

Hiermit kann man fragen, welche Fehler auf dem GerÑt in letzter Zeit
aufgetreten sind.
Dies ist nîtig, da evtl. mehrere Programme mit diesem GerÑt arbeiten und 
damit derjenige, der den Status mit Request Sense ausliest, der einzige ist, 
der weiû, was passiert ist.
Daher muû jeder, der Request Sense auswertet, einen entsprechenden Fehler 
melden, damit dieser fÅr alle anderen Prozesse mit einem offenen Hande 
protokolliert wird.

Gemeldet werden muû alles, was einen Wechselstatus des GerÑtes ergibt, also 
Mediach und Reset.
Nur so kann zB der Plattentreiber einen Mediachange mitbekommen, wenn bei 
einem Image-Backup das Medium gewechselt wurde.

rwflag = 0 fragt den Status ab (16 Bit Bitvektor) und lîscht ihn fÅr dieses 
handle. rwflag = 1 setzt das Bit ErrNo bei allen auf dieses GerÑt geîffneten 
handles.

!subnode Install
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode Deinstall
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode GetCmd
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode SendData
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode GetData
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode SendStatus
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode SendMsg
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode GetMsg
    Nur fÅr Targethandling, siehe SCSIDRV2

!subnode ReqData
    Nur fÅr Targethandling, siehe SCSIDRV2

!node Virtuelles RAM

Bei vorhandenem virtuellem RAM ist es dem Treiber leider nicht mîglich, 
selbsttÑtig die physikalische Adresse des zu transferierenden Speichers zu 
ermitteln (die virtuellen Treiber liefern keinerlei solche Information). Eine 
eigenstÑndige Entscheidung des Treibers, wann die Daten durch einen Puffer im 
ST-RAM zu kopieren sind, erscheint auch nicht sinnvoll, da zur Vermeidung von 
Deadlocks fÅr jeden Prozeû ein eigener Puffer eingerichtet werden mÅûte.
Daher mÅssen Programme selbsttÑtig davor sorgen, daû der zu transferierende 
Speicher im ST-RAM liegt, wenn virtuelles RAM vorliegt (siehe auch SCSILIB.H).
Der Transfer fÅr ACSI-Zugriffe Åber den FRB bzw den XFRB stellt dabei kein 
Problem da.

!node Tips

Wenn ein Programm den Treiber benutzt, sollte es unbedingt auf ein GerÑt ein
InquireDev absetzen. Dies ist sinnvoll, wenn der Treiber dadurch feststellen
kann, was fÅr ein Adaptertyp zB auf ACSI liegt.
Meine Routinen checken dabei, ob es sich um einen ALIA handelt, oder auch um
einen ICD-Adapter.
Im Falle eines ICD-Adapters ergibt sich dadurch die Mîglichkeit, daû der
Treiber fÅr Class-1-Kommandos die ICD-Technik benutzt.

!node Treiberinstallation

Dieses Kapitel ist noch nicht fertiggestellt.

Es werden nur wesentliche Stichpunkte genannt, die von Treibern zu beachten 
sind.

Wenn bereits ein Treiber installiert ist:

!begin_itemize
!item
  Treiber dÅrfen bereits existierende Busse nicht ersetzen, es muû also zunÑchst 
  nach Bussen gescannt werden, dann kînnen die eigenen Busse auf freie Bus-Ids 
  gelegt werden.

  Der Cookieinhalt des vorhergehenden Treibers wird dann gemerkt und die eigenen 
  Daten werden in die Struktur des alten Treibers geschrieben, die Daten werden 
  also ersetzt.

  Der Cookiewert (der Zeiger im Cookiejar) darf NICHT ersetzt werden.

!item
  Tabellen und Variablen mÅssen beim Treiberstart initialisiert werden.
  Initialisierte Varibalen (DATA-Segement) sind nicht zulÑssig, da ein resetfest 
  geladener Treiber (Stichwort SCSI.RAM bei MagiC) dann nicht funktionieren 
  kann.


!item die Fehlermeldungen die ein Treiber zu melden hat/melden kann:

  !begin_description
    !item[NOSCSIERROR] Alles klar, kein Fehler
    !item[SELECTERROR] Das GerÑt konnte nicht selektiert werden. Bei SCSI ein 
      Timeout auf /SEL (/BSY kam nicht)
    !item[STATUSERROR] Defaultfehler, wenn gar nix geht
    !item[PHASEERROR] Eine ungÅltige Phase wurde erkannt. Diese Fehlermeldung 
      ist fÅr Busphasen vorgesehen, die nicht der SCSI-Norm entsprechen. Dies sind 
      die Phasen mit /C/D = 0, /MSG = 1 und /I/O = 0 oder = 1
    !item[BSYERROR]
      Das Target hat unkontrolliert den Bus freigegeben (busy loss)
    !item[BUSERROR] Busfehler bei der öbertragung (zB die Fehlermeldung des 
      TT-DMA-Chip)
    !item[TRANSERROR] Beim DMA-Transfer keine Daten Åbertragen. Nur verwenden, 
      wenn Datenphase eingeleitet, aber dann nichts Åbertragen wurde, also als 
      GerÑtefehler, nicht als SCSI-Fehler zu verstehen.
    !item[FREEERROR] Wenn der Bus nach Abschluû (Msg Complete) nicht freigegeben 
      werden konnte (Busy bleibt stehen)
    !item[TIMEOUTERROR] Ein Timeout bei der Verbindung (nicht Selektion, dort 
      SELECTERROR verwenden)
    !item[DATATOOLONG] So viele Daten kînnen nicht mit einem Transfer Åbertragen 
      werden (zB FRB-Grîûe).
    !item[LINKERROR] Bei Linked-Cmd trat Fehler auf (spezielle Meldung fÅr ACSI 
      mit Linked Cmds
    !item[TIMEOUTARBIT] Wenn innerhalb einer vom Treiber vorzusehenden Zeit 
        keine Arbitrierung um den Bus mit Erfolg beendet werden konnte.
    !item[PENDINGERROR] Soll gemeldet werden, wenn auf einem handle noch ein 
        Fehler gemerkt und nicht abgeholt ist. Der Klient muû mit 
        Error(cErrRead) den Fehler abholen, dann wird der Fehler auf diesem 
        Handle gelîscht.
    !item[PARITYERROR] es ist ein Parityfehler aufgetreten
  !end_description


!end_itemize
