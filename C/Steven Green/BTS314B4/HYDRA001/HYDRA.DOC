









    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    Filename......: HYDRA.DOC; The HYDRA file transfer protocol
                    (also published as EMSC-002).
    Rev...........: 001
    Date..........: Dec 1, 1992
    Subject.......: HYDRA file transfer protocol definitions
    Authors.......: Joaquim H. Homrighausen and Arjen G. Lentz

    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     Copyright 1991-1993 Joaquim H. Homrighausen. All rights reserved.
     Copyright 1991-1993 Lentz Software Development. All rights reserved.
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


    Restrictions
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    You are granted a license to implement the HYDRA file transfer
    protocol, HYDRA hereafter, in your own programs and/or use the sample
    source code and adapt these to your particular situation and needs;
    subject to the following conditions:

    o You must refer to it as the HYDRA file transfer protocol, and you
      must give credit to the authors of HYDRA in any information screens
      or literature pertaining to your programs that contains other such
      information (credits, your own copyrights, etc.).

    o HYDRA will always remain backwards compatible with previous
      revisions. HYDRA allows for expansion of its features without
      interfering with previous revisions. It is, however, important that
      different people do not expand the protocol in different directions.
      We therefore ask you to contact us if you have any needs/ideas
      regarding HYDRA, so development can be synchronized and beneficial
      to all.

    o If your implementation cannot converse with past or future revisions
      as supplied by us, then you must refer to it as "HYDRA derived", or
      as "a variation of HYDRA", or words to that effect.

    Permission is hereby granted to the FTSC (FidoNet Technical Standards
    Committee) and other technical organisations to republish this
    document in its entirety. Librarians may change the title page and
    page headers to match their library format as long as all copyrights
    and body text remain unaltered. The original document name and source
    must be mentioned in any republished versions of this document.

    No organization, company, person, or other being may impose any fees
    for any reason for providing this document. This document may not be
    sold or otherwise transferred for personal or company gain under any
    circumstances.


    Disclaimer
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    This information is provided "as is" and comes with no warranties of
    any kind, either expressed or implied. There is no support available
    for this package. It's intended to be used by programmers and
    developers.

    In no event shall the authors be liable to you or anyone else for any
    damages, including any lost profits, lost savings or other incidental
    or consequential damages arising out of the use or inability to use
    this information.


    Revision timestamps
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    001                           0x2b1aab00                 Dec 01, 1992


    Introduction
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    This document will not attempt to convince the reader that HYDRA is
    of value to him/her or that it is better than other file transfer
    protocols, it will simply describe the protocol. Just to get it out
    of the way, HYDRA is not the ultimate file transfer protocol.

    The authors do, however, feel that it offers an significant
    improvement over those file transfer protocols available today. HYDRA
    is a bi-directional protocol with the ability to receive and send
    files simultaneously. There are other bi-directional file transfer
    protocols, but to the authors' knowledge no public specifications
    exist.

    HYDRA owes much to Zmodem and its designer, Chuck Forsberg as well as
    to Janus, designed by Rick Huebner. We would like to think of HYDRA
    as a combination of both with a few extra options installed.

    The basic concept of a bi-directional file transfer protocol is
    simple. Both data channels are utilized to transmit and receive files
    simultaneously. I.e. two 100 kb files can be exchanged between two
    parties in the time it takes a fully streaming uni-directional file
    transfer protocol to transmit one of the files.


    Protocol design
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    The ultimate goal when designing HYDRA was to design a protocol that
    is as simple and robust as possible; complexity increase the problem
    of faulty implementations.

    The obvious function of a file transfer protocol is to transport a
    collection of data from its source to its destination as efficient
    possible and without jeopardizing the integrity of the data.

    The lack of data compression and lost packet management (as used in
    Kermit and Super Kermit) is intentional. The authors feel that this
    unnecessarily increases the complexity of the protocol.

    While HYDRA performs to its best on full duplex links, it should be
    possible to use it on links using proprietary protocols such as the
    US Robotics HST protocol which features one 14.4 kbps data channel
    and one 450 bps back channel.

    The protocol design should be flexible enough for future enhancements
    while maintaining backward compatibility.


    Protocol requirements and restrictions
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    HYDRA require that the link can handle ASCII character 24 (DLE) as
    well as all ASCII characters in the range 32 through 126. All other
    characters can be escaped or encoded by the protocol as required by
    the link.

    Capability of the computer to perform simultaneous serial I/O as well
    as simultaneous serial I/O combined with disk access is preferred,
    but can be circumvented by opting for windowed transmission instead
    of full streaming.

    HYDRA calls for the ability to check whether there is anything in the
    serial input buffer (i.e. "peek-ahead"), but it doesn't mind if it
    has to wait for a second if there is no data available (using for
    instance the UNIX alarm() mechanism).

    The protocol is extremely tolerant with timeouts (i.e. satellite or
    network delays) while still maintaining maximum reliability,
    robustness, and throughput.


    Terms and definitions
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    A BYTE                   An 8-bit unsigned character.
    A WORD                   A 16-bit unsigned integer.
    A DWORD                  A 32-bit unsigned integer.
    A LONG                   A 32-bit SIGNED integer.
    FILE OFFSETS (position)  A long.
    NUL                      The ASCII character 0.
    BS                       The ASCII character 8.
    CR                       The ASCII character 13.
    XOFF                     The ASCII character 17.
    XON                      The ASCII character 19.
    H_DLE                    The HYDRA link escape character, ASCII 24
                             (^X).
    SP or SPACE              The ASCII character 32.
    UNIX timestamp           A specific time and date expressed as the
                             number of seconds since midnight, January
                             1st, 1970. All UNIX timestamps used in HYDRA
                             are expressed in local time.

    Multi-byte items are transmitted in "low-byte first" order, so big-
    endian CPUs (like 680xx) need to do some byteswapping, depending on
    the implementation.

    Values preceded by '0x' are in hexadecimal notation (base 16, 0..9
    a..f). All values transmitted in hexadecimal notation must be
    converted to lowercase characters and left-padded to their full
    size with '0' prior to transmission. E.g. a WORD with the value 255
    (decimal) is expressed as 00ff. A LONG with the value 255 (decmial)
    is expressed as 000000ff.

    In formulas, "AND" means bitwise AND, "XOR" means bitwise Exclusive
    OR, "NOT" is ones complement (i.e. all zeros become ones, all ones
    become zeros). The ">>" is a shift operation to the right, "R >> 3"
    means shift R three bits to the right.


    General packet format
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    All data exchange is done with framed packets protected by 16 or 32
    bit CRC values appended to the packet data and packet type (low-
    byte first). The only exception to this is the cancel sequence of 5
    consecutive H_DLE characters.

    All packets except those with the type DATA are followed by a CR
    (ASCII 13) to help get through some buffered environments and aid
    possible debugging and/or tracing. If requested by the other side in
    its INIT packet, packets can also be prefixed by a specific data
    string which can include NULs, delays or break signals. Refer to the
    section on the INIT packet for more information.


                          Format of unframed packet

                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ~ Zero or more bytes packet dependent data ~
                ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³ Packet type byte                         ³
                ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³ CRC-16/32 of packet data and packet type ³
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                            Table of packet types

         ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
         ³Name    ³Character³ASCII³Description                     ³
         ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
         ³START   ³   'A'   ³  65 ³Startup sequence                ³
         ³INIT    ³   'B'   ³  66 ³Session initialisation          ³
         ³INITACK ³   'C'   ³  67 ³Response to INIT packet         ³
         ³FINFO   ³   'D'   ³  68 ³File information                ³
         ³FINFOACK³   'E'   ³  69 ³Response to FINFO packet        ³
         ³DATA    ³   'F'   ³  70 ³File data packet                ³
         ³DATAACK ³   'G'   ³  71 ³File data position ACK packet   ³
         ³RPOS    ³   'H'   ³  72 ³Reposition request packet       ³
         ³EOF     ³   'I'   ³  73 ³End of file packet              ³
         ³EOFACK  ³   'J'   ³  74 ³Response to EOF packet          ³
         ³END     ³   'K'   ³  75 ³End of session                  ³
         ³IDLE    ³   'L'   ³  76 ³Idle (just saying I'm alive)    ³
         ³DEVDATA ³   'M'   ³  77 ³Data to specified device     (1)³
         ³DEVDACK ³   'N'   ³  78 ³Response to DEVDATA packet   (1)³
         ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    (1) Support for DEVDATA and DEVDACK types is optional and indicated
        in INIT state of a HYDRA session.


                           Format of framed packet

               ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
               ³        H_DLE         ³Packet format byte  ³
               ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
               ~               Encoded packet              ~
               ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
               ³        H_DLE         ³End of framed packet³
               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                            Table of packet formats

           ÚÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
           ³Name³Character³ASCII³Description                     ³
           ÃÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ³END ³   'a'   ³  97 ³End of framed packet            ³
           ³BIN ³   'b'   ³  98 ³Binary packet                   ³
           ³HEX ³   'c'   ³  99 ³Hex encoded packet              ³
           ³ASC ³   'd'   ³ 100 ³Shifted 7-bit encoded packet (1)³
           ³UUE ³   'e'   ³ 101 ³UUencoded packet             (1)³
           ÀÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    (1) Support for ASC and/or UUE formats is optional and indicated in
        the INIT state of a HYDRA session.


    Packet sender and receiver state charts
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TXPKT (Sender)
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³1³pkttype == START or         ³format = HEXPKT           ³Format    ³
³        ³ ³pkttype == INIT or          ³                          ³          ³
³        ³ ³pkttype == INITACK or       ³                          ³          ³
³        ³ ³pkttype == END or           ³                          ³          ³
³        ³ ³pkttype == IDLE             ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Escape 8th bit (7 bit link) ³                          ³Coding    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (no spc.pkt, 8bit link)³format = BINPKT           ³Format    ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Coding  ³1³escape all control chars &  ³format = UUEPKT           ³Format    ³
³        ³ ³UUENCODED packets allowed   ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³ASCII packets allowed       ³format = ASCPKT           ³Format    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³7 bit link &                ³format = HEXPKT           ³Format    ³
³        ³ ³escape all control chars &  ³                          ³          ³
³        ³ ³UUE/ASC pkts not allowed    ³                          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Format  ³                              ³Append format byte to data³CRC       ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³CRC     ³1³format != HEXPKT &          ³Calc CRC-32 (data,pkttype)³Encode    ³
³        ³ ³CRC-32 allowed              ³Append one's complement of³          ³
³        ³ ³                            ³CRC to data, lowbyte first³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (HEXPKT or no CRC-32)  ³Calc CRC-16 (data,pkttype)³Encode    ³
³        ³ ³                            ³Append one's complement of³          ³
³        ³ ³                            ³CRC to data, lowbyte first³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Encode  ³1³format == BINPKT            ³BIN escape databuf        ³Prefix    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³format == HEXPKT            ³HEX encode databuf        ³Prefix    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³format == ASCPKT            ³ASC encode/escape databuf ³Prefix    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³format == UUEPKT            ³UUE encode databuf        ³Prefix    ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Prefix  ³1³No more prefix characters   ³                          ³Transmit  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Prefix character ASCII 221  ³Send 1 second break signal³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Prefix character ASCII 222  ³1 second delay            ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³Prefix character ASCII 223  ³Transmit NUL (ASCII 0)    ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³else (any other character)  ³Transmit character        ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Transmit³                              ³Transmit H_DLE,format byte³Suffix    ³
³        ³                              ³Transmit encoded buffer   ³          ³
³        ³                              ³Transmit H_DLE,pktend byte³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Suffix  ³1³pkttype != DATA &           ³Transmit CR,LF (ASC 13,10)³Done      ³
³        ³ ³pktformat != BINPKT         ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (pkttype == DATA or    ³                          ³Done      ³
³        ³ ³      pktformat == BINPKT)  ³                          ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ


RXPKT (Receiver)
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Reset   ³                              ³rxdle = 0                 ³NextByte  ³
³        ³                              ³format = 0                ³          ³
³        ³                              ³pktlen = 0                ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³User wishes to abort session³Report reason for abort   ³Abort     ³
³        ³ ³or carrier lost             ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Byte available in inputbuf  ³                          ³StripIn   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³braintimer expired          ³Report braindead situation³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³Any other timer expired     ³Tell responsible party    ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³StripIn ³1³Escape 8th bit (7 bit link) ³c = c AND 0x7f (strip 8th)³StripC    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (8 bit link)           ³                          ³StripC    ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³StripC  ³1³Escape ctlchars with 8th set³n = c AND 0x7f (strip 8th)³Process   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (let 8 bit ctl through)³n = c                     ³Process   ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Process ³1³c == H_DLE                  ³increment rxdle           ³DLE       ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Escape XON/XOFF &           ³Eat these                 ³NextByte  ³
³        ³ ³n == XON or n == XOFF       ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Escape all control chars &  ³Eat these                 ³NextByte  ³
³        ³ ³n < 32 or n == 127          ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxdle > 0                   ³                          ³Escape    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³else (no eating or escaping)³                          ³Store     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DLE     ³1³rxdle == 5                  ³Report remote wants abort ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (rxdle < 5)            ³                          ³NextByte  ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Escape  ³1³c == PKTEND                 ³                          ³PktEnd    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³c == BINPKT                 ³format = BINPKT           ³PktStart  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³c == HEXPKT                 ³format = HEXPKT           ³PktStart  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³c == ASCPKT                 ³format = ASCPKT           ³PktStart  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³c == UUEPKT                 ³format = UUEPKT           ³PktStart  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³6³else (normal escaped char)  ³c = c XOR 0x40            ³Store     ³
³        ³ ³                            ³rxdle = 0                 ³Store     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Store   ³1³format == 0                 ³Garbage                   ³NextByte  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³pktlen >= maximum           ³Pkt too long / lost PKTEND³Reset     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (fmt > 0 & len < max)  ³Append c to databuffer    ³NextByte  ³
³        ³ ³                            ³increment pktlen          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³PktStart³                              ³rxdle = 0                 ³NextByte  ³
³        ³                              ³pktlen = 0                ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³PktEnd  ³1³format == 0                 ³End without start, garbage³Reset     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³format == BINPKT            ³(No more decoding needed) ³CalcCRC   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³format == HEXPKT            ³ok = Decode HEXPKT        ³CheckDec  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³format == ASCPKT            ³ok = Decode ASCPKT        ³CheckDec  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³format == UUEPKT            ³ok = Decode UUEPKT        ³CheckDec  ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³CheckDec³1³ok (no errors during decode)³                          ³CalcCRC   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (errors in decoding)   ³Bad encoding, ignore pkt  ³Reset     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³CalcCRC ³1³format != HEXPKT &          ³Calc CRC-32 over databuf  ³CheckCRC  ³
³        ³ ³CRC-32 allowed              ³ok = (crc == 0xdebb20e3)  ³          ³
³        ³ ³                            ³pktlen = pktlen - 4       ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (HEXPKT or no CRC-32)  ³Calc CRC-16 over databuf  ³CheckCRC  ³
³        ³ ³                            ³ok = (crc == 0xf0b8)      ³          ³
³        ³ ³                            ³pktlen = pktlen - 2       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³CheckCRC³1³ok (CRC matched magic)      ³pkttype = last byte of buf³Reset     ³
³        ³ ³                            ³pktlen = pktlen - 1       ³          ³
³        ³ ³                            ³Hand pkt to higher level  ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (CRC check failed)     ³Bad CRC, ignore packet    ³Reset     ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ



    BIN packet format
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    The binary packet format require an 8-bit data channel. If requested
    by either side, one or more sets of control characters are escaped.
    In this case, when one of these characters appears in an unframed
    packet, a H_DLE is sent followed by the character XOR 0x40. The H_DLE
    character itself is always transmitted in this fashion. On the
    receiver side, if the character after a H_DLE is not one of the
    packet format bytes, this character is decoded using XOR 0x40 again.


BINPKT Escaping
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³txlastc = 0               ³NextByte  ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³No more bytes to process    ³                          ³Done      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Escape ctlchars with 8th set³n = c AND 0x7f (strip 8th)³Escape    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (let 8 bit ctl through)³n = c                     ³Escape    ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Escape  ³1³n == H_DLE                  ³Output H_DLE              ³Output    ³
³        ³ ³                            ³c = c XOR 0x40            ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Escape XON/XOFF &           ³Output H_DLE              ³Output    ³
³        ³ ³n == XON or n == XOFF       ³c = c XOR 0x40            ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Escape Telenet &            ³Output H_DLE              ³Output    ³
³        ³ ³n == CR &                   ³c = c XOR 0x40            ³          ³
³        ³ ³txlasc == '@'               ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³Escape all control chars &  ³Output H_DLE              ³Output    ³
³        ³ ³n < 32 or n == 127          ³c = c XOR 0x40            ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³else (any other character)  ³                          ³Output    ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Output  ³                              ³Store c                   ³NextByte  ³
³        ³                              ³txlastc = c               ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ



    HEX packet format
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Supported by all implementations, this packet format is used in
    worst-case situations and upon startup of a session when it is not
    yet known what restrictions the line and the other side will place on
    the link.

    Packet types always transmitted in HEX format are: START, INIT,
    INITACK, IDLE, END.

    HEX format packets always use a 16-bit CRC.

    HEX packets assume a 7-bit link, escaping all control characters and
    filtering all control characters upon receipt.

    ASCII characters in the range 128-255 (high bit set) are encoded by
    first transmitting a backslash ('\') character (ASCII 92), followed
    by the character in two lowercase hex-digits (bits 4-7 in first
    digit, bits 0-3 in second).

    Uppercase hex-digits are not permitted.

    The backslash character itself is transmitted as two backslashes.

    ASCII characters in the range 0-31 and 127 (all control characters)
    are escaped with H_DLE in the same fashion as in binary (BIN)
    packets.

    Decoded  byte 1
            ÚÄÄÄÄÄÄ¿
            76543210
            ÀÄÄÙÀÄÄÙ
    Encoded  h1  h2


HEXPKT Encoding/Escaping
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³No more bytes to process    ³                          ³Done      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³High bit of c set           ³Output \ (backslash)      ³          ³
³        ³ ³                            ³Output hexdigit(c bit 4-7)³          ³
³        ³ ³                            ³Output hexdigit(c bit 0-3)³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³c < 32 or c == 127          ³Output H_DLE              ³          ³
³        ³ ³                            ³Output (c XOR 0x40)       ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³c == \ (backslash)          ³Output \ (backslash)      ³          ³
³        ³ ³                            ³Output \ (backslash)      ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³else (any other character)  ³Output c                  ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ


HEXPKT Decoding
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³No more bytes to process    ³                          ³Done OK   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³c == \ (backslash)          ³                          ³Escape    ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (any other character)  ³Output c                  ³Escape    ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Escape  ³1³No more bytes to process    ³Premature end of data     ³Error     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³c == \ (backslash)          ³Output \ (backslash)      ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³c == lowercase hexdigit     ³Save c, move ptr to next  ³NextHex   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³else (all other characters) ³Invalid character         ³Error     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextHex ³1³No more bytes to process    ³Premature end of data     ³Error     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³c == lowercase hexdigit     ³Output (1st << 4 OR 2nd)  ³NextByte  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (all other characters) ³Invalid character         ³Error     ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ


    ASC packet format
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Support of this packet format is optional and signalled in the INIT
    packet with the ASC flag in the "Supported options" field. 8-bit data
    is transformed into 7-bit data by a simple shift operation. Each byte
    is inserted at the top of a shift register, the lower seven bits are
    moved out. So seven 8-bit bytes are encoded into eight 7-bit
    characters.

    The end of the packet is padded by a maximum of six bits of 0 to make
    the number of bits a multiple of seven and thereby creating
    complete characters (so the receiver stops decoding when there are
    less than seven bits left). The output can contain control
    characters, so if escaping of these characters is required, this is
    done as in BIN packets using the H_DLE method.


    Decoded  byte 7  byte 6  byte 5  byte 4  byte 3  byte 2  byte 1
            ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿
            76543210765432107654321076543210765432107654321076543210
            ÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙÀÄÄÄÄÄÙ
    Encoded   c8     c7      c6    c5     c4     c3     c2     c1


ASCPKT Encoding/Escaping
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Reset   ³                              ³n = 0 (16 bit wide!)      ³NextByte  ³
³        ³                              ³bitshift = 0              ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³No more bytes to process    ³                          ³Flush     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (more bytes to process)³n = n OR (c << bitshift)  ³Shift     ³
³        ³ ³                            ³BINPKT escape (n & 0x7f)  ³          ³
³        ³ ³                            ³n = n >> 7                ³          ³
³        ³ ³                            ³increment bitshift        ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Shift   ³1³bitshift == 7               ³BINPKT escape (n & 0x7f)  ³Reset     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (bitshift < 7)         ³                          ³NextByte  ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Flush   ³1³bitshift > 0                ³BINPKT escape (n & 0x7f)  ³Done      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (bitshift == 0)        ³                          ³Done      ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

ASCPKT Decoding
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³n = 0 (16 bit wide!)      ³NextByte  ³
³        ³                              ³bitshift = 0              ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³No more bytes to process    ³                          ³Done OK   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (more bytes to process)³c = c AND 0x7f            ³Shift     ³
³        ³ ³                            ³n = n OR (c << bitshift)  ³          ³
³        ³ ³                            ³bitshift = bitshift + 7   ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Shift   ³1³bitshift >= 8               ³Output (n AND 0xff)       ³NextByte  ³
³        ³ ³                            ³n = n >> 8                ³          ³
³        ³ ³                            ³bitshift = bitshift - 8   ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (bitshift < 8)         ³                          ³NextByte  ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ



    UUE packet format
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Support of this packet format is optional and signalled in the INIT
    packet with the UUE flag in the "Supported options" field. The 8-bit
    data is transformed into printable ASCII using the UUENCODE
    algorithm. Three 8-bit bytes are encoded into four printable ASCII
    characters. This done by taking the bottom six bits left and adding
    '!' (ASCII 33) to move this character value into printable ASCII
    range.

    The end of the packet is padded by a maximum of five bits of 0 to
    make the number of bits a multiple of six and thereby creating 
    complete characters (so the receiver stops decoding when there are
    less than six bits left). The output of this coding scheme does not
    need any further escaping before transmission.

    Decoded  byte 3  byte 2  byte 1
            ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿ÚÄÄÄÄÄÄ¿
            765432107654321076543210
            ÀÄÄÄÄÙÀÄÄÄÄÙÀÄÄÄÄÙÀÄÄÄÄÙ
    Encoded   c4    c3    c2    c1


UUEPKT Encoding
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³Less than three bytes left  ³                          ³Flush     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (three or more left)   ³UUE(in[0]>>2)             ³          ³
³        ³ ³                            ³UUE(in[0]<<4 OR in[1]>>4) ³          ³
³        ³ ³                            ³UUE(in[1]<<2 OR in[2]>>6) ³          ³
³        ³ ³                            ³UUE(in[2])                ³          ³
³        ³ ³                            ³(UUE: (c AND 0x3f) + '!') ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Flush   ³1³No more bytes left          ³                          ³Done      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³One byte left               ³UUE(in[0]>>2)             ³Done      ³
³        ³ ³                            ³UUE(in[0]<<4)             ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Two bytes left              ³UUE(in[0]>>2)             ³Done      ³
³        ³ ³                            ³UUE(in[0]<<4 OR in[1]>>4) ³          ³
³        ³ ³                            ³UUE(in[1]<<2)             ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

UUEPKT Decoding
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextByte³1³Less than four bytes left   ³                          ³Flush     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (four or more left) &  ³UD(i[0])<<2 OR UD(i[1])>>4³          ³
³        ³ ³(c AND 0x7f) is in UUE range³UD(i[1])<<4 OR UD(i[2])>>2³          ³
³        ³ ³                            ³UD(i[2])<<6 OR UD(i[3])   ³          ³
³        ³ ³                            ³(UD: (c - '!') AND 0x3f)  ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (all other characters) ³Invalid character(s)      ³Error     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Flush   ³1³No bytes left or            ³                          ³Done OK   ³
³        ³ ³Less than two bytes left    ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Two bytes left &            ³UD(i[0])<<2 OR UD(i[1])>>4³Done OK   ³
³        ³ ³(c AND 0x7f) is in UUE range³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Three bytes left &          ³UD(i[0])<<2 OR UD(i[1])>>4³Done OK   ³
³        ³ ³(c AND 0x7f) is in UUE range³UD(i[1])<<4 OR UD(i[2])>>2³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³else (all other characters) ³Invalid character(s)      ³Error     ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ



    START packet                                             (HEX format)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    This packet is sent to tell the remote to initiate a HYDRA session.

    The complete framed packet as transmitted looks like:

        ASCII values   24    99  65  92 102  53  92  97  51    24    97
                    ÚÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄ¿
        Characters  ³ H_DLE ³ c ³ A ³ \ ³ f ³ 5 ³ \ ³ a ³ 3 ³ H_DLE ³ a ³
                    ÀÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÙ

    Applications may scan for this sequence to automatically start HYDRA
    when the remote transmits this packet (AutoStart). Prior to the START
    packet, a special string is transmitted to enable remote starting
    from a command prompt, hydra<CR> (the word hydra in lowercase):

        ASCII values 104 121 100 114  97  13
                    ÚÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÄ¿
        Characters  ³ h ³ y ³ d ³ r ³ a ³ CR ³
                    ÀÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÄÙ

    The special string combined with the START packet is transmitted at
    five second intervals until either a START or INIT packet is received
    from the remote, or the maximum number of retries is reached. Any
    other packet types received in this stage must be ignored as they
    could be remains of a previous session.


    INIT packet                                              (HEX format)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    The INIT packet contains file transfer session options. The remote
    acknowledges this packet by returning an INITACK packet.


                              INIT packet data

                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                 ~ Application ID string, NUL terminated ~
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ~ Supported options, NUL terminated     ~
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ~ Desired options, NUL terminated       ~
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ³ Desired transmitter window size or 0  ³
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ³ Desired receiver window size or 0     ³
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ~ Other general options, NUL terminated ~
                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ~ Packet prefix string, NUL terminated  ~
                 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    The application ID string contains a printable ASCII string with the
    document revision date, product name, product revision number, and
    optionally the product serial number. The format of the string is:

        <RevDate><ProductName><,><ProductRevision>[<,><ProductSerial#>]

    RevDate is the UNIX timestamp (the hour, minute, and second portion
    is assumed to be zero), in hexadecimal notation, of the HYDRA
    document that the application is supposed to support. None of the
    following three fields should exceed thirty characters in length and
    must not contain any control characters (ASCII 0-31) or the comma
    character (ASCII 44). The field separator is a comma (ASCII 44)
    character.

    Capability flags

        XON        Escape <XON> and <XOFF> characters.
        TLN        Escape the <CR>@<CR> sequence (Telenet escape).
        CTL        Escape ASCII characters 0-31 and 127.
        HIC        Escape above three with high bit set.
        HI8        Escape ASCII characters 128-255 and strip the high bit.
        BRK        Can transmit a break signal.
        ASC        Can handle ASC packets.
        UUE        Can handle UUE packets.
        C32        Can receive packets with 32-bit CRC error detection.
        DEV        Can receive device packets.
        FPT        Can receive filenames with paths.

    Capability flags are always three characters long, in uppercase, and
    seperated by a comma character (ASCII 44). Please note that the first
    five flags must be supported by all applications that implement the
    HYDRA specifications.

    The "Supported options" string contain the capability flags of the
    options that the application support. The "Desired options" string
    contain the capability flags of the options that the application
    would like to use/enable for the session. Some flags do not have to
    be specified in both strings. E.g. if the C32 flag is present in the
    "Supported options" string and the remote system indicates support
    for the same flag, 32-bit CRC error detection will be used. An
    application may not ask for an option it does not support.

    Escaping certain characters or bits also means filtering any
    occurrence of them in the incoming data stream. At the start of a
    session, it is assumed that the first five capability flags are in
    effect, i.e. the high bit is stripped off every received character
    and all control characters are filtered out.

    The "Desired transmitter/receiver window size" fields are long
    integers expressed in hexadecimal notation. With these options each
    side tells the other to use window management of the requested size
    when transmitting file data, instead of using full streaming (0).
    The window setting is completely seperate for both directions.
    If one side requests a smaller window size than the other, that
    smaller size will be used for that direction; also, a window of any
    size takes precedence over no window (0).
    Please note that the terms 'transmitter' and 'receiver' used for the
    fields in the INIT packet are from the view of the side transmitting
    that packet, so the other side should merge the 'transmitter' window
    field from the received INIT packet with its own 'receiver' window
    field.

    The "General options" string currently has no other fields than
    "Desired tx/rx window size"; the string is NUL terminated.

    The packet prefix string is normally empty, but may be provided by
    the remote if required. The maximum length of a packet prefix string
    is 30 characters. All characters should be transmitted as specified,
    with the following exceptions:

    
                Table of special packet prefix string chars

               ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
               ³ASCII³Description                           ³
               ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
               ³ 221 ³Transmit a break signal for one second³
               ³ 222 ³Delay one second before next character³
               ³ 223 ³Transmit a NUL (ASCII 0) character    ³
               ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


    INITACK packet                                           (HEX format)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    The INITACK packet is used to acknowledge the receipt of the remote's
    INIT packet.

    Duplicate INIT packets should be acknowledged too, as the remote may
    have missed previous INITACK packets; the reception of such a
    duplicate packet should not however reset the braindead timer, as it
    does not mean a change of state and is not actual file data.


    FINFO packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    File information packet, sent to notify the remote that another file
    is to be transmitted, or to signal end of batch. After the FINFO
    packet has been transmitted, the timer is set to the normal timeout
    value. The sender then waits for an FINFOACK packet from the remote
    or for the timer to expire. In the event of a timeout, the transmit/
    wait sequence is repeated with half the normal timeout value until
    the maximum number of retries has been reached.


                              FINFO packet data
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ~ File information, NUL terminated    ~
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                   File information        End of batch
                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                  ³ Timestamp or 0  ³   ³       NUL       ³ 
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
                  ³ Filesize or 0   ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ Reserved (0)    ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ Transaction #   ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ File count or 0 ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ~ Short filename  ~
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ~ Real filename   ~
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³     NUL         ³
                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                     
    End of batch is signalled by an empty string (only the terminating
    NUL).

    The first five fields are long integers expressed in hexadecimal
    notation.

    Timestamp is a UNIX timestamp representing the creation time of the
    file. If the creation time is not known, this is zero.

    Filesize is the size of the file in bytes. If the size of the file is
    not known, this is zero. This field should not be used as an exact
    measure of the size of the file. It is safe to assume that you should
    not receive less data than specified in this field, but the file may
    grow while it is being transferred (e.g. the result of a background
    process).

    Transaction # is a unique number for each set of files being sent
    during the session. This is primarily used to allow the receiving
    application to group several files together and store them in
    specific directories as a result of automated file requests. If the
    file being sent is not a result of an automated file request, this
    field must be set to zero.

    File count is the session file counter. For the first file in a
    session, this field contains the total number of files to be sent
    during the session; for subsequent files, it contains the file number
    in the session, starting with two (2). If the total number of files
    is not known, this field contains zero for all files.

    The first filename field must be specified in lowercase characters.
    It must conform to MS-DOS filename conventions and not exceed 12
    characters in length (excluding the terminating NUL character). The
    second field, real filename, is the actual filename on the sending
    system. If this field is not present, the short filename field is
    used.

    No directory paths may be specified in the short filename. Directory
    paths may be specified in the real filename field if the "Desired
    options" of the receiver contains FPT. If the real filename field
    contains a path, it may include any ASCII character in the range 32
    (0x20) through 255 (0xff) with \ characters translated to /. A drive
    specifier may be present in the <Drive>: (e.g. c:) format. If both
    the short and real filename fields are present, they are separated
    by a NUL character. There is never more than one NUL character
    terminating the packet.
    

    FINFOACK packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Sent in response to an FINFO packet. If the FINFO packet contained
    file information, the FINFOACK packet is also used to instruct the
    remote how to proceed with the transfer.


                            FINFOACK packet data
                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                 ³ Long file offset, special code, or 0  ³
                 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    The only data in this packet is a long integer. In response to an
    an end of batch FINFO packet, the file offset is set to zero (0). In
    all other cases, file offset is one of the following:


                       File offsets and special values
           ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
           ³Offset³Description                                   ³
           ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ³ >=0  ³Seek to specified offset and start sending (1)³
           ³  -1  ³Already have file                          (2)³
           ³  -2  ³Send file during another batch (not now)      ³
           ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    (1) This can only be something other than zero if the FINFO packet
        specified a filesize other than zero (i.e. the size of the file
        is known to the receiver).

    (2) The sending application should consider the file as having been
        sent successfully. This is primarily used to prevent duplicate
        files from being transmitted.


    DATA packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Packet containing actual file data.


                                  DATA packet
                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                  ³ Long file offset of file data block     ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ~ Variable length data block 0-2048 bytes ~
                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    If the file offset corresponds with what is expected by the receiver,
    the data block is saved and the file position increased accordingly.
    If the file offset is not correct, DATA packets may have been lost or
    failed the CRC check. Bad packets are ignored because it is not
    certain that the bad packet was an actual DATA packet and not some
    other type of packet. The file offset comparison is therefore the
    only way to find out about lost or bad data.

    When a bad data packet is detected, an RPOS packet is transmitted by
    the receiver to force the sender to seek to the desired file offset
    and resume transmission from it. After transmitting the RPOS packet,
    the receiver initializes a timer and continues to monitor received
    DATA packets while comparing their file offset with its desired
    offset.

    If the offset of a newly received DATA packet is greater than the
    offset received in the last DATA packet prior to transmitting the
    RPOS packet, the sender has not yet seen the RPOS packet, or the
    DATA packet was already in the data stream when the RPOS packet was
    transmitted.

    If the received offset matches the requested offset, the transfer is
    resumed, otherwise, a new RPOS packet is transmitted by the receiver
    and the timer restarted.

    If the timer expires, another RPOS packet is transmitted by the
    receiver. This is repeated until the maximum number of retries has
    been reached.

    If the receiver encounters more missing or invalid DATA packets at
    the same offset than it finds acceptable and it is not the originator
    of the session, it may decide to revert to a one-way transfer and
    wait with sending the remainder of its own files until the remote has
    transmitted its end of batch signal. It is possible that some hard-
    ware is not capable or well suited for a bi-directional file transfer
    involving large volumes of data (see description of the IDLE packet).


    DATAACK packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Transmitted by the receiver with its current file offset after
    receiving a valid DATA packet.


                              DATAACK packet data
                          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                          ³    Long file offset    ³
                          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    This packet is only transmitted if there is a window in operation
    for that direction (selected in the INIT stage of the session), in
    which case the sender uses the DATAACK file offsets to manage its
    transmit window. If the sender's file offset is greater than or equal
    to the last DATAACK offset received plus the window size, no more
    data is transmitted by the sender until a DATAACK packet is received
    which allows the sender to proceed without exceeding the window size.

    While waiting for the DATAACK packet, the sender checks its timer
    and retry counter. If the timer expires before a valid DATAACK packet
    is received, the next DATA packet is transmitted, the retry counter
    incremented, and the timer restarted with half the normal timeout.
    This system ensures that the two sides do not end up waiting for
    each other in case packets are lost; the receiver will respond with
    either a DATAACK or RPOS packet. Receipt of a DATAACK packet does not
    reset the braindead timer.

    There are two windowing systems the receiver can use: sliding window
    or segmented streaming.

    If the receiver is capable of simultaneous serial and disk I/O, it
    will transmit a DATAACK packet for every received DATA packet, or
    every few DATA packets if it wants to be more economical with line
    capacity.
    Sliding window transmission is just a method of keeping the runahaid
    of the transmitter within reasonable limits (for sattelite or network
    links with long delays), thereby allowing for faster error recovery.
    Because of Hydra's tolerancy to delays and method of error recovery,
    sliding windows transmission is not normally required and full
    streaming can be used.

    If however the receiver is not capable of simultaneous serial and
    disk I/O, it will will process received DATA packets until the window
    size is reached (or slightly exceeded), write the received packets to
    disk, and then transmit one DATAACK packet to signal that it can
    receive the next segment of data.

    If the sender cannot handle simultaneous serial and disk I/O, it can
    apply the segmented streaming technique for reading data segments of
    the negotiated window size from disk.


    RPOS packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Transmitted by the receiver to force the sender to seek to a specific
    position in the file and resume the transfer (as described above).

    The RPOS packet is also used by the receiver to skip a file once the
    transfer has been initiated. This is done by transmitting a RPOS
    packet with -2 as the desired offset and then waiting for a EOF
    packet with the same offset (-2). Once the EOF packet is received,
    the receiver responds to it by transmitting a EOFACK packet and then
    proceeds to wait for the next FINFO packet.


                          RPOS packet dependent data
                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                  ³ Long file offset                       ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ Desired datablock size (word, 64-2048) ³
                  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                  ³ Long RPOS packet ID                    ³
                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                                 File offsets 
             ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
             ³Offset³Description                                ³
             ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
             ³ >=0  ³Seek to specified offset and resume sending³
             ³  -2  ³Send file during another batch (not now)   ³
             ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    The desired data blocksize field tells the sender what blocksize
    to use when it resumes transmitting from the specified file offset.

    Each new RPOS packet should be given a different packet ID. This
    allows the sender to identify and ignore duplicate RPOS packets.
    The ID need not be sequential, but it must not have the same value as
    any other RPOS packet sent during the transmission of the same file.
    A RPOS ID value of zero (0) is not permitted. The same ID value is
    only used when sending multiple RPOS packets due to an expired RPOS
    packet timer as described above (DATA packet).


    EOF packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Indicates that the end of the file has been reached by the sender.
    The packet is transmitted after the last DATA packet with file data.
    The EOF packet only contains one field which holds the current file
    offset of the sender (i.e. the actual size of the file).

    After the EOF packet has been transmitted, the timer is set to the
    normal timeout value. The sender then waits for an EOFACK packet
    from the remote or for the timer to expire. In the event of a
    timeout, the transmit/wait sequence is repeated with half the normal
    timeout value until the maximum number of retries has been reached.

    In the event that the receiver requests to skip the file by
    transmitting a RPOS(-2) packet (see RPOS packet), the EOF packet
    contains the same value (-2). If the sender wants to skip the file
    currently being transmitted, it issues an EOF packet with -2 as the
    offset value.

    EOF packets with an incorrect offset should be treated by the
    receiver as if it was an incorrect DATA packet (i.e. transmitting an
    RPOS packet). Accepted EOF packets are acknowledged by transmitting
    an EOFACK packet.


                                EOF packet data
                     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                     ³ Long file offset or special code ³
                     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                         File offsets and special value
               ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
               ³Offset³Description                             ³
               ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
               ³ >=0  ³Final offset in file (size of file)     ³
               ³  -2  ³Send file during another batch (not now)³
               ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


    EOFACK packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Transmitted in response to an accepted EOF packet. After transmitting
    this packet, the receiver waits for the FINFO packet of the next file
    or end of batch.


    END packet                                               (HEX format)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Once all files have been transmitted by both sides and no device
    packets remain to be transmitted, the end of session sequence is
    initiated. END packets are always sent in HEX format.

    Two END packets are transmitted and the transmit timer set to half
    the normal timeout. The application then waits for an END packet from
    the remote or for the transmit timer to expire. In the event of a
    timeout, the transmit/wait sequence is repeated until the maximum
    number of retries has been reached. At this point, the HYDRA session
    may be considered to be successful as both batches were completed.

    If an END packet is received before timeout, another three (3) END
    packets are transmitted and the protocol exits. Both sides need to
    transmit END packets and receive at least one from the remote.


    IDLE packet                                              (HEX format)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    The IDLE packet is used to let the remote know that the application
    is still alive. This is only applicable in uni-directional transfer
    mode to let the remote know that your application is still alive when
    it is receiving files, and after having transmitted an end of batch
    signal to the remote and not having any more files to send for the
    remainder of the session.

    When applicable, the IDLE packet is transmitted every 20 seconds. The
    remote resets its braindead timer upon receipt of an IDLE packet. If
    an application receives an IDLE packet while it is in a state where
    it is transmitting IDLE packets to the remote, something is wrong.
    This could occur if both sides have accidentally switched to one-way
    mode waiting for the remote to finish its batch. In this situation,
    one-way should be disabled to prevent a complete deadlock. Note that
    if both sides have finished their batch, the end of session sequence
    (see END packet) should be initiated.


    DEVDATA packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Support for the DEVDATA and DEVDACK packets is optional and indicated
    in the INIT packet with the DEV flag in the "Supported options"
    field. The ID value is a long, different for each new device data
    packet sent. A value of zero (0) is not permitted.

    Only one DEVDATA packet may be transmitted at a time; the side
    issuing it then waits either for a timeout of the device transmit
    timer, or for a DEVDACK packet with the correct ID value to be
    received from the remote. If the timer expires before a correct
    DEVDACK packet is received, the DEVDATA packet is again transmitted,
    and the nnumber of device transmit retries incremented. If the
    maximum number of retries is reached, the HYDRA session is aborted;
    apparently the other is not functioning properly, or data is not
    getting through. In either case, the normal operation of the
    protocol (transferring files) will also fail.

    The name of the device to which the data is addressed is transmitted
    as an uppercase fixed-length three character NUL terminated string.
    There are two pre-defined device names as described below. If an
    unknown device name is specified, or a duplicate DEVDATA packet is
    received (one with the same ID value as a previously received and
    acknowledged DEVDATA packet), the packet is simply discarded after
    transmitting a DEVDACK packet with the corresponding ID value.

    DEVDATA and DEVDACK packets do not reset the braindead timer. They
    operate independently from the normal protocol. Device packets may
    only be transmitted after the initialization sequence, and before
    both sides have completed their batch. If a DEVDATA packet has not
    yet been acknowledged, the end of session sequence is delayed until
    a DEVDACK packet has been sent in response.


                       DEVDATA packet dependent data
           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
           ³ Long DEVDATA packet ID value                     ³
           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ³ 3 character uppercase device name, NUL terminated³
           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
           ~ Variable length device data block (0-2048)       ~
           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                           Predefined device names
                ÚÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³Dev³Description                          ³
                ÃÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³MSG³Print data in protocol message window³
                ³CON³Print data to user console           ³
                ÀÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    The MSG device may be used to notify the remote of protocol-specific
    issues, i.e. "One-way transfer mode". Such messages may be logged,
    but should not be considered to be machine-readable.

    The CON device may be used to implement a "chat" or conversation
    feature. This is a special case in which a session *can* be prolonged
    after end of batch, but not against the remote's will.
    While chat is enabled, there is no transition from the REND to the
    END transmitter state. When a CON device packet is transmitted in
    chat mode and the txstate is REND, the own braindead timer is reset.
    If the other side does initiate the end sequence by sending an END
    packet, the chat mode is immediately terminated and the session ended
    in a clean manner. If one side does not want to (continue) chat, and
    the other side does not comply, the one side will abort after a
    braindead timeout, so this chat system does not mean a security flaw.
    Each side is responsible for keeping the session going on his end
    until its own user has finished chatting. It is suggested that the
    software apply a timeout of say 1 minute to keyboard input, ending
    the chat automatically if the user stops typing but does not exit
    chat mode. Also, the chat mode should be initiated with a special key
    so that it can not erronously be started or prolonged.


    DEVDACK packet
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Transmitted in response to a DEVDATA packet. The device data ID value
    must correspond to the ID of the previously received DEVDATA packet.


                              DEVDACK packet data
                         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                         ³ Long device data ID value ³
                         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



DEVICE sender (devtxstate HTD_...)
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³devtxid = 0               ³DONE      ³
³        ³                              ³reset devtxtimer          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DONE    ³1³wish to send device data &  ³increase devtxid          ³DATA      ³
³        ³ ³other side allows DEV pkts  ³devtxretries = 0          ³          ³
³        ³ ³                            ³reset devtxtimer          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³wish to send device data &  ³Tell calling function     ³          ³
³        ³ ³other doesn't allow DEV pkts³it's not on...            ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DATA    ³1³devtxretries == 10          ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (devtxretries < 10)    ³txpkt DEVDATA(id,dev,data)³DACK      ³
³        ³ ³                            ³devtxtimer = timeout      ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DACK    ³1³rxpkt DACK &                ³reset devtxtimer          ³DONE      ³
³        ³ ³DACK(id) == devtxid         ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³devtxtimer expired          ³Report devtx timeout      ³DATA      ³
³        ³ ³                            ³increase devtxretries     ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ
 
DEVICE RECEIVER
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³devrxid = 0               ³DONE      ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DONE    ³1³rxpkt DEVDATA               ³txpkt DEVDACK(id)         ³CheckID   ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³CheckID ³1³DEVDATA(id) != devrxid      ³devrxid = DEVDATA(id)     ³Process   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (apparent duplicate)   ³                          ³DONE      ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Process ³1³DEVDATA(dev) == MSG         ³Print protocol message    ³DONE      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³DEVDATA(dev) == CON         ³Output to user console    ³DONE      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³DEVDATA(dev) == known&ok    ³Call processing routine   ³DONE      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³else (unknown/not-ok device)³One-way into bitbucket    ³DONE      ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

 
    Packet length and data block size
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    The maximum length of a source data block (i.e. raw, non processed
    input file or device data) is 2048 bytes. The maximum allowed length
    of the packet data is 2048 + 8 = 2056 bytes. The eight bytes are to
    provide sufficient room for the additional fields in the DATA and
    DEVDATA packets. Packetizing adds an additional three to five bytes.
    The maximum length of a framed packet being transmitted can be three
    times the size of its source data depending on what type of encoding
    scheme is used (ASC, HEX, UUE, BIN). The minimum length of a data
    block is 64 bytes.

    The block size of DATA packets is based on the physical (DCE) link
    speed and is established as follows:

            ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            ³DCE speed³Maximum block size³Starting block size³
            ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ³  300 bps³     256 bytes    ³     256 bytes     ³
            ³ 1200 bps³     512 bytes    ³     256 bytes     ³
            ³ 2400 bps³    1024 bytes    ³     512 bytes     ³
            ³>2400 bps³    2048 bytes    ³     512 bytes     ³
            ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    The blocksize is initialized to the starting blocksize when a session
    is first started. After each kilobyte of file data transmitted, the
    blocksize is doubled until it reaches the maximum allowed blocksize.

    When the maximum allowed blocksize has been reached, the variable
    keeping track of how many bytes are needed to increase the blocksize
    is reset to zero.

    If a request for retransmission (RPOS packet) is received from the
    receiver, the blocksize is immediately set to that specified in the
    retransmission request. Every time this occurs, the number of bytes
    needed to double the blocksize is increased by 1024 with a maximum of
    of 8192 bytes. The end result is that more data has to be
    successfully transmitted before the blocksize is increased for each
    error that occurs.

    The length of a data block is dynamic and always in the range 0-2048
    bytes. A data block is never padded. If there is insufficient data
    to fill a block of the current blocksize, the blocksize is adjusted
    to the amount of remaining data.

    The blocksize logic is not reset between files in a session.


    Timers and retry counters
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    Each process in the protocol (transmit, receive and device transmit)
    has its own timer and retry counter, and there is one overall
    braindead timer. Allowed are 10 tries, the braindead timeout is 120
    seconds, and the other timeouts are based on the speed of the line
    and the state of the protocol. It can be calculated as (40960/DCE
    rate), with a minimum of 10 seconds and a maximum of 60 seconds.

                     ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
                     ³DCE speed³Timeout   ³Half      ³
                     ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
                     ³  300 bps³60 seconds³30 seconds³
                     ³ 1200 bps³34 seconds³17 seconds³
                     ³ 2400 bps³17 seconds³ 8 seconds³
                     ³>2400 bps³10 seconds³ 5 seconds³
                     ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

    If the output buffer is empty, the timeout value is halved. In
    general, this is the case if the number of tries is greater than zero
    and during the init and end sequences. These timeouts are not fatal
    situations, they just give the remote a reasonable amount of time to
    receive and respond to a packet before a retry occurs. Duplicate
    packets are always identified and ignored. A retry counter is reset
    if there is a change of state, or a reposition different from the
    previous file offset occurs.

    The braindead timer monitors useful data from the other side: a first
    response to a transmitted supervisiory packet, or a received packet
    with file data at the correct offset. Device packets and packets that
    do not signify any progress of the protocol do not affect the
    braindead timer.

    No other timers (such as one between characters in a packet) are
    necessary.


    Aborting a session
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    A session is aborted with five consequetive CAN (^X or ASCII 24)
    characters. Whenever a state table mentions "Abort", the following
    procedure is to be followed:

    Clear the output buffer and transmit eight CAN characters followed by
    ten BS (^H or ASCII 8) characters; wait a few seconds for the data to
    be transmitted to the remote, purge the input buffer and exit the
    protocol code.


GENERAL sender (txstate HTX_...)
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³txretries = 0             ³START     ³
³        ³                              ³reset txtimer             ³          ³
³        ³                              ³blksize = startblksize    ³          ³
³        ³                              ³goodbytes = 0             ³          ³
³        ³                              ³goodneeded = 1024         ³          ³
³        ³                              ³braintimer = 120          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³START   ³1³txretries == 10             ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (txretries < 10)       ³txstr AutoStart           ³SWAIT     ³
³        ³ ³                            ³txpkt START               ³          ³
³        ³ ³                            ³txtimer = 5               ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³SWAIT   ³1³rxpkt START or              ³txretries = 0             ³INIT      ³
³        ³ ³rxpkt INIT                  ³reset txtimer             ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txtimer expired             ³Report tx timeout         ³START     ³
³        ³ ³                            ³increment txretries       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³INIT    ³1³txretries == 10             ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (txretries < 10)       ³txpkt INIT(linkinfo)      ³INITACK   ³
³        ³ ³                            ³txtimer = timeout/2       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³INITACK ³1³rxpkt INITACK               ³txretries = 0             ³RINIT     ³
³        ³ ³                            ³reset txtimer             ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txtimer expired             ³Report tx timeout         ³INIT      ³
³        ³ ³                            ³increment txretries       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³RINIT   ³1³rxstate != INIT             ³                          ³NextFile  ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³NextFile³1³No files left?              ³Report end of batch       ³ToFName   ³
³        ³ ³                            ³Set NULL fileinfo         ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³Can access next file?       ³Set up fileinfo           ³ToFName   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³Can't access file?          ³Report access failure     ³NextFile  ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³ToFName ³                              ³txsyncid = 0              ³FINFO     ³
³        ³                              ³txretries = 0             ³          ³
³        ³                              ³reset txtimer             ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³FINFO   ³1³txretries == 10             ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txretries > 0               ³txpkt FINFO(fileinfo)     ³FINFOACK  ³
³        ³ ³                            ³txtimer = timeout/2       ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (txretries == 0)       ³txpkt FINFO(fileinfo)     ³FINFOACK  ³
³        ³ ³                            ³txtimer = timeout         ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³FINFOACK³1³NULL fname (end of batch) & ³txtimer = idletimeout     ³REND      ³
³        ³ ³rxpkt FINFOACK              ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt FINFOACK &            ³txpos = FINFOACK(pos)     ³DATA      ³
³        ³ ³FINFOACK(pos) >= 0          ³txretries = 0             ³          ³
³        ³ ³                            ³txlastack = 0             ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt FINFOACK &            ³They already have file    ³NextFile  ³
³        ³ ³FINFOACK(pos) == -1)        ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt FINFOACK &            ³Skip this file for now    ³NextFile  ³
³        ³ ³FINFOACK(pos) == -2)        ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³txtimer expired             ³Report tx timeout         ³FINFO     ³
³        ³ ³                            ³inrease txretries         ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DATA    ³1³rxstate != Done &           ³txtimer = idletimeout     ³XWAIT     ³
³        ³ ³hdxlink == True             ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt DATAACK &             ³txlastack = DATAACK(pos)  ³          ³
³        ³ ³DATAACK(pos) > txlastack    ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt RPOS &                ³Skip this file for now    ³SkipFile  ³
³        ³ ³RPOS(pos) < 0               ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt RPOS &                ³Report too many errors    ³Abort     ³
³        ³ ³RPOS(id) == txsyncid &      ³                          ³          ³
³        ³ ³inc txretries == 10         ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³rxpkt RPOS &                ³txpos = RPOS(pos)         ³          ³
³        ³ ³RPOS(id) != txsyncid &      ³txsyncid = RPOS(id)       ³          ³
³        ³ ³RPOS(pos) >= 0              ³txretries = 1             ³          ³
³        ³ ³                            ³blksize = RPOS(blksize)   ³          ³
³        ³ ³                            ³goodbytes = 0             ³          ³
³        ³ ³                            ³inc goodneeded + 1024     ³          ³
³        ³ ³                            ³if (goodneeded > 8192)    ³          ³
³        ³ ³                            ³   goodneeded = 8192      ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³6³File seek/read error or     ³Skip this file for now    ³SkipFile  ³
³        ³ ³user wishes to skip file    ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³7³txwindow &                  ³if (txretries > 0)        ³DATAACK   ³
³        ³ ³txpos >= txlastack+txwindow ³   txtimer = timeout/2    ³          ³
³        ³ ³                            ³else                      ³          ³
³        ³ ³                            ³   txtimer = timeout      ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³8³Enough room in output &     ³txpkt DATA(pos,data)      ³          ³
³        ³ ³more filedata(blksize) to go³txpos += datalen          ³          ³
³        ³ ³                            ³inc goodbytes + datalen   ³          ³
³        ³ ³                            ³if goodbytes > goodneeded ³          ³
³        ³ ³                            ³   Store txpos,blksize    ³          ³
³        ³ ³                            ³   blksize * 2 (max.2048) ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³9³End of filedata reached     ³                          ³EOF       ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³SkipFile³                              ³txpos = -1                ³EOF       ³
³        ³                              ³txretries = 0             ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DATAACK ³1³txretries == 10             ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt DATAACK &             ³txlastack = DATAACK(pos)  ³DATA      ³
³        ³ ³DATAACK(pos) > txlastack &  ³txretries = 0             ³          ³
³        ³ ³txpos < DATAACK(pos) + txwin³reset txtimer             ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt RPOS                  ³Handle RPOS in state DATA ³          ³
³        ³ ³                            ³but stay in this state    ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³txtimer expired             ³Report tx timeout         ³DATA      ³
³        ³ ³                            ³increment txretries       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³XWAIT   ³1³rxstate == Done             ³reset txtimer             ³DATA      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt DATAACK &             ³txlastack = DATAACK(pos)  ³          ³
³        ³ ³DATAACK(pos) > txlastack    ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt RPOS                  ³Handle RPOS in state DATA ³          ³
³        ³ ³                            ³but stay in this state    ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt IDLE                  ³hdxlink = False           ³DATA      ³
³        ³ ³                            ³reset txtimer             ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³txtimer expired             ³txpkt IDLE                ³          ³
³        ³ ³                            ³txtimer = idletimeout     ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³EOF     ³1³txretries == 10             ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txretries > 0               ³txpkt EOF(txpos)          ³EOFACK    ³
³        ³ ³                            ³txtimer = timeout/2       ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (txretries == 0)       ³txpkt EOF(txpos)          ³EOFACK    ³
³        ³ ³                            ³txtimer = timeout         ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³EOFACK  ³1³rxpkt EOFACK                ³braintimer = 120          ³NextFile  ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt DATAACK &             ³txlastack = DATAACK(pos)  ³          ³
³        ³ ³DATAACK(pos) > txlastack    ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt RPOS &                ³rxpos == -2               ³EOF       ³
³        ³ ³RPOS(pos) == -2 &           ³                          ³          ³
³        ³ ³rxpos != -2                 ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt RPOS &                ³Handle as in state DATA   ³DATA      ³
³        ³ ³RPOS(pos) >= 0              ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³txtimer expired             ³Report tx timeout         ³EOF       ³
³        ³ ³                            ³increment txretries       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³REND    ³1³rxstate == DONE &           ³txretries = 0             ³END       ³
³        ³ ³devtxstate == DONE          ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txtimer expired             ³txpkt IDLE                ³          ³
³        ³ ³                            ³txtimer = idletimeout     ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³END     ³1³txretries == 10             ³                          ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (txretries < 10)       ³txpkt END (twice)         ³ENDACK    ³
³        ³ ³                            ³txtimer = timeout/2       ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³ENDACK  ³1³rxpkt END                   ³txpkt END (thrice)        ³Done      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³txtimer expired             ³Report tx timeout         ³END       ³
³        ³ ³                            ³increment txretries       ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

 
 
GENERAL RECEIVER (rxstate HRX_...)
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³State   ³Predicate(s)                  ³Action(s)                 ³Next state³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Begin   ³                              ³reset rxtimer             ³START     ³
³        ³                              ³lastrxdlen = startblksize ³          ³
³        ³                              ³(tx handles braintimer)   ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³INIT    ³1³rxpkt INIT &                ³txpkt INITACK             ³FINFO     ³
³        ³ ³INIT(options) are compatible³Set options               ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³INIT(options) not compatible³Report link failure       ³Abort     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³FINFO   ³1³rxpkt INIT (apparent dup)   ³txpkt INITACK             ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt FINFO &               ³Report end of batch       ³          ³
³        ³ ³FINFO(fileinfo) == Empty    ³txpkt FINFOACK            ³DONE      ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt FINFO &               ³do not want this file     ³          ³
³        ³ ³we already have file        ³txpkt FINFOACK(-1)        ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt FINFO &               ³Skip this file for now    ³          ³
³        ³ ³open/diskspace error        ³txpkt FINFOACK(-2)        ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³rxpkt FINFO &               ³rxpos = resume offset     ³ToData    ³
³        ³ ³file we want to resume      ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³6³rxpkt FINFO &               ³rxpos = 0                 ³ToData    ³
³        ³ ³new file for us             ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³7³rxpkt EOF (apparent dup)    ³txpkt EOFACK              ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³ToData  ³                              ³txpkt FINFOACK(rxpos)     ³DATA      ³
³        ³                              ³rxsyncid = 0              ³          ³
³        ³                              ³rxlastsync = 0;           ³          ³
³        ³                              ³rxretries = 0             ³          ³
³        ³                              ³reset rxtimer             ³          ³
³        ³                              ³braintimer = 120          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DATA    ³1³rxpkt FINFO (apparent dup)  ³txpkt FINFOACK(rxpos)     ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxpkt DATA &                ³Store data                ³          ³
³        ³ ³DATA(pos) == rxpos          ³rxpos += datalen          ³          ³
³        ³ ³                            ³rxretries = 0             ³          ³
³        ³ ³                            ³rxlastsync = rxpos        ³          ³
³        ³ ³                            ³reset rxtimer             ³          ³
³        ³ ³                            ³braintimer = 120          ³          ³
³        ³ ³                            ³if (rxwindow)             ³          ³
³        ³ ³                            ³   txpkt DATAACK(rxpos)   ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³rxpkt DATA &                ³Report bad rxpos          ³BadPos    ³
³        ³ ³DATA(pos) != rxpos          ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³4³rxpkt EOF &                 ³Close file, received ok   ³OkEOF     ³
³        ³ ³EOF(pos) == rxpos           ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³5³rxpkt EOF &                 ³Close, save for resume    ³OkEOF     ³
³        ³ ³EOF(pos) == -2              ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³6³rxpkt EOF &                 ³Report bad EOF            ³BadPos    ³
³        ³ ³EOF(pos) != rxpos           ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³7³File write error or         ³Close, save for resume    ³          ³
³        ³ ³user wishes to skip file    ³rxpos = -2                ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³8³rxpkt IDLE &                ³braintimer = 120          ³          ³
³        ³ ³hdxlink == False            ³                          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³BadPos  ³1³DATA/EOF(pos) <= rxlastsync ³rxretries = 0             ³Timer     ³
³        ³ ³                            ³reset rxtimer             ³          ³
³        ³ ³                            ³rxlastsync = pos          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³DATA/EOF(pos) > rxlastsync  ³rxlastsync = pos          ³Timer     ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Timer   ³1³rxtimer expired             ³                          ³HdxLink   ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (rxtimer not expired)  ³                          ³DATA      ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³HdxLink ³1³rxretries > 4 &             ³hdxlink = True            ³Retries   ³
³        ³ ³txstate < REND &            ³rxretries = 0             ³          ³
³        ³ ³originator == False &       ³                          ³          ³
³        ³ ³hdxlink == False            ³                          ³          ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³else (above not the case)   ³                          ³Retries   ³
ÃÄÄÄÄÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³Retries ³1³inc rxretries == 10         ³Report too many errors    ³Abort     ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³2³rxretries == 1              ³increase rxsyncid         ³RPos      ³
³        ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³        ³3³else (rxretries > 1)        ³                          ³RPos      ³
ÃÄÄÄÄÄÄÄÄÅÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³RPos    ³                              ³lastrxdatalen/=2 (min.64) ³DATA      ³
³        ³                              ³txpkt RPOS (rxpos,        ³          ³
³        ³                              ³   lastrxdatalen,rxsyncid)³          ³
³        ³                              ³rxtimer = timeout         ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³OkEOF   ³                              ³txpkt EOFACK              ³FINFO     ³
³        ³                              ³reset rxtimer             ³          ³
³        ³                              ³braintimer = 120          ³          ³
ÃÄÄÄÄÄÄÄÄÅÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ´
³DONE    ³1³rxpkt FINFO (apparent dup)  ³txpkt FINFOACK(-2)        ³          ³
ÀÄÄÄÄÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ


    HYDRA in FidoNet technology mailers
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    HYDRA is suitable for use in FidoNet mailers. It can be implemented
    for EMSI and FTS-6 mail sessions. The FTS-6 (YooHoo) capability bit
    for HYDRA is 0x0020 (DOES_HYDRA). The EMSI and IEMSI protocol
    capability flag is HYD.

    When utilizing HYDRA in a mail session, two complete batches are
    always performed. Little else differs from a normal FTS-6 ZedZap mail
    session. The first batch is used to transmit all mail, files, and
    file requests by both sides. The second batch is always performed,
    sending nothing if there are no file requests to honor. The data
    buffers are not purged between the two batches since HYDRA ignores
    any leftovers from the previous batch (END packets, etc.).

    To integrate HYDRA into an existing mailer, the same code used for
    the ZedZap session flow can be used, but instead of one transmit and
    one receive session, two transmit sessions (or batches) are used.
    When the HYDRA end of batch is initiated it will not be terminated
    until an end of batch has been received from the remote and the end
    of session sequence has been finished.

    Fido and FidoNet are registered marks of Tom Jennings and Fido
    Software.


    Error detection using CRCs
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    CRC (Cyclic Redundancy Check) values only provide their promised
    maximum error detection capability when properly applied, which
    involves calculating and transmitting low-bit first, presetting the
    CRC with all ones, and transmitting the ones' complement of the
    result. The receiver also initializes to all ones, processes all of
    the data AND the following CRC, and the result should match a "magic
    value" which is 0xf0b8 for the 16-bit CRC and 0xdebb20e3 for the
    32-bit CRC.

    The easiest and fastest way to perform CRC calculations is by using a
    table that does the algorithm's shift-operations in 8-bits at a time.


    CRC-16 error detection
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    16-bit CRC using the CCITT CRC-16 polynomial. This is the default at
    startup, and always used for HEX packets even if both sides are
    capable of handling 32-bit CRCs.

    This CRC-16 is not identical to the one used by the Xmodem and Zmodem
    file transfer protocols. The polynomial is the same
    (X^16+X^12+X^5+X^0 or 0x8408) but the bit-ordering is the opposite,
    and preconditioning and postconditioning is used as in 32-bit CRCs.
    This method is also used by the European version of X.25.

    The 16-bit CRC table is created as follows (pseudocode, the variable
    CRC16 and the table of 256 entries are 16-bit unsigned integers):

        FOR (i=0 TO 255)
            {
            CRC16=i
            FOR (N=1 TO 8)
                {
                IF (CRC16 AND 1)
                    CRC16=(CRC16 >> 1) XOR 0x8408
                ELSE
                    CRC16=CRC16 >> 1
                }
            CRC16TAB[i]=CRC16;
            }

    When processing data, each byte is run through the CRC calculation
    routine as follows (variable CRC stores the 16-bit CRC value/result,
    C is the next 8-bit char):

        CRC=CRC16TAB[(CRC XOR C) AND 0xff] XOR ((CRC>>8) AND 0x00ff)


    CRC-32 error detection
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    32-bit CRC using the CCITT CRC-32 polynomial. Support of CRC-32 is
    optional and signalled in the INIT packet.

    If both sides indicate they can handle CRC-32, all packets except
    those transmitted in HEX format use this algorithm instead of CRC-16
    to improve error detection.

    This CRC-32 is identical to the one used by the Zmodem protocol.
    The polynomial is (0xedb88320):

    X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0

    The principal method of calculation, transmission, and checking is
    identical to CRC-16 as described above, but the "magic value" for
    32-bit CRC is 0xdebb20e3.

    The CRC-32 table is created as follows (pseudocode, the variable
    CRC32 and the table of 256 entries are 32-bit unsigned integers):

    FOR (i=0 TO 255)
        {
        CRC32=i
        FOR (N=1 TO 8)
            {
            IF (CRC32 AND 1)
                CRC32 = (CRC32 >> 1) XOR 0xedb88320
            ELSE
                CRC32 = CRC32 >> 1
            }
        CRC32TAB[i] = CRC32;
        }

    When processing data, each byte is run through the CRC calculation
    routine as follows (variable CRC stores the 32-bit CRC value/result,
    C is the next 8-bit character):

        CRC=CRC32TAB[(CRC XOR C) AND 0xFF] XOR ((CRC>>8) AND 0x00ffffff)


    The authors
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    The authors can be reached at the following addresses:

    Joaquim H. Homrighausen                    Arjen G. Lentz
    389, route d'Arlon                         Lentz Software Development
    L-8011 Strassen                            Langegracht 7B
    Luxembourg                                 3811 BT Amersfoort
                                               The Netherlands
	joho@ae.lu
    FidoNet 2:270/17                           aglentz@fido.lu
                                               FidoNet 2:283/512


    The name HYDRA
    ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    Hydra is a greek mythological creature (the watersnake). Like the
    Nemeic lion, Hydra is the daughter of the giant Typhon and the snake
    Echidna.

    She grew up in the marshes of Lerna near/in Argolis (Argos). There
    she ate entire herds of cattle and destroyed large cropfields. Later,
    she lived in caves on a hill near the spring of Amymone.

    Hydra is a monstrous large snake with nine heads: eight mortal ones,
    and one (the middle one) immortal. She was defeated and killed by
    Heracles (Hercules) - son of Zeus and Alcemene, grandson of Perseus -
    as the second of his twelve tasks, with the help of his cousin
    Iolaos. Every time he cut of one of the heads with his sword, two new
    heads grew in its place. So Iolaos scorched the wound of each cut off
    head with burning branches so the head couldn't grow on again.

    Heracles buried the last and immortal head under a stone nearby. He
    also dipped his arrows in Hydra's poisonous blood, thereafter the
    wounds caused by those arrows were incurable.


    Also star constellation (sign of the watersnake) in the equatorial
    zone.


    Also a type of sweetwater polip (the Hydroidea Thin, tubeshaped body
    can be full contracted, just like the six (or more) tentacles. There
    is no generation change, the gender-products grow directly on the
    body.

    The animals catch their prey with nettlecells, and are very verocious.
    They can be found in various stilstanding and flowing water and were
    first described by Anthonie van Leeuwenhoek in the year 1704.


    Also small island (spelled Idhra in modern Greek) of the Sargonic
    group in the Aegean Sea, just of the eastern tip of the Argolis
    peninsula of the Peloponesus (Attika). Its length (NE/SW) is 21 km,
    with a total area of 49,6 square km. Its highest point is 597 meters
    above sea level. Population of 2794 (latest census: 1981). Only one
    real city with the same name as the island. Once quite wooded and
    well watered, now denuded and dry, with almost no arable land
    (infertile limestone). Certain times of the year the people have to
    ship in water from the main land. Its Turkish name is Camliza which
    means "Place of Pines".

    References:
         Dutch:  Oosthoeks Encyclopedie
                 Grote Winklerprins Encyclopedie
       English:  Encyclopaedia Brittannica

    --- end of "hydra.doc" ---
