@database "The GEM application support library"
@author   "Draco (draco@atari.org)"
@subject  Documentation/Manual
@$VER: gemma.stg (@:"__DATE__")
@options "-s +i +zz"

@node "Main"
@title "The GEM application support library"
@line 1 70 0

@{B}          GEMMA, the GEM application support library@{b}

@line 1 70 0

        License

        I.   Installation

        II.  Function description

             1. Static library interface
             2. Application control functions
             3. Resource file related functions
             4. Environment functions
             5. Windowed dialog management
             6. External event handlers
             7. Alert functions
             8. Process management
             9. AV protocol support
            10. Invoking standard applications
            11. Other support

        III. Library functions listed by opcode

        VI.  Programming

        V.   CHANGES

@line 1 70 0

@endnode

@node "License"

    Gemma, support library for GEM application programs.
    Copyright (C) 1999-2000 Draco/YC

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
    USA.

@endnode

@node "Programming"
Programming
@line 1 70 0

This information is for programmers wishing to use the SLB in own
(gcc) programs. This is pretty straighforward:

I. Headers and static modules

- function prototypes and structure definitions are inside the
  header file gemma.h, which belongs to /usr/include/gemma folder.
  If you #include <gemma/gemma.h>, you do NOT need to include
  gem.h, the usual header for GEM programs.

- definitions needed for an SLB, but not belonging to the Gemma
  library are inside the header file slb.h. This belongs to the
  /usr/include/mint folder and is automatically included by the
  gemma.h header.

- your program, once compiled, must be linked against libgemma.a
  and libslb.a (exactly in this order: -lgemma -lslb). Both
  libraries get built when you type `make' at the top level of the
  directory structure created by unpacking the source archive.
  After the libraries are compiled, you copy the contents of the
  lib/ subdirectory to your /usr/lib.

@{B}libslb.a@{b}
This module is responsible for the actual opening an SLB. It
provides a function called _slbload() which opens the named SLB and
returns on success or prints a brief error message on failure. The
message is displayed via Salert() on MiNT or via Cconws()
otherwise. You do not have to call the _slbload() yourself, it is
done automatically, in appl_open().

@{B}libgemma.a@{b}
This module contains bindings for AES function calls. These
bindings are not the same as in the GEMLib, since here the AES
calls are done via the shared library. Also, this module is
responsible for opening the library - via a call to the _slbopen()
mentioned above - and initializing all the necessary stuff either
inside the libgemma module and inside the shared object. All this
is done by the appl_open() you call at the begin of your program.

II. Other info

- currently there is only support for `-mshort' programs.
- you should provide at least 8k room on the stack for the
  gemma.slb functions.

@line 1 70 0

@endnode

@node "Installation"
Installation
@line 1 70 0

This is my GEM application support library. It mostly consists of
functions I have written while developing bigger or smaller
programs. Since I am lazy and really dislike writing the same code
sequences again and again, I've decided to include all this in a
library. And here it is.

The library upto version 1.04 was written entirely in assembler and
was intended as a support for assembler programs. But it will
probably work for other languages too, particularly for the C
language. Now, since version 1.06 the library development continues
in C - however, in turn, this does not mean that it cannot be used
with programs written in other languages, including assembler.

The backside of the conversion done is, that MagiC users will
probably not be able to use the compiled binary directly. This is
because the gcc only produces binaries in the extended executable
format, and SLBs in this format will probably not be accepted by
MagiC.

The library is (obviously) multitasking safe and memory protection
clean.

@{B}How to install@{b}

Unless otherwise specified in the documentation of a program which
uses the library, the best choice is to put the gemma.slb into a
folder where other such libs live. On my system this is
/usr/local/lib/slb/ (i.e. u:/usr/local/lib/slb) but you can 
obviously choose another location as well.

The folder must be pointed to by the $SLBPATH environment variable.
You define this by adding a line like:

setenv SLBPATH u:/the/path/where/you/keep/libs

to your mint.cnf file. Notice that the FreeMiNT kernel requires it
to be a single pathname, unlike $PATH, which can be a string made
of subsequent pathnames of folders to search by.

If you already have an older version of the gemma.slb in that
folder, you will probably have to replace it with newer one. If the
folder is on a filesystem, which supports 'x-bits' (e.g. minix or
ext2), you also have to set the x flags for each SLB file there or
the system won't load them otherwise.

If you have programs which use the gemma.slb, you should also
install the SMS server, which is a separate program used by the
library for more functionality, when present. The server is
available on the web under the following addresses:

http://draco.atari.org
http://piwo.bl.pg.gda.pl/~draco/falcon.html
http://wh58-508.st.uni-magdeburg.de/~draco/atari.html

Also installing the Assemsoft's StringServer is recommended. The
StringServer can be downloaded at http://assemsoft.atari.org.

If you don't have StringServer installed, it is advised to define
the following environment variables (all, or at least the first
one):

GEMWWW=[here the full path to your WWW browser]
GEMFTP=[the full path to your FTP client]
GEMMAIL=[the full path to the mailer program]
GEMTELNET=[the full path to the telnet program]
GEMNEWS=[the full path to the news reader]
GEMGOPHER=[the full path to the gopher client]

If you don't have some of programs mentioned above, don't worry,
just don't define the variable.

Have fun,
draco@atari.org

Warszawa, December 2000

@line 1 70 0

@endnode

@node "Invoking standard applications"
Invoking standard applications
@line 1 70 0

Almost every system (well, most of them) has several daily programs
of similar or even the same type: a text editor, a text viewer, a
CLI, a web browser et cetera. For a developer working in a
multitasking environment it is extremely handy to have a
standardized way of invoking such useful applications from within a
program instead of being forced to code everything from scratch
each time one needs a viewer.

There is much of this functionality in the desktop's AV protocol,
which e.g. supplies the way of invoking a viewer for any data type
known to the shell application (desktop), see the chapter entitled
AV protocol support somewhere within this document. However, not
everything can be done this way and thus the library provides
methonds to access other applications as well, just to save your
efforts.

@{B}long open_url(char *url)@{b}

Opcode:       40
Function:     execute an appropriate network client handing the
              parameter off to it. The `url' must be a NULL
              terminated string formatted in the normal form of the
              Universal Resource Locator, e.g.:
              http://draco.atari.org. The library recognizes the
              required protocol reading the first part of the URL
              (i.e. the 'http:' in example above) and then executes
              an application associated with the protocol by an
              appropriate environment variable. The variable must
              contain a valid pathname to the program in question.

              Protocol  Variable        Should point to
              --------  --------        ---------------
              http:     GEMWWW=         a web browser application
              file:     GEMWWW=         a web browser application
              ftp:      GEMFTP=         an FTP client
              mail:     GEMMAIL=        an SMTP (mail) client
              news:     GEMNEWS=        a net news client
              nntp:     GEMNEWS=        a net news client
              telnet:   GEMTELNET=      a telnet client
              gopher:   GEMGOPHER=      a gopher client

              Variables should be defined in your n_aes.cnf file
              the following way:

              export GEMWWW=u:\d\net\cab\cab.app

              The application, if found, is started in parallel
              with the calling program.

              Alternatively if the Assemsoft's StringServer is
              installed and up, the `url' string is passed to it
              and evaluated as it is determined by the server
              configuration.

Return value: 0 on success or GEMDOS error code otherwise. Status
              -305 returned by this function means that an unknown
              protocol identifier has been used.

@line 1 70 0

@endnode

@node "AV protocol support"
AV protocol support
@line 1 70 0

The AV protocol mostly serves for communication between programs
and the desktop, and back. The library contains few functions which
perform the most often used (by me) AV commands doing automatically
as much as possible.

Since the memory protection violation is the Typically Encountered
Problem¿ when dealing with AV protocol, because people often don't
understand what they actually should, the library carries all this
automatically as well. That is, no pointer to data given as an
argument is directly passed to the AV server, but instead of that,
the library allocates temporary buffers (with 'Readable' status),
copies the stuff over and then sends. Hence, while using the
library functions, you are allowed to not care about `in what type
of the memory is the pathname I want to use in an AV command'. It
may be private memory and you still don't bother. The buffers
allocated by the library are released after 200 milliseconds, which
is twice as big the time than recommended.

@{B}long av_dir_update(short drive)@{b}

Opcode:       30
Function:     tell the desktop to refresh the contents of a
              directory window for `drive', if one is open. The
              argument is a standard drive code, i.e. 0 for A:, 1
              for B:, 2 for C: and so on.
Return value: 0 on success or GEMDOS error code otherwise.

@{B}long av_view(char *pathname)@{b}

Opcode:       31
Function:     displays the file specified by the `pathname' in an
              external viewer, if such one is installed. The
              argument can be given in one of three forms:

              1) as a single filename: foobar.txt
              2) as a relative path: foo\bar.txt
              3) as a path with leading slash: \foo\bar.txt
              4) as an absolute pathname: c:\foo\bar.txt

              The first two instances are treated as pathnames
              relative to the current working directory of the
              calling program. The third instance is converted to
              an absolute path starting at drive U: (i.e. it will
              be U:\foo\bar.txt). The fourth one is obvious.
              Wildcards like '..' are NOT evaluated.

              Most of the dark work is done by the desktop, i.e. it
              must determine the data type and decide which
              application to run as a viewer. Because of that, for
              this function to properly work, the desktop and the
              AV server must be installed properly.

Return value: mostly 0, but also can be a negative GEMDOS error
              code, like ENOENT when there is no running AV server.

@{B}long av_help(char *filename)@{b}

Opcode:       32
Function:     tries to open the file, whose name has been given as
              a parameter in currently installed help system. When
              N.AES' shel_help() call is available, the parameter
              is passed to it. If shel_help() is not available, it
              is assumed that the help system is ST Guide and
              attempts to communicate with it are made, the
              following way:

              1) if an AV server is installed, the `filename' is
                 passed to it by a VA_START message.
              2) if no AV server is found, but ST Guide is running,
                 the VA_START message is sent directly to it.
              3) if neither action seems possible, the variable
                 STGUIDE= is searched for, and if it is found, the
                 program, whose path is held by the variable, is
                 started up with `filename' given as a parameter.

              When all this fails, the library displays an error
              message to the user.

Return value: 0 or a GEMDOS error code.

@{B}long va_send(short cmd, char *msg, long len)@{b}

Opcode:       33
Function:     send command `cmd' to the AV server. The `msg' is the
              pointer to the command argument (usually a string)
              and the `len' - its length in bytes.
              The `msg' pointer does not have to point to global or
              readable memory (the library copies it over anyway).
Comments:     This function is also used by other AV related
              functions of the library to send commands.
Return value: 0 or a GEMDOS error code (e.g. ENOMEM).

@line 1 70 0

@endnode

@node "Other support"
Other support
@line 1 70 0

Here are other helper functions which may be, and usually are,
useful while writing a GEM application.

@{B}long rc_intersect(GRECT *src, GRECT *dest)@{b}

Opcode:       9
Function:     calculates a 'result rectangle' out of two given as
              arguments. The structure GRECT is defined in gemma.h.
              The function is used (also internally) to decide
              whether a portion of the screen should be redrawn, if 
              WM_REDRAW message was received. The `source' 
              rectangle is the one returned by the AES from the 
              window's rectangle list, whereas the `destination' 
              one is the rectangle specified by the screen manager 
              in the WM_REDRAW message.
Return value: returns 1, if the rectangles intersect, or 0
              otherwise.

@{B}long objc_xchange(WD *window, short obj, short newst, \
                          short redraw)@{b}
Opcode:       15
Function:     the same as the AES' objc_change() call, but the
              clipping is made automatically.
Return value: 0

@{B}long objc_xdraw(WD *window, short obj@{b}
Opcode:       35
Function:     the same as the AES' objc_draw() call, but the
              clipping is automatically made to the work area of 
              the `window', and maximum depth is assumed.
Comments:     This function was previously available as an 
              alternative binding for objc_draw() and has been 
              moved into the library as of version 1.08.
Return value: 0

@{B}char *file_select(char *title, char *mask, ushort flag)@{b}

Opcode:       38
Function:     invokes the system file selector. `title' is the
              string to be taken as the title of the file selector
              window. `mask' is the default file mask.

              When $HOME is defined, the file selector opens by
              default in the directory pointed by that variable, or
              in the application's default directory otherwise. The
              last selection is preserved in the memory until the
              next call to this function (unless `flag' has its
              highest bit set).

Caveats:      the library will run into problems, when the file to
              select has a filename longer than 256 characters, or
              the complete path is longer than 1024 bytes.

Return value: a pointer to the pathname selected, if the user
              clicked OK, or NULL otherwise.

@line 1 70 0

@endnode

@node "Process management"
Process management
@line 1 70 0

@{B}long thread_fork(void *startup, void *address, \
                     char *ptitle, long stacksize)@{b}
Opcode:       13
Function:     spawn a subroutine pointed to by `address' as a
              separate process (thread). The parameter `ptitle' is
              optional and defines the name (displayed by ps) for
              the new process. If this argument is NULL, the parent
              process' name will be used.
              The parameter `stacksize' defines the stack size for
              the new process.
              The parameter `startup' points to the thread startup
              code. Because of memory protection reasons, this is
              normally embedded in the statically linked part of
              the library. This startup code combined with the
              library call is used to provide a binding that does
              not require the `startup' parameter.

              The function automatically registers a signal handler
              for SIGCHLD. This handler reads the result code upon
              child termination and sends a special CH_EXIT message
              to the main application via SMS server, if installed.
              If the SMS server is not installed, this action
              silently fails.

              The thread is created using Pexec(7) and started with
              Pexec(104). Program flags for Pexec(7) are
              automatically copied from the parent process' PROC
              structure. Pexec(7) and subsequent Mshrink() call are
              done under the scope of a semaphore, so that if
              preemption occurs in the process, and another program
              enters the thread_fork() procedure, it will be put to
              sleep until the memory is shrunk and the semaphore is
              released, so that the function wouldn't fail because
              of a temporary lack of memory resources.

Return value: positive process ID (pid) of the thread or a negative
              GEMDOS error code otherwise.

@{B}long proc_exec(short mode, long flags, char *file, \
                        char *cmd, char *env)@{b}
Opcode:       41
Function:     Create a new process according to the parameters.
              The function operates like the Pexec(mode) in GEMDOS,
              except:

              1) for mode value of 0, 3, 100 and 200 the `file'
                 argument specifies the name of an executable file
                 to load. If no path is included, and the file is
                 not found in the current directory, it will be
                 searched in all the folders specified by the $PATH
                 environment variable.
              2) the file specified may be a shell script; in order
                 to execute it the library will invoke the shell as
                 specified in the script. If the script does not
                 contain the full path to the proper interpreter,
                 and only the file name is specified, $PATH
                 searching will be performed before doing anything
                 further.
              3) the `cmd' argument is a pointer to the argument
                 list, which should be passed to the newly created
                 process. Unlike for Pexec(), this must be
                 a normal, NULL terminated C string containing
                 subsequent arguments separated with spaces
                 (arguments which contain spaces themselves should
                 be enclosed in quotes). This string is NOT limited
                 in length to 126 bytes.
              4) in order to be able to pass long argument list the
                 library constructs the ARGV= list in the
                 environment of the process to be created.

              For all other modes (4, 6, 104, 106, 204, 206, ...)
              all arguments (except `flags') should conform to the
              values defined by the appropriate system
              documentation.

              If the bit 0 of the `flags' argument is set to 1, the
              new process will be executed with its standard output
              stream redirected to NULL.

Return value: like in P_exec().

@line 1 70 0

@endnode

@node "Alert functions"
Alert functions
@line 1 70 0

Alerts are currently modal, but it is planned to change that into
nonmodal type in future versions of the library.

@{B}long windial_alert(short button, short string)@{b}

Opcode:       14
Function:     display an alert box. `string' is an RSC index of a
              free string to be displayed as an alert box. The
              string SHOULD be formatted as for an alert box (e.g.
              exactly like the Interface program does when
              formatting alert trees).
Return value: the number of the button clicked.

@{B}void windial_error(long error, char *message)@{b}

Opcode:        18
Function:      display an "error" alert box with a text appropriate
               for the `error' parameter value (e.g. when `error'
               is -2, the message will say "Resource busy"). The
               `error' value should be negative, exactly as
               returned by GEMDOS. These messages are provided by 
               separate library called `error.slb'.
               The second argument is optional and ignored when its
               value is -1. Otherwise it is treated as a pointer
               to a free string, which will be displayed in
               addition to the normal error message. The string
               should not be formatted as for an alertbox (the
               library does all necessary formatting) and should
               not exceed 40 characters in length. When it is
               necessary to split the message into two lines, you
               should use the "|" character for line break.

@line 1 70 0

@endnode

@node "Static library interface"
Static library interface
@line 1 70 0

This is a group of functions that directly interfaces the program
to the shared library, hence they are the corner stone of the
library bindings.

@{B}GEM_ARRAY *gem_control(void)@{b}

Opcode:       0
Function:     return a pointer to the application control array.
              The array is defined as follows:

              typedef struct {
                long  aesparams[6];
                short control[16];
                short global[16];
                short int_in[16];
                short int_out[16];
                long  addr_in[16];
                long  addr_out[16];
                long  vdiparams[5];
                short contrl[12];
                short intin[128];
                short ptsin[128];
                short intout[128];
                short ptsout[128];
                short vwk_handle;
                long  vwk_colors;
              } GEM_ARRAY;

              The global[0] contains the AES version number encoded
              on four decimal digits: 0x0410 = 4.10. This number is
              internally used by the library to decide whether the
              appl_getinfo() call is available or not. It is
              assumed that if the AES version is below 4.0, the
              appl_getinfo() is not available (see Atari specs).

              The library is basically designed to work in a
              multitasking system and with AES version >= 4.0. It
              was not tested with old AESes.

              The field `vwk_handle' contains the current VDI
              handle for the virtual workstation open in a result
              of the appl_open() call. The `vwk_colors' field
              contains the number of colors displayable at one
              time. This number is not necessarily a precise one,
              specifically for true colour displays it will contain
              a value of 65536 (0x00010000).

              Since this function makes GEMDOS calls, it has been
              separated from the call_aes() to reduce GEM call
              overhead.

Caveats:      The GEM_ARRAY structure contains more (undocumented)
              fields used internally by the library.

Return value: a pointer to the application control array.


@{B}short call_aes(GEM_ARRAY *control, short function_number)@{b}

Opcode:       1
Function:     call an AES function. The `control' parameter is
              identical with the pointer returned by the
              gem_control() function above.
Caveats:      all AES calls the program does should be done via
              this function. Otherwise the library may not work
              correctly.
Return value: int_out[0] or ENOSYS, if the `function_number'
              parameter is out of the defined range.

@line 1 70 0

@endnode

@node "Application control functions"
Application control functions
@line 1 70 0

@{B}long appl_open(char *rscfile, short thread, char *pname)@{b}

Opcode:       17
Function:     First the application is switched into MiNT domain
              and registered in the AES with appl_init() call. When
              the parameter `thread' is zero, and the parameter
              `rscfile' is nonzero, it is treated as a pointer to a
              valid GEMDOS pathname of the GEM resource file to be
              loaded. When the parameter `thread' is nonzero, the
              `rscfile' pointer is ignored, and a previously loaded
              (by the parent process) resource file is utilized. It
              will only work, if the parent process has really
              loaded an RSC file via either appl_open() or
              rsrc_xload() call, and if the child shares the memory
              with him.

              If an error occurs while loading the RSC, the
              application registration gets cancelled by a call to
              appl_exit().

              The parameter `pname' is the application's name for
              the "Desk" menu. If this is -1, the parameter is
              ignored. If its value is below 65536, it is
              understood as a resource index of a free string in
              the resource file just loaded. Contrary, if it is
              greater than 65535, it is understood as an address of
              a free string which should be taken as the
              application's name.

              When the action above succeeds, the AES is
              additionally told the application recognizes the
              AP_TERM message and a basic VDI virtual workstation
              is open.

Return value: AES application ID on success, or a negative error
              code otherwise.

@{B}long appl_top(void)@{b}

Opcode:       25
Function:     Top the application, if possible.
Return value: 0 on success or a negative error code otherwise
              (currently this is ENOSYS standing for "invalid AES
              function call").

@{B}long appl_close(void)@{b}

Opcode:       39
Function:     Closes the virtual workstation that was open by
              appl_open(), releases the resource file (if loaded)
              by a call to rsrc_xfree() and leaves the GEM with
              appl_exit().
Return value: currently always 0 (success).

@line 1 70 0

@endnode

@node "Resource file related functions"
Resource file related functions
@line 1 70 0

@{B}long rsrc_xload(char *rscfile)@{b}

Opcode:       10
Function:     Cache the specified GEM resource file in the memory.
Caveats:      This is a custom library call, you cannot use
              rsrc_load() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xalloc(void)@{b}

Opcode:       11
Function:     Fixup the raw RSC file previously cached by the
              rsrc_xload() call.
Caveats:      This is a custom library call, you cannot use
              rsrc_rcfix() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xfree(void)@{b}

Opcode:       12
Function:     Release the RSC file previously loaded with
              appl_open() or rsrc_xalloc().
Caveats:      This is a custom library call, you cannot use
              rsrc_free() instead.
Return value: 0 on success or a negative error code otherwise.

@line 1 70 0

@endnode

@node "Environment functions"
Environment functions
@line 1 70 0

@{B}char *env_get(const char *variable)@{b}

Opcode:       21
Function:     Finds the specified variable in the application
              environment string. The variable name (pointed to by
              the argument) must be a NULL terminated string ended
              with the "=" character. For example, to find the
              value of the $HOME, the function call should look as
              follows:

                char *home;

                home = env_get("HOME=");

              The returned value specifies the variable litterally
              as it is defined in the environment, no conversion or
              evaluation is made.
Return value: a pointer to the variable value or NULL, if the
              specified variable does not exist.

@{B}char *env_eval(const char *variable)@{b}

Opcode:       22
Function:     This is similar to the env_get(), except that the
              variable, if found, is additionally processed as
              indicated by the $UNIXMODE variable.

              Furthermore, each variable is evaluated, so that a
              part of it (or an entire variable) can be defined by
              another one. For example, for a definition like:

                setenv HOME u:\root
                setenv MYDIR $HOME

              the $MYDIR will be evaluated and returned as
              `u:\root'. Similarly, if you define

                setenv HOME u:\root
                setenv MYDIR $HOME
                setenv DEFAULTS $MYDIR\defaults
                setenv CONFIGFILE $DEFAULTS\config.inf

              the env_eval("CONFIGFILE=") will return
              `u:\root\defaults\config.inf', whereas env_get()
              only returns `$DEFAULTS\config.inf' in this case.
Caveats:      - the recursion depth is limited to 64 levels.
              - the maximum recursion depth requires about 16k free
                stack space, and you should provide at least this
                much in case there is a circular reference between
                variables.
              - variables $PCONVERT and $UNIXMODE cannot be defined
                indirectly, because their values are used as
                arguments for the evaluation (references to other
                variables found in these two are ignored).
              - the variable $SLBPATH cannot be defined this way,
                because it is evaluated by the kernel and the code
                dealing with that is not so intelligent, for the
                sake of speed.
Return value: a pointer to the result string on success or NULL on
              failure.

@{B}long env_getargc(void)@{b}

Opcode:       23
Function:     returns the number of ARGV arguments. The old MS-DOS
              style command line is not supported.

@{B}char *env_getargv(long argc)@{b}

Opcode:       24
Function:     returns a pointer to the ARGV argument number `argc',
              or NULL, if there is no such argument. The old MS-DOS
              style command line is not supported.

@line 1 70 0

@endnode

@node "Windowed dialog management"
Windowed dialogs
@line 1 70 0

Routines for creating and managing windowed dialogs are the corner
stone of the library. In most cases, an application must only
provide memory for the WD structure which contains all the
information needed by the library to properly handle a window. The
structure is completely filled in and managed by the library so
that in most cases the programmer does not have to worry on the
sturcture's contents. The structure is defined by the source files
supplied along with the library.

@{B}long windial_size(void)@{b}

Opcode:       2
Function:     returns the minimum size of the WD structure for a
              single windowed dialog box. Your program should
              provide at least this much for each window it needs
              to create. It is guaranteed that the number returned
              by this function is the same for all dialog boxes the
              program needs to create - it only can be different
              across different versions of the lib.

@{B}long windial_create(WD *window, short box, short icon, \
                         short ftext, char *title)@{b}

Opcode:       3
Function:     initializes the window structure in the memory buffer
              pointed to by the `window' parameter. If the `window'
              is NULL, the function will first allocate the needed
              memory buffer (freed later by the windial_delete()
              function), though it is not an optimal choice.
              `box' is the resource index of the dialog box object
              tree. This parameter is obligatory.
              `icon' is the resource index of the icon object tree.
              If this parameter is 0, the dialog box won't have the
              iconifier gadget and no iconification will be
              possible.
              `ftext' is the resource index of the first editable
              textfield found in the object `box'. If there are no
              editable textfields in the box, the parameter should
              be 0.
              `title' is a pointer to a free string which will be
              used as the window's title displayed on its title
              bar. When no title is required, the pointer should
              point to an empty string (""), but also may be -1.
              When this parameter's value is below 65536, it is
              understood as a resource index of the RSC file loaded.

              Exactly like the AES function wind_create(), this one
              does not display any window. After a successful
              return, the structure WD initialized by the function
              can be manipulated so that the subsequent
              windial_open() call will display the window e.g. in
              an arbitrary location rather than the default one.

Return value: returns a pointer to the WD structure, or 0 if the
              function failed.

@{B}long windial_open(WD *window)@{b}

Opcode:       4
Function:     opens the windowed dialog box as defined by the
              parameter.
Return value: currently 0 (success).

@{B}long windial_formdo(WD *window)@{b}

Opcode:       5
Function:     similarly to the AES' form_do(), the function is
              monitoring the user interaction with the dialog box,
              or dialog boxes, if multiple are displayed at a time.
              Window events, like move, iconify, uniconify, full,
              top, untop etc. and also editable textfields, are
              handled automatically inside the library without
              arranging the main application.
Return value: the returned longword contains the resource index of
              the object clicked in the low word and the resource
              index of the object tree where the object belongs to
              in the high word. If the user clicked the closer
              gadget, a value of -1 is returned for the object
              index.
              When your program only displays one dialog at a time,
              the high word can be safely ignored.
Caveat:       if windial_setjmp() was used to define an alternative
              event handler, this function may never return.

@{B}long windial_close(WD *window)@{b}

Opcode:       6
Function:     closes the specified window. The window's structure
              in the memory is not released so that it can be
              reopened by windial_open().
Return value: currently 0 (success).

@{B}long windial_delete(WD *window)@{b}

Opcode:       7
Function:     deletes the specified window. The window's structure
              in the memory is released so that it cannot be
              reopened by windial_open() without a previous call to
              windial_create().
Return value: currently 0 (success).

@{B}long windial_center(WD *window)@{b}

Opcode:       8
Function:     performs the window positioning at the centre of the
              screen.
Return value: currently 0.

@{B}long windial_dup(WD *old, WD *new)@{b}

Opcode:       19
Function:     duplicates a window defined by the `old' parameter
              and initializes the `new' structure, so that the
              `new' window being a copy of the `old' one can be
              opened with windial_open() without a separate call to
              the windial_create(). As with windial_create(), the
              `new' parameter can be NULL and in such a case the
              required memory will be allocated automatically.
              When both windows are opened simultaneously, the
              windial_formdo() routine handles both.
Return value: 0 on success or a negative error code otherwise.

@{B}long windial_link(WD *from, WD *to)@{b}

Opcode:       20
Function:     two windows created independently with two separate
              windial_create() calls are linked together, so that
              the windial_formdo() routine can automatically switch
              from one to another handling them both as necessary.
Return value: 0 on success or a negative error code otherwise.

@{B}long windial_unlink(WD *window)@{b}

Opcode:       27
Function:     unlinks the specified window from the linked list
              created by windial_link(). The window's structure is
              simultaneously invalidated, so that it cannot be
              linked back. For this reason it is more advisable to
              use windial_delete(), which performs unlinking
              automatically.
Return value: currently 0. In case of an error the function
              silently fails.

@line 1 70 0

@endnode

@node "External event handlers"
External event handlers
@line 1 70 0

Here are functions which allow you to intercept and modify the
operation of the event handlers provided by the library.

@{B}long windial_setjmp(WD *window, short vec, void *adr)@{b}

Opcode:       26
Function:     registers an external handler for events which are
              not handled internally by the library. This is mainly
              intended for the AP_TERM and VA_START messages, but in fact
              any type of the standard GEM events can be intercepted this
              way. Each window can have own separate subset of such
              handlers (or can have none).
              The `vec' parameter contains the "vector number" for
              the required type of events. Currently these vectors
              are defined as follows:

              Vec       Handling
              ---       --------
               0        AES messages
               1        keyboard events
               2        mouse button events
               3        mouse rectangle events
               4        alternative mouse rectangle events
               5        timer events

              Of that number, handlers 0 and 1 are local for each
              window (i.e. each window can have different handler),
              whereas handlers 2-5 are global for all windows.
              The parameter `adr' is the new value of the vector
              `vec', i.e. the entry point for the new handler.

              The point defined by this argument *** MUST *** find
              itself in the same stack context as the initial call
              to the windial_setjmp() was, or else stack corruption
              may occur.

              The handler setup by this function is called before
              (if at all) the associated event is handled by the
              library routines, and accepts stacked arguments:

              Vec       Handler prototype
              ---       -----------------
               0        long newmsg(WD *wd, short vec, (void *)msg)
               1        long newkey(WD *wd, short vec, short ks, \
                                                        short kc)
               2        (not yet defined)
               3        (not yet defined)
               4        (not yet defined)
               5        long newtmr(WD *wd, short vec, long timer)

              Where `wd' is a pointer to the structure of the
              window, that generated the event (undefined for
              handlers 2-5), `vec' is the vector number, `msg' is
              a pointer to the AES message buffer, `ks' is a word
              containing the state of the keyboard shift keys, `kc'
              is the keycode and `timer' is the start value of the
              evnt_timer().

              The handler once entered and has done what was
              supposed necessary, may behave three ways. First, it
              can just return with a long value of 0 in the d0
              register, which means it wishes the event to be
              further processed by the library routines. In an
              opposite case, when no further processing is
              required, a long value of -1 should be returned.

              The keyboard handler has an additional function here:
              if the returned value is greater than a zero, it is
              interpreted as the new keycode. After return to the
              library, its routines do further processing using the
              code returned.

              Eventually, the windial_longjmp() may be called, which
              performs an exit from the event loop and jumps back
              here to return to the program exactly at the same
              point where the windial_setjmp() was originally
              called.

Return value: 0 on success or EINVAL when invalid argument was
              specified (particularly `vec' is out of range) while
              setting the jump. While returning from
              windial_longjmp() this function returns 1.

@{B}void windial_longjmp(WD *window, short vec)@{b}

Opcode:       28
Function:     returns from the event handler (see above), restores
              the stack context to the state recorded by the
              windial_setjmp() call, then jumps back to the
              windial_setjmp() function.
              The function of this call is similar to the operation
              made by the sigreturn() and longjmp() when returning
              from kernel signal handlers.
Return value: this function never returns.

@line 1 70 0

@endnode

@node "Library functions listed by opcode"
Library functions listed by opcode
@line 1 70 0

Opcode          Function prototype
------          ------------------
  0             GEM_ARRAY *gem_control(void)
  1             long call_aes(GEM_ARRAY *ctrl, short opcode)
  2             long windial_size(void)
  3             long windial_create(WD *window, short box, short icon, \
                                    short ftext, char *title)
  4             long windial_open(WD *window)
  5             long windial_formdo(WD *window)
  6             long windial_close(WD *window)
  7             long windial_delete(WD *window)
  8             long windial_center(WD *window)
  9             long rc_intersect(GRECT *src, GRECT *dest)
  10            long rsrc_xload(char *filename)
  11            long rsrc_xalloc(void)
  12            long rsrc_xfree(void)
  13            long thread_fork(void *stub, void *func, char *ptitle, \
                                 long stksize)
  14            long windial_alert(short button, short object)
  15            long objc_xchange(WD *window, short obj, short newst, \
                                    short redraw)
  16            void *rsrc_xgaddr(short type, short object)
  17            long appl_open(char *filename, short thread, char *pname)
  18            long windial_error(long error, char *usermsg)
  19            long windial_dup(WD *old, WD *new)
  20            long windial_link(WD *from, WD *to)
  21            char *env_get(char *var)
  22            char *env_eval(char *var)
  23            long env_getargc(void)
  24            char *env_getargv(short argc)
  25            long appl_top(void)
  26            long windial_setjmp(WD *window, short vec, void *adr, \
                                        void *link)
  27            long windial_unlink(WD *window)
  28            void windial_longjmp(WD *window, short vec)
  29            void ftext_init(short tree, short obj)
  30            long av_dir_update(short drive)
  31            long av_view(char *pathname)
  32            long av_help(char *filename)
  33            long va_send(short cmd, char *msg, long len)

  35            long objc_xdraw(WD *window, short object)
  36            long thread_overlay(void *stub, void *func, \
                                        char *ptitle, long stksize)
  37            long menu_xpop(WD *window, short obj, MENU *menu)
  38            char *file_select(char *title, short flag)
  39            long appl_close(void)
  40            long open_url(char *url)
  41            long proc_exec(short mode, long flags, \
                                char *file, char *cmd, char *env)
@line 1 70 0

@endnode

@node "CHANGES"
CHANGES
@line 1 70 0

TODO:

- finally do the multidialog support, as advertised
- code the nonmodal alerts
- add font selection support
- support the xrsrc
- emulate whitebak objects where not directly supported

Version 1.08 pl 3

- removed the internal list of system errors and converted into a 
  separate library `error.slb', which is loaded when necessary.
- appl_open() now first searches $HOME directory for the RSC file.
- bit 2 of the flag parameter to appl_open() now added
- fixed a bug that made loading extended RSC files impossible
- added some debug blurp here and there
- added pathname conversion to the internal DOS functions

Version 1.08 pl 2

- fixed bug in objc_xchange()
- fixed possible inconsistency in the users count
- reduced number of casts, passim (a NULL pointer is also a pointer)
- new icons for alert boxes are available as of AES 4.10, not 4.0
- added a pointer to the begin of the window chain to the internal
  application structure
- minor bugfixes
- zeroing the `icon' parameter for windial_create() didn't disable 
  the iconifier gadget, fixed now.

Version 1.08 pl 1

- appl_open() now changes the mouse shape to arrow.
- added appl_getinfo() emulation done so that the function can be 
  safely called on AES < 4.0 as well. Especially the emulation 
  indicates features introduced to the AES 3.30 and 3.31 (Falcon 
  TOS has AES 3.40).
- fsel_exinput() may be called on AES < 1.40 (fsel_input() is 
  invoked)
- added appl_yield() emulation.
- added function number 36, thread_overlay().
- fixed all (?) bugs in proc_exec()
- env_getargc() and env_getargv() implemented.
- internal AES calls redirected through emulation code in callout.c 
  (new file). Calls to graf_growbox() etc. can be filtered out 
  before reaching the AES, there is pointer verification etc.
- the objc_xdraw() converted to a macro and moved into the lib as 
  function number 35.
- added config.h file containing compile-time options.
- added form_popup() emulation.
- corrected some typos here and there

Version 1.07

- added function number 41, proc_exec()
- env variable names for open_url() changed to avoid conflicts with
  text based, or other gui based applications.

Version 1.06

- the entire library has been rewritten in C and compiled with
  gcc 2.95.2.
- all functions have been extended with an additional parameter.
  The application can now maintain the pointer to its GEM_ARRAY and
  pass it to the library along with other function parameters. This
  allows to greatly reduce the function call overhead inside the
  library.
  This extension is compatible with previous versions of the
  library. Programs compiled for the last assembler version of the
  gemma.slb (i.e. 1.04) should still work.
- internal reorganization and revision for all of the code allowed
  to reduce function overhead, memory requirements, and also to do
  many bugfixes here and there.
- windial_alert() now accepts char * as the second parameter. This
  extension is compatible with previous versions of the library:
  when no third parameter is passed, the old calling style is
  assumed and the arguments are adjusted appropriately.
- all functions now return EACCES when no appl_init() was called
  before.
- removed redundant code in windial_center()
- the WINDIAL structure (one copy) is now integrated into the
  internal application structure maintained by the library and
  automatically assigned to the first windowed dialog the program
  creates without assigning it a predefined memory block. This
  saves some memory in case of programs which display only one
  window.
- the `mask' parameter for file_select() is no longer ignored,
  neither is `flag'.
- bugfixes in initialization of the object tree for screen modes
  with less than 16 colours (should be recursive though)
- fixed bug in av_dir_update(), the AES version number instead of
  the sender apid was sent to the AV server :>
- operations on window objects, when it is iconified, should work
  now.
- added functions: va_send(), get_users(), get_version().

Version 1.05 is skipped

Version 1.04

- editable text fields can be now activated with a mouse click
- windial_create() now automatically initializes editable text
  fields starting from the object given as the first field.
- call_aes() expanded to recognize N.AES calls objc_xfind(),
  graf_multirubber(), form_popup().
- windial_create() now recognizes additional parameter defining
  gadgets. The alternative binding for C is named windial_xcreate().
- call_aes() now recognizes MagiC wdlg_*() calls (but they aren't
  emulated).

1.XI.2000.

- rsrc_xgaddr() now goes through the common calling sequence, and
  all internal calls to rsrc_gaddr() go through rsrc_xgaddr().
- memory page size is now read from the system, if this is
  impossible, 8k is assumed.
- rsrc_xalloc() now checks whether the functions it uses are
  present and supported by the AES.
- some functions verify input addresses before calling the AES.
  This is to prevent the AES from bombing down when an invalid
  address is specified. Since the verification is done by touching
  the address, the faulty process will die, but the system will
  survive.
- fixed a bug that made programs crash when rsrc_rcfix() was not
  present, the library clients now less or more work under XaAES.
- windial_error() was full of nasty bugs and I am surprised it
  worked at all.
- introduced vertical positioning compensation, depending on a flag
  in the header.

Version 1.03

- fixed bad bug related to iconification
- included VDI support, appl_open() now opens the VDI
- appl_close() function added.
- appl_open() now does menu_register()
- functions preserve all registers, this solves problems with gcc
  programs.
- appl_open(), windial_create() and windial_error() now
  automatically convert RSC indexes into addresses for free strings
  given as parameters.
- made windial_setjmp() & windial_longjmp() calls
- added fileselector support
- more bugfixes
- appl_open() returns all errors to the caller again
- fixed wrong definition of the call_aes() in gemma.h
- fixed a bug in the event handler that caused the library to loss
  keystrokes sometimes.

Version 1.02

- added functions ftext_init(), av_dir_update(), av_view(),
  av_help(), open_url()
- redefined the order and number of the stacked arguments passed to
  the external event handlers (this breaks compatibility with
  previous versions).
- added handling external handler vector 5 (evnt_timer)
- memory allocations done by the library are now under the scope of
  a semaphore (the same one as in thread_fork())
- removed separator conversions in paths, this is not required by
  MiNT and not necessary on other systems.
- appl_open() now switches into MiNT domain and registers AP_TERM
  message in the system.
- added StringServer support.
- appl_open() now displays a message and terminates the program, if
  appl_init() fails.
- removed an unused buffer

Version 1.01

- various tests and bugfixes

Version 1.00

- initial version, quite buggy and limited.

@line 1 70 0

@endnode
