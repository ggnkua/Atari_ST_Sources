



          ***************************************************************
         *****************************************************************
        ****                                                           ****
        ***                                                             ***
        ***               XXXXXXXXX  XXXXXXXXX  XXXXXXX                 ***
        ***               XXXXXXXXX  XXXXXXXXX  XXXXXXXX                ***
        ***               XXX        XXX        XXX   XXX               ***
        ***               XXX        XXX        XXX   XXX               ***
        ***               XXX        XXX        XXX   XXX               ***
        ***               XXXXXX     XXXXXX     XXXXXXXX                ***
        ***               XXXXXX     XXXXXX     XXXXXXX                 ***
        ***               XXX        XXX        XXX XXX                 ***
        ***               XXX        XXX        XXX  XXX                ***
        ***               XXX        XXX        XXX   XXX               ***
        ***               XXX        XXX        XXX    XXX              ***
        ***                                                             ***
        ***                                                             ***
        ***                    XXXXXXX         XXXXX     XXXXXXX        ***
        ***                   XXXXXXXXX       XXX XXX   XXXXXXXXX       ***
        ***                   XXX   XXX      XXX   XXX  XX    XXX       ***
        ***                         XXX      XXX  XXXX        XXX       ***
        ***                       XXXX       XXX X XXX      XXXX        ***
        ***        XXX   XXX      XXXX       XXX X XXX      XXXX        ***
        ***        XXX   XXX        XXX      XXX X XXX        XXX       ***
        ***        XXX   XXX        XXX      XXXX  XXX        XXX       ***
        ***         XXX XXX   XXX   XXX      XXX   XXX  XXX   XXX       ***
        ***          XXXXX    XXXXXXXXX  XX   XXX XXX   XXXXXXXXX       ***
        ***           XXX      XXXXXXX   XX    XXXXX     XXXXXXX        ***
        ***                                                             ***
        ****                                                           ****
         *****************************************************************
          ***************************************************************



          ***************************************************************
         *****************************************************************
        ****                                                           ****
        ***   Mailbox-File-Fraktionierer,  Version 3.03  (11.12.1991)   ***
        ***                                                             ***
        *** Zerteiler fÅr Mitschriften aus beliebigen Mailboxen.        ***
        ***                                                             ***
        *** FFR - erkennt die Files der Kodierer 7PLUS, 7BIT, LCPLUS,.  ***
        ***       RADIX95,UUENCODE, UUXFER und speichert sie unter      ***
        ***       ihren korrekten Filenamen. Beliebige weitere Kodierer ***
        ***       sind konfigurierbar.                                  ***
        ***     - erkennt persînliche Mails.                            ***
        ***     - ist an praktisch alle Mailboxsysteme anpassbar.       ***
        ***     - hilft bei der Verwaltung grosser Mailbox-Mitschriften.***
        ***                                                             ***
        ***                                                             ***
        *** Author:         Axel Bauda           (DG1BBQ @DB0CL.DEU.EU) ***
        ***                 Potsdamer Str.43                            ***
        ***         D-w2850 Bremerhaven 21                              ***
        ***                                                             ***
        *** FFR ist HAMWARE und darf nur kostenlos und VOLLSTéNDIG      ***
        *** weitergegeben werden.                                       ***
        ****                                                           ****
         *****************************************************************
          ***************************************************************


        Inhalt:
        Inhalt:
        _______

        1. Schnellstart.................................................  3
             1.1 Vorgeschichte..........................................  3
        2. Wozu dient FFR?..............................................  3
        3. Arbeitsweise von FFR.........................................  4
             3.1 Header.................................................  4
             3.2 Prompts................................................  5
             3.3 Kodiererfiles..........................................  5
        4. Namensformate der von FFR erzeugten Files....................  6
             4.1 Filenamen bei allgemeinen Nachrichten..................  6
             4.2 Filenamen bei persînlichen Nachrichten.................  6
        5. Bedienung....................................................  7
             5.1 Kommandozeilensyntax...................................  7
             5.2 Kommandos..............................................  7
             5.3 Rubrik/Bereich.........................................  7
             5.4 Optionen...............................................  8
             5.5 Suchbegriffe........................................... 10
             5.6 Beispielaufrufe........................................ 10
        6. Konfiguration................................................ 11
             6.1 Rufzeichendefinition................................... 11
             6.2 Festlegung der Ausgabepfade............................ 12
             6.3 Monatsbezeichner....................................... 13
             6.4 Prompts (allgemein).................................... 14
                  6.4.1 Prompts im 'prompts {}'-Block................... 14
                  6.4.2 Prompts im 'header {}'-Block.................... 15
                  6.4.3 Prompts und das eigene Rufzeichen............... 15
             6.5 Das File-Lese-Fenster.................................. 15
             6.6 Header-Definition ('header {}'-Block).................. 15
                  6.6.1 Struktur des 'header {}'-Blocks................. 16
                  6.6.2 Quicktest....................................... 17
                  6.6.3 Header-Test..................................... 17
                  6.6.4 LÑnge des Headers............................... 17
                  6.6.5 Formate zum Lesen von Rubrik/Absender/Datum..... 18
                  6.6.6 Datumstyp....................................... 18
                  6.6.7 Boxspezifische Prompts.......................... 18
             6.7 Kodierer-Definition ('code {}'-Block).................. 18
                  6.7.1  Struktur des 'code {}'-Blocks.................. 19
                  6.7.2  Quicktest...................................... 19
                  6.7.3  Header-Test.................................... 20
                  6.7.4  LÑnge des Headers...............................20
                  6.7.5  Name des kodierten Files....................... 20
                  6.7.6  Nummer des Teils............................... 20
                  6.7.7  Gesamtanzahl der Teile......................... 21
                  6.7.8  Bildungsformate fÅr den Filenamen.............. 21
                  6.7.9  Ende-Test...................................... 22
                  6.7.10 Extension inkrementieren....................... 22
                  6.7.11 File-Typ....................................... 23
        7. Muster-Erkennungsformate..................................... 23
             7.1 Zeichenweise PrÅfung von Zeichenketten (<String>)...... 23
             7.2 PrÅfung von Zeichenketten per Formatstring (<Format>).. 24
             7.3 Lesen von Informationen aus einer Zeile................ 25
             7.4 Aufbau von Formaten.................................... 26
                  7.4.1 Mîgliche Typen.................................. 26
                  7.4.2 Format zum Test auf Leerzeile................... 26
             7.5 Formate fÅr die Ausgabe von Filenamen.................. 27
        8. Nachtrag..................................................... 27
        9. Weitergabe von FFR........................................... 28
        10. Bezug von FFR............................................... 28



        1. Schnellstart
        1. Schnellstart
        _______________

        Wer einfach nur mit FFR arbeiten und sich nicht mit der Konfigu-
        ration befassen mîchte, kann die Abschnitte 6.1 bis einschliesslich
        7.5 getrost auslassen.

        Besonders mîchte ich die genaue LektÅre von Abschnitt 5 ans Herz
        legen, um unnîtigen Nachfragen vorzubeugen.


        1.1 Vorgeschichte
        1.1 Vorgeschichte
        _________________

        Beim heftigen Packet-Betrieb ergab sich immer wieder das Problem,
        dass die Mitschriften aus den Mailboxen solche Ausmasse annahmen,
        dass sie einfach nicht mehr editierbar waren. So entstand bereits
        1987 auf meinem C128 ein Programm namens MBPRINT.
        Es war in der Lage die Header von Nachrichten in einer Mitschrift
        zu erkennen, die Nachrichten wahlweise auf dem Bildschirm, Drucker
        oder in eine Datei auszugeben. MBPRINT war in BASIC geschrieben und
        brachte trotz kompilierter Form keine allzu befriedigende Geschwin-
        digkeit. Eine Umsetzung in Assembler war mir zu mÅhsam, so dass ich
        das Projekt damals nicht weiter verfolgte.

        WÑhrend meiner Zeit bei der Marine arbeitete ich unter UNIX und
        lernte zwangslÑufig die Programmiersprache C, etwas, dass ich schon
        lange vorhatte, aber mangels vernÅnftiger Compiler fÅr den C128
        nicht in die Tat umsetzen konnte.

        Nun hatte ich in C hineingeschnuppert und kam nicht wieder davon
        los, so dass ich mir einen PC zulegte und einen C-Compiler! Da ich
        den PC auch fÅr Packet nutzte, ergab sich auch dort das Problem,
        grosse Mailbox-Mitschriften zu verarbeiten. Ich erinnerte mich an
        mein altes Projekt vom C128 und damit war FFR geboren, denn endlich
        hatte ich die passenden Werkzeuge um die Idee effektiv umsetzen zu
        kînnen.


        2. Wozu dient FFR?
        2. Wozu dient FFR?
        __________________

        Wer viel aus Mailboxen ausliest, weiss, dass das Nachbearbeiten der
        ausgelesenen Nachrichten recht viel Zeit in Anspruch nehmen kann.
        Bei sehr grossen Mitschriften ergibt sich darÅber hinaus das Pro-
        blem, dass sie mitunter nicht mehr mit den Åblichen Editoren bear-
        beitet werden kînnen.

        Um die Bearbeitung von Mitschriften aus Packet-Radio-Mailboxen so-
        weit wie mîglich zu vereinfachen, wurde FFR geschaffen.

        Jeder kennt bestimmt die folgenden Situationen:
        _______________________________________________

        Die noch vertretbare Methode:

        Man liest eine ganze Reihe von Nachrichten aus der Mailbox aus und
        speichert gleichzeitig auf Disk mit. Nach der 'Sitzung' kommt das
        grosse Editieren, um die Nachrichten aus dem Savefile zu extrahie-
        ren, die man gerne archivieren mîchte. Also 'rein in den Editor,
        Block markieren, Namen ausdenken, abspeichern usw.. Das gleiche
        gilt fÅr evtl enthaltene Files der bekannten Kodierer: Editieren,
        abspeichern (wie war das nochmal mit den Filenamen von Kodierer XYZ
        bei gesplitteten Files?).


        .. oder:
        ________

        Die vîllig indiskutable Methode:

        Man liest Nachricht fÅr Nachricht aus der Mailbox aus und îffnet
        jeweils ein extra File und schliesst es wieder, wenn die Nachricht
        durch ist. Nacheditieren muss man aber unter UmstÑnden auch hier,
        wenn Kodiererfiles enthalten sind. Dies gilt besonders bei gesplit-
        teten Files, da diese in der Regel vom entsprechenden Kodierer in
        einem bestimmten Format erwartet werden.

        Genau um diese Arbeiten zu vereinfachen, gibt es FFR!

        Findet FFR z.B. beim Zerteilen einer Mitschrift einen Eintrag der
        Rubrik IBM vom 1.11.91, so wird dessen Inhalt in ein separates File
        namens IBM01.B01 geschrieben. Ist in dem Eintrag ein Kodiererfile
        enthalten, so wird dieses getrennt und mit einem dem Kodierer ent-
        sprechenden Namen abgespeichert. Findet FFR noch einen Eintrag der
        Rubrik IBM vom selben Tag, so schreibt er dessen Inhalt in
        IBM02.B01 usw...

        Anschliessend ist es dann leicht, mit Hilfe von verbreiteten Bedie-
        nungsoberflÑchen (Norton Commander, PC Tools usw) die Files auszu-
        sondern, die man behalten mîchte.


        3. Arbeitsweise von FFR
        3. Arbeitsweise von FFR
        _______________________

        Als Grundlage fÅr die Identifizierung der verschiedenen Datentypen
        dient die Konfigurationsdatei, in der alle notwendigen Mustererken-
        nungsformate definiert werden kînnen. FFR ist damit gegenÅber sei-
        nen Vorversionen, die nur DieBox-kompatible Mailboxen unterstÅtz-
        ten, sehr flexibel geworden und kann an praktisch jedes Packet-
        Radio-Mailboxsystem angepasst werden, ohne am Programm selbst énde-
        rungen vornehmen zu mÅssen. Dasselbe gilt Åbrigens auch fÅr die Er-
        kennung von Kodiererfiles!

        Das vollautomatische Erkennen von EintrÑgen und kodierten Files er-
        fordert einen recht hohen Aufwand. Wenn FFR eine Mitschrift durch-
        arbeitet, wird jede Zeile bis zu 50mal (!) und mehr geprÅft. (Ein
        langsamer XT ist nicht unbedingt geeignet, um mit FFR zu arbeiten,
        da die AusfÅhrungszeiten dort recht hoch sein kînnen!)


        FFR unterscheidet dabei mehrere Typen von Daten:

        3.1 Header:
        3.1 Header:

        Jeder Eintrag in einer Mailbox besitzt einen Kopf (Header), in dem
        die wichtigsten Informationen Åber den Eintrag zusammengefasst
        sind: Absender, Ziel oder Rubrik, Datum, öberschrift usw.

        Beispiel:

        DL1AAA @DB0BBB   de:DJ2CCC 28.10.91 14:53 UTC Frage...

        Die Strukturen der Header sind von Mailboxsystem zu Mailboxsystem
        sehr unterschiedlich, so dass jedes System eine eingene Definition
        im Konfigurationsfile benîtig. Erschwerend kommt hinzu, dass sich
        die Header eines Systems je nach eingestellter Sprache unterschei-
        den kînnen. Selbst bei gleicher Sprache und gleichem Mailboxsytem
        kînnen Unterschiede bestehen, weil einem Sysop die Original-Header
        nicht gefallen. So kann es also durchaus passieren, dass FFR mal
        einen Eintrag nicht erkennt, weil man eine andere Spsache in der
        Box gewÑhlt hat, oder der Sysop an den Headern herumgefummelt hat.

        3.2 Prompts:
        3.2 Prompts:

        Prompts sind Aufforderungen von Mailboxen, die dem Benutzer signa-
        lisieren, dass eine Eingabe erwartet wird. Ebenfalls als Prompts
        werden Ausgaben betrachtet, die benutzt werden kînnen, um das Ende
        eines Eintrages zu erkennen. Hierzu zÑhlen nicht nur Ausgaben der
        Mailboxen, sondern auch Ausgaben des eigenen Terminals, TNCs oder
        des Netzes.
        Bei den Prompts gibt leider die gleichen Probleme wie bei den
        Headern: Sie kînnen sich bei gleichem Mailboxsystem und Sprache je
        nach Gusto des Sysops unterscheiden. Das in DL am weitesten ver-
        breitete DieBox-System ist in diesem Punkt ein unrÅhmliches Bei-
        spiel.

        Bei manchen Mailboxen kann es vorkommen, dass ein Eintrag direkt
        hinter einem Prompt beginnt. Dies ist dann der Fall, wenn der
        Prompt nicht mit einem RETURN abgeschlossen ist und beim eigenen
        Terminal das Echo ausgeschaltet ist. Daher unterscheidet FFR
        wiederum zwei Arten von Prompts:

        repositionierende und nicht repositionierende Prompts.
        _________________     _______________________         

        Beispiel:

        DG1BBQ de DB0CL>DL1AAA @DB0BBB   de:DJ2CCC 28.10.91 14:53 UTC....
        +--------------++----------------------------------------------->
         Prompt          Header

        Ist der Prompt 'DG1BBQ de DB0CL>' im Konfigurationsfile als reposi-
        tionierend definiert, berechnet FFR die Position direkt hinter dem
        Prompt, repositioniert den Lesezeiger dorthin und liest die Zeile
        neu ein. Somit liegt der Header jetzt am Anfang der Zeile und kann
        normal weiterverarbeitet werden.

        Diese Vorgehensweise wurde aus GeschwindigkeitsgrÅnden gewÑhlt,
        weil damit eine zeilenweise Verarbeitung mîglich ist. Eine zeichen-
        weise Verarbeitung brÑchte einen erheblich hîheren Overhead bei der
        Mustererkennung und demnach eine viel geringere Verarbeitungsge-
        schwindigkeit.

        3.3 Kodiererfiles:
        3.3 Kodiererfiles:

        Sie werden von FFR gesondert behandelt indem sie mit Hilfe der De-
        finitionen im Konfigurationsfile identifiziert und unter dem Kodie-
        rer entsprechendem Namen gespeichert werden. Ein Nacheditieren der
        Kodiererfiles erÅbrigt sich damit.

        Im Konfigurationsfile sind bereits eine ganze Reihe von Kodierern
        definiert. Beim Auftauchen von neuen Kodierern kînnen diese Dort
        nachgetragen werden. In der Regel werden die notwendigen énderungen
        in den Mailboxen bekanngegeben, so dass man sich nicht unbedingt
        mit den Feinheiten von FFR auskennen muss.

        4. Namensformate der von FFR erzeugten Files
        4. Namensformate der von FFR erzeugten Files
        ____________________________________________

        Identifizert FFR den Header einer Nachricht in einer Mitschrift, so
        liest er gemÑss der Definitionen im Konfigurationsfile die benîtig-
        ten Informationen aus dem Header:

        Ziel (bei allgemeinen Nachrichten die Rubrik, auch Board genannt),
        ____                                                              
        Absender, und Datum.
        ________      _____ 

        Aus diesen Informationen bildet FFR einen geeigneten Filenamen, um
        den Eintrag abzuspeichern.

        4.1 Filenamen bei allgemeinen Nachrichten:
        4.1 Filenamen bei allgemeinen Nachrichten:

        Der Filename setzt sich aus der Rubrik, einer laufenden Nummer und
        dem Datum der Nachricht zusammen:

              SOFTWA01.B21
             +-----+--+---+
                1   2   3

             1) Rubrikname (auf 6 Zeichen gekÅrzt).
             2) Laufende Nummer in hexadezimaler Notation.
                Beim nÑchsten Eintrag der Rubrik SOFTWARE an diesem Tag
                wird die Nummer um 1 fortgezÑhlt.
             3) Datum. Die erste Stelle reprÑsentiert den Monat (hexade-
                zimal), wobei A fÅr den Monat Oktober, B fÅr November und C
                fÅr Dezember steht. Die letzten beiden Stellen reprÑsentie-
                ren den Tag (dezimal).

        Pro Rubrik und Tag sind also maximal FF (255 Dez) EintrÑge mîglich.


        4.2 Filenamen bei persînlichen Nachrichten:
        4.2 Filenamen bei persînlichen Nachrichten:

        Filenamen von persînlichen Nachrichten unterscheiden sich von denen
        von allgemeinen Nachrichten:

              DL1AAA_A.B21
             +-----+--+---+
                1    2  3

             1) Absenderrufzeichen (max 6 Zeichen. Ist es kÅrzer, wird es
                mit '_' aufgefÅllt).
             2) Laufende Nummerierung. A bedeutet 1, B 2 usw. bis Z.
             3) Datum (siehe '4.1 Filenamen bei allgemeinen Nachrichten').

        Pro Absender sind pro Tag maximal 26 Nachrichten mîglich.

        Damit FFR Nachrichten als persînlich erkennen kann, muss in der
        Konfigurationsdatei das eigene Rufzeichen eingetragen sein!

        Siehe '6.1 Rufzeichendefinition'

        5. Bedienung
        5. Bedienung
        ____________

        5.1 Kommandozeilensyntax:
        5.1 Kommandozeilensyntax:

        FFR wird Åber die Kommadozeile gesteuert.
        Es ist dabei die folgende Syntax einzuhalten (symbolische Darstel-
        lung):

          ffr <Eingabefile> [{Kommando} <Rubrik|Bereich> [Optionen] ..
          ffr <Eingabefile> [{Kommando} <Rubrik|Bereich> [Optionen] ..
              .. [<Suchbegriffe1-5>]]
              .. [<Suchbegriffe1-5>]]

        Elemente in '<' und '>' sind hierbei Zeichenketten. In eckige Klam-
        mern eingeschlossene Elemente sind Optional, d.h. mÅssen nicht an-
        gegeben werden, wenn sie nicht benîtigt werden. Elemente in ge-
        schweiften Klammern mÅssen vorhanden sein. Der ODER-Strich '|' gibt
        an, dass entweder das eine oder das andere angegeben werden darf.


        <Eingabefile>
        <Eingabefile>

        Legt das File fest, in dem die Nachrichten enthalten sind, die FFR
        bearbeiten soll.


        5.2 {Kommando}
        5.2 {Kommando}

        FFR kennt drei Kommandos:

          -l (List) EintrÑge aus einer Mitschrift auf dem Bildschirm lis-
             ten.

          -k (Kill) EintrÑge oder unnîtige Informationen zwischen den Ein-
             trÑgen lîschen. Alle gelîschten Daten werden in KILL.FFR ge-
             schrieben.

          -x (eXtract) EintrÑge extrahieren. Die EintrÑge werden nicht aus
             der Mitschrift gelîscht.


        5.3 <Rubrik|Bereich>
        5.3 <Rubrik|Bereich>

        Kommandos haben immer einen Parameter, der festlegt, welche Ein-
        trÑge gelistet, gelîscht oder extrahiert werden sollen.

        Der Parameter kann der Name einer Rubrik (bei allgemeinen Nachrich-
        ten), eines Zielrufzeichens (bei persînlichen Nachrichten), eine
        Bereichsangabe oder ein Stern sein. Der Stern als Parameter wÑhlt
        alle EintrÑge aus.

        Beim Kill-Kommando hat der Stern eine etwas andere Bedeutung. Es
        werden nicht alle EintrÑge gelîscht, sondern die unnîtigen Infor-
        mationen zwischen den EintrÑgen.

        Eine Bereichangabe ist eine Liste von Eintragsnummern.

        Beispiel:  -5,12-20,78-

        Bedeutet: EintrÑge 1-5, 12-20 und 78 bis Ende auswÑhlen.

        In einer Bereichsangabe sind Leerzeichen nicht zulÑssig!


        5.4 [Optionen]
        5.4 [Optionen]

        -debug
           Um Fehler in den Definitionen im Konfigurationsfile aufspÅren zu
           kînnen, werden zusÑtzliche Informationen auf dem Bilschirm aus-
           gegeben. Vorsicht ist mit dieser Option geboten, da nicht uner-
           hebliche Datenmengen entstehen! Man kann die Ausgaben auch in
           eine Datei umlenken, indem man am Ende der Kommandozeile das
           Ausgabeumleitungszeichen '>' und einen Filenamen angibt.

        -gi <Filename>
           Bei der tÑglichen Arbeit ist es mitunter etwas mÅhsam, wenn eine
           ganze Reihe von bestimmten EintrÑgen gelîscht oder extrahiert
           werden sollen: EintrÑge listen, Nummern der EintrÑge notieren,
           FFR aufrufen und u.U. lange Ketten von Zahlen eingeben...
           HierfÅr gibt es die '-gi'-Option, die diese Arbeiten erheblich
           vereinfacht.

           Vorgehensweise:

           1) Man erstellt eine Liste der EintrÑge:
              ffr savefile >liste

           2) Das entstandene File 'liste' editieren. Vor jedem Eintrag
              befindet die laufende Nummer des Eintrages, z.B.: #25
              Man braucht jetzt nur ein zusÑtzliches Doppelkreuz vor die
              Nummer zu schreiben und der Eintrag ist markiert.
              Das wiederholt man nun fÅr alle EintrÑge, die man extrahie-
              ren, listen oder lîschen will und speichert das File wieder
              ab.

           3) Der folgende Aufruf lîscht dann alle markierten EintrÑge:
              ffr savefile -k * -gi liste

           Warnung: Hat man eine Liste zum Lîschen benutzt, sollte man sie
                    auf keinen Fall erneut dazu verwenden!

        -ic
           Wird diese Option verwendet, ignoriert FFR in der Mitschrift
           enthaltene Kodiererfiles. Sie werden dann wie gewîhnlicher Text
           behandelt.

        -ih
           Das GegenstÅck zur '-ic'-Option, es wird nur nach Kodiererfiles
           gesucht.

        -h
           BefehlsÅbersicht anzeigen. Die Ausgabe hÑlt nach 24 Zeilen an
           und wird nach einem Tastendruck fortgesetzt. Die BefehlsÅber-
           sicht erhÑlt man allerding auch wenn FFR ohne Kommandozeilen-
           parameter aufgerufen wird.

        -m <Rufzeichen>
           Eigenes Rufzeichen angeben. Ist nicht erforderlich, wenn es be-
           reits im Konfigurationsfile eingetragen ist.

        -o <Filename>
           Soll das Eingabefile beim Lîschen von EintrÑgen nicht verÑndert
           werden, so kann FFR hiermit angewiesen werden, die restlichen
           Daten in das angegebene File zu schreiben.

        -cp <Pfad>
           Legt den Zielpfad fÅr die extrahierten Kodiererfiles fest. Auf
           diese Weise lassen sich die Kodiererfiles gleich getrennt von
           den anderen Files in ein eigenes Verzeichnis ablegen. Bei der
           Angabe des Pfades ist darauf zu achten, dass dieser korrekt ab-
           geschlossen ist.

           Beispiele:

           -cp c:\sp\save\mail\code\
           -cp code\

           Beim zweiten Beispiel versucht FFR die Kodiererfiles in das Ver-
           zeichnis 'code', dass im aktuellen Verzeichnis vorhanden sein
           muss, zu schreiben. Besser ist es keine relativen Pfade wie im
           zweiten, sondern absolute Pfade wie im ersten Beispiel anzuge-
           ben.
           Ist der Ausgabepfad fÅr Kodiererfiles bereits im Konfigurations-
           file fesgelegt, wird dieser ignoriert. Ein Åber die Kommando-
           zeile definierter Ausgabepfad hat also eine grîssere PrioritÑt.
           Zur Definition von Ausgabepfaden im Konfigurationsfile, siehe:
           '6.2 Festlegung der Ausgabepfade'.

        -gp <Pfad>
           Zielpfad fÅr allgemeine Nachtrichten festlegen. Syntax wie bei
           der '-cp'-Option.

        -pp <Pfad>
           Dito, bezogen auf persînliche Nachrichten.

        -icp
           FFR wird angewiesen, den im Konfigurationsfile festgelegten
           Ausgabepfad fÅr Kodiererfiles zu ignorieren. Die extrahierten
           Files werden dann wie gewohnt im aktuellen Verzeichnis abgelegt.

        -igp
           Wie '-icp', jedoch bezogen auf allgemeine Nachrichten.

        -ipp
           Wie '-icp', jedoch bezogen auf persînliche Nachrichten.

        -iap
           Hat die selbe Wirkung wie die '-icp'-, '-igp'- und '-ipp'-Optio-
           nen zusammengenommen, d.h. alles wird in das aktuelle Verzeich-
           nis extrahiert.


        5.5 <Suchbegriffe1-5>
        5.5 <Suchbegriffe1-5>

        Bis zu fÅnf Suchbegriffe kînnen angegeben werden, um bestimmte Ein-
        trÑge auszuwÑhlen. Der Suchbegriff muss im Header des Eintrages
        vorkommen, damit der Eintrag als erkannt gilt. Bei der PrÅfung wird
        nicht auf Gross/Kleinschreibung geachtet. Wird mehr als ein Suchbe-
        griff angegeben, mÅssen auch alle im Header vorkommen!

        Beispiel:

        ffr savefile -x ibm 7plus dg1bbq
                            +----------+
                                 !
                                 +-------- Suchbegriffe


        5.6 Beispielaufrufe:
        5.6 Beispielaufrufe:

        ffr savefile
           Erstellt eine Liste der in 'savefile' enthaltenen EintrÑge.

        ffr savefile >liste
           Dito, jedoch werden die Bildschirmausgaben dabei in die Datei
           'liste' geschrieben. Siehe hierzu '5.4 [Optionen]'

        ffr savefile -x *
           Extrahiert alle enthaltenen EintrÑge.

        ffr savefile -x ibm
           Extrahiert alle EintrÑge der Rubrik 'IBM'.

        ffr savefile -x ibm dl1aaa
           Dito, jedoch muss 'dl1aaa' im Header der EintrÑge vorkommen.

        ffr savefile -x 4-7
           Extrahiert die EintrÑge 4 bis einschliesslich 7.

        ffr savefile -k *
           Unnîtige Informationen zwischen den EintrÑgen aus der Mitschrift
           entfernen. Sicherheitshalber werden die gelîschten Zeilen in
           KILL.FFR protokolliert.

        ffr savefile -k alle info
           Alle EintrÑge der Rubrik 'ALLE' lîschen, in deren Header 'info'
           vorkommt.


        6. Konfiguration
        6. Konfiguration
        ________________

        Im Konfigurationsfile sind alle Informationen gespeichert, die FFR
        zur Erkennung von Mailbox-Headern und kodierten Files benîtigt.
        Ohne Konfigurationsfile kann FFR nicht arbeiten, daher ist es
        wichtig, dass er es auch findet. Bei MSDOS- und UNIX-Systemen
        sollte es in dem Verzeichnis abgelegt werden, in dem sich auch FFR
        selbst, also das ausfÅhrbares File, befindet. Bei UNIX-Systemen
        prÅft FFR zusÑtzlich die Umgebungsvariable HOME und sucht in dem
        dort angegebenen Pfad nach dem Konfigurationsfile.
        Aus Programmtechnischen GrÅnden muss das File beim Atari_ST jedoch
        im Hauptverzeichnis abgelegt sein.

        Der Filename des Kofigurationsfiles lautet bei MSDOS und Atari_ST
        'FFR.CFG', bei UNIX-Systemen '.ffrrc'.

        Im Konfigurationsfile kînnen auch Kommentare untergebracht werden,
        wenn diese mit einem Doppelkreuz '#' beginnen.

        Wichtig: Alle Zeilen im Konfigurationsfile dÅrfen nicht lÑnger als
                 _________________________________________________________
                 80 Zeichen sein und mÅssen in der ersten Spalte beginnen!!
                 __________________________________________________________

        Die Platzhalter <Format> und <String> die im Anschluss verwendet
        werden, stellen unterschiedliche Arten von Zeichenketten dar. Was
        darin erlaubt ist und was nicht, siehe '7. Muster-Erkennungformate'


        6.1 Rufzeichendefinition
        6.1 Rufzeichendefinition
        ________________________

        FFR benîtigt zur Identifikation von persînlichen Nachrichten das
        eigene Rufzeichen. Manche Prompts enthalten ebenfalls das eigene
        Rufzeichen, so dass es zur sicheren und eindeutigen Identifikation
        dieser Prompts ebenfalls benîtigt wird.

        Das Rufzeichen wird wie folgt definiert:

          mycall "<Rufzeichen>"
          mycall "<Rufzeichen>"

        Es kînnen bis zu fÅnf Rufzeichen definiert werden. Das ist dann
        sinnvoll, wenn z.B. ein und der selbe Rechner von mehreren liz.
        Mitgliedern einer Familie oder an einer Clubstation Verwendung
        findet. Jedes Rufzeichen wird dabei mit einer eigenen Zeile
        'mycall..' eingetragen.

        Wird Åber die Kommandozeilenoption '-m' ein Rufzeichen definiert,
        so werden nur die ersten vier Rufzeichen im Konfigurationsfile
        gelesen.

        Siehe auch '6.4.3 Prompts und das eigene Rufzeichen'

        Beispiel:

        mycall "dg1bbq"



        6.2 Festlegung der Ausgabepfade
        6.2 Festlegung der Ausgabepfade
        _______________________________

        FFR kann angewiesen werden, Files generell in bestimmte Verzeich-
        nisse zu schreiben. Damit erÅbrigt sich das nachtrÑgliche Ausein-
        anderkopieren und erhîht die öbersichtlichkeit.

        Da FFR drei Filetypen unterscheidet - Kodiererfiles, allgemeine und
        persînliche Nachrichten -, kînnen dementsprechend drei Ausgabepfade
        definiert werden:

        codepath "<Pfad fÅr Kodiererfiles>"
        codepath "<Pfad fÅr Kodiererfiles>"
        genpath "<Pfad fÅr allgemeine Nachrichten>"
        genpath "<Pfad fÅr allgemeine Nachrichten>"
        perspath "<Pfad fÅr persînliche Nachrichten>"
        perspath "<Pfad fÅr persînliche Nachrichten>"

        Beispiel:

        codepath "c:\sp\save\mail\code\"
        genpath "c:\sp\save\mail\"
        perspath "c:\sp\save\mail\pers\"


        Werden eine oder mehrere Definitionen weggelassen, so schreibt FFR
        die entsprechenden Files wie gewohnt in das aktuelle Verzeichnis.
        Hierzu mÅssen die nicht benîtigten Definitionen nicht entfernt
        werden, sondern es genÅgt sie vor FFR zu 'verstecken', indem ein-
        fach ein Doppelkreuz vor die entsprechende Definition geschrieben
        wird:

        #codepath "c:\sp\save\mail\code\"

        Eine andere Mîglichkeit, die definierten Ausgabepfade zu deaktivie-
        ren oder zu Åbergehen ist Åber die Kommmandozeile gegeben.
        Siehe hierzu '5.4 [Optionen]'.



        6.3 Monatsbezeichner
        6.3 Monatsbezeichner
        ____________________

        Damit FFR auch Datumsangaben auswerten kann, die den Monat in Klar-
        text enthalten, benîtigt er eine Liste von Monatsbezeichnern.
        öber diese Liste ist es dann mîglich, einem Monatsbezeichner die
        entsprechende Monatnummer zuzuweisen. Da Monatsangaben in verschie-
        denen Sprachen vorkommen, kînnen jeweils mehrere Bezeichner ange-
        geben werden.

        Format:

        months
        months
        {
        {
        1 "<Bezeichner fÅr Januar>    ..."
        1 "<Bezeichner fÅr Januar>    ..."
        2 "<Bezeichner fÅr Februar>   ..."
        2 "<Bezeichner fÅr Februar>   ..."
        3 "<Bezeichner fÅr MÑrz>      ..."
        3 "<Bezeichner fÅr MÑrz>      ..."
        4 "<Bezeichner fÅr April>     ..."
        4 "<Bezeichner fÅr April>     ..."
        5 "<Bezeichner fÅr Mai>       ..."
        5 "<Bezeichner fÅr Mai>       ..."
        6 "<Bezeichner fÅr Juni>      ..."
        6 "<Bezeichner fÅr Juni>      ..."
        7 "<Bezeichner fÅr Juli>      ..."
        7 "<Bezeichner fÅr Juli>      ..."
        8 "<Bezeichner fÅr August>    ..."
        8 "<Bezeichner fÅr August>    ..."
        9 "<Bezeichner fÅr September> ..."
        9 "<Bezeichner fÅr September> ..."
        10 "<Bezeichner fÅr Oktober>   ..."
        10 "<Bezeichner fÅr Oktober>   ..."
        11 "<Bezeichner fÅr November>  ..."
        11 "<Bezeichner fÅr November>  ..."
        12 "<Bezeichner fÅr Dezember>  ..."
        12 "<Bezeichner fÅr Dezember>  ..."
        }
        }

        Beispiel:

        months
        {
        1 "jan"
        2 "feb"
        3 "mar"
        4 "apr"
        5 "mai may"
        6 "jun"
        7 "jul"
        8 "aug"
        9 "sep"
        10 "okt oct"
        11 "nov"
        12 "dez dec"
        }



        6.4 Prompts (allgemein)
        6.4 Prompts (allgemein)
        _______________________

        Prompts sind Ausgaben der Mailboxen, TNCs oder des Netzes, an denen
        FFR erkennen kann, dass ein Eintrag beendet ist.

        Definition eines Prompts:

          p n "<String>|<Format>"
          p n "<String>|<Format>"
            !
            +------------- 0 -> nicht repositionierender Prompt.
                           1 -> repositionierender Prompt.

        Repositionierende Prompts mÅssen am Ende ihres Formats ein Format-
                                  ______                                  
        element besitzen in das der gesamte Rest der Zeile eingelesen wird!
        Der Grund ist, dass hinter einem solchen Prompt bÅndig, also ohne
        Zeilentrenner, ein Eintrag beginnen kann. Damit FFR den Eintrag
        identifizeren kann, muss er am Anfang der Zeile beginnen. FFR
        benutzt das Formatelement, in dem der Rest der Zeile enthalten ist,
        um den Offset fÅr die Repositionierung des Lesezeigers zu berech-
        nen.

        Beispiel:

        p 1 "bbs> %[^~]"

        Bei nicht repositionierenden Prompts ist dies nicht notwendig, da
        dort der Rest der Zeile hîchstens das Echo einer eigenen Eingabe
        enthalten kann.

        Prompts treten immer nur im Zusammenhang mit anderen Definitionen
        im Konfigurationsfile auf, z.B. innerhalb des 'prompts {}'- und
        'header {}'-Blocks.

        In jedem Block sollten die repositionierenden Prompts zuerst
        definifert werden und danach die nicht repositionierenden.


        6.4.1 Prompts im 'prompts {}'-Block:
        6.4.1 Prompts im 'prompts {}'-Block:

        Im diesem Block werden all jene Prompts definiert, die immer
                                                               _____
        geprÅft werden mÅssen. Dies sind zum einen die repositionierenden
        Prompts und die Prompts, die vom TNC oder dem Netz generiert
        werden.

        Beispiel:

        prompts
        {
        p 1 "bbs> %[^~]"
        p 0 "DISCONNECTED fm"
         .
         . Beliebige Anzahl ....
         .
        }



        6.4.2 Prompts im 'header {}'-Block:
        6.4.2 Prompts im 'header {}'-Block:

        Prompts, die in einem 'header {}'-Block definiert sind, werden nur
        dann geprÅft, wenn FFR gerade EintrÑge des entsprechenden Boxtyps
        bearbeitet. Dies erkennt FFR automatisch.


        6.4.3 Prompts und das eigene Rufzeichen:
        6.4.3 Prompts und das eigene Rufzeichen:

        Manche Prompts enthalten das Rufzeichen der in der Box eingelogten
        Station, sprich das eigene Rufzeichen.
        Damit man nun nicht bei allen betreffenden Prompts jeweils sein
        Rufzeichen eintragen muss, kann man einen Platzhalter einsetzen,
        der dann automatisch durch das eigene Rufzeichen ersetzt wird.

        Beispiel:

        p 0 "%M de %[^>]%[>]"

        Das '%M' wird automatisch durch das eigene Rufzeichen in Gross-
        schrift ersetzt. Ist '%m' angegeben, wird das Rufzeichen in Klein-
        schrift eingesetzt

        Sind mehrere Rufzeichen definiert, wird fÅr jedes Rufzeichen eine
        entsprechende Kopie des Prompts durch FFR erstellt.

        Siehe auch '6.1 Rufzeichendefinition'


        6.5 Das File-Lese-Fenster
        6.5 Das File-Lese-Fenster
        _________________________

        Da viele Mailboxsysteme Headerstrukturen haben, die sich Åber
        mehrere Zeilen erstrecken, ist es mitunter notwendig 'vorraus-
        zusehen'. Hierzu besitzt FFR einen zyklischen Puffer, der Zeilen-
        orientiert arbeitet und die Mîglichkeit bietet von der aktuellen
        Zeile aus 9 Zeilen vorrauszusehen.
        Diesen Puffer (das File-Lese-Fenster) kann man sich auch als Lese-
        lupe vorstellen, die man Åber einen Text schiebt, nur dass man ins-
        gesamt 10 Zeilen gleichzeitig sehen kann.

        Wenn im Anschluss von 'Offset' gesprochen wird, bezieht sich dies
        auf das File-Lese-Fenster. Ein Offset von 2 bedeutet dann 'Åber-
        nÑchste Zeile'.


        6.6 Header-Definition ('header {}'-Block)
        6.6 Header-Definition ('header {}'-Block)
        _________________________________________

        In der Header-Definition sind alle Informationen zusammengefasst,
        die FFR benîtigt, EintrÑge sicher und eindeutig zu identifizieren.
        Maximal 25 Mailboxtypen kînnen definiert werden. Werden mehr ge-
        braucht, was ich nicht glaube, kann die Konstante MAXMBTYPES in den
        Sources von FFR entsprechend erhîht und FFR neu kompiliert werden.



        6.6.1 Struktur des 'header {}'-Blocks:
        6.6.1 Struktur des 'header {}'-Blocks:

          header <Boxbezeichnung>
          {
          q n "<String>"              Quicktest
                                      Quicktest
          h n "<Format 1>"            Header-Test 1 bis m
                                      Header-Test 1 bis m
            .
            .
            .
          h n "<Format m>"
          l n                         LÑnge des Headers in Zeilen
                                      LÑnge des Headers in Zeilen
          b n "<Format>"              Format zum Lesen der Rubrik
                                      Format zum Lesen der Rubrik
          s n "<Format>"                               des Absenders
                                                       des Absenders
          d n "<Format>"                               des Datums
                                                       des Datums
          t n                         Datumstyp
                                      Datumstyp
          p n "<String 1>|<Format 1>" Boxspezifischer Prompt 1 bis n
                                      Boxspezifischer Prompt 1 bis n
            .
            .
            .
          p n "<String n>|<Format n>"
          }

        Die folgenden Beispiele beziehen sich alle auf diesen Header:

        Date: 28 Oct 91 13:32
        Message-ID: <0@EA2RCG>
        From: EB2DJM@EA2RCG
        To: ALL@EU
        Subject: I need the schemas of FT-73R(yaesu)


        Beispiel:

        header W0RLI-BBS
        {
        q 0 "Date:"
        h 0 "Date%[:]"
        h 1 "Message-I%[dD]%[:]"
        h 2 "From%[:]"
        h 3 "To%[:]"
        h 4 "Subject%[:]"
        l 5
        b 3 "%s %[^@]"
        s 2 "%s %[^@]"
        d 0 "%s %9[^~]"
        t 1
        p 0 " Msg# Stat Size To     From   @ BBS  Date/Time Subject"
        p 0 "%s user(s), %[^>]%[>]"
        p 0 "%M de %[^(](H %s Help) %[>]"
        }



        6.6.2 Quicktest:
        6.6.2 Quicktest:

        Um Zeit zu sparen, fÅhrt FFR einen Schnelltest durch, bevor ein
        potentieller Header ausfÅhrlich geprÅft wird.

          q n "<String>"
          q n "<String>"
            !
            +------------ Offset zur aktuellen Zeile.

        Beispiel:

        q 1 "Date:"


        6.6.3 Header-Test:
        6.6.3 Header-Test:

        War der Quicktest erfolgreich, wird der potentielle Header mit dem
        Header-Test genauer geprÅft.

          h n "<Format1>||<Format2>|| ..."
          h n "<Format1>||<Format2>|| ..."
            !
            +------------ Offset zur aktuellen Zeile.

        Es kînnen beliebig viele Header-Test-Zeilen in einer Header-Defini-
        tion vorkommen. Nur wenn alle Header-Tests erfolgreich verlaufen,
        gilt der Header als erkannt.

        Werden mehrere Alternativ-Formate in einem Header-Test duch '||'
        getrennt angegeben, so gilt der Test als erfolgreich wenn eine der
        Alternativen zutrifft.

        Es besteht also folgender Zusammenhang:

        Ein Header gilt als erkannt, wenn alle Header-Tests erfolgreich
        verlaufen. EnthÑlt ein Header-Test mehrere Alternativen, so muss
        eine der Alternativen zutreffen. Zwischen den Header-Test besteht
        also eine UND-VerknÅpfung und innerhalb der Header-Tests eine ODER-
        VerknÅpfung.

        Beispiel:

        h 1 "Message-I%[dD]%[:]"

        6.6.4 LÑnge des Headers:
        6.6.4 LÑnge des Headers:

        FÅr die Verarbeitung von Suchbegriffen und Erstellen von Listen ist
        es notwendig, dass FFR die Anzahl der Zeilen kennt, die der Header
        umfasst.

          l n
          l n
            !
            +------------ Anzahl der Zeilen

        Beispiel:

        l 5


        6.6.5 Formate zum Lesen von Rubrik/Absender/Datum:
        6.6.5 Formate zum Lesen von Rubrik/Absender/Datum:

        Hat FFR einen Header eindeutig identifiziert, geht es nun darum,
        die relevanten Informationen aus dem Header zu lesen.

        Rubrik:
          b n "<Format>"
          b n "<Format>"
            !
            +----------- Offset zur aktuellen Zeile.

        Absender:
          s n "<Format>"
          s n "<Format>"

        Datum:
          d n "<Format>"
          d n "<Format>"

        Die jeweiligen Formate mÅssen so ausgelegt sein, dass die benîtigte
        Information aus dem Header im letzten Format-Element reprÑsentiert
        wird.

        Beispiele:

        b 3 "%s %[^@]"
        s 2 "%s %[^@]"
        d 0 "%s %9[^~]"


        6.6.6 Datumstyp:
        6.6.6 Datumstyp:

        FFR kennt vier verschiedene Datumstypen.

          t n
          t n
            !
            +----------- Datumstyp

        Typ 0 : DD?MM            z.B. 01.04.91, 01-04-91 usw.
        Typ 1 : D|DD?<Monat>          1 April, 1.April, 01/Apr usw.
        Typ 2 : MM?DD                 04.01.91, 04/01/91 usw.
        Typ 3 : MMDD                  910401


        Beispiel:

        t 1

        6.6.7 Boxspezifische Prompts:
        6.6.7 Boxspezifische Prompts:

        siehe '6.4.2 Prompts im 'header {}'-Block'


        6.7 Kodierer-Definition ('code {}'-Block)
        6.7 Kodierer-Definition ('code {}'-Block)
        _________________________________________

        FFR kann auf beliebige Kodierer konfiguriert werden. Hierzu dient
        der 'code {}'-Block in dem alle notwendigen Informationen dazu zu-
        sammengefasst sind.
        Maximal 25 Kodierer kînnen definiert werden. Werden mehr gebraucht,
        was ich nicht glaube, kann die Konstante MAXCOTYPES in den Sources
        von FFR entsprechend erhîht und FFR neu kompiliert werden.



        6.7.1 Struktur des 'code {}'-Blocks:
        6.7.1 Struktur des 'code {}'-Blocks:

          code <Kodierername>
          {
          q n "<String>"         Quicktest
                                 Quicktest
          f n "<Format 1>"       Header-Test 1 bis m
                                 Header-Test 1 bis m
            .
            .
          ..
          f n "<Format m>"
          l n                    LÑnge des Headers in Zeilen
                                 LÑnge des Headers in Zeilen
          n n "<Format>"         Format zum Lesen des Namens
                                 Format zum Lesen des Namens
          p n "<Format>"                          der Teil-Nummer
                                                  der Teil-Nummer
          o n "<Format>"                          der Gesamtanzahl Teile
                                                  der Gesamtanzahl Teile
          1 "<Format>"           Bildungsformat 1 fÅr den Filenamen
                                 Bildungsformat 1 fÅr den Filenamen
          2 "<Format>"                          2
                                                2
          e "<String>|<Format>"  Ende-Test
                                 Ende-Test
          i n                    Extension inkrementieren
                                 Extension inkrementieren
          t n                    File-Typ
                                 File-Typ
          }


        Die folgenden Beispiele beziehen sich alle auf dieses File:

         go_7+. 001 of 001 TEST.TXT     0000046 0040 001 (7PLUS v1.5) XXXXX
        fkGSDwekler34weEwrwer!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$fW
         stop_7+. (TEST.TXT)

        Beispiel:

        code 7PLUS
        {
        q 0 " go_"
        f 0 " go_7+. %s of %34[^~](%[^)]%[)]"
        l 1
        n 0 "%19[^~]%8[^.]"
        p 0 "%8[^~]%d"
        o 0 "%16[^~]%d"
        1 "%s.7pl"
        2 "%s.p%02x"
        e " stop_7+."
        }


        6.7.2 Quicktest:
        6.7.2 Quicktest:

        Wie bereits bei der Header-Definition wird auch hier ein Quicktest
        durchgefÅhrt, bevor genauer gerÅft wird.

          q n "<String>"
          q n "<String>"
            !
            +----------- Offset zur aktuellen Zeile

        Beispiel:

        q " go_"



        6.7.3 Header-Test:
        6.7.3 Header-Test:

        War der Quicktest erfolgreich, wird der potentielle Header des Ko-
        diererfiles genauer geprÅft. Es kînnen mehrere Header-Tests in
        einem 'code {}'-Block vorkommen, wobei der Header des Kodiererfiles
        nur dann als erkannt gilt, wenn alle Header-Tests erfolgreich sind.

          f n "<Format>"
          f n "<Format>"
            !
            +------------ Offset zur aktuellen Zeile

        Beispiel:

        f 0 " go_7+. %s of %34[^~](%[^)]%[)]"


        6.7.4 LÑnge des Headers:
        6.7.4 LÑnge des Headers:

        FÅr die Verarbeitung von Suchbegriffen ist es notwendig, dass FFR
        die Anzahl der Zeilen kennt, die der Header umfasst.

          l n
          l n
            !
            +------------ Anzahl der Zeilen

        Beispiel:

        l 1

        6.7.5 Name des kodierten Files:
        6.7.5 Name des kodierten Files:

        Wurde der Header des Kodiererfiles erkannt, muss nun der Name des
        kodierten Files aus dem Header gelesen werden.

          n n "<Format>"
          n n "<Format>"
          ..!
            +------------ Offset zur aktuellen Zeile

        Das Format muss so aufgebaut sein, dass der Name im letzten Format-
        Element reprÑsentiert ist. Dabei sollte auch nur der Name des Files
        gelesen werden, also ohne Extension, es sei denn, der Name kann di-
        rekt verwendet werden.

        Beispiel:

        n 0 "%19[^~]%8[^. ]"


        6.7.6 Nummer des Teils:
        6.7.6 Nummer des Teils:

        Dieses Format liest die Nummer des Teils aus dem Header.

          p n "<Format>"
          p n "<Format>"
            !
            +----------- Offset zur aktuellen Zeile

        Beispiel:

        p 0 "%8[^~]%d"

        Das Format muss so aufgebaut sein, dass das letzte Format-Element
        die Nummer des Teils in numerischer Form aufnimmt.

        Besitzt der Kodierer keine Teilenummerierung, so kann ein leeres
        Format angegeben werden:

        p 0 ""


        6.7.7 Gesamtanzahl der Teile:
        6.7.7 Gesamtanzahl der Teile:

        Hiermit wird die Gesamtanzahl der Teile gelesen.

          o n "<Format>"
          o n "<Format>"
            !
            +----------- Offset zur aktuellen Zeile

        Beispiel:

        o n "%16[^~]%d"

        Das Format muss so aufgebaut sein, dass das letzte Format-Element
        die Gesamtanzahl der Teile in numerischer Form aufnimmt.

        EnthÑlt der Header keine Angabe der Gesamtanzahl der Teile, so kann
        auch hier ein leeres Format angegeben werden:

        o ""


        6.7.8 Bildungsformate fÅr den Filenamen:
        6.7.8 Bildungsformate fÅr den Filenamen:

        Mit diesen Formaten kann festgelegt werden, wie der Filename
        erzeugt wird.

          1 "<Format>"
          1 "<Format>"
          2 "<Format>"
          2 "<Format>"

        Die Formate mÅssen so aufgebaut sein, dass das erste Format-Element
        den Namen aufnimmt und u.U. das zweite die Nummer des Teils.

        FFR benutzt das erste Format fÅr die Bildung des Filenamens dann,
        entweder die Nummer des Teils und der Gesamtanzahl Teile gleich 1
        sind oder beide nicht gelesen wurden.
        Das zweite Format wird in allen anderen FÑllen benutzt.

        Beispiel:

        1 "%s.7pl"
        2 "%s.p%02x"

        Gibt es von dem Kodierer nur einteilige Files, kann das zweite
        Format leer angegeben werden:

        2 ""


        Sind die Regeln der Namensbildung eines Kodieres bei einteiligen
        und mehrteiligen Files gleich, kann das erste Format leer angegeben
        werden:

        1 ""

        Dann sollte 'o' (6.6.6 Gesamtanzahl der Teile) ebenfalls leer
        definiert werden, so dass immer Format 2 verwendet wird.

        Siehe auch '7.5 Formate fÅr die Ausgabe von Filenamen'


        6.7.9 Ende-Test:
        6.7.9 Ende-Test:

        Damit das Ende eines Kodiererfiles erkannt werden kann, gibt es
        dieses Format.

          e "<String>|<Format>"
          e "<String>|<Format>"

        Beispiel:

        e " stop_7+."

        6.7.10 Extension inkrementieren:
        6.7.10 Extension inkrementieren:

          i n
          i n
            !
            +----------- 0 -> Extension nicht automatisch inkrementieren.
                         1 -> Extension automatisch inkrementieren


        Es gibt FÑlle, wo die Kodiererfiles keinerlei Nummerierung be-
        sitzen. Sind mehrere dieser Files in einer Mitschrift vorhanden,
        wÅrde dies dazu fÅhren, dass FFR stÑndig fragt:

        'File already exists. Overwrite?'

        Um dies zu verhindern kann diese Option auf 1 gesetzt werden.
        Beim ersten Auftreten des Files wird Filenamen-Bildungsformat 1
        verwendet und bei allen folgenden Bildungsformat 2.

        Ein solcher Fall sind z.b. Fehlerprotokolle des 7PLUS-Kodierers.
        Dort entsteht beim ersten Auftreten von FFR.ERR das File 'FFR.ERR'
        nach Bildungsformat 1, bei jedem weiteren Auftreten enstehen Files
        der Form 'FFR.EXX' nach Format 2, wobei XX eine Hexzahl ist, die
        jeweils um eins erhîht (inkrementiert) wird.

        Beispiel:

        i 1



        6.7.11 File-Typ:
        6.7.11 File-Typ:

        Es gibt die Mîglichkeit, Texte automatisch extrahieren zu lassen,
        wenn diese vorher entsprechend markiert in die Box eingespielt
        wurden. Dabei ist es jedoch stîrend, wenn die Markierungen im
        extrahierten Text erhalten bleiben.
        Diese Option legt fest, ob die erste und letzte Zeile entfernt
        werden oder nicht.

          t n
          t n
            !
            +---------- 0 -> Normal.
                        1 -> Erste und letzte Zeile automatisch entfernen.

        Beispiel:

        t 1

        Beispiel fÅr einen markierten Text:

        Vor der Extraktion:

         go_text. FFR.DOC
        bla bla bla
        bla bla bla
         stop_text.

        Danach:

        bla bla bla
        bla bla bla


        7. Muster-Erkennungsformate
        7. Muster-Erkennungsformate
        ___________________________

        FFR besitzt zwei Mîglichkeiten zur Mustererkennung:

        1) eine einfache, zeichenweise PrÅfung von Zeichenketten.
        2) eine auf der scanf()-Funktion der Programmiersprache C basie-
           rende Mustererkennung, die entsprechend aufwendig und kompli-
           ziert ist.

        7.1. Zeichenweise PrÅfung von Zeichenketten (<String>):
        7.1. Zeichenweise PrÅfung von Zeichenketten (<String>):

        Mit dieser Mîglichkeit kînnen Zeichenketten verglichen werden. Es
        ist damit allerdings nicht mîglich aus einer Zeichenkette Informa-
        tionen zu lesen!

        öberall, wo in Abschnitt 6 der Platzhalter '<String>' auftaucht,
        darf diese Mîglichkeit eingesetzt werden.

        Die Zeichenweise PrÅfung kennt nur zwei Ergebnisse:

        öbereinstimmung oder keine öbereinstimmung

        Der PrÅfstring wird Zeichenweise bis zu seinem Ende mit der aus der
        Mitschrift gelesenen Zeile verglichen. Tilden '~' im PrÅfstring
        kînnen verwendet werden, um einzelne Zeichen zu Åbergehen.
        Die PrÅfung beginnt immer mit dem ersten Zeichen der gelesenen
        Zeile.


        Beispiel:

        PrÅfstring:
        "~~~~~~~(C)heck"

        Gelesene Zeile:
        "(H)elp (C)heck (L)ist (R)ead (S)end (Q)uit"

        Ergebnis: öbereinstimmung.

        ErklÑrung:
        Die sieben Tilden im PrÅfstring bewirken, dass die ersten 7 Zeichen
        nicht geprÅft werden. Ab dem achten Zeichen wird dann auf öberein-
        stimmung geprÅft, bis das Ende des PrÅfstrings erreicht ist. Waren
        die Zeichen bis dorthin gleich, gilt der Vergleich als erfolgreich.


        7.2 PrÅfung von Zeichenketten per Formatstring (<Format>)
        7.2 PrÅfung von Zeichenketten per Formatstring (<Format>)

        Diese Mîglichkeit, Zeichenketten zu prÅfen ist weitaus komplizerter
        als einfache zeichenweise Vergleiche, dafÅr bietet sie aber auch
        eine erheblich hîhere FlexibilitÑt!

        Ein Formatstring stellt ein Muster dar, dass auf eine gelesene
        Zeile angewendet wird.

        Bei der PrÅfung einer Zeile gilt diese als erkannt, wenn alle
        Formatelemente des Formatstring erfolgreich gelesen werden konnten.
        Die in die Formatelemente eingelesenen Informationen werden dabei
        nicht weiter beachtet.

        Genaue Informationen Åber den Aufbau von Formaten:
        siehe Abschnitt: '7.4 Aufbau von Formaten'.

        Beispiel:

        Format:
        " go_7+. %[0-9] of %[0-9]"

        Zeile:
        " go_7+. 001 of 001 TEST.TXT ........"
         123456789012345678901234567.........
                  1         2


        Die PrÅfung lÑuft wie folgt ab:

        " go_7+ " ist in der Zeile genauso vorhanden, wie im Format. Bis
        dahin wird Zeichenweise geprÅft. Bis Position 8 stimmen Format und
        Zeile Åberein. Als nÑchstes kommt das Formatelement "%[0-9]", was
        bedeutet: 'Lese Zeichen, bis Du auf ein anderes Zeichen als '01234
        56789' triffst. Da "001" in dieses Schema passt, wird das Format-
        element erfolgreich gelesen. Nun folgt ab Position 12 " of ". Dies
        ist wieder eine normale Zeichenkette, die Zeichenweise geprÅft
        wird. Als nÑchstes folgt wieder ein Formatelement, das auch wieder
        erfolgreich gelesen werden kann.
        Da an dieser Stelle der Formatstring zuende ist und alle Format-
        elemente erfolgreich gelesen werden konnten, gilt der Vergleich als
        erfolgreich.



        7.3 Lesen von Informationen aus einer Zeile:
        7.3 Lesen von Informationen aus einer Zeile:

        Beim Lesen aus einer Zeile, z.B. wenn die Rubrik, Absender usw aus
        einer Zeile gelesen werden sollen, werden die durch die Formatele-
        mente gelesenen Abschnitte einer Zeile in Variablen gespeichert.
        Dabei muss der letzte gelesene Abschnitt die gewÅnschte Information
        enthalten.

        Beispiel:

        Aus Folgender Zeile soll der Filename (ohne Extension) gelesen
        werden:

        " go_7+. 001 of 001 TEST.TXT ........"

        Hier der Formatstring dazu:

        "%s %s %s %s %[^. ]"

        Nach der Anwendung des Formatstring befinden sich in den Variablen
        folgende Abschnitte:

        Var 1: " go_7+"
        Var 2: " 001"
        Var 3: "of"
        Var 4: "001"
        Var 5: "TEST"

        Alternativ dazu, wÑre auch folgender Formatstring mîglich, da bei
        diesem Beispiel der Filename immer an der gleichen Position be-
        ginnt:

        "%19[^~]%8[^. ]"

        Var 1: " go_7+. 001 of 001 "
        Var 2: "TEST"

        Das Leerzeichen im Formatelement '%[^. ]' stellt sicher, dass bei
        Filenamen, die keine Extension enthalten und kÅrzer als 8 Zeichen
        sind; nicht unnîtige Leerzeichen am Ende mitgelesen werden.


        7.4 Aufbau von Formaten:
        7.4 Aufbau von Formaten:

        Ein Formatstring besteht aus normalen Zeichen, Zeichenketten und
        Formatelementen.

        Zeichen und Zeichenketten in Formaten werden 1:1 geprÅft, d.h. fÅr
        jedes Zeichen im Format muss ein entsprechendes Zeichen in der
        gelesenen Zeile vorhanden sein.

        Formatelemente geben Anweisungen, wie oder was gelesen werden soll.
        Sie beginnen immer mit einem Prozentzeichen '%'.


        Prinzipieller Aufbau eines Formatelements:

          %[Breite]Typ
          %[Breite]Typ
          !   !     !
          !   !     +------ Legt fest, welche Art von Daten gelesen werden.
          !   +------------ Maximale Anzahl zu lesender Zeichen oder Anzahl
          !                 zu lesender Stellen bei nummerischen Werten.
          +-----------------Formatelemente beginnen immer mit einem '%'.


        7.4.1 Mîgliche Typen:
        7.4.1 Mîgliche Typen:

        's':
          Liest eine beliebige Zeichenkette bis zum nÑchsten Leerzeichen,
          Zeilen- oder Stringende.

        '[<Zeichenauswahl>]':
          Liest solange Zeichen, bis ein Zeichen gefunden wird, das nicht
          in der Auswahl enthalten ist. Die Logik kann durch vorranstellen
          eines '^' vor die Zeichenauswahl umgedreht werden. Dann werden
          solange Zeichen gelesen, bis ein Zeichen gefunden wird, das in
          der Zeichenauswahl vorkommt.

          Beispiel:

          '%[ABC]' : Lesen bis ein Zeichen gefunden wird, das nicht ein
                     A, B oder C ist.
          '%[^ABC] : Lesen bis ein A, B oder C gefunden wird. Das letzte
                     gelesene Zeichen ist das Zeichen vor dem A, B oder C.

          Es kînnen bei der Zeichenauswahl auch Zeichenbereiche angegeben
          werden: 'A-Z'.
          Mehrfachbereiche sind ebenfalls zulÑssig: 'A-Za-z'
          Vorsicht! Ein vorrangestelltes '^' negiert den gesamten Zeichen-
          bereich.

        'd':
          Liest einen ganzzahligen dezimalen Wert.

        'x':
          Liest einen hexadezimalen Wert.


        Die Typen 'd' und 'x' sind nur bei den 'p'-, 'o'-, '1'- und '2'-
        Definitionen im 'code {}'-Block zulÑssig.


        7.4.2 Format zum Test auf Leerzeile:
        7.4.2 Format zum Test auf Leerzeile:

        Beim Header-Test im 'header {}'-Block kann es vorkommen, dass eine
        Leerzeile identifiziert werden soll. Mit den Åblichen Formaten ist
        dies leider nicht mîglich. Daher ist hierzu eine Mîglichkeit vorge-
        sehen:

        "~" als Format erzwingt einen Test auf Leerzeile.

        Diese Mîglichkeit ist nur im 'header {}'-Block zulÑssig!



        7.5 Formate fÅr die Ausgabe von Filenamen:
        7.5 Formate fÅr die Ausgabe von Filenamen:

        Bei der Filenamensbildung von Kodiererfiles werden Formatelemente
        nicht zum Lesen, sondern zum Erzeugen von Zeichenketten verwendet.

        Hier darf fÅr die Ausgabe von Zeichenketten lediglich der Typ 's'
        ohne Angabe der Breite verwendet werden.

        Bei der Ausgabe von numerischen Werten ist zu beachten, dass die
        Breite dazu dient, Zahlen auf eine bestimmte Anzahl von Stellen mit
        Nullen aufzufÅllen.

        Beipiel: (Name 'TEST', Nummer des Teiles 11)

        "%s.%03d"

        Erzeugt z.B. folgenden Filenamen:

        "TEST.011"

        ..oder

        "%s.p%02x"

        Erzeugt:

        "test.p0b"


        8 Nachtrag
        8 Nachtrag
        __________

        Die Mîglichkeiten der Konfiguration von FFR sind so komplex, dass
        es nicht leicht ist, im Rahmen dieser Anleitung alles erschîpfend
        zu erîrtern. Einige Passagen sind absichtlich sehr allgemein ge-
        halten, um nicht tausendmal dasselbe erklÑren zu mÅssen. Ich denke
        aber, dass die Informationen fÅr findige OMs vollkommen ausreichen
        sollten, zudem in der Konfigurationsdatei schon einiges an Bei-
        spielen vordefiniert ist. Otto-Normal-OM wird wahrscheinlich ohne-
        hin nie in die Verlegenheit kommen, an der Konfiguration weiter-
        reichende énderungen vorzunehmen. Die einzige Anpassung, die jeder
        auf jeden Fall vornehmen sollte, ist das Eintragen des eigenen Ruf-
        zeichens in die Konfigurationsdatei.
        Gern bin ich auch bereit, bei Bedarf, z.B. dem Autreten von neuen
        Kodierern, entsprechende Konfigurationen vorzunehmen oder dabei zu
        helfen.

        Die vorliegende Version ist mit Sicherheit noch nicht das Non-Plus-
        Ultra, sollte aber fÅr die tÑgliche Arbeit ausreichend sein. Auf
        jeden Fall aber ist sie zukunftssicherer als die VorgÑngerversio-
        nen, die sich starr nach dem Mailboxsystem in DL gerichtet haben.

        Auf Aufwendige BedienungsoberflÑchen verzichte ich aus GrÅnden der
        PortabilitÑt. Auf diese Weise dÅrfte es keine grossen Schwierig-
        keiten bereiten, FFR auf anderen Computern zu compilieren. Ein
        weiterer Vorteil ist der relativ geringe Speicherbedarf. Zum aus-
        fÅhren von FFR sind auf einem MSDOS-System lediglich 100k freier
        Anwendungsspeicher notwendig, so dass FFR durchaus von anderen
        Programmen aus aufgerufen werden kann, z.B. aus SP heraus. In sol-
        chen FÑllen empfiehlt es sich SHARE zu installieren, um Dateizu-
        griffskonflikten vorzubeugen! Manche Programme schliessen ihre
        Savefiles nur bei Beendigung, so dass Schreibzugriffe auf diese
        Files zu ihrer Zerstîrung fÅhren kînnen!!


        9. Weitergabe von FFR
        9. Weitergabe von FFR
        _____________________

        FFR darf nur vollstÑndig und kostenlos weitergegeben werden, d.h.
                     ___________     _________                           
        C-Sources, Anleitung und ausfÅhrbares File. énderungen an den
        Sources bitte ich mir mitzuteilen, damit ich diese, wenn sinnvoll,
        in zukÅnftigen Versionen berÅcksichtigen kann. Ebenfalls muss bei
        der Weitergabe deutlich auf eigene énderungen hingewiesen werden.
        Da ich FFR kostenlos abgebe, kann ich verlangen, dass man diese
        Auflagen beachtet.


        10. Bezug von FFR
        10. Bezug von FFR
        _________________

        Allgemein spiele ich FFR in die Mailboxen ein, so dass man es sich
        auf diesem Wege beschaffen kann.

        Wer nicht die Mîglichkeit hat, FFR aus den Boxen auszulesen, sei es
        wegen fehlendem Dekodierer, schlechte Links usw, kann FFR auch per
        Disk + SASE beziehen.

        Meine Adresse:

                Axel Bauda
                Potsdamer Str.43
        D-w2850 Bremerhaven 21

        Mîgliche Formate: Alle Åblichen MSDOS-Formate.

        Wer eine Spende beilegt, dem sei schon im Vorraus gedankt. Ich gebe
        zu Bedenken, dass in FFR inzwischen 8 Monate Arbeit und so manch'
        durchprogrammierte Nacht steckt......

        Bankverbindung: Postgiroamt Hamburg,
                        BLZ 200 100 20,
                        Kto: 5413 91-206


