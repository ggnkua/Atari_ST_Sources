' Erweiterte FORM_DO()-Routine/userdefined objects fÅr GFA-BASIC 3.x
' Basierend auf einem Artikel in der ST COMPUTER
'
' Komplett Åberarbeitet und insbesondere um Flydials, Checkboxen usw.
' erweitert von Gregi Duchalski, Baueracker 15a, 4690 Herne 1
' eMail-Adresse: GREGOR DUCHALSKI @ DO im MausNet.
'
' last change 06.08.92
' ------------------------------------------------------------------------------
' ACHTUNG: Sollten Sie dieses Listing im LST-Format erhalten haben, so mÅssen <=
' Sie zunÑchst die INLINEs in der Prozedur 'userdef_inlines' einladen!        <=
'
' Zu diesem Listing gehîrt die FORM_DO.RSC-Datei. Zum besseren VerstÑndnis
' sollten Sie sich diese Dialogbox mit einem RCS ansehen.
' Auûerdem sollten Sie die EinfÅhrung in FORM_DO.TXT lesen.
'
' Das ist die erste Version der neuen Flydial-Routinen. Verbesserungen werden
' sicher noch folgen. Also wenn Sie VorschlÑge haben: Her damit!
' ------------------------------------------------------------------------------
' GrundsÑtzliches...
'  Die Adressen der DialogbÑume befinden sich im Feld rsc_adr%(), die Koordinaten
'  in den Feldern rsc_x&(),rsc_y&(),rsc_b&(),rsc_h&(). Die einzelnen Funktionen
'  werden meistens nur mit der Baumnummer aufgerufen, das spart Tipparbeit.
'
'  Mit der Funktion rsc_draw() wird der Dialog gezeichnet. Dabei wird der
'  Hintergrund NICHT gesichert, um Auflîsungs-Problemen aus dem Wege zu gehen.
'  Wollen Sie mehrere Dialogboxen Åbereinander darstellen, mÅssen Sie sich um
'  die Hintergrund-Restauration kÅmmern!
'
' Neue erweiterte Editier-Mîglichkeiten...
' -Spezielle Tastenbelegungen:
'  SHIFT-LINKS/RECHTS springt an den Anfang/das Ende eines Eingabefeldes
'  CLRHOME/SHIFT-CLRHOME springt zum ersten/letzten Eingabefeld
'  SHIFT-HOCH/RUNTER macht das Gleiche
'  UNDO bricht den Dialog ab, wenn es eine 'Abbruch'-Taste gibt.
'
' -Tastaturbedienung Åber ALTERNATE:
'  Im oberen Byte von OB_TYPE wird der SCAN-Code der gewÅnschten Taste einge-
'  tragen. Beispiel: 97 fÅr 'Abbruch', 98 fÅr 'Hilfe'
'  Somit lassen Sie sich Objekte mit der Taste ALTERNATE und dem unterstrichenen
'  Buchstaben auswÑhlen.
'
' -Sonstiges:
'  Der Cursor lÑût sich in Eingabefeldern zeichengenau mit der Maus
'  positionieren.
'
init
'
' Resource laden. Hier muû natÅrlich Ihr persînlicher Pfad rein!              <=
rsc_laden("D:\BINDINGS\FORM_DO\FORM_DO.RSC",0)
rsc_draw(0,0,10)
'
' Dialogaufruf (Objektbaum,Startobjekt, in obj& steht am Ende das Objekt, in
' dem der Cursor steht). Unsauber: In mc& steht die Anzahl der Mausklicks.
rsc&=@form_do(0,1,obj&)
'
~RSRC_FREE()
EDIT
'
> PROCEDURE init
  '
  ' Hier werden ein Paar Werte geholt, die von den RSC-Routinen
  ' benîtigt werden.
  '
  ' Breite und Hîhe eines Zeichens...
  ~GRAF_HANDLE(wchar&,hchar&,a&,a&)
  '
  ' Bildschirmausmaûe...
  max_w&=SUCC(WORK_OUT(0))
  max_h&=SUCC(WORK_OUT(1))
  max_p&=@vdi_planes(V~H)
  '
  ' Hintergrundfenster. Wichtig fÅr die Flydials...
  ~WIND_GET(0,7,deskx&,desky&,deskw&,deskh&)
  '
  ' Bildschirm fÑrben...
  ~FORM_DIAL(3,deskx&,desky&,deskw&,deskh&,deskx&,desky&,deskw&,deskh&)
  '
  ' Die neuen Ausgabe-Routinen vorbereiten...
  userdef_inlines
  '
  ' Maus als Pfeil...
  DEFMOUSE 0
  '
RETURN
> FUNCTION vdi_planes(handle&)
$F%
'
' Ermittelt sauber die verfÅgbaren Bitplanes
'
INTIN(0)=1
'
CONTRL(6)=handle&
'
VDISYS 102,1,0
'
RETURN INTOUT(4)
ENDFUNC
'
> PROCEDURE rsc_laden(a$,l&)
LOCAL i&
'
' Setzt das Bit b& in a&, und zwar TRUE bei c&<>0...
DEFFN bsc(a&,b&,c&)=-MUL((c&=0),BCLR(a&,b&))-MUL((c&<>0),BSET(a&,b&))
'
' Vertauscht High- und Low-Byte von OB_TYPE...
DEFFN swap_type(a|,b|)=BYTE(SHR(OB_TYPE(rsc_adr%(a|),b|),8))
'
' GegenstÅck zur Prozedur rsc_flags()...
DEFFN rsc_flags(a&,b&,c&)=BTST(OB_FLAGS(rsc_adr%(a&),b&),c&)
'
' GegenstÅck zur Prozedur rsc_state()...
DEFFN rsc_state(a&,b&,c&)=BTST(OB_STATE(rsc_adr%(a&),b&),c&)
'
DIM rsc_adr%(l&),rscx&(l&),rscy&(l&),rscb&(l&),rsch&(l&)
'
IF RSRC_LOAD(a$)=0                 ! Rsc laden...
  ALERT 3," | Fehler beim Laden der | Resource-Datei... ",1,"Abbruch",b&
  EDIT
ENDIF
'                                  ! Baumadresse ermitteln...
FOR i&=0 TO l&
  '
  ~RSRC_GADDR(0,i&,rsc_adr%(i&))
  ~FORM_CENTER(rsc_adr%(i&),rscx&(i&),rscy&(i&),rscb&(i&),rsch&(i&))
  '
NEXT i&
'
rsc_walk_tree(0,l&)                ! Userdefs eintragen
'
RETURN
' -------------------------------------------------------- RSC-Routinen
' Diese Routinen dienen nur der Vereinfachung.
'
> PROCEDURE rsc_draw(a&,b&,c&)
LOCAL a!,h&,w&
'
' Zeichnet den Objektbaum a& ab Objekt b& mit der Tiefe c&
'
' Der Dialoghintergrund wird dabei in a$ gesichert, sofern er 32K nicht Åber-
' steigt. Nur dann kann der Dialog SOLID verschoben werden, sonst wird nur
' ein Rahmen bewegt. Mîchten Sie auch grîûere HntergrÅnde sichern, so kommen
' Sie nicht um eine eigene GET/PUT-Routine herum, die ich aus PlatzgrÅnden
' nicht in die Routinen aufgenommen habe.
'
IF c&>3 AND c&<>11
  w&=MIN(PRED(max_w&),ADD(ADD(rscx&(a&),rscb&(a&)),10))
  h&=MIN(PRED(max_h&),ADD(ADD(rscy&(a&),rsch&(a&)),10))
  '
  ' Paût der Hintergrund in einen String...
  a!=(rscb&(a&)/8*rsch&(a&)*max_p&)<=32760
  '
  ' Wenn ja, dann getten...
  IF a!
    GET rscx&(a&),rscy&(a&),ADD(rscx&(a&),PRED(rscb&(a&))),ADD(rscy&(a&),PRED(rsch&(a&))),rsc_back$
  ENDIF
  '
  ' Optischer Schnickschnack...
  ~FORM_DIAL(1,ADD(rscx&(a&),DIV(rscb&(a&),2)),ADD(rscy&(a&),DIV(rsch&(a&),2)),0,0,rscx&(a&),rscy&(a&),rscb&(a&),rsch&(a&))
  '
ENDIF
'
~OBJC_DRAW(rsc_adr%(a&),b&,c&,rscx&(a&),rscy&(a&),rscb&(a&),rsch&(a&))
'
RETURN
> PROCEDURE rsc_back(a&)
'
' Redraw fÅr den Dialoghintergrund auslîsen...
' Wenn Sie den Hintergrund zuvor gesichert haben, so sollten Sie ihn hier
' natÅrlich wieder hinsetzen.
~FORM_DIAL(3,rscx&(a|),rscy&(a|),rscb&(a|),rsch&(a|),rscx&(a|),rscy&(a|),rscb&(a|),rsch&(a|))
'
' Optischer Schnickschnack...
~FORM_DIAL(2,ADD(rscx&(a|),DIV(rscb&(a|),2)),ADD(rscy&(a|),DIV(rsch&(a|),2)),0,0,rscx&(a|),rscy&(a|),rscb&(a|),rsch&(a|))
'
RETURN
'
> PROCEDURE rsc_state(a&,b&,c&,d&)
'
' Setzt das Bit c& in OB_STATE() des Objektes b& im Baum a&
' d&=0 : FALSE, d&<>0 : TRUE
'
OB_STATE(rsc_adr%(a&),b&)=@bsc(OB_STATE(rsc_adr%(a&),b&),c&,d&)
'
RETURN
> PROCEDURE rsc_flags(a&,b&,c&,d&)
'
' Setzt das Bit c& in OB_FLAGS() des Objektes b& im Baum a&
' d&=0 : FALSE, d&<>0 : TRUE
'
OB_FLAGS(rsc_adr%(a&),b&)=@bsc(OB_FLAGS(rsc_adr%(a&),b&),c&,d&)
'
RETURN
'
> PROCEDURE rsc_fly_dial(a&)
LOCAL a!,b&,h&,x&,y&,a$
'
DEFMOUSE 4
~GRAF_MKSTATE(mx&,my&,mb&,shift&)
'
x&=SUB(mx&,SUCC(rscx&(a&)))
y&=SUB(my&,SUCC(rscy&(a&)))
'
mx&=rscx&(a&)
my&=rscy&(a&)
'
' Paût es in einen String...
a!=(MUL(MUL(DIV(rscb&(a&),8),rsch&(a&)),max_p&))<=32760     ! GETSIZE
'
' Wenn ja, dann getten...
IF a!
  GET rscx&(a&),rscy&(a&),ADD(rscx&(a&),PRED(rscb&(a&))),ADD(rscy&(a&),PRED(rsch&(a&))),a$
  '
  ' ansonsten Cursor aus und Box zeichnen...
ELSE
  ~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,3,pos&)
  rsc_back(a&)
  GRAPHMODE 3
  BOX mx&,my&,ADD(mx&,PRED(rscb&(a&))),ADD(my&,PRED(rsch&(a&)))
ENDIF
'
REPEAT
  '
  ~GRAF_MKSTATE(b&,h&,mb&,shift&)
  '
  b&=SUB(PRED(b&),x&)
  h&=SUB(PRED(h&),y&)
  '
  b&=MIN(MAX(b&,deskx&),deskx&+deskw&-rscb&(a&))
  h&=MIN(MAX(h&,desky&),desky&+deskh&-rsch&(a&))
  '
  IF b&<>mx& OR h&<>my&
    '
    ' Wenn der Hintergr. gerettet werden konnte...
    IF a!
      '
      HIDEM ! Besser: ~GRAF_MOUSE(256,0), gibt aber Flecken im Interpreter...
      '
      ~C:movedial%(L:ADD(V:a$,6),L:ADD(V:rsc_back$,6),b&,h&,rscb&(a&),rsch&(a&),mx&,my&,V~H,max_w&,max_h&,max_p&)
      '
      SHOWM ! Besser: ~GRAF_MOUSE(257,0), gibt aber Flecken im Interpreter...
      '
    ELSE
      ' ansonsten nur einen Rahmen bewegen...
      BOX mx&,my&,ADD(mx&,PRED(rscb&(a&))),ADD(my&,PRED(rsch&(a&)))
    ENDIF
    '
    mx&=b&
    my&=h&
    '
    ' Hintergr. nicht gerettet, wieder ein Rahmen...
    IF NOT a!
      BOX mx&,my&,ADD(mx&,PRED(rscb&(a&))),ADD(my&,PRED(rsch&(a&)))
    ENDIF
    '
  ENDIF
  '
UNTIL mb&=0
'
x&=mx&
y&=my&
'
DEFMOUSE 0
'
' Redraw fÅr den Dialoghintergrund auslîsen...
'  ~FORM_DIAL(3,rscx&(a&),rscy&(a&),rscb&(a&),rscb&(a&),rscx&(a&),rscy&(a&),rscb&(a&),rscb&(a&))
'
OB_X(rsc_adr%(a&),0)=ADD(x&,3)
OB_Y(rsc_adr%(a&),0)=ADD(y&,3)
rscx&(a&)=x&
rscy&(a&)=y&
'
b&=MIN(PRED(max_w&),ADD(ADD(rscx&(a&),rscb&(a&)),10))
h&=MIN(PRED(max_h&),ADD(ADD(rscy&(a&),rsch&(a&)),10))
'
' Hintergr. nicht gerettet...
IF NOT a!
  ' ...also Dialog neu zeichnen und Cursor einschalten
  GRAPHMODE 1
  rsc_draw(a&,0,10)
  ~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,1,pos&)
ENDIF
'
RETURN
' ------------------------------------------------ FORM_DO()-Routine
' Hier beginnt die eigentliche Dialogroutine.
'
> FUNCTION form_do(a&,b&,VAR obj&)
$F%
LOCAL c&,mx&,my&,mb&,rsc&,shift&,key&,a!
'
' In mc& steht die Anzahl der Mausklicks, daher nicht lokal
' In obj& steht das Objekt, in dem der Cursor steht
'
~WIND_UPDATE(1)                                 !Appl. Åberni. Kontrolle...
~WIND_UPDATE(3)
'
b&=MAX(0,b&)                                    !Positivieren
obj&=-1
'
IF @rsc_flags(a&,b&,3) AND (NOT @rsc_state(a&,b&,3))!Start-Objekt editierbar?
nxt_obj&=b&                                       !und nicht disabled
'
ELSE                                            !nicht editierbar,
nxt_obj&=b&
'
REPEAT
  nxt_obj&=@form_search_flag(a&,nxt_obj&,3,1) !also editierbares suchen
UNTIL nxt_obj&=0 OR (NOT @rsc_flags(a&,nxt_obj&,7)) !Event. hidden?
'
ENDIF
'
a!=(nxt_obj&<>0)                                !Editable Objekt vorhanden
'
REPEAT                                          !Nun geht's los...
IF obj&<>nxt_obj& AND nxt_obj&<>0
  obj&=nxt_obj&
  ~OBJC_EDIT(rsc_adr%(a&),obj&,0,0,1,pos&)    !Cursor darstellen
ENDIF
'
rsc&=EVNT_MULTI(&X11,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,shift&,key&,mc&)
'
IF BTST(rsc&,0)                               !Tastaturereignis...
  c&=@form_key(a&,obj&,shift&,key&,nxt_obj&)
  '
ELSE                                          !Mausereignis...
  c&=OBJC_FIND(rsc_adr%(a&),0,100,mx&,my&)    !Objekt unter der Maus ermitteln
  c&=@form_maus(a&,c&,mc&,nxt_obj&)
  '
ENDIF
'
IF c&=0 OR (obj&<>nxt_obj& AND nxt_obj&<>0)
  ~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,3,pos&) !Cursor weg
ENDIF
UNTIL c&=0                                      !Bis Touchexit-Objekt
'
~WIND_UPDATE(2)                                 !Appl. gibt Kontrolle ab...
~WIND_UPDATE(0)
'
RETURN nxt_obj&
ENDFUNC
'
> FUNCTION form_maus(a&,b&,mc&,VAR nxt_obj&)
$F%
LOCAL c&
'
' Hier wird der Mausklick ausgewertet.
' a&       : Objektbaum
' b&       : Objekt unter der Maus
' mc&      : Anzahl Klicks
' nxt_obj& :
'
IF b&=-1                                  ! Daneben...
OUT 2,7
RETURN obj&
'
ELSE
' --------------------------------------- Flydial...
IF @rsc_flags(a&,b&,10)                 ! (OB_FLAGS 10)
rsc_fly_dial(a&)
nxt_obj&=obj&
RETURN 1
'
ELSE IF @rsc_state(a&,b&,3)             ! ...Disabled
RETURN obj&
'
ELSE IF @rsc_flags(a&,b&,3)             ! ...Editable
RETURN @form_edit(a&,b&)
'
ELSE                                    ! sonst form_button
'
c&=FORM_BUTTON(rsc_adr%(a&),b&,mc&,nxt_obj&)
'
nxt_obj&=WORD(BCLR(nxt_obj&,15))
'
RETURN c&
ENDIF
'
ENDIF
'
ENDFUNC
> FUNCTION form_edit(a&,b&)
$F%
LOCAL a%,b%,i&,l&,m&,p&,x&,a|
'
a%=rsc_adr%(a&)                     !Baum-Adresse
b%=OB_SPEC(a%,b&)                   !
'
~OBJC_OFFSET(a%,b&,x&,c&)           !Absolute Koordinaten
'
~GRAF_HANDLE(w&,c&,c&,c&)           !Breite eines Standardzeichens
'
l&=CARD{ADD(b%,26)}                 !LÑnge des Objekts
'
SELECT CARD{ADD(b%,16)}             !Ausrichtung...
'
CASE 0                              !...linksbÅndig
m&=TRUNC((mx&-x&)/w&+0.5)
'
CASE 1                              !...rechtsbÅndig
m&=TRUNC((mx&-x&-OB_W(a%,b&)+l&*w&)/w&-0.5)
'
CASE 2                              !...zentriert
m&=TRUNC((mx&-x&-(OB_W(a%,b&)-l&*w&)/2)/w&)
'
ENDSELECT
'
CLR p&,i&
'
IF m&>0
'
REPEAT
'
IF BYTE{ADD({ADD(b%,4)},i&)}=95 !'_'
INC p&
ENDIF
'
INC i&
UNTIL i&=m& OR i&=l&
'
ELSE
p&=0
ENDIF
'
~OBJC_EDIT(a%,obj&,0,pos&,3,pos&)   !Cursor weg
'
a|=BYTE{ADD({b%},p&)}               !Zeichen merken
BYTE{ADD({b%},p&)}=0                !und durch 0 ersetzen
'
~OBJC_EDIT(a%,b&,0,pos&,1,pos&)     !Cursor setzen
BYTE{ADD({b%},p&)}=a|               !und Zeichen restaurieren
'
nxt_obj&=b&
obj&=b&
'
RETURN 1
ENDFUNC
'
> FUNCTION form_key(a&,obj&,shift&,key&,VAR nxt_obj&)
$F%
'
' Hier wird ein Tastendruck ausgewertet. Wenn er keine Sonderfunktion
' wie z.B. CLR-HOME bedient, so wird nach einem tastaturbedienbaren Objekt
' gesucht. Beim DrÅcken der UNDO-Taste wird nach einem Objekt gesucht, das
' mit dem Buchstaben 'A' bedient wird. Daraus folgt: 'A' sollten Sie nur fÅr
' die 'Abbruch'-Taste verwenden.
'
SELECT key&
'
CASE &H6100                               ! UNDO...
c&=@form_search_key(a&,8,SHL&(30,8))    ! ...nach 'A' suchen
'
IF c&
RETURN @form_maus(a&,c&,1,nxt_obj&)
'
ENDIF
'
CASE &H1C0D,&H720D                        ! RETURN/ENTER...
nxt_obj&=@form_search_flag(a&,0,1,1)    ! ...Default-Button suchen
IF nxt_obj&                             ! ...gefunden
RETURN FORM_BUTTON(rsc_adr%(a&),nxt_obj&,1,nxt_obj&)
ENDIF
'
CASE &H4D36                               ! SHIFT right...
IF a!
~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,3,pos&)
~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,1,pos&)
ENDIF
'
CASE &H4B34                               ! SHIFT left...
IF a!
'
~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,3,pos&)
'
a|=BYTE{{OB_SPEC(rsc_adr%(a&),obj&)}}
BYTE{{OB_SPEC(rsc_adr%(a&),obj&)}}=0
'
~OBJC_EDIT(rsc_adr%(a&),obj&,0,pos&,1,pos&)
BYTE{{OB_SPEC(rsc_adr%(a&),obj&)}}=a|
'
ENDIF
'
CASE &H5000                               ! Down
nxt_obj&=@form_search_flag(a&,obj&,3,1)
'
CASE &H4800                               ! Up
nxt_obj&=@form_search_flag(a&,obj&,3,-1)
'
CASE &H5032,&H4737                        ! SHIFT down, SHIFT home =>letztes Feld
REPEAT
nxt_obj&=obj&
obj&=@form_search_flag(a&,obj&,3,1)
UNTIL obj&=0
'
CASE &H4838,&H4700                        ! SHIFT up, HOME =>erstes Feld
nxt_obj&=@form_search_flag(a&,0,3,1)
'
CASE &H1C0D,&H720D                        ! RETURN/ENTER
nxt_obj&=@form_search_flag(a&,0,1,1)    ! Default-Button suchen
IF nxt_obj&                             ! gefunden
RETURN FORM_BUTTON(rsc_adr%(a&),nxt_obj&,1,nxt_obj&)
ENDIF
'
DEFAULT                                   ! Keine Steuertaste =>Objekt suchen
c&=@form_search_key(a&,shift&,key&)
'
IF c&
RETURN @form_maus(a&,c&,1,nxt_obj&)
'
ENDIF
'
nxt_obj&=obj&
'
' Achtung: Bei TOS 1.0: fÅhrt hier '_' zum Absturz:
~OBJC_EDIT(rsc_adr%(a&),obj&,key&,pos&,2,pos&)
'
ENDSELECT
'
RETURN -1
ENDFUNC
'
> FUNCTION form_search_flag(a&,c&,a|,d&)
$F%
LOCAL b&
'
' Sucht im Baum a& ab Objekt c& das gesetzte OB_FLAG a| mit Schrittweite d&..
'
b&=c&
'
REPEAT
ADD b&,d&
IF @rsc_flags(a&,b&,a|) AND (NOT @rsc_state(a&,b&,3))
RETURN b&
ENDIF
UNTIL (b&<=0) OR @rsc_flags(a&,b&,5)! Exit wenn <=0 oder LAST-OBJECT gesetzt.
'
RETURN 0 !c&                           ! Nichts gefunden
ENDFUNC
> FUNCTION form_search_key(a&,shift&,key&)
$F%
LOCAL b&
'
' Findet ein Objekt im Baum a&, dem die Taste key& zugeordnet wurde...
'
scan|=SHR&(key&,8)
'
IF scan|=98 OR scan|=97 OR shift&=8     ! HELP, UNDO oder ALT...
'
REPEAT
INC b&
IF scan|=@swap_type(a&,b&)
RETURN b&                         ! ...gefunden
ENDIF
UNTIL @rsc_flags(a&,b&,5)             ! ...bis Last-Objekt gesetzt
'
ENDIF
'
RETURN 0
ENDFUNC
' ------------------------------------------------ Userdef Object einbinden
> PROCEDURE rsc_walk_tree(a&,b&)
LOCAL i&,tree&,obj&,anz&,a%,l%,a$,b$
'
' Hier wird die Resource nach userdef-Objekten durchsucht. Die gefundenen
' werden zunÑchst in einen String eingetragen. Auûerdem wird gespeichert,
' wieviel Speicher die Strukturen benîtigen. Diesen kînnen wir danach Åber
' MALLOC anfordern.
'
' Zur Festlegung der Objektart werden die unbenutzten OB_FLAGS-Bits benutzt.
' Damit bleibt das obere Byte von OB_TYPE fÅr andere Aufgaben (z.B. Tastencodes)
' frei:
'
' Bit  9 -> Menue-Niceline
' Bit 10 -> Flydial
' Bit 11 -> Ankreuz-Button
' Bit 12 -> Kreis-Button
' Bit 13 -> Linie
' Bit 14 -> Button/String
' ----------------------------------------------------- Objekte ermitteln...
FOR tree&=a& TO b&                  ! Alle BÑume durchgehen...
'
obj&=-1
'
REPEAT
'
INC obj&
rsc_make_userdef(tree&,obj&,a$,l%)
'
UNTIL @rsc_flags(tree&,obj&,5)    ! ...bis Last-Objekt gesetzt
'
NEXT tree&
' -----------------------------------------------------
' In a$ haben wird jetzt die Objekte, in l% steht die Grîûe des anzufordernden
' Speicherbereiches.
'
userblk%=MALLOC(l%)                 ! Platz fÅr USERBLK anfordern
'
IF userblk%                         ! Konnte angefordert werden...
'
a%=userblk%
'
REPEAT                            ! Allen Objekten einen USERBLK zuweisen...
'
tree&=CVI(a$)                   ! ...Baumnr.
obj&=CVI(MID$(a$,3))            ! ...Objektnr.
b%=CVL(MID$(a$,5))              ! ...Ausgabe-Routine
'
SELECT b%                       ! Flydial oder Niceline...
CASE draw_flydial%,draw_niceline%
'
{a%}=b%
{ADD(a%,4)}=V~H
l%=8
'
DEFAULT                         ! Alles andere...
'
{a%}=b%
'
b$=CHAR{OB_SPEC(rsc_adr%(tree&),obj&)}
pos&=INSTR(b$,"[")            ! ...Pos. des unterstr. Buchst. ermitteln
IF pos&
b$=LEFT$(b$,PRED(pos&))+MID$(b$,SUCC(pos&))
CHAR{OB_SPEC(rsc_adr%(tree&),obj&)}=b$
ENDIF
'
{ADD(a%,4)}=ADD(a%,8)         ! ...in USERBLK Zeiger eintragen
'
INT{ADD(a%,8)}=V~H            ! WORD u_handle;  /* Bildschirmhandle V~H
'
{ADD(a%,10)}=OB_SPEC(rsc_adr%(tree&),obj&) ! BYTE *u_text;   /* Adresse des Textes
'
BYTE{ADD(a%,14)}=wchar&       ! BYTE u_wchar;   /* Breite eines Zeichens
BYTE{ADD(a%,15)}=hchar&       ! BYTE u_hchar;   /* Hîhe eines Zeichens
INT{ADD(a%,16)}=pos&          ! WORD u_pos;     /* Pos. d. unterstr. Buchst.
'
l%=18
'
ENDSELECT
'
OB_SPEC(rsc_adr%(tree&),obj&)=a%! OB_SPEC() zeigt jetzt auf den USERBLK
'
ADD a%,l%                       ! nÑchster USERBLK
'
a$=MID$(a$,9)                   ! a$ verkÅrzen
'
UNTIL a$=""
'
ELSE                                ! Oho, kein Speicher mehr frei
~FORM_ALERT(1,"[3][ | Zu wenig Speicher verfÅgbar... ][Abbruch]")
END
ENDIF
'
RETURN
> PROCEDURE rsc_make_userdef(tree&,obj&,VAR a$,l%)
LOCAL a&,a%
'
' Hier stellen wir fest, ob das Objekt ein userdef sein soll. Wenn ja, dann
' Ñndern wir OB_TYPE entsprechend und tragen das Objekt in a$ ein.
' In l% zÑhlen wir die Grîûe des USERBLKs mit. OB_TYPE() wird verknÅpft, um
' das obere Byte nicht zu zerstîren.
'
a&=OB_FLAGS(rsc_adr%(tree&),obj&)      ! Flags auswerten...
a&=SHR(a&,9)                           ! nur die interessanten beachten
'
IF a&
'
SELECT a&
CASE &X1                             ! ...Menue-Niceline
'
a%=draw_niceline%
ADD l%,8
'
CASE &X10                            ! ...Flydial
rsc_state(tree&,obj&,4,0)
'
a%=draw_flydial%
ADD l%,8
'
CASE &X100                           ! ...Ankreuz
a%=draw_kreuz%
ADD l%,18
'
CASE &X1000                          ! ...Kreisbutton
a%=draw_kreis%
ADD l%,18
'
CASE &X10000                         ! ...Linie
a%=draw_linie%
ADD l%,18
'
CASE &X100000                        ! ...Button/String mit unterstr. Buchstaben
a%=draw_button%
ADD l%,18
'
ENDSELECT
'
OB_TYPE(rsc_adr%(tree&),obj&)=AND(OR(OB_TYPE(rsc_adr%(tree&),obj&),&HFF),&HFF18)
a$=a$+MKI$(tree&)+MKI$(obj&)+MKL$(a%)
'
ENDIF
'
RETURN
'
PROCEDURE userdef_inlines
'
' Hier also befinden sich die mit Pure C erstellten neuen Objektausgaberoutinen.
' Die Routinen werden zunÑchst kopiert, da es sonst Probleme beim mehrfachen
' Starten des Programmes geben wÅrde. Dann wird jede Routine reloziert und ist
' damit fertig zur Einbindung...
'
' Die Routinen befinden sich jeweils im ersten INLINE. Der zweite INLINE enthÑlt
' dann spÑter die relozierte Routine inklusive BSS-Segment.
'
' Relozier-Routine (RELOCATE)...
INLINE relo%,108
'
' Movedial (MOVEDIAL)...
INLINE a%,1593
INLINE movedial%,3164
BMOVE a%,movedial%,1593
'
' Flydial (D_FLYDIAL)...
INLINE a%,675
INLINE draw_flydial%,2234
BMOVE a%,draw_flydial%,675
'
' Ankreuzbutton (D_KREUZ)...
INLINE a%,701
INLINE draw_kreuz%,2260
BMOVE a%,draw_kreuz%,701
'
' Kreis (D_KREIS)...
INLINE a%,662
INLINE draw_kreis%,2224
BMOVE a%,draw_kreis%,662
'
' Text mit Linie (D_LINIE)...
INLINE a%,360
INLINE draw_linie%,1928
BMOVE a%,draw_linie%,360
'
' Unterstr. Button (D_BUTTON)...
INLINE a%,1050
INLINE draw_button%,2606
BMOVE a%,draw_button%,1050
'
' Menue-Niceline (D_NICELI)
INLINE a%,457
INLINE draw_niceline%,2022
BMOVE a%,draw_niceline%,457
'
' Routinen relozieren...
~C:relo%(L:movedial%)
'
~C:relo%(L:draw_flydial%)
~C:relo%(L:draw_kreuz%)
~C:relo%(L:draw_kreis%)
~C:relo%(L:draw_linie%)
~C:relo%(L:draw_button%)
~C:relo%(L:draw_niceline%)
'
RETURN
