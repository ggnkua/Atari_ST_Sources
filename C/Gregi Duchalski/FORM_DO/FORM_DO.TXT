Einbindung von 'userdefined objects' in GFA-BASIC 3.x
(c)1992 by Gregor Duchalski

Mit den hier vorliegenden Routinen kînnen Sie endlich auch GFA-BASIC-Programme
mit zeitgemÑûen Dialogboxen versehen:

 -Flydial-Ecke,
  damit verbunden natÅrlich frei verschiebbare Dialoge im SOLID-Modus
 -Unterstrichene Dialogtitel
 -Ankreuz-Buttons
 -Runde Buttons
 -GeÑnderte Menuestriche, sog. 'nicelines'
 -Tastaturbedienbare Buttons mit unterstr. Buchstaben

Die Routinen funktionieren in allen ST/TT-Auflîsungen!

Die Realisation der Objekte orientiert sich dabei eng an den Flydials von Julian
Reschke, dem die Ehre gebÅhrt, hier einen weitreichenden Standard geschaffen zu
haben.

Mein Dank geht an Michael Seyfried fÅr die Relozier-Routine und an Dirk Koenen,
der einige nÅtzlich Flydial-Routinen beigesteuert hat.

Das ist die erste îffentliche Version der neuen Flydials. Sicher werden noch
Verbesserungen folgen. Soll z.B. der Speicherbedarf verringert werden, alles in
einem INLINE untergebracht werden usw. Wenn Sie also weitere VorschlÑge haben,
immer her damit!

Die Routinen sind Freeware, die Weitergabe ist erwÅnscht. Allerdings sollten die
Funktionen nur komplett weitergegeben werden. Sollten Sie die Routinen in eige-
nen Programmen verwenden, so sollte der Ursprung erwÑhnt werden.

Meine Adresse : Gregor Duchalski, Baueracker 15a, 4690 Herne 1

oder per eMail: GREGOR DUCHALSKI @ DO im Mausnetz

--------------------------------------------------------------------------------
Folgende Dateien sollten Sie besitzen...
--------------------------------------------------------------------------------

  FORM_DO.TXT        Dieser Text
  FORM_DO.LST        Beispiel-Listing
  FORM_DO.RSC        Beispiel-Resource
  FORM_DO.DFN        RSC-Definitionsfile
  INTERFACE.IMG      Beispiel fÅr die INTERFACE-Einbindung

 *SOURCEN.C          In diesem Ordner finden Sie die Ausgaberoutinen im C-Quell-
                     code und die compilierten INLINES

  D_BUTTON.C         Unterstr. Buttons/Strings
  D_BUTTON.INL

  D_FLYDIAL.C        Flydial
  D_FLYDIAL.INL

  D_KREUZ.C          Ankreuz-Button
  D_KREUZ.INL

  D_KREIS.C          Runder Radiobutton
  D_KREIS.INL

  D_LINIE.C          Unterstrichener Text
  D_LINIE.INL

  D_NICELINE.C       Anderer Menuestrich
  D_NICELINE.INL

  MOVEDIAL.C         Bewegt die Dialogbox
  MOVEDIAL.INL

  RELOCATE.C         Relozier-Routine
  RELOCATE.INL

  ERMITTEL.LST       Ermittelt die benîtigte INLINE-Grîûe

Das Beispiel-Listing liegt aus KompatibilitÑtsgrÅnden im ASCII-Format vor. Daher
mÅssen Sie zu Beginn zunÑchst die INLINES einladen. Die C-Routinen benîtigen Sie
nur, wenn Sie VerÑnderungen an den Ausgabefunktionen vornehmen wollen.

Dieser Text stellt keine umfassende EinfÅhrung in die userdefined objects dar,
ein gewisses Vorwissen sollten Sie also mitbringen. LiteraturvorschlÑge:

ST-COMPUTER 2/91, S. 100, Button-Designer, Hans-JÅrgen Riechstein
ST-MAGAZIN  4/91, S. 78, Objekte u. Resourcen, Dietmar Rabich
ATARI PROFIBUCH, 10 Auflage, S. 778, Frei definierte Objekttypen

--------------------------------------------------------------------------------
So benutzen Sie die Routinen...
--------------------------------------------------------------------------------

Objekte festlegen

 Im RCS mÅssen wir festlegen, wie das Objekt spÑter aussehen soll. Dazu verwen-
 den wir die unbenutzten Bits von OB_FLAGS(), im einzelnen:

   Bit  9 -> Menue-Niceline
   Bit 10 -> Flydial
   Bit 11 -> Ankreuz-Button
   Bit 12 -> Runder Button
   Bit 13 -> Unterstr. Dialogtitel
   Bit 14 -> Unterstr. Button/String

 Sie benîtigen allerdings ein RCS, indem Sie diese Werte setzen kînnen. INTERFA-
 CE bietet sich da an. Sie kînnen die Resource von INTERFACE entsprechend anpas-
 sen, die Belegung kînnen Sie dem Bild INTRFACE.IMG entnehmen.

 VerfÅgen Sie Åber kein so komfortables RCS, so mÅssen die Objekte aus der Bei-
 spiel-Resource jeweils in Ihre eigenen Resourcen kopieren.
 Welchen Typ das Objekt zunÑchst im RCS hat, ist egal. In unserem Fall nahmen
 wir ein BOXCHAR-Objekt, da es nicht viel Speicher benîtigt.

Tastenbedienung

 Um ein Objekt mit der Tastatur bedienen zu kînnen, muû ihm der SCAN-Code der
 gewÅnschten Taste mitgegeben werden. Dazu verwenden wir das unbenutzte, obere
 Byte von OB_TYPE(), auch 'extended OB_TYPE' genannt. Den Buchstaben, der un-
 terstrichen werden soll, markieren wir mit dem Zeichen '['. Ein Beispiel:
 Der Button 'Abbruch' soll Åber die Taste 'A' angesprochen werden. Dazu tragen
 wir zunÑchst im RCS als Text '[Abbruch' ein. Das 'A' den SCAN-Code 30 hat, tra-
 gen wir '30' als extended OB_TYPE ein.
 Damit unsere Routine Åberhaupt weiû, daû es sich um ein spezielles Objekt han-
 delt, setzen wir das 14.Bit von OB_STATE.

 Es ist geplant, die Auswertung direkt Åber das '['-Symbol laufen zu lassen.

--------------------------------------------------------------------------------
Hier sollten Sie nur weiterlesen, wenn Sie die Ausgaberoutinen verÑndern wollen
und Åber die nîtgen C-Kenntnisse verfÅgen...
--------------------------------------------------------------------------------

VerÑndern der Ausgaberoutinen

 Wenn Ihnen die Ausgaberoutinen nicht zusagen, so kînnen Sie diese natÅrlich
 auch verÑndern:

 In der Projektdatei mÅssen Sie 'PCSTART.O' weglassen. In den Linker-Einstel-
 lungen sollten Sie fÅr die STACK- und HEAP-Grîûe '0' eintragen. Sonst wÅrde
 der Code unnîtig verlÑngert werden, da zusÑtzlich ein Stackbereich von
 mind. 4096 Bytes eingerichtet werden wÅrde. In den Compiler-Optionen habe ich
 nur 'default char is unsigned' gesetzt, andere Einstellungen sind aber mîglich.

 Die compilierte Routine Ñhnelt einer Programmdatei. D.h. Sie hat einen 28 Bytes
 langen Header, in dem z.B. die Grîûe des TEXT, DATA und BSS-Segmentes abgelegt
 sind. Sie muû im BASIC zunÑchst reloziert werden, bevor wir sie verwenden kîn-
 nen. Stellt sich ein Problem: Beim zweiten Start des Programmes im Interpreter
 wÅrde es Probleme geben, da die Routine im INLINE ja dann bereits reloziert
 ist. Also laden wir die Routine in einen INLINE und kopieren sie bei jedem
 Programmlauf. Die Kopie relozieren wir dann. Der INLINE der Kopie ist um eini-
 ges grîûer als der INLINE, der die compilierte Routine enthÑlt. Denn er enthÑlt
 zusÑtzlich das BSS-Segment.
 Wie groû muû der zweite INLINE sein? Ganz einfach:

  28 Bytes fÅr den Programmheader
 +Grîûe des TEXT-Segmentes
 +Grîûe des DATA-Segmentes
 +Grîûe des BSS-Segmentes

 Dazu finden Sie das Programm ERMITTEL.LST im SOURCEN-Ordner. Damit laden Sie
 einfach die C-compilierte Ausgaberoutine. Ausgegeben wird dann die Grîûe des
 benîtigten INLINES.

 Nach soviel Theorie ein Beispiel:

 Wir compilieren in C eine Ausgaberoutine. Das erzeugte File 'D_BUTTON.INL' ist
 313 Bytes lang. Also sieht der 1. INLINE im Programm so aus:

  INLINE a%,313

 Hier laden wir die Routine ein.

 Mit dem ERMITTEL.LST-Programm ermitteln wir fÅr den zweiten INLINE eine Grîûe
 von 2156 Bytes. Somit haben wir den 2. INLINE:

  INLINE draw_linie%

 Beim Programmstart kopieren wir den Original-INLINE (313 Bytes) in den grîûeren
 INLINE (2156 Bytes):

  BMOVE a%,draw_button%,313

 Damit sind die Routinen bereit zum Eintragen in die Objektstruktur.

 Nach dem Laden des RSC-Files durchsuchen wir die DialogbÑume nach UOs. Das
 geschieht mit der Funktion 'rsc_walk_tree'. In einem ersten Schritt tragen wir
 alle gefundenen UOs in den String a$ ein:

  a$=a$+MKI$(tree&)+MKI$(obj&)+CHR$(art)

 In l% zÑhlen wir dabei mit, wieviel Speicher wir spÑter anfordern mÅssen.
 Dann machen wir das Objekt zu einem UO, indem wir OB_TYPE() des Objektes auf
 G_USERDEF (=24) setzen.

 Im zweiten Schritt gehen wir den String durch, erzeugen einen USERBLK fÅr jedes
 Objekt und weisen diese OB_SPEC() zu.

 Eine USERBLK-Struktur umfaût 8 Bytes umfaût und hat folgenden Aufbau:

   long *ub_code          /* Zeiger auf die Objektausgabe-Funktion */
   long ub_parm;          /* freier Parameter                      */

 Nun tragen wir also den Zeiger auf die Ausgaberoutine ein:

  {userblk%}=draw_linie%

 Als freien Parameter Åbergeben wir das Bildschirmhandle V~H, da wir es fÅr alle
 Zeichenfunktionen in der Ausgaberoutine benîtigen:

  {userblk%+4}=V~H

 Bei einem BUTTON-Objekt ist allerdings etwas mehr Aufwand erforderlich, da hier
 mehr Parameter (Text, Zeichenhîhe usw.) benîtigt werden. Zuerst tragen wir wie
 gehabt die Zeichenroutine ein:

  {userblk%}=draw_button%

 Als optionalen Paramter Åbergeben wir allerdings die Adresse einer weiteren
 Struktur:

  {userblk%+4}=userblk%+8

 Diese Struktur befindet sich direkt hinter dem USERBLK, sie ist 10 Bytes lang
 und hat folgenden Aufbau:

  WORD    u_handle;  /* Bildschirmhandle V~H      */
  LONG    *u_text;   /* Adresse des Textes        */
  BYTE    u_wchar;   /* Breite eines Zeichens     */
  BYTE    u_hchar;   /* Hîhe eines Zeichens       */
  WORD    u_pos;     /* Pos. d. unterstr. Buchst. */

 Ein normales UO benîtigt also eine 8 Bytes lange Struktur, ein Button 8+10,
 also 18 Bytes. Alles klar?

 Breite und Hîhe eines Zeichens ermitteln wir am Programmbeginn mit GRAF_HANDLE.
 Nun lesen wir den Buttontext aus und suchen das '[' Zeichen in ihm, das ja an-
 gibt, welcher Buchstabe unterstrichen werden soll. Auch diese Position tragen
 wir in die erweiterte Struktur ein. Wir entfernen das '[' aus dem String und
 schreiben ihn zurÅck:

  b$=CHAR{OB_SPEC(rsc_adr%(tree&),obj&)}

  pos&=INSTR(b$,"[")             ! ...Pos. des unterstr. Buchst. ermitteln
  IF pos&
    b$=LEFT$(b$,PRED(pos&))+MID$(b$,SUCC(pos&))
    CHAR{OB_SPEC(rsc_adr%(tree&),obj&)}=b$
  ENDIF

  {userblk%+4}=userblk%+8        ! ...in USERBLK Zeiger eintragen

  INT{userblk%+8}=V~H            ! WORD u_handle;  /* Bildschirmhandle V~H

  '                              ! BYTE *u_text;   /* Adresse des Textes
  {userblk%+10}=OB_SPEC(rsc_adr%(tree&),obj&)

  BYTE{userblk%+14}=wchar&       ! BYTE u_wchar;   /* Breite eines Zeichens
  BYTE{userblk%+15}=hchar&       ! BYTE u_hchar;   /* Hîhe eines Zeichens
  INT{userblk%+16}=pos&          ! WORD u_pos;     /* Pos. d. unterstr. Buchst.

 Jetzt wird vielleicht auch deutlich, warum wir die Resource in zwei Schritten
 durchsuchen mÅssen: Um feste Adressen fÅr die USERBLKs zu erhalten, mÅssen wir
 den gesamten Speicherbereich mit MALLOC allozieren. Das kînnen wir aber nicht,
 bevor wir nicht wissen, wieviel Speicher wir brauchen...

 Damit ist die Einbindung der userdefined object abgeschlossen.

--------------------------------------------------------------------------------
Herne 1, 06.08.92
