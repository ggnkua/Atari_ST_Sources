* Object skeleton used by DEMOS1.S or DASTD.S (v2.0)
* v1.0: * Monitormode selection.
*       * SET_RES routine vbl-synced.
*       * Screenaddress-setting optimised.
*
* v1.1: * Automaticly initializes screenbuffers and resolution.
*       * Returns resultcode in INIT routine.
*       * Minor optimisations.

******** OBJECT TABLE ********

* Must be first in object!!
RotoZoomer.table:
	DC.L	RotoZoomerMAINLOOP
	DC.L	INIT_RotoZoomer
	DC.L	SET_RotoZoomerRES
	DC.L	RotoZoomer.startTrajectory
	DC.L	RotoZoomer.setCharS
;	DC.L	RotoZoomer.setCharE
	DC.L	RotoZoomer.setCharC
	DC.L	RotoZoomer.setCharT
;	DC.L	RotoZoomer.setCharO
;	DC.L	RotoZoomer.setCharR
	DC.L	RotoZoomer.setChar1
	DC.L	RotoZoomer.setCharF
	DC.L	RotoZoomer.setCharU
	DC.L	RotoZoomer.setCharN
	DC.L	RotoZoomer.killChar
	DC.L	RotoZoomer.triggerWipe
	DC.L	0

	INCLUDE	FONT.SO
	TEXT

******** OBJECT EQUATES ********

RotoZoomer.RX:		=	32
RotoZoomer.RY:		=	32

			RSRESET
VectorTable.AX:		RS.W	1
VectorTable.AY:		RS.W	1
VectorTable.BX:		RS.W	1
VectorTable.BY:		RS.W	1
VectorTable.SIZE:	RS.B	0

Primitive.GRADIENTBITS:	=	7
Primitive.GRADIENTSIZE:	=	1<<(Primitive.GRADIENTBITS+1)

* Shade types for polygons
Polygon.FLATSHADED:	=	%0000000000000000
Polygon.GOURAUDSHADED:	=	%0010000000000000
Polygon.PHONGSHADED:	=	%0100000000000000
Polygon.TEXTUREMAPPED:	=	%0110000000000000
Polygon.ENVMAPPED:	=	%1000000000000000
Polygon.ALPHATEXTURED:	=	%1010000000000000
Polygon.BUMPMAPPED:	=	%1100000000000000

* Primitive types
Primitive.TYPEMASK:	=	%0001110000000000
Primitive.TYPESHIFT:	=	10
Primitive.SPRITETYPE:	=	%0000000000000000
Primitive.LINETYPE:	=	%0000010000000000
* Other types are polygons, %10 :== triangle, %11 :== quadrangle, etc.

* TableLookup mask
Primitive.TEXTUREMASK:	=	%0000001111111111

* Standard Polygon types
Polygon.TRI:		=	(3-1)<<Primitive.TYPESHIFT
Polygon.QUAD:		=	(4-1)<<Primitive.TYPESHIFT

******** Viewport

Viewport.MAX_X:		=	800		* Maximum X dimension
Viewport.MAX_Y:		=	600		* Maximum Y dimension

			RSRESET
Viewport.XSCREEN:	RS.W	1		* X dimension of screenbuffer
Viewport.YSCREEN:	RS.W	1		* Y dimension of screenbuffer
Viewport.XSTART:	RS.W	1		* X start within screen
Viewport.XEND:		RS.W	1		* X end within screen
Viewport.YSTART:	RS.W	1		* Y start within screen
Viewport.YEND:		RS.W	1		* Y end within screen
Viewport.XCENTER:	RS.W	1		* Y start within screen
Viewport.YCENTER:	RS.W	1		* Y end within screen
Viewport.FOCAL:		RS.W	1		* Focal length
Viewport.ASPECT:	RS.W	1		* 8:8 Y scale
Viewport.SIZE:		RS.B	0

******** Fragment

			RSRESET
Fragment.LSLOPE:	RS.L	1		* 16:16 fixed point
Fragment.RSLOPE:	RS.L	1		* 16:16 fixed point
Fragment.LX:		RS.W	1		* left X
Fragment.RX:		RS.W	1		* right X
Fragment.LUSTART:	RS.W	1		* 8:8 index
Fragment.LVSTART:	RS.W	1		* 8:8 index
Fragment.RUSTART:	RS.W	1		* 8:8 index
Fragment.RVSTART:	RS.W	1		* 8:8 index
Fragment.LUSLOPE:	RS.W	1		* 8:8 slope
Fragment.LVSLOPE:	RS.W	1		* 8:8 slope
Fragment.RUSLOPE:	RS.W	1		* 8:8 slope
Fragment.RVSLOPE:	RS.W	1		* 8:8 slope
Fragment.START:		RS.W	1		* start scanline of fragment
Fragment.HEIGHT:	RS.W	1		* height of fragment
Fragment.SIZE:		RS.B	0

ClipEdges:	MACRO		LeftClipRoutine,RightClipRoutine,TopClipRoutine,BottomClipRoutine
.left_clip:
	btst	#1,.clipflags(pc)
	beq.s	.end_left_clip
	move.w	Viewport.settingsTable+Viewport.XSTART,d0
	lsl.w	#4,d0
	movea.w	d0,a2
	move.l	a0,-(sp)
	move.l	a1,-(sp)
	bsr	\1
	movea.l	(sp)+,a0
	movea.l	(sp)+,a1
	tst.w	(a1)
	beq	.end
.end_left_clip:

.right_clip:
	btst	#0,.clipflags(pc)
	beq.s	.end_right_clip
	move.w	Viewport.settingsTable+Viewport.XEND,d0
	lsl.w	#4,d0
	movea.w	d0,a2
	move.l	a0,-(sp)
	move.l	a1,-(sp)
	bsr	\2
	movea.l	(sp)+,a0
	movea.l	(sp)+,a1
	tst.w	(a1)
	beq.s	.end
.end_right_clip:

.top_clip:
	btst	#3,.clipflags(pc)
	beq.s	.end_top_clip
	move.w	Viewport.settingsTable+Viewport.YSTART,d0
	lsl.w	#4,d0
	movea.w	d0,a2
	move.l	a0,-(sp)
	move.l	a1,-(sp)
	bsr	\3
	movea.l	(sp)+,a0
	movea.l	(sp)+,a1
	tst.w	(a1)
	beq.s	.end
.end_top_clip:

.bottom_clip:
	btst	#2,.clipflags(pc)
	beq.s	.end_bottom_clip
	move.w	Viewport.settingsTable+Viewport.YEND,d0
	lsl.w	#4,d0
	movea.w	d0,a2
	move.l	a0,-(sp)
	move.l	a1,-(sp)
	bsr	\4
	movea.l	(sp)+,a0
	movea.l	(sp)+,a1
	tst.w	(a1)
	beq.s	.end
.end_bottom_clip:
	ENDM

IntersectV1Edge:	MACRO
	sub.w	d4,d5				* du := u1-u0
	sub.w	d2,d3				* dy := y1-y0
	sub.w	d0,d1				* dx := x1-x0
	swap	d3
	sub.w	d3,d3
	ext.l	d1
	divs.l	d1,d3				* slope := dy/dx
	ext.l	d5
	lsl.l	#8,d5
	divs.w	d1,d5				* uslope : = du/dx
	sub.w	a2,d0				* xi := x0-clipx
	neg.w	d0
	ext.l	d0
	muls.l	d0,d3				* dy/dx * -xi
	muls.w	d0,d5				* du/dx * -xi
	swap	d3
	tst.l	d3
	bpl.s	.\@no_round
	addq.w	#1,d3
.\@no_round:
	ror.l	#8,d5
	tst.l	d5
	bpl.s	.\@no_roundu
	addq.w	#1,d5
.\@no_roundu:
	add.w	d2,d3				* Y = dy/dx * -xi + y0
	add.w	d4,d5				* U = du/dx * -xi + u0
	ENDM

******** RESOLUTION SETTING ROUTINE ********

SET_RotoZoomerRES:
	bsr	RotoZoomer.startTrajectory

	IFEQ	testmode
	move.l	#rts,vbl_gfx

	move.w	$0468.w,d0
.ck468:	cmp.w	$0468.w,d0
	beq.s	.ck468
	move.w	monitormode,d0
	cmpi.w	#vga60,d0
	beq.s	.vga60
	cmpi.w	#vga100,d0
	beq.s	.vga100
	cmpi.w	#rgb50,d0
	beq.s	.rgb50
* Unknown monitormode..
	rts
.vga60:	bra.l	vga60_16bit_160_200
	rts
.vga100:
	bra.l	vga100_16bit_160_100
	rts
.rgb50:	bra.l	rgb50_16bit_320_100
	ENDC
	rts

******** INIT SUBROUTINE ********

* OUTPUT: d0.l: 0   = All clear.
*               neg = Error! Not initialized!
INIT_RotoZoomer:
	bsr	Font.init

	lea	RotoZoomer.map,a0
	movea.l	a0,a1
	move.l	#"Word",(a1)+
	move.l	#"PerP",(a1)+
	move.l	#"ixel",(a1)+
	move.l	#$01000100,(a1)+
	lea	20(a0),a0
	bsr	Font.paintToTexture

	lea	RotoZoomer.flowPal,a1
	lea	RotoZoomer.pal,a0
	bsr	RotoZoomer.makeColorFlow

	bsr	RotoZoomer.generateTexture

	lea	Viewport.settingsTable,a0
	move.w	#160,Viewport.XSCREEN(a0)
	move.w	#100,Viewport.YSCREEN(a0)
	move.w	#0,Viewport.XSTART(a0)
	move.w	#0,Viewport.YSTART(a0)
	move.w	#160,Viewport.XEND(a0)
	move.w	#100,Viewport.YEND(a0)
	move.w	#80,Viewport.XCENTER(a0)
	move.w	#50,Viewport.YCENTER(a0)
	move.w	#256+32,Viewport.ASPECT(a0)
	move.w	#$100,Viewport.FOCAL(a0)

	lea	RotoZoomer.textureTable,a0
	bsr	Polygon.init

.success:
	moveq	#0,d0
	rts
.error:	moveq	#-1,d0
	rts

******** SCREENINIT SUBROUTINE ********

INIT_RotoZoomerSCREEN:
* Insert screenarea initialising, etc. in here!
	rts

******** MAINLOOP SUBROUTINE ********

RotoZoomerMAINLOOP:
	move.l	frmcnt,d0
	sub.l	lastframecount,d0
	cmpi.l	#3,d0
	bhs.s	.end_screeninit
	bsr	INIT_RotoZoomerSCREEN
.end_screeninit:
	move.w	$468.w,.old468

	bsr	RotoZoomer.calcPosition

	tst.w	RotoZoomer.wipe
	beq.s	.end_wipe
	bsr	RotoZoomer.wipeTexture
.end_wipe:

; Paint the background (rotozoomer).
	lea	RotoZoomer.logBuffer,a0
	bsr	RotoZoomer.paint

; Paint the char on screen..
	tst.w	RotoZoomer.fontActive
	beq.s	.end_paint_char

	lea	RotoZoomer.logBuffer,a0
	bsr	Primitive.setScreenbuffer

	bsr	RotoZoomer.getFontTime
	move.w	d0,d2
	subi.w	#190,d0
	mulu.w	#22,d2
	not.w	d2
	andi.w	#$1FFF,d2
	addi.w	#$0200,d2
	move.l	#$00FF0000,d1
	divu.w	d2,d1
	movea.l	RotoZoomer.charRectAddy,a1
	bsr	RotoZoomer.calcPoly

	lea	RotoZoomer.polygonTest,a1
	bsr	Polygon.paintClippedTextured
.end_paint_char:

	bsr	RotoZoomer.flush

	move.l	frmcnt,d0
	sub.l	lastframecount,d0
	bne.s	.res_done
	bsr	SET_RotoZoomerRES
.res_done:

	IFEQ	testmode
	lea	scr,a0
	move.l	(a0)+,d0
	move.l	(a0)+,d1
	move.l	(a0),-4(a0)
	move.l	d0,(a0)
	move.l	d1,-8(a0)
	move.l	d0,d1
	lsr.w	#8,d0
	move.l	d0,$ffff8200.w
	move.b	d1,$ffff820d.w
	ENDC

	move.w	.old468(pc),d0
.wait468:
	cmp.w	$468.w,d0
	beq.s	.wait468
	rts

.old468:
	DC.W	0

******** OBJECT SUBROUTINES ********

RotoZoomer.startTrajectory:
	move.l	$04BA.w,RotoZoomer.startTime
	rts

RotoZoomer.startFontZoom:
	move.w	#1,RotoZoomer.fontActive
	move.l	$04BA.w,RotoZoomer.fontStartTime
	rts

RotoZoomer.setCharS:
	move.l	#RotoZoomer.sRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharE:
	move.l	#RotoZoomer.eRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharC:
	move.l	#RotoZoomer.cRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharT:
	move.l	#RotoZoomer.tRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharO:
	move.l	#RotoZoomer.oRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharR:
	move.l	#RotoZoomer.rRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharF:
	move.l	#RotoZoomer.fRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharU:
	move.l	#RotoZoomer.uRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setCharN:
	move.l	#RotoZoomer.nRectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.setChar1:
	move.l	#RotoZoomer.1Rectangle,RotoZoomer.charRectAddy
	bsr	RotoZoomer.startFontZoom
	rts

RotoZoomer.killChar:
	clr.w	RotoZoomer.fontActive
	rts

RotoZoomer.triggerWipe:
	move.w	#1,RotoZoomer.wipe
	rts

;* This is V.R.T.G ************************************
;* Very Random Textures Generator :-D *****************
; Original code by Kalms. Thankyou for this smart stuff.
RotoZoomer.generateTexture:
	lea	RotoZoom.byteTexture,a1
	movea.l	a1,a0			;saves pointer
	moveq	#37,d0
	move.w	#256*256-1,d7

.random	ror.l	d0,d0			;tanx to Azure for this..
	addq.l	#7,d0			;smart (and chip) rnd generator
	move.b	d0,(a0)+		;fill texture with random values
	dbra	d7,.random

	moveq	#6-1,d4			;filter passes

.start	moveq	#6-1,d6			;blur passes
	movea.l	a1,a0			;saves texture pointer
	move.w	#256*256-1,d7

.loopf	move.b	(a0),d0			;load one texel
	lsl.b	#2,d0			;*4
	bge.s	.ok			;it's greater than 127?
	not.b	d0			;yeah..so make it 'reasonable' :)
.ok	move.b	d0,(a0)+		;store texel
	dbra	d7,.loopf

.loopbb	movea.l	a1,a0			;some pointers sutff
	move.l	#256,d0
	move.l	d0,d1
	neg.w	d1
	clr.l	d5			;u,v := 0,0
	moveq	#0,d2			;loads 4 texels
	moveq	#0,d3			

	IFNE	0

.loopb:	move.l	d5,d7
	subq.b	#1,d7
	move.b	(a0,d7.l),d2		;left
	addq.b	#2,d7
	add.b	(a0,d7.l),d2		;+right
	move.b	(a1,d0.l),d3		;bottom 
	add.b	(a1,d1.l),d3		;+top
	add.w	d2,d3			;mix alltogether
	lsr.w	#2,d3			;perform average
	move.b	d3,(a0,d5.l)		;and store smoothed texel
	addq.w	#1,d0
	addq.w	#1,d1
	addq.w	#1,d5
	bne.s	.loopb

	ELSE

.yloop:	lea	(a1,d0.l),a4
	lea	(a1,d1.l),a5

	IFNE	1

	move.b	255(a0),d2
	add.b	1(a0),d2
	move.b	(a5)+,d3		;bottom 
	add.b	(a4)+,d3		;+top
	add.w	d2,d3			;mix alltogether
	lsr.w	#2,d3			;perform average
	move.b	d3,(a0)+		;and store smoothed texel

	move.w	#256-3,d7
.xloop:	move.b	-1(a0),d2		;left
	add.b	1(a0),d2		;+right
	move.b	(a5)+,d3		;bottom 
	add.b	(a4)+,d3		;+top
	add.w	d2,d3			;mix alltogether
	lsr.w	#2,d3			;perform average
	move.b	d3,(a0)+		;and store smoothed texel
	dbra	d7,.xloop

	move.b	-1(a0),d2
	add.b	-255(a0),d2
	move.b	(a5)+,d3		;bottom 
	add.b	(a4)+,d3		;+top
	add.w	d2,d3			;mix alltogether
	lsr.w	#2,d3			;perform average
	move.b	d3,(a0)+		;and store smoothed texel

	ELSE

	move.w	#256-1,d7
.xloop:	subq.b	#1,d5
	move.b	(a1,d5.l),d2		;left
	addq.b	#2,d5
	add.b	(a1,d5.l),d2		;+right
	move.b	(a5)+,d3		;bottom 
	add.b	(a4)+,d3		;+top
	add.w	d2,d3			;mix alltogether
	lsr.w	#2,d3			;perform average
	move.b	d3,(a0)+		;and store smoothed texel
	dbra	d7,.xloop

	ENDC

	addi.w	#$0100,d0
	addi.w	#$0100,d1
	addi.w	#$0100,d5
	bne.s	.yloop

	ENDC

	dbra	d6,.loopbb

	dbra	d4,.start

; Convert all this shite to highcolor..
	lea	RotoZoomer.texture,a0
	lea	RotoZoomer.pal,a2
	move.w	#256*256-1,d7
	clr.l	d0
.convert_loop:
	move.b	(a1)+,d0
	move.w	(a2,d0.l*2),(a0)+
	dbra	d7,.convert_loop

	rts

RotoZoomer.getTime:
	move.l	$04BA.w,d0
	sub.l	RotoZoomer.startTime,d0
	rts

RotoZoomer.getFontTime:
	move.l	$04BA.w,d0
	sub.l	RotoZoomer.fontStartTime,d0
	rts

RotoZoomer.WIPESPEED:	=	3

RotoZoomer.wipeTexture:
	lea	RotoZoomer.texture,a0
	move.w	RotoZoomer.wipeCount,d0
	clr.l	d1
	move.w	d0,d1
	lsl.w	#8,d1
	lea	(a0,d1.l*2),a0
	move.w	#RotoZoomer.WIPESPEED*256/2-1,d7

.loop:	clr.l	(a0)+
	dbra	d7,.loop

	addq.b	#RotoZoomer.WIPESPEED,d0
	bcc.s	.store_count
	clr.w	RotoZoomer.wipe
.store_count:
	move.w	d0,RotoZoomer.wipeCount
	rts

; Calculates rotationwindow vertices: a, b, c, d.
; We output clockwise to a polygon like so: a,b,d,c.
; 
;   a *----->* b
;     |
;     |  *--> (rx,0)' = r.x*[+cos(t),+sin(t)]
;     |  |
;     v  v
;   c *  (0,r.y)' = r.y*[-sin(t),+cos(t)]
;
; a.x = -cos(t)*r.x +sin(t)*r.y = -xc +ys
; a.y = -cos(t)*r.x -cos(t)*r.y = -xs -yc
;
; b.x = +xc +ys
; b.y = +xs -yc
;
; c.x = -xc -ys
; c.y = -xs +yc
;
; d.x = -a.x
; d.y = -a.y
;
; INPUT:
; d0.w = angle theta = t
; d1.w = scale [-32768,+32767] =^ [-2.0,+2.0]
; a1: rectangle (specifies texturearea)
; OUTPUT:
; RotoZoomer.polygonTest: texturemapped 4-sided poly
RotoZoomer.calcPoly:
	lea	RotoZoomer.polygonTest,a0
	move.w	#0,(a0)+
	move.w	#4,(a0)+
	Do_SinModulo	d0
	Get_SinCos	sine_tbl,d0,d0,d3
; d0.w=sin(t), d3.w=cos(t)

	muls.w	d1,d0
	muls.w	d1,d3
	add.l	d0,d0
	add.l	d3,d3
	swap	d0
	swap	d3
	move.w	d0,d2
	move.w	d3,d1
	muls.w	#+RotoZoomer.RX,d0
	muls.w	#+RotoZoomer.RX,d1
	muls.w	#+RotoZoomer.RY,d2
	muls.w	#+RotoZoomer.RY,d3
; d0.l=xs, d1.l=xc, d2.l=ys, d3.l=yc

; Calculate a.
	move.l	d1,d4
	neg.l	d4
	add.l	d2,d4
	move.l	d0,d5
	neg.l	d5
	sub.l	d3,d5
	moveq	#14,d6
	asr.l	d6,d4
	asr.l	d6,d5

; Calculate d=-a.
	move.l	d4,d6
	move.l	d5,d7
	neg.l	d6
	neg.l	d7

; Center a.
	addi.w	#80,d4
	addi.w	#50,d5
; Store a.
	move.w	d4,(a0)+
	move.w	d5,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+

; Calculate b.
	move.l	d1,d4
	add.l	d2,d4
	move.l	d0,d5
	sub.l	d3,d5
	moveq	#14,d0
	asr.l	d0,d4
	asr.l	d0,d5

; Calculate c=-b.
	move.l	d4,d0
	move.l	d5,d1
	neg.l	d0
	neg.l	d1

; Center b.
	addi.w	#80,d4
	addi.w	#50,d5
; Store b.
	move.w	d4,(a0)+
	move.w	d5,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+

; Center d.
	addi.w	#80,d6
	addi.w	#50,d7
; Store d.
	move.w	d6,(a0)+
	move.w	d7,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+

; Center c.
	addi.w	#80,d0
	addi.w	#50,d1
; Store c.
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+

	rts

; Generates a highcolor pallette from a (truecolor) flowtable.
; INPUT:
; a0: highcolor buffer to write to
; a1: instruction table 
RotoZoomer.makeColorFlow:
	move.l	a0,-(sp)

	move.w	(a1)+,d7
	moveq	#0,d0
	move.w	(a1)+,d0
	moveq	#1,d6
	lsl.w	d0,d6
	move.w	d7,d5
	mulu.w	d6,d5
	move.w	d5,(a0)+
	subq.w	#1,d6
	movea.w	d6,a5
	subq.w	#1,d7

.loop:	move.l	(a1)+,d1
	move.l	(a1),d2
	move.l	d1,d3
	move.l	d2,d4
	lsr.l	#8,d3
	lsr.l	#8,d4
	clr.w	d3
	clr.w	d4
	sub.l	d3,d4
	asr.l	d0,d4
	move.l	a0,a6

.red_loop:
	swap	d3
	move.w	d3,d5
	lsl.w	#8,d5
	andi.w	#$f800,d5
	move.w	d5,(a0)+
	swap	d3
	add.l	d4,d3
	dbra	d6,.red_loop

	move.w	a5,d6
	move.l	a6,a0
	move.l	d1,d3
	move.l	d2,d4
	andi.l	#$00ff0000,d3
	andi.l	#$00ff0000,d4
	sub.l	d3,d4
	asr.l	d0,d4

.green_loop:
	swap	d3
	move.w	d3,d5
	lsl.w	#3,d5
	andi.w	#$07e0,d5
	or.w	d5,(a0)+
	swap	d3
	add.l	d4,d3
	dbra	d6,.green_loop

	move.l	a6,a0
	move.w	a5,d6
	moveq	#0,d3
	moveq	#0,d4
	move.b	d1,d3
	move.b	d2,d4
	swap	d3
	swap	d4
	sub.l	d3,d4
	asr.l	d0,d4

.blue_loop:
	swap	d3
	move.w	d3,d5
	lsr.w	#3,d5
	andi.w	#$001f,d5
	or.w	d5,(a0)+
	swap	d3
	add.l	d4,d3
	dbra	d6,.blue_loop

	move.w	a5,d6
	dbra	d7,.loop

	movea.l	(sp)+,a1
	rts

RotoZoomer.calcPosition:
* First we calculate the current time.
	bsr	RotoZoomer.getTime
	move.l	d0,d1
	move.l	d0,d6
	lea	sine_tbl,a0

* Now we calculate our center position.
	move.w	d1,d4
	mulu.w	#3,d4
	lsr.l	#1,d4
	mulu.w	#5,d1
	lsr.l	#2,d1
	Do_SinModulo	d1
	Do_SinModulo	d4
	Get_Sin	a0,d1,d2
	Get_Sin	a0,d4,d3
	asl.l	#1,d2
	asl.l	#1,d3
;	moveq	#0,d2
;	moveq	#0,d3
	movem.w	d2/d3,RotoZoomer.center

* And now we calculate the current position in the trajectory.
	Do_SinModulo	d0
	Get_SinCos	a0,d0,d0,d1
* d0.w: +sin(fi)
* d1.w: +cos(fi)

* a'.x = +cos(fi)*a.x +sin(fi)*a.y
* a'.y = -sin(fi)*a.x +cos(fi)*a.y
	move.w	d1,d2
	move.w	d0,d3
	muls.w	#256,d2
	muls.w	#-256,d3
	add.l	d2,d2
	add.l	d3,d3
	swap	d2
	swap	d3
* d2.w: a'.x, d3.w: a'.y
* b'.x = +cos(fi)*b.x +sin(fi)*b.y
* b'.y = -sin(fi)*b.x +cos(fi)*b.y
	move.w	d0,d4
	move.w	d1,d5
	muls.w	#256,d4
	muls.w	#256,d5
	add.l	d4,d4
	add.l	d5,d5
	swap	d4
	swap	d5
* d4.w: b'.x, d5.w: b'.y
	movem.w	d2-d5,RotoZoomer.vectorTable

* And we calculate the amount of zoom...
	Do_SinModulo	d6
	Get_Sin	a0,d6,d6
	addi.w	#$8000,d6
	andi.l	#$ffff,d6
	divu.w	#230,d6
	addi.w	#$20,d6
* And zoom the damn thing!
	muls.w	d6,d2
	muls.w	d6,d3
	muls.w	d6,d4
	muls.w	d6,d5
	asr.l	#8,d2
	asr.l	#8,d3
	asr.l	#8,d4
	asr.l	#8,d5
	movem.w	d2-d5,RotoZoomer.scaledVectorTable

	rts

; INPUT:
; a0: screen
RotoZoomer.paint:
	IFNE	1
	movem.w	RotoZoomer.scaledVectorTable,d0-d3
* d0.w: a.x, d1.w: a.y, d2.w: b.x, d3.w: b.y
	movem.w	RotoZoomer.center,d6/d7
	move.w	d0,d4
	move.w	d1,d5
	muls.w	#50,d4
	muls.w	#50,d5
	sub.w	d4,d6
	sub.w	d5,d7
	move.w	d2,d4
	move.w	d3,d5
	muls.w	#80,d4
	muls.w	#80,d5
	sub.w	d4,d6
	sub.w	d5,d7
* a
	ror.l	#8,d1
	move.w	d1,d5
	move.w	d0,d1
	movea.l	d1,a4
* b
	ror.l	#8,d3
	move.w	d3,d4
	move.w	d2,d3

* top-left
	ror.l	#8,d7
	movea.w	d7,a3
	move.w	d6,d7
	movea.l	d7,a2
	ELSE
* top-left
	movea.l	#$00000000,a2
	movea.l	#$00000000,a3
* a
	movea.l	#$70000000,a4
	move.l	#$00000001,d5
* b
	move.l	#$60000100,d3
	move.l	#$00000003,d4
	ENDC

	lea	RotoZoomer.texture,a1
	moveq	#100-1,d7
	moveq	#0,d2

.yloop:	moveq	#16-1,d6
	move.l	a2,d0
	move.l	a3,d1

.chunkloop:
	REPT	10
	move.w	d0,d2
	add.l	d3,d0
	move.b	d1,d2
	addx.b	d4,d1
	move.w	(a1,d2.l*2),(a0)+
	ENDR
	dbra	d6,.chunkloop

	move.l	a2,d0
	move.l	a3,d1
	add.l	a4,d0
	addx.b	d5,d1
	movea.l	d0,a2
	movea.l	d1,a3
	dbra	d7,.yloop
	rts

RotoZoomer.flush:
	lea	RotoZoomer.logBuffer,a1
	movea.l	scr,a0
	cmpi.w	#vga100,monitormode
	beq	RotoZoomer.flushVga100
	cmpi.w	#vga60,monitormode
	beq	RotoZoomer.flushVga60
	cmpi.w	#rgb50,monitormode
	beq	RotoZoomer.flushRgb50
	rts

RotoZoomer.flushVga100:
	moveq	#100-1,d7

.yloop:	move.w	#160/16-1,d6

.xloop:	REPT	8
	move.l	(a1)+,(a0)+
	ENDR
	dbra	d6,.xloop

	dbra	d7,.yloop
	rts

RotoZoomer.flushRgb50:
	moveq	#100-1,d7

.yloop:	move.w	#160/16-1,d6

.xloop:	REPT	16
	move.w	(a1)+,d0
	move.w	d0,(a0)+
	move.w	d0,(a0)+
	ENDR
	dbra	d6,.xloop

	dbra	d7,.yloop
	rts

RotoZoomer.flushVga60:
	moveq	#100-1,d7
.yloop:	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,(a0)
	movem.l	d0-d6/a2-a6,160*2(a0)
	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,24*2(a0)
	movem.l	d0-d6/a2-a6,(160+24)*2(a0)
	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,48*2(a0)
	movem.l	d0-d6/a2-a6,(160+48)*2(a0)
	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,72*2(a0)
	movem.l	d0-d6/a2-a6,(160+72)*2(a0)
	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,96*2(a0)
	movem.l	d0-d6/a2-a6,(160+96)*2(a0)
	movem.l	(a1)+,d0-d6/a2-a6
	movem.l	d0-d6/a2-a6,120*2(a0)
	movem.l	d0-d6/a2-a6,(160+120)*2(a0)
	movem.l	(a1)+,d0-d6/a2
	movem.l	d0-d6/a2,144*2(a0)
	movem.l	d0-d6/a2,(160+144)*2(a0)
	lea	160*2*2(a0),a0
	dbra	d7,.yloop
	rts

******** Primitive

* INPUT:
* a0: address of screenbuffer
Primitive.setScreenbuffer:
	move.l	a0,Primitive.screenadr
	rts

******** Polygon

* Initializes polygonpainter lookup tables.
* INPUT:
* a0: texture-address-table
* OUTPUT:
* d0.l: 0=ok, -1=error
Polygon.init:
	move.l	a0,Polygon.textureadr
	bsr	Polygon.parseTextureTable
	bsr	Polygon.calcInvTable

.success:
	moveq	#0,d0
	rts
.error:	moveq	#-1,d0
	rts

* Parses a table containing APX block textures and resets all addresses
* to point to the start of the pixeldata.
* PRECONDITIONS:
* The texturetable points to APX blocks.
* The texturetable is null-terminated.
* INPUT:
* a0: texture table
Polygon.parseTextureTable:
.loop:	movea.l	(a0)+,a1
	tst.l	a1
	beq.s	.end
	move.l	(a1),d0
.test_byte_per_pixel:
	cmpi.l	#"Byte",d0
	bne.s	.end_test_byte_per_pixel
	lea	788(a1),a1
.end_test_byte_per_pixel:
.test_word_per_pixel:
	cmpi.l	#"Word",d0
	bne.s	.end_test_word_per_pixel
	lea	20(a1),a1
.end_test_word_per_pixel:
	move.l	a1,-4(a0)
	bra.s	.loop
.end:	rts

Polygon.calcInvTable:
	lea	Polygon.invTable,a0
	move.l	#$80000000,d1
	moveq	#2,d0
	move.l	d1,d2
	swap	d2
	move.w	#$7fff,(a0)+
	move.w	#$7fff,(a0)+

.posloop:
	move.l	d1,d2
	divu.l	d0,d2
	swap	d2
	move.w	d2,(a0)+
	addq.w	#1,d0
	cmpi.w	#Viewport.MAX_Y,d0
	blt.s	.posloop

	rts

* Paints a textured polygon.
* INPUT:
* a1: polygon (texture.w, numofpoints.w, x0.w, y0.w, u0.w, v0.w....)
Polygon.paintClippedTextured:
	move.w	(a1)+,Polygon.curtexture
	lea	Polygon.polypointTable,a0
	movea.l	a0,a6
	move.w	(a1)+,d7
	move.w	d7,(a0)+
	subq.w	#1,d7
	movea.l	a1,a5

.vertexloop:
	move.l	(a1)+,(a0)+
	move.l	(a1)+,(a0)+
	dbra	d7,.vertexloop
	move.l	(a5)+,(a0)+
	move.l	(a5)+,(a0)+

	movea.l	a6,a0

	movea.l	a0,a1				* Backup polygon.
	move.w	(a0)+,d7
	subq.w	#1,d7	
	move.w	d7,d6
	movem.w	Viewport.settingsTable+Viewport.XSTART,d1-d4

.loop:	moveq	#0,d5				* Set point clipflags to 0.
	move.w	(a0)+,d0			* d0 := X
.check_left:
	cmp.w	d1,d0				* XSTART
	bpl.s	.check_right
	addq.w	#%0010,d5
.check_right:
	cmp.w	d2,d0				* XEND
	blt.s	.end_check_right
	addq.w	#%0001,d5
.end_check_right:
	move.w	(a0)+,d0			* d0 := Y
.check_above:
	cmp.w	d3,d0				* YSTART
	bpl.s	.check_under
	ori.w	#%1000,d5
.check_under:
	cmp.w	d4,d0				* YEND
	blt.s	.end_check
	addq.w	#%0100,d5
.end_check:
	move.w	d5,-(sp)
	addq	#4,a0
	dbra	d7,.loop

	subq.w	#1,d6
	move.w	(sp)+,d0
	move.w	d0,d1
.poeploop:
	move.w	(sp)+,d2
	or.w	d2,d0
	and.w	d2,d1
	dbra	d6,.poeploop

	tst.w	d1
	bne	.offscreen

	tst.w	d0
	beq	Polygon.paintTexturemapped2

	move.b	d0,.clipflags
	movea.l	a1,a6
	move.w	(a1)+,d7
	addq.w	#1,d7
	mulu.w	#4,d7
	subq.w	#1,d7
.scale_up_loop:
	move.w	(a1),d0
	lsl.w	#4,d0
	move.w	d0,(a1)+
	dbra	d7,.scale_up_loop
	movea.l	a6,a1
	lea	Polygon.polypointTable2,a0

	ClipEdges	Polygon.clipV2Left,Polygon.clipV2Right,Polygon.clipV2Top,Polygon.clipV2Bottom

	movea.l	a1,a0
	move.w	(a0)+,d7
	mulu.w	#4,d7
	subq.w	#1,d7
.scaleloop:
	move.w	(a0),d0
	asr.w	#4,d0
	move.w	d0,(a0)+
	dbra	d7,.scaleloop

	bra	Polygon.paintTexturemapped2

.end:	rts
.offscreen:
	rts

.clipflags:
	DC.W	0

IntersectV2Edge:	MACRO
	sub.w	d4,d5				* dv := v1-v0
	ext.l	d5
	lsl.l	#8,d5
	divs.w	d1,d5				* vslope := dv/dx
	muls.w	d0,d5				* dv/dx * -xi
	ror.l	#8,d5
	tst.l	d5
	bpl.s	.\@no_roundu
	addq.w	#1,d5
.\@no_roundu:
	add.w	d4,d5				* V := dv/dx * -xi + v0
	ENDM

* Clip a v2 polygon against the left side.
* INPUT: a0: destination v2-polygon
*        a1: source v2-polygon
*        a2.l: viewport x start
Polygon.clipV2Left:
	lea	2(a0),a6			* Backup destination address.
	move.w	(a1)+,d7			* Get amount of source points.
	subq.w	#1,d7
	moveq	#0,d6				* Reset amount of destination points.

.loop:	move.w	(a1),d0
.check_first:
	cmp.w	a2,d0
	blt	.check_second_outside
.check_second_inside:
	move.w	8(a1),d1
	cmp.w	a2,d1
	bge.s	.inside
* The source edge goes from inside to outside.
* Write the clipped point.
.clip_inside_outside:
	move.w	2(a1),d3
	move.w	10(a1),d2
	move.w	4(a1),d5
	move.w	12(a1),d4
	exg	d0,d1				* swap x0, x1
	IntersectV1Edge
	move.w	a2,(a6)+			* Store X (=leftx).
	move.w	d3,(a6)+			* Store Y.
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d5
	move.w	14(a1),d4
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	addq	#8,a1
	addq.w	#1,d6
	bra	.loop_end
* The source edge is inside -> write the first point to the destination.
.inside:
	addq	#8,a1
	move.l	(a1),(a6)+
	move.l	4(a1),(a6)+
	addq.w	#1,d6
	bra.s	.loop_end
.check_second_outside:
	move.w	8(a1),d1
	cmp.w	a2,d1
	blt.s	.outside
* The source edge goes from outside to inside.
* Write the clipped point and the inside point as well.
.clipped_outside_inside:
	move.w	2(a1),d2
	move.w	10(a1),d3
	move.w	4(a1),d4
	move.w	12(a1),d5
	IntersectV1Edge
	move.w	a2,(a6)+			* Store X (=leftx).
	move.w	d3,(a6)+			* Store Y.
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d4
	move.w	14(a1),d5
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	move.l	8(a1),(a6)+			* Store next X,Y.
	move.l	12(a1),(a6)+			* Store next U,V.
	addq.w	#2,d6
* The source edge is outside, don't write.
.outside:
	addq	#8,a1
.loop_end:
	dbra	d7,.loop

	move.w	d6,(a0)+			* Write amount of destination points.
	move.l	(a0),(a6)			* Duplicate first point.
	move.l	4(a0),4(a6)
	rts

* Clip a v2 polygon against the right side.
* INPUT: a0: destination v2-polygon
*        a1: source v2-polygon
*        a2.l: viewport x end
Polygon.clipV2Right:
	lea	2(a0),a6			* Backup destination address.
	move.w	(a1)+,d7			* Get amount of source points.
	subq.w	#1,d7
	moveq	#0,d6				* Reset amount of destination points.

.loop:	move.w	(a1),d0
.check_first:
	cmp.w	a2,d0
	bge	.check_second_outside
* First point is inside.
.check_second_inside:
	move.w	8(a1),d1
	cmp.w	a2,d1
	blt.s	.inside
* The source edge goes from inside to outside.
* Write the clipped point.
.clip_inside_outside:
	move.w	2(a1),d3
	move.w	10(a1),d2
	move.w	4(a1),d5
	move.w	12(a1),d4
	exg	d0,d1				* swap x0, x1
	IntersectV1Edge
	move.w	a2,(a6)+			* Store X (=leftx).
	move.w	d3,(a6)+			* Store Y.
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d5
	move.w	14(a1),d4
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	addq	#8,a1
	addq.w	#1,d6
	bra	.loop_end
* The source edge is inside -> write the first point to the destination.
.inside:
	addq	#8,a1
	move.l	(a1),(a6)+
	move.l	4(a1),(a6)+
	addq.w	#1,d6
	bra.s	.loop_end
.check_second_outside:
	move.w	8(a1),d1
	cmp.w	a2,d1
	bge.s	.outside
* The source edge goes from outside to inside.
* Write the clipped point and the inside point as well.
.clipped_outside_inside:
	move.w	2(a1),d2
	move.w	10(a1),d3
	move.w	4(a1),d4
	move.w	12(a1),d5
	IntersectV1Edge
	move.w	a2,(a6)+			* Store X (=leftx).
	move.w	d3,(a6)+			* Store Y.
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d4
	move.w	14(a1),d5
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	move.l	8(a1),(a6)+			* Store next X,Y.
	move.l	12(a1),(a6)+			* Store next U,V.
	addq.w	#2,d6
* The source edge is outside, don't write.
.outside:
	addq	#8,a1
.loop_end:
	dbra	d7,.loop

	move.w	d6,(a0)+			* Write amount of destination points.
	move.l	(a0),(a6)			* Duplicate first point.
	move.l	4(a0),4(a6)
	rts

* Clip a v2 polygon against the top.
* INPUT: a0: destination v2-polygon
*        a1: source v2-polygon
*        a2.l: viewport x start
Polygon.clipV2Top:
	lea	2(a0),a6			* Backup destination address.
	move.w	(a1)+,d7			* Get amount of source points.
	subq.w	#1,d7
	moveq	#0,d6				* Reset amount of destination points.

.loop:	move.w	2(a1),d0
.check_first:
	cmp.w	a2,d0
	blt	.check_second_outside
.check_second_inside:
	move.w	10(a1),d1
	cmp.w	a2,d1
	bge.s	.inside
* The source edge goes from inside to outside.
* Write the clipped point.
.clip_inside_outside:
	move.w	0(a1),d3
	move.w	8(a1),d2
	move.w	4(a1),d5
	move.w	12(a1),d4
	exg	d0,d1				* swap x0, x1
	IntersectV1Edge
	move.w	d3,(a6)+			* Store X.
	move.w	a2,(a6)+			* Store Y (clipy).
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d5
	move.w	14(a1),d4
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	addq	#8,a1
	addq.w	#1,d6
	bra	.loop_end
* The source edge is inside -> write the first point to the destination.
.inside:
	addq	#8,a1
	move.l	(a1),(a6)+
	move.l	4(a1),(a6)+
	addq.w	#1,d6
	bra.s	.loop_end
.check_second_outside:
	move.w	10(a1),d1
	cmp.w	a2,d1
	blt.s	.outside
* The source edge goes from outside to inside.
* Write the clipped point and the inside point as well.
.clipped_outside_inside:
	move.w	0(a1),d2
	move.w	8(a1),d3
	move.w	4(a1),d4
	move.w	12(a1),d5
	IntersectV1Edge
	move.w	d3,(a6)+			* Store X.
	move.w	a2,(a6)+			* Store Y (clipy).
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d4
	move.w	14(a1),d5
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	move.l	8(a1),(a6)+			* Store next X,Y.
	move.l	12(a1),(a6)+			* Store next U,V.
	addq.w	#2,d6
* The source edge is outside, don't write.
.outside:
	addq	#8,a1
.loop_end:
	dbra	d7,.loop

	move.w	d6,(a0)+			* Write amount of destination points.
	move.l	(a0),(a6)			* Duplicate first point.
	move.l	4(a0),4(a6)
	rts

* Clip a v2 polygon against the bottom.
* INPUT: a0: destination v2-polygon
*        a1: source v2-polygon
*        a2.l: viewport x start
Polygon.clipV2Bottom:
	lea	2(a0),a6			* Backup destination address.
	move.w	(a1)+,d7			* Get amount of source points.
	subq.w	#1,d7
	moveq	#0,d6				* Reset amount of destination points.

.loop:	move.w	2(a1),d0
.check_first:
	cmp.w	a2,d0
	bge	.check_second_outside
.check_second_inside:
	move.w	10(a1),d1
	cmp.w	a2,d1
	blt.s	.inside
* The source edge goes from inside to outside.
* Write the clipped point.
.clip_inside_outside:
	move.w	0(a1),d3
	move.w	8(a1),d2
	move.w	4(a1),d5
	move.w	12(a1),d4
	exg	d0,d1				* swap y0, y1
	IntersectV1Edge
	move.w	d3,(a6)+			* Store X.
	move.w	a2,(a6)+			* Store Y (clipy).
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d5
	move.w	14(a1),d4
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	addq	#8,a1
	addq.w	#1,d6
	bra	.loop_end
* The source edge is inside -> write the first point to the destination.
.inside:
	addq	#8,a1
	move.l	(a1),(a6)+
	move.l	4(a1),(a6)+
	addq.w	#1,d6
	bra.s	.loop_end
.check_second_outside:
	move.w	10(a1),d1
	cmp.w	a2,d1
	bge.s	.outside
* The source edge goes from outside to inside.
* Write the clipped point and the inside point as well.
.clipped_outside_inside:
	move.w	0(a1),d2
	move.w	8(a1),d3
	move.w	4(a1),d4
	move.w	12(a1),d5
	IntersectV1Edge
	move.w	d3,(a6)+			* Store X.
	move.w	a2,(a6)+			* Store Y (clipy).
	move.w	d5,(a6)+			* Store U.
	move.w	6(a1),d4
	move.w	14(a1),d5
	IntersectV2Edge
	move.w	d5,(a6)+			* Store V.
	move.l	8(a1),(a6)+			* Store next X,Y.
	move.l	12(a1),(a6)+			* Store next U,V.
	addq.w	#2,d6
* The source edge is outside, don't write.
.outside:
	addq	#8,a1
.loop_end:
	dbra	d7,.loop

	move.w	d6,(a0)+			* Write amount of destination points.
	move.l	(a0),(a6)			* Duplicate first point.
	move.l	4(a0),4(a6)
	rts

Polygon.paintTexturemapped2:
	move.w	(a1)+,d7
	movem.w	(a1)+,d0-d1
	movea.l	(a1)+,a0
	movem.w	d0-d1,-(sp)
	move.l	a0,-(sp)
	subq.w	#3,d7

.loop:	move.w	d7,-(sp)

	movem.w	(a1)+,d2-d3
	movea.l	(a1)+,a3			* Sucky backup.
	move.l	a1,-(sp)

	movem.w	(a1),d4-d7
	swap	d6
	move.w	d7,d6
	movea.l	d6,a2

	movea.l	a3,a1

	bsr	PAINT_UNCLIPTEXTURETRIANGLE
	movea.l	(sp)+,a1
	move.w	(sp)+,d7
	movea.l	(sp),a0
	movem.w	4(sp),d0-d1
	dbra	d7,.loop
	addq	#8,sp
	rts

		RSRESET
tmapEdgeXSlope:	RS.L	1
tmapEdgeUSlope:	RS.W	1
tmapEdgeVSlope:	RS.W	1
tmapEdgeXStart:	RS.W	1
tmapEdgeYStart:	RS.W	1
tmapEdgeUStart:	RS.W	1
tmapEdgeVStart:	RS.W	1
tmapEdgeDY:	RS.W	1
tmapEdgeSize:	RS.B	0

* Subroutine that draws a textured fragment to a table.
* Vertical and horizontal clipping are NOT this routine's responsibility.
* INPUT: d0.l: 16:16 (XXxx) left X-start
*        d1.l: 16:16 (XXxx) right X-start
*        d2.l: 8:8 (00Uu) left U-start
*        d3.l: 8:8 (00Vv) left V-start
*        a1.l: 16:16 (XXxx) left X-step
*        a2.l: 16:16 (XXxx) right X-step
*        d4.l: 8:8 (00Uu) left U-step
*        d5.l: 8:8 (00Vv) left V-step
*        d7.w: number of scanlines to paint - 1
*        a0: startentry of scanline table
* OUTPUT: a0: start of next scanline entry
DRAW_TEXTUREFRAGMENT:
.scanline_loop:
	move.l	d0,d6				*  2
	swap	d6				*  4
	move.w	d6,(a0)+			* ?8
	move.l	d1,d6				*  2
	swap	d6				*  4
	move.w	d6,(a0)+			* ?8
	move.w	d2,(a0)+			* ?8
	move.w	d3,(a0)+			* ?8
	add.l	a1,d0				*  2
	add.l	a2,d1				*  2
	add.w	d4,d2				*  2
	add.w	d5,d3				*  2
	dbra	d7,.scanline_loop		*  6
						* 58
	rts

PAINT_UNCLIPTEXTURETRIANGLE:
	movea.l	a0,a3
	movea.l	a1,a4
	movea.l	a2,a5

* d0.l: X1
* d1.l: Y1
* d2.l: X2
* d3.l: Y2
* d4.l: X3
* d5.l: Y3
* a3.l: U1:V1
* a4.l: U2:V2
* a5.l: U3:V3

* Sort points in Y-order.
.sort_y:
	cmp.l	d1,d3
	bgt.s	.first_y_ok
	exg	d0,d2
	exg	d1,d3
	exg	a3,a4
.first_y_ok:
	cmp.l	d1,d5
	bgt.s	.first_y_ok2
	exg	d0,d4
	exg	d1,d5
	exg	a3,a5
.first_y_ok2:
	cmp.l	d3,d5
	bgt.s	.second_y_ok
	exg	d2,d4
	exg	d3,d5
	exg	a4,a5
.second_y_ok:
.end_sort_y:

.calc_edges:
* X2-X1 X3-X1 X3-X2
* Y2-Y1 Y3-Y1 Y3-Y2
* I2-I1 I3-I1 I3-I2

	lea	Polygon.invTable,a6

	lea	.edges_tbl,a0
	lea	tmapEdgeSize(a0),a1
	lea	tmapEdgeSize(a1),a2
	move.w	d0,tmapEdgeXStart(a0)
	move.w	d1,tmapEdgeYStart(a0)
	move.l	d2,d6
	move.l	d3,d7
	sub.l	d0,d6
	sub.l	d1,d7
	muls.w	(a6,d7.l*2),d6
	add.l	d6,d6
	move.l	d6,tmapEdgeXSlope(a0)
	move.l	a3,tmapEdgeUStart(a0)		* u,v
	move.l	a4,d6
	move.w	a3,d6
	sub.l	a3,d6
	swap	d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeUSlope(a0)
	move.w	a4,d6
	sub.w	a3,d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeVSlope(a0)
	move.w	d7,tmapEdgeDY(a0)

;	move.w	d0,tmapEdgeXStart(a1)
;	move.w	d1,tmapEdgeYStart(a1)
	move.l	d4,d6
	move.l	d5,d7
	sub.l	d0,d6
	sub.l	d1,d7
	muls.w	(a6,d7.l*2),d6
	add.l	d6,d6
	move.l	d6,tmapEdgeXSlope(a1)
;	move.l	a3,tmapEdgeUStart(a1)		* u,v
	move.l	a5,d6
	move.w	a3,d6
	sub.l	a3,d6
	swap	d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeUSlope(a1)
	move.w	a5,d6
	sub.w	a3,d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeVSlope(a1)
;	subq.w	#1,d7
;	move.w	d7,tmapEdgeDY(a1)

	move.w	d2,tmapEdgeXStart(a2)
	move.w	d3,tmapEdgeYStart(a2)
	move.l	d4,d6
	move.l	d5,d7
	sub.l	d2,d6
	sub.l	d3,d7
	muls.w	(a6,d7.l*2),d6
	add.l	d6,d6
	move.l	d6,tmapEdgeXSlope(a2)
	move.l	a4,tmapEdgeUStart(a2)		* u,v
	move.l	a5,d6
	move.w	a4,d6
	sub.l	a4,d6
	swap	d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeUSlope(a2)
	move.w	a5,d6
	sub.w	a4,d6
	muls.w	(a6,d7.l*2),d6
	asr.l	#7,d6
	move.w	d6,tmapEdgeVSlope(a2)
	move.w	d7,tmapEdgeDY(a2)
.end_calc_edges:

* Calculate horizontal intensity slope.
.calcslope:
	cmp.l	d1,d3
	bne.s	.not_edge1
	move.l	d2,d7
	sub.l	d0,d7
	addq.w	#1,d7
	move.l	a4,d0
	move.w	a3,d0
	sub.l	a3,d0
	asr.l	#8,d0
	divs.w	d7,d0
	move.w	a4,d1
	sub.w	a3,d1
	ext.l	d1
	lsl.l	#8,d1
	divs.w	d7,d1
	bra.s	.end_calcslope
.not_edge1:
	cmp.l	d3,d5
	bne.s	.not_edge3
	move.l	d4,d7
	sub.l	d2,d7
	addq.w	#1,d7
	move.l	a5,d0
	move.w	a4,d0
	sub.l	a4,d0
	asr.l	#8,d0
	divs.w	d7,d0
	move.w	a5,d1
	sub.w	a4,d1
	ext.l	d1
	lsl.l	#8,d1
	divs.w	d7,d1
	bra.s	.end_calcslope
.not_edge3:

* x_intersect := Edge1Slope * Edge0length + Edge1XStart
	move.l	tmapEdgeXSlope(a1),d7
	moveq	#0,d3
	move.w	tmapEdgeDY(a0),d3
	muls.l	d3,d7
	swap	d7
	add.w	tmapEdgeXStart(a0),d7		a1* x_intersect
* i_intersect := Edge1ISlope * Edge0length + Edge1IStart
	move.w	tmapEdgeUSlope(a1),d0
	move.w	tmapEdgeVSlope(a1),d1
	muls.w	d3,d0
	muls.w	d3,d1
	asr.l	#8,d0
	asr.l	#8,d1
	add.w	tmapEdgeUStart(a0),d0		a1* i_intersect
	add.w	tmapEdgeVStart(a0),d1		a1
* i_horizontalslope := (x_intersect - I2) / (x_intersect - X2)
	sub.w	tmapEdgeXStart(a2),d7
	bmi.s	.fuk
	addq.w	#1,d7
	bra.s	.end_fuk
.fuk:	subq.w	#1,d7
.end_fuk:
	sub.w	tmapEdgeUStart(a2),d0
	sub.w	tmapEdgeVStart(a2),d1
	ext.l	d0
	ext.l	d1
	lsl.l	#8,d0
	lsl.l	#8,d1
	ext.l	d7
	beq.s	.slope0
	divs.w	d7,d0
	divs.w	d7,d1
.slope0:
.end_calcslope:

* d0.w: Uu
* d1.w: Vv
* d7.l: dx

	movem.w	d0/d1,Polygon.uvslopes

* Special case for triangles that have a horizontal edge.
	lea	.edges_tbl,a0
	tst.w	tmapEdgeDY(a0)
	bne.s	.make_fragments
	move.w	tmapEdgeDY(a2),d7
	subq.w	#1,d7
	movea.w	d7,a5
	bmi	.end_paint_triangle
	moveq	#0,d0
	move.w	tmapEdgeXStart(a0),d0
	swap	d0
	moveq	#0,d1
	move.w	tmapEdgeXStart(a2),d1
	swap	d1
	movea.l	tmapEdgeXSlope(a1),a4
	movea.l	tmapEdgeXSlope(a2),a6
	cmp.l	d0,d1
	bgt.s	.left_right
.right_left:
	exg	d0,d1
	exg	a4,a6
	move.w	tmapEdgeUStart(a2),d2
	lsl.w	#8,d2
	move.w	tmapEdgeVStart(a2),d3
	lsl.w	#8,d3
	move.w	tmapEdgeVSlope(a2),d5
	move.w	tmapEdgeUSlope(a2),d4
	bra.s	.start_x_okay
.left_right:
	move.l	a3,d2	tmapEdgeUStart(a1),d2
	sub.w	d2,d2
	lsr.l	#8,d2
	move.w	a3,d3	tmapEdgeVStart(a1),d3
	lsl.w	#8,d3
	moveq	#0,d4
	move.w	tmapEdgeVSlope(a1),d5
	move.w	tmapEdgeUSlope(a1),d4
.start_x_okay:
	movea.l	a4,a1
	movea.l	a6,a2
	movea.w tmapEdgeYStart(a0),a4
	lea	Polygon.scanlineTable,a0
	bsr	DRAW_TEXTUREFRAGMENT
 	bra	.end_draw_fragments

.make_fragments:
	move.l	tmapEdgeXSlope(a0),d0
	move.l	tmapEdgeXSlope(a1),d1
	cmp.l	d0,d1
	blt	.make_fragments_rl

* a0 /\ a1
*      \
.make_fragments_lr:
* Create upper fragment..
	movea.l	a2,a6
	movea.w	tmapEdgeYStart(a0),a4
	move.l	d0,a1
	move.l	d1,a2
	moveq	#0,d0
	move.w	tmapEdgeXStart(a0),d0
	swap	d0
	move.l	d0,d1
	move.w	tmapEdgeUStart(a0),d2
	lsl.w	#8,d2
	move.w	tmapEdgeVStart(a0),d3
	lsl.w	#8,d3
	move.w	tmapEdgeVSlope(a0),d5
	move.w	tmapEdgeUSlope(a0),d4
	move.w	tmapEdgeDY(a0),d7
	subq.w	#1,d7
	movea.w	d7,a5
	lea	Polygon.scanlineTable,a0
	bmi.s	.lr_skip_upper
	bsr	DRAW_TEXTUREFRAGMENT
.lr_skip_upper:

* Create lower fragment..
	move.w	tmapEdgeDY(a6),d7
	adda.w	d7,a5
	moveq	#0,d0
	move.w	tmapEdgeXStart(a6),d0
	swap	d0
	move.w	tmapEdgeUStart(a6),d2
	lsl.w	#8,d2
	move.w	tmapEdgeVStart(a6),d3
	lsl.w	#8,d3
	move.w	tmapEdgeVSlope(a6),d5
	move.w	tmapEdgeUSlope(a6),d4
	movea.l	tmapEdgeXSlope(a6),a1
	subq.w	#1,d7
	bmi.s	.lr_skip_lower
	bsr	DRAW_TEXTUREFRAGMENT
.lr_skip_lower:
 	bra	.end_draw_fragments

.make_fragments_rl:
* Create upper fragment..
	movea.l	a2,a6
	movea.w	tmapEdgeYStart(a0),a4
	move.l	d0,a2
	moveq	#0,d0
	move.w	tmapEdgeXStart(a0),d0
	swap	d0
	move.w	tmapEdgeUStart(a0),d2
	lsl.w	#8,d2
	move.w	tmapEdgeVStart(a0),d3
	lsl.w	#8,d3
	move.w	tmapEdgeVSlope(a1),d5
	move.w	tmapEdgeUSlope(a1),d4
	move.w	tmapEdgeDY(a0),d7
	move.l	d1,a1
	move.l	d0,d1
	subq.w	#1,d7
	movea.w	d7,a5
	lea	Polygon.scanlineTable,a0
	bmi.s	.rl_skip_upper
	bsr	DRAW_TEXTUREFRAGMENT
.rl_skip_upper:

* Create lower fragment..
	move.w	tmapEdgeDY(a6),d7
	adda.w	d7,a5
	moveq	#0,d1
	move.w	tmapEdgeXStart(a6),d1
	swap	d1
	movea.l	tmapEdgeXSlope(a6),a2
	subq.w	#1,d7
	bmi.s	.rl_skip_lower
	bsr	DRAW_TEXTUREFRAGMENT
.rl_skip_lower:
.end_draw_fragments:

	move.w	Polygon.curtexture,d0
	movea.l	Polygon.textureadr,a0
	movea.l	(a0,d0.w*4),a3
	movea.l	Primitive.screenadr,a0
	move.w	a4,d0	;move.w	Polygon.fragmentTable+2+Fragment.START(a6),d0
	mulu.w	Viewport.settingsTable+Viewport.XSCREEN,d0
	add.l	d0,d0
	adda.l	d0,a0
	lea	Polygon.scanlineTable,a1
	move.w	a5,d7
	bpl.s	PAINT_UNCLIPTEXTURESCANS

.end_paint_triangle:
	rts

	BSS

.edges_tbl:
	DS.B	tmapEdgeSize*3

	TEXT

* Draws a textured triangle to the screen.
* Horizontal clipping is implemented.
* INPUT: a0: start screenline
*        a1: start entry in scanline table
*        a3: texture
*        d7.w: number of scanlines to paint - 1
PAINT_UNCLIPTEXTURESCANS:
	movem.w	Polygon.uvslopes,d0/d5
	ror.l	#8,d5
	move.l	d5,d1
	move.w	d0,d1
	movea.l	d1,a5
	moveq	#0,d6
	move.w	Viewport.settingsTable+Viewport.XSCREEN,d6
	add.l	d6,d6

.paint_yloop:
	movem.w	(a1)+,d0-d3
* d0.w: left x
* d1.w: right x
* d2.w: left Uu 8:8
* d3.w: left Vv 8:8
	sub.w	d0,d1
	ble.s	.end_paint_yloop
	lea	(a0,d0.l*2),a6
	ror.l	#8,d3
	move.l	d3,d4
	move.w	d2,d4				* d4.l: v0Uu left v, left Uu
	move.b	d3,d2				* d2.b: left V
	subq.w	#1,d1

.paint_xloop:
	move.w	d4,d0
	add.l	a5,d4
	move.b	d2,d0
	addx.b	d5,d2
	move.w	(a3,d0.l*2),d0
	beq.s	.end_write
	move.w	d0,(a6)
.end_write:
	addq	#2,a6
	dbra	d1,.paint_xloop

.end_paint_yloop:
	adda.l	d6,a0
	dbra	d7,.paint_yloop
	rts

******** OBJECT DATA ********

	DATA

RotoZoomer.textureTable
	DC.L	RotoZoomer.map
	DC.L	0

RotoZoomer.sRectangle:
	DC.W	015,000+000
	DC.W	015,000+059
	DC.W	080,000+059
	DC.W	080,000+000
;	DC.W	0,0
;	DC.W	63,0
;	DC.W	63,63
;	DC.W	0,63
RotoZoomer.eRectangle:
	DC.W	0,64
	DC.W	63,64
	DC.W	63,127
	DC.W	0,127
RotoZoomer.cRectangle:
	DC.W	015,060+000
	DC.W	015,060+049
	DC.W	080,060+049
	DC.W	080,060+000
;	DC.W	0,128
;	DC.W	63,128
;	DC.W	63,191
;	DC.W	0,191
RotoZoomer.tRectangle:
	DC.W	015,115+000
	DC.W	015,115+054
	DC.W	080,115+054
	DC.W	080,115+000
;	DC.W	0,192
;	DC.W	63,192
;	DC.W	63,255
;	DC.W	0,255
RotoZoomer.oRectangle:
	DC.W	64,0
	DC.W	127,0
	DC.W	127,63
	DC.W	64,63
RotoZoomer.rRectangle:
	DC.W	64,64
	DC.W	127,64
	DC.W	127,127
	DC.W	64,127
RotoZoomer.1Rectangle:
	DC.W	015,166+000
	DC.W	015,166+049
	DC.W	080,166+049
	DC.W	080,166+000
;	DC.W	64,64
;	DC.W	127,64
;	DC.W	127,127
;	DC.W	64,127
RotoZoomer.fRectangle:
	DC.W	015+070,000+000
	DC.W	015+070,000+059
	DC.W	080+070,000+059
	DC.W	080+070,000+000
;	DC.W	64,128
;	DC.W	127,128
;	DC.W	127,191
;	DC.W	64,191
RotoZoomer.uRectangle:
	DC.W	015+070,056+000
	DC.W	015+070,056+057
	DC.W	080+070,056+057
	DC.W	080+070,056+000
;	DC.W	64,192
;	DC.W	127,192
;	DC.W	127,255
;	DC.W	64,255
RotoZoomer.nRectangle:
	DC.W	015+070,111+000
	DC.W	015+070,111+059
	DC.W	080+070,111+059
	DC.W	080+070,111+000
;	DC.W	128,0
;	DC.W	191,0
;	DC.W	191,63
;	DC.W	128,63

RotoZoomer.polygonTest:
	DC.W	0
	DC.W	4
	DC.W	040,010,010,040
	DC.W	120,010,010,120
	DC.W	120,090,090,120
	DC.W	040,090,090,040

RotoZoomer.charRectAddy:
	DC.L	RotoZoomer.sRectangle

RotoZoomer.flowPal:
	DC.W	(.end-.start)/4
	DC.W	6
.start:	DC.L	$1F1F003F
	DC.L	$7F7F009F
	DC.L	$BFBF00DF
.end:

RotoZoomer.wipe
	DC.W	0
RotoZoomer.wipeCount:
	DC.W	0

******** OBJECT RESERVES ********

	BSS

RotoZoom.byteTexture:
	DS.B	256*256

RotoZoomer.texture:
	DS.W	256*256

RotoZoomer.fontActive:
	DS.W	1
RotoZoomer.startTime:
	DS.L	1
RotoZoomer.fontStartTime:
	DS.L	1
RotoZoomer.vectorTable:
	DS.B	VectorTable.SIZE
RotoZoomer.scaledVectorTable:
	DS.B	VectorTable.SIZE
RotoZoomer.center:
	DS.W	2
RotoZoomer.logBuffer:
	DS.W	160*100
RotoZoomer.pal:
	DS.W	256

RotoZoomer.map:
	DS.B	20
	DS.W	256*256

******** Viewport

Viewport.settingsTable:
	DS.B	Viewport.SIZE

******** Primitive

Primitive.screenadr:
	DS.L	1

******* Polygon

Polygon.gradadr:				* address of current gradient table
	DS.L	1
Polygon.textureadr:				* base address of texture tables
	DS.L	1
Polygon.textureroutadr:
	DS.L	1
Polygon.v4routadr:
	DS.L	1
Polygon.alphatableadr:
	DS.L	1
Polygon.texturemode:
	DS.W	1
Polygon.v4texturemode:
	DS.W	1
Polygon.color:					* current color
	DS.L	1
Polygon.coloradr:				* base address of gradient tables
	DS.L	1
Polygon.curtexture:				* first current textureaddress
	DS.L	1
Polygon.curtexture2:				* second current textureaddress
	DS.L	1

Polygon.uvslopes:
	DS.W	4				* u0,v0,u1,v1
Polygon.invTable:
	DS.W	320
Polygon.shadeTable:
	DS.W	2*16				* (u,v) for each vertex
Polygon.extvertexTable:
	DS.W	4*3				* for each trianglevertex: u0,v0,u1,v1
Polygon.polypointTable:
	DS.W	1
	DS.B	12*16
Polygon.polypointTable2:
	DS.W	1
	DS.B	12*16
Polygon.scanlineTable:
	DS.W	1
	DS.W	3*200				* table for tmap and envmap scanlines
Polygon.fragmentTable:
	DS.W	1				* active fragment flags
	DS.B	Fragment.SIZE*4			* max 3 for quad, max 2 for triangle

******** END OF DEMO-EFFECT OBJECT ********