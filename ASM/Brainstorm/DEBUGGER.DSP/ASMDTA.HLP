{ABS}						Absolute Value

Operation:
	|D|->D				(parallel move)

Assembler Syntax:
	ABS	D				(parallel move)

Description:
	Take the absolute value of the destination operand D and store the
result in the destination accumulator.

Example:
	ABS	A	#$123456,X0	A,Y0	; Take abs. value, setup X0, save value

	Before execution:
		A = $FF:FFFFFF:FFFFF2
	After execution:
		A = $00:000000:00000E

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$FF:FFFFFF:FFFFF2, Since this is a negative number, the execution of
the ABS instruction takes the twos complement of that value and returns
$00:000000:00000E.

NOTE: For the case in which the D operand equals $80:000000:000000
( -256.0), the ABS instruction will cause an overflow to occur since
the result cannot be correctly expressed using the standard 56-bit,
fixed-point, twos-complement data representation. Data limiting does
not occur (i.e., A is not set to the limiting value of
$7F:FFFFFF:FFFFFF).

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|L |**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result

NOTE: The definition of the {E} and {U} bits varies according to the
scaling mode being used.

Instruction Format:
	ABS	D

	D = ({A},{B})
	
Timing:		2+mv oscillator clock cycles

Memory:		1+mv programs words


{ADC}						Add Long with Carry

Operation:
	S+C+D -> D			(parallel move)

Assembler Syntax:
	ADC	S,D				(parallel move)

Description:
	Add the source operand S and the carry bit {C} of the condition code
register to the destination operand D and store the result in the
destination accumulator. Long words (48 bits) may be added to the
(56-bit) destination accumulator.

NOTE: The carry bit is set correctly for multiple precision arithmetic
using long word operands if the extension register of the destination
accumulator ({A2} or {B2}) is the sign extension of bit 47 of the
destination accumulator ({A} or {B}).

Example:
	MOVE	L:<$0,X			;get a 48-bit LS long-word operand in X
	MOVE	L:<$1,A			;get other LS long word in A (Sing ext.)
	MOVE	L:<$2,Y			;get a 48-bit MS long-word operand in Y
	ADD		X,A	L:<$3,B		;add LS words; get other MS word in B
	ADC		Y,B	A10,L:<$4	;add MS words with carry, save LS sum
	MOVE	B10,L:<$5		;save MS sum

	Before Execution:
		A = $FF:800000:000000
		X = $800000:000000
		B = $00:000000:000001
		Y = $000000:000001
		
	After Execution:
		A = $FF:000000:000000
		X = $800000:000000
		B = $00:000000:000000
		Y = $000000:000001

Explanation of Example:
	This example illustrates long-word double-precision (96-bit) addition
using the ADC instruction. Prior to execution of the ADD and ADC
instructions, the double-precision 96-bit value
$000000:000001:800000:000000 is loaded into the {Y} and {X} registers (Y:X),
respectively. The other double-precision 96-bit value
$000000:000001:800000:000000 is loaded into the {B} and {A} accumulators
(B:A), respectively. Since the 48-bit value loaded into the {A}
accumulator is automatically sign extended to 56 bits and the other
48-bit long-word operand is internally sign extended to 56 bits during
instruction execution, the carry bit wil be set correctly after the
execution of the ADD X,A instruction. The ADC Y,B instruction then
produces the correct MS 56-bit result. The actual 96-bit result is
stored in memory using the {A10} and {B10} operands (instead of {A} and {B})
because shifting and limiting is not desired.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the {E} and {U} bits varies according to the
scaling mode being used.

Instruction Format:
	ADC	S,D

	S = (X,Y)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ADD}						Add

Operation:
	S+D -> D			(parallel move)

Assembler Syntax:
	ADD	S,D				(parallel move)

Description:
	Add the source operand S to the destination operand D and store the
result in the destination accumulator. Words (24 bits), long words (48
bits), and accumulators (56 bits) may be added to the destination
accumulator.

NOTE: The carry bit is set correctly using word and long-word source
operands if the extension register of the destination accumulator (A2
or B2) is the sign extension of bit 47 of the destination accumulator
(A or B). Thus, the carry bit is always set correctly using accumulator
source operands, but can be set incorrectly if {A1}, {B1}, {A10}, or {B10} are
used as source operands and {A2} and {B2} are not replicas of bit 47.

Example:
	ADD	X0,A A,X1	A,Y:(R1)+	;24-bit add,set up X1, save prev, result
	
	Before Execution:
		X0 = $FFFFFF
		A  = $00:000100:000000

	After Execution:
		X0 = $FFFFFF
		A  = $00:0000FF:000000

Explanation of Example:
	Prior to execution, the 24-bit {X0} register contains the value
$FFFFFF and the 56-bit {A} accumulator contains the value
$00:000100:000000. The ADD instruction automatically appends the 24-bit
value in the {X0} register with 24 LS zeros, sign extends the resulting
48-bit long word to 56 bits, and adds the result to the 56-bit {A}
accumulator. Thus, 24-bit operands are are added to the MSP portion of
{A} or {B} ({A}1 or {B}1) because all arithmetic instructions assume a
fractional, twos complement data representation. Note that 24-bit
operands can be added to the LSP portion of {A} or {B} ({A0} or {B0}) by loading
the 24-bit operand into {X0} or {Y0}, forming a 48-bit word by loading {X1} or
{Y1} with the sign extension of {X0} or {Y0} and executing an ADD X,A or
ADD Y,A instruction.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the {E} and {U} bits varies according to the
scaling mode being used.

Instruction Format:
	ADD	S,D

	S = (A,B,X,Y,X0,Y0,X1,Y1)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ADDL}						Shift Left and Add Accumulators

Operation:
	S+2*D -> D			(parallel move)

Assembler Syntax:
	ADDL	S,D			(parallel move)

Description:
	Add the source operand S to two times the destination operand D and
store the result in the destination accumulator. The destination
operand D is arithmecally shifted one bit to the left, and a zero is
shifted into the LS bit of D prior to the addition operation. The carry
bit is set correctly if the source operand does not overflow as a
result of the left shifte operation. The overflow bit may be set as a
result of either the shifting or addition operation (or both). This
instruction is useful for efficient divide and decimation int time
(DIT) FFT algorithms.

Example:
	ADDL	A,B	#$0,R0		;A + 2 * B -> B, set up addr. reg. {R0}

	Before Execution:
		A = $00:000000:000123
		B = $00:005000:000000

	After Execution:
		A = $00:000000:000123
		B = $00:00A000:000123

Explanation of example:
	Prior to execution, the 56-bit accumulator contains the value
$00:000000:000123, and the 56-bit B accumulator contains the value
$00:005000:000000. The ADDL A,B instruction adds two times the value
in the {B} accumulator to the value in the {A} accumulator and stores the
56-bit result in the {B} accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result or if the MS bit of
	   the destination operand is changed as a result of the instruction's
	   left shift
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the {E} and {U} bits varies according to the
scaling mode being used.

Instruction Format:
	ADDL	S,D

	S = ({A},{B})
	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ADDR}						Shift Right and Add Accumulators

Operation:
	S + D / 2 -> D		(parallel move)

Assembler Syntax:
	ADDR	S,D			(parallel move)

Description:
	Add the source operand S to one-half the destination operand D and
store the result in the destination accumulator. The destination operand
D is arithmetically shifted one bit to the right while the MS bit of D
is held constant prior to the addition operation. In contrast to the
ADDL instruction, the carry bit is always set correctly, and the
overflow bit can only be set by the addition operation and not by an
overflow due to the initial shifting operation. This instuction is
useful for efficient divide and decimation in time (DIT) FFT
algorithms.

Example:
	ADDR	B,A	X0,X:(R1)+N1 Y0,Y:(R4)-		;B+A/2 -> A, save X0 and Y0

	Before execution:
		A = $80:000000:2468AC
		B = $00:013570:000000
	After execution:
		A = $C0:013570:123456
		B = $00:013570:000000

Explanation of Example:
	Prior to execution, the 56-bit {A} accumulator contains the value
$80:000000:2468AC, and the 56-bit {B} accumulator contains the value
$00:013570:000000. The ADDR B,A instruction adds one-half the value
in the {A} accumulator to the value in the {B} accumulator and stores
the 56-bit result in the {A} accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the {E} and {U} bits varies according to the
scaling mode being used.

Instruction Format:
	ADDR	S,D

	S = ({A},{B})
	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{AND}						Logical AND

Operation:
	S & D[47:24] -> D[47:24] (parallel move)
	where & denotes the logical AND operator

Assembler Syntax:
	AND	S,D				(parallel move)

Description:
	Logically AND the source operand S with bits 47-24 of the
destination operand D and store the result in bits 47-24 of the
destination accumulator. This instruction is a 24-bit operation. The
remaining bits of the destination operand D are not affected.

Example:
	AND	X0,A	(R5)-N5		;AND X0 with A1, update R5 using N5

	Before Execution:
		X0 = $FF0000
		A  = $00:123456:789ABC

	After Execution:
		X0 = $FF0000
		A  = $00:120000:789ABC

Explanation of Example:
	Prior to execution, the 24-bit {X0} register contains the value
$FF0000, and the 56-bit {A} accumulator contains the value
$00:123456:789ABC. The AND X0,A instruction logically ANDs the 24-bit
value in the {X0} register with bits 47-24 of the {A} accumulator ({A1})
and stores the result in the the {A} accumulator with bits 55-48 and
23-0 unchanged.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 A or B result are zero
	{V}- Always cleared

Instruction Format:
	AND	S,D

	S = ({X0},{X1},{Y0},{Y1})
	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ANDI}						AND Immediate with Control Register

Operation:
	#xx & D -> D
	where & denotes the logical AND operator

Assembler Syntax:
	AND(I)	#xx,D

Description:
	Logically AND the 8-bit immediate operand (#xx) with the contents
of the destination control register D and store the result in the
destination control register. The condition code are affected only when
the condition code register (CCR) is specified as the destination
operand.

Restrictions:
	The ANDI #xx,MR instruction cannot be used immediately before an
{ENDDO} or {RTI} instruction and cannot be one of the last three
instructions in a {DO} loop (at {LA}-2, {LA}-1, or {LA}).
The ANDI #xx,CCR instruction cannot be used immediately before an {RTI}
instruction.

Example:
	ANDI	#$FE,CCR		;clear carry bit C in cond. code register

	Before Execution:
		CCR = $31
	After Execution:
		CCR = $30

Explanation of Example:
	Prior to execution, the 8-bit condition code register ({CCR})
contains the value $31. The ANDI #$FE,CCR instruction logically ANDs
the immediate 8-bit value $FE with the contents of the condition code
register and stores the result in the condition code register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

For CCR Operand:
	{L}- Cleared if bit 6 of the immediate operand is cleared
	{E}- Cleared if bit 5 of the immediate operand is cleared
	{U}- Cleared if bit 4 of the immediate operand is cleared
	{N}- Cleared if bit 3 of the immediate operand is cleared
	{Z}- Cleared if bit 2 of the immediate operand is cleared
	{V}- Cleared if bit 1 of the immediate operand is cleared
	{C}- Cleared if bit 0 of the immediate operand is cleared

For MR and OMR Operands:
	The condition codes are not affected using these operands.

Instruction Format:
	ANDI	#xx,D
	
	#xx = 8-bit Immediate Short Data
	D = ({MR},{CCR},{OMR})

Timing:		2 oscillator clock cycles

Memory:		1 program word


{ASL}						Aritmetic Shift Accumulator Left

Operation:

	    55 47     23   0
	   +--+------+------+
	C<-|<-|<-----|<-----|<--0 (parallel move)
	   +--+------+------+

Assembler Syntax:
	ASL	D				(parallel move)

Description:
	Arithmetically shift the destination operand D one bit to the left
and store the result in the destination accumulator. The MS bit of D
prior to instruction execution is shifted into the carry bit {C} and a
zero is shifted into the LS bit of the destination accumulator D. If a
zero shift count is specified, the carry bit is cleared. The difference
between ASL and {LSL} is that ASL operates on the entires 56 bits of
the accumulator and therefore sets the {V} bit if the number overflowed.

Example:
	ASL A	(R3)-		;multiply A by 2,update R3

	Before Execution:
		A  = $A5:012345:012345
		SR = $0300

	After Execution:
		A  = $4A:02468A:02468A
		SR = $0373

Explanation of Example:
	Prior to execution, the 56-bit {A} accumulator contains the value
$A5:012345:012345. The execution of the ASL A instruction shifts the
56-bit value in the A accumulator one bit to the left and stores the
result back in the A accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if bit 55 of A or B result is changed due to left shift
	{C}- Set if bit 55 of A or B was set prior to instruction execution

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	ASL	D

	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ASR}						Arithmetic Shift Accumulator Right

Operation:

	    55 47     23   0
	   +--+------+------+
	+->|->|----->|----->|--> C (parallel move)
	|  +--+------+------+
	+---+

Assembler Syntax:
	ASR	D				(parallel move)

Description:
	Arithmetically shift the destination operand D one bit to the right
and store the result in the destination accumulator. The LS bit of D
prior to instruction execution is shifted into the carry bit {C}, and
the MS bit of D is held constant.

Example:
	ASR B	X:-(R3),R3		;divide B by 2, update R3,load R3

	Before Execution:
		B  = $AB:A86420:A86421
		SR = $0300

	After Execution:
		B  = $D4:543210:543210
		SR = $0329

Explanation of Example:
	Prior to execution, the 56-bit {B} accumulator contains the value
$A8:A86420:A86420. The execution of the ASR B instruction shifts the
56-bit value in the B accumulator one bit to the right and restore
the result back in the B accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Always cleared
	{C}- Set if bit 0 of A or B was set prior to instruction execution

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	ASR D

	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{BCHG}						Bit Test and Change

Operation:
	D[n] -> C;
	D[n] -> D[n]

Assembler Syntax:
	BCHG	#n,X:ea
	BCHG	#n,X:aa
	BCHG	#n,X:pp
	BCHG	#n,Y:ea
	BCHG	#n,Y:aa
	BCHG	#n,Y:pp
	BCHG	#n,D

Description:
	Test the nth bit of the destination operand D, complement it, and
store the result in the destination location. The state of the nth bit
is stored in the carry bit {C} of the condition code register. After the
test, the nth bit of the destination location is complemented. The bit
to be tested is selected by an immediate bit number from 0-23. This
instruction performs a read-modify-write operation on the destination
locatiob using two destination accesses before releasing the bus. This
instruction providesa test-and-change capability which is useful for
synchronizing multiple processors using a shared memory. This
instruction can use all memory alterable addressing modes.

Example:
	BCHG	#$7,X:<<$FFE2		;test and change bit 7 in I/O Port B DDR

	Before Execution:
		X:$FFE2 = $000000
		SR      = $0300

	After Execution:
		X:$FFE2 = $000080
		SR      = $0300

Explanation of Example:
	Prior to execution, the 24-bit X memory location X:$FFE2 (I/O port
B data direction register) contains the value $000000. The execution of
the BCHG #$7,X:<<$FFE2 instructiontests the state of the 7th bit in
X:$FFE2, sets the carry bit {C} accordingly, and then complements the 7th
bit in X:$FFE2.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

CCR Condition Codes:
	For destination operand SR:
		{C}- Changed if bit 0 is specified. Not affected otherwise.
		{V}- Changed if bit 1 is specified. Not affected otherwise.
		{Z}- Changed if bit 2 is specified. Not affected otherwise.
		{N}- Changed if bit 3 is specified. Not affected otherwise.
		{U}- Changed if bit 4 is specified. Not affected otherwise.
		{E}- Changed if bit 5 is specified. Not affected otherwise.
		{L}- Changed if bit 6 is specified. Not affected otherwise.

	For other destination operands:
		{C}- Set if bit tested is set. Cleared otherwise.
		{V}- Not Affected.
		{Z}- Not Affected.
		{N}- Not Affected.
		{U}- Not Affected.
		{E}- Not Affected.
		{L}- Not Affected.

MR Status Bits:
	For destination operand SR:
		{I0}- Changed if bit 8 specified. Not affected otherwise.
		{I1}- Changed if bit 9 specified. Not affected otherwise.
		{S0}- Changed if bit 10 specified. Not affected otherwise.
		{S1}- Changed if bit 11 specified. Not affected otherwise.
		{T} - Changed if bit 13 specified. Not affected otherwise.
		{LF}- Changed if bit 15 specified. Not affected otherwise.

	For other destination operands:
		{I0}- Not affected
		{I1}- Not affected
		{S0}- Not affected
		{S1}- Not affected
		{T} - Not affected
		{LF}- Not affected

Instruction Format:
	BCHG	#n,X:ea
	BCHG	#n,Y:ea
	BCHG	#n,X:aa
	BCHG	#n,Y:aa
	BCHG	#n,X:pp
	BCHG	#n,Y:pp
	BCHG	#n,D

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	D  = (	{X0},{X1},{Y0},{Y1},{A0},{B0},{A2},{B2},{A1},{B1},{A},{B},
			{Rn},{Nn},{Mn},{SR},{OMR},{SP},{SSH},{SSL},{LA},{LC})

Timing:		4 + mvb oscillator clock cycles

Memory:		1 + ea program words


{BCLR}						Bit Test and Clear

Operation:
	D[n] -> C;
	0 -> D[n]

Assembler Syntax:
	BCLR	#n,X:ea
	BCLR	#n,X:aa
	BCLR	#n,X:pp
	BCLR	#n,Y:ea
	BCLR	#n,Y:aa
	BCLR	#n,Y:pp
	BCLR	#n,D

Description:
	Test the nth bit of the destination operand D, clear it and store
the result in the destination location. The state of the nth bit is
stored in the carry bit C of the condition code register. After the
test, the nth bit of the destination location is clered. The bit to be
tested is selected by an immediate bit number from 0-23. This
instruction performs a read-modify-write operation on the destination
location using two destination accesses before releasing the bus. This
instruction provides a test-and-clear capability which is useful for
synchronizing multiple processors using a shared memory. This
instruction can use all memory alterable addressing modes.

Example:
	BCLR	#$E,X<<$FFE4	;test and clear bit 14 in I/O Port B Data Reg.

	Before Execution:
		X:$FFE4 = $FFFFFF
		SR      = $0300

	After Execution:
		X:$FFE4 = $FFBFFF
		SR      = $0301

Explanation of Example:
	Prior to execution, the 24-bit X memory location X:$FFE4 (I/O port
B data register) contains the value $FFFFFF. The execution of the
BCLR #$E,X:<<$FFE4 instruction tests the state of the 14th bit in
X:$FFE4, sets the carry bit {C} accordingly, and then clears the 14th
bit in X:$FFE4.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

{CCR} Condition Codes:
	For destination operand {SR}:
		{C}- Changed if bit 0 is specified. Not affected otherwise.
		{V}- Changed if bit 1 is specified. Not affected otherwise.
		{Z}- Changed if bit 2 is specified. Not affected otherwise.
		{N}- Changed if bit 3 is specified. Not affected otherwise.
		{U}- Changed if bit 4 is specified. Not affected otherwise.
		{E}- Changed if bit 5 is specified. Not affected otherwise.
		{L}- Changed if bit 6 is specified. Not affected otherwise.

	For other destination operands:
		{C}- Set if bit tested is set. Cleared otherwise.
		{V}- Not Affected.
		{Z}- Not Affected.
		{N}- Not Affected.
		{U}- Not Affected.
		{E}- Not Affected.
		{L}- Not Affected.

{MR} Status Bits:
	For destination operand {SR}:
		{I0}- Changed if bit 8 specified. Not affected otherwise.
		{I1}- Changed if bit 9 specified. Not affected otherwise.
		{S0}- Changed if bit 10 specified. Not affected otherwise.
		{S1}- Changed if bit 11 specified. Not affected otherwise.

		{T} - Changed if bit 13 specified. Not affected otherwise.
		{LF}- Changed if bit 15 specified. Not affected otherwise.

	For other destination operands:
		{I0}- Not affected
		{I1}- Not affected
		{S0}- Not affected
		{S1}- Not affected
		{T} - Not affected
		{LF}- Not affected

Instruction Format:
	BCLR	#n,X:ea
	BCLR	#n,Y:ea
	BCLR	#n,X:aa
	BCLR	#n,Y:aa
	BCLR	#n,X:pp
	BCLR	#n,Y:pp
	BCLR	#n,D

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	D  = (	{X0},{X1},{Y0},{Y1},{A0},{B0},{A2},{B2},{A1},{B1},{A},{B},
			{Rn},{Nn},{Mn},{SR},{OMR},{SP},{SSH},{SSL},{LA},{LC})

Timing:		4 + mvb oscillator clock cycles

Memory:		1 + ea program words


{BSET}						Bit Test and Set

Operation:
	D[n] -> C;
	1 -> D[n]

Assembler Syntax:
	BSET	#n,X:ea
	BSET	#n,X:aa
	BSET	#n,X:pp
	BSET	#n,Y:ea
	BSET	#n,Y:aa
	BSET	#n,Y:pp
	BSET	#n,D

Description:
	Test the nth bit of the destination operand D, set it, and store
the result in the destination location. The state of the nth bit is
stored in the carry bit {C} of the condition code register. After the
test, the nth bit of the destination location is set. The bit to be
tested is selected by an immediate bit number from 0-23. This
instruction performs a read-modify-write operation on the destination
location using two destination accesses before releasing the bus. This
instruction provides a test-and-set capability which is useful for
synchronizing multiple processorsusing a shared memory. This
instruction can use all memory alterable addressing modes.

Example:
	BSET	#$0,X:<<$FFE5	;test and set bit 10 in I/O Port C Data Reg.

	Before Execution:
		X:$FFE5 = $000000
		SR      = $0300

	After Execution:
		X:$FFE5 = $000001
		SR      = $0300

Explanation of Example:
	Prior to execution, the 24-bit X memory location X:$FFE5 (I/O port
C data register) contains the value $000000. The execution of the BSET
#$0,X:<<$FFE5 instruction test the state of the 0th bit in X:$FFE5,
sets the carry bit {C} accordingly, and then sets the 0th bit in X:$FFE5.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

{CCR} Condition Codes:
	For destination operand {SR}:
		{C}- Changed if bit 0 is specified. Not affected otherwise.
		{V}- Changed if bit 1 is specified. Not affected otherwise.
		{Z}- Changed if bit 2 is specified. Not affected otherwise.
		{N}- Changed if bit 3 is specified. Not affected otherwise.
		{U}- Changed if bit 4 is specified. Not affected otherwise.
		{E}- Changed if bit 5 is specified. Not affected otherwise.
		{L}- Changed if bit 6 is specified. Not affected otherwise.

	For other destination operands:
		{C}- Set if bit tested is set. Cleared otherwise.
		{V}- Not Affected.
		{Z}- Not Affected.
		{N}- Not Affected.
		{U}- Not Affected.
		{E}- Not Affected.
		{L}- Not Affected.

{MR} Status Bits:
	For destination operand {SR}:
		{I0}- Changed if bit 8 specified. Not affected otherwise.
		{I1}- Changed if bit 9 specified. Not affected otherwise.
		{S0}- Changed if bit 10 specified. Not affected otherwise.
		{S1}- Changed if bit 11 specified. Not affected otherwise.
		{T} - Changed if bit 13 specified. Not affected otherwise.
		{LF}- Changed if bit 15 specified. Not affected otherwise.

	For other destination operands:
		{I0}- Not affected
		{I1}- Not affected
		{S0}- Not affected
		{S1}- Not affected
		{T} - Not affected
		{LF}- Not affected

Instruction Format:
	BSET	#n,X:ea
	BSET	#n,Y:ea
	BSET	#n,X:aa
	BSET	#n,Y:aa
	BSET	#n,X:pp
	BSET	#n,Y:pp
	BSET	#n,D

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	D  = (	{X0},{X1},{Y0},{Y1},{A0},{B0},{A2},{B2},{A1},{B1},{A},{B},
			{Rn},{Nn},{Mn},{SR},{OMR},{SP},{SSH},{SSL},{LA},{LC})

Timing:		4 + mvb oscillator clock cycles

Memory:		1 + ea program words


{BTST}						Bit Test

Operation:
	D[n] -> C

Assembler Syntax:
	BTST	#n,X:ea
	BTST	#n,X:aa
	BTST	#n,X:pp
	BTST	#n,Y:ea
	BTST	#n,Y:aa
	BTST	#n,Y:pp
	BTST	#n,D

Description:
	Test the nth bit of the destination operand D. The state of the nth
bit is stored in the carry bit {C} of the condition code register. The bit
to be tested is selected by an immediate bit number from 0-23. This
instruction is useful for performing serial to parallel conversion when
used with the apropriate rotate instructions. This instruction can use
all memory alterable addressing modes.

Example:
	BTST	#$1,X:<<$FFEE	;read SSI serial input flag IF1 into C bit
	ROL		A				;rotate carry bit C into LSB of A1

	Before Execution:
		X:$FFEE = $000002
		SR      = $0300

	After Execution:
		X:$FFEE = $000002
		SR      = $0301

Explanation of Example:
	Prior to execution, the 24-bit X memory location X:$FFEE (I/O SSI
status register) contains the value $000002. The execution of the BTST
#$1,X:<<$FFEE instruction tests the state of the 1st bit (serial input
flag {IF1}) in X:$FFEE and sets the carry bit {C} accordingly. This
instruction sequence illustrates serial to parallel conversion using
the carry bit {C} and the 24-bit {A1} register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

CCR Condition Codes:
	{C}- Set if bit tested is set. Cleared otherwise
	{V}- Not Affected
	{Z}- Not Affected
	{N}- Not Affected
	{U}- Not Affected
	{E}- Not Affected
	{L}- Not Affected

{MR} Status bits are not affeted.

{SP}- Stack Pointer:
	For destination operand {SSH}: {SP} - Decrement by 1.
	For other destination operands: {SP} - Not affected.

Instruction format:
	BTST	#n,X:ea
	BTST	#n,Y:ea
	BTST	#n,X:aa
	BTST	#n,Y:aa
	BTST	#n,X:pp
	BTST	#n,Y:pp
	BTST	#n,D

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	D  = (	{X0},{X1},{Y0},{Y1},{A0},{B0},{A2},{B2},{A1},{B1},{A},{B},
			{Rn},{Nn},{Mn},{SR},{OMR},{SP},{SSH},{SSL},{LA},{LC})

Timing:		4 + mvb oscillator clock cycles

Memory:		1 + ea program words


{CLR}						Clear Accumulator

Operation:
	0 -> D				(parallel move)

Assembler Syntax:
	CLR	D				(parallel move)

Description:
	Clear the destination accumulator. This is a 56-bit clear instruction.

Example:
	CLR	A	#$7F,N0		;clear A, set up N0 addr. reg.

	Before Execution:
		A = $12:345678:9ABCDE

	After Execution:
		A = $00:000000:000000

Explanation of Example:
	Prior to execution, the 56-bit {A} accumulator contains the value
$12:345678:9ABCDE. The execution of the CLR A instruction clears the
56-bit A accumulator to zero.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data Limiting has occured during parallel move
	{E}- Always cleared
	{U}- Always set
	{N}- Always cleared
	{Z}- Always set
	{V}- Always cleared

Instruction Format:
	CLR	D

	D = ({A},{B})

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{CMP}						Compare

Operation:
	S2 - S1				(parallel move)

Assembler Syntax:
	CMP	S1,S2			(parallel move)

Description:
	Subtract the source one operand, S1, from the source two
accumulator, S2, and update the condition code register. The result of
the substraction operation isnot stored.

NOTE: This instruction substracts 56-bit operands. When a word is
specified as S1, it is sign extended and zero filled to form a valid
56-bit operand. For the carry to be set correctly as a result of the
substraction, S2 must be properly sign extended. S2 can be improperly
sign extended by writing A1 or B1 explicity prior to executing the
compare so that {A2} or {B2}, respectively, may not represent the correct
sign extension. This note particularly applies to the case where it is
extended to compare 24-bit operands such as X0 with A1.

Example:
	CMP	Y0,B	X0,X:(R6)+N6	Y1,Y:(R0)-	;comp. Y0 and B, save X0,Y1

	Before Execution:
		B  = $00:000020:000000
		Y0 = $000024
		SR = $0300

	After Execution:
		B  = $00:000020:000000
		Y0 = $000024
		SR = $0319

Explanation of Example:
	Prior to execution, the 56-bit {B} accumulator contains the value
$00:000020:000000 and the 24-bit {Y0} register contains the value
$000024. The execution of the CMP Y0,B instruction automatically
appends the 24-bit value in the Y0 register with 24 LS zeros, sign
extends the resulting 48-bit long word to 56 bits, substracts the
result from the 56-bit {B} accumulator and updates the condition code
register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of result is in use
	{U}- Set if result is unnormlized
	{N}- Set if bit 55 of result is set
	{Z}- Set if result equals zero
	{V}- Set if overflow has occured in result
	{C}- Set if a carry (or borrow) occurs from bit 55 of result

NOTE: The definition of the {E} and {U} bits varies according
to the scaling mode being used.

Instruction Format:
	CMP	S1,S2

	S1 = (A,B,X0,Y0,X1,Y1)
	S2 = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{CMPM}						Compare Magnitude

Operation:
	|S2| - |S1|			(parallel move)

Assembler Syntax:
	CMPM	S1,S2		(parallel move)

Description:
	Subtract the absolute value (magnitude) of the source  oneoperand,
S1, from the absolute value of the source two accumulator, S2, and
update the condition code register. The result of the substraction
operation is not stored.

NOTE: This instruction substracts 56-bit operands. When a word is
specified as S1, it is sign extended and zero filled to form a valid
56-bit operand. For the carry to be set correctly as a result of the
substraction, S2 must be properly sign extended. S2 can be improperly
sign extended by writing {A1} or {B1} explicitly prior to executing the
compare so that {A2} or {B2}, respectively, may not represent the correct
sign extension. This note particulary applies to the case where it is
extended to compare 24-bit operands such as {X0} witch {A1}.

Example:
	CMPM	X1,A	BA,L:-(R4)	;comp. X1 and A mag.,save B1 and A1

	Before Execution:
		A  = $00:000006:000000
		X1 = $FFFFF7
		SR = $0300

	After Execution:
		A  = $00:000006:000000
		X1 = $FFFFF7
		SR = $0319

Explanation of Example:
	Prior to execution, the 56-bit {A} accumulator contains the value
$00:000006:000000, and the 24-bit {X1} register contains the $FFFFF7.
The execution of the CMPM X1,A instruction automatically appends the
24-bit value in the {X1} register with 24 LS zeros, sign extends the
resulting 48-bit long word to 56 bits, takes the absolute value of
the resulting 56-bit number, substracts the result from the absolute
value of the contents of the 56-bit {A} accumulator, and updates the
condition code register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of result is in use
	{U}- Set if result is unnormlized
	{N}- Set if bit 55 of result is set
	{Z}- Set if result equals zero
	{V}- Set if overflow has occured in result
	{C}- Set if a carry (or borrow) occurs from bit 55 of result
	
NOTE: The definition of the {E} and {U} bits varies according
to the scaling mode being used.

Instruction Format:
	CMPM	S1,S2

	S1 = (A,B,X0,Y0,X1,Y1)
	S2 = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{DIV}						Divide Iteration

Operation:

	If	D[55] ^ S[23] = 1

			 55   47           23         0
			+----+------------+------------+
	then	|<---|<-----------|<-----------| <- C + S -> D
			+----+------------+------------+
				Destination Accumulator D

			 55   47           23         0
			+----+------------+------------+
	else	|<---|<-----------|<-----------| <- C - S -> D
			+----+------------+------------+
				Destination Accumulator D

	where ^ denotes the logical exclusive OR operator

Assembler Syntax:
	DIV	S,D

Description:
	Divide the destination operand D by the source operand S and store
the result in the destination accumulator D. The 48-bit dividend must
be a positive fraction which has been sign extended to 56-bits and is
stored in the full 56-bit destination accumulator D. The 24-bit divisor
is a signed fraction and is stored in the source operand S. Each DIV
iteration calculates one quotient bit using a nonrestoring fractional
division algorithm (see description). After the execution of the first
DIV instruction, the destination operand holds both the partial
remainder and the formed quotient. The partial remainder occupies the
high-order portion of the destination accumulator D and is a signed
fraction. The formed quotient occupies the low-oreder portion of the
destinatioin accumulator D ({A0} or {B0}) and is a positive fraction. One
bit of the formed quotient is shifted into the LS bit of the
destination accumulator at the start of each  DIV iteration. The
formed quotientis the true quotient if the true quotient is positive.
If the true quotient is negative, the formed quotient must be negated.
Valid result are obtained only when |D| < |S| and the operands are
interpreted as fractions. Note that this condition ensures that the
magnitude of the quotient is less than one (i.e., is fractional) and
precludes division by zero.

	The DIV instruction calculates one quotient bit based on the divisor
and the previous partial remainder. To produce an N-bit quotient, the
DIV instruction is executed N times where N is the number of bits of
precision desired in the quotient, 1 <= N <= 24. Thus, for a
full-precision (24-bit) quotient, 24 DIV iterations are required. In
general, executing the DIV instruction N times produces an N-bit
quotient and a 48-bit remainder which has (48-N) bits of precision
and whose N MS bits are zeros. The partial remainder is not a true
remainder and must be corrected due to the nonrestoring nature of the
division algorithm before it may be used. Therefore, once the divide
is complete, it is necessary to reverse the last DIV operation and
restore the remainder to obtain the true remainder.

	The DIV instruction uses a nonrestoring fractional division algorithm
which consists of the following operations (see the previous Operation
diagram):

1.	Compare the source and destination operand sign bits: An exclusive
	OR operation is performed on bit 55 of the destination operand D and
	bit 23 of the source operand S;

2.	Shift the partial remainder and the quotient: The 55-bit
	destination accumulator D is shifted one bit to the left. The carry
	bit C is moved into the LS bit (bit 0) of the accumulator;

3.	Calculate the next quotient bit and the new partial remainder:
	The 24-bit source operand S (signed divisor) is either added to or
	subtracted from the MSP portion of the destination accumulator
	(A1 or B1), and the result is stored back into the MSP portion of
	that destination accumulator. If the result of the exclusive OR
	operation was a '1' (i.e., the sign bits were different), the
	source operand S is added to the accumulator. If the result of the
	exclusive OR operation was a '0' (i.e., the sign bits were the
	same), the source operand S is subtracted from the accumulator. Due
	to the automatic sign extension of the 24-bit sign extension of
	the 24-bit signed divisor, the addition or subtraction operation
	correctly sets the carry bit C of the condition code register with
	the next quotient bit.

Example:
	(4-Quadrant division, 24-bit signed quotient, 48-bit signed remainder)
	ABS A	A,B				;make dividend positive, copy A1 to B1
	EOR	X0,B	B,X:$0		;save rem. sign in X:$0, quo. sign in N
	AND	#$FE,CCR			;clear carry bit C (quotient sign bit)
	REP	#$18				;form a 24-bit quotient
	DIV	X0,A				;form quotient in A0, remainder in A1
	TFR	A,B					;save quotient and remainder in B1,B0
	JPL	SAVEQUO				;go to SAVEQUO if quotient is positive
	NEG	B					;complement quotient if N bit set
SAVEQUO:
	TFR	X0,B	B0,X1		;save quo. in X1, get signed divisor
	ABS	B					;get absolute value of signed divisor
	ADD	A,B					;restore remainder in B1
	JCLR	#23,X:$0,DONE	;go to DONE if remainder is positive
	MOVE	#$0,B0			;clear LS 24 bits of B
	NEG	B					;complement remainder if negative
DONE:

	Before Execution:
		A  = $00:0E66D7:F2832C
		X0 = $123456
		X1 = $000000
		B  = $00:000000:000000

	After Execution:
		A  = $FF:EDCCAA:654321
		X0 = $123456
		X1 = $654321
		B  = $00:000100:654321

Explanation of Example:
	Prior to execution, 56-bit {A} accumulator contains the 56-bit,
signed-extended fractional dividend D (D=$00:0E66D7:F2832C =
0.112513535894635 approx.) and the 24-bit X0 register contains the
24-bit, signed fractional divisor S (S = $123456 = 0.142222166061401).
Since |D|<|S|, the execution of the previous divide routine stores the
correct 24-bit signed quotient in the 24-bit {X1} register (A/X0 =
0.79111111164093 = $654321 = X1). The partial remainder is restored by
reversing the last DIV operation and adding back the absolute value of
the signed divisor i {X0} remained in the 24-bit {B1} register. Note that
the remainder is really a 48-bit value which has 24 bits of precision.
Thus, the correct 48-bit remainder is $000000:000100 which equals
0.0000000000018190 approximately.

	Note that the divide routine used in the previous example assumes that
the sign-extended 56-bit signed fractional dividend is stored in the A
accumulator and that the 24-bit signed fractional dividend is stored in
the X0 register. This routine produces a ful 24-bit signed quotinet
and a 48-bit signed remainder.

	This routine may be greatly simplified for the case in which only
positive, fractional operands are used to produce a 24-bit positive
quotient and a 48-bit positive remainder, as shown in the following
example:

	1-Quadrant division, 24-bit unsigned quotient, 48-bit unsigned
	remainder

	AND	#$FE,CCR	;clear carry bit C (quotient sign bit)
	REP	#$18		;form a 24-bit quotint and remainder
	DIV	X0,A		;form quotient in A0, remainder in A1
	ADD	X0,A		;restore remainder in A1

	Note that this routine assumes that the 56-bit positive, fractional,
sign-extended dividend is stored in the A accumulator and that the
24-bit positive, fractional divisor is stored in the X0 register. After
execution, the 24-bit positive fractional quotient is stored in the A0
register; the LS 24 bits of the 48-bit positive fractional remainder
are stored in the A1 register.

	There are many variations possible when choosing a suitable division
routine for a given application. The selection of a suitable division
routine normally involves specification of the following items:
	1)	the number of bits precision in the dividend;
	2)	the number of bits of precision N in quotient;
	3)	whether the value of N is fixed or is variable;
	4)	whether the operands are unsigned or signed;
	5)	whether or not the remainder is to be calculated.

	For extended precision division (i.e., for N-bit quotients where N>24),
the DIV instruction is no longer applicable, and a user-defined N-bit
division routine is required.

Condition codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if overflow bit V is set
	{V}- Set if the MS bit of the destination operand is changed as a result
	   of the instruction's left shift operation
	{C}- Set if bit 55 of the result is cleared

Instruction Format:
	DIV	S,D

	S = ({X0},{Y0},{X1},{Y1})
	D = ({A},{B})

Timing:		2 oscillator clock cycles

Memory:		1 program word


{DO}						Start Hardware Loop

Operation:								Assembler Syntax:
	SP+1->SP;LA->SSH;LC->SSL;X:ea->LC		DO	X:ea,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	SP+1->SP;LA->SSH;LC->SSL;X:aa->LC		DO	X:aa,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	SP+1->SP;LA->SSH;LC->SSL;Y:ea->LC		DO	Y:ea,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	SP+1->SP;LA->SSH;LC->SSL;Y:aa->LC		DO	Y:aa,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	SP+1->SP;LA->SSH;LC->SSL;#xxx->LC		DO	#xxx,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	SP+1->SP;LA->SSH;LC->SSL;S->LC			DO	S,expr
	SP+1->SP;PC->SSH;SR->SSL;expr-1->LA
	1->LF

	End of Loop:
	SSL(LF)->SR;SP-1->SP
	SSH->LA;SSL->LC;SP-1->SP

Description:
	Begin a hardware Do loop that is to be repeated the number of times
specified in the instruction's source operand and whose range of
execution is terminated by the destination operand (previously shown as
"expr"). No overhead other than the execution of this DO instruction
is required to set up this loop. DO loops can be nested and the loop
count can be passed as a parameter.

	During the first instruction cycle, the current contents of the loop
address ({LA}) and the loop counter ({LC}) registers are pushed onto the
system stack. The DO instruction's source operand is then loaded into
the loop counter ({LC}) register. The {LC} register countains the remaining
number of times the DO loop will be executed and can be accessed from
inside the DO loop subject to certain restrictions. If {LC} equals zero,
the DO loop is executed 65536 times. All address register indirect
addressing modes may be used to generate the effective address of the
source operand. If immediate short data is specified, the 12 LS bits of
{LC} are loaded with the 12-bit immediate value, and the four MS bits of
{LC} are cleared.

	During the second instruction cycle, the current contents of the
program counter ({PC}) register and the status register ({SR}) are pushed
onto the system stack. The stacking of the {LA}, {LC}, {PC}, and {SR} registers
is the mechanisme which permits the nesting of DO loops. The DO
instruction's destination operand (shown as "expr") is then loaded into
the loop address ({LA}) register. The value in the program counter ({PC})
register pushed onto the system stack is the address of the first
instruction following the DO instruction (i.e., the first actual
instruction in the DO loop). This value is read (i.e., copied but not
pulled) fromthe top of the system stackto return to the top of the loop
for another pass through the loop.

	During the third instruction cycle, the loop flag ({LF}) is set. This
results in the {PC} being reapeatedly compared with {LA} to determine if
the last instruction in the loop has been fetched and the loop counter
({LC}) is tested. If {LC} not equal to one, it is decremented by one and
{SSH} is loaded into the {PC} to fetch the first instruction in the loop
again. If {LC} equals one, the "end-of-loop" processing begins.

	When executing a DO loop, the instructions are actually fetched each
time through the loop. Therefore, a DO loop can be interrupted. DO
loops can also be nested. When DO loops ar nested, the end-of-loop
addresses must also be nested and are not allowed to be equal. The
assembler generates an error message when DO loops are improperly
nested. Nested DO loops are illustratedin the example.

NOTE: The assembler calculates the end-of-loop address to be loaded
into LA (the absolute address extension word) by evaluating the
end-of-loop expression "expr" and subtracting one. This is done to
accommodate the case where the last word in the DO loop is a two word
instruction. Thus, the end-of-loop expression "expr" in the source code
must represent the address of the instruction AFTER the last
instruction in the loop as shown in example.

	During the "end-of-loop" processing, the loop flag ({LF}) from the lower
position ({SSL}) of {SP} is written into the status the status register
({SR}), the contents of the loop address ({LA}) are restored from the upper
portion ({SSH}) of ({SP}-1), the contents of the loop counter ({LC}) register
are restored from the lower portion ({SSL}) of ({SP}-1) and the stack
pointer ({SP}) is decremented by two. Instruction fetches now continue at
the address of the instruction following the last instruction in the DO
loop. Note that {LF} is the only bit in the {SR} that is restored after a
hardware DO loop has been exited.

NOTE: The {LF} is cleared by a hardware reset.

Restrictions:
	The "end-of-loop" comparison previously described actually occurs
at instruction fetch time. That is, {LA} is being compared with PC when
the instruction at {LA}-2 is being executed. Therefore, instructions
which acceses the program controller register and/or change program
flow canot be used in locations {LA}-2, {LA}-1, or {LA}.

	Proper DO loop operation is not guaranteed if an instruction starting
at address {LA}-2, {LA}-1, or {LA} specifies one of the program controller
registers {SR}, {SP}, {SSL}, {LA}, {LC}, or (implicitly) {PC} as a destination
register. Similary, the {SSH} program controller register may not be
specified as a source or destination register in an instruction
starting at address {LA}-2,{LA}-1, or {LA}. Additionally, the {SSH} register
cannot be specified as a source register in the DO instruction itself
and {LA} cannot be used as a target for jumps to subroutine (i.e., {JSR}
{JScc}, {JSSET}, or {JSCLR} to {LA}). A DO instruction cannot be repeated using
the {REP} instruction.

	The following instructions cannot begin at the indicated position(s)
near the end of a DO loop:

At LA-2, LA-1, and LA
	DO
	MOVEC from SSH
	MOVEM from SSH
	MOVEP from SSH
	MOVEC to LA, LC, SR, SP, SSH, or SSL
	MOVEM to LA, LC, SR, SP, SSH, or SSL
	MOVEP to LA, LC, SR, SP, SSH, or SSL
	ANDI MR
	ORI MR
	Two word instructions which read LC, SP, or SSL

At LA-1
	Single-word instructions (except {REP}) which read {LC}, {SP}, or {SSL},
	{JCLR}, {JSET}, two-word {JMP}, two word {Jcc}.

At LA
	any two-word instruction
	Jcc				REP
	JCLR			RESET
	JSET			RTI
	JMP				RTS
	JScc			STOP
	JSR				WAIT

Other Restrictions:
	DO	SSH,xxxx
	JSR to (LA) whenever the loop flag (LF) is set
	JScc to (LA) whenever the loop flag (LF) is set
	JSCLR to (LA) whenever the loop flag (LF) is set
	JSSET to (LA) whenever the loop flag (LF) is set

	A DO instruction cannot be repeated using the REP instruction.

NOTE: Due to pipelining, if an address register (Rn,Nn, or Mn) is
changed using a move-type instruction (LUA, Tcc, MOVE, MOVEC, MOVEM,
MOVEP, or parallel move), the new contents of the destination address
register will not be available for use during the folowing instruction
(i.e., there is a single instruction cycle pipeline delay). This
restriction also applies tothe situation in which the lat instruction
in a DO loop changes an address register and the first instruction at
the top of the DO loop uses that same address register. The top
instruction becomes the following instruction because of the loop
construct.

	Similary, since the DO instruction accesses the program controller
registers, the DO instrcuction must not be immediately preceded byany
of the following instructions:

Immediately before DO:
	MOVEC to LA, LC, SSH, SSL, or SP
	MOVEM to LA, LC, SSH, SSL, or SP
	MOVEP to LA, LC, SSH, SSL, or SP
	MOVEC from SSH
	MOVEM from SSH
	MOVEP from SSH

Example:
		DO	#cnt1,END1		;begin outer DO loop
		 :
		DO	#cnt2,END2		;begin inner DO loop
		 :
		 :
		MOVE	A,X:(R0)+	;last instruction in inner loop
		 :					;(in outer loop)
	END2:					;last instruction in outer loop
		ADD	A,B	X:(R1)+,X0	;first instruction after outer loop
	END1:

Explanation of Example:
	This example illustrates a nested DO loop. The outer DO loop will
be executed "cnt1" times while the inner DO loop wile be executed
("cnt1" * "cnt2") times. Note that the labels END1 and END2 are located
at the first instruction past the end of the DO loop, as mentioned
above, and are nested properly.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{LF}- Set when a DO loop is in progress
	{L} - Set if data limiting occurred

Instruction Format:
	DO	X:ea,expr
	DO	Y:ea,expr
	DO	X:aa,expr
	DO	Y:aa,expr
	DO	#xxx,expr
	DO	S,expr

	expr = 16-bit Absolute Adress

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	#xxx = 12-bit Immediate Short Data

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B
		 SR,OMR,SP,SSL,LA,LC,Rn,Nn,Mn)

NOTE 1:
Implementation Notes:

	For DO SP,expr	The actual value that will be load into the loop
counter (LC) is the value of the stack pointer (SP) before the
execution of the DO instruction, incremented by 1.

	Thus, if SP=3, the execution of the DO SP,expr instruction will
load the loop counter (LC) with the value LC = 4.

	For DO SSL,expr	The LC will be loaded with the previous value wich
was saved on the stack by the DO instruction itself.

NOTE 2: If A or B is specified as a source operand, the accumulator
value is optionally shifted according to the scaling mode bits in the
status register. If the data out of the shifter indicates that the
accumulator extension is in use, the 24-bit data is limited to a
maximum positive or negative saturation constant. The shifted and
limited value is loaded into LC, although A or B remain unchanged.

Timing:		6 + mv oscillator clock cycles

Memory:		2 program words


{ENDDO}					End Current DO Loop

Operation:
	SSL(LF)->SR;SP-1->SP
	SSH->LA;SSL->LC;SP-1->SP

Assembler Syntax:
	ENDDO

Description:
	Terminate the current hardware loop before the current loop
counter (LC) equals one. If the value of the current DO loop counter
(LC) is needed, it must be read before the execution of the ENDDO
instruction. Initially, the loop flag (LF) is restored from the system
stack and the remaining portion of the status register (SR) and the
Program counter are purged from the system stack. The LA and the LC
registers are then restored from the system stack.

Restrictions:
	Due to pipelining and the fact that the ENDDO instruction accesses
the program controller registers, the ENDDO instruction must not be
immediately preceded by any of the following instructions:

Immediately before ENDDO
	MOVEC to LA, LC, SR, SSH, SSL, or SP
	MOVEM to LA, LC, SR, SSH, SSL, or SP
	MOVEP to LA, LC, SR, SSH, SSL, or SP
	MOVEC from SSH
	MOVEM from SSH
	MOVEP from SSH
	ORI MR
	ANDI MR

	Also, the ENDDO instruction cannot be the next to last(LA-1) or last
(LA) instruction in a DO loop.

Example:
		DO	Y0,NEXT				;exec. loop ending at NEXT (Y0) times
		 :
		MOVEC	LC,A			;get current value of loop counter
		CMP		Y1,A			;compare LC with value in Y1
		JNE		ONWARD			;go to ONWARD ifLC not equal to Y1
		ENDDO					;LC equals to Y1, restore all DO registers
		JMP		NEXT			;go to NEXT
	ONWARD:						;LC not equal to Y1, continue DO loop
		 :						;(last instruction in DO loop)
	NEXT:
		MOVE	#$123456,X1		;(first instruction AFTER DO loop)

Explanation of Example:
	This example illustrate the use of the ENDDO instruction to
terminate the current DO loop. The value of the loop counter is
compared with the value in the Y1 register to determine if execution
of the DO loop should continue. Note that the ENDDO instruction
updates certain program controller registers but does not automatically
jump past the end of the DO loop. Thus, if this action is desired, a
JMP instruction (i.e., JMP NEXT as previously shown) must be included
after the ENDDO instruction to transfer program control to the first
instruction past the end of the DO loop.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	ENDDO

Timing:		2 oscillator clock cycles

Memory:		1 program word


{EOR}						Logical Exclusif OR

Operation:
	S ^ D[47:24]->D[47:24]	(parallel move)
	where ^ denotes the logical exclusive OR operator

Assembler Syntax:
	EOR	S,D				(parallel move)

Description:
	Logically exclusive OR the source operand S with bits 47-24 of the
destination operand D and store the result in bits 47-24 of the
destination accumulator. This instruction is 24-bit operation. The
remaining bits of the destination operand D are not affected.

Example:
	EOR	Y1,B	(R2)+		;Exclusive OR Y1 with B1, update R2

	Before Execution:
		Y1 = $000003
		B  = $00:000005:000000

	After Execution:
		Y1 = $000003
		B  = $00:000006:000000

Explanation of Example:
	Prior to execution, the 24-bit Y1 register contains the value
$000003, and the 56-bit B accumulator contains the value
$00:000005:000000. The EOR Y1,B instruction logically exclusive ORs
the 24-bit value in the Y1 register with bits 47-24 of the B
accumulator (B1) and stores the result in the B accumulator with bits
55-48 and 23-0 unchanged.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 of A or B result are zero
	{V}- Always cleared

Instruction Format:
	EOR	S,D

	S = (X0,X1,Y0,Y1)
	D = (A,B)

Timing:		2 + mv oscillator

Memory:		1 + mv program words


{ILLEGAL}					Illegal Instruction Interrupt

Operation:
	Begin Illegal Instruction exception processing

Assembler Syntax:
	ILLEGAL

Description:
	The {ILLEGAL} instruction is executed as if it were a NOP
instruction. Normal instruction execution is suspend and illegal
instruction exception processing is initiated. The interrupt vector
address is located at address P:$3E. The interrupt priority level
(I1,I0) is set to 3 in the status register if a long interrupt
service routine is used. The pupose of the ILLEGAL instruction is
to force the DSP into an illegal instruction exception for test
purposes. If a fast interrupt is used with the ILLEGAL instruction,
an infinite loop will be formed (an illegal instruction interupt
normally returns to the illegal instruction) which can only be broke
by a hardware reset. Therefore, only long interrupts should be used.
Exiting an illegal instruction is a fatal error. The long exception
routine should indicate this condition and cause the system to be
restarted.

	If the ILLEGAL instruction is in a DO loop at LA and the instruction
at LA-1 is being interrupted, then LC will be decremented twice due to
the same mechanism that causes LC to be decremented twice if {JSR}, {REP},
etc. at {LA} are restricted. Clearly restriction cannot be imposed on
illegal instructions.

	Since {REP} is uninterruptable, repeating an ILLEGAL instruction results
in interrupt not being initiated until after completion of the REP.
After servicing the interrupt, program control will return to the
address of the second word following the ILLEGAL instruction. Of
course, the ILLEGAL interrupt service routine should obort further
processing, and the processor should be reinitialized.

Example:
	ILLEGAL			;begin ILLEGAL exception processing

Explanation of Example:
	The ILLEGAL instruction suspends normal instruction execution and
initiates ILLEGAL exception processing.

Condition Codes:
	The condition codes are not affected by this instruction.

Timing:		8 oscillator clock cycles

Memory:		1 program word


{Jcc}						Jump Conditionally{JCC}{JCS}{JEC}{JEQ}{JES}{JGE}{JGT}{JLC}{JLE}{JLS}{JLT}{JMI}{JNE}{JNR}{JPL}{JNN}

Operation:						Assembler Syntax:
	If cc, then 0xxx -> PC			Jcc	xxx
	else PC+1 -> PC

	If cc, then ea -> PC			Jcc ea
	else PC+1 -> PC

Description:
	Jump to the location in program memory given by the instruction's
effective address if the specified if the specified condition is true.
If the specified condition is false, the program counter (PC) is
incremented and the effective address is ignored. However, the address
register specified in the effective address field is always updated
independently of the specified condition. All memory alterable
addressing modes may be used for effective address. A fast Short Jump
addressing mode may also be used. The 12-bit data is zero extended
toform the effectiveaddress. The term "cc" may specify the following
conditions:

	"cc" Mnemonic								Condition
	CC (HS) - carry clear (higher or same)		C = 0
	CS (LO) - carry set (lower)					C = 1
	EC		- extension clear					E = 0
	EQ		- equal								Z = 1
	ES		- extension set						E = 1
	GE		- greater than or equal				N^V = 0
	GT		- greater than						Z+(N^V) = 0
	LC		- limit clear						L = 0
	LE		- less than or equal				Z+(N^V) = 1
	LS		- limit set							L = 1
	LT		- less than							N^V = 1
	MI		- minus								N = 1
	NE		- not equal							Z = 0
	NR		- normalized						Z+(~U & ~E) = 1
	PL		- plus								N = 0
	NN		- not normalized					Z+(~U & ~E) = 0

	where
	~ denote the logical complement,
	+ denotes the logical OR operator,
	& denotes the logical AND operator, and
	^ denotes the logical Exclusive OR operator.

Restrictions:
	A Jcc instruction used within a {DO} loop cannot begin at the address
{LA} within that {DO} loop.

	A Jcc instruction cannot be repeated using the {REP} instruction.

Example:
	JNN	-(R4)		;jump to P:(R4)-1 if not normalized

Explanation of Example:
	In this example, program execution is transferred to the address
P:(R4)-1 if the result is not normalized. Note that the contents of
address register R4 are predecremented by 1, and the resulting address
is then loaded into the program counter if the specified condition is
true. If the specified condition is not true, no jump is taken, and the
program counter is incremented by one.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	Jcc	xxx
	Jcc	ea

	xxx = 12-bit Short Jump Adress

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		4 + jx oscillator clock cycles

Memory:		1 + ea program words


{JCLR}						Jump if Bit Clear

Operation:
	If S[n] = 0, then xxxx -> PC
	else PC+1 -> PC

Assembler Syntax:
	JCLR	#n,X:ea,xxxx
	JCLR	#n,X:aa,xxxx
	JCLR	#n,X:pp,xxxx
	JCLR	#n,Y:ea,xxxx
	JCLR	#n,Y:aa,xxxx
	JCLR	#n,Y:pp,xxxx
	JCLR	#n,S,xxxx

Description:
	Jump to the 16-bit absolute address in program memory specified in
the instruction's 24-bit extension word if the nth bit of the source
operand S is clear. The bit tested is selected by an immediate bit
number from 0-23. If the specified memory bit is not clear, the program
counter is incremented and the absolute address in the extension word
is ignored. However, the address register specified in the effective
address field is always updated independently ofthe state of the nth
bit. All address register indirect addressing modes may be used to
reference the source operand S. Absolute Short and I/O Short addressing
modes may also be used.

Restrictions:
	A JCLR instruction cannot be repeated using the {REP} instruction.

	A JCLR located at {LA}, LA-1, or LA-2 of the {DO} loop cannot specify the
program controller registers SR, SP, SSH, SSL, LA, or LC as its target.

	JCLR SSH or JCLR SSL cannot follow an instruction that changes the {SP}.

Example:
	JCLR	#$5,X:<<$FFF1,$1234	;go to P:$1234 if bit 5 in SCI SSR is clear

Explanation of Example:
	In this example, program execution is transferred to the address
P:$1234 if bit 5 (PE) of the 8-bit read-only X memory location X:$FFF1
(I/O SCI interface status register) is a zero. If the specified bit
is not clear, no jump is taken, and the PC is incremented by one.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JCLR	#n,X:ea,xxxx
	JCLR	#n,Y:ea,xxxx
	JCLR	#n,X:aa,xxxx
	JCLR	#n,Y:aa,xxxx
	JCLR	#n,X:pp,xxxx
	JCLR	#n,Y:pp,xxxx
	JCLR	#n,S,xxxx

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	S  = (	X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,
			Rn,Nn,Mn,SR,OMR,SP,SSH,SSL,LA,LC)

Timing:		6 + jx oscillator

Memory:		2 program words


{JMP}						Jump

Operation:				Assembler Syntax:
	0xxx -> PC				JMP	xxx
	ea -> PC				JMP ea

Description:
	Jump to the location in program memory given by the instruction's
effective address. All memory alterable addressing modes may be used
for effective address. A Fast Short Jump addressing modes may also be
used. The 12-bit data is zero extended to form the efective address.

Restriction:
	A JMP instruction used within a DO loop cannot begin at the Address
LA within that DO loop.

	A JMP instruction cannot be repeated using the REP instruction.

Example:
	JMP	(R1 + N1)	;jump to program address P:(R1 + N1)

Explanation of Example:
	In this example, program execution is transferred to theprogram
address P:(R1 + N1).

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JMP	xxx
	JMP	ea

	xxx = 12-bit Short Jump Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		4 + jx oscillator clock cycles

Memory:		1 + ea program words


{JScc}						Jump to Subroutine Conditionally{JSCC}{JSCS}{JSEC}{JSEQ}{JSES}{JSGE}{JSGT}{JSLC}{JSLE}{JSLS}{JSLT}{JSMI}{JSNE}{JSNR}{JSPL}{JSNN}

Operation:											Assembler Syntax:
	If cc, then SP+1->SP;PC->SSH;SR->SSL;0xxx->PC		JScc	xxx
		else PC+1->PC

	If cc, then SP+1->SP;PC->SSH;SR->SSL;ea->PC			JScc	ea
		else PC+1->PC

Description:
	Jump to subroutine whose location in program memory is given by
the instruction's effective address if the specified condition is true.
If the specified condition is true, the address of the instruction
immediately following the JScc instruction (PC) and SR are pushed onto
the system stack. Program execution then continues at the specified
effective address in program memory. If the specified condition is
false, the PC is incremented, and any extension word is ignored.
However, the address register specified in the effective address field
is always updated independently of the specified condition. All memory
alterable addressing mods may be used for the effective address. A
fast short jump addressing mode may also be used? The 12-bit data
is zero extended to form the effective address. The term "cc" may
specify the following condition:

	"cc" Mnemonic								Condition
	CC (HS) - carry clear (higher or same)		C = 0
	CS (LO) - carry set (lower)					C = 1
	EC		- extension clear					E = 0
	EQ		- equal								Z = 1
	ES		- extension set						E = 1
	GE		- greater than or equal				N^V = 0
	GT		- greater than						Z+(N^V) = 0
	LC		- limit clear						L = 0
	LE		- less than or equal				Z+(N^V) = 1
	LS		- limit set							L = 1
	LT		- less than							N^V = 1
	MI		- minus								N = 1
	NE		- not equal							Z = 0
	NR		- normalized						Z+(~U & ~E) = 1
	PL		- plus								N = 0
	NN		- not normalized					Z+(~U & ~E) = 0

	where
	~ denote the logical complement,
	+ denotes the logical OR operator,
	& denotes the logical AND operator, and
	^ denotes the logical Exclusive OR operator.

Restrictions:
	A JScc instruction used within a DO loop cannot specify the loop
address (LA) as its target.

	A JScc instruction used within in a DO loop cannot begin at the address
LA within that DO loop.

	A JScc instruction cannot be repeated using the REP instruction.

Example:
	JSLS	(R3+N3)	;jump to subroutine at P:(R3+N3) if limit set (L=1)

Explanation of Example:
	In this example, program execution is transfered tothe subroutine
at address P:(R3+N3) in program memory if the limit bit is set (L=1).
Both the return address (PC) and SR are pushed onto the system stack
prior to transferring program control to the subroutine if the
specified condition is not true, no jump is taken and the PC is
incremented by 1.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JScc	xxx
	JScc	ea

	xxx = 12-bit Short Jump Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		4 + jx oscillator clock cycles

Memory:		1 + ea program words


{JSCLR}					Jump to Subroutine if Bit Clear

Operation:
	If S[n]=0,
	then SP+1->SP;PC->SSH;SR->SSL;xxxx->PC
	else PC+1->PC

Assembler Syntax:
	JSCLR	#n,X:ea,xxxx
	JSCLR	#n,X:aa,xxxx
	JSCLR	#n,X:pp,xxxx
	JSCLR	#n,Y:ea,xxxx
	JSCLR	#n,Y:aa,xxxx
	JSCLR	#n,Y:pp,xxxx
	JSCLR	#n,S,xxxx

Description:
	Jump to subroutine at the 16-bit absolute address in program memory
specified in the instruction's 24-bit extension word if the nth bit of
the source operand S is clear. The bit to be tested is selected by an
immediate bit number from 0-23. if the nth bit of the source operand S
is clear, the address of the instruction immediately following the
JSCLR instruction (PC) and the SR are pushed onto the system stack.
Program  execution then contintinues at the specified absolute address
in the instruction's 24-bit extension word. If the specified memory bit
is not clear, the PC is incremented and the extension word is ignored.
However, the adress register specified in the effective address field
is always updated independently of the state of the nth bit. All
address register indirect addressing modes may be used to reference the
source operand S. Absolute short and I/O short adressing modes may also
be used.

Restrictions:
	A JSCLR instruction used within a DO lopp cannot specify the loop
address (LA) as its target.

	A JSCLR located at LA, LA-1, or LA-2 of a DO loop, cannot specify the
program controller registers SR, SP, SSH, SSL, LA, or LC as its target.

	JSCLR SSH or JSCLR SSL  cannot follow an instruction that changes the
SP.

	A JSCLR instrcuction cannot be repeated using the REP instruction.

Example:
	JSCLR	#$1,Y:<<$FFE3,$1357		; go sub. at P:$1357 if bit 1 in
									; Y:$FFE3 is clear

Explanation of Example:
	In this example, program execution is transferred to the subroutine
at absolute address P:$1357 in program memory if bit 1 of the external
I/O location Y:<<$FFE3 is a zero. If the specified bit is not clear, no
jump is taken and the PC is incremented by 1.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JSCLR	#n,X:ea,xxxx
	JSCLR	#n,X:aa,xxxx
	JSCLR	#n,X:pp,xxxx
	JSCLR	#n,Y:ea,xxxx
	JSCLR	#n,Y:aa,xxxx
	JSCLR	#n,Y:pp,xxxx
	JSCLR	#n,S,xxxx

	xxxx = 16-bit Absolute Address

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	S  = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,
			Rn,Nn,Mn,SR,OMR,SP,SSH,SSL,LA,LC)

Timing:		6 + jx oscillator clock cycles

Memory:		2 program words


{JSET}						Jump if Bit Set

Operation:
	If S[n] = 1, then xxxx->PC
	else PC+1->PC

Assembler Syntax:
	JSET	#n,X:ea,xxxx
	JSET	#n,X:aa,xxxx
	JSET	#n,X:pp,xxxx
	JSET	#n,Y:ea,xxxx
	JSET	#n,Y:aa,xxxx
	JSET	#n,Y:pp,xxxx
	JSET	#n,S,xxxx

Description:
	Jump to the 16-bit absolute address in program memory specified in
the instruction's 24-bit extension word if the nth bit of the source
operand S is set. The bitto be tested is selected by an immediate bit
number from 0-23. If the specified memory bitis not set, the PC is
incremented, and the absolute address in the extension word is ignored.
However, the address register specified in the effective address field
is always updated independently of the state of the nth bit. All
address register indirect addressing modes may be used to reference the
source operand S. Absolute short I/O addressing modes may also be used.

Restrictions:
	A JSET instruction used within a DO loop cannot specify the loop address
(LA) as its target.

	A JSET located at LA, LA-1, or LA-2 of a DO loop cannot specify the
program controller registers SR, SP, SSH, SSL, LA, or LC as its target.

	JSET SSH or JSET SSL cannot follow an instruction that changes the SP.

	A JSET instruction cannot be repeated using the REP instruction.

Example:
	JSET	#12,X:<<$FFF2,$4321	;$4321 -> (PC) if bit 12 (SCI COD) is set

Explanation of Example:
	In this example, pogram execution is transfered to the address
P:$4321 if bit 12 (SCI COD) of the 16-bit read/write I/O register
X:$FFF2 is a one. If the specified bit is not set, no jump is taken and
the program counter (PC) is incremented by 1.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JSET	#n,X:ea,xxxx
	JSET	#n,X:aa,xxxx
	JSET	#n,X:pp,xxxx
	JSET	#n,Y:ea,xxxx
	JSET	#n,Y:aa,xxxx
	JSET	#n,Y:pp,xxxx
	JSET	#n,S,xxxx

	xxxx = 16-bit Absolute Address

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	S  = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,
			Rn,Nn,Mn,SR,OMR,SP,SSH,SSL,LA,LC)

Timing:		6 + jx oscillator clock cycles

Memory:		2 program words


{JSR}						Jump to Subroutine

Operation:								Assembler Syntax:
	SP+1->SP;PC->SSH;SR->SSL;0xxx->PC		JSR	xxx

	SP+1->SP;PC->SSH;SR->SSL;ea->PC			JSR	ea

Description:
	Jump to the subroutine whose location in program memory is given by
the instruction's effective address. The address of the instruction
immediately following the JSR instruction (PC) and the SR is pushed
onto the system stack. Program execution then continues at the
specified effective address in program memory. All memory alterable
addressing modes may be used for the effective address. A fast short
jump addressing mode may also be used. the 12-bit data iszero extended
to form the effective address.

Restrictions:
	A JSR instruction used within a DO loop cannot specify the loop address
(LA) as its target.

	A JSR instruction used within a DO loop cannot begin at the address LA
within that DO loop.

	A JSR instruction cannot be repeated using the REP instruction.

Example:
	JSR	(R5)+	;jump to subroutine at (R5), update R5

Explanation of Example:
	In this example, program execution is transferred to the subroutine
at address P:(R5) in program memory, and the contents of the R5 address
register are then updated.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	JSR	xxx
	JSR ea

	xxx = 12-bit Short Jump Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		4 + jx oscillator clock cycles

Memory:		1 + ea program words


{JSSET}					Jump to Subroutine if Bit Set

Operation:
	If S[n] = 1,
	then SP+1->SP;PC->SSH;SR->SSL;xxxx->PC
	else PC+1->PC

Assembler Syntax:
	JSSET	#n,X:ea,xxxx
	JSSET	#n,X:aa,xxxx
	JSSET	#n,X:pp,xxxx
	JSSET	#n,Y:ea,xxxx
	JSSET	#n,Y:aa,xxxx
	JSSET	#n,Y:pp,xxxx
	JSSET	#n,S,xxxx

Description:
	Jump to the subroutine at the 16-bit absolute address in program
memory specified in the instruction's 24-bit extension word if the
nth bit of the source operand S is set. The bit to be tested is
selected by an immediate bit number from 0-23. If the nth bit of the
source operand S is set, the address of the instruction immediately
following the JSSET instruction (PC) and the SR are pushed onto the
system stack. Program execution then continues at the specified
absolute absolute address in the instruction's 24-bit extension word.
If the specified memory bit is not set, the PC is incremented, and
the extension word is ignored. However, the address register specified
in the effective address field is always updated independently of the
state of the nth bit. All address register indirect addressing modes
may be used to reference the source operand S. Absolute short and I/O
short addressing modes may also be used.

Restrictions:
	A JSSET instruction used within a DO loop cannot specify the loop
address (LA) as its target.

	A JSSET located at LA, LA-1, or LA-2 ofa DO loop, cannot specify the
program controller registers SR, SP, SSH, SSL, LA, or LC as its target.

	JSSET SSH or JSSET SSL cannot follow an instruction that changes the
SP.

	A JSSET instruction cannot be repeated using the REP instruction.

Example:
	JSSET #$17,Y:<$3F,$100	;go to sub. at P:$0100 if bit 23 in Y:$3F
							is set

Explanation of Example:
	In this example, program execution is transferred to the subroutine
at absolute address P:$0100 in program memory if bit 23 of Y memory
location Y:$003F is a one. If the specified bit is not set, no jump is
taken and the PC is incremented by 1.

Condition Codes:
	The condition codes are notaffected by this instruction.

Instruction Format:
	JSSET	#n,X:ea,xxxx
	JSSET	#n,X:aa,xxxx
	JSSET	#n,X:pp,xxxx
	JSSET	#n,Y:ea,xxxx
	JSSET	#n,Y:aa,xxxx
	JSSET	#n,Y:pp,xxxx
	JSSET	#n,S,xxxx


	xxxx = 16-bit Absolute Address

	#n = bit number

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	pp = 6-bit I/O Short Address

	S  = ( X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,
			Rn,Nn,Mn,SR,OMR,SP,SSH,SSL,LA,LC)

Timing:		6 + jx oscillator clock cycles

Memory:		2 program words


{LSL}						Logical Shift Left

Operation:

			 47        24
			+------------+
		C <-|<-----------|<- 0 (parallel move)
		    +------------+

Assembler Syntax:
	LSL	D				(parallel move)

Description:
	Logical shifts bits 47-24 of the destination operand D one bit to
the left and store the result in the destination accumulator. Prior to
instruction execution, bit 47 of D is shifted into the carry bit C,
and zero is shifted into bit 24 of the destination accumulator D. This
instruction is a 24-bit operation. The remainig bits of the
destination operand E are not affected. If zero shift count is
specified, the carry bit is cleared. The difference between LSL and ASL
is that LSL operates on only A1 or B1 and always clears the V bit.

Example:
	LSL	B	#$7F,R0		;shift B1 one bit to the left, set up R0

	Before execution:
		B  = $00:F01234:13579B
		SR = $0300

	After execution:
		B  = $00:E02468:13579B
		SR = $0309
	
Explanation of Example:
	Prior to execution, the 56-bit B accumulator contains the value
$00:F01234:13579B. The execution of the LSL B instruction shifts the
24-bit value in the B1 register one bit to the left and stores the
result back in the B1 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 of A or B result are zero
	{V}- Always cleared
	{C}- Set if bit 47 of A or B was set prior to instruction execution

Instruction Format:
	LSL	D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{LSR}						Logical Shift Right

Operation:

			 47        24
			+------------+
		0 ->|----------->|-> C (parallel move)
		    +------------+

Assembler Syntax:
	LSR	D				(parallel move)

Description:
	Logically shifts bits 47-24 of the destination operand D one bit to
the right and store the result in the destination accumulator. Prior to
instruction execution, bit 24 of D is shifted into the carry bit C, and
zero is shifted into bit 47 of the destination accumulator D. This
instruction is a 24-bit operation. The remaining bits of the
destination operand D are not affected.

Example:
	LSR	A	A1,N4		;shift A1 one bit to the right, set up N4

	Before execution:
		A  = $37:444445:828180
		SR = $0300

	After execution:
		A  = $37:222222:828180
		SR = $0301

Explanation of Example:
	Prior to execution, the 56-bit A accumulator countains the value
$37:444445:828180. The execution of the LSR A instruction shifts the
24-bit value in the A1 register one bit tothe right and stores the
result back in the A1 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Always cleared
	{Z}- Set if bits 47-24 of A or B result are zero
	{V}- Always cleared
	{C}- Set if bit 24 of A or B was set prior to instruction execution

Instruction Format:
	LSR D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{LUA}						Load Update Address

Operation:
	ea -> D

Assembler Syntax:
	LUA	ea,D

Description:
	Load the updated address into the destination address register D.
The source address register and the update mode used to compute the
updated address are specified by the effective address (ea). Note that
the source address register specified in the effective address is not
updated. All update addressing modes may be used.

NOTE: This instruction is considered to be a move-type instruction.
Due to pipelining, the new contents of the destination address register
(Rn or Nn) will not be available for use during the following
instruction (i.e., there is a single instruction cycle pipeline delay).

Example
	LUA	(R0)+N0,R1		;update R1 using (R0)+N0

	Before Execution:
		R0 = $0003
		N0 = $0005
		R1 = $0004

	After Execution:
		R0 = $0003
		N0 = $0005
		R1 = $0008

Explanation of Example:
	Prior to execution, the 16-bit address register R0 contains the
value $0003, the 16-bit address register N0 contains the value $0005,
and the 16-bit address register R1 contains the value $0004. The
execution of the LUA (R0)+N0,R1 instruction adds the contents of the R0
register to the contents of the N0 register and stores the resulting
updated address in R1. The contents of both the R0 and N0 address
registers are not affected.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	LUA	ea,D

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+

	D  = (Rn,Nn)

Timing:		4 oscillator clock cycles

Memory:		1 program word


{MAC}						Signed Multiply-Accumulate

Operation:
	D+-S1*S2 -> D		(parallel move)

Assembler Syntax:
	MAC	(+-)S1,S2,D		(parallel move)

Description:
	Multiply the two signed 24-bit source operands S1 and S2 and
add/subtract the product to/from the specified 56-bit destination
accumulator D. The "-" sign option is used to negate the specified
product prior to accumulation. The default sign option is "+".

Example:
	MAC	X0,X0,A	X:(R2)+N2,Y1	;square X0 and store in A, update Y1 and R2

	Before Execution:
		X0 = $123456
		A  = $00:100000:000000

	After Execution:
		X0 = $123456
		A  = $00:1296CD:9619C8

Explanation of Example:
	Prior to execution, the 24-bit X0 register contains the value of
$123456 (0.142222166), and the 56-bit A accumulator contains the value
$00:100000:000000 (0.125). The execution of the MAC X0,X0,A instruction
square the 24-bit signed value in the X0 regsiter and adds the
resulting 48-bit product to the 56-bit A accumulator (X0*X0+A =
0.145227144519197 approximatively = $00:1296CD:9619C8 = A).

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormlized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result

NOTE: The definition of the E and U bits varies according
to the scaling mode being used.

Instruction Format:
	MAC	(+-)S1,S2,D

	S1 = (X0,Y0,X1,Y1)
	S2 = (X0,Y0,X1,Y1)
	D  = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{MACR}						Signed Multiply-Accumulate and Round

Operation:
	D+-S1*S2+r -> D		(parallel move)

Assembler Syntax:
	MACR	(+-)S1,S2,D	(parallel move)

Description:
	Multiply the two signed 24-bit source operands S1 and S2,
add/subtract the product to/from the specified 56-bit destination
accumulator D, and then round the result using convergent rounding.
The rounded result is stored in the destination accumulator D. The "-"
sign option is used to negate the specified product prior to
accumulation. The default sign option is "+". The contribution of the
LS bits of the result is rounded into the upper portion of the
destination accumulator (A1 or B1) by adding a constant to the LS bits
of the lower portion of the accumulator (A0 or B0). The value of the
constant added is determined by the scaling mode bits S0 and S1 in the
RS. Once rounding has been completed, the LS bits of the destination
accumulator D (A0 orB0) are loaded with zeros to maintain an unbiased
accumulator value which may be refused by next instruction. The upper
portion of the accumulator (A1 or B1) contains the rounded result
which may be read out to the data buses. Refer to the RND instruction
for more complete information on the convergent rounding process.

Example:
	MACR X0,Y0,B	B,X0 Y:(R4)+N4,Y0	;X0*Y0+B->B, rnd B, update X0,Y0,R4

	Before Execution:
		X0 = $123456
		Y0 = $123456
		B  = $00:100000:000000

	After Execution:
		X0 = $100000
		Y0 = $987654
		B  = $00:1296CE:000000

Explanation of Example:
	Prior to execution, the 24-bit X0 register contains the value
$123456 (0.142222166), the 24-bit Y0 regsiter contains the value
$123456 (0.142222166), and the 56-bit accumulator contains the value
$00:100000:000000 (0.125). The execution of the MACR X0,Y0,B
instruction multiples the 24-bit signed value in the X0 register
by the 24-bit signed value in the Y0 register, adds the resulting
product to the 56-bit B accumulator, rounds the result into the B1
portion of the accumulator, and then zeros the B0 portion of the
accumulator (X0*Y0+B = 0.145227144519197 approximately =
$00:1296CD:9619C8, which is rounded to the value $00:1296CE:000000 =
0.145227193832397 = B).

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormlized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result

NOTE: The definition of the E and U bits varies according
to the scaling mode being used.

Instruction Format:
	MACR	(+-)S1,S2,D

	S1 = (X0,Y0,X1,Y1)
	S2 = (X0,Y0,X1,Y1)
	D  = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{MOVE}						Move Data

Operation:
	S->D

Assembler Syntax:
	MOVE	S,D

Description:
	Move the contents of the specified data source S to the specified
destination D. This instruction is equivalent to a data ALU NOP with a
parallel data move.

	When a 56-bit accumulator (A or B) is specified as a source operand S,
the accumulator value is optionally shifted according to the scaling
mode bits S0 and S1 in the SR. If the data out of the shifter indicates
that the accumulator extension register is in use and the data is to be
moved into a 24 or 48-bit destination, the value stored in the
destination D is limited to a maximum positive or negative saturation
constant to minimize truncation error. Limiting does not occurif an
individual 24-bit accumulator register (A1,A0,B1, or B0) is specified
as a source operand instead of the full 56-bit accumulator (A or B).
This limiting features allows block floating-point operations to be
performed with error detection since the L bit in the condition code
register is latched.

	When a 56-bit accumulator (A orB) is specified as a destination operand
D, any 24-bit source data to be moved into that accumulator is
automatically extended to 56-bits by sign extending the MS bit o the
source operand (bit23) and appending the source operand with 24 LS
zeros. Similary, any 48-bit source data to be load into a 56-bit
accumulator isautomatically sign extended to 56 bits. Note that for
24-bit source operands both the automatic sign-extension and zeroing
features may be disabled by specifying the destination register to be
one of the individual 24-bit accumulator registers (A1 orB1). Similary,
for 48-bit source operands, the automatic sign-extension feature may be
disabled by using the long memory move addressing mode specifying A10
or B10 as the destination operand.

Example:
	MOVE	X0,A1	;move X0 to A1 without sign ext. or zeroing

	Before Execution:
		X0 = $234567
		A  = $FF:FFFFFF:FFFFFF

	After Execution:
		X0 = $234567
		A  = $FF:234567:FFFFFF

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$FF:FFFFFF:FFFFFF, and the 24-bit X0 register contains the value
$234567. The execution of the MOVE X0,A1 instruction moves the 24-bit
value in the X0 register into the  24-bit A1 register without automatic
sign extension and without automatic zeroing.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

Parallel Move Descriptions:
	Thirty of the sixty-two instructions provide the capability	to
specify an optional parallel data bus movement over the X and/or Y data
bus. This allows a data ALU operation to be executed in parallel with
up to two data bus moves during the instruction cycle. Ten types of
parallel moves are permitted, including register to register moves,
register to memory moves, and memory to register moves. However, not
all addressing modes are allowed for each type of memory reference.
Addressing mode restrictions which apply to specific types of moves are
noted in the individual move operation descriptions. The following
section contains detailed descriptions about each type of parallel
move operation.

	When a 56-bit accumulator (A or B) is specified as a source operand S,
the accumulator value is optionally shifted according to the scaling
mode bits S0 and S1 in the system status register (SR). If the data
out of the shifter indicates that the accumulator extension register is
in use and the data is to be moved into a 24- or 48-bit destination,
the value stored in the destination D is limited to a maximum positive
or negative saturation constant to minimize truncation error. Limiting
does not occur if an individual 24-bit accumulator register (A1,A0,B1,
or B0) isspecified as a source operand instead of a full 56-bit
accumulator (A or B). This limiting feature allows block floting-point
operations to be performed with error detection since the L bit in the
condition code register is latched.

	When a 56-bit accumulator (A or B) is specified as a destination
operand D, any 24-bit source data to be moved into that accumulator is
automatically extended to 56 bits by sign extending the MS bit of the
source operand (bit 23) and appending the source operand with 24 LS 
zeros. Similary, any 48-bit source data to be loaded into a 56-bit 
accumulator is automatically sign extended to 56 bits. Note that for 
24-bit source operands both the automatic sign-extension and zeroing
features may be disabled by specifying the destination register to be
one of the individual 24-bit accumulator registers (A1 or B1).
Similary, for 48-bit source operands, the automatic sign-extension
feature may be disabled by using the long memory move addressing mode
and specifying A10 or B10 as the destination operand.

	Note that the symbols used in decoding the various opcode fields of an
instruction or parallel move are completely arbitrary. Furthermore,
the opcode symbols used in one instruction or parallel move are
completely independent of the opcode symbols used in a different
instruction or parallel move.

Timing:		2 + mv oscillator cycles

Memory:		1 + mv program words


{I}						Immediate Short Data Move

Operation:
	(.....),#xx->D

Assembler Syntax:
	(.....)	#xx,D

Description:
	Move the 8-bit immediate data value (#xx) into the destination
operand D.

	If the destination register D is A0, A1, A2, B0, B1, B2, Rn, or Nn, the
8-bit immediate short operand is interpreted as an unsigned integer
and is stored in the specified destination regsiter. That is, the
8-bit data is stored in the eight LS bit of the destination operand,
and the remaining bits of the destination operand D are zeroed.

	If the destination register D is X0, X1, Y0, Y1, A, or B, the 8-bit
immediate short operand is interpreted as a signed fraction and is
stored in the specified destination register. That is, the 8-bit data
is stored in the eight MS bits of the destination operand, and the
remaining bits of the destination operand D are zeroed.

	If the arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destination D in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data move portion of the instruction may not
specify A0, A1, A2, or A as its destination D. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as tis destination, the parallel data bus move portion of
the instruction may not specify B0, B1, B2, or B as its destination D.
That is, duplicate destinations are NOT allowed within the same
instruction.

NOTE: This parallel data move is considered to be a move-type
instruction. Due to pipelining, if an address register (R or N) is
changed using a move-type instruction, the new contents of the
destination address register will not be available for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay.

Example:
	ABS	B	#$18,R1	;take the absolute value of B, #$18->R1

	Before Execution:
		R1 = $0000

	After Execution:
		R1 = $0018

Explanation of Example:
	Prior to execution, the 16-bit address register R1 contains the
value $0000. The execution of the parallel move portion of the
instruction, #$18,R1, moves the 8-bit immediate short operand into
eight LS bits of the R1 register and zeros the remaining eight MS bits
of that register. The 8-bit value is intrepeted as an unsigned integer
since its destination is R1 address register.

Condition Codes:
	The condition codes are not affected by this type of parallel move.

Instruction Format:
	(.....)	#xx,D

	#xx = 8-bit Immediate Short Data

	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{R}						Register to Register Data Move

Operation:
	(.....);S->D

Assembler Syntax:
	(.....)	S,D

Description:
	Move the source register S to the destination register D.

	If the arithmetic or logical opcode_operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destination D in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction
may not specify A0, A1, A2, or A as its destination D. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify B0,B1,B2, or B as its destination D.
That is, duplicate destination are NOT allowed within the same
instruction.

	If the opcode-operand portion of the instruction specifies a given
source or destination register, that same register or portion of that
register may be used as a source S in the parallel data bus move
operation. This allows data to be moved in the same instruction in
which it is being used as a source operand by a data ALU operation.
That is, duplicate sources are allowed within the same instruction.

	When a 24-bit source operand is moved into a 16-bit destination
register, the 16 LS bits of the 24-bit source operand are stored in
16-bit destination register. When a 16-bit source operand is moved into
a 24-bit destination register, the 16 LS bits of the destination
register are loaded with the contents of the 16-bit source operand,
and the eight MS bits of the 24-bit destination register are zeroed.

NOTE: The MOVE A,B operation will result in a 24-bit positive or
negative saturation constant being stored in the B1 portion of the B
accumulator if the signed integer portion of the A accumulator is in
use.

NOTE: This parallel data move is considered to be a move-type
instruction. Due to pipelining, if an address register (R or N) is
changed using a move-type instruction, the new contents of the
destination address register will not be available for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Example:
	MACR	-X0,Y0,A	Y1,N5	;-X0*Y0+A->A, move Y1->N5

	Before execution:
		Y1 = $001234
		N5 = $0000

	After execution:
		Y1 = $001234
		N5 = $1234

Explanation of Example:
	Prior to execution, the 24-bit Y1 register contains the value
$001234 and the 16-bit address offset register N5 contains the value
$0000. The execution of the parallel move portion of the instruction,
Y1,N5, moves the 16 LS bits of the 24-bit value in the Y1 register into
the 16-bit N5 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

Instruction Format:
	(.....) S,D

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)
	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{U}						Address Register Update

Operation:
	(.....); ea->Rn

Assembler Syntax:
	(.....) ea

Description:
	Update the specified address register according to the specified
effective addressing mode. All update addressing modes may be used.

Example:
	RND	B	(R3)+N3		;round value in N into B1,R3+N3->R3

	Before Execution:
		R3 = $0007
		N3 = $0004

	After Execution:
		R3 = $000B
		N3 = $0004

Explanation of Example:
	Prior to execution, the 16-bit address register R3 contains the
value $0007, and the 16-bit address offset register N3 contains the
value $0004. The execution of the paralle move portion of the
instruction, (R3)+N3, updates the R3 address register according to the
specified effective addressing mode by adding the value in the R3
register to the value in the N3 register and storing the 16-bit result
back in the R3 address register.

Condition Codes:
	The condition codes are not affected by this type of parallel move.

Instruction Format:
	(.....) ea

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+

Timing:		mv oscillator clock cycles

Memory:		mv program words


{X:}						X Memory Data Move

Operation:						Assembler Syntax:
	(.....); X:ea->D				(.....)	X:ea,D
	(.....); X:aa->D				(.....)	X:aa,D
	(.....); S->X:ea				(.....)	S,X:ea
	(.....); S->X:aa				(.....)	S,X:aa
	(.....); #xxxxxx->D				(.....)	#xxxxxx,D

Description:
	Move the specified word operand from/to X memory. All memory
addressing modes, including absolute addressing and 24-bit immediate
data, may be used. Absolute short addressing may also be used.

	If the arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may notbe specified as destination D in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction may
not specify A0,A1,A2, or A as its destination D. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify B0,B1,B2, or B as its destination D.
That is, duplicate destinations are NOT allowed within the same
instruction.

	If the opcode-operand portion of the instruction specifies a given
source or destination register, that same register or portion of that
register may be used as a source S in the parallel data bus move
operation. This allows data to be moved in the same instruction in
which it is being used as a source operand by data ALU operation.
That is, duplicate sources are allowed within the same instruction.

	When a 24-bit source operand is moved ino a 16-bit destination
register, the 16 LS bits of the 24-bit source operand are stored in
the 16-bit destination register. When a 16-bit source operand is moved
into a 24-bit destination register, the 16LS bits of the destination
register are loaded with the contents of the 16-bit source operand,
and the eight MS bits of the 24-bit destination register are zeroed.

NOTE: This parallel data move is considered to be a move-type
instruction. Due to pipelining, if an address register (R or N) is
changed using a move-type instruction, the new contents of the
destination address register will not be available for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Example:
	ASL	A	R2,X:-(R2)	;A*2->A, save updated R2 in X:(R2)

	Before Execution:
		R2      = $1001
		X:$1000 = $000000

	After Execution:
		R2      = $1000
		X:$1000 = $001000

Explanation of Example:
	Prior to execution, the 16-bit R2 address register contains the
value $1001, and the 24-bit X memory location X:$1000 contains the
value $000000. The execution of the parallel move portion of the
instruction, R2,X:-(R2), predecrements the R2 address register and
then uses the R2 address register to move the updated contents of the
R2 address register into the 24-bit X memory location X:$1000.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

NOTE: The MOVE A,X:ea operation will result in a 24-bit positive or
negative saturation constant being stored in the specified 24-bit X
memory if the signed integer portion of the A accumulator is in use.

Instruction Format:
	(.....)	X:ea,D
	(.....)	S,X:ea
	(.....)	#xxxxxx,D
	(.....)	X:aa,D
	(.....)	S,X:aa

	#xxxxxx = 24-bit Immediate Data

	aa = 6-bit Absolute Short Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)
	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{X:R}						X Memory and Register Data Move

Operation:							Assembler Syntax:
	Class I								Class I
		(...);	X:ea->D1;S2->D2				(...) X:ea,D1	S2,D2
		(...);	S1->X:ea;S2->D2				(...) S1,X:ea	S2,D2
		(...);	#xxxxxx->D1;S2->D2			(...) #xxxxxx,D1	S2,D2
	Class II							Class II
		(...);	A->X:ea;X0->A				(...) A,X:ea	X0,A
		(...);	B->X:ea;X0->B				(...) B,X:ea	X0,B

Description:
	Class I: Move a one-word operand from/to X memory and move
another word operand from an accumulator (S2) to an input register
(D2). All memory addressing modes, including absolute addressing and
24-bit immediate data, may be used. The register to register move
(S2,D2) allows data to be moved to data ALU input register for use as
a data ALU operand in the following instruction.

	Class II: Move one-word operand from a data ALU accumulator to X
memory and one-word operand from data ALU register X0 to a data ALU
accumulator. One effective address is specified. All memory addressing
modes, excluding long absolute addressing and long immediate data, may
be used.

	For both Class I and Class II X:R parallel data moves, if the
arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destination D1 in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction may
not specify A0,A1,A2, or A as its destination D1. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify B0,B1,B2, or B as its destination D1.
That is, duplicate destination are NOT allowed within the same
instruction.

	If the opcode-operand portion of the instruction specifies a given
source or detsination register, that same register or portion of that
register may be used as a source S1 and/or S2 in the parallel data bus
move operation. This allows data to be moved in the parallel data bus
move operation. This allows data to be moved in the same instruction
in which it is being used as a source operand by data ALU operation.
That is, duplication sources are allowed within the same instruction.
Note that S1 and S2 may specify the same register.

Class I Example:
	CMPM	Y0,A	A,X:$1234	A,Y0 ;compare A,Y0 mag., save A, update Y0

	Before Execution:
		A       = $00:800000:000000
		X:$1234 = $000000
		Y0      = $000000

	After Execution:
		A       = $00:800000:000000
		X:$1234 = $7FFFFF
		Y0      = $7FFFFF

Explanation of the Class I Example:
	Prior to executio, the 56-bit A accumulator contains the value
$00:800000:00000, the 24-bit X memory location X:$1234 contains the
value $000000, and the 24-bit Y0 regsiter contains the value $00000.
The execution of the parallel move portion of the instruction,
A,X:$1234	A,Y0, moves the 24-bit limited positive saturation constant
$7FFFFF into both the X:$1234 memory location and the Y0 register
since the signed portion of the A accumulator was in use.

Class II Example:
	MAC	X0,Y0,A	B,X:(R1)+	X0,B	;multiply X0 and Y0 accumulate in A
									;move B to X memory location pointed to
									;by R1 and postincrement R1
									;move X0 to B

	Before Execution:
		X0      = $400000
		Y0      = $600000
		A       = $00:000000:000000
		B       = $FF:7FFFFF:000000
		X:$1234 = $000000
		R1      = $1234

	After Execution:
		X0      = $400000
		Y0      = $600000
		A       = $00:300000:000000
		B       = $00:400000:000000
		X:$1234 = $800000
		R1      = $1235

Explanation of the Class II Example:
	Prior to execution, the 24-bit registers X0 and Y0 contain $400000
and $600000, respectively. The 56-bit accumulators A and B contain the
values $00:000000:000000 and $FF:7FFFFF:000000, respectively. The
24-bit X memory location X:$1234 contains the value $000000, and the
16-bit R1 regsiter contains the value $1234. Execution of the parallel
move portion of the instruction (B,X:(R1)+ X0,B) moves the 24-bit
limited value of B ($800000) into the X:$1234 memory location and the
X0 register ($400000) into accumulator B1 ($400000), sign extends B1
into B2 ($00), and zero fills B0 ($000000). It also increments R1 to
$1235.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

Class I Instruction Format:
	(.....)	X:ea,D1	S2,D2
	(.....)	S1,X:ea	S2,D2
	(.....)	#xxxxxx,D1	S2,D2

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address
		 Immediate data

	S1 = (X0,X1,A,B)
	D1 = (X0,X1,A,B)

	S2 = (A,B)
	D2 = (Y0,Y1)

Class II Instruction Format:
	(.....)	A,X:ea	X0,A
	(.....)	B,X:ea	X0,B

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		mv oscillator clock cycles

Memory:		mv program words


{Y:}						Y Memory Data Move

Operation:						Assembler Syntax:
	(.....); Y:ea->D				(.....)	Y:ea,D
	(.....); Y:aa->D				(.....)	Y:aa,D
	(.....); S->Y:ea				(.....)	S,Y:ea
	(.....); S->Y:aa				(.....)	S,Y:aa
	(.....); #xxxxxx->D				(.....)	#xxxxxx,D

Description:
	Move the specified word operand from/to Y memory. All memory
addressing modes, including absolute addressing and 24-bit immediate
data, may be used. Absolute short addressing may also be used.

	If the arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may notbe specified as destination D in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction may
not specify A0,A1,A2, or A as its destination D. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify B0,B1,B2, or B as its destination D.
That is, duplicate destinations are NOT allowed within the same
instruction.

	If the opcode-operand portion of the instruction specifies a given
source or destination register, that same register or portion of that
register may be used as a source S in the parallel data bus move
operation. This allows data to be moved in the same instruction in
which it is being used as a source operand by data ALU operation.
That is, duplicate sources are allowed within the same instruction.

	When a 24-bit source operand is moved ino a 16-bit destination
register, the 16 LS bits of the 24-bit source operand are stored in
the 16-bit destination register. When a 16-bit source operand is moved
into a 24-bit destination register, the 16LS bits of the destination
register are loaded with the contents of the 16-bit source operand,
and the eight MS bits of the 24-bit destination register are zeroed.

NOTE: This parallel data move is considered to be a move-type
instruction. Due to pipelining, if an address register (R or N) is
changed using a move-type instruction, the new contents of the
destination address register will not be available for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Example:
	EOR	X0,B	#$123456,A	;exclusive OR X0 and B, update A accumulator

	Before Execution:
		A = $FF:FFFFFF:FFFFFF

	After Execution:
		A = $00:123456:000000

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$FF:FFFFFF:FFFFFF. The execution of the parallel move portion of the
instruction, #$123456,A, moves the 24-bit immediate value $123456 into
the 24-bit A1 register, then sign extends that value into the A2
portion of the accumulator, and zeros the lower 24-bit A0 portion of
the accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-         MR        ->|<-       CCR         ->|

	{L}- Set if data limiting has occured during parallel move

NOTE: The MOVE A,Y:ea operation will result in a 24-bit positive or
negative saturation constant being stored in the specified 24-bit X
memory if the signed integer portion of the A accumulator is in use.

Instruction Format:
	(.....)	Y:ea,D
	(.....)	S,Y:ea
	(.....)	#xxxxxx,D
	(.....)	Y:aa,D
	(.....)	S,Y:aa

	#xxxxxx = 24-bit Immediate Data

	aa = 6-bit Absolute Short Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)
	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{R:Y}						Register and Y Memory Data Move

Operation:							Assembler Syntax:
	Class I								Class I
		(...); S1->D1;Y:ea->D2				(...) S1,D1 Y:ea,D2
		(...); S1->D1;S2->Y:ea				(...) S1,D1 S2,Y:ea
		(...); S1->D1;#xxxxxx->D2			(...) S1,D1	#xxxxxx,D2
	Class II							Class II
		(...); Y0->A;A->Y:ea				(...) Y0,A	A,Y:ea
		(...); Y0->B;B->Y:ea				(...) Y0,B	B,Y:ea

Description:
	Class I: Move a one-word operand from an accumulator (S1) to an
input register (D1) and move another word operand from/to Y memory.
All memory addressing modes, including absolute addressing and 24-bit
immediate data, may be used. The register to register move (S1,D1)
allows a data ALU accumulator to be moved to a data ALU input register
for use as a data ALU accumulator to be moved to a data ALU input
register for use as a data ALU operand in the following instruction.

	Class II: Move one-word operand from a data ALU accumulator to Y
memory and one-word operand from data ALU register Y0 to a data ALU
accumulator. One effective address is specified. All memory addressing
modes, excluding long absolute addressing and long immediate data,
may be used. Class II move operations have been added to the R:Y
parallel move (and a similar feature has been added to the X:R
parallel move) as an added feature available in the first quarter of
1989.

	For both Class I and Class II R:Y parallel data moves, if the
arithmetic or logical opcode-operand portion of teh instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destiation D2 in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction may
not specify A0,A1,A2, or A as its destination D2. Similary, if the
opcode-operand portion of the parallel data bus move portion of the
instruction may not specify B0,B1,B2, or B as its destination D2. That
is, duplicate destinations are NOT allowed within the same instruction.

	If the opcode-operand portion of the instruction specifies a given
source or detsination register, that same register or portion of that
register may be used as a source S1 and/or S2 in the parallel data bus
move operation. This allows data to be moved in the parallel data bus
move operation. This allows data to be moved in the same instruction
in which it is being used as a source operand by data ALU operation.
That is, duplication sources are allowed within the same instruction.
Note that S1 and S2 may specify the same register.

Class I Example:
	ADDL	B,A	B,X1	Y:(R6)-N6,B	;2*A+B->A, update X1,B and R6

	Before Execution:
		B       = $80:123456:789ABC
		X1      = $000000
		R6      = $2020
		N6      = $0020
		Y:$2020 = 654321

	After Execution:
		B       = $00:654321:000000
		X1      = $800000
		R6      = $2000
		N6      = $0020
		Y:$2020 = 654321

Explanation of the Class I Example:
	Prior to execution, the 56-bit B accumulator contains the value
$80:123456:789ABC, the 24-bit X1 register contains the value $000000,
the 16-bit R6 address register contains the value $2020, the 16-bit N6
address offset register contains the value $654321. The execution of
the parallel move portion of the instruction, B,X1 Y:(R6)-N6,B moves
the 24-bit limited negative saturation constant $800000 into the X1
register since the signed integer portion of the B accumulator was in
use, uses the value in the 16-bit R6 address register to move the
24-bit value in the Y memory location Y:$2020 into the 56-bit B
accumulator (B2) and automatic zeroing of the lower portion of the
accumulator (B0), and finally uses the contents of the 16-bit R6
address register. The contents of the N6 address offset register are
not affected.

Class II Example:
	MAC	X0,Y0,A	Y0,B	B,Y:(R1)+	;multiply X0 and Y0 and accumulate in
									;A move B to Y memory location pointed
									;to by R1 and postincrement R1 move Y0
									;to B

	Before Execution:
		X0      = $400000
		Y0      = $600000
		A       = $00:000000:000000
		B       = $00:800000:000000
		Y:$1234 = $000000
		R1      = $1234

	After Execution:
		X0      = $400000
		Y0      = $600000
		A       = $00:300000:000000
		B       = $00:600000:000000
		Y:$1234 = $7FFFFF
		R1      = $1235

Explanation of the Class II Example:
	Prior to execution, the 24-bit registers, X0 and Y0, contain
$400000 and $600000, respectively. The 56-bit accumulators A and B
contain the values $00:000000:000000 and $00:800000:000000 (+1.0),
respectively. The 24-bit Y memory location Y:$1234 contains the value
$000000, and the 16-bit R1 register contains the value $1234. Execution
of the parallel move portion of the instruction (Y0,B B,Y:(R1)+) moves
the Y0 register ($600000) into accumulator B1 ($600000), sign extends
B1 into B2 ($00), and zero fills B0 ($000000). It also moves the 24-bit
limited value of B ($7FFFFF) into the Y:$1234 memory location and
increments R1 to $1235.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

Class I Instruction Format:
	(...)	S1,D1	Y:ea,D2
	(...)	S1,D1	S2,Y:ea
	(...)	S1,D1	#xxxxxx,D2

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address
		 Immediate data

	S1 = (A,B)
	D1 = (X0,X1)

	S2 = (Y0,Y1,A,B)
	D2 = (Y0,Y1,A,B)

Class II Instruction Format:
	(...)	Y0,A	A,Y:ea
	(...)	Y0,B	B,Y:ea

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

Timing:		mv oscillator clock cycles

Memory:		mv program words


{L:}						Long Memory Data Move

Operation:							Assembler Syntax:
	(...); X:ea->D1;Y:ea->D2			(...)	L:ea,D
	(...); X:aa->D1;Y:aa->D2			(...)	L:aa,D
	(...); S1->X:ea;S2->Y:ea			(...)	S,L:ea
	(...); S1->X:aa;S2->Y:aa			(...)	S,L:aa

Description:
	Move one 48-bit long-word operand from/to X and Y memory. Two data
ALU registers are concatenated to form the 48-bit long-word operand.
This allows efficient moving of both double-precision (high:low) and
complex (real:imaginary) data from/to one effective address in L (X:Y)
memory. The same effective address is used for both the X and Y memory
spaces; thus, only one effective address is required. Note that the A,
B, A10, and B10 operands reference a single 48-bit signed
(double-precision) quantity while the X,Y,AB, and BA operands reference
two seperate (i.e., real and imaginary) 24-bit signed quantities. All
memory alterable addressing modes may be used. Absolute short
addressing may also be used.

	If the arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destination D in
the parallel data bus move operation. Thus, if the opcode-operand
portion of the instruction specifies the 56-bit A accumulator as its
destination, the parallel data bus move portion of the instruction may
not specify A, A10, AB, or BA as destination D. Similary, if the
opcode-operand portion of the instruction specifies the 56-bit B
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify  B, B10, AB, or BA as its destination
D. That is, duplicate destinations are not allowed within the same
instruction.

	If the opcode-operand portion of the instruction specifies a given
source or destination register, that same register or portion of that
register may be used as a source S in the parallel data bus move
operation. This allows data to be moved in the same instruction in
which it is being used as a source operand by a data ALU operation.
That is, duplicate sources are allowed within the same instruction.

NOTE: The operands A10, B10, X, Y, AB, and BA may be used only for a
48-bit long memory move as previously described. These operands may not
be used in any other type of instruction or parallel move.

Example:
	CMP	Y0,B	A,L:$1234	;compare Y0 and B, save 48-bit A1:A0 value

	Before Execution:
		A       = $01:234567:89ABCD
		X:$1234 = $000000
		Y:$1234 = $000000

	After Execution:
		A       = $01:234567:89ABCD
		X:$1234 = $7FFFFF
		Y:$1234 = $FFFFFF

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$01:234567:89ABCD, the 24-bit X memory location X:$1234 contains the
value $000000, and the 24-bit Y memory location Y:$1234 contains the
value $000000. The execution of the parallel move portion of the
instruction, A,L:$1234, moves the 48-bit limited positive saturation
constant $7FFFFF:FFFFFF into the specified long memory location by
moving the MS 24 bits of the 48-bit limited positive saturation
constant ($7FFFFF) into the 24-bit X memory location X:$1234 and by
moving the LS 24 bits of the 48-bit limited positive saturation
constant ($FFFFFF) into the 24-bit Y memory location Y:$1234 since the
signed integer portion of the A accumulator was in use.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

NOTE: The MOVE A,L:ea operation will result in a 48-bit positive or
negative saturation constant being stored in the specified 24-bit X
and Y memory locations if the signed integer portion ofthe A
accumulator is in use. The MOVE AB,L:ea operation will result in
either one of the two 24-bit positive and/or negative saturation
constant(s) being stored in the specified 24-bit X and/or Y memory
location(s) if the signed integer portion of the A and/or B
accumulator(s) is in use. 

Instruction Format:
	(...)	L:ea,D
	(...)	S,L:ea
	(...)	L:aa,D
	(...)	S,L:aa

	aa = 6-bit Absolute Short Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S = (A10,B10,X,Y,A,B,AB,BA)
	D = (A10,B10,X,Y,A,B,AB,BA)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{X:Y}						X Y Memory Data Move

Operation:							Assembler Syntax:
	(...);X:<eax>->D1;Y:<eay>->D2		(...) X:<eax>,D1 Y:<eay>,D2
	(...);X:<eax>->D1;S2->Y:<eay>		(...) X:<eax>,D1 S2,Y:<eay>
	(...);S1->X:<eax>;Y:<eay>->D2		(...) S1,X:<eax> Y:<eay>,D2
	(...);S1->X:<eax>;S2->Y:<eay>		(...) S1,X:<eax> S2,Y:<eay>

Description:
	Move one-word operand from/to X memory and move another word
operand from/to Y memory. Note that two independent effective addresses
are specified (<eax> and <eay>) where one of the effective addresses
uses the lower bank of address registers (R0-R3) while the other
effective address uses the upper bank of address registers (R4-R7).
All parallel addressing modes may be used.

	If the arithmetic or logical opcode-operand portion of the instruction
specifies a given destination accumulator, that same accumulator or
portion of that accumulator may not be specified as a destination D1
or D2 in the parallel data bus move operation. Thus, if the
opcode-operand portion of the instruction specifies the 56-bit A
accumulator as its destination, the parallel data bus move portion of
the instruction may not specify A as its destination D1 or D2.
Similary, if the opcode-operand portion of the instruction specifies
the  56-bit B accumulator as its destination, the parallel data bus
move portion of the instruction may not specify B as its destination
D1 or D2. That is, duplicate destinations are NOT allowed within the
same instruction. D1 and D2 may not specify the same register.

	If the opcode-operand portion of the instruction specifies a given
source or destination register, that same register or portion of that
register may be used as a source S1 and/or S2 in the parallel data bus
move operation. This allows data to be moved in the same instruction in
which it is being used as a source operand by data ALU operation. That
is, duplicate sources are allowed within the same instruction. Note
that S1 and S2 may specify the same register.

Example:
	MPYR X1,Y0,A X1,X:(R0)+ Y0,Y:(R4)+N4	;X1*Y0->A, save X1 and Y0

	Before Execution:
		X1      = $123123
		Y0      = $456456
		R0      = $1000
		R4      = $0100
		N4      = $0023
		X:$1000 = $000000
		Y:$0100 = $000000

	After Execution:
		X1      = $123123
		Y0      = $456456
		R0      = $1001
		R4      = $0123
		N4      = $0023
		X:$1000 = $123123
		Y:$0100 = $456456

Explanation of example:
	Prior to execution, the 24-bit X1 register contains the value
$123123, the 24-bit Y0 register contains the value $456456, the 16-bit
R0 address register contains the value $1000, the 16-bit R4 address
register contains the value $0100, the 16-bit N4 address offset
register contains the value $000000, the 24-bit X memory location
X:$1000 contains the value $000000, and the 24-bit Y memory location
Y:$0100 contains the value $000000. The execution of the parallel move
portion of the instruction, X1,X:(R0)+ Y0,Y:(R4)+N4, moves the 24-bit
value in the X1 register into the 24-bit X memory location X:$1000
using the 16-bit R0 address register, moves the 24-bit value in the Y0
register into the 24-bit Y memory location Y:$0100 using the 16-bit R4
address register, updates the 16-bit value in the R0 address register,
and updates the 16-bit R4 address register using the 16-bit value in
the R0 address register, and updates the 16-bit R4 address register
using the 16-bit N4 address offset register. The contents of the N4
address offset register are not affected.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

NOTE: The MOVE A,X:<eax> B,Y:<eay> operation will result in one or
two 24-bit positive and/or negative saturation constant(s) being
stored in the specified 24-bit X and/or Y memory locations if the
signed integer portion of the A and/or B accumulator(s) is in use.

Instruction Format:
	(...) X:<eax>,D1 Y:<eay>,D2
	(...) X:<eax>,D1 S2,Y:<eay>
	(...) S1,X:<eax> Y:<eay>,D2
	(...) S1,X:<eax> S2,Y:<eay>

	eax = (Rn)+Nn
		  (Rn)-
		  (Rn)+
		  (Rn)

	eay = (Rn)+Nn
		  (Rn)-
		  (Rn)+
		  (Rn)

	S1 = (X0,X1,A,B)
	D1 = (X0,X1,A,B)

	S2 = (Y0,Y1,A,B)
	D2 = (Y0,Y1,A,B)

Timing:		mv oscillator clock cycles

Memory:		mv program words


{MOVEC}					Move Control Register

Operation:						Assembler Syntax:
	X:ea->D1						MOVEC	X:ea,D1
	X:aa->D1						MOVEC	X:aa,D1
	S1->X:ea						MOVEC	S1,X:ea
	S1->X:aa						MOVEC	S1,X:aa
	Y:ea->D1						MOVEC	Y:ea,D1
	Y:aa->D1						MOVEC	Y:aa,D1
	S1->Y:ea						MOVEC	S1,Y:ea
	S1->Y:aa						MOVEC	S1,Y:aa
	S1->D2							MOVEC	S1,D2
	S2->D1							MOVEC	S2,D1
	#xxxx->D1						MOVEC	#xxxx,D1
	#xx->D1							MOVEC	#xx,D1

Description:
	Move the contents of the specified source control register S1 or S2
to the specified destination or move the specified source to the
specified destination control register D1 or D2. The control registers
S1 and D1 are subset of the S2 and D2 register set and consist of the
address ALU modifier registers and the program controller registers.
These registers. These registers may be moved to or from any other
register or memory space. All memory addressing modes, as well as an
immediate short addressing mode, may be used.

	If the system stack register SSH is specified as a source operand, the
system stack pointer (SP) is postdecremented by 1 after SSH has been
read. If the system stack register SSH is specified as a destination
operand, the system stack pointer (SP) is preincremented by 1 before
SSH is written. This allows the system stack to be efficiently extended
using software stack pointer operations.

	When a 56-bit accumulator (A or B) is specified as a source operand,
the accumulator value is optionnaly shifted according to the scaling
mode bits S0 and S1 in the system status register (SR). If the data
out of the shifter indicates that the accumulator extension register is
in use and the data is to be moved into a 24-bit destination, the value
stored in the destination is limited to a maximum positive or negative
saturation constant to minimize truncation error. If the data is to be
moved into 16-bit destination and the accumulator extension register is
in use, the value is limited to a maximum positive or negative
saturation constant whose LS 16 bits are then stored in the 16-bit
destination register. Limiting does not occur if an individual 24-bit
accumulator register (A1,A0,B1, or B0) is specified as a source operand
instead of the full 56-bit accumulator (A or B). This limiting features
allows block floating-point operations to be performed with error
detection since the L bit in the condition code register is latched.

	When a 56-bit accumulator (A or B) is specified as a destination
operand, any 24-bit source data to be moved into that accumulator is
automatically extended to 56 bits by sign extending the MS bits ofthe
source operand (bit 23) and appending the source operand with 24 LS
zeros. Whenever a 16-bit source operands is to be moved into a 24-bit
destination, the 16-bit value is stored in the 16 LS 16 bits of the
24-bit destination, and the MS 8 bits of that destination are zeroed.
Similary, whenever a 16-bit source operand is to be moved into a 56-bit
accumulator, the 16-bit value is moved into the LS 16 bits of the MSP
portion of the accumulator (A1 or B1), the MS 8 bits of the MSP portion
of that accumulator are zeroed, and the resulting 24-bit value is
extended to 56 bits by sign extending the MS bit and appending the
result with 24 LS zeros. Note that for 24-bit source operands both the
automatic sign-extension and zeroing features may be disabled by
specifying the destination register to be one of the individual 24-bit
accumulator registers (A1 or B1).

NOTE: Due to pipelining, if an address register (R,N, or M) is
changed using a move-type instruction, the new contents of the
destination address register will not beavailable for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Restrictions:

NOTE: The following restrictions represent very unusual operations,
which probably would never be used but are listed only for
completeness.

	A MOVEC instruction used within a DO loop which specifies SSH as the
source operand or LA, LC, SR, SP, SSH, or SSL as the destination
operand cannot begin at the address LA-2, LA-1, or LA within that DO
loop.

	A MOVEC instruction which specifies SSH as the source operand or LA,
LC, SSH, SSL, or SP as the destination operand cannot be used
immediately before a DO instruction.

	A MOVEC instruction which specifies SSH as the source operand or LA,
LC, SR, SSH, SSL, or SP as the destination operand cannot be used
immediately before an ENDDO instruction.

	A MOVEC instruction which specifies SSH as the source operand or SR,
SSH, SSL, or SP as the destination operand cannot be used immediately
before an RTI instruction.

	A MOVEC instruction which specifies SSH as the source operand or SSH,
SSL, or SP as the destination operand cannot be used immediately before
an RTS instruction.

	A MOVEC instruction which specifies SP as the destination operand
cannot be used immediately before a MOVEC, MOVEM, or MOVEP instruction
which specifies SSH or SSL as the source operand.

	A MOVEC SSH,SSH instruction is illegal and cannot be used.

Example:
	MOVEC	LC,X0	;move LC into X0

	Before Execution:
		LC = $0100
		X0 = $123456

	After Execution:
		LC = $0100
		X0 = $000100

Explanation of Example:
	Prior to execution, the 16-bit loop couter (LC) register contains
the value $0100, and the 24-bit X0 register contains the value $123456.
The execution of the MOVEC LC,X0 instruction moves the contents of the
16-bit LC register into the 16 LS bits of the 24-bit X0 register and
zeros the 8 MS bits of the X0 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	For D1 or D2 = SR operand:
		{L}- Set according to bit 6 of the source operand
		{E}- Set according to bit 5 of the source operand
		{U}- Set according to bit 4 of the source operand
		{N}- Set according to bit 3 of the source operand
		{Z}- Set according to bit 2 of the source operand
		{V}- Set according to bit 1 of the source operand
		{C}- Set according to bit 0 of the source operand

	For D1 and D2 != SR operand:
		{L}- Set if data limiting has occured during move

Instruction Format:
	MOVEC	X:ea,D1
	MOVEC	X:aa,D1
	MOVEC	S1,X:ea
	MOVEC	S1,X:aa
	MOVEC	Y:ea,D1
	MOVEC	Y:aa,D1
	MOVEC	S1,Y:ea
	MOVEC	S1,Y:aa
	MOVEC	S1,D2
	MOVEC	S2,D1
	MOVEC	#xxxx,D1
	MOVEC	#xx,D1

	#xxxx = Immediate Data

	#xx = 8-bit Immediate Short Data

	aa = 6-bit Absolute Short Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S1 = (Mn,SR,OMR,SP,SSH,SSL,LA,LC)
	D1 = (Mn,SR,OMR,SP,SSH,SSL,LA,LC)

	S2 = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,
		  OMR,SP,SSH,SSL,LA,LC)
	D2 = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,
		  OMR,SP,SSH,SSL,LA,LC)

Timing:		2 + mvc oscillator clock cycles

Memory:		1 + ea program words


{MOVEM}					Move Program Memory

Operation:					Assembler Syntax:
	S->P:ea						MOVEM	S,P:ea
	S->P:aa						MOVEM	S,P:aa
	P:ea->D						MOVEM	P:ea,D
	P:aa->D						MOVEM	P:aa,D

Description:
	Move the specified operand from/to the specified operand from/to
the specified program (P) memory location. This is a powerful move
instruction in that the source and destination registers S and D may be
any register. All memory alterable addressing modes may be used as well
as the absolute short addressing mode.

	If the system stack register SSH is specified as a source operand, the
system stack pointer (SP) is postdecremented by 1 after SSH has been
read. If the system stack register SSH is specified as a destination
operand, the system stack pointer (SP) is preincremented by 1 before
SSH is written. This allows the system stack to be efficiently extended
using software stack pointer operations.

	When a 56-bit accumulator (A or B) is specified as a source operand S,
the accumulator value is optionnaly shifted according to the scaling
mode bits S0 and S1 in the system status register (SR). If data out of
the shifter indicates that the accumulator extension register is in use
and the data is to be moved into a 24-bit destination, the value stored
in the destination is limited to a maximum positive or negative
saturation constant to minimize truncation error. If a 24-bit source
operand is to be moved into a 16-bit destination register D, the 8 MS
bits of the 24-bit source operand are discarded, and the 16 LS bits are
stored in the 16-bit destination register. Limiting does not occur if
an individual 24-bit accumulator register (A1,A0,B1, or B0) is
specified as a source operand instead of the full 56-bit accumulator
(A or B). This limiting feature allows block floating-point operations
to be performed with error detection since the L bit in the condition
code register is latched.

	When a 56-bit accumulator (A or B) is specified as a destination
operand D, any 24-bit source data to be moved into that accumulator is
automatically extended to 56 bits by sign extending the MS bits of the
source operand (bit 23) and appending the source operand with 24 LS
zeros. Whenever a 16-bit source operand S is to be moved into 24-bit
destination, the 16-bit source is loaded into the LS 16 bits of the
destination operand, and the remaining 8 MS bits of the destination
are zeroed. Note that for 24-bit source operands, both the automatic
sign-extension and zeroing features may be disabled by specifying the
destination register to be one of the individual 24-bit accumulator
register (A1 or B1).

NOTE: Due to pipelining, if an address register (R,N, or M) is
changed using a move-type instruction, the new contents of the
destination address register will not beavailable for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Restrictions:
	A MOVEM instruction used within a DO loop which specifies SSH as the
source operand or LA, LC, SR, SP, SSH, or SSL as the destination
operand cannot begin at the address LA-2, LA-1, or LA within that DO
loop.

	A MOVEM instruction which specifies SSH as the source operand or LA,
LC, SSH, SSL, or SP as the destination operand cannot be used
immediately before a DO instruction.

	A MOVEM instruction which specifies SSH as the source operand or LA,
LC, SR, SSH, SSL, or SP as the destination operand cannot be used
immediately before an ENDDO instruction.

	A MOVEM instruction which specifies SSH as the source operand or SR,
SSH, SSL, or SP as the destination operand cannot be used immediately
before an RTI instruction.

	A MOVEM instruction which specifies SSH as the source operand or SSH,
SSL, or SP as the destination operand cannot be used immediately before
an RTS instruction.

	A MOVEM instruction which specifies SP as the destination operand
cannot be used immediately before a MOVEC, MOVEM, or MOVEP instruction
which specifies SSH or SSL as the source operand.

Example:
	MOVEM	P:(R5+N5),LC	;move P:(R5+N5) into the loop counter (LC)

	Before Execution:
		P:(R5+N5) = $000116
		LC        = $0000

	After Execution:
		P:(R5+N5) = $000116
		LC        = $0116

Explanation of Example:
	Prior to execution, the 16-bit loop couter (LC) register contains
the value $0000, and the 24-bit program (P) memory locations P:(R5+N5)
contains the value $0000, and the 24-bit program (P) memory location
P:(R5+N5) into the 16-bit LC register.

Conditions Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	For D = SR operand:
		{L}- Set according to bit 6 of the source operand
		{E}- Set according to bit 5 of the source operand
		{U}- Set according to bit 4 of the source operand
		{N}- Set according to bit 3 of the source operand
		{Z}- Set according to bit 2 of the source operand
		{V}- Set according to bit 1 of the source operand
		{C}- Set according to bit 0 of the source operand

	For D != SR operand:
		{L}- Set if data limiting has occured during move

Instruction Format:
	MOVEM	S,P:ea
	MOVEM	S,P:aa
	MOVEM	P:ea,D
	MOVEM	P:aa,D

	aa = 6-bit Absolute Short Data

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,OMR,SP,SSH,
		 SSL,LA,LC)
	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,OMR,SP,SSH,
		 SSL,LA,LC)

Timing:		2 + mvm oscillator clock cycles

Memory:		1 + ea program words


{MOVEP}					Move Peripheral Data

Operation:					Assembler Syntax:
	X:pp->D						MOVEP	X:pp,D
	X:pp->X:ea					MOVEP	X:pp,X:ea
	X:pp->Y:ea					MOVEP	X:pp,Y:ea
	X:pp->P:ea					MOVEP	X:pp,P:ea
	S->X:pp						MOVEP	S,X:pp
	#xxxxxx->X:pp				MOVEP	#xxxxxx,X:pp
	X:ea->X:pp					MOVEP	X:ea,X:pp
	Y:ea->X:pp					MOVEP	Y:ea,X:pp
	P:ea->X:pp					MOVEP	P:ea,X:pp
	Y:pp->D						MOVEP	Y:pp,D
	Y:pp->X:ea					MOVEP	Y:pp,X:ea
	Y:pp->Y:ea					MOVEP	Y:pp,Y:ea
	Y:pp->P:ea					MOVEP	Y:pp,P:ea
	S->Y:pp						MOVEP	S,Y:pp
	#xxxxxx->Y:pp				MOVEP	#xxxxxx,Y:pp
	X:ea->Y:pp					MOVEP	X:ea,Y:pp
	Y:ea->Y:pp					MOVEP	Y:ea,Y:pp
	P:ea->Y:pp					MOVEP	P:ea,Y:pp

Description:
	Move the specified operand from/to the specified X or Y I/O
peripheral. The I/O short addressing mode is used for the I/O
peripheral address. All memory addressing modes may be used for the X or
Y memory effective address.

	If the system stack register SSH is specified as a source operand, the
system stack pointer (SP) is postdecremented by 1 after SSH has been
read. If the system stack register SSH is specified as a destination
operand, the system stack pointer (SP) is preincremented by 1 before
SSH is written. This allows the system stack to be efficiently extended
using software stack pointer operations.

	When a 56-bit accumulator (A or B) is specified as a source operand S,
the accumulator value is optionally shifted according to the scaling
mode bits S0 and S1 in the system status register (SR). If the data out
of the shifter indicates that the accumulator extension register is in
use and the data is to be moved into a 24-bit destination, the value
stored in the destination is limited to a maximum positive or negative
saturation constant to minimize truncation error. If a 24-bit source
operand is to be moved into a 16-bit destination register D, the 8 MS
bits of the 24-bit source operand are discarded, and the 16 LS bits
are stored in the 16-bit destination register. Limiting does not occur
if an individual 24-bit accumulator register (A1,A0,B1, or B0) is
specified as a source operand instead of the full 56-bit accumulator
(A or B). This limiting feature allows block floating-point operations
to be performed with error detection since the L bit in the condition
code register is latched.

	When a 56-bit accumulator (A or B) is specified as a destination
operand D, any 24-bit source data to be moved into that accumulator is
automatically extended to 56 bits by sign extending the MS bit of the
source operand (bit 23) and appending the source operand with 24 LS
zeros. Whenever a 16-bit source operand S is to be moved into a 24-bit
destination, the 16-bit source is loaded into the LS 16 bits of the
destination operand, and the remaining 8 MS bits of the destination are
zeroed. Note that for 24-bit source operands both the automatic
sign-extension and zeroing features may be disabled by specifying the
destination register to be one of the individual 24-bit accumulator
register (A1 or B1).

NOTE: Due to pipelining, if an address register (R,N, or M) is
changed using a move-type instruction, the new contents of the
destination address register will not be available for use during the
following instruction (i.e., there is a single instruction cycle
pipeline delay).

Restrictions:

NOTE: The following restrictions represent very unusual operations,
which probably would never be used but are listed only for
completeness.

	A MOVEP instruction used within a DO loop which specifies SSH as the
source operand or LA, LC, SR, SP, SSH, or SSL as the destination
operand cannot begin at the address LA-2, LA-1, or LA within that DO
loop.

	A MOVEP instruction which specifies SSH as the source operand or LA,
LC, SSH, SSL, or SP as the destination operand cannot be used
immediately before a DO instruction.

	A MOVEP instruction which specifies SSH as the source operand or LA,
LC, SR, SSH, SSL, or SP as the destination operand cannot be used
immediately before an ENDDO instruction.

	A MOVEP instruction which specifies SSH as the source operand or SR,
SSH, SSL, or SP as the destination operand cannot be used immediately
before an RTI instruction.

	A MOVEP instruction which specifies SSH as the source operand or SSH,
SSL, or SP as the destination operand cannot be used immediately before
an RTS instruction.

	A MOVEP instruction which specifies SP as the destination operand
cannot be used immediately before a MOVEC, MOVEM, or MOVEP instruction
which specifies SSH or SSL as the source operand.

Example:
	MOVEP	#$1113,X:<<$FFFE ;initialize Bus Control Register wait states

	Before Execution:
		X:$FFFE (BCR) = $FFFF

	After Execution:
		X:$FFFE (BCR) = $1113

Explanation of Example:
	Prior to execution, the 16-bit, X memory-mapped, I/O bus control
register (BCR) contains the value $FFFF. The execution of the MOVEP
#$1113,X:<<$FFFE instruction moves the value $1113 into the 16-bit bus
control register X:$FFFE, resulting in one wait state for all external
X, external Y, and external program memory accesses and three wait
states for al external I/O accesses.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	For D = SR operand:
		{L}- Set according to bit 6 of the source operand
		{E}- Set according to bit 5 of the source operand
		{U}- Set according to bit 4 of the source operand
		{N}- Set according to bit 3 of the source operand
		{Z}- Set according to bit 2 of the source operand
		{V}- Set according to bit 1 of the source operand
		{C}- Set according to bit 0 of the source operand

	For D != SR operand:
		{L}- Set if data limiting has occured during move

Instruction Format:
	MOVEP	X:pp,D
	MOVEP	X:pp,X:ea
	MOVEP	X:pp,Y:ea
	MOVEP	X:pp,P:ea
	MOVEP	S,X:pp
	MOVEP	#xxxxxx,X:pp
	MOVEP	X:ea,X:pp
	MOVEP	Y:ea,X:pp
	MOVEP	P:ea,X:pp
	MOVEP	Y:pp,D
	MOVEP	Y:pp,X:ea
	MOVEP	Y:pp,Y:ea
	MOVEP	Y:pp,P:ea
	MOVEP	S,Y:pp
	MOVEP	#xxxxxx,Y:pp
	MOVEP	X:ea,Y:pp
	MOVEP	Y:ea,Y:pp
	MOVEP	P:ea,Y:pp

	#xxxxxx = Immediate Data

	pp = 6-bit I/O Short Address

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)
		 Absolute address

	S = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,OMR,SP,SSH,
		 SSL,LA,LC)
	D = (X0,X1,Y0,Y1,A0,B0,A2,B2,A1,B1,A,B,Rn,Nn,Mn,SR,OMR,SP,SSH,
		 SSL,LA,LC)

Timing:		4 + mvp oscillator clock cycles

Memory:		1 + ea program words


{MPY}						Signed Multiply

Operation:
	+-S1*S2->D			(parallel move)

Assembler Syntax:
	MPY	(+-)S1,S2,D		(parallel move)

Description:
	Multiply the two signed 24-bit source operands S1 and S2 and store
the resulting product in the specified 56-bit destination accumulator
D. The "-" sign option is used to negate the specified product. The
default sign option is "+".

Example:
	MPY	-X1,Y1,A #$543210,Y0	;-(X1*Y1)->A, update Y0

	Before Execution:
		X1 = $800000
		Y1 = $C00000
		A  = $00:000000:000000

	After Execution:
		X1 = $800000
		Y1 = $C00000
		A  = $FF:C00000:000000

Explanation of Example:
	Prior to execution, the 24-bit X1 register contains the value
$800000 (-1,0), the 24-bit Y1 register contains the value $C00000,
(-0.5), and the 56-bit A accumulator contains the value
$00:000000:000000 (0.0). The execution ofthe MPY -X1,Y1,A instruction
multiples the 24-bit signed value in the X1 register by the 24-bit
signed value in the Y1 register, negates the 48-bit product , and
stores the result in the 56-bit A accumulator (-X1*Y1= -0.5=
$FF:C00000:000000 = A).

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Always cleared

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	MPY	(+-)S1,S2,D

	S1 = (X0,Y0,X1,Y1)
	S2 = (X0,Y0,X1,Y1)

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{MPYR}						Signed Multiply and Round

Operation:
	+-S1*S2+r->D		(parallel move)

Assembler Syntax:
	MPYR	(+-)S1,S2,D	(parallel move)

Description:
	Multiply the two signed 24-bit source operands S1 and S2, round the
result convergent rounding, and store it in the specified 56-bit
destination accumulator D. The "-" sign option is used to negate the
product prior to rounding. The default sign option is "+". The
contribution of the LS bits of the result is rounded into the upper
portion of the destination accumulator (A1 or B1) by adding a constant
to the LS bits of the lower portion of the accumulator (A0 or B0). The
value of the constant added is determined by the scaling mode bits S0
and S1 in the status register. Once the rouding has been completed, the
LS bits of the destination accumulator D (A0 or B0) are loaded with
zeros to maintain an unbiased accumulator value which may be reused by
the next instruction. The upper portion of the accumulator (A1 or B1)
contains the rounded result which may be read out to the data buses.
Refer to the RND instruction for more complete information on the
convergent rounding process.

Example:
	MPYR	-Y0,Y0,B (R3)-N3	;square and negate Y0, update R3

	Before Execution:
		Y0 = $654321
		B  = $00:000000:000000

	After Execution:
		Y0 = $654321
		B  = $FF:AFE3ED:000000

Explanation of Example:
	Prior to execution, the 24-bit Y0 register contains the value
$654321 (0.791111112), and the 56-bit B accumulator contains the value
$00:000000:000000 (0.0). The execution of the MPYR -Y0,Y0,B instruction
squares the 24-bit signed value in the Y0 register, negates the
resulting 48-bit product, rounds the result into B1, and zeros B0
(-Y0*Y0 = -0.625856790961748 approximately = $FF:AFE3EC:B76B7E, which
is rounded to the value $FF:AFE3ED:000000 = -0.625856757164002 = B).

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Always cleared

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	MPYR	(+-)S1,S2,D

	S1 = (X0,Y0,X1,Y1)
	S2 = (X0,Y0,X1,Y1)

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{NEG}						Negate Accumulator

Operation
	0-D->D				(parallel move)

Assembler Syntax:
	NEG D				(parallel move)

Description:
	Negate the destination operand D and store the result in the
destination accumulator. This is a 56-bit, twos-complement operation.

Example:
	NEG	X1,X:(R3)+	Y:(R6)-,A	;0-B->B,update A,X1,R3,R6

	Before Execution:
		B = $00:123456:789ABC

	After Execution:
		B = $FF:EDCBA9:876544

Explanation of Example:
	Prior to execution, the 56-bit B accumulator contains the value
$00:123456:789ABC. The NEG B instruction takes the twos complement of
the value in the B accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occurred in A or B result

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	NEG D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{NOP}						No operation

Operation
	PC = PC +1

Assembler Syntax:
	NOP

Description:
	Increment the programm counter (PC),. Pending pipeline actions,
if any, are completed. Execution continues with the instruction following
the NOP.

Condition Codes:
	The condition codes are not affected by this instruction

Instruction Format:
	NOP

Timing:		2 oscillator clock cycles

Memory:		1 program words


{NORM}						Normalize Accumulator Iteration

Operation:
	If	~E & U & ~Z = 1, then ASL D and Rn-1 -> Rn
	else if			E = 1, then ASR D and Rn+1 -> Rn
	else NOP

	where
	~ denotes the logical complement
	& denotes the logical AND operator

Assembler Syntax:
	NORM	Rn,D

Description:
	Perform one normalization iteration on the specified destination operand
D, update the specified address register Rn based upon the result of that
iteration, and store the result back in the destination accumulator. This
is a 56-bit operation. If the accumulator extension is not in use, the
accumulator is unnormalized, and the accumulator is not zero, the
destination operand is arithmetically shifted one bit to the left, and the
specified address register is decremented by 1. If the accumulator extension
is in use, the destination operand is arithmetically shifted one bit to the
right, and the specified address register is incremented by 1. If the
accumulator is normalized, or zero, a NOP is executed and the specified
address register is not affectred. Since the operation of the NORM
instruction depends on the E, U and Z condition code register bits, these
bits must correctly reflect the current state of the destination accumulator
prior to executing the NORM instruction. Note that the L and V bits in the
condition code register will be cleared unless they have been improperly
set up prior to executing the NORM instruction.

Example:
	REP	#$2E		;maximum number of iterations needed
	NORM	R3,A		;perform 1 normalization iteration

Before Execution:
	A  = $00:000000:000001
	R3 = $0000

After Execution:
	A  = $00:400000:000000
	R3	$FFD2

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$00:000000:000001, and the 16-bit R3 address register contains the value
$0000. The repetition of the NORM R3,A instruction normalizes the value
in the 56-bit accumulator and stores the resulting number of shifts
performed during that normalization process in the R3 address register.
A negative value reflects the number of left shifts performed; a positive
number reflects the number of right shifts performed during the
normalization process.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if overflow has occured in A or B result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if bit 55 is changed as a result of a left shift

Instruction Format:
	NORM	Rn,D

Timing:		2 oscillator clock cycles

Memory:		1 program words


{NOT}						Logical Complement

Operation:
	~D[47:24] -> D[47:24]	(parallel move)
	where ~ denotes the logical NOT operator

Assembler Syntax:
	NOT	D				(parallel move)

Description:
	Take ones complement of bits 47-24 off the destination operand D and
store the result in bits 47-24 of the destination accumulator.
This instruction is a 24-bit operation. The remaining bits of the
destination operand D are not affected.

Example:
NOT	A AB,L:(R2)+		;save A1,B1, take the ones complement of A1
	
Before Execution:
	A  = $00:123456:789ABC

After Execution:
	A  = $00:EDCBA9:789ABC

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$00:123456:789ABC. The NOT A instruction takes the ones complement
of bits 47-24 of the A accumulator (A1) and stores the result back in
the A1 register. The remainings bits of the A accumulator are not
affected.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 A or B result are zero
	{V}- Always cleared

Instruction Format:
	NOT	D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{OR}						Logical Inclusive OR

Operation:
	S + D[47:24] -> D[47:24] (parallel move)
	where + denotes the logical inclusive OR operator

Assembler Syntax:
	OR	S,D				(parallel move)

Description:
	Logically inclusive OR the source operand S with bits 47-24 of the
destination operand D and store the result in bits 47-24 of the
destination accumulator. This instruction is a 24-bit operation. The
remaining bits of the destination operand D are not affected.

Example:
OR	Y1,B	BA,L:$1234	;save A1,B1, OR Y1 with B

Before Execution:
	Y1 = $FF0000
	B  = $00:123456:789ABC

After Execution:
	Y1 = $FF0000
	B  = $00:FF3256:789ABC

Explanation of Example:
	Prior to execution, the 24-bit Y1 register contains the value
$FF0000, and the 56-bit B accumulator contains the value
$00:123456:789ABC. The OR Y1,B instruction logically ORs the 24-bit
value in the Y1 register with bits 47-24 of the B accumulator (B1)
and stores the result in the B accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 A or B result are zero
	{V}- Always cleared

Instruction Format:
	OR	S,D

	S = (X0,X0,X1,Y1)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ORI}						OR Immediate with Control Register

Operation:
	#xx + D -> D
	where + denotes the logical inclusive OR operator

Assembler Syntax:
	OR(I)	#xx,D

Description:
	Logically OR the 8-bit immediate operand (#xx) with the contents
of the destination control register D and store the result in the
destination control register. The condition code are affected only when
the condition code register (CCR) is specified as the destination
operand.

Restrictions:
	The ORI #xx,MR instruction cannot be used immediately before an
ENDDO or RTI instruction and cannot be one of the last three
instructions in a DO loop (at LA-2, LA-1, or LA).

	Example:
	ORI	#$8,MR		;set scaling mode bit S1 to scale up

Before Execution:
	MR = $03
After Execution:
	MR = $0B

Explanation of Example:
	Prior to execution, the 8-bit mode register (MR)
contains the value $03. The ORI #$8,MR instruction logically ORs
the immediate 8-bit value $8 with the contents of the
mode register and stores the result in the mode register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	For CCR Operand:
	{L}- Set if bit 6 of the immediate operand is cleared
	{E}- Set if bit 5 of the immediate operand is cleared
	{U}- Set if bit 4 of the immediate operand is cleared
	{N}- Set if bit 3 of the immediate operand is cleared
	{Z}- Set if bit 2 of the immediate operand is cleared
	{V}- Set if bit 1 of the immediate operand is cleared
	{C}- Set if bit 0 of the immediate operand is cleared

	For MR and OMR Operands:
	The condition codes are not affected using these operands.

Instruction Format:
	ORI	#xx,D

	D = (MR,CCR,OMR)

Timing:		2 oscillator clock cycles

Memory:		1 program word


{REP}						Repeat Next Instruction

Operation:
	LC -> TEMP; X:<ea> -> LC or
	LC -> TEMP; X:<aa> -> LC or
	LC -> TEMP; Y:<ea> -> LC or
	LC -> TEMP; Y:<aa> -> LC or
	LC -> TEMP; S -> LC      or
	LC -> TEMP; #xxx -> LC

	Repeat next instruction until LC=1
	TEMP -> LC

Assembler syntax:
	REP	X:<ea>
	REP	X:<aa>
	REP	Y:<ea>
	REP	Y:<aa>
	REP	S
	REP	#xxx

Description:
	Repeat the SINGLE-WORD INSTRUCTION immediately following the REP
instruction the specified number of times. The value specifying the
number of times the given instruction is to be repeated is loaded into
the 16-bit loop counter {LC} register. The single-word instruction is
then executed the specified number of times, decrementing the loop counter
(LC) after each execution until LC=1. When the REP instruction is in effect,
the repeated instruction is fetched only one time, and it remains in the
instruction register for the duration of the loop count. Thus, THE REP
INSTRUCTION IS NOT INTERRUPTIBLE (sequential repeats are also not
interruptible). The current loop counter (LC) value is stored in an internal
temporary register. If LC is set equal to zero, the instruction is repeated
65,536 times. The instruction's effective address specifies the address of
the value wich is to be loaded into the loop counter (LC). All address
register indirect adressing modes may be used. The absolute short and the
immediate short addressing modes may also be used. The four MS bits of the
12-bit immediate value are zeroed to form the 16-bit value that is to be
loaded into the loop counter (LC).

	If the {A} or {B} accumulator is specified as a SOURCE operand, the
accumulator value is optionally shifted according to the scaling mode bits
S0 and S1 in the system status register (SR). If the data out the shifter
indicates that the accumulator extension is in use, the value to be loaded
into the loop counter (LC) register will be limited to a 24-bit maximum
positive or negative saturation constant to minimize the error due to
truncation. The LS 16 bits of the resulting 24-bit value are then stored
in the 16-bit loop counter (LC) register.

	If the system stack register {SSH} is specified as a source operand, the
system stack pointer {SP} is postdecremented by 1 after {SSH} has been read.

Restrictions:
	The REP instruction can repeat any single-word instruction except the REP
instruction itself and any instruction that changes program flow. The
following instructions are not allowed to follow an REP instruction:

IMMEDIATELY AFTER REP

	DO			JSSET
	Jcc			REP
	JCLR		RTI
	JMP			RTS
	JSET		STOP
	JScc		SWI
	JSCLR		WAIT
	JSR

	Also a REP instruction cannot be the LAST instruction in a DO loop
(at LA). The assembler will generate an error if any of the previous
instructions are found immediately following an REP instruction.

Example:
REP	X0					;repeat (X0) times
MAC	X1,Y1,A X:(R1)+,X1 Y:(R4)+,Y1	;X1*Y1+A -> A, update X1,Y1

Before execution:
	X0 = $000100
	LC = $0000

After execution:
	X0 = $000100
	LC = $0100

Explanation of example:
	Prior to execution, the 24-bit X0 register contains the value $000100,
and the 16-bit loop counter (LC) register contains the value $0000. The
execution of the REP X0 instruction takes the 24-bit value in the X0
register, truncates the MS 8 bits, and stores the 16 LS bits in the 16-bit
loop counter (LC) register. Thus, the single-word MAC instruction
immediately following the REP instruction is repeated $100 times.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting occured using A or B as source operands

Instruction format:
	REP	X:<ea>
	REP	X:<aa>
	REP	Y:<ea>
	REP	Y:<aa>
	REP	S
	REP	#xxx

	ea = (Rn)-Nn
		 (Rn)+Nn
		 (Rn)-
		 (Rn)+
		 (Rn)
		 (Rn+Nn)
		 -(Rn)

	aa = 6-bit Absolute Short Address

	#xxx = 12-bit Immediate Short Data

	S = (X0,Y0,X1,Y1,A2,A1,A0,B2,B1,B0,A,B,R0-R7
		 N0-N7,M0-M7,SR,OMR,SP,SSH,SSL,LA,LC)

Timing:		4 oscillator clock cycles

Memory:		1 program word


{RESET}					Reset On-Chip Peripheral Devices

Operation:
	Reset the interrupt priority register and all on-chip peripherals

Assembler Syntax:
	RESET

Description:
	Reset the interrupt priority register and all on-chip peripherals.
This is a SOFTWARE RESET wich is NOT equivalent to a hardware reset since
only on-chip peripherals and the interrupt structure are affected. the
processor state is not affected, and execution continues with the next
instruction. All interrupt sources are disabled except for the trace,
stack error, NMI, illegal instruction, and hardware reset interrupts.

Restrictions:
	A RESET instruction cannot be the last instruction in a DO loop (at LA).

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	RESET

Timing:		4 oscillator clock cycles

Memory:		1 program word


{RND}						Round Accumulator

Operation:
	D+r -> D (parallel move)

Assembler Syntax:
	RND	D (parallel move)

Description:
	Round the 56-bit value in the specified destination operand D and store
the result in the MSP portion of the destination accumulator (A1 or B1).
This instruction uses a convergent rounding technique. The contribution
of the LS bits of the result (A0 and B0) is rounded into the upper portion
of the result (A1 or B1) by adding a rounding constant to the LS bits of
the result. The MSP portion of the destination accumulator contains the
rounded result wich may be read out to the data buses.

	The value of the rounding constant added is determined by the scaling
mode bits S0 and S1 in the system register (SR). A "1" is added in the
rounding position as shown below:

				  Rounding		Rounding Constant
S1	S0	Scaling Mode	Pos.	55-25	24	23	22	21-0
-----------------------------------------------------------------------------
0	0	No Scaling	23	0...0	0	1	0	0...0
0	1	Scale Down	24	0...0	1	0	0	0...0
1	0	Scale Up	22	0...0	0	0	1	0...0

	Normal or "standard" rounding consists of adding a rounding constant
to a given number of LS bits of a value to produce a rounded result. The
rounding constant depends on the scaling mode being used as previously
shown. Unfortunately, when using a twos-complement data representation,
this process introduces a positive bias in the statistical distribution
of the roundoff .error.

	Convergent rounding differs from "standard" rounding in that convergent
rounding attempts to remove the aforementioned positive bias by equally
distributing the round-off error. The convergent rounding technique
initially performs "standard" rounding as previously described. Again, the
rounding constant depends on the scaling mode being used. Once "standard"
rounding has been done, the convergent rounding method tests the result to
determine if ALL bits INCLUDING AND TO THE RIGHT of the rounding position
are ZERO. IF, AND ONLY IF, this SPECIAL CONDITION is true, the convergent
rounding method will clear the bit immediately to the LEFT of the rounding
position. When this special condition is true, numbers wich have a "1" in
the bit immediately to the left of the rounding position are rounded UP;
numbers with a "0" in the bit immediately to the left of the rounding
position are rounded DOWN. Thus, these numbers are rounded UP HALF the
time and rounded DOWN the rest of the time. Therefore, THE ROUNDOFF ERROR
AVERAGES OUT TO ZERO. The LS bits of the convergently rounded result are
cleared so that the rounded result may be immediately used by the next
instruction.

Example:
	RND	A	#$123456,X1	B,Y1	;round A accumulator into A1, zero A0

Before execution:

	Case 1:	A = $00:123456:789ABC
	Case 2: A = $00:123456:800000
	Case 3: A = $00:123455:800000

After execution:

	Case 1:	A = $00:123456:000000
	Case 2: A = $00:123456:000000
	Case 3: A = $00:123456:000000

Explanation of Example:
	Prior to execution, the 56-bit A accumulator countains the value
$00:123456:789ABC for case 1, the value $00:123456:800000 for case 2, and
the value $00:123455:800000 for case 3. The execution of the RND A
instruction rounds the value in the A accumulator into the MSP portion
of the A accumulator (A1), using wonvergent rounding, and then zeros
the LSP portion of the A accumulator (A0). Note that case 2 is the special
case that distinguishes convergent rounding from standard or biased rounding.


Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting or overflow has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result are zero
	{V}- Set if overflow has occured in A or B result

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	RND D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ROL}						Rotate Left

Operation:

	     47        24
	    +------------+
	<-C-|<-----------|<-+  (parallel move)
	|   +------------+  |
	+-------------------+

Assembler Syntax:
	ROL	D (parallel move)

Description:
	Rotate bits 47-24 of the destination operand D one bit to
the left and store the result in the destination accumulator. Prior to
instruction execution, bit 47 of D is shifted into the carry bit C, and,
prior to instruction execution, the value in the carry bit C is shifted into
bit 24 of the destination accumulator D. This instruction is a 24-bit
operation. The remaining bits of the destination operand D are not affected.

Example:
	ROL	A	#$314,N2	;rotate A1 left one bit, update N2

Before execution:
	A  = $00:000000:000000
	SR = $0301

After execution:
	A  = $00:000001:000000
	SR = $0300

Explanation of Example:
	Prior to execution, the 56-bit A accumulator countains the value
$00:000000:00000. The execution of the ROL A instruction shifts the
24-bit value in the A1 register one bit to the left, shifting bit 47 into
the carry bit C,rotating the carry bit C into bit 24, and storing the
result back in the A1 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 of A or B result are zero
	{V}- Always cleared
	{C}- Set if bit 47 of A or B was set prior to instruction execution

Instruction Format:
	ROR D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{ROR}						Rotate Right

Operation:

	     47        24
	    +------------+
	+C->|----------->|->-+	(parallel move)
	|   +------------+   |
	+--------------------+

Assembler Syntax:
	ROR	D				(parallel move)

Description:
	Rotate bits 47-24 of the destination operand D one bit to
the right and store the result in the destination accumulator. Prior to
instruction execution, bit 24 of D is shifted into the carry bit C, and,
prior to instruction execution, the value in the carry bit C is shifted
into bit 47 of the destination accumulator D. This instruction is a 24-bit
operation. The remaining bits of the destination operand D are not affected.

Example:
	ROR	B	#$1234,R2	; rotate B1 right
				; one bit, update R2

Before execution:
	B  = $00:000001:222222
	SR = $0300

After execution:
	B  = $00:000000:222222
	SR = $0305

Explanation of Example:
	Prior to execution, the 56-bit B accumulator countains the
value $00:000001:222222. The execution of the ROR B instruction shifts the
24-bit value in the B1 register one bit to the right, shifting bit 24 into
the carry bit C,rotating the carry bit C into bit 47, and storing the
result back in the B1 register.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{N}- Set if bit 47 of A or B result is set
	{Z}- Set if bits 47-24 of A or B result are zero
	{V}- Always cleared
	{C}- Set if bit 47 of A or B was set prior to
	      instruction execution

Instruction Format:
	ROR D

	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{RTI}						Return from Interrupt

Operation:
	SSH -> PC
	SSL -> SR
	SP - 1 -> SP

Assembler Syntax:
	RTI

Description:
	Pull the program counter (PC) and the status register (SR)
from the stack. The previous program counter and status register are lost.

Restrictions:
	Due to pipelining in the program controller and the fact
that the RTI instruction accesses certain controller registers, the RTI
instruction must be immediately preceded by any of the following
instructions:

Immediately before RTI:
	MOVEC to LA, LC, SSH, SSL, or SP
	MOVEM to LA, LC, SSH, SSL, or SP
	MOVEP to LA, LC, SSH, SSL, or SP
	MOVEC from SSH
	MOVEM from SSH
	MOVEP from SSH
	ANDI MR or ANDI CCR
	ORI MR or ORI CCR


An RTI instruction cannot be the LAST instruction in a DO loop (at LA).
An RTI instruction cannot be repeated using the REP instruction.

Condition Codes:

	{L}- Set according to the value pulled from the stack
	{E}- Set according to the value pulled from the stack
	{U}- Set according to the value pulled from the stack
	{N}- Set according to the value pulled from the stack
	{Z}- Set according to the value pulled from the stack
	{V}- Set according to the value pulled from the stack
	{C}- Set according to the value pulled from the stack


Instruction Format:
	RTI

Timing:		4+rx oscillator clock cycles

Memory:		1 program word


{RTS}						Return from Subroutine

Operation:
	SSH -> PC; SP - 1 -> SP

Assembler Syntax:
	RTS

Description:
	Pull the program counter (PC) from the stack. The previous program
counter is lost. The status register (SR) is not affected.

Restrictions:
	Due to pipelining in the program controller and the fact that the
RTS instruction accesses certain controller registers, the RTS
instruction must be immediately preceded by any of the following
instructions:

Immediately before RTS:
	MOVEC to LA, LC, SSH, SSL, or SP
	MOVEM to LA, LC, SSH, SSL, or SP
	MOVEP to LA, LC, SSH, SSL, or SP
	MOVEC from SSH
	MOVEM from SSH
	MOVEP from SSH


	An RTS instruction cannot be the LAST instruction in a DO
loop (at LA).

	An RTS instruction cannot be repeated using the REP instruction.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	RTS

Timing:		4+rx oscillator clock cycles

Memory:		1 program word


{SBC}						Subtract Long with Carry

Operation:
	D - S - C -> D		(parallel move)

Assembler Syntax:
	SBC	S,D				(parallel move)

Description:
	subtract the source operand S and the carry bit C of the condition
code register from the destination operand D and store the result in the
destination accumulator. Long words (48 bits) may be subtracted to the
(56-bit) destination accumulator.

NOTE: The carry bit is set correctly for multiple precision arithmetic
using long word operands if the extension register of the destination
accumulator (A2 or B2) is the sign extension of bit 47 of the
destination accumulator (A or B).

Example:
	MOVE	L:<$0,X			;get a 48-bit LS long-word operand in X
	MOVE	L:<$1,A			;get other LS long word in A (Sing ext.)
	MOVE	L:<$2,Y			;get a 48-bit MS long-word operand in Y
	SUB	X,A	L:<$3,B		;sub LS words; get other MS word in B
	SBC	Y,B	A10,L:<$4	;sub MS words with carry, save LS sum
	MOVE	B10,L:<$5		;save MS difference

	Before Execution:
		A = $00:000000:000000
		X = $800000:000000
		B = $00:000000:000003
		Y = $000000:000001

	After Execution:
		A = $00:800000:000000
		X = $800000:000000
		B = $00:000000:000001
		Y = $000000:000001

Explanation of Example:
	This example illustrate long-word double-precision (96-bit) subtraction
using the SBC instruction. Prior to execution of the SUB and SBC
instructions, the double-precision 96-bit value
$000000:000001:800000:000000 is loaded into the Y and X registers (Y:X),
respectively. The other double-precision 96-bit value
$000000:000003:000000:000000 is loaded into the B and A accumulators
(B:A), respectively. Since the 48-bit value loaded into the A
accumulator is automatically sign extended to 56 bits and the other
48-bit long-word operand is internally sign extended to 56 bits during
instruction execution, the carry bit wil be set correctly after the
execution of the SUB X,A instruction. The SBC Y,B instruction then
produces the correct MS 56-bit result. The actual 96-bit result is
stored in memory using the A10 and B10 operands (instead of A and B)
because shifting and limiting is not desired.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	SBC	S,D

	S = (X,Y)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{STOP}						Stop Instruction Processing

Operation:
	Enter the STOP processing state and stop the clock oscillator

Assembler Syntax:
	STOP

Description:
	Enter the STOP processing state. All activity in the processor is
suspended until the RESET or IRQA pin is asserted. The clock escillator
is gated off internally. The STOP processing state is a low-power standby
state.

	During the STOP state, port A is in an idle state with the control
signals held inactive (I.E., RD=WR=VCC etc.), the data pins (D0-D23) are
high impedance, and the address pins (A1-A15) are unchanged from the
previous instruction. If the bus grant was asserted when the STOP
instruction was executed, port A will remain three-stated until the
DSP exits the STOP state.

	If the exit from the STOP state was caused by a low level on the
RESET pin, then the processor will enter the reset processing state.
The time to recover from the STOP state using RESET will depend on the
oscillator used.

	If the exit from the STOP state was caused by a low level on the IRQA
pin, then the processor will service the highest priority pending interrupt
and will not service the IRQA interrupt unless it is highest priority. The
interrupt will be serviced after an internal delay counter counts 65,536
clock cycles (or a three clock cycle delay if the stop delay bit in the
OMR is set to one) plus 17T. During this clock stabilization count delay,
all peripherals and external interrupts are cleared and
re-enabled/arbitrated at the start of the 17T period following the count
interval. The processor will resume program execution at the instruction
following the STOP instruction that caused the entry into the STOP state
after the delay count plus 17T. If the IRQA pin is asserted when the STOP
instruction is executed, the clock will not be gated off, and the internal
delay counter will be started.

Restrictions:
	A STOP instruction cannot be used in a fast interrupt routine.
	A STOP instruction cannot be the last instruction in a DO loop (at LA).
	A STOP instruction cannot be repeated using REP instruction.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	STOP

Timing:		The STOP instruction disable the internal clock oscillator
and internal distribution of the external clock.

Memory:		1 program word


{SUB}						Subtract

Operation:
	D - S -> D			(parallel move)

Assembler Syntax:
	SUB	S,D				(parallel move)

Description:
	Subtract the source operand S from the destination operand D and
store the result in the destination operand D. Words (24 bits), long
words (48 bits), and accumulators (56 bits) may be added to the
destination accumulator.

NOTE: The carry bit is set correctly using word and long-word source
operands if the extension register of the destination accumulator (A2
or B2) is the sign extension of bit 47 of the destination accumulator
(A or B). The carry bit is always set correctly using accumulator
source operands.

Example:
	SUB	X1,A	X:(R2)+	N2,R0	;24-bit subtract, load R0, update R2

Before Execution:
	X1 = $000003
	A  = $00:000058:242424

After Execution:
	X1 = $000003
	A  = $00:000055:242424

Explanation of Example:
	Prior to execution, the 24-bit X1 register contains the value
$000003 and the 56-bit A accumulator contains the value $00:000058:242424.
The SUB instruction automatically appends the 24-bit value in the X1
register with 24 LS zeros, sign extends the resulting 48-bit long word
to 56 bits, and subtracts the result to the 56-bit A accumulator. Thus,
24-bit operands are subtracted from the MSP portion of A or B (A1 or B1)
because all arithmetic instructions assume a fractional, twos complement
data representation. Note that 24-bit operands can be subtracted from the
LSP portion of A or B (A0 or B0) by loading the 24-bit operand into X0 or
Y0, forming a 48-bit word by loading X1 or Y1 with the sign extension of
X0 or Y0 and executing an SUB X,A or SUB Y,A instruction.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result
	
NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	SUB	S,D

	S = (A,B,X,Y,X0,Y0,X1,Y1)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{SUBL}						Shift Left and Subtract Accumulators

Operation:
	2*D - S -> D		(parallel move)

Assembler Syntax:
	SUBL	S,D			(parallel move)

Description:
	Subtract the source operand S from two times the destination operand D
and store the result in the destination accumulator. The destination
operand D is arithmecally shifted one bit to the left, and a zero is
shifted into the LS bit of D prior to the subtraction operation. The carry
bit is set correctly if the source operand does not overflow as a
result of the left shift operation. The overflow bit may be set as a result
of either the shifting or addition operation (or both). This instruction is
useful for efficient divide and decimation in time (DIT) FFT algorithms.

Example:
	SUBL	A,B	Y:(R5+N5),R7		;2*B-A -> B, load R7, no R5 update

Before Execution:
	A = $00:004000:000000
	B = $00:005000:000000

After Execution:
	A = $00:004000:000000
	B = $00:006000:000000

Explanation of example:
	Prior to execution, the 56-bit accumulator contains the value
$00:004000:000000, and the 56-bit B accumulator contains the value
$00:005000:000000. The SUBL A,B instruction subtracts the value
in the A accumulator from two times the value in the A accumulator
and stores the 56-bit result in the B accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result or if the MS bit of
	   the destination operand is changed as a result of the instruction's
	   left shift
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	SUBL	S,D

	S = (A,B)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{SUBR}						Shift Right and Subtract Accumulators

Operation:
	D / 2 - S -> D		(parallel move)

Assembler Syntax:
	SUBR	S,D			(parallel move)

Description:
	Subtract the source operand S from one-half the destination operand
D and store the result in the destination accumulator. The destination
operand D is arithmetically shifted one bit to the right while the MS
bit of D is held constant prior to the subtract operation. In contrast
to the SUBL instruction, the carry bit is always set correctly, and the
overflow bit can only be set by the addition operation and not by an
overflow due to the initial shifting operation. This instuction is
useful for efficient divide and decimation in time (DIT) FFT algorithms.

Example:
	SUBR	B,A	N5,Y:-(R5)		;A/2 - B -> A, update R5, save N5

Before execution:
	A = $80:000000:2468AC
	B = $00:000000:123456
After execution:
	A = $C0:000000:000000
	B = $00:000000:123456

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$80:000000:2468AC, and the 56-bit accumulator contains the value
$00:000000:123456. The SUBR B,A instruction subtract the value in
the B accumulator from one-half the value in the A accumulator and
stores the 56-bit result in the A accumulator.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if limiting (parallel move) or overflow has occured in result
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Set if overflow has occured in A or B result
	{C}- Set if a carry (or borrow) occurs from bit 55 of A or B result

NOTE: The definition of the E and U bits varies according to the
scaling mode being used.

Instruction Format:
	SUBR	S,D

	S = (A,B)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{SWI}						Software Interrupt

Operation:
	Begin SWI exception processing

Assembler Syntax:
	SWI

Description:
	Suspend normal instruction execution and begin SWI exception processing.
The interrupt priority level (I1,I0) is set to 3 in the status register (SR)
if a long interrupt service routine is used.

Restrictions:
	An SWI instruction cannot be used in a fast interrupt routine.
	An SWI instruction cannot be repeated using REP instruction.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	SWI

Timing:		8 oscillator clock cycles

Memory:		1 program word


{Tcc}						Transfer Conditionally{TCC}{TCS}{TEC}{TEQ}{TES}{TGE}{TGT}{TLC}{TLE}{TLS}{TLT}{TMI}{TNE}{TNR}{TPL}{TNN}

Operation:
	If cc, then S1 -> D1
	If cc, then S1 -> D1 and S2 -> D2

Assembler Syntax:
	Tcc S1,D1
	Tcc S1,D1 S2,D2

Description:
	Transfer data from the specified source register S1 to the specified
destination accumulator D1 if the specified condition is true. If a second
source register S2 and a second destination register D2 are also specified,
transfer data from address register S2 to address register D2 if the
specified condition is true. If the specified condition is false, a NOP
is executed. The term "cc" may specify the following conditions:

	"cc" Mnemonic								Condition	
	CC (HS) - carry clear (higher or same)		C = 0
	CS (LO) - carry set (lower)					C = 1
	EC	- extension clear						E = 0
	EQ	- equal									Z = 1
	ES	- extension set							E = 1
	GE	- greater than or equal					N^V = 0
	GT	- greater than							Z+(N^V) = 0
	LC	- limit clear							L = 0
	LE	- less than or equal					Z+(N^V) = 1
	LS	- limit set								L = 1
	LT	- less than								N^V = 1
	MI	- minus									N = 1
	NE	- not equal								Z = 0
	NR	- normalized							Z+(~U & ~E) = 1
	PL	- plus									N = 0
	NN	- not normalized						Z+(~U & ~E) = 0

	where
	~ denote the logical complement,
	+ denotes the logical OR operator,
	& denotes the logical AND operator, and
	^ denotes the logical Exclusive OR operator.

	When used after the CMP or CMPM instructions, the Tcc instruction
can perform many useful functions such as a "maximum value", "minimum value"
 "maximum absolute value" or "minimum absolute value" function. The desired
value is stored in the destination accumulator D1. If address register S2
is used as an address pointer into an array of data, the address of the
desired value is stored in the address register D2. The Tcc instruction
may be used after any instruction and allows efficient searching and
sorting algorithms. The Tcc instruction uses the internal data ALU paths
and internal address ALU paths. The Tcc instruction does not affect the
condition code bits.

Note: This instruction is considered to be a move-type instruction.
Due to pipelining, if an address register (R0-R7) is changed using a
move-type instruction, the new contents of the destination address
register will not be available for use during the following instruction
(i.e., there is a single instruction cycle pipeline delay).

Example:
	CMP	X0,A		;compare X0 and A (sort for minimum)
	TGT	X0,A	R0,R1	;transfer X0->A and R0->R1 if X0<A

Explanation of Example:
	In this example, the contents of the 24-bit X0 register are
transferred to the 56-bit A accumulator, and the contents of the 16-bit
R0 address register are transferred to the 16-bit R1 address register if
the specified condition is true. If the specified condition is not true,
a NOP is executed.


Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Formats:
	Tcc	S1,D1
	Tcc	S1,D1	S2,D2

	S1 = (A,B,X0,Y0,X1,Y1)
	D1 = (A,B)

	S2 = (Rn)
	D2 = (Rn)

Timing:		2 oscillator clock cycles

Memory:		1 program word


{TFR}						Transfer Data ALU Register

Operation:
	S -> D				(parallel move)

Assembler Syntax:
	TFR S,D				(parallel move)

Description:
	Transfer data from the specified source data ALU register S to the
specified destination data ALU accumulator D. TFR uses the internal data
ALU data paths; thus, data DO NOT pass through the data shifter/limiters.
This allows the full 56-bit contents of one of the accumulatorsto be
transferred into the other accumulator WITHOUT data shifting and/or
limiting. Moreover, since TFR uses the internal data ALU data paths,
parallel moves are possible. The TFR instruction only affects the L
condition code bit, wich can be set by data limiting associated with the
instruction's parallel move operations.

Example:
	TFR	A,B	A,X1	Y:((R4+N4),Y0	;move A to B and X1, update Y0

	Before Execution:
	A  = $01:234567:89ABCD
	B  = $FF:FFFFFF:FFFFFF

	After Execution:
	A  = $01:234567:89ABCD
	B  = $01:234567:89ABCD

Explanation of Example:
	Prior to execution, the 56-bit A accumulator contains the value
$01:234567:89ABCD, and the 56-bit B accumulator contains the value
$FF:FFFFFF:FFFFFF. The execution of the TFR A,B instruction moves the
56-bit value in the A accumulator into the 56-bit B accumulator using
the internal data ALU data paths without any data shifting and/or limiting.
The value in the B accumulator WOULD have been limited if a MOVE A,B
instruction had been used. Note, however, that the parallel move portion
of the TFR instruction DOES use the data shifter/limiter. Thus, the value
stored in the 24-bit X1 register (not shown) WOULD have been limited in
this example. This instruction illustrate a TRIPLE move instruction.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move

Instruction Format:
	TFR	S,D

	S = (A,B,X0,Y0,X1,Y1)
	D = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{TST}						Test Accumulator

Operation:
	S - 0				(parallel move)

Assembler Syntax:
	TST S				(parallel move)

Description:
	Compare the specified source accumulator S with zero and set the
condition codes accordingly. No result is stored although the condition
codes are updated.

Condition Codes:

	 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|LF|**| T|**|S1|S0|I1|I0|**| L| E| U| N| Z| V| C|
	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	|<-           {MR}         ->|<-       {CCR}      ->|

	{L}- Set if data limiting has occured during parallel move
	{E}- Set if the signed integer portion of A or B result is in use
	{U}- Set if A or B result is unnormalized
	{N}- Set if bit 55 of A or B result is set
	{Z}- Set if A or B result equals zero
	{V}- Always cleared

NOTE: The definition of the E and U bits varies according to the scaling
mode being used.

Instruction Format:
	TST	S

	S = (A,B)

Timing:		2 + mv oscillator clock cycles

Memory:		1 + mv program words


{WAIT}						Wait for Interrupt

Operation:
	Disable clocks to the processor core and enter the WAIT processing
state.

Assembler Syntax:
	WAIT

Description:
	Enter the WAIT processing state. The internal clocks to the processor
core and memories are gated off, and all activity in the processor is
suspended until an unmasked interrupt occurs. The clock oscillator and
the internal I/O peripheral clocks remain active. If WAIT is executed
when an interrupt is pending, the interrupt will be processed; the effect
will be the same as if the processor never entered the WAIT state and
three NOPs followed the WAIT instruction. When an unmasked interrupt or
external (hardware) processor RESET occurs, the processor leave the WAIT
state and begins exception processing of the unmasked interrupt or RESET
condition. The BR/BG circuits remain active during the WAIT state. The WAIT
state is a low-power standby state. The processor always leave the WAIT
state in the T2 clock phase. Therefore, multiple processors may be
synchronized by having them all enter the WAIT state and then interrupting
them with a common interrupt.

Restrictions:
	A WAIT instruction cannot be used in a fast interrupt routine.
	A WAIT instruction cannot be the last instruction in a DO loop (at LA).
	A WAIT instruction cannot be repeated using REP instruction.

Condition Codes:
	The condition codes are not affected by this instruction.

Instruction Format:
	WAIT

Timing:		The WAIT instruction takes a minimum of 16 cycles to execute
when an internal interrupt is pending during the execution of the WAIT
instruction.

Memory:		1 program word


