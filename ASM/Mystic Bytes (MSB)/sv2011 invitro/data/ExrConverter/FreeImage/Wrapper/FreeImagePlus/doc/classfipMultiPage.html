<HTML>
<HEAD>
<TITLE>FreeImagePlus</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>fipMultiPage Class Reference</h1><!-- doxytag: class="fipMultiPage" --><!-- doxytag: inherits="fipObject" --><code>#include &lt;<a class="el" href="FreeImagePlus_8h-source.html">FreeImagePlus.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for fipMultiPage:</div>
<div class="dynsection">

<p><center><img src="classfipMultiPage.png" usemap="#fipMultiPage_map" border="0" alt=""></center>
<map name="fipMultiPage_map">
<area href="classfipObject.html" alt="fipObject" shape="rect" coords="0,0,82,24">
</map>
</div>

<p>
<a href="classfipMultiPage-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Multi-page file stream. 
<p>
<a class="el" href="classfipMultiPage.html" title="Multi-page file stream.">fipMultiPage</a> encapsulates the multi-page API. It supports reading/writing multi-page TIFF, ICO and GIF files. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#8f29aa89580db03b3d7f5dd45841358a">fipMultiPage</a> (BOOL keep_cache_in_memory=FALSE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#8f29aa89580db03b3d7f5dd45841358a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#6003c7145f37ac6403fb3f44098c951f">~fipMultiPage</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor Close the file stream if not already done.  <a href="#6003c7145f37ac6403fb3f44098c951f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#f71902acb54dcfb2b35107b47a303cd7">isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if the multi-page stream is opened.  <a href="#f71902acb54dcfb2b35107b47a303cd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#bef1676bf6d03db05df6f717c1a72813">operator FIMULTIBITMAP *</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the FIMULTIBITMAP data.  <a href="#bef1676bf6d03db05df6f717c1a72813"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#e2b5dce78d3907c8af0097f9c00a597f">open</a> (const char *lpszPathName, BOOL create_new, BOOL read_only, int flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a multi-page file stream.  <a href="#e2b5dce78d3907c8af0097f9c00a597f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#3ccbb6d4de6d2f2dfc4ab7f59f5f3a5c">open</a> (<a class="el" href="classfipMemoryIO.html">fipMemoryIO</a> &amp;memIO, int flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a multi-page memory stream as read/write.  <a href="#3ccbb6d4de6d2f2dfc4ab7f59f5f3a5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#188729e51191b2c40a143bdf7e85c21b">open</a> (FreeImageIO *io, fi_handle handle, int flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a multi-page image as read/write, using the specified FreeImageIO struct and fi_handle, and an optional flag.  <a href="#188729e51191b2c40a143bdf7e85c21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#91d955507a995f6439f1d5f26722c6c5">close</a> (int flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a file stream.  <a href="#91d955507a995f6439f1d5f26722c6c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#61e88a4558f8bf83e214b7af087644d4">saveToHandle</a> (FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves a multi-page image using the specified FreeImageIO struct and fi_handle, and an optional flag.  <a href="#61e88a4558f8bf83e214b7af087644d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#9f3053679f574e9d1de96adf9f76579b">saveToMemory</a> (FREE_IMAGE_FORMAT fif, <a class="el" href="classfipMemoryIO.html">fipMemoryIO</a> &amp;memIO, int flags=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves a multi-page image using the specified memory stream and an optional flag.  <a href="#9f3053679f574e9d1de96adf9f76579b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#32ede1504c5d6f613eb01442b5e98af5">getPageCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of pages currently available in the multi-paged bitmap.  <a href="#32ede1504c5d6f613eb01442b5e98af5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#2d46fced03c663079e8faea2fa748c4e">appendPage</a> (<a class="el" href="classfipImage.html">fipImage</a> &amp;image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a new page to the end of the bitmap.  <a href="#2d46fced03c663079e8faea2fa748c4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#ff5679c8622481acb8f5d3545ef39cab">insertPage</a> (int page, <a class="el" href="classfipImage.html">fipImage</a> &amp;image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new page before the given position in the bitmap.  <a href="#ff5679c8622481acb8f5d3545ef39cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#6c0e48a23d2d905267d079c032c81646">deletePage</a> (int page)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the page on the given position.  <a href="#6c0e48a23d2d905267d079c032c81646"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#ebf864bb0a80904f969015cf87ee1059">movePage</a> (int target, int source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the source page to the position of the target page.  <a href="#ebf864bb0a80904f969015cf87ee1059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FIBITMAP *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#1a89d21aebc6f9078b57ba5edffd6b87">lockPage</a> (int page)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks a page in memory for editing.  <a href="#1a89d21aebc6f9078b57ba5edffd6b87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#0549fa7f8a9d99cc218337ce6bf3ae4c">unlockPage</a> (<a class="el" href="classfipImage.html">fipImage</a> &amp;image, BOOL changed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks a previously locked page and gives it back to the multi-page engine.  <a href="#0549fa7f8a9d99cc218337ce6bf3ae4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#1d5dd1f8aae45ab20c9abc23401af3c5">getLockedPageNumbers</a> (int *pages, int *count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of page-numbers that are currently locked in memory.  <a href="#1d5dd1f8aae45ab20c9abc23401af3c5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FIMULTIBITMAP *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#ee3486c81392488e48efd978f0d6e83b">_mpage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a multi-page file stream.  <a href="#ee3486c81392488e48efd978f0d6e83b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfipMultiPage.html#a9a56c170df363f7bc9750dc649e92ac">_bMemoryCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TRUE when using a memory cache, FALSE otherwise.  <a href="#a9a56c170df363f7bc9750dc649e92ac"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8f29aa89580db03b3d7f5dd45841358a"></a><!-- doxytag: member="fipMultiPage::fipMultiPage" ref="8f29aa89580db03b3d7f5dd45841358a" args="(BOOL keep_cache_in_memory=FALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fipMultiPage::fipMultiPage           </td>
          <td>(</td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>keep_cache_in_memory</em> = <code>FALSE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keep_cache_in_memory</em>&nbsp;</td><td>When it is TRUE, all gathered bitmap data in the page manipulation process is kept in memory, otherwise it is lazily flushed to a temporary file on the hard disk in 64 Kb blocks. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6003c7145f37ac6403fb3f44098c951f"></a><!-- doxytag: member="fipMultiPage::~fipMultiPage" ref="6003c7145f37ac6403fb3f44098c951f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual fipMultiPage::~fipMultiPage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor Close the file stream if not already done. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f71902acb54dcfb2b35107b47a303cd7"></a><!-- doxytag: member="fipMultiPage::isValid" ref="f71902acb54dcfb2b35107b47a303cd7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns TRUE if the multi-page stream is opened. 
<p>

<p>Implements <a class="el" href="classfipObject.html#0fe8446f5665032bcf2089f08139b8cd">fipObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="bef1676bf6d03db05df6f717c1a72813"></a><!-- doxytag: member="fipMultiPage::operator FIMULTIBITMAP *" ref="bef1676bf6d03db05df6f717c1a72813" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fipMultiPage::operator FIMULTIBITMAP *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the FIMULTIBITMAP data. 
<p>
Used for direct access from FREEIMAGE functions or from your own low level C functions. 
</div>
</div><p>
<a class="anchor" name="e2b5dce78d3907c8af0097f9c00a597f"></a><!-- doxytag: member="fipMultiPage::open" ref="e2b5dce78d3907c8af0097f9c00a597f" args="(const char *lpszPathName, BOOL create_new, BOOL read_only, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>lpszPathName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>create_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>read_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a multi-page file stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lpszPathName</em>&nbsp;</td><td>Name of the multi-page bitmap file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>create_new</em>&nbsp;</td><td>When TRUE, it means that a new bitmap will be created rather than an existing one being opened </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read_only</em>&nbsp;</td><td>When TRUE the bitmap is opened read-only </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Load flags. The signification of this flag depends on the image to be loaded. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, returns FALSE otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_OpenMultiBitmap </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ccbb6d4de6d2f2dfc4ab7f59f5f3a5c"></a><!-- doxytag: member="fipMultiPage::open" ref="3ccbb6d4de6d2f2dfc4ab7f59f5f3a5c" args="(fipMemoryIO &amp;memIO, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::open           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfipMemoryIO.html">fipMemoryIO</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>memIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a multi-page memory stream as read/write. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memIO</em>&nbsp;</td><td>Memory stream. The memory stream MUST BE a wrapped user buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Load flags. The signification of this flag depends on the image to be loaded. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, returns FALSE otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_LoadMultiBitmapFromMemory </dd></dl>

</div>
</div><p>
<a class="anchor" name="188729e51191b2c40a143bdf7e85c21b"></a><!-- doxytag: member="fipMultiPage::open" ref="188729e51191b2c40a143bdf7e85c21b" args="(FreeImageIO *io, fi_handle handle, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::open           </td>
          <td>(</td>
          <td class="paramtype">FreeImageIO *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_handle&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a multi-page image as read/write, using the specified FreeImageIO struct and fi_handle, and an optional flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>io</em>&nbsp;</td><td>FreeImageIO structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>FreeImage fi_handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The signification of this flag depends on the image to be read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, FALSE otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_OpenMultiBitmapFromHandle </dd></dl>

</div>
</div><p>
<a class="anchor" name="91d955507a995f6439f1d5f26722c6c5"></a><!-- doxytag: member="fipMultiPage::close" ref="91d955507a995f6439f1d5f26722c6c5" args="(int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::close           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a file stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Save flags. The signification of this flag depends on the image to be saved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, returns FALSE otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_CloseMultiBitmap </dd></dl>

</div>
</div><p>
<a class="anchor" name="61e88a4558f8bf83e214b7af087644d4"></a><!-- doxytag: member="fipMultiPage::saveToHandle" ref="61e88a4558f8bf83e214b7af087644d4" args="(FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::saveToHandle           </td>
          <td>(</td>
          <td class="paramtype">FREE_IMAGE_FORMAT&nbsp;</td>
          <td class="paramname"> <em>fif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeImageIO *&nbsp;</td>
          <td class="paramname"> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_handle&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves a multi-page image using the specified FreeImageIO struct and fi_handle, and an optional flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fif</em>&nbsp;</td><td>Format identifier (FreeImage format) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io</em>&nbsp;</td><td>FreeImageIO structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>FreeImage fi_handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The signification of this flag depends on the multi-page image to be saved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, FALSE otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_SaveMultiBitmapToHandle, FreeImage documentation </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f3053679f574e9d1de96adf9f76579b"></a><!-- doxytag: member="fipMultiPage::saveToMemory" ref="9f3053679f574e9d1de96adf9f76579b" args="(FREE_IMAGE_FORMAT fif, fipMemoryIO &amp;memIO, int flags=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::saveToMemory           </td>
          <td>(</td>
          <td class="paramtype">FREE_IMAGE_FORMAT&nbsp;</td>
          <td class="paramname"> <em>fif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfipMemoryIO.html">fipMemoryIO</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>memIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves a multi-page image using the specified memory stream and an optional flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fif</em>&nbsp;</td><td>Format identifier (FreeImage format) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memIO</em>&nbsp;</td><td>FreeImage memory stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The signification of this flag depends on the image to be saved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, FALSE otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_SaveMultiBitmapToMemory, FreeImage documentation </dd></dl>

</div>
</div><p>
<a class="anchor" name="32ede1504c5d6f613eb01442b5e98af5"></a><!-- doxytag: member="fipMultiPage::getPageCount" ref="32ede1504c5d6f613eb01442b5e98af5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fipMultiPage::getPageCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of pages currently available in the multi-paged bitmap. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_GetPageCount </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d46fced03c663079e8faea2fa748c4e"></a><!-- doxytag: member="fipMultiPage::appendPage" ref="2d46fced03c663079e8faea2fa748c4e" args="(fipImage &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fipMultiPage::appendPage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfipImage.html">fipImage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a new page to the end of the bitmap. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Image to append </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_AppendPage </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff5679c8622481acb8f5d3545ef39cab"></a><!-- doxytag: member="fipMultiPage::insertPage" ref="ff5679c8622481acb8f5d3545ef39cab" args="(int page, fipImage &amp;image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fipMultiPage::insertPage           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfipImage.html">fipImage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new page before the given position in the bitmap. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page</em>&nbsp;</td><td>Page number. Page has to be a number smaller than the current number of pages available in the bitmap. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Image to insert </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_InsertPage </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c0e48a23d2d905267d079c032c81646"></a><!-- doxytag: member="fipMultiPage::deletePage" ref="6c0e48a23d2d905267d079c032c81646" args="(int page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fipMultiPage::deletePage           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the page on the given position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page</em>&nbsp;</td><td>Page number </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_DeletePage </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebf864bb0a80904f969015cf87ee1059"></a><!-- doxytag: member="fipMultiPage::movePage" ref="ebf864bb0a80904f969015cf87ee1059" args="(int target, int source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::movePage           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the source page to the position of the target page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target page position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source page position </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, returns FALSE otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_MovePage </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a89d21aebc6f9078b57ba5edffd6b87"></a><!-- doxytag: member="fipMultiPage::lockPage" ref="1a89d21aebc6f9078b57ba5edffd6b87" args="(int page)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FIBITMAP* fipMultiPage::lockPage           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks a page in memory for editing. 
<p>
You must call unlockPage to free the page<br>
 <b>Usage : </b><br>
 <pre>
	<a class="el" href="classfipMultiPage.html" title="Multi-page file stream.">fipMultiPage</a> mpage;
...
	<a class="el" href="classfipImage.html" title="A class used to manage all photo related images and all image types used by the library...">fipImage</a> image;		// You must declare this before
	image = mpage.lockPage(2);
	if(image.isValid()) {
...
	  mpage.unlockPage(image, TRUE);
	}
	</pre> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page</em>&nbsp;</td><td>Page number </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the page if successful, returns NULL otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_LockPage </dd></dl>

</div>
</div><p>
<a class="anchor" name="0549fa7f8a9d99cc218337ce6bf3ae4c"></a><!-- doxytag: member="fipMultiPage::unlockPage" ref="0549fa7f8a9d99cc218337ce6bf3ae4c" args="(fipImage &amp;image, BOOL changed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fipMultiPage::unlockPage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfipImage.html">fipImage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>changed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks a previously locked page and gives it back to the multi-page engine. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Page to unlock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changed</em>&nbsp;</td><td>When TRUE, the page is marked changed and the new page data is applied in the multi-page bitmap. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_UnlockPage </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d5dd1f8aae45ab20c9abc23401af3c5"></a><!-- doxytag: member="fipMultiPage::getLockedPageNumbers" ref="1d5dd1f8aae45ab20c9abc23401af3c5" args="(int *pages, int *count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL fipMultiPage::getLockedPageNumbers           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an array of page-numbers that are currently locked in memory. 
<p>
When the pages parameter is NULL, the size of the array is returned in the count variable. You can then allocate the array of the desired size and call getLockedPageNumbers again to populate the array. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns TRUE if successful, returns FALSE otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>FreeImage_GetLockedPageNumbers </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="ee3486c81392488e48efd978f0d6e83b"></a><!-- doxytag: member="fipMultiPage::_mpage" ref="ee3486c81392488e48efd978f0d6e83b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FIMULTIBITMAP* <a class="el" href="classfipMultiPage.html#ee3486c81392488e48efd978f0d6e83b">fipMultiPage::_mpage</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to a multi-page file stream. 
<p>

</div>
</div><p>
<a class="anchor" name="a9a56c170df363f7bc9750dc649e92ac"></a><!-- doxytag: member="fipMultiPage::_bMemoryCache" ref="a9a56c170df363f7bc9750dc649e92ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="classfipMultiPage.html#a9a56c170df363f7bc9750dc649e92ac">fipMultiPage::_bMemoryCache</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TRUE when using a memory cache, FALSE otherwise. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FreeImagePlus_8h-source.html">FreeImagePlus.h</a></ul>
<hr>
<p align="right">
<img src="freeimage.png"><br>
</p>
</BODY>
</HTML>

