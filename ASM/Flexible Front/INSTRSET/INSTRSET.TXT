                      68000 INSTRUCTION SET


                 ABCD - Add Binary Coded Decimal

   This instruction is a specialized arithmetic instruction that 
adds together two bytes (and only bytes) containing binary-coded 
decimal numbers.
   The addition can either be done between two data registers or 
between two memory locations. If performed on bytes in memory, 
only address register indirect with predecrement addressing can 
be used. This facilitates easy manipulation of multiple-precision 
BCD numbers. The extend bit is added along with the BCD bytes to 
allow this multiprecision data manipulation. Also note that the 
Zero flag is only changed if the result becomes non-zero.
   Therefore, both the Extend and Zero bits in the condition code 
register should be preset before the operation is performed. The 
Extend bit would normally be preset to a zero (to prevent 
extension on the first addition), and the Zero bit to a one (to 
preset a zero result prior to the first addition). A MOVE #4,CCR 
would setup these flags correctly.

Syntax:   ABCD Dn, Dn
or        ABCD -(An), -(An).

Flags affected: The Extend, Zero, and Carry flags are affected as 
          per the result of the operation. The state of the 
          Negative and Ovreflow flags is undefined.

                        ADD - Add Binary

   The ADD insrtuction adds the source to the destination operand 
with the result appearing in the destination. It is possible to 
add bytes, words, or long words with this opcode. Either the 
source or destination (or both) must be a data register. The 
source operand can be any memory location or data register, and 
the destination operand can also be any memory location or data 
register.

Syntax:   ADD Dn, Dn
or        ADD address, Dn
or        ADD Dn, address.

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all affected as per the result of the 
          addition.

                       ADDA - Add Address

   This variant of the ADD instruction only differs from ADD in 
that an address register is specified as the destination. As an 
address rather than data is being manipulated, the condition code 
flags are left unaltered. Only sign-extended words or long words 
can be added.

                      ADDI - Add Immediate

   This variant of the ADD instruction is used to add a constant 
value to the destination. The immediate operand can be any 8-, 
16-, or 32-bit value as specified by the .B, .W, or .L opcode 
suffix. The destination can not be an address register or a 
program counter relative address.

Syntax:   ADDI #imm, Dn
or        ADDI #imm, address
where     address is any memory addressing mode except program 
          counter relative.

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all set as per the result of the addition.

                        ADDQ - Add Quick

   This variant of the ADD instruction is used to add a small 
positive integer between one and eight to the destination. The 
destination can be a memory location, a data register, or an 
address register. If it is an address register, the condition 
code flags are unaffected and the operand length can not be a 
byte.
   This operation takes the place of the increment instruction 
found on other processors.

Syntax:   ADDQ #imm, Rn
or        ADDQ #imm, address.

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all set as per the result of the addition 
          unless the destination is an address register.

                       ADDX - Add Extended

   This variant of the ADD instruction adds two numbers plus the 
Extend bit from the condition code register. This allows 
multiple-precision additions to be performed. For this reason, 
the Zero flag is only affected when a non-zero result is 
obtained. This means that if multiple numbers are added together 
using ADDX, the Zero flag will stay reset if any of those numbers 
were non-zero.

Syntax:   ADDX Dn, Dn
or        ADDX -(An), -(An).

                        AND - Logical AND

   This instruction logically ANDs bits in the source operand 
with the same number of bits in the destination operand were the 
result is left. The number of bits can be 8, 16, or 32 as per the 
.B, .W, or .L opcode suffix. One or both operands must be a data 
register.

Syntax:   AND Dn, Dn
or        AND Dn, memory
or        AND memory, Dn.

                  ANDI - Logical AND Immediate

   This instruction logically ANDs an immediate byte, word, or 
long word value with the destination. The destination can be a 
data register, memory, or one of two special cases: the condition 
code register, only a byte-length immediate value is allowed. If 
the destination is the status register, only a word-length 
immediate value is allowed, and the processor must be in 
supervisor mode or a priviledge voilation will occur.

Syntax:   ANDI #imm, Dn
or        ANDI #imm, memory
or        ANDI.B #imm 8-bit value, CCR
or        ANDI.W #imm 16-bit value, SR (Privileged).

Flags affected: The Overflow and Carry bits are reset, the 
          Negative and Zero bits set as per the result, and the 
          Extend bit is unaffected.

                   ASL - Arithmetic Shift Left

   This instruction shifts the destination operand left by a 
specified number of bits. If you are shifting a data register, 
the number of bits to be shifted can be specified as an immediate 
value or as a value in another data register. The immediate value 
can be 1 to 8, whereas the data register can be 1 to 64 (where 
zero acts as the 64 count). Data registers may be shifted as 8, 
16, or 32 bit quantities. Only 16-bit word values can be shifted 
in memory and then only by one bit. As shown below zeroes are 
shifted in at the right hand side of the operand. As each bit is 
shifted out of the left of an operand, it is placed in the Carry 
and Extend bits of the condition code register. If the sign of 
the operand changes during the shift, the Owerflow bit is set in 
the condition code register.

     C <
         < | <<< ASL <<< | < 0
     X <

Syntax:   ASL Dn, Dn
or        ASL #imm 3-bit value, Dn
or        ASL memory (1 bit shift only).

                  ASR - Arithmetic Shift Right

   This instruction shifts the destination operand right by a 
specified number of bits. If you are shifting a data register, 
the number of bits to be shifted can be specified as an immediate 
value or as a value in another data register. The immediate value 
can specify a shift of 1 to 8, while the data register can 
specify a shift of 1 to 64 (where zero acts as the 64 count). 
Data registers may be shifted as 8, 16, or 32 bit quantities. 
Only 16-bit word values can be shifted in memory and then only by 
one bit. Each bit shifted out of the right hand side of an 
operand is placed in the Carry and Extend bits of the condition 
code register. As shown below the bit shifted in at the left hand 
side is the current sign bit (the most significant bit is 
therefore preserved throughout the shift).

                                     > C
     Current MSB > | >>> ASR >>> | >
                                     > X

Syntax:   ASR Dn, Dn
or        ASR #imm 3-bit value, Dn
or        ASR memory (1 bit shift only).

                       BRS - Branch Always

   This instruction changes the program counter register so 
execution continues at a different point in the program code. The 
destination of the jump is specified as a signed displacement to 
the program counter. This signed displacement can be an 8- or 16-
bit quantity. With a bit 8-bit quantities, this allows branches 
of +126 to -128 bytes; 16-bit quantities can specify branches of 
+32766 to -32768 bytes. The value of the program counter when the 
displacement is added is taken to be the first word after the BRA 
opcode. This is the actual opcode address plus two. Normally an 
assembler will assume a 16-bit quantity as the displacement, but 
if an opcode suffix of .S is appended th the BRA, a short 8-bit 
displacement will be used instead.

Syntax:   BRA label (16-bit displacement)
or        BRA.S label (8-bit displacement).

Flags affected: None.

                   Bcc - Branch Conditionally

   Other variants of the BRA instruction allow a branch to be 
made only if a certain condition is met in the condition code 
register. These Bcc instructions can be divided into three 
different categories. Whether or not this instruction is actually 
executed depends on the required condition, which is verified by 
means of the flags. A minus sign before a flag indicates that it 
must be cleared to satisfy the condition. Logical operations are 
indicated with "*" for AND and "/" for OR.

   Branches depending on flag status:
      BCC - Branch if carry clear     -C
      BCS - Branch if carry set       C
      BNE - Branch if zero clear      -Z
      BEQ - Branch if zero set        Z
      BVC - Branch if overflow clear  -V
      BVS - Branch if overflow set    V
      BPL - Branch if negative clear  -N
      BMI - Branch if negative set    N

   Branches after unsigned comparison:
      BHI - Branch if higher than            -C * -Z
      BHS - Branch if higher than or same as
      BLO - Branch if lower than
      BLS - Branch if lower than or same as  C / Z
      BEQ - Branch if equal to               Z
      BNE - Branch if not equal to           -Z

   Branches after signed comparison:
      BGT - Branch if greater than     N * V * -Z / -N * -V * -Z
      BGE - Branch if greater than or equal to   N * V / -N * -V
      BLT - Branch if less than                  N * -V / -N * V
      BLE - Branch if less than or equal to  Z / N * -V / -N * V
      BEQ - Branch if equal to                   Z
      BNE - Branch if not equal to               -Z

Syntax:   Bcc label (16-bit displacement)
or        Bcc.S label (8-bit displacement).

Flags affected: None.

                   BSR - Branch to Subroutine

   This instruction causes control to be passed unconditionally 
to the specified program counter displacement as in the BRA 
opcode. However, before the branch is made, the address of the 
opcode following the BSR is saved on the stack so return can 
later be made to that address to continue processing at that 
point. This is achived as follows:

   1. The 24-bit address following the opcode is pushed on the 
      stack as two words.
   2. The program counter is loaded with its new value and 
      processing continues at the new address.

Syntax:   BSR label (16-bit displacement)
or        BSR.S label (8-bit displacement).

Flags affected: None.

    BCHG, BCLR, BSET, BTST - Bit Test and Change, Clear, Set

   These instructions allow the manipulation and testing of 
single bits. The bits are numbered from the right to the left 
starting with bit no zero. Thus a byte contains bits 0 to 7; a 
word bits 0 to 15; and a long word bits 0 to 31. The number of 
the bit to be tested is specified in a data register or as an 
immediate value. The value of the bit is reflected in the Zero 
flag of the condition code register. This means that the if the 
bit tested was zero, the Zero flag will be set (Z=1). Therefore 
the Zero flag is always the opposite of the bit being tested. 
Once the test is made and the Zero flag is set up, the tested bit 
is manipulated as follows:

   BCHG - The bit is reversed.
   BCLR - The bit is cleared to zero.
   BSET - The bit is set to a one.
   BTST - The bit is unchanged.

Syntax:   Bxxx Dn, address
or        Bxxx #imm, address.

Flags affected: Zero flag only.

                   CHK - Check Against Bounds

   This instruction checks its first operand against a data 
register's word contents. If the data register contains less than 
zero or greater than its first operand, a trap to the address 
specified by vector 6 occurs. Thus, CHK can be used to ensure 
that an element of an array is neither below nor above its 
boundaries.

Syntax:   CHK bounds, Dn
where     bounds is anything except an address register.

Flags affected: All flags are undefined after this operation.

                 CLR - Clear Destination to Zero

   This instruction allows a byte, a word or a long word to be 
cleared to a zero according to the operand suffix .B, .W, or .L. 
The destination can be either a data register or memory. Address 
registers cannot be cleared with the CLR instruction (Use MOVE.L 
#0, An).

Syntax:   CLR Dn
or        CLR address.

Flags affected: Negative, Overflow, and Carry are all set to 
          zero, the Zero flag is set to a one, and the Extend 
          flag is unaffected.

                          CMP - Compare

   This instruction compares two operands and sets flags in the 
condition code register according to the result. Except for the 
Extend flag, the flags are set as if the source operand were 
subtracted from the destination. However, the result of this 
subtraction is not actually retained so the destination remains 
unchanged. The information about the comparison that is stored in 
the condition flags can then be acted upon by a Bcc-instruction. 
CMP may be used with byte, word, or long word source operands. 
Note that although any addressing mode can be used to specify the 
source operand, an address register can only be used if a word or 
long word comparison is performed.

Syntax:   CMP address, Dn.

                     CMPA - Compare Address

   This variation of the CMP instruction is used to compare a 
source operand with an address register as destination operand. 
Only word or long word compares are allowed with CMPA. If a word 
is used as source, if is sign-extended to 32 bits before the 
comparison is made.

Syntax:   CMPA address, An.

Flags affected: Same as CMP instruction.

                    CMPI - Compare Immediate

   This variation of the CMP instruction is used to compare a 
source operand consisting of an immediate value with either a 
data register or memory. The comparison length can be byte, word, 
or long word as specified by the .B, .W, or .L opcode suffix.

Syntax:   CMPI #imm, Dn
or        CMPI #imm, memory.

                      CMPM - Compare Memory

   This variation of the CMP opcode is used to compare sequential 
memory locations. These locations can be of type byte, word, or 
long word as specified by the .B, .W, or .L opcode suffix. To 
perform the sequencing automatically through memory, both source 
and destination operands must be specified using address register 
indirect with postincrement. Thus, after the compare is made, the 
address registers of both source and destination operands will 
be incremented by the length of data compared.

Syntax:   CMPM (An)+, (An)+.

Flags affected: Same as the CMP opcode.

                   DBRA - Decrement and Branch

   This instruction is used to control the program counter 
register in much the same way as BRA instruction is except that 
this allows greater power and versatility. By using DBRA, a 
specified data register is decremented and the branch made only 
if that register goes past zero. Thus, the count from a positive 
number will count down until zero and branch one more time. This 
allows loops where an index of zero is the last element. Note 
that as a result of this, the value left in the register will be 
-1 when an exit is made at the end of the loop. As an example, if 
eight locations were to be accessed, the data register specified 
in the DBRA instruction would be loaded with seven. The 
countdown, including the final zero, would go through eight 
cycles.
   The program counter register is modified as in the BRA 
instruction whereby a sign-extended 16-bit displacement is added 
to the program counter. No short 8 bit form is available. only 
bits 0 to 15 (that is, one word) of the data register is used. 
The destination of the branch is usually supplied as a label from 
which the assembler automatically calculates the displacement 
needed to that label.

Syntax:   DBRA Dn, label.

            DBcc - Decrement and Branch Conditionally

   This is a whole series of instruction that resemble the 
conditional versions of the BRA opcode. Conditional decrement and 
branch instruction work in a similar manner to the DBRA 
instruction except that one step is added to the execution 
process.
   Before the decrement is performed as in DBRA, the condition 
specified in the mnemonic is tested (in the opposite order to 
that suggested by the opcode name). If the condition is true, 
control drops through to the next instruction - the branch is not 
made. This is the opposite to the normal branch instruction where 
the conditional branch is made if the condition is true. Thus 
this mnemonic might more accurately be read as "decrement and 
branch if the condition is not fulfilled".
   Powerful loops can be constructed using the decrement and 
branch conditional instruction; an exit can be made from the loop 
either if the data register passes zero or if a pretested 
condition is met. The following  list displays the conditions 
available for testing before the decrement and possible branch is 
made. This list is similar to that for the Bcc opcode with the 
addition of the F (false) and T (true) conditions, which specify 
an always false or always true precondition. Therefore a DBF is 
always false, so it will never drop through to the following 
opcode. Thus, the branch after the decrement will always be 
performed. Conversely, a DBT is always true, so it will always 
drop through and never perform the decrement. (This would only be 
likely to be of use during program development.)

   DBEQ - Decrement, branch equal.
   DBF  - Decrement, branch false. (Same as DBRA.)
   DBGE - Decrement, branch greater than or equal.
   DBGT - Decrement, branch graeter than.
   DBHI - Decrement, branch higher.
   DBLE - Decrement, branch less than or equal.
   DBLS - Decrement, branch lower than or same.
   DBLT - Decrement, branch less than.
   DBMI - Decrement, branch minus.
   DBNE - Decrement, branch not equal.
   DBPL - Decrement, branch plus.
   DBRA - Decrement, branch unconditionally.
   DBT  - Decrement, branch true. (Branch never taken.)

Syntax:   DBcc Dn, label.

              DIVS, DIVU - Divide Signed, Unsigned

   These instructions allow a 16-bit divisor (n„mnare) to be used 
as a source and a 32-bit destination to be specified as dividend 
(t„ljare) in a divide operation. DIVS assumes both mubers are 
signed, whereas DIVU assumes both to be unsigned. The destination 
must be a data register. The source can be a memory location or 
another data register. The result is stored in the low word of 
the destination data register and the remainder in the high word 
of the same register. If the result will not fit in the 16 bits 
of the low half, the Overflow flag is set in the condition code 
register. It is possible that the overflow condition can occur 
during the internal processing of the divide, in which case the 
Negative and Zero flags will be undefined as will be the result. 
Either a conditional branch on overflow or a TRAPV can be placed 
after the divide opcode to act upon the error.
   Another problem occurs if a divisor of zero is specified. In 
this case a division-by-zero exception processing sequence is 
automatically initiated which causes a trap through vector 5.

Syntax:   DIVx Dn, Dn
or        DIVx address, Dn.

Flags affected: The Carry flag is always set to zero. The Zero, 
          Overflow, and Negative flags are set as per the result. 
          The Extend flag is unaffected.

                   EOR - Logical Exclusive OR

   This instruction performs a logical exclusive OR of the source 
operand with the same number of bits in the destination operand 
where the result is left. The number if bits can be 8, 16, or 32 
as specified by the .B, .W, or .L opcode suffix.

Syntax:   EOR Dn, Dn
or        EOR Dn, address
or        EOR address, Dn.

Flags affected: The Overflow and Carry flags are reset. The 
          Negative and Zero flags are set as per the result, and 
          the Extend flag is unaffected.

              EORI - Logical Exclusive OR Immediate

   This instruction performs a logical exclusive OR on a length 
of byte, word or long word between an immediate value and a 
destination. The destination can be a data register, memory or 
one of two special cases: the condition code register or the 
status register. If the destination is the the condition code 
register, only a byte-length immediate value is allowed. If the 
destination is the status register, only a word-length immediate 
value is allowed, and the processor must be in supervisor mode or 
else a priviledge voilation will occur causing a trap through 
vector 8.

Syntax:   EORI #imm, Dn
or        EORI #imm, memory
or        EORI.B #imm 8-bit value, CCR
or        EORI.W #imm 16-bit value, SR (Privileged).

Flags affected: Same as the EOR instruction.

                    EXG - Exchange registers

   This instruction allows the sign bit (the most significant 
bit) to be extended up to the next higher size. Thus if an opcode 
modifier of .W is used, the bit in position 7 of the lower-order 
byte will be extended into the rest of the word (in bits 8 to 
15). If an opcode modifier of .L is used, the bit in position 15 
of the low-order word will be extended into the rest of the long 
word (bits 16 to 31). If a byte value has to sign-extended to a 
long word, both an EXT.W and an EXT.L have to be performed on the 
data register.

Syntax:   EXT Dn.

Flags affected: The Negative and Zero flags are set as per the 
          result. The Overflow and Carry are reset to zero, and 
          the Extend flag is unaffected.

                           JMP - Jump

   This instruction allows execution of the program to be 
transferred anywhere within the entire addressing space of the 
68000. The jump address can be specified using any memory mode 
except register indirect with postincrement or predecrement. It 
should be borne in mind that an absolute address specified in a 
jump instruction will load the program counter immediately with 
that value. Because absolute addresses are not position-
independent. If the program is moved in memory it has to be 
reassembled if the label is contained within the program. The JMP 
instruction with an absolute address is more properly used for 
jumps to static locations such as ROM routines. To keep the jump 
position-independent, a program-counter-relative address should 
be specified.

Syntax:   JMP address
where     address is any addressing mode except (An)+ and -(An).

Flags affected: None.

                    JSR - Jump to Subroutine

   This instruction allows control to be redirected in a similar 
manner to the JMP instruction; however, before the jump is made, 
the address of the following opcode is pushed onto the stack. 
(See BSR for a description of the stack save process.) Thus a 
subroutine can perform a task, and when it finishes, it can 
execute a Return instruction to return to the address saved on 
the stack. As far as the destination address of the JSR 
instruction is concerned, the same caveats apply as for the JMP 
instruction. Absolute addresses, even as labels inside your 
program, should be avoided where possible to avoid a program 
which is not position-independent. Unless using such things as 
ROM routines or memory-mapped hardware locations, which have 
absolute addresses, use program counter relative or address 
register indirect addressing.

Syntax:   JSR address
where     address is any addressing mode except (An)+ and -(An).

Flags affected: None.

                  LEA - Load Effective Address

   This instruction provides a simple way of loading any address 
register with the address resulting from nearly any addressing 
mode. Only two such modes are excluded from the list of 
possibilities. Due to the fact that address register indirect 
with postincrement or predecrement represent a dynamically 
increasing or decreasing addresses, these two modes cannot be 
used with LEA. But any other address, no matter how complicated, 
(including address register indirect with displacement and index) 
can be loaded into the specified address register. This saves 
performing the address arithmetic within the program. The 
processor will automatically take the same value as the 
calculated address - or in other words "the effective address".
   Only address registers can be used with this instruction, and 
the destination address register is loaded with a 32-bit long 
value even though the address will only be 24 bits long.

Syntax:   LEA address, An
where     address is any addressing mode except postincrement and 
          predecrement.

Flags affected: None.

                     LINK - Link Subroutine

   This instruction is a specialized data area allocation opcode 
for use by subroutines that require a temporary work area that 
will be relinguished after use. Normally, when a subroutine has 
been entered from a JSR or BSR instruction, the return address 
(that is, the address of the instruction after the JSR or BSR) 
has automatically been saved on the stack by the processor before 
transferring control to the subroutine. This is part of the 
regular linkage for a subroutine call, which is automatically 
performed by any computer processor. The LINK instruction adds 
another automatic-linkage option after control has been handed to 
the subroutine.
   Assume the subroutine nedds ten bytes of temporary storage in 
order to perform its function. The ideal place for this would be 
on the stack, which is the usual place for dynamic registers 
saves during a program's operation. As the stack pointer saves 
numbers in a downward direction in memory, simply subtracting ten 
from the stack pointer register A7 would reserve ten bytes of the 
stack space with A7 pointing at it. However, A7 may not point to 
the ten bytes for long, as other items may subsequently be pushed 
onto the stack changing A7 to point lower in memory. So ideally, 
another address register should be loaded with the contents of A7 
before it was decremented by ten so we have a firm pointer to the 
stack before it is changed. This is exactly what the LINK 
instruction does.
   An address register is elected to save the current pointer to 
the stack in A7; this assigned will become the pointer to the 
temporary reserved stack space. The stack pointer A7 is then 
decremented by however many bytes needed, but before being 
decremented, the assigned register itself is saved on the stack. 
This way, the called subroutine can perform a LINK to reserve 
space, knowing that it can call yet another subroutine, which can 
also perform a LINK with no registers being corrupted. The 
diagram shows what happens.

                        LINK A0,#-10

     Before:                        After:
                                               Low memory
                                           |                |
                                           |----------------|
                Low memory          A7  >  |                |
            |                |             |    10 bytes    |
            |----------------|             |                |
     A7  >  | Return address |             |----------------|
            |----------------|      A0  >  |  Previous A0   |
            |                |             |----------------|
                High memory                | Return Address |
                                           |----------------|
                                           |                |
                                               High memory

   Note that because ten bytes are required on stack going 
downwards in memory (as per normal stack practice), a negative 
displacement is specified in the LINK instruction. As the 
displacement is a signed 16-bit immediate value, a stack 
displacement of plus or minus 32K can be specified. The address 
register assigned to point to the top of the reserved space, or 
stack frame, is generally known as a frame pointer when used in 
this way. Note that as this register will be used with 
predecrement instructions, it initially points to one word above 
the frame.

Syntax:   LINK An, #imm
where     #imm is plus or minus 32K.

Flags affected: None.

                    LSL - Logical Shift Left

   This instruction shifts the destination operand left by a 
specified number of bits. If you are shifting a data register, 
the number of bits to be shifted can be specified as an immediate 
value or as a value in another data register. The immediate value 
can be 1 to 8, whereas the data register value can be 1 to 64 
(where zero acts as the 64 count). Data registers may be shifted 
as 8, 16 or 32 bit quantities. Only 16-bit word values can be 
shifted in memory and then only by one bit. Each bit shifted out 
of the left-hand side of an operand is placed in the Carry and 
Extend bits in the condition code register. As shown below, the 
bit shifted in at the right hand side is always a zero.

     C <
         < | <<< LSL <<< | < 0
     X <

Syntax:   LSL Dn, Dn
or        LSL #imm 3-bit value, Dn
or        LSL memory (1 bit shift only).

Flags affected: The Carry and Extend bits are set as per the most 
          significant operand bit before the shift. The Overflow 
          flag is reset to zero. The Negative and Zero flags are 
          set as per result.

                     LSR Logical Shift Right

   This instruction shifts the destination operand right by a 
specified number of bits. If you are shifting a data register, 
the number of bits to be shifted can be specified as an immediate 
value or as a value in another data register. The immediate value 
can specify a shift of 1 to 8, while the data register value can 
specify a shift of 1 to 64 (where zero acts as the 64 count). 
Data registers may be shifted as 8, 16, or 32 bit quantities. 
Only 16-bit word values can be shifted in memory and then only by 
one bit. Each bit shifted out of the right hand side of an 
operand is placed in the Carry and Extend bits of the condition 
code register. As shown below, the bit shifted in at the left 
hand side is always a zero.

                               > C
     0 MSB > | >>> ASR >>> | >
                               > X

Syntax:   LSR Dn, Dn
or        LSR #imm 3-bit value, Dn
or        LSR memory (1 bit shift only).

Flags affected: The Carry and Extend bits are set as per the 
          least significant operand bit before the shift. The 
          Overflow flag is reset to zero. The Negative and Zero 
          flags are set as per result.

                        MOVE - Move Data

   This is the 68000's general purpose data-transfer instruction. 
Using one single opcode, data can be moved from register to 
register, register to memory, memory to register and memory to 
memory. The MOVE instruction can also be used to move data to 
(but not from) the condition code register, thus explicitly 
setting a particular set of conditions. If you are in privileged 
(or supervisor) mode, the MOVE instruction can be used to move 
data to the status register and to or from the user stack 
pointer. (Privileged mode is not required to move data from the 
status register.)
   With so many potential sources and destinations of data moves, 
the 68000 makes life easier by allowing all addressing modes to 
be used for the source. For destination, all except program 
counter relative addressing modes may be used. With data 
transfers involving memory and / or data registers, the data 
transfer can be made using 8, 16, or 32 bit quantities and is 
specified by appending .B, .W, or .L to the MOVE mnemonic. If the 
high-order bits of a data register are not involved in the data 
move, those bits remain unaffected by the transfer. Care should 
be used when mixing length of operands during routines using 
MOVE; if a byte is moved from a location using MOVE.B and then 
stored back again using MOVE.W, it will be stored in a memory 
location one byte higher than it was fetched from. Similary, 
storing it back with MOVE.L would store it three bytes higher 
than its original location.
   If the destination operand of the MOVE is the condition code 
register, the length of the source operand can only be eight 
bits. If the status register is involved as either source or 
destination of the move, only 16-bit transfers allowed. The 
instruction involving the user stack pointer is the only 
circumstance under which the 68000 allows optional access to 
either the user or the system stack pointer. Normally, the stack 
pointer is accessed as register A7. Whichever of two A7 registers 
is in effect depends on whether the processor is in supervisor or 
user mode. However, the supervisor mode may have a need to access 
the user stack pointer even though it would normally only access 
the system stack pointer. This is why the privileged mode is 
required to access a normally unprotected register.

Syntax:   MOVE source, destination
where     source can be any addressing mode
          destination can be any addressing mode except program 
          counter relative and immediate. Either of the above can 
          be CCR, SR and USP (privileged mode only).

Flags affected: When the MOVE source, destination format is used, 
          the Negative and Zero flags are set as per the data 
          moved, the Overflow and Carry flags are reset to zero 
          and the Extend flag is unaffected.
             When the MOVE source, CCR / SR formats are used, the 
          flags are set directly from the data.
             When the MOVE is done with the USP as an operand, no 
          flags are affected.

                      MOVEA - Move Address

   This specialized version of the MOVE command is used when the 
destination is an address register. The instruction only allows 
transfers of 16 or 32 bits in length. Byte transfers are not 
allowed with an address register as the destination. Also note 
that unlike the normal MOVE command, no flag bits are affected.

Syntax:   MOVEA source, An
where     source is any addressing mode.

Flags affected: None.

                      MOVEM - Move Multiple

   This variation of the MOVE instruction allows multiple 
registers to be saved and restored using a single operation. Any 
of the 16 data or address registers can be moved this way. At the 
source code level, the registers chosen to be saved or restored 
are specified to the assembler in a list separated by slashes. 
Thus, to save D0, D3 and A1, the register list would be specified 
as D0/D3/A1. If a consecutive number of registers are included in 
the list, they can be idetified as such by a hyphen. So to save 
D0, D1, D2, D5 and A1, the register list can be specified as 
D5/D0-D2/A1. Notice that the order of register between slashes is 
unimportant; however, when the 68000 saves these registers, it 
does so in a definite order. It also retrives them in a definite 
(but opposite) order, so that if the registers are saved on the 
stack, they can be pulled off in a typical stack-like fashion 
(that is, last in first out). The order in which the 68000 saves 
registers is first A7 through A0, and then D7 through D0. Then in 
reverse order, D0 is restored first, and restoration continues 
all the way through to A7. As the registers are most often saved 
in a stack formation, normally an address register is chosen to 
point to that stack. Then a predecrement addressing mode is used 
to push the registers down onto the stack. Conversely, when 
registers are being restored, a postincrement addressing mode is 
used. As an example, to save two registers at a memory location 
pointed to by A3, the instruction MOVEM D1/A1, -(A3) might be 
used. To restore them at another point in program, MOVEM (A3)+, 
D1/A1 would be correct. Note that registers can only be saved as 
words or long words. If they are saved as 16-bit words, then when 
they are restored, the upper half of the register is automtically 
sign-extended so that bit 15 fills the upper half of the 
register. Although less memory is used to save registers this 
way, such a loss of control of the upper 16 bits of every 
restored register may present problems unless you remain acutely 
aware of the possible corruption of an upper register half.
   the MOVEM instruction may be used with addressing modes other 
than predecrement and postincrement. By specifying other 
addressing modes as the source or destination of the multiple 
transfer, registers can be saved and restored in ascending 
locations in memory. The same register order is used, but they 
will not be stacked in at last in, first out order. Note that no 
flags are affected by this operation. Thus a subroutine can 
affect the condition code register, restore multiple registers 
with MOVEM, and return with the condition code register still 
intact.

Syntax:   MOVEM register list, destination address
or        MOVEM source address, register list
or        MOVEM register list, -(An)
or        MOVEM (An)+, register list.

Flags affected: None.

                  MOVEP - Move Peripheral Data

  This variation of the MOVE instruction is used to transfer data 
between the 68000 and certain peripherals. As input and output on 
the 68000 is memory-mapped, certain addresses will not actually 
be memory at all but will instead be external devices. The 68000 
has a special design to allow it to use the many hardware 
interfaces that exist for 8-bit microprocessors, in particular 
the 6800. What this means to the programmer is that if a 
peripheral is interfaced to the 68000 and is normally addressed 
at consecutive address on an 8-bit microprocessor, it will be 
addressed at every other address on the 68000 due to the design 
of its peripheral hardware bus. Thus the MOVEP instruction was 
included to address such peripherals. A long word of data from a 
data register can be transferred high byte first to every 
alternate memory (pheripheral) address with a single MOVEP to the 
first address.
   This also works the other way round in that every other word 
will be addressed starting with the source address specified in 
the MOVEP instruction. Only word or long word transfers are 
allowed. (A normal MOVE would be used for a single byte.) The 
only addressing mode allowed to specify the memory location is 
address register indirect with displacement, and only a data 
register can be used as the other operand.

Syntax:   MOVEP Dn, disp(An)
or        MOVEP disp(An), Dn
where     disp is a 16-bit displacement.

                       MOVEQ - Move Quick

   This variation on the MOVE instruction allows the quick 
loading of a data register with an immediate value. The MOVEQ 
variant works like a MOVE immediate value to the data register 
except that MOVEQ is much faster and only takes up two bytes in 
memory. The immediate value that is moved into a data register 
can only be in the range -128 to +127. This value is sign-
extended into the entire 32 bits of the data register, so it is 
always of type .L despite the small immediate value. As this 
instruction works so fast, it is quicker to clear a data register 
with a
   MOVE #0, Dn
than to use
   CLR Dn.
MOVEQ cannot, however, be used with address registers or numbers 
larger than eight bits.

Syntax:   MOVEQ #imm 8-bit signed value, Dn.

Flags affected: The Negative and Zero flags are set as per the 
          immediate value; the Overflow and Carry flags are reset 
          to zero, and the Extent flag is unaffected.

             MULS, MULU - Multiply Signed, Unsigned

   This instruction allow a multiplication to take place between 
a 16-bit source operand and the low order 16 bits of a data 
register. MULS assumes both numbers are signed, whereas MULU 
assumes both to be unsigned. The source can be a word from any 
memory location or the low-order 16 bits of a data register. The 
destination has to be a data register. The result is stored as a 
32-bit signed or unsigned value in the destination register. The 
Negative flag in the condition code register is affected whether 
or not the operands are signed, and reflects the most significant 
bit of the result.

Syntax:   MULx Dn, Dn
or        MULx address, Dn
where     address is any addressing mode.

Flags affected: The Negative and Zero flags are set as per the 
          result. The Overflow and Carry flags are reset to zero. 
          The Extend flag is unaffected.

               NBCD - Negate Binary Coded Decimal

   This specialized arithmetic instruction allows a single byte 
containing two binary coded decimal digits to be negated. The 
byte can be contained in the low portion of a data register or in 
memory. If the number is in memory, any memory addressing mode 
except program counter relative may be used. If the number is in 
data register, bits 8 to 31 are not affected.

Syntax:   NBCD Dn
or        NBCD address.

Flags affected: The Negative and Overflow flag is undefined. The 
          Zero flag is set per the contents of register. Carry 
          and Extend are set as per the result of operation.

          NEG, NEGX - Negate Binary, Negate with Extend

   This instruction negates its operand. The result is the same 
as if the operand were subtracted from zero. The operand may be 
8, 16, or 32 bits long as specified by the .B, .W, or .L mnemonic 
suffix. All flags are affected by this operation. A variation of 
this instruction exists to facilitate the manipulation of 
multiple-precision quantities where data is handled in segments. 
This is achived by using the Extend flag as set or reset from a 
previous arithmetic operation. The NEGX instruction works by 
subtracting its operand from zero then subtracting the Extend 
bit. All flags are affected by the result of the NEGX operation, 
but the Zero flag is only changed if the result becomes non-zero 
thus reflecting the nonzero state of a segmented number. For this 
reason, the Zero flag should be reset before performing code 
involving multiple use of NEGX.

Syntax:   NEG Dn
or        NEG address
where     address is any addressing mode except program counter 
          relative.

Flags affected: All.

                       NOP - No Operation

   This instruction is a do-nothing opcode. It is used during 
program developement to leave room in a section of code. This 
space can be patched with machine-code instruction as necessary 
during debugging to test new routines within a previously written 
machine code level by substituting NOP instruction for the 
instructions and operands.

Syntax:   NOP.

Flags affected: None.

                        NOT - Logical NOT

   This instruction takes its operand and simply inverts all of 
its bits. (Each one-bit becomes zero and each zero-bit becomes 
one.) The operand can either be in a data register or memory and 
can be 8, 16, or 32 bits in length as per the .B, .W, or .L 
operand suffix.

Syntax:   NOT Dn
or        NOT address
where     address is any memory addressing mode except program 
          counter relative.

                         OR - Logical OR

   The OR opcode performs a logical OR operation. A number of 
bits in the source operand are ORed with the same number of bits 
in the destination operand where the result is left. The number 
of bits can be 8, 16, or 32 as the .B, .W, or .L opcode suffix. 
One or both operands must be a data register.

Syntax:   OR Dn, Dn
or        OR Dn, address
or        OR address, Dn
where     address is any addressing mode with the proviso that 
          program counter relative may not be used as 
          destination.

                   ORI - Logical OR Immediate

   This instruction logically ORs a byte, word, or long word 
immediate value with the destination. The destination address can 
be a data register, memory, or one of two special cases: the 
condition code register and the status register. If the 
destination is the condition code register, only a byte-length 
immediate value is allowed. If the destination is the status 
register, only a word-length immediate value is allowed, and the 
processor must be in supervisor mode or else a privilege 
voilation will occur.

Syntax:   ORI #imm, Dn
or        ORI #imm, address
or        ORI.B #imm 8-bit value, CCR
or        ORI.W #imm 16-bit value, SR (Privileged).

Flags affected: The Overflow and Carry bits are reset, the 
          Negative and Zero bits set as per the result, and the 
          Extend bit is unaffected.

                  PEA - Push Effective Address

   This instruction takes the effective address of its operands 
and pushes it onto the stack as pointed to by the stack pointer 
A7. The operand can be nearly any addressing mode and is 
represented as a 32-bit long word. Only two addressing modes are 
excluded from the list of possibilities. Due to the fact that 
address register indirect with postincrement or predecrement 
represent a dynamically increasing or decreasing address, these 
two modes cannot be used with PEA. But any other address, no 
matter how complicated, (including address register indirect with 
displacement and index) can be pushed onto the stack. This saves 
performing the address arithmetic within the program. The 
processor will automatically push the same value as the 
calculated address - or in other words "the effective address". 
The destination address on the stack is loaded with a 32-bit long 
value even though the address will only be 24 bits long. No flags 
are affected by the result of the address calculation.

Syntax:   PEA address
where     address is any memory addressing mode except 
          postincrement and predecrement.

Flags affected: None.

                 RESET - Reset External Devices

   This instruction sends out a pulse from the RESET pin of the 
68000. It is normally used when a system is first powered up to 
reset all devices to a known state. It is only likely to be used 
after that if a hardware fault-condition developes. Because it is 
such a powerful opcode, it is restricted to use in supervisor 
mode only.

Syntax:   RESET

Flags affected: None.

          ROL, ROXL - Rotate Left, Rotate Extended Left

   These two instructions both rotate the destination operand 
left by a specified number of bits. If you are rotating a data 
register, the number of bits can be specified as an immediate 
value or as a value in another data register. The immediate value 
can be 1 to 8, whereas the data register value can be 1 to 64 
(where zero acts as the 64 count). Data registers may be rotated 
as 8, 16, or 32 bit quantities. Only 16-bit word values can be 
rotated im memory and then only by one bit. As shown, each bit 
rotated out of the left hand side of the operand is placed in the 
Carry bit of the condition code register, and in case of ROXL, 
also in the Extend bit. The bit rotated in at the right is the 
most significant bit for ROL or the Extend bit for ROXL. Thus, 
one more bit is involved in the ROXL rotate than in the ROL 
rotate. Note that ROL does not affect the Extend flag in the 
condition code register.

     C < | <<< ROL <<< | <       C <
        > > > > > > > > >            < | <<< ROXL <<< | <
                               < X <
                                > > > > > > > > > > > > >

Syntax:   ROL Dn, Dn
or        ROL #imm, Dn
or        ROL address.

Flags affected: The Negative flag is set as per most significant 
          bit before the rotate. The Zero flag is set as per 
          resultant operand. The Overflow flag is reset to zero. 
          The Extend flag is unaffected by ROL, but contains the 
          previous most significant bit for ROXL.

         ROR, ROXL - Rotate Right, Rotate Extended Right

   These two instructions both rotate the destination operand 
right by a specified number of bits. If you are rotating a data 
register, the number of bits can be specified as an immediate 
value or as a value in another data register. The immediate value 
can be 1 to 8, whereas the data register value can be 1 to 64 
(where zero acts as the 64 count). Data registers may be rotated 
as 8, 16, or 32 bit quantities. Only 16-bit word values can be 
rotated im memory and then only by one bit.
   As shown, each bit rotated out of the right hand side of the 
operand is placed in the Carry bit of the condition code 
register and in case of ROXR, also in the Extend bit. The bit 
rotated in at the left is the least significant bit for ROR or 
the Extend bit for ROXR. Thus, one more bit is involved in the 
ROXR rotate than in the ROR rotate. Note that ROR does not affect 
the Extend flag in the condition code register.

     > | >>> ROR >>> | > C                          > C
      < < < < < < < < <        > | >>> ROXR >>> | >
                                                    > X >
                               < < < < < < < < < < < < <

Syntax:   ROR Dn, Dn
or        ROR #imm, Dn
or        ROR address.

Flags affected: The Negative flag is set as per most significant 
          bit before the rotate. The Zero flag is set as per 
          resultant operand. The Overflow flag is reset to zero. 
          The Extend flag is unaffected by ROR, but contains the 
          previous most significant bit for ROXR.

            RTE - Return from Exception, RTR - Return
          and Restore CCR, RTS - Return from Subroutine

   These instructions change program control by loading the 
program counter with an execution address previously saved on the 
stack. The most common version is RTS, which simply pulls the 
saved address from the stack, increments A7 to allow reuse of the 
stack space, and reloads the program counter.
   RTE excepts to find a previously saved status register word on 
the stack, which it pulls and restores prior to reloading the 
program counter. As RTE accesses the privileged byte of the 
status register, it can only be executed in supervisor mode or 
else a privilege voilation trap will occur.
   RTR expects to find a previously saved condition code register 
word on the stack, which it pulls and restores prior to reloading 
the program counter.

Syntax:   RTS
or        RTE
or        RTR.

Flags affected: No flags are affected by RTS. All flags are 
          reloaded by RTE and RTR.

              SBCD - Subtract Binary Coded Decimal

   This instruction a specialized arithmetic instruction that 
subtracts one bytes from another (only bytes) when each byte 
containis binary-coded decimal numbers.
   The subtraction can be performed either on two data registers 
or between two memory locations. If performed on bytes in memory, 
only address register indirect with predecrement can be used. 
This facilitates easy manipulation of multiple-precision BCD 
numbers. The extend bit is subtracted along with the BCD bytes to 
allow this multiprecision data manipulation. Also note that the 
zero flag is only changed if the result becomes nonzero. 
Therefore, both the Extend and Zero bits in the condition code 
register should be perset before the operation is performed. The 
Extend bit would normally be preset to a zero (to prevent 
extension on the first subtraction) and the Zero bit to a one (to 
signify a zero result prior to the first subtraction). A MOVE #4, 
CCR would preset these flags correctly.

Syntax:   SBCD Dn, Dn
or        SBCD -(An), -(An)

Flags affected: The Zero flag is cleared if the result becomes 
          nonzero. The Carry and Extend flags are set if a 
          decimal borrow is generated. The Negative and Overflow 
          bits are undefined.

                 Scc - Set from Conditions Codes

   This instruction sets a single byte specified in the operand 
to all zeroes or all ones according to the condition codes. The 
condition codes which may be used are the same as for the 
decrement and branch opcode. If the specified condition is true 
as reflected in the condition code register, the destination byte 
is set to all ones ($FF). If it is not true, the destination byte 
is set to zero.
   The destination can be the low-order byte of a data register 
or a byte in memory. This instruction is of particular value 
saving status of a specific condition code.

   EQ - Equal to
   NE - Not equal to
   MI - Minus
   PL - Plus
   CS - Carry set
   CC - Carry clear
   VS - Overflow set
   VC - Overflow clear
   HI - Higher
   LS - Less than or same
   HS - Higher or same
   LO - Lower
   GT - Greater
   GE - Greater than or equal to
   LE - Less than or equal to
   LT - Less than
   F  - False  Always false => MOVE #$0
   T  - True   Always true  => MOVE #$FF

Syntax:   Scc Dn
or        Scc address
where     address is any addressing mode except program counter 
          relative.

Flags affected: None.

                 STOP - Stop processor and wait

   This is a privileged instruction that first copies its operand 
(which is an immediate word value) into the status register and 
then halts the processor. The processor will remain in this state 
until it receives an interrupt that is not masked by the 
interrupt mask into the status register.

Syntax:   STOP #imm 16-bit value (Privileged).

Flags affected: All flags are set as per the immediate value.

                      SUB - Subtract Binary

   The SUB instruction subtracts the source operand from the 
destination operand with the result appearing in the destination. 
It is possible to subtract bytes, words, or long words with this 
opcode by appending .B, .W, or .L to the mnemonic. Either the 
source or destination (or both) must be a data register. The 
source operand can be any memory location or data register, and 
the destination operand can also be any memory location or data 
register.

Syntax:   SUB Dn, Dn
or        SUB address, Dn
or        SUB Dn, address

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all affected as per the result of the 
          subtraction.

                     SUBA - Subtract Address

   This variant of the SUB instruction only differs in 
that an address register is specified as the destination. As an 
address rather than data is being manipulated, the condition code 
flags are left unaffected. Only sign-extended words or long words 
can be subtracted.

                    SUBI - Subtract Immediate

   This variant of the SUB instruction is used to subtract a 
constant value from the destination. The immediate operand can be 
any 8-, 16-, or 32-bit value as specified by the .B, .W, or .L 
opcode suffix. The destination cannot be an address register or a 
program counter relative address.

Syntax:   SUBI #imm, Dn
or        SUBI #imm, address
where     address is any memory addressing mode except program  
          counter relative.

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all set as per the result of the subtraction.

                      SUBQ - Subtract Quick

   This variant of the SUB instruction is used to subtract a 
small integer between one and eight from the destination. The 
destination can be a memory location, a data register, or an 
address register. If it is an address register, the condition 
code flags are unaffected and the operand length cannot be a 
byte.
   This operation takes the place of the decrement instruction 
found on other processors.

Syntax:   SUBQ #imm, Rn
or        SUBQ #imm, address.

Flags affected: The Extend, Negative, Zero, Overflow, and Carry 
          flags are all set as per the result of the subtraction 
          unless the destination is an address register.

                    SUBX - Subtract Extended

   This variant of the SUB instruction subtracts two numbers and 
the Extend bit of the condition code register. This allows 
multiple-precision subtractions to be performed. For this reason, 
the Zero flag is only affected when a non-zero result is 
obtained. This means that if multiple numbers are subtracted 
using SUBX, the Zero flag will stay reset if any of those numbers 
were non-zero.

Syntax:   SUBX Dn, Dn
or        SUBX -(An), -(An).

                SWAP - Swap Data register halves

   This instruction takes the lower 16 bits of the specified data 
register and swaps it with the upper 16 bits. It can only be used 
with data registers and only on the fixed word length in each 
half.

Syntax:   SWAP Dn.

Flags affected: The Negative and Zero flags are set to reflect 
          the 32-bit result. The Overflow and Carry flags are 
          reset to zero. The Extend flag is unaffected.

                       TAS - Test and Set

   This is a highly specialized instruction that is used to test 
a byte in memory or in a data register. When the condition codes 
are set as per the byte's contents, bit 7 (the most significant 
bit) of the byte is set to a one. This operation is achived in an 
uninterruptible read-modify-write cycle. It is the only 
instruction on the 68000 that uses this method. Its importance 
lies in the fact that no interrupt can cause a read of the 
accessed byte before the operation is finished. If the operation 
were done in two steps, an interrupt could occur before the byte 
was changed, which would allow the interrupting routine to scan 
the byte and draw an erroneous conclution as to its status.

Syntax:   TAS Dn
or        TAS address
where     address is any addressing mode except program counter 
          relative.

Flags affected: The Negative and Zero flags are set as per the 
          byte before modification. The Overflow and Carry flags 
          are reset to zero. The Extend flag is unaffected.

                      TRAP - Software Trap

   This instruction causes a trap to occur in the same manner as 
if it had been caused by a hardware-detected condition. The 
processor will jump to one of the 16 special addresses set up in 
the first 1024 bytes of memory. The actual address that will be 
jumped to is determined by the operand supplied with the opcode. 
This will be a number from 0 to 15. The software trap vectors are 
32-bit addresses stored in memory starting at location #128. 
Before the specified vector is taken, the status register and 
program counter are pushed onto the stack to facilitate a return 
via an RTE instruction.

Syntax:   TRAP #imm
where     #imm is an immediate value from 0 to 15.

Flags affected: None.

                    TRAPV - Trap if Overflow

   This instruction causes a trap to occur to the address in 
location #28 in low memory if the Overflow flag is set in the 
condition code register. Before the overflow vector is taken, the 
status register and program counter are pushed onto the stack to 
facilitate a return via an RTE instruction.

Syntax:   TRAPV

Flags affected: None.

                       TST - Test Operand

   This instruction causes the processor to scan the operand and 
set the condition code flags according to the contents. The 
operand can be 8, 16, or 32 bytes as specified in the .B, .W, or 
.L opcode modifier. No registers other than the condition code 
register are changed. The operand can be either a data register 
or a memory location.

Syntax:   TST Dn
or        TST address
where     address is any addressing mode except program counter 
          relative.

                          UNLK - Unlink

   This instruction is the reverse of the LINK opcode. It takes 
the address in the specified address register and loads the stack 
pointer (A7) with it. This removes any space allocated on the 
stack for temporary storage. The stack pointer then points at the 
previous contents of the address register (the frame pointer). 
This contents would have been placed there by a previous LINK 
instruction. The frame pointer is automatically reloaded by 
pulling the value from the stack. Both the frame pointer and the 
stack pointer are therefore returned to their values before the 
last LINK. This entire operation is performed automatically by a 
single UNLK instruction.

Syntax:   UNLK An

Flags affected: None.

