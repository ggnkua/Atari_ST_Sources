   Atari ST Machine Specific Programming In Assembly

Chapter 3: Assembly and Addressing Modes
               

     On April 1st, one year in the late 1970's, the 
announcement of a revolutionary semiconductor device, the 
write only memory (WOM), provided engineers the laugh of the 
day.  Imagine my mirth when I discovered that Motorola was 
apparently manufacturing a microprocessor that is 
"compatible" with that device--a read only processor (ROP).  
Imagine my chagrin when I realized that I had purchased a 
computer designed around that microprocessor.
     In the early stages of my ST education, the dilemma I 
faced was this: the ST's operating system requires position 
independent programs (My definition of a position 
independent program is this: it is a program for which the 
validity of execution results does not depend on the 
location of the program and its data in ram.); according to 
the references, this attribute is bestowed on programs which 
use the MC68000 pc-relative addressing mode to access label 
operands; however, this addressing mode cannot be used when 
the operand is a destination.  How, then, does one store 
data in program variables during program execution?

The ST Relocator
  
     Well, of course, I soon learned, via page 79 of the 
AssemPro manual, that the ST has a built in program 
relocator that nullifies the MC68000's pc-relative 
addressing mode limitation, by producing position 
independent code for programs that are relocatable (My 
definition of a relocatable program is this: it is a program 
to which the attribute position independence may or may not 
initially be applicable.  Regardless, however, the relocator 
will position the program in ram in a manner which 
guarantees that the validity of execution results does not 
depend on its location); and, fortunately, AssemPro provides 
relocatable code when a source file is assembled with the 
Relocatable assembly option checked.  For a time, therefore, 
the dilemma seemed moot.
     But the process is not as automatic as it seems.  The 
AssemPro manual attempts to provide an example, on pages 79 
and 80, to indicate a type of expression which the relocator 
would find unpalatable.  I have tried to deduced Mr. 
Schulz's intent, because it is not clearly stated.  
Furthermore, the example does not seem to contain enough 
information to render it informative.  I don't think that he 
intended to indicate that files containing these types of 
expressions will not be assembled, because I have assembled 
my own example.  The source file is program 6a.
     I have included various statements which use the 
declared labels in this program so that you can see what 
works and what doesn't.  Statement #5 is the only one that 
causes a run time error.  And the reason is not a mystery, 
as you can see in the disassembly listing shown in figure 
3.2.  The statement assembles into an instruction that 
attempts to store the contents of address -4 in register D0.

Program 6a. My source file for the discussion on pages 79 
and 80 of the AssemPro manual.

 ; Program Name: PRG_2AR.S
 ;      Version: 1.002

 ; Assembly Instructions:

 ;    Assemble in AssemPro Relocatable mode and save the assembled program
 ; with a PRG extension.

 ; Program Function:

 ;    Serves as a source file for the discussion on pages 79 and 80 of the
 ; AssemPro manual.

 move.l    up_1, d0
 move.l    up_2, d0
 move.l    #-4, d0        ; The statement below will resemble this one
                          ; after assembly.  Both are relocatable.
 move.l    #up_1-up_2,d0  ; This is Mr. Schulz's example.
 move.l    up_1-up_2, d0  ; I think he meant to use this type of example,
 data                     ; because this one does cause a problem.
pointer:   dc.l  up_1
up_1:      dc.l  5
up_2:      dc.l  3
 end


     This program was assembled in AssemPro's Relocatable 
mode, with the Listing option checked.  The listing was 
directed to the file shown in figure 3.1.  As you shall see 
in figure 3.2, a disassembled listing of program 6a, the 
expression #up_1-up_2 is evaluated to -4 during assembly.  
This fact is also evident in the listing of figure 3.1, 
where you are able to see that the object code on line 6 is 
actually that for the instruction: move.l #-4, d0, identical 
to the statement on line 5.  This is the instruction given 
as an example of one that is not relocatable in the AssemPro 
manual.  But I found that this instruction does not cause 
any problems.  In fact, I included the statement on line 5 
of the program to illustrate that it works whether it is 
introduced specifically into the program or it is assembled 
into that format by the assembler.  It is the statement on 
line 19 which causes a run time error.
  
Figure 3.1. Assembly listing for program 6a.

 Address Objectcode   Line    Sourcetext Assembly listing for PRG_2AR.S                                          
 
000000 :                 1   ; Program Name: PRG_2AR.S
000000 :                 2   ;      Version: 1.002
000000 :                 3
000000 :                 4   ; Assembly Instructions:
000000 :                 5
000000 :                 6   ;    Assemble in AssemPro Relocatable mode and save the assembled program
000000 :                 7   ; with a PRG extension.
000000 :                 8
000000 :                 9   ; Program Function:
000000 :                10
000000 :                11   ;    Serves as a source file for the discussion on pages 79 and 80 of the
000000 :                12   ; AssemPro manual.
000000 :                13
000000 :203900000022    14   move.l    up_1, d0
000006 :203900000026    15   move.l    up_2, d0
00000C :203CFFFFFFFC    16   move.l    #-4, d0        ; The statement below will resemble this one
000012 :                17                            ; after assembly.  Both are relocatable.
000012 :203CFFFFFFFC    18   move.l    #up_1-up_2,d0  ; This is Mr. Schulz's example.
000018 :2039FFFFFFFC    19   move.l    up_1-up_2, d0  ; I think he meant to use this type of example,
00001E :                20   data                     ; because this one does cause a problem.
00001E :00000022        21  pointer:   dc.l  up_1
000022 :00000005        22  up_1:      dc.l  5
000026 :00000003        23  up_2:      dc.l  3
00002A :                24   end


     The file shown in figure 3.2 was produced by clicking 
on the Disassembling option under the Debugger menu, then by 
typing $5D7B4 as the from address and $5D7DE as the to 
address.  When disassembling a program with this AssemPro 
function, you must always specify a to address that is 
beyond the last address you want to appear in the listing; 
furthermore, the address you specify must be beyond the 
address of the last item of data you wish to appear in the 
listing.  For example, the last address shown in the listing 
of figure 3.2 is $05D7DA.  The data located at that address 
is a longword (4 bytes) in length, therefore, the to address 
specified was $05D7DA + 4 = $05D7DE.


Figure 3.2. Disassembly listing for program 6a.

 Disassembled listing of PRG_2AR.PRG

05D7B4 20390005D7D6  MOVE.L $5D7D6,D0
05D7BA 20390005D7DA  MOVE.L $5D7DA,D0
05D7C0 203CFFFFFFFC  MOVE.L #-4,D0
05D7C6 203CFFFFFFFC  MOVE.L #-4,D0
05D7CC 2039FFFFFFFC  MOVE.L -4,D0
05D7D2 0005D7D6      ORI.B #-$2A,D5
05D7D6 00000005      ORI.B #5,D0
05D7DA 00000003      ORI.B #3,D0


     The disassembly listing clearly shows that an error 
will occur when an attempt is made to execute the fifth 
statement because that statement has been assembled into one 
which attempts to load the contents of a negative address 
into D0.  See figure 3.3.  The -4 produced in this statement 
(as is the -4 in the fourth statement) is the difference 
between the addresses of labels up_1 and up_2 during 
assembly.

  
Figure 3.3. Attempting to execute the fifth statement of 
figure 3.2 in the AssemPro debugger will cause an alert box 
similar to this one to appear.










   
     If the intent of a programmer is to store the 
difference between the contents of the run time addresses of 
labels up_1 and up_2 in D0, then, clearly, that does not 
happen.  I believe that this is the point which Mr. Schulz 
intended to make with his example.  Even if this was not his 
intent, the example still illustrates that assembly using 
AssemPro's Relocatable mode does not guarantee a position 
independent program, unless the elements of each statement 
in the program are congruous with relocatability.  As we 
have seen, it is possible to load and execute a position 
dependent program which has been assembled in the 
Relocatable mode.

A Few More Comments About the AssemPro Manual
  
     The paragraph concerning the advantage of a relocatable 
program on page 80 has not been correctly written.  Instead 
of "The advantage of a relocatable program...", the 
paragraph should merely indicate that labels can be used as 
destination operands in a program that is assembled in 
AssemPro's Relocatable mode.  Nothing else that is implied 
by that paragraph can be confirmed.  That the use of labels 
in destination operands is advantageous is a subjective 
opinion at best.  In fact, I shall show that the requisite 
memory of a program assembled in AssemPro's Relocatable mode 
can never be as low as if it were assembled in the PC-
relative mode; and, furthermore, the loading times required 
for programs assembled in the Relocatable mode are much 
greater than they are for those assembled in the PC-relative 
mode.
     The following characteristics are the major differences 
between the three AssemPro modes.  Some of these 
characteristics are not evident during the assembly process.

     1. When a program is assembled in PC-relative mode the 
        assembler automatically attaches a (PC) suffix to 
        labels used as source operands.  If the program were 
        assembled in the Absolute mode, the programmer would 
        have to manually attach the (pc) suffix to each 
        label.  During assembly, the assembler will issue an 
        error report, declaring that the effective address 
        is not acceptable, for each label used as a 
        destination operand.

     2. In a program assembled in the Relocatable mode, 
        labels are accepted as legal destination operands.  
        If used, the (pc) suffix must be inserted where 
        desired by the programmer.  As in item 1, above, the 
        assembler will flag instructions which contain a 
        label(pc) in a destination operand.

     3. Programs assembled in the Absolute or PC-relative 
        modes inherently require less memory and loading 
        time than do programs assembled in the Relocatable 
        mode.

Concept Definitions
  
     The concepts with which we must be concerned during 
this discussion involve assembly modes, run-time memory 
addresses and assembly-time addresses.  During program 
execution, addresses are referenced as data locations or as 
locations which must be forced into the program counter in 
order to effect a transfer of execution flow.  I will now 
define the necessary concepts and the conditions under which 
I will apply the terminology connected with each.  My 
comments concerning things to which the word absolute 
applies will be brief because our interests are in things to 
which the words program counter relative and relocatable 
apply.  Remember that PC-relative assembly is simply 
Absolute assembly with (PC) automatically inserted for 
convenience.  But remember also that there may be times when 
absolute assembly would be preferable to PC-relative 
assembly because of the 16-bit branch limitation associated 
with pc-relative addressing.  When that limitation can't be 
tolerated, automatic insertion of the (PC) suffix becomes an 
inconvenience.

Concept One
  
     The AssemPro assembler has three assembly options.  
These are PC-relative, Relocatable and Absolute.  For our 
convenience only, I will use the name of the mode in which a 
program was assembled as an adjective to describe a program 
assembled in that particular mode.  For example, I will say 
things such as "this is a PC-relative program; that is a 
Relocatable program.
     In addition to the AssemPro modes, I add one of my own, 
the Combination (Combo) mode.  A Combo program will be one 
that is assembled in AssemPro's Relocatable mode, but one in 
which the location of labels used as source operands in 
instructions are specified using the MC68000 Program Counter 
With Displacement addressing mode.  The Combo mode produces 
programs that take advantage of the faster execution speed 
and smaller memory requirements of the program counter with 
displacement addressing mode, and the mode also permits 
labels to be used in destination operands.

Concept Two
  
     The MC68000 microprocessor has among its addressing 
modes one which is called program counter with displacement, 
one which is called program counter with index, one which is 
called absolute short and one which is called absolute long.  
We will be interested in the absolute short and absolute 
long addressing modes when we wish to reference operating 
system variables while the processor is in its supervisor 
mode.  For the discussion in this chapter, we are primarily 
interested in the program counter with displacement mode.  
All of the references that I have seen replace this rather 
cumbersome phrase with pc-relative, and refer to the 
addressing mode as pc-relative addressing.  Now that I have 
pointed out the difference between PC-relative assembly and 
pc-relative addressing, we should be able to use this common 
notation with no problem.

The Rub
  
     Before I go further, because I am going to say what 
needs to be said about the MC68000, I must clarify my 
position.  I consider Motorola microprocessors to be the 
finest available.  And I speak from experience with their 
devices and Intel's.  Yet, were it not for a serious flaw 
(one of two) in the design of the MC68000 (My opinion, of 
course, but the only viewpoint from which a sane discussion 
of the processor's limitations can proceed.), this 
discussion would not be taking place.
     However else are we to view the obstacle to storing 
data that is inherent in the chip's design?  Are we to 
believe that someone would deliberately incorporate an 
addressing scheme which attempts to thwart data storage in 
the design of a computer's processor?  That is the snow job 
that most of the references parrot.  No, the extra coding 
that is necessary to overcome the limitation of the 
MC68000's pc-relative addressing mode makes sense, and is 
justified, only when that limitation is viewed as a design 
error.
     The flaw, of which I now speak, is the microprocessor's 
inability to accept pc-relative destination operands.  
Ostensibly, according to the references, Motorola chose this 
method to protect us from mad dog, crazy-running-amok, self-
modifying code producing programmers.  I shall prove to you 
that the design of the pc-relative addressing mode does not 
prevent the writing of data to destination operands; thus, I 
must conclude that, if the limitation was designed 
deliberately, it is a failure; therefore it is useless and 
only hinders programming effort.
     On the other hand, if the limitation was an error in 
design, I must conclude that it was not deliberate, and, 
being otherwise satisfied with the microprocessor, I choose 
to accept the task of designing my programs to work around 
the flaw.  That is this chapter's raison d'ˆtre: designing 
PC-relative programs that work in spite of the flaw.  The 
extra effort that must be exerted is justified as 
corrections to an honest mistake in design.  Furthermore, I 
will try to show you that there exists a viewpoint from 
which we can consider the flaw to be an incentive to 
inspirational algorithmic development, the result of which 
shall be algorithms that are faster and consume less memory 
than they might have were we not forced to use the 
corrections.

PC-Relative Addressing: The Microprocessor Option
  
     I have decided that the most coherent explanation of 
MC68000 pc-relative addressing is contained in the Kelly-
Bootle book.  See pages 59-70, 91-92, 112-115  and 186-196.  
But, of course, Mr. Kelly-Bootle's explanation is not Atari 
St specific; he did not intend that it be.  My explanation 
will fill in the blanks, but I do advise you to read Mr. 
Kelly-Bootle's pc-relative material, and, if you've the 
time, the other sections of chapters 1 through 7 you find 
pertinent.  I am especially fond of the quotation at the 
beginning of his introduction.
     The importance attached to pc-relative addressing on 
page 61 of the Kelly-Bootle book do not apply to the ST 
because of its built in relocator.  The assembly directive 
RORG does not apply either, because AssemPro replaces that 
directive with the PC-relative assembly option under the 
Assembler menu.  The importance of the LEA and PEA 
instructions in PC-relative programs is amply documented in 
this book, but there is a compound error on page 113.  The 
first part of the error is semantical.  MOVEA.Z #<label>, A0 
cannot be both equivalent and faster than LEA <label>, A0; 
if you don't see that, look up the definition of 
equivalence.
     The second part of the error is factual.  These 
instructions execute at identical speeds according to the 
Instruction Execution Times tables in the Motorola M68000 
Programmer's Reference Manual.  Furthermore, after I have 
covered sufficient introductory material, I will present a 
program which provides data which supports the Motorola 
manual.  In fact, if you think about it, why should the 
times be different.  Both instructions accomplish the same 
task.

PC-Relative Mode: The Assembler Option
  
    Only programs which contain no destination operands that 
are labels can be assembled with the assembler's PC-relative 
mode asserted.  This means that you cannot write 
instructions that store data in program variables by 
referencing the labels of dc and bss declarations.  Instead, 
you must store data in those locations via indirect 
reference.  You do that by storing the location of the label 
in an address register, then by using one of the MC68000's 
Address Register Indirect addressing modes in the 
destination operand portion of a data storing instruction.
     This is the extra effort that must be expended to 
nullify the flaw in the MC68000's Program Counter addressing 
modes.  However, this effort does not always represent an 
expense in speed and requisite memory.  Actually, expense is 
incurred only when a single reference to a label is required 
in a program, or when heavy register usage does not permit a 
register to be assigned to a variable during a significant 
portion of the program in which the variable must be 
referenced.
     When a program is assembled in the PC-relative mode, 
the assembler forces the addressing mode of every label used 
in an instruction operand into the MC68000 Program Counter 
With Displacement addressing mode.  Of course, an error will 
be reported for every instruction which contains a label in 
the destination operand.  While it is true that programs 
assembled in this mode are position independent, we are not 
as interested in this attribute of PC-relative programs as 
we are interested in their faster execution speed and lesser 
requisite memory, because we can obtain position 
independence simply by using the Relocatable mode.

Relocatable Mode: The Assembler Option
  
     As we have seen, it is possible to construct statements 
which the ST relocator cannot handle properly, even though 
the assembler will not sense an error.  I avoid such 
problems because I do not include mathematical expressions 
in my instruction operands.  I have enough problems with my 
programs without trying to outguess the relocator and the 
assembler.
     It may not be readily apparent that AssemPro's 
Relocatable mode does not preclude the use of the MC68000's 
program counter with displacement addressing mode.  I have 
decided to discuss such usage as though it were another 
assembly mode.  I do this only because Mr. Schulz stressed 
the automatic inclusion of (PC) for labels used as source 
operands when assembly takes place in his PC-relative mode, 
and I want to stress the advantage of using the processor's 
pc-relative mode in programs that are to be assembled in 
AssemPro's Relocatable mode, even though (pc) must be 
manually typed after ever label in a source operand.

Combination Mode: The Option Mr. Schulz Forgot

     If AssemPro had been provided with an assembly mode 
that inserted the (pc) for labels used as source operands, 
but which simply ignored destination operands, then 
assembled in Relocatable format, we would not have to type 
(pc) behind each label in our source operands to take 
advantage of the pc-relative addressing mode in Relocatable 
programs.  As you shall see, by using the (pc) suffix 
judiciously, we shall be able to reduce both execution time 
and requisite memory.

Comparing Assembler Modes
  
     The introduction of the program 6a provides me with the 
opportunity to begin a comparative analysis of the 
consequences of each Assembler mode.  You have already seen 
three forms of a program assembled in the Relocatable mode.  
I would like you to obtain one piece of information about 
PRG_2AR.PRG from the desktop.  By clicking one on the 
program's icon, then by selecting Show Info under the File 
menu, you will be able to observe and record the disk space 
occupied by the program.  It is 78 bytes.
     You can obtain a PC-relative version of the program, 
simply by loading PRG_2AR.S into the editor, clicking on 
AssemPro's PC-relative Assembly option and assembling.  
Change the file name to PRG_2AP and save the assembled 
program to disk with a PRG extension.  From the desktop, 
obtain the disk space occupied by the program (PRG_2AP.PRG).  
It is 64 bytes.
     Program 6b is a listing of PRG_2AR.S transformed into a 
program that uses pc-relative addressing for the labels in 
the source operands.  You should assemble this program in 
the Relocatable mode, change the file name to PRG_2AC and 
save the assembled code to disk as PRG_2AC.PRG.  From the 
desktop, obtain the disk space occupied by the program.  It 
is 72 bytes.
  
Program 6b. PRG_2AR.S altered to produce PRG_2AC.S, a Combo 
program.
 
 ; Program Name: PRG_2AC.S
 ;      Version: 1.002

 ; Assembly Instructions:

 ;    Assemble in AssemPro Relocatable mode and save the assembled program
 ; with a PRG extension.

 ; Program Function:

 ;    Serves as a source file for the discussion on pages 79 and 80 of the
 ; AssemPro manual.

 move.l    up_1(pc), d0
 move.l    up_2(pc), d0
 move.l    #-4, d0

 move.l    #up_1-up_2,d0  ; (pc) can't be used with the labels here.
 move.l    up_1-up_2, d0  ; (pc) can't be used with the labels here.

 ; NOTE: If the (pc) suffix is attached to both labels in the above
 ;       statement, the assembler will flag the first as an error.  If the
 ;       (pc) suffix is attached only to the second label, the instruction
 ;       will be assembled into a statement that moves a portion of the 
 ;       the preceding statement into register D0.

 data
pointer:   dc.l  up_1
up_1:      dc.l  5
up_2:      dc.l  3
 end


     The disassemby listing of PRG_2AR.S assembled in the 
PC-relative mode is shown in figure 3.5.  There you can see 
one of the reasons that PRG_2AP.PRG has a lower requisite 
memory than PRG_2AR.PRG.  The first, second and fifth lines 
of the disassembly listing show that the labels in these 
instructions have been cast in the pc-relative addressing 
mode by the assembler, therefore, these source operands 
require only one word of extension, whereas those 
instructions in PRG_2AR.PRG require two words of extension.
     Six bytes of requisite memory are saved via the use of 
the pc-relative addressing mode, two for each of the three 
instructions.  The additional eight byte differential 
between the requisite memory for PRG_2AR.PRG and PRG_2AP.PRG 
is due to the information which must be stored for the 
relocator in PRG_2AR.PRG, as discussed on page 80 of the 
AssemPro manual.

Figure 3.5. Disassembly listing for program 6a assembled in 
the PC-relative mode.

 Disassembly listing of PRG_2AP.PRG

06D5DA 203A001A      MOVE.L $6D5F6(PC),D0
06D5DE 203A001A      MOVE.L $6D5FA(PC),D0
06D5E2 203CFFFFFFFC  MOVE.L #-4,D0
06D5E8 203CFFFFFFFC  MOVE.L #-4,D0
06D5EE 203AFFE6      MOVE.L $6D5D6(PC),D0

 NOTE: Although the above statement has been assembled
       without an error indication, the effective address
       is not within the program's boundaries.

06D5F2 0000001C      ORI.B #$1C,D0
06D5F6 00000005      ORI.B #5,D0
06D5FA 00000003      ORI.B #3,D0


     The disassembly listing for PRG_2AC.PRG, shown in 
figure 3.6, illustrates that the extension word savings can 
be obtained when the pc-relative addressing mode is applied 
to appropriate instructions in programs that are assembled 
in the Relocatable mode.  In PRG_2AC.PRG, the pc-relative 
mode can be applied to the first and second instructions.  
This yields a four-byte savings.  An additional 2 bytes are 
saved because less information must be stored for the 
relocator in this program.

Figure 3.6. Disassembly listing for program 6b.

 Disassembly listing of PRG_2AC.PRG

06D4F6 203A001C      MOVE.L $6D514(PC),D0
06D4FA 203A001C      MOVE.L $6D518(PC),D0
06D4FE 203CFFFFFFFC  MOVE.L #-4,D0
06D504 203CFFFFFFFC  MOVE.L #-4,D0
06D50A 2039FFFFFFFC  MOVE.L -4,D0
06D510 0006D514      ORI.B #$14,D6
06D514 00000005      ORI.B #5,D0
06D518 00000003      ORI.B #3,D0
  
  
     These somewhat trivial comparisons have been introduced 
in order to prepare you for the more complicated comparisons 
to follow.  Besides the requisite memory differentials 
between the three programs, by referring to the disassembly 
listings, you should notice that the correct run-time 
address of label up_1 is stored at the label pointer when 
the example program is assembled in the Relocatable or Combo 
modes, but when it is assembled in the PC-relative mode, the 
value stored at pointer is the assembly-time location of the 
label up_1.  See figure 3.7.
  
Figure 3.7. Assembly listing for program 6a assembled in the 
PC-relative mode.  Compare the assembly-time address of up_1 
to the run-time address stored at pointer in figure 3.5 and 
notice that they are the same.  That is not what was 
desired.

Address Objectcode   Line    Sourcetext PRG_2AR.S assembled in PC-relative mode                                 

000000 :                1   ; Program Name: PRG_2AR.S
000000 :                2   ;      Version: 1.002
000000 :                3
000000 :                4   ; Assembly Instructions:
000000 :                5
000000 :                6   ;    Assemble in AssemPro Relocatable mode and save the assembled program
000000 :                7   ; with a PRG extension.
000000 :                8
000000 :                9   ; Program Function:
000000 :               10
000000 :               11   ;    Serves as a source file for the discussion on pages 79 and 80 of the
000000 :               12   ; AssemPro manual.
000000 :               13
000000 :203A001A       14   move.l    up_1, d0
000004 :203A001A       15   move.l    up_2, d0
000008 :203CFFFFFFFC   16   move.l    #-4, d0        ; The statement below will resemble this one
00000E :               17                            ; after assembly.  Both are relocatable.
00000E :203CFFFFFFFC   18   move.l    #up_1-up_2,d0  ; This is Mr. Schulz's example.
000014 :203AFFE6       19   move.l    up_1-up_2, d0  ; I think he meant to use this type of example,
000018 :               20   data                     ; because this one does cause a problem.
000018 :0000001C       21  pointer:   dc.l  up_1
00001C :00000005       22  up_1:      dc.l  5
000020 :00000003       23  up_2:      dc.l  3
000024 :               24   end


     In addition to the incompatibility between the 
declarations and the PC-relative mode just discussed, 
certain move instructions are not compatible with assembly 
in the PC-relative mode.  Programs 7a-7d are sources 
prepared for assembly in each of the four possible assembly 
modes.  The name of each source listing indicates the mode 
of assembly.  The comments in each program convey assembly 
and run-time expectations and the suitability or 
unsuitability of pertinent instructions relative to the mode 
of assembly.  Program 8 is a final example that stresses the 
differences between instructions which are compatible with 
PC-relative assembly and those which aren't.  This program 
can be assembled in Relocatable or PC-relative mode.  But 
when it is assembled in PC-relative mode, the code for 
portions of it is not what we want.

Program 7a. ABSOLUTE.S

 ; Program Name: Absolute.s
 ;      Version: 1.001

 ; Assembly Instructions:

 ;      Assemble in Absolute mode.

 ; Execution Instructions:

 ;      Go to the debugger and single step through the first 3 instructions.
 ; When you attempt to single step the 4th instruction a BUS ERROR will occur.
 ; Press the Return key when the alert box appears.  Then move the mouse arrow
 ; to the 5th instruction in the debugger output field and, while holding the
 ; Control key pressed, click on the left mouse button to move the program
 ; counter cursor to the 5th instruction.  Finally, single step the 5th
 ; instruction.

 ; Record the values that are stored in each of the four registers D0, D1,
 ; A0 and A1.

 lea       label(pc), a0        ; Label's run time address is moved into A0.
 move.l    label(pc), d0        ; Label's contents are moved into D0.
 movea.l   #label, a1           ; Label's assembly time add is moved into A1.

 ; NOTE:  The MC68000 does not permit the (PC) suffix to be attached to a
 ;        label that is preceded by a # sign.

 move.l    #$0, label

 ; Result of executing the above instruction is a BUS ERROR because label's
 ; address is its assembly time value, and that value is an address that can
 ; only be accessed while the processor is in supervisor mode.  You can prove
 ; that this is true by clicking on the status register S box in the debugger
 ; screen before executing the instruction again.  After that, I suggest that
 ; you reset the computer because storing $0 at that address may not be a
 ; healthy thing to do.

 ; NOTE:   Manually move the program counter cursor to the next instruction.

 move.l    label(pc), d1        ; Label's contents are moved into D1.

label:     dc.l $FFFFFFFF       ; Label's contents initialized to -1.

 end

  
Program 7b. COMBO.S

 ; Program Name: Combo.s
 ;      Version: 1.001

 ; Assembly Instructions:

 ;      Assemble in Relocatable mode.

 ; Execution Instructions:

 ;      Go to the debugger and click on the relocate button.  Single step
 ; through the 5 instructions.  Record the values that are stored in each
 ; of the four registers D0, D1, A0 and A1.

 lea       label(pc), a0        ; Label's run time address is moved into A0.
 move.l    label(pc), d0        ; Label's contents are moved into D0.
 movea.l   #label, a1           ; Label's run time address is moved into A1.
 move.l    #$0, label           ; Label's contents are changed to $00000000.

 ; NOTE:  If you want to see the new contents of label after the above
 ;        instruction is executed, click twice on the disassembled button
 ;        located in the lower right hand corner of the debugger screen.

 move.l    label(pc), d1        ; Label's contents are moved into D1.

label:     dc.l $FFFFFFFF       ; Label's contents initialized to -1.
 end

Program 7c. RELATIVE.S.

 ; Program Name: Relative.s
 ;      Version: 1.001

 ; Assembly Instructions:

 ;      Attempt to assemble in PC-relative mode.  The assembler will not
 ; accept the 4th instruction because of the attempt to use a label as a
 ; destination operand.  Type a semicolon in front of the instruction in
 ; order to comment it out, then assemble the program.

 ; Execution Instructions:

 ;      Go to the debugger and note that the assembler has attached a (PC)
 ; suffix to the source operand "label" in the 1st, 2nd and 4th instructions.
 ; Single step through the 4 instructions.  Record the values that are stored
 ; in each of the four registers D0, D1, A0 and A1.

 lea       label, a0            ; Label's run time address is moved into A0.
 move.l    label, d0            ; Label's contents are moved into D0.
 movea.l   #label, a1           ; Label's assembly time address is moved into A1.

 ; NOTE:  The assembler will not attach a (PC) suffix to the source operand
 ;        "label" in the above instruction.

 move.l    #$0, label 

 ; Assembler will not accept "label" as a destination operand because AssemPro
 ; attaches a (PC) suffix to every label which is not preceded by a # sign in
 ; a program that is assembled in the PC-relative mode.  The MC68000 does not
 ; permit the (PC) suffix attachment to labels that are destination operands.

 move.l    label(pc), d1        ; Label's contents are moved into D1.

label:     dc.l $FFFFFFFF       ; Label's contents initialized to -1.

 end

Program 7d. RELOCATE.S

 ; Program Name: Relocate.s
 ;      Version: 1.001

 ; Assembly Instructions:

 ;      Assemble in Relocatable mode.

 ; Execution Instructions:

 ;      Go to the debugger and click on the relocate button.  Single step
 ; through the 5 instructions.  Record the values that are stored in each
 ; of the four registers D0, D1, A0 and A1.

 lea       label, a0            ; Label's run time address is moved into A0.
 move.l    label, d0            ; Label's contents are moved into D0.
 movea.l   #label, a1           ; Label's run time address is moved into A1.
 move.l    #$0, label           ; Label's contents are changed to $00000000.

 ; NOTE:  If you want to see the new contents of label after the above
 ;        instruction is executed, click twice on the disassembled button
 ;        located in the lower right hand corner of the debugger screen.

 move.l    label, d1            ; Label's contents are moved into D1.

label:     dc.l $FFFFFFFF       ; Label's contents initialized to -1.

 end


Program 8. Instructions that are compatible with PC-relative 
assembly and those that aren't.

 ; Program Name: PRG_2BR.S

 ; Assembly Instructions:

 ;    The algorithms in this program can be assembled in Relocatable or
 ; PC-relative mode.  But when they are assembled in PC-relative mode, the
 ; code is not always what we want.

 ; Experiment 1.

 ;    Shows that a pointer, declared in the data section, to a variable
 ; declared in the bss section will contain the correct address when
 ; assembly is in Relocatable mode; but when assembled in PC-relative mode,
 ; the pointer will contain the location at which the variable resided
 ; during the assembly process.

 movea.l   _variable, a0       ; A pointer to a variable is loaded into
                               ; an address register.
 ; End of Experiment 1.

 ; Experiment 2.

 ;    Illustrates that the instructions

 ;         move.l #label, -(sp)
 ;         move.l #label, An

 ; are not compatible with assembly in the PC-relative mode, and that
 ; the following instructions must be used instead.

 ;         pea    label
 ;         lea    label.

 move.l    #label_1, -(sp)
 move.l    #label_1, a0
 move.l    #label_2, -(sp)
 move.l    #label_2, a1

 pea       label_1
 lea       label_1, a0
 pea       label_2
 lea       label_2, a1

 ; End of Experiment 2.

 data
label_1:   dc.l      1
_variable: dc.l variable       ; _variable is a pointer to variable.
 bss
label_2:   ds.l      1
variable:  ds.l      1         ; During loading, we want the address of
                               ; this variable to be stored in the
                               ; location addressed by the pointer.
 end


     You should assemble this program in both the 
Relocatable and PC-relative modes so that you can compare 
the assembly and disassembly listings.  My assembly listings 
appear in figures 3.8 and 3.9.  The disassembly listings are 
shown in figures 3.10 and 3.11.  The assembly-time addresses 
of the variables declared in the data and bss segments of 
the program are evident in figures 3.8 and 3.9.  These 
should be compared to the addresses that would be loaded 
into the arrays and the stack at run-time, as shown in 
disassembly listings.
  
Figure 3.8. Assembly listing for PRG_2BR.S assembled in the 
PC-relative mode.

 Address Objectcode  Line    Sourcetext PRG_2BR.S Assembled in PC-relative mode                                

000000 :                1   ; Program Name: PRG_2BR.S
000000 :                2
000000 :                3   ; Assembly Instructions:
000000 :                4
000000 :                5   ;    The algorithms in this program can be assembled in Relocatable or
000000 :                6   ; PC-relative mode.  But when they are assembled in PC-relative mode, the
000000 :                7   ; code is not always what we want.
000000 :                8
000000 :                9   ; Experiment 1.
000000 :               10
000000 :               11   ;    Shows that a pointer, declared in the data section, to a variable
000000 :               12   ; declared in the bss section will contain the correct address when
000000 :               13   ; assembly is in Relocatable mode; but when assembled in PC-relative mode,
000000 :               14   ; the pointer will contain the location at which the variable resided
000000 :               15   ; during the assembly process.
000000 :               16
000000 :207A002E       17   movea.l   _variable, a0       ; A pointer to a variable is loaded into
000004 :               18                                 ; an address register.
000004 :               19   ; End of Experiment 1.
000004 :               20
000004 :               21   ; Experiment 2.
000004 :               22
000004 :               23   ;    Illustrates that the instructions
000004 :               24
000004 :               25   ;         move.l #label, -(sp)
000004 :               26   ;         move.l #label, An
000004 :               27
000004 :               28   ; are not compatible with assembly in the PC-relative mode, and that
000004 :               29   ; the following instructions must be used instead.
000004 :               30
000004 :               31   ;         pea    label
000004 :               32   ;         lea    label.
000004 :               33
000004 :2F3C0000002C   34   move.l    #label_1, -(sp)
00000A :207C0000002C   35   move.l    #label_1, a0
000010 :2F3C00000034   36   move.l    #label_2, -(sp)
000016 :227C00000034   37   move.l    #label_2, a1
00001C :               38
00001C :487A000E       39   pea       label_1
000020 :41FA000A       40   lea       label_1, a0
000024 :487A000E       41   pea       label_2
000028 :43FA000A       42   lea       label_2, a1
00002C :               43
00002C :               44   ; End of Experiment 2.
00002C :               45
00002C :               46   data
00002C :00000001       47  label_1:   dc.l      1
000030 :00000038       48  _variable: dc.l variable       ; _variable is a pointer to variable.
000034 :               49   bss
000034 : ^     4       50  label_2:   ds.l      1
000038 : ^     4       51  variable:  ds.l      1         ; During loading, we want the address of
00003C :               52                                 ; this variable to be stored in the
00003C :               53                                 ; location addressed by the pointer.
00003C :               54   end


Figure 3.9. Assembly listing for PRG_2BR.S assembled in the 
Relocatable mode.

 Address Objectcode  Line    Sourcetext PRG_2BR.S Assembled in Relocatable mode                                

000000 :                1   ; Program Name: PRG_2BR.S
000000 :                2
000000 :                3   ; Assembly Instructions:
000000 :                4
000000 :                5   ;    The algorithms in this program can be assembled in Relocatable or
000000 :                6   ; PC-relative mode.  But when they are assembled in PC-relative mode, the
000000 :                7   ; code is not always what we want.
000000 :                8
000000 :                9   ; Experiment 1.
000000 :               10
000000 :               11   ;    Shows that a pointer, declared in the data section, to a variable
000000 :               12   ; declared in the bss section will contain the correct address when
000000 :               13   ; assembly is in Relocatable mode; but when assembled in PC-relative mode,
000000 :               14   ; the pointer will contain the location at which the variable resided
000000 :               15   ; during the assembly process.
000000 :               16
000000 :20790000003A   17   movea.l   _variable, a0       ; A pointer to a variable is loaded into
000006 :               18                                 ; an address register.
000006 :               19   ; End of Experiment 1.
000006 :               20
000006 :               21   ; Experiment 2.
000006 :               22
000006 :               23   ;    Illustrates that the instructions
000006 :               24
000006 :               25   ;         move.l #label, -(sp)
000006 :               26   ;         move.l #label, An
000006 :               27
000006 :               28   ; are not compatible with assembly in the PC-relative mode, and that
000006 :               29   ; the following instructions must be used instead.
000006 :               30
000006 :               31   ;         pea    label
000006 :               32   ;         lea    label.
000006 :               33
000006 :2F3C00000036   34   move.l    #label_1, -(sp)
00000C :207C00000036   35   move.l    #label_1, a0
000012 :2F3C0000003E   36   move.l    #label_2, -(sp)
000018 :227C0000003E   37   move.l    #label_2, a1
00001E :               38
00001E :487900000036   39   pea       label_1
000024 :41F900000036   40   lea       label_1, a0
00002A :48790000003E   41   pea       label_2
000030 :43F90000003E   42   lea       label_2, a1
000036 :               43
000036 :               44   ; End of Experiment 2.
000036 :               45
000036 :               46   data
000036 :00000001       47  label_1:   dc.l      1
00003A :00000042       48  _variable: dc.l variable       ; _variable is a pointer to variable.
00003E :               49   bss
00003E : ^     4       50  label_2:   ds.l      1
000042 : ^     4       51  variable:  ds.l      1         ; During loading, we want the address of
000046 :               52                                 ; this variable to be stored in the
000046 :               53                                 ; location addressed by the pointer.
000046 :               54   end


Figure 3.10. Disassembly listing for PRG_2BR.S assembled in 
the PC-relative mode.

 PRG_2BR.S assembled in PC-relative mode

05A1E6 207A002E      MOVEA.L $5A216(PC),A0
05A1EA 2F3C0000002C  MOVE.L #$2C,-(A7)
05A1F0 207C0000002C  MOVEA.L #$2C,A0
05A1F6 2F3C00000034  MOVE.L #$34,-(A7)
05A1FC 227C00000034  MOVEA.L #$34,A1
05A202 487A000E      PEA $5A212(PC)
05A206 41FA000A      LEA $5A212(PC),A0
05A20A 487A000E      PEA $5A21A(PC)
05A20E 43FA000A      LEA $5A21A(PC),A1
05A212 00000001      ORI.B #1,D0         ; location of label_1.
05A216 00000038      ORI.B #$38,D0       ; location of _variable.
05A21A 542E5300      ADDQ.B #2,$5300(A6) ; location of label_2.
05A21E 4620          NOT.B -(A0)         ; location of variable.
05A220 5259          ADDQ.W #1,(A1)+


     Looking at the first instruction in figure 3.10, you 
can see that the value $38, which is the contents of memory 
location $05A216, will be loaded into register A0.  With 
this instruction, the value we wanted to store in A0 is the 
run-time address of variable.  Referring to figure 3.11, you 
can see that this desire is fulfilled when the program is 
assembled in the Relocatable mode.  This is a good time to 
point out that, although the disassembler indicates the 
actual address from which the value will be taken in the 
first instruction of figure 3.10, the object code itself 
references the location relatively.
     The object code at address $05A1E6 can be divided into 
the instruction word and the extension word as shown below.

                   Instruction word: 207A

                   Extension Word:   002E

The instruction word can be divided into its component bits 
as shown below:

            Component  1  2  3   4   5   6
            
                      00 10 000 001 111 010 
              
     The first component of the instruction word indicates a 
movea operation; the second component indicates that the 
operation is word size.  Remember, our instruction indicated 
that the operation was to be longword size.  The operation 
size is reduced automatically because the effective address 
is now specified in the pc-relative addressing mode.  Even 
so, the word size operand will be extended to a 32 bit 
quantity before the operation is done, because the 
destination is an address register.
     The third component of the instruction word indicates 
that the destination register is 0, and the fourth component 
indicates that the destination is an address register.  The 
fifth and sixth components indicate that effective address 
of the source operand is specified by pc-relative 
addressing.  The displacement to be used in calculating the 
address of the source operand is specified in the extension 
word; that value is $2E.
     The actual address of the source operand is calculated 
by adding $2E to the contents of the program counter when it 
contains the address of the extension word.  That is, 
$05A1E8 + $2E = $5A216.  The disassembler kindly shows us 
the results of the computation in the disassembly listing.  
Referring to the disassembly listing for the Relocatable 
program, in figure 3.11, you can see that no such 
computation is necessary because the actual address of the 
source operand is included in the object code for the first 
instruction.
     Figure 3.10 also shows that the values pushed onto the 
stack or loaded into the address registers  by the next four 
instructions of the program will produce equally undesirable 
results.  Then, the four instructions which follow those 
four illustrate the use of lea and pea to load the correct 
run-time addresses into address registers and the stack in a 
PC-relative program.  For example, the first pea instruction 
will push the address equal to the value in the extension 
word, $E, plus the address of the extension word, $5A204, 
which is $5A212, the address of label_1.

Figure 3.11. Disassembly listing for PRG_2BR.S assembled in 
the Relocatable mode.

 PRG_2BR.S assembled in Relocatable mode

05A1E6 20790005A220  MOVEA.L $5A220,A0
05A1EC 2F3C0005A21C  MOVE.L #$5A21C,-(A7)
05A1F2 207C0005A21C  MOVEA.L #$5A21C,A0
05A1F8 2F3C0005A224  MOVE.L #$5A224,-(A7)
05A1FE 227C0005A224  MOVEA.L #$5A224,A1
05A204 48790005A21C  PEA $5A21C
05A20A 41F90005A21C  LEA $5A21C,A0
05A210 48790005A224  PEA $5A224
05A216 43F90005A224  LEA $5A224,A1
05A21C 00000001      ORI.B #1,D0         ; location of label_1.
05A220 0005A228      ORI.B #$28,D5       ; location of _variable.
05A224 00000002      ORI.B #2,D0         ; location of label_2.
05A228 06060606      ADDI.B #6,D6        ; location of variable.


     So far, I have concentrated on the requisite memory 
advantage of pc-relative addressing, whether is is 
accomplished via the PC-relative assembly mode or by forcing 
the mode on labels which are source operands in programs 
assembled in the Relocatable mode.  In chapter 6 I will 
focus attention on the execution speed advantage of pc-
relative addressing and the loading speed advantage of 
programs assembled in AssemPro's PC-relative mode.

Emphasizing Speed
  
     Writing algorithms that execute rapidly requires 
discipline and dedication to the task of learning which 
instructions execute fastest and a somewhat fanatical desire 
to seek out those less obvious instruction combinations 
which execute faster than those which seem to flow from the 
intellect much faster than their execution time.  Magazine 
articles are probably the best reference material for coding 
that concentrates of speed improvement.
     An excellent example of such an article, which 
discusses speed and traps (not the exception kind), is 68000 
Tricks and Traps, by Mike Morton, published in Byte, 
September, 1986, pages 163-172.  This is article is so 
valuable, I suggest that you write to Byte for a reprint, or 
try to obtain one from a library.  During your search for 
the fastest algorithms, I caution you to believe only what 
you prove with your own programs.  Some references advance 
claims that seem to be untried and unproven.
     For example, Mr. Morton advances the following 
conclusion: multiplying a word by 4 is faster with

                      add.w dn,dn
  
                      add.w dn,dn
  
than                  asl.w #2, dn.
  
I will present a program which refutes this assertion in 
chapter 6.  Also, in his section on Fast subroutine calls, 
Mr. Morton seems to indicate that the LEA instruction always 
references labels with pc-relative addressing; this is not 
true for programs assembled in AssemPro's Relocatable mode, 
unless the pc-relative addressing is forced with label(pc).
     The first stage of increasing a program's execution 
speed is getting it into ram as fast as possible.  Some ways 
of doing this is by moving from a ram disk to main ram, 
using utilities such as Switch/Back, produced by Alpha 
Systems (I use this product.), and by reducing the loading 
time.  This latter method will be discussed in chapter 6.  
Before I can introduce the algorithm that I shall use to 
measure a program's load and execute time, I must present 
the introductory material which makes the algorithm 
comprehensible.

Conclusion
  
     In this chapter my intent was to show you the 
difference between programs produced by four assembly modes.  
In future chapters, the emphasis will be placed on programs 
assembled in the PC-relative mode.  In addition, I have 
distinguished pc-relative addressing from AssemPro's PC-
relative assembly mode.
     The basics of pc-relative addressing is covered in the 
references, most comprehensively in the Kelly-Bootle book.  
But you will see more examples of its use in the programs to 
be presented in future chapters of this book.  I have 
assumed the task of explaining the significance of 
AssemPro's PC-relative and Relocatable assembly modes, and I 
have suggested that programs which explicitly use pc-
relative addressing and are assembled in the Relocatable 
mode are best understood when their mode of assembly is 
referenced as if it were a fourth option.

