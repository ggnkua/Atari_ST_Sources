 ' RAIL_MAN 2.00 D OMIKRON-BASIC-Musterprogramm
 ' ============================================
 '
 ' Letze énderung: 01.05.1990
 '
 ' (C) 1990 by Martin Birn
 ' Knoblochstraûe 51, 7100 Heilbronn
 ' ----------------------------------------------------------------------------

 LIBRARY Gem ,"Gem.lib"

 'Konstanten-Definition fÅr RSC-Elemente

 Menue%=0
 Desk%=3
 Info%=7
 Datei%=4
 Fpl1%=16:Fpl2%=17:Fpl3%=18
 Quit%=20

 CLS
 Appl_Init
 Rsrc_Load("RAIL_OMP.RSC",X%L)
 IF X%L<>1 THEN
   PRINT CHR$(7);
   FORM_ALERT (1,"[3][Resourcedatei nicht gefunden.][Abbruch]")
   Appl_Exit
   END
 ENDIF

 Rsrc_Gaddr(0,Menue%,Menu_Addr%L)
 Menu_Bar(Menu_Addr%L)
 Graf_Mouse(0)

 Rail_Init

 REPEAT
   Evnt_Mesag(X$)
   FOR I%=0 TO 7
     Message%L(I%)= CVI( MID$(X$,I%*2+1,2))
   NEXT I%

   IF Message%L(0)=Mn_Selected%L THEN

     IF Message%L(4)=Info% THEN
       PRINT CHR$(7);
       FORM_ALERT (1,"[1][RAIL_MAN 2.00 D Basic-Binding|(C) 1990 by Martin Birn|            Knoblochstraûe 51|            7100 Heilbronn][ OK ]")
       Menu_Tnormal(Desk%,1)
     ENDIF

     IF Message%L(4)=Quit% THEN
       Menu_Tnormal(Datei%,1)
       A_End(0,Handle%)
       Appl_Exit
       END
     ENDIF

     IF Message%L(4)=Fpl1% THEN
       Fahrplan1
       Menu_Tnormal(Datei%,1)
     ENDIF

     IF Message%L(4)=Fpl2% THEN
       Fahrplan2
       Menu_Tnormal(Datei%,1)
     ENDIF

     IF Message%L(4)=Fpl3% THEN
       Fahrplan3
       Menu_Tnormal(Datei%,1)
     ENDIF

   ENDIF

 UNTIL 0

 'In die hier folgenden Proceduren kînnen Sie beliebige Befehle zur Steuerung
 'einfÅgen. Die FahrplÑne werden dann Åber die entsprechenden MenÅeintrÑge
 'gestartet.

 DEF PROC Fahrplan1
   A_End(0,100)'einen Fehler zur Demonstration
 RETURN

 DEF PROC Fahrplan2
 RETURN

 DEF PROC Fahrplan3
 RETURN

 '
 'Funktionsgruppe A
 '
 DEF PROC A_Start(R Ret%L)
   GEMDOS (Ret%L,253,0)
 RETURN

 DEF PROC A_End(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,1,Handle%)
   Rail_Err(Ret%L AND $FFFF)
   IF Rail_Addr%L<>0 THEN
     FRE Rail_Addr%L
   ENDIF
 RETURN

 DEF PROC A_State(R Ret%L,Handle%,Mode%)
   GEMDOS (Ret%L,253,2,Handle%,Mode%)
   Rail_Err Ret%L
 RETURN

 DEF PROC A_Wait(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,3,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC A_Reset(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,5,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC A_Update(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,6,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe E (Engine = Loksteuerung)
 '

 DEF PROC E_Speed(R Ret%L,Handle%,Index%,Mode%,Speed%)
   GEMDOS (Ret%L,253,7,Handle%,Index%,Mode%,Speed%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Direction(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,8,Handle%,Index%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Mode(R Ret%L,Handle%,Index%,Mode%)
   GEMDOS (Ret%L,253,9,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Function(R Ret%L,Handle%,Index%,Number%,Mode%)
   GEMDOS (Ret%L,253,10,Handle%,Index%,Number%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe S (Switch = Weiche)
 '

 DEF PROC S_Setgroup(R Ret%L,Handle%,Index%,Mode%)
   GEMDOS (Ret%L,253,11,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Delgroup(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,12,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Switch(R Ret%L,Handle%,Index%,Mode%,Direction%)
   GEMDOS (Ret%L,253,13,Handle%,Index%,Mode%,Direction%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Bswitch(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,21,Handle%,Index%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe R (RÅckmeldungen)
 '

 DEF PROC R_Start(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,14,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC R_Stop(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,15,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe Q (reQuest = Nachfragefunktionen)
 '

 DEF PROC Q_Version(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,16,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC Q_Array(R Ret%L,Handle%,Addr%L)
   GEMDOS (Ret%L,253,17,Handle%,L Addr%L):
   Rail_Err(Ret%L)
 RETURN

 DEF PROC Q_File(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,18,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe X (information eXchange = Infoaustausch)
 '

 DEF PROC X_Search(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,19,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC X_Updated(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,20,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC X_Done(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,22,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' vorgefertigte Funktionen bzw. Routinen
 '

 '
 'initialisieren und besorgen eines Handles
 'GLOBALE VARIABLEN: Handle%,Rail_Eflg%,Rail_addr
 '

 DEF PROC Rail_Init
   LOCAL Rret%L,X%
   A_Start(Rret%L)
   IF Rret%L=-32 THEN 'Accessory installiert?
     Rret%L=0'nein
     PRINT CHR$(7);
     MOUSEON : FORM_ALERT (1,"[3][RAIL_MAN nicht installiert][Abbruch]",X%)
   ELSE
     Rail_Eflg%=0'alles klar
     Rail_Err(Rret%L)'Handle berechnen
     Handle%=Rret%L
     Rail_Addr%L= MEMORY(100)
     Q_Array(Rret%L,Handle%,Rail_Addr%L)'und fÅllen lassen
   ENDIF
 RETURN

 DEF PROC Rail_Err(R Ercd%L)
   LOCAL E%,A%L,Code%L
   Code%L=Ercd%L
   Ercd%L=Code%L AND $FFFF
   IF Ercd%L>$EFFF THEN Ercd%L=-($10000-Ercd%L): ENDIF
   IF Ercd%L<>-1020 AND Rail_Eflg%=0 THEN 'bei falschem Handle oder laufendem Redraw kein Redraw!!
     '
     'DER FOLGENDE BEFEHL IST EXTREM WICHTIG!!
     '
     Rail_Eflg%=1'keine weiteren Redraw-Messages
     IF Code%L AND 2^16 THEN Redraw: ENDIF
     IF Code%L AND 2^17 THEN Rm_Update: ENDIF
     IF Code%L AND 2^18 THEN Rd_File: ENDIF
     IF Code%L AND 2^19 THEN Lok_Update: ENDIF
     Rail_Eflg%=0'Redraw wieder zulassen
   ENDIF
   E%=-(Ercd%L+1000)
   IF Rail_Addr%L<>0 AND E%>0 AND E%<= LPEEK( LPEEK(Rail_Addr%L+22*4)) THEN
     'falls Feld belegt und E% im erwarteten Bereich
     PRINT CHR$(7);
     MOUSEON
     Addrin%L(0)= LPEEK( LPEEK(Rail_Addr%L+22*4)+4*E%)'Adresse des Strings Åbergeben
     Intin%(0)=1'Default-Button 1
     AES (52,Global%(15),Intin%(1),Addrin%L(1),Intout%(1),Addrout%L(0))
   ENDIF
 RETURN

 ' ----------------------------------------------------------------------------
 ' Redraw-UP

 DEF PROC Redraw
   LOCAL Rret%L
   REPEAT
     X_Search(Rret%L,Handle%)'RÅckgabewert holen
   UNTIL Rret%L=0
 RETURN

 DEF PROC Rm_Update
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,1)
 RETURN

 DEF PROC Rd_File
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,2)
 RETURN

 DEF PROC Lok_Update
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,3)
 RETURN

 LIBRARY CODE Gem
