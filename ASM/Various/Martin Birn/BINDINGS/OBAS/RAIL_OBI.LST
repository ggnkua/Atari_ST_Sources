 ' RAIL_MAN 2.00 D OMIKRON-BASIC-Binding
 ' =====================================
 '
 ' Letze Žnderung: 01.05.1990
 '
 ' (C) 1990 by Martin Birn
 ' Knoblochstraže 51, 7100 Heilbronn
 ' ----------------------------------------------------------------------------

 LIBRARY Gem ,"Gem.lib"

 '
 'Funktionsgruppe A
 '
 DEF PROC A_Start(R Ret%L)
   GEMDOS (Ret%L,253,0)
 RETURN

 DEF PROC A_End(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,1,Handle%)
   Rail_Err(Ret%L)
   IF Rail_Addr%L<>0 THEN
     FRE Rail_Addr%L
   ENDIF
 RETURN

 DEF PROC A_State(R Ret%L,Handle%,Mode%)
   GEMDOS (Ret%L,253,2,Handle%,Mode%)
   Rail_Err Ret%L
 RETURN

 DEF PROC A_Wait(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,3,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC A_Reset(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,5,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC A_Update(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,6,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe E (Engine = Loksteuerung)
 '

 DEF PROC E_Speed(R Ret%L,Handle%,Index%,Mode%,Speed%)
   GEMDOS (Ret%L,253,7,Handle%,Index%,Mode%,Speed%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Direction(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,8,Handle%,Index%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Mode(R Ret%L,Handle%,Index%,Mode%)
   GEMDOS (Ret%L,253,9,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC E_Function(R Ret%L,Handle%,Index%,Number%,Mode%)
   GEMDOS (Ret%L,253,10,Handle%,Index%,Number%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe S (Switch = Weiche)
 '

 DEF PROC S_Setgroup(R Ret%L,Handle%,Index%,Mode%)
   GEMDOS (Ret%L,253,11,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Delgroup(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,12,Handle%,Index%,Mode%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Switch(R Ret%L,Handle%,Index%,Mode%,Direction%)
   GEMDOS (Ret%L,253,13,Handle%,Index%,Mode%,Direction%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC S_Bswitch(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,21,Handle%,Index%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe R (Rckmeldungen)
 '

 DEF PROC R_Start(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,14,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC R_Stop(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,15,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe Q (reQuest = Nachfragefunktionen)
 '

 DEF PROC Q_Version(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,16,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC Q_Array(R Ret%L,Handle%,Addr%L)
   GEMDOS (Ret%L,253,17,Handle%,L Addr%L):
   Rail_Err(Ret%L)
 RETURN

 DEF PROC Q_File(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,18,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' Funktionsgruppe X (information eXchange = Infoaustausch)
 '

 DEF PROC X_Search(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,19,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC X_Updated(R Ret%L,Handle%)
   GEMDOS (Ret%L,253,20,Handle%)
   Rail_Err(Ret%L)
 RETURN

 DEF PROC X_Done(R Ret%L,Handle%,Index%)
   GEMDOS (Ret%L,253,22,Handle%)
   Rail_Err(Ret%L)
 RETURN

 '
 ' vorgefertigte Funktionen bzw. Routinen
 '

 '
 'initialisieren und besorgen eines Handles
 'GLOBALE VARIABLEN: Handle%,Rail_Eflg%,Rail_addr
 '

 DEF PROC Rail_Init
   LOCAL Rret%L,X%
   A_Start(Rret%L)
   IF Rret%L=-32 THEN 'Accessory installiert?
     Rret%L=0'nein
     PRINT CHR$(7);
     MOUSEON : FORM_ALERT (1,"[3][RAIL_MAN nicht installiert][Abbruch]",X%)
   ELSE
     Rail_Eflg%=0'alles klar
     Rail_Err(Rret%L)'Handle berechnen
     Handle%=Rret%L
     Rail_Addr%L= MEMORY(100)
     Q_Array(Rret%L,Handle%,Rail_Addr%L)'und fllen lassen
   ENDIF
 RETURN

 DEF PROC Rail_Err(R Ercd%L)
   LOCAL E%,A%L,Code%L
   Code%L=Ercd%L
   Ercd%L=Code%L AND $FFFF
   IF Ercd%L>$EFFF THEN Ercd%L=-($10000-Ercd%L): ENDIF
   IF Ercd%L<>-1020 AND Rail_Eflg%=0 THEN 'bei falschem Handle oder laufendem Redraw kein Redraw!!
     '
     'DER FOLGENDE BEFEHL IST EXTREM WICHTIG!!
     '
     Rail_Eflg%=1'keine weiteren Redraw-Messages
     IF Code%L AND 2^16 THEN Redraw: ENDIF
     IF Code%L AND 2^17 THEN Rm_Update: ENDIF
     IF Code%L AND 2^18 THEN Rd_File: ENDIF
     IF Code%L AND 2^19 THEN Lok_Update: ENDIF
     Rail_Eflg%=0'Redraw wieder zulassen
   ENDIF
   E%=-(Ercd%L+1000)
   IF Rail_Addr%L<>0 AND E%>0 AND E%<= LPEEK( LPEEK(Rail_Addr%L+22*4)) THEN
     'falls Feld belegt und E% im erwarteten Bereich
     PRINT CHR$(7);
     MOUSEON
     Addrin%L(0)= LPEEK( LPEEK(Rail_Addr%L+22*4)+4*E%)'Adresse des Strings bergeben
     Intin%(0)=1'Default-Button 1
     AES (52,Global%(15),Intin%(1),Addrin%L(1),Intout%(1),Addrout%L(0))
   ENDIF
   PRINT "Rckgabewert: ";Ercd%L
 RETURN

 ' ----------------------------------------------------------------------------
 ' Redraw-UP
 '
 DEF PROC Redraw
   LOCAL Rret%L,Index%L,Rh%L
   PRINT "Redraw angefordert: "'Ggf. Entfrnen
   REPEAT
     X_Search(Rret%L,Handle%)'Rckgabewert holen
     IF Rret%L<>0 THEN
       Index%L=Rret%L AND $FFFF'Index holen
       Rh%L=Rret%L/2^16'Handle holen
       '
       IF Index%L=1 THEN
         Rd_Notstop(Rh%L)
       ELSE
         IF Index%L<258 THEN
           Rd_Switch(Rh%L,Index%L-1)
         ELSE
           IF Index%L<338 THEN
             Rd_Engine(Rh%L,Index%L-257)
           ELSE
             IF Index%L<418 THEN
               Rd_F1(Rh%L,Index%L-337)
             ELSE
               IF Index%L<498 THEN
                 Rd_F2(Rh%L,Index%L-417)
               ELSE
                 IF Index%L<578 THEN
                   Rd_F3(Rh%L,Index%L-497)
                 ELSE
                   IF Index%L<658 THEN
                     Rd_F4(Rh%L,Index%L-577)
                   ELSE
                     IF Index%L<738 THEN
                       Rd_F5(Rh%L,Index%L-657)
                     ELSE
                       IF Index%L<993 THEN
                         Rd_Fahr(Rh%L,Index%L-737)
                       ENDIF
                     ENDIF
                   ENDIF
                 ENDIF
               ENDIF
             ENDIF
           ENDIF
         ENDIF
       ENDIF
     ENDIF
   UNTIL Rret%L=0
 RETURN
 '
 ' die folgenden Redraw-Routinen entsprechend umschreiben
 '
 DEF PROC Rd_Notstop(H%)
   PRINT "Handle ";H%;" Notstop-Anzeige"
 RETURN

 DEF PROC Rd_Switch(H%,I%L)
   PRINT "Handle ";H%;" Magnetartikel Nr. ";I%L
 RETURN

 DEF PROC Rd_Engine(H%,I%L)
   PRINT "Handle ";H%;" Lok Nr. ";I%L
 RETURN

 DEF PROC Rd_F1(H%,I%L)
   PRINT "Handle ";H%;" Lokfunktion Nr. ";I%L
 RETURN

 DEF PROC Rd_F2(H%,I%L)
   PRINT "Handle ";H%;" Extrafunktion 1 Nr. ";I%L
 RETURN

 DEF PROC Rd_F3(H%,I%L)
   PRINT "Handle ";H%;" Extrafunktion 2 Nr. ";I%L
 RETURN

 DEF PROC Rd_F4(H%,I%L)
   PRINT "Handle ";H%;" Extrafunktion 3 Nr. ";I%L
 RETURN

 DEF PROC Rd_F5(H%,I%L)
   PRINT "Handle ";H%;" Extrafunktion 4 Nr. ";I%L
 RETURN

 DEF PROC Rd_Fahr(H%,I%L)
   PRINT "Handle ";H%;" Fahrstraže Nr. ";I%L
 RETURN

 '
 ' Routine, die bei einer Aktualisierung der RM-Daten aufgerufen wird
 '

 DEF PROC Rm_Update
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,1)
   '
   ' hier kommt Ihre Anzeigeroutine anstatt der Meldung
   '
   PRINT "Neue RM-Daten!"'Beispiel-Meldung
 RETURN


 '
 ' Routine, die alles neu zeichnet (zu Beginn und wenn eine neue Datei geladen
 ' wurde)
 '

 DEF PROC Rd_File
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,2)
   '
   ' hier kommt Ihre Anzeigeroutine anstatt der Meldung
   '
   PRINT "Neue Datei geladen / Redraw angefordert!"
 RETURN

 DEF PROC Lok_Update
   LOCAL Dummy%L
   X_Done(Dummy%L,Handle%,3)
   '
   ' hier kommt Ihre Anzeigeroutine anstatt der Meldung
   '
   PRINT "Lokdaten aktualisiert!"
 RETURN

 LIBRARY CODE Gem

