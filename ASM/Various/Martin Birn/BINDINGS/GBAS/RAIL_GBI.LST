' RAIL_MAN 2.00 GFA-BASIC-Binding
' ===============================
'
' Letzte 始derung: 01.05.1990
'
' (C) 1990 by Martin Birn
' Knoblochstra枡 51, 7100 Heilbronn
' =============================================================================
'
' Funktionsgruppe A
'
Deffn A_start=Gemdos(253,0)
'
' der R…kgabewert ist der globalen Integervariablen
' Handle% zuzuweisen.
' Hierzu bitte das Unterprogramm Rail_init benutzen.
'
Deffn A_end(Handle%)=Gemdos(253,1,Handle%)
Deffn A_state(Handle%,Mode%)=Gemdos(253,2,Handle%,Mode%)
Deffn A_wait(Handle%)=Gemdos(253,3,Handle%)
Deffn A_reset(Handle%)=Gemdos(253,5,Handle%)
Deffn A_update(Handle%)=Gemdos(253,6,Handle%)
'
' Funktionsgruppe E (Engine = Loksteuerung)
'
Deffn E_speed(Handle%,Index%,Mode%,Speed%)=Gemdos(253,7,Handle%,Index%,Mode%,Speed%)
Deffn E_direction(Handle%,Index%)=Gemdos(253,8,Handle%,Index%)
Deffn E_mode(Handle%,Index%,Mode%)=Gemdos(253,9,Handle%,Index%,Mode%)
Deffn E_function(Handle%,Index%,Number%,Mode%)=Gemdos(253,10,Handle%,Index%,Number%,Mode%)
'
' Funktionsgruppe S (Switch = Weiche)
'
Deffn S_setgroup(Handle%,Index%,Mode%)=Gemdos(253,11,Handle%,Index%,Mode%)
Deffn S_delgroup(Handle%,Index%)=Gemdos(253,12,Handle%,Index%,Mode%)
Deffn S_switch(Handle%,Index%,Mode%,Direction%)=Gemdos(253,13,Handle%,Index%,Mode%,Direction%)
Deffn S_bswitch(Handle%,Index%)=Gemdos(253,21,Handle%,Index%)
'
' Funktionsgruppe R (R…kmeldungen)
'
Deffn R_start(Handle%)=Gemdos(253,14,Handle%)
Deffn R_stop(Handle%)=Gemdos(253,15,Handle%)
'
' Funktionsgruppe Q (reQuest = Nachfragefunktionen)
'
Deffn Q_version(Handle%)=Gemdos(253,16,Handle%)
Deffn Q_array(Handle%,Addr%)=Gemdos(253,17,Handle%,L:Addr%)
Deffn Q_file(Handle%)=Gemdos(253,18,Handle%)
'
' Funktionsgruppe X (information eXchange = Infoaustausch)
'
Deffn X_search(Handle%)=Gemdos(253,19,Handle%)
Deffn X_updated(Handle%)=Gemdos(253,20,Handle%)
Deffn X_done(Handle%,Index%)=Gemdos(253,22,Handle%,Index%)
'
' =============================================================================
' FUNKTIONEN
'
' -----------------------------------------------------------------------------
' Rail_init
'
' Globale Variablen:
'
' Handle%     RAIL_MAN-Handle (bei weiteren Funktionsaufrufen angeben!)
' Rail_eflg%  Flag zur internen Verwendung
' Rail_arr%() Feld mit den R…kgabewerten von q_array
'
Procedure Rail_init
  Local Rret%,Adr%
  Rret%=@A_start
  If Rret%=-32          !nicht installiert
    Clr Handle%
    Alert 3,"RAIL_MAN nicht installiert.",1,"Abbruch",X%
  Else
    @Rail_err(Rret%,*Handle%)   !Handle berechnen
    Dim Rail_arr%(25)           !Feld anlegen
    Adr%=Varptr(Rail_arr%(0))   !Adresse des ersten Elements holen
    Void @Q_array(Handle%,Adr%) !ab hier Daten ablegen
    Clr Rail_eflg%              !internes Flag zur…ksetzen
  Endif
Return
'
' -----------------------------------------------------------------------------
' Fehlerbehandlungsprocedur
'
' Beispielaufruf:
' @Rail_err(@A_end(100),*X%)
' zeigt Fehlermeldung 'ung〕tiges Handle' an und gibt in x% -1020 zur…k
'
' @Rail_err(@A_end(100),0)
' zeigt -1020 an, anstatt den Wert einer Variablen zu ｜ergeben
'
' Faustregel: Als ersten Parameter den R…kgabewert der RAIL_MAN-Funktion
' angeben, als zweiten die Adresse der Variablen, der der R…kgabewert
' zugewiesen werden soll (oder 0, falls nicht erw］scht).
'
' Die Adressen der Alert-Strings wurden mit q_array ermittelt --> Dieses UP
' funktioniert nur, wenn rail_init benutzt wurde!!!
'
Procedure Rail_err(Code%,Return%)
  Local Ercd%,E%
  Ercd%=Code% And &HFFFF
  If Ercd%>&HEFFF
    Ercd%=-(&H10000-Ercd%) !vorzeichenbehaftet, daher umrechnen
  Endif
  If Return%<>0      !R…kgabewert gew］scht?
    *Return%=Ercd%   !ja
  Else
    Print "R…kgabewert: ";Ercd% !sonst Wert auf Bildschirm ausgeben
    ' obiger Befehl kann ggf. entfallen.
  Endif
  '
  If Ercd%<>-1020 And Rail_eflg%=0  !nicht bei falschem Handle oder laufendem Redraw
    '
    ' DER FOLGENDE BEFEHL IST EXTREM WICHTIG!!
    '
    Rail_eflg%=1 !weitere Redraw-Messages sperren
    '
    If Code% And 2^16
      Gosub Redraw
    Endif
    If Code% And 2^17
      Gosub Rm_update
    Endif
    If Code% And 2^18
      Gosub Newfile
    Endif
    If Code% And 2^19
      Gosub Lok_update
    Endif
    '
    Clr Rail_eflg% !Redraw-Messages wieder zulassen
  Endif
  E%=-(Ercd%+1000)      !Fehlerindex feststellen
  If Dim?(Rail_arr%())  !Feld angelegt?
    If E%>0 And E%<=Lpeek(Rail_arr%(22))  !Fehlermeldung im angegebenen Bereich?
      Print Chr$(7);
      Dpoke Gintin,1    !Defaultbutton 1
      Lpoke Addrin,Lpeek(Rail_arr%(22)+4*E%)   !Adresse des Alert-Strings ｜ergeben
      Gemsys 52         !FORM_ALERT des AES aufrufen
    Endif
  Endif
Return
'
' -----------------------------------------------------------------------------
' Redraw-UP
'
Procedure Redraw
  Local Rret%,Index%,Rh%
  Print "Redraw angefordert:"    !ggf. entfrnen
  Do
    Rret%=@X_search(Handle%)     !R…kgabewert holen
    Exit If Rret%=0
    Index%=Rret% And 2^16-1      !Index holen
    Rh%=Rret%/2^16               !Handle holen
    '
    If Index%=1
      @Rd_notstop(Rh%)
    Else
      If Index%<258
        @Rd_switch(Rh%,Index%-1)
      Else
        If Index%<338
          @Rd_engine(Rh%,Index%-257)
        Else
          If Index%<418
            @Rd_f1(Rh%,Index%-337)
          Else
            If Index%<498
              @Rd_f2(Rh%,Index%-417)
            Else
              If Index%<578
                @Rd_f3(Rh%,Index%-497)
              Else
                If Index%<658
                  @Rd_f4(Rh%,Index%-577)
                Else
                  If Index%<738
                    @Rd_f5(Rh%,Index%-657)
                  Else
                    If Index%<993
                      @Rd_fahrs(Rh%,Index%-737)
                    Endif
                  Endif
                Endif
              Endif
            Endif
          Endif
        Endif
      Endif
    Endif
  Loop
Return
'
' die folgenden Redraw-Routinen entsprechend umschreiben
'
Procedure Rd_notstop(H%)
  Print "Handle"'H%'"Notstop-Anzeige"
Return
Procedure Rd_switch(H%,I%)
  Print "Handle"'H%'"Magnetartikel Nr."'I%
Return
Procedure Rd_engine(H%,I%)
  Print "Handle"'H%'"Lok Nr."'I%
Return
Procedure Rd_f1(H%,I%)
  Print "Handle"'H%'"Lokfunktion Nr."'I%
Return
Procedure Rd_f2(H%,I%)
  Print "Handle"'H%'"Extrafunktion 1 Nr."'I%
Return
Procedure Rd_f3(H%,I%)
  Print "Handle"'H%'"Extrafunktion 2 Nr."'I%
Return
Procedure Rd_f4(H%,I%)
  Print "Handle"'H%'"Extrafunktion 3 Nr."'I%
Return
Procedure Rd_f5(H%,I%)
  Print "Handle"'H%'"Extrafunktion 4 Nr."'I%
Return
Procedure Rd_fahrs(H%,I%)
  Print "Handle"'H%'"Fahrstra枡 Nr. "'I%
Return
'
' Routine, die bei einer Aktualisierung der RM-Daten aufgerufen wird
'
Procedure Rm_update
  Void Fn X_done(Handle%,1)
  '
  ' hier kommt Ihre Anzeigeroutine statt der Meldung
  '
  Print "Neue RM-Daten!" !Beispiel-Meldung
Return
'
' Routine, die alles neu zeichnet (zu Beginn und wenn eine neue Datei geladen
' wurde)
'
Procedure Newfile
  Void Fn X_done(Handle%,2)
  '
  ' hier kommt Ihre Anzeigeroutine statt der Meldung
  '
  Print "Neue Datei geladen / Redraw angefordert!"
Return
'
' Routine, die alle Lokdaten neu anzeigt
'
Procedure Lok_update
  Void Fn X_done(Handle%,3)
  '
  ' hier kommt Ihre Anzeigeroutine statt der Meldung
  '
  Print "Lokdaten aktualisiert."
Return
