 	OPT	D+

*************** INITIALISE ROUTINES **************

*	MOUSE OFF,JOYSTK OFF

START	MOVE.L	#KEYSET,-(A7)
	MOVE.L	#$190001,-(A7)	MOFF,JOFF USING ikbdws
	TRAP	#14
	ADDQ	#8,A7
	DC.W	$A000	INIT LINE A
	DC.W	$A00A	REMOVE MOUSE

*	SAVE OLD SR AND SSP AND ENTER SUPERVISOR MODE

	MOVE.W	SR,OLDSR+2
	MOVE.L	A7,-(A7)
	MOVE.W	#$20,-(A7)	CALL super
	TRAP	#1
	MOVE.L	D0,OLDSSP+2

*	ALL MFP IRQS OFF

	LEA	$FFFFFA01,A0	MFP HARDWARE BASE ADDRESS
	MOVEQ	#0,D0	SET UP ALL INTERRUPTS
	MOVEP.L	D0,0(A0)	TO BE OFF AND IGNORED
	MOVEP.L	D0,8(A0)	AND CLEAR IRQ MASKING ETC.
	MOVEP.L	D0,16(A0)
	MOVE.B	#$48,22(A0)	VECTOR NUMBER HIGH NIBBLE
*			AND S BIT SET (BIT 3)

*	RESET KEYBOARD ACIA

	MOVE.B	#3,$FFFFFC00	HARD RESET
	MOVE.B	#$96,$FFFFFC00	SET RATE/PARITY ETC.

*	NEW KEYBRD/JYSTK VECTOR

	MOVE.L	#READKEY,(A7)
	MOVE.L	#$D0006,-(A7)	CALL mfpint
	TRAP	#14
	ADDQ.W	#8,A7

*	NEW VBL ROUTINE

	MOVE.L	$70.W,OLDVBL+2	STORE OLD VECTOR
	MOVE.L	#VBL,$70.W	SET TO NEW VALUE

*	FIND 256 BOUNDARY WITHIN STORE

	MOVE.L	#STORE,D0
	TST.B	D0
	BEQ.S	SCRPOSOK
	ANDI.B	#0,D0
	ADD.L	#$100,D0
SCRPOSOK	MOVE.L	D0,SCRNADD+2
	ADDI.L	#32000,D0
	MOVE.L	D0,SCROLLDATA+2
	ADDI.L	#32000,D0
	MOVE.L	D0,SCROLLADD+2

*	STORE CURRENT PALLATE

	LEA	$FFFF8240,A0
	LEA	SAVEPALL,A1
	MOVEQ	#15,D0
STOPALL	MOVE.W	(A0)+,(A1)+
	DBF	D0,STOPALL

*************** MAIN PROGRAM **************

*	PRINT THE MENU AND SELECT AN OPERATION

MAIN	LEA	MENU,A0
	BSR	OUTLINE
	BSR	CURSORON
SELECT	BSR.S	KEY
	CMPI.B	#1,D0
	BEQ.S	EXIT
	CMPI.B	#"1",D0
	BCS.S	SELECT
	CMPI.B	#"5",D0
	BHI.S	SELECT
	MOVE.W	D0,-(A7)
	BSR	OUTCHAR
	BSR	ENDLINE
	BSR	CURSOROFF
	MOVE.W	(A7)+,D0
	SUBI.W	#"1",D0
	LSL.W	#2,D0
	LEA	JUMPS,A0
	MOVE.L	0(A0,D0.W),A0
	JSR	(A0)
	BRA.S	MAIN

*	RESTORE OPERATING SYSTEM AND EXIT

EXIT	BSR	CURSOROFF
OLDVBL	MOVE.L	#0,$70.W	RESTORE OLD VBL VECTOR
	JSR	$FC2408
	MOVE.L	#KEYS1,-(A7)
	MOVE.L	#$190003,-(A7)	RESET KYBRD,MOFF,JOFF
	TRAP	#14
	ADDQ	#8,A7
	DC.W	$A009	PUT MOUSE BACK
	MOVE.L	A7,A0
OLDSSP	MOVE.L	#0,A7
OLDSR	MOVE.W	#0,SR
	MOVE.L	A0,A7
	CLR.W	-(A7)
	TRAP	#1

*	SUBROUTINE TO READ A KEY - RETURNS ASCII CODE IN D0
*	ONLY MODIFIES D0 !

KEY	MOVEQ	#0,D0	GET KEY VALUE
	BEQ.S	NOKEY	ZERO=NONE
	BMI.S	GETASCII	IF MINUS THEN CONVERT
DUDKEY	MOVEQ	#0,D0	IGNORE SHIFT KEYS ETC
NOKEY	RTS		DONE
GETASCII	CLR.B	KEY+1	REMOVE OLD KEY
	ANDI.W	#$7F,D0	CLEAR BIT 8
	CMPI.B	#$60,D0	WITHIN ALLOWED RANGE ?
	BHI.S	DUDKEY	NO
	MOVE.L	A0,-(A7)	STORE A0
	LEA	ASCII,A0	GET ASCII TABLE ADDRESS
	TST.B	SHIFTFLAG	SHIFT ON ?
	BEQ.S	NOSHIFT	NO
	LEA	ASCII1,A0	GET SHIFTED ASCII TABLE
NOSHIFT	MOVE.B	0(A0,D0.W),D0	GET ASCII CODE
	MOVE.L	(A7)+,A0	RESTORE A0
	RTS

*	SUBROUTINE TO OUTPUT A LINE OF TEXT

OUTLINE	TST.B	(A0)
	BEQ.S	LINEDONE
	MOVE.B	(A0)+,D0
	MOVE.L	A0,-(A7)
	BSR.S	OUTCHAR
	MOVE.L	(A7)+,A0
	BRA.S	OUTLINE

*	SUBROUTINE TO OUTPUT A CHARACTER
*	USES A TRAP SO PRESUME ONLY STACK TO BE PRESERVED

OUTCHAR	ANDI.W	#$FF,D0
	MOVE.W	D0,-(A7)
	MOVE.W	#2,-(A7)
	TRAP	#1
	ADDQ	#4,A7
LINEDONE	RTS	

*	SUBROUTINE TO OUTPUT ENTER

ENDLINE	MOVE.B	#12,D0
	BSR.S	OUTCHAR
	MOVE.B	#13,D0
	BRA.S	OUTCHAR

*	SUBROUTINE TO OUTPUT BACKSPACE

BACKSPACE	MOVE.B	#8,D0
	BSR.S	OUTCHAR
	MOVE.B	#" ",D0
	BSR.S	OUTCHAR
	MOVE.B	#8,D0
	BRA.S	OUTCHAR

*	SUBROUTINE TO SWITCH CURSOR ON

CURSORON	MOVE.B	#27,D0
	BSR.S	OUTCHAR
	MOVE.B	#"e",D0
	BRA.S	OUTCHAR

*	SUBROUTINE TO SWITCH CURSOR OFF

CURSOROFF	MOVE.B	#27,D0
	BSR.S	OUTCHAR
	MOVE.B	#"f",D0
	BRA.S	OUTCHAR

*	INPUT FILENAME

GETNAME	LEA	FILEPROMPT,A0
	BSR.S	OUTLINE

*	READ A LINE OF TEXT

LINEREAD	BSR.S	CURSORON
	LEA	CHARBUFF,A0
	MOVE.L	A0,STORECHAR+2
CLEARBUFF	CLR.B	(A0)+
	CMP.L	#ENDSTO,A0
	BNE.S	CLEARBUFF
READLINE	BSR	KEY
	TST.B	D0
	BEQ.S	READLINE
	CMPI.B	#$D,D0
	BEQ.S	CRSOROFF
	CMPI.B	#$8,D0
	BNE.S	NOTDEL
	MOVE.L	STORECHAR+2,A0
	CMP.L	#CHARBUFF,A0
	BEQ.S	READLINE
	CLR.B	-(A0)
	MOVE.L	A0,STORECHAR+2
	BSR.S	BACKSPACE
	BRA.S	READLINE
NOTDEL	CMPI.L	#ENDSTO,STORECHAR+2
	BEQ.S	READLINE
STORECHAR	MOVE.B	D0,CHARBUFF
	ADDQ.L	#1,STORECHAR+2
	BSR	OUTCHAR
	BRA.S	READLINE
CRSOROFF	BSR.S	CURSOROFF
	BRA	ENDLINE

*	SUBROUTINE TO SAVE PRE-ROTATED DATA TO DISK

SAVEDATA	BSR.S	GETNAME
	MOVE.L	SCROLLADD+2,WRITEFILE+2
	MOVE.L	DATALENGTH,FLENGTH+2
	MOVE.L	OLDVBL+2,$70.W	RESTORE OLD VBL VECTOR
	BSR.S	CREATEFILE
	TST.W	D0
	BMI.S	ERROCCUR1
	BSR	WRITEFILE
	TST.W	D0
	BMI.S	ERROCCUR1
	BSR	CLOSEFILE
ERROCCUR1	MOVE.L	#VBL,$70.W
	RTS

*	SUBROUTINE TO CHECK FOR DISK CHANGE

CHCKDISK	MOVE.W	#0,-(A7)	DRIVE A
	MOVE.W	#7,-(A7)	GETBPB
	TRAP	#13	BIOS
	ADDQ	#4,A7
	RTS

*	SUBROUTINE TO CREATE A FILE NB. NAME IN CHARBUFF

CREATEFILE	BSR.S	CHCKDISK
	MOVE.W	#0,-(A7)
	PEA	CHARBUFF
	MOVE.W	#$3C,-(A7)
	TRAP	#1
	MOVE.W	D0,FHANDLE+2
	ADDQ	#8,A7
	RTS

*	SUBROUTINE TO OPEN A FILE NB. NAME IN CHARBUFF

OPENFILE	BSR.S	CHCKDISK
	MOVE.W	#2,-(A7)	OPEN FILE
	PEA	CHARBUFF
	MOVE.W	#$3D,-(A7)
	TRAP	#1
	MOVE.W	D0,FHANDLE+2
	ADDQ	#8,A7
	RTS

*	SUBROUTINE TO READ FROM A FILE NB. FHANDLE+2 SET UP

READFILE	PEA	STORE	LOAD ADDRESS
FLENGTH	PEA	32000	LENGTH
FHANDLE	MOVE.W	#0,-(A7)
	MOVE.W	#$3F,-(A7)	LOAD FILE
	TRAP	#1
	ADD.L	#12,A7
	RTS

*	SUBROUTINE TO WRITE TO A FILE NB. FHANDLE+2 SET UP

WRITEFILE	PEA	STORE	SAVE ADDRESS
	MOVE.L	FLENGTH+2,-(A7)	LENGTH TO SAVE
	MOVE.W	FHANDLE+2,-(A7)
	MOVE.W	#$40,-(A7)
	TRAP	#1
	ADD.L	#12,A7
	RTS

*	SUBROUTINE TO CLOSE A FILE NB. FHANDLE+2 SET UP

CLOSEFILE	MOVE.W	FHANDLE+2,-(A7)	CLOSE FILE
	MOVE.W	#$3E,-(A7)
	TRAP	#1
	ADDQ	#4,A7
	RTS

*	SUBROUTINE TO LOAD AND VIEW A NEO FILE

VIEWNEO	BSR	GETNAME
	MOVE.L	OLDVBL+2,$70.W
	BSR.S	OPENFILE
	TST.W	D0
	BMI	ERROCCUR
	MOVE.L	#NEOPALL,READFILE+2
	MOVE.L	#128,FLENGTH+2
	BSR.S	READFILE
	TST.W	D0
	BMI.S	ERROCCUR
SCRNADD	MOVE.L	#STORE,READFILE+2
	MOVE.L	#32000,FLENGTH+2
	BSR	READFILE
	TST.W	D0
	BMI.S	ERROCCUR
	BSR.S	CLOSEFILE
	TST.W	D0
	BMI.S	ERROCCUR
	MOVE.L	#VBL,$70.W
	BSR.S	SETNEO

*	WAIT FOR KEYPRESS

KEYWAIT	TST.B	KEY+1
	BPL.S	KEYWAIT

*	RESET SCREEN ADDRESS AND PALETTE

SETMENU	BSR.S	WAITVBL
	LEA	$FFFF8201,A0
	MOVE.B	$44F.W,(A0)
	MOVE.B	$450.W,2(A0)
	ADD.W	#$3F,A0
	LEA	SAVEPALL,A1
	MOVEQ	#15,D0
OLDPALL	MOVE.W	(A1)+,(A0)+
	DBF	D0,OLDPALL
ERROCCUR	MOVE.L	#VBL,$70.W
	RTS

*	SWITCH SCREEN ADDRESS AND CHANGE PALETTE

SETNEO	BSR.S	WAITVBL
	LEA	$FFFF8201,A0
	MOVE.B	SCRNADD+3,(A0)
	MOVE.B	SCRNADD+4,2(A0)
	ADD.W	#$3F,A0
	LEA	NEOPALL+4,A1
	MOVEQ	#15,D0
NEWPALL	MOVE.W	(A1)+,(A0)+
	DBF	D0,NEWPALL
	RTS

*	WAIT FOR VBL

WAITVBL	MOVE.B	$469.W,D0
WAIT	CMP.B	$469.W,D0
	BEQ.S	WAIT
	RTS

*	SUBROUTINE TO SELECT THE SPRITE

GETIT	BSR.S	SETNEO
BADGET	MOVE.W	#0,XCO+2
	MOVE.W	#0,YCO+2
	BSR	SELECTPOS
	MOVE.W	XCO+2,X1+2
	MOVE.W	YCO+2,Y1+2
	MOVE.L	POS+2,POS1+2
	MOVEQ	#49,D1
WAITFIRE	BSR	WAITVBL
	DBF	D1,WAITFIRE
	BSR.S	SELECTPOS
XCO	MOVE.W	#0,D0
X1	SUBI.W	#0,D0
	BPL.S	YCO
	NEG.W	D0
YCO	MOVE.W	#0,D1
Y1	SUBI.W	#0,D1
	BEQ.S	YOK
	BPL.S	YOK1
	NEG.W	D1
YOK1	SUBI.W	#1,D1
YOK	MOVE.W	D1,NLINES+2
	LSR.W	#1,D0	= NO OF BYTES
	ADDQ	#7,D0
	MOVE.W	D0,WIDTH+2
POS	MOVE.L	#0,D2
POS1	CMPI.L	#0,D2
	BCS.S	PSTNOK
	MOVE.L	POS1+2,D2
PSTNOK	MOVE.L	D2,CONVDATA+2
	ADDQ	#1,D0
	ADDQ	#1,D1
	MULU	D1,D0
	MOVE.W	D0,SIZE+2
	ANDI.L	#$FFFF,D0
	LSL.L	#3,D0
	MOVE.L	D0,DATALENGTH
	BRA	SETMENU

*	ROUTINE TO SELECT SCREEN POSITION

SELECTPOS	BSR	DRAWPOS
	MOVE.B	JOY1+1,D0
	CLR.B	JOY1+1
	BTST	#7,D0
	BNE	POSOFF
	MOVE.W	XCO+2,D1
	MOVE.W	YCO+2,D2
	BTST	#0,D0
	BEQ.S	NOTD1
	SUBI.W	#8,D2
	BPL.S	NOTD1
	ADDI.W	#8,D2
NOTD1	BTST	#1,D0
	BEQ.S	NOTD2
	ADDI.W	#8,D2
	CMPI.W	#200,D2
	BCS.S	NOTD2
	SUBI.W	#8,D2
NOTD2	BTST	#2,D0
	BEQ.S	NOTD3
	SUBI.W	#16,D1
	BPL.S	NOTD3
	ADDI.W	#16,D1
NOTD3	BTST	#3,D0
	BEQ.S	NOTD4
	ADDI.W	#16,D1
	CMPI.W	#320,D1
	BCS.S	NOTD4
	SUBI.W	#16,D1
NOTD4	BSR	WAITVBL
	BSR	WAITVBL
	BSR	WAITVBL
	BSR.S	POSOFF
	MOVE.W	D1,XCO+2
	MOVE.W	D2,YCO+2
	BRA	SELECTPOS

DRAWPOS	MOVE.L	SCRNADD+2,A0
	MOVE.W	YCO+2,D0
	MULU	#160,D0
	ADDA.W	D0,A0
	MOVE.W	XCO+2,D0
	LSR.W	#1,D0
	ADDA.W	D0,A0
	MOVE.L	A0,POS+2
POSOFF	EORI.L	#$FFFFFFFF,(A0)
	EORI.L	#$FFFFFFFF,2(A0)
	RTS

*	SUBROUTINE TO CONVERT GRAPHICS DATA

CONVDATA	MOVE.L	#STORE,A0	TOP LEFT ON SCREEN
SCROLLADD	LEA	STORE,A2
NLINES	MOVE.W	#47,D0	48 LINES
DOLINE	MOVE.L	A0,A1
WIDTH	MOVE.W	#63,D1	IN BYTES
COPYDATA	MOVE.B	(A1)+,(A2)+
	DBF	D1,COPYDATA
	ADDA.W	#160,A0	MOVE TO NEXT LINE
	DBF	D0,DOLINE
	MOVE.L	A2,A0	NEXT SECTION INTO A0
	MOVEQ	#6,D7	7 MORE COPIES-TO BE ROTATED
ROTATE	MOVE.L	A0,A1	A1 TO PSTN FOR NEXT SECTION
SIZE	SUBA.W	#$C00,A0	LAST SECTION IN A0
	MOVE.W	SIZE+2,D0
	SUBQ	#1,D0
COPYALL	MOVE.B	(A0)+,(A1)+	COPY ALL THE DATA
	DBF	D0,COPYALL
	MOVE.W	NLINES+2,D6	ROTATE NLINES
ROTATELINE	MOVEQ	#1,D5	ROTATE 2 BITS
TWOBITS	MOVEQ	#3,D4	4 BIT PLANES
BITPLANES	MOVE.W	WIDTH+2,D0	WIDTH
	SUBQ	#7,D0
	MOVE.W	0(A0,D0.W),D0	BIT PLANE AT END OF LINE
	MOVE.W	WIDTH+2,D3
	ADDQ	#1,D3
	LSR.W	#3,D3
	SUBQ	#1,D3	N BLOCKS OF 16 PIXELS
	ROXR.W	#1,D0	ROTATE THE BIT INTO X
ROTATEPLANE	ROXR.W	(A0)
	ADDQ	#8,A0
	DBF	D3,ROTATEPLANE	ALL BLOCKS THIS BIT PLANE
	MOVE.W	WIDTH+2,D3
	SUBQ	#1,D3
	SUBA.W	D3,A0	MOVE TO NEXT PLANE
	DBF	D4,BITPLANES	ALL BITPLANES
	SUBQ	#8,A0	A0 BACK TO START OF LINE
	DBF	D5,TWOBITS	ROTATE TWICE
	ADDA.W	WIDTH+2,A0	A0 TO NEXT LINE
	ADDQ	#1,A0
	DBF	D6,ROTATELINE	ALL LINES
	DBF	D7,ROTATE	ALL COPIES
	RTS

EXITVIEW	MOVE.L	SCROLLDATA+2,A0
	MOVE.L	SCRNADD+2,A1
	MOVE.W	#7999,D0
GETSCREEN	MOVE.L	(A0)+,(A1)+
	DBF	D0,GETSCREEN
	BRA	SETMENU

*	VIEW THE ROTATED DATA

SCROLLDATA	LEA	STORE,A0
	MOVE.L	SCRNADD+2,A1
	MOVE.W	#7999,D0
STOSCREEN	MOVE.L	(A1)+,(A0)+
	DBF	D0,STOSCREEN
	BSR	SETNEO
	MOVE.W	#0,SCROLLPOS+2
DOSCROLL	BSR	WAITVBL
	LEA	$FFFF8203,A0	SCREEN BASE MID-BYTE
	MOVE.B	(A0),D0	PUT INTO D0
WAIT1	CMP.B	4(A0),D0	RASTER AT BASE ?
	BNE.S	ONVIEW	NO
WAIT2	TST.B	6(A0)	RASTER ABOVE LINE 1 ?
	BEQ.S	WAIT2	YES
ONVIEW	MOVE.L	SCRNADD+2,A4
SCROLLPOS	MOVE.W	#0,D0
SPEED	MOVE.W	#0,D2
JOY1	MOVEQ	#0,D1
	CLR.B	JOY1+1
	BTST	#7,D1
	BNE.S	EXITVIEW
	BTST	#0,D1
	BEQ.S	NOTUP
	ADDQ	#1,D2
	CMPI.W	#$500,D2
	BHI.S	TOOHI
NOTUP	BTST	#1,D1
	BEQ.S	SPEEDOK
TOOHI	SUBQ.W	#1,D2
	BPL.S	SPEEDOK
	ADDQ	#1,D2
SPEEDOK	MOVE.W	D2,SPEED+2
	EORI.W	#$777,$FFFF8240
	BTST	#3,D1
	BEQ.S	NOTRIGHT
	ADD.W	D2,D0
NOTRIGHT	BTST	#2,D1
	BEQ.S	NOTLEFT
	SUB.W	D2,D0
NOTLEFT	TST.W	D0
	BPL.S	CHCKLOW	IF NEGATIVE THEN
	ADDI.W	#$A00,D0	SUBTRACT FROM MAX VALUE
	BRA.S	PSTNSET
CHCKLOW	CMPI.W	#$A00,D0
	BCS.S	PSTNSET	IF PAST MAX THEN
	SUBI.W	#$A00,D0	SUBTRACT MAX
PSTNSET	MOVE.W	D0,SCROLLPOS+2	STORE NEW POSITION
	LSR.W	#4,D0	REMOVE FRACTION
	MOVE.W	D0,D1	COPY VALUE
	ANDI.W	#7,D0	DRAWING NUMBER IN D0
	ANDI.W	#$F8,D1	HORIZ POSITION IN D1
	ADDA.W	D1,A4	TOP LEFT IN A4
	MOVE.L	SCROLLADD+2,A0
	MOVE.W	SIZE+2,D2
	MULU	D2,D0
	ADDA.L	D0,A0	A0=START OF DRAWING
	MOVE.L	SCRNADD+2,A6
	MOVE.W	#1919,D7
CLS	CLR.L	(A6)+
	DBF	D7,CLS
	MOVE.W	NLINES+2,D1
PRINTIT	MOVE.W	WIDTH+2,D2
	ADDQ	#1,D2
	LSR.W	#2,D2	NO OF LONG WORDS WIDE
	SUBQ	#1,D2
	MOVE.L	A4,A5
PRINTIT1	MOVE.L	(A0)+,(A5)+
	DBF	D2,PRINTIT1
	ADDA.W	#160,A4
	DBF	D1,PRINTIT

	EORI.W	#$777,$FFFF8240
	BRA	DOSCROLL

*	VBL ROUTINE
*	COUNT/MONITOR CHECK/REQUEST JOYSTICK DATA EVERY 16TH VBL

VBL	MOVE.L	D0,-(A7)	STORE D0
	MOVE.L	$466.W,D0	GET COUNT
	ADDQ	#1,D0	ADD ONE
	MOVE.L	D0,$466.W	STORE COUNT
	ANDI.B	#$0,D0	CHECK IF BITS 0-3 CLEAR
	BNE.S	NOT32	IF NOT THEN OK ELSE

*	REQUEST JOYSTICK DATA

	MOVE.L	A0,-(A7)	STORE A0
	LEA	$FFFFFC00,A0	ACIA STATUS/CONTROL
JOYWAIT	MOVE.B	(A0),D0	GET STATUS
	BTST	#1,D0	READY ?
	BEQ.S	JOYWAIT	NO
	MOVE.B	#$16,2(A0)	REQUEST JOYSTICK DATA
	MOVE.W	#$80,$FFFF8606	SELECT FDC COMMAND REG
	MOVE.W	$FFFF8604,D0	READ FDC STATUS REG
	BTST.B	#7,D0	MOTOR ON ?
	BNE.S	DRIVEON	YES
	MOVE.B	#$E,$FFFF8800	ELSE DESELECT FLOPPIES
	MOVE.B	$FFFF8800,D0
	ORI.B	#7,D0
	MOVE.B	D0,$FFFF8802
DRIVEON	MOVE.L	(A7)+,A0	RESTORE A0

NOT32	MOVE.L	(A7)+,D0	RESTORE D0
	RTE		DONE

*	READ KYBRD/JOYSTICK

READKEY	MOVEM.L	D0/D1/A0,-(A7)	STORE REGS
STILLIRQ	LEA	$FFFFFC00,A0	KEYBOARD STATUS/CONTROL
	MOVE.B	(A0),D1	READ STATUS TO CLEAR FLAGS
	BTST	#7,D1	IRQ ?
	BEQ	NOKEY2	NO
	BTST	#0,D1	BUFFER FULL ?
	BEQ.S	NOKEY1	NO
	MOVE.B	2(A0),D0	READ DATA
NOKEY1	ANDI.B	#$20,D1	ERROR ?
	BEQ.S	JKFLG	NO
	MOVE.B	2(A0),D1	READ AGAIN,CLEAR STATUS
	BRA	NOKEY2

JKFLG	MOVEQ	#0,D1	CHECK PACKAGE COUNT
	BNE.S	JOYVALS	IF IN PACKAGE

	CMPI.B	#$FD,D0	START OF JOYSTICK PACKAGE ?
	BEQ.S	NEWJOY	YES

	MOVE.B	D0,KEY+1	STORE KEY READ
	CMPI.B	#$2A,D0	LEFT SHIFT ON ?
	BNE.S	LSHFTOK
	SEQ	LSHIFTFLAG+1
LSHFTOK	CMPI.B	#$36,D0	RIGHT SHIFT ON ?
	BNE.S	RSHFTOK
	SEQ	RSHIFTFLAG+3
RSHFTOK	CMPI.B	#$AA,D0	LEFT SHIFT OFF ?
	BNE.S	LSHFTOK1	NO
	CLR.B	LSHIFTFLAG+1
LSHFTOK1	CMPI.B	#$B6,D0	RIGHT SHIFT OFF ?
	BNE.S	LSHIFTFLAG	NO
	CLR.B	RSHIFTFLAG+3
LSHIFTFLAG	MOVEQ	#0,D0
RSHIFTFLAG	ORI.W	#$0,D0
	MOVE.B	D0,SHIFTFLAG
	BRA.S	JKDONE	EXIT

NEWJOY	MOVEQ	#2,D1	SET COUNT TO 2 BYTES
	BRA.S	JKDONE	EXIT

JOYVALS	SUBQ.B	#1,D1	DECREASE PACKAGE COUNT
	BEQ.S	SECOND	IF LAST BYTE OF PACKAGE

	MOVE.B	D0,JOY0+1	STORE JOYSTICK 0 DATA
	BRA.S	JKDONE	EXIT

SECOND	MOVE.B	D0,JOY1+1	STORE JOYSTICK 1 DATA

JKDONE	MOVE.B	D1,JKFLG+1	EXIT-STORE NEW PCKGE COUNT
NOKEY2	BCLR	#6,$FFFFFA11	CLEAR IRQ MASK
	MOVEM.L	(A7)+,D0/D1/A0	RESTORE REGS
	RTE		RETURN

KEYS1	DC.B	$80,1	RESET KEY READ STATE
KEYSET	DC.B	$12,$1A	MOUSE OFF,JOYSTICK OFF

MENU	DC.B	27,"E",27,"Y",32,50,"MENU",12,13,12
	DC.B	"1. LOAD AND VIEW NEO FILE",12,13
	DC.B	"2. SELECT SPRITE",12,13
	DC.B	"3. CONVERT GRAPHICS STRIP AND PRE-ROTATE"
	DC.B	12,13,"4. SCROLL STRIP-TO CHECK IT",12,13
	DC.B	"5. SAVE ALL STRIP DATA",12,13,12
PROMPT	DC.B	"WHAT NEXT ? ",0
FILEPROMPT	DC.B	"FILENAME ? ",0
SHIFTFLAG	DC.B	0
ASCII	DC.B	0,0,"1234567890-=",8,0,"QWERTYUIOP[]",13,0
	DC.B	"ASDFGHJKL;'`",0,"#ZXCVBNM,./",0,0,0," "
	DC.B	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DC.B	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"\"
ASCII1	DC.B	0,1,"!",34,"œ$%^&*()_+",8,0,"qwertyuiop{}"
	DC.B	13,0,"asdfghjkl:@_",0,"~zxcvbnm<>?",0,0
	DC.B	0," ",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DC.B	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"|"

	EVEN

DATALENGTH	EQU	64*48*8

CHARBUFF	DC.B	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	DC.B	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ENDSTO	DC.B	0

	EVEN

JOY0	DC.W	0

JUMPS	DC.L	VIEWNEO,GETIT,CONVDATA,SCROLLDATA,SAVEDATA
SAVEPALL	DS.L	8
NEOPALL	DS.L	32
STORE	DSBSS.B	32000*6

	END
