*falls #taste: setze Datum der ST_uhr.  sonst:

*holt .o-FILE (das AS68 hinterlie) macht draus .tos-FILE; mu relocierbar sein!
* hol m”glichst laut Name, der auf stack bergeben. Sonst Name von Tastatur.
* Wenn Name z.B. auf xx3.O endet, so suche xx2.o oder xx2.TO, h„ngs dran
* (wobei xx2.o am header und am tail gekrzt), dann ebenso xx1.o oder xx1.TO
*  noch dran, dann xx.tos generieren. xx.TOS ohne Ziffer,wenns xx1.o gab.
*l”scht altes .tos        verlangt neue zeileneingabe, wenn asci<32 au13

.text



ttr: equ -90    ab echt_hier bytes von tastatur
mxt: equ ttr+77 also maximal 77bytes
EE:  equ -100  ab hier KEIN eingelesner Text mehr
inf: equ -104  ab diesr adr bewahrt die basepage bergebene Infos auf
nam: equ -108  hier filename z.B. 'A:ORDD\XXX4.O'
pkt: equ -112  hier der '.' innerhalb des filenamens
dta: equ -116


 MOVEQ #$2F,D4
WUCL:
 BSR CLOSE      nur so ist CLOSE der handleNr des GENTOS.TOS zu erreichen
 DBPL D4, WUCL

 move.L 4(a7),a0  ab hier eventuell Infos (falls via ANWENDUNG gestartet)
 link  a4,#-200  platz brm stack frdiverse variablen
 subq  #8, a4
 move.L a0,inf(a4)

 moveq #5, d0      'filename: ' etc
 bsr   tx
 move.L inf(a4),a0
 LEA    150(a0),a1   *zwi a0 und a1 k”nnte evtl ein pathname stehen
 cmp.l  a0,     a7
 bcs    h9
hh: cmp.b #'O',(a0)+
 beq    h2
 cmp.L  a1,     a0
 bcc    h9
 bra    hh
h2:
 cmp.b #'.',-2(a0)
 bne    hh
 LEA    -2(a0), a1    *also '.O' gefunden, a1 zeigt '.', a0 hinters 'O'

 MOVE.B -(A1),D0
 CMP.B #$9F,D0
 BHS  hh
 CMP.B #'0',D0
 BLO  hh
* CMP.B #':',D0
* BLO  h3
* CMP.B #'?',D0
* BLS  hh
h3:
 MOVE.B -(A1),D0
 CMP.B #$9F,D0
 BHS  hw4
* CMP.B #'?',D0
* BHI  h3
* CMP.B #':',D0
* BEQ  hdop
* BHI  hh
 CMP.B #'0',D0
 BHS  h3
hw4:
 ADDQ.L #1,A1
hww:
 CLR.B   (A0)   *hier text des pathname zuende, mu mit 0 mark werdn
 LEA (A1),A0
 bsr tx_
 lea (a1),a0
 bra ooo
hdop:
 SUBQ.L #1,A1
 BRA hww
pfehlr:
 moveq #5,d0   'bitte nochmals__ mit .o'
  bsr  tx
h9: bsr rd      gibt ebenfalls 0 als Endemarke
 bmi setDate
ooo:
 MOVE.L A0, nam(a4)
NOCHO:
 MOVE.B (A0)+,D0
 BNE NOCHO       bis also a0 aufs byte hinter der 0 zeigt
 MOVEQ #$DF,D0
 SUBQ.L #1, A0
 AND.B -(A0),D0
 CMP.B #'O',D0
 bne   pfehlr
 CMP.B #'.',-(A0)
 bne     pfehlr
 MOVE.L A0, pkt(A4)
 LEA LL(PC),A0     ab hier RAM nutzbar
 BSR OPUNDRD
 BMI das_wars
 LEA  LL(PC),A1   filebeginn
 ADD.L A1,  A0    plus fileL„nge
 MOVE.L A0,EE(A4)  bishier (excl) steht nun das file
 MOVEQ  #$1C,D0
 ADD.L  2(A1),D0
 ADD.L  6(A1),D0   L„nge des files xx.tos
 MOVE.L D0,2(A1)
 CLR.L    6(A1)
 CLR.L   10(A1)
 CLR.L   14(A1)
 CLR.L   18(A1)
 CLR.L   22(A1)
 MOVE.W #$DADA,26(A1)  nun fileVORSPANN so, da nur obj- &dat-Teil
 LEA   0(A1,D0.L),A1   zeig hinters file xx.TOS
 CMP.L EE(A4),   A1    zu weit?
 BHI   dasssw
 MOVE.L A1,EE(A4)
SONCH1:
 MOVEQ #1,D0
 AND.B EE+3(A4),D0
 BNE   NIXDADA
 MOVE.L EE(A4),A1
 CMP.W #$DADA,-(A1)  endend mit DADA auf gerader adr? dann evt was dazuh„nge!
 BNE   NIXDADA
 MOVE.L pkt(A4),A0
 MOVE.B -(A0), D0
 CMP.B #'2',D0
 BLO  OBDADA
 CMP.B #'9',D0
 BHI  OBDADA
 SUBQ.B #1,(A0)  z.B. name 'xx4.O' nun zu 'xx3.O' gemacht
 MOVEQ  #8,D0
 BSR    tx
 MOVE.L nam(A4),A0
 BSR    tx_
 SUBQ.L #2, EE(A4)  statt DADA weiteres file dranh„nge
 MOVE.L EE(A4),A0
 BSR OPUNDRD
 BPL OKAYO
 MOVEQ #9,D0
 BSR tx
 MOVEQ  #8,D0
 BSR    tx
 MOVE.L pkt(A4),A0
 MOVE.B #'T',1(A0)
 MOVE.B #'O',2(A0)
 CLR.B       3(A0)
 MOVE.L nam(A4),A0
 BSR    tx_
 MOVE.L EE(A4),A0
 BSR OPUNDRD
 BPL OKAYTO
 MOVEQ #11,D0
 BSR tx
 BSR rd1
 CMP.B #'0',D0
 BEQ daswars
 BRA OBDADA

OKAYO:
 MOVE.L EE(A4),A1  ab hier wurde das hinzugekommene ins RAM gelesen
 MOVE.L 2(A1),D1
 ADD.L  6(A1),D1   L„nge dessen, was wirklich ben”tigt wird
 BEQ    daww
 CMP.L  A0,  D1    zu weit? (A0=realeL„nge aus subrout OPUNDRD)
 BHI    dasssw
 MOVE.L EE(A4),A1  Verl„ngerung protokolliere
 ADD.L  D1,EE(A4)
 LEA   LL(PC),A0
 ADD.L  D1, 2(A0)  Verl„ngerung im 1.header protokolliere
 SUBQ.L #2, 2(A0)  weil .w #$DADA des bisherigen files berschrieben wird
 LEA   $1C(A1),A0  vorbereite,die 28 bytes des 2.header zu berschreiben
SCHIBW:
 MOVE.B (A0)+,(A1)+
 SUBQ.L #1, D1
 BNE   SCHIBW     bis A1 = EE(A4)
 BRA  SONCH1

OKAYTO:
 MOVE.L A0,D0
 ADD.L  D0,EE(A4)
 LEA   LL(PC),A0
 SUBQ.L #2, D0
 ADD.L  D0, 2(A0)  Verl„ngerung im header protokolliere
 BRA  SONCH1

*******************
OBDADA:

NIXDADA:
 MOVE.L pkt(A4),A0
 CMP.B #'1',-1(A0)
 BNE   NXXAA
 MOVE.B #'.',-(A0)
NXXAA:
 ADDQ.L #1,A0
 move.B #'T',(A0)+
 move.B #'O',(A0)+
 move.B #'S',(A0)+
 clr.b     (A0)
* MOVE.W #$2F,-(A7)  gibt d0= adr der DT (DiskTransferAddress)
* TRAP  #1
* ADDQ.L #2,A7
* MOVE.L D0,dta(A4)
 LEA -90(A7),A7
 LEA  (A7),  A1
 MOVE.L A1,  D1
 MOVE.L nam(A4),A0
N1B1C:
 MOVE.B (A0)+,(A1)+  name auf localStack kopieren
 BNE N1B1C
 MOVE.L D1, -(A7)
 MOVE.W #$41,-(A7)   UNLINK  ein bestehendes xx.TOS l”schen
 TRAP  #1
 LEA  96(A7),A7

 clr.w         -(a7)    bei create: code fr Les/Schreib-File
 move.L nam(A4),-(a7)   adr des filenames
 move.w #$3C,  -(a7)    * create
 trap   #1
 pea    LL(PC) *-(a7) aus dieser RAM_Adresse file holen
 MOVE.L EE(A4),A0    bis hier
 SUB.L  (A7),  A0    somit soviele bytes
 MOVE.L A0,    -(a7)
 move.w d0,    -(a7) *handleNr (von create)
 move.w d0,     d4    handle aufheb
 move.w #$40,  -(a7) * WRITE file
 trap   #1
 bsr  CLOSE
 bra daswars

holziff:
 bsr rd1      readTastaturWithEcho
 sub.b #48,d0 unter ziffer 0?
 bcs  nziff
* cmp.b #9,d0 oberhalb ziffer 9?
* bhi  nziff
 and  #15, d0
 mulu #10, d1
 add  d0,  d1
 moveq #-1,d0 flag mi: ziffer getippt
 bra  rziff
nziff:
 cmp.b #13,d0 flag eq: nixZiffer, RET getippt
 beq  rziff
 and  #7, ccr flag pl: andre NichtZiffer
rziff:
RTS

setDate:
 moveq #4, d0
 bsr  tx
 moveq #0,  d1
 moveq #0,  d2
 moveq #0,  d3
h1: bsr holziff
 bmi   h1
 bne   n1
 move  d1,  d2
 bra   setzj
n1:move d1, d2  TAG
 moveq  #0, d1
hh2: bsr holziff
 bmi   hh2
 bne   n2
 move  d1,  d3  MONAT
 bra   setzj
n2:move d1, d3
 moveq  #0, d1
hh3: bsr holziff
 bmi   hh3
*              d1=JAHR
 tst   d1
 bne   jchck
setzj:
 move #1990,d1
jchck:
 cmp  #1980,d1
 bhs   numach
 cmp   #100,d1
 bhs   setzj
 add  #1900,d1
numach:
 sub  #1980,d1
 swap       d1   jahrCode vorerst in bits 16..22
 move d3,   d1
 lsl  #8,   d1
 lsl   #4,  d1   monatCode in 12..15
 lsr.L #4,  d1   j= 12..18  m= 8..11
 move.b d2, d1
 lsl.b #3,  d1    tagCode in 3..7
 lsr.L #3,  d1   j=9..15 m=5..8 t=0..4
 
 move d1,  -(a7)
 move #$2B,-(a7)  setDate
 trap #1
 addq #4,  a7
 bra  daswars

daww:
 moveq #10,d0
 bra  das__wars
dasssw:
 moveq #7,d0
 bra  das__wars
das_wars:
 moveq #6,d0
das__wars:
 bsr   tx_rd
daswars: clr.w     -(a7)
        trap #1

OPUNDRD:
 MOVE.L A0,-(A7)  merk startadresse (wo file ins RAM soll)

 MOVE.L nam(A4),-(A7)
 MOVE.W  #$3D,-(A7)  * open
 TRAP  #1
 ADDQ.L #6,A7
 MOVE.L (A7)+,A0
 MOVE.W D0,D0
 bmi   fehler
 MOVE.W D0,-(A7)   merk handle

 MOVE.L A0, -(A7)  ab hier memory beschreiben
 lea  -98(a7),a0   bis maximal hier
 sub.L (a7),  a0
 move.L a0, -(a7)   RAMl„nge
 move.W d0, -(a7)   handle-Nr des file
 move.W #$3F,-(a7)  read
 trap   #1
 ADDA.W #12,A7
 MOVE.W (A7)+,D4  handl
 MOVE.L D0,D0
 BMI   fehler
 MOVE.L D0,-(A7)  L„nge
 BSR   CLOSE
 MOVE.L (A7)+,A0  L„nge
fehler:
 RTS  mit flag mi(zB.aus CLOSE), wenn floppyfehler aufgetreten. sonst a0=L„nge.

CLOSE:
 MOVE.W D4, -(A7)
 MOVE.W #$3E,-(A7)  close
 TRAP   #1
 ADDQ.L #4,A7
 TST.W D0
RTS

*subr holt einen ascii von tastatur  !a0d0
rd1:
 move #1,-(a7)  readTastaturWithEcho
 trap #1
 addq #2,a7
 RTS

*subr ruft tx und rd1
* gib mi=Taste1 ov=Taste2 eq=Taste0
*tx_r:
* bsr tx
* bsr rd1 
* cmp.b #'1',d0
* beq   fou1
* cmp.b #'2',d0
* beq   fou2
* cmp.b #'0',d0
* beq   fou0
* move  #0, ccr
* rts
*fou1: move #8,ccr
* rts
*fou2: move #2,ccr
* rts
*fou0:
* rts

*subr ruft tx und rd     !a0a1d0
tx_rd:
 bsr tx

*subr gib a0=a4+ttr, ab hier tastaturEinles  flag mi, wenn # getipt !a0a1d0
rd:
 bsr newline
 lea ttr(a4),a1  ab hier tastatur einles
 bra no1rd
de1rd:
 cmp.b #8,d0  BACKSPACE?
 bne   n1rd
 lea  mxt(a4),a0
 cmp.L a0,   a1  ganz hintn im EinlesBuffr(cc)?
 bcs  ok1li
 bsr  cu1re     vom sys ist cursor bereits 1links gestellt, hintn nichtsinnvoll
ok1li:
 bsr  blank
 bsr  cu1li
 lea ttr(a4),a0
 cmp.L a1,  a0   ganz vorn im EinlesBuffer?
 bcc  no1rd
 bra  cl1rd
n1rd:
 lea  mxt(a4),a0  ab hier drfen KEINE zeichen mehr hin
 cmp.L a0,   a1
 bcs  noc1rd
 subq #1,    a1
noc1rd:
 move.b d0, (a1)+
 beq   cl1rd      asciis=0 nicht registrieren
 lea  mxt(a4),a0  ab hier drfen KEINE zeichen mehr hin
 cmp.L a0,   a1
 bcs   no1rd
 bsr   cu1li
 bra   no1rd
cl1rd:
 subq #1,  a1
no1rd:
 bsr  rd1
 CMP.B #'#',D0
 BEQ  FIS
 cmp  #13,d0    carrRt?
 bne  de1rd
 clr.b      (a1) so i.a. return mit flag eq
 lea  ttr(a4),a0
 RTS
FIS:
 MOVEQ #-1,D0
 RTS

blank:
moveq #1,d0
bra   tx

cu1li:
moveq #2,d0
bra   tx

cu1re:
moveq #3,d0
bra   tx

newline:
moveq #0,d0

*subr sucht ab "dat:" nach sovielNullen,wie d0 angibt.TXTabDORTauf tv !a0d0
tx:
 lea dat(pc),a0
tsx: tst.b (a0)+
 bne  tsx
 dbra d0, tsx
tx_:
 pea  (a0)
 move #9,-(a7)
 trap #1
 addq #6, a7
 RTS
dat:
dc.b 0
dc.b 10,13,0
dc.b ' ',0
dc.b 27,68,0
dc.b 27,67,0
*dc.b 10,13,'tip Zahlen erste=TAG zweite=MONAT evtlDritte=JAHR',10,13,0
*dc.b 10,13,'{#=setDate} ansonsten, um .TOS zu generiern,',13,10,' Ganzer .O-Name: ',0
*dc.b 10,10,13,' Fehler bei File-Suche  ## Abbruch ## ',0
*dc.b 10,13,'bitte nochmals, !endend mit .O',0
*dc.b 13,10,10,' Fehler der file-L„nge, gehtnichso! ',0
*dc.b 13,10,' dranh„ngVersuch: ',0
*dc.b 13,10,' - aber leider gibts kein file dieses Namens.',0
*dc.b 13,10,'(gekrztes) file = 0 ?? ',0
*dc.b 13,10,' auch dies file gibts nicht. tipp '
*dc.b 13,10,' 0=abbrechen, ansonstn bisher gesammelts speichrn ',0
dc.b 13,10,'T M J ',0
dc.b 10,13,'{#} .O-Nam:',0
dc.b 'F?',0
dc.b 'L?',0
dc.b 13,10,'+',0
dc.b 'no',0
dc.b '?',0
dc.b 'no 0=ab,elseS',0
.even

LL: dc.w 0
.end

