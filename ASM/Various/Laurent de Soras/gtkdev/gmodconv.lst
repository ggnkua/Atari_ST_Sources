' ****************************************************************************
' *                                                                          *
' *             G R A O U M F   M O D U L E   C O N V E R T E R              *
' *                Convertisseur de modules de soundtrackers                 *
' *                        By Laurent de Soras, 1996                         *
' *                                                                          *
' ****************************************************************************
'
' Routines de sauvegarde et de chargement issues du Graoumf Tracker
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                              Initialisations                             *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
RESERVE -131072                 ! 128 Ko reserves pour le systeme
gtk_version%=10600              ! Numero de version du logiciel x10000
gtk_file_vnum%=4                ! Numero de format de module GTK
gt2_file_vnum%=1                ! Numero de format de module GT2
npath_prog$=CHR$(ADD(65,GEMDOS(&H19)))+":"+DIR$(0)+"\SYS\"
' npath_prog$="F:\DEV.GTK\SYS\"   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
npath_prefs$=npath_prog$        ! Chemin des preferences
nfile_prefs$="GTKPREFS.INF"     ! Fichier de preferences a charger
key_click%=PEEK(&H484)          ! Sauve l'etat du clavier
'
GOSUB init_variables_prefs
'
IF FN exist(npath_prefs$+nfile_prefs$)
  GOSUB load_prefs2(npath_prefs$+nfile_prefs$,TRUE)
ENDIF
'
' Initialisations diverses 1
' --------------------------
xbra_remove$=""                 ! Les adr de tous les vecteurs detournes (adr_vect.l, old_val_vect.l)
GOSUB change_resolution
adr_af_pat%=ADD(XBIOS(2),MUL(SHR(scr_larg%,1),170))     ! Adresse d'affichage des patterns
ON BREAK GOSUB br
GOSUB bee(TRUE)
SPOKE &H484,PEEK(&H484) AND -2
~XBIOS(&H82,4,2)
~XBIOS(&H82,5,0)                ! Connecte l'ADC pour la partie enregistrement
GOSUB charge_g_routines
'
GOSUB init_tableaux
'
' Initialisations diverses 2
' --------------------------
para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
place_totale%=SUB(FRE(0),655360) AND -4                 ! La place qu'il reste pour patterns+samples
garbage%=0
GOSUB charge_r_routines
ARRAYFILL module&(),&H2020              ! Initialise le module
module&(0)=&H4754
module&(1)=ADD(&H4B00,gtk_file_vnum% AND 255)
module&(98)=255                         ! Nbr d'instr
module&(99)=nbr_lines%
module&(100)=nbr_track%
module&(101)=1
module&(102)=0
'
GOSUB init_fonctions_simples
'
GOSUB init_variables_post_prefs
'
HIDEM
SETMOUSE SHL(ADD(divbi&(0,0,0),SHR(SUCC(divbi&(2,0,0)),1)),3),ADD(divbi&(1,0,0),5),0
flag_registered!=TRUE
flag_registered2!=TRUE
~FRE(0)
ON ERROR GOSUB erreur_gfa_basic
sortie!=FALSE
REPEAT
  CLS
  GOSUB bee(FALSE)
  txt$="**********************************|"
  txt$=txt$+"*                                *|"
  txt$=txt$+"*    Graoumf Module Converter    *|"
  txt$=txt$+"*                                *|"
  txt$=txt$+"*   By Laurent de Soras - 1996   *|"
  txt$=txt$+"*         \\ Freeware //         *|"
  txt$=txt$+"*                                *|"
  txt$=txt$+"**********************************||"
  txt$=txt$+"Please select a module."
  GOSUB dialog("v"+STR$(gtk_version%/10000),txt$,"Select|Quit",MOUSEX,MOUSEY)
  IF bouton%<>1
    next_module$="*.*"
    GOSUB load_module
    CLS
    txt$="New module format?||"
    txt$=txt$+"GT2/GTK: Graoumf Tracker|"
    txt$=txt$+"MOD    : ProTracker|"
    txt$=txt$+"S3M    : Scream Tracker"
    GOSUB dialog("",txt$,"GT2|GTK|MOD|S3M|Cancel",MOUSEX,MOUSEY)
    IF bouton%<>4
      next_module$="*."+MID$("GT2GTKMODS3M",SUCC(MUL(bouton%,3)),3)
      GOSUB save_module
    ENDIF
  ELSE
    sortie!=TRUE
  ENDIF
UNTIL sortie!
GOSUB br
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                                Procedures                                *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' Systeme
' -------
PROCEDURE rien
  ' rien !!!
RETURN
PROCEDURE br
  HIDEM
  IF r_flag_the_end%>0
    DPOKE r_flag_the_end%,1     ! A pu zik...
  ENDIF
  ~XBIOS(5,L:oldscreenadr%,L:oldscreenadr%,3,oldscreenmode%)
  GOSUB restaure_palette                        ! Restaure la palette
  ~XBIOS(&H82,5,3)
  ~XBIOS(&H82,4,3)
  SPOKE &H484,key_click%        ! Bip bip
  SETCOLOR 0,&HFFF
  SETCOLOR 15,0
  WHILE xbra_remove$<>""        ! On remet les vecteurs a l'envers car il peut y avoir plusieurs fois le meme vecteur detourne
    SLPOKE LONG{ADD(V:xbra_remove$,SUB(LEN(xbra_remove$),8))},LONG{ADD(V:xbra_remove$,SUB(LEN(xbra_remove$),4))}
    xbra_remove$=LEFT$(xbra_remove$,SUB(LEN(xbra_remove$),8))
  WEND
  SHOWM
  GOSUB bee(FALSE)
  EDIT
RETURN
PROCEDURE erreur_gfa_basic
  erreur_gfa%=ERR
  flag_erreur_gfa!=TRUE
  PRINT CHR$(7);
  GOSUB aff_message("ERROR : "+ERR$(erreur_gfa%)+" PRESS A KEY.")
  ~GEMDOS(7)
  GOSUB aff_message("NEXT MISTAKE... LAST MISTAKE!")
  flag_erreur_gfa!=FALSE
  RESUME NEXT
RETURN
'
' Initialisations
' ---------------
PROCEDURE init_variables_prefs
  '
  ' Variables configurables dans les preferences
  ' --------------------------------------------
  color_pal$="00088FF00F4F800C6FF40F8F888AAACCCFFF889AABCCDFFF" ! La palette (RVB pour 16 couleurs)
  grmode_overscan%=-1           ! -1 = suivant VGA/RGB/TV, 0 = aucun overscan, 1 = force l'overscan
  grmode_80colonnes%=1          ! -1 = laisse, 0 = 40 colonnes, 1 = 80 colonnes
  grmode_entrelace%=-1          ! -1 = laisse, 0 = 200/240 lignes, 1 = 400/480 lignes
  grmode_puissance_plans%=2     ! -1 = laisse, 0 = 2 couleurs, 1 = 4, 2 = 16, 3 = 256, 4 = 65536
  graoumf_logo_color%=4         ! Numero de la couleur du logo (marron)
  npath_sample$=npath_prog$     ! Chemin des samples
  npath_module$=npath_prog$     ! Chemin des modules
  npath_autoload$=npath_prog$   ! Chemin d'autochargement
  npath_div$=npath_prog$        ! Chemin des operations diverses
  nfile_sample$=""              ! Fichier par defaut pour les samples
  nfile_module$=""              ! Fichier par defaut pour les modules
  nfile_autoload$=""            ! Fichier par defaut a autocharger
  nfile_p1$="DUMTRACK.PGT"      ! Nom du fichier contenant les routines diverses
  nfile_p2$="GTPLAY.PGT"        ! Nom du fichier contenant le player
  next_module$="*.GT2"          ! Extension pour les modules
  next_sample$="*.AVR"          ! Extension pour les samples
  nbr_track%=4                  ! Nombre de voies
  nbr_lines%=64                 ! Nombre de lignes (n'a plus d'utilite mais sert encore)
  instr%=1                      ! Instrument courant
  sample%=1                     ! Sample courant
  n_preset%=0                   ! Numero du preset courant
  line_step%=1                  ! Saut de ligne a l'edition
  haut_lig%=99999               ! Nombre de lignes de pattern affichees (99999 car min dans chgt de resol)
  octave%=1                     ! Octave-1 (0-6 -> 1-7)
  default_pattern_high%=64      ! Nombre de lignes a mettre sur un pattern lors de sa creation
  ss_menu%=1                    ! 1 = disk, 2 = tools, 3 = instr, 4 = samples, 5 = enveloppes
  ss_menut%=1                   ! Numero de sous-menu du sous-menu Tools (1, 2 ou 3)
  ss_menui%=1                   ! Numero de sous-menu du sous-menu Instruments
  ss_menus%=1                   ! Numero de sous-menu du sous-menu Samples
  ss_menue%=0                   ! Numero de sous-menu du sous-menu Envelopes (0, 1 ou 2)
  ss_menuc_npan%=0              ! Plage des pannings du sous-menu Control (0 = 1-8, 1 = 9-16, etc...)
  ss_menu2%=1                   ! Numero de sous-menu de l'editeur de sample
  ss_menu2.fl%=1                ! Num ss-menu Flanger (1 ou 2)
  ss_menu2.rev%=1               ! Num ss-menu Reverb (1 ou 2)
  maskblock%=0                  ! 0 = all, 1 = masque
  replaceblock%=0               ! 0 = replace, 1 = transparent
  trackpat%=0                   ! 0 = piste, 1 = pattern, 2 = preset
  bl_flagsong!=FALSE            ! Si l'operation de bloc porte sur toute la song
  bl_maska1$=STRING$(5,0)       ! 0 = n'importe quoi, F = seulement bl_maska2%
  bl_maska2$=STRING$(5,0)       ! Copie si (note AND bl_maska1)=bl_maska2
  bl_maskb1$=STRING$(5,255)     ! F = n'importe quoi, 0 = seulement bl_maskb2%
  bl_maskb2$=STRING$(5,0)       ! Masque de remplacement
  bl_echo_lines%=2              ! Echo toutes les 2 lignes
  bl_echo_feedback%=50          ! 50% de feedback dans l'echo
  bl_echo_fadestep%=&H40        ! - $40 de volume a chaque echo
  bl_echo_cont!=FALSE           ! Ne joue l'echo que de la derniere note
  bl_echo_fdbk!=TRUE            ! True = feedback, False = fade
  ext_note1%=&HFFFFFF           ! F = n'importe quoi, 0 = met qqc
  ext_note2%=0                  ! (Effet AND ext_note1) OR ext_note2
  signe_sam%=0                  ! A ajouter au sample quand sauve/charge
  drumpad_flag%=0               ! 0 = No d'instr, 1 = drumpad
  freq_buffer%=8363             ! Frequence de base du buffer
  snapshot_number%=0            ! Numero du dernier snapshot effectue
  snapshot_format%=1            ! Format du snapshot : 0 = TGA 16 couleurs, 1 = TGA 24 bits
  flag_keep_buffer!=FALSE       ! S'il est mis, les modules detruisent le buffer au minimum
  flag_gt2cnf!=FALSE            ! Sauvegarde de la configuration du GT dans les modules GT2
  flag_backup_modules!=TRUE     ! Sauve les modules avec back up en fichier .BAK
  type_affpiste%=1              ! Affichage des pistes : 0 = note+ins, 1 = normal, 2 = +volume
  env_num&=1                    ! Numero de l'enveloppe editee
  env_sect&=0                   ! Section de l'enveloppe editee : 0 = attack, 1 = key off
  env_copy&=1                   ! Numero de l'enveloppe a copier
  se.mix_master_volume%=16384   ! Master volume (/32768) pour la fonction de mixage
  se.rec_input_device%=0        ! Entree digitalisation : 0 = Falcon ADC, 1 = ST Replay pro
  se.rec_canal%=1               ! Canal d'entree : 1 = Left, 2 = Right, 3 = Left+Right
  se.rec_adc_freq%=1            ! Frequence de digit sur l'ADC du Falcon (freq type CODEC)
  se.rec_ext_freq%=44100        ! Frequence de digit avec un autre ADC (ST Replay pro)
  se.rec_trigger%=6553          ! Impulsion minimum pour commencer la digit /32768
  se.rec_flag_trigger!=FALSE    ! False = trigger off, true = trigger on
  se.freq_nfe%=16390            ! Nouvelle frequence d'echantillonnage
  se.freq_ofn%=131              ! Ancienne frequence de note
  se.freq_nfn%=131              ! Nouvelle frequence de note
  se.freq_iptype%=1             ! Type d'interpolation : 0 = none, 1 = Linear, 2 = 3rd degree
  se.freq_fftdisp%=0            ! 0 = affichage lineaire, 1 = affichage logarithmique
  se.freq_fftwin%=0             ! Fenetrage FFT : 0 = rectangulaire, 1 = Blackman
  se.freq_fftnoteon!=TRUE       ! Affichage ou non de la frequence de la note sur la FFT
  se.freq_fft_cflag!=TRUE       ! Calcule la note du sample avec la FFT
  se.freq_fft_pnbr%=640         ! Nombre de points a calculer pour la FFT
  se.delay_flags%=&X1           ! Chaque bit (0-3) = tap on/off, bit 4 = mute in, bit 5 = multi-tap mode
  se.delay_feedback%=0          ! Feedback du delay (/32768)
  se.delay_timefeed%=375        ! Temps de repetition (ms)
  se.delay_dry%=32768           ! Niveau du son clair (/32768)
  se.delay_wet%=16384           ! Niveau du delay
  se.delay_source%=0            ! Sample source : 0 = buffer, 1-255 = sample
  se.delay_mutein%=500          ! Temps (ms) apres lequel le signal d'entree est coupe
  se.flanger_dry%=16384         ! Niveau dry du flanger (/32768)
  se.flanger_wet%=16384         ! Niveau wet
  se.flanger_lsource%=0         ! Sample source gauche (0 = buffer)
  se.flanger_rsource%=0         ! Sample source droit   " "    "
  se.flanger_time%=1000         ! Delay du flanger (Ês) -> 10 ms
  se.flanger_freq%=500          ! Frequence du flanger (mHz)
  se.flanger_depth%=500         ! Profondeur du flanger (Ês) -> 6.35 ms
  se.flanger_fdbkll%=9830       ! Feedback L -> L (30%)
  se.flanger_fdbklr%=9830       ! Feedback L -> R (30%)
  se.flanger_fdbkrr%=9830       ! Feedback R -> R (30%)
  se.flanger_fdbkrl%=9830       ! Feedback R -> L (30%)
  se.flanger_phase%=0           ! Phase intitiale (0-4095)
  se.flanger_wave%=0            ! 0 = sin, 1 = carre, 2 = triangle, 3 = scie descendante, 4 = scie montante
  se.flanger_stereo!=FALSE      ! Flag de stereophonie du flanger
  se.rev_aprdelay%=5000         ! Delay de l'All Pass Reverb, en Ês. Maxi : 0.25 s
  se.rev_aprg%=22937            ! Feedback de l'All Pass reverb
  se.rev_adlydelay%=26540       ! Delay de l'Alignement delay, en Ês. Maxi : 0.25 s
  se.rev_drylevel%=16384        ! Dry level (/32768)
  se.rev_revlevel%=11469        ! Reverb level (/32768)
  se.rev_ereflevel%=4915        ! Early reflection level (/32768)
  se.rev_nbrtaps%=7             ! Nombre de taps pour l'Early reflection
  se.rev_nbrcomb%=4             ! Nombre de comb filters
  se.rev_combgain%=27852        ! Gain general des comb filters (/32768)
  se.rev_source%=0              ! Sample source (0 = buffer)
  se.rev_tappos%=0              ! Position dans la liste des taps de l'ER
  se.rev_combpos%=0             ! Position dans la liste des comb filters
  se.s2d_posstart%=0            ! Position de depart d'enregistrement
  se.s2d_ligstart%=0            ! Ligne de depart d'enregistrement
  se.s2d_posend%=0              ! Position de fin d'enregistrement
  se.s2d_ligend%=0              ! Ligne de fin d'enregistrement
  se.s2d_bits%=1                ! Enregistrement en 1 : 8 bits, 2 : 16 bits
  se.s2d_stereo%=1              ! Enregistrement en 1 : mono, 2 : stereo
  se.s2d_maxsize%=1024          ! Taille maximum (Ko)
  se.s2d_out%=1                 ! Sortie sur 1 : block, 2 : disk
  se.s2d_2ndtime!=FALSE         ! False : normal, True : attend un bouclage avant d'enregistrer
  se.s2d_speed%=7               ! Vitesse d'enregistrement (0 = vite, 7 = lent). Agit sur _prediv%
  se.s2d_prediv%=11             ! Prediviseur pour la vitesse DMA : 1 = 50KHz, 2 = 32 KHz... Depend de _speed%
  se.comp_source%=0             ! Sample source (0 = buffer)
  se.comp_speed%=10000          ! Periode de recalcul du taux de compression (1-99999) (Ês)
  se.comp_level%=16384          ! Niveau de compression (vol ideal a atteindre) (/32768)
  se.comp_initvolume%=se.comp_level%    ! Volume presume de depart (/32768)
RETURN
PROCEDURE init_variables_post_prefs
  '
  ' Variables diverses non configurables dans les preferences
  ' ---------------------------------------------------------
  gamme$="C-C#D-D#E-F-F#G-G#A-A#B-"
  gamme2$="C C#D D#E F F#G G#A A#B "
  songpos%=0                    ! Position courante dans la song
  posligne%=0                   ! Ligne courante dans le pattern
  curs_x%=0                     ! 0 = note, 1-2 = instr, 3-6 = effet, 7-8 = volume
  curs_col%=0                   ! Colonne du curseur
  play%=0                       ! 0 = stop, 1 = play song, 2 = play pattern
  edit%=0                       ! 0 = stop, 1 = edit
  flag_nvl_boucle_sample%=0     ! Flag de calcul du nouveau bouclage d'un sample
  num_nvl_boucle_sample%=1      ! Le numero du sample
  bl_start&=0                   ! Ligne de debut du bloc
  bl_end&=0                     ! Ligne de fin du bloc
  bl_pat&=0                     ! Pattern 0
  bl_trk&=0                     ! Voie 1
  sample_list_pos%=1            ! Position dans la liste des samples
  instr_list_pos%=1             ! Position dans la liste des instruments
  song_list_pos%=0              ! Position dans l'arrangement des patterns
  instr_note_pos%=48            ! Position dans la liste des notes
  instr_note_aff%=48            ! Affichage dans la liste des notes
  instr_group!=TRUE             ! On manipule tout un groupe de notes
  mark_1%=0                     ! Marqueur de debut de bloc dans le sample
  mark_len%=FN lon_buffer       ! Marqueur de fin de bloc
  mark_2%=ADD(mark_1%,mark_len%)! Marqueur fantome de fin de bloc
  mark_rep%=0                   ! Marqueur de repetition
  win_pos%=mark_1%              ! Debut de la fenetre de sample
  win_lon%=mark_len%            ! Longueur de la fenetre
  win_bits%=1                   ! Buffer 8 bits
  erreur_gfa%=0                 ! Numero d'erreur de GFA Basic
  treg_str1$=" by Laurent de SORAS 1994/95 - Shareware! Demo version"
  treg_str2$="USER.REG"
  treg_str3$="version to"
  treg_str4$=" registered to "
  treg_str5$=" *** Invalid USER.REG file ***"
  ' flag_registered!=FALSE        ! false = demo, true = normal
  ' flag_registered2!=FALSE       ! false = demo, true = normal
  flag_registered3!=FALSE       ! Indique si on a fait ou pas le 2eme test de protection
  flag_erreur_gfa!=FALSE        ! Indique s'il y a eu une erreur
  flag_blague!=FALSE            ! Ne sort pas de vanne a la Julien Boeuf pour l'instant
  flag_autoload!=FALSE          ! N'est pas en cours d'autochargement
  erreur%=0                     ! Sert localement pour la gestion des erreurs
  periode_blague%=4096          ! Periode moyenne de sortie d'une vanne
  debut_temps%=TIMER            ! Valeur du Timer pour le debut du chrono
  env_posaff&=0                 ! Position de l'affichage de l'enveloppe, en commandes
  env_poscurs&=0                ! Position du curseur dans l'enveloppe, en commandes
  env_codpos&=0                 ! Position dans la liste des codes des enveloppes
  se.sample_editor_flag!=FALSE  ! Indique si on est ou non dans l'editeur de samples
  se.volume_ok!=FALSE           ! Indique si le volume du block est valable
  se.volume_spl%=0              ! Volume du-dit block (/32768)
  se.volume_fade_start%=32768   ! Volume de debut de fade (/32768)
  se.volume_fade_end%=32768     ! Volume de fin de fade (/32768)
  se.flag_best_volume!=FALSE    ! Garde le volume du sample quitte a saturer lors d'un effet (True : cherche le meilleur volume)
  se.mark_selected%=0           ! Bits representant les presets de marques selectionnes
  se.mark_set!=FALSE            ! Icone SET alumee ou pas
  se.freq_fftmin%=20            ! Frequence minimum de la FFT (deja calculee)
  se.freq_fftmax%=SHR(freq_buffer%,1)   ! Frequence maximum de la FFT (deja calculee)
  se.freq_fftech%=freq_buffer%  ! Frequence d'echantillonnage du sample lors de la FFT (deja calculee)
  se.freq_fftlon%=1             ! Nombre de frequences scannees par la FFT (deja calculee)
  se.freq_fft_pstart%=0         ! Frequence de debut de calcul FFT
  se.freq_fft_pend%=SHR(freq_buffer%,1) ! Frequence de fin de calcul FFT
RETURN
PROCEDURE init_tableaux
  '
  ' Dimentionnement des tableaux
  ' ----------------------------
  DIM icone$(4,2)               ! Icones du haut
  DIM drumpad%(31,2)            ! Les No d'instr et les notes/instr du drumpad
  DIM preset&(31,31)            ! Numeros de pistes : (colonne,preset)
  DIM nbr_colonnes%(31)         ! Nombre de colonnes affichees pour chaque preset
  DIM t_note%(53)
  DIM fft&(1023)                ! Resultats de FFT
  DIM divbn$(63,31)             ! Noms de divers boutons des sous-menus
  DIM divbi&(3,63,31)           ! Leurs coordonnees et taille
  DIM help$(23,15)              ! Texte d'aide
  DIM blague$(99)               ! Des blagues
  DIM control_old%(12)          ! Anciennes valeurs pour les updates du sous-menu Control
  DIM se.mix_param%(3,4)        ! Parametres de mixages du Sample_Editor : flags (+1=on, +2=loop) , n¯de sample (0=buffer), volume debut/32768, volume fin/32768
  DIM se.mark%(1,9)             ! Presets de samples (start/length,numero)
  DIM se.mark$(9)               ! Le nom des presets
  DIM se.delaytime%(3)          ! Temps (ms) de decalage pour chaque tap
  DIM se.delaylevel%(3)         ! Niveau d'entree (/32768) pour chaque tap
  DIM se.rev_tapdelay%(15)      ! Delay des taps de reverb, en Ês. Maxi : 0.25 s
  DIM se.rev_taplevel%(15)      ! Level des taps de reverb, (/32768)
  DIM se.rev_combdelay%(15)     ! Delay des comb filters de reverb, en Ês. Maxi : 0.25 s
  DIM se.rev_comblpf%(15)       ! Niveau de gain des lpf dans la reverb (/32768)
  DIM se.rev_buffer$(10)        ! Buffers pour la reverb : 3 (early, alignement, APR) + 8 (comb filters)
  DIM env_code$(255)            ! Code des mnemoniques des commandes des enveloppes
  DIM env_conv&(19,2)           ! Conversion (num ds la liste,type) -> Code d'enveloppe
  DIM env_valdef&(19,2)         ! Valeurs par defaut pour les parametres des commandes d'enveloppes
  DIM env_codmax&(2)            ! Nombre maxi de codes pour chaque type d'enveloppe
  '
  ' Remplissage des tableaux
  ' ------------------------
  '
  ' Lecure de l'Help
  '
  RESTORE help_text
  j%=0
  READ a$
  REPEAT
    help$(0,j%)=a$
    FOR i%=1 TO 23
      READ help$(i%,j%)
    NEXT i%
    READ a$
    INC j%
  UNTIL a$="***"
  help_pmax%=PRED(j%)
  '
  ' Initialisation des Marks du S.E.
  '
  FOR i%=0 TO 9
    se.mark%(0,i%)=0
    se.mark%(1,i%)=&HFFFFFE
    se.mark$(i%)=SPACE$(21)
  NEXT i%
  '
  ' Lecture des blagues
  '
  RESTORE textes_blagues
  i%=0
  READ a$
  REPEAT
    flag!=FALSE
    blague$(i%)=""
    REPEAT
      IF flag!
        blague$(i%)=blague$(i%)+"|"
      ENDIF
      blague$(i%)=blague$(i%)+a$
      flag!=TRUE
      READ a$
    UNTIL a$="*"
    INC i%
    READ a$
  UNTIL a$="***"
  blague_nbr%=i%
  '
  ' Initialisation du Drumpad
  '
  FOR i%=0 TO 31
    drumpad%(i%,0)=SUCC(i%)
    drumpad%(i%,1)=ADD(&H3C000000,SHL(SUCC(i%),16))
  NEXT i%
  '
  ' Lecture des icones des sous-menus
  '
  RESTORE icones_disk
  ARRAYFILL divbi&(),-1
  FOR j%=0 TO 26
    READ n%,x%,y%
    FOR i%=0 TO PRED(n%)
      READ a%                   ! Sert a rien pour l'instant
      READ divbn$(i%,j%),divbi&(0,i%,j%),divbi&(1,i%,j%),divbi&(2,i%,j%)
      ADD divbi&(0,i%,j%),x%
      ADD divbi&(1,i%,j%),y%
      READ divbi&(3,i%,j%)
    NEXT i%
  NEXT j%
  ARRAYFILL t_note%(),-1
  '
  ' Lecture des touches
  '
  RESTORE touches_notes
  FOR i%=0 TO 16
    READ a%
    t_note%(a%)=i%
  NEXT i%
  FOR i%=12 TO 32
    READ a%
    t_note%(a%)=i%
  NEXT i%
  '
  ' Lecture des commandes d'enveloppes
  '
  RESTORE enveloppe_coms
  ARRAYFILL env_conv&(),-1
  c%=0
  READ a%,b%
  FOR i%=a% TO PRED(ADD(a%,b%))
    READ env_code$(i%),d%
    env_conv&(c%,0)=i%
    env_conv&(c%,1)=i%
    env_conv&(c%,2)=i%
    env_valdef&(c%,0)=d%
    env_valdef&(c%,1)=d%
    env_valdef&(c%,2)=d%
    INC c%
  NEXT i%
  FOR j%=0 TO 2
    d%=c%
    READ a%,b%
    FOR i%=a% TO PRED(ADD(a%,b%))
      READ env_code$(i%),env_valdef&(d%,j%)
      env_conv&(d%,j%)=i%
      INC d%
    NEXT i%
    env_codmax&(j%)=d%
  NEXT j%
  '
  ' Lecture des delay/levels des taps pour la reverb
  '
  RESTORE rev_tap_delay_level
  ARRAYFILL se.rev_tapdelay%(),0
  ARRAYFILL se.rev_taplevel%(),0
  FOR i%=0 TO 6
    READ a,b
    se.rev_tapdelay%(i%)=a*1000000
    se.rev_taplevel%(i%)=b*32768
  NEXT i%
  '
  ' Lecture des delay/lpfs des comb filters pour la reverb
  '
  RESTORE rev_comb_delay_lpf
  ARRAYFILL se.rev_combdelay%(),70000
  ARRAYFILL se.rev_comblpf%(),0
  FOR i%=0 TO 3
    READ a,b
    se.rev_combdelay%(i%)=a*1000000
    se.rev_comblpf%(i%)=b*32768
  NEXT i%
  '
  ' Init des presets
  '
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  ARRAYFILL nbr_colonnes%(),nbr_track%
  '
  ' Initialise les parametres de la fonction Mix du Sample_Editor
  '
  FOR i%=0 TO 4
    se.mix_param%(0,i%)=(i%<2) AND 1      ! +1 : ON, +3 : LOOP
    se.mix_param%(1,i%)=i%                ! Numero de sample
    se.mix_param%(2,i%)=32768             ! Volume de debut
    se.mix_param%(3,i%)=32768             ! Volume de fin
  NEXT i%
  '
  ' Init des fonctions de delay du S.E.
  '
  FOR i%=0 TO 3
    se.delaytime%(i%)=375
    se.delaylevel%(i%)=32768
  NEXT i%
RETURN
PROCEDURE init_fonctions_simples
  '
  ' Definition des fonctions simples
  ' --------------------------------
  DEFFN zone_start=V:zone%(0)
  DEFFN zone_end=ADD(FN zone_start,place_totale%)
  ' Fonctions concernant les samples
  DEFFN adrsamchk(s%)=LONG{ADD(r_adr_sample%,SHL(s%,2))}
  DEFFN lonsamchk(s%)=LONG{ADD(FN adrsamchk(s%),4)}
  DEFFN adresse(s%)=ADD(FN adrsamchk(s%),64)
  DEFFN volume(s%)=CARD{ADD(FN adrsamchk(s%),58)}
  DEFFN finetune(s%)=INT{ADD(FN adrsamchk(s%),60)}
  DEFFN length(s%)=LONG{ADD(FN adrsamchk(s%),46)}
  DEFFN repeat(s%)=LONG{ADD(FN adrsamchk(s%),50)}
  DEFFN replen(s%)=LONG{ADD(FN adrsamchk(s%),54)}
  DEFFN freqech(s%)=CARD{ADD(FN adrsamchk(s%),44)}
  DEFFN resol(s%)=SHR(CARD{ADD(FN adrsamchk(s%),42)},3)
  DEFFN autobal(s%)=CARD{ADD(FN adrsamchk(s%),40)}
  DEFFN total_length=SUB(ADD(FN adrsamchk(255),FN lonsamchk(255)),FN adrsamchk(0))      ! Memoire totale occupee par les samples
  ' Fonctions concernant les pistes
  DEFFN track_onoff(t%)=CARD{ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,t%))}
  DEFFN track_interpol(t%)=CARD{ADD(ADD(r_info_track%,r_interpol_t%),MUL(r_itl%,t%))}
  DEFFN balance(i%)=CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,i%))}       ! Balance (0-31)
  ' Fonctions concernant les instruments
  DEFFN ivolume(i%)=SHR(instrset%(10,i%),16)
  DEFFN ievol(i%)=SHR(instrset%(11,i%),16)
  DEFFN ieton(i%)=instrset%(11,i%) AND &HFFFF
  DEFFN iepan(i%)=SHR(instrset%(12,i%),16)
  DEFFN itransp(i%,j%)=FN sbyte(BYTE{ADD(V:instrset%(15,i%),SUCC(SHL(j%,1)))})  ! Octet signe
  DEFFN isample(i%,j%)=BYTE{ADD(V:instrset%(15,i%),SHL(j%,1))}
  ' Fonctions concernant la song
  DEFFN song_length=module&(101)
  DEFFN song_repeat=module&(102)
  DEFFN mod_tempo=CARD{r_mod_tempo%}
  DEFFN mod_speed=CARD{r_mod_speed%}
  ' Fonctions concernant les patterns
  DEFFN adr_patchunk(i%)=LONG{ADD(r_adr_pattern%,SHL(i%,2))}
  DEFFN lon_patchunk(i%)=LONG{ADD(FN adr_patchunk(i%),4)}
  DEFFN nbr_lines(i%)=CARD{ADD(FN adr_patchunk(i%),28)}
  DEFFN nbr_lines2(i%)=FN nbr_lines(song&(i%))
  DEFFN nbr_lines3=FN nbr_lines(song&(songpos%))
  DEFFN nbr_track(i%)=CARD{ADD(FN adr_patchunk(i%),30)}
  DEFFN nbr_track2(i%)=FN nbr_track(song&(i%))
  DEFFN nbr_track3=FN nbr_track(song&(songpos%))
  ' adresse du pattern a%, ligne b%, piste c%
  DEFFN adr_pat(a%)=ADD(FN adr_patchunk(a%),32)
  DEFFN adr_line(a%,b%)=ADD(FN adr_pat(a%),MUL(MUL(nbr_track%,5),b%))
  DEFFN adr_trk(a%,b%,c%)=ADD(FN adr_line(a%,b%),MUL(c%,5))
  ' adresse du pattern de la position a%, ligne b%, piste c%
  DEFFN adr_spat(a%)=FN adr_pat(song&(a%))
  DEFFN adr_sline(a%,b%)=FN adr_line(song&(a%),b%)
  DEFFN adr_strk(a%,b%,c%)=FN adr_trk(song&(a%),b%,c%)
  ' Fonctions concernant le buffer de sample
  DEFFN adr_buffer=ADD(FN adrsamchk(255),FN lonsamchk(255)) AND -2      ! Adresse de debut du buffer
  DEFFN lon_buffer=SUB(FN zone_end,FN adr_buffer) AND -2                ! Longueur du buffer
  ' Divers
  DEFFN zone_free=FN lon_buffer         ! Memoire libre pour les patterns, enveloppes et samples
  DEFFN zone_free2=SUB(FN zone_end,ADD(FN zone_start,80000))    ! Memoire restante quand le module est minimum (environ)
  DEFFN freq2note(f)=ROUND(LOG(f/440)*12/LOG(2)+69)     ! Conversion frequence -> note (codage MIDI)
  DEFFN note2freq(n)=440*2^((n-69)/12)                  ! Conversion note -> frequence
RETURN
PROCEDURE change_resolution
  ' Passage en resolution 80 colonnes 16 couleurs
  ' ---------------------------------------------
  LOCAL a%,b%,c%,i%,mon%,flag!,a$
  oldscreenadr%=XBIOS(2)
  oldscreenmode%=XBIOS(88,-1)
  mon%=XBIOS(&H59)
  SELECT mon%
  CASE 0        ! Monochrome
    SHOWM
    ALERT 3,"GRAOUMF TRACKER|don't work on|monochrome screen",1,"Fuck!|Chier...|Ahh??",a%
    HIDEM
    GOSUB br
  CASE 2        ! VGA
    IF grmode_overscan%=-1                      !
      grmode_overscan%=0
    ENDIF
  CASE 3        ! TV
    ALERT 2,"GRAOUMF TRACKER :|Overscan ???",1,"Yes|Dnt know|No",a%
    IF a%=3 OR (a%=2 AND RND>0.5)
      grmode_overscan%=0
    ENDIF
  ENDSELECT
  '
  ' Enleve les XBRA genants
  '
  ~FN vire_xbra(&HB4,CVL("ACCx"),&HFFFFFF00,TRUE)       ! Accent 1, 2 et 3 du Feroce Lapin
  ~FN vire_xbra(&H70,CVL("NVDI"),-1,TRUE)               ! NVDI: VBL interrupt
  ~FN vire_xbra(&H84,CVL("NVDI"),-1,TRUE)               ! NVDI: GEMDOS
  ~FN vire_xbra(&H88,CVL("NVDI"),-1,TRUE)               ! NVDI: AES/VDI
  ~FN vire_xbra(&HB4,CVL("NVDI"),-1,TRUE)               ! NVDI: BIOS
  ~FN vire_xbra(&HB8,CVL("NVDI"),-1,TRUE)               ! NVDI: XBIOS
  flag_falcon_screen!=FN vire_xbra(&HB8,CVL("‰FSC"),-1,FALSE)   ! Teste seulement Falcon Screen
  '
  GOSUB sauve_palette                           ! Sauve la palette
  ON BREAK GOSUB br
  '
  ' Calcule le nouveau mode ecran
  '
  ' 4 plans, 80 colonnes, overscan
  newscreenmode%=oldscreenmode%
  IF grmode_overscan%=0
    newscreenmode%=newscreenmode% AND (NOT &H40)
  ELSE IF grmode_overscan%=1
    newscreenmode%=newscreenmode% OR &H40
  ENDIF
  '
  IF grmode_80colonnes%=0
    newscreenmode%=newscreenmode% AND (NOT &H8)
  ELSE IF grmode_80colonnes%=1
    newscreenmode%=newscreenmode% OR &H8
  ENDIF
  '
  IF grmode_puissance_plans%<>-1
    newscreenmode%=(newscreenmode% AND (NOT &H7)) OR grmode_puissance_plans%
  ENDIF
  '
  IF grmode_entrelace%=0
    IF mon%=2                                   ! VGA
      newscreenmode%=newscreenmode% OR &H100
    ELSE                                        ! RVB/TV
      newscreenmode%=newscreenmode% AND (NOT &H100)
    ENDIF
  ELSE IF grmode_entrelace%=1
    IF mon%=2                                   ! VGA
      newscreenmode%=newscreenmode% AND (NOT &H100)
    ELSE                                        ! RVB/TV
      newscreenmode%=newscreenmode% OR &H100
    ENDIF
  ENDIF
  '
  IF flag_falcon_screen!                        ! Sinon la taille de l'ecran est erronnee
    ~XBIOS(88,newscreenmode%)
  ENDIF
  screensize%=XBIOS(91,newscreenmode%)
  DIM screen%(ADD(SHR(screensize%,2),1000))     ! Memoire de l'ecran (+4000 par sñrete)
  adrlogscr%=ADD(V:screen%(0),255) AND -256     ! Ecran logique a 256 pres
  adrphyscr%=adrlogscr%                         ! Ecran physique
  ~XBIOS(5,L:adrlogscr%,L:adrphyscr%,3,newscreenmode%)
  HIDEM
  a$=MKL$(&H48E77FFE)+MKL$(&HA0002008)+MKL$(&H4CDF7FFE)+MKI$(&H4E75)
  a%=V:a$
  b%=C:a%(0)                                    ! b% = adresse des variables line A
  scr_larg%=DPEEK(SUB(b%,12))                   ! Largeur de l'ecran en pixels
  scr_haut%=DPEEK(SUB(b%,4))                    ! Hauteur de l'ecran en pixels
  IF scr_larg%<640 OR scr_haut%<200             ! Largeur et hauteur minimum
    SHOWM
    ALERT 3,"Resolution insuffisante|640x200 16 couleurs|minimum!",1,"Ah bon|Tant pis",a%
    HIDEM
    GOSUB br
  ENDIF
  scr_ncol%=SHR(scr_larg%,3)                    ! ...et en colonnes de caracteres
  GOSUB chg_type_affpiste(type_affpiste%)       ! Nombre de pistes affichables
  haut_lig%=MIN(DIV(SUB(scr_haut%,180),6) OR 1,haut_lig%)       ! Nombre de lignes de pattern affichees
  GOSUB nouvelle_palette(color_pal$)
RETURN
PROCEDURE charge_g_routines
  ' Charge les routines graphiques (et autres routines)
  ' ---------------------------------------------------
  LOCAL a%
  DIM g_routines%(12288)         ! 48 Ko environ
  BLOAD npath_prog$+nfile_p1$,V:g_routines%(0)
  a%=ADD(V:g_routines%(0),28)
  g_relocation%=a%
  g_fabrique_fonte_ombr%=ADD(a%,4)
  g_cadre_centre%=ADD(a%,8)
  g_dessine_cadre_int%=ADD(a%,12)
  g_dessine_cadre_ext%=ADD(a%,16)
  g_affchaine_trans%=ADD(a%,20)
  g_affchaine_trans_ombr%=ADD(a%,24)
  g_affchaine_notrans%=ADD(a%,28)
  g_affcar8x6%=ADD(a%,32)
  g_affcar8x6_dec%=ADD(a%,36)
  g_affcar8x6_ombr%=ADD(a%,40)
  g_affcar8x6_ombr_dec%=ADD(a%,44)
  g_affcar8x6nt_ombr%=ADD(a%,48)
  g_affiche_pattern%=ADD(a%,52)
  g_affiche_sample%=ADD(a%,56)
  g_convert_nt_2_gtk%=ADD(a%,60)
  g_convert_669_2_gtk%=ADD(a%,64)
  g_convert_mtmv_2_gtk%=ADD(a%,68)
  g_signe_sample%=ADD(a%,72)
  g_stereo_2_mono_one%=ADD(a%,76)
  g_stereo_2_mono_ave%=ADD(a%,80)
  g_convert_mmd1_2_gtk%=ADD(a%,84)
  g_teste_icones%=ADD(a%,88)
  g_convert_s3m_2_gtk%=ADD(a%,92)
  g_intel_16_bits%=ADD(a%,96)
  g_convert_ult_2_gtk%=ADD(a%,100)
  g_convert_gtk_2_gtk_vol%=ADD(a%,104)
  g_clear_note_block%=ADD(a%,108)
  g_paste_note_block%=ADD(a%,112)
  g_atomic_35_unpack%=ADD(a%,116)
  g_swap_note_block%=ADD(a%,120)
  g_transpose_note_block%=ADD(a%,124)
  g_packice_21_unpack%=ADD(a%,128)
  g_invert_memory%=ADD(a%,132)
  g_affiche_marqueur_sample%=ADD(a%,136)
  g_efface_marqueur_sample%=ADD(a%,140)
  g_copy_sample_8_2_16%=ADD(a%,144)
  g_copy_sample_16_2_8%=ADD(a%,148)
  g_convert_gtk_2_nt%=ADD(a%,152)
  g_cherche_volume_sample%=ADD(a%,156)
  g_change_volume_sample%=ADD(a%,160)
  g_mixage_sample%=ADD(a%,164)
  g_affiche_vumetre%=ADD(a%,168)
  g_start_sample_recording%=ADD(a%,172)
  g_cherche_volume_buffer_stereo%=ADD(a%,176)
  g_change_sample_frequency%=ADD(a%,180)
  g_trans_fourier%=ADD(a%,184)
  g_fx_delay%=ADD(a%,188)
  g_convert_dtm_2_gtk%=ADD(a%,192)
  g_dtm_next_chunk%=ADD(a%,196)
  g_convert_gtk_2_s3m%=ADD(a%,200)
  g_convert_ft2_2_gtk%=ADD(a%,204)
  g_absolu_2_delta%=ADD(a%,208)
  g_delta_2_absolu%=ADD(a%,212)
  g_bmove%=ADD(a%,216)
  g_fx_stereo_flanger%=ADD(a%,220)
  g_packice_24_unpack%=ADD(a%,224)
  g_reverberation%=ADD(a%,228)
  g_grise_surface%=ADD(a%,232)
  g_convert_stereo16%=ADD(a%,236)
  g_start_song_recording%=ADD(a%,240)
  g_stop_song_recording%=ADD(a%,244)
  g_fx_compression%=ADD(a%,248)
  g_affiche_image_presentation%=ADD(a%,252)
  a%=V:g_routines%(0)
  g_adrecr%=C:g_relocation%(L:a%)               ! Reloge la routine
  g_linewidth%=ADD(g_adrecr%,4)
  g_flag_sample_rec%=ADD(g_adrecr%,6)
  g_flag_sample_rec2%=ADD(g_adrecr%,8)
  g_adr_record_inf%=LONG{ADD(g_adrecr%,10)}     ! C'est directement l'adresse des infos de digit
  g_rec_sam_buffer%=LONG{ADD(g_adrecr%,14)}     ! C'est directement l'adresse du buffer 1 de digit
  g_sngrec_paramadr%=ADD(g_adrecr%,26)          ! Adresse des parametres de Song-2-Disk (DUMTRACK.PGT)
  LPOKE g_adrecr%,adrlogscr%
  DPOKE g_linewidth%,SHR(scr_larg%,1)
  ~C:g_fabrique_fonte_ombr%(0)                  ! Fabrique la fonte ombree
RETURN
PROCEDURE charge_r_routines
  LOCAL a$,a%,b%,i%
  DIM module&(103)                              ! Le debut du module
  DIM zone%(SHR(place_totale%,2))               ! Les patterns, enveloppes et samples
  DIM song&(255)                                ! La song
  DIM instrset%(78,255)                         ! 256 * 316 octets pour les instruments
  DIM r_mod%(80000)                             ! 320 Ko pour la routine de replay
  DIM pattern_bidon%(20500)                     ! 2 * (32 + 64 * 32 * 5) : Patterns 256 et 257
  DIM module_bidon%(52)
  DIM song_bidon%(127)
  ARRAYFILL song_bidon%(),&H1010101
  song_bidon%(0)=&H1000101
  a$="GTK"+CHR$(gtk_file_vnum%)+SPACE$(192)+MKI$(255)+MKI$(nbr_lines%)+MKI$(nbr_track%)+MKI$(2)+MKI$(1)
  BMOVE V:a$,V:module_bidon%(0),208
  BLOAD npath_prog$+nfile_p2$,V:r_mod%(0)
  a%=V:r_mod%(0)
  b%=ADD(a%,28)
  rr_player_on%=ADD(b%,4)                       ! Routine d'activation du player
  rr_boucle_sample%=ADD(b%,8)                   ! Routine de bouclage d'un instrument
  rr_play_one_sample%=ADD(b%,12)                ! Routine de replay d'un sample sur une voie
  rr_play_one_note%=ADD(b%,16)                  ! Routine de replay d'une note sur une voie
  a%=C:b%(L:a%)                                 ! On reloge
  r_itl%=DPEEK(a%)                              ! Taille des informations concernant 1 voie
  r_nbrvoies%=LPEEK(ADD(a%,2))
  r_master_vol%=LPEEK(ADD(a%,6))
  r_adr_sample%=LPEEK(ADD(a%,10))
  r_adr_module%=LPEEK(ADD(a%,14))
  r_adr_instrset%=LPEEK(ADD(a%,18))
  r_adr_song%=LPEEK(ADD(a%,22))
  r_adr_pattern%=LPEEK(ADD(a%,26))
  r_mod_nbrtrack%=LPEEK(ADD(a%,30))
  r_mod_songlen%=LPEEK(ADD(a%,38))
  r_mod_songrep%=LPEEK(ADD(a%,42))
  r_mod_songpos%=LPEEK(ADD(a%,46))
  r_mod_numpat%=LPEEK(ADD(a%,50))
  r_mod_linepos%=LPEEK(ADD(a%,54))
  r_mod_speed%=LPEEK(ADD(a%,58))
  r_mod_nbrvbl%=LPEEK(ADD(a%,62))
  r_info_track%=LPEEK(ADD(a%,66))
  r_repeatbuffer%=LPEEK(ADD(a%,70))
  r_flag_stop_voices%=LPEEK(ADD(a%,74))
  ' r_adrlodname%=LPEEK(ADD(a%,78))
  r_flag_the_end%=LPEEK(ADD(a%,82))
  r_onoff_t%=LPEEK(ADD(a%,86))
  r_nbits_t%=LPEEK(ADD(a%,90))
  r_fech_t%=LPEEK(ADD(a%,94))
  r_bal_t%=LPEEK(ADD(a%,98))
  r_flag_mt_display%=LPEEK(ADD(a%,102))
  r_vblsize%=LPEEK(ADD(a%,106))
  r_mod_patrep%=LPEEK(ADD(a%,110))
  r_vblnumber%=LPEEK(ADD(a%,114))
  r_adr_replay_frequency%=LONG{ADD(a%,118)}
  r_adr_evol%=LONG{ADD(a%,122)}
  r_adr_eton%=LONG{ADD(a%,126)}
  r_adr_epan%=LONG{ADD(a%,130)}
  r_songrecord_state%=LONG{ADD(a%,134)}
  r_songrecord_routine%=LONG{ADD(a%,138)}
  r_mod_tempo%=LONG{ADD(a%,142)}
  r_interpol_t%=LONG{ADD(a%,146)}
  r_adr_adr_inter%=LONG{ADD(a%,150)}
  r_current_play_mode%=LONG{ADD(a%,154)}
  r_current_edit_mode%=LONG{ADD(a%,158)}
  r_midi_in_gfa_playline%=LONG{ADD(a%,162)}
  r_midi_instr_map%=LONG{ADD(a%,166)}
  r_midi_track_state%=LONG{ADD(a%,170)}
  r_midi_ts_next%=LONG{ADD(a%,174)}
  r_new_note_buffer%=LONG{ADD(a%,178)}
  r_midi_in_noteoff_flag%=LONG{ADD(a%,182)}
  r_midi_in_velo_flag%=LONG{ADD(a%,186)}
  ' Initialisation du player
  garbage%=0
  GOSUB clear_patterns
  garbage%=1
  GOSUB clear_instr
  garbage%=2
  GOSUB clear_samples2
  garbage%=3
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  LPOKE r_adr_module%,V:module_bidon%(0)
  LPOKE r_adr_song%,V:song_bidon%(0)
  LPOKE r_adr_instrset%,V:instrset%(0,0)
  DPOKE r_flag_mt_display%,0
  ~C:rr_player_on%(W:1)                 ! Player active (mais ne joue rien)
RETURN
PROCEDURE teste_enregistrement
  LOCAL a%,b%,a$,c$,i%
  SHOWM
  GOSUB bee(TRUE)
  mes_registred$=treg_str1$
  IF FN exist(npath_prog$+treg_str2$)
    OPEN "i",#0,npath_prog$+treg_str2$
    IF LOF(#0)=1032
      c$=STRING$(1032,0)
      BGET #0,V:c$,1032
      a%=0                              ! Teste la somme de controle
      b%=1
      FOR i%=0 TO 1027
        a%=ADD(a%,MUL(b%,BYTE{ADD(V:c$,i%)} XOR 255))
        INC b%
      NEXT i%
      IF a%=LONG{ADD(V:c$,1028)}
        a%=&H5BA3
        a$=""
        FOR i%=0 TO 510 STEP 2
          b%=CARD{ADD(V:c$,i%)}
          a$=a$+MKI$(b% XOR a%)
          a%=SUB(a%,b%) AND &HFFFF
        NEXT i%
        IF a$=MID$(c$,517,512)
          flag_registered!=TRUE
          a%=ADD(INSTR(c$,treg_str3$),13)
          b%=INSTR(RIGHT$(c$,SUCC(SUB(LEN(c$),a%))),","+CHR$(13))
          mes_registred$=treg_str4$+MID$(c$,a%,PRED(b%))
        ELSE
          GOTO erreur_user.reg
        ENDIF
      ELSE
        GOTO erreur_user.reg
      ENDIF
    ELSE
    erreur_user.reg:
      mes_registred$=treg_str5$
    ENDIF
    CLOSE #0
  ENDIF
  GOSUB bee(FALSE)
RETURN
PROCEDURE sauve_palette
  LOCAL i%
  oldpalette$=""
  FOR i%=&HFFFF9800 TO &HFFFF983C STEP 4
    oldpalette$=oldpalette$+MKL$(LPEEK(i%))
  NEXT i%
RETURN
PROCEDURE nouvelle_palette(pal$)
  LOCAL a%,b%,c%
  FOR a%=0 TO 15
    ' Palette Falcon
    b%=SHL(VAL("&"+MID$(pal$,ADD(MUL(a%,3),3),1)),4)
    ADD b%,SHL(VAL("&"+MID$(pal$,ADD(MUL(a%,3),2),1)),20)
    ADD b%,SHL(VAL("&"+MID$(pal$,SUCC(MUL(a%,3)),1)),28)
    SLPOKE ADD(&HFFFF9800,SHL(a%,2)),b%
    ' Palette ST
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),3),1))
    b%=ADD(SHR(c%,1),SHL(c% AND 1,3))
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),2),1))
    ADD b%,SHL(ADD(SHR(c%,1),SHL(c% AND 1,3)),4)
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),1),1))
    ADD b%,SHL(ADD(SHR(c%,1),SHL(c% AND 1,3)),8)
    SDPOKE ADD(&HFFFF8240,SHL(a%,1)),b%
  NEXT a%
RETURN
PROCEDURE restaure_palette
  LOCAL iiiii%
  FOR iiiii%=0 TO &H3C STEP 4
    SLPOKE ADD(iiiii%,&HFFFF9800),CVL(MID$(oldpalette$,SUCC(iiiii%),4))
  NEXT iiiii%
RETURN
'
'
' Affichages de base
' ------------------
PROCEDURE resync_tv_screen
  LOCAL a%
  a%=GEMDOS(7) AND 255
  SELECT a%
  CASE "1"                                  ! Normal non entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H160
    SDPOKE &HFF8286,&HA7
    SDPOKE &HFF8288,&H70
    SDPOKE &HFF828A,&H120
    SDPOKE &HFF828C,&H1B4
    SDPOKE &HFF82A2,&H20D
    SDPOKE &HFF82A4,&H201
    SDPOKE &HFF82A6,&H32
    SDPOKE &HFF82A8,&H4D
    SDPOKE &HFF82AA,&H1DD
    SDPOKE &HFF82AC,&H207
  CASE "2"                                  ! Normal entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H160
    SDPOKE &HFF8286,&HA7
    SDPOKE &HFF8288,&H70
    SDPOKE &HFF828A,&H120
    SDPOKE &HFF828C,&H1B4
    SDPOKE &HFF82A2,&H20C
    SDPOKE &HFF82A4,&H201
    SDPOKE &HFF82A6,&H32
    SDPOKE &HFF82A8,&H4C
    SDPOKE &HFF82AA,&H1DC
    SDPOKE &HFF82AC,&H207
  CASE "4"                                  ! Overscan non entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H180
    SDPOKE &HFF8286,&H7F
    SDPOKE &HFF8288,&H2D
    SDPOKE &HFF828A,&H15D
    SDPOKE &HFF828C,&H1A1
    SDPOKE &HFF82A2,&H20D
    SDPOKE &HFF82A4,&H207
    SDPOKE &HFF82A6,&H25
    SDPOKE &HFF82A8,&H25
    SDPOKE &HFF82AA,&H205
    SDPOKE &HFF82AC,&H207
  CASE "5"                                  ! Overscan entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H180
    SDPOKE &HFF8286,&H7F
    SDPOKE &HFF8288,&H2D
    SDPOKE &HFF828A,&H15D
    SDPOKE &HFF828C,&H1A1
    SDPOKE &HFF82A2,&H20C
    SDPOKE &HFF82A4,&H207
    SDPOKE &HFF82A6,&H25
    SDPOKE &HFF82A8,&H24
    SDPOKE &HFF82AA,&H204
    SDPOKE &HFF82AC,&H207
  ENDSELECT
RETURN
PROCEDURE cadre_int(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_int%(L:iiii%)
RETURN
PROCEDURE cadre_ext(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_ext%(L:iiii%)
RETURN
PROCEDURE cadre_o_int(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  GOSUB cadre_int(ADD(aaaa%,1),ADD(bbbb%,4),MAX(MIN(cccc%,SUB(SUB(scr_ncol%,aaaa%),2)),0),MAX(MIN(dddd%,SUB(SUB(scr_haut%,bbbb%),2)),0),0,0,0,0)
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_int%(L:iiii%)
RETURN
PROCEDURE cadre_o_ext(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  GOSUB cadre_ext(ADD(aaaa%,1),ADD(bbbb%,4),MAX(MIN(cccc%,SUB(SUB(scr_ncol%,aaaa%),2)),0),MAX(MIN(dddd%,SUB(SUB(scr_haut%,bbbb%),2)),0),0,0,0,0)
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_ext%(L:iiii%)
RETURN
PROCEDURE cadre_texte(aaaa$,xxxx%,yyyy%,llll%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte2(aaaa$,xxxx%,yyyy%,llll%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(8)+CHR$(10)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte3(aaaa$,xxxx%,yyyy%,llll%,hhhh%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(9)+CHR$(9)+CHR$(8)+CHR$(10)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte_b(aaaa$,xxxx%,yyyy%,llll%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte2_b(aaaa$,xxxx%,yyyy%,llll%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(12)+CHR$(14)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte3_b(aaaa$,xxxx%,yyyy%,llll%,hhhh%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(13)+CHR$(13)+CHR$(12)+CHR$(14)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE grise_surface(xxxx%,yyyy%,llll%,hhhh%)
  ~C:g_grise_surface%(W:xxxx%,W:yyyy%,W:llll%,W:hhhh%)
RETURN
PROCEDURE grise_icone(nnn%,ttt%,xxxd%,yyyd%)
  GOSUB grise_surface(ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%))
RETURN
PROCEDURE affchaine_notrans(aaaa$,xxxx%,yyyy%,cccc%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_notrans%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%)
  ENDIF
RETURN
PROCEDURE affchaine_trans(aaaa$,xxxx%,yyyy%,cccc%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_trans%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%)
  ENDIF
RETURN
PROCEDURE affchaine_trans_ombr(aaaa$,xxxx%,yyyy%,cccc%,cccc2%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_trans_ombr%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%,W:cccc2%)
  ENDIF
RETURN
PROCEDURE affchaine_tronque(aaa$,xxx%,yyy%,ccc%,lll%)
  IF LEN(aaa$)>lll%
    aaa$=LEFT$(aaa$,PRED(lll%))+CHR$(8)
  ENDIF
  GOSUB affchaine_notrans(aaa$,xxx%,yyy%,ccc%)
RETURN
PROCEDURE affiche_icone(nnn%,ttt%,xxxd%,yyyd%,ccc%)
  GOSUB cadre_texte3(divbn$(nnn%,ttt%),ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%),ccc%)
RETURN
PROCEDURE affiche_icone_b(nnn%,ttt%,xxxd%,yyyd%,ccc%)
  GOSUB cadre_texte3_b(divbn$(nnn%,ttt%),ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%),ccc%)
RETURN
PROCEDURE affiche_bloc_icones(dd%,nn%,tt%,xxd%,yyd%)
  LOCAL ii%
  FOR ii%=dd% TO ADD(dd%,PRED(nn%))
    GOSUB affiche_icone(ii%,tt%,xxd%,yyd%,0)
  NEXT ii%
RETURN
PROCEDURE affiche_bloc_icones_b(dd%,nn%,tt%,xxd%,yyd%)
  LOCAL ii%
  FOR ii%=dd% TO ADD(dd%,PRED(nn%))
    GOSUB affiche_icone_b(ii%,tt%,xxd%,yyd%,0)
  NEXT ii%
RETURN
PROCEDURE affiche_pattern(pat%,lig%,pre%)
  LOCAL a%,b%,xm%,ym%,km%
  a%=V:para_affiche_pattern$
  BMOVE V:preset&(0,pre%),ADD(a%,8),64
  CARD{ADD(a%,2)}=FN nbr_lines(pat%)
  CARD{ADD(a%,4)}=MIN(nbr_colonnes%(pre%),nbr_col%)
  b%=FN adr_pat(pat%)
  MOUSE xm%,ym%,km%
  IF xm%>23 AND ym%>153 AND ym%<ADD(170,MUL(haut_lig%,6))
    HIDEM
  ELSE
    SHOWM
  ENDIF
  ~C:g_affiche_pattern%(W:lig%,L:a%,L:b%,L:adr_af_pat%,W:curs_col%,W:curs_x%)
  SHOWM
RETURN
PROCEDURE affiche_c_pattern
  LOCAL a%,b%,xm%,ym%,km%
  a%=V:para_affiche_pattern$
  BMOVE V:preset&(0,n_preset%),ADD(a%,8),64
  CARD{ADD(a%,2)}=FN nbr_lines2(songpos%)
  CARD{ADD(a%,4)}=MIN(nbr_colonnes%(n_preset%),nbr_col%)
  b%=FN adr_pat(song&(songpos%))
  MOUSE xm%,ym%,km%
  IF xm%>23 AND ym%>153 AND ym%<ADD(170,MUL(haut_lig%,6))
    HIDEM
  ELSE
    SHOWM
  ENDIF
  ~C:g_affiche_pattern%(W:posligne%,L:a%,L:b%,L:adr_af_pat%,W:curs_col%,W:curs_x%)
  SHOWM
RETURN
'
' Affichages divers
' -----------------
PROCEDURE affiche_info_sample
  LOCAL a%
  IF NOT se.sample_editor_flag!
    HIDEM
    GOSUB affchaine_notrans(" "+HEX$(instr%,2),ADD(divbi&(0,12,16),11),ADD(divbi&(1,12,16),2),1)
    GOSUB affchaine_notrans(" "+HEX$(sample%,2),ADD(divbi&(0,15,16),11),ADD(divbi&(1,15,16),2),1)
    GOSUB affchaine_notrans(FN instrname$(instr%),ADD(divbi&(0,22,16),9),ADD(divbi&(1,22,16),2),1)
  ENDIF
  IF ss_menu%=3
    GOSUB affiche_icones_instrb
  ELSE IF ss_menu%=4
    GOSUB affiche_icones_sampleb
  ENDIF
RETURN
PROCEDURE affiche_info_song
  LOCAL a$
  IF NOT se.sample_editor_flag!
    HIDEM
    GOSUB affchaine_notrans(" "+HEX$(songpos%,2),ADD(divbi&(0,0,16),11),ADD(divbi&(1,0,16),2),1)
    GOSUB affchaine_notrans(" "+HEX$(song&(songpos%),2),ADD(divbi&(0,3,16),11),ADD(divbi&(1,3,16),2),1)
    IF module&(101)<256
      GOSUB affchaine_notrans(" "+HEX$(module&(101),2),ADD(divbi&(0,6,16),11),ADD(divbi&(1,6,16),2),1)
    ELSE
      GOSUB affchaine_notrans(HEX$(module&(101),3),ADD(divbi&(0,6,16),11),ADD(divbi&(1,6,16),2),1)
    ENDIF
    GOSUB affchaine_notrans(" "+HEX$(module&(102),2),ADD(divbi&(0,9,16),11),ADD(divbi&(1,9,16),2),1)
    GOSUB affchaine_notrans(FN songname$,ADD(divbi&(0,21,16),9),ADD(divbi&(1,21,16),2),1)
    GOSUB affchaine_notrans(STR$(nbr_track%,2),ADD(divbi&(0,23,16),7),ADD(divbi&(1,23,16),2),1)
    GOSUB affchaine_notrans(STR$(FN nbr_lines3,3),ADD(divbi&(0,24,16),6),ADD(divbi&(1,24,16),2),1)
    posligne%=MAX(MIN(posligne%,PRED(FN nbr_lines3)),0)
    IF line_step%<0
      a$="-"+HEX$(ABS(line_step%),1)
    ELSE
      a$=HEX$(line_step%,2)
    ENDIF
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,18,16),5),ADD(divbi&(1,18,16),2),1)
    IF ss_menu%=2 AND ss_menut%=3
      GOSUB affiche_icones_toolsb3
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_info_preset
  LOCAL iii%,aaa%
  SELECT type_affpiste%
  CASE 0
    aaa%=6
  CASE 2
    aaa%=12
  DEFAULT
    aaa%=10
  ENDSELECT
  HIDEM
  GOSUB cadre_texte2(STR$(SUCC(n_preset%)),ADD(MUL(n_preset%,2),8),130,1,1)
  FOR iii%=0 TO PRED(nbr_col%)
    IF iii%<nbr_colonnes%(n_preset%)
      GOSUB affchaine_notrans(STR$(SUCC(preset&(iii%,n_preset%)),2),ADD(MUL(iii%,aaa%),6),162,1)
      IF FN track_onoff(preset&(iii%,n_preset%))<>0
        GOSUB affchaine_notrans(CHR$(6),ADD(MUL(iii%,aaa%),5),162,1)
      ELSE
        GOSUB affchaine_notrans(CHR$(5),ADD(MUL(iii%,aaa%),5),162,1)
      ENDIF
    ELSE
      GOSUB affchaine_notrans("   ",ADD(MUL(iii%,aaa%),5),162,1)
      GOSUB cadre_ext(ADD(MUL(iii%,aaa%),4),170,SUB(aaa%,2),PRED(MUL(haut_lig%,6)),0,9,8,10)
    ENDIF
  NEXT iii%
  GOSUB affiche_c_pattern
RETURN
PROCEDURE affiche_barre_info
  GOSUB cadre_int(1,140,77,7,9,9,9,9)  ! Efface ce qu'il y avait avant
  GOSUB affchaine_trans("OCT",2,142,10)
  GOSUB affchaine_trans(STR$(SUCC(octave%),1),10,142,8)
  GOSUB affchaine_trans("BLK",20,142,10)
  GOSUB affchaine_trans("/  :  -",32,142,8)
  GOSUB affchaine_trans(STR$(SUCC(bl_trk&),2),28,142,8)
  GOSUB affchaine_trans(HEX$(bl_pat&,2),34,142,8)
  GOSUB affchaine_trans(HEX$(bl_start&,2),40,142,8)
  GOSUB affchaine_trans(HEX$(bl_end&,2),46,142,8)
  GOSUB affchaine_trans("NUMPAD",58,142,10)
  IF drumpad_flag%=0
    GOSUB affchaine_trans("SAMPLES",72,142,8)
  ELSE
    GOSUB affchaine_trans("DRUMKIT",72,142,8)
  ENDIF
  GOSUB affchaine_trans("FREE       Kb",94,142,10)
  GOSUB affchaine_trans(STR$(SHR(FN zone_free,10),5),104,142,8)
RETURN
PROCEDURE aff_message(a$)
  GOSUB cadre_int(0,149,PRED(scr_ncol%),8,13,13,12,14)  ! Efface ce qu'il y avait avant
  GOSUB affchaine_trans(LEFT$(a$,MIN(LEN(a$),scr_ncol%)),2,151,12)
RETURN
PROCEDURE affiche_temps
  LOCAL a%,m$,s$
  a%=DIV(SUB(TIMER,debut_temps%),200)
  s$=STR$(a% MOD 60)
  m$=STR$(DIV(a%,60) MOD 60)
  GOSUB affchaine_notrans(STRING$(SUB(2,LEN(m$)),"0")+m$+":"+STRING$(SUB(2,LEN(s$)),"0")+s$,ADD(divbi&(0,25,16),1),ADD(divbi&(1,25,16),2),1)
RETURN
PROCEDURE aff_ps_pp_e
  HIDEM
  GOSUB affiche_icone(0,24,0,0,play%=1)
  GOSUB affiche_icone(5,24,0,0,play%=2)
  GOSUB affiche_icone(1,24,0,0,edit%)
  SHOWM
RETURN
PROCEDURE affiche_please_register
  GOSUB dialog("SHAREWARE","This is a demonstration version of|GRAOUMF TRACKER. If you like it or|if you use it frequently, please|register to get the complete version.|See documentation for more details.","Please register soon",MOUSEX,MOUSEY)
RETURN
'
' Chargements/sauvegardes/disk
' ----------------------------
PROCEDURE save_sample
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_sample$<>""
      a$=npath_sample$+nfile_sample$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE SAMPLE",0,0,PRED(scr_ncol%))
      FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING SAMPLE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_sample2
      IF erreur%=0
        GOSUB separe_nom_chemin(a$)
        nfile_sample$=nfile_$
        npath_sample$=npath_$
      ENDIF
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_sample2
  ' Fournir a$ nom du sample, sample% numero du sample
  LOCAL a%,b$,i%,j%,k%,lon%,signe%
  erreur%=0
  warning%=0
  GOSUB bee(TRUE)
  lon%=FN length(sample%)
  IF lon%>0
    OPEN "o",#0,a$
    SEEK #0,0
    IF next_sample$="*.SPL"
      signe%=128
    ELSE
      signe%=signe_sam%
    ENDIF
    IF next_sample$="*.AVR"
      ' Entete du format .AVR
      GOSUB separe_nom_chemin(a$)       ! Recupere le nom
      b$=LEFT$(nfile_$,8)
      IF INSTR(b$,".")>1
        b$=LEFT$(b$,PRED(INSTR(b$,".")))
        IF LEN(b$)<8
          b$=b$+STRING$(SUB(8,LEN(b$)),0)
        ENDIF
      ENDIF
      b$="2BIT"+b$+MKI$(0)+MKI$(SHL(FN resol(sample%),3))+MKI$(signe%=0)
      IF FN repeat(sample%)>0 OR FN replen(sample%)>2
        b$=b$+MKI$(-1)+MKI$(-1)+MKI$(&HFF00)+MKI$(FN freqech(sample%))+MKL$(DIV(lon%,FN resol(sample%)))+MKL$(DIV(FN repeat(sample%),FN resol(sample%)))+MKL$(DIV(ADD(FN repeat(sample%),FN replen(sample%)),FN resol(sample%)))
      ELSE
        b$=b$+MKI$(0)+MKI$(-1)+MKI$(&HFF00)+MKI$(FN freqech(sample%))+MKL$(DIV(lon%,FN resol(sample%)))+MKL$(0)+MKL$(0)
      ENDIF
      b$=b$+"This sample passed through GRAOUMF TRACKER (c) Laurent de Soras"
      b$=b$+STRING$(SUB(128,LEN(b$)),0)
      BPUT #0,V:b$,128
    ENDIF
    ' Sauvegarde des donnees du sample
    b$=STRING$(1024,0)  ! Buffer de signature
    i%=0
    k%=FN resol(sample%)
    REPEAT
      j%=MIN(1024,SUB(lon%,i%))
      BMOVE ADD(FN adresse(sample%),i%),V:b$,j%*(-flag_registered2!)    ! *** 2eme protection
      IF signe%<>0
        a%=V:b$
        ~C:g_signe_sample%(L:a%,L:j%,W:k%)
      ENDIF
      BPUT #0,V:b$,j%
      ADD i%,j%
    UNTIL i%=>lon%
    CLOSE #0
  ENDIF
RETURN
PROCEDURE load_sample
  LOCAL a$
  IF km%=2 AND nfile_sample$<>""
    a$=npath_sample$+nfile_sample$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD SAMPLE",0,0,PRED(scr_ncol%))
    FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING SAMPLE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB load_sample2
      IF erreur%=0
        GOSUB separe_nom_chemin(a$)
        nfile_sample$=nfile_$
        npath_sample$=npath_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  IF erreur%=1
    GOSUB dialog("FILE","Error:|Not enough memory|to load this sample!","Cancel",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE load_sample2
  ' Fournir a$ nom du sample, sample% numero du sample
  LOCAL adsam%,freq%,lonfic%,lonsam%,res%,signe%
  LOCAL buffer$
  ~FRE(0)
  GOSUB bee(TRUE)
  GOSUB chg_taille_sample(sample%,0)
  erreur%=0
  warning%=0
  res%=FN resol(sample%)
  freq%=FN freqech(sample%)
  signe%=signe_sam%
  buffer$=STRING$(128,0)
  OPEN "i",#0,a$
  lonfic%=LOF(#0)                               ! Taille du fichier
  BGET #0,V:buffer$,MIN(LOF(#0),128)
  ' Compacte ? Si, oui, cherche la vraie longueur
  IF LEFT$(buffer$,4)="ATM5"
    lonsam%=LONG{ADD(V:buffer$,4)}
  ELSE IF LEFT$(buffer$,4)="Ice!"
    lonsam%=LONG{ADD(V:buffer$,4)}
  ELSE IF LEFT$(buffer$,4)="ICE!"
    lonsam%=LONG{ADD(V:buffer$,8)}
  ELSE
    lonsam%=LOF(#0)
  ENDIF
  IF MAX(lonsam%,lonfic%)<FN zone_free          ! Assez de memoire pour charger ?
    GOSUB chg_taille_sample(sample%,SUCC(MAX(lonsam%,lonfic%)) AND -2)
    adsam%=FN adresse(sample%)
    SEEK #0,0
    BGET #0,adsam%,lonfic%
    ~C:g_atomic_35_unpack%(L:adsam%)
    ~C:g_packice_21_unpack%(L:adsam%)
    ~C:g_packice_24_unpack%(L:adsam%)
    IF LONG{adsam%}=&H32424954                  ! '2BIT' : Format AVR
      GOSUB load_sample_avr
    ELSE IF LONG{adsam%}=&H52494646             ! 'RIFF' : Format WAV
      GOSUB load_sample_wav
    ELSE                                        ! Format inconnu : donnees brutes
      GOSUB load_sample_raw
    ENDIF
  ELSE
    erreur%=1                                   ! Pas assez de memoire pour charger le fichier
  ENDIF
  CLOSE #0
  IF erreur%=0
    ~C:rr_boucle_sample%(W:sample%)
  ELSE
    GOSUB kill_sample(sample%)
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_sample_raw
  ' Besoin de : a$, freq%, res%, signe%, adsam% et lonsam% (longueur du fichier et non du sample)
  LOCAL len%
  LOCAL b$
  len%=lonsam% AND -2
  GOSUB chg_sam_balance(sample%,&HFFFF)
  GOSUB chg_sam_volume(sample%,&H100)
  GOSUB chg_sam_finetune(sample%,0)
  GOSUB chg_sam_length(sample%,len%)
  GOSUB chg_sam_repeat(sample%,0)
  GOSUB chg_sam_replen(sample%,2)
  IF len%>0
    a%=FN adresse(sample%)
    IF signe%<>0 OR next_sample$="*.SPL"
      ~C:g_signe_sample%(L:a%,L:len%,W:res%)            ! Signature
    ENDIF
  ENDIF
  GOSUB chg_taille_sample(sample%,len%)
  b$=a$
  WHILE INSTR(b$,"\")>0
    a%=INSTR(b$,"\")
    b$=RIGHT$(b$,SUB(LEN(b$),a%))
  WEND
  GOSUB chg_samplename(b$,sample%)
  ~FRE(0)
RETURN
PROCEDURE load_sample_avr
  ' Besoin de : a$, freq%, res%, signe%, adsam% et lonsam% (longueur du fichier et non du sample)
  LOCAL a%,b%,c%,len%,loop%,rep_avr%,rep2_avr%,stereo%
  LOCAL b$
  res%=MAX(MIN(SHR(CARD{ADD(adsam%,14)},3),2),1)        ! Nbr d'octets/sample
  freq%=MAX(CARD{ADD(adsam%,24)},2000)                  ! Frequence d'echantillonnage du sample
  signe%=128
  IF CARD{ADD(adsam%,16)}<>0
    signe%=0
  ENDIF
  len%=MAX(0,MUL(LONG{ADD(adsam%,&H1A)},res%) AND -2)
  rep_avr%=MUL(LONG{ADD(adsam%,&H1E)},res%) AND -2
  rep2_avr%=MUL(LONG{ADD(adsam%,&H22)},res%) AND -2
  loop%=CARD{ADD(adsam%,18)}
  stereo%=CARD{ADD(adsam%,12)}
  IF stereo%<>0                                         ! Stereo
    GOSUB dialog("STEREO","Sample stereo.|What must I load ?","Left|Right|Mix|Cancel",MOUSEX,MOUSEY)
    IF bouton%=3                                        ! Cancel
      GOTO fin_load_sample2
    ENDIF
    GOSUB bee(TRUE)
    a%=ADD(adsam%,128)
    b%=a%
    IF bouton%<2                                        ! 1 seul canal
      ADD b%,MUL(res%,bouton%)
      ~C:g_stereo_2_mono_one%(L:b%,L:a%,L:len%,W:res%)
    ELSE                                                ! Mixage des deux canaux
      ~C:g_stereo_2_mono_ave%(L:b%,L:a%,L:len%,W:res%)
    ENDIF
  ENDIF
  a%=FN adresse(sample%)
  BMOVE ADD(adsam%,128),a%,len%
  GOSUB chg_taille_sample(sample%,len%)
  a%=FN adresse(sample%)
  IF signe%<>0
    ~C:g_signe_sample%(L:a%,L:len%,W:res%)          ! Signature
  ENDIF
  rep_avr%=MAX(0,MIN(SUB(len%,2),rep_avr%))
  GOSUB chg_sam_balance(sample%,&HFFFF)
  GOSUB chg_sam_nbits(sample%,res%)
  GOSUB chg_sam_freq(sample%,freq%)
  GOSUB chg_sam_volume(sample%,&H100)
  GOSUB chg_sam_finetune(sample%,0)
  GOSUB chg_sam_length(sample%,len%)
  IF loop%=0                                          ! Non boucle
    GOSUB chg_sam_repeat(sample%,0)
    GOSUB chg_sam_replen(sample%,2)
  ELSE                                                ! Boucle
    GOSUB chg_sam_repeat(sample%,rep_avr%)
    GOSUB chg_sam_replen(sample%,MAX(SUB(rep2_avr%,rep_avr%),2))
  ENDIF
  ' Le nom
  b$=a$
  WHILE INSTR(b$,"\")>0
    a%=INSTR(b$,"\")
    b$=RIGHT$(b$,SUB(LEN(b$),a%))
  WEND
  GOSUB chg_samplename(b$,sample%)
  ~FRE(0)
RETURN
PROCEDURE load_sample_wav
  ' Besoin de : a$, freq%, res%, signe%, adsam% et lonsam% (longueur du fichier et non du sample)
  ' Ne tient pas compte de la stereo!
  LOCAL a%,len%
  LOCAL b$
  GOSUB intel_l(ADD(adsam%,24))
  GOSUB intel_l(ADD(adsam%,40))
  res%=SHR(BYTE{ADD(adsam%,34)},3)
  len%=LONG{ADD(adsam%,40)} AND -2
  freq%=LONG{ADD(adsam%,24)}
  GOSUB chg_sam_balance(sample%,&HFFFF)
  GOSUB chg_sam_nbits(sample%,res%)
  GOSUB chg_sam_freq(sample%,freq%)
  GOSUB chg_sam_volume(sample%,&H100)
  GOSUB chg_sam_finetune(sample%,0)
  GOSUB chg_sam_length(sample%,len%)
  GOSUB chg_sam_repeat(sample%,0)
  GOSUB chg_sam_replen(sample%,2)
  IF len%>0
    a%=FN adresse(sample%)
    BMOVE ADD(adsam%,44),a%,len%
    IF FN resol(sample%)=2                          ! 16 bits
      ~C:g_intel_16_bits%(L:a%,L:len%)
    ENDIF
    ~C:g_signe_sample%(L:a%,L:len%,W:res%)          ! Signature
  ENDIF
  GOSUB chg_taille_sample(sample%,len%)
  ' Le nom
  b$=a$
  WHILE INSTR(b$,"\")>0
    a%=INSTR(b$,"\")
    b$=RIGHT$(b$,SUB(LEN(b$),a%))
  WEND
  GOSUB chg_samplename(b$,sample%)
  ~FRE(0)
RETURN
PROCEDURE save_module
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_module$<>""
      a$=npath_module$+nfile_module$
    ELSE
      CLS
      IF next_module$="*.MOD"
        GOSUB cadre_texte("EXPORT MODULE .MOD",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.MOD",nfile_module$,a$
      ELSE IF next_module$="*.S3M"
        GOSUB cadre_texte("EXPORT MODULE .S3M",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.S3M",nfile_module$,a$
      ELSE IF next_module$="*.GTK"
        GOSUB cadre_texte("SAVE OLD MODULE",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.GTK",nfile_module$,a$
      ELSE
        GOSUB cadre_texte("SAVE MODULE",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.GT2",nfile_module$,a$
      ENDIF
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : BACK UP OF THE MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      IF flag_backup_modules!
        e%=FN backup_file(a$)
        IF e%<0
          GOSUB dialog("ERROR","Error during the backup of the file|"+a$,"Continue",mousx,MOUSEY)
        ENDIF
      ENDIF
      CLS
      GOSUB cadre_texte("WAITING : SAVING MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_module2
      GOSUB separe_nom_chemin(a$)
      nfile_module$=nfile_$
      npath_module$=npath_$
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
RETURN
PROCEDURE save_module2
  ' Fournir a$ nom du module
  LOCAL i%,a%
  ~FRE(0)
  erreur%=0
  warning%=0
  GOSUB bee(TRUE)
  module&(1)=ADD(&H4B00,gtk_file_vnum%)
  OPEN "o",#0,a$
  SEEK #0,0
  IF next_module$="*.MOD"
    GOSUB save_module_mod
  ELSE IF next_module$="*.S3M"
    GOSUB save_module_s3m
  ELSE IF next_module$="*.GTK"
    GOSUB save_module_gtk
  ELSE
    GOSUB save_module_gt2
  ENDIF
  CLOSE #0
RETURN
PROCEDURE save_module_gt2
  LOCAL a%,i%,j%,nbs%,nbi%
  LOCAL a$,chk$,lsam$,lins$,lenv$
  LOCAL ok!
  ~FRE(0)
  '
  ' Travail preparatoire
  '
  ' Recherche les samples utilises
  lsam$=STRING$(256,0)
  nbs%=0
  FOR i%=1 TO 255
    IF FN length(i%)>0 OR FN samplename$(i%)<>SPACE$(28)
      BYTE{ADD(V:lsam$,i%)}=1           ! Criteres: longueur > 0 ou nom defini
      INC nbs%
    ENDIF
  NEXT i%
  ' Recherche les instruments utilises
  lins$=STRING$(256,0)
  nbi%=0
  FOR i%=1 TO 255
    j%=0
    ok!=FALSE
    REPEAT
      IF (BYTE{ADD(V:lsam$,FN isample(i%,j%))}<>0 AND FN length(FN isample(i%,j%))>0) OR FN instrname$(i%)<>SPACE$(28)
        BYTE{ADD(V:lins$,i%)}=1         ! Criteres: contient au moins un sample selectionne ou nom defini
        INC nbi%
        ok!=TRUE
      ENDIF
      INC j%
    UNTIL ok! OR j%>127
  NEXT i%
  ' Recherche des enveloppes utilisees
  lenv$=STRING$(192,0)
  FOR i%=1 TO 63
    FOR j%=0 TO 2                       ! Critere : longueur d'une section > 1
      IF FN env_sectlen(i%,j%,0)>1 OR FN env_sectlen(i%,j%,1)>1
        BYTE{ADD(V:lenv$,ADD(MUL(i%,3),j%))}=1
      ENDIF
    NEXT j%
  NEXT i%
  '
  ' Chunk d'informations generales
  '
  a$=DATE$
  a%=FN mod_tempo                       ! Tempo
  chk$="GT2"+CHR$(gt2_file_vnum%)+MKL$(0)+FN songname$+FN songcomment$
  chk$=chk$+CHR$(VAL(LEFT$(a$,2)))+CHR$(VAL(MID$(a$,4,2)))+MKI$(VAL(RIGHT$(a$,4)))
  chk$=chk$+"Graoumf Tracker v"+STR$(gtk_version%/10000)        ! Nom du Tracker
  chk$=chk$+SPACE$(SUB(228,LEN(chk$)))
  chk$=chk$+MKI$(CARD{r_mod_speed%})+MKI$(a%)+MKI$(CARD{r_master_vol%})+MKI$(nbr_track%)
  FOR i%=0 TO PRED(nbr_track%)                                  ! Les balances
    chk$=chk$+MKI$(CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,i%))})
  NEXT i%
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  BPUT #0,V:chk$,LEN(chk$)
  '
  ' Chunk de configuration du tracker
  '
  IF flag_gt2cnf!
    chk$="TCN1"+MKL$(2660)+MKI$(0)+MKI$(songpos%)+MKI$(posligne%)+MKI$(n_preset%)
    chk$=chk$+MKI$(type_affpiste%)+MKI$(curs_col%)+MKI$(curs_x%)+MKI$(ADD(play%,SHL(edit%,2)))
    chk$=chk$+MKI$(octave%)+MKI$(line_step%)+MKI$(instr%)+MKI$(sample%)
    FOR i%=0 TO 31
      chk$=chk$+MKI$(nbr_colonnes%(i%))
    NEXT i%
    FOR i%=0 TO 31
      chk$=chk$+SPACE$(16)                      ! *** Faire de vrais noms
    NEXT i%
    a$=STRING$(2048,0)
    BMOVE V:preset&(0,0),V:a$,2048
    chk$=chk$+a$
    a%=0
    FOR i%=0 TO 31
      IF FN track_onoff(i%)<>0
        a%=a% OR SHL(1,i%)
      ENDIF
    NEXT i%
    chk$=chk$+MKL$(a%)
    LONG{ADD(V:chk$,4)}=LEN(chk$)
    BPUT #0,V:chk$,LEN(chk$)
  ENDIF
  '
  ' Chunk de sequence de patterns
  '
  chk$="SONG"+MKL$(ADD(FN song_length,12))+MKI$(FN song_length)+MKI$(FN song_repeat)
  FOR i%=0 TO PRED(FN song_length)
    chk$=chk$+MKI$(song&(i%))
  NEXT i%
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  BPUT #0,V:chk$,LEN(chk$)
  '
  ' Chunk d'ensemble de patterns
  '
  chk$="PATS"+MKL$(12)+MKI$(nbr_track%)+MKI$(SUCC(FN last_pat_util))
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  BPUT #0,V:chk$,LEN(chk$)
  '
  ' Chunks des patterns
  '
  FOR i%=0 TO FN last_pat_util
    a%=MAX(FN adr_patchunk(i%)*(-flag_registered2!),&H1498)     ! A cause de la 2eme protection
    BPUT #0,a%,FN lon_patchunk(i%)
  NEXT i%
  '
  ' Chunk d'ensemble d'instruments
  '
  chk$="ORCH"+MKL$(10)+MKI$(nbi%)
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  BPUT #0,V:chk$,LEN(chk$)
  '
  ' Chunks des instruments
  '
  FOR i%=1 TO 255
    IF BYTE{ADD(V:lins$,i%)}<>0
      a%=MAX(V:instrset%(0,i%)*(-flag_registered2!),&H1264)     ! A cause de la 2eme protection
      BPUT #0,a%,instrset%(1,i%)
    ENDIF
  NEXT i%
  '
  ' Chunks des samples
  '
  FOR i%=1 TO 255
    IF BYTE{ADD(V:lsam$,i%)}<>0
      a%=MAX(FN adrsamchk(i%)*(-flag_registered2!),&H1529)      ! A cause de la 2eme protection
      BPUT #0,a%,FN lonsamchk(i%)
    ENDIF
  NEXT i%
  '
  ' Chunks des enveloppes
  '
  FOR i%=1 TO 63
    FOR j%=0 TO 2
      IF BYTE{ADD(V:lenv$,ADD(MUL(i%,3),j%))}<>0
        a%=MAX(FN env_chunkadr(i%,j%)*(-flag_registered2!),&H1798)      ! A cause de la 2eme protection
        BPUT #0,a%,FN env_chunklen(i%,j%)
      ENDIF
    NEXT j%
  NEXT i%
  ~FRE(0)
RETURN
PROCEDURE save_module_gtk
  LOCAL a%,i%,j%,nblm%
  LOCAL a$
  '
  ' Le header du module
  '
  nblm%=FN nbr_lines_maxi
  a$=STRING$(206,0)
  BMOVE V:module&(0),V:a$,206
  CARD{ADD(V:a$,198)}=nblm%
  BPUT #0,V:a$,206
  '
  ' Les headers des samples
  '
  FOR j%=1 TO module&(98)
    i%=FN isample(j%,48)
    a$=FN samplename$(i%)+STRING$(14,0)+MKI$(FN autobal(i%))+MKI$(FN resol(i%))+MKI$(FN freqech(i%))+MKL$(FN length(i%))+MKL$(FN repeat(i%))+MKL$(FN replen(i%))+MKI$(FN ivolume(j%))+MKI$(FN finetune(i%))
    BPUT #0,V:a$,64
  NEXT j%
  '
  ' La song
  '
  BPUT #0,V:song&(0),512
  '
  ' Les patterns
  '
  a%=FN last_pat_util
  FOR i%=0 TO a%
    nbl%=FN nbr_lines(i%)
    a$=STRING$(MIN(MUL(MUL(nbr_track%,nblm%),5),32767),0)
    BMOVE FN adr_pat(i%),V:a$,MUL(MUL(nbr_track%,nbl%),5)
    IF nbl%<nblm%
      CARD{ADD(V:a$,SUB(MUL(MUL(nbr_track%,nbl%),5),3))}=&HD00
    ENDIF
    IF EXP(flag_registered2!)=1                 ! *** 2eme protection
      a$=STRING$(LEN(a$),0)
    ENDIF
    BPUT #0,V:a$,LEN(a$)
  NEXT i%
  '
  ' Les samples
  '
  FOR j%=1 TO module&(98)
    i%=FN isample(j%,48)
    IF FN length(i%)>0
      a%=MAX(FN adresse(i%)*(-flag_registered2!),&H1895)        ! *** 2eme protection
      BPUT #0,a%,FN length(i%)
    ENDIF
  NEXT j%
RETURN
PROCEDURE save_module_mod
  ' Sauve un module au format .MOD
  LOCAL a%,b%,c%,d%,e%,i%,i2%,j%,k%,n%,nblm%
  LOCAL a&,b&
  LOCAL flag_fast!
  LOCAL a$,lig$,sam$,sam2$
  ~FRE(0)
  nblm%=FN nbr_lines_maxi
  IF nblm%=64 AND nbr_track%<>4                 ! On doit le sauver au format FastTracker ?
    flag_fast!=TRUE
  ELSE
    flag_fast!=FALSE
  ENDIF
  BPUT #0,V:module&(2),20                       ! Le nom du module
  '
  ' Rearrange les samples pour qu'ils puissent tous tenir
  '
  sam$=STRING$(256,0)                           ! Correspondance des samples pour la conversion des patterns
  sam2$=""
  FOR i%=1 TO 31
    sam2$=sam2$+CHR$(i%)
  NEXT i%
  BMOVE V:sam2$,SUCC(V:sam$),31
  i%=32
  j%=0
  REPEAT
    WHILE FN length(FN isample(BYTE{ADD(V:sam2$,j%)},48))<>0 AND j%<31
      INC j%
    WEND
    EXIT IF j%>=31
    IF FN length(FN isample(i%,48))>0
      BYTE{ADD(V:sam$,i%)}=SUCC(j%)
      BYTE{ADD(V:sam2$,j%)}=i%
      INC j%
    ENDIF
    INC i%
  UNTIL i%>255
  '
  ' Sauve les headers de sample
  '
  FOR j%=0 TO 30
    i2%=BYTE{ADD(V:sam2$,j%)}
    i%=FN isample(i2%,48)
    a$=FN samplename$(i%)                     ! Nom du sample
    BPUT #0,V:a$,22
    c%=FN resol(i%)
    a&=MIN(SHR(DIV(FN length(i%),c%),1),&H7FFF)
    BPUT #0,V:a&,2                            ! Longueur du sample
    b&=ADD(SHL(FN finetune(i%),8) AND &HF00,SHR(FN ivolume(i2%),2) AND &H7F)
    BPUT #0,V:b&,2                            ! Finetune + Volume
    b&=MAX(MIN(SHR(DIV(FN repeat(i%),c%),1),PRED(a&)),0)
    BPUT #0,V:b&,2                            ! Reppos
    b&=MAX(MIN(SHR(DIV(FN replen(i%),c%),1),SUB(a&,b&)),1)
    BPUT #0,V:b&,2                            ! Replen
  NEXT j%
  '
  ' La song
  '
  a&=ADD(SHL(MIN(module&(101),128),8),MIN(module&(102),127))
  BPUT #0,V:a&,2                ! Songlen + Songrepeat
  a&=SHR(a&,8)
  b&=0
  a%=0
  FOR i%=0 TO 127               ! La song
    b&=MIN(song&(i%),255)
    IF i%=>a&
      b&=0
    ENDIF
    a%=MAX(a%,b&)
    BPUT #0,SUCC(V:b&),1
  NEXT i%
  IF flag_fast!                 ! Format FastTracker
    b%=CVL(LEFT$(STR$(nbr_track%)+"CHN",4))
    BPUT #0,V:b%,4
  ELSE IF nblm%<>64             ! Format MOD Digital Tracker (FAxx)
    b%=CVL("FA"+CHR$(ADD(DIV(nbr_track%,10),48))+CHR$(ADD(nbr_track% MOD 10,48)))
    BPUT #0,V:b%,4
    b%=SHL(nblm%,16)
    BPUT #0,V:b%,4
  ELSE IF nbr_track%=4          ! Format ProTracker standard
    b%=&H4D2E4B2E
    BPUT #0,V:b%,4
  ENDIF
  '
  ' Les patterns
  '
  FOR j%=0 TO a%                ! Les patterns
    n%=FN nbr_lines(j%)
    lig$=STRING$(SHL(nbr_track%,2),0)
    b%=FN adr_pat(j%)
    FOR i%=0 TO PRED(n%)
      c%=V:lig$
      d%=V:sam$
      e%=MAX(nbr_track%*(-flag_registered2!),1) ! *** 2eme protection
      ~C:g_convert_gtk_2_nt%(L:b%,L:c%,L:d%,W:e%)
      IF i%=PRED(n%) AND n%<nblm%
        CARD{ADD(V:lig$,SUB(SHL(nbr_track%,2),2))}=ADD(CARD{ADD(V:lig$,SUB(SHL(nbr_track%,2),2))} AND &HF000,&HD00)
      ENDIF
      BPUT #0,V:lig$,SHL(nbr_track%,2)
      ADD b%,MUL(nbr_track%,5)
    NEXT i%
    IF n%<nblm%
      lig$=STRING$(MUL(SHL(nbr_track%,2),SUB(nblm%,n%)),0)
      BPUT #0,V:lig$,LEN(lig$)
    ENDIF
  NEXT j%
  '
  ' Les samples
  '
  ' Penser a reechantillonner si besoin est
  lig$=STRING$(16384,0)
  FOR j%=0 TO 30                ! Les samples
    i%=FN isample(BYTE{ADD(V:sam2$,j%)},48)
    a%=MIN(DIV(FN length(i%),FN resol(i%)) AND -2,&HFFFE)
    IF a%>0
      IF FN resol(i%)=2         ! Convertit 16 bits en 8 bits
        k%=0
        REPEAT
          b%=ADD(FN adresse(i%),SHL(k%,1))
          d%=MIN(SHL(SUB(a%,k%) AND -2,1),32768)
          c%=V:lig$
          IF COS(flag_registered2!)<1           ! *** 2eme protection
            ~C:g_copy_sample_16_2_8%(L:b%,L:c%,L:d%)
          ENDIF
          BPUT #0,V:lig$,SHR(d%,1)
          ADD k%,SHR(d%,1)
        UNTIL k%>=a%
      ELSE
        b%=MAX(FN adresse(i%)*(-flag_registered2!),&H1958)      ! *** 2eme protection
        BPUT #0,b%,a%
      ENDIF
    ENDIF
  NEXT j%
  ~FRE(0)
RETURN
PROCEDURE save_module_s3m
  LOCAL a%,b%,c%,d%,e%,f%,i%,j%,nbl%,nblm%,p%,xxx1%,xxx2%,xxx3%
  LOCAL a$,b$,mod$,pp$,ps$
  ~FRE(0)
  vide$=STRING$(16,0)
  nblm%=FN nbr_lines_maxi
  xxx1%=ADD(&H60,SUCC(FN song_length) AND -2)
  xxx2%=ADD(xxx1%,SHL(FN last_spl_util2,1))
  xxx3%=ADD(xxx2%,SHL(SUCC(FN last_pat_util),1))
  p%=ADD(ADD(xxx3%,32),15) AND -16      ! Debut des donnees de pat ou spl, alignement car parapointer
  '
  ' Le header du module
  '
  a%=FN mod_tempo                               ! Tempo
  mod$=LEFT$(FN songname$,28)+MKI$(&H1A10)+MKI$(0)
  mod$=mod$+MKI$(SUCC(FN song_length) AND -2)+MKI$(FN last_spl_util2)+MKI$(SUCC(FN last_pat_util))+MKI$(0)
  mod$=mod$+"GT"+MKI$(2)+"SCRM"
  mod$=mod$+CHR$(&H40)+CHR$(CARD{r_mod_speed%})+CHR$(a%)+CHR$(&HFF)+CHR$(0)+CHR$(252)+STRING$(10,0)
  GOSUB intel_w(ADD(V:mod$,&H20))
  GOSUB intel_w(ADD(V:mod$,&H22))
  GOSUB intel_w(ADD(V:mod$,&H24))
  GOSUB intel_w(ADD(V:mod$,&H26))
  GOSUB intel_w(ADD(V:mod$,&H2A))
  ' Les channels settings
  a%=0
  b%=0
  FOR i%=0 TO 31
    IF i%<nbr_track%
      IF FN balance(i%)<&H800
        mod$=mod$+CHR$(a%)
        a%=SUCC(a%) AND 7
      ELSE
        mod$=mod$+CHR$(ADD(b%,8))
        b%=SUCC(b%) AND 7
      ENDIF
    ELSE
      mod$=mod$+CHR$(255)
    ENDIF
  NEXT i%
  ' La song
  FOR i%=0 TO PRED(FN song_length)
    mod$=mod$+CHR$(song&(i%))
  NEXT i%
  IF (FN song_length AND 1)=1
    mod$=mod$+CHR$(255)
  ENDIF
  mod$=mod$+STRING$(SUB(p%,LEN(mod$)),0)
  ' Les Pan Pos
  FOR i%=0 TO PRED(nbr_track%)
    a%=ADD(FN balance(i%),&H80)                 ! Meilleure estimation possible
    BYTE{ADD(ADD(V:mod$,xxx3%),i%)}=ADD(MIN(DIV(MUL(a%,15),&H1000),15),32)
  NEXT i%
  BPUT #0,V:mod$,p%
  '
  ' Les samples
  '
  ps$=""                        ! Liste des parapointers
  FOR j%=1 TO FN last_spl_util2
    i%=FN isample(j%,48)
    ps$=ps$+MKI$(SHR(p%,4))
    ' Le header
    a$=CHR$(1)+"SAMPLE"+HEX$(j%,2)+STRING$(5,0)+MKI$(SHR(ADD(p%,&H50),4))
    a$=a$+MKL$(FN length(i%))+MKL$(FN repeat(i%))+MKL$(ADD(FN repeat(i%),FN replen(i%)))
    a$=a$+CHR$(SHR(FN ivolume(j%),2))+CHR$(0)+CHR$(0)
    IF ADD(FN repeat(i%),FN replen(i%))<=2
      a%=0
    ELSE
      a%=1
    ENDIF
    a$=a$+CHR$(ADD(a%,SHL(PRED(FN resol(i%)),2)))
    a%=FN freqech(i%)*(2^(FN finetune(i%)/96))
    a$=a$+MKL$(a%)+STRING$(12,0)+FN samplename$(i%)+"SCRS"
    GOSUB intel_w(ADD(V:a$,&HE))
    GOSUB intel_l(ADD(V:a$,&H10))
    GOSUB intel_l(ADD(V:a$,&H14))
    GOSUB intel_l(ADD(V:a$,&H18))
    GOSUB intel_l(ADD(V:a$,&H20))
    BPUT #0,V:vide$,16
    SEEK #0,p%
    BPUT #0,V:a$,&H50
    ADD p%,&H50
    ' Donnees
    a$=STRING$(16384,0)
    a%=0
    e%=FN resol(i%)
    WHILE SUB(FN length(i%),a%)>0
      b%=ADD(FN adresse(i%),a%)
      c%=V:a$
      d%=MIN(16384,SUB(FN length(i%),a%))
      f%=d%*(-flag_registered2!)                ! *** 2eme protection
      BMOVE b%,c%,f%
      ~C:g_signe_sample%(L:c%,L:d%,W:e%)
      IF e%=2
        ~C:g_intel_16_bits%(L:c%,L:d%)
      ENDIF
      BPUT #0,V:a$,d%
      ADD a%,d%
    WEND
    p%=ADD(ADD(p%,FN length(i%)),15) AND -16
  NEXT j%
  '
  ' les patterns
  '
  a$=STRING$(16384,0)           ! Au grand maximum...
  b$=STRING$(10240,0)
  pp$=""                        ! Liste des parapointers
  FOR i%=0 TO FN last_pat_util
    nbl%=FN nbr_lines(i%)
    pp$=pp$+MKI$(SHR(p%,4))
    GOSUB clear_mem(V:b$,10240)
    BMOVE FN adr_pat(i%),V:b$,MUL(MUL(nbr_track%,MIN(64,nblm%)),5)
    IF nbl%<64
      CARD{ADD(V:b$,SUB(MUL(MUL(nbr_track%,nbl%),5),3))}=&HD00
    ENDIF
    a%=V:b$
    b%=V:a$
    c%=MAX(nbr_track%*(-flag_registered2!),1)           ! *** 2eme protection
    d%=MAX(MIN(nblm%,64)*(-flag_registered2!),1)        ! *** 2eme protection
    ~C:g_convert_gtk_2_s3m%(L:a%,L:b%,W:c%,W:d%)
    a%=CARD{V:a$}
    GOSUB intel_w(V:a$)
    BPUT #0,V:vide$,16
    SEEK #0,p%
    BPUT #0,V:a$,a%
    p%=ADD(ADD(p%,a%),15) AND -16
  NEXT i%
  '
  ' Sauvegarde des parapointers
  '
  FOR i%=0 TO SUB(LEN(pp$),2) STEP 2
    GOSUB intel_w(ADD(V:pp$,i%))
  NEXT i%
  FOR i%=0 TO SUB(LEN(ps$),2) STEP 2
    GOSUB intel_w(ADD(V:ps$,i%))
  NEXT i%
  SEEK #0,xxx1%
  BPUT #0,V:ps$,LEN(ps$)
  SEEK #0,xxx2%
  BPUT #0,V:pp$,LEN(pp$)
RETURN
PROCEDURE load_module
  LOCAL a$
  ~FRE(0)
  IF km%=2 AND nfile_module$<>""
    a$=npath_module$+nfile_module$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD MODULE",0,0,PRED(scr_ncol%))
    FILESELECT npath_module$+next_module$,nfile_module$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      ~FRE(0)
      GOSUB load_module2
      IF erreur%=0
        GOSUB separe_nom_chemin(a$)
        npath_module$=npath_$
        nfile_module$=nfile_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  SELECT erreur%
  CASE 0                                        ! Pas d'erreur, tout est OK
    IF play%=1
      GOSUB play_song(TRUE)
    ELSE IF play%=2
      GOSUB play_pattern(TRUE)
    ELSE
      GOSUB stop_voices
    ENDIF
  CASE 1
    GOSUB dialog("FILE","Error:|Not enough memory|to load this module!","Cancel",MOUSEX,MOUSEY)
  CASE 2
    GOSUB dialog("FILE","Error:|Not enough memory|to load the pattern section|of this module!","Cancel",MOUSEX,MOUSEY)
  CASE 3
    GOSUB dialog("FILE","Error:|Not enough memory|to load the sample section|of this module!","Cancel",MOUSEX,MOUSEY)
  CASE 4
    GOSUB dialog("FILE","Error:|Unknown module format, or|probably an unknown compression|type.","Cancel",MOUSEX,MOUSEY)
  ENDSELECT
RETURN
PROCEDURE load_module2
  ' a$ nom du module
  LOCAL a%,admod%,anc%,b%,c%,i%,j%,ticks%,mastervol%
  LOCAL lonmod%,place_totale2%,tempo%,translate%
  LOCAL a&
  LOCAL b$,balance$,chk$,chunk$,chknbv$,header$
  ~FRE(0)
  GOSUB bee(TRUE)
  erreur%=0
  warning%=0
  place_totale2%=place_totale%
  translate%=0                          ! Decalage du buffer au cours du chargement du module
  ticks%=6                              ! Vitesse de base
  tempo%=125                            ! Tempo BPM de base
  mastervol%=0                          ! Master
  FOR i%=0 TO 31                        ! Fixe la balance par defaut
    balance$=balance$+MKI$(MUL(SHR(SUCC(i%),1) AND 1,&HFFF))
  NEXT i%
  OPEN "i",#0,a$
  header$=STRING$(4096,0)
  SEEK #0,0
  BGET #0,V:header$,MIN(4096,LOF(#0))
  ~FRE(0)
  IF LEFT$(header$,3)="ATM"                     ! Si c'est un fichier packe (Atomic packer 3.5)
    lonmod%=LONG{ADD(V:header$,4)}              ! Longueur du module decompacte
    GOTO ld_mod2_comp_suite
  ELSE IF LEFT$(header$,4)="Ice!"               ! Si c'est un fichier packe (Ice Packer 2.1)
    lonmod%=LONG{ADD(V:header$,4)}              ! Longueur du module decompacte
    GOTO ld_mod2_comp_suite
  ELSE IF LEFT$(header$,4)="ICE!"               ! Si c'est un fichier packe (Ice Packer 2.4)
    lonmod%=LONG{ADD(V:header$,8)}              ! Longueur du module decompacte
  ld_mod2_comp_suite:
    IF lonmod%<FN zone_free2                    ! Y a la place ?
      GOSUB stop_voices
      GOSUB clear_samples
      GOSUB clear_instr
      admod%=SUB(FN zone_end,lonmod%)
      BMOVE ADD(FN adr_buffer,lonmod%),FN adr_buffer,SUB(FN lon_buffer,lonmod%)
      SEEK #0,0
      BGET #0,admod%,LOF(#0)
      IF flag_autoload!
        GOSUB aff_message("WAITING : DECRUNCHING MODULE")
      ELSE
        GOSUB cadre_texte("WAITING : DECRUNCHING MODULE",0,0,PRED(scr_ncol%))
      ENDIF
      GOSUB bee(TRUE)
      ~C:g_atomic_35_unpack%(L:admod%)
      ~C:g_packice_21_unpack%(L:admod%)
      ~C:g_packice_24_unpack%(L:admod%)
      BMOVE admod%,V:header$,4096               ! Nouveau header
      GOTO ld_module2_cv_in_mem
    ELSE
      erreur%=1
      GOTO ld_module2_fin
    ENDIF
  ELSE IF LOF(#0)<FN zone_free2
    ' On peut le charger en memoire puis le convertir apres
    GOSUB stop_voices
    GOSUB clear_samples
    GOSUB clear_instr
    lonmod%=LOF(#0)
    admod%=SUB(FN zone_end,lonmod%)
    BMOVE ADD(FN adr_buffer,lonmod%),FN adr_buffer,SUB(FN lon_buffer,lonmod%)
    SEEK #0,0
    BGET #0,admod%,lonmod%
  ld_module2_cv_in_mem:
    IF flag_autoload!
      GOSUB aff_message("WAITING : CONVERTING MODULE")
    ELSE
      GOSUB cadre_texte("WAITING : CONVERTING MODULE",0,0,PRED(scr_ncol%))
    ENDIF
    SUB place_totale2%,lonmod%
    SWAP place_totale%,place_totale2%
    GOSUB bee(TRUE)
    SHOWM
    IF LEFT$(header$,3)="GT2"
      GOSUB load_module_gt2_mem
    ELSE IF LEFT$(header$,3)="GTK"
      GOSUB load_module_gtk_mem
    ELSE
      ' Sinon ca doit encore etre un de ces p... de modules Noisetracker !!!
      chunk$="M.K.M&K&FLT4FLT6FLT8CD81M!K!RASP"
      chknbv$=MKL$(&H4040406)+MKL$(&H8080404)
      chk$=MID$(header$,&H439,4)
      a%=INSTR(chunk$,chk$)
      IF (a% AND 3)=1 OR (LEFT$(chk$,2)="FA" AND VAL(RIGHT$(chk$,2))>0) OR (RIGHT$(chk$,3)="CHN" AND VAL(LEFT$(chk$,1))>0) OR (RIGHT$(chk$,2)="CH" AND VAL(LEFT$(chk$,2))>0)
        GOSUB load_module_mod_mem
      ELSE IF LONG{V:header$}=&H4D4D4431
        ' Format OCTAmed Amiga
        GOSUB load_module_octamed_mem
      ELSE IF CARD{V:header$}=&H6966
        ' Foramt 669
        GOSUB load_module_669_mem
      ELSE IF MID$(header$,1,3)="MTM"
        ' Format MTM
        GOSUB load_module_mtm_mem
      ELSE IF MID$(header$,&H2D,4)="SCRM"
        ' Format  Scream Tracker 3
        GOSUB load_module_s3m_mem
      ELSE IF LEFT$(header$,12)="MAS_UTrack_V"
        ' Format Ultra Tracker
        GOSUB load_module_ult_mem
      ELSE IF LEFT$(header$,4)="D.T."
        ' Format Digital Tracker
        GOSUB load_module_dtm_mem
      ELSE IF LEFT$(header$,17)="Extended Module: "
        ' Format FastTracker 2
        GOSUB load_module_xm_mem
      ELSE
        ' Autre format ?
        GOTO ld_module2_disk
      ENDIF
    ENDIF
    SWAP place_totale%,place_totale2%
    BMOVE FN adr_buffer,ADD(FN adr_buffer,SUB(lonmod%,translate%)),SUB(FN lon_buffer,SUB(lonmod%,translate%))
    GOTO ld_module2_reorg
  ENDIF
ld_module2_disk:
  ' Chargement et conversion a partir du disque (lent)
  IF flag_autoload!
    GOSUB aff_message("WAITING : LOADING & CONVERTING MODULE")
  ELSE
    GOSUB cadre_texte("WAITING : LOADING & CONVERTING MODULE",0,0,PRED(scr_ncol%))
  ENDIF
  GOSUB bee(TRUE)
  IF LEFT$(header$,3)="GT2"             ! C'est bien un de nos modules ?
    GOSUB stop_voices
    GOSUB load_module_gt2
  ELSE IF LEFT$(header$,3)="GTK"        ! Ancien module ?
    GOSUB stop_voices
    GOSUB load_module_gtk
  ELSE
    ' Sinon ca doit encore etre un de ces p... de modules Noisetracker !!!
    chunk$="M.K.M&K&FLT4FLT6FLT8CD81M!K!RASP"
    chknbv$=MKL$(&H4040406)+MKL$(&H8080404)
    SEEK #0,&H438
    BGET #0,V:a%,4
    chk$=MKL$(a%)
    a%=INSTR(chunk$,chk$)
    IF (a% AND 3)=1 OR (LEFT$(chk$,2)="FA" AND VAL(RIGHT$(chk$,2))>0) OR (RIGHT$(chk$,3)="CHN" AND VAL(LEFT$(chk$,1))>0) OR (RIGHT$(chk$,2)="CH" AND VAL(LEFT$(chk$,2))>0)
      GOSUB stop_voices
      GOSUB load_module_mod
    ELSE IF LONG{V:header$}=&H4D4D4431
      ' Format OCTAmed Amiga
      GOSUB stop_voices
      GOSUB load_module_octamed
    ELSE IF CARD{V:header$}=&H6966
      ' Foramt 669
      GOSUB stop_voices
      GOSUB load_module_669
    ELSE IF MID$(header$,1,3)="MTM"
      ' Format MTM
      GOSUB stop_voices
      GOSUB load_module_mtm
    ELSE IF MID$(header$,&H2D,4)="SCRM"
      ' Format  Scream Tracker 3
      GOSUB stop_voices
      GOSUB load_module_s3m
    ELSE IF LEFT$(header$,12)="MAS_UTrack_V"
      ' Format Ultra Tracker
      GOSUB stop_voices
      GOSUB load_module_ult
    ELSE
      ' Autre format ?
      erreur%=4                 ! Format non reconnu
      GOTO ld_module2_fin
    ENDIF
  ENDIF
ld_module2_reorg:
  IF erreur%=0
    ' Reorganise un peut tout ca
    para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
    FOR i%=1 TO 255
      ~C:rr_boucle_sample%(W:i%)
    NEXT i%
    module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
    module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
    ARRAYFILL pattern_bidon%(),0
    bl_start&=0
    bl_end&=0
    bl_trk&=0
    bl_pat&=0
    IF mastervol%=0
      DPOKE r_master_vol%,MIN(DIV(&H3000,ADD(nbr_track%,4)),&H500)
    ELSE
      DPOKE r_master_vol%,mastervol%
    ENDIF
    GOSUB chg_tempo(tempo%)
    DPOKE r_mod_speed%,ticks%
    DPOKE r_mod_nbrtrack%,nbr_track%
    GOSUB set_balance(balance$)
  ENDIF
ld_module2_fin:
  GOSUB garbage_collection
  CLOSE #0
  ~FRE(0)
RETURN
PROCEDURE load_module_gtk               !!!
  ' Modules GTK
  ' header$ : 4096 octets du debut du module
ld_module_gtk_fin:
RETURN
PROCEDURE load_module_gtk_mem
  ' Conversion d'un module au format GTK (ancien format interne) deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL a%,b%,c%,i%,nvf%,pt%,nbs%,nbl%,adi$
  ~FRE(0)
  nvf%=BYTE{ADD(admod%,3)}              ! Numero de version du format
  nbl%=CARD{ADD(admod%,198)}            ! Nombre de lignes
  GOSUB new_pattern_format(CARD{ADD(admod%,200)})
  BMOVE admod%,V:module&(0),&HCE
  nbs%=module&(98)
  module&(98)=255
  pt%=ADD(admod%,&HCE)                  ! Pointe dans le fichier en memoire
  '
  ' Les headers des instruments
  '
  FOR i%=1 TO nbs%
    GOSUB chg_samplename2(pt%,28,i%)
    GOSUB chg_instrname2(pt%,28,i%)
    IF nvf%>2
      GOSUB chg_sam_balance(i%,CARD{ADD(pt%,42)})
    ELSE
      SUB pt%,16
    ENDIF
    IF nvf%>1
      GOSUB chg_sam_nbits(i%,CARD{ADD(pt%,44)})
      GOSUB chg_sam_freq(i%,CARD{ADD(pt%,46)})
    ENDIF
    GOSUB chg_sam_length(i%,LONG{ADD(pt%,48)})
    GOSUB chg_sam_repeat(i%,LONG{ADD(pt%,52)})
    GOSUB chg_sam_replen(i%,LONG{ADD(pt%,56)})
    GOSUB chg_ins_volume(i%,CARD{ADD(pt%,60)})
    GOSUB chg_sam_volume(i%,&H100)
    GOSUB chg_sam_finetune(i%,INT{ADD(pt%,62)})
    ADD pt%,64
  NEXT i%
  '
  ' La song
  '
  BMOVE pt%,V:song&(0),512
  ADD pt%,512
  a%=0
  FOR i%=0 TO PRED(module&(101))
    a%=MAX(a%,song&(i%))
  NEXT i%
  c%=MUL(MUL(SUCC(a%),MUL(nbr_track%,nbl%)),5)
  ~FRE(0)
  '
  ' Les patterns
  '
  GOSUB create_space_multipatchunk(STRING$(SUCC(a%),MKI$(nbr_track%)+MKI$(nbl%)),SUCC(a%),FALSE)
  c%=MUL(nbr_track%,nbl%)
  IF nvf%<4
    FOR i%=0 TO a%
      b%=FN adr_pat(i%)
      BMOVE pt%,b%,SHL(c%,2)
      ADD pt%,SHL(c%,2)
      ~C:g_convert_gtk_2_gtk_vol%(L:b%,L:c%)
    NEXT i%
  ELSE
    FOR i%=0 TO a%
      BMOVE pt%,FN adr_pat(i%),MUL(c%,5)
      ADD pt%,MUL(c%,5)
    NEXT i%
  ENDIF
  '
  ' Les instruments
  '
  adi$=""
  FOR i%=1 TO nbs%
    adi$=adi$+MKL$(pt%)
    ADD pt%,FN length(i%)
  NEXT i%
  FOR i%=1 TO nbs%
    GOSUB decale_sample(i%,nbs%,V:adi$)
  NEXT i%
ld_module_gtk_mem_fin:
RETURN
PROCEDURE load_module_gt2               !!!
RETURN
PROCEDURE load_module_gt2_mem
  ' Conversion d'un module au format GT2 (nouveau format interne) deja en memoire
  LOCAL a%,b%,c%,d%,e%,f%,i%,j%,finmod%,flags%,linestoadd%
  LOCAL orchchk%,patschk%,songchk%,tcn1chk%
  LOCAL adp$,ads$,adi$,ade$,map$
  ~FRE(0)
  '
  ' Recherche des adresses de tous les chunks
  '
  finmod%=ADD(admod%,lonmod%)
  a%=ADD(admod%,LONG{ADD(admod%,4)})    ! Pointe sur le 2eme chunk du module
  adp$=STRING$(1024,0)                  ! Adresses des chunks des patterns
  ads$=STRING$(1024,0)                  ! Adresses des chunks des samples
  adi$=STRING$(1024,0)                  ! Adresses des chunks des instruments
  ade$=STRING$(768,0)                   ! Adresses des chunks des enveloppes
  songchk%=0
  patschk%=0
  orchchk%=0
  tcn1chk%=0
  WHILE a%<finmod%
    SELECT LONG{a%}
    CASE "SONG"
      songchk%=a%
    CASE "TCN1"
      tcn1chk%=a%
    CASE "PATS"
      patschk%=a%
    CASE "PATD"
      LONG{ADD(V:adp$,SHL(CARD{ADD(a%,8)},2))}=a%
    CASE "ORCH"
      orchchk%=a%
    CASE "INST"
      LONG{ADD(V:adi$,SHL(CARD{ADD(a%,8)},2))}=a%
    CASE "SAMP"
      LONG{ADD(V:ads$,SHL(CARD{ADD(a%,8)},2))}=a%
    CASE "VENV"
      LONG{ADD(V:ade$,MUL(CARD{ADD(a%,8)},12))}=a%
    CASE "TENV"
      LONG{ADD(V:ade$,ADD(MUL(CARD{ADD(a%,8)},12),4))}=a%
    CASE "PENV"
      LONG{ADD(V:ade$,ADD(MUL(CARD{ADD(a%,8)},12),8))}=a%
    ENDSELECT
    ADD a%,LONG{ADD(a%,4)}              ! Chunk suivant
  WEND
  '
  ' Chargement des informations generales
  '
  GOSUB chg_songname2(ADD(admod%,8),32)
  GOSUB chg_songcomment2(ADD(admod%,40),160)
  mastervol%=CARD{ADD(admod%,232)}
  ticks%=CARD{ADD(admod%,228)}
  tempo%=CARD{ADD(admod%,230)}          ! Tempo
  BMOVE ADD(admod%,236),V:balance$,SHL(CARD{ADD(admod%,234)},1)
  '
  ' Recherche du nombre de lignes et de pistes
  '
  IF patschk%>0
    map$=""
    a%=CARD{ADD(patschk%,8)}            ! Nombre de pistes
    linestoadd%=0                       ! Nombre de lignes a ajouter au total
    FOR i%=0 TO 255
      c%=LONG{ADD(V:adp$,SHL(i%,2))}
      IF c%>0
        IF CARD{ADD(c%,26)}=0           ! Format de pattern 0 : donnees brutes
          ADD linestoadd%,SUB(CARD{ADD(c%,28)},1)
          map$=map$+MKI$(a%)+MKI$(CARD{ADD(c%,28)})
        ELSE
          map$=map$+MKI$(a%)+MKI$(1)
        ENDIF
      ELSE
        map$=map$+MKI$(a%)+MKI$(1)
      ENDIF
    NEXT i%
    GOSUB new_pattern_format(a%)
  ENDIF
  '
  ' Les configurations
  '
  IF tcn1chk%>0 AND flag_gt2cnf!
    songpos%=CARD{ADD(tcn1chk%,10)}
    posligne%=CARD{ADD(tcn1chk%,12)}
    n_preset%=CARD{ADD(tcn1chk%,14)}
    GOSUB chg_type_affpiste(CARD{ADD(tcn1chk%,16)})
    curs_col%=CARD{ADD(tcn1chk%,18)}
    curs_x%=CARD{ADD(tcn1chk%,20)}
    flags%=CARD{ADD(tcn1chk%,22)}
    play%=flags% AND 3
    edit%=SHR(flags%,2) AND 1
    octave%=CARD{ADD(tcn1chk%,24)}
    line_step%=CARD{ADD(tcn1chk%,26)}
    instr%=CARD{ADD(tcn1chk%,28)}
    sample%=CARD{ADD(tcn1chk%,30)}
    FOR i%=0 TO 31                              ! Les presets
      nbr_colonnes%(i%)=CARD{ADD(tcn1chk%,ADD(32,SHL(i%,1)))}
    NEXT i%
    ' *** Penser aux noms
    BMOVE ADD(tcn1chk%,608),V:preset&(0,0),2048
    a%=LONG{ADD(tcn1chk%,2656)}                 ! Les pistes on/off
    FOR i%=0 TO 31
      DPOKE ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,i%)),BTST(a%,i%) AND 1
    NEXT i%
  ENDIF
  '
  ' Chargement de la song
  '
  IF songchk%>0
    module&(101)=CARD{ADD(songchk%,8)}
    module&(102)=CARD{ADD(songchk%,10)}
    FOR i%=0 TO PRED(FN song_length)
      song&(i%)=CARD{ADD(ADD(songchk%,12),SHL(i%,1))}
    NEXT i%
  ENDIF
  '
  ' Chargement des patterns
  '
  IF patschk%>0
    GOSUB create_space_multipatchunk(map$,256,TRUE)
    FOR i%=0 TO 255
      a%=LONG{ADD(V:adp$,SHL(i%,2))}
      IF a%>0
        GOSUB chg_patternname2(ADD(a%,10),16,i%)
        IF CARD{ADD(a%,26)}=0           ! Format de pattern 0 : donnees brutes
          b%=CARD{ADD(a%,28)}           ! Nombre de lignes de ce pattern
          ' Ignore le nombre de voies
          ~C:g_bmove%(L:ADD(a%,32),L:FN adr_pat(i%),L:MUL(MUL(nbr_track%,b%),5))
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
  '
  ' Chargement des instruments
  '
  FOR i%=1 TO 255
    a%=LONG{ADD(V:adi$,SHL(i%,2))}
    IF a%>0
      BMOVE a%,V:instrset%(0,i%),LONG{ADD(a%,4)}
    ENDIF
  NEXT i%
  '
  ' Chargement des enveloppes
  '
  FOR i%=1 TO 63
    FOR j%=0 TO 2
      a%=LONG{ADD(V:ade$,SHL(ADD(MUL(i%,3),j%),2))}
      IF a%>0
        b%=LONG{ADD(a%,4)}              ! Taille du chunk
        c%=CARD{ADD(a%,30)}             ! Taille de la section Attack
        GOSUB chg_env_length(i%,j%,0,c%)
        GOSUB chg_env_length(i%,j%,1,SUB(SUB(b%,32),c%))
        BMOVE a%,FN env_chunkadr(i%,j%),b%
      ENDIF
    NEXT j%
  NEXT i%
  '
  ' Chargement des samples
  '
  FOR i%=1 TO 255
    a%=LONG{ADD(V:ads$,SHL(i%,2))}
    IF a%>0
      b%=LONG{ADD(a%,4)}                ! Longueur du nouveau chunk
      c%=FN adrsamchk(i%)               ! Adresse de l'ancien chunk
      d%=FN lonsamchk(i%)               ! Longueur de l'ancien chunk
      e%=ADD(c%,b%)
      j%=SUCC(i%)
      WHILE j%<256
        f%=LONG{ADD(V:ads$,SHL(j%,2))}
        EXIT IF f%<e% AND f%>0
        INC j%                          ! Cherche si des samples genent
      WEND
      IF j%<256 OR flag_keep_buffer!    ! On est oblige de faire une rotation
        ~C:g_bmove%(L:a%,L:c%,L:d%)     ! Copie ce qui tient
        GOSUB mem_rotation(ADD(c%,d%),SUB(ADD(a%,b%),ADD(c%,d%)),SUB(b%,d%))    ! et deplace le reste
        ADD translate%,SUB(b%,d%)
        IF i%<255
          FOR j%=SUCC(i%) TO 255        ! Remise a jour des chunks de sample
            GOSUB chg_sam_chunkadr(j%,ADD(FN adrsamchk(j%),SUB(b%,d%)))
            e%=LONG{ADD(V:ads$,SHL(j%,2))}
            IF e%>0 AND e%<a%
              LONG{ADD(V:ads$,SHL(j%,2))}=ADD(e%,SUB(b%,d%))
            ENDIF
          NEXT j%
        ENDIF
      ELSE
        IF i%<255
          ~C:g_bmove%(L:ADD(c%,d%),L:ADD(c%,b%),L:SUB(FN adr_buffer,ADD(c%,d%)))
        ENDIF
        ~C:g_bmove%(L:a%,L:c%,L:b%)
        IF i%<255
          FOR j%=SUCC(i%) TO 255        ! Remise a jour des chunks de sample
            GOSUB chg_sam_chunkadr(j%,ADD(FN adrsamchk(j%),SUB(b%,d%)))
          NEXT j%
        ENDIF
      ENDIF
    ENDIF
  NEXT i%
RETURN
PROCEDURE load_module_mod               !!!
  ' Modules classiques type ProTracker Amiga
  ' header$ : 4096 octets du debut du module
ld_module_mod_fin:
RETURN
PROCEDURE load_module_mod_mem
  ' Modules classiques type ProTracker Amiga, deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,i%,nbl%,nbt%
  LOCAL a&
  LOCAL flag_digital!,flag_intel!
  LOCAL chk$,chknbv$,chunk$,adi$
  ~FRE(0)
  '
  ' Trouve le bon format
  '
  flag_digital!=FALSE
  flag_intel!=FALSE
  chunk$="M.K.M&K&FLT4FLT6FLT8CD81M!K!RASP"
  chknbv$=MKL$(&H4040406)+MKL$(&H8080404)
  chk$=MID$(header$,&H439,4)
  a%=INSTR(chunk$,chk$)
  nbl%=64
  IF (a% AND 3)=1               ! Format courant
    nbt%=ASC(MID$(chknbv$,SUCC(SHR(PRED(a%),2)),1))
  ELSE IF RIGHT$(chk$,3)="CHN"  ! FastTracker
    nbt%=VAL(LEFT$(chk$,1))
  ELSE IF RIGHT$(chk$,2)="CH"   ! FastTracker
    nbt%=VAL(LEFT$(chk$,2))
  ELSE IF LEFT$(chk$,2)="FA"    ! Format Digital Tracker
    nbt%=VAL(RIGHT$(chk$,2))
    flag_digital!=TRUE
    nbl%=CARD{ADD(admod%,&H43C)}
  ENDIF
  GOSUB new_pattern_format(nbt%)
  pt%=admod%
  GOSUB chg_songname2(pt%,20)                   ! Le nom du module
  ADD pt%,20
  '
  ' Lit les entetes des instruments
  '
  FOR j%=1 TO 31
    GOSUB chg_samplename2(pt%,22,j%)
    GOSUB chg_instrname2(pt%,22,j%)
    a&=INT{ADD(pt%,22)}                 ! Longueur
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_length(j%,SHL(a& AND 65535,1))
    a&=BYTE{ADD(pt%,24)}                ! Finetune
    IF a&<8
      GOSUB chg_sam_finetune(j%,a&)
    ELSE
      GOSUB chg_sam_finetune(j%,SUB(a&,16))
    ENDIF
    a&=BYTE{ADD(pt%,25)}                ! Volume
    GOSUB chg_ins_volume(j%,SHL(a&,2))
    GOSUB chg_sam_volume(j%,&H100)
    a&=INT{ADD(pt%,26)}                 ! Repeat
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_repeat(j%,SHL(a& AND 65535,1))
    a&=INT{ADD(pt%,28)}                 ! Replen
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_replen(j%,SHL(a& AND 65535,1))
    ADD pt%,30
  NEXT j%
  '
  ' La song
  '
  module&(101)=BYTE{pt%}        ! Longueur
  a&=BYTE{SUCC(pt%)}            ! Boucle
  ADD pt%,2
  IF a&>PRED(module&(101))
    a&=0
  ENDIF
  module&(102)=a&
  a%=0                          ! Numero du dernier pattern sauve
  FOR i%=0 TO 127               ! La song
    song&(i%)=BYTE{ADD(pt%,i%)}
    a%=MAX(a%,song&(i%))
  NEXT i%
  '
  ' Chargement des patterns
  '
  GOSUB create_space_multipatchunk(STRING$(SUCC(a%),MKI$(nbt%)+MKI$(nbl%)),SUCC(a%),FALSE)
  IF flag_digital!
    pt%=ADD(admod%,&H440)       ! Les patterns (pour DT)
  ELSE
    pt%=ADD(admod%,&H43C)       ! Les patterns (modules courants)
  ENDIF
  b%=MUL(SUCC(a%),SHL(MUL(nbl%,nbr_track%),2))
  '
  ' Conversion des patterns
  '
  c%=MUL(nbl%,nbr_track%)
  FOR i%=0 TO a%
    a%=FN adr_pat(i%)
    ~C:g_bmove%(L:pt%,L:a%,L:SHL(c%,2))
    ADD pt%,SHL(c%,2)
    ~C:g_convert_nt_2_gtk%(L:a%,L:c%)
  NEXT i%
  '
  ' Les samples
  '
  adi$=""
  FOR i%=1 TO 31
    adi$=adi$+MKL$(pt%)
    ADD pt%,FN length(i%)
  NEXT i%
  FOR i%=1 TO 31
    GOSUB decale_sample(i%,31,V:adi$)
  NEXT i%
ld_module_mod_mem_fin:
RETURN
PROCEDURE load_module_octamed           !!!
  ' Chargement d'un module au format OctaMED Pro Amiga
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_octamed_mem       !!!
  ' Chargement d'un module au format OctaMED Pro Amiga deja en memoire
  LOCAL a%,asc%,b%,c%,d%,e%,flags%,flags2%,i%,instrhdr%,j%,k%,l%
  LOCAL mmd0song%,mmd0block%,mmd0exp%,nbi%,nbs%,no%,rl%,rs%,sc%,t%,type%,wf%
  LOCAL a$,adi$,b$,octstart$,samiff$,transpose$,map$
  ~FRE(0)
  '
  ' Recherche des adresses de principaux chunks
  ' et des principales informations
  '
  mmd0song%=ADD(admod%,LONG{ADD(admod%,8)})     ! Pointe sur le header de la song
  mmd0block%=ADD(admod%,LONG{ADD(admod%,16)})   ! Pointe sur les offsets des patterns
  instrhdr%=ADD(admod%,LONG{ADD(admod%,24)})
  mmd0exp%=ADD(admod%,LONG{ADD(admod%,32)})     ! Pointe sur les donnees d'expansion
  ' Recherche nombre voies/piste
  numblock%=CARD{ADD(mmd0song%,504)}            ! Nombre de patterns
  t%=1
  map$=""
  FOR i%=0 TO PRED(numblock%)
    a%=LONG{ADD(mmd0block%,SHL(i%,2))}          ! Offset du header du pattern i
    IF a%>0
      t%=MAX(t%,CARD{ADD(admod%,a%)})
      l%=SUCC(CARD{ADD(ADD(admod%,a%),2)})
      map$=map$+MKI$(1)+MKI$(l%)
    ELSE
      map$=map$+MKI$(1)+MKI$(1)
    ENDIF
  NEXT i%
  FOR i%=0 TO SHL(PRED(numblock%),2) STEP 4
    CARD{ADD(V:map$,i%)}=t%
  NEXT i%
  GOSUB new_pattern_format(t%)
  GOSUB create_space_multipatchunk(map$,numblock%,TRUE)
  flags%=BYTE{ADD(mmd0song%,767)}
  flags2%=BYTE{ADD(mmd0song%,768)}
  ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ' PRINT AT(1,5);CARD{ADD(mmd0song%,764)},SUCC(flag2% AND 31),BYTE{ADD(mmd0song%,769)}
  ' IF BTST(flags2%,5)
  '   PRINT "Ok"
  ' ENDIF
  ' ~INP(2)
  ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ' Le Tempo
  ' IF BTST(flags2%,5)
  '   tempo%=CARD{ADD(mmd0song%,764)}             ! BPM
  ' ENDIF
  ' b%=SUCC(flags2% AND 31)
  '
  ' La song
  '
  module&(101)=CARD{ADD(mmd0song%,506)}
  module&(102)=0
  FOR i%=0 TO PRED(FN song_length)
    song&(i%)=BYTE{ADD(ADD(mmd0song%,508),i%)}
  NEXT i%
  '
  ' Les patterns
  '
  transpose$=STRING$(64,35)
  FOR i%=0 TO PRED(numblock%)
    a%=LONG{ADD(mmd0block%,SHL(i%,2))}
    IF a%>0
      t%=CARD{ADD(admod%,a%)}
      l%=SUCC(CARD{ADD(admod%,ADD(a%,2))})
      IF t%>0 AND l%>0
        e%=ADD(admod%,ADD(a%,8))
        d%=SUB(nbr_track%,t%)
        b%=FN adr_pat(i%)
        c%=V:transpose$
        ~C:g_convert_mmd1_2_gtk%(L:e%,L:b%,L:c%,W:t%,W:l%,W:d%)
      ENDIF
    ENDIF
  NEXT i%
  '
  ' Les headers d'instruments
  '
  nbi%=BYTE{ADD(mmd0song%,787)}                 ! Nbr d'instruments
  nbs%=0                                        ! Nombre actuel de samples decodes
  adi$=""
  samiff$="000000 432110 221100 110000 332210 543210 654321"
  octstart$="001224364860 121212122424 001212242436 001212243636 001212242424 121212121212 121212121212"
  FOR i%=1 TO nbi%
    a%=LONG{ADD(instrhdr%,SHL(PRED(i%),2))}
    IF a%>0
      ADD a%,admod%                             ! Pointe sur le header de l'instrument
      b%=ADD(mmd0song%,MUL(PRED(i%),8))         ! Pointe sur d'autres infos sur le sample
      t%=FN sbyte(BYTE{ADD(b%,7)})              ! Transposition generale de l'instrument
      GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(b%,6)},2))
      type%=INT{ADD(a%,4)}                      ! Type de l'instrument
      SELECT type%
      CASE 0 TO 6
        ' --- Sample de 1 a 7 octaves ---
        ' -------------------------------
      ld_mmd_samples:
        no%=VAL(MID$("1532467",SUCC(type%),1))  ! Nombre d'octaves dans l'instrument
        sc%=SUCC(nbs%)                          ! Sample en cours de traitement
        asc%=ADD(a%,6)                          ! Adr spl "   "    "    "
        FOR j%=0 TO PRED(no%)
          GOSUB chg_sam_nbits(sc%,1)
          GOSUB chg_sam_volume(sc%,&H100)
          GOSUB chg_sam_freq(sc%,8363)
          GOSUB chg_sam_finetune(sc%,0)         ! 0 par defaut, mais on voit plus tard si y en a
          rs%=SHL(CARD{b%},SUCC(j%))            ! Repeat
          rl%=SHL(CARD{ADD(b%,2)},SUCC(j%))     ! Replen
          IF type%=0                            ! Un sample/instr : on prend la longueur totale
            GOSUB chg_sam_length(sc%,LONG{a%} AND -2)
          ELSE                                  ! Sinon c'est repeat+replen
            GOSUB chg_sam_length(sc%,ADD(rs%,rl%))
          ENDIF
          GOSUB chg_sam_repeat(sc%,rs%)
          GOSUB chg_sam_replen(sc%,MAX(rl%,2))
          adi$=adi$+MKL$(asc%)
          ADD asc%,ADD(rs%,rl%)
          INC sc%
        NEXT j%
        ' Transpositions et affectation des samples aux instruments
        FOR j%=0 TO 5
          c%=ADD(VAL(MID$(samiff$,ADD(SUCC(MUL(type%,7)),j%),1)),SUCC(nbs%))
          d%=ADD(SUB(VAL(MID$(octstart$,ADD(SUCC(MUL(type%,13)),SHL(j%,1)),2)),MUL(j%,12)),t%)
          FOR k%=ADD(MUL(j%,12),36) TO ADD(MUL(j%,12),47)
            GOSUB chg_ins_sample(i%,k%,c%)      ! Sample
            GOSUB chg_ins_transp(i%,k%,d%)      ! Transposition
          NEXT k%
        NEXT j%
        FOR j%=1 TO 35
          GOSUB chg_ins_sample(i%,j%,FN isample(i%,36))
          GOSUB chg_ins_transp(i%,j%,FN itransp(i%,36))
        NEXT j%
        FOR j%=108 TO 127
          GOSUB chg_ins_sample(i%,j%,FN isample(i%,107))
          GOSUB chg_ins_transp(i%,j%,FN itransp(i%,107))
        NEXT j%
        GOSUB chg_ins_sample(i%,0,0)
        GOSUB chg_ins_transp(i%,0,0)
        ADD nbs%,no%
      CASE -1
        ' ---------- Synthetic ----------
        ' -------------------------------
        ' Ne prend pour l'instant en compte que la 1ere forme d'onde
        sc%=SUCC(nbs%)
        GOSUB chg_sam_nbits(sc%,1)
        GOSUB chg_sam_volume(sc%,&H100)
        GOSUB chg_sam_freq(sc%,8363)
        GOSUB chg_sam_finetune(sc%,0)
        wf%=ADD(a%,LONG{ADD(a%,278)})
        GOSUB chg_sam_length(sc%,SHL(CARD{wf%},1))
        GOSUB chg_sam_repeat(sc%,0)
        GOSUB chg_sam_replen(sc%,SHL(CARD{wf%},1))
        adi$=adi$+MKL$(ADD(wf%,2))
        FOR j%=1 TO 127
          GOSUB chg_ins_sample(i%,j%,sc%)
          GOSUB chg_ins_transp(i%,j%,SUB(t%,24))
        NEXT j%
        GOSUB chg_ins_sample(i%,0,0)
        GOSUB chg_ins_transp(i%,0,0)
        INC nbs%
        '
        '
        '
        '
      CASE -2
        ' ----------- Hybrid ------------
        ' -------------------------------
        '
        '
        '
        '
        b%=ADD(a%,8)                            ! Seulement valable pour Rep/Replen!!!
        a%=ADD(a%,LONG{ADD(a%,278)})            ! Pointe sur un instrument classique
        type%=INT{ADD(a%,4)}                    ! Nouveau type de l'instrument
        GOTO ld_mmd_samples
      ENDSELECT
    ENDIF
  NEXT i%
  '
  ' Donnees d'expansion
  '
  IF mmd0exp%>admod%
    ' --- Finetunes ---
    a%=LONG{ADD(mmd0exp%,4)}
    b%=CARD{ADD(mmd0exp%,8)}
    c%=CARD{ADD(mmd0exp%,10)}
    IF a%>0 AND b%>0 AND c%=>4
      FOR i%=1 TO MIN(nbi%,b%)
        a$=FN ins_used_samples$(i%)
        IF LEN(a$)>0
          d%=FN sbyte(BYTE{ADD(admod%,ADD(a%,3))})
          FOR j%=0 TO SUB(LEN(a$),2) STEP 2
            GOSUB chg_sam_finetune(CARD{ADD(V:a$,j%)},d%)
          NEXT j%
        ENDIF
        ADD a%,c%                       ! Structure suivante
      NEXT i%
    ENDIF
    ' --- Noms des instruments ---
    a%=LONG{ADD(mmd0exp%,20)}           ! a% sur les noms
    b%=CARD{ADD(mmd0exp%,24)}           ! b% nbr de noms
    c%=CARD{ADD(mmd0exp%,26)}           ! c% taille d'un nom
    IF a%>0 AND b%>0 AND c%>0           ! S'il y a bien des noms
      FOR i%=1 TO MIN(nbi%,b%)
        GOSUB chg_instrname2(ADD(admod%,a%),c%,i%)
        a$=FN ins_used_samples$(i%)
        b$=SPACE$(28)
        BMOVE ADD(admod%,a%),V:b$,MIN(c%,28)
        IF LEN(a$)=2                    ! 1 seul sample
          GOSUB chg_samplename(b$,CARD{V:a$})
        ELSE IF LEN(a$)>2               ! Pluseurs samples d'octaves differents
          FOR j%=0 TO SUB(LEN(a$),2) STEP 2
            b$=LEFT$(b$,25)+"("+STR$(SUCC(SHR(j%,1)))+")"
            GOSUB chg_samplename(b$,CARD{ADD(V:a$,j%)})
          NEXT j%
        ENDIF
        ADD a%,c%                       ! Structure suivante
      NEXT i%
    ENDIF
    ' --- Nom de la chanson ---
    a%=LONG{ADD(mmd0exp%,44)}
    b%=LONG{ADD(mmd0exp%,48)}
    IF a%>0 AND b%>0
      GOSUB chg_songname2(ADD(a%,admod%),b%)
    ELSE
      GOSUB chg_songname("")
    ENDIF
  ENDIF
  '
  ' Les donnees des samples
  '
  IF nbs%>0
    FOR i%=1 TO nbs%
      GOSUB decale_sample(i%,nbs%,V:adi$)
    NEXT i%
  ENDIF
RETURN
PROCEDURE load_module_669               !!!
  ' Chargement d'un module au format 669
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_669_mem
  ' Chargement d'un module au format 669 deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,i%,j%,nbs%,nbp%,res%,sec%,tem%,brk%,os$
  ~FRE(0)
  GOSUB new_pattern_format(9)           ! 8 + 1 voies
  GOSUB chg_songname2(ADD(admod%,2),108)
  nbs%=BYTE{ADD(admod%,110)}            ! nbs% = nombre de samples
  nbp%=BYTE{ADD(admod%,111)}            ! nbp% = nombre de patterns
  res%=BYTE{ADD(admod%,112)}            ! res% = position de rebouclage
  sec%=ADD(admod%,113)
  tem%=ADD(admod%,241)
  brk%=ADD(admod%,369)
  '
  ' Les headers des instruments
  '
  IF nbs%>0
    pt%=ADD(admod%,497)
    a%=0
    b%=ADD(497,ADD(MUL(nbs%,25),MUL(nbp%,&H600)))       ! b% = offset de sample
    os$=""
    FOR i%=1 TO nbs%
      os$=os$+MKL$(ADD(b%,admod%))
      GOSUB chg_samplename2(pt%,13,i%)
      GOSUB chg_instrname2(pt%,13,i%)
      ADD pt%,13
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      ADD b%,a%
      a%=a% AND -2
      GOSUB chg_sam_length(i%,a%)
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      a%=a% AND -2
      GOSUB chg_sam_repeat(i%,a%)
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      IF a%<&HFFFF0
        a%=SUB(a%,FN replen(i%)) AND -2
      ELSE
        GOSUB chg_sam_repeat(i%,0)
        a%=2
      ENDIF
      GOSUB chg_sam_volume(i%,&H100)
      GOSUB chg_sam_replen(i%,a%)
      GOSUB chg_sam_freq(i%,&H12224)            ! 8740 Hz
    NEXT i%
  ENDIF
  '
  ' Les patterns
  '
  IF nbp%>0
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(9)+MKI$(64)),nbp%,TRUE)
    pt%=ADD(admod%,ADD(497,MUL(nbs%,25)))
    FOR i%=0 TO PRED(nbp%)
      b%=FN adr_pat(i%)
      ~C:g_convert_669_2_gtk%(L:pt%,L:b%)
      LONG{b%}=ADD(&HA800,BYTE{ADD(tem%,i%)})           ! Vitesse du pattern
      LONG{ADD(b%,MUL(BYTE{ADD(brk%,i%)},45))}=&HD00    ! Fin du pattern
      ADD pt%,&H600
    NEXT i%
  ENDIF
  '
  ' La song
  '
  FOR i%=0 TO 127
    IF BYTE{ADD(sec%,i%)}=255
      a%=i%
      i%=127
    ELSE
      song&(i%)=BYTE{ADD(sec%,i%)}
    ENDIF
  NEXT i%
  a%=MAX(1,a%)
  module&(101)=a%
  module&(102)=MIN(res%,PRED(a%))
  '
  ' Les instruments
  '
  IF nbs%>0
    FOR i%=1 TO nbs%
      b%=FN length(i%)
      IF b%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        a%=FN adresse(i%)
        ~C:g_signe_sample%(L:a%,L:b%,W:1)
      ENDIF
    NEXT i%
  ENDIF
  FOR i%=2 TO 16 STEP 2
    CARD{ADD(V:balance$,i%)}=MUL(SHR(SUB(i%,2),1) AND 1,&HFFF)
  NEXT i%
  tick%=4
  tempo%=80
  ~FRE(0)
RETURN
PROCEDURE load_module_mtm               !!!
  ' Chargement d'un module au format Multi Tracker
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_mtm_mem
  ' Chargement d'un module au format Multi Tracker deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,d%,i%,j%,k%,lon%,nbp%,nps%,nbt%,sle%,nbl%,p1%,p2%,p3%,p4%
  LOCAL os$
  ~FRE(0)
  GOSUB clear_song(TRUE)
  GOSUB chg_songname2(ADD(admod%,4),20)
  GOSUB intel_w(ADD(admod%,24))
  GOSUB intel_w(ADD(admod%,28))
  nbt%=CARD{ADD(admod%,24)}             ! Nombre de pistes sauvees
  nbp%=SUCC(BYTE{ADD(admod%,26)})       ! Nombre de patterns
  lon%=SUCC(BYTE{ADD(admod%,27)})       ! Nombre de positions
  sle%=CARD{ADD(admod%,28)}             ! Song Length Extra-comment
  nbs%=BYTE{ADD(admod%,30)}             ! Nombre de samples
  nbl%=BYTE{ADD(admod%,32)}             ! Nombre de lignes
  GOSUB new_pattern_format(BYTE{ADD(admod%,33)})
  GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(BYTE{ADD(admod%,33)})+MKI$(nbl%)),nbp%,TRUE)
  module&(101)=MAX(lon%,1)
  FOR i%=0 TO PRED(nbr_track%)          ! Regle la balance de chaque piste
    CARD{ADD(V:balance$,SHL(i%,1))}=VAL("&H"+MID$("000100200300400500600700800924A48B6CC90DB4ED8FFF",SUCC(MUL(BYTE{ADD(admod%,ADD(i%,34))},3)),3))
  NEXT i%
  p1%=ADD(66,MUL(nbs%,37))              ! Pointe sur la sequence
  p2%=ADD(ADD(p1%,128),MUL(nbt%,192))   ! Pointe sur la disposition des pistes
  p3%=ADD(p2%,MUL(nbp%,64))             ! Pointe sur l'extra-comment
  p4%=ADD(p3%,sle%)                     ! Pointe sur les samples
  '
  ' Chargement des headers des samples
  '
  IF nbs%>0
    pt%=ADD(admod%,66)
    os$=""
    a%=p4%                              ! Offset du premier sample
    FOR i%=1 TO nbs%
      GOSUB chg_samplename2(pt%,22,i%)
      GOSUB chg_instrname2(pt%,22,i%)
      GOSUB intel_l(ADD(pt%,22))
      GOSUB intel_l(ADD(pt%,26))
      GOSUB intel_l(ADD(pt%,30))
      b%=LONG{ADD(pt%,22)}
      os$=os$+MKL$(ADD(admod%,a%))
      ADD a%,b%
      b%=b% AND -2
      ADD d%,b%
      c%=MAX(MIN(LONG{ADD(pt%,26)} AND -2,SUB(b%,2)),0)
      GOSUB chg_sam_nbits(i%,SUCC(BYTE{ADD(pt%,36)} AND 1))
      GOSUB chg_sam_length(i%,b%)
      GOSUB chg_sam_repeat(i%,c%)
      GOSUB chg_sam_replen(i%,MAX(MIN(SUB(LONG{ADD(pt%,30)},c%),SUB(b%,c%)) AND -2,2))
      GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(pt%,35)},2))
      GOSUB chg_sam_volume(i%,&H100)
      b%=BYTE{ADD(pt%,36)}
      IF b%>7
        SUB b%,16
      ENDIF
      GOSUB chg_sam_finetune(i%,b%)
      ADD pt%,37
    NEXT i%
  ENDIF
  '
  ' Chargement de la song
  '
  pt%=ADD(admod%,p1%)
  FOR i%=0 TO PRED(lon%)
    song&(i%)=BYTE{ADD(pt%,i%)}
  NEXT i%
  '
  ' Chargement des patterns
  '
  d%=ADD(admod%,p2%)
  FOR i%=d% TO ADD(d%,SUB(MUL(nbp%,64),2)) STEP 2
    GOSUB intel_w(i%)
  NEXT i%
  pt%=ADD(admod%,ADD(p1%,128))
  FOR i%=1 TO nbt%
    b%=0
    FOR j%=0 TO MUL(PRED(nbp%),64) STEP 64
      a%=FN adr_pat(b%)
      FOR k%=j% TO ADD(j%,SHL(PRED(nbr_track%),1)) STEP 2
        IF i%=CARD{ADD(d%,k%)}
          ~C:g_convert_mtmv_2_gtk%(L:pt%,L:a%,W:nbr_track%,W:nbl%)
        ENDIF
        ADD a%,5
      NEXT k%
      INC b%
    NEXT j%
    ADD pt%,192
  NEXT i%
  '
  ' Charge les instruments
  '
  IF nbs%>0
    FOR i%=1 TO nbs%
      b%=FN length(i%)
      IF b%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        a%=FN adresse(i%)
        c%=FN resol(i%)
        IF c%=2
          ~C:g_intel_16_bits%(L:a%,L:b%)
        ENDIF
        ~C:g_signe_sample%(L:a%,L:b%,W:c%)
      ENDIF
    NEXT i%
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_module_s3m               !!!
  ' Chargement d'un module au format Scream Tracker 3
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_s3m_mem
  ' Chargement d'un module au format Scream Tracker 3 deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,d%,convtrk$,ffv%,flg%,i%,j%,lon%,nbp%,nbs%,xxx1%,xxx2%,xxx3%,os$
  ~FRE(0)
  GOSUB chg_songname2(admod%,28)
  GOSUB intel_w(ADD(admod%,&H20))
  GOSUB intel_w(ADD(admod%,&H22))
  GOSUB intel_w(ADD(admod%,&H24))
  GOSUB intel_w(ADD(admod%,&H2A))
  lon%=CARD{ADD(admod%,&H20)}           ! Longueur de la song (pair)
  nbs%=CARD{ADD(admod%,&H22)}           ! Nombre de samples
  nbp%=CARD{ADD(admod%,&H24)}           ! Nombre de patterns sauves
  ffv%=CARD{ADD(admod%,&H2A)}           ! File Format Version
  ticks%=BYTE{ADD(admod%,&H31)}         ! Vitesse
  tempo%=BYTE{ADD(admod%,&H32)}         ! Tempo
  xxx1%=ADD(&H60,SUCC(lon%) AND -2)     ! Ca doit toujours etre pair mais on ne sait jamais...
  xxx2%=ADD(xxx1%,SHL(nbs%,1))
  xxx3%=ADD(xxx2%,SHL(nbp%,1))
  '
  ' Recherche du nombre de voies
  '
  nbt%=0                                ! Nombre de voies
  convtrk$=""
  FOR i%=0 TO 31
    b%=BYTE{ADD(admod%,ADD(i%,&H40))} AND 127
    IF b%<16
      convtrk$=convtrk$+CHR$(nbt%)
      CARD{ADD(V:balance$,SHL(nbt%,1))}=MUL(SHR(b%,3),&HFFF)
      INC nbt%
    ELSE
      convtrk$=convtrk$+CHR$(255)
    ENDIF
  NEXT i%
  IF nbt%>0
    GOSUB new_pattern_format(nbt%)
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbt%)+MKI$(64)),nbp%,TRUE)
    '
    ' Les pan positions
    '
    IF BYTE{ADD(admod%,&H35)}=252
      FOR i%=0 TO PRED(nbt%)
        a%=BYTE{ADD(ADD(admod%,xxx3%),i%)}
        IF BTST(a%,5)
          a%=a% AND 15
          CARD{ADD(V:balance$,SHL(i%,1))}=MIN(DIV(MUL(a%,&H1000),15),&HFFF)
        ENDIF
      NEXT i%
    ENDIF
    '
    ' Chargement du header des samples
    '
    os$=""
    IF nbs%>0
      FOR i%=1 TO nbs%
        a%=ADD(admod%,ADD(xxx1%,SHL(PRED(i%),1)))
        GOSUB intel_w(a%)
        pt%=ADD(admod%,SHL(CARD{a%},4))
        a%=0
        IF BYTE{pt%}=1                    ! Est-ce bien un sample ?
          IF BYTE{ADD(pt%,&H1E)}=0        ! Sample non compacte
            GOSUB chg_samplename2(ADD(pt%,&H30),28,i%)
            GOSUB chg_instrname2(ADD(pt%,&H30),28,i%)
            GOSUB intel_w(ADD(pt%,&HE))
            GOSUB intel_l(ADD(pt%,&H10))
            GOSUB intel_l(ADD(pt%,&H14))
            GOSUB intel_l(ADD(pt%,&H18))
            GOSUB intel_l(ADD(pt%,&H20))
            flg%=BYTE{ADD(pt%,&H1F)}      ! Flags divers
            a%=MIN(MAX(LONG{ADD(pt%,&H10)},0),&HFFFFFE) AND -2
            IF BTST(flg%,0)               ! Boucle
              b%=MIN(MAX(LONG{ADD(pt%,&H14)},0) AND -2,SUB(a%,2))
              c%=MIN(MAX(SUB(MAX(LONG{ADD(pt%,&H18)},0) AND -2,b%),2),SUB(a%,b%))
            ELSE                          ! Pas boucle
              b%=0
              c%=2
            ENDIF
            GOSUB chg_sam_freq(i%,LONG{ADD(pt%,&H20)} AND 65535)
            GOSUB chg_sam_nbits(i%,SUB(1,BTST(flg%,2)))
            GOSUB chg_sam_length(i%,a%)
            GOSUB chg_sam_repeat(i%,b%)
            GOSUB chg_sam_replen(i%,c%)
            GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(pt%,&H1C)},2))
            GOSUB chg_sam_volume(i%,&H100)
            os$=os$+MKL$(ADD(admod%,SHL(CARD{ADD(pt%,&HE)},4)))
          ELSE
            os$=os$+MKL$(0)
          ENDIF
        ELSE
          os$=os$+MKL$(0)
        ENDIF
      NEXT i%
    ENDIF
    IF lon%>0 AND nbt%>0
      '
      ' Chargement de la sequence
      '
      a%=0
      b%=0
      REPEAT
        song&(a%)=BYTE{ADD(admod%,ADD(b%,&H60))}
        IF song&(a%)<254
          INC a%
        ENDIF
        INC b%
      UNTIL b%=lon%                     ! OR BYTE{ADD(admod%,ADD(b%,&H60))}=255
      song&(a%)=0
      module&(101)=a%
      '
      ' Chargement des patterns
      '
      FOR i%=0 TO PRED(nbp%)
        a%=ADD(admod%,ADD(xxx2%,SHL(i%,1)))
        GOSUB intel_w(a%)
        pt%=ADD(admod%,SHL(CARD{a%},4))
        a%=CARD{pt%}                    ! Longueur du pattern
        GOSUB intel_w(ADD(V:a%,2))      ! Mais qu'est-ce que j'en fais ???
        ADD pt%,2
        b%=FN adr_pat(i%)
        c%=V:convtrk$
        ~C:g_convert_s3m_2_gtk%(L:pt%,L:b%,L:c%,W:nbr_track%)
      NEXT i%
    ENDIF
    '
    ' Chargement des sample
    '
    IF nbs%>0
      FOR i%=1 TO nbs%
        a%=FN length(i%)
        IF a%>0
          GOSUB decale_sample(i%,nbs%,V:os$)
          d%=FN adresse(i%)
          b%=FN resol(i%)
          IF b%=2               ! 16 bits
            ~C:g_intel_16_bits%(L:d%,L:a%)
          ENDIF
          IF ffv%=2
            ~C:g_signe_sample%(L:d%,L:a%,W:b%)
          ENDIF
        ENDIF
      NEXT i%
    ENDIF
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_module_ult               !!!
  ' Chargement d'un module au format Ultra Tracker
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_ult_mem
  ' Chargement d'un module au format Ultra Tracker
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,bidi%,c%,d%,e%,i%,j%,nbp%,nbs%,ofp%,patt_seq%,res%,shs%,ver%,pat$,os$
  ~FRE(0)
  ver%=1                                ! Numero de version du format
  shs%=64                               ! Taille d'un header de sample
  SELECT VAL(MID$(header$,13,3))
  CASE 2
    ver%=2
  CASE 3
    ver%=3
  CASE 4
    ver%=4
    shs%=66
  ENDSELECT
  GOSUB chg_songname2(ADD(admod%,15),32)
  res%=ADD(MUL(BYTE{ADD(admod%,47)},32),49)     ! Offset des descripteurs de samples
  nbs%=BYTE{ADD(admod%,PRED(res%))}
  patt_seq%=ADD(res%,MUL(nbs%,shs%))            ! Offset de la song
  nbp%=SUCC(BYTE{ADD(admod%,ADD(patt_seq%,257))})       ! Nombre de patterns
  GOSUB new_pattern_format(SUCC(BYTE{ADD(admod%,ADD(patt_seq%,256))}))
  IF ver%>2
    FOR i%=0 TO PRED(nbr_track%)
      CARD{ADD(V:balance$,SHL(i%,1))}=MUL(BYTE{ADD(ADD(admod%,ADD(patt_seq%,258)),i%)},&H111)
    NEXT i%
  ENDIF
  '
  ' La song
  '
  i%=0
  REPEAT
    a%=BYTE{ADD(admod%,ADD(patt_seq%,i%))}
    IF a%<nbp%
      song&(i%)=a%
      INC i%
    ENDIF
  UNTIL a%=>nbp% OR i%=>256
  module&(101)=i%
  '
  ' Chargement des patterns
  '
  IF ver%<3
    ofp%=ADD(patt_seq%,258)
  ELSE
    ofp%=ADD(patt_seq%,ADD(258,nbr_track%))
  ENDIF
  IF nbp%>0
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbr_track%)+MKI$(64)),nbp%,FALSE)
    FOR j%=0 TO PRED(nbr_track%)
      FOR i%=0 TO PRED(nbp%)
        a%=ADD(admod%,ofp%)
        b%=FN adr_trk(i%,0,j%)
        a%=C:g_convert_ult_2_gtk%(L:a%,L:b%,W:nbr_track%)       ! Convertit et prend la longueur de cette voie
        ADD ofp%,a%
      NEXT i%
    NEXT j%
  ENDIF
  '
  ' Chargement des samples
  '
  IF nbs%>0
    os$=""
    FOR i%=1 TO nbs%
      pt%=ADD(admod%,ADD(res%,MUL(PRED(i%),shs%)))
      GOSUB chg_samplename2(pt%,28,i%)
      GOSUB chg_instrname2(pt%,28,i%)
      GOSUB intel_l(ADD(pt%,44))
      GOSUB intel_l(ADD(pt%,48))
      GOSUB intel_l(ADD(pt%,52))
      GOSUB intel_l(ADD(pt%,56))
      GOSUB intel_w(ADD(pt%,SUB(shs%,2)))
      bidi%=BYTE{ADD(pt%,61)}
      b%=SUB(LONG{ADD(pt%,56)},LONG{ADD(pt%,52)})       ! Longueur
      c%=LONG{ADD(pt%,44)}                              ! Loop start
      d%=LONG{ADD(pt%,48)}                              ! Loop end
      IF BTST(bidi%,2)                                  ! 16 bits ?
        ADD b%,b%
        ADD c%,c%
        ADD d%,d%
      ENDIF
      os$=os$+MKL$(ADD(admod%,ofp%))
      ADD ofp%,b%
      b%=MIN(MAX(b% AND -2,0),&HFFFFFE)
      IF BTST(bidi%,3) OR BTST(bidi%,4)                 ! Bouclage
        c%=MAX(MIN(c% AND -2,SUB(b%,2)),0)
        d%=MAX(SUB(MIN(d%,b%),c%),2) AND -2
      ELSE
        c%=0
        d%=2
      ENDIF
      GOSUB chg_sam_length(i%,b%)
      GOSUB chg_sam_repeat(i%,c%)
      GOSUB chg_sam_replen(i%,d%)
      d%=CARD{ADD(pt%,SUB(shs%,2))} AND 15      ! Finetune
      IF d%>7
        SUB d%,16
      ENDIF
      GOSUB chg_sam_finetune(i%,d%)
      GOSUB chg_ins_volume(i%,BYTE{ADD(pt%,60)})
      GOSUB chg_sam_volume(i%,&H100)
      GOSUB chg_sam_nbits(i%,SUB(1,BTST(bidi%,2)))
      IF ver%>3                         ! Frequence d'echantillonnage
        GOSUB intel_w(ADD(pt%,SUB(shs%,4)))
        GOSUB chg_sam_freq(i%,CARD{ADD(pt%,SUB(shs%,4))})
      ENDIF
    NEXT i%
    FOR i%=1 TO nbs%
      a%=FN length(i%)
      IF a%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        IF FN resol(i%)=2       ! 16 bits
          d%=FN adresse(i%)
          ~C:g_intel_16_bits%(L:d%,L:a%)
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_module_dtm_mem
  LOCAL a%,b%,c%,adsq%,adpatt%,adinst%,finmod%,i%,j%,k%,l%,nbs%,nbp%,pt%
  LOCAL adp$,adi$,map$
  ~FRE(0)
  '
  ' Identification des chunks
  '
  finmod%=ADD(admod%,lonmod%)
  adp$=STRING$(1024,0)
  adi$=STRING$(1024,0)
  map$=STRING$(256,MKI$(1)+MKI$(1))
  a%=admod%
  REPEAT
    SELECT LONG{a%}
    CASE "S.Q."
      adsq%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "PATT"
      adpatt%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "INST"
      adinst%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "DAPT"
      LONG{ADD(V:adp$,SHL(CARD{ADD(a%,12)},2))}=a%
      CARD{ADD(V:map$,ADD(SHL(CARD{ADD(a%,12)},2),2))}=CARD{ADD(a%,14)}
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "DAIT"
      LONG{ADD(V:adi$,SHL(CARD{ADD(a%,8)},2))}=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    ENDSELECT
    a%=C:g_dtm_next_chunk%(L:a%,L:finmod%)
  UNTIL a%>=finmod%
  '
  ' Infos generales
  '
  GOSUB new_pattern_format(CARD{ADD(adpatt%,8)})
  GOSUB chg_songname2(ADD(admod%,22),20)
  IF CARD{ADD(admod%,14)}<>0
    ticks%=CARD{ADD(admod%,14)}                 ! Vitesse
  ENDIF
  IF CARD{ADD(admod%,16)}<>0                    ! Tempo
    tempo%=CARD{ADD(admod%,16)}
  ENDIF
  nbs%=CARD{ADD(adinst%,8)}
  '
  ' La song
  '
  module&(101)=CARD{ADD(adsq%,8)}
  module&(102)=CARD{ADD(adsq%,10)}
  ARRAYFILL song&(),0
  FOR i%=0 TO PRED(module&(101))
    song&(i%)=BYTE{ADD(ADD(adsq%,16),i%)}
  NEXT i%
  '
  ' Les patterns
  '
  nbp%=CARD{ADD(adpatt%,10)}
  FOR i%=0 TO SHL(PRED(nbp%),2) STEP 4
    CARD{ADD(V:map$,i%)}=nbr_track%
  NEXT i%
  GOSUB create_space_multipatchunk(map$,nbp%,FALSE)
  FOR i%=0 TO PRED(nbp%)
    a%=LONG{ADD(V:adp$,SHL(i%,2))}      ! Adresse du pattern
    IF a%<>0
      l%=CARD{ADD(a%,14)}
      IF l%>0
        ADD a%,16                       ! Adresse des donnees
        b%=FN adr_pat(i%)
        c%=MUL(l%,nbr_track%)
        IF LONG{ADD(adpatt%,12)}=&H322E3034     ! '2.04'
          ~C:g_convert_dtm_2_gtk%(L:a%,L:b%,L:c%)
        ELSE                                    ! Ancien format
          BMOVE a%,b%,SHL(c%,2)
          ~C:g_convert_nt_2_gtk%(L:b%,L:c%)
        ENDIF
      ENDIF
    ENDIF
  NEXT i%
  '
  ' Les instruments
  '
  IF nbs%>0
    FOR i%=1 TO nbs%
      IF LONG{ADD(V:adi$,SHL(PRED(i%),2))}>admod%
        a%=ADD(ADD(adinst%,10),MUL(PRED(i%),50))
        GOSUB chg_samplename2(ADD(a%,18),22,i%)
        GOSUB chg_instrname2(ADD(a%,18),22,i%)
        c%=LONG{ADD(a%,4)} AND -2
        GOSUB chg_sam_length(i%,c%)
        IF c%>0
          GOSUB chg_sam_freq(i%,LONG{ADD(a%,46)})
          GOSUB chg_sam_nbits(i%,SHR(BYTE{ADD(a%,41)},3))
          GOSUB chg_sam_repeat(i%,MIN(SUB(c%,2),MAX(0,LONG{ADD(a%,10)} AND -2)))
          GOSUB chg_sam_replen(i%,MIN(SUB(c%,FN repeat(i%)),MAX(2,LONG{ADD(a%,14)} AND -2)))
          c%=BYTE{ADD(a%,8)}
          IF c%>7
            SUB c%,16
          ENDIF
          GOSUB chg_sam_finetune(i%,c%)
          GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(a%,9)},2))
          GOSUB chg_sam_volume(i%,&H100)
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
  ~FRE(0)
  IF nbs%>0
    FOR i%=0 TO PRED(nbs%)
      IF FN length(SUCC(i%))>0
        LONG{ADD(V:adi$,SHL(i%,2))}=ADD(LONG{ADD(V:adi$,SHL(i%,2))},10)
      ELSE
        LONG{ADD(V:adi$,SHL(i%,2))}=0
      ENDIF
    NEXT i%
    FOR i%=1 TO nbs%
      GOSUB decale_sample(i%,nbs%,V:adi$)
    NEXT i%
  ENDIF
RETURN
PROCEDURE load_module_xm_mem            !!!
  LOCAL a%,b%,c%,d%,i%,j%,l%,hs%,nbi%,nbl%,nbp%,nbt%,pt%,sl%,snum%,sr%,tem%
  LOCAL transp$,adi$,map$
  ~FRE(0)
  '
  ' Header du module
  '
  GOSUB chg_songname2(ADD(admod%,17),20)
  GOSUB intel_l(ADD(admod%,60))
  GOSUB intel_w(ADD(admod%,64))
  GOSUB intel_w(ADD(admod%,66))
  GOSUB intel_w(ADD(admod%,68))
  GOSUB intel_w(ADD(admod%,70))
  GOSUB intel_w(ADD(admod%,72))
  GOSUB intel_w(ADD(admod%,76))
  GOSUB intel_w(ADD(admod%,78))
  pt%=ADD(ADD(60,admod%),LONG{ADD(admod%,60)})  ! Pointe sur le 1er pattern
  sl%=CARD{ADD(admod%,64)}              ! Song length
  sr%=CARD{ADD(admod%,66)}              ! Song repeat
  nbt%=CARD{ADD(admod%,68)}             ! Nombre de tracks
  nbp%=CARD{ADD(admod%,70)}             ! Nombre de patterns
  nbi%=CARD{ADD(admod%,72)}             ! Nombre d'instruments
  ticks%=CARD{ADD(admod%,76)}           ! Vitesse
  tempo%=CARD{ADD(admod%,78)}           ! Tempo
  '
  ' Recherche du nombre de lignes
  ' DesINTELisation des mots dans les headers des patterns
  '
  map$=""
  nbl%=1
  a%=pt%
  FOR i%=1 TO nbp%
    GOSUB intel_l(a%)
    GOSUB intel_w(ADD(a%,5))
    GOSUB intel_w(ADD(a%,7))
    nbl%=CARD{ADD(a%,5)}
    map$=map$+MKI$(nbt%)+MKI$(nbl%)
    ADD a%,ADD(LONG{a%},CARD{ADD(a%,7)})
  NEXT i%
  GOSUB new_pattern_format(nbt%)
  '
  ' La song
  '
  module&(101)=sl%
  module&(102)=sr%
  FOR i%=0 TO PRED(FN song_length)
    song&(i%)=BYTE{ADD(ADD(admod%,80),i%)}
  NEXT i%
  '
  ' Les patterns
  '
  GOSUB create_space_multipatchunk(map$,nbp%,FALSE)
  FOR i%=0 TO PRED(nbp%)
    IF BYTE{ADD(pt%,4)}=0               ! Packing type 0
      l%=CARD{ADD(pt%,5)}
      a%=ADD(pt%,9)
      b%=FN adr_pat(i%)
      ~C:g_convert_ft2_2_gtk%(L:a%,L:b%,W:nbr_track%,W:l%)
      pt%=ADD(a%,CARD{ADD(pt%,7)})
    ENDIF
  NEXT i%
  '
  ' Les instruments et headers des samples
  '
  snum%=1                               ! Sample courant
  adi$=""
  FOR i%=1 TO nbi%
    GOSUB intel_l(pt%)
    GOSUB intel_w(ADD(pt%,27))
    hs%=LONG{pt%}                       ! Taille du header d'instr
    c%=CARD{ADD(pt%,27)}                ! Nombre de samples dans l'instr
    GOSUB chg_instrname2(ADD(pt%,4),22,i%)
    IF c%=0
      ADD pt%,hs%                       ! Si pas de sample, instr suivant
    ELSE
      GOSUB chg_ins_volume(i%,256)
      FOR j%=1 TO 95                    ! Affectation des samples pour chaque note
        GOSUB chg_ins_sample(i%,j%,ADD(BYTE{ADD(pt%,ADD(33,j%))},snum%))
      NEXT j%
      FOR j%=96 TO 127
        GOSUB chg_ins_sample(i%,j%,FN isample(i%,95))
      NEXT j%
      GOSUB chg_ins_sample(i%,0,0)
      transp$=STRING$(256,0)            ! Table des transposition pour chaque sample
      GOSUB intel_l(ADD(pt%,29))
      a%=LONG{ADD(pt%,29)}              ! Taille des Sample Headers
      ADD pt%,hs%                       ! Pointe sur le premier header de sample
      ' Scanne chaque header de sample
      b%=0                              ! Taille totale des sample data de l'instrument
      FOR j%=1 TO c%                    ! DesINTELise tous les headers
        GOSUB intel_l(pt%)
        GOSUB intel_l(ADD(pt%,4))
        GOSUB intel_l(ADD(pt%,8))
        BYTE{ADD(V:transp$,snum%)}=BYTE{ADD(pt%,16)}    ! Memorise la transposition
        adi$=adi$+MKL$(b%)
        d%=LONG{pt%}
        ADD b%,d%
        d%=d% AND -2
        GOSUB chg_sam_length(snum%,d%)
        IF BTST(BYTE{ADD(pt%,14)},0) OR BTST(BYTE{ADD(pt%,14)},1)
          GOSUB chg_sam_repeat(snum%,LONG{ADD(pt%,4)} AND -2)
          GOSUB chg_sam_replen(snum%,MIN(MAX(LONG{ADD(pt%,8)},2),SUB(FN length(snum%),FN repeat(snum%))) AND -2)
        ELSE
          GOSUB chg_sam_repeat(snum%,0)
          GOSUB chg_sam_replen(snum%,2)
        ENDIF
        GOSUB chg_sam_volume(snum%,SHL(BYTE{ADD(pt%,12)},2))
        GOSUB chg_sam_freq(snum%,8363)
        GOSUB chg_sam_finetune(snum%,DIV(FN sbyte(BYTE{ADD(pt%,13)}),16))
        GOSUB chg_sam_nbits(snum%,SUB(1,BTST(BYTE{ADD(pt%,14)},4)))
        GOSUB chg_sam_balance(snum%,SHL(BYTE{ADD(pt%,15)},4))
        GOSUB chg_samplename2(ADD(pt%,18),22,snum%)
        ADD pt%,a%
        INC snum%                       ! Attention faut pas depasser 255!!!!!
      NEXT j%
      FOR j%=1 TO c%                    ! Les adresses des samples dans le XM
        LONG{ADD(V:adi$,SHL(SUB(PRED(snum%),j%),2))}=ADD(LONG{ADD(V:adi$,SHL(SUB(PRED(snum%),j%),2))},pt%)
      NEXT j%
      ADD pt%,b%                        ! Saute les donnees de sample
      FOR j%=1 TO 95                    ! Affecte les transpositions a chaque note suivant les samples
        GOSUB chg_ins_transp(i%,j%,BYTE{ADD(V:transp$,FN isample(i%,j%))})
      NEXT j%
      FOR j%=96 TO 127
        GOSUB chg_ins_transp(i%,j%,FN itransp(i%,95))
      NEXT j%
      GOSUB chg_ins_transp(i%,0,0)
    ENDIF
  NEXT i%
  '
  ' Deplacement des samples et conversion en absolu
  '
  IF snum%>1
    FOR i%=1 TO PRED(snum%)
      GOSUB decale_sample(i%,PRED(snum%),V:adi$)
      a%=FN adresse(i%)
      b%=FN length(i%)
      c%=FN resol(i%)
      IF c%=2                           ! 16 bits
        ~C:g_intel_16_bits%(L:a%,L:b%)
      ENDIF
      ~C:g_delta_2_absolu%(L:a%,L:b%,W:c%)
    NEXT i%
  ENDIF
RETURN
PROCEDURE save_instrument
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_instrument$<>""
      a$=npath_div$+nfile_instrument$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE INSTRUMENT",0,0,PRED(scr_ncol%))
      FILESELECT npath_div$+"*.INS",nfile_instrument$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING INSTRUMENT "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_instrument2
      GOSUB separe_nom_chemin(a$)
      nfile_instrument$=nfile_$
      npath_div$=npath_$
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_instrument2
  ' Fournir a$ nom du module, instr% numero de l'instrument
  LOCAL a%,i%
  LOCAL b$
  erreur%=0
  warning%=0
  OPEN "o",#0,a$
  SEEK #0,0
  '
  ' Travail preparatoire
  '
  ' Cherche les samples utilises par cet instrument
  lsam$=STRING$(256,0)
  FOR i%=0 TO 127
    a%=FN isample(instr%,i%)
    IF a%<>0
      BYTE{ADD(V:lsam$,a%)}=1
    ENDIF
  NEXT i%
  '
  ' Chunk de l'instrument
  '
  BPUT #0,V:instrset%(0,instr%),instrset%(1,instr%)
  '
  ' Chunks des samples
  '
  FOR i%=1 TO 255
    IF BYTE{ADD(V:lsam$,i%)}<>0
      a%=MAX(FN adrsamchk(i%)*(-flag_registered2!),&H1563)      ! *** 2eme protection
      BPUT #0,a%,FN lonsamchk(i%)
    ENDIF
  NEXT i%
  CLOSE #0
RETURN
PROCEDURE load_instrument
  LOCAL a$
  IF km%=2 AND nfile_instrument$<>""
    a$=npath_div$+nfile_instrument$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD SAMPLE",0,0,PRED(scr_ncol%))
    FILESELECT npath_div$+"*.INS",nfile_instrument$,a$
  ENDIF
  IF FN exist(a$)
    CLS
    GOSUB cadre_texte("WAITING : LOADING INSTRUMENT "+a$+"...",0,0,PRED(scr_ncol%))
    GOSUB load_instrument2
    IF erreur%=0
      GOSUB separe_nom_chemin(a$)
      nfile_instrument$=nfile_$
      npath_div$=npath_$
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
  IF erreur%=1
    GOSUB aff_message("NOT AN INSTRUMENT.")
  ELSE IF erreur%=2
    GOSUB aff_message("NOT ENOUGH MEMORY TO LOAD THIS INSTRUMENT !")
  ELSE IF erreur%=3
    GOSUB aff_message("TOO MANY SAMPLES IN THIS INSTRUMENT")
  ENDIF
RETURN
PROCEDURE load_instrument2
  ' Nom fourni dans a$
  LOCAL a%,b%,c%,i%,j%,lchk%,nbs%,posact%,totlon%
  LOCAL chk$,sam$
  ~FRE(0)
  erreur%=0
  warning%=0
  OPEN "i",#0,a$
  totlon%=LOF(#0)
  posact%=0
  '
  ' Chargement du chunk de l'instrument
  '
  chk$=STRING$(8,0)
  SEEK #0,posact%
  BGET #0,V:chk$,8
  ADD posact%,8
  IF LEFT$(chk$,4)="INST"                       ! Verifie que c'est bien un instrument
    lchk%=LONG{ADD(V:chk$,4)}
    chk$=chk$+STRING$(SUB(lchk%,8),0)
    BGET #0,ADD(V:chk$,8),SUB(lchk%,8)
    ADD posact%,SUB(lchk%,8)
    ' Table de conversion de numero d'instrument
    sam$=STRING$(256,0)
    nbs%=0                                      ! Nombre de samples
    a%=0
    FOR i%=1 TO 127
      b%=BYTE{ADD(ADD(V:chk$,60),SHL(i%,1))}
      IF BYTE{ADD(V:sam$,b%)}=0 AND b%>0
        INC nbs%
        REPEAT
          INC a%
          EXIT IF a%>255
        UNTIL FN length(a%)=0                   ! Cherche un sample libre : longueur nulle
        IF a%<=255
          BYTE{ADD(V:sam$,b%)}=a%
        ELSE
          erreur%=3                             ! Plus de sample libre : erreur
          i%=999
        ENDIF
      ENDIF
    NEXT i%
    IF erreur%<>0
      GOTO ld_instr2_fin
    ENDIF
    CARD{ADD(V:chk$,8)}=instr%
    CARD{ADD(V:chk$,60)}=0
    FOR i%=1 TO 127                             ! Nouveaux numeros de sample
      BYTE{ADD(ADD(V:chk$,60),SHL(i%,1))}=BYTE{ADD(V:sam$,BYTE{ADD(ADD(V:chk$,60),(SHL(i%,1)))})}
    NEXT i%
    BMOVE V:chk$,V:instrset%(0,instr%),316
    '
    ' Chargement des samples
    '
    IF nbs%>0
      a%=0                                      ! Nombre de samples charges
      WHILE posact%<totlon% AND a%<nbs%
        chk$=STRING$(64,0)
        SEEK #0,posact%
        BGET #0,V:chk$,64
        ADD posact%,64
        lchk%=LONG{ADD(V:chk$,4)}               ! Longueur totale du chunk du sample
        c%=LONG{ADD(V:chk$,46)}                 ! Longueur en octets
        d%=CARD{ADD(V:chk$,8)}                  ! Ancien numero du sample
        b%=BYTE{ADD(V:sam$,d%)}                 ! Nouveau numero du sample
        IF b%<>0                                ! S'il etait bien declare dans le chunk de l'instrument
          CARD{ADD(V:chk$,8)}=b%
          GOSUB chg_taille_sample(b%,c%)        ! Change d'abord la taille
          BMOVE V:chk$,FN adrsamchk(b%),64      ! Transfert ensuite le chunk
          BGET #0,FN adresse(b%),c%             ! Puis transfert les donnees (taille indiquee dans Length)
          ADD posact%,SUB(lchk%,64)             ! Pointe sur le chunk suivant
          BYTE{ADD(V:sam$,d%)}=0                ! Indique que le sample est deja charge
          INC a%
        ELSE                                    ! Sample qui etait en trop
          ADD posact%,SUB(lchk%,64)
        ENDIF
      WEND
    ENDIF
    IF a%<nbs%
      warning%=1                                ! Tous les samples n'ont pas ete trouves
    ENDIF
    FOR i%=1 TO 255
      ~C:rr_boucle_sample%(W:i%)
    NEXT i%
  ELSE
    erreur%=1
  ENDIF
ld_instr2_fin:
  CLOSE #0
RETURN
PROCEDURE load_prefs
  LOCAL a$
  IF km%=2 AND nfile_sample$<>""
    a$=npath_prefs$+nfile_prefs$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD PREFERENCES",0,0,PRED(scr_ncol%))
    FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING PREFERENCES "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB load_prefs2(a$,FALSE)
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE load_prefs2(fic$,first_time!) !!!
  LOCAL a%,b%,i%
  LOCAL a$,lig$,p$,p1$,p2$
  LOCAL error!
  OPEN "i",#0,fic$
  WHILE NOT EOF(#0)
    LINE INPUT #0,lig$
    IF LEN(lig$)>2
      ' Transforme les caracteres non ASCII en espaces
      FOR i%=0 TO PRED(LEN(lig$))
        IF BYTE{ADD(V:lig$,i%)}<32
          BYTE{ADD(V:lig$,i%)}=32
        ENDIF
      NEXT i%
      lig$=TRIM$(lig$)
      a%=INSTR(lig$,"=")
      IF a%>1
        p$=UPPER$(TRIM$(LEFT$(lig$,PRED(a%))))  ! p$ contient le nom de la variable
        p1$=RIGHT$(lig$,SUB(LEN(lig$),a%))      ! p1$ contient le reste brut de la ligne
        b%=INSTR(p1$,";")
        IF b%>0
          p2$=UPPER$(TRIM$(LEFT$(p1$,PRED(b%))))        ! p2$ contient le 2eme terme sans commentaire
        ELSE
          p2$=UPPER$(TRIM$(p1$))
        ENDIF
        '
        ' Main pannel
        ' -----------
        '
        ' Disk
        '
        IF p$="PROGRAM_PATH"
          npath_prog$=p2$
        ELSE IF p$="MODULE_PATH"
          npath_module$=p2$
        ELSE IF p$="SAMPLE_PATH"
          npath_sample$=p2$
        ELSE IF p$="AUTOLOAD_PATH"
          npath_autoload$=p2$
        ELSE IF p$="PREF_PATH"
          npath_prefs$=p2$
        ELSE IF p$="MISC_PATH"
          npath_div$=p2$
        ELSE IF p$="MODULE_EXTENSION"
          next_module$=p2$
        ELSE IF p$="SAMPLE_EXTENSION"
          next_sample$=p2$
        ELSE IF p$="MODULE_FILE"
          IF p2$<>"/"
            nfile_module$=p2$
          ELSE
            nfile_module$=""
          ENDIF
        ELSE IF p$="SAMPLE_FILE"
          IF p2$<>"/"
            nfile_sample$=p2$
          ELSE
            nfile_sample$=""
          ENDIF
        ELSE IF p$="AUTOLOAD_FILE"
          IF p2$<>"/"
            nfile_autoload$=p2$
          ELSE
            nfile_autoload$=""
          ENDIF
        ELSE IF p$="PREF_FILE"
          IF p2$<>"/"
            nfile_prefs$=p2$
          ELSE
            nfile_prefs$=""
          ENDIF
        ELSE IF p$="SAVE_CONFIG_GT2"
          IF p2$="TRUE"
            flag_gt2cnf!=TRUE
          ELSE
            flag_gt2cnf!=FALSE
          ENDIF
        ELSE IF p$="MODULE_BACKUP"
          IF p2$="TRUE"
            flag_backup_modules!=TRUE
          ELSE
            flag_backup_modules!=FALSE
          ENDIF
          '
          ' Divers
          '
        ELSE IF p$="COLOR_PAL"
          error!=FALSE
          a$=""
          FOR i%=0 TO 15
            IF LEN(p2$)<3
              error!=TRUE
            ELSE
              a$=a$+LEFT$(p2$,3)
              p2$=TRIM$(RIGHT$(p2$,SUB(LEN(p2$),3)))
            ENDIF
          NEXT i%
          IF NOT error!
            color_pal$=a$
          ENDIF
        ELSE IF p$="PATTERN_LINE_MAX"
          haut_lig%=MIN(MAX(VAL(p2$) OR 1,1),99999)
          IF NOT first_time!
            haut_lig%=MIN(DIV(SUB(scr_haut%,180),6) OR 1,haut_lig%)
          ENDIF
        ELSE IF p$="INSTRUMENT"
          instr%=MIN(MAX(VAL(p2$),1),255)
        ELSE IF p$="SAMPLE"
          sample%=MIN(MAX(VAL(p2$),1),255)
        ELSE IF p$="LINE_STEP"
          line_step%=MIN(MAX(VAL(p2$),-64),64)
        ELSE IF p$="NUMBER_OF_TRACKS"
          IF first_time!
            nbr_track%=MIN(MAX(VAL(p2$),1),32)
          ENDIF
        ELSE IF p$="PRESET"
          n_preset%=MIN(MAX(PRED(VAL(p2$)),0),31)
        ELSE IF p$="OCTAVE"
          octave%=MIN(MAX(PRED(VAL(p2$)),0),6)
        ELSE IF p$="MENU"
          IF p2$="DISK"
            ss_menu%=1
          ELSE IF p2$="TOOLS"
            ss_menu%=2
          ELSE IF p2$="INSTRUMENTS"
            ss_menu%=3
          ELSE IF p2$="SAMPLES"
            ss_menu%=4
          ELSE IF p2$="ENVELOPES"
            ss_menu%=5
          ELSE IF p2$="CONTROL"
            ss_menu%=6
          ELSE
            ss_menu%=MIN(MAX(VAL(p2$),1),5)
          ENDIF
        ELSE IF p$="NUMPAD"
          IF p2$="DRUMKIT"
            drumpad_flag%=1
          ELSE
            drumpad_flag%=0
          ENDIF
        ELSE IF p$="PATTERN_DISPLAY"
          type_affpiste%=MIN(MAX(VAL(p2$),0),2)
        ELSE IF p$="BLOCK_REPLACE"
          IF p2$="TRUE"
            replace_block%=1
          ELSE
            replace_block%=0
          ENDIF
          '
          ' Tools
          '
        ELSE IF p$="BLOCK_TYPE"
          IF p2$="PATTERN"
            trackpat%=1
          ELSE IF p2$="PRESET"
            trackpat%=2
          ELSE
            trackpat%=0
          ENDIF
        ELSE IF p$="BLOCK_SONG"
          IF p2$="TRUE"
            bl_flagsong!=TRUE
          ELSE
            bl_flagsong!=FALSE
          ENDIF
        ELSE IF p$="BLOCK_MASK"
          IF p2$="TRUE"
            maskblock%=1
          ELSE
            maskblock%=0
          ENDIF
        ELSE IF p$="BLOCK_MASK1"
          '
          '
          '
        ELSE IF p$="BLOCK_MASK2"
          '
          '
          '
        ELSE IF p$="TOOLS_ECHO_STEP"
          bl_echo_lines%=MIN(MAX(VAL(p2$),1),64)
        ELSE IF p$="TOOLS_ECHO_FDBKVAL"
          bl_echo_feedback%=MIN(MAX(VAL(p2$),0),100)
        ELSE IF p$="TOOLS_ECHO_FADESTEP"
          bl_echo_fadestep%=MIN(MAX(VAL(p2$),0),256)
        ELSE IF p$="TOOLS_ECHO_CONT"
          IF p2$="TRUE"
            bl_echo_cont!=TRUE
          ELSE
            bl_echo_cont!=FALSE
          ENDIF
        ELSE IF p$="TOOLS_ECHO_FEEDBACK"
          IF p2$="TRUE"
            bl_echo_fdbk!=TRUE
          ELSE
            bl_echo_fdbk!=FALSE
          ENDIF
        ELSE IF p$="NOTE_EXTENSION"
          '
          '
          '
          '
          ' Envelopes
          '
        ELSE IF p$="ENVELOPE"
          env_num&=MIN(MAX(VAL(p2$),1),64)
        ELSE IF p$="ENV_SECTION"
          IF p2$="KEYOFF"
            env_sect&=1
          ELSE
            env_sect&=0
          ENDIF
        ELSE IF p$="ENVELOPE_TYPE"
          IF p2$="TONE"
            ss_menue%=1
          ELSE IF p2$="PANNING"
            ss_menue%=2
          ELSE
            ss_menue%=0
          ENDIF
        ELSE IF p$="ENVELOPE_COPY"
          env_copy&=MIN(MAX(VAL(p2$),1),64)
          '
          '
          '
          '
          '
          ' Sample Editor
          ' -------------
        ELSE IF p$="KEEP_BUFFER"
          IF first_time!
            IF p2$="TRUE"
              flag_keep_buffer!=TRUE
            ELSE
              flag_keep_buffer!=FALSE
            ENDIF
          ENDIF
          '
          ' Mix
          '
        ELSE IF p$="MIX_MASTER_VOLUME"
          se.mix_master_volume%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
          '
          ' Frequency
          '
        ELSE IF p$="FREQ_NEW_SAMPLE_FREQ"
          se.freq_nfe%=MIN(MAX(VAL(p2$),2000),65000)
        ELSE IF p$="FREQ_OLD_NOTE_FREQ"+STR$(se.freq_ofn%)
          se.freq_ofn%=MIN(MAX(VAL(p2$),20),32500)
        ELSE IF p$="FREQ_NEW_NOTE_FREQ"+STR$(se.freq_nfn%)
          se.freq_nfn%=MIN(MAX(VAL(p2$),20),32500)
        ELSE IF p$="FREQ_INTERPOLATION"""
          IF p2$="LINEAR"
            se.freq_iptype%=1
          ELSE IF p2$="3RD DEGREE"
            se.freq_iptype%=2
          ELSE
            se.freq_iptype%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_DISPLAY"
          IF p2$="LOGARITHMIC"
            se.freq_fftdisp%=1
          ELSE
            se.freq_fftdisp%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_WINDOW"
          IF p2$="BLACKMAN"
            se.freq_fftwin%=1
          ELSE
            se.freq_fftwin%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_NOTE_DISPLAY"
          IF p2$="FALSE"
            se.freq_fftnoteon!=FALSE
          ELSE
            se.freq_fftnoteon!=TRUE
          ENDIF
        ELSE IF p$="FREQ_FFT_NUM_OF_POINTS"
          se.freq_fft_pnbr%=MIN(MAX(VAL(p2$),1),1024)
          '
          ' Flanger
          '
        ELSE IF p$="FLANGER_DRY_LEVEL"
          se.flanger_dry%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_WET_LEVEL"
          se.flanger_wet%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_LEFT_SOURCE"
          se.flanger_lsource%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="FLANGER_RIGHT_SOURCE"
          se.flanger_rsource%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="FLANGER_DELAY"
          se.flanger_time%=MIN(MAX(VAL(p2$)*1000,0),10000)
        ELSE IF p$="FLANGER_FREQ"
          se.flanger_freq%=MIN(MAX(VAL(p2$)*1000,0),50000)
        ELSE IF p$="FLANGER_DEPTH"
          se.flanger_depth%=MIN(MAX(VAL(p2$)*1000,0),6350)
        ELSE IF p$="FLANGER_FDBK_L_L"
          se.flanger_fdbkll%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_L_R"
          se.flanger_fdbklr%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_R_R"
          se.flanger_fdbkrr%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_R_L"
          se.flanger_fdbkrl%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_INIT_PHASE"
          se.flanger_phase%=DIV(VAL(p2$)*4096,360) AND 4095
        ELSE IF p$="FLANGER_WAVE_TYPE"
          IF p2$="SQUARE"
            se.flanger_wave%=1
          ELSE IF p2$="TRIANGLE"
            se.flanger_wave%=2
          ELSE IF p2$="RAMPDOWN"
            se.flanger_wave%=3
          ELSE IF p2$="RAMPUP"
            se.flanger_wave%=4
          ELSE
            se.flanger_wave%=0
          ENDIF
        ELSE IF p$="FLANGER_STEREO"
          IF p2$="TRUE"
            se.flanger_stereo!=TRUE
          ELSE
            se.flanger_stereo!=FALSE
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  WEND
  CLOSE #0
RETURN
PROCEDURE save_prefs
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_prefs$<>""
      a$=npath_prefs$+nfile_prefs$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE PREFERENCES",0,0,PRED(scr_ncol%))
      FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING PREFERENCES "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_prefs2(a$)
      GOSUB separe_nom_chemin(a$)
      nfile_prefs$=nfile_$
      npath_prefs$=npath_$
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_prefs2(fic$)
  LOCAL i%
  LOCAL lig$
  OPEN "o",#0,fic$
  PRINT #0,";*****************************************************************************"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*                              GRAOUMF TRACKER                              *"
  PRINT #0,";*                        by Laurent de Soras 1994-95                        *"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*                              Preference file                              *"
  PRINT #0,";*                          Last update: "+LEFT$(DATE$+"  ",10)+"                          *"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*****************************************************************************"
  PRINT #0,"; Tab = 8"
  PRINT #0
  PRINT #0,"; Text following a "";"" is a comment and ignored by Graoumf Tracker."
  PRINT #0,"; In the file names, a ""/"" means no file."
  PRINT #0,"; ""$"" means the value is in hexadecimal."
  PRINT #0
  PRINT #0
  PRINT #0
  '
  '
  '
  PRINT #0,";============================================================================;"
  PRINT #0,";                       Main pannel                                          ;"
  PRINT #0,";============================================================================;"
  PRINT #0
  lig$="color_pal ="
  FOR i%=0 TO 15
    lig$=lig$+" "+HEX$(SHR(PEEK(ADD(&HFFFF9800,SHL(i%,2))),4),1)
    lig$=lig$+HEX$(SHR(PEEK(ADD(&HFFFF9801,SHL(i%,2))),4),1)
    lig$=lig$+HEX$(SHR(PEEK(ADD(&HFFFF9803,SHL(i%,2))),4),1)
  NEXT i%
  PRINT #0,lig$
  lig$=""
  GOSUB write_comment("RGB for 16 colors")
  lig$="number_of_tracks = "+STR$(nbr_track%)
  GOSUB write_comment("1-32")
  lig$="instrument = "+STR$(instr%)
  GOSUB write_comment("1-255")
  lig$="sample = "+STR$(sample%)
  GOSUB write_comment("1-255")
  lig$="preset = "+STR$(n_preset%)
  GOSUB write_comment("1-32")
  lig$="line_step = "+STR$(line_step%)
  GOSUB write_comment("Jump n-1 lines when entering a note")
  lig$="octave = "+STR$(SUCC(octave%))
  GOSUB write_comment("1-7")
  lig$="pattern_display = "+STR$(type_affpiste%)
  GOSUB write_comment("0 (without effect), 1 (normal) or 2 (with")
  GOSUB write_comment("volume column)")
  a%=DIV(SUB(scr_haut%,180),6) OR 1
  IF a%=haut_lig%
    a%=99999
  ELSE
    a%=haut_lig%
  ENDIF
  lig$="pattern_line_max = "+STR$(a%)
  GOSUB write_comment("Maximum number of lines displayed on screen.")
  GOSUB write_comment("99999 (or very high #) = resolution limit.")
  lig$="numpad = "+FN get_elt_in_list$("samples,drumkit",drumpad_flag%)
  GOSUB write_comment("samples, drumkit")
  lig$="menu = "+FN get_elt_in_list$("disk,tools,instruments,samples,envelopes",PRED(ss_menu%))
  GOSUB write_comment("disk, tools, instruments, samples, envelopes, control")
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Disk"
  PRINT #0,";------"
  PRINT #0
  lig$=";program_path = "+npath_prog$
  GOSUB write_comment("Path of GTPLAY.PGT and DUMTRACK.PGT. Usually")
  GOSUB write_comment("unused.")
  PRINT #0,"module_path = "+npath_module$
  PRINT #0,"sample_path = "+npath_sample$
  PRINT #0,"autoload_path = "+npath_autoload$
  PRINT #0,"pref_path = "+npath_prefs$
  PRINT #0,"misc_path = "+npath_div$
  PRINT #0
  PRINT #0,"module_ext = "+next_module$
  PRINT #0,"sample_ext = "+next_sample$
  PRINT #0
  PRINT #0,"module_file = ";
  IF nfile_module$<>""
    PRINT #0,nfile_module$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"sample_file = ";
  IF nfile_sample$<>""
    PRINT #0,nfile_sample$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"autoload_file = ";
  IF nfile_autoload$<>""
    PRINT #0,nfile_autoload$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"pref_file = ";
  IF nfile_prefs$<>""
    PRINT #0,nfile_prefs$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0
  PRINT #0,"save_config_gt2 = "+FN falsetrue$(flag_gt2cnf!)
  PRINT #0,"module_backup = "+FN falsetrue$(flag_backup_modules!)
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Tools"
  PRINT #0,";-------"
  PRINT #0
  lig$="block_type = "+FN get_elt_in_list$("track,pattern,preset",trackpat%)
  GOSUB write_comment("track, pattern, preset")
  lig$="block_song = "+FN falsetrue$(bl_flagsong!)
  GOSUB write_comment("If it's on the whole song or just 1 pattern")
  PRINT #0,"block_replace = "+FN falsetrue$(replaceblock%)
  PRINT #0,"block_mask = "+FN falsetrue$(maskblock%)
  ' block_mask1 = ??? ?? ???? ??	; * Not implemented *
  ' block_mask2 = ??? ?? ???? ??	; * Not implemented *
  lig$="tools_echo_step = "+STR$(bl_echo_lines%)
  GOSUB write_comment("1-64")
  lig$="tools_echo_fdbkval = "+STR$(bl_echo_feedback%)
  GOSUB write_comment("Feedback value (0-100 per cent)")
  lig$="tools_echo_fadestep = "+STR$(bl_echo_fadestep%)
  GOSUB write_comment("0-255")
  PRINT #0,"tools_echo_cont = "+FN falsetrue$(bl_echo_cont!)
  lig$="tools_echo_feedback = "+FN falsetrue$(bl_echo_fdbk!)
  GOSUB write_comment("Feedback (logarithmic fade) or linear fade")
  PRINT #0
  ' note_extension = ???? ??	; * Not implemented *
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Envelopes"
  PRINT #0,";-----------"
  PRINT #0
  lig$="envelope = "+STR$(env_num&)
  GOSUB write_comment("1-64")
  lig$="env_section = "+FN get_elt_in_list$("attack,keyoff",env_sect&)
  GOSUB write_comment("attack, keyoff")
  lig$="envelope_type = "+FN get_elt_in_list$("volume,tone,panning",ss_menue%)
  GOSUB write_comment("volume, tone, panning")
  lig$="envelope_copy = "+STR$(env_copy&)
  GOSUB write_comment("1-64")
  PRINT #0
  PRINT #0
  PRINT #0
  PRINT #0,";============================================================================;"
  PRINT #0,";                       Sample Editor                                        ;"
  PRINT #0,";============================================================================;"
  PRINT #0
  lig$="keep_buffer = "+FN falsetrue$(flag_keep_buffer!)
  GOSUB write_comment("true: keep better the buffer when loading")
  GOSUB write_comment("a module (but it's slower)")
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Mix"
  PRINT #0,";-----"
  PRINT #0
  lig$="mix_master_volume = "+FN pourcent$(se.mix_master_volume%,32768)
  GOSUB write_comment("%")
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Frequency"
  PRINT #0,";-----------"
  PRINT #0
  lig$="freq_new_sample_freq = "+STR$(se.freq_nfe%)
  GOSUB write_comment("Hz")
  lig$="freq_old_note_freq = "+STR$(se.freq_ofn%)
  GOSUB write_comment("Hz")
  lig$="freq_new_note_freq = "+STR$(se.freq_nfn%)
  GOSUB write_comment("Hz")
  lig$="freq_interpolation = "+FN get_elt_in_list$("none,linear,3rd degree",se.freq_iptype%)
  GOSUB write_comment("none, linear")
  lig$="freq_fft_display = "+FN get_elt_in_list$("linear,logarithmic",se.freq_fftdisp%)
  GOSUB write_comment("linear, logarithmic")
  lig$="freq_fft_window = "+FN get_elt_in_list$("rectangle,Blackman",se.freq_fftwin%)
  GOSUB write_comment("rectangle, Blackman")
  PRINT #0,"freq_fft_note_display = "+FN falsetrue$(se.freq_fftnoteon!)
  lig$="freq_fft_num_of_points = "+STR$(se.freq_fft_pnbr%)
  GOSUB write_comment("1-1024")
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Flanger"
  PRINT #0,";---------"
  PRINT #0
  lig$="flanger_dry_level = "+FN pourcent$(se.flanger_dry%,32768)
  GOSUB write_comment("%")
  lig$="flanger_wet_level = "+FN pourcent$(se.flanger_wet%,32768)
  GOSUB write_comment("%")
  lig$="flanger_left_source = "
  IF se.flanger_lsource%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.flanger_lsource%)
  ENDIF
  GOSUB write_comment("Left source: buffer or sample # (1-255)")
  lig$="flanger_right_source = "
  IF se.flanger_rsource%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.flanger_rsource%)
  ENDIF
  GOSUB write_comment("Right source: buffer or sample # (1-255)")
  lig$="flanger_delay = "+STR$(se.flanger_time%/1000)
  GOSUB write_comment("Flanger delay (ms). Maximum: 10 ms")
  lig$="flanger_freq = "+STR$(se.flanger_freq%/1000)
  GOSUB write_comment("Flanger LFO frequency (Hz). Maximum: 50 Hz")
  lig$="flanger_depth = "+STR$(se.flanger_depth%/1000)
  GOSUB write_comment("Flanger depth (ms). Maximum: 6.35 ms")
  lig$="flanger_fdbk_l_l = "+FN pourcent$(se.flanger_fdbkll%,32768)
  GOSUB write_comment("Feedback Left -> Left (%)")
  lig$="flanger_fdbk_l_r = "+FN pourcent$(se.flanger_fdbklr%,32768)
  GOSUB write_comment("Feedback Left -> Right (%)")
  lig$="flanger_fdbk_r_r = "+FN pourcent$(se.flanger_fdbkrr%,32768)
  GOSUB write_comment("Feedback Right -> Right (%)")
  lig$="flanger_fdbk_r_l = "+FN pourcent$(se.flanger_fdbkrl%,32768)
  GOSUB write_comment("Feedback Right -> Left (%)")
  lig$="flanger_init_phase = "+STR$(MUL(se.flanger_phase%,360)/4096)
  GOSUB write_comment("Initial phase (0-359¯)")
  lig$="flanger_wave_type = "+FN get_elt_in_list$("sin,square,triangle,rampdown,rampup",se.flanger_wave%)
  GOSUB write_comment("sin, square, triangle, rampdown or rampup")
  lig$="flanger_stereo = "+FN falsetrue$(se.flanger_stereo!)
  GOSUB write_comment("false = mono, true = stereo")
  PRINT #0
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; End of file"
  CLOSE #0
RETURN
PROCEDURE write_comment(a$)
  ' Ecrit sur le fichier #0 un commentaire au bout de la variable lig$
  ' Utilise et modifie lig$
  lig$=lig$+STRING$(MAX(SUCC(DIV(SUB(31,LEN(lig$)),8)),1),9)
  lig$=lig$+"; "+a$
  PRINT #0,lig$
  lig$=""
RETURN
PROCEDURE make_directory
  LOCAL a$,bouton%
  CLS
  GOSUB cadre_texte("MAKE NEW DIRECTORY",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    CLS
    GOSUB separe_nom_chemin(a$)
    IF nfile_$<>""
      GOSUB dialog("DISK","Do you really want|to create a new directory|"+a$+"\|ON DISK ?","YES|CANCEL",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("CREATING DIRECTORY "+a$+"\...",0,0,PRED(scr_ncol%))
        MKDIR a$
        npath_div$=a$+"\"
      ENDIF
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE delete_directory
  LOCAL bouton%,e%
  LOCAL a$,b$
  CLS
  GOSUB cadre_texte("DELETE DIRECTORY",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    CLS
    GOSUB separe_nom_chemin(a$)
    IF FN exist(npath_$+"*.*")
      GOSUB dialog("STOP","Directory|"+npath_$+"|must be empty","Cancel",MOUSEX,MOUSEY)
    ELSE
      GOSUB dialog("DISK","Do you really want|to delete directory|"+npath_$+"|on disk ?","Ok|Cancel",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("DELETING DIRECTORY "+npath_$+"...",0,0,PRED(scr_ncol%))
        a$=LEFT$(npath_$,PRED(LEN(npath_$)))
        b$=a$+CHR$(0)
        e%=GEMDOS(58,L:V:b$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+"during deleting directory|"+a$+"\","Cancel",MOUSEX,MOUSEY)
        ENDIF
        GOSUB separe_nom_chemin(a$)
        npath_div$=npath_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE delete_file
  LOCAL bouton%,e%
  LOCAL b$
  CLS
  GOSUB cadre_texte("DELETE FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB dialog("FILE","Do you really|want to delete|"+a$+"|on disk ?","Ok|Cancel",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("DELETING FILE "+a$+"...",0,0,PRED(scr_ncol%))
        b$=a$+CHR$(0)
        e%=GEMDOS(65,L:V:a$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+" during deleting|file "+a$,"Cancel",MOUSEX,MOUSEY)
        ENDIF
        GOSUB separe_nom_chemin(a$)
        npath_div$=npath_$
      ENDIF
    ELSE
      GOSUB dialog("FILE","File not found:|"+a$,"Cancel",MOUSEX,MOUSEY)
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE format_disk                   !!!
RETURN
PROCEDURE rename_file
  LOCAL e%
  LOCAL a$,b$,c$,d$,e$,f$
  ~FRE(0)
  CLS
  GOSUB cadre_texte("RENAME A FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("SELECT NEW NAME OF "+a$,0,0,PRED(scr_ncol%))
      GOSUB separe_nom_chemin(a$)
      npath_div$=npath_$
      c$=nfile_$
      FILESELECT npath_div$+"*.*",c$,b$
      GOSUB separe_nom_chemin(b$)
      d$=nfile_$
      IF d$<>"" AND d$<>c$ AND npath_$=npath_div$
        CLS
        GOSUB cadre_texte("RENAMING "+a$+" AS "+d$+"...",0,0,PRED(scr_ncol%))
        f$=a$+CHR$(0)
        e$=b$+CHR$(0)
        e%=GEMDOS(86,0,L:V:f$,L:V:e$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+" during renaming.","Ok",MOUSEX,MOUSEY)
        ENDIF
      ELSE IF npath_$<>npath_div$
        GOSUB dialog("RENAME","Old and new file|must be in the|same path!","Cancel",MOUSEX,MOUSEY)
      ENDIF
    ELSE
      GOSUB dialog("FILE","File not found:|"+a$,"Cancel",MOUSEX,MOUSEY)
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE separe_nom_chemin(aaaa$)
  ' Chercher le nom et le chemin
  ' Renvoie npath_$ et nfile_$
  LOCAL iiii%,flag%
  nfile_$=""
  npath_$=""
  flag%=0
  FOR iiii%=LEN(aaaa$) DOWNTO 1
    IF MID$(aaaa$,iiii%,1)="\" AND flag%=0
      flag%=1
      npath_$=LEFT$(aaaa$,iiii%)
    ELSE IF flag%=0
      nfile_$=MID$(aaaa$,iiii%,1)+nfile_$
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE selpath_module
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR MODULE",0,0,PRED(scr_ncol%))
  FILESELECT npath_module$+next_module$,nfile_module$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_module$=nfile_$
    npath_module$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_sample
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR SAMPLE",0,0,PRED(scr_ncol%))
  FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_sample$=nfile_$
    npath_sample$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_prefs
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR PREFERENCE FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_prefs$=nfile_$
    npath_prefs$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_autoload
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR AUTOLOAD",0,0,PRED(scr_ncol%))
  FILESELECT npath_autoload$+next_module$,nfile_autoload$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_autoload$=nfile_$
    npath_autoload$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
'
' Procedures diverses
' -------------------
PROCEDURE dialog(tit$,txt$,but$,x%,y%)
  ' Boite de dialogue. txt$=texte, | pour changer de ligne, but$=boutons, | pour separer les boutons
  ' x% et y% milieu de la boite, tit$ titre
  ' Renvoie bouton% (0 - n-1)
  LOCAL a%,b%,i%,j%,ntxt%,nbut%,oldp%,ox%,ox2%,oy%,oy2%,p%,tmax1%,tmax2%,tx%,ty%
  LOCAL xm%,xm2%,ym%,km%
  LOCAL ok!
  LOCAL ptxt$,pbut$
  HIDEM
  '
  ' Recherche du nombre de lignes de texte, indices et longueurs
  '
  ptxt$=""
  p%=1
  oldp%=p%
  ntxt%=1
  tmax1%=0
  REPEAT
    IF MID$(txt$,p%,1)="|"
      ptxt$=ptxt$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
      tmax1%=MAX(tmax1%,SUB(p%,oldp%))
      oldp%=SUCC(p%)
      INC ntxt%
    ENDIF
    INC p%
  UNTIL p%>LEN(txt$)
  ptxt$=ptxt$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
  tmax1%=MAX(tmax1%,SUB(p%,oldp%))
  '
  ' Recherche du nombre de boutons, indices et longueurs
  '
  pbut$=""
  p%=1
  oldp%=p%
  nbut%=1
  tmax2%=6
  REPEAT
    IF MID$(but$,p%,1)="|"
      pbut$=pbut$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
      tmax2%=MAX(tmax2%,SUB(p%,oldp%))
      oldp%=SUCC(p%)
      INC nbut%
    ENDIF
    INC p%
  UNTIL p%>LEN(but$)
  pbut$=pbut$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
  tmax2%=MAX(tmax2%,SUB(p%,oldp%))
  ADD tmax2%,2                                  ! 1 espace de chaque cote du bouton
  '
  ' Definition de la taille de la boite
  '
  tx%=MAX(ADD(tmax1%,4),MUL(ADD(tmax2%,2),nbut%))
  ty%=ADD(MUL(ntxt%,8),34)                      ! 1+ 12 + 1+4+(8*l-2)+4+1 + 1+1+8+1+1 +1
  ox%=MIN(MAX(SUB(SHR(x%,3),SHR(tx%,1)),0),SUB(scr_ncol%,SUCC(tx%)))
  oy%=MIN(MAX(SUB(y%,SUB(ty%,6)),0),SUB(scr_haut%,ADD(ty%,4)))
  ox2%=SUB(ADD(ox%,tx%),PRED(MUL(ADD(tmax2%,2),nbut%)))
  oy2%=ADD(oy%,SUB(ty%,12))
  '
  ' Affichage de la boite
  '
  GOSUB cadre_int(SUCC(ox%),ADD(oy%,4),PRED(tx%),PRED(ty%),0,0,0,0)
  GOSUB cadre_int(ox%,oy%,PRED(tx%),PRED(ty%),9,9,10,8)
  GOSUB cadre_ext(SUCC(ox%),ADD(oy%,14),SUB(tx%,3),ADD(SHL(ntxt%,3),5),1,9,8,10)
  IF tit$<>""
    GOSUB affchaine_trans(tit$,SHL(SUCC(ox%),1),ADD(oy%,4),8)
  ENDIF
  ' Le texte
  FOR i%=0 TO PRED(ntxt%)
    a%=CARD{ADD(V:ptxt$,SHL(i%,2))}
    b%=CARD{ADD(V:ptxt$,ADD(SHL(i%,2),2))}
    ' GOSUB affchaine_trans(MID$(txt$,a%,b%),SUB(ADD(SHL(ox%,1),tx%),b%),ADD(ADD(oy%,18),SHL(i%,3)),0)
    ' Texte centre ----^
    GOSUB affchaine_trans(MID$(txt$,a%,b%),ADD(SHL(ox%,1),4),ADD(ADD(oy%,18),SHL(i%,3)),0)
  NEXT i%
  ' Les boutons
  FOR i%=0 TO PRED(nbut%)
    GOSUB cadre_texte_b(MID$(but$,CARD{ADD(V:pbut$,SHL(i%,2))},CARD{ADD(V:pbut$,ADD(SHL(i%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),i%)),oy2%,PRED(tmax2%))
  NEXT i%
  '
  ' Gestion de la souris et du clavier
  '
  SHOWM
  GOSUB wait_mouse(TRUE)
  bouton%=-1                                    ! Aucun bouton selectionne pour l'instant
  ok!=FALSE
  REPEAT
    REPEAT
      km%=MOUSEK
    UNTIL km%<>0 OR GEMDOS(11)<>0               ! Attend qu'on appuie sur le bouton de la souris ou une touche
    IF km%<>0
      ' --- Gestion souris ---
      REPEAT                                    ! Quand on appuie, la selection des boutons suit
        MOUSE xm%,ym%,km%                       ! la souris jusqu'au relachement
        xm2%=SHR(xm%,3)
        a%=DIV(SUB(xm2%,ox2%),ADD(tmax2%,2))
        b%=SUB(xm2%,ox2%) MOD ADD(tmax2%,2)
        IF a%>=0 AND a%<nbut% AND b%<tmax2% AND ym%>=oy2% AND ym%<ADD(oy2%,10)  ! On est bien sur un bouton, a% en est son numero
          IF a%<>bouton%                    ! Si on a change de bouton depuis la derniere fois,
            IF bouton%>=0                   ! Deselectionne le precedent bouton
              GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
            ENDIF
            bouton%=a%
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),1)
            ok!=TRUE
          ENDIF
        ELSE                                ! On n'est plus sur un bouton
          IF bouton%>=0                     ! Deselectionne le precedent bouton
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
          ENDIF
          bouton%=-1
          ok!=FALSE
        ENDIF
        SHOWM
      UNTIL km%=0
    ELSE
      ' --- Gestion clavier ---
      a%=GEMDOS(7) AND 255                      ! Caractere ASCII
      IF a%=>48 AND a%<58                       ! <1> - <0>
        a%=SUB(a%,39) MOD 10                    ! "1" > 0, ... "9" > 8, "0" > 9
        IF a%<nbut%                             ! a% numero du bouton selectionne
          IF bouton%>=0                         ! Deselectionne le precedent bouton
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
          ENDIF
          bouton%=a%
          GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),1)
        ENDIF
        ok!=FALSE
      ELSE IF a%=13 AND bouton%>=0              ! <Return>
        ok!=TRUE
      ENDIF
      SHOWM
    ENDIF
  UNTIL bouton%>=0 AND ok!
RETURN
PROCEDURE wait_mouse(flag!)
  IF flag!
    REPEAT
    UNTIL MOUSEK=0
  ENDIF
RETURN
PROCEDURE bee(flag!)
  ' Souris en forme de fleche (False) ou d'abeille (True)
  HIDEM
  DEFMOUSE flag! AND 2
  SHOWM
RETURN
PROCEDURE intel_w(aaaa%)
  LOCAL bbbb%
  bbbb%=BYTE{SUCC(aaaa%)}
  BYTE{SUCC(aaaa%)}=BYTE{aaaa%}
  BYTE{aaaa%}=bbbb%
RETURN
PROCEDURE intel_l(aaaa%)
  LOCAL bbbb%
  bbbb%=BYTE{ADD(aaaa%,3)}
  BYTE{ADD(aaaa%,3)}=BYTE{aaaa%}
  BYTE{aaaa%}=bbbb%
  bbbb%=BYTE{SUCC(aaaa%)}
  BYTE{SUCC(aaaa%)}=BYTE{ADD(aaaa%,2)}
  BYTE{ADD(aaaa%,2)}=bbbb%
RETURN
PROCEDURE mem_rotation(aaaa%,llll%,dddd%)
  ' Rotation de memoire :
  ' adresse aaaa%, longueur llll%, deplacement dddd%
  LOCAL bbbb%,aaaa$
  IF llll%>0
    dddd%=dddd% MOD llll%                 ! Meilleure direction de deplacement
    IF ABS(dddd%)>SHR(llll%,2)
      SUB dddd%,MUL(llll%,SGN(dddd%))
    ENDIF
    aaaa$=STRING$(16384,0)                ! Par blocs de 16 Ko
    IF dddd%=>0
      WHILE dddd%>0                       ! Deplacement positif (vers la droite)
        bbbb%=MIN(dddd%,16384)
        ~C:g_bmove%(L:ADD(aaaa%,SUB(llll%,bbbb%)),L:V:aaaa$,L:bbbb%)
        ~C:g_bmove%(L:aaaa%,L:ADD(aaaa%,bbbb%),L:SUB(llll%,bbbb%))
        ~C:g_bmove%(L:V:aaaa$,L:aaaa%,L:bbbb%)
        SUB dddd%,bbbb%
      WEND
    ELSE
      WHILE dddd%<0                       ! Deplacement negatif (vers la gauche)
        bbbb%=MIN(-dddd%,16384)
        ~C:g_bmove%(L:aaaa%,L:V:aaaa$,L:bbbb%)
        ~C:g_bmove%(L:ADD(aaaa%,bbbb%),L:aaaa%,L:SUB(llll%,bbbb%))
        ~C:g_bmove%(L:V:aaaa$,L:ADD(aaaa%,SUB(llll%,bbbb%)),L:bbbb%)
        ADD dddd%,bbbb%
      WEND
    ENDIF
  ENDIF
RETURN
PROCEDURE clear_mem(aaaa%,llll%)
  ' Vide une partie de la memoire (methode rapide en GfA)
  ' aaaa% = adresse, llll% = longueur
  ' Ne fait rien si longueur <= 0
  LOCAL l_clr%
  ~FRE(0)
  IF llll%>0
    l_clr%=1
    BYTE{aaaa%}=0                               ! Efface le premier octet
    WHILE l_clr%<=SHR(llll%,1)                  ! Efface au moins la moitie du
      BMOVE aaaa%,ADD(aaaa%,l_clr%),l_clr%      ! buffer par doublages successifs
      ADD l_clr%,l_clr%                         ! de la surface effacee
    WEND
    BMOVE aaaa%,ADD(aaaa%,l_clr%),SUB(llll%,l_clr%)     ! Le reste
  ENDIF
RETURN
PROCEDURE decale_sample(i%,nbs%,adi%)
  ' adi$ commence au sample 1 et contient des adresses
  LOCAL a%,b%,c%,d%,j%,pt%
  a%=FN length(i%)
  d%=FN adresse(i%)
  b%=ADD(a%,d%)
  pt%=LONG{ADD(adi%,SHL(PRED(i%),2))}
  IF a%>0
    j%=i%                       ! Scanne les samples suivants
    WHILE j%<nbs%
      c%=LONG{ADD(adi%,SHL(j%,2))}
      EXIT IF c%<b% AND c%>d%
      INC j%
    WEND
    IF j%<nbs% OR flag_keep_buffer!     ! On a trouve un sample qui va se faire ecraser alors on tourne
      GOSUB mem_rotation(d%,SUB(ADD(pt%,a%),d%),a%)
      IF i%<nbs%                        ! Repositionne les samples qui etaient avant celui-la
        FOR j%=SHL(i%,2) TO SHL(PRED(nbs%),2) STEP 4
          IF LONG{ADD(adi%,j%)}<pt%
            LONG{ADD(adi%,j%)}=ADD(LONG{ADD(adi%,j%)},a%)
          ENDIF
        NEXT j%
      ENDIF
      ADD translate%,a%
    ELSE                        ! Pas de probleme, on effectue une simple copie et un deplacement du reste
      IF i%<255
        ~C:g_bmove%(L:d%,L:b%,L:SUB(FN adr_buffer,d%))
      ENDIF
      ~C:g_bmove%(L:pt%,L:d%,L:a%)
    ENDIF
    IF i%<255                   ! Reajuste les adresses des samples suivants
      FOR j%=SHL(SUCC(i%),2) TO &H3FC STEP 4
        LONG{ADD(r_adr_sample%,j%)}=ADD(LONG{ADD(r_adr_sample%,j%)},a%)
      NEXT j%
    ENDIF
  ENDIF
RETURN
PROCEDURE vide_buffer_clavier
  WHILE GEMDOS(11)<>0
    ~GEMDOS(7)
  WEND
RETURN
PROCEDURE play_pattern_bidon
  DPOKE r_mod_songrep%,1
  DPOKE r_mod_songlen%,2
  DPOKE r_mod_songpos%,0
  DPOKE r_mod_numpat%,256
  DPOKE r_mod_patrep%,0
  LPOKE r_adr_module%,V:module_bidon%(0)
  LPOKE r_adr_song%,V:song_bidon%(0)
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
RETURN
PROCEDURE play_song(a%)
  GOSUB play_song2(a%)
  GOSUB aff_ps_pp_e
  GOSUB aff_message("Playing song...")
RETURN
PROCEDURE play_song2(a%)
  GOSUB stop_voices
  play%=1
  LPOKE r_adr_module%,V:module&(0)
  LPOKE r_adr_song%,V:song&(0)
  DPOKE r_mod_songrep%,module&(102)
  DPOKE r_mod_songlen%,module&(101)
  DPOKE r_mod_songpos%,songpos%
  DPOKE r_mod_numpat%,song&(songpos%)
  IF a%=0
    DPOKE r_mod_linepos%,0
  ELSE
    DPOKE r_mod_linepos%,posligne%
  ENDIF
  DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
  debut_temps%=TIMER
  IF edit%=0
    SLPOKE &HFFFF983C,&HE00000  ! Vert
  ENDIF
RETURN
PROCEDURE play_pattern(a%)
  GOSUB stop_voices
  play%=2
  LPOKE r_adr_module%,V:module&(0)
  LPOKE r_adr_song%,V:song&(0)
  DPOKE r_mod_songrep%,songpos%
  DPOKE r_mod_songlen%,SUCC(songpos%)
  DPOKE r_mod_songpos%,songpos%
  DPOKE r_mod_numpat%,song&(songpos%)
  IF a%=0
    DPOKE r_mod_linepos%,0
  ELSE
    DPOKE r_mod_linepos%,posligne%
  ENDIF
  DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
  debut_temps%=TIMER
  GOSUB aff_ps_pp_e
  GOSUB aff_message("Playing pattern...")
  IF edit%=0
    SLPOKE &HFFFF983C,&HFF800000  ! Jaune
  ENDIF
RETURN
PROCEDURE stop_voices
  LOCAL i%
  FOR i%=0 TO PRED(nbr_track%)
    LONG{ADD(V:pattern_bidon%(8),MUL(i%,5))}=0
  NEXT i%
  GOSUB play_pattern_bidon
  DPOKE r_flag_stop_voices%,1
  play%=0
  IF edit%=0
    SLPOKE &HFFFF983C,&HFFFF00FF  ! Blanc
  ELSE
    SLPOKE &HFFFF983C,&HFF        ! Bleu
  ENDIF
  REPEAT
  UNTIL DPEEK(r_flag_stop_voices%)=0
RETURN
PROCEDURE stop_edit
  IF play%<>0
    IF play%=1
      GOSUB aff_message("Song stopped.")
    ELSE
      GOSUB aff_message("Pattern stopped.")
    ENDIF
    GOSUB stop_voices
    edit%=0
    SLPOKE &HFFFF983C,&HFFFF00FF                ! Blanc
  ELSE
    GOSUB stop_voices
    IF edit%=0
      edit%=1
      SLPOKE &HFFFF983C,&HFF                    ! Bleu
      GOSUB aff_message("Edit mode activated.")
    ELSE
      edit%=0
      SLPOKE &HFFFF983C,&HFFFF00FF              ! Blanc
      GOSUB aff_message("Edit mode deactivated.")
    ENDIF
  ENDIF
  GOSUB aff_ps_pp_e
RETURN
PROCEDURE balance_reset
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_balance(i%,MUL(SHR(SUCC(i%),1) AND 1,&HFFF))
  NEXT i%
RETURN
PROCEDURE set_balance(a$)
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_balance(i%,CARD{ADD(V:a$,SHL(i%,1))})
  NEXT i%
RETURN
PROCEDURE all_track_on(flag!)
  LOCAL i%
  FOR i%=0 TO 31
    DPOKE ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,i%)),1
    IF flag!
      GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(8,SHL(i%,1)),120,1,FN track_onoff(i%) XOR 1)
    ENDIF
  NEXT i%
RETURN
PROCEDURE kill_sample(s%)
  GOSUB stop_voices
  GOSUB chg_taille_sample(s%,0)
  a$="SAMP"+MKL$(64)+MKI$(s%)+SPACE$(28)+MKI$(0)+MKI$(&HFFFF)+MKI$(8)+MKI$(8363)+MKL$(0)+MKL$(0)+MKL$(2)+MKI$(0)+MKI$(0)+MKI$(0)
  BMOVE V:a$,FN adrsamchk(s%),64
RETURN
PROCEDURE clear_patterns2
  ' Se contente de reduire les patterns a leur taille minimum
  LOCAL a%,b%,c%,i%,a$
  c%=1                                          ! 1 seule ligne pour tous les patterns vides
  b%=FN zone_start
  a%=ADD(MUL(MUL(c%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(c%)+MKI$(nbr_track%)
  FOR i%=0 TO 255
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB chg_pat_chunkadr(i%,b%)
    ADD b%,a%
  NEXT i%
  bl_start&=0
  bl_end&=0
  bl_pat&=0
RETURN
PROCEDURE clear_patterns
  LOCAL i%
  GOSUB clear_patterns2
  FOR i%=0 TO 255
    GOSUB clear_mem(FN adr_pat(i%),MUL(MUL(FN nbr_track(i%),FN nbr_lines(i%)),5))
  NEXT i%
  GOSUB garbage_collection
RETURN
PROCEDURE clear_song(flag!)
  ' Efface la song et les patterns
  ' Si flag! est faux, songname n'est pas efface
  LOCAL a%,b%,i%
  GOSUB stop_voices
  ARRAYFILL song&(),0
  GOSUB clear_patterns
  IF flag!
    FOR i%=2 TO 97
      module&(i%)=&H2020
    NEXT i%
  ENDIF
  module&(101)=1
  module&(102)=0
  songpos%=0
RETURN
PROCEDURE clear_samples
  ' Efface les samples
  GOSUB stop_voices
  GOSUB clear_samples2
  sample%=1
RETURN
PROCEDURE clear_samples2
  LOCAL i%,j%,a$
  j%=ADD(FN env_chunkadr(63,2),FN env_chunklen(63,2))
  a$="SAMP"+MKL$(64)+MKI$(0)+SPACE$(28)+MKI$(0)+MKI$(&HFFFF)+MKI$(8)+MKI$(8363)+MKL$(0)+MKL$(0)+MKL$(2)+MKI$(0)+MKI$(0)+MKI$(0)
  FOR i%=0 TO 255
    LONG{ADD(r_adr_sample%,SHL(i%,2))}=ADD(j%,MUL(i%,64))
    BMOVE V:a$,LONG{ADD(r_adr_sample%,SHL(i%,2))},64
    CARD{ADD(LONG{ADD(r_adr_sample%,SHL(i%,2))},8)}=i%
  NEXT i%
  GOSUB garbage_collection
RETURN
PROCEDURE clear_instr
  ' Efface les instruments (seulement les instr+env, pas les samples)
  LOCAL a%,b%,i%,j%
  FOR i%=0 TO 255
    instrset%(0,i%)=&H494E5354                  ! 'INST'
    instrset%(1,i%)=316                         ! Taille du chunk
    instrset%(2,i%)=ADD(SHL(i%,16),&H2020)      ! Numero + Nom
    FOR j%=3 TO 8
      instrset%(j%,i%)=&H20202020               ! Nom
    NEXT j%
    instrset%(9,i%)=&H20200000                  ! Nom + Type (sample)
    instrset%(10,i%)=&H100FFFF                  ! Volume + Autobalance
    instrset%(11,i%)=0                          ! Enveloppe volume + tonalite
    instrset%(12,i%)=0                          ! Enveloppe panning + reserve
    instrset%(13,i%)=0                          ! Reserve
    instrset%(14,i%)=0                          ! Reserve
    instrset%(15,i%)=SHL(i%,8)
    a%=ADD(SHL(i%,24),SHL(i%,8))
    b%=V:instrset%(16,i%)
    LONG{b%}=a%
    BMOVE b%,ADD(b%,4),4                        ! Remplit 252 octets avec le meme mot
    BMOVE b%,ADD(b%,8),8
    BMOVE b%,ADD(b%,16),16
    BMOVE b%,ADD(b%,32),32
    BMOVE b%,ADD(b%,64),64
    BMOVE b%,ADD(b%,128),124
  NEXT i%
  GOSUB clear_enveloppes
RETURN
PROCEDURE clear_enveloppes
  ' Efface les enveloppes de volume, tonalite et panning
  ' Dans la mem, les env sont rangees dans cet ordre : V T P  V T P  V T P...
  LOCAL i%,a%,deb%
  deb%=ADD(FN adr_patchunk(255),FN lon_patchunk(255))
  FOR i%=0 TO 63
    a%=ADD(deb%,MUL(i%,102))
    LONG{a%}=&H56454E56         ! 'VENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,0,a%)
    a%=ADD(ADD(deb%,34),MUL(i%,102))
    LONG{a%}=&H54454E56         ! 'TENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,1,a%)
    a%=ADD(ADD(deb%,68),MUL(i%,102))
    LONG{a%}=&H50454E56         ! 'PENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,2,a%)
  NEXT i%
  env_poscurs&=0
  env_posaff&=0
  GOSUB garbage_collection
RETURN
PROCEDURE garbage_collection
  ' Regroupe les patterns, enveloppes et samples
  ' dans cet ordre, en bas de la memoire.
  ' garbage% aurorise la manipulation de chaque type de chunk
  LOCAL i%,j%,na%,oa%,l%
  ' Les patterns
  IF garbage%>0
    FOR i%=0 TO 255
      oa%=FN adr_patchunk(i%)
      IF i%>0
        na%=ADD(FN adr_patchunk(PRED(i%)),FN lon_patchunk(PRED(i%)))
      ELSE
        na%=FN zone_start
      ENDIF
      IF oa%<>na%
        l%=FN lon_patchunk(i%)
        GOSUB chg_pat_chunkadr(i%,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
  ' Les enveloppes
  IF garbage%>1
    FOR i%=0 TO 191
      oa%=FN env_chunkadr(DIV(i%,3),i% MOD 3)
      IF i%>0
        na%=ADD(FN env_chunkadr(DIV(PRED(i%),3),PRED(i%) MOD 3),FN env_chunklen(DIV(PRED(i%),3),PRED(i%) MOD 3))
      ELSE
        na%=ADD(FN adr_patchunk(255),FN lon_patchunk(255))
      ENDIF
      IF oa%<>na%
        l%=FN env_chunklen(DIV(i%,3),i% MOD 3)
        GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
  ' Les samples
  IF garbage%>2
    FOR i%=0 TO 255
      oa%=FN adrsamchk(i%)
      IF i%>0
        na%=ADD(FN adrsamchk(PRED(i%)),FN lonsamchk(PRED(i%)))
      ELSE
        na%=ADD(FN env_chunkadr(63,2),FN env_chunklen(63,2))
      ENDIF
      IF oa%<>na%
        l%=FN lonsamchk(i%)
        GOSUB chg_sam_chunkadr(i%,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
RETURN
PROCEDURE create_space_patchunk(p%,t%,l%,flag!)
  ' Demenage la memoire pour obtenir un pattern de t% tracks, l% lignes
  ' Le header du chunk est modifie mais pas les donnees du pattern
  ' Si flag! n'est pas mis, seulement les patterns seront deplaces (on devra
  ' avoir verifie que la place pour cette operation a bien ete inseree entre
  ' les patterns et les enveloppes).
  LOCAL a%,b%,c%,i%,oldlen%,newlen%,dif%
  IF p%<255
    oldlen%=SUB(FN adr_patchunk(SUCC(p%)),FN adr_patchunk(p%))
  ELSE
    oldlen%=SUB(FN env_chunkadr(0,0),FN adr_patchunk(p%))
  ENDIF
  newlen%=ADD(MUL(MUL(t%,l%),5),32)
  dif%=SUB(newlen%,oldlen%)
  IF dif%<>0
    a%=ADD(FN adr_patchunk(p%),oldlen%)
    b%=ADD(FN adr_patchunk(p%),newlen%)
    c%=SUB(FN adr_buffer,a%)
    IF p%<255
      FOR i%=SUCC(p%) TO 255                      ! Change les adresses des patterns
        GOSUB chg_pat_chunkadr(i%,ADD(FN adr_patchunk(i%),dif%))
      NEXT i%
    ENDIF
    IF flag!
      FOR i%=0 TO 191                             ! Change les adresses des enveloppes
        GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),dif%))
      NEXT i%
      FOR i%=0 TO 255                             ! Change les adresses des samples
        GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
      NEXT i%
    ENDIF
    IF flag!
      ~C:g_bmove%(L:a%,L:b%,L:c%)
    ELSE IF p%<255
      ~C:g_bmove%(L:a%,L:b%,L:SUB(FN env_chunkadr(0,0),MAX(a%,b%)))
    ENDIF
  ENDIF
  GOSUB chg_pat_chunklen(p%,newlen%)
  GOSUB chg_pat_nbr_lines(p%,l%)
  GOSUB chg_pat_nbr_track(p%,t%)
RETURN
PROCEDURE create_space_multipatchunk(map$,nbp%,flag!)
  ' Comme ci-dessus mais pour plusieurs patterns (0...nbp%-1)
  ' map$ contient (NbTi.w,NbLi.w), i de 0 a nbp%-1
  ' Tous les chunks sont bien deplaces
  ' Si flag! est mis, les nouveaux patterns crees sont nettoyes
  LOCAL a%,b%,c%,d%,i%,dif%
  LOCAL a$
  ' Calcul de la place occupee par ces nouveaux patterns
  a%=0
  FOR i%=0 TO PRED(nbp%)
    ADD a%,ADD(MUL(MUL(CARD{ADD(V:map$,SHL(i%,2))},CARD{ADD(V:map$,ADD(SHL(i%,2),2))}),5),32)
  NEXT i%
  IF nbp%<256
    dif%=SUB(ADD(FN zone_start,a%),FN adr_patchunk(nbp%))
    ~C:g_bmove%(L:FN adr_patchunk(nbp%),L:ADD(FN zone_start,a%),L:SUB(FN adr_buffer,FN adr_patchunk(nbp%)))
    FOR i%=nbp% TO 255                            ! Change les adresses des patterns suivants
      GOSUB chg_pat_chunkadr(i%,ADD(FN adr_patchunk(i%),dif%))
    NEXT i%
    FOR i%=0 TO 191                               ! Change les adresses des enveloppes
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),dif%))
    NEXT i%
    FOR i%=0 TO 255                               ! Change les adresses des samples
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
    NEXT i%
  ELSE
    GOSUB create_space_for_patterns(SUB(a%,SUB(FN env_chunkadr(0,0),FN zone_start)))
  ENDIF
  ' Creation des nouveaux chunks a la bonne taille
  b%=FN zone_start
  FOR i%=0 TO PRED(nbp%)
    c%=CARD{ADD(V:map$,SHL(i%,2))}
    d%=CARD{ADD(V:map$,ADD(SHL(i%,2),2))}
    a%=ADD(MUL(MUL(c%,d%),5),32)
    a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(d%)+MKI$(c%)
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB chg_pat_chunkadr(i%,b%)
    IF flag!
      GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    ENDIF
    ADD b%,a%
  NEXT i%
RETURN
PROCEDURE create_space_for_patterns(l%)
  ' Deplace les chunks des enveloppes et des samples de facon a laisser
  ' l% octets en plus pour les patterns.
  LOCAL a%,b%,c%,i%
  IF l%>0
    a%=FN env_chunkadr(0,0)
    b%=ADD(a%,l%)
    c%=SUB(FN adr_buffer,a%)
    FOR i%=0 TO 191                               ! Change les adresses des enveloppes
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),l%))
    NEXT i%
    FOR i%=0 TO 255                               ! Change les adresses des samples
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),l%))
    NEXT i%
    ~C:g_bmove%(L:a%,L:b%,L:c%)
  ENDIF
RETURN
PROCEDURE change_pattern_high(p%,l%)
  LOCAL ol%
  ol%=FN nbr_lines(p%)
  GOSUB create_space_patchunk(p%,nbr_track%,l%,TRUE)
  IF l%>ol%
    GOSUB clear_mem(FN adr_line(p%,ol%),MUL(MUL(nbr_track%,SUB(l%,ol%)),5))
  ENDIF
  IF p%=bl_pat&
    bl_end&=MIN(bl_end&,PRED(l%))
    bl_start&=MIN(bl_start&,bl_end&)
  ENDIF
RETURN
PROCEDURE change_format(t%)
  LOCAL bouton%,a$,a%
  a$="DO YOU REALLY WANT TO CHANGE THE|PATTERN SIZE TO "+STR$(t%)+" TRACKS ?"
  IF t%<nbr_track%
    a$=a$+"|"+STR$(SUB(nbr_track%,t%))+" TRACK(S) WILL BE LOST"
    a$=a$+"||1. New song|2. Try to keep the song|3. Abort the operation"
  ENDIF
  GOSUB dialog("CHANGE NUMBER OF TRACKS",a$,"NEW|KEEP|CANCEL",xm%,ym%)
  IF bouton%=0
    GOSUB aff_message("WAITING : CONVERTING...")
    GOSUB bee(TRUE)
    GOSUB new_pattern_format(t%)
  ELSE IF bouton%=1
    GOSUB aff_message("WAITING : CONVERTING...")
    GOSUB bee(TRUE)
    GOSUB chg_pattern_format(t%)
  ENDIF
  GOSUB bee(FALSE)
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE new_pattern_format(t%)
  ' Change le nbr de voies t%, de lignes 1 et efface la chanson
  LOCAL a%,b%,i%,j%
  LOCAL a$
  GOSUB stop_voices
  GOSUB clear_patterns2
  sample%=1
  instr%=1
  songpos%=0
  posligne%=0
  curs_col%=0
  curs_x%=0
  a%=nbr_track%
  nbr_track%=t%
  module&(100)=t%
  module&(101)=1        ! Longueur song
  module&(102)=0        ! Pt de bouclage
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  GOSUB create_space_for_patterns(MUL(MUL(MAX(SUB(nbr_track%,a%),0),5),256))
  GOSUB clear_song(FALSE)
  ARRAYFILL nbr_colonnes%(),nbr_track%
  para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
  module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
  module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  DPOKE r_master_vol%,DIV(&H3000,ADD(nbr_track%,3))
  DPOKE r_mod_songpos%,songpos%
  DPOKE r_mod_numpat%,song&(songpos%)
  DPOKE r_mod_speed%,6
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrtrack%,nbr_track%
  bl_start&=0
  bl_end&=0
  bl_trk&=0
  bl_pat&=0
  GOSUB stop_voices
  GOSUB all_track_on(FALSE)
  GOSUB balance_reset
RETURN
PROCEDURE chg_pattern_format(t%)
  ' Change le nbr de voies t% et essaie de garder la chanson
  ' Attention au format 32 piste/256 lignes, car utilisation d'une chaine de
  ' 32768 octets. Normalement pas de bug car GfA gere les chaines au mot pres
  LOCAL a%,b%,c%,d%,i%,j%,otp%
  LOCAL a$,b$
  GOSUB stop_voices
  IF t%>nbr_track%
    a%=0
    FOR i%=0 TO 255
      ADD a%,FN nbr_lines(i%)
    NEXT i%
    MUL a%,MUL(SUB(t%,nbr_track%),5)
    GOSUB create_space_for_patterns(a%)
    FOR i%=0 TO 255
      otp%=MUL(nbr_track%,FN nbr_lines(i%))
      a$=STRING$(MUL(otp%,5),0)
      BMOVE FN adr_pat(i%),V:a$,MUL(otp%,5)
      GOSUB create_space_patchunk(i%,t%,FN nbr_lines(i%),FALSE)
      GOSUB clear_mem(FN adr_pat(i%),MUL(MUL(t%,FN nbr_lines(i%)),5))
      a%=V:a$
      b%=FN adr_pat(i%)
      c%=MUL(nbr_track%,5)
      d%=MUL(t%,5)
      FOR j%=0 TO PRED(FN nbr_lines(i%))
        BMOVE a%,b%,c%
        ADD a%,c%
        ADD b%,d%
      NEXT j%
    NEXT i%
  ELSE
    FOR i%=0 TO 255
      otp%=MUL(nbr_track%,FN nbr_lines(i%))
      a$=STRING$(MUL(otp%,5),0)
      BMOVE FN adr_pat(i%),V:a$,MUL(otp%,5)
      GOSUB create_space_patchunk(i%,t%,FN nbr_lines(i%),FALSE)
      a%=V:a$
      b%=FN adr_pat(i%)
      c%=MUL(nbr_track%,5)
      d%=MUL(t%,5)
      FOR j%=0 TO PRED(FN nbr_lines(i%))
        BMOVE a%,b%,d%
        ADD a%,c%
        ADD b%,d%
      NEXT j%
    NEXT i%
  ENDIF
  GOSUB garbage_collection
  nbr_track%=t%
  module&(100)=t%
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  ARRAYFILL nbr_colonnes%(),nbr_track%
  para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
  module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
  module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  curs_col%=0
  curs_x%=0
  bl_trk&=0
  bl_pat&=0
  DPOKE r_master_vol%,DIV(&H3000,ADD(nbr_track%,3))
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrtrack%,nbr_track%
  GOSUB stop_voices
  GOSUB all_track_on(FALSE)
RETURN
PROCEDURE chg_taille_sample(ns%,ls%)
  ' Ne teste pas s'il y a assez de place pour agrandir un sample
  ' N'utilise que les adresses des samples
  ' Ne change absolument rien aux chunks
  LOCAL olda%,newa%,lon%,i%,dif%
  ls%=ls% AND -2
  IF ns%<255
    olda%=FN adrsamchk(SUCC(ns%))
    newa%=ADD(ADD(FN adrsamchk(ns%),64),ls%)
    lon%=SUB(FN adr_buffer,olda%)
    ~C:g_bmove%(L:olda%,L:newa%,L:lon%)
    dif%=SUB(newa%,olda%)
    FOR i%=SUCC(ns%) TO 255
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
    NEXT i%
    GOSUB clear_mem(ADD(newa%,lon%),-dif%)    ! Vide la fin du buffer de sample si on agrandit son espace
  ENDIF
RETURN
PROCEDURE chg_type_affpiste(n%)
  IF n%=0
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),6),32)    ! Nombre de pistes affichables sans volume ni effet
  ELSE IF n%=2
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),12),32)   ! Nombre de pistes affichables avec volume
  ELSE
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),10),32)   ! Nombre de pistes affichables sans volume
  ENDIF
  type_affpiste%=n%
RETURN
PROCEDURE chg_tempo(tempo%)
  LOCAL vblpf%,spf%
  vblpf%=0
  REPEAT
    INC vblpf%
    spf%=ROUND(CARD{r_adr_replay_frequency%}*2.5/MUL(tempo%,vblpf%))    ! replfreq*60/6/4 / tempo
  UNTIL spf%<1200
  CARD{r_mod_tempo%}=tempo%
  CARD{r_vblsize%}=spf%
  CARD{r_vblnumber%}=vblpf%
RETURN
PROCEDURE chg_speed(speed%)
  CARD{r_mod_speed%}=speed%
RETURN
PROCEDURE chg_songpos
  IF d%=0
    GOSUB edite_chaine(HEX$(songpos%,2),ADD(divbi&(0,0,16),12),ADD(divbi&(1,0,16),2),2,1)
    songpos%=VAL("$"+bbbb$)
  ELSE
    ADD songpos%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  songpos%=MIN(MAX(songpos%,0),PRED(module&(101)))
  GOSUB affiche_info_song
  GOSUB affiche_c_pattern
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF play%>0
    posligne%=MIN(DPEEK(r_mod_linepos%),PRED(FN nbr_lines2(songpos%)))
    DPOKE r_mod_linepos%,posligne%
    DPOKE r_mod_songpos%,songpos%
    DPOKE r_mod_numpat%,song&(songpos%)
  ENDIF
  IF km%>0 AND km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_pattern
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(song&(songpos%),2),ADD(divbi&(0,3,16),12),ADD(divbi&(1,3,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(song&(songpos%),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  song&(songpos%)=MIN(MAX(a%,0),255)
  GOSUB affiche_info_song
  GOSUB affiche_c_pattern
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF play%>0
    posligne%=MIN(DPEEK(r_mod_linepos%),PRED(FN nbr_lines2(songpos%)))
    DPOKE r_mod_linepos%,posligne%
    DPOKE r_mod_numpat%,song&(songpos%)
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_songlen
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(module&(101),2),ADD(divbi&(0,6,16),12),ADD(divbi&(1,6,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(module&(101),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  module&(101)=MIN(MAX(a%,SUCC(songpos%)),256)
  DPOKE r_mod_songlen%,module&(101)
  module&(102)=MIN(module&(102),PRED(module&(101)))
  DPOKE r_mod_songrep%,module&(102)
  GOSUB affiche_info_song
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_songrep
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(module&(102),2),ADD(divbi&(0,9,16),12),ADD(divbi&(1,9,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(module&(102),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  module&(102)=MIN(MAX(a%,0),PRED(module&(101)))
  DPOKE r_mod_songrep%,module&(102)
  GOSUB affiche_info_song
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_instrument
  IF d%=0
    GOSUB edite_chaine(HEX$(instr%,2),ADD(divbi&(0,12,16),12),ADD(divbi&(1,12,16),2),2,1)
    instr%=VAL("$"+bbbb$)
  ELSE
    ADD instr%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  instr%=MAX(MIN(instr%,255),1)
  GOSUB affiche_info_sample
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_sample
  IF d%=0
    GOSUB edite_chaine(HEX$(sample%,2),ADD(divbi&(0,15,16),12),ADD(divbi&(1,15,16),2),2,1)
    sample%=VAL("$"+bbbb$)
  ELSE
    ADD sample%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  sample%=MAX(MIN(sample%,255),1)
  GOSUB affiche_info_sample
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_linestep
  LOCAL a$
  IF d%=0
    IF line_step%<0
      a$="-"+HEX$(ABS(line_step%),1)
    ELSE
      a$=HEX$(line_step%,2)
    ENDIF
    GOSUB edite_chaine(a$,ADD(divbi&(0,18,16),5),ADD(divbi&(1,18,16),2),2,0)
    IF INSTR(bbbb$,"-")>0
      line_step%=-VAL("$"+RIGHT$(bbbb$))
    ELSE
      line_step%=VAL("$"+bbbb$)
    ENDIF
  ELSE
    ADD line_step%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  line_step%=MAX(MIN(line_step%,PRED(FN nbr_lines3)),-PRED(FN nbr_lines3),-15)
  GOSUB affiche_info_song
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_t_balance(t%,b%)
  CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,t%))}=b%
RETURN
PROCEDURE chg_s_sample
  IF flag_nvl_boucle_sample%<=0
    IF d%=0
      GOSUB edite_chaine(HEX$(sample%,2),ADD(divbi&(0,0,14),11),ADD(divbi&(1,0,14),2),2,1)
      sample%=VAL("$"+bbbb$)
    ELSE
      ADD sample%,MUL(d%,MAX(PRED(km%),1))
    ENDIF
    sample%=MAX(MIN(sample%,255),1)
    GOSUB affiche_icones_sampleb
    GOSUB affiche_info_sample
    IF km%<3 AND d%<>0
      PAUSE SUB(13,MUL(km%,5))
    ENDIF
  ENDIF
RETURN
PROCEDURE chg_s_volume
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN volume(sample%),3),ADD(divbi&(0,13,14),8),ADD(divbi&(1,13,14),2),3,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN volume(sample%),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  GOSUB chg_sam_volume(sample%,MIN(MAX(a%,0),&HFFF))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_length                  !!!
RETURN
PROCEDURE chg_s_reppos
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN repeat(sample%),6),ADD(divbi&(0,7,14),7),ADD(divbi&(1,7,14),2),6,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN repeat(sample%),SHL(d%,SUB(MUL(km%,4),3))) AND -2
  ENDIF
  GOSUB chg_sam_repeat(sample%,MAX(MIN(a%,SUB(FN length(sample%),FN replen(sample%))),0))
  GOSUB affiche_icones_sampleb
  num_nvl_boucle_sample%=sample%
  flag_nvl_boucle_sample%=4
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_replen
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN replen(sample%),6),ADD(divbi&(0,10,14),7),ADD(divbi&(1,10,14),2),6,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN replen(sample%),SHL(d%,SUB(MUL(km%,4),3))) AND -2
  ENDIF
  GOSUB chg_sam_replen(sample%,MAX(MIN(a%,SUB(FN length(sample%),FN repeat(sample%))),2))
  GOSUB affiche_icones_sampleb
  flag_nvl_boucle_sample%=4
  num_nvl_boucle_sample%=sample%
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_finetune
  LOCAL a%,b%
  IF d%=0
  ELSE
    a%=ADD(FN finetune(sample%),d%)
  ENDIF
  GOSUB chg_sam_finetune(sample%,MIN(MAX(a%,-8),7))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_balance
  LOCAL a%,a$
  a%=FN autobal(sample%)
  IF d%=0
    IF a%<=&HFFF
      a$=HEX$(FN autobal(sample%),3)
    ELSE
      a$="???"
    ENDIF
    GOSUB edite_chaine(a$,ADD(divbi&(0,19,14),8),ADD(divbi&(1,19,14),2),3,0)
    IF INSTR(bbbb$,"?")>0
      a%=-1
    ELSE
      a%=VAL("$"+bbbb$)
    ENDIF
  ELSE
    IF a%>&HFFF
      a%=-1
    ENDIF
    a%=ADD(a%,SHL(d%,SUB(MUL(km%,4),3))) AND -2
  ENDIF
  GOSUB chg_sam_balance(sample%,MAX(MIN(a%,&HFFF),-1) AND &HFFFF)
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_freqech
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(STR$(FN freqech(sample%),5),ADD(divbi&(0,22,14),10),ADD(divbi&(1,22,14),2),5,2)
    a%=VAL(bbbb$)
  ELSE
    a%=ADD(FN freqech(sample%),MUL(d%,20^PRED(km%)))
  ENDIF
  GOSUB chg_sam_freq(sample%,MAX(MIN(a%,65000),2000))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE 3
  ENDIF
RETURN
PROCEDURE chg_songname(nnnn$)
  LOCAL iiii%
  FOR iiii%=2 TO 17
    module&(iiii%)=&H2020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),32))
    BYTE{ADD(V:module&(2),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_songname2(aaaa%,llll%)
  LOCAL iiii%
  FOR iiii%=0 TO 31
    IF iiii%<llll%
      BYTE{ADD(V:module&(2),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(V:module&(2),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_songcomment(nnnn$)
  LOCAL iiii%
  FOR iiii%=18 TO 97
    module&(iiii%)=&H2020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),160))
    BYTE{ADD(V:module&(18),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_songcomment2(aaaa%,llll%)
  LOCAL iiii%
  FOR iiii%=0 TO 159
    IF iiii%<llll%
      BYTE{ADD(V:module&(18),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(V:module&(18),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_patternname(nnnn$,pppp%)
  IF LEN(nnnn$)<16
    nnnn$=nnnn$+SPACE$(SUB(16,LEN(nnnn$)))
  ENDIF
  nnnn$=LEFT$(nnnn$,16)
  BMOVE V:nnnn$,ADD(FN adr_patchunk(pppp%),10),16
RETURN
PROCEDURE chg_patternname2(aaaa%,llll%,pppp%)
  LOCAL iiii%
  FOR iiii%=0 TO 15
    IF iiii%<llll%
      BYTE{ADD(ADD(FN adr_patchunk(pppp%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(FN adr_patchunk(pppp%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_samplename(nnnn$,ssss%)
  LOCAL iiii%
  FOR iiii%=10 TO 34 STEP 4
    LONG{ADD(FN adrsamchk(ssss%),iiii%)}=&H20202020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),28))
    BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_samplename2(aaaa%,llll%,ssss%)
  LOCAL iiii%
  FOR iiii%=0 TO 27
    IF iiii%<llll%
      BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_instrname(nnnn$,ssss%)
  LOCAL iiii%
  FOR iiii%=10 TO 34 STEP 4
    LONG{ADD(V:instrset%(0,ssss%),iiii%)}=&H20202020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),28))
    BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_instrname2(aaaa%,llll%,ssss%)
  LOCAL iiii%
  FOR iiii%=0 TO 27
    IF iiii%<llll%
      BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_envelopename(nnnn$,eeee%,tttt%)
  LOCAL a%,b%,i%
  a%=FN env_chunkadr(eeee%,tttt%)
  FOR i%=ADD(a%,10) TO ADD(a%,26) STEP 4
    LONG{i%}=&H20202020
  NEXT i%
  IF nnnn$<>""
    b%=V:nnnn$
    FOR i%=ADD(a%,10) TO ADD(a%,ADD(MIN(LEN(nnnn$),20),9))
      BYTE{i%}=MAX(BYTE{b%},32)
      INC b%
    NEXT i%
  ENDIF
RETURN
PROCEDURE chg_envelopename2(aaaa%,llll%,eeee%,tttt%)
  LOCAL a%,b%,i%
  a%=FN env_chunkadr(eeee%,tttt%)
  FOR i%=ADD(a%,10) TO ADD(a%,26) STEP 4
    LONG{i%}=&H20202020
  NEXT i%
  IF llll%>0
    FOR i%=ADD(a%,10) TO ADD(a%,ADD(MIN(LEN(nnnn$),20),9))
      BYTE{i%}=MAX(BYTE{aaaa%},32)
      INC aaaa%
    NEXT i%
  ENDIF
RETURN
PROCEDURE chg_pat_chunkadr(pppp%,aaaa%)
  LONG{ADD(r_adr_pattern%,SHL(pppp%,2))}=aaaa%
RETURN
PROCEDURE chg_pat_chunklen(pppp%,aaaa%)
  LONG{ADD(FN adr_patchunk(pppp%),4)}=aaaa%
RETURN
PROCEDURE chg_pat_nbr_track(pppp%,aaaa%)
  CARD{ADD(FN adr_patchunk(pppp%),30)}=aaaa%
RETURN
PROCEDURE chg_pat_nbr_lines(pppp%,aaaa%)
  CARD{ADD(FN adr_patchunk(pppp%),28)}=aaaa%
RETURN
PROCEDURE chg_sam_chunkadr(ssss%,ffff%)
  LONG{ADD(r_adr_sample%,SHL(ssss%,2))}=ffff%
RETURN
PROCEDURE chg_sam_freq(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),44)}=ffff%
RETURN
PROCEDURE chg_sam_balance(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),40)}=ffff%
RETURN
PROCEDURE chg_sam_volume(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),58)}=ffff%
RETURN
PROCEDURE chg_sam_nbits(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),42)}=SHL(ffff%,3)
RETURN
PROCEDURE chg_sam_length(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),46)}=ffff%
  LONG{ADD(FN adrsamchk(ssss%),4)}=ADD(ffff%,64)
RETURN
PROCEDURE chg_sam_repeat(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),50)}=ffff%
RETURN
PROCEDURE chg_sam_replen(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),54)}=MAX(ffff%,2)
RETURN
PROCEDURE chg_sam_finetune(ssss%,ffff%)
  INT{ADD(FN adrsamchk(ssss%),60)}=ffff%
RETURN
PROCEDURE chg_ins_balance(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),42)}=ffff%
RETURN
PROCEDURE chg_ins_volume(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),40)}=ffff%
RETURN
PROCEDURE chg_ins_evol(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),44)}=ffff%
RETURN
PROCEDURE chg_ins_eton(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),46)}=ffff%
RETURN
PROCEDURE chg_ins_epan(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),48)}=ffff%
RETURN
PROCEDURE chg_ins_transp(ssss%,ffff%,gggg%)
  BYTE{ADD(V:instrset%(15,ssss%),SUCC(SHL(ffff%,1)))}=gggg%
RETURN
PROCEDURE chg_ins_sample(ssss%,ffff%,gggg%)
  BYTE{ADD(V:instrset%(15,ssss%),SHL(ffff%,1))}=gggg%
RETURN
PROCEDURE chg_env_chunkadr(num%,type%,adr%)
  SELECT type%
  CASE 0
    LONG{ADD(r_adr_evol%,SHL(num%,2))}=adr%
  CASE 1
    LONG{ADD(r_adr_eton%,SHL(num%,2))}=adr%
  CASE 2
    LONG{ADD(r_adr_epan%,SHL(num%,2))}=adr%
  ENDSELECT
RETURN
PROCEDURE chg_env_length(num%,type%,sect%,lon%)
  ' Change la longueur d'une section d'enveloppe
  ' Les commandes sont effacees
  LOCAL a%
  a%=SUB(lon%,FN env_sectlen(num%,type%,sect%))
  GOSUB chg_env_rellength(num%,type%,sect%,0,a%)
  a%=FN env_sectadr(num%,type%,sect%)
  FOR a%=a% TO PRED(ADD(a%,FN env_sectlen(num%,type%,sect%)))
    BYTE{a%}=0
  NEXT a%
RETURN
PROCEDURE chg_env_rellength(num%,type%,sect%,pos%,rlon%)
  ' Insere un certain nombre d'octets dans une enveloppe
  ' Marche aussi pour la reduction de la taille de l'enveloppe (lon% negatif)
  ' Pos% est en numero de commande et non en octets
  ' Le chunk est mis a jour
  LOCAL d%,i%,j%,l%,s%
  s%=ADD(FN env_sectadr(num%,type%,sect%),FN pos_enveloppe(num%,type%,sect%,pos%))
  d%=ADD(s%,rlon%)
  l%=SUB(FN adr_buffer,s%)
  IF num%<63 OR type%<2
    FOR i%=SUCC(ADD(MUL(num%,3),type%)) TO 191
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),rlon%))
    NEXT i%
  ENDIF
  FOR i%=0 TO 255
    GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),rlon%))
  NEXT i%
  ~C:g_bmove%(L:s%,L:d%,L:l%)
  LONG{ADD(FN env_chunkadr(num%,type%),4)}=ADD(FN env_chunklen(num%,type%),rlon%)
  IF sect%=0
    CARD{ADD(FN env_chunkadr(num%,type%),30)}=ADD(CARD{ADD(FN env_chunkadr(num%,type%),30)},rlon%)
  ENDIF
RETURN
PROCEDURE chg_env_adrjump(num%,type%,sect%,pos%,lon%)
  ' Change les adresses de saut apres une insertion ou destruction de commande
  ' Pos% en octets
  LOCAL a%,b%,i%,l%
  a%=FN env_sectadr(num%,type%,sect%)
  l%=FN env_sectlen(num%,type%,sect%)
  WHILE i%<l%
    SELECT BYTE{ADD(a%,i%)}
    CASE &H1,&H4
      b%=CARD{SUCC(ADD(a%,i%))}
      IF b%>pos%
        CARD{SUCC(ADD(a%,i%))}=ADD(b%,lon%)
      ENDIF
      ADD i%,3
    CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2
      ADD i%,2
    CASE &H2,&H80,&H81,&HA0,&HA1,&HC0,&HC1
      ADD i%,3
    DEFAULT
      ADD i%,1
    ENDSELECT
  WEND
RETURN
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                                Fonctions                                 *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
FUNCTION vire_xbra(adr%,id%,mask%,vire!)
LOCAL a%,c%
LOCAL flag!,found!
found!=FALSE
a%=LPEEK(adr%)
flag!=FALSE
WHILE LPEEK(MAX(SUB(a%,12),0))=CVL("XBRA")
  IF (LPEEK(SUB(a%,8)) AND mask%)=(id% AND mask%)
    found!=TRUE
    IF vire!
      c%=adr%
      IF flag!
        SUB c%,4
      ENDIF
      xbra_remove$=xbra_remove$+MKL$(c%)+MKL$(a%)
      SLPOKE c%,LPEEK(SUB(a%,4))
    ENDIF
  ENDIF
  adr%=a%
  a%=LPEEK(SUB(a%,4))
  flag!=TRUE
WEND
RETURN found!
ENDFUNC
FUNCTION exist(a$)
' Cherche si le fichier a$ existe (jockers autorises)
LOCAL dta$,masque_fichier$
dta$=STRING$(44,0)
masque_fichier$=a$+CHR$(0)
~FRE(0)
~GEMDOS(&H1A,L:V:dta$)
IF GEMDOS(&H4E,L:V:masque_fichier$,1)=>0
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
FUNCTION backup_file(a$)
LOCAL e%,a%
LOCAL b$,c$
IF FN exist(a$)
b$=RIGHT$(a$,4)
a%=ADD(INSTR(b$,"."),SUB(LEN(a$),4))
b$=LEFT$(a$,a%)                             ! On a le fichier sans l'extention (mais avec le .)
c$=b$+"BAK"+CHR$(0)
IF FN exist(c$)
e%=SHL(GEMDOS(65,L:V:c$),16)              ! Detruit l'ancien .BAK
ELSE
e%=0
ENDIF
a$=a$+CHR$(0)
ADD e%,GEMDOS(86,0,L:V:a$,L:V:c$) AND 65535 ! Renome
ENDIF
RETURN e%
~FRE(0)
ENDFUNC
FUNCTION last_pat_util
' Indique le dernier pattern utilise
LOCAL aaaaa%,iiiii%
aaaaa%=0
FOR iiiii%=0 TO PRED(module&(101))
aaaaa%=MAX(aaaaa%,song&(iiiii%))
NEXT iiiii%
RETURN aaaaa%
ENDFUNC
FUNCTION last_spl_util
' Indique le dernier sample utilise (min 1)
LOCAL iiii%,aaaa%
aaaa%=1
FOR iiii%=1 TO 255
IF FN length(iiii%)>0
aaaa%=iiii%
ENDIF
NEXT iiii%
RETURN aaaa%
ENDFUNC
FUNCTION last_spl_util2
' Indique le dernier instrument utilisant un sample non-vide en C-2 (min 1)
LOCAL iiii%,aaaa%
aaaa%=1
FOR iiii%=1 TO 255
IF FN length(FN isample(iiii%,48))>0
aaaa%=iiii%
ENDIF
NEXT iiii%
RETURN aaaa%
ENDFUNC
FUNCTION nbr_lines_maxi
LOCAL iiii%
aaaa%=1
FOR iiii%=0 TO FN last_pat_util
aaaa%=MAX(aaaa%,FN nbr_lines(iiii%))
NEXT iiii%
RETURN aaaa%
ENDFUNC
FUNCTION songcomment$
LOCAL aaaa$
aaaa$=SPACE$(160)
BMOVE V:module&(18),V:aaaa$,160
RETURN aaaa$
ENDFUNC
FUNCTION songname$
LOCAL aaaa$
aaaa$=SPACE$(32)
BMOVE V:module&(2),V:aaaa$,32
RETURN aaaa$
ENDFUNC
FUNCTION patternname$(pppp%)
LOCAL aaaa$
aaaa$=SPACE$(16)
BMOVE ADD(FN adr_patchunk(pppp%),10),V:aaaa$,16
RETURN aaaa$
ENDFUNC
FUNCTION samplename$(ssss%)
LOCAL iiii%,aaaa$
aaaa$=""
FOR iiii%=10 TO 34 STEP 4
aaaa$=aaaa$+MKL$(LONG{ADD(FN adrsamchk(ssss%),iiii%)})
NEXT iiii%
RETURN aaaa$
ENDFUNC
FUNCTION pourcent$(aaaa%,bbbb%)
' Transforme aaaa%/bbbb% en "xxx.x" %
' Arrondissement par exces
RETURN RIGHT$("  "+STR$(INT(aaaa%*100/bbbb%+0.0999)),3)+"."+RIGHT$(STR$(INT(aaaa%*1000/bbbb%+0.999)),1)
ENDFUNC
FUNCTION fft(aaaa%,tttt%,llll%,ffffe%,ffff0%,bbbb%)
' aaaa% = adresse du sample, tttt %= adresse d'une table de 1.25*4096 sinus 16 bits
' llll% = longueur en octets, ffffe% = freq d'ech, ffff0% = freq recherchee
' bbbb% = nombre d'octets par sample
LOCAL cccc%,dddd,eeee,ffff
cccc%=C:g_trans_fourier%(L:aaaa%,L:llll%,L:ffffe%,L:ffff0%,W:bbbb%,L:tttt%)
eeee=LONG{cccc%}
ffff=LONG{ADD(cccc%,4)}
dddd=SQR((eeee*eeee+ffff*ffff))/1073741824            ! Module (variant de 0 a 1)
RETURN dddd
ENDFUNC
FUNCTION spl_cherche_volume(dddd%,llll%,bbbb%)
' Cherche le volume du sample position dddd%, longueur llll%, resol bbbb%
LOCAL aaaa%,cccc%
cccc%=ADD(FN adr_buffer,dddd%)
aaaa%=C:g_cherche_volume_sample%(L:cccc%,L:llll%,W:bbbb%)
aaaa%=SHL(aaaa%,SHL(SUB(2,bbbb%),3))              ! Recalibre /32768
RETURN aaaa%
ENDFUNC
FUNCTION se.sm_fft_tot(fmin%,fmax%,fech%,nfreq%,adr%,lon%,bits%,flagc!,flagd!)
' Renvoie dans fft&() les puissances (15 bits) de nfreq%
' frequences de fmin%...fmax% puis la frequence.w du sample
LOCAL a%,i%,pc%,pctot%,pcnxt%,a,b,coef,p,pm,f1,f2,tabl$
~FRE(0)
ARRAYFILL fft&(),0
IF flagd!
GOSUB cadre_o_int(SUB(SHR(scr_ncol%,1),11),SUB(SHR(scr_haut%,1),24),21,47,9,9,10,8)
GOSUB cadre_ext(SUB(SHR(scr_ncol%,1),10),ADD(SHR(scr_haut%,1),8),19,5,9,9,8,10)
GOSUB affchaine_trans("WAITING : FFT",SUB(scr_ncol%,13),SUB(SHR(scr_haut%,1),8),10)
GOSUB bee(TRUE)
ENDIF
tabl$=STRING$(8192,0)
a%=V:tabl$
a=PI/2048
FOR i%=0 TO 1024                      ! Calcul de la table
INT{a%}=ROUND(SIN(i%*a)*32767)
ADD a%,2
NEXT i%
FOR i%=4 TO 4092 STEP 4
INT{a%}=INT{SUB(a%,i%)}
ADD a%,2
NEXT i%
FOR i%=0 TO 2048
INT{a%}=-INT{SUB(a%,4096)}
ADD a%,2
NEXT i%
se.freq_fftmin%=fmin%
se.freq_fftmax%=fmax%
se.freq_fftech%=fech%
se.freq_fftlon%=nfreq%
' FFT de chaque frequence
pm=0
f1=-1
f2=0
b=(fmax%-fmin%)/nfreq%
IF b>1 AND b<100 AND flagc!
pctot%=nfreq%+2*b
ELSE
pctot%=nfreq%
ENDIF
pc%=0
pcnxt%=0
FOR i%=0 TO PRED(nfreq%)
a=f1
f1=fmin%+i%*b                       ! Frequence a tester
p=FN fft(adr%,V:tabl$,lon%,SHL(fech%,4),MAX(ROUND(f1*16),0),bits%)
fft&(i%)=MAX(MIN(p*&H7FFF,&H7FFF),0)
IF f1>=30
coef=1/f1
ELSE
coef=0
ENDIF
IF p*coef>pm
pm=p*coef
f2=f1
ENDIF
IF GEMDOS(11)<>0
IF SHR(GEMDOS(7),16)=1            ! ESC = arret
i%=nfreq%
ENDIF
ENDIF
IF flagd!                           ! Affichage du pourcentage de calcul
IF DIV(MUL(100,pc%),pctot%)>=pcnxt%
GOSUB affchaine_trans(STRING$(SUCC(DIV(pcnxt%,5)),7),SUB(scr_ncol%,20),ADD(SHR(scr_haut%,1),8),8)
GOSUB bee(TRUE)
WHILE DIV(MUL(100,pc%),pctot%)>=pcnxt%
ADD pcnxt%,5
WEND
ENDIF
INC pc%
ENDIF
NEXT i%
' 2eme recherche pour la frequence du sample, precise
IF flagc! AND b>1 AND b<=100          ! Scanning Hz par Hz
FOR i%=f2-b TO f2+b
p=FN fft(adr%,V:tabl$,lon%,fech%,MAX(i%,0),bits%)
IF i%>=30
coef=1/i%
ELSE
coef=0
ENDIF
IF p*coef>pm
pm=p*coef
f2=i%
ENDIF
IF GEMDOS(11)<>0
IF SHR(GEMDOS(7),16)=1          ! ESC = arret
i%=f2+b
ENDIF
ENDIF
IF flagd!                         ! Affichage du pourcentage de calcul
IF DIV(MUL(100,pc%),pctot%)>=pcnxt%
GOSUB affchaine_trans(STRING$(SUCC(DIV(pcnxt%,5)),7),SUB(scr_ncol%,20),ADD(SHR(scr_haut%,1),8),8)
GOSUB bee(TRUE)
WHILE DIV(MUL(100,pc%),pctot%)>=pcnxt%
ADD pcnxt%,5
WEND
ENDIF
INC pc%
ENDIF
NEXT i%
ENDIF
IF b>100 OR NOT flagc!        ! Si l'ecart est trop grand, pas de frequence pour le sample
f2=0
ENDIF
RETURN ROUND(f2)
ENDFUNC
FUNCTION se.sm_adresse_sample(i%)
IF i%=0
RETURN ADD(FN adr_buffer,mark_1%)
ELSE
RETURN FN adresse(i%)
ENDIF
ENDFUNC
FUNCTION se.sm_longueur_sample(i%)
IF i%=0
RETURN mark_len%
ELSE
RETURN FN length(i%)
ENDIF
ENDFUNC
FUNCTION se.sm_resol_sample(i%)
IF i%=0
RETURN win_bits%
ELSE
RETURN FN resol(i%)
ENDIF
ENDFUNC
FUNCTION hexasigne$(vvvv%,llll%)
' Renvoie une chaine en hexa signe, avec llll% chiffre (+ le signe)
IF vvvv%>=0
RETURN "+"+HEX$(vvvv%,llll%)
ELSE
RETURN "-"+HEX$(ABS(vvvv%),llll%)
ENDIF
ENDFUNC
FUNCTION valhexasigne(aaaa$)
' Renvoie la valeur d'une chaine hexa signee, avec ou sans '$'
LOCAL a%
a%=INSTR(aaaa$,"$")
IF a%>0
aaaa$=LEFT$(aaaa$,PRED(a%))+RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))
ENDIF
a%=INSTR(aaaa$,"+")
IF a%>0
RETURN VAL("$"+TRIM$(RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))))
ELSE
a%=INSTR(aaaa$,"-")
IF a%>0
RETURN -VAL("$"+TRIM$(RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))))
ELSE
RETURN VAL("$"+TRIM$(aaaa$))
ENDIF
ENDIF
ENDFUNC
FUNCTION sbyte(a%)
' Retablit la signature d'un octet et enleve les bits inutiles
a%=a% AND 255
IF a%>127
RETURN SUB(a%,256)
ELSE
RETURN a%
ENDIF
ENDFUNC
FUNCTION squartet(a%)
' Retablit la signature d'un quartet et enleve les bits inutiles
a%=a% AND 15
IF a%>7
RETURN SUB(a%,16)
ELSE
RETURN a%
ENDIF
ENDFUNC
FUNCTION get_elt_in_list$(l$,a%)
' Renvoie le a%ieme element (de 0 a ...) de la liste l$
' Les elements sont separes par des virgules
LOCAL b%
LOCAL b$
IF a%<0
b$=""
ELSE
REPEAT
b%=INSTR(l$,",")
IF b%>0
b$=LEFT$(l$,PRED(b%))
l$=RIGHT$(l$,SUB(LEN(l$),b%))
ELSE
b$=l$
l$=""
ENDIF
DEC a%
UNTIL a%<0
ENDIF
RETURN b$
ENDFUNC
FUNCTION falsetrue$(a%)
IF a%<>0
RETURN "true"
ELSE
RETURN "false"
ENDIF
ENDFUNC
' Fonctions concernant les instruments
FUNCTION instrname$(ssss%)
LOCAL iiii%,aaaa$
aaaa$=""
FOR iiii%=10 TO 34 STEP 4
aaaa$=aaaa$+MKL$(LONG{ADD(V:instrset%(0,ssss%),iiii%)})
NEXT iiii%
RETURN aaaa$
ENDFUNC
FUNCTION ins_deb_zone(nnnn%,pppp%)
' Cherche le debut d'une zone isosample dans la table des samples d'un instrument
LOCAL aaaa%
aaaa%=FN isample(nnnn%,pppp%)
WHILE pppp%>1
EXIT IF FN isample(nnnn%,PRED(pppp%))<>aaaa%
DEC pppp%
WEND
RETURN pppp%
ENDFUNC
FUNCTION ins_fin_zone(nnnn%,pppp%)
' Cherche la fin d'une zone isosample dans la table des samples d'un instrument
LOCAL aaaa%
aaaa%=FN isample(nnnn%,pppp%)
WHILE pppp%<127
EXIT IF FN isample(nnnn%,SUCC(pppp%))<>aaaa%
INC pppp%
WEND
RETURN pppp%
ENDFUNC
FUNCTION ins_used_samples$(nnnn%)
' Renvoie une chaine de MOTS contenant les numeros des samples utilises dans
' l'instrument specifie (sauf 0)
LOCAL aaaa%,iiii%,jjjj%,pppp%
LOCAL ffff!
LOCAL aaaa$
aaaa$=""
FOR iiii%=0 TO 127
aaaa%=FN isample(nnnn%,iiii%)
IF aaaa%>0
ffff!=TRUE
IF LEN(aaaa$)>0
FOR jjjj%=0 TO SUB(LEN(aaaa$),2) STEP 2
IF CARD{ADD(V:aaaa$,jjjj%)}=aaaa%
ffff!=FALSE
jjjj%=LEN(aaaa$)
ENDIF
NEXT jjjj%
ENDIF
IF ffff!
pppp%=0
WHILE pppp%<LEN(aaaa$)
EXIT IF CARD{ADD(V:aaaa$,pppp%)}>aaaa%
ADD pppp%,2
WEND
aaaa$=LEFT$(aaaa$,pppp%)+MKI$(aaaa%)+RIGHT$(aaaa$,SUB(LEN(aaaa$),pppp%))
ENDIF
ENDIF
NEXT iiii%
RETURN aaaa$
ENDFUNC
FUNCTION ins_cherche_sample(ssss%,dddd%)
' Cherche dans quel instrument se trouve le sample ssss%
' La recherche commence a l'instrument dddd%
LOCAL iiii%
LOCAL ffff!
ffff!=FALSE
WHILE dddd%<=255
FOR iiii%=1 TO 127
IF FN isample(dddd%,iiii%)=ssss%
ffff!=TRUE
ENDIF
NEXT iiii%
EXIT IF ffff!
INC dddd%
WEND
IF ffff!
RETURN dddd%
ELSE
RETURN 0
ENDIF
ENDFUNC
' Fonctions concernant les enveloppes
FUNCTION env_chunkadr(num%,type%)
IF type%=0
RETURN LONG{ADD(r_adr_evol%,SHL(num%,2))}
ELSE IF type%=1
RETURN LONG{ADD(r_adr_eton%,SHL(num%,2))}
ELSE
RETURN LONG{ADD(r_adr_epan%,SHL(num%,2))}
ENDIF
ENDFUNC
FUNCTION env_chunklen(num%,type%)
RETURN LONG{ADD(FN env_chunkadr(num%,type%),4)}
ENDFUNC
FUNCTION envelopename$(num%,type%)
LOCAL i%,a$
a$=""
FOR i%=10 TO 26 STEP 4
a$=a$+MKL$(LONG{ADD(FN env_chunkadr(num%,type%),i%)})
NEXT i%
RETURN a$
ENDFUNC
FUNCTION env_sectadr(num%,type%,sect%)
IF sect%=0
RETURN ADD(FN env_chunkadr(num%,type%),32)
ELSE
RETURN ADD(FN env_chunkadr(num%,type%),ADD(32,CARD{ADD(FN env_chunkadr(num%,type%),30)}))
ENDIF
ENDFUNC
FUNCTION env_sectlen(num%,type%,sect%)
IF sect%=0
RETURN CARD{ADD(FN env_chunkadr(num%,type%),30)}
ELSE
RETURN SUB(SUB(LONG{ADD(FN env_chunkadr(num%,type%),4)},32),CARD{ADD(FN env_chunkadr(num%,type%),30)})
ENDIF
ENDFUNC
FUNCTION pos_enveloppe(num%,type%,sect%,pos%)
' Type de l'enveloppe (0,1 ou 2), numero de l'enveloppe (0-63),
' Attack/Key off (0 ou 1), position recherchee
' Retourne la position en octets relativement au debut des donnees du numero
' d'une commande
' Retourne -1 si la position n'existe pas
LOCAL a%,b%,c%,l%,p%
a%=FN env_sectadr(num%,type%,sect%)
l%=FN env_sectlen(num%,type%,sect%)
p%=0                  ! Compteur en positions
c%=0                  ! Compteur en octets
WHILE c%<l%
EXIT IF p%>=pos%
b%=BYTE{a%}         ! Commande
SELECT b%           ! Nbr d'octets pris par commande+parametre
CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2
ADD a%,2
ADD c%,2
CASE &H1,&H2,&H4,&H80,&H81,&HA0,&HA1,&HC0,&HC1
ADD a%,3
ADD c%,3
DEFAULT
INC a%
INC c%
ENDSELECT
INC p%
WEND
IF c%>=l%
RETURN -1
ELSE
RETURN c%
ENDIF
ENDFUNC
FUNCTION numcom_enveloppe(num%,type%,sect%,pos%)
' Type de l'enveloppe (0,1 ou 2), numero de l'enveloppe (0-63),
' Attack/Key off (0 ou 1), position en octets recherchee
' Retourne le numero de la commande correspondant a une position en octets
LOCAL a%,b%,c%,l%,p%
a%=FN env_sectadr(num%,type%,sect%)
l%=FN env_sectlen(num%,type%,sect%)
p%=0                  ! Compteur en positions
c%=0                  ! Compteur en octets
WHILE c%<l%
EXIT IF c%>=pos%
b%=BYTE{a%}         ! Commande
SELECT b%           ! Nbr d'octets pris par commande+parametre
CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2
ADD a%,2
ADD c%,2
CASE &H1,&H2,&H4,&H80,&H81,&HA0,&HA1,&HC0,&HC1
ADD a%,3
ADD c%,3
DEFAULT
INC a%
INC c%
ENDSELECT
INC p%
WEND
RETURN p%
ENDFUNC
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                             Donnees diverses                             *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' 0
icones_disk:
DATA 33,0,5
DATA 0,"LOAD MOD",21,35,9,9, 1,"SAVE MOD",31,35,9,9
DATA 2," ",66,45,1,9, 3," ",66,45,1,9
DATA 4,"LOAD PREF",21,45,9,9, 5,"SAVE PREF",31,45,9,9
DATA 6,"MODULE PATH                                       ",20,60,50,9
DATA 7,"SAMPLE PATH                                       ",20,70,50,9
DATA 8,"PREFS PATH                                        ",20,80,50,9
DATA 9,"AUTOLOAD PATH                                     ",20,90,50,9
DATA 10,"GT2",42,35,3,9, 11,"GTK",42,45,3,9, 12,"MOD",46,35,3,9, 13,"MMD",46,45,3,9
DATA 14,"669",50,35,3,9, 15,"MTM",50,45,3,9, 16,"S3M",54,35,3,9, 17,"ULT",54,45,3,9
DATA 18,"DTM",58,35,3,9, 19,"XM",58,45,3,9, 20,"*",62,35,3,9, 21,"   ",62,45,3,9
DATA 22,"   ",66,35,3,9, 23,"   ",66,45,3,9, 24,"   ",70,35,3,9, 25,"   ",70,45,3,9
DATA 26,"UNSIGNED",66,45,1,9
DATA 27,"MAKE DIR",71,60,8,9, 28,"DEL DIR",71,70,8,9
DATA 29,"DEL FILE",71,80,8,9, 30,"RENAME",71,90,8,9
DATA 31,"FORMAT",71,50,8,9
DATA 32," ",77,35,1,9
' 1
icones_tools:
DATA 24,0,5
DATA 0,"START",21,40,9,11, 1,"PASTE",33,35,7,9, 2,"CLEAR",41,45,7,9, 3,"NOTE UP",49,45,9,9
DATA 4,"END",21,53,9,11, 5,"INSERT",33,45,7,9, 6,"DELETE",41,55,7,9, 7,"NOTE DOWN",49,55,9,9
DATA 8,"SWAP",33,55,7,9, 9,"REPLACE",53,75,7,9, 10,"ALL",21,75,7,9, 11,"TRACK",61,30,7,9
DATA 12,"TRANSP",53,85,7,9, 13,"MASK",21,85,7,9, 14,"PATTERN",61,40,7,9, 15,"PRESET",61,50,7,9
DATA 16,"MASK ON               ",29,75,22,9, 17,"REPLACE BY            ",29,85,22,9
DATA 18,"EXT NOTE       ",63,77,15,9
DATA 19,"SONG",71,40,7,9, 20,"INSTR",71,50,7,9, 21,"ALL",71,60,7,9
DATA 22,".../...",72,90,7,9
DATA 23,"SONG",61,60,7,9
' 2
icones_sample1:
DATA 16,0,0
DATA 0,"EXIT",70,70,9,9
DATA 1,"ZOOM",0,20,9,9, 2,"ZOOM OUT",10,20,9,9
DATA 3,"COPY SPL => BLOCK",0,30,19,9
DATA 4,"COPY BLOCK => SPL",0,40,19,9
DATA 5,"SWAP BLOCK AND SPL",0,50,19,9
DATA 6,"CLEAR",0,70,5,9, 7,"CUT",6,70,3,9, 8,"KEEP",10,70,4,9, 9,"FLIP",15,70,4,9
DATA 10,"GAP (BLK)",0,60,9,9, 11,"GAP (SPL)",10,60,9,9
DATA 12,"PLAY",20,30,9,29
DATA 13,"FINE POS",20,60,9,9
DATA 14,"SWAP CURS",20,70,9,9
DATA 15,"RESET CUR",20,20,9,9
' 3
icones_sample2:
DATA 10,0,0
DATA 0,"POS L",1,0,5,9, 1,"CURS L",8,0,5,9, 2,"BITS",25,0,1,9, 3,"BLOCK",29,0,5,9, 4,"BUFFER",36,0,5,9
DATA 5,"REPEAT",43,0,5,9, 6,"FREQ",50,0,4,9, 7,"SAMPLE",60,0,1,9, 8,"CURS R",66,0,5,9, 9,"POS R",73,0,5,9
' 4
icones_sample3:
DATA 10,0,0
DATA 0,"VOLUME",40,20,9,9, 1,"MIX",40,30,9,9, 2,"RECORD",40,40,9,9
DATA 3,"MARKS",40,50,9,9, 4,"FREQUENCY",40,60,9,9, 5,"DELAY",40,70,9,9
DATA 6,"FLANGER",50,20,9,9, 7,"REVERB",50,30,9,9, 8,"SONG2DISK",50,40,9,9
DATA 9,"COMPRESS.",50,50,9,9
' 5
icones_sample_sm1:
DATA 17,0,0
DATA 0,"VOLUME      %",15,90,13,9
DATA 1,"VOLUME ?",1,85,12,19
DATA 2,"+ 1 dB",31,90,7,9, 3,"+ 2 dB",31,100,7,9, 4,"+ 3 dB",31,110,7,9, 5,"+ 6 dB",31,120,7,9
DATA 6,"- 1 dB",39,90,7,9, 7,"- 2 dB",39,100,7,9, 8,"- 3 dB",39,110,7,9, 9,"- 6 dB",39,120,7,9
DATA 10,"FADE !",49,90,29,9
DATA 11,"FADE START      %",49,115,17,9
DATA 12,"FADE END        %",49,125,17,9
DATA 13,"FADE IN",69,115,9,9
DATA 14,"FADE OUT",69,125,9,9
DATA 15,"NO CHANGE",1,125,13,9, 16,"BEST",15,125,13,9
' 6
icones_sample_sm2:
DATA 46,0,0
DATA 0,"MIX !",1,85,11,9, 1,"MASTER      %",15,85,13,9
DATA 2,"2",31,85,1,9, 3,"3",33,85,1,9, 4,"4",35,85,1,9, 5,"5",37,85,1,9
DATA 6,"ON",5,100,3,9, 7,"START      %",9,100,12,9, 8,"END      %",22,100,10,9, 9,"LOOP",33,100,5,9
DATA 10," ",1,110,3,9, 11,"¸",5,110,1,9, 12,"˝",7,110,1,9, 13," ",9,110,29,9
DATA 14,"ON",5,120,3,9, 15,"START      %",9,120,12,9, 16,"END      %",22,120,10,9, 17,"LOOP",33,120,5,9
DATA 18," ",1,130,3,9, 19,"¸",5,130,1,9, 20,"˝",7,130,1,9, 21," ",9,130,29,9
DATA 22,"ON",45,80,3,9, 23,"START      %",49,80,12,9, 24,"END      %",62,80,10,9, 25,"LOOP",73,80,5,9
DATA 26," ",41,90,3,9, 27,"¸",45,90,1,9, 28,"˝",47,90,1,9, 29," ",49,90,29,9
DATA 30,"ON",45,100,3,9, 31,"START      %",49,100,12,9, 32,"END      %",62,100,10,9, 33,"LOOP",73,100,5,9
DATA 34," ",41,110,3,9, 35,"¸",45,110,1,9, 36,"˝",47,110,1,9, 37," ",49,110,29,9
DATA 38,"ON",45,120,3,9, 39,"START      %",49,120,12,9, 40,"END      %",62,120,10,9, 41,"LOOP",73,120,5,9
DATA 42," ",41,130,3,9, 43,"¸",45,130,1,9, 44,"˝",47,130,1,9, 45," ",49,130,29,9
' 7
icones_samples_sm3:
DATA 18,0,0
DATA 0,"SAMPLE",1,85,9,9, 1,"PRESAMPLE",13,85,9,9
DATA 2,"¸",65,105,1,9, 3,"˝",67,105,1,9, 4,"¸",75,105,1,9, 5,"˝",77,105,1,9
DATA 6,"AUTO",69,105,5,9
DATA 7,"FREQUENCY      Hz",1,105,17,9, 8,"¸",19,105,1,9, 9,"˝",21,105,1,9
DATA 10,"MONITOR",25,120,11,9
DATA 11,"LEVEL      %",10,125,12,9, 12,"TRIGGER",1,125,8,9
DATA 13,"L",25,95,3,9, 14,"L+R",29,95,3,9, 15,"R",33,95,3,9
DATA 16,"FALCON 030 D.A.C.",39,95,23,9, 17,"ST REPLAY PRO CARDRIDGE",39,105,23,9
' 8
icones_samples_sm4:
DATA 29,0,0
DATA 0,"1",1,80,1,9, 1,"2",1,90,1,9, 2,"3",1,100,1,9, 3,"4",1,110,1,9, 4,"5",1,120,1,9
DATA 5,"6",41,80,1,9, 6,"7",41,90,1,9, 7,"8",41,100,1,9, 8,"9",41,110,1,9, 9,"10",41,120,1,9
DATA 10,"ALL",65,130,3,9, 11,"RESET",74,130,5,9
DATA 12,"SET",0,130,5,9
DATA 13,"1",44,130,1,9, 14,"2",46,130,1,9, 15,"3",48,130,1,9, 16,"4",50,130,1,9, 17,"5",52,130,1,9
DATA 18,"6",54,130,1,9, 19,"7",56,130,1,9, 20,"8",58,130,1,9, 21,"9",60,130,1,9, 22,"10",62,130,1,9
DATA 23," ",4,80,20,49, 24," ",44,80,20,49
DATA 25," ",26,80,20,49, 26," ",66,80,20,49
DATA 27," ",33,80,20,49, 28," ",73,80,20,49
' 9
icones_samples_sm5:
DATA 23,0,0
DATA 0,"CONVERT",1,90,11,9
DATA 1,"/2",1,115,3,9, 2,"/3",5,115,3,9, 3,"/4",9,115,3,9
DATA 4,"x2",1,125,3,9, 5,"x3",5,125,3,9, 6,"x4",9,125,3,9
DATA 7,"DO",50,90,13,9
DATA 8,"Hz        =>      ",15,90,18,9
DATA 9,"NOTE      =>      ",15,115,18,9
DATA 10,"Hz        =>      ",15,125,18,9
DATA 11,"NONE",36,95,11,9, 12,"LINEAR",36,105,11,9, 13,"3RD DEGREE",36,115,11,9
DATA 14,"START      Hz",50,105,13,9, 15,"END        Hz",50,115,13,9
DATA 16,"# OF PTS     ",50,125,13,9
DATA 17,"LINEAR",66,90,6,9, 18,"dB",73,90,5,9
DATA 19,"NONE",66,115,12,9, 20,"BLACKMAN",66,125,12,9
DATA 21," ",33,107,0,5, 22," ",63,82,0,5
' 10
icones_samples_sm6:
DATA 30,0,0
DATA 0,"ON",44,85,2,9, 1,"DELAY TIME      ms",47,85,18,9, 2,"LEVEL      %",66,85,12,9
DATA 3,"ON",44,95,2,9, 4,"DELAY TIME      ms",47,95,18,9, 5,"LEVEL      %",66,95,12,9
DATA 6,"ON",44,105,2,9, 7,"DELAY TIME      ms",47,105,18,9, 8,"LEVEL      %",66,105,12,9
DATA 9,"ON",44,115,2,9, 10,"DELAY TIME      ms",47,115,18,9, 11,"LEVEL      %",66,115,12,9
DATA 12,"SAMPLE SOURCE   ",29,130,16,9, 13,"¸",46,130,1,9, 14,"˝",48,130,1,9, 15," ",50,130,29,9
DATA 16,"DO",30,113,9,13
DATA 17,"FEEDBACK       % ",1,85,17,9, 18,"TIME FEED      ms",1,95,17,9
DATA 19,"DRY LEVEL        %",21,85,18,9, 20,"DELAY LEVEL      %",21,95,18,9
DATA 21,"MULTI-TAP MODE",1,115,18,9
DATA 22,"MUTE IN :",1,125,9,9, 23,"      ms",11,125,8,9
DATA 24,"1",22,115,1,9, 25,"2",24,115,1,9, 26,"3",26,115,1,9
DATA 27,"4",22,125,1,9, 28,"5",24,125,1,9, 29,"6",26,125,1,9
' 11
icones_tools2:
DATA 11,0,5
DATA 0,".../...",72,90,7,9
DATA 1,"ECHO",21,40,7,9, 2,"CONT",31,40,7,9
DATA 3,"EVERY   LINES",21,55,13,9, 4,"¸",35,55,1,9, 5,"˝",37,55,1,9
DATA 6," ",21,70,1,9, 7,"FEEDBACK     %",24,70,14,9
DATA 8," ",21,85,1,9, 9,"FADESTEP      ",24,85,14,9
DATA 10,"VOLUME SLIDE",41,35,15,9
' 12
icones_instr:
DATA 42,0,5
DATA 0," ",21,34,1,7, 1," ",24,34,19,7
DATA 2," ",21,40,1,7, 3," ",24,40,19,7
DATA 4," ",21,46,1,7, 5," ",24,46,19,7
DATA 6," ",21,52,1,7, 7," ",24,52,19,7
DATA 8," ",21,58,1,7, 9," ",24,58,19,7
DATA 10," ",21,64,1,7, 11," ",24,64,19,7
DATA 12," ",21,70,1,7, 13," ",24,70,19,7
DATA 14," ",21,76,1,7, 15," ",24,76,19,7
DATA 16,"¸",45,35,1,9, 17,"˝",45,45,1,9
DATA 18,"FROM      ",49,60,10,9, 19,"¸",60,60,1,9, 20,"˝",62,60,1,9
DATA 21,"TO        ",49,70,10,9, 22,"¸",60,70,1,9, 23,"˝",62,70,1,9
DATA 24,"VOLUME    ",49,85,10,9, 25,"¸",60,85,1,9, 26,"˝",62,85,1,9
DATA 27,"VOLUME   ",65,45,9,9, 28,"¸",75,45,1,9, 29,"˝",77,45,1,9
DATA 30,"TON      ",65,55,9,9, 31,"¸",75,55,1,9, 32,"˝",77,55,1,9
DATA 33,"PAN      ",65,65,9,9, 34,"¸",75,65,1,9, 35,"˝",77,65,1,9
DATA 36,"¸",27,85,1,9, 37,"˝",29,85,1,9
DATA 38,"¸",44,85,1,9, 39,"˝",46,85,1,9
DATA 40,"LIST",65,80,13,14
DATA 41,"GROUP",52,35,7,19
' 13
icones_instr_list:
DATA 17,0,5
DATA 0,"1st PAGE",69,75,9,19
DATA 1,"¸",53,35,1,9, 2,"˝",53,45,1,9
DATA 3,"TOP",56,35,3,9
DATA 4,"LOAD INSTRUMENT",61,35,17,9
DATA 5,"LOAD & KEEP SPL",61,45,17,9
DATA 6,"SAVE INSTRUMENT",61,55,17,9
DATA 7," ",21,35,30,5
DATA 8," ",21,41,30,5
DATA 9," ",21,47,30,5
DATA 10," ",21,53,30,5
DATA 11," ",21,59,30,5
DATA 12," ",21,65,30,5
DATA 13," ",21,71,30,5
DATA 14," ",21,77,30,5
DATA 15," ",21,83,30,5
DATA 16," ",21,89,30,5
' 14
icones_sample:
DATA 41,0,5
DATA 0,"SAMPLE       ",21,35,13,9, 1,"¸",35,35,1,9, 2,"˝",37,35,1,9
DATA 3,"NAME                             ",39,35,33,9
DATA 4,"LENGTH       ",21,50,13,9, 5,"¸",35,50,1,9, 6,"˝",37,50,1,9
DATA 7,"REPEAT       ",21,60,13,9, 8,"¸",35,60,1,9, 9,"˝",37,60,1,9
DATA 10,"REPLEN       ",21,70,13,9, 11,"¸",35,70,1,9, 12,"˝",37,70,1,9
DATA 13,"VOLUME     ",41,50,11,9, 14,"¸",53,50,1,9, 15,"˝",55,50,1,9
DATA 16,"FINETUNE   ",41,60,11,9, 17,"¸",53,60,1,9, 18,"˝",55,60,1,9
DATA 19,"BALANCE    ",41,70,11,9, 20,"¸",53,70,1,9, 21,"˝",55,70,1,9
DATA 22,"FREQUENCY      ",59,50,15,9, 23,"¸",75,50,1,9, 24,"˝",77,50,1,9
DATA 25,"NBR OF BITS    ",59,60,15,9, 26,"¸",75,60,1,9, 27,"˝",77,60,1,9
DATA 28,"KILL",74,35,4,9
DATA 29,"LIST",71,75,7,19
DATA 30,"LOAD",21,85,7,9, 31,"SAVE",29,85,7,9
DATA 32,"AVR",50,85,3,9, 33,"SPL",54,85,3,9, 34,"WAV",58,85,3,9, 35,"*",62,85,3,9
DATA 36,"   ",66,85,3,9, 37,"   ",58,75,3,9, 38,"   ",62,75,3,9, 39,"   ",66,75,3,9
DATA 40,"SIGNED",39,85,8,9
' 15
icones_sample_list:
DATA 15,0,5
DATA 0,"1st PAGE",69,75,9,19
DATA 1,"¸",53,35,1,9, 2,"˝",53,45,1,9
DATA 3,"TOP",56,35,3,9
DATA 4,"INSTRUMENT ?",61,35,17,9
DATA 5," ",21,35,30,5
DATA 6," ",21,41,30,5
DATA 7," ",21,47,30,5
DATA 8," ",21,53,30,5
DATA 9," ",21,59,30,5
DATA 10," ",21,65,30,5
DATA 11," ",21,71,30,5
DATA 12," ",21,77,30,5
DATA 13," ",21,83,30,5
DATA 14," ",21,89,30,5
' 16
icones_panneau_principal:
DATA 28,0,0
DATA 0,"POSITION      ",0,0,14,9, 1,"¸",15,0,1,9, 2,"˝",17,0,1,9
DATA 3,"PATTERN       ",0,10,14,9, 4,"¸",15,10,1,9, 5,"˝",17,10,1,9
DATA 6,"LENGTH        ",0,20,14,9, 7,"¸",15,20,1,9, 8,"˝",17,20,1,9
DATA 9,"REPEAT        ",0,30,14,9, 10,"¸",15,30,1,9, 11,"˝",17,30,1,9
DATA 12,"INSTRUMENT    ",0,45,14,9, 13,"¸",15,45,1,9, 14,"˝",17,45,1,9
DATA 15,"SAMPLE        ",0,55,14,9, 16,"¸",15,55,1,9, 17,"˝",17,55,1,9
DATA 18,"STEP   ",7,65,7,9, 19,"¸",15,65,1,9, 20,"˝",17,65,1,9
DATA 21,"SONGNAME                                 ",0,110,41,9
DATA 22,"INSTRNAME                             ",42,110,37,9
DATA 23,"TRACKS   ",0,80,9,9, 24,"LINES    ",0,90,9,9
DATA 25," ",0,65,6,9
DATA 26,"ON/OFF",0,120,7,9, 27,"PRESET",0,130,7,9
' 17
icones_enveloppe_volume:
DATA 49,0,5
DATA 0," ",21,35,3,5
DATA 1," ",21,41,3,5
DATA 2," ",21,47,3,5
DATA 3," ",21,53,3,5
DATA 4," ",21,59,3,5
DATA 5," ",21,65,3,5
DATA 6," ",21,71,3,5
DATA 7," ",21,77,3,5
DATA 8," ",21,83,3,5
DATA 9," ",21,89,3,5
DATA 10," ",26,35,15,5
DATA 11," ",26,41,15,5
DATA 12," ",26,47,15,5
DATA 13," ",26,53,15,5
DATA 14," ",26,59,15,5
DATA 15," ",26,65,15,5
DATA 16," ",26,71,15,5
DATA 17," ",26,77,15,5
DATA 18," ",26,83,15,5
DATA 19," ",26,89,15,5
DATA 20," ",68,35,10,5
DATA 21," ",68,41,10,5
DATA 22," ",68,47,10,5
DATA 23," ",68,53,10,5
DATA 24," ",68,59,10,5
DATA 25," ",68,65,10,5
DATA 26," ",68,71,10,5
DATA 27," ",68,77,10,5
DATA 28," ",68,83,10,5
DATA 29," ",68,89,10,5
DATA 30,"¸",43,35,1,9, 31,"˝",43,45,1,9
DATA 32,"¸",65,35,1,9, 33,"˝",65,45,1,9
DATA 34,"VOLUME",46,35,6,9, 35,"TONE",53,35,5,9, 36,"PAN",59,35,4,9
DATA 37,"ATTACK",47,45,7,9, 38,"KEY OFF",55,45,7,9
DATA 39,"ENVELOPE   ",43,60,11,9, 40,"¸",55,60,1,9, 41,"˝",57,60,1,9
DATA 42,"CLR ENV",59,60,7,9
DATA 43," ",44,70,21,9
DATA 44,"DEL COM",43,85,7,9
DATA 45,"COPY",52,85,6,9, 46," ",59,85,3,9, 47,"¸",63,85,1,9, 48,"˝",65,85,1,9
' 18
icones_tools3:
DATA 16,0,5
DATA 0,".../...",72,90,7,9
DATA 1,"¸",44,35,1,9, 2,"˝",44,45,1,9
DATA 3,"TOP",47,35,3,9
DATA 4,"INSERT POS",52,35,11,9, 5,"DELETE POS",52,45,11,9
DATA 6," ",21,35,30,5
DATA 7," ",21,41,30,5
DATA 8," ",21,47,30,5
DATA 9," ",21,53,30,5
DATA 10," ",21,59,30,5
DATA 11," ",21,65,30,5
DATA 12," ",21,71,30,5
DATA 13," ",21,77,30,5
DATA 14," ",21,83,30,5
DATA 15," ",21,89,30,5
' 19
icones_samples_sm7_1:
DATA 16,0,0
DATA 0,"2nd PAGE",61,115,17,19
DATA 1,"LEFT CHANNEL",1,95,13,9, 2,"RIGHT CHANNEL",1,105,13,9, 3,"MIX L & R CHN",1,115,13,9
DATA 4,"DRY LEVEL         %",17,95,19,9, 5,"FLANGE LEVEL      %",17,105,19,9
DATA 6,"FLANGE TIME      ms",39,95,19,9
DATA 7,"FLANGE FREQ      Hz",39,105,19,9
DATA 8,"FLANGE DEPTH     ms",39,115,19,9
DATA 9,"INIT PHASE       „ ",39,125,19,9
DATA 10,"1",61,95,1,9, 11,"2",64,95,1,9, 12,"3",67,95,1,9
DATA 13,"4",70,95,1,9, 14,"5",73,95,1,9, 15,"6",76,95,1,9
' 20
icones_samples_sm7_2:
DATA 20,0,0
DATA 0,"1st PAGE",67,115,11,19
DATA 1,"LEFT SOURCE    ",1,85,15,9, 2,"¸",17,85,1,9, 3,"˝",19,85,1,9, 4," ",21,85,29,9
DATA 5,"RIGHT SOURCE   ",1,115,15,9, 6,"¸",17,115,1,9, 7,"˝",19,115,1,9, 8," ",21,115,29,9
DATA 9,"LEFT ˛ LEFT        %",10,95,20,9, 10,"LEFT ˛ RIGHT      %",31,95,19,9
DATA 11,"RIGHT ˛ RIGHT      %",10,125,20,9, 12,"RIGHT ˛ LEFT      %",31,125,19,9
DATA 13,"MONO",67,85,11,9, 14,"STEREO",67,95,11,9
DATA 15,"SIN",53,85,11,9, 16,"SQUARE",53,95,11,9, 17,"TRIANGLE",53,105,11,9
DATA 18,"RAMP DOWN",53,115,11,9, 19,"RAMP UP",53,125,11,9
' 21
icones_samples_sm8_1:
DATA 16,0,0
DATA 0,"EXTRA",71,120,8,19
DATA 1,"REVERBERATION",1,85,22,9
DATA 2,"DRY LEVEL            %",1,105,22,9
DATA 3,"REVERB LEVEL         %",1,115,22,9
DATA 4,"EARLY REF LEVEL      %",1,125,22,9
DATA 5,"NUMBER OF TAPS   ",26,95,17,9, 6,"¸",44,95,1,9, 7,"˝",46,95,1,9
DATA 8,"NUMBER OF C.F.   ",50,95,17,9, 9,"¸",68,95,1,9, 10,"˝",70,95,1,9
DATA 11,"OVERALL GAIN        %",50,105,21,9
DATA 12,"SOURCE   ",26,125,9,9, 13,"¸",36,125,1,9, 14,"˝",38,125,1,9
DATA 15," ",40,125,29,9
' 22
icones_samples_sm8_2:
DATA 14,0,0
DATA 0,"MAIN PAGE",68,120,11,19
DATA 1," ",1,90,1,41, 2," ",4,90,4,41, 3," ",10,90,4,41
DATA 4,"¸",16,90,1,9, 5,"˝",16,100,1,9
DATA 6," ",20,90,1,41, 7," ",23,90,4,41, 8," ",29,90,4,41
DATA 9,"¸",35,90,1,9, 10,"˝",35,100,1,9
DATA 11,"DELAY      ms",39,95,13,9, 12,"GAIN       % ",53,95,13,9
DATA 13,"DELAY      ms",39,125,13,9
' 23
icones_song2disk:
DATA 21,0,0
DATA 0," ",7,95,1,9, 1," ",12,95,1,9
DATA 2," ",7,105,1,9, 3," ",12,105,1,9
DATA 4,"8 BITS",17,85,7,9, 5,"16 BITS",25,85,7,9
DATA 6,"MONO",17,105,7,9, 7,"STEREO",25,105,7,9
DATA 8,"BLOCK",35,95,5,9, 9,"DISK",35,105,5,9
DATA 10,"MAXIMUM DURATION      s ",43,95,24,9
DATA 11,"MAXIMUM SIZE          Kb",43,105,24,9
DATA 12,"1  HIGH",70,95,8,9, 13,"2",70,105,2,9, 14,"3",73,105,2,9, 15,"4",76,105,2,9
DATA 16,"5",70,115,2,9, 17,"6",73,115,2,9, 18,"7",76,115,2,9, 19,"8   LOW",70,125,8,9
DATA 20,"RECORD",1,125,9,9
' 24
texte_icone1:
DATA 16,0,0
DATA 0,"PLAY SONG",20,0,11,9, 1,"EDIT",32,0,11,9, 2,"INSERT POS",44,0,11,9
DATA 3,"PREFS",56,0,11,9, 4,"SCORE",68,0,11,9
DATA 5,"PLAY PAT.",20,10,11,9, 6,"STOP",32,10,11,9, 7,"DELETE POS",44,10,11,9
DATA 8,"HELP",56,10,11,9, 9,"SAMPLE EDIT",68,10,11,9
DATA 10,"DISK",20,20,8,9, 11,"TOOLS",29,20,8,9, 12,"INSTRUMENTS",38,20,11,9
DATA 13,"SAMPLES",50,20,9,9, 14,"ENVELOPES",60,20,9,9, 15,"CONTROL",70,20,9,9
' 25
icones_control:
DATA 50,0,5
DATA 0," ",20,30,0,0, 1,"RESET",44,35,5,9
DATA 2," ",21,40,2,47, 3," ",21,92,2,5
DATA 4," ",26,40,2,47, 5," ",26,92,2,5
DATA 6," ",31,40,2,47, 7," ",31,92,2,5
DATA 8,"TEMPO    ",36,75,9,9, 9,"¸",46,75,1,9, 10,"˝",48,75,1,9
DATA 11,"SPEED    ",36,85,9,9, 12,"¸",46,85,1,9, 13,"˝",48,85,1,9
DATA 14,"01-08",36,45,6,9, 15,"09-16",43,45,6,9
DATA 16,"17-24",36,55,6,9, 17,"25-32",43,55,6,9
DATA 18," ",56,32,2,5, 19,"ˇ",60,31,1,7, 20,"˛",62,31,1,7, 21," ",52,40,11,5
DATA 22," ",56,49,2,5, 23,"ˇ",60,48,1,7, 24,"˛",62,48,1,7, 25," ",52,57,11,5
DATA 26," ",56,66,2,5, 27,"ˇ",60,65,1,7, 28,"˛",62,65,1,7, 29," ",52,74,11,5
DATA 30," ",56,83,2,5, 31,"ˇ",60,82,1,7, 32,"˛",62,82,1,7, 33," ",52,91,11,5
DATA 34," ",70,32,2,5, 35,"ˇ",74,31,1,7, 36,"˛",76,31,1,7, 37," ",66,40,11,5
DATA 38," ",70,49,2,5, 39,"ˇ",74,48,1,7, 40,"˛",76,48,1,7, 41," ",66,57,11,5
DATA 42," ",70,66,2,5, 43,"ˇ",74,65,1,7, 44,"˛",76,65,1,7, 45," ",66,74,11,5
DATA 46," ",70,83,2,5, 47,"ˇ",74,82,1,7, 48,"˛",76,82,1,7, 49," ",66,91,11,5
' 26
icones_samples_sm9:
DATA 9,0,0
DATA 0,"DO",1,85,15,49
DATA 1,"SOURCE   ",19,125,9,9, 2,"¸",29,125,1,9, 3,"˝",31,125,1,9
DATA 4," ",33,125,29,9
DATA 5,"LEVEL       %",19,85,13,9
DATA 6,"SPEED    ",19,105,9,9, 7,"¸",29,105,1,9, 8,"˝",31,105,1,9
'
touches_notes:
DATA 44,31,45,32,46,47,34,48,35,49,36,50,51,38,52,39,53
DATA 16,3,17,4,18,19,6,20,7,21,8,22,23,10,24,11,25,26,13,27,41
'
enveloppe_coms:
DATA $0,6
DATA "End",0,"Jump to ",0,"Wait ",50,"Set Counter ",1,"Loop to ",0,"Key Off",0
DATA $80,11
DATA "Volume ",$4000,"Vol Step ",0,"Vol Speed ",1
DATA "Tremolo On",0,"Tremolo Off",0,"Trem Width ",$10,"Trem Speed ",8
DATA "Tremor On",0,"Tremor Off",0,"TremorTime1 ",3,"TremorTime2 ",3
DATA $A0,7
DATA "Period ",$1000,"Tone Step ",0,"Tone Speed ",1
DATA "Vibrato On",0,"Vibrato Off",0,"Vib Width ",3,"Vib Speed ",8
DATA $C0,3
DATA "Panning ",$800,"Pan Step ",0,"Pan Speed ",1
'
rev_tap_delay_level:
DATA 0,0.213, 0.0349,0.135, 0.0714,0.051, 0.0178,0.217, 0.0371,0.153, 0.0317,0.174, 0.0627,0.157
rev_comb_delay_lpf:
DATA 0.0547,0.448, 0.07,0.496, 0.0448,0.408, 0.0646,0.476
'
help_text:
DATA "              ******************************************"
DATA "              *                                        *"
DATA "              *     G R A O U M F   T R A C K E R      *"
DATA "              *                                        *"
DATA "              *           Version Beta-demo            *"
DATA "              *      by Laurent de SORAS - 1994/95     *"
DATA "              *                                        *"
DATA "              *     "Bidibidi Zwivvv Bidibidi Toc      *"
DATA "              *         Eki Eki Eki Ta Pang !          *"
DATA "              *      Ata Ata Oglo Hulu : Ni Ni !"      *"
DATA "              *                                        *"
DATA "              ******************************************"
DATA ""
DATA "                             ------------"
DATA "                             -   HELP   -"
DATA "                             ------------"
DATA ""
DATA "Graoumf Tracker is Shareware!!!"
DATA "You can copy me, but if you like me, you MUST send your money to my"
DATA "creator (100 FF, $25 or 30 DM):"
DATA "Laurent de Soras"
DATA "92 Avenue Albert 1er"
DATA "92500 Rueil-Malmaison"
DATA "FRANCE"
'
DATA "Les notes"
DATA "---------"
DATA ""
DATA "C  C# D  D# E     F  F# G  G# A  A# B     C  C# D  D# E    F  F# G  G#"
DATA "----------------------------------------------------------------------"
DATA "   2     3           5     6    7            9     0          -     `"
DATA "A     Z     E     R     T     Y     U     I     O     P    ^     $"
DATA "----------------------------------------------------------------------"
DATA "   S     D           G     H     J           L     M"
DATA "W     X     C     V     B     N     ,     ;     :     ="
DATA "----------------------------------------------------------------------"
DATA ""
DATA "Les touches"
DATA "-----------"
DATA ""
DATA "SHIFT + ˇ ou ˛            : Position +/-"
DATA "SHIFT + ¸ ou ˝            : Saute au debut de la mesure la plus proche"
DATA "TAB                       : Place le curseur sur la colonne suivante"
DATA "SHIFT + TAB               : L'inverse de ci-dessus"
DATA "CTRL + ˇ ou ˛             : Change de preset"
DATA "BACKSPACE                 : Detruit la note sous le curseur et l'instr"
DATA "SHIFT + BACKSPACE         : Detruit seulement l'effet"
DATA "CTRL + BACKSPACE          : Detruit note, numero d'instrument et effet"
DATA "ALT + BACKSPACE           : Detruit la commande de volume"
'
DATA "CTRL + DELETE             : Supprime une ligne de la voie sur laquelle"
DATA "                            est le curseur"
DATA "SHIFT gauche + DELETE     : Supprime une ligne du pattern"
DATA "SHIFT gauche + CTRL + DEL : Supprime une ligne du preset"
DATA "CTRL + INSERT             : Insere une ligne dans la voie sur laquelle"
DATA "                            est le curseur"
DATA "SHIFT gauche + INSERT     : Insere une ligne dans le pattern"
DATA "SHIFT gauche + CTRL + INS : Insere une ligne dans le preset"
DATA "Ces 6 commandes + SHIFT d : Rotation vers le haut ou le bas au lieu"
DATA "                            d'inserion/suppression"
DATA "Pave numerique (+SHIFT d) : Selection d'un instrument"
DATA "INSERT                    : Diminue le numero du sample courant"
DATA "CLR HOME                  : Augmente le numero du sample courant"
DATA "ESC                       : Change l'octave du clavier"
DATA "F5                        : Selection Numero de sample/Drumpad"
DATA "SHIFT gauche + Pave       : Enregistrer sur le drumpad la note sous le"
DATA "                            curseur"
DATA "RETURN ou 0 du pave       : Play song"
DATA "SHIFT + RET ou + 0 pave   : Play pattern"
DATA "F4                        : Cont song"
DATA "SHIFT + F4                : Cont pattern"
DATA "F6 - F10 (+ SHIFT)        : Ligne 00, 10, 20, 30 et 3F (+40)"
DATA ""
DATA ""
'
DATA "F1                        : Marque le debut du bloc"
DATA "SHIFT + F1                : Marque la fin du bloc"
DATA "F2                        : Copie le bloc sur le curseur (piste)"
DATA "SHIFT + F2                : Copie le bloc (pattern)"
DATA "CTRL + F2                 : Copie le bloc (preset)"
DATA "ALT + F2                  : Copie le bloc (la voie sous le curseur)"
DATA "CTRL + SHIFT + ¸          : Augmente de 2 lignes l'affichage du patt."
DATA "CTRL + SHIFT + ˝          : Diminue de 2 lignes l'affichage du pattern"
DATA "CTRL + D                  : Affiche le temps machine"
DATA "CTRL + E                  : Acces a la colonne de volume"
DATA "                            Vision normale ou globale"
DATA "CTRL + I                  : Interpolation On/Off sur la voie du curseur"
DATA "CTRL + SHIFT + I          : Interpolation On/Off sur toutes les voies"
DATA "CTRL + R                  : Change la frequence de replay"
DATA "CTRL + S                  : Augmentation de 1 du pas d'edition"
DATA "  + SHIFT                 : Diminution de 1 du pas d'edition"
DATA "ALT + L                   : Load module"
DATA "ALT + S                   : Save module"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'
DATA "Les Effets"
DATA "----------"
DATA ""
DATA "01xx : Portamento up"
DATA "02xx : Portamento down"
DATA "03xx : Tone portamento"
DATA "04xy : Vibrato"
DATA "05xx : Tone portamento + Vibrato"
DATA "06xy : Vibrato + Tone portamento"
DATA "07xy : Tremolo"
DATA "08xy : Detune"
DATA "09xx : Note delay"
DATA "0Axx : Cut note"
DATA "0Bxx : Go to line"
DATA "0C?x : Set vibrato waveform"
DATA "0Dxx : Break pattern"
DATA "0E?x : Set tremolo waveform"
DATA "0Fxx : Set global speed/Tempo"
DATA "10xy : Arpeggio"
DATA "11xx : Fine portamento up"
DATA "12xx : Fine portamento down"
DATA "13xy : Roll + Volume slide"
DATA "14xx : Linear volume slide up"
DATA "15xx : Linear volume slide down"
'
DATA "16xx : Exp. volume slide up"
DATA "17xx : Exp. volume slide down"
DATA "18xx : Linear volume slide up + Tone portamento"
DATA "19xx : Linear volume slide down + Tone portamento"
DATA "1Axx : Exp. volume slide up + Tone portamento"
DATA "1Bxx : Exp. volume slide down + Tone portamento"
DATA "1Cxx : Linear volume slide up + Vibrato"
DATA "1Dxx : Linear volume slide down + Vibrato"
DATA "1Exx : Exp. volume slide up + Vibrato"
DATA "1Fxx : Exp. volume slide down + Vibrato"
DATA "A0xx : Linear master volume slide up"
DATA "A1xx : Linear master volume slide down"
DATA "A4xx : Fine linear volume up"
DATA "A5xx : Fine linear volume down"
DATA "A6xx : Fine linear master volume up"
DATA "A7xx : Fine linear master volume down"
DATA "A8xx : Set number of frames"
DATA "A9xx : Set fine speed"
DATA "AAxx : Pattern delay"
DATA "ABxx : Extra fine tone portamento"
DATA "ACxx : Extra fine portamento up"
DATA "ADxx : Extra fine portamento down"
DATA "AExx : Left balance move"
DATA "AFxx : Right balance move"
'
DATA "B0xy : Tremor"
DATA "B1xx : Pattern loop"
DATA "B2xx : Set flags... +1 : interpolation"
DATA "2xxx : Set linear volume"
DATA "3xxx : Set exp. volume"
DATA "4xxx : Set balance"
DATA "5xxx : Set master linear volume"
DATA "6xxx : Set master esp. volume"
DATA "7xyy : Roll"
DATA "8xyz : Roll + volume slide + set balance"
DATA "9xxx : Offset sample"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'
DATA "THE CRUCIFICTION OF SEAN PENN"
DATA ""
DATA "We're gonna kill the California girls"
DATA "We're gonna fire the exploding load"
DATA "in the milkmaid maidenhead"
DATA "We're gonna find the meaning of feeling good"
DATA "And we're gonna stay there as long as we think we should"
DATA "  Mystery train"
DATA "  Three way plane"
DATA "  Expressway to yr skull"
DATA ""
DATA "                                               (SoNiC YoUTh / E.V.O.L)"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'    "1234567890123456789012345678901234567890123456789012345678901234567890"
DATA "***"
'
textes_blagues:
DATA "Mr et Mme BRICOT ont un fils,|comment l'appelent-ils ?||R : Judas","*"
DATA "Mr et Mme POTDANLAPOCHE ont une fille,|comment l'appelent-ils ?||R : Jessica","*"
DATA "Mr et Mme PEULAFENETRE ont trois fils,|comment les appelent-ils ?||R : Geoffroy, Angele, Firmin","*"
DATA "Mr et Mme HERGEBEL ont un fils,|comment l'appelent-ils ?||R : Octave","*"
DATA "Mr et Mme PAFROI ont sept fils,|comment les appelent-ils ?||R : Eva, Aude, Anne, Marc, Sanson, Gilles et Ella","*"
DATA "Mr et Mme PROVISTSAPU ont trois fils,|comment les appelent-ils ?||R : Quentin, Gaspard, Alain","*"
DATA "Mr et Mme LIOTEKDAKAJOU ont un fils,|comment l'appelent-ils ?||R : Habib","*"
DATA "Mr et Mme REMORD ont un fils,|comment l'appelent-ils ?||R : Yves","*"
DATA "Mr et Mme POURLAVERLCARLAGE ont un fils,|comment l'appelent-ils ?||R : Vladimir","*"
DATA "Mr et Mme CREMENT ont un fils,|comment l'appelent-ils ?||R : Alex","*"
DATA "Mr et Mme TANANANANANANA ont deux fils,|comment les appelent-ils ?||R : Starsky et Hutch","*"
DATA "Mr et Mme LFRIGO ont cinq fils,|comment les appelent-ils ?||R : Steve, Eude, Hubert, Yann, Adam","*"
DATA "Mr et Mme ERVITMONSLIP ont un fils,|comment l'appelent-ils ?||R : Jean-Philippe","*"
DATA "Mr et Mme ZELPOURMONMOTEUR ont un fils,|comment l'appelent-ils ?||R : Didier","*"
DATA "Mr et Mme MAIJAVALPA ont un fils,|comment l'appelent-ils ?||R : Jesus","*"
DATA "Mr et Mme MAROLEX ont une fille,|comment l'appelent-ils ?||R : Eleonore","*"
DATA "Mr et Mme PONSABLDUMATOS ont une fille,|comment l'appelent-ils ?||R : Therese","*"
DATA "Mr et Mme LUTFINALE ont une fille,|comment l'appelent-ils ?||R : Sheila","*"
DATA "Mr et Mme CHMONFILS ont un fils,|comment l'appelent-ils ?||R : Thierry","*"
DATA "Mr et Mme BIENUNPTICASCROUTE ont un fils,|comment l'appelent-ils ?||R : Humphrey","*"
DATA "Mr et Mme BISTROJAISOIF ont un fils,|comment l'appelent-ils ?||R : Alonzo","*"
DATA "Mr et Mme CONERY ont une fille,|comment l'appelent-ils ?||R : Aretha","*"
DATA "Mr et Mme PUDBIERDANLFRIGO ont un fils,|comment l'appelent-ils ?||R : Roger","*"
DATA "Mr et Mme ITZEGOUDWAITOUZESTATION ont une fille,|comment l'appelent-ils ?||R : Eloise","*"
DATA "Mr et Mme POURIEN ont trois fils,|comment les appelent-ils ?||R : Yvon, Paul et Mickey","*"
DATA "Mr et Mme AMAR ont cinq fils,|comment les appelent-ils ?||R : Ella, Pacome, Ancel, Helene,|Nadege","*"
DATA "Mr et Mme NAIBOURREDAITA ont trois fils,|comment les appelent-ils ?||R : Derek, Tom, Jean","*"
DATA "Mr et Mme Ore ont un fils,|qui est l'ami du fils de|Mr et Mme Jeuner. Comment|s'appele le fils des Ore ?||R : Rick|Car Rick Ore, l'ami du petit des Jeuner","*"
DATA "Mr et Mme SURLELITETPASSURLECANAPE ont un chien,|comment l'appelent-ils ?||R : Medor","*"
DATA C'est un chat|qui se fait eventrer|par John Borg|qui a besoin de|nouvelles|cordes.||Le chat dit :|"C'est du racket!"
DATA "*","C'est deux Corses qui se promenent.|Tout d'un coup, l'un deux se retourne"
DATA "et ecrase un escargot. L'autre :|- Ben pourquoi t'as fait ca ?"
DATA "- Ca faisait un quart d'heure|que cette bestiole nous suivait!","*"
DATA "2 vieilles dames discutent|sur la terrasse d'un cafe :"
DATA "- J'ai l'impression que l'homme la-bas,|il nous regarde avec envie."
DATA "- Tu m'etonnes, c'est l'antiquaire!","*"
DATA "Saviez-vous qu'il y a deux|sortes de Pastis ?|- Le Pastis 51 au gout d'anis|- Le Pastis 69 au gout d'anus","*"
DATA "C'est un type qui veut se suicider."
DATA "Pour son dernier jour, il se lave, se coiffe,"
DATA "se relave, met du Petrol Hane, du parfum,"
DATA "enfile ses plus beaux habits."
DATA "Il monte en haut de la Tour Eiffel, et saute."
DATA "Le corps s'ecrase, suivi plusieurs secondes"
DATA "apres de ses cheveux.|Pourquoi ?|"
DATA "R : parceque Petrol Hane ralentit|la chute des cheveux...","*"
DATA "C'est un gars qui a une moumoute et|qui va chez le coiffeur"
DATA "La, rien a faire, les ciseaux|n'arrivent pas a couper les cheveux.|Pourquoi ?|"
DATA "R : parceque les faux tifs ne sont pas coupables","*"
DATA "Pourquoi les Somaliens ne prennent-|ils pas de medicament ?||R : C'est marque dessus :|"A prendre apres chaque repas","*"
DATA "Qu'est-ce qui est le plus|dur a manger dans|un legume ?||R : la chaise roulante","*"
DATA "Quel est le point commun entre|un myopathe et un spaghetti ?||R : Le spaghetti bouge quand|on le suce...","*"
DATA "Qu'est-ce qui est vert|et qui devient rouge|quand on appuie sur|un bouton ?||R : Une grenouille dans un mixer","*"
DATA "Qu'est-ce qui est vert|et qui pue au fond des bois ?||R : Un scout mort","*"
DATA "Qu'est-ce qui est rouge|et qui a plus de cervelle|que Kurt Cobain ?||R : Son plafond","*"
DATA "Qu'est-ce qui est petit, rouge,|et qui avance en faisant|beaucoup de bruit ?||R : Un bebe sucant des lames de rasoir","*"
DATA "Qu'est-ce qui est petit, rouge,|et qui ne tourne pas dans|les couloirs ?||R : Un enfant avec un javelot|dans la tete.","*"
DATA "Qu'est-ce qu'une boite jaune a|l'exterieur et noire a l'interieur ?||R : Une R4 de la Poste","*"
DATA "Qu'y a-t-il de pire qu'un|bebe dans une poubelle ?||R : Un bebe dans deux poubelles","*"
DATA "Qu'est-ce qu'un combat|d'eunuques ?||R : c'est un combat sanglant","*"
DATA "C'est J.C. Vandame qui rentre|dans sa bagnole et qui|fout l'contact","*"
DATA "C'est Stallone qui va au|bal et qui se rend beau","*"
DATA "C'est un mec qui rentre|dans un cafe et PLOUF!","*"
DATA "C'est un sanglier qui|croise un cochon:|- Ca se passe bien pour|toi la chimiotherapie ?","*"
DATA "Vous connaissez l'histoire|de Paf le chien ?||C'est un chien qui traverse|l'autoroute et PAF le chien!","*"
DATA "Vous connaissez l'histoire|de Scroutch l'escargot ?||C'est un escargot qui passe|sous un rouleau compresseur|et SCROUTCH l'escargot!","*"
DATA "Vous connaissez l'histoire|de Zip le pingouin ?||C'est un pingouin qui se promene|sur la banquise et ZIP le pingouin!","*"
DATA "Vous connaissez l'histoire|de Flip-Flop la girafe ?||C'est un helicoptere qui fait du|rase-motte et FLIP-FLOP la girafe!","*"
DATA "Vous connaissez l'histoire|de Tiens la vieille ?||C'est une vieille qui se fait|frapper et TIENS la vieille!","*"
DATA "***"
