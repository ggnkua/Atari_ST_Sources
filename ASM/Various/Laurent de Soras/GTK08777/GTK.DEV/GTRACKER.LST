' ****************************************************************************
' *                                                                          *
' * #### #### #### #### #  # #   # ####  ##### #### #### #### #  # #### #### *
' * #    #  # #  # #  # #  # ## ## #       #   #  # #  # #    #  # #    #  # *
' * # ## ###  #### #  # #  # # # # ###     #   ###  #### #    ###  ###  ###  *
' * #  # #  # #  # #  # #  # #   # #       #   #  # #  # #    #  # #    #  # *
' * #### #  # #  # #### #### #   # #       #   #  # #  # #### #  # #### #  # *
' *                                                                          *
' *         THE ULTIMATE 32-VOICES DSP SOUNDTRACKER ON ATARI FALCON.         *
' *                        TO SERVE WITH FRESH BLOOD.                        *
' *                                                                          *
' *              GRAOUMF TRACKER by Laurent de SORAS ~ 1994-96               *
' *                                                                          *
' ****************************************************************************
'
' GRAOUMF TRACKER by Laurent de SORAS and the Graoumf Devteam ~ 2000
'
' The Graoumf Devteam is:
'                         - sjx
'                         - lp
'
' ============================================================================
' Divers bugs et contraintes dus au GfA-Basic:
'     - Ne pas utiliser EXIST() (fonction redefinie).
'     - Sous le compilateur, les operations flottantes a arguments uniquement
' entiers ne sont pas toujours calculees en flottant.
' ============================================================================
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                              Initialisations                             *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' -------------------------- [ post-SORAS version history ] ------------------
' /sjx - 0.8776 - Correcting typos and making bugfixes, about 10 in all.
'                 Notably, envelopes are now actually saved in GT2 modules!
'                 Also, new configuration file options:
'                     grmode_preserve  (set to yes to force graoumf not to change resolution)
'                     grmode_skipxbra  (set to yes to force graoumf not to unhook NVDI, etc.)
'                 ... these ought to improve stability in certain cases.
'                 See the update documentation for more detailed info.
' /sjx - 0.8775 - Workaround for a bug in 0.8770 (which would save GT2 modules
'                 with a quirk whereby some samples would start with a 'ASMP'
'                 chunk). Looks like the old binary sometimes did one too many
'                 byteswaps, so as a result, the loader has to be kludged.
'                 (On the bright side, once saved again, it'll be correct.)
' /sjx - 0.8774 - Full support for Octalyser modules (e.g., CD83) added.
' /sjx - 0.8773 - Seriously braindead bug ("jmp 0"?!) with unknown module type
'                 fixed - bug in compiler. Don't goto to an undefined label!
' /sjx - 0.8772 - Some registration legacy code removed; as now freeware.
'        0.8771 - Laurent de SORAS's full source code release. Freeware.
'                 Note that changes between 8870 and 8771 are unknown.
'        0.8770 - Last known binary release.
' ----------------------------------------------------------------------------
gtk_version%=8776               ! Numero de version du logiciel x10000
gtk_file_vnum%=4                ! Numero de format de module GTK
gt2_file_vnum%=4                ! Numero de format de module GT2
npath_prog$=CHR$(ADD(65,GEMDOS(&H19)))+":"+DIR$(0)+"\SYS\"
' npath_prog$="E:\DEV.GTK\SYS\"   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
npath_prefs$=npath_prog$        ! Chemin des preferences
nfile_prefs$="GTKPREFS.INF"     ! Fichier de preferences a charger
nfile_present$="PRESENT.PIC"    ! Nom de l'image de presentation
nfile_logo$="GT_LOGO.PI1"       ! Nom du logo
key_click%=PEEK(&H484)          ! Sauve l'etat du clavier
'
GOSUB init_variables_prefs
'
IF FN exist(npath_prefs$+nfile_prefs$)
  GOSUB load_prefs2(npath_prefs$+nfile_prefs$,TRUE)
ENDIF
'
' Initialisations diverses 1
' --------------------------
xbra_remove$=""                                 ! Les adr de tous les vecteurs detournes (adr_vect.l, old_val_vect.l)
zone%=0                                         ! C'est a cause du Mfree qui peut intervenir avant le Malloc (break)
oldscreenmode%=0                                ! Idem.
GOSUB change_resolution
adr_af_pat%=ADD(XBIOS(2),MUL(SHR(scr_larg%,1),170))     ! Adresse d'affichage des patterns
ON BREAK GOSUB br
GOSUB bee(TRUE)
SPOKE &H484,PEEK(&H484) AND -2
~XBIOS(&H82,4,2)
~XBIOS(&H82,5,0)                                ! Connecte l'ADC pour la partie enregistrement
GOSUB charge_g_routines
attente_fin_presentation%=0                     ! Nombre de secondes a attendre apres la presentation
graoumf_logo$=""                                ! Le logo
graoumf_logo_mask$=""                           ! Et son masque
GOSUB charge_image_presentation
'
GOSUB init_tableaux
'
' Initialisations diverses 2
' --------------------------
para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
garbage%=0
GOSUB charge_r_routines
ARRAYFILL module&(),&H2020                      ! Initialise le module
module&(0)=&H4754
module&(1)=ADD(&H4B00,gtk_file_vnum% AND 255)
module&(98)=255                                 ! Nbr d'instr
module&(99)=nbr_lines%
module&(100)=nbr_track%
module&(101)=1
module&(102)=0
'
GOSUB reset_all_midi_track_state
GOSUB chg_midi_flag_data_in(midi_flag_data_in!)
'
GOSUB init_fonctions_simples
'
GOSUB init_variables_post_prefs
'
HIDEM
SETMOUSE SHL(ADD(divbi&(0,0,0),SHR(SUCC(divbi&(2,0,0)),1)),3),ADD(divbi&(1,0,0),5),0
GOSUB teste_enregistrement
HIDEM
GOSUB attente_interruptible(attente_fin_presentation%)
CLS
GOSUB nouvelle_palette(color_pal$)
IF NOT flag_registered!
  SHOWM
  GOSUB affiche_please_register
ENDIF
GOSUB affiche_panneau_principal
~FRE(0)
GOSUB autoload
GOSUB aff_message("Welcome to GRAOUMF TRACKER v"+STR$(gtk_version%/10000)+mes_registred$)
ON ERROR GOSUB erreur_gfa_basic
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                            Boucle principale                             *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
DO
  '
  ' Souris
  ' ------
  SHOWM
  MOUSE xm%,ym%,km%
  IF km%<>0 AND xm%<8 AND ym%<8         ! On se barre ?
    GOSUB dialog("QUIT","Do you really want to quit|GRAOUMF TRACKER ?","Yes sir!|Bof...|No, no!",xm%,ym%)
    IF bouton%=0 OR (bouton%=1 AND (TIMER AND 1)=1)
      CLS
      IF NOT flag_registered!
        GOSUB affiche_please_register
      ENDIF
      GOSUB br
    ELSE
      GOSUB affiche_panneau_principal
      MOUSE xm%,ym%,km%
    ENDIF
  ELSE IF km%<>0 AND xm%=PRED(scr_larg%) AND ym%=PRED(scr_haut%)
    flag_blague!=TRUE
  ENDIF
  '
  ' Icones a repetition
  ' -------------------
  IF km%<>0 AND ym%>159 AND ym%<170
    ' Changement de la voie d'une colonne
    IF type_affpiste%=0         ! Selon la taille d'une piste
      a%=SUB(xm%,24) MOD 48
      b%=DIV(SUB(xm%,24),48)
      c%=6
    ELSE IF type_affpiste%=2
      a%=SUB(xm%,24) MOD 96
      b%=DIV(SUB(xm%,24),96)
      c%=12
    ELSE
      a%=SUB(xm%,24) MOD 80
      b%=DIV(SUB(xm%,24),80)      ! Numero de la colonne
      c%=10
    ENDIF
    IF km%=1 AND b%=>0 AND b%<MIN(nbr_col%,nbr_colonnes%(n_preset%))
      IF a%>47
        IF a%<64          ! Fleche haut
          d%=1
        ELSE IF a%<80     ! Fleche bas
          d%=-1
        ENDIF
        preset&(b%,n_preset%)=MIN(MAX(ADD(preset&(b%,n_preset%),d%),0),PRED(nbr_track%))
      ELSE
        a$=STR$(SUCC(preset&(b%,n_preset%)),2)
        GOSUB edite_chaine(a$,ADD(MUL(b%,c%),6),162,2,2)
        preset&(b%,n_preset%)=MIN(MAX(PRED(VAL(bbbb$)),0),PRED(nbr_track%))
        GOSUB affiche_c_pattern
      ENDIF
      GOSUB affiche_info_preset
    ELSE IF km%=2 AND a%>7 AND a%<48 AND b%=>0 AND b%<nbr_col%
      nbr_colonnes%(n_preset%)=SUCC(b%)
      curs_col%=MIN(curs_col%,b%)
      GOSUB affiche_info_preset
    ENDIF
    GOTO fin_test_souris
  ENDIF
  '
  ' Icones a simple clic
  ' --------------------
  IF km%<>0 AND ym%<30 AND xm%>167 AND xm%<640  ! Icones du haut
    ~FRE(0)
    GOSUB gere_icones_haut
  ELSE IF km%<>0 AND ym%>34 AND ym%<105 AND xm%>159 AND xm%<640
    ~FRE(0)
    ON ss_menu% GOSUB gere_icones_disk,gere_icones_tools,gere_icones_instr,gere_icones_sample,gere_icones_enveloppe,gere_icones_control,gere_icones_midi
  ELSE IF km%<>0 AND ym%>129 AND ym%<140 AND xm%>63 AND xm%<576
    ' --- Choix d'un preset --------------------------------------------------
    GOSUB chg_preset(SHR(SUB(xm%,64),4))
  ELSE IF km%<>0 AND ym%>169 AND ym%<ADD(170,MUL(haut_lig%,6)) AND xm%>31
    ' --- Clic sur une colonne -----------------------------------------------
    IF type_affpiste%=0               ! Selon la largeur d'une piste
      a%=DIV(SUB(xm%,32),48)
      b%=SUB(SUB(xm%,32),MUL(a%,48))
    ELSE IF type_affpiste%=2
      a%=DIV(SUB(xm%,32),96)
      b%=SUB(SUB(xm%,32),MUL(a%,96))
    ELSE
      a%=DIV(SUB(xm%,32),80)
      b%=SUB(SUB(xm%,32),MUL(a%,80))
    ENDIF
    IF km%=1
      ' Bouton gauche: positionne le curseur
      IF a%<nbr_colonnes%(n_preset%) AND b%<72
        curs_col%=a%
        curs_x%=MAX(0,SUB(SHR(b%,3),2))
        a%=ADD(170,MUL(SHR(haut_lig%,1),6))
        IF ym%<a%
          posligne%=MAX(0,MIN(PRED(FN nbr_lines3),ADD(posligne%,DIV(SUB(ym%,ADD(a%,5)),6))))
        ELSE IF ym%>ADD(a%,5)
          posligne%=MAX(0,MIN(PRED(FN nbr_lines3),ADD(posligne%,DIV(SUB(ym%,a%),6))))
        ENDIF
        IF play%>0
          DPOKE r_mod_linepos%,posligne%
        ENDIF
        GOSUB affiche_c_pattern
        GOSUB wait_mouse(TRUE)
      ENDIF
      ' Bouton droit: track on/off
    ELSE IF km%=2
      IF a%<nbr_colonnes%(n_preset%)
        a%=preset&(a%,n_preset%)
        GOSUB chg_a_track_onoff(a%,ABS(SGN(FN track_onoff(a%))) XOR 1)
        GOSUB wait_mouse(TRUE)
      ENDIF
    ENDIF
  ELSE IF km%<>0 AND ym%>119 AND ym%<130 AND xm%>63
    ' --- Track on/off, par appui sur les touches ----------------------------
    a%=SHR(SUB(xm%,64),4)
    IF a%<nbr_track%
      IF km%=1          ! Track on/off
        GOSUB chg_a_track_onoff(a%,ABS(SGN(FN track_onoff(a%))) XOR 1)
      ELSE              ! Track cliquee on, les autres off
        FOR i%=0 TO PRED(nbr_track%)
          IF i%<>a%
            GOSUB chg_track_onoff(i%,0)
            GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(8,SHL(i%,1)),120,1,FN track_onoff(i%) XOR 1)
          ELSE
            GOSUB chg_track_onoff(i%,1)
            GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(8,SHL(i%,1)),120,1,FN track_onoff(i%) XOR 1)
          ENDIF
        NEXT i%
        GOSUB affiche_info_preset
      ENDIF
      GOSUB affiche_info_preset
      GOSUB wait_mouse(TRUE)
    ENDIF
  ELSE IF km%>0
    ' --- Toutes les autres icones -------------------------------------------
    GOSUB gere_icones_panneaup
  ENDIF
fin_test_souris:
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  ' MIDI In
  ' -------
  IF edit%<>0 AND play%=0                       ! Seulement en Edit sans Play
    IF CARD{r_midi_in_gfa_playline%}<>0         ! Une ou des notes frappees?
      CARD{r_midi_in_gfa_playline%}=0
      FOR i%=0 TO PRED(nbr_track%)
        a%=ADD(r_new_note_buffer%,MUL(i%,6))
        b%=FN adr_strk(songpos%,posligne%,i%)
        IF BYTE{a%}<>0                          ! Si nouvelle note sur cette piste,
          LONG{b%}=LONG{SUCC(a%)}               ! copie-la sur le pattern
          BYTE{ADD(b%,4)}=BYTE{ADD(a%,5)}
          BYTE{a%}=0
        ENDIF
        LONG{ADD(V:pattern_bidon%(8),MUL(i%,5))}=LONG{b%}
        BYTE{ADD(V:pattern_bidon%(8),ADD(MUL(i%,5),4))}=BYTE{ADD(b%,4)}
      NEXT i%
      GOSUB play_pattern_bidon
      GOSUB next_line
    ENDIF
  ENDIF
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  ' Clavier
  ' -------
  GOSUB gestion_clavier
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  ' Affichages
  ' ----------
  ' Pattern et horloge
  IF play%>0
    posligne%=DPEEK(r_mod_linepos%)
    GOSUB affiche_c_pattern
    IF play%=1 AND songpos%<>DPEEK(r_mod_songpos%)
      songpos%=DPEEK(r_mod_songpos%)
      GOSUB affiche_info_song
    ENDIF
    GOSUB affiche_temps
  ENDIF
  ' Raffraichissement du sous-menu Control
  IF ss_menu%=6
    IF ss_menuc%=1
      GOSUB affiche_icones_controlc(FALSE)
      GOSUB affiche_icones_controld(FALSE)
    ELSE IF ss_menuc%=2
      GOSUB affiche_icones_controlc2(FALSE)
      GOSUB affiche_icones_controld2(FALSE)
    ENDIF
  ENDIF
  ' Temps machine
  IF play%>0 OR flag_cpu_display!
    GOSUB affiche_cpu_time_pourcent
  ENDIF
  ' Blague
  IF flag_blague!
    IF INT(RND*SHR(periode_blague%,MUL(SGN(play%),2)))=0
      a$=blague$(INT(RND*blague_nbr%))
      GOSUB dialog("JOKE",a$,"Hahaha!!!|Bide...",SHR(scr_larg%,1),SHR(scr_haut%,1))
      IF bouton%=0
        GOSUB aff_message("Merci, j'en cherche une autre, voyons...")
        periode_blague%=MAX(SHR(periode_blague%,1),1)
      ELSE
        GOSUB aff_message("Desole...")
        periode_blague%=MIN(SHL(periode_blague%,1),262144)
      ENDIF
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
  SHOWM
  ' Nouveau bouclage ?
  IF flag_nvl_boucle_sample%>0
    DEC flag_nvl_boucle_sample%
    IF flag_nvl_boucle_sample%=0
      GOSUB stop_voices
      ~C:rr_boucle_sample%(W:num_nvl_boucle_sample%)
    ENDIF
  ENDIF
  ' 2eme test de protection
  IF (NOT flag_registered3!) AND flag_registered!
    GOSUB teste_enregistrement2
    flag_registered3!=TRUE
  ENDIF
LOOP
'
GOSUB br
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                                Procedures                                *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' Systeme
' -------
PROCEDURE rien
  ' rien !!!
RETURN
PROCEDURE br
  HIDEM
  IF r_flag_the_end%>0
    DPOKE r_flag_the_end%,1     ! A pu zik...
  ENDIF
  IF zone%<>0
    ~MFREE(zone%)
  ENDIF
  IF oldscreenmode%<>0
    oldscreenadr%=GEMDOS(21,L:oldscreensize%)
    IF grmode_preserve%=0
      ~XBIOS(5,L:oldscreenadr%,L:oldscreenadr%,3,oldscreenmode%)
    ELSE IF grmode_preserve%=1
      ~XBIOS(5,L:oldscreenadr%,L:oldscreenadr%,-1)
    ENDIF
    GOSUB restaure_palette                      ! Restaure la palette
  ENDIF
  ~XBIOS(&H82,5,3)
  ~XBIOS(&H82,4,3)
  SPOKE &H484,key_click%        ! Bip bip
  SETCOLOR 0,&HFFF
  SETCOLOR 15,0
  IF grmode_skipxbra%=0
    WHILE xbra_remove$<>""        ! On remet les vecteurs a l'envers car il peut y avoir plusieurs fois le meme vecteur detourne
      SLPOKE LONG{ADD(V:xbra_remove$,SUB(LEN(xbra_remove$),8))},LONG{ADD(V:xbra_remove$,SUB(LEN(xbra_remove$),4))}
      xbra_remove$=LEFT$(xbra_remove$,SUB(LEN(xbra_remove$),8))
    WEND
  ENDIF
  SHOWM
  GOSUB bee(FALSE)
  EDIT
RETURN
PROCEDURE erreur_gfa_basic
  erreur_gfa%=ERR
  flag_erreur_gfa!=TRUE
  PRINT CHR$(7);
  GOSUB aff_message("ERROR : "+ERR$(erreur_gfa%)+" PRESS A KEY.")
  ~GEMDOS(7)
  GOSUB aff_message("NEXT MISTAKE... LAST MISTAKE!")
  flag_erreur_gfa!=FALSE
  RESUME NEXT
RETURN
'
' Initialisations
' ---------------
PROCEDURE init_variables_prefs
  '
  ' Variables configurables dans les preferences
  ' --------------------------------------------
  LOCAL i%,n%,a1$,a2$,a3$,a4$,a5$
  '
  ' Tableaux
  '
  DIM keydef_val%(1,99)         ! 2 touches possibles, numero de commande
  DIM keydef_mask%(1,99)        ! 2 touches possibles, numero de commande
  DIM keydef_param%(99)         ! Numero de commande
  ARRAYFILL keydef_val%(),0
  ARRAYFILL keydef_mask%(),0
  ARRAYFILL keydef_param%(),0
  RESTORE default_keycodes
  READ n%
  FOR i%=0 TO PRED(n%)
    READ a1$,a2$,a3$,a4$,a5$
    keydef_mask%(0,i%)=VAL("$"+a1$)
    keydef_val%(0,i%)=VAL("$"+a2$)
    keydef_mask%(1,i%)=VAL("$"+a3$)
    keydef_val%(1,i%)=VAL("$"+a4$)
    keydef_param%(i%)=VAL("$"+a5$)
  NEXT i%
  '
  ' Variables simples
  '
  system_memory%=131072         ! 128 Ko reserves pour le systeme
  keyboard_type%=0              ! 0 = azerty, 1 = qwerty
  color_pal$="00088FF00F4F800C6FF40F8F888AAACCCFFF889AABCCDFFF" ! La palette (RVB pour 16 couleurs)
  grmode_overscan%=-1           ! -1 = suivant VGA/RGB/TV, 0 = aucun overscan, 1 = force l'overscan
  grmode_80colonnes%=1          ! -1 = laisse, 0 = 40 colonnes, 1 = 80 colonnes
  grmode_entrelace%=-1          ! -1 = laisse, 0 = 200/240 lignes, 1 = 400/480 lignes
  grmode_puissance_plans%=2     ! -1 = laisse, 0 = 2 couleurs, 1 = 4, 2 = 16, 3 = 256, 4 = 65536
  grmode_preserve%=0            ! 0 = change mode, 1 = change mode if current mode unusable, 2 = never change mode
  grmode_skipxbra%=0            ! 0 = remove NVDI/etc from vector chain, 1 = leave vectors alone
  graoumf_logo_color%=4         ! Numero de la couleur du logo (marron)
  path_displayed%=1             ! 0 = systeme, 1 = module, 2 = prefs, 3 = sample, 4 = instruments, 5 = autoload, 6 = misc
  npath_sample$=npath_prog$     ! Chemin des samples
  npath_module$=npath_prog$     ! Chemin des modules
  npath_autoload$=npath_prog$   ! Chemin d'autochargement
  npath_div$=npath_prog$        ! Chemin des operations diverses
  nfile_sample$=""              ! Fichier par defaut pour les samples
  nfile_module$=""              ! Fichier par defaut pour les modules
  nfile_autoload$=""            ! Fichier par defaut a autocharger
  nfile_p1$="DUMTRACK.PGT"      ! Nom du fichier contenant les routines diverses
  nfile_p2$="GTPLAY.PGT"        ! Nom du fichier contenant le player
  next_module$="*.GT2"          ! Extension pour les modules
  next_sample$="*.AVR"          ! Extension pour les samples
  nbr_track%=4                  ! Nombre de voies
  nbr_lines%=64                 ! Nombre de lignes (n'a plus d'utilite mais sert encore)
  instr%=1                      ! Instrument courant
  sample%=1                     ! Sample courant
  n_preset%=0                   ! Numero du preset courant
  line_step%=1                  ! Saut de ligne a l'edition
  haut_lig%=99999               ! Nombre de lignes de pattern affichees (99999 car min dans chgt de resol)
  octave%=1                     ! Octave-1 (0-6 -> 1-7)
  default_pattern_high%=64      ! Nombre de lignes a mettre sur un pattern lors de sa creation
  ss_menu%=1                    ! 1 = disk, 2 = tools, 3 = instr, 4 = samples, 5 = enveloppes, 6 = midi
  ss_menut%=1                   ! Numero de sous-menu du sous-menu Tools (1, 2 ou 3)
  ss_menui%=1                   ! Numero de sous-menu du sous-menu Instruments (1 ou 2)
  ss_menus%=1                   ! Numero de sous-menu du sous-menu Samples (1 ou 2)
  ss_menue%=0                   ! Numero de sous-menu du sous-menu Envelopes (0, 1 ou 2)
  ss_menuc%=1                   ! Numero de sous-menu du sous-menu Control (1 ou 2)
  ss_menuc_npan%=0              ! Plage des pannings du sous-menu Control (0 = 1-8, 1 = 9-16, etc...)
  ss_menuc2_npan%=0             ! Plage des volumes du sous-menu Control (0 = 1-8, 1 = 9-16, etc...)
  ss_menum%=1                   ! Numero de sous-menu du sous-menu Midi (1 ou 2)
  ss_menu2%=1                   ! Numero de sous-menu de l'editeur de sample (1, ...)
  ss_menu2.fl%=1                ! Num ss-menu Flanger (1 ou 2)
  ss_menu2.rev%=1               ! Num ss-menu Reverb (1 ou 2)
  maskblock%=0                  ! 0 = all, 1 = masque
  replaceblock%=0               ! 0 = replace, 1 = transparent
  trackpat%=0                   ! 0 = piste, 1 = pattern, 2 = preset
  bl_flagsong!=FALSE            ! Si l'operation de bloc porte sur toute la song
  bl_maska1$=STRING$(5,0)       ! 0 = n'importe quoi, F = seulement bl_maska2%
  bl_maska2$=STRING$(5,0)       ! Copie si (note AND bl_maska1)=bl_maska2
  bl_maskb1$=STRING$(5,255)     ! F = n'importe quoi, 0 = seulement bl_maskb2%
  bl_maskb2$=STRING$(5,0)       ! Masque de remplacement
  bl_echo_lines%=2              ! Echo toutes les 2 lignes
  bl_echo_feedback%=50          ! 50% de feedback dans l'echo
  bl_echo_fadestep%=&H40        ! - $40 de volume a chaque echo
  bl_echo_cont!=FALSE           ! Ne joue l'echo que de la derniere note
  bl_echo_fdbk!=TRUE            ! True = feedback, False = fade
  ext_note1%=&HFFFFFF           ! F = n'importe quoi, 0 = met qqc
  ext_note2%=0                  ! (Effet AND ext_note1) OR ext_note2
  signe_sam%=0                  ! A ajouter au sample quand sauve/charge
  drumpad_flag%=0               ! 0 = No d'instr, 1 = drumpad
  freq_buffer%=8363             ! Frequence de base du buffer
  snapshot_number%=0            ! Numero du dernier snapshot effectue
  snapshot_format%=1            ! Format du snapshot : 0 = TGA 16 couleurs, 1 = TGA 24 bits
  flag_keep_buffer!=FALSE       ! S'il est mis, les modules detruisent le buffer au minimum
  flag_gt2cnf!=FALSE            ! Sauvegarde de la configuration du GT dans les modules GT2
  flag_backup_modules!=TRUE     ! Sauve les modules avec back up en fichier .BAK
  flag_keyboard_buffer!=FALSE   ! False = vide le buffer clavier apres chaque pression de touche
  flag_cpu_display!=FALSE       ! True = affiche le temps machine tout le temps, False = seulement en Play
  type_affpiste%=1              ! Affichage des pistes : 0 = note+ins, 1 = normal, 2 = +volume
  env_num&=1                    ! Numero de l'enveloppe editee
  env_sect&=0                   ! Section de l'enveloppe editee : 0 = attack, 1 = key off
  env_copy&=1                   ! Numero de l'enveloppe a copier
  midi_flag_data_in!=FALSE      ! True = MIDI In possible
  midi_flag_data_out!=FALSE     ! True = MIDI Out possible
  midi_flag_synchro%=0          ! 0 = pas de synchro, 1 = GT suit la synchro, 2 = GT donne la synchro
  midi_polyphonic_mode!=TRUE    ! False = Monophonic, True = Polyphonic
  midi_monomode_channel_nbr%=1  ! Numero de canal MIDI en mode Monophonique (1-16)
  midi_monomode_instr_nbr%=0    ! Numero d'instrument en mode Monophonique. 0 = instrument courant
  midi_polymode_channel_nbr%=1  ! Numero de canal MIDI en mode Polyphonique (1-16)
  '
  de.display_type%=0            ! Type d'affichage du pat dans le Drum Editor: 0 = pattern, 1 = info pistes
  '
  se.mix_master_volume%=16384   ! Master volume (/32768) pour la fonction de mixage
  se.rec_input_device%=0        ! Entree digitalisation : 0 = Falcon ADC, 1 = ST Replay pro
  se.rec_canal%=1               ! Canal d'entree : 1 = Left, 2 = Right, 3 = Left+Right
  se.rec_adc_freq%=1            ! Frequence de digit sur l'ADC du Falcon (freq type CODEC)
  se.rec_ext_freq%=44100        ! Frequence de digit avec un autre ADC (ST Replay pro)
  se.rec_trigger%=6553          ! Impulsion minimum pour commencer la digit /32768
  se.rec_flag_trigger!=FALSE    ! False = trigger off, true = trigger on
  se.freq_nfe%=16390            ! Nouvelle frequence d'echantillonnage
  se.freq_ofn%=131              ! Ancienne frequence de note
  se.freq_nfn%=131              ! Nouvelle frequence de note
  se.freq_iptype%=1             ! Type d'interpolation : 0 = none, 1 = Linear, 2 = 3rd degree
  se.freq_fftdisp%=0            ! 0 = affichage lineaire, 1 = affichage logarithmique
  se.freq_fftwin%=0             ! Fenetrage FFT : 0 = rectangulaire, 1 = Blackman
  se.freq_fftnoteon!=TRUE       ! Affichage ou non de la frequence de la note sur la FFT
  se.freq_fft_cflag!=TRUE       ! Calcule la note du sample avec la FFT
  se.freq_fft_pnbr%=640         ! Nombre de points a calculer pour la FFT
  se.delay_flags%=&X1           ! Chaque bit (0-3) = tap on/off, bit 4 = mute in, bit 5 = multi-tap mode
  se.delay_feedback%=0          ! Feedback du delay (/32768)
  se.delay_timefeed%=375        ! Temps de repetition (ms)
  se.delay_dry%=32768           ! Niveau du son clair (/32768)
  se.delay_wet%=16384           ! Niveau du delay
  se.delay_source%=0            ! Sample source : 0 = buffer, 1-255 = sample
  se.delay_mutein%=500          ! Temps (ms) apres lequel le signal d'entree est coupe
  se.flanger_dry%=16384         ! Niveau dry du flanger (/32768)
  se.flanger_wet%=16384         ! Niveau wet
  se.flanger_lsource%=0         ! Sample source gauche (0 = buffer)
  se.flanger_rsource%=0         ! Sample source droit   " "    "
  se.flanger_time%=1000         ! Delay du flanger (Ês) -> 10 ms
  se.flanger_freq%=500          ! Frequence du flanger (mHz)
  se.flanger_depth%=500         ! Profondeur du flanger (Ês) -> 6.35 ms
  se.flanger_fdbkll%=9830       ! Feedback L -> L (30%)
  se.flanger_fdbklr%=9830       ! Feedback L -> R (30%)
  se.flanger_fdbkrr%=9830       ! Feedback R -> R (30%)
  se.flanger_fdbkrl%=9830       ! Feedback R -> L (30%)
  se.flanger_phase%=0           ! Phase intitiale (0-4095)
  se.flanger_wave%=0            ! 0 = sin, 1 = carre, 2 = triangle, 3 = scie descendante, 4 = scie montante
  se.flanger_stereo!=FALSE      ! Flag de stereophonie du flanger
  se.rev_aprdelay%=5000         ! Delay de l'All Pass Reverb, en Ês. Maxi : 0.25 s
  se.rev_aprg%=22937            ! Feedback de l'All Pass reverb
  se.rev_adlydelay%=26540       ! Delay de l'Alignement delay, en Ês. Maxi : 0.25 s
  se.rev_drylevel%=16384        ! Dry level (/32768)
  se.rev_revlevel%=11469        ! Reverb level (/32768)
  se.rev_ereflevel%=4915        ! Early reflection level (/32768)
  se.rev_nbrtaps%=7             ! Nombre de taps pour l'Early reflection
  se.rev_nbrcomb%=4             ! Nombre de comb filters
  se.rev_combgain%=27852        ! Gain general des comb filters (/32768)
  se.rev_source%=0              ! Sample source (0 = buffer)
  se.rev_tappos%=0              ! Position dans la liste des taps de l'ER
  se.rev_combpos%=0             ! Position dans la liste des comb filters
  se.s2d_posstart%=0            ! Position de depart d'enregistrement
  se.s2d_ligstart%=0            ! Ligne de depart d'enregistrement
  se.s2d_posend%=0              ! Position de fin d'enregistrement
  se.s2d_ligend%=0              ! Ligne de fin d'enregistrement
  se.s2d_bits%=1                ! Enregistrement en 1 : 8 bits, 2 : 16 bits
  se.s2d_stereo%=1              ! Enregistrement en 1 : mono, 2 : stereo
  se.s2d_maxsize%=1024          ! Taille maximum (Ko)
  se.s2d_out%=1                 ! Sortie sur 1 : block, 2 : disk
  se.s2d_2ndtime!=FALSE         ! False : normal, True : attend un bouclage avant d'enregistrer
  se.s2d_speed%=7               ! Vitesse d'enregistrement (0 = vite, 7 = lent). Agit sur _prediv%
  se.s2d_prediv%=11             ! Prediviseur pour la vitesse DMA : 1 = 50KHz, 2 = 32 KHz... Depend de _speed%
  se.s2d_monitor!=FALSE         ! True = ecoute pendant l'enregistrement, False = enregistrement en differe
  se.comp_source%=0             ! Sample source (0 = buffer)
  se.comp_speed%=10000          ! Periode de recalcul du taux de compression (1-99999) (Ês)
  se.comp_level%=16384          ! Niveau de compression (vol ideal a atteindre) (/32768)
  se.comp_initvolume%=se.comp_level%    ! Volume presume de depart (/32768)
  se.disto_source%=0            ! Sample source (0 = buffer)
  se.disto_gain%=32768          ! Gain de la disto (/32768)
  se.disto_initpower%=4         ! Facteur de puissance de la disto avec un gain < 100% (min = 1)
RETURN
PROCEDURE init_variables_post_prefs
  '
  ' Variables diverses non configurables dans les preferences
  ' ---------------------------------------------------------
  gamme$="C-C#D-D#E-F-F#G-G#A-A#B-"
  gamme2$="C C#D D#E F F#G G#A A#B "
  numericpad_scancodes$=MKI$(99)+MKI$(100)+MKI$(101)+MKI$(102)+MKI$(103)+MKI$(104)+MKI$(105)+MKI$(74)
  numericpad_scancodes$=numericpad_scancodes$+MKI$(106)+MKI$(107)+MKI$(108)+MKI$(78)
  numericpad_scancodes$=numericpad_scancodes$+MKI$(109)+MKI$(110)+MKI$(111)+MKI$(114)
  adr_background%=0             ! Adresse du malloc pour un background (si <> 0, liberer a la fin).
  songpos%=0                    ! Position courante dans la song
  posligne%=0                   ! Ligne courante dans le pattern
  curs_x%=0                     ! 0 = note, 1-2 = instr, 3-6 = effet, 7-8 = volume
  curs_col%=0                   ! Colonne du curseur
  play%=0                       ! 0 = stop, 1 = play song, 2 = play pattern
  edit%=0                       ! 0 = stop, 1 = edit
  flag_nvl_boucle_sample%=0     ! Flag de calcul du nouveau bouclage d'un sample
  num_nvl_boucle_sample%=1      ! Le numero du sample
  bl_start&=0                   ! Ligne de debut du bloc
  bl_end&=0                     ! Ligne de fin du bloc
  bl_pat&=0                     ! Pattern 0
  bl_trk&=0                     ! Voie 1
  sample_list_pos%=1            ! Position dans la liste des samples
  instr_list_pos%=1             ! Position dans la liste des instruments
  song_list_pos%=0              ! Position dans l'arrangement des patterns
  instr_note_pos%=48            ! Position dans la liste des notes
  instr_note_aff%=48            ! Affichage dans la liste des notes
  instr_group!=TRUE             ! On manipule tout un groupe de notes
  mark_1%=0                     ! Marqueur de debut de bloc dans le sample
  mark_len%=FN lon_buffer       ! Marqueur de fin de bloc
  mark_2%=ADD(mark_1%,mark_len%)! Marqueur fantome de fin de bloc
  mark_rep%=0                   ! Marqueur de repetition
  win_pos%=mark_1%              ! Debut de la fenetre de sample
  win_lon%=mark_len%            ! Longueur de la fenetre
  win_bits%=1                   ! Buffer 8 bits
  erreur_gfa%=0                 ! Numero d'erreur de GFA Basic
  treg_str1$=" by Laurent de SORAS and the Graoumf Devteam."
  treg_str2$="USER.REG"
  treg_str3$="version to"
  treg_str4$=" licensed to "
  treg_str5$=" (license is invalid)"
  ' flag_registered!=TRUE         ! false = demo, true = normal
  ' flag_registered2!=TRUE        ! false = demo, true = normal
  flag_registered3!=FALSE       ! Indique si on a fait ou pas le 2eme test de protection
  flag_erreur_gfa!=FALSE        ! Indique s'il y a eu une erreur
  flag_blague!=FALSE            ! Ne sort pas de vanne a la Julien Boeuf pour l'instant
  flag_autoload!=FALSE          ! N'est pas en cours d'autochargement
  erreur%=0                     ! Sert localement pour la gestion des erreurs
  periode_blague%=4096          ! Periode moyenne de sortie d'une vanne
  debut_temps%=TIMER            ! Valeur du Timer pour le debut du chrono
  env_posaff&=0                 ! Position de l'affichage de l'enveloppe, en commandes
  env_poscurs&=0                ! Position du curseur dans l'enveloppe, en commandes
  env_codpos&=0                 ! Position dans la liste des codes des enveloppes
  progression_xpos%=0           ! Abscisse de la boite de progression (car)
  progression_ypos%=0           ! Ordonnee de la boite de progression (pix)
  progression_width%=64         ! Largeur de la barre de progression (pix)
  progression_len%=65536        ! Valeur maxi de la valeur de progression
  progression_oldval%=0         ! Ancienne valeur de progression, sert a la mise a jour de la barre.
  se.sample_editor_flag!=FALSE  ! Indique si on est ou non dans l'editeur de samples
  se.volume_ok!=FALSE           ! Indique si le volume du block est valable
  se.volume_spl%=0              ! Volume du-dit block (/32768)
  se.volume_fade_start%=32768   ! Volume de debut de fade (/32768)
  se.volume_fade_end%=32768     ! Volume de fin de fade (/32768)
  se.flag_best_volume!=FALSE    ! Garde le volume du sample quitte a saturer lors d'un effet (True : cherche le meilleur volume)
  se.mark_selected%=0           ! Bits representant les presets de marques selectionnes
  se.mark_set!=FALSE            ! Icone SET alumee ou pas
  se.freq_fftmin%=20            ! Frequence minimum de la FFT (deja calculee)
  se.freq_fftmax%=SHR(freq_buffer%,1)   ! Frequence maximum de la FFT (deja calculee)
  se.freq_fftech%=freq_buffer%  ! Frequence d'echantillonnage du sample lors de la FFT (deja calculee)
  se.freq_fftlon%=1             ! Nombre de frequences scannees par la FFT (deja calculee)
  se.freq_fft_pstart%=0         ! Frequence de debut de calcul FFT
  se.freq_fft_pend%=SHR(freq_buffer%,1) ! Frequence de fin de calcul FFT
RETURN
PROCEDURE init_tableaux
  '
  ' Dimentionnement des tableaux
  ' ----------------------------
  DIM scancode2ascii$(2,1)      ! Ligne de touches, Type de clavier
  DIM icone$(4,2)               ! Icones du haut
  DIM drumpad%(31,2)            ! Numero de touche, Instruments/ Samples/ Notes du drumpad
  DIM presetpad%(31)            ! Numero de touche
  DIM trackpad%(31)             ! Numero de touche
  DIM preset&(31,31)            ! Numeros de pistes : (colonne,preset)
  DIM nbr_colonnes%(31)         ! Nombre de colonnes affichees pour chaque preset
  DIM t_note%(53)
  DIM fft&(1023)                ! Resultats de FFT
  DIM divbn$(63,31)             ! Noms de divers boutons des sous-menus
  DIM divbi&(3,63,31)           ! Leurs coordonnees et taille
  DIM popup_nbrlines%(7)        ! Nombre de lignes des popups: popup
  DIM popup_code%(31,7)         ! Code de retour des popups: ligne, popup
  DIM popup_txt$(31,7)          ! Textes des popups: ligne, popup
  DIM help$(23,15)              ! Texte d'aide
  DIM blague$(99)               ! Des blagues
  DIM control_old%(20)          ! Anciennes valeurs pour les updates du sous-menu Control
  DIM midi_in_channel%(31)      ! Numero du canal MIDI attribue a chaque piste en Mode Polyphonique
  DIM midi_in_instr%(15)        ! Numero d'instrument assigne a chaque canal en Mode Polyphonique
  DIM se.mix_param%(3,4)        ! Parametres de mixages du Sample_Editor : flags (+1=on, +2=loop) , n¯de sample (0=buffer), volume debut/32768, volume fin/32768
  DIM se.mark%(1,9)             ! Presets de samples (start/length,numero)
  DIM se.mark$(9)               ! Le nom des presets
  DIM se.delaytime%(3)          ! Temps (ms) de decalage pour chaque tap
  DIM se.delaylevel%(3)         ! Niveau d'entree (/32768) pour chaque tap
  DIM se.rev_tapdelay%(15)      ! Delay des taps de reverb, en Ês. Maxi : 0.25 s
  DIM se.rev_taplevel%(15)      ! Level des taps de reverb, (/32768)
  DIM se.rev_combdelay%(15)     ! Delay des comb filters de reverb, en Ês. Maxi : 0.25 s
  DIM se.rev_comblpf%(15)       ! Niveau de gain des lpf dans la reverb (/32768)
  DIM se.rev_buffer$(10)        ! Buffers pour la reverb : 3 (early, alignement, APR) + 8 (comb filters)
  DIM env_code$(255)            ! Code des mnemoniques des commandes des enveloppes
  DIM env_conv&(19,2)           ! Conversion (num ds la liste,type) -> Code d'enveloppe
  DIM env_valdef&(19,2)         ! Valeurs par defaut pour les parametres des commandes d'enveloppes
  DIM env_codmax&(2)            ! Nombre maxi de codes pour chaque type d'enveloppe
  '
  ' Remplissage des tableaux
  ' ------------------------
  '
  ' Lecure de l'Help
  '
  RESTORE help_text
  j%=0
  READ a$
  REPEAT
    help$(0,j%)=a$
    FOR i%=1 TO 23
      READ help$(i%,j%)
    NEXT i%
    READ a$
    INC j%
  UNTIL a$="***"
  help_pmax%=PRED(j%)
  '
  ' Initialisation des Marks du S.E.
  '
  FOR i%=0 TO 9
    se.mark%(0,i%)=0
    se.mark%(1,i%)=&HFFFFFE
    se.mark$(i%)=SPACE$(21)
  NEXT i%
  '
  ' Lecture des blagues
  '
  RESTORE textes_blagues
  i%=0
  READ a$
  REPEAT
    flag!=FALSE
    blague$(i%)=""
    REPEAT
      IF flag!
        blague$(i%)=blague$(i%)+"|"
      ENDIF
      blague$(i%)=blague$(i%)+a$
      flag!=TRUE
      READ a$
    UNTIL a$="*"
    INC i%
    READ a$
  UNTIL a$="***"
  blague_nbr%=i%
  '
  ' Initialisation des pads
  '
  FOR i%=0 TO 31
    drumpad%(i%,0)=SUCC(i%)
    drumpad%(i%,1)=SUCC(i%)
    drumpad%(i%,2)=ADD(&H3C000000,SHL(SUCC(i%),16))
    presetpad%(i%)=i%
    trackpad%(i%)=i%
  NEXT i%
  '
  ' Lecture des icones des sous-menus
  '
  RESTORE icones_disk
  ARRAYFILL divbi&(),-1
  j%=0
  READ n%
  WHILE n%>0
    READ x%,y%
    FOR i%=0 TO PRED(n%)
      READ a%                   ! Sert a rien pour l'instant
      READ divbn$(i%,j%),divbi&(0,i%,j%),divbi&(1,i%,j%),divbi&(2,i%,j%)
      ADD divbi&(0,i%,j%),x%
      ADD divbi&(1,i%,j%),y%
      READ divbi&(3,i%,j%)
    NEXT i%
    INC j%
    READ n%
  WEND
  '
  ' Donnees des Pop Up
  '
  RESTORE popup_mod_ext
  j%=0
  READ n%
  WHILE n%>0
    popup_nbrlines%(j%)=n%
    FOR i%=0 TO PRED(n%)
      READ popup_txt$(i%,j%)
      READ popup_code%(i%,j%)
    NEXT i%
    INC j%
    READ n%
  WEND
  '
  ' Lecture des touches
  '
  RESTORE touches_notes
  ARRAYFILL t_note%(),-1
  FOR i%=0 TO 16
    READ a%
    t_note%(a%)=i%
  NEXT i%
  FOR i%=12 TO 32
    READ a%
    t_note%(a%)=i%
  NEXT i%
  '
  ' Lecture des commandes d'enveloppes
  '
  RESTORE enveloppe_coms
  ARRAYFILL env_conv&(),-1
  c%=0
  READ a%,b%
  FOR i%=a% TO PRED(ADD(a%,b%))
    READ env_code$(i%),d%
    env_conv&(c%,0)=i%
    env_conv&(c%,1)=i%
    env_conv&(c%,2)=i%
    env_valdef&(c%,0)=d%
    env_valdef&(c%,1)=d%
    env_valdef&(c%,2)=d%
    INC c%
  NEXT i%
  FOR j%=0 TO 2
    d%=c%
    READ a%,b%
    FOR i%=a% TO PRED(ADD(a%,b%))
      READ env_code$(i%),env_valdef&(d%,j%)
      env_conv&(d%,j%)=i%
      INC d%
    NEXT i%
    env_codmax&(j%)=d%
  NEXT j%
  '
  ' Lecture des delay/levels des taps pour la reverb
  '
  RESTORE rev_tap_delay_level
  ARRAYFILL se.rev_tapdelay%(),0
  ARRAYFILL se.rev_taplevel%(),0
  FOR i%=0 TO 6
    READ a,b
    se.rev_tapdelay%(i%)=a*1000000
    se.rev_taplevel%(i%)=b*32768
  NEXT i%
  '
  ' Lecture des delay/lpfs des comb filters pour la reverb
  '
  RESTORE rev_comb_delay_lpf
  ARRAYFILL se.rev_combdelay%(),70000
  ARRAYFILL se.rev_comblpf%(),0
  FOR i%=0 TO 3
    READ a,b
    se.rev_combdelay%(i%)=a*1000000
    se.rev_comblpf%(i%)=b*32768
  NEXT i%
  '
  ' Init des presets
  '
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  ARRAYFILL nbr_colonnes%(),nbr_track%
  '
  ' Initialise les parametres de la fonction Mix du Sample_Editor
  '
  FOR i%=0 TO 4
    se.mix_param%(0,i%)=(i%<2) AND 1            ! +1 : ON, +3 : LOOP
    se.mix_param%(1,i%)=i%                      ! Numero de sample
    se.mix_param%(2,i%)=32768                   ! Volume de debut
    se.mix_param%(3,i%)=32768                   ! Volume de fin
  NEXT i%
  '
  ' Init des fonctions de delay du S.E.
  '
  FOR i%=0 TO 3
    se.delaytime%(i%)=375
    se.delaylevel%(i%)=32768
  NEXT i%
  '
  ' Init des tableaux MIDI
  '
  ARRAYFILL midi_in_channel%(),0                ! Aucun canal MIDI
  ARRAYFILL midi_in_instr%(),1                  ! Numero 1 par defaut
  '
  ' Scancode -> Ascii
  '
  RESTORE key_scancode_to_ascii
  FOR i%=0 TO 1
    FOR j%=0 TO 2
      READ scancode2ascii$(j%,i%)
    NEXT j%
  NEXT i%
RETURN
PROCEDURE init_fonctions_simples
  '
  ' Definition des fonctions simples
  ' --------------------------------
  DEFFN zone_start=zone%
  DEFFN zone_end=ADD(FN zone_start,place_totale%)
  ' Fonctions concernant les samples
  DEFFN adrsamchk(s%)=LONG{ADD(r_adr_sample%,SHL(s%,2))}
  DEFFN lonsamchk(s%)=LONG{ADD(FN adrsamchk(s%),4)}
  DEFFN adresse(s%)=ADD(FN adrsamchk(s%),64)
  DEFFN volume(s%)=CARD{ADD(FN adrsamchk(s%),58)}
  DEFFN finetune(s%)=INT{ADD(FN adrsamchk(s%),60)}
  DEFFN length(s%)=LONG{ADD(FN adrsamchk(s%),46)}
  DEFFN repeat(s%)=LONG{ADD(FN adrsamchk(s%),50)}
  DEFFN replen(s%)=LONG{ADD(FN adrsamchk(s%),54)}
  DEFFN freqech(s%)=CARD{ADD(FN adrsamchk(s%),44)}
  DEFFN resol(s%)=SHR(CARD{ADD(FN adrsamchk(s%),42)},3)
  DEFFN autobal(s%)=CARD{ADD(FN adrsamchk(s%),40)}
  DEFFN total_length=SUB(ADD(FN adrsamchk(255),FN lonsamchk(255)),FN adrsamchk(0))      ! Memoire totale occupee par les samples
  ' Fonctions concernant les pistes
  DEFFN track_onoff(t%)=CARD{ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,t%))}
  DEFFN track_interpol(t%)=CARD{ADD(ADD(r_info_track%,r_interpol_t%),MUL(r_itl%,t%))}
  DEFFN balance(i%)=CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,i%))}       ! Balance (0-31)
  DEFFN track_volume_lin(i%)=CARD{ADD(ADD(r_info_track%,r_mix_volume_t%),MUL(r_itl%,i%))}
  DEFFN track_volume_exp(i%)=CARD{ADD(ADD(r_info_track%,r_mix_volume_e_t%),MUL(r_itl%,i%))}
  ' Fonctions concernant les instruments
  DEFFN ivolume(i%)=SHR(instrset%(10,i%),16)
  DEFFN ievol(i%)=SHR(instrset%(11,i%),16)
  DEFFN ieton(i%)=instrset%(11,i%) AND &HFFFF
  DEFFN iepan(i%)=SHR(instrset%(12,i%),16)
  DEFFN itransp(i%,j%)=FN sbyte(BYTE{ADD(V:instrset%(15,i%),SUCC(SHL(j%,1)))})  ! Octet signe
  DEFFN isample(i%,j%)=BYTE{ADD(V:instrset%(15,i%),SHL(j%,1))}
  ' Fonctions concernant la song
  DEFFN song_length=module&(101)
  DEFFN song_repeat=module&(102)
  DEFFN mod_tempo=CARD{r_mod_tempo%}
  DEFFN mod_speed=CARD{r_mod_speed%}
  ' Fonctions concernant les patterns
  DEFFN adr_patchunk(i%)=LONG{ADD(r_adr_pattern%,SHL(i%,2))}
  DEFFN lon_patchunk(i%)=LONG{ADD(FN adr_patchunk(i%),4)}
  DEFFN nbr_lines(i%)=CARD{ADD(FN adr_patchunk(i%),28)}
  DEFFN nbr_lines2(i%)=FN nbr_lines(song&(i%))
  DEFFN nbr_lines3=FN nbr_lines(song&(songpos%))
  DEFFN nbr_track(i%)=CARD{ADD(FN adr_patchunk(i%),30)}
  DEFFN nbr_track2(i%)=FN nbr_track(song&(i%))
  DEFFN nbr_track3=FN nbr_track(song&(songpos%))
  ' adresse du pattern a%, ligne b%, piste c%
  DEFFN adr_pat(a%)=ADD(FN adr_patchunk(a%),32)
  DEFFN adr_line(a%,b%)=ADD(FN adr_pat(a%),MUL(MUL(nbr_track%,5),b%))
  DEFFN adr_trk(a%,b%,c%)=ADD(FN adr_line(a%,b%),MUL(c%,5))
  ' adresse du pattern de la position a%, ligne b%, piste c%
  DEFFN adr_spat(a%)=FN adr_pat(song&(a%))
  DEFFN adr_sline(a%,b%)=FN adr_line(song&(a%),b%)
  DEFFN adr_strk(a%,b%,c%)=FN adr_trk(song&(a%),b%,c%)
  ' Fonctions concernant le MIDI
  DEFFN get_midi_flag_velocity(can%)=INT{ADD(r_midi_in_velo_flag%,SHL(PRED(can%),1))}
  DEFFN get_midi_flag_note_off(can%)=INT{ADD(r_midi_in_noteoff_flag%,SHL(PRED(can%),1))}
  ' Fonctions concernant le buffer de sample
  DEFFN adr_buffer=ADD(FN adrsamchk(255),FN lonsamchk(255)) AND -2      ! Adresse de debut du buffer
  DEFFN lon_buffer=SUB(FN zone_end,FN adr_buffer) AND -2                ! Longueur du buffer
  ' Divers
  DEFFN zone_free=FN lon_buffer         ! Memoire libre pour les patterns, enveloppes et samples
  DEFFN zone_free2=SUB(FN zone_end,ADD(FN zone_start,80000))    ! Memoire restante quand le module est minimum (environ)
  DEFFN freq2note(f)=ROUND(LOG(f/440)*12/LOG(2)+69)     ! Conversion frequence -> note (codage MIDI)
  DEFFN note2freq(n)=440*2^((n-69)/12)                  ! Conversion note -> frequence
RETURN
PROCEDURE change_resolution
  ' Passage en resolution 80 colonnes 16 couleurs
  ' ---------------------------------------------
  LOCAL a%,b%,c%,i%,mon%,flag!,a$
  oldscreenadr%=XBIOS(2)
  oldscreenmode%=XBIOS(88,-1)
  oldscreensize%=XBIOS(91,oldscreenmode%)
  mon%=XBIOS(&H59)
  SELECT mon%
  CASE 0        ! Monochrome
    SHOWM
    ALERT 3,"GRAOUMF TRACKER|don't work on|monochrome screen",1,"Fuck!|Chier...|Ahh??",a%
    HIDEM
    GOSUB br
  CASE 1        ! RGB
    IF grmode_overscan%=-1                      ! Overscan par defaut
      grmode_overscan%=1
    ENDIF
  CASE 2        ! VGA
    IF grmode_overscan%=-1                      ! Pas d'overscan par defaut
      grmode_overscan%=0
    ENDIF
  CASE 3        ! TV
    ALERT 2,"GRAOUMF TRACKER :|Overscan ???",1,"Yes|Dnt know|No",a%
    IF a%=3 OR (a%=2 AND RND>0.5)
      grmode_overscan%=0
    ENDIF
  ENDSELECT
  '
  ' Enleve les XBRA genants
  '
  IF grmode_skipxbra%=1
    GOTO cmode.skipxbra
  ENDIF
  ~FN vire_xbra(&HB4,CVL("ACCx"),&HFFFFFF00,TRUE)       ! Accent 1, 2 et 3 du Feroce Lapin
  ~FN vire_xbra(&H70,CVL("NVDI"),-1,TRUE)               ! NVDI: VBL interrupt
  ~FN vire_xbra(&H84,CVL("NVDI"),-1,TRUE)               ! NVDI: GEMDOS
  ~FN vire_xbra(&H88,CVL("NVDI"),-1,TRUE)               ! NVDI: AES/VDI
  ~FN vire_xbra(&HB4,CVL("NVDI"),-1,TRUE)               ! NVDI: BIOS
  ~FN vire_xbra(&HB8,CVL("NVDI"),-1,TRUE)               ! NVDI: XBIOS
  flag_falcon_screen!=FN vire_xbra(&HB8,CVL("‰FSC"),-1,FALSE)   ! Teste seulement Falcon Screen
cmode.skipxbra:
  '
  GOSUB sauve_palette                           ! Sauve la palette
  ON BREAK GOSUB br
  '
  ' Calcule le nouveau mode ecran
  '
  ' 4 plans, 80 colonnes, overscan
  newscreenmode%=oldscreenmode% AND (NOT &H80)  ! Pas de resolution compatible ST
  IF grmode_overscan%=0
    newscreenmode%=newscreenmode% AND (NOT &H40)
  ELSE IF grmode_overscan%=1
    newscreenmode%=newscreenmode% OR &H40
  ENDIF
  '
  IF grmode_80colonnes%=0
    newscreenmode%=newscreenmode% AND (NOT &H8)
  ELSE IF grmode_80colonnes%=1
    newscreenmode%=newscreenmode% OR &H8
  ENDIF
  '
  IF grmode_puissance_plans%<>-1
    newscreenmode%=(newscreenmode% AND (NOT &H7)) OR grmode_puissance_plans%
  ENDIF
  '
  IF grmode_entrelace%=0
    IF mon%=2                                   ! VGA
      newscreenmode%=newscreenmode% OR &H100
    ELSE                                        ! RVB/TV
      newscreenmode%=newscreenmode% AND (NOT &H100)
    ENDIF
  ELSE IF grmode_entrelace%=1
    IF mon%=2                                   ! VGA
      newscreenmode%=newscreenmode% AND (NOT &H100)
    ELSE                                        ! RVB/TV
      newscreenmode%=newscreenmode% OR &H100
    ENDIF
  ENDIF
  '
  IF flag_falcon_screen!                        ! Sinon la taille de l'ecran est erronnee
    ~XBIOS(88,newscreenmode%)
  ENDIF
  screensize%=ADD(XBIOS(91,newscreenmode%),4000)
  RESERVE -MAX(screensize%,system_memory%)
  adrlogscr%=ADD(GEMDOS(21,L:screensize%),255) AND -256 ! Ecran logique a 256 pres
  adrphyscr%=adrlogscr%                         ! Ecran physique
  HIDEM
  IF grmode_preserve%=0
    ~XBIOS(5,L:adrlogscr%,L:adrphyscr%,3,newscreenmode%)
  ELSE IF grmode_preserve%=1
    ~XBIOS(5,L:adrlogscr%,L:adrphyscr%,-1)
  ENDIF
  '  HIDEM sjx, 8776, exp
  a$=MKL$(&H48E77FFE)+MKL$(&HA0002008)+MKL$(&H4CDF7FFE)+MKI$(&H4E75)
  a%=V:a$
  b%=C:a%(0)                                    ! b% = adresse des variables line A
  scr_larg%=DPEEK(SUB(b%,12))                   ! Largeur de l'ecran en pixels
  scr_haut%=DPEEK(SUB(b%,4))                    ! Hauteur de l'ecran en pixels
  IF scr_larg%<640 OR scr_haut%<200             ! Largeur et hauteur minimum
    SHOWM
    ALERT 3,"Screen mode too small!|Graoumf Tracker needs|640x200 16 colours minimum!",1,"Damn",a%
    HIDEM
    GOSUB br
  ENDIF
  scr_ncol%=SHR(scr_larg%,3)                    ! ...et en colonnes de caracteres
  GOSUB chg_type_affpiste(type_affpiste%)       ! Nombre de pistes affichables
  haut_lig%=MIN(DIV(SUB(scr_haut%,180),6) OR 1,haut_lig%)       ! Nombre de lignes de pattern affichees
  GOSUB nouvelle_palette(color_pal$)
RETURN
PROCEDURE charge_g_routines
  ' Charge les routines graphiques (et autres routines)
  ' ---------------------------------------------------
  LOCAL a%
  DIM g_routines%(12288)         ! 48 Ko environ
  BLOAD npath_prog$+nfile_p1$,V:g_routines%(0)
  a%=ADD(V:g_routines%(0),28)
  g_relocation%=a%
  g_fabrique_fonte_ombr%=ADD(a%,4)
  g_cadre_centre%=ADD(a%,8)
  g_dessine_cadre_int%=ADD(a%,12)
  g_dessine_cadre_ext%=ADD(a%,16)
  g_affchaine_trans%=ADD(a%,20)
  g_affchaine_trans_ombr%=ADD(a%,24)
  g_affchaine_notrans%=ADD(a%,28)
  g_affcar8x6%=ADD(a%,32)
  g_affcar8x6_dec%=ADD(a%,36)
  g_affcar8x6_ombr%=ADD(a%,40)
  g_affcar8x6_ombr_dec%=ADD(a%,44)
  g_affcar8x6nt_ombr%=ADD(a%,48)
  g_affiche_pattern%=ADD(a%,52)
  g_affiche_sample%=ADD(a%,56)
  g_convert_nt_2_gtk%=ADD(a%,60)
  g_convert_669_2_gtk%=ADD(a%,64)
  g_convert_mtmv_2_gtk%=ADD(a%,68)
  g_signe_sample%=ADD(a%,72)
  g_stereo_2_mono_one%=ADD(a%,76)
  g_stereo_2_mono_ave%=ADD(a%,80)
  g_convert_mmd1_2_gtk%=ADD(a%,84)
  g_teste_icones%=ADD(a%,88)
  g_convert_s3m_2_gtk%=ADD(a%,92)
  g_intel_16_bits%=ADD(a%,96)
  g_convert_ult_2_gtk%=ADD(a%,100)
  g_convert_gtk_2_gtk_vol%=ADD(a%,104)
  g_clear_note_block%=ADD(a%,108)
  g_paste_note_block%=ADD(a%,112)
  g_atomic_35_unpack%=ADD(a%,116)
  g_swap_note_block%=ADD(a%,120)
  g_transpose_note_block%=ADD(a%,124)
  g_packice_21_unpack%=ADD(a%,128)
  g_invert_memory%=ADD(a%,132)
  g_affiche_marqueur_sample%=ADD(a%,136)
  g_efface_marqueur_sample%=ADD(a%,140)
  g_copy_sample_8_2_16%=ADD(a%,144)
  g_copy_sample_16_2_8%=ADD(a%,148)
  g_convert_gtk_2_nt%=ADD(a%,152)
  g_cherche_volume_sample%=ADD(a%,156)
  g_change_volume_sample%=ADD(a%,160)
  g_mixage_sample%=ADD(a%,164)
  g_affiche_vumetre%=ADD(a%,168)
  g_start_sample_recording%=ADD(a%,172)
  g_cherche_volume_buffer_stereo%=ADD(a%,176)
  g_change_sample_frequency%=ADD(a%,180)
  g_trans_fourier%=ADD(a%,184)
  g_fx_delay%=ADD(a%,188)
  g_convert_dtm_2_gtk%=ADD(a%,192)
  g_dtm_next_chunk%=ADD(a%,196)
  g_convert_gtk_2_s3m%=ADD(a%,200)
  g_convert_ft2_2_gtk%=ADD(a%,204)
  g_absolu_2_delta%=ADD(a%,208)
  g_delta_2_absolu%=ADD(a%,212)
  g_bmove%=ADD(a%,216)
  g_fx_stereo_flanger%=ADD(a%,220)
  g_packice_24_unpack%=ADD(a%,224)
  g_reverberation%=ADD(a%,228)
  g_grise_surface%=ADD(a%,232)
  g_convert_stereo16%=ADD(a%,236)
  g_start_song_recording%=ADD(a%,240)
  g_stop_song_recording%=ADD(a%,244)
  g_fx_compression%=ADD(a%,248)
  g_affiche_image_presentation%=ADD(a%,252)
  g_find_key_function%=ADD(a%,256)
  g_find_used_samples_and_instruments%=ADD(a%,260)
  g_speedpacker_unpack%=ADD(a%,264)
  a%=V:g_routines%(0)
  g_adrecr%=C:g_relocation%(L:a%)               ! Reloge la routine
  g_linewidth%=ADD(g_adrecr%,4)
  g_flag_sample_rec%=ADD(g_adrecr%,6)
  g_flag_sample_rec2%=ADD(g_adrecr%,8)
  g_adr_record_inf%=LONG{ADD(g_adrecr%,10)}     ! C'est directement l'adresse des infos de digit
  g_rec_sam_buffer%=LONG{ADD(g_adrecr%,14)}     ! C'est directement l'adresse du buffer 1 de digit
  g_sngrec_paramadr%=ADD(g_adrecr%,26)          ! Adresse des parametres de Song-2-Disk (DUMTRACK.PGT)
  g_progression_pos%=ADD(g_adrecr%,58)          ! Position de la progression
  g_progression_len%=ADD(g_adrecr%,62)          ! Longueur de la progression
  LPOKE g_adrecr%,adrlogscr%
  DPOKE g_linewidth%,SHR(scr_larg%,1)
  ~C:g_fabrique_fonte_ombr%(0)                  ! Fabrique la fonte ombree
RETURN
PROCEDURE charge_r_routines
  LOCAL a$,a%,b%,i%
  RESERVE 655360                                ! Il reste 640 Ko pour nous
  place_totale%=SUB(MALLOC(-1),system_memory%) AND -4   ! La place qu'il reste pour patterns+samples
  zone%=MALLOC(place_totale%)                   ! Les patterns, enveloppes et samples
  DIM module&(103)                              ! Le debut du module
  DIM song&(255)                                ! La song
  DIM instrset%(78,255)                         ! 256 * 316 octets pour les instruments
  DIM r_mod%(80000)                             ! 320 Ko pour la routine de replay
  DIM pattern_bidon%(20500)                     ! 2 * (32 + 64 * 32 * 5) : Patterns 256 et 257
  DIM module_bidon%(52)
  DIM song_bidon%(127)
  ARRAYFILL song_bidon%(),&H1010101
  song_bidon%(0)=&H1000101
  a$="GTK"+CHR$(gtk_file_vnum%)+SPACE$(192)+MKI$(255)+MKI$(nbr_lines%)+MKI$(nbr_track%)+MKI$(2)+MKI$(1)
  BMOVE V:a$,V:module_bidon%(0),208
  BLOAD npath_prog$+nfile_p2$,V:r_mod%(0)
  a%=V:r_mod%(0)
  b%=ADD(a%,28)
  rr_player_on%=ADD(b%,4)                       ! Routine d'activation du player
  rr_boucle_sample%=ADD(b%,8)                   ! Routine de bouclage d'un instrument
  rr_play_one_sample%=ADD(b%,12)                ! Routine de replay d'un sample sur une voie
  rr_play_one_note%=ADD(b%,16)                  ! Routine de replay d'une note sur une voie
  rr_songrecord_routine_no_realtime%=ADD(b%,20) ! Routine d'enregistrement d'un module
  a%=C:b%(L:a%)                                 ! On reloge
  r_itl%=DPEEK(a%)                              ! Taille des informations concernant 1 voie
  r_nbrvoies%=LPEEK(ADD(a%,2))
  r_master_vol%=LPEEK(ADD(a%,6))
  r_adr_sample%=LPEEK(ADD(a%,10))
  r_adr_module%=LPEEK(ADD(a%,14))
  r_adr_instrset%=LPEEK(ADD(a%,18))
  r_adr_song%=LPEEK(ADD(a%,22))
  r_adr_pattern%=LPEEK(ADD(a%,26))
  r_mod_nbrtrack%=LPEEK(ADD(a%,30))
  r_mix_volume_e_t%=LPEEK(ADD(a%,34))
  r_mod_songlen%=LPEEK(ADD(a%,38))
  r_mod_songrep%=LPEEK(ADD(a%,42))
  r_mod_songpos%=LPEEK(ADD(a%,46))
  r_mod_numpat%=LPEEK(ADD(a%,50))
  r_mod_linepos%=LPEEK(ADD(a%,54))
  r_mod_speed%=LPEEK(ADD(a%,58))
  r_mod_nbrvbl%=LPEEK(ADD(a%,62))
  r_info_track%=LPEEK(ADD(a%,66))
  r_repeatbuffer%=LPEEK(ADD(a%,70))
  r_flag_stop_voices%=LPEEK(ADD(a%,74))
  r_mix_volume_t%=LPEEK(ADD(a%,78))
  r_flag_the_end%=LPEEK(ADD(a%,82))
  r_onoff_t%=LPEEK(ADD(a%,86))
  r_nbits_t%=LPEEK(ADD(a%,90))
  r_fech_t%=LPEEK(ADD(a%,94))
  r_bal_t%=LPEEK(ADD(a%,98))
  r_flag_mt_display%=LPEEK(ADD(a%,102))
  r_vblsize%=LPEEK(ADD(a%,106))
  r_mod_patrep%=LPEEK(ADD(a%,110))
  r_vblnumber%=LPEEK(ADD(a%,114))
  r_adr_replay_frequency%=LONG{ADD(a%,118)}
  r_adr_evol%=LONG{ADD(a%,122)}
  r_adr_eton%=LONG{ADD(a%,126)}
  r_adr_epan%=LONG{ADD(a%,130)}
  r_songrecord_state%=LONG{ADD(a%,134)}
  r_songrecord_routine%=LONG{ADD(a%,138)}
  r_mod_tempo%=LONG{ADD(a%,142)}
  r_interpol_t%=LONG{ADD(a%,146)}
  r_adr_adr_inter%=LONG{ADD(a%,150)}
  r_current_play_mode%=LONG{ADD(a%,154)}
  r_current_edit_mode%=LONG{ADD(a%,158)}
  r_midi_in_gfa_playline%=LONG{ADD(a%,162)}
  r_midi_instr_map%=LONG{ADD(a%,166)}
  r_midi_track_state%=LONG{ADD(a%,170)}
  r_midi_ts_next%=LONG{ADD(a%,174)}
  r_new_note_buffer%=LONG{ADD(a%,178)}
  r_midi_in_noteoff_flag%=LONG{ADD(a%,182)}
  r_midi_in_velo_flag%=LONG{ADD(a%,186)}
  r_midi_in_sync_flag%=LONG{ADD(a%,190)}
  r_midi_in_sync_cpt%=LONG{ADD(a%,194)}
  r_midi_in_on%=LONG{ADD(a%,198)}
  r_cpu_time_pourcent%=LONG{ADD(a%,202)}
  r_flag_overload%=LONG{ADD(a%,206)}
  ' Initialisation du player
  garbage%=0
  GOSUB clear_patterns
  garbage%=1
  GOSUB clear_instr
  garbage%=2
  GOSUB clear_samples2
  garbage%=3
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  LPOKE r_adr_module%,V:module_bidon%(0)
  LPOKE r_adr_song%,V:song_bidon%(0)
  LPOKE r_adr_instrset%,V:instrset%(0,0)
  DPOKE r_flag_mt_display%,0
  ~C:rr_player_on%(W:1)                 ! Player active (mais ne joue rien)
RETURN
PROCEDURE teste_enregistrement
  LOCAL a%,b%,a$,c$,i%,user_nbr%
  flag_registered!=TRUE
  SHOWM
  GOSUB bee(TRUE)
  mes_registred$=treg_str1$
  IF FN exist(npath_prog$+treg_str2$)
    OPEN "i",#0,npath_prog$+treg_str2$
    IF LOF(#0)=1032
      c$=STRING$(1032,0)
      BGET #0,V:c$,1032
      a%=0                              ! Teste la somme de controle
      b%=1
      FOR i%=0 TO 1027
        a%=ADD(a%,MUL(b%,BYTE{ADD(V:c$,i%)} XOR 255))
        INC b%
      NEXT i%
      IF a%=LONG{ADD(V:c$,1028)}
        user%=LONG{ADD(V:c$,512)}
        a%=&H5BA3
        a$=""
        FOR i%=0 TO 510 STEP 2
          b%=CARD{ADD(V:c$,i%)}
          a$=a$+MKI$(b% XOR a%)
          a%=SUB(a%,b%) AND &HFFFF
        NEXT i%
        IF a$=MID$(c$,517,512) AND user%<>10
          flag_registered!=TRUE
          a%=ADD(INSTR(c$,treg_str3$),13)
          b%=INSTR(RIGHT$(c$,SUCC(SUB(LEN(c$),a%))),","+CHR$(13))
          mes_registred$=treg_str4$+MID$(c$,a%,PRED(b%))
        ELSE
          GOTO erreur_user.reg
        ENDIF
      ELSE
        GOTO erreur_user.reg
      ENDIF
    ELSE
    erreur_user.reg:
      mes_registred$=treg_str5$
    ENDIF
    CLOSE #0
  ENDIF
  GOSUB bee(FALSE)
RETURN
PROCEDURE charge_image_presentation
  LOCAL adr_img%,adr_logo%,col%,haut%,haut_img%,i%,j%,lig_aff%,lig_img%,lon_fic%,plan%,x_logo%
  LOCAL header%
  LOCAL dummy
  LOCAL pal$,logo$
  RANDOMIZE TIMER
  IF FN exist(npath_prog$+nfile_present$) AND FN exist(npath_prog$+nfile_logo$)
    logo$=STRING$(32034,0)
    BLOAD npath_prog$+nfile_logo$,V:logo$
    ~C:g_atomic_35_unpack%(L:V:logo$)           ! Au cas ou il serait packe
    OPEN "i",#0,npath_prog$+nfile_present$
    BGET #0,V:header%,4
    IF MKL$(header%)="ATM5"
      BGET #0,V:lon_fic%,4
    ELSE
      lon_fic%=LOF(#0)
    ENDIF
    SEEK #0,0
    IF lon_fic%<SUB(FRE(0),65536)
      GOSUB nouvelle_palette(STRING$(44,48))
      DIM image_presentation%(SHR(ADD(lon_fic%,3),2))
      adr_img%=V:image_presentation%(0)
      BGET #0,adr_img%,LOF(#0)
      ~C:g_atomic_35_unpack%(L:adr_img%)        ! Au cas ou il serait packe
      '
      ' Affichage de l'image puis du logo.
      '
      haut_img%=LONG{ADD(adr_img%,4)}
      IF DIV(scr_larg%,scr_haut%)<2             ! Mode video avec pixels carres
        haut%=MIN(scr_haut%,haut_img%)
        lig_img%=MIN(SUB(haut_img%,haut%),30)
        lig_aff%=SHR(SUB(scr_haut%,haut%),1)
        col%=SHR(SUB(scr_larg%,LONG{adr_img%}),4)
        VOID C:g_affiche_image_presentation%(L:adr_img%,W:col%,W:lig_aff%,W:lig_img%,W:haut%,W:FALSE)
        x_logo%=SHR(SUB(scr_larg%,320),1)
        adr_logo%=ADD(V:logo$,34)
        FOR i%=0 TO 119
          RC_COPY ADD(adr_logo%,MUL(i%,160)),0,0,320,1 TO XBIOS(2),PRED(x_logo%),i%,4
          RC_COPY ADD(adr_logo%,MUL(i%,160)),0,0,320,1 TO XBIOS(2),SUCC(x_logo%),i%,4
          RC_COPY ADD(adr_logo%,MUL(i%,160)),0,0,320,1 TO XBIOS(2),x_logo%,MAX(PRED(i%),0),4
          RC_COPY ADD(adr_logo%,MUL(i%,160)),0,0,320,1 TO XBIOS(2),x_logo%,SUCC(i%),4
        NEXT i%
        FOR i%=0 TO 119
          RC_COPY ADD(adr_logo%,MUL(i%,160)),0,0,320,1 TO XBIOS(2),x_logo%,i%,7
        NEXT i%
      ELSE                                      ! Mode video avec pixels rectangulaires
        DIV haut_img%,2
        haut%=MIN(scr_haut%,haut_img%)
        lig_img%=MIN(SUB(haut_img%,haut%),32)
        lig_aff%=SHR(SUB(scr_haut%,haut%),1)
        col%=SHR(SUB(scr_larg%,LONG{adr_img%}),4)
        VOID C:g_affiche_image_presentation%(L:adr_img%,W:col%,W:lig_aff%,W:lig_img%,W:haut%,W:TRUE)
        x_logo%=SHR(SUB(scr_larg%,320),1)
        adr_logo%=ADD(V:logo$,34)
        FOR i%=0 TO 59
          RC_COPY ADD(adr_logo%,MUL(i%,320)),0,0,320,1 TO XBIOS(2),PRED(x_logo%),i%,4
          RC_COPY ADD(adr_logo%,MUL(i%,320)),0,0,320,1 TO XBIOS(2),SUCC(x_logo%),i%,4
          RC_COPY ADD(adr_logo%,MUL(i%,320)),0,0,320,1 TO XBIOS(2),x_logo%,MAX(PRED(i%),0),4
          RC_COPY ADD(adr_logo%,MUL(i%,320)),0,0,320,1 TO XBIOS(2),x_logo%,SUCC(i%),4
        NEXT i%
        FOR i%=0 TO 59
          RC_COPY ADD(adr_logo%,MUL(i%,320)),0,0,320,1 TO XBIOS(2),x_logo%,i%,7
        NEXT i%
      ENDIF
      ERASE image_presentation%()
      '
      ' Palette de l'image
      '
      pal$=""
      dummy=RND
      IF dummy<0.85
        FOR i%=0 TO 15
          pal$=pal$+HEX$(MUL(i%,&H111),3)
        NEXT i%
      ELSE IF dummy<0.95
        FOR i%=0 TO 15
          pal$=pal$+HEX$(MUL(SUB(15,i%),&H111),3)
        NEXT i%
      ELSE IF dummy<0.975
        FOR i%=0 TO 15
          pal$=pal$+HEX$(ADD(MUL(i%,&H100),MUL(SUB(15,i%),&H10)),3)
        NEXT i%
      ELSE
        FOR i%=0 TO 15
          IF i%<8
            j%=ADD(i%,3)
          ELSE
            j%=SUB(19,i%)
          ENDIF
          pal$=pal$+HEX$(MUL(j%,&H111),3)
        NEXT i%
      ENDIF
      GOSUB nouvelle_palette(pal$)
      '
      ' Constitue le logo pour l'affichage dans le programme
      '
      graoumf_logo_mask$=MID$(logo$,35,19200)   ! 120 lignes de 160 octets
      graoumf_logo$=graoumf_logo_mask$
      FOR plan%=0 TO 3                          ! Met a 0 les bitplans non utilises, suivant la couleur
        IF NOT BTST(graoumf_logo_color%,plan%)
          adr_logo%=V:graoumf_logo$
          FOR i%=ADD(adr_logo%,SHL(plan%,1)) TO ADD(ADD(adr_logo%,SHL(plan%,1)),19192) STEP 8
            CARD{i%}=0
          NEXT i%
        ENDIF
      NEXT plan%
      attente_fin_presentation%=2               ! On laissera admirer 2 secondes l'image...
    ENDIF
    CLOSE #0
  ENDIF
RETURN
PROCEDURE sauve_palette
  LOCAL i%
  oldpalette$=""
  FOR i%=&HFFFF9800 TO &HFFFF983C STEP 4
    oldpalette$=oldpalette$+MKL$(LPEEK(i%))
  NEXT i%
RETURN
PROCEDURE nouvelle_palette(pal$)
  LOCAL a%,b%,c%
  FOR a%=0 TO 15
    ' Palette Falcon
    b%=SHL(VAL("&"+MID$(pal$,ADD(MUL(a%,3),3),1)),4)
    ADD b%,SHL(VAL("&"+MID$(pal$,ADD(MUL(a%,3),2),1)),20)
    ADD b%,SHL(VAL("&"+MID$(pal$,SUCC(MUL(a%,3)),1)),28)
    SLPOKE ADD(&HFFFF9800,SHL(a%,2)),b%
    ' Palette ST
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),3),1))
    b%=ADD(SHR(c%,1),SHL(c% AND 1,3))
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),2),1))
    ADD b%,SHL(ADD(SHR(c%,1),SHL(c% AND 1,3)),4)
    c%=VAL("&"+MID$(pal$,ADD(MUL(a%,3),1),1))
    ADD b%,SHL(ADD(SHR(c%,1),SHL(c% AND 1,3)),8)
    SDPOKE ADD(&HFFFF8240,SHL(a%,1)),b%
  NEXT a%
RETURN
PROCEDURE restaure_palette
  LOCAL iiiii%
  FOR iiiii%=0 TO &H3C STEP 4
    SLPOKE ADD(iiiii%,&HFFFF9800),CVL(MID$(oldpalette$,SUCC(iiiii%),4))
  NEXT iiiii%
RETURN
'
' Affichages de base
' ------------------
PROCEDURE resync_tv_screen
  LOCAL a%
  a%=GEMDOS(7) AND 255
  SELECT a%
  CASE "1"                                  ! Normal non entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H160
    SDPOKE &HFF8286,&HA7
    SDPOKE &HFF8288,&H70
    SDPOKE &HFF828A,&H120
    SDPOKE &HFF828C,&H1B4
    SDPOKE &HFF82A2,&H20D
    SDPOKE &HFF82A4,&H201
    SDPOKE &HFF82A6,&H32
    SDPOKE &HFF82A8,&H4D
    SDPOKE &HFF82AA,&H1DD
    SDPOKE &HFF82AC,&H207
  CASE "2"                                  ! Normal entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H160
    SDPOKE &HFF8286,&HA7
    SDPOKE &HFF8288,&H70
    SDPOKE &HFF828A,&H120
    SDPOKE &HFF828C,&H1B4
    SDPOKE &HFF82A2,&H20C
    SDPOKE &HFF82A4,&H201
    SDPOKE &HFF82A6,&H32
    SDPOKE &HFF82A8,&H4C
    SDPOKE &HFF82AA,&H1DC
    SDPOKE &HFF82AC,&H207
  CASE "4"                                  ! Overscan non entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H180
    SDPOKE &HFF8286,&H7F
    SDPOKE &HFF8288,&H2D
    SDPOKE &HFF828A,&H15D
    SDPOKE &HFF828C,&H1A1
    SDPOKE &HFF82A2,&H20D
    SDPOKE &HFF82A4,&H207
    SDPOKE &HFF82A6,&H25
    SDPOKE &HFF82A8,&H25
    SDPOKE &HFF82AA,&H205
    SDPOKE &HFF82AC,&H207
  CASE "5"                                  ! Overscan entrelace
    SDPOKE &HFF8282,&H1FF
    SDPOKE &HFF8284,&H180
    SDPOKE &HFF8286,&H7F
    SDPOKE &HFF8288,&H2D
    SDPOKE &HFF828A,&H15D
    SDPOKE &HFF828C,&H1A1
    SDPOKE &HFF82A2,&H20C
    SDPOKE &HFF82A4,&H207
    SDPOKE &HFF82A6,&H25
    SDPOKE &HFF82A8,&H24
    SDPOKE &HFF82AA,&H204
    SDPOKE &HFF82AC,&H207
  ENDSELECT
RETURN
PROCEDURE cadre_int(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_int%(L:iiii%)
RETURN
PROCEDURE cadre_ext(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_ext%(L:iiii%)
RETURN
PROCEDURE cadre_o_int(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  GOSUB cadre_int(ADD(aaaa%,1),ADD(bbbb%,4),MAX(MIN(cccc%,SUB(SUB(scr_ncol%,aaaa%),2)),0),MAX(MIN(dddd%,SUB(SUB(scr_haut%,bbbb%),2)),0),0,0,0,0)
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_int%(L:iiii%)
RETURN
PROCEDURE cadre_o_ext(aaaa%,bbbb%,cccc%,dddd%,eeee%,ffff%,gggg%,hhhh%)
  LOCAL aaaa$,iiii%
  HIDEM
  GOSUB cadre_ext(ADD(aaaa%,1),ADD(bbbb%,4),MAX(MIN(cccc%,SUB(SUB(scr_ncol%,aaaa%),2)),0),MAX(MIN(dddd%,SUB(SUB(scr_haut%,bbbb%),2)),0),0,0,0,0)
  aaaa$=MKI$(aaaa%)+MKI$(bbbb%)+MKI$(cccc%)+MKI$(dddd%)+CHR$(eeee%)+CHR$(ffff%)+CHR$(gggg%)+CHR$(hhhh%)
  iiii%=V:aaaa$
  ~C:g_dessine_cadre_ext%(L:iiii%)
RETURN
PROCEDURE cadre_texte(aaaa$,xxxx%,yyyy%,llll%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte2(aaaa$,xxxx%,yyyy%,llll%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(9)+CHR$(9)+CHR$(8)+CHR$(10)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte3(aaaa$,xxxx%,yyyy%,llll%,hhhh%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(9)+CHR$(9)+CHR$(10)+CHR$(8)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(9)+CHR$(9)+CHR$(8)+CHR$(10)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte_b(aaaa$,xxxx%,yyyy%,llll%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte2_b(aaaa$,xxxx%,yyyy%,llll%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(9)+CHR$(13)+CHR$(13)+CHR$(12)+CHR$(14)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE cadre_texte3_b(aaaa$,xxxx%,yyyy%,llll%,hhhh%,pppp%)
  LOCAL aaaa%,bbbb%,bbbb$,cccc$
  HIDEM
  IF aaaa$=""
    aaaa$=CHR$(0)
  ENDIF
  cccc$=aaaa$+CHR$(0)
  aaaa%=V:cccc$
  IF pppp%=0
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(13)+CHR$(13)+CHR$(14)+CHR$(12)
  ELSE
    bbbb$=MKI$(xxxx%)+MKI$(yyyy%)+MKI$(0)+MKI$(hhhh%)+CHR$(13)+CHR$(13)+CHR$(12)+CHR$(14)
  ENDIF
  bbbb%=V:bbbb$
  ~C:g_cadre_centre%(L:bbbb%,L:aaaa%,W:llll%)
RETURN
PROCEDURE grise_surface(xxxx%,yyyy%,llll%,hhhh%)
  ~C:g_grise_surface%(W:xxxx%,W:yyyy%,W:llll%,W:hhhh%)
RETURN
PROCEDURE grise_icone(nnn%,ttt%,xxxd%,yyyd%)
  GOSUB grise_surface(ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%))
RETURN
PROCEDURE affchaine_notrans(aaaa$,xxxx%,yyyy%,cccc%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_notrans%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%)
  ENDIF
RETURN
PROCEDURE affchaine_trans(aaaa$,xxxx%,yyyy%,cccc%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_trans%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%)
  ENDIF
RETURN
PROCEDURE affchaine_trans_ombr(aaaa$,xxxx%,yyyy%,cccc%,cccc2%)
  LOCAL aaaa%,bbbb$
  IF aaaa$<>""
    HIDEM
    bbbb$=aaaa$+CHR$(0)
    aaaa%=V:bbbb$
    ~C:g_affchaine_trans_ombr%(L:aaaa%,W:yyyy%,W:xxxx%,W:cccc%,W:cccc2%)
  ENDIF
RETURN
PROCEDURE affchaine_tronque(aaa$,xxx%,yyy%,ccc%,lll%)
  IF LEN(aaa$)>lll%
    aaa$=LEFT$(aaa$,PRED(lll%))+CHR$(11)
  ENDIF
  GOSUB affchaine_notrans(aaa$,xxx%,yyy%,ccc%)
RETURN
PROCEDURE affiche_icone(nnn%,ttt%,xxxd%,yyyd%,ccc%)
  GOSUB cadre_texte3(divbn$(nnn%,ttt%),ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%),ccc%)
RETURN
PROCEDURE affiche_icone_b(nnn%,ttt%,xxxd%,yyyd%,ccc%)
  GOSUB cadre_texte3_b(divbn$(nnn%,ttt%),ADD(divbi&(0,nnn%,ttt%),xxxd%),ADD(divbi&(1,nnn%,ttt%),yyyd%),divbi&(2,nnn%,ttt%),divbi&(3,nnn%,ttt%),ccc%)
RETURN
PROCEDURE affiche_bloc_icones(dd%,nn%,tt%,xxd%,yyd%)
  LOCAL ii%
  FOR ii%=dd% TO ADD(dd%,PRED(nn%))
    GOSUB affiche_icone(ii%,tt%,xxd%,yyd%,0)
  NEXT ii%
RETURN
PROCEDURE affiche_bloc_icones_b(dd%,nn%,tt%,xxd%,yyd%)
  LOCAL ii%
  FOR ii%=dd% TO ADD(dd%,PRED(nn%))
    GOSUB affiche_icone_b(ii%,tt%,xxd%,yyd%,0)
  NEXT ii%
RETURN
PROCEDURE affiche_pattern(pat%,lig%,pre%)
  LOCAL a%,b%,xm%,ym%,km%
  a%=V:para_affiche_pattern$
  BMOVE V:preset&(0,pre%),ADD(a%,8),64
  CARD{ADD(a%,2)}=FN nbr_lines(pat%)
  CARD{ADD(a%,4)}=MIN(nbr_colonnes%(pre%),nbr_col%)
  b%=FN adr_pat(pat%)
  MOUSE xm%,ym%,km%
  IF xm%>23 AND ym%>153 AND ym%<ADD(170,MUL(haut_lig%,6))
    HIDEM
  ELSE
    SHOWM
  ENDIF
  ~C:g_affiche_pattern%(W:lig%,L:a%,L:b%,L:adr_af_pat%,W:curs_col%,W:curs_x%)
  SHOWM
RETURN
PROCEDURE affiche_c_pattern
  LOCAL a%,b%,xm%,ym%,km%
  a%=V:para_affiche_pattern$
  BMOVE V:preset&(0,n_preset%),ADD(a%,8),64
  CARD{ADD(a%,2)}=FN nbr_lines2(songpos%)
  CARD{ADD(a%,4)}=MIN(nbr_colonnes%(n_preset%),nbr_col%)
  b%=FN adr_pat(song&(songpos%))
  MOUSE xm%,ym%,km%
  IF xm%>23 AND ym%>153 AND ym%<ADD(170,MUL(haut_lig%,6))
    HIDEM
  ELSE
    SHOWM
  ENDIF
  ~C:g_affiche_pattern%(W:posligne%,L:a%,L:b%,L:adr_af_pat%,W:curs_col%,W:curs_x%)
  SHOWM
RETURN
PROCEDURE save_background(x%,y%,l%,h%)
  LOCAL i%,size%,adrinc%
  adrinc%=SHR(ADD(l%,15) AND -16,1)
  size%=MUL(adrinc%,h%)
  IF MALLOC(-1)>ADD(size%,8)
    adr_background%=MALLOC(ADD(size%,8))
    CARD{adr_background%}=x%
    CARD{ADD(adr_background%,2)}=y%
    CARD{ADD(adr_background%,4)}=l%
    CARD{ADD(adr_background%,6)}=h%
    a%=ADD(adr_background%,8)
    HIDEM
    FOR i%=0 TO PRED(h%)
      RC_COPY XBIOS(3),x%,ADD(y%,i%),l%,1 TO a%,0,0
      ADD a%,adrinc%
    NEXT i%
  ELSE
    adr_background%=0
  ENDIF
RETURN
PROCEDURE restore_background
  LOCAL i%,x%,y%,l%,h%,adrinc%
  IF adr_background%<>0
    x%=CARD{adr_background%}
    y%=CARD{ADD(adr_background%,2)}
    l%=CARD{ADD(adr_background%,4)}
    h%=CARD{ADD(adr_background%,6)}
    a%=ADD(adr_background%,8)
    adrinc%=SHR(ADD(l%,15) AND -16,1)
    HIDEM
    FOR i%=0 TO PRED(h%)
      RC_COPY a%,0,0,l%,1 TO XBIOS(3),x%,ADD(y%,i%)
      ADD a%,adrinc%
    NEXT i%
    ~MFREE(adr_background%)
    adr_background%=0
  ELSE
    GOSUB affiche_panneau_principal
  ENDIF
RETURN
'
' Sous-menus du tracker
' --------------------
PROCEDURE aff_nssmenu
  LOCAL iiii%
  FOR iiii%=1 TO 7
    IF ss_menu%=iiii%
      GOSUB affiche_icone_b(ADD(iiii%,9),24,0,0,-1)
    ELSE
      GOSUB affiche_icone(ADD(iiii%,9),24,0,0,0)
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE affiche_icones_commande
  GOSUB affiche_bloc_icones(0,17,24,0,0)
  GOSUB grise_icone(3,24,0,0)                   ! Prefs
  GOSUB grise_icone(4,24,0,0)                   ! Score
  GOSUB grise_icone(8,24,0,0)                   ! Drum Editor
  GOSUB aff_nssmenu
RETURN
PROCEDURE gere_icones_haut
  LOCAL a%,b%,d%,i%,srt%
  LOCAL a$
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:24,W:xm%,W:ym%)
  IF srt%>=0
    GOSUB affiche_icone(srt%,24,0,0,-1)
    GOSUB wait_mouse(TRUE)
    SELECT srt%
      ' ----------------------------------------------------------------------
    CASE 0      ! Play song
      GOSUB edit_mode_off
      IF km%=2
        GOSUB play_song(TRUE)
      ELSE
        GOSUB play_song(FALSE)
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 1      ! Edit
      GOSUB edit_mode_on
      SLPOKE &HFFFF983C,&HFF            ! Bleu
      GOSUB aff_ps_pp_e
      GOSUB aff_message("Edit mode activated.")
      ' ----------------------------------------------------------------------
    CASE 5      ! Play pattern
      GOSUB edit_mode_off
      IF km%=2
        GOSUB play_pattern(TRUE)
      ELSE
        GOSUB play_pattern(FALSE)
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 10     ! Disk
      ss_menu%=1
      GOSUB aff_nssmenu
      GOSUB affiche_icones_disk
      ' ----------------------------------------------------------------------
    CASE 11     ! Tools
      ss_menu%=2
      GOSUB aff_nssmenu
      GOSUB affiche_icones_tools
      ' ----------------------------------------------------------------------
    CASE 12     ! Instruments
      ss_menu%=3
      GOSUB aff_nssmenu
      GOSUB affiche_icones_instr
      ' ----------------------------------------------------------------------
    CASE 13     ! Samples
      ss_menu%=4
      GOSUB aff_nssmenu
      GOSUB affiche_icones_sample
      ' ----------------------------------------------------------------------
    CASE 14     ! Envelopes
      ss_menu%=5
      GOSUB aff_nssmenu
      GOSUB affiche_icones_enveloppe
      ' ----------------------------------------------------------------------
    CASE 15     ! Control
      ss_menu%=6
      GOSUB aff_nssmenu
      GOSUB affiche_icones_control
      ' ----------------------------------------------------------------------
    CASE 16     ! Midi
      ss_menu%=7
      GOSUB aff_nssmenu
      GOSUB affiche_icones_midi
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 2      ! Insert position
        IF FN song_length<256
          GOSUB stop_voices
          IF songpos%<PRED(FN song_length)
            FOR i%=PRED(FN song_length) DOWNTO songpos%
              song&(SUCC(i%))=song&(i%)
            NEXT i%
          ENDIF
          INC module&(101)
          IF FN song_repeat>songpos%
            INC module&(102)
          ENDIF
          INC songpos%
          IF km%=2        ! Clic droit  : Nouveau pattern inutilise
            a%=0
            i%=0
            REPEAT
              IF a%=song&(i%)
                INC a%
                i%=-1
              ENDIF
              INC i%
            UNTIL i%=>FN song_length
            song&(songpos%)=a%
            IF FN nbr_lines(a%)=1               ! Initialise la hauteur du pattern s'il est vide
              GOSUB bee(TRUE)
              b%=FN adr_pat(a%)
              i%=nbr_track%
              WHILE LONG{b%}=0 AND BYTE{ADD(b%,4)}=0 AND i%>0
                DEC i%
                ADD b%,5
              WEND
              IF i%=0
                GOSUB change_pattern_high(a%,default_pattern_high%)
              ENDIF
              GOSUB bee(FALSE)
            ENDIF
          ENDIF
          a$=TRIM$(FN patternname$(song&(songpos%)))
          IF a$<>""
            a$=" ("+a$+")"
          ENDIF
          GOSUB aff_message("Pattern "+HEX$(song&(songpos%),2)+a$+" inserted at position "+HEX$(songpos%,2)+".")
          GOSUB affiche_info_song
          GOSUB affiche_c_pattern
        ENDIF
        ' --------------------------------------------------------------------
      CASE 3      ! Preferences
        ' Rien
        ' GOSUB prefs
        ' --------------------------------------------------------------------
      CASE 4      ! Score
        ' Rien
        ' --------------------------------------------------------------------
      CASE 6      ! Stop
        GOSUB edit_mode_off
        GOSUB stop_voices
        SLPOKE &HFFFF983C,&HFFFF00FF      ! Blanc
        GOSUB aff_ps_pp_e
        GOSUB aff_message("Song stopped and Edit mode deactivated.")
        ' --------------------------------------------------------------------
      CASE 7      ! Delete position
        IF songpos%<PRED(FN song_length)
          FOR i%=SUCC(songpos%) TO PRED(FN song_length)
            song&(PRED(i%))=song&(i%)
          NEXT i%
          DEC module&(101)
          song&(FN song_length)=0
          IF FN song_repeat>songpos%
            DEC module&(102)
          ENDIF
          GOSUB affiche_info_song
          GOSUB affiche_c_pattern
          GOSUB aff_message("Position "+HEX$(songpos%,2)+" deleted.")
        ENDIF
        ' --------------------------------------------------------------------
        ' CASE 8            ! Help
        ' GOSUB help(0)
      CASE 8            ! Drum Editor
        GOSUB drum_editor
        GOSUB affiche_panneau_principal
        ' --------------------------------------------------------------------
      CASE 9            ! Sample Editor
        GOSUB sample_editor
        GOSUB affiche_panneau_principal
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone(srt%,24,0,0,0)
      GOSUB grise_icone(3,24,0,0)               ! Prefs
      GOSUB grise_icone(4,24,0,0)               ! Score
      GOSUB grise_icone(8,24,0,0)               ! Drum Editor
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
PROCEDURE gere_icones_panneaup
  LOCAL a%,b%,d%,h%,i%,srt%
  LOCAL flag_relachement!
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:16,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 12                     ! Numero d'instrument
      IF km%=2
        instr%=sample%
        ss_menu%=3
        GOSUB aff_nssmenu
        GOSUB affiche_icones_instr
        GOSUB affiche_info_sample
      ELSE
        d%=0
        GOSUB chg_instrument
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 15                     ! Numero de sample
      IF km%=2
        sample%=FN isample(instr%,instr_note_pos%)
        ss_menu%=4
        GOSUB aff_nssmenu
        GOSUB affiche_icones_sample
        GOSUB affiche_info_sample
      ELSE
        d%=0
        GOSUB chg_sample
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 0,3,6,9,18             ! Autres icones: Edition des numeros
      d%=0
      ON DIV(ADD(srt%,3),3) GOSUB chg_songpos,chg_pattern,chg_songlen,chg_songrep,rien,rien,chg_linestep
      ' ----------------------------------------------------------------------
    CASE 1,4,7,10,13,16,19      ! Numero +
      d%=1
      ON DIV(ADD(srt%,2),3) GOSUB chg_songpos,chg_pattern,chg_songlen,chg_songrep,chg_instrument,chg_sample,chg_linestep
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 2,5,8,11,14,17,20      ! Numero -
      d%=-1
      ON DIV(ADD(srt%,1),3) GOSUB chg_songpos,chg_pattern,chg_songlen,chg_songrep,chg_instrument,chg_sample,chg_linestep
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 21                     ! Songname
      GOSUB edite_chaine(FN songname$,ADD(divbi&(0,srt%,16),9),ADD(divbi&(1,srt%,16),2),32,0)
      BMOVE V:bbbb$,V:module&(2),32
      GOSUB affiche_info_song
      ' ----------------------------------------------------------------------
    CASE 22                     ! Instrname
      GOSUB edite_chaine(FN instrname$(instr%),ADD(divbi&(0,srt%,16),9),ADD(divbi&(1,srt%,16),2),28,0)
      GOSUB chg_instrname(bbbb$,instr%)
      GOSUB affiche_info_song
      ' ----------------------------------------------------------------------
    CASE 23                     ! Track
      GOSUB edite_chaine(STR$(nbr_track%,2),ADD(divbi&(0,srt%,16),7),ADD(divbi&(1,srt%,16),2),2,2)
      a%=MAX(MIN(VAL(bbbb$),32),1)
      IF a%<>nbr_track%
        GOSUB change_format(a%)
      ELSE
        GOSUB affiche_panneau_principal
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 24                     ! Lines
      a%=song&(songpos%)
      IF km%=1
        GOSUB edite_chaine(STR$(FN nbr_lines(a%),3),ADD(divbi&(0,srt%,16),6),ADD(divbi&(1,srt%,16),2),3,2)
        h%=MAX(MIN(VAL(bbbb$),256),1)
        GOSUB bee(TRUE)
        GOSUB change_pattern_high(song&(songpos%),h%)
      ELSE                                      ! Initialise la hauteur du pattern avec la valeur predefinie
        GOSUB bee(TRUE)
        GOSUB change_pattern_high(a%,default_pattern_high%)
      ENDIF
      GOSUB affiche_info_song
      GOSUB affiche_c_pattern
      GOSUB bee(FALSE)
      ' ----------------------------------------------------------------------
    CASE 25                     ! Horloge
      debut_temps%=TIMER
      GOSUB affiche_temps
      ' ----------------------------------------------------------------------
    CASE 27                     ! Preset
      ' Rien
      ' ----------------------------------------------------------------------
    CASE 3,4                    ! Prefs & Score
      ' Rien
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone(srt%,16,0,0,-1)
      ' GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 26                   ! ON/OFF
        IF km%=1                        ! Bouton gauche : toutes les voies ON
          GOSUB all_track_on(TRUE)
        ELSE                            ! Bouton droit : inversion de l'etat de chaque voie
          FOR i%=0 TO PRED(nbr_track%)
            GOSUB chg_track_onoff(i%,ABS(SGN(FN track_onoff(i%))) XOR 1)
            GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(8,SHL(i%,1)),120,1,FN track_onoff(i%) XOR 1)
          NEXT i%
        ENDIF
        GOSUB affiche_info_preset
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone(srt%,16,0,0,0)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Disk
PROCEDURE affiche_icones_disk
  LOCAL i%
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,16,0,0,0)
  GOSUB cadre_ext(ADD(divbi&(0,8,0),8),ADD(divbi&(1,8,0),2),15,5,0,13,12,14)
  GOSUB cadre_ext(SUCC(divbi&(0,9,0)),ADD(divbi&(1,9,0),2),SUB(divbi&(2,9,0),2),5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,10,0),12),ADD(divbi&(1,10,0),2),4,5,0,13,12,14)
  GOSUB affchaine_trans("SAVE CONF",134,82,14)
  GOSUB grise_icone(4,0,0,0)
  GOSUB grise_icone(5,0,0,0)
  GOSUB grise_icone(6,0,0,0)
  GOSUB grise_icone(7,0,0,0)
  GOSUB affiche_icones_diskb
RETURN
PROCEDURE affiche_icones_diskb
  LOCAL a$,b$
  SELECT path_displayed%
  CASE 0
    a$=npath_prog$
    b$="System"
  CASE 1
    a$=npath_module$+nfile_module$
    b$="Module"
  CASE 2
    a$=npath_prefs$+nfile_prefs$
    b$="Preferences"
  CASE 3
    a$=npath_sample$+nfile_sample$
    b$="Sample # "+HEX$(sample%,2)
  CASE 4
    a$=npath_sample$
    b$="Instrument # "+HEX$(instr%,2)
  CASE 5
    a$=npath_autoload$
    b$="Autoload"
  CASE 6
    a$=npath_div$
    b$="Miscellaneous"
  ENDSELECT
  IF LEN(a$)<58
    a$=a$+SPACE$(SUB(58,LEN(a$)))
  ENDIF
  b$=b$+SPACE$(SUB(16,LEN(b$)))
  GOSUB affchaine_notrans(b$,ADD(divbi&(0,8,0),8),ADD(divbi&(1,8,0),2),1)
  GOSUB affchaine_tronque(a$,SUCC(divbi&(0,9,0)),ADD(divbi&(1,9,0),2),1,SUB(divbi&(2,9,0),1))
  a$=SPACE$(SUB(5,LEN(next_module$)))+next_module$
  GOSUB affchaine_notrans(a$,ADD(divbi&(0,10,0),12),ADD(divbi&(1,10,0),2),1)
  GOSUB affiche_icone_b(16,0,0,0,flag_gt2cnf!)
RETURN
PROCEDURE gere_icones_disk
  LOCAL a%,srt%
  LOCAL a$
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:0,W:xm%,W:ym%)
  ~FRE(0)
  SELECT srt%
    ' ------------------------------------------------------------------------
  CASE 0 TO 7,11 TO 15
    GOSUB affiche_icone_b(srt%,0,0,0,1)
    GOSUB wait_mouse(TRUE)
    IF srt%<=7
      ON SUCC(srt%) GOSUB load_module,save_module,load_prefs,save_prefs,rien,rien,rien,rien
    ELSE
      ON SUB(srt%,10) GOSUB make_directory,delete_directory,rename_file,delete_file,format_disk
    ENDIF
    GOSUB affiche_icone_b(srt%,0,0,0,0)
    ' ------------------------------------------------------------------------
  CASE 8
    a%=FN popup(2,path_displayed%,MOUSEX,MOUSEY)
    IF a%>=0
      path_displayed%=a% AND &HFFFF
    ENDIF
    GOSUB affiche_icones_diskb
    ' ------------------------------------------------------------------------
  CASE 9
    ON SUCC(path_displayed%) GOSUB rien,selpath_module,selpath_prefs,selpath_sample,selpath_sample,selpath_autoload,rien
    GOSUB affiche_icones_diskb
    ' ------------------------------------------------------------------------
  CASE 10
    a$="GT2GTKMODS3MDTMMMDMTM669ULTXM  *  "
    a%=INSTR(a$,RIGHT$(next_module$,SUB(LEN(next_module$),INSTR(next_module$,"."))))
    IF a%>0
      a%=DIV(PRED(a%),3)
    ELSE
      a%=-1
    ENDIF
    a%=FN popup(0,a%,MOUSEX,MOUSEY)
    IF a%>=0
      a%=a% AND &HFFFF
      next_module$="*."+TRIM$(MID$(a$,SUCC(MUL(a%,3)),3))
    ENDIF
    GOSUB affiche_icones_diskb
    ' ------------------------------------------------------------------------
  CASE 16
    flag_gt2cnf!=NOT flag_gt2cnf!
    GOSUB affiche_icones_diskb
    GOSUB wait_mouse(TRUE)
    ' ------------------------------------------------------------------------
  ENDSELECT
RETURN
' Tools
PROCEDURE affiche_icones_tools
  LOCAL i%
  IF ss_menut%=2
    GOSUB affiche_icones_tools2
  ELSE IF ss_menut%=3
    GOSUB affiche_icones_tools3
  ELSE
    GOSUB cadre_int(20,35,59,69,13,13,14,12)
    GOSUB cadre_int(20,35,11,39,13,13,14,12)
    GOSUB cadre_int(32,35,27,39,13,13,14,12)
    GOSUB cadre_int(60,35,9,39,13,13,14,12)
    GOSUB cadre_int(70,35,9,43,13,13,14,12)
    GOSUB cadre_int(20,75,41,29,13,13,14,12)
    GOSUB affiche_bloc_icones_b(0,9,1,0,0)
    GOSUB affiche_bloc_icones_b(16,7,1,0,0)
    GOSUB cadre_ext(ADD(divbi&(0,16,1),11),ADD(divbi&(1,16,1),2),10,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,17,1),11),ADD(divbi&(1,17,1),2),10,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,18,1),9),ADD(divbi&(1,18,1),2),5,5,0,13,12,14)
    GOSUB affchaine_trans("BLOCK",42,37,14)
    GOSUB affchaine_trans("ACTION",106,37,14)
    GOSUB affchaine_trans("CLEAR",SHL(divbi&(0,19,1),1),SUB(divbi&(1,19,1),8),14)
    GOSUB affiche_icones_toolsb
  ENDIF
RETURN
PROCEDURE affiche_icones_toolsb
  LOCAL a%,b%,c%,d%,i%,x1%,x2%,x3%,y1%,y2%,y3%,a1%,a2%,b1%,b2%
  IF ss_menut%=2
    GOSUB affiche_icones_toolsb2
  ELSE IF ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ELSE
    GOSUB affiche_icone_b(9,1,0,0,replaceblock%=0)
    GOSUB affiche_icone_b(12,1,0,0,replaceblock%=1)
    GOSUB affiche_icone_b(10,1,0,0,maskblock%=0)
    GOSUB affiche_icone_b(13,1,0,0,maskblock%=1)
    GOSUB affiche_icone_b(11,1,0,0,trackpat%=0)
    GOSUB affiche_icone_b(14,1,0,0,trackpat%=1)
    GOSUB affiche_icone_b(15,1,0,0,trackpat%=2)
    GOSUB affiche_icone_b(23,1,0,0,bl_flagsong!)
    x1%=ADD(divbi&(0,16,1),11)
    y1%=ADD(divbi&(1,16,1),2)
    x2%=ADD(divbi&(0,17,1),11)
    y2%=ADD(divbi&(1,17,1),2)
    x3%=ADD(divbi&(0,18,1),9)
    y3%=ADD(divbi&(1,18,1),2)
    a1%=V:bl_maska1$
    a2%=V:bl_maska2$
    b1%=V:bl_maskb1$
    b2%=V:bl_maskb2$
    IF BYTE{a1%}=0
      GOSUB affchaine_notrans("?  ",x1%,y1%,1)
    ELSE
      IF BYTE{a2%}=0
        GOSUB affchaine_notrans("---",x1%,y1%,1)
      ELSE
        GOSUB affchaine_notrans(MID$(gamme$,SUCC(SHL(BYTE{a2%} MOD 12,1)),2)+STR$(SUB(DIV(BYTE{a2%},12),2),1),x1%,y1%,1)
      ENDIF
    ENDIF
    IF BYTE{b1%}=255
      GOSUB affchaine_notrans("?  ",x2%,y2%,1)
    ELSE
      IF BYTE{b2%}=0
        GOSUB affchaine_notrans("---",x2%,y2%,1)
      ELSE
        GOSUB affchaine_notrans(MID$(gamme$,SUCC(SHL(BYTE{b2%} MOD 12,1)),2)+STR$(SUB(DIV(BYTE{b2%},12),2),1),x2%,y2%,1)
      ENDIF
    ENDIF
    a1%=LONG{SUCC(a1%)}
    a2%=LONG{SUCC(a2%)}
    b1%=LONG{SUCC(b1%)}
    b2%=LONG{SUCC(b2%)}
    FOR i%=0 TO 7
      IF (SHL(a1%,SHL(i%,2)) AND &HF0000000)=&H0
        GOSUB affchaine_notrans("?",ADD(ADD(x1%,i%),3),y1%,1)
      ELSE
        GOSUB affchaine_notrans(HEX$(SHR(a2%,SUB(28,SHL(i%,2))) AND 15,1),ADD(ADD(x1%,i%),3),y1%,1)
      ENDIF
      IF (SHL(b1%,SHL(i%,2)) AND &HF0000000)=&HF0000000
        GOSUB affchaine_notrans("?",ADD(ADD(x2%,i%),3),y2%,1)
      ELSE
        GOSUB affchaine_notrans(HEX$(SHR(b2%,SUB(28,SHL(i%,2))) AND 15,1),ADD(ADD(x2%,i%),3),y2%,1)
      ENDIF
      IF i%<6
        IF (SHL(ext_note1%,SHL(i%,2)) AND &HF00000)=&HF00000
          GOSUB affchaine_notrans("?",ADD(x3%,i%),y3%,1)
        ELSE
          GOSUB affchaine_notrans(HEX$(SHR(ext_note2%,SUB(20,SHL(i%,2))) AND 15,1),ADD(x3%,i%),y3%,1)
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
RETURN
PROCEDURE gere_icones_tools
  LOCAL a%,b%,c%,d%,i%,srt%
  IF ss_menut%=2
    GOSUB gere_icones_tools2
  ELSE IF ss_menut%=3
    GOSUB gere_icones_tools3
  ELSE
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:1,W:xm%,W:ym%)
    IF srt%=>0
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 9
        replaceblock%=0
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 10
        maskblock%=0
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 11
        trackpat%=0
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 12
        replaceblock%=1
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 13
        maskblock%=1
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 14
        trackpat%=1
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 15
        trackpat%=2
        GOSUB affiche_icones_toolsb
        ' --------------------------------------------------------------------
      CASE 16       ! Mask on
        GOSUB edite_mask1(bl_maska1$,bl_maska2$,ADD(divbi&(0,16,1),11),ADD(divbi&(1,16,1),2),0,0)
        bl_maska1$=zzzz1$
        bl_maska2$=zzzz2$
        ' --------------------------------------------------------------------
      CASE 17       ! Replace by
        GOSUB edite_mask1(bl_maskb1$,bl_maskb2$,ADD(divbi&(0,17,1),11),ADD(divbi&(1,17,1),2),-1,0)
        bl_maskb1$=zzzz1$
        bl_maskb2$=zzzz2$
        ' --------------------------------------------------------------------
      CASE 18       ! Ext note
        GOSUB edite_mask1(CHR$(0)+MKL$(ext_note1%),CHR$(0)+MKL$(ext_note2%),ADD(divbi&(0,18,1),9),ADD(divbi&(1,18,1),2),-1,1)
        ext_note1%=LONG{SUCC(V:zzzz1$)} AND &HFFFFFF
        ext_note2%=LONG{SUCC(V:zzzz2$)} AND &HFFFFFF
        ' --------------------------------------------------------------------
      CASE 19       ! Clear song
        GOSUB dialog("CLEAR SONG","Do you really want|to do that ?","Ok|Cancel",MOUSEX,MOUSEY)
        IF bouton%=0
          GOSUB aff_message("Clearing song & patterns...")
          GOSUB bee(TRUE)
          GOSUB clear_song(TRUE)
          GOSUB aff_message("Song cleared.")
          GOSUB bee(FALSE)
          GOSUB affiche_info_song
          GOSUB affiche_info_preset
        ENDIF
        ' --------------------------------------------------------------------
      CASE 20       ! Clear instr
        GOSUB dialog("CLEAR SAMPLES","Do you really want|to clear your samples,|instruments and envelopes ?","Ok|Cancel",MOUSEX,MOUSEY)
        IF bouton%=0
          GOSUB aff_message("Clearing samples...")
          GOSUB bee(TRUE)
          GOSUB clear_instr
          GOSUB aff_message("Clearing instruments & envelopes...")
          GOSUB bee(TRUE)
          GOSUB clear_samples
          GOSUB aff_message("Samples cleared.")
          GOSUB bee(FALSE)
          GOSUB affiche_info_song
          GOSUB affiche_info_sample
        ENDIF
        ' --------------------------------------------------------------------
      CASE 21       ! Clear all
        GOSUB dialog("CLEAR ALL","Do you really want|to clear all your module ?","Ok|Cancel",MOUSEX,MOUSEY)
        IF bouton%=0
          GOSUB aff_message("Clearing song & patterns...")
          GOSUB bee(TRUE)
          GOSUB clear_song(TRUE)
          GOSUB aff_message("Clearing samples...")
          GOSUB bee(TRUE)
          GOSUB clear_samples
          GOSUB aff_message("Clearing instruments & envelopes...")
          GOSUB bee(TRUE)
          GOSUB clear_instr
          GOSUB aff_message("Module cleared.")
          GOSUB bee(FALSE)
          GOSUB affiche_info_song
          GOSUB affiche_info_sample
          GOSUB affiche_info_preset
        ENDIF
        ' --------------------------------------------------------------------
      CASE 22       ! Page suivante
        GOSUB affiche_icone_b(srt%,1,0,0,1)
        GOSUB wait_mouse(TRUE)
        ss_menut%=2
        GOSUB affiche_icones_tools2
        ' --------------------------------------------------------------------
      CASE 23       ! Operations sur la song entiere
        bl_flagsong!=NOT bl_flagsong!
        GOSUB affiche_icones_toolsb
        GOSUB wait_mouse(TRUE)      ! Flip-flop alors on attend un relÉchement
        ' --------------------------------------------------------------------
      DEFAULT
        GOSUB affiche_icone_b(srt%,1,0,0,1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0
          GOSUB block_start
          GOSUB affiche_c_pattern
          ' ------------------------------------------------------------------
        CASE 1
          GOSUB bee(TRUE)
          GOSUB paste_block
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          SELECT trackpat%
          CASE 0
            GOSUB aff_message("Track pasted.")
          CASE 1
            GOSUB aff_message("Pattern pasted.")
          CASE 2
            GOSUB aff_message("Preset pasted.")
          ENDSELECT
          ' ------------------------------------------------------------------
        CASE 2
          GOSUB bee(TRUE)
          GOSUB clear_block
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          SELECT trackpat%
          CASE 0
            GOSUB aff_message("Track cleared.")
          CASE 1
            GOSUB aff_message("Pattern cleared.")
          CASE 2
            GOSUB aff_message("Preset cleared.")
          ENDSELECT
          ' ------------------------------------------------------------------
        CASE 3
          GOSUB bee(TRUE)
          IF km%=2
            FOR i%=0 TO 11
              GOSUB note_up_general             ! Octave Up
            NEXT i%
          ELSE
            GOSUB note_up_general
          ENDIF
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          ' ------------------------------------------------------------------
        CASE 4
          GOSUB block_end
          GOSUB affiche_c_pattern
          ' ------------------------------------------------------------------
        CASE 5
          GOSUB bee(TRUE)
          GOSUB insert_block
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          SELECT trackpat%
          CASE 0
            GOSUB aff_message("Track inserted.")
          CASE 1
            GOSUB aff_message("Pattern inserted.")
          CASE 2
            GOSUB aff_message("Preset inserted.")
          ENDSELECT
          ' ------------------------------------------------------------------
        CASE 6
          GOSUB bee(TRUE)
          GOSUB delete_block
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          SELECT trackpat%
          CASE 0
            GOSUB aff_message("Track deleted.")
          CASE 1
            GOSUB aff_message("Pattern deleted.")
          CASE 2
            GOSUB aff_message("Preset deleted.")
          ENDSELECT
          ' ------------------------------------------------------------------
        CASE 7
          GOSUB bee(TRUE)
          IF km%=2
            FOR i%=0 TO 11
              GOSUB note_down_general
            NEXT i%
          ELSE
            GOSUB note_down_general
          ENDIF
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          ' ------------------------------------------------------------------
        CASE 8
          GOSUB bee(TRUE)
          GOSUB swap_block
          GOSUB bee(FALSE)
          GOSUB affiche_c_pattern
          GOSUB aff_message("Track swapped.")
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,1,0,0,0)
      ENDSELECT
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_tools2
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB cadre_int(20,35,19,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,11,11,0,0)
  GOSUB affchaine_trans("ECHO",42,37,14)
  GOSUB cadre_ext(ADD(divbi&(0,3,11),6),ADD(divbi&(1,3,11),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,7,11),10),ADD(divbi&(1,7,11),2),2,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,9,11),10),ADD(divbi&(1,9,11),2),2,5,0,13,12,14)
  GOSUB affiche_icones_toolsb2
RETURN
PROCEDURE affiche_icones_toolsb2
  GOSUB affiche_icone_b(2,11,0,0,bl_echo_cont!)
  GOSUB affiche_icone_b(6,11,0,0,bl_echo_fdbk!)
  GOSUB affiche_icone_b(8,11,0,0,NOT bl_echo_fdbk!)
  GOSUB affchaine_notrans(HEX$(bl_echo_lines%,2),ADD(divbi&(0,3,11),6),ADD(divbi&(1,3,11),2),1)
  GOSUB affchaine_notrans(STR$(bl_echo_feedback%,3),ADD(divbi&(0,7,11),10),ADD(divbi&(1,7,11),2),1)
  GOSUB affchaine_notrans("-"+HEX$(bl_echo_fadestep%,2),ADD(divbi&(0,9,11),10),ADD(divbi&(1,9,11),2),1)
RETURN
PROCEDURE gere_icones_tools2
  ' Les autres var. locales sont dans le tools1
  LOCAL flag_relachement!
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:11,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 2
      bl_echo_cont!=NOT bl_echo_cont!
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    CASE 3              ! Lines
      GOSUB edite_chaine(HEX$(bl_echo_lines%,2),ADD(divbi&(0,3,11),6),ADD(divbi&(1,3,11),2),2,1)
      bl_echo_lines%=MIN(MAX(VAL("$"+bbbb$),1),&HFF)
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    CASE 4,5            ! Lines +/-
      bl_echo_lines%=MIN(MAX(ADD(bl_echo_lines%,SUB(9,SHL(srt%,1))),1),&HFF)
      PAUSE SUB(6,SHL(km%,1))
      GOSUB affiche_icones_toolsb2
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 6              ! Flag feedback
      bl_echo_fdbk!=TRUE
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    CASE 8              ! Flag fade
      bl_echo_fdbk!=FALSE
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    CASE 7              ! Feedback
      GOSUB edite_chaine(STR$(bl_echo_feedback%,3),ADD(divbi&(0,7,11),10),ADD(divbi&(1,7,11),2),3,2)
      bl_echo_feedback%=MIN(MAX(VAL(bbbb$),1),100)
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    CASE 9              ! Fade
      GOSUB edite_chaine(HEX$(bl_echo_fadestep%,2),ADD(divbi&(0,9,11),11),ADD(divbi&(1,9,11),2),2,1)
      bl_echo_fadestep%=MIN(MAX(VAL("$"+bbbb$),0),&HFF)
      GOSUB affiche_icones_toolsb2
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,11,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 0            ! .../...
        ss_menut%=3
        ' --------------------------------------------------------------------
      CASE 1            ! Echo
        GOSUB echo_block
        GOSUB affiche_c_pattern
        ' --------------------------------------------------------------------
      CASE 10           ! Volume slide
        GOSUB volume_slide(song&(songpos%),posligne%,preset&(curs_col%,n_preset%))
        GOSUB affiche_c_pattern
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone_b(srt%,11,0,0,0)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
    IF ss_menut%=3
      GOSUB affiche_icones_tools3
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_tools3
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,6,18,0,0)
  GOSUB cadre_ext(divbi&(0,6,18),divbi&(1,6,18),21,59,0,13,12,14)
  GOSUB affchaine_trans("SONG",88,87,14)
  GOSUB affiche_icones_toolsb3
RETURN
PROCEDURE affiche_icones_toolsb3
  ' Var. locales de toolsb1
  song_list_pos%=MAX(MIN(song_list_pos%,SUB(FN song_length,10)),0)
  b%=song_list_pos%
  FOR a%=0 TO 9
    IF b%=songpos%
      c%=2
    ELSE
      c%=1
    ENDIF
    d%=32
    IF b%=FN song_repeat
      d%=253
    ENDIF
    IF b%<FN song_length
      GOSUB affchaine_notrans(HEX$(b%,2)+CHR$(d%)+HEX$(song&(b%),2)+" "+FN patternname$(song&(b%)),divbi&(0,ADD(a%,6),18),divbi&(1,ADD(a%,6),18),c%)
    ELSE
      GOSUB affchaine_notrans(SPACE$(22),divbi&(0,ADD(a%,6),18),divbi&(1,ADD(a%,6),18),1)
    ENDIF
    INC b%
  NEXT a%
RETURN
PROCEDURE gere_icones_tools3
  ' Les autres var. locales sont dans tools1
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:18,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 0              ! .../...
      ' /sjx - there was a cosmetic bug here -- sorted
      GOSUB affiche_icone_b(srt%,18,0,0,-1)
      GOSUB wait_mouse(TRUE)
      ss_menut%=1
      GOSUB affiche_icones_tools
      ' ----------------------------------------------------------------------
    CASE 1              ! Up
      song_list_pos%=MAX(SUB(song_list_pos%,SUB(km%,MUL(km%=3,7))),0)       ! Pas de -1, -2 et -10
      GOSUB affiche_icones_toolsb3
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 2              ! Down
      song_list_pos%=MAX(MIN(ADD(song_list_pos%,SUB(km%,MUL(km%=3,7))),SUB(FN song_length,10)),0)       ! Pas de 1, 2 et 10
      GOSUB affiche_icones_toolsb3
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 6 TO 15        ! Choix d'une position sur la liste
      IF km%=1                  ! Bouton gauche : changement de position
        songpos%=-1
        d%=MIN(ADD(song_list_pos%,SUB(srt%,5)),FN song_length)  ! songpos+1
        km%=1
        GOSUB chg_songpos
      ELSE                      ! Bonton droit : edition du nom du pattern
        a%=song&(MIN(ADD(song_list_pos%,SUB(srt%,6)),PRED(FN song_length)))
        GOSUB edite_chaine(FN patternname$(a%),ADD(divbi&(0,srt%,18),6),divbi&(1,srt%,18),16,0)
        GOSUB chg_patternname(bbbb$,a%)
        GOSUB affiche_icones_toolsb3
      ENDIF
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,18,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 3            ! Top
        song_list_pos%=0
        GOSUB affiche_icones_toolsb3
        ' --------------------------------------------------------------------
      CASE 4            ! Insert pos
        IF FN song_length<256
          GOSUB stop_voices
          IF songpos%<PRED(FN song_length)
            FOR i%=PRED(FN song_length) DOWNTO songpos%
              song&(SUCC(i%))=song&(i%)
            NEXT i%
          ENDIF
          INC module&(101)
          IF FN song_repeat>songpos%
            INC module&(102)
          ENDIF
          INC songpos%
          IF km%=2              ! Clic droit  : Nouveau pattern inutilise
            a%=0
            i%=0
            REPEAT
              IF a%=song&(i%)
                INC a%
                i%=-1
              ENDIF
              INC i%
            UNTIL i%=>FN song_length
            song&(songpos%)=a%
          ENDIF
          GOSUB affiche_info_song
          GOSUB affiche_c_pattern
        ENDIF
        ' --------------------------------------------------------------------
      CASE 5            ! Delete pos
        IF songpos%<PRED(FN song_length)
          FOR i%=SUCC(songpos%) TO PRED(FN song_length)
            song&(PRED(i%))=song&(i%)
          NEXT i%
          DEC module&(101)
          song&(FN song_length)=0
          IF FN song_repeat>songpos%
            DEC module&(102)
          ENDIF
          GOSUB affiche_info_song
          GOSUB affiche_c_pattern
        ENDIF
      ENDSELECT
      GOSUB affiche_icone_b(srt%,18,0,0,0)
      ' --------------------------------------------------------------------
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Instrument
PROCEDURE affiche_icones_instr
  LOCAL i%
  IF ss_menui%=2
    GOSUB affiche_icones_instr2
  ELSE
    GOSUB cadre_int(20,35,59,69,13,13,14,12)
    GOSUB affiche_bloc_icones_b(16,25,12,0,0)
    GOSUB affchaine_trans("ENVELOPES",130,42,14)
    GOSUB affchaine_trans("SAMPLE",41,92,14)
    GOSUB affchaine_trans("TRANSPOSE",69,92,14)
    GOSUB cadre_ext(divbi&(0,0,12),divbi&(1,0,12),1,47,0,13,12,14)
    GOSUB cadre_ext(divbi&(0,1,12),divbi&(1,1,12),11,47,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,1,12),13),divbi&(1,1,12),2,47,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,1,12),17),divbi&(1,1,12),2,47,0,13,12,14)
    FOR i%=18 TO 24 STEP 3
      GOSUB cadre_ext(ADD(divbi&(0,i%,12),7),ADD(divbi&(1,i%,12),2),2,5,0,13,12,14)
      GOSUB cadre_ext(ADD(divbi&(0,ADD(i%,9),12),7),ADD(divbi&(1,ADD(i%,9),12),2),1,5,0,13,12,14)
    NEXT i%
    GOSUB affiche_icones_instrb
  ENDIF
RETURN
PROCEDURE affiche_icones_instrb
  LOCAL a%,c%,i%,d%,a$
  IF ss_menui%=2
    GOSUB affiche_icones_instrb2
  ELSE
    instr_note_pos%=MAX(MIN(instr_note_pos%,127),24)
    instr_note_aff%=MAX(MIN(instr_note_aff%,instr_note_pos%),SUB(instr_note_pos%,7))
    GOSUB affiche_icone_b(41,12,0,0,instr_group!)
    FOR i%=0 TO 7
      d%=ADD(i%,instr_note_aff%)
      IF d%>127
        GOSUB affchaine_notrans("  ",divbi&(0,SHL(i%,1),12),divbi&(1,SHL(i%,1),12),c%)
        GOSUB affchaine_notrans(SPACE$(12),divbi&(0,SUCC(SHL(i%,1)),12),divbi&(1,SUCC(SHL(i%,1)),12),c%)
        GOSUB affchaine_notrans("   ",ADD(divbi&(0,SUCC(SHL(i%,1)),12),13),divbi&(1,SUCC(SHL(i%,1)),12),c%)
        GOSUB affchaine_notrans("   ",ADD(divbi&(0,SUCC(SHL(i%,1)),12),17),divbi&(1,SUCC(SHL(i%,1)),12),c%)
      ELSE
        IF d%=instr_note_pos%
          c%=2
        ELSE
          c%=1
        ENDIF
        a%=FN isample(instr%,d%)
        GOSUB affchaine_notrans(HEX$(a%,2),divbi&(0,SHL(i%,1),12),divbi&(1,SHL(i%,1),12),c%)
        GOSUB affchaine_notrans(LEFT$(FN samplename$(a%),12),divbi&(0,SUCC(SHL(i%,1)),12),divbi&(1,SUCC(SHL(i%,1)),12),c%)
        a%=FN itransp(instr%,d%)
        IF a%<0
          a$="-"
        ELSE
          a$="+"
        ENDIF
        a$=a$+STR$(ABS(a%),2)
        GOSUB affchaine_notrans(a$,ADD(divbi&(0,SUCC(SHL(i%,1)),12),13),divbi&(1,SUCC(SHL(i%,1)),12),c%)
        a$=MID$(gamme$,SUCC(SHL(d% MOD 12,1)),2)+STR$(SUB(DIV(d%,12),2),1)
        GOSUB affchaine_notrans(a$,ADD(divbi&(0,SUCC(SHL(i%,1)),12),17),divbi&(1,SUCC(SHL(i%,1)),12),c%)
      ENDIF
    NEXT i%
    '
    a%=MAX(FN ins_deb_zone(instr%,instr_note_pos%),24)
    a$=MID$(gamme$,SUCC(SHL(a% MOD 12,1)),2)+STR$(SUB(DIV(a%,12),2),1)
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,18,12),7),ADD(divbi&(1,18,12),2),1)
    a%=FN ins_fin_zone(instr%,instr_note_pos%)
    a$=MID$(gamme$,SUCC(SHL(a% MOD 12,1)),2)+STR$(SUB(DIV(a%,12),2),1)
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,21,12),7),ADD(divbi&(1,21,12),2),1)
    '
    GOSUB affchaine_notrans(HEX$(FN ivolume(instr%),3),ADD(divbi&(0,24,12),7),ADD(divbi&(1,24,12),2),1)
    IF FN ievol(instr%)>0
      GOSUB affchaine_notrans(HEX$(FN ievol(instr%),2),ADD(divbi&(0,27,12),7),ADD(divbi&(1,27,12),2),1)
    ELSE
      GOSUB affchaine_notrans(STRING$(2,5),ADD(divbi&(0,27,12),7),ADD(divbi&(1,27,12),2),1)
    ENDIF
    IF FN ieton(instr%)>0
      GOSUB affchaine_notrans(HEX$(FN ieton(instr%),2),ADD(divbi&(0,30,12),7),ADD(divbi&(1,30,12),2),1)
    ELSE
      GOSUB affchaine_notrans(STRING$(2,5),ADD(divbi&(0,30,12),7),ADD(divbi&(1,30,12),2),1)
    ENDIF
    IF FN iepan(instr%)>0
      GOSUB affchaine_notrans(HEX$(FN iepan(instr%),2),ADD(divbi&(0,33,12),7),ADD(divbi&(1,33,12),2),1)
    ELSE
      GOSUB affchaine_notrans(STRING$(2,5),ADD(divbi&(0,33,12),7),ADD(divbi&(1,33,12),2),1)
    ENDIF
  ENDIF
RETURN
PROCEDURE gere_icones_instr             !!!
  LOCAL a%,b%,c%,d%,i%,srt%
  LOCAL a$,b$
  LOCAL flag_relachement!
  IF ss_menui%=2
    GOSUB gere_icones_instr2
  ELSE
    flag_relachement!=TRUE
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:12,W:xm%,W:ym%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 0 TO 15      ! Numero de sample
        instr_note_pos%=MIN(ADD(instr_note_aff%,SHR(srt%,1)),127)
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 16,17        ! Haut/Bas
        a%=MUL(SUB(1,SHL(SUB(srt%,16),1)),SHL(1,PRED(km%)))
        instr_note_pos%=MAX(MIN(SUB(instr_note_pos%,a%),127),24)
        instr_note_aff%=MAX(MIN(instr_note_aff%,instr_note_pos%),SUB(instr_note_pos%,7))
        GOSUB affiche_icones_instrb
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 18           ! From note
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 19           ! +
        a%=FN ins_deb_zone(instr%,instr_note_pos%)
        IF a%>1 AND a%<instr_note_pos%
          b%=MIN(ADD(PRED(a%),SHL(1,PRED(km%))),PRED(instr_note_pos%))
          c%=FN isample(instr%,PRED(a%))
          d%=FN itransp(instr%,PRED(a%))
          FOR i%=a% TO b%
            GOSUB chg_ins_sample(instr%,i%,c%)
            GOSUB chg_ins_transp(instr%,i%,d%)
          NEXT i%
        ENDIF
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 20           ! -
        a%=FN ins_deb_zone(instr%,instr_note_pos%)
        IF a%>1
          b%=MAX(SUB(a%,SHL(1,PRED(km%))),1)
          c%=FN isample(instr%,instr_note_pos%)
          d%=FN itransp(instr%,instr_note_pos%)
          FOR i%=b% TO PRED(a%)
            GOSUB chg_ins_sample(instr%,i%,c%)
            GOSUB chg_ins_transp(instr%,i%,d%)
          NEXT i%
        ENDIF
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 21           ! To note
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 22           ! +
        a%=FN ins_fin_zone(instr%,instr_note_pos%)
        IF a%<127
          b%=MIN(ADD(a%,SHL(1,PRED(km%))),127)
          c%=FN isample(instr%,instr_note_pos%)
          d%=FN itransp(instr%,instr_note_pos%)
          FOR i%=SUCC(a%) TO b%
            GOSUB chg_ins_sample(instr%,i%,c%)
            GOSUB chg_ins_transp(instr%,i%,d%)
          NEXT i%
        ENDIF
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 23           ! -
        a%=FN ins_fin_zone(instr%,instr_note_pos%)
        IF a%<127 AND a%>instr_note_pos%
          b%=MAX(SUB(SUCC(a%),SHL(1,PRED(km%))),SUCC(instr_note_pos%))
          c%=FN isample(instr%,SUCC(a%))
          d%=FN itransp(instr%,SUCC(a%))
          FOR i%=b% TO a%
            GOSUB chg_ins_sample(instr%,i%,c%)
            GOSUB chg_ins_transp(instr%,i%,d%)
          NEXT i%
        ENDIF
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 24           ! Volume
        GOSUB edite_chaine(HEX$(FN ivolume(instr%),3),ADD(divbi&(0,24,12),7),ADD(divbi&(1,24,12),2),3,1)
        GOSUB chg_ins_volume(instr%,MIN(MAX(VAL("$"+bbbb$),0),256))
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      CASE 25,26        ! +/-
        a%=MUL(SUB(1,SHL(SUB(srt%,25),1)),SHL(1,PRED(km%)))
        GOSUB chg_ins_volume(instr%,MAX(MIN(ADD(FN ivolume(instr%),a%),256),0))
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 27           ! Enveloppe de volume
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 28,29        ! +/-
        a%=MUL(SUB(1,SHL(SUB(srt%,28),1)),SHL(1,PRED(km%)))
        GOSUB chg_ins_evol(instr%,MAX(MIN(ADD(FN ievol(instr%),a%),63),0))
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 30           ! Enveloppe de tonalite
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 31,32        ! +/-
        a%=MUL(SUB(1,SHL(SUB(srt%,31),1)),SHL(1,PRED(km%)))
        GOSUB chg_ins_eton(instr%,MAX(MIN(ADD(FN ieton(instr%),a%),63),0))
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 33           ! Enveloppe de panning
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 34,35        ! +/-
        a%=MUL(SUB(1,SHL(SUB(srt%,34),1)),SHL(1,PRED(km%)))
        GOSUB chg_ins_epan(instr%,MAX(MIN(ADD(FN iepan(instr%),a%),63),0))
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 36,37        ! +/- Sample
        a%=MUL(SUB(1,SHL(SUB(srt%,36),1)),SHL(1,PRED(km%)))
        a%=MAX(MIN(ADD(FN isample(instr%,instr_note_pos%),a%),255),1)
        IF instr_group!
          b%=FN ins_deb_zone(instr%,instr_note_pos%)
          c%=FN ins_fin_zone(instr%,instr_note_pos%)
        ELSE
          b%=instr_note_pos%
          c%=instr_note_pos%
        ENDIF
        FOR i%=b% TO c%
          GOSUB chg_ins_sample(instr%,i%,a%)
        NEXT i%
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 38,39        ! +/- Transpose
        a%=MUL(SUB(1,SHL(SUB(srt%,38),1)),SHL(1,PRED(km%)))
        b%=MAX(MIN(ADD(FN itransp(instr%,instr_note_pos%),a%),96),-96)
        IF instr_group!
          a%=FN ins_deb_zone(instr%,instr_note_pos%)
          c%=FN ins_fin_zone(instr%,instr_note_pos%)
        ELSE
          a%=instr_note_pos%
          c%=instr_note_pos%
        ENDIF
        FOR i%=a% TO c%
          GOSUB chg_ins_transp(instr%,i%,b%)
        NEXT i%
        GOSUB affiche_icones_instrb
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 40           ! Liste des instruments
        GOSUB affiche_icone_b(srt%,12,0,0,-1)
        GOSUB wait_mouse(TRUE)
        ss_menui%=2
        GOSUB affiche_icones_instr
        ' --------------------------------------------------------------------
      CASE 41           ! Group
        instr_group!=NOT instr_group!
        GOSUB affiche_icones_instrb
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,12,0,0,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
        ENDSELECT
        GOSUB affiche_icone_b(srt%,12,0,0,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_instr2
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,7,13,0,0)
  GOSUB cadre_ext(divbi&(0,7,13),divbi&(1,7,13),30,59,0,13,12,14)
  GOSUB affchaine_trans("INSTRUMENT LIST",106,87,14)
  GOSUB affiche_icones_instrb2
RETURN
PROCEDURE affiche_icones_instrb2
  ' Var. locales de instrb1
  instr_list_pos%=MAX(MIN(instr_list_pos%,246),1)
  FOR a%=0 TO 9
    IF ADD(a%,instr_list_pos%)=instr%
      GOSUB affchaine_notrans(HEX$(ADD(a%,instr_list_pos%),2)+" "+FN instrname$(ADD(a%,instr_list_pos%)),divbi&(0,ADD(a%,7),13),divbi&(1,ADD(a%,7),13),2)
    ELSE
      GOSUB affchaine_notrans(HEX$(ADD(a%,instr_list_pos%),2)+" "+FN instrname$(ADD(a%,instr_list_pos%)),divbi&(0,ADD(a%,7),13),divbi&(1,ADD(a%,7),13),1)
    ENDIF
  NEXT a%
RETURN
PROCEDURE gere_icones_instr2            !!!
  ' Les autres var. locales sont dans instr1
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:13,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 0              ! Page 1
      GOSUB affiche_icone_b(srt%,13,0,0,-1)
      GOSUB wait_mouse(TRUE)
      ss_menui%=1
      GOSUB affiche_icones_instr
      ' ----------------------------------------------------------------------
    CASE 1              ! Up
      instr_list_pos%=MAX(SUB(instr_list_pos%,SUB(km%,MUL(km%=3,7))),1)         ! Pas de -1, -2 et -10
      GOSUB affiche_icones_instrb2
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 2              ! Down
      instr_list_pos%=MIN(ADD(instr_list_pos%,SUB(km%,MUL(km%=3,7))),246)       ! Pas de 1, 2 et 10
      GOSUB affiche_icones_instrb2
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 7 TO 16        ! Choix d'un sample sur la liste
      instr%=ADD(instr_list_pos%,SUB(srt%,7))
      GOSUB affiche_info_sample
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,13,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 3            ! Top
        instr_list_pos%=1
        GOSUB affiche_icones_instrb2
        ' --------------------------------------------------------------------
      CASE 4            ! Load instrument
        GOSUB stop_voices
        GOSUB load_instrument
        ' --------------------------------------------------------------------
      CASE 5            ! Load and replace samples
        GOSUB stop_voices
        b$=""
        FOR i%=1 TO 127                         ! Cherche tous les samples contenus dans l'instrument
          a%=FN isample(instr%,i%)
          IF a%<>0
            IF INSTR(b$,CHR$(a%))=0
              b$=b$+CHR$(a%)
            ENDIF
          ENDIF
        NEXT i%
        '
        '
        '
        '
        ' GOSUB chg_taille_sample(sample%,0)
        ' a$="SAMP"+MKL$(64)+MKI$(sample%)+SPACE$(28)+MKI$(0)+MKI$(&HFFFF)+MKI$(8)+MKI$(8363)+MKL$(0)+MKL$(0)+MKL$(2)+MKI$(0)+MKI$(0)+MKI$(0)
        ' BMOVE V:a$,FN adrsamchk(sample%),64
        '
        '
        '
        '
        ' --------------------------------------------------------------------
      CASE 6            ! Save instrument
        GOSUB save_instrument
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone_b(srt%,13,0,0,0)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Sample
PROCEDURE affiche_icones_sample
  LOCAL i%
  IF ss_menus%=2
    GOSUB affiche_icones_sample2
  ELSE
    GOSUB cadre_int(20,35,59,69,13,13,14,12)
    GOSUB affiche_bloc_icones_b(0,33,14,0,0)
    GOSUB cadre_ext(ADD(divbi&(0,0,14),11),ADD(divbi&(1,0,14),2),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,3,14),5),ADD(divbi&(1,3,14),2),27,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,4,14),7),ADD(divbi&(1,4,14),2),5,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,7,14),7),ADD(divbi&(1,7,14),2),5,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,10,14),7),ADD(divbi&(1,10,14),2),5,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,13,14),8),ADD(divbi&(1,13,14),2),2,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,16,14),9),ADD(divbi&(1,16,14),2),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,19,14),8),ADD(divbi&(1,19,14),2),2,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,22,14),10),ADD(divbi&(1,22,14),2),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,25,14),13),ADD(divbi&(1,25,14),2),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,32,14),12),ADD(divbi&(1,32,14),2),4,5,0,13,12,14)
    GOSUB affiche_icones_sampleb
    GOSUB affiche_icones_samplec
  ENDIF
RETURN
PROCEDURE affiche_icones_sampleb
  LOCAL a%,b%,c%,a$
  IF ss_menus%=2
    GOSUB affiche_icones_sampleb2
  ELSE
    GOSUB affchaine_notrans(HEX$(sample%,2),ADD(divbi&(0,0,14),11),ADD(divbi&(1,0,14),2),1)
    GOSUB affchaine_notrans(FN samplename$(sample%),ADD(divbi&(0,3,14),5),ADD(divbi&(1,3,14),2),1)
    GOSUB affchaine_notrans(HEX$(FN length(sample%),6),ADD(divbi&(0,4,14),7),ADD(divbi&(1,4,14),2),1)
    GOSUB affchaine_notrans(HEX$(FN repeat(sample%),6),ADD(divbi&(0,7,14),7),ADD(divbi&(1,7,14),2),1)
    GOSUB affchaine_notrans(HEX$(FN replen(sample%),6),ADD(divbi&(0,10,14),7),ADD(divbi&(1,10,14),2),1)
    GOSUB affchaine_notrans(HEX$(FN volume(sample%),3),ADD(divbi&(0,13,14),8),ADD(divbi&(1,13,14),2),1)
    GOSUB affchaine_notrans(STR$(FN freqech(sample%),5),ADD(divbi&(0,22,14),10),ADD(divbi&(1,22,14),2),1)
    GOSUB affchaine_notrans(STR$(SHL(FN resol(sample%),3),2),ADD(divbi&(0,25,14),13),ADD(divbi&(1,25,14),2),1)
    a%=FN finetune(sample%)
    IF a%<0
      a$="-"+HEX$(ABS(a%),1)
    ELSE
      a$="+"+HEX$(a%,1)
    ENDIF
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,16,14),9),ADD(divbi&(1,16,14),2),1)
    IF FN autobal(sample%)>&HFFF
      a$="???"
    ELSE
      a$=HEX$(FN autobal(sample%),3)
    ENDIF
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,19,14),8),ADD(divbi&(1,19,14),2),1)
  ENDIF
RETURN
PROCEDURE affiche_icones_samplec
  LOCAL a$
  a$=SPACE$(SUB(5,LEN(next_sample$)))+next_sample$
  GOSUB affchaine_notrans(a$,ADD(divbi&(0,32,14),12),ADD(divbi&(1,32,14),2),1)
  GOSUB affiche_icone_b(33,14,0,0,signe_sam%=0)
RETURN
PROCEDURE gere_icones_sample
  LOCAL a%,b%,c%,d%,srt%
  LOCAL a$
  LOCAL flag_relachement!
  IF ss_menus%=2
    GOSUB gere_icones_sample2
  ELSE
    flag_relachement!=TRUE
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:14,W:xm%,W:ym%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 0                      ! Sample
        d%=0
        GOSUB chg_s_sample
        ' --------------------------------------------------------------------
      CASE 1                      ! Sample +
        d%=1
        GOSUB chg_s_sample
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 2                      ! Sample -
        d%=-1
        GOSUB chg_s_sample
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 3                      ! Samplename
        GOSUB edite_chaine(FN samplename$(sample%),ADD(divbi&(0,3,14),5),ADD(divbi&(1,3,14),2),28,0)
        GOSUB chg_samplename(bbbb$,sample%)
        GOSUB affiche_icones_sampleb
        ' --------------------------------------------------------------------
      CASE 4,7,10,13,16,19,22     ! Edition des chiffres
        d%=0
        ON DIV(PRED(srt%),3) GOSUB chg_s_length,chg_s_reppos,chg_s_replen,chg_s_volume,chg_s_finetune,chg_s_balance,chg_s_freqech
        ' --------------------------------------------------------------------
      CASE 5,8,11,14,17,20,23     ! +
        d%=1
        ON DIV(SUB(srt%,2),3) GOSUB chg_s_length,chg_s_reppos,chg_s_replen,chg_s_volume,chg_s_finetune,chg_s_balance,chg_s_freqech
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 6,9,12,15,18,21,24     ! -
        d%=-1
        ON DIV(SUB(srt%,3),3) GOSUB chg_s_length,chg_s_reppos,chg_s_replen,chg_s_volume,chg_s_finetune,chg_s_balance,chg_s_freqech
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 29                     ! List
        GOSUB affiche_icone_b(srt%,14,0,0,-1)
        GOSUB wait_mouse(TRUE)
        ss_menus%=2
        GOSUB affiche_icones_sample
        ' --------------------------------------------------------------------
      CASE 32
        a$="AVRSPLWAVVOC  *  "
        a%=INSTR(a$,RIGHT$(next_sample$,SUB(LEN(next_sample$),INSTR(next_sample$,"."))))
        IF a%>0
          a%=DIV(PRED(a%),3)
        ELSE
          a%=-1
        ENDIF
        a%=FN popup(1,a%,MOUSEX,MOUSEY)
        IF a%>=0
          a%=a% AND &HFFFF
          next_sample$="*."+TRIM$(MID$(a$,SUCC(MUL(a%,3)),3))
        ENDIF
        GOSUB affiche_icones_samplec
        ' --------------------------------------------------------------------
      CASE 33                     ! Signed
        signe_sam%=SUB(128,signe_sam%)
        GOSUB affiche_icones_samplec
        ' --------------------------------------------------------------------
      CASE 35 TO 39
        ' Rien
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,14,0,0,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 25,26,27             ! Nbr de bits
          IF FN resol(sample%)=1      ! 8 -> 16 bits
            GOSUB dialog("CONVERT TO 16 BITS","DO YOU REALLY WANT|TO CONVERT SAMPLE #"+HEX$(sample%,2)+"|TO 16 BITS ?","YES|NO",xm%,ym%)
            IF bouton%=0
              GOSUB stop_voices
              GOSUB aff_message("Converting...")
              GOSUB bee(TRUE)
              a%=FN adresse(sample%)
              b%=FN length(sample%)
              IF b%>0
                GOSUB chg_taille_sample(sample%,SHL(b%,1))
                ~C:g_copy_sample_8_2_16%(L:a%,L:a%,L:b%)
                GOSUB chg_sam_length(sample%,SHL(b%,1))
                IF ADD(FN repeat(sample%),FN replen(sample%))>2
                  GOSUB chg_sam_repeat(sample%,SHL(FN repeat(sample%),1))
                  GOSUB chg_sam_replen(sample%,SHL(FN replen(sample%),1))
                ENDIF
              ENDIF
              GOSUB chg_sam_nbits(sample%,2)
              ~C:rr_boucle_sample%(W:sample%)
              GOSUB aff_message("Sample # "+HEX$(sample%,2)+" converted to 16 bits.")
            ENDIF
          ELSE                        ! 16 -> 8 bits
            GOSUB dialog("CONVERT TO 8 BITS","DO YOU REALLY WANT|TO CONVERT SAMPLE #"+HEX$(sample%,2)+"|TO 8 BITS ?","YES|NO",xm%,ym%)
            IF bouton%=0
              GOSUB stop_voices
              GOSUB aff_message("Converting...")
              GOSUB bee(TRUE)
              a%=FN adresse(sample%)
              IF FN length(sample%)>0
                b%=FN length(sample%) AND -4
                ~C:g_copy_sample_16_2_8%(L:a%,L:a%,L:b%)
                GOSUB chg_taille_sample(sample%,b%)
                GOSUB chg_sam_length(sample%,SHR(b%,1) AND -2)
                IF ADD(FN repeat(sample%),FN replen(sample%))>2
                  GOSUB chg_sam_repeat(sample%,SHR(FN repeat(sample%),1) AND -2)
                  GOSUB chg_sam_replen(sample%,SHR(FN replen(sample%),1) AND -2)
                ENDIF
              ENDIF
              GOSUB chg_sam_nbits(sample%,1)
              ~C:rr_boucle_sample%(W:sample%)
              GOSUB aff_message("Sample # "+HEX$(sample%,2)+" converted to 8 bits.")
            ENDIF
          ENDIF
          GOSUB bee(FALSE)
          GOSUB affiche_icones_samplec
          ' ------------------------------------------------------------------
        CASE 28                   ! Kill sample
          GOSUB dialog("KILL SAMPLE","DO YOU REALLY WANT|TO KILL SAMPLE #"+HEX$(sample%,2)+" ?","YES|NO",xm%,ym%)
          IF bouton%=0
            GOSUB bee(TRUE)
            GOSUB kill_sample(sample%)
            GOSUB bee(FALSE)
            GOSUB affiche_info_sample
            GOSUB aff_message("SAMPLE #"+HEX$(sample%,2)+" KILLED BY DEATH...")
            GOSUB affiche_icones_samplec
          ENDIF
          ' ------------------------------------------------------------------
        CASE 30                   ! Load sample
          GOSUB load_sample(FALSE)
          ' ------------------------------------------------------------------
        CASE 31                   ! Save sample
          GOSUB save_sample(FALSE)
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,14,0,0,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_sample2
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,5,15,0,0)
  GOSUB cadre_ext(divbi&(0,5,15),divbi&(1,5,15),30,59,0,13,12,14)
  GOSUB affchaine_trans("SAMPLE LIST",106,87,14)
  GOSUB affiche_icones_sampleb2
RETURN
PROCEDURE affiche_icones_sampleb2
  ' Var. locales de sampleb1
  sample_list_pos%=MAX(MIN(sample_list_pos%,246),1)
  b%=sample_list_pos%
  FOR a%=0 TO 9
    IF b%=sample%
      c%=2
    ELSE
      c%=1
    ENDIF
    IF FN length(b%)>0
      GOSUB affchaine_notrans(HEX$(b%,2)+CHR$(9)+FN samplename$(b%),divbi&(0,ADD(a%,5),15),divbi&(1,ADD(a%,5),15),c%)
    ELSE
      GOSUB affchaine_notrans(HEX$(b%,2)+" "+FN samplename$(b%),divbi&(0,ADD(a%,5),15),divbi&(1,ADD(a%,5),15),c%)
    ENDIF
    INC b%
  NEXT a%
RETURN
PROCEDURE gere_icones_sample2
  ' Les autres var. locales sont dans sample1
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:15,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 0              ! Page 1
      GOSUB affiche_icone_b(srt%,15,0,0,-1)
      GOSUB wait_mouse(TRUE)
      ss_menus%=1
      GOSUB affiche_icones_sample
      ' ----------------------------------------------------------------------
    CASE 1              ! Up
      sample_list_pos%=MAX(SUB(sample_list_pos%,SUB(km%,MUL(km%=3,7))),1)       ! Pas de -1, -2 et -10
      GOSUB affiche_icones_sampleb2
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 2              ! Down
      sample_list_pos%=MIN(ADD(sample_list_pos%,SUB(km%,MUL(km%=3,7))),246)     ! Pas de 1, 2 et 10
      GOSUB affiche_icones_sampleb2
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 5 TO 14        ! Choix d'un sample sur la liste
      sample%=ADD(sample_list_pos%,SUB(srt%,5))
      GOSUB affiche_info_sample
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,15,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 3            ! Top
        sample_list_pos%=1
        GOSUB affiche_icones_sampleb2
        ' --------------------------------------------------------------------
      CASE 4            ! Instrument
        IF km%=2 AND instr%<255
          a%=SUCC(instr%)
          GOSUB aff_message("Waiting : searching sample "+HEX$(sample%,2)+" from instrument "+HEX$(a%,2)+"...")
        ELSE
          a%=1
          GOSUB aff_message("Waiting : searching sample "+HEX$(sample%,2)+" from the first instrument...")
        ENDIF
        GOSUB bee(TRUE)
        b%=FN ins_cherche_sample(sample%,a%)
        GOSUB bee(FALSE)
        IF b%>0
          instr%=b%
          GOSUB aff_message("Sample "+HEX$(sample%,2)+" found in instrument "+HEX$(instr%,2)+".")
        ELSE
          GOSUB aff_message("Sample "+HEX$(sample%,2)+" not found.")
        ENDIF
        GOSUB affiche_info_sample
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone_b(srt%,15,0,0,0)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Envelopes
PROCEDURE affiche_icones_enveloppe
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(30,19,17,0,0)
  GOSUB cadre_ext(divbi&(0,0,17),divbi&(1,0,17),3,59,0,13,12,14)
  GOSUB cadre_ext(divbi&(0,10,17),divbi&(1,10,17),15,59,0,13,12,14)
  GOSUB cadre_ext(divbi&(0,20,17),divbi&(1,20,17),10,59,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,39,17),9),ADD(divbi&(1,39,17),2),1,5,0,13,12,14)
  GOSUB cadre_ext(SUCC(divbi&(0,43,17)),ADD(divbi&(1,43,17),2),19,5,0,13,12,14)
  GOSUB cadre_ext(SUCC(divbi&(0,46,17)),ADD(divbi&(1,46,17),2),1,5,0,13,12,14)
  GOSUB affiche_icones_enveloppeb
RETURN
PROCEDURE affiche_icones_enveloppeb
  env_num&=MIN(MAX(env_num&,0),63)
  env_copy&=MIN(MAX(env_copy&,0),63)
  GOSUB affchaine_notrans(HEX$(env_num&,2),ADD(divbi&(0,39,17),9),ADD(divbi&(1,39,17),2),1)
  GOSUB affchaine_notrans(FN envelopename$(env_num&,ss_menue%),SUCC(divbi&(0,43,17)),ADD(divbi&(1,43,17),2),1)
  GOSUB affchaine_notrans(HEX$(env_copy&,2),SUCC(divbi&(0,46,17)),ADD(divbi&(1,46,17),2),1)
  GOSUB affiche_icone_b(34,17,0,0,ss_menue%=0)
  GOSUB affiche_icone_b(35,17,0,0,ss_menue%=1)
  GOSUB affiche_icone_b(36,17,0,0,ss_menue%=2)
  GOSUB affiche_icone_b(37,17,0,0,env_sect&=0)
  GOSUB affiche_icone_b(38,17,0,0,env_sect&=1)
  GOSUB affiche_icones_enveloppec
  GOSUB affiche_icones_envelopped
RETURN
PROCEDURE affiche_icones_enveloppec
  ' Affichage de la liste des commandes
  LOCAL i%
  LOCAL a$
  env_codpos&=MIN(MAX(env_codpos&,0),PRED(env_codmax&(ss_menue%)))
  FOR i%=0 TO 9
    IF ADD(i%,env_codpos&)<env_codmax&(ss_menue%)
      a$=TRIM$(env_code$(env_conv&(ADD(i%,env_codpos&),ss_menue%)))
    ELSE
      a$=""
    ENDIF
    GOSUB affchaine_notrans(a$+SPACE$(SUB(11,LEN(a$))),divbi&(0,ADD(20,i%),17),divbi&(1,ADD(20,i%),17),1)
  NEXT i%
RETURN
PROCEDURE affiche_icones_envelopped
  LOCAL a%,b%,c%,i%,l%,p%
  LOCAL a$
  p%=FN pos_enveloppe(env_num&,ss_menue%,env_sect&,env_posaff&)
  IF p%<0
    env_posaff&=0
    env_poscurs&=0
    p%=0
  ENDIF
  a%=FN env_sectadr(env_num&,ss_menue%,env_sect&)
  l%=FN env_sectlen(env_num&,ss_menue%,env_sect&)
  env_poscurs&=MIN(MAX(env_poscurs&,env_posaff&),ADD(env_posaff&,9))
  FOR i%=0 TO 9
    IF ADD(env_posaff&,i%)=env_poscurs&
      a$=">"+STR$(ADD(env_posaff&,i%),3)
    ELSE IF p%<=l%
      a$=STR$(ADD(env_posaff&,i%),4)
    ELSE
      a$="    "
    ENDIF
    GOSUB affchaine_notrans(a$,divbi&(0,i%,17),divbi&(1,i%,17),1)
    IF p%<l%
      b%=BYTE{ADD(a%,p%)}
      c%=SUCC(ADD(a%,p%))
      a$=env_code$(b%)
      SELECT b%
      CASE &H2
        a$=a$+STR$(CARD{c%},5)
        ADD p%,3
      CASE &H1,&H2,&H4
        a$=a$+STR$(FN numcom_enveloppe(env_num&,ss_menue%,env_sect&,CARD{c%}),3)
        ADD p%,3
      CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2
        a$=a$+HEX$(BYTE{c%},2)
        ADD p%,2
      CASE &H80,&HA0
        a$=a$+HEX$(CARD{c%},4)
        ADD p%,3
      CASE &HC0
        a$=a$+HEX$(CARD{c%},3)
        ADD p%,3
      CASE &H81,&HA1,&HC1
        a$=a$+FN hexasigne$(INT{c%},4)
        ADD p%,3
      DEFAULT
        INC p%
      ENDSELECT
      a$=a$+SPACE$(SUB(16,LEN(a$)))
      GOSUB affchaine_notrans(a$,divbi&(0,ADD(i%,10),17),divbi&(1,ADD(i%,10),17),1)
    ELSE
      GOSUB affchaine_notrans(SPACE$(16),divbi&(0,ADD(i%,10),17),divbi&(1,ADD(i%,10),17),1)
      INC p%
    ENDIF
  NEXT i%
RETURN
PROCEDURE gere_icones_enveloppe
  LOCAL a%,b%,c%,d%,e%,i%,srt%
  LOCAL flag_relachement!
  LOCAL a$
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:17,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 0 TO 9                 ! Numero de pas
      b%=FN numcom_enveloppe(env_num&,ss_menue%,env_sect&,FN env_sectlen(env_num&,ss_menue%,env_sect&))
      env_poscurs&=MIN(MAX(ADD(env_posaff&,srt%),0),b%)
      GOSUB affiche_icones_envelopped
      ' ----------------------------------------------------------------------
    CASE 10 TO 19               ! Commande dans l'enveloppe : Edition du parametre
      a%=FN pos_enveloppe(env_num&,ss_menue%,env_sect&,ADD(env_posaff&,SUB(srt%,10)))
      IF a%>=0
        a%=ADD(FN env_sectadr(env_num&,ss_menue%,env_sect&),a%)
        b%=BYTE{a%}
        c%=ADD(divbi&(0,srt%,17),LEN(env_code$(b%)))
        d%=divbi&(1,srt%,17)
        INC a%
        SELECT b%
        CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2   ! Octet
          GOSUB edite_chaine(HEX$(BYTE{a%},2),c%,d%,2,1)
          BYTE{a%}=VAL("$"+bbbb$)
        CASE &H2                                                ! Mot decimal
          GOSUB edite_chaine(STR$(CARD{a%},5),c%,d%,5,2)
          CARD{a%}=MIN(MAX(VAL(bbbb$),0),32767)
        CASE &H1,&H4                                            ! Mot decimal (position) 999 maxi
          GOSUB edite_chaine(STR$(FN numcom_enveloppe(env_num&,ss_menue%,env_sect&,CARD{a%}),3),c%,d%,3,2)
          CARD{a%}=MIN(MAX(FN pos_enveloppe(env_num&,ss_menue%,env_sect&,VAL(bbbb$)),0),PRED(FN env_sectlen(env_num&,ss_menue%,env_sect&)))
        CASE &H80,&HA0                                          ! Mot
          GOSUB edite_chaine(HEX$(CARD{a%},4),c%,d%,4,1)
          CARD{a%}=VAL("$"+bbbb$)
        CASE &HC0                                               ! Mot 3 chiffres
          GOSUB edite_chaine(HEX$(CARD{a%},3),c%,d%,3,1)
          CARD{a%}=VAL("$"+bbbb$)
        CASE &H81,&HA1,&HC1                                     ! Mot signe
          GOSUB edite_chaine(FN hexasigne$(INT{a%},4),c%,d%,5,0)
          INT{a%}=FN valhexasigne(bbbb$)
        DEFAULT
          GOTO gere_icone_env_gotopos
        ENDSELECT
      ELSE
      gere_icone_env_gotopos:
        b%=FN numcom_enveloppe(env_num&,ss_menue%,env_sect&,FN env_sectlen(env_num&,ss_menue%,env_sect&))
        env_poscurs&=MIN(MAX(ADD(env_posaff&,SUB(srt%,10)),0),b%)
      ENDIF
      GOSUB affiche_icones_envelopped
      ' ----------------------------------------------------------------------
    CASE 20 TO 29               ! Commande dans la liste : insertion
      e%=ADD(env_codpos&,SUB(srt%,20))
      IF e%<env_codmax&(ss_menue%)
        GOSUB bee(TRUE)
        a%=env_conv&(e%,ss_menue%)              ! Numero de la commande a inserer
        b%=FN env_comlen(a%)                    ! Determination de la taille
        GOSUB chg_env_rellength(env_num&,ss_menue%,env_sect&,env_poscurs&,b%)
        d%=FN pos_enveloppe(env_num&,ss_menue%,env_sect&,env_poscurs&)
        c%=ADD(FN env_sectadr(env_num&,ss_menue%,env_sect&),d%)
        BYTE{c%}=a%
        IF b%=2
          BYTE{SUCC(c%)}=env_valdef&(e%,ss_menue%)
        ELSE IF b%=3
          CARD{SUCC(c%)}=env_valdef&(e%,ss_menue%)
        ENDIF
        GOSUB chg_env_adrjump(env_num&,ss_menue%,env_sect&,d%,b%)
        INC env_poscurs&
        env_posaff&=MAX(MIN(env_posaff&,env_poscurs&),SUB(env_poscurs&,9))
        GOSUB bee(FALSE)
        GOSUB affiche_icones_envelopped
      ENDIF
      ' ----------------------------------------------------------------------
    CASE 30,31                  ! Fleches de defilement de l'enveloppe
      a%=MUL(PRED(SHL(SUB(srt%,30),1)),SHL(1,PRED(km%)))
      b%=FN numcom_enveloppe(env_num&,ss_menue%,env_sect&,FN env_sectlen(env_num&,ss_menue%,env_sect&))
      env_poscurs&=MIN(MAX(ADD(env_poscurs&,a%),0),b%)
      env_posaff&=MAX(MIN(env_posaff&,env_poscurs&),SUB(env_poscurs&,9))
      GOSUB affiche_icones_envelopped
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 32,33                  ! Fleches de defilement des commandes
      env_codpos&=MIN(MAX(ADD(env_codpos&,PRED(SHL(SUB(srt%,32),1))),0),PRED(env_codmax&(ss_menue%)))
      GOSUB affiche_icones_enveloppec
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 34 TO 36               ! Type d'enveloppe
      ss_menue%=SUB(srt%,34)
      env_posaff&=0
      env_poscurs&=0
      env_codpos&=0
      GOSUB affiche_icones_enveloppeb
      ' ----------------------------------------------------------------------
    CASE 37,38                  ! Type de section
      env_sect&=SUB(srt%,37)
      env_posaff&=0
      env_poscurs&=0
      env_codpos&=0
      GOSUB affiche_icones_enveloppeb
      ' ----------------------------------------------------------------------
    CASE 39                     ! Numero de l'enveloppe
      GOSUB edite_chaine(HEX$(env_num&,2),ADD(divbi&(0,39,17),9),ADD(divbi&(1,39,17),2),2,1)
      env_num&=MIN(MAX(VAL("$"+bbbb$),1),63)
      env_poscurs&=0
      env_posaff&=0
      GOSUB affiche_icones_enveloppeb
      ' ----------------------------------------------------------------------
    CASE 40,41                  ! Enveloppe +/-
      env_num&=MAX(MIN(ADD(env_num&,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,40),km%))),63),1)
      env_poscurs&=0
      env_posaff&=0
      GOSUB affiche_icones_enveloppeb
      IF km%=1
        PAUSE 2
      ENDIF
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 43                     ! Nom de l'enveloppe
      GOSUB edite_chaine(FN envelopename$(env_num&,ss_menue%),SUCC(divbi&(0,43,17)),ADD(divbi&(1,43,17),2),20,0)
      GOSUB chg_envelopename(bbbb$,env_num&,ss_menue%)
      GOSUB affiche_icones_enveloppeb
      ' ----------------------------------------------------------------------
    CASE 46                     ! Numero de Copy
      GOSUB edite_chaine(HEX$(env_copy&,2),SUCC(divbi&(0,46,17)),ADD(divbi&(1,46,17),2),2,1)
      env_copy&=MIN(MAX(VAL("$"+bbbb$),1),63)
      GOSUB affiche_icones_enveloppeb
      ' ----------------------------------------------------------------------
    CASE 47,48                  ! Copy +/-
      env_copy&=MAX(MIN(ADD(env_copy&,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,47),km%))),63),1)
      GOSUB affiche_icones_enveloppeb
      IF km%=1
        PAUSE 2
      ENDIF
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,17,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 42                   ! Clear Envelope
        a$=MID$("volume tone   panning",SUCC(MUL(ss_menue%,7)),7)
        GOSUB dialog("CLEAR ENVELOPE","Do you want to clear|"+a$+" envelope #"+HEX$(env_num&,2)+" ?","Ok|Cancel",MOUSEX,MOUSEY)
        IF bouton%=0
          GOSUB bee(TRUE)
          GOSUB chg_env_length(env_num&,ss_menue%,0,1)
          GOSUB chg_env_length(env_num&,ss_menue%,1,1)
          GOSUB chg_envelopename("",env_num&,ss_menue%)
          env_poscurs&=0
          env_posaff&=0
          GOSUB bee(FALSE)
          GOSUB affiche_icones_envelopped
          GOSUB aff_message(a$+" envelope "+HEX$(env_num&,2)+" cleared.")
        ENDIF
        ' --------------------------------------------------------------------
      CASE 44                   ! Delete Command
        d%=FN pos_enveloppe(env_num&,ss_menue%,env_sect&,env_poscurs&)
        IF d%>=0
          GOSUB bee(TRUE)
          IF FN pos_enveloppe(env_num&,ss_menue%,env_sect&,1)>=0
            b%=ADD(FN env_sectadr(env_num&,ss_menue%,env_sect&),d%)
            a%=BYTE{b%}
            b%=FN env_comlen(a%)                ! Determination de la taille
            GOSUB chg_env_rellength(env_num&,ss_menue%,env_sect&,env_poscurs&,-b%)
            GOSUB chg_env_adrjump(env_num&,ss_menue%,env_sect&,d%,-b%)
          ELSE
            GOSUB chg_env_length(env_num&,ss_menue%,env_sect&,1)        ! End obligatoire si aucune commande
          ENDIF
          GOSUB bee(FALSE)
        ENDIF
        GOSUB affiche_icones_envelopped
        ' --------------------------------------------------------------------
      CASE 45                   ! Copy Envelope
        IF env_num&<>env_copy&
          a$=MID$("volume tone   panning",SUCC(MUL(ss_menue%,7)),7)
          GOSUB dialog("COPY ENVELOPE","Do you want to copy|"+a$+" envelope #"+HEX$(env_copy&,2)+"|to envelope #"+HEX$(env_num&,2)+" ?","Ok|Cancel",MOUSEX,MOUSEY)
          IF bouton%=0
            GOSUB bee(TRUE)
            FOR i%=0 TO 1
              b%=FN env_sectlen(env_copy&,ss_menue%,i%)
              GOSUB chg_env_length(env_num&,ss_menue%,i%,b%)
              a%=FN env_sectadr(env_copy&,ss_menue%,i%)
              BMOVE a%,FN env_sectadr(env_num&,ss_menue%,i%),b%
            NEXT i%
            GOSUB chg_envelopename(FN envelopename$(env_copy&,ss_menue%),env_num&,ss_menue%)
            env_poscurs&=0
            env_posaff&=0
            GOSUB aff_message(a$+" envelope "+HEX$(env_copy&,2)+" copied to envelope "+HEX$(env_num&,2)+".")
            GOSUB bee(FALSE)
            GOSUB affiche_icones_envelopped
          ENDIF
        ENDIF
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone_b(srt%,17,0,0,0)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Control
PROCEDURE affiche_icones_control
  LOCAL i%
  IF ss_menuc%=2
    GOSUB affiche_icones_control2
  ELSE
    GOSUB cadre_int(20,35,14,69,13,13,14,12)
    GOSUB cadre_int(35,35,15,39,13,13,14,12)
    GOSUB cadre_int(35,75,15,29,13,13,14,12)
    GOSUB cadre_int(51,35,28,69,13,13,14,12)
    GOSUB affchaine_trans("PANNING",72,42,14)
    GOSUB affiche_bloc_icones_b(0,2,25,0,0)
    GOSUB affiche_bloc_icones_b(8,6,25,0,0)
    GOSUB cadre_ext(ADD(divbi&(0,8,25),6),ADD(divbi&(1,8,25),2),2,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,11,25),6),ADD(divbi&(1,11,25),2),2,5,0,13,12,14)
    FOR i%=18 TO 46 STEP 4
      GOSUB cadre_ext(divbi&(0,i%,25),divbi&(1,i%,25),divbi&(2,i%,25),divbi&(3,i%,25),0,13,12,14)
      GOSUB affiche_bloc_icones_b(SUCC(i%),2,25,0,0)
      GOSUB cadre_ext(divbi&(0,ADD(i%,3),25),divbi&(1,ADD(i%,3),25),divbi&(2,ADD(i%,3),25),divbi&(3,ADD(i%,3),25),0,13,12,14)
    NEXT i%
    GOSUB affiche_icones_controlb
  ENDIF
RETURN
PROCEDURE affiche_icones_controlb
  LOCAL i%,n%,t%
  IF ss_menuc%=2
    GOSUB affiche_icones_controlb2
  ELSE
    FOR i%=0 TO 3
      GOSUB affiche_icone_b(ADD(14,i%),25,0,0,i%=ss_menuc_npan%)
    NEXT i%
    FOR i%=0 TO 7
      n%=ADD(MUL(i%,4),21)
      t%=ADD(SHL(ss_menuc_npan%,3),i%)
      GOSUB cadre_int(divbi&(0,n%,25),divbi&(1,ADD(18,MUL(i%,4)),25),1,5,13,13,13,13)
      GOSUB affchaine_trans(STR$(SUCC(t%),2),SHL(divbi&(0,n%,25),1),divbi&(1,ADD(18,MUL(i%,4)),25),14)
    NEXT i%
    GOSUB affiche_icones_controlc(TRUE)
    GOSUB affiche_icones_controld(TRUE)
  ENDIF
RETURN
PROCEDURE affiche_icones_controlc(update!)
  LOCAL a%
  a%=FN mod_tempo
  IF a%<>control_old%(8) OR update!
    GOSUB affchaine_notrans(STR$(a%,3),ADD(divbi&(0,8,25),6),ADD(divbi&(1,8,25),2),1)
    control_old%(8)=a%
  ENDIF
  a%=CARD{r_mod_speed%}
  IF a%<>control_old%(9) OR update!
    GOSUB affchaine_notrans(STR$(a%,3),ADD(divbi&(0,11,25),6),ADD(divbi&(1,11,25),2),1)
    control_old%(9)=a%
  ENDIF
RETURN
PROCEDURE affiche_icones_controld(update!)
  '
  ' Les pannings
  ' ------------
  LOCAL i%,n%,p%
  FOR i%=0 TO 7
    p%=FN balance(ADD(SHL(ss_menuc_npan%,3),i%))
    IF p%<>control_old%(i%) OR update!
      n%=ADD(MUL(i%,4),21)
      GOSUB affchaine_notrans(HEX$(p%,3),divbi&(0,SUB(n%,3),25),divbi&(1,SUB(n%,3),25),1)
      GOSUB affiche_slider_h(divbi&(0,n%,25),divbi&(1,n%,25),divbi&(2,n%,25),p%,4095)
      control_old%(i%)=p%
    ENDIF
  NEXT i%
RETURN
PROCEDURE gere_icones_control
  LOCAL a%,b%,c%,srt%
  LOCAL flag_relachement!
  LOCAL a$
  IF ss_menuc%=2
    GOSUB gere_icones_control2
  ELSE
    flag_relachement!=TRUE
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:25,W:xm%,W:ym%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' ----------------------------------------------------------------------
      CASE 8      ! Tempo
        a%=FN mod_tempo
        GOSUB edite_chaine(STR$(a%,3),ADD(divbi&(0,srt%,25),6),ADD(divbi&(1,srt%,25),2),3,2)
        a%=MIN(MAX(VAL(bbbb$),1),999)
        GOSUB chg_tempo(a%)
        GOSUB affiche_icones_controlc(TRUE)
        ' ----------------------------------------------------------------------
      CASE 9,10   ! Tempo +/-
        a%=FN mod_tempo
        a%=MAX(MIN(ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,9),km%))),999),1)
        GOSUB chg_tempo(a%)
        GOSUB affiche_icones_controlc(TRUE)
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' ----------------------------------------------------------------------
      CASE 11     ! Speed
        a%=FN mod_speed
        GOSUB edite_chaine(STR$(a%,3),ADD(divbi&(0,srt%,25),6),ADD(divbi&(1,srt%,25),2),3,2)
        a%=MIN(MAX(VAL(bbbb$),1),255)
        GOSUB chg_speed(a%)
        GOSUB affiche_icones_controlc(TRUE)
        ' ----------------------------------------------------------------------
      CASE 12,13  ! Speed +/-
        a%=FN mod_speed
        a%=MAX(MIN(ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,12),km%))),255),1)
        GOSUB chg_speed(a%)
        GOSUB affiche_icones_controlc(TRUE)
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' ----------------------------------------------------------------------
      CASE 14 TO 17       ! Numero de plage des pannings
        ss_menuc_npan%=SUB(srt%,14)
        GOSUB affiche_icones_controlb
        ' ----------------------------------------------------------------------
      CASE 18,22,26,30,34,38,42,46                                ! Valeur Panning
        b%=ADD(SHL(ss_menuc_npan%,3),DIV(SUB(srt%,18),4))
        a%=FN balance(b%)
        GOSUB edite_chaine(HEX$(a%,3),divbi&(0,srt%,25),divbi&(1,srt%,25),3,1)
        a%=MIN(MAX(VAL("$"+bbbb$),0),4095)
        GOSUB chg_t_balance(b%,a%)
        GOSUB affiche_icones_controld(TRUE)
        ' ----------------------------------------------------------------------
      CASE 19,20,23,24,27,28,31,32,35,36,39,40,43,44,47,48        ! Panning +/-
        SELECT km%
        CASE 1
          c%=1
        CASE 2
          c%=&H10
        CASE 3
          c%=&H80
        ENDSELECT
        b%=ADD(SHL(ss_menuc_npan%,3),DIV(SUB(srt%,19),4))
        a%=FN balance(b%)
        a%=MAX(MIN(ADD(a%,SUB(MUL(SUB(srt%,19) MOD 4,SHL(c%,1)),c%)),4095),0)
        GOSUB chg_t_balance(b%,a%)
        GOSUB affiche_icones_controlc(TRUE)
        IF km%=1
          PAUSE 6
        ENDIF
        flag_relachement!=FALSE
        GOSUB affiche_icones_controld(FALSE)
        ' ----------------------------------------------------------------------
      CASE 21,25,29,33,37,41,45,49                                ! Slider Panning
        a%=MIN(4095,MUL(4095,SUB(xm%,SHL(divbi&(0,srt%,25),3)))/ADD(SHL(divbi&(2,srt%,25),3),6)+0.999)
        b%=ADD(SHL(ss_menuc_npan%,3),DIV(SUB(srt%,21),4))
        GOSUB chg_t_balance(b%,a%)
        GOSUB affiche_icones_controld(FALSE)
        flag_relachement!=FALSE
        ' ----------------------------------------------------------------------
      CASE 2 TO 7       ! Rien de rien...
        ' ----------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,25,0,0,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' --------------------------------------------------------------------
        CASE 0    ! Page suivante
          ss_menuc%=2
          GOSUB affiche_icones_control
          ' --------------------------------------------------------------------
        CASE 1    ! Reset des balances
          GOSUB dialog("PAN RESET","Which setting do you want?||- Standard : as on a ProTracker|module, L-R-R-L-L-R...|- Mono","Standard|Mono|Cancel",MOUSEX,MOUSEY)
          IF bouton%=0
            GOSUB balance_reset
          ELSE IF bouton%=1
            a$=STRING$(32,MKI$(&H800))
            GOSUB set_balance(a$)
          ENDIF
          GOSUB affiche_icones_controlb
          ' --------------------------------------------------------------------
        ENDSELECT
        IF ss_menuc%=1
          GOSUB affiche_icone_b(srt%,25,0,0,0)
        ENDIF
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_control2
  LOCAL i%
  GOSUB cadre_int(20,35,9,69,13,13,14,12)
  GOSUB cadre_int(30,35,4,69,13,13,14,12)
  GOSUB cadre_int(35,35,19,39,13,13,14,12)
  GOSUB cadre_int(35,75,19,29,13,13,14,12)
  GOSUB cadre_int(55,35,24,69,13,13,14,12)
  GOSUB affchaine_trans("L    R",44,37,14)
  GOSUB affchaine_trans("M",64,37,14)
  GOSUB affchaine_trans("VOLUME",72,42,14)
  FOR i%=2 TO 7
    GOSUB cadre_ext(divbi&(0,i%,31),divbi&(1,i%,31),divbi&(2,i%,31),divbi&(3,i%,31),0,13,12,14)
  NEXT i%
  GOSUB affiche_bloc_icones_b(0,2,31,0,0)
  FOR i%=12 TO 19
    GOSUB cadre_ext(divbi&(0,i%,31),divbi&(1,i%,31),divbi&(2,i%,31),divbi&(3,i%,31),0,13,12,14)
  NEXT i%
  GOSUB affiche_icones_controlb
RETURN
PROCEDURE affiche_icones_controlb2
  LOCAL i%,n%,t%
  FOR i%=0 TO 3
    GOSUB affiche_icone_b(ADD(8,i%),31,0,0,i%=ss_menuc2_nvol%)
  NEXT i%
  FOR i%=0 TO 7
    n%=ADD(i%,12)
    t%=ADD(SHL(ss_menuc2_nvol%,3),i%)
    GOSUB cadre_int(divbi&(0,n%,31),SUB(divbi&(1,n%,31),8),1,5,13,13,13,13)
    GOSUB affchaine_trans(STR$(SUCC(t%),2),SHL(divbi&(0,n%,31),1),SUB(divbi&(1,n%,31),8),14)
  NEXT i%
  GOSUB affiche_icones_controlc2(TRUE)
  GOSUB affiche_icones_controld2(TRUE)
RETURN
PROCEDURE affiche_icones_controlc2(update!)
  '
  ' Les volumes generaux
  ' --------------------
  LOCAL v%
  ' Left du CoDec
  v%=SUB(15,PEEK(&HFFFF893A) AND 15)
  IF v%<>control_old%(10) OR update!
    GOSUB affchaine_notrans(STR$(v%,3),divbi&(0,3,25),divbi&(1,3,25),1)
    GOSUB affiche_slider_v(divbi&(0,2,25),divbi&(1,2,25),divbi&(2,2,25),divbi&(3,2,25),v%,15)
    control_old%(10)=v%
  ENDIF
  ' Right du CoDec
  v%=SUB(15,SHR(PEEK(&HFFFF893B),4))
  IF v%<>control_old%(11) OR update!
    GOSUB affchaine_notrans(STR$(v%,3),divbi&(0,5,25),divbi&(1,5,25),1)
    GOSUB affiche_slider_v(divbi&(0,4,25),divbi&(1,4,25),divbi&(2,4,25),divbi&(3,4,25),v%,15)
    control_old%(11)=v%
  ENDIF
  ' Master du sountracker
  v%=CARD{r_master_vol%}
  IF v%<>control_old%(12) OR update!
    GOSUB affchaine_notrans(HEX$(v%,3),divbi&(0,7,25),divbi&(1,7,25),1)
    GOSUB affiche_slider_v(divbi&(0,6,25),divbi&(1,6,25),divbi&(2,6,25),divbi&(3,6,25),v%,4095)
    control_old%(12)=v%
  ENDIF
RETURN
PROCEDURE affiche_icones_controld2(update!)
  '
  ' Les volumes exponentiels de chaque voie
  ' ---------------------------------------
  ' Affichage entre $800 et $E00
  LOCAL i%,n%,p%,v%,v2%
  FOR i%=0 TO 7
    v%=FN track_volume_exp(ADD(SHL(ss_menuc2_nvol%,3),i%))
    p%=ADD(i%,12)
    IF v%<>control_old%(ADD(i%,13)) OR update!
      v2%=MAX(MIN(SUB(v%,&H800),&H600),0)
      n%=ADD(MUL(i%,4),21)
      GOSUB affiche_slider_v(divbi&(0,p%,31),divbi&(1,p%,31),divbi&(2,p%,31),divbi&(3,p%,31),v2%,&H600)
      control_old%(ADD(i%,13))=v%
    ENDIF
  NEXT i%
RETURN
PROCEDURE gere_icones_control2
  LOCAL a%,b%,c%,srt%
  LOCAL flag_relachement!
  LOCAL a$
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:31,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 2      ! Slider Left amplification
      a%=MUL(15,SUB(divbi&(3,srt%,31),SUB(ym%,divbi&(1,srt%,31))))/divbi&(3,srt%,31)+0.999
      SPOKE &HFFFF893A,SUB(15,a%)
      GOSUB affiche_icones_controlc2(FALSE)
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 3      ! Valeur Left amplification
      a%=SUB(15,PEEK(&HFFFF893A) AND 15)
      GOSUB edite_chaine(STR$(a%,3),divbi&(0,srt%,31),divbi&(1,srt%,31),3,2)
      a%=MIN(MAX(VAL(bbbb$),0),15)
      SPOKE &HFFFF893A,SUB(15,a%)
      GOSUB affiche_icones_controlc2(TRUE)
      ' ----------------------------------------------------------------------
    CASE 4      ! Slider Right amplification
      a%=MUL(15,SUB(divbi&(3,srt%,31),SUB(ym%,divbi&(1,srt%,31))))/divbi&(3,srt%,31)+0.999
      SPOKE &HFFFF893B,SHL(SUB(15,a%),4)
      GOSUB affiche_icones_controlc2(FALSE)
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 5      ! Valeur Right amplification
      a%=SUB(15,SHR(PEEK(&HFFFF893B),4))
      GOSUB edite_chaine(STR$(a%,3),divbi&(0,srt%,31),divbi&(1,srt%,31),3,2)
      a%=MIN(MAX(VAL(bbbb$),0),15)
      SPOKE &HFFFF893B,SHL(SUB(15,a%),4)
      GOSUB affiche_icones_controlc2(TRUE)
      ' ----------------------------------------------------------------------
    CASE 6      ! Slider Master volume
      a%=MUL(4095,SUB(divbi&(3,srt%,31),SUB(ym%,divbi&(1,srt%,31))))/divbi&(3,srt%,31)+0.999
      CARD{r_master_vol%}=a%
      GOSUB affiche_icones_controlc2(FALSE)
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 7      ! Valeur Master volume
      a%=CARD{r_master_vol%}
      GOSUB edite_chaine(HEX$(a%,3),divbi&(0,srt%,31),divbi&(1,srt%,31),3,1)
      a%=MIN(MAX(VAL("$"+bbbb$),0),4095)
      CARD{r_master_vol%}=a%
      GOSUB affiche_icones_controlc2(TRUE)
      ' ----------------------------------------------------------------------
    CASE 8 TO 11        ! Numero de plage des volumes
      ss_menuc2_nvol%=SUB(srt%,8)
      GOSUB affiche_icones_controlb
      ' ----------------------------------------------------------------------
    CASE 12 TO 19       ! Slider volume d'une voie ou entree a la main
      b%=ADD(SHL(ss_menuc2_nvol%,3),SUB(srt%,12))
      IF km%=2          ! Entree de la valeur
      ELSE              ! Slider: entre $800 et $E00
        a%=MUL(&H600,SUB(divbi&(3,srt%,31),SUB(ym%,divbi&(1,srt%,31))))/divbi&(3,srt%,31)+0.999
        ADD a%,&H800
        GOSUB chg_t_mix_volume_e(b%,a%)
        flag_relachement!=FALSE
      ENDIF
      GOSUB affiche_icones_controld2(FALSE)
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,31,0,0,-1)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 0    ! Page precedente
        ss_menuc%=1
        GOSUB affiche_icones_control
        ' --------------------------------------------------------------------
      CASE 1    ! Reset des volumes
        GOSUB dialog("VOLUME RESET","Reset all the|track volumes.","OK|Cancel",MOUSEX,MOUSEY)
        IF bouton%=0
          GOSUB track_volume_reset
        ENDIF
        GOSUB affiche_icones_controlb
        ' --------------------------------------------------------------------
      ENDSELECT
      IF ss_menuc%=2
        GOSUB affiche_icone_b(srt%,31,0,0,0)
      ENDIF
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
' Midi
PROCEDURE affiche_icones_midi
  IF ss_menum%=2
    GOSUB affiche_icones_midi2
  ELSE
    GOSUB cadre_int(20,35,59,69,13,13,14,12)
    GOSUB cadre_int(20,35,14,29,13,13,14,12)
    GOSUB cadre_int(35,35,11,39,13,13,14,12)
    GOSUB cadre_int(47,35,19,39,13,13,14,12)
    GOSUB cadre_int(20,65,14,39,13,13,14,12)
    GOSUB affiche_bloc_icones_b(8,7,27,0,0)
    GOSUB affchaine_trans("MIDI",42,41,14)
    GOSUB affchaine_trans("SYNC",42,53,14)
    GOSUB affchaine_trans("OPTIONS",72,40,14)
    GOSUB affchaine_trans("MONOPHONIC MODE",96,40,14)
    GOSUB affchaine_trans("REC. MODE",42,70,14)
    GOSUB cadre_ext(ADD(divbi&(0,8,27),11),ADD(divbi&(1,8,27),2),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(divbi&(0,11,27),11),ADD(divbi&(1,11,27),2),1,5,0,13,12,14)
    GOSUB affiche_icones_midib
  ENDIF
RETURN
PROCEDURE affiche_icones_midib
  LOCAL a$
  GOSUB affiche_icone_b(0,27,0,0,midi_flag_data_in!)
  GOSUB affiche_icone_b(1,27,0,0,midi_flag_data_out!)
  GOSUB affiche_icone_b(2,27,0,0,midi_flag_synchro%=1)
  GOSUB affiche_icone_b(3,27,0,0,midi_flag_synchro%=2)
  GOSUB affiche_icone_b(6,27,0,0,NOT midi_polyphonic_mode!)
  GOSUB affiche_icone_b(7,27,0,0,midi_polyphonic_mode!)
  GOSUB affchaine_notrans(STR$(midi_monomode_channel_nbr%,2),ADD(divbi&(0,8,27),11),ADD(divbi&(1,8,27),2),1)
  IF midi_monomode_instr_nbr%=0
    a$="C."
  ELSE
    a$=HEX$(midi_monomode_instr_nbr%,2)
  ENDIF
  GOSUB affchaine_notrans(a$,ADD(divbi&(0,11,27),11),ADD(divbi&(1,11,27),2),1)
  '
  GOSUB grise_icone(1,27,0,0)
  GOSUB grise_icone(3,27,0,0)
  GOSUB grise_icone(6,27,0,0)
RETURN
PROCEDURE gere_icones_midi              !!!
  LOCAL a%,b%,c%,d%,e%,i%,srt%
  LOCAL flag_relachement!
  LOCAL a$
  IF ss_menum%=2
    GOSUB gere_icones_midi2
  ELSE
    flag_relachement!=TRUE
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:27,W:xm%,W:ym%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' ----------------------------------------------------------------------
      CASE 0            ! In  On/Off
        GOSUB chg_midi_flag_data_in(NOT midi_flag_data_in!)
        IF midi_flag_synchro%=1
          IF midi_flag_data_in!
            GOSUB chg_tempo2(500)
          ELSE
            GOSUB chg_tempo(FN mod_tempo)
          ENDIF
        ENDIF
        GOSUB affiche_icones_midib
        ' ----------------------------------------------------------------------
      CASE 1            ! Out On/Off
        ' GOSUB chg_midi_flag_data_in(NOT midi_flag_data_in!)
        ' GOSUB affiche_icones_midib
        '
        '
        '
        '
        ' ----------------------------------------------------------------------
      CASE 2            ! Synchro In
        IF midi_flag_synchro%<>1
          midi_flag_synchro%=1
        ELSE
          midi_flag_synchro%=0
        ENDIF
        CARD{r_midi_in_sync_flag%}=SGN(midi_flag_synchro%)
        IF midi_flag_synchro%=1
          GOSUB chg_tempo2(500)                 ! 500 BPM pour une synchro midi correcte
        ELSE
          GOSUB chg_tempo(FN mod_tempo)         ! Remet l'ancienne valeur quand plus de sync
        ENDIF
        GOSUB affiche_icones_midib
        ' ----------------------------------------------------------------------
      CASE 3            ! Synchro Out
        ' IF midi_flag_synchro%<>2
        '   midi_flag_synchro%=2
        ' ELSE
        '   midi_flag_synchro%=0
        ' ENDIF
        ' CARD{r_midi_out_sync_flag%}=SGN(midi_flag_synchro%)
        ' GOSUB chg_tempo(FN mod_tempo)
        ' GOSUB affiche_icones_midib
        '
        '
        '
        '
        ' ----------------------------------------------------------------------
      CASE 6            ! Monophonic mode
        '
        '
        '
        '
        ' ----------------------------------------------------------------------
      CASE 7            ! Polyphonic mode
        '
        '
        '
        '
        ' ----------------------------------------------------------------------
      CASE 8            ! MIDI Channel (monophonic mode)
        GOSUB edite_chaine(STR$(midi_monomode_channel_nbr%,2),ADD(divbi&(0,srt%,27),11),ADD(divbi&(1,srt%,27),2),2,2)
        GOSUB chg_midi_monomode_channel_nbr(MIN(MAX(VAL(bbbb$),1),16))
        GOSUB affiche_icones_midib
        ' ----------------------------------------------------------------------
      CASE 9,10         ! MIDI Channel +/-
        a%=midi_monomode_channel_nbr%
        a%=ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,9),km%)))
        GOSUB chg_midi_monomode_channel_nbr(MIN(MAX(a%,1),16))
        GOSUB affiche_icones_midib
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' ----------------------------------------------------------------------
      CASE 11           ! Instrument (monophonic mode)
        IF midi_monomode_instr_nbr%=0
          a$="C."
        ELSE
          a$=HEX$(midi_monomode_instr_nbr%,2)
        ENDIF
        GOSUB edite_chaine(a$,ADD(divbi&(0,srt%,27),11),ADD(divbi&(1,srt%,27),2),2,1)
        GOSUB chg_midi_monomode_instr_nbr(MIN(MAX(VAL("$"+bbbb$),0),255))
        GOSUB affiche_icones_midib
        ' ----------------------------------------------------------------------
      CASE 12,13        ! Instrument +/-
        a%=midi_monomode_instr_nbr%
        a%=ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,12),km%)))
        GOSUB chg_midi_monomode_instr_nbr(MIN(MAX(a%,0),255))
        GOSUB affiche_icones_midib
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' ----------------------------------------------------------------------
      CASE 14           ! Page 2
        GOSUB affiche_icone_b(srt%,27,0,0,-1)
        GOSUB wait_mouse(TRUE)
        ss_menum%=2
        GOSUB affiche_icones_midi
        ' ----------------------------------------------------------------------
      CASE 4,5          ! Rien
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,27,0,0,TRUE)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' --------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,27,0,0,FALSE)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_icones_midi2
  LOCAL a%,i%,j%
  GOSUB cadre_int(20,35,59,69,13,13,14,12)
  GOSUB affiche_bloc_icones_b(32,10,28,0,0)
  GOSUB cadre_ext(ADD(divbi&(0,32,28),15),ADD(divbi&(1,32,28),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,35,28),15),ADD(divbi&(1,35,28),2),1,5,0,13,12,14)
  FOR i%=0 TO 3
    GOSUB cadre_ext(SUB(divbi&(0,MUL(i%,8),28),9),SUCC(divbi&(1,MUL(i%,8),28)),32,SUB(divbi&(3,MUL(i%,8),28),2),13,13,12,14)
    GOSUB cadre_ext(divbi&(0,MUL(i%,8),28),ADD(divbi&(1,MUL(i%,8),28),9),23,5,0,13,12,14)
    GOSUB affchaine_trans("TRACK",SHL(SUB(divbi&(0,MUL(i%,8),28),8),1),ADD(divbi&(1,MUL(i%,8),28),2),14)
    GOSUB affchaine_trans("CHANNEL",SHL(SUB(divbi&(0,MUL(i%,8),28),8),1),ADD(divbi&(1,MUL(i%,8),28),9),14)
    FOR j%=0 TO 7
      a%=ADD(MUL(i%,8),j%)
      GOSUB cadre_texte3_b(divbn$(a%,28),divbi&(0,a%,28),ADD(divbi&(1,a%,28),1),divbi&(2,a%,28),7,0)
    NEXT j%
  NEXT i%
  GOSUB affiche_icones_midib2
RETURN
PROCEDURE affiche_icones_midib2
  LOCAL track%,channel%
  GOSUB affchaine_notrans(STR$(midi_polymode_channel_nbr%,2),ADD(divbi&(0,32,28),15),ADD(divbi&(1,32,28),2),1)
  GOSUB affchaine_notrans(HEX$(midi_in_instr%(PRED(midi_polymode_channel_nbr%)),2),ADD(divbi&(0,35,28),15),ADD(divbi&(1,35,28),2),1)
  FOR track%=0 TO 31
    IF track%<nbr_track%
      channel%=midi_in_channel%(track%)
      IF channel%>0
        GOSUB affchaine_notrans(STR$(channel%,2),divbi&(0,track%,28),ADD(divbi&(1,track%,28),9),1)
      ELSE
        GOSUB affchaine_notrans(MKI$(&H2005),divbi&(0,track%,28),ADD(divbi&(1,track%,28),9),1)
      ENDIF
    ELSE
      GOSUB affchaine_notrans(SPACE$(2),divbi&(0,track%,28),ADD(divbi&(1,track%,28),9),1)
    ENDIF
  NEXT track%
RETURN
PROCEDURE gere_icones_midi2
  flag_relachement!=TRUE
  a%=V:divbi&(0,0,0)
  srt%=C:g_teste_icones%(L:a%,W:28,W:xm%,W:ym%)
  IF srt%>=0
    SELECT srt%
      ' Radio-boutons, Flip-flops ou champs de texte
      ' ----------------------------------------------------------------------
    CASE 0 TO 31        ! Piste
      IF SUB(ym%,divbi&(1,srt%,28))<9           ! Partie haute: le numero de piste
        IF midi_in_channel%(srt%)<>midi_polymode_channel_nbr%
          GOSUB chg_midi_polymode_channel(srt%,midi_polymode_channel_nbr%)
        ELSE
          GOSUB chg_midi_polymode_channel(srt%,0)
        ENDIF
      ELSE                                      ! Partie basse: le numero de canal MIDI
        IF midi_in_channel%(srt%)<>0
          a%=midi_in_channel%(srt%)
          IF km%=1
            a%=MIN(SUCC(a%),16)
          ELSE IF km%=2
            a%=MAX(PRED(a%),1)
          ENDIF
          GOSUB chg_midi_polymode_channel(srt%,a%)
        ELSE
          GOSUB chg_midi_polymode_channel(srt%,midi_polymode_channel_nbr%)
        ENDIF
      ENDIF
      GOSUB affiche_icones_midib2
      ' ----------------------------------------------------------------------
    CASE 32             ! Numero de canal
      ' IF km%=2
      popup_code%(1,4)=popup_code%(1,4) AND (NOT &H20000)
      popup_code%(2,4)=popup_code%(2,4) AND (NOT &H20000)
      popup_code%(4,4)=popup_code%(4,4) AND (NOT &H20000)
      popup_code%(5,4)=popup_code%(5,4) AND (NOT &H20000)
      popup_code%(7,4)=popup_code%(7,4) AND (NOT &H20000)
      popup_code%(8,4)=popup_code%(8,4) AND (NOT &H20000)
      IF FN get_midi_flag_velocity(midi_polymode_channel_nbr%)<>0
        popup_code%(7,4)=popup_code%(7,4) OR &H20000
      ELSE
        popup_code%(8,4)=popup_code%(8,4) OR &H20000
      ENDIF
      a%=FN get_midi_flag_note_off(midi_polymode_channel_nbr%)
      IF a%=0
        popup_code%(2,4)=popup_code%(2,4) OR &H20000
        popup_code%(5,4)=popup_code%(5,4) OR &H20000
      ELSE
        popup_code%(1,4)=popup_code%(1,4) OR &H20000
        IF a%=-1
          popup_code%(4,4)=popup_code%(4,4) OR &H20000
        ELSE
          popup_code%(5,4)=popup_code%(5,4) OR &H20000
        ENDIF
      ENDIF
      a%=FN popup(4,-1,xm%,ym%)
      IF a%>=0
        a%=a% AND &HFFFF
        SELECT a%
        CASE 0          ! Melody
          GOSUB chg_midi_flag_note_off(midi_polymode_channel_nbr%,-1)
        CASE 1          ! Drums
          GOSUB chg_midi_flag_note_off(midi_polymode_channel_nbr%,0)
        CASE 10         ! Note Off transcribed
          GOSUB chg_midi_flag_note_off(midi_polymode_channel_nbr%,-1)
        CASE 11         ! Note Off ignored
          IF FN get_midi_flag_note_off(midi_polymode_channel_nbr%)<>0
            GOSUB chg_midi_flag_note_off(midi_polymode_channel_nbr%,1)
          ENDIF
        CASE 20         ! Velocity transcribed
          GOSUB chg_midi_flag_velocity(midi_polymode_channel_nbr%,TRUE)
        CASE 21         ! Velocity ignored
          GOSUB chg_midi_flag_velocity(midi_polymode_channel_nbr%,FALSE)
        ENDSELECT
      ENDIF
      ' ELSE
      '   GOSUB edite_chaine(STR$(midi_polymode_channel_nbr%,2),ADD(divbi&(0,srt%,28),15),ADD(divbi&(1,srt%,28),2),2,2)
      '   midi_polymode_channel_nbr%=MIN(MAX(VAL(bbbb$),1),16)
      ' ENDIF
      GOSUB affiche_icones_midib2
      ' ----------------------------------------------------------------------
    CASE 33,34          ! Numero de canal +/-
      a%=midi_polymode_channel_nbr%
      a%=ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,33),km%)))
      midi_polymode_channel_nbr%=MIN(MAX(a%,1),16)
      GOSUB affiche_icones_midib2
      IF km%=1
        PAUSE 6
      ENDIF
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 35             ! Numero d'instrument
      GOSUB edite_chaine(HEX$(midi_in_instr%(PRED(midi_polymode_channel_nbr%)),2),ADD(divbi&(0,srt%,28),15),ADD(divbi&(1,srt%,28),2),2,1)
      GOSUB chg_midi_in_instr(PRED(midi_polymode_channel_nbr%),MIN(MAX(VAL("$"+bbbb$),1),255))
      GOSUB affiche_icones_midib2
      ' ----------------------------------------------------------------------
    CASE 36,37          ! Numero d'instrument +/-
      a%=midi_in_instr%(PRED(midi_polymode_channel_nbr%))
      a%=ADD(a%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,36),km%)))
      GOSUB chg_midi_in_instr(PRED(midi_polymode_channel_nbr%),MIN(MAX(a%,1),255))
      GOSUB affiche_icones_midib2
      IF km%=1
        PAUSE 6
      ENDIF
      flag_relachement!=FALSE
      ' ----------------------------------------------------------------------
    CASE 41             ! Page 1
      GOSUB affiche_icone_b(srt%,28,0,0,-1)
      GOSUB wait_mouse(TRUE)
      ss_menum%=1
      GOSUB affiche_icones_midi
      ' ----------------------------------------------------------------------
    DEFAULT
      ' Icones normales
      GOSUB affiche_icone_b(srt%,28,0,0,TRUE)
      GOSUB wait_mouse(TRUE)
      SELECT srt%
        ' --------------------------------------------------------------------
      CASE 38           ! Select current preset
        FOR i%=0 TO PRED(nbr_colonnes%(n_preset%))
          ' IF i%<nbr_col%
          a%=preset&(i%,n_preset%)
          IF a%<nbr_track%
            GOSUB chg_midi_polymode_channel(a%,midi_polymode_channel_nbr%)
          ENDIF
          ' ENDIF
        NEXT i%
        GOSUB affiche_icones_midib2
        ' --------------------------------------------------------------------
      CASE 39           ! Remove MIDI channel
        FOR i%=0 TO PRED(nbr_track%)
          IF midi_in_channel%(i%)=midi_polymode_channel_nbr%
            GOSUB chg_midi_polymode_channel(i%,0)
          ENDIF
        NEXT i%
        GOSUB affiche_icones_midib2
        ' --------------------------------------------------------------------
      CASE 40           ! Reset
        IF midi_polyphonic_mode!
          GOSUB reset_all_midi_track_state
          GOSUB affiche_icones_midib2
        ELSE
          GOSUB dialog("RESET TRACKS","You can't do this because you're|not in polyphonic mode.","Cancel",MOUSEX,MOUSEY)
        ENDIF
        ' --------------------------------------------------------------------
      ENDSELECT
      GOSUB affiche_icone_b(srt%,28,0,0,FALSE)
    ENDSELECT
    GOSUB wait_mouse(flag_relachement!)
    GOSUB vide_buffer_clavier
  ENDIF
RETURN
'
' Affichages divers
' -----------------
PROCEDURE affiche_info_sample
  LOCAL a%
  IF NOT se.sample_editor_flag!
    HIDEM
    GOSUB affchaine_notrans(" "+HEX$(instr%,2),ADD(divbi&(0,12,16),11),ADD(divbi&(1,12,16),2),1)
    GOSUB affchaine_notrans(" "+HEX$(sample%,2),ADD(divbi&(0,15,16),11),ADD(divbi&(1,15,16),2),1)
    GOSUB affchaine_notrans(FN instrname$(instr%),ADD(divbi&(0,22,16),9),ADD(divbi&(1,22,16),2),1)
  ENDIF
  IF ss_menu%=3
    GOSUB affiche_icones_instrb
  ELSE IF ss_menu%=4
    GOSUB affiche_icones_sampleb
  ENDIF
RETURN
PROCEDURE affiche_info_song
  LOCAL a$
  IF NOT se.sample_editor_flag!
    HIDEM
    GOSUB affchaine_notrans(" "+HEX$(songpos%,2),ADD(divbi&(0,0,16),11),ADD(divbi&(1,0,16),2),1)
    GOSUB affchaine_notrans(" "+HEX$(song&(songpos%),2),ADD(divbi&(0,3,16),11),ADD(divbi&(1,3,16),2),1)
    IF module&(101)<256
      GOSUB affchaine_notrans(" "+HEX$(module&(101),2),ADD(divbi&(0,6,16),11),ADD(divbi&(1,6,16),2),1)
    ELSE
      GOSUB affchaine_notrans(HEX$(module&(101),3),ADD(divbi&(0,6,16),11),ADD(divbi&(1,6,16),2),1)
    ENDIF
    GOSUB affchaine_notrans(" "+HEX$(module&(102),2),ADD(divbi&(0,9,16),11),ADD(divbi&(1,9,16),2),1)
    GOSUB affchaine_notrans(FN songname$,ADD(divbi&(0,21,16),9),ADD(divbi&(1,21,16),2),1)
    GOSUB affchaine_notrans(STR$(nbr_track%,2),ADD(divbi&(0,23,16),7),ADD(divbi&(1,23,16),2),1)
    GOSUB affchaine_notrans(STR$(FN nbr_lines3,3),ADD(divbi&(0,24,16),6),ADD(divbi&(1,24,16),2),1)
    posligne%=MAX(MIN(posligne%,PRED(FN nbr_lines3)),0)
    SELECT line_step%
    CASE -255 TO -1
      a$="-"+HEX$(ABS(line_step%),1)
    CASE 0 TO 255
      a$=HEX$(line_step%,2)
    CASE 256
      a$="NL"
    CASE 257
      a$="NN"
    CASE 258
      a$="NF"
    CASE 259
      a$="NV"
    ENDSELECT
    GOSUB affchaine_notrans(a$,ADD(divbi&(0,18,16),5),ADD(divbi&(1,18,16),2),1)
    IF ss_menu%=2 AND ss_menut%=3
      GOSUB affiche_icones_toolsb3
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_info_preset
  LOCAL iii%,aaa%
  SELECT type_affpiste%
  CASE 0
    aaa%=6
  CASE 2
    aaa%=12
  DEFAULT
    aaa%=10
  ENDSELECT
  HIDEM
  GOSUB cadre_texte2(STR$(SUCC(n_preset%)),ADD(MUL(n_preset%,2),8),130,1,1)
  FOR iii%=0 TO PRED(nbr_col%)
    IF iii%<nbr_colonnes%(n_preset%)
      GOSUB affchaine_notrans(STR$(SUCC(preset&(iii%,n_preset%)),2),ADD(MUL(iii%,aaa%),6),162,1)
      IF FN track_onoff(preset&(iii%,n_preset%))<>0
        GOSUB affchaine_notrans(CHR$(6),ADD(MUL(iii%,aaa%),5),162,1)
      ELSE
        GOSUB affchaine_notrans(CHR$(5),ADD(MUL(iii%,aaa%),5),162,1)
      ENDIF
    ELSE
      GOSUB affchaine_notrans("   ",ADD(MUL(iii%,aaa%),5),162,1)
      GOSUB cadre_ext(ADD(MUL(iii%,aaa%),4),170,SUB(aaa%,2),PRED(MUL(haut_lig%,6)),0,9,8,10)
    ENDIF
  NEXT iii%
  GOSUB affiche_c_pattern
RETURN
PROCEDURE affiche_barre_info
  GOSUB cadre_int(1,140,70,7,9,9,9,9)           ! Efface ce qu'il y avait avant
  GOSUB affchaine_trans("OCT",2,142,10)
  GOSUB affchaine_trans(STR$(SUCC(octave%),1),10,142,8)
  GOSUB affchaine_trans("BLK",20,142,10)
  GOSUB affchaine_trans("/  :  -",32,142,8)
  GOSUB affchaine_trans(STR$(SUCC(bl_trk&),2),28,142,8)
  GOSUB affchaine_trans(HEX$(bl_pat&,2),34,142,8)
  GOSUB affchaine_trans(HEX$(bl_start&,2),40,142,8)
  GOSUB affchaine_trans(HEX$(bl_end&,2),46,142,8)
  GOSUB affchaine_trans("NUMPAD",58,142,10)
  IF drumpad_flag%=0
    GOSUB affchaine_trans("INSTRUM",72,142,8)
  ELSE IF drumpad_flag%=1
    GOSUB affchaine_trans("SAMPLES",72,142,8)
  ELSE
    GOSUB affchaine_trans("DRUMKIT",72,142,8)
  ENDIF
  GOSUB affchaine_trans("FREE       Kb",94,142,10)
  GOSUB affchaine_trans(STR$(SHR(FN zone_free,10),5),104,142,8)
RETURN
PROCEDURE aff_message(a$)
  GOSUB cadre_int(0,149,PRED(scr_ncol%),8,13,13,12,14)  ! Efface ce qu'il y avait avant
  GOSUB affchaine_trans(LEFT$(a$,MIN(LEN(a$),scr_ncol%)),2,151,12)
RETURN
PROCEDURE affiche_temps
  LOCAL a%,m$,s$
  a%=DIV(SUB(TIMER,debut_temps%),200)
  s$=STR$(a% MOD 60)
  m$=STR$(DIV(a%,60) MOD 60)
  GOSUB affchaine_notrans(STRING$(SUB(2,LEN(m$)),"0")+m$+":"+STRING$(SUB(2,LEN(s$)),"0")+s$,ADD(divbi&(0,25,16),1),ADD(divbi&(1,25,16),2),1)
RETURN
PROCEDURE affiche_cpu_time_pourcent
  ' Temps machine
  GOSUB cadre_int(75,140,3,7,9,9,9,9)
  IF CARD{r_flag_overload%}<>0
    GOSUB cadre_int(76,142,2,5,2,2,2,2)
    CARD{r_flag_overload%}=0
  ELSE
    GOSUB affchaine_trans(STR$(CARD{r_cpu_time_pourcent%},3)+"%",150,142,8)
  ENDIF
RETURN
PROCEDURE aff_ps_pp_e
  HIDEM
  GOSUB affiche_icone(0,24,0,0,play%=1)
  GOSUB affiche_icone(5,24,0,0,play%=2)
  GOSUB affiche_icone(1,24,0,0,edit%)
  SHOWM
RETURN
PROCEDURE affiche_slider_h(xxx%,yyy%,lll%,qqq%,mmm%)
  LOCAL iii%,ppp%
  GOSUB cadre_int(xxx%,yyy%,lll%,5,0,0,0,0)
  ppp%=DIV(MUL(qqq%,ADD(SHL(lll%,3),6)),mmm%)
  FOR iii%=ppp% TO SUCC(ppp%)
    GOSUB affchaine_trans(CHR$(ADD(iii% AND 7,16)),SHL(ADD(xxx%,SHR(iii%,3)),1),yyy%,1)
  NEXT iii%
RETURN
PROCEDURE affiche_slider_v(xxx%,yyy%,lll%,hhh%,qqq%,mmm%)
  LOCAL iii%,ppp%
  ppp%=DIV(MUL(qqq%,hhh%),mmm%)
  IF ppp%<hhh%
    GOSUB cadre_int(xxx%,yyy%,lll%,PRED(SUB(hhh%,ppp%)),0,0,0,0)
  ENDIF
  GOSUB cadre_int(xxx%,ADD(yyy%,SUB(hhh%,ppp%)),lll%,ppp%,1,1,1,1)
RETURN
PROCEDURE affiche_cadre_voies
  LOCAL iii%,aaa%
  GOSUB cadre_ext(1,170,1,PRED(MUL(haut_lig%,6)),0,9,8,10)
  SELECT type_affpiste%
  CASE 0
    aaa%=6
  CASE 1
    aaa%=10
  CASE 2
    aaa%=12
  ENDSELECT
  FOR iii%=0 TO PRED(nbr_col%)
    GOSUB cadre_ext(ADD(MUL(iii%,aaa%),4),170,SUB(aaa%,2),PRED(MUL(haut_lig%,6)),0,9,8,10)
    IF type_affpiste%>0
      GOSUB cadre_int(ADD(MUL(iii%,aaa%),4),160,8,9,9,9,10,8)
      GOSUB cadre_texte(CHR$(1),ADD(MUL(iii%,aaa%),9),160,1)
      GOSUB cadre_texte(CHR$(2),ADD(MUL(iii%,aaa%),11),160,1)
    ELSE
      GOSUB cadre_int(ADD(MUL(iii%,aaa%),4),160,4,9,9,9,10,8)
    ENDIF
    GOSUB cadre_ext(ADD(MUL(iii%,aaa%),5),162,2,5,0,9,8,10)
  NEXT iii%
RETURN
PROCEDURE affiche_panneau_principal
  LOCAL i%,a$
  IF NOT se.sample_editor_flag!
    DEFMOUSE 0
    HIDEM
    GOSUB cadre_int(0,0,PRED(scr_ncol%),PRED(scr_haut%),9,9,10,8)
    ' GOSUB affiche_graoumf_logo
    GOSUB affiche_bloc_icones(0,28,16,0,0)
    FOR i%=0 TO 15 STEP 3
      GOSUB cadre_ext(ADD(divbi&(0,i%,16),11),ADD(divbi&(1,i%,16),2),2,5,0,9,8,10)
    NEXT i%
    GOSUB cadre_ext(ADD(divbi&(0,18,16),5),ADD(divbi&(1,18,16),2),1,5,0,9,8,10)
    GOSUB cadre_ext(ADD(divbi&(0,21,16),9),ADD(divbi&(1,21,16),2),31,5,0,9,8,10)
    GOSUB cadre_ext(ADD(divbi&(0,22,16),9),ADD(divbi&(1,22,16),2),27,5,0,9,8,10)
    GOSUB cadre_ext(ADD(divbi&(0,23,16),7),ADD(divbi&(1,23,16),2),1,5,0,9,8,10)
    GOSUB cadre_ext(ADD(divbi&(0,24,16),6),ADD(divbi&(1,24,16),2),2,5,0,9,8,10)
    GOSUB cadre_ext(ADD(divbi&(0,25,16),1),ADD(divbi&(1,25,16),2),4,5,0,9,8,10)
    FOR i%=0 TO 31
      GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(divbi&(0,26,16),ADD(8,SHL(i%,1))),divbi&(1,26,16),1,ABS(SGN(FN track_onoff(i%))) XOR 1)
      GOSUB cadre_texte(STR$(SUCC(i%)),ADD(divbi&(0,27,16),ADD(SHL(i%,1),8)),divbi&(1,27,16),1)
    NEXT i%
    GOSUB affiche_icones_commande
    ON ss_menu% GOSUB affiche_icones_disk,affiche_icones_tools,affiche_icones_instr,affiche_icones_sample,affiche_icones_enveloppe,affiche_icones_control,affiche_icones_midi
    GOSUB affiche_cadre_voies
    GOSUB affiche_info_song
    GOSUB affiche_info_sample
    GOSUB affiche_info_preset
    GOSUB affiche_barre_info
    GOSUB affchaine_trans("CPU",144,142,10)
    IF play%=0
      debut_temps%=TIMER
    ENDIF
    GOSUB affiche_temps
    SHOWM
    GOSUB bee(FALSE)
  ELSE
    GOSUB affiche_panneau_sample
    IF NOT se.pas_sous_menu!
      ON ss_menu% GOSUB affiche_icones_disk,affiche_icones_tools,affiche_icones_instr,affiche_icones_sample,affiche_icones_enveloppe,affiche_icones_control,affiche_icones_midi
    ENDIF
  ENDIF
RETURN
PROCEDURE affiche_please_register
  GOSUB dialog("SHAREWARE","This is a demonstration version of|GRAOUMF TRACKER. If you like it or|if you use it frequently, please|register to get the complete version.|See documentation for more details.","Please register soon",MOUSEX,MOUSEY)
RETURN
PROCEDURE affiche_graoumf_logo
  LOCAL high%,nbr_l%,nbr_h%,width%,x_logo%,x_cpt%,x_offset%,y_logo%,y_cpt%,y_offset%
  IF LEN(graoumf_logo$)>0
    nbr_l%=DIV(scr_larg%,320)
    nbr_h%=DIV(scr_haut%,120)
    width%=DIV(scr_larg%,nbr_l%)
    high%=DIV(scr_haut%,nbr_h%)
    x_offset%=SHR(SUB(width%,320),1)
    y_offset%=SHR(SUB(high%,120),1)
    FOR y_cpt%=0 TO PRED(nbr_h%)
      FOR x_cpt%=0 TO PRED(nbr_l%)
        x_logo%=ADD(MUL(x_cpt%,width%),x_offset%)
        y_logo%=ADD(MUL(y_cpt%,high%),y_offset%)
        IF ADD(y_logo%,120)<160 OR y_logo%>=ADD(170,MUL(haut_lig%,6))
          GOSUB affiche_one_graoumf_logo(x_logo%,y_logo%)
        ENDIF
      NEXT x_cpt%
    NEXT y_cpt%
  ENDIF
RETURN
PROCEDURE affiche_one_graoumf_logo(x_logo%,y_logo%)
  LOCAL adr_ecran%,adr_logo%,adr_mask%,lig%
  IF LEN(graoumf_logo$)>0
    adr_ecran%=XBIOS(2)
    adr_logo%=V:graoumf_logo$
    adr_mask%=V:graoumf_logo_mask$
    FOR lig%=0 TO 119
      RC_COPY adr_mask%,0,0,320,1 TO adr_ecran%,x_logo%,y_logo%,4
      RC_COPY adr_logo%,0,0,320,1 TO adr_ecran%,x_logo%,y_logo%,7
      ADD adr_mask%,160
      ADD adr_logo%,160
      INC y_logo%
    NEXT lig%
  ENDIF
RETURN
PROCEDURE affiche_panneau_progression(mes$,p_len%,x%,y%)
  ' mes$: Titre de la boite de progression
  ' p_len%: valeur maximum de la variable de progression
  ' x%, y%: coordonnees de la boite (car, pix). -1 = milieu de l'ecran
  LOCAL box_width%,box_height%
  '
  box_width%=MAX(ADD(LEN(mes$),2),32)
  box_height%=30                                ! 4 +6 +4 +6*2 +4
  IF x%<0
    x%=SHR(SUB(scr_ncol%,box_width%),1)
  ENDIF
  IF y%<0
    y%=SHR(SUB(scr_haut%,box_height%),1)
  ENDIF
  x%=MAX(MIN(x%,SUB(scr_ncol%,box_width%)),0)
  y%=MAX(MIN(y%,SUB(scr_haut%,box_height%)),0)
  progression_xpos%=x%
  progression_ypos%=y%
  progression_width%=SHL(SUB(box_width%,2),3)
  progression_len%=p_len%
  progression_oldval%=-1
  '
  GOSUB cadre_o_int(x%,y%,PRED(box_width%),PRED(box_height%),9,9,10,8)
  GOSUB cadre_ext(SUCC(x%),ADD(y%,14),SUB(box_width%,3),11,9,9,8,10)
  GOSUB affchaine_trans(mes$,SHL(SUCC(x%),1),ADD(y%,4),8)
  GOSUB affiche_progression(0)
RETURN
PROCEDURE affiche_progression(newval%)
  ' newval entre 0 et progression_len%
  '
  LOCAL i%,oldpos%,newpos%,carxpos%,pixxpos%,pixypos%,pixypos2%
  '
  IF progression_oldval%<0
    oldpos%=-1
  ELSE
    oldpos%=progression_oldval%*progression_width%/progression_len%
  ENDIF
  newpos%=newval%*progression_width%/progression_len%
  IF newpos%>oldpos%
    oldpos%=MAX(SUCC(oldpos%),0)
    carxpos%=SHL(ADD(SUCC(progression_xpos%),SHR(oldpos%,3)),1)
    pixxpos%=ADD(oldpos% AND 7,16)
    pixypos%=ADD(progression_ypos%,14)
    pixypos2%=ADD(pixypos%,6)
    FOR i%=oldpos% TO newpos%
      GOSUB affchaine_trans(CHR$(pixxpos%),carxpos%,pixypos%,8)
      GOSUB affchaine_trans(CHR$(pixxpos%),carxpos%,pixypos2%,8)
      INC pixxpos%
      IF pixxpos%>23
        SUB pixxpos%,8
        ADD carxpos%,2
      ENDIF
    NEXT i%
  ENDIF
  progression_oldval%=MAX(newval%,progression_oldval%)
RETURN
'
' Chargements/sauvegardes/disk
' ----------------------------
PROCEDURE save_sample(buf!)
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_sample$<>""
      a$=npath_sample$+nfile_sample$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE SAMPLE",0,0,PRED(scr_ncol%))
      FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING SAMPLE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_sample2(buf!)
      IF erreur%=0
        GOSUB separe_nom_chemin(a$)
        nfile_sample$=nfile_$
        npath_sample$=npath_$
      ENDIF
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_sample2(buf!)
  ' Fournir a$ nom du sample, sample% numero du sample
  LOCAL a%,b$,i%,j%,k%,lon%,signe%
  erreur%=0
  warning%=0
  GOSUB bee(TRUE)
  IF NOT buf!
    lon%=FN length(sample%)
  ELSE
    lon%=mark_len%
  ENDIF
  IF lon%>0
    OPEN "o",#0,a$
    SEEK #0,0
    IF next_sample$="*.SPL"
      signe%=128
    ELSE
      signe%=signe_sam%
    ENDIF
    IF next_sample$="*.AVR"
      ' Entete du format .AVR
      GOSUB separe_nom_chemin(a$)       ! Recupere le nom
      b$=LEFT$(nfile_$,8)
      IF INSTR(b$,".")>1
        b$=LEFT$(b$,PRED(INSTR(b$,".")))
        IF LEN(b$)<8
          b$=b$+STRING$(SUB(8,LEN(b$)),0)
        ENDIF
      ENDIF
      IF NOT buf!
        b$="2BIT"+b$+MKI$(0)+MKI$(SHL(FN resol(sample%),3))+MKI$(signe%=0)
        IF FN repeat(sample%)>0 OR FN replen(sample%)>2
          b$=b$+MKI$(-1)+MKI$(-1)+MKI$(&HFF00)+MKI$(FN freqech(sample%))+MKL$(DIV(lon%,FN resol(sample%)))+MKL$(DIV(FN repeat(sample%),FN resol(sample%)))+MKL$(DIV(ADD(FN repeat(sample%),FN replen(sample%)),FN resol(sample%)))
        ELSE
          b$=b$+MKI$(0)+MKI$(-1)+MKI$(&HFF00)+MKI$(FN freqech(sample%))+MKL$(DIV(lon%,FN resol(sample%)))+MKL$(0)+MKL$(0)
        ENDIF
      ELSE
        b$="2BIT"+b$+MKI$(0)+MKI$(SHL(win_bits%,3))+MKI$(signe%=0)
        b$=b$+MKI$(0)+MKI$(-1)+MKI$(&HFF00)+MKI$(freq_buffer%)+MKL$(DIV(lon%,win_bits%))+MKL$(0)+MKL$(0)
      ENDIF
      b$=b$+"This sample passed through GRAOUMF TRACKER (c) Laurent de Soras"
      b$=b$+STRING$(SUB(128,LEN(b$)),0)
      BPUT #0,V:b$,128
    ENDIF
    ' Sauvegarde des donnees du sample
    b$=STRING$(1024,0)  ! Buffer de signature
    i%=0
    IF NOT buf!
      k%=FN resol(sample%)
    ELSE
      k%=win_bits%
    ENDIF
    REPEAT
      j%=MIN(1024,SUB(lon%,i%))
      IF NOT buf!
        BMOVE ADD(FN adresse(sample%),i%),V:b$,j%*(-flag_registered2!)    ! *** 2eme protection
      ELSE
        BMOVE ADD(ADD(FN adr_buffer,mark_1%),i%),V:b$,j%*(-flag_registered2!)    ! *** 2eme protection
      ENDIF
      IF signe%<>0
        a%=V:b$
        ~C:g_signe_sample%(L:a%,L:j%,W:k%)
      ENDIF
      BPUT #0,V:b$,j%
      ADD i%,j%
    UNTIL i%=>lon%
    CLOSE #0
  ENDIF
RETURN
PROCEDURE load_sample(buf!)
  LOCAL a$
  IF km%=2 AND nfile_sample$<>""
    a$=npath_sample$+nfile_sample$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD SAMPLE",0,0,PRED(scr_ncol%))
    FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING SAMPLE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB load_sample2(buf!)
      IF erreur%=0
        GOSUB separe_nom_chemin(a$)
        nfile_sample$=nfile_$
        npath_sample$=npath_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  SELECT erreur%
  CASE 1
    GOSUB dialog("FILE","Error:|Not enough memory|to load this sample!","Cancel",MOUSEX,MOUSEY)
  CASE 2
    GOSUB dialog("FILE","Error:|Unknown format version.","Cancel",MOUSEX,MOUSEY)
  ENDSELECT
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE load_sample2(buf!)
  ' Fournir a$ nom du sample, sample% numero du sample
  LOCAL adsam%,freq%,lonfic%,lonsam%,res%,signe%
  LOCAL buffer$
  ~FRE(0)
  GOSUB bee(TRUE)
  IF NOT buf!
    GOSUB chg_taille_sample(sample%,0)
  ENDIF
  erreur%=0
  warning%=0
  res%=FN resol(sample%)
  freq%=FN freqech(sample%)
  signe%=signe_sam%
  buffer$=STRING$(128,0)
  OPEN "i",#0,a$
  lonfic%=LOF(#0)                               ! Taille du fichier
  BGET #0,V:buffer$,MIN(LOF(#0),128)
  ' Compacte ? Si, oui, cherche la vraie longueur
  IF LEFT$(buffer$,4)="ATM5"
    lonsam%=LONG{ADD(V:buffer$,4)}
  ELSE IF LEFT$(buffer$,4)="Ice!"
    lonsam%=LONG{ADD(V:buffer$,4)}
  ELSE IF LEFT$(buffer$,4)="ICE!"
    lonsam%=LONG{ADD(V:buffer$,8)}
  ELSE IF LEFT$(buffer$,4)="SPv3"
    lonsam%=LONG{ADD(V:buffer$,12)}
  ELSE
    lonsam%=LOF(#0)
  ENDIF
  IF (buf! AND lonsam%<mark_len%) OR (NOT buf! AND MAX(lonsam%,lonfic%)<FN zone_free)          ! Assez de memoire pour charger ?
    IF NOT buf!
      GOSUB chg_taille_sample(sample%,SUCC(MAX(lonsam%,lonfic%)) AND -2)
      adsam%=FN adresse(sample%)
    ELSE
      adsam%=FN adr_buffer+mark_1%
    ENDIF
    SEEK #0,0
    BGET #0,adsam%,lonfic%
    ~C:g_atomic_35_unpack%(L:adsam%)
    ~C:g_packice_21_unpack%(L:adsam%)
    ~C:g_packice_24_unpack%(L:adsam%)
    ~C:g_speedpacker_unpack%(L:adsam%)
    BMOVE adsam%,V:buffer$,MIN(lonsam%,128)
    IF LONG{adsam%}=&H32424954                  ! '2BIT' : Format AVR
      GOSUB load_sample_avr(buf!)
    ELSE IF LONG{adsam%}=&H52494646             ! 'RIFF' : Format WAV
      GOSUB load_sample_wav(buf!)
    ELSE IF LEFT$(buffer$,19)="Creative Voice File"     ! Format VOC
      GOSUB load_sample_voc(buf!)
    ELSE                                        ! Format inconnu : donnees brutes
      GOSUB load_sample_raw(buf!)
    ENDIF
  ELSE
    erreur%=1                                   ! Pas assez de memoire pour charger le fichier
  ENDIF
  CLOSE #0
  IF NOT buf!
    IF erreur%=0
      ~C:rr_boucle_sample%(W:sample%)
    ELSE
      GOSUB kill_sample(sample%)
    ENDIF
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_sample_raw(buf!)
  ' Besoin (Load_Sample2): a$, freq%, res%, signe%, adsam% et lonsam%
  LOCAL len%
  LOCAL b$
  len%=lonsam% AND -2
  GOSUB chg_sam_balance(sample%,&HFFFF)
  GOSUB chg_sam_volume(sample%,&H100)
  GOSUB chg_sam_finetune(sample%,0)
  GOSUB chg_sam_length(sample%,len%)
  GOSUB chg_sam_repeat(sample%,0)
  GOSUB chg_sam_replen(sample%,2)
  IF len%>0
    IF (NOT buf!)
      a%=FN adresse(sample%)
    ELSE
      a%=FN adr_buffer+mark_1%
    ENDIF
    IF signe%<>0 OR next_sample$="*.SPL"
      ~C:g_signe_sample%(L:a%,L:len%,W:res%)            ! Signature
    ENDIF
  ENDIF
  IF (NOT buf!)
    GOSUB chg_taille_sample(sample%,len%)
  ELSE
    mark_2%=ADD(mark_1%,len%)
  ENDIF
  b$=a$
  WHILE INSTR(b$,"\")>0
    a%=INSTR(b$,"\")
    b$=RIGHT$(b$,SUB(LEN(b$),a%))
  WEND
  IF NOT buf!
    GOSUB chg_samplename(b$,sample%)
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_sample_avr(buf!)
  ' Besoin (Load_Sample2): a$, adsam% et lonsam%
  ' Change (Load_Sample2): freq%, res%, signe%
  LOCAL a%,b%,c%,len%,loop%,rep_avr%,rep2_avr%,stereo%
  LOCAL b$
  res%=MAX(MIN(SHR(CARD{ADD(adsam%,14)},3),2),1)        ! Nbr d'octets/sample
  a%=CARD{ADD(adsam%,12)}
  IF a%=0
    stereo%=1
  ELSE
    stereo%=2
  ENDIF
  freq%=MAX(CARD{ADD(adsam%,24)},2000)                  ! Frequence d'echantillonnage du sample
  signe%=128
  IF CARD{ADD(adsam%,16)}<>0
    signe%=0
  ENDIF
  len%=MAX(0,MIN(MUL(LONG{ADD(adsam%,&H1A)},MUL(res%,stereo%)),SUB(lonsam%,128)) AND -2)
  rep_avr%=MUL(LONG{ADD(adsam%,&H1E)},MUL(res%,stereo%)) AND -2
  rep2_avr%=MUL(LONG{ADD(adsam%,&H22)},MUL(res%,stereo%)) AND -2
  loop%=CARD{ADD(adsam%,18)}
  IF stereo%<>1                                 ! Stereo
    GOSUB dialog("STEREO","Sample stereo.|What must I load ?","Left|Right|Mix|Cancel",MOUSEX,MOUSEY)
    IF bouton%=3                                ! Cancel
      IF NOT buf!
        GOSUB chg_taille_sample(sample%,0)
      ENDIF
      GOTO fin_load_sample_avr
    ENDIF
    GOSUB bee(TRUE)
    len%=len% AND -4
    a%=ADD(adsam%,128)
    b%=a%
    IF bouton%=0                                ! 1 seul canal: gauche
      ~C:g_stereo_2_mono_one%(L:b%,L:a%,L:len%,W:res%)
    ELSE IF bouton%=1                           ! 1 seul canal: droit
      ADD b%,res%
      ~C:g_stereo_2_mono_one%(L:b%,L:a%,L:len%,W:res%)
    ELSE                                        ! Mixage des deux canaux
      ~C:g_stereo_2_mono_ave%(L:b%,L:a%,L:len%,W:res%)
    ENDIF
    len%=SHR(len%,1)
  ENDIF
  IF NOT buf!
    a%=FN adresse(sample%)
  ELSE
    a%=adsam%
  ENDIF
  BMOVE ADD(adsam%,128),a%,len%
  IF NOT buf!
    GOSUB chg_taille_sample(sample%,len%)
  ELSE
    mark_2%=ADD(mark_1%,len%)
  ENDIF
  IF signe%<>0
    ~C:g_signe_sample%(L:a%,L:len%,W:res%)      ! Signature
  ENDIF
  rep_avr%=MAX(0,MIN(SUB(len%,2),rep_avr%))
  IF NOT buf!
    GOSUB chg_sam_balance(sample%,&HFFFF)
    GOSUB chg_sam_nbits(sample%,res%)
    GOSUB chg_sam_freq(sample%,freq%)
    GOSUB chg_sam_volume(sample%,&H100)
    GOSUB chg_sam_finetune(sample%,0)
    GOSUB chg_sam_length(sample%,len%)
    IF loop%=0                                    ! Non boucle
      GOSUB chg_sam_repeat(sample%,0)
      GOSUB chg_sam_replen(sample%,2)
    ELSE                                          ! Boucle
      GOSUB chg_sam_repeat(sample%,rep_avr%)
      GOSUB chg_sam_replen(sample%,MAX(SUB(rep2_avr%,rep_avr%),2))
    ENDIF
  ELSE
    freq_buffer%=freq%
  ENDIF
  IF NOT buf!
    ' Le nom
    b$=a$
    WHILE INSTR(b$,"\")>0
      a%=INSTR(b$,"\")
      b$=RIGHT$(b$,SUB(LEN(b$),a%))
    WEND
    GOSUB chg_samplename(b$,sample%)
  ENDIF
fin_load_sample_avr:
  ~FRE(0)
RETURN
PROCEDURE load_sample_wav(buf!)
  ' Besoin (Load_Sample2): a$, adsam% et lonsam%
  ' Change (Load_Sample2): freq%, res%
  ' *** Ne tient pas compte exactement de la structure en chunks
  LOCAL a%,b%,len%,nchannels%
  LOCAL b$
  GOSUB intel_l(ADD(adsam%,24))
  GOSUB intel_l(ADD(adsam%,40))
  GOSUB intel_w(ADD(adsam%,22))
  GOSUB intel_w(ADD(adsam%,34))
  nchannels%=CARD{ADD(adsam%,34)}
  res%=SHR(CARD{ADD(adsam%,34)},3)
  len%=MAX(MIN(LONG{ADD(adsam%,40)},SUB(lonsam%,44)),0) AND -2
  freq%=LONG{ADD(adsam%,24)}
  ncanal%=0
  IF NOT buf!
    GOSUB chg_sam_balance(sample%,&HFFFF)
    GOSUB chg_sam_nbits(sample%,res%)
    GOSUB chg_sam_freq(sample%,freq%)
    GOSUB chg_sam_volume(sample%,&H100)
    GOSUB chg_sam_finetune(sample%,0)
    GOSUB chg_sam_length(sample%,len%)
    GOSUB chg_sam_repeat(sample%,0)
    GOSUB chg_sam_replen(sample%,2)
  ELSE
    freq_buffer%=freq%
  ENDIF
  IF len%>0
    IF NOT buf!
      a%=FN adresse(sample%)
    ELSE
      a%=adsam%
    ENDIF
    BMOVE ADD(adsam%,44),a%,len%
    IF res%=2                      ! 16 bits
      ~C:g_intel_16_bits%(L:a%,L:len%)
    ENDIF
    IF res%=1
      ~C:g_signe_sample%(L:a%,L:len%,W:res%)    ! Signature seulement pour le 8 bits
    ENDIF
    IF nchannels%=2                             ! Stereo
      GOSUB dialog("STEREO","Sample stereo.|What must I load ?","Left|Right|Mix|Cancel",MOUSEX,MOUSEY)
      IF bouton%=3                              ! Cancel
        IF NOT buf!
          GOSUB chg_taille_sample(sample%,0)
        ENDIF
        GOTO fin_load_sample_wav
      ENDIF
      GOSUB bee(TRUE)
      len%=len% AND -4
      b%=adsam%
      IF bouton%=0                              ! 1 seul canal: gauche
        ~C:g_stereo_2_mono_one%(L:b%,L:adsam%,L:len%,W:res%)
      ELSE IF bouton%=1                         ! 1 seul canal: droit
        ADD b%,res%
        ~C:g_stereo_2_mono_one%(L:b%,L:adsam%,L:len%,W:res%)
      ELSE                                      ! Mixage des deux canaux
        ~C:g_stereo_2_mono_ave%(L:b%,L:adsam%,L:len%,W:res%)
      ENDIF
      len%=SHR(len%,1)
    ENDIF
  ENDIF
  IF NOT buf!
    GOSUB chg_taille_sample(sample%,len%)
  ELSE
    mark_2%=ADD(mark_1%,len%)
  ENDIF
  ' Le nom
  IF NOT buf!
    b$=a$
    WHILE INSTR(b$,"\")>0
      a%=INSTR(b$,"\")
      b$=RIGHT$(b$,SUB(LEN(b$),a%))
    WEND
    GOSUB chg_samplename(b$,sample%)
  ENDIF
fin_load_sample_wav:
  ~FRE(0)
RETURN
PROCEDURE load_sample_voc(buf!)
  ' Besoin (Load_Sample2): a$, adsam% et lonsam%
  ' Change (Load_Sample2): signe%, freq%, res%
  ' *** Attention, gere tres incompletement le type 9 (pas de stereo)
  LOCAL i%,total_len%,total_len2%,offset%,adr_block%,type%,sect_nbr%
  LOCAL block_len%,block_adr%,new_block_adr%
  LOCAL sname$,offset$,size$
  LOCAL ok!,first!
  IF BYTE{ADD(adsam%,23)}=1                     ! Pourquoi ???
    GOSUB intel_w(ADD(adsam%,20))
    offset%=CARD{ADD(adsam%,20)}
    '
    ' Cherche la taille du sample et des differents blocs qui le composent
    '
    signe%=0
    adr_block%=ADD(adsam%,offset%)
    total_len%=0                                ! La longueur finale du sample
    sect_nbr%=0
    sname$=""
    offset$=""
    size$=""
    type$=""
    ok!=TRUE
    first!=TRUE
    REPEAT
      type%=BYTE{adr_block%}
      INC adr_block%
      type$=type$+CHR$(type%)
      SELECT type%
      CASE 0
        ok!=FALSE
      CASE 1,2                                  ! Bloc de donnees
        GOSUB intel_3(adr_block%)
        block_len%=SHR(LONG{adr_block%},8)
        ADD adr_block%,3
        IF type%=1
          IF first!
            freq%=DIV(1000000,SUB(256,BYTE{adr_block%}))
            first!=FALSE
          ENDIF
          ADD adr_block%,2
          SUB block_len%,2
        ENDIF
        offset$=offset$+MKL$(SUB(adr_block%,adsam%))
        size$=size$+MKL$(block_len%)
        INC sect_nbr%
        ADD total_len%,block_len%
        ADD adr_block%,block_len%
      CASE 3                                    ! Blanc
        block_len%=SHR(LONG{adr_block%},8)
        ADD adr_block%,6
        offset$=offset$+MKL$(total_len%)
        size$=size$+MKL$(block_len%)
        INC sect_nbr%
        ADD total_len%,block_len%
      CASE 5                                    ! Le nom
        GOSUB intel_3(adr_block%)
        block_len%=SHR(LONG{adr_block%},8)
        ADD adr_block%,3
        sname$=STRING$(block_len%,0)
        BMOVE adr_block%,V:sname$,block_len%
        ADD adr_block%,block_len%
      CASE 9                                    ! *** Flou total...
        GOSUB intel_3(adr_block%)
        block_len%=SUB(SHR(LONG{adr_block%},8),12)
        ADD adr_block%,3
        GOSUB intel_w(adr_block%)
        freq%=CARD{adr_block%}
        res%=SHR(BYTE{ADD(adr_block%,4)},3)
        ' Nombre de voies en + 05.b ?
        signe%=BTST(BYTE{ADD(adr_block%,6)},2)
        ADD adr_block%,12
        offset$=offset$+MKL$(SUB(adr_block%,adsam%))
        size$=size$+MKL$(block_len%)
        INC sect_nbr%
        ADD total_len%,block_len%
        ADD adr_block%,block_len%
      ENDSELECT
    UNTIL (NOT ok!) OR adr_block%>=ADD(adsam%,lonsam%)
    total_len%=total_len% AND -2
    '
    ' Recompose correctement le sample
    '
    IF NOT buf!
      GOSUB chg_sam_balance(sample%,&HFFFF)
      GOSUB chg_sam_nbits(sample%,res%)
      GOSUB chg_sam_freq(sample%,freq%)
      GOSUB chg_sam_volume(sample%,&H100)
      GOSUB chg_sam_finetune(sample%,0)
      GOSUB chg_sam_length(sample%,total_len%)
      GOSUB chg_sam_repeat(sample%,0)
      GOSUB chg_sam_replen(sample%,2)
    ELSE
      freq_buffer%=freq%
    ENDIF
    IF total_len%>0
      IF total_len%>lonsam%
        IF NOT buf!
          GOSUB chg_taille_sample(sample%,total_len%)
        ENDIF
      ENDIF
      ' Passe 1: On ne garde que les donnees brutes
      new_block_adr%=adsam%
      FOR i%=0 TO PRED(sect_nbr%)
        SELECT BYTE{ADD(V:type$,i%)}
        CASE 1,2,9
          block_adr%=ADD(adsam%,LONG{ADD(V:offset$,SHL(i%,2))})
          block_len%=LONG{ADD(V:size$,SHL(i%,2))}
          block_len%=MIN(block_len%,SUB(ADD(adsam%,total_len%),new_block_adr%)) ! Si on a arrondi total_len%, ne pas depasser!
          BMOVE block_adr%,new_block_adr%,block_len%
          ADD new_block_adr%,block_len%
        ENDSELECT
      NEXT i%
      ' Passe 2: On insere les blancs s'il y en a
      FOR i%=0 TO PRED(sect_nbr%)
        SELECT BYTE{ADD(V:type$,i%)}
        CASE 3
          block_adr%=ADD(adsam%,LONG{ADD(V:offset$,SHL(i%,2))})
          new_block_adr%=ADD(block_adr%,LONG{ADD(V:size$,SHL(i%,2))})
          block_len%=SUB(ADD(adsam%,total_len%),new_block_adr%)
          IF block_len%>0
            BMOVE block_adr%,new_block_adr%,block_len%
            GOSUB clear_mem(block_adr%,SUB(new_block_adr%,block_adr%))
          ENDIF
        ENDSELECT
      NEXT i%
      IF res%=2                    ! 16 bits
        ~C:g_intel_16_bits%(L:adsam%,L:total_len%)
      ENDIF
      IF signe%=0                               ! Signature
        ~C:g_signe_sample%(L:adsam%,L:total_len%,W:res%)
      ENDIF
    ENDIF
    IF total_len%<lonsam%
      IF NOT buf!
        GOSUB chg_taille_sample(sample%,total_len%)
      ELSE
        mark_2%=ADD(mark_1%,total_len%)
      ENDIF
    ENDIF
    ' Le nom
    IF NOT buf!
      IF LEN(sname$)>0
        GOSUB chg_samplename(sname$,sample%)
      ELSE
        b$=a$
        WHILE INSTR(b$,"\")>0
          a%=INSTR(b$,"\")
          b$=RIGHT$(b$,SUB(LEN(b$),a%))
        WEND
        GOSUB chg_samplename(b$,sample%)
      ENDIF
    ENDIF
  ELSE
    erreur%=2
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE save_module
  LOCAL time_taken%,erreur%
  LOCAL a$
  erreur%=0
  IF flag_registered!
    IF km%=2 AND nfile_module$<>""
      a$=npath_module$+nfile_module$
    ELSE
      CLS
      IF next_module$="*.MOD"
        GOSUB cadre_texte("EXPORT MODULE .MOD",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.MOD",nfile_module$,a$
      ELSE IF next_module$="*.S3M"
        GOSUB cadre_texte("EXPORT MODULE .S3M",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.S3M",nfile_module$,a$
      ELSE IF next_module$="*.GTK"
        GOSUB cadre_texte("SAVE OLD MODULE",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.GTK",nfile_module$,a$
      ELSE
        GOSUB cadre_texte("SAVE MODULE",0,0,PRED(scr_ncol%))
        FILESELECT npath_module$+"*.GT2",nfile_module$,a$
      ENDIF
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : BACK UP OF THE MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      IF flag_backup_modules!
        e%=FN backup_file(a$)
        IF e%<0
          GOSUB dialog("ERROR","Error during the backup of the file|"+a$,"Continue",MOUSEX,MOUSEY)
        ENDIF
      ENDIF
      CLS
      GOSUB cadre_texte("WAITING : SAVING MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB rec_result("Saving module "+a$+"...",TRUE)
      time_taken%=TIMER
      GOSUB save_module2
      time_taken%=SUB(TIMER,time_taken%)
      GOSUB separe_nom_chemin(a$)
      nfile_module$=nfile_$
      npath_module$=npath_$
    ENDIF
    SELECT erreur%
    CASE 0
      GOSUB rec_result("Complete. Time for saving: "+FN time_hmsd$(time_taken%),TRUE)
    CASE -1
      GOSUB rec_result("Error: Disk full"+STR$(erreur%),TRUE)
      GOSUB dialog("FILE","Error:|Disk full","Cancel",MOUSEX,MOUSEY)
    DEFAULT
      GOSUB rec_result("Disk error: "+STR$(erreur%),TRUE)
      GOSUB dialog("FILE","Error:|"+STR$(erreur%),"Cancel",MOUSEX,MOUSEY)
    ENDSELECT
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_module2
  ' Fournir a$ nom du module
  LOCAL i%,a%
  LOCAL handle_fichier%,code_erreur_fichier%
  LOCAL filename$
  ~FRE(0)
  erreur%=0
  warning%=0
  GOSUB bee(TRUE)
  module&(1)=ADD(&H4B00,gtk_file_vnum%)
  filename$=a$+CHR$(0)
  handle_fichier%=GEMDOS(60,L:V:filename$,W:0)
  IF handle_fichier%>=0
    IF next_module$="*.MOD"
      GOSUB save_module_mod
    ELSE IF next_module$="*.S3M"
      GOSUB save_module_s3m
    ELSE IF next_module$="*.GTK"
      GOSUB save_module_gtk
    ELSE
      GOSUB save_module_gt2
    ENDIF
    code_erreur_fichier%=GEMDOS(62,W:handle%)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
    ENDIF
  ELSE
    erreur%=handle_fichier%
  ENDIF
  GOSUB bee(FALSE)
RETURN
PROCEDURE save_module_gt2
  ' Variables utilisees pour la sauvegarde:
  ' handle_fichier%, code_erreur_fichier%, erreur%
  LOCAL a%,i%,j%,nbs%,nbi%,nbe%,total_len%
  LOCAL loopend1%,loopend2%
  LOCAL ok!
  LOCAL a$,chk$,lsam$,lins$,lenv$
  ~FRE(0)
  GOSUB rec_result("  Saving in GT2 format (Graoumf Tracker module).",TRUE)
  '
  ' Travail preparatoire
  '
  ' Recherche les samples et les instruments utilises
  GOSUB rec_result("  Instruments used... ",FALSE)
  lsam$=STRING$(256,0)
  lins$=STRING$(256,0)
  a%=C:g_find_used_samples_and_instruments%(L:r_adr_sample%,L:V:instrset%(0,0),L:V:lsam$,L:V:lins$)
  nbi%=a% AND &HFFFF
  nbs%=SWAP(a%) AND &HFFFF
  GOSUB rec_result(STR$(nbi%)+".",TRUE)
  GOSUB rec_result("  Samples used... ",FALSE)
  GOSUB rec_result(STR$(nbs%)+".",TRUE)
  ' Recherche des enveloppes utilisees
  GOSUB rec_result("  Envelopes used:... ",FALSE)
  lenv$=STRING$(192,0)
  nbe%=0
  FOR i%=1 TO 63
    FOR j%=0 TO 2                       ! Critere : longueur d'une section > 1
      IF FN env_sectlen(i%,j%,0)>1 OR FN env_sectlen(i%,j%,1)>1
        BYTE{ADD(V:lenv$,ADD(MUL(i%,3),j%))}=1
        INC nbe%
      ENDIF
    NEXT j%
  NEXT i%
  GOSUB rec_result(STR$(nbe%)+".",TRUE)
  '
  ' Chunk d'informations generales
  '
  GOSUB rec_result("  Saving header chunk... ",FALSE)
  a$=DATE$
  a%=FN mod_tempo                       ! Tempo
  chk$="GT2"+CHR$(gt2_file_vnum%)+MKL$(0)+FN songname$+FN songcomment$
  chk$=chk$+CHR$(VAL(LEFT$(a$,2)))+CHR$(VAL(MID$(a$,4,2)))+MKI$(VAL(RIGHT$(a$,4)))
  chk$=chk$+"Graoumf Tracker v"+STR$(gtk_version%/10000)        ! Nom du Tracker
  chk$=chk$+SPACE$(SUB(228,LEN(chk$)))
  chk$=chk$+MKI$(CARD{r_mod_speed%})+MKI$(a%)+MKI$(CARD{r_master_vol%})+MKI$(nbr_track%)
  FOR i%=0 TO PRED(nbr_track%)                                  ! Les balances
    chk$=chk$+MKI$(CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,i%))})
  NEXT i%
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunk des volumes des pistes
  '
  GOSUB rec_result("  Saving track volume chunk... ",FALSE)
  chk$="TVOL"+MKL$(0)+MKI$(nbr_track%)
  FOR i%=0 TO PRED(nbr_track%)
    chk$=chk$+MKI$(FN track_volume_lin(i%))
  NEXT i%
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunk de configuration du tracker
  '
  IF flag_gt2cnf!
    GOSUB rec_result("  Saving config. chunk... ",FALSE)
    chk$="TCN1"+MKL$(2660)+MKI$(0)+MKI$(songpos%)+MKI$(posligne%)+MKI$(n_preset%)
    chk$=chk$+MKI$(type_affpiste%)+MKI$(curs_col%)+MKI$(curs_x%)+MKI$(ADD(play%,SHL(edit%,2)))
    chk$=chk$+MKI$(octave%)+MKI$(line_step%)+MKI$(instr%)+MKI$(sample%)
    FOR i%=0 TO 31
      chk$=chk$+MKI$(nbr_colonnes%(i%))
    NEXT i%
    FOR i%=0 TO 31
      chk$=chk$+SPACE$(16)                      ! *** Faire de vrais noms
    NEXT i%
    a$=STRING$(2048,0)
    BMOVE V:preset&(0,0),V:a$,2048
    chk$=chk$+a$
    a%=0
    FOR i%=0 TO 31
      IF FN track_onoff(i%)<>0
        a%=a% OR SHL(1,i%)
      ENDIF
    NEXT i%
    chk$=chk$+MKL$(a%)
    LONG{ADD(V:chk$,4)}=LEN(chk$)
    code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_gt2_erreur
    ENDIF
    GOSUB rec_result("done.",TRUE)
  ENDIF
  '
  ' Chunk de sequence de patterns
  '
  GOSUB rec_result("  Saving song chunk... ",FALSE)
  chk$="SONG"+MKL$(ADD(FN song_length,12))+MKI$(FN song_length)+MKI$(FN song_repeat)
  FOR i%=0 TO PRED(FN song_length)
    chk$=chk$+MKI$(song&(i%))
  NEXT i%
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunk d'ensemble de patterns
  '
  GOSUB rec_result("  Saving pattern chunks... ",FALSE)
  chk$="PATS"+MKL$(12)+MKI$(nbr_track%)+MKI$(SUCC(FN last_pat_util))
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  '
  ' Chunks des patterns
  '
  loopend1%=FN last_pat_util
  i%=0
  WHILE i%<=loopend1%
    a%=MAX(FN adr_patchunk(i%)*(-flag_registered2!),&H1498)     ! A cause de la 2eme protection
    code_erreur_fichier%=FN fwrite(handle_fichier%,FN lon_patchunk(i%),a%)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_gt2_erreur
    ENDIF
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunk d'ensemble d'instruments
  '
  GOSUB rec_result("  Saving instrument chunks... ",FALSE)
  chk$="ORCH"+MKL$(10)+MKI$(nbi%)
  LONG{ADD(V:chk$,4)}=LEN(chk$)
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  '
  ' Chunks des instruments
  '
  i%=1
  WHILE i%<=255
    IF BYTE{ADD(V:lins$,i%)}<>0
      a%=MAX(V:instrset%(0,i%)*(-flag_registered2!),&H1264)     ! A cause de la 2eme protection
      code_erreur_fichier%=FN fwrite(handle_fichier%,instrset%(1,i%),a%)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_gt2_erreur
      ENDIF
    ENDIF
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunks des samples
  '
  GOSUB rec_result("  Saving sample chunks... ",FALSE)
  i%=1
  WHILE i%<=255
    IF BYTE{ADD(V:lsam$,i%)}<>0
      a%=MAX(FN adrsamchk(i%)*(-flag_registered2!),&H1529)      ! A cause de la 2eme protection
      code_erreur_fichier%=FN fwrite(handle_fichier%,FN lonsamchk(i%),a%)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_gt2_erreur
      ENDIF
    ENDIF
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunks des enveloppes
  '
  GOSUB rec_result("  Saving envelope chunks... ",FALSE)
  i%=1
  WHILE i%<=63
    ' 8776 - attempted correction of envelope bug - /sjx.
    '    j%=2
    j%=0
    WHILE j%<=2
      IF BYTE{ADD(V:lenv$,ADD(MUL(i%,3),j%))}<>0
        ' /sjx - wtf *was* this boobytrap shit, anyway?
        a%=FN env_chunkadr(i%,j%)
        code_erreur_fichier%=FN fwrite(handle_fichier%,FN env_chunklen(i%,j%),a%)
        IF code_erreur_fichier%<0
          erreur%=code_erreur_fichier%
          GOTO sav_module_gt2_erreur
        ENDIF
      ENDIF
      INC j%
    WEND
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Chunk de fin
  '
  GOSUB rec_result("  Saving end chunks... ",FALSE)
  chk$="ENDC"+MKL$(12)+MKL$(0)
  total_len%=0          ! *********** Trouver la vraie longueur!!!
  LONG{ADD(V:chk$,8)}=total_len%
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(chk$),V:chk$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gt2_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
sav_module_gt2_erreur:
  ~FRE(0)
RETURN
PROCEDURE save_module_gtk
  LOCAL a%,i%,j%,nblm%
  LOCAL loopend1%
  LOCAL a$
  GOSUB rec_result("  Saving in GTK format (old Graoumf Tracker module).",TRUE)
  '
  ' Le header du module
  '
  GOSUB rec_result("  Saving module header... ",FALSE)
  nblm%=FN nbr_lines_maxi
  a$=STRING$(206,0)
  BMOVE V:module&(0),V:a$,206
  CARD{ADD(V:a$,198)}=nblm%
  code_erreur_fichier%=FN fwrite(handle_fichier%,206,V:a$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gtk_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les headers des samples
  '
  GOSUB rec_result("  Saving sample headers... ",FALSE)
  j%=1
  loopend1%=module&(98)
  WHILE j%<=loopend1%
    i%=FN isample(j%,48)
    a$=FN samplename$(i%)+STRING$(14,0)+MKI$(FN autobal(i%))+MKI$(FN resol(i%))+MKI$(FN freqech(i%))+MKL$(FN length(i%))+MKL$(FN repeat(i%))+MKL$(FN replen(i%))+MKI$(FN ivolume(j%))+MKI$(FN finetune(i%))
    code_erreur_fichier%=FN fwrite(handle_fichier%,64,V:a$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_gtk_erreur
    ENDIF
    INC j%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Saving song... ",FALSE)
  code_erreur_fichier%=FN fwrite(handle_fichier%,512,V:song&(0))
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_gtk_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Saving patterns... ",FALSE)
  loopend1%=FN last_pat_util
  i%=0
  WHILE i%<=loopend1%
    nbl%=FN nbr_lines(i%)
    a$=STRING$(MIN(MUL(MUL(nbr_track%,nblm%),5),32767),0)
    BMOVE FN adr_pat(i%),V:a$,MUL(MUL(nbr_track%,nbl%),5)
    IF nbl%<nblm%
      CARD{ADD(V:a$,SUB(MUL(MUL(nbr_track%,nbl%),5),3))}=&HD00
    ENDIF
    IF EXP(flag_registered2!)=1                 ! *** 2eme protection
      a$=STRING$(LEN(a$),0)
    ENDIF
    code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(a$),V:a$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_gtk_erreur
    ENDIF
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Les samples
  '
  GOSUB rec_result("  Saving samples... ",FALSE)
  j%=1
  loopend1%=module&(98)
  WHILE j%<=loopend1%
    i%=FN isample(j%,48)
    IF FN length(i%)>0
      a%=MAX(FN adresse(i%)*(-flag_registered2!),&H1895)        ! *** 2eme protection
      code_erreur_fichier%=FN fwrite(handle_fichier%,FN length(i%),a%)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_gtk_erreur
      ENDIF
    ENDIF
    INC j%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
sav_module_gtk_erreur:
  ~FRE(0)
RETURN
PROCEDURE save_module_mod
  ' Sauve un module au format .MOD
  LOCAL a%,b%,c%,d%,e%,i%,i2%,j%,k%,n%,nblm%
  LOCAL ss%,st%
  LOCAL loopend1%,loopend2%
  LOCAL a&,b&
  LOCAL flag_fast!
  LOCAL a$,lig$,sam$,sam2$
  LOCAL mod_header$
  ~FRE(0)
  GOSUB rec_result("  Saving in MOD format (ProTracker module).",TRUE)
  nblm%=FN nbr_lines_maxi
  IF nblm%=64 AND nbr_track%<>4                 ! On doit le sauver au format FastTracker ?
    flag_fast!=TRUE
  ELSE
    flag_fast!=FALSE
  ENDIF
  mod_header$=LEFT$(FN songname$,20)
  mod_header$=mod_header$+SPACE$(SUB(20,LEN(mod_header$)))
  '
  ' Rearrange les samples pour qu'ils puissent tous tenir
  '
  GOSUB rec_result("  Saving sample headers... ",FALSE)
  sam$=STRING$(256,0)                           ! Correspondance des samples pour la conversion des patterns
  sam2$=""
  FOR i%=1 TO 31
    sam2$=sam2$+CHR$(i%)
  NEXT i%
  BMOVE V:sam2$,SUCC(V:sam$),31
  i%=32
  j%=0
  REPEAT
    WHILE FN length(FN isample(BYTE{ADD(V:sam2$,j%)},48))<>0 AND j%<31
      INC j%
    WEND                                        ! On a trouve un emplacement libre
    EXIT IF j%>=31                              ! C'etait le dernier ? On sort alors...
    IF FN length(FN isample(i%,48))>0           ! Si on a un sample >32, on le met la.
      BYTE{ADD(V:sam$,i%)}=SUCC(j%)
      BYTE{ADD(V:sam2$,j%)}=i%
      INC j%
    ENDIF
    INC i%
  UNTIL i%>255
  ss%=MIN(j%,31)
  st%=0
  FOR i%=1 TO 255
    IF FN length(FN isample(BYTE{ADD(V:sam2$,j%)},48))<>0
      INC st%
    ENDIF
  NEXT i%
  '
  ' Sauve les headers de sample
  '
  FOR j%=0 TO 30
    i2%=BYTE{ADD(V:sam2$,j%)}
    i%=FN isample(i2%,48)
    a$=LEFT$(FN samplename$(i%),22)             ! Nom du sample
    a$=a$+SPACE$(SUB(22,LEN(a$)))
    mod_header$=mod_header$+a$
    c%=FN resol(i%)
    a&=MIN(SHR(DIV(FN length(i%),c%),1),&H7FFF) ! Longueur du sample
    mod_header$=mod_header$+MKI$(a&)
    b&=ADD(SHL(FN finetune(i%),8) AND &HF00,SHR(FN ivolume(i2%),2) AND &H7F)    ! Finetune + Volume
    mod_header$=mod_header$+MKI$(b&)
    b&=MAX(MIN(SHR(DIV(FN repeat(i%),c%),1),PRED(a&)),0)        ! Reppos
    mod_header$=mod_header$+MKI$(b&)
    b&=MAX(MIN(SHR(DIV(FN replen(i%),c%),1),SUB(a&,b&)),1)      ! Replen
    mod_header$=mod_header$+MKI$(b&)
  NEXT j%
  IF st%<=ss%
    GOSUB rec_result("done, "+STR$(j%)+"samples.",TRUE)
  ELSE
    GOSUB rec_result("done, for "+STR$(j%)+"samples. "+STR$(SUB(a%,j%))+" samples can't be saved.",TRUE)
  ENDIF
  '
  ' La song
  '
  GOSUB rec_result("  Saving song... ",FALSE)
  a&=ADD(SHL(MIN(module&(101),128),8),MIN(module&(102),127))
  mod_header$=mod_header$+MKI$(a&)              ! Songlen + Songrepeat
  a&=SHR(a&,8)
  b&=0
  a%=0
  FOR i%=0 TO 127               ! La song
    b&=MIN(song&(i%),255)
    IF i%=>a&
      b&=0
    ENDIF
    a%=MAX(a%,b&)
    mod_header$=mod_header$+CHR$(b&)
  NEXT i%
  IF flag_fast!                 ! Format FastTracker
    b%=CVL(LEFT$(STR$(nbr_track%)+"CHN",4))
    mod_header$=mod_header$+MKL$(b%)
    GOSUB rec_result("done. FastTracker '"+MKL$(b%)+"' format.",TRUE)
  ELSE IF nblm%<>64             ! Format MOD Digital Tracker (FAxx)
    b%=CVL("FA"+CHR$(ADD(DIV(nbr_track%,10),48))+CHR$(ADD(nbr_track% MOD 10,48)))
    mod_header$=mod_header$+MKL$(b%)
    c%=SHL(nblm%,16)
    mod_header$=mod_header$+MKL$(c%)
    GOSUB rec_result("done. Digital Tracker '"+MKL$(b%)+"' format.",TRUE)
  ELSE                          ! Format ProTracker standard
    b%=&H4D2E4B2E
    mod_header$=mod_header$+MKL$(b%)
    GOSUB rec_result("done. Standard ProTracker 'M.K.' format.",TRUE)
  ENDIF
  ' Sauve le tout
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(mod_header$),V:mod_header$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_mod_erreur
  ENDIF
  '
  ' Les patterns
  '
  GOSUB rec_result("  Saving patterns... ",FALSE)
  j%=0
  loopend1%=a%
  WHILE j%<=loopend1%                   ! Les patterns
    n%=FN nbr_lines(j%)
    lig$=STRING$(SHL(nbr_track%,2),0)
    b%=FN adr_pat(j%)
    i%=0
    loopend2%=PRED(n%)
    WHILE i%<=loopend2%
      c%=V:lig$
      d%=V:sam$
      e%=MAX(nbr_track%*(-flag_registered2!),1) ! *** 2eme protection
      ~C:g_convert_gtk_2_nt%(L:b%,L:c%,L:d%,W:e%)
      IF i%=PRED(n%) AND n%<nblm%
        CARD{ADD(V:lig$,SUB(SHL(nbr_track%,2),2))}=ADD(CARD{ADD(V:lig$,SUB(SHL(nbr_track%,2),2))} AND &HF000,&HD00)
      ENDIF
      code_erreur_fichier%=FN fwrite(handle_fichier%,SHL(nbr_track%,2),V:lig$)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_mod_erreur
      ENDIF
      ADD b%,MUL(nbr_track%,5)
      INC i%
    WEND
    IF n%<nblm%
      lig$=STRING$(MUL(SHL(nbr_track%,2),SUB(nblm%,n%)),0)
      code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(lig$),V:lig$)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_mod_erreur
      ENDIF
    ENDIF
    INC j%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Les samples
  '
  ' Penser a reechantillonner si besoin est
  GOSUB rec_result("  Saving samples... ",FALSE)
  lig$=STRING$(16384,0)
  j%=0
  WHILE j%<=30                  ! Les samples
    i%=FN isample(BYTE{ADD(V:sam2$,j%)},48)
    a%=MIN(DIV(FN length(i%),FN resol(i%)) AND -2,&HFFFE)
    IF a%>0
      IF FN resol(i%)=2         ! Convertit 16 bits en 8 bits
        k%=0
        REPEAT
          b%=ADD(FN adresse(i%),SHL(k%,1))
          d%=MIN(SHL(SUB(a%,k%) AND -2,1),32768)
          c%=V:lig$
          IF COS(flag_registered2!)<1           ! *** 2eme protection
            ~C:g_copy_sample_16_2_8%(L:b%,L:c%,L:d%)
          ENDIF
          code_erreur_fichier%=FN fwrite(handle_fichier%,SHR(d%,1),V:lig$)
          IF code_erreur_fichier%<0
            erreur%=code_erreur_fichier%
            GOTO sav_module_mod_erreur
          ENDIF
          ADD k%,SHR(d%,1)
        UNTIL k%>=a%
      ELSE
        b%=MAX(FN adresse(i%)*(-flag_registered2!),&H1958)      ! *** 2eme protection
        code_erreur_fichier%=FN fwrite(handle_fichier%,a%,b%)
        IF code_erreur_fichier%<0
          erreur%=code_erreur_fichier%
          GOTO sav_module_mod_erreur
        ENDIF
      ENDIF
    ENDIF
    INC j%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
sav_module_mod_erreur:
  ~FRE(0)
RETURN
PROCEDURE save_module_s3m
  LOCAL a%,b%,c%,d%,e%,f%,i%,j%,nbl%,nblm%,p%,xxx1%,xxx2%,xxx3%
  LOCAL loopend1%
  LOCAL a$,b$,mod$,pp$,ps$
  ~FRE(0)
  GOSUB rec_result("  Saving in S3M format (ScreamTracker 3 module).",TRUE)
  vide$=STRING$(16,0)
  nblm%=FN nbr_lines_maxi
  xxx1%=ADD(&H60,SUCC(FN song_length) AND -2)
  xxx2%=ADD(xxx1%,SHL(FN last_spl_util2,1))
  xxx3%=ADD(xxx2%,SHL(SUCC(FN last_pat_util),1))
  p%=ADD(ADD(xxx3%,32),15) AND -16      ! Debut des donnees de pat ou spl, alignement car parapointer
  '
  ' Le header du module
  '
  GOSUB rec_result("  Saving module header... ",FALSE)
  a%=FN mod_tempo                               ! Tempo
  mod$=LEFT$(FN songname$,28)+MKI$(&H1A10)+MKI$(0)
  mod$=mod$+MKI$(SUCC(FN song_length) AND -2)+MKI$(FN last_spl_util2)+MKI$(SUCC(FN last_pat_util))+MKI$(0)
  mod$=mod$+"GT"+MKI$(2)+"SCRM"
  mod$=mod$+CHR$(&H40)+CHR$(CARD{r_mod_speed%})+CHR$(a%)+CHR$(&HFF)+CHR$(0)+CHR$(252)+STRING$(10,0)
  GOSUB intel_w(ADD(V:mod$,&H20))
  GOSUB intel_w(ADD(V:mod$,&H22))
  GOSUB intel_w(ADD(V:mod$,&H24))
  GOSUB intel_w(ADD(V:mod$,&H26))
  GOSUB intel_w(ADD(V:mod$,&H2A))
  ' Les channels settings
  a%=0
  b%=0
  FOR i%=0 TO 31
    IF i%<nbr_track%
      IF FN balance(i%)<&H800
        mod$=mod$+CHR$(a%)
        a%=SUCC(a%) AND 7
      ELSE
        mod$=mod$+CHR$(ADD(b%,8))
        b%=SUCC(b%) AND 7
      ENDIF
    ELSE
      mod$=mod$+CHR$(255)
    ENDIF
  NEXT i%
  ' La song
  FOR i%=0 TO PRED(FN song_length)
    mod$=mod$+CHR$(song&(i%))
  NEXT i%
  IF (FN song_length AND 1)=1
    mod$=mod$+CHR$(255)
  ENDIF
  mod$=mod$+STRING$(SUB(p%,LEN(mod$)),0)
  ' Les Pan Pos
  FOR i%=0 TO PRED(nbr_track%)
    a%=ADD(FN balance(i%),&H80)                 ! Meilleure estimation possible
    BYTE{ADD(ADD(V:mod$,xxx3%),i%)}=ADD(MIN(DIV(MUL(a%,15),&H1000),15),32)
  NEXT i%
  code_erreur_fichier%=FN fwrite(handle_fichier%,p%,V:mod$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_s3m_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les samples
  '
  GOSUB rec_result("  Saving samples... ",FALSE)
  ps$=""                        ! Liste des parapointers
  j%=1
  loopend1%=FN last_spl_util2
  WHILE j%<=loopend1%
    i%=FN isample(j%,48)
    ps$=ps$+MKI$(SHR(p%,4))
    ' Le header
    a$=CHR$(1)+"SAMPLE"+HEX$(j%,2)+STRING$(5,0)+MKI$(SHR(ADD(p%,&H50),4))
    a$=a$+MKL$(FN length(i%))+MKL$(FN repeat(i%))+MKL$(ADD(FN repeat(i%),FN replen(i%)))
    a$=a$+CHR$(SHR(FN ivolume(j%),2))+CHR$(0)+CHR$(0)
    IF ADD(FN repeat(i%),FN replen(i%))<=2
      a%=0
    ELSE
      a%=1
    ENDIF
    a$=a$+CHR$(ADD(a%,SHL(PRED(FN resol(i%)),2)))
    a%=FN freqech(i%)*(2^(FN finetune(i%)/96))
    a$=a$+MKL$(a%)+STRING$(12,0)+FN samplename$(i%)+"SCRS"
    GOSUB intel_w(ADD(V:a$,&HE))
    GOSUB intel_l(ADD(V:a$,&H10))
    GOSUB intel_l(ADD(V:a$,&H14))
    GOSUB intel_l(ADD(V:a$,&H18))
    GOSUB intel_l(ADD(V:a$,&H20))
    code_erreur_fichier%=FN fwrite(handle_fichier%,16,V:vide$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    code_erreur_fichier%=GEMDOS(66,L:p%,W:handle_fichier%,W:0)  ! Seek
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    code_erreur_fichier%=FN fwrite(handle_fichier%,&H50,V:a$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    ADD p%,&H50
    ' Donnees
    a$=STRING$(16384,0)
    a%=0
    e%=FN resol(i%)
    WHILE SUB(FN length(i%),a%)>0
      b%=ADD(FN adresse(i%),a%)
      c%=V:a$
      d%=MIN(16384,SUB(FN length(i%),a%))
      f%=d%*(-flag_registered2!)                ! *** 2eme protection
      BMOVE b%,c%,f%
      ~C:g_signe_sample%(L:c%,L:d%,W:e%)
      IF e%=2
        ~C:g_intel_16_bits%(L:c%,L:d%)
      ENDIF
      code_erreur_fichier%=FN fwrite(handle_fichier%,d%,V:a$)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO sav_module_s3m_erreur
      ENDIF
      ADD a%,d%
    WEND
    p%=ADD(ADD(p%,FN length(i%)),15) AND -16
    INC j%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' les patterns
  '
  GOSUB rec_result("  Packing and saving patterns... ",FALSE)
  a$=STRING$(16384,0)           ! Au grand maximum...
  b$=STRING$(10240,0)
  pp$=""                        ! Liste des parapointers
  i%=0
  loopend1%=FN last_pat_util
  WHILE i%<=loopend1%
    nbl%=FN nbr_lines(i%)
    pp$=pp$+MKI$(SHR(p%,4))
    GOSUB clear_mem(V:b$,10240)
    BMOVE FN adr_pat(i%),V:b$,MUL(MUL(nbr_track%,MIN(64,nblm%)),5)
    IF nbl%<64
      CARD{ADD(V:b$,SUB(MUL(MUL(nbr_track%,nbl%),5),3))}=&HD00
    ENDIF
    a%=V:b$
    b%=V:a$
    c%=MAX(nbr_track%*(-flag_registered2!),1)           ! *** 2eme protection
    d%=MAX(MIN(nblm%,64)*(-flag_registered2!),1)        ! *** 2eme protection
    ~C:g_convert_gtk_2_s3m%(L:a%,L:b%,W:c%,W:d%)
    a%=CARD{V:a$}
    GOSUB intel_w(V:a$)
    code_erreur_fichier%=FN fwrite(handle_fichier%,16,V:vide$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    code_erreur_fichier%=GEMDOS(66,L:p%,W:handle_fichier%,W:0)  ! Seek
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    code_erreur_fichier%=FN fwrite(handle_fichier%,a%,V:a$)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO sav_module_s3m_erreur
    ENDIF
    p%=ADD(ADD(p%,a%),15) AND -16
    INC i%
  WEND
  GOSUB rec_result("done.",TRUE)
  '
  ' Sauvegarde des parapointers
  '
  GOSUB rec_result("  Saving pointers... ",FALSE)
  FOR i%=0 TO SUB(LEN(pp$),2) STEP 2
    GOSUB intel_w(ADD(V:pp$,i%))
  NEXT i%
  FOR i%=0 TO SUB(LEN(ps$),2) STEP 2
    GOSUB intel_w(ADD(V:ps$,i%))
  NEXT i%
  code_erreur_fichier%=GEMDOS(66,L:xxx1%,W:handle_fichier%,W:0) ! Seek
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_s3m_erreur
  ENDIF
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(ps$),V:ps$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_s3m_erreur
  ENDIF
  code_erreur_fichier%=GEMDOS(66,L:xxx2%,W:handle_fichier%,W:0) ! Seek
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_s3m_erreur
  ENDIF
  code_erreur_fichier%=FN fwrite(handle_fichier%,LEN(pp$),V:pp$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO sav_module_s3m_erreur
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
sav_module_s3m_erreur:
  ~FRE(0)
RETURN
PROCEDURE save_module_xm                !!!
RETURN
PROCEDURE load_module
  LOCAL time_taken%,erreur%
  LOCAL a$
  ~FRE(0)
  erreur%=0
  IF km%=2 AND nfile_module$<>""
    a$=npath_module$+nfile_module$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD MODULE",0,0,PRED(scr_ncol%))
    FILESELECT npath_module$+next_module$,nfile_module$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING MODULE "+a$+"...",0,0,PRED(scr_ncol%))
      ~FRE(0)
      GOSUB rec_result("Loading module "+a$+"...",TRUE)
      time_taken%=TIMER
      GOSUB load_module2
      time_taken%=SUB(TIMER,time_taken%)
      IF erreur%=0
        GOSUB rec_result("Complete. Time for loading: "+FN time_hmsd$(time_taken%),TRUE)
        GOSUB separe_nom_chemin(a$)
        npath_module$=npath_$
        nfile_module$=nfile_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  SELECT erreur%
  CASE 0                                        ! Pas d'erreur, tout est OK
    IF play%=1
      GOSUB play_song(TRUE)
    ELSE IF play%=2
      GOSUB play_pattern(TRUE)
    ELSE
      GOSUB stop_voices
    ENDIF
  CASE 1
    GOSUB rec_result("Error: No memory enough.",TRUE)
    GOSUB dialog("FILE","Error:|No memory enough|to load this module!","Cancel",MOUSEX,MOUSEY)
  CASE 2
    GOSUB rec_result("Error: No memory enough.",TRUE)
    GOSUB dialog("FILE","Error:|No memory enough|to load the pattern section|of this module!","Cancel",MOUSEX,MOUSEY)
  CASE 3
    GOSUB rec_result("Error: No memory enough.",TRUE)
    GOSUB dialog("FILE","Error:|No memory enough|to load the sample section|of this module!","Cancel",MOUSEX,MOUSEY)
  CASE 4
    GOSUB rec_result("Error: Unknown format.",TRUE)
    GOSUB dialog("FILE","Error:|Unknown module format, or|probably an unknown compression|type.","Cancel",MOUSEX,MOUSEY)
  DEFAULT
    GOSUB rec_result("Disk error: "+STR$(erreur%),TRUE)
    GOSUB dialog("FILE","Error:|"+STR$(erreur%),"Cancel",MOUSEX,MOUSEY)
  ENDSELECT
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE load_module2
  ' a$ nom du module
  LOCAL a%,admod%,anc%,b%,c%,i%,j%,ticks%,mastervol%
  LOCAL lonmod%,place_totale2%,tempo%,translate%
  LOCAL handle_fichier%,taille_fichier%
  LOCAL a&
  LOCAL b$,balance$,chk$,chunk$,chknbv$,header$,track_volume$
  LOCAL filename$
  ~FRE(0)
  GOSUB bee(TRUE)
  warning%=0
  place_totale2%=place_totale%
  translate%=0                          ! Decalage du buffer au cours du chargement du module
  ticks%=6                              ! Vitesse de base
  tempo%=125                            ! Tempo BPM de base
  mastervol%=0                          ! Master
  FOR i%=0 TO 31                        ! Fixe la balance par defaut
    balance$=balance$+MKI$(MUL(SHR(SUCC(i%),1) AND 1,&HFFF))
  NEXT i%
  track_volume$=STRING$(32,MKI$(&H1000))
  OPEN "i",#0,a$
  taille_fichier%=LOF(#0)
  CLOSE #0
  filename$=a$+CHR$(0)
  handle_fichier%=GEMDOS(61,L:V:filename$,W:0)
  header$=STRING$(4096,0)
  code_erreur_fichier%=FN fread(handle_fichier%,MIN(LEN(header$),taille_fichier%),V:header$)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
    GOTO ld_module2_fin
  ENDIF
  ~FRE(0)
  crunched%=0
  '
  ' Module packe ?
  '
  IF LEFT$(header$,3)="ATM"                     ! Si c'est un fichier packe (Atomic packer 3.5)
    lonmod%=LONG{ADD(V:header$,4)}              ! Longueur du module decompacte
    GOSUB rec_result("File crunched with Atomik Packer 3.5",TRUE)
    GOTO ld_mod2_comp_suite
  ELSE IF LEFT$(header$,4)="Ice!"               ! Si c'est un fichier packe (Ice Packer 2.1)
    lonmod%=LONG{ADD(V:header$,4)}              ! Longueur du module decompacte
    GOSUB rec_result("File crunched with Ice Packer 2.1",TRUE)
    GOTO ld_mod2_comp_suite
  ELSE IF LEFT$(header$,4)="ICE!"               ! Si c'est un fichier packe (Ice Packer 2.4)
    lonmod%=LONG{ADD(V:header$,8)}              ! Longueur du module decompacte
    GOSUB rec_result("File crunched with Ice Packer 2.4",TRUE)
    GOTO ld_mod2_comp_suite
  ELSE IF LEFT$(header$,4)="SPv3"               ! Si c'est un fichier packe (Speed Packer 3)
    lonmod%=LONG{ADD(V:header$,12)}             ! Longueur du module decompacte
    GOSUB rec_result("File crunched with Speed Packer 3",TRUE)
    GOTO ld_mod2_comp_suite
  ld_mod2_comp_suite:
    IF lonmod%<FN zone_free2                    ! Y a la place ?
      GOSUB rec_result("Clearing memory... ",FALSE)
      GOSUB stop_voices
      GOSUB clear_samples
      GOSUB clear_instr
      admod%=SUB(FN zone_end,lonmod%)
      BMOVE ADD(FN adr_buffer,lonmod%),FN adr_buffer,SUB(FN lon_buffer,lonmod%)
      GOSUB rec_result("done.",TRUE)
      GOSUB rec_result("Loading module... ",FALSE)
      code_erreur_fichier%=GEMDOS(66,L:0,W:handle_fichier%,W:0) ! Seek
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO ld_module2_fin
      ENDIF
      code_erreur_fichier%=FN fread(handle_fichier%,taille_fichier%,admod%)
      IF code_erreur_fichier%<0
        erreur%=code_erreur_fichier%
        GOTO ld_module2_fin
      ENDIF
      GOSUB rec_result("done.",TRUE)
      IF flag_autoload!
        GOSUB aff_message("WAITING : DECRUNCHING MODULE")
      ELSE
        GOSUB cadre_texte("WAITING : DECRUNCHING MODULE",0,0,PRED(scr_ncol%))
      ENDIF
      GOSUB bee(TRUE)
      GOSUB rec_result("Decrunching module... ",FALSE)
      ~C:g_atomic_35_unpack%(L:admod%)
      ~C:g_packice_21_unpack%(L:admod%)
      ~C:g_packice_24_unpack%(L:admod%)
      ~C:g_speedpacker_unpack%(L:admod%)
      GOSUB rec_result("done.",TRUE)
      BMOVE admod%,V:header$,4096               ! Nouveau header
      GOTO ld_module2_cv_in_mem
    ELSE
      erreur%=1                                 ! Pas assez de memoire
      GOTO ld_module2_fin
    ENDIF
    '
    ' On peut le charger en memoire puis le convertir apres
    '
  ELSE IF taille_fichier%<FN zone_free2
    GOSUB rec_result("Clearing memory... ",FALSE)
    GOSUB stop_voices
    GOSUB clear_samples
    GOSUB clear_instr
    GOSUB rec_result("done.",TRUE)
    GOSUB rec_result("Loading module... ",FALSE)
    lonmod%=taille_fichier%
    admod%=SUB(FN zone_end,lonmod%)
    BMOVE ADD(FN adr_buffer,lonmod%),FN adr_buffer,SUB(FN lon_buffer,lonmod%)
    code_erreur_fichier%=GEMDOS(66,L:0,W:handle_fichier%,W:0) ! Seek
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO ld_module2_fin
    ENDIF
    code_erreur_fichier%=FN fread(handle_fichier%,lonmod%,admod%)
    IF code_erreur_fichier%<0
      erreur%=code_erreur_fichier%
      GOTO ld_module2_fin
    ENDIF
    GOSUB rec_result("done.",TRUE)
    '
    ' Conversion en memoire
    '
  ld_module2_cv_in_mem:
    IF flag_autoload!
      GOSUB aff_message("WAITING : CONVERTING MODULE")
    ELSE
      GOSUB cadre_texte("WAITING : CONVERTING MODULE",0,0,PRED(scr_ncol%))
    ENDIF
    SUB place_totale2%,lonmod%
    SWAP place_totale%,place_totale2%
    GOSUB bee(TRUE)
    SHOWM
    IF LEFT$(header$,3)="GT2"
      GOSUB load_module_gt2_mem
    ELSE IF LEFT$(header$,3)="GTK"
      GOSUB load_module_gtk_mem
    ELSE
      ' Sinon ca doit encore etre un de ces p... de modules Noisetracker !!!
      chunk$="M.K.M&K&FLT4FLT6FLT8CD81CD82CD83CD41CD42CD43CD61CD62CD63M!K!RASPM~K~"
      '      chknbv$=MKL$(&H4040406)+MKL$(&H8080404)
      chk$=MID$(header$,&H439,4)
      a%=INSTR(chunk$,chk$)
      IF (a% AND 3)=1 OR (LEFT$(chk$,2)="FA" AND VAL(RIGHT$(chk$,2))>0) OR (RIGHT$(chk$,3)="CHN" AND VAL(LEFT$(chk$,1))>0) OR (RIGHT$(chk$,2)="CH" AND VAL(LEFT$(chk$,2))>0)
        GOSUB load_module_mod_mem
      ELSE IF LONG{V:header$}=&H4D4D4431
        ' Format OCTAmed Amiga
        GOSUB load_module_octamed_mem
      ELSE IF CARD{V:header$}=&H6966
        ' Foramt 669
        GOSUB load_module_669_mem
      ELSE IF MID$(header$,1,3)="MTM"
        ' Format MTM
        GOSUB load_module_mtm_mem
      ELSE IF MID$(header$,&H2D,4)="SCRM"
        ' Format  Scream Tracker 3
        GOSUB load_module_s3m_mem
      ELSE IF LEFT$(header$,12)="MAS_UTrack_V"
        ' Format Ultra Tracker
        GOSUB load_module_ult_mem
      ELSE IF LEFT$(header$,4)="D.T."
        ' Format Digital Tracker
        GOSUB load_module_dtm_mem
      ELSE IF LEFT$(header$,17)="Extended Module: "
        ' Format FastTracker 2
        GOSUB load_module_xm_mem
      ELSE
        ' Autre format ?
        '        GOTO ld_module2_disk   -- bug /sjx  0.8773 (there wasn't a label for this, caused jmp 0!)
        erreur%=4                               ! unknown format error /sjx.
        GOTO ld_module2_fin
      ENDIF
    ENDIF
    SWAP place_totale%,place_totale2%
    BMOVE FN adr_buffer,ADD(FN adr_buffer,SUB(lonmod%,translate%)),SUB(FN lon_buffer,SUB(lonmod%,translate%))
  ELSE
    erreur%=1                                   ! Pas assez de memoire
    GOTO ld_module2_fin
  ENDIF
  '
  ' Reorganisation
  '
  IF erreur%=0
    GOSUB rec_result("  Tracks: "+STR$(nbr_track%),TRUE)
    GOSUB rec_result("  Tempo: "+STR$(tempo%)+" BPM",TRUE)
    GOSUB rec_result("  Ticks per line: "+STR$(ticks%),TRUE)
    GOSUB rec_result("  Master Volume: "+STR$(mastervol%)+"/4096",TRUE)
    ' Reorganise un peut tout ca
    para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
    FOR i%=1 TO 255
      ~C:rr_boucle_sample%(W:i%)
    NEXT i%
    module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
    module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
    ARRAYFILL pattern_bidon%(),0
    bl_start&=0
    bl_end&=0
    bl_trk&=0
    bl_pat&=0
    IF mastervol%=0
      DPOKE r_master_vol%,MIN(DIV(&H3000,ADD(nbr_track%,4)),&H500)
    ELSE
      DPOKE r_master_vol%,mastervol%
    ENDIF
    GOSUB chg_tempo(tempo%)
    DPOKE r_mod_speed%,ticks%
    DPOKE r_mod_nbrtrack%,nbr_track%
    GOSUB set_balance(balance$)
    GOSUB set_track_volume(track_volume$)
  ENDIF
  '
ld_module2_fin:
  code_erreur_fichier%=GEMDOS(62,W:handle%)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
  ENDIF
  GOSUB garbage_collection
  ~FRE(0)
RETURN
PROCEDURE load_module_gtk               !!!
  ' Modules GTK
  ' header$ : 4096 octets du debut du module
ld_module_gtk_fin:
RETURN
PROCEDURE load_module_gtk_mem
  ' Conversion d'un module au format GTK (ancien format interne) deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL a%,b%,c%,i%,nvf%,pt%,nbs%,nbl%,adi$
  LOCAL nbp%,nbs2%
  ~FRE(0)
  GOSUB rec_result("It is an old Graoumf Tracker module (GTK).",TRUE)
  nvf%=BYTE{ADD(admod%,3)}              ! Numero de version du format
  nbl%=CARD{ADD(admod%,198)}            ! Nombre de lignes
  GOSUB new_pattern_format(CARD{ADD(admod%,200)})
  BMOVE admod%,V:module&(0),&HCE
  nbs%=module&(98)
  module&(98)=255
  pt%=ADD(admod%,&HCE)                  ! Pointe dans le fichier en memoire
  '
  ' Les headers des instruments
  '
  GOSUB rec_result("  Converting sample headers... ",FALSE)
  nbs2%=0
  FOR i%=1 TO nbs%
    GOSUB chg_samplename2(pt%,28,i%)
    GOSUB chg_instrname2(pt%,28,i%)
    IF nvf%>2
      GOSUB chg_sam_balance(i%,CARD{ADD(pt%,42)})
    ELSE
      SUB pt%,16
    ENDIF
    IF nvf%>1
      GOSUB chg_sam_nbits(i%,CARD{ADD(pt%,44)})
      GOSUB chg_sam_freq(i%,CARD{ADD(pt%,46)})
    ENDIF
    a%=LONG{ADD(pt%,48)}
    IF a%>0
      INC nbs2%
    ENDIF
    GOSUB chg_sam_length(i%,a%)
    GOSUB chg_sam_repeat(i%,LONG{ADD(pt%,52)})
    GOSUB chg_sam_replen(i%,LONG{ADD(pt%,56)})
    GOSUB chg_ins_volume(i%,CARD{ADD(pt%,60)})
    GOSUB chg_sam_volume(i%,&H100)
    GOSUB chg_sam_finetune(i%,INT{ADD(pt%,62)})
    ADD pt%,64
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song... ",FALSE)
  BMOVE pt%,V:song&(0),512
  ADD pt%,512
  nbp%=0
  FOR i%=0 TO PRED(module&(101))
    nbp%=MAX(nbp%,song&(i%))
  NEXT i%
  INC nbp%
  c%=MUL(MUL(nbp%,MUL(nbr_track%,nbl%)),5)
  ~FRE(0)
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbs2%)+" samples.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Converting patterns... ",FALSE)
  GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbr_track%)+MKI$(nbl%)),nbp%,FALSE)
  c%=MUL(nbr_track%,nbl%)
  IF nvf%<4
    FOR i%=0 TO PRED(nbp%)
      b%=FN adr_pat(i%)
      BMOVE pt%,b%,SHL(c%,2)
      ADD pt%,SHL(c%,2)
      ~C:g_convert_gtk_2_gtk_vol%(L:b%,L:c%)
    NEXT i%
  ELSE
    FOR i%=0 TO PRED(nbp%)
      BMOVE pt%,FN adr_pat(i%),MUL(c%,5)
      ADD pt%,MUL(c%,5)
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les instruments
  '
  GOSUB rec_result("  Converting samples... ",FALSE)
  adi$=""
  FOR i%=1 TO nbs%
    adi$=adi$+MKL$(pt%)
    ADD pt%,FN length(i%)
  NEXT i%
  FOR i%=1 TO nbs%
    GOSUB decale_sample(i%,nbs%,V:adi$)
  NEXT i%
  GOSUB rec_result("done.",TRUE)
ld_module_gtk_mem_fin:
RETURN
PROCEDURE load_module_gt2               !!!
RETURN
PROCEDURE load_module_gt2_mem
  ' Conversion d'un module au format GT2 (nouveau format interne) deja en memoire
  LOCAL a%,b%,c%,d%,e%,f%,i%,j%,finmod%,flags%,linestoadd%,version%
  LOCAL xcomchk%,orchchk%,patschk%,songchk%,tcn1chk%,tvolchk%
  LOCAL nbp%,nbs%,nbi%,nbe%
  LOCAL txt$,adp$,ads$,adi$,ade$,map$
  ~FRE(0)
  GOSUB rec_result("It's a Graoumf Tracker module (GT2).",TRUE)
  version%=BYTE{ADD(admod%,3)}
  GOSUB rec_result("  Format version number: "+STR$(version%)+".",TRUE)
  IF version%>gt2_file_vnum%
    GOSUB rec_result("  File will be probably not completely converted.",TRUE)
  ENDIF
  '
  ' Recherche des adresses de tous les chunks
  '
  finmod%=ADD(admod%,lonmod%)
  a%=ADD(admod%,LONG{ADD(admod%,4)})    ! Pointe sur le 2eme chunk du module
  adp$=STRING$(1024,0)                  ! Adresses des chunks des patterns
  ads$=STRING$(1024,0)                  ! Adresses des chunks des samples
  adi$=STRING$(1024,0)                  ! Adresses des chunks des instruments
  ade$=STRING$(768,0)                   ! Adresses des chunks des enveloppes
  songchk%=0
  patschk%=0
  orchchk%=0
  tcn1chk%=0
  xcomchk%=0
  tvolchk%=0
  nbp%=0
  nbs%=0
  nbi%=0
  nbe%=0
  ' Chunk detection.
  ' Note: Workaround 0.8775 put around here.
  ' I think the corruption (incorrect byteswapping) can only happen
  ' after a (16-bit?) SAMP chunk. So, SAMP, VENV, TENV, PENV, XCOM,
  ' and ENDC need to be treated. Should you encounter any more
  ' "Unknown chunk 'bacd'" messages where abcd is a valid chunk,
  ' you know what to do.
  WHILE a%<finmod%
  redetect_chunk:
    SELECT LONG{a%}
    CASE "TVOL"
      tvolchk%=a%
    CASE "SONG"
      songchk%=a%
    CASE "TCN1"
      tcn1chk%=a%
    CASE "PATS"
      patschk%=a%
    CASE "PATD"
      LONG{ADD(V:adp$,SHL(CARD{ADD(a%,8)},2))}=a%
      INC nbp%
    CASE "ORCH"
      orchchk%=a%
    CASE "INST"
      LONG{ADD(V:adi$,SHL(CARD{ADD(a%,8)},2))}=a%
      INC nbi%
    CASE "ASMP"
      LONG{a%}=CVL("SAMP")
      GOTO redetect_chunk
    CASE "SAMP"
      LONG{ADD(V:ads$,SHL(CARD{ADD(a%,8)},2))}=a%
      INC nbs%
    CASE "EVNV"
      LONG{a%}=CVL("VENV")
      GOTO redetect_chunk
    CASE "VENV"
      LONG{ADD(V:ade$,MUL(CARD{ADD(a%,8)},12))}=a%
      INC nbe%
    CASE "ETNV"
      LONG{a%}=CVL("TENV")
      GOTO redetect_chunk
    CASE "TENV"
      LONG{ADD(V:ade$,ADD(MUL(CARD{ADD(a%,8)},12),4))}=a%
      INC nbe%
    CASE "EPNV"
      LONG{a%}=CVL("PENV")
      GOTO redetect_chunk
    CASE "PENV"
      LONG{ADD(V:ade$,ADD(MUL(CARD{ADD(a%,8)},12),8))}=a%
      INC nbe%
    CASE "CXOM"
      LONG{a%}=CVL("XCOM")
      GOTO redetect_chunk
    CASE "XCOM"
      xcomchk%=a%
    CASE "NEDC"
      LONG{a%}=CVL("ENDC")
      GOTO redetect_chunk
    CASE "ENDC"
    DEFAULT
      GOSUB rec_result("  Unknown chunk: '"+MKL$(LONG{a%})+"'.",TRUE)
    ENDSELECT
    ADD a%,LONG{ADD(a%,4)}              ! Chunk suivant
  WEND
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbi%)+" instruments,",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples,",TRUE)
  GOSUB rec_result("  "+STR$(nbe%)+" envelopes.",TRUE)
  '
  ' Chargement des informations generales
  '
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB chg_songname2(ADD(admod%,8),32)
  GOSUB chg_songcomment2(ADD(admod%,40),160)
  mastervol%=CARD{ADD(admod%,232)}
  ticks%=CARD{ADD(admod%,228)}
  tempo%=CARD{ADD(admod%,230)}          ! Tempo
  BMOVE ADD(admod%,236),V:balance$,SHL(CARD{ADD(admod%,234)},1)
  '
  ' Recherche du nombre de lignes et de pistes
  '
  IF patschk%>0
    map$=""
    a%=CARD{ADD(patschk%,8)}            ! Nombre de pistes
    linestoadd%=0                       ! Nombre de lignes a ajouter au total
    FOR i%=0 TO 255
      c%=LONG{ADD(V:adp$,SHL(i%,2))}
      IF c%>0
        IF CARD{ADD(c%,26)}=0           ! Format de pattern 0 : donnees brutes
          ADD linestoadd%,SUB(CARD{ADD(c%,28)},1)
          map$=map$+MKI$(a%)+MKI$(CARD{ADD(c%,28)})
        ELSE
          map$=map$+MKI$(a%)+MKI$(1)
        ENDIF
      ELSE
        map$=map$+MKI$(a%)+MKI$(1)
      ENDIF
    NEXT i%
    GOSUB new_pattern_format(a%)
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Extra comment
  '
  IF xcomchk%>0
    GOSUB rec_result("  Comment:",TRUE)
    a%=LONG{ADD(xcomchk%,8)}
    txt$=""
    FOR i%=ADD(xcomchk%,12) TO ADD(ADD(xcomchk%,a%),11)
      b%=BYTE{i%}
      IF b%=10                                  ! CR
        GOSUB rec_result("  "+txt$,TRUE)
        txt$=""
      ELSE IF b%>=32                            ! Elimine les car. non ASCII
        txt$=txt$+CHR$(b%)
      ENDIF
    NEXT i%
    IF LEN(txt$)>0
      GOSUB rec_result("  "+txt$,TRUE)
      txt$=""
    ENDIF
    GOSUB rec_result("  (End of comment)",TRUE)
  ENDIF
  '
  ' Volumes des pistes
  '
  IF tvolchk%>0
    GOSUB rec_result("  Converting track volume chunk... ",FALSE)
    a%=CARD{ADD(tvolchk%,8)}
    BMOVE ADD(tvolchk%,10),V:track_volume$,SHL(a%,1)
    GOSUB rec_result("done.",TRUE)
  ENDIF
  '
  ' Les configurations
  '
  IF tcn1chk%>0 AND flag_gt2cnf!
    GOSUB rec_result("  Converting config. chunk... ",FALSE)
    songpos%=CARD{ADD(tcn1chk%,10)}
    posligne%=CARD{ADD(tcn1chk%,12)}
    n_preset%=CARD{ADD(tcn1chk%,14)}
    GOSUB chg_type_affpiste(CARD{ADD(tcn1chk%,16)})
    curs_col%=CARD{ADD(tcn1chk%,18)}
    curs_x%=CARD{ADD(tcn1chk%,20)}
    flags%=CARD{ADD(tcn1chk%,22)}
    play%=flags% AND 3
    IF (SHR(flags%,2) AND 1)=1
      GOSUB edit_mode_on
    ELSE
      GOSUB edit_mode_off
    ENDIF
    octave%=CARD{ADD(tcn1chk%,24)}
    line_step%=CARD{ADD(tcn1chk%,26)}
    instr%=CARD{ADD(tcn1chk%,28)}
    sample%=CARD{ADD(tcn1chk%,30)}
    FOR i%=0 TO 31                              ! Les presets
      nbr_colonnes%(i%)=CARD{ADD(tcn1chk%,ADD(32,SHL(i%,1)))}
    NEXT i%
    ' *** Penser aux noms
    BMOVE ADD(tcn1chk%,608),V:preset&(0,0),2048
    a%=LONG{ADD(tcn1chk%,2656)}                 ! Les pistes on/off
    FOR i%=0 TO 31
      DPOKE ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,i%)),BTST(a%,i%) AND 1
    NEXT i%
    GOSUB rec_result("done.",TRUE)
  ENDIF
  '
  ' Chargement de la song
  '
  IF songchk%>0
    GOSUB rec_result("  Converting song chunk... ",FALSE)
    module&(101)=CARD{ADD(songchk%,8)}
    module&(102)=CARD{ADD(songchk%,10)}
    FOR i%=0 TO PRED(FN song_length)
      song&(i%)=CARD{ADD(ADD(songchk%,12),SHL(i%,1))}
    NEXT i%
    GOSUB rec_result("done.",TRUE)
  ENDIF
  '
  ' Chargement des patterns
  '
  IF patschk%>0
    GOSUB rec_result("  Converting pattern chunks... ",FALSE)
    GOSUB create_space_multipatchunk(map$,256,TRUE)
    FOR i%=0 TO 255
      a%=LONG{ADD(V:adp$,SHL(i%,2))}
      IF a%>0
        GOSUB chg_patternname2(ADD(a%,10),16,i%)
        IF CARD{ADD(a%,26)}=0           ! Format de pattern 0 : donnees brutes
          b%=CARD{ADD(a%,28)}           ! Nombre de lignes de ce pattern
          ' Ignore le nombre de voies
          ~C:g_bmove%(L:ADD(a%,32),L:FN adr_pat(i%),L:MUL(MUL(nbr_track%,b%),5))
        ENDIF
      ENDIF
    NEXT i%
    GOSUB rec_result("done.",TRUE)
  ENDIF
  '
  ' Chargement des instruments
  '
  GOSUB rec_result("  Converting instrument chunks... ",FALSE)
  FOR i%=1 TO 255
    a%=LONG{ADD(V:adi$,SHL(i%,2))}
    IF a%>0
      BMOVE a%,V:instrset%(0,i%),LONG{ADD(a%,4)}
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement des enveloppes
  '
  GOSUB rec_result("  Converting envelope chunks... ",FALSE)
  FOR i%=1 TO 63
    FOR j%=0 TO 2
      a%=LONG{ADD(V:ade$,SHL(ADD(MUL(i%,3),j%),2))}
      IF a%>0
        b%=LONG{ADD(a%,4)}              ! Taille du chunk
        c%=CARD{ADD(a%,30)}             ! Taille de la section Attack
        GOSUB chg_env_length(i%,j%,0,c%)
        GOSUB chg_env_length(i%,j%,1,SUB(SUB(b%,32),c%))
        BMOVE a%,FN env_chunkadr(i%,j%),b%
      ENDIF
    NEXT j%
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement des samples
  '
  GOSUB rec_result("  Converting sample chunks... ",FALSE)
  FOR i%=1 TO 255
    a%=LONG{ADD(V:ads$,SHL(i%,2))}
    IF a%>0
      b%=LONG{ADD(a%,4)}                ! Longueur du nouveau chunk
      c%=FN adrsamchk(i%)               ! Adresse de l'ancien chunk
      d%=FN lonsamchk(i%)               ! Longueur de l'ancien chunk
      e%=ADD(c%,b%)
      j%=SUCC(i%)
      WHILE j%<256
        f%=LONG{ADD(V:ads$,SHL(j%,2))}
        EXIT IF f%<e% AND f%>0
        INC j%                          ! Cherche si des samples genent
      WEND
      IF j%<256 OR flag_keep_buffer!    ! On est oblige de faire une rotation
        ~C:g_bmove%(L:a%,L:c%,L:d%)     ! Copie ce qui tient
        GOSUB mem_rotation(ADD(c%,d%),SUB(ADD(a%,b%),ADD(c%,d%)),SUB(b%,d%))    ! et deplace le reste
        ADD translate%,SUB(b%,d%)
        IF i%<255
          FOR j%=SUCC(i%) TO 255        ! Remise a jour des chunks de sample
            GOSUB chg_sam_chunkadr(j%,ADD(FN adrsamchk(j%),SUB(b%,d%)))
            e%=LONG{ADD(V:ads$,SHL(j%,2))}
            IF e%>0 AND e%<a%
              LONG{ADD(V:ads$,SHL(j%,2))}=ADD(e%,SUB(b%,d%))
            ENDIF
          NEXT j%
        ENDIF
      ELSE
        IF i%<255
          ~C:g_bmove%(L:ADD(c%,d%),L:ADD(c%,b%),L:SUB(FN adr_buffer,ADD(c%,d%)))
        ENDIF
        ~C:g_bmove%(L:a%,L:c%,L:b%)
        IF i%<255
          FOR j%=SUCC(i%) TO 255        ! Remise a jour des chunks de sample
            GOSUB chg_sam_chunkadr(j%,ADD(FN adrsamchk(j%),SUB(b%,d%)))
          NEXT j%
        ENDIF
      ENDIF
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
RETURN
PROCEDURE load_module_mod               !!!
  ' Modules classiques type ProTracker Amiga
  ' header$ : 4096 octets du debut du module
ld_module_mod_fin:
RETURN
PROCEDURE load_module_mod_mem
  ' Modules classiques type ProTracker Amiga, deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,i%,nbl%,nbt%,nbs%,nbp%,bspd%
  LOCAL a&
  LOCAL flag_digital!,flag_intel!
  LOCAL chk$,chknbv$,chunk$,adi$
  ~FRE(0)
  '
  ' Trouve le bon format
  '
  flag_digital!=FALSE
  flag_intel!=FALSE
  chunk$="M.K.M&K&FLT4FLT6FLT8M!K!RASPM~K~"
  chknbv$=MKL$(&H4040406)+MKL$(&H8040404)
  chk$=MID$(header$,&H439,4)
  a%=INSTR(chunk$,chk$)
  nbl%=64
  bspd%=8363
  IF (a% AND 3)=1               ! Format courant
    nbt%=ASC(MID$(chknbv$,SUCC(SHR(PRED(a%),2)),1))
    GOSUB rec_result("It is a standard ProTracker module (MOD).",TRUE)
  ELSE IF RIGHT$(chk$,3)="CHN"  ! FastTracker
    nbt%=VAL(LEFT$(chk$,1))
    GOSUB rec_result("It is a ProTracker module (MOD), FastTracker mutation.",TRUE)
  ELSE IF RIGHT$(chk$,2)="CH"   ! FastTracker
    nbt%=VAL(LEFT$(chk$,2))
    GOSUB rec_result("It is a ProTracker module (MOD), FastTracker mutation.",TRUE)
  ELSE IF LEFT$(chk$,2)="CD"   ! Octalyser CDxy
    GOSUB rec_result("It is a ProTracker module (MOD), Octalyser mutation.",TRUE)
    bspd%=8363                  ! y=basespeed - 1,2,3 -> 16KHz, 20KHz, 25KHz
    IF RIGHT$(chk$,1)="2"
      bspd%=10038               ! Note: Neither of these are exact values, but it's...
    ELSE IF RIGHT$(chk$,1)="3"
      bspd%=12570               ! ...bloody hard to work them out from Blade's precalcs. /sjx.
    ENDIF
    nbt%=VAL(MID$(chk$,3,1))
  ELSE IF LEFT$(chk$,2)="FA"    ! Format Digital Tracker
    nbt%=VAL(RIGHT$(chk$,2))
    GOSUB rec_result("It is a ProTracker module (MOD), Digital Tracker mutation.",TRUE)
    flag_digital!=TRUE
    nbl%=CARD{ADD(admod%,&H43C)}
  ENDIF
  GOSUB new_pattern_format(nbt%)
  pt%=admod%
  GOSUB chg_songname2(pt%,20)                   ! Le nom du module
  ADD pt%,20
  '
  ' Lit les entetes des instruments
  '
  GOSUB rec_result("  Converting sample headers... ",FALSE)
  nbs%=0
  FOR j%=1 TO 31
    GOSUB chg_samplename2(pt%,22,j%)
    GOSUB chg_instrname2(pt%,22,j%)
    GOSUB chg_sam_freq(j%,bspd%)
    a&=INT{ADD(pt%,22)}                 ! Longueur
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_length(j%,SHL(a& AND 65535,1))
    IF a&>0
      INC nbs%
    ENDIF
    a&=BYTE{ADD(pt%,24)}                ! Finetune
    IF a&<8
      GOSUB chg_sam_finetune(j%,a&)
    ELSE
      GOSUB chg_sam_finetune(j%,SUB(a&,16))
    ENDIF
    a&=BYTE{ADD(pt%,25)}                ! Volume
    GOSUB chg_ins_volume(j%,SHL(a&,2))
    GOSUB chg_sam_volume(j%,&H100)
    a&=INT{ADD(pt%,26)}                 ! Repeat
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_repeat(j%,SHL(a& AND 65535,1))
    a&=INT{ADD(pt%,28)}                 ! Replen
    IF falg_intel!
      GOSUB intel_w(V:a&)
    ENDIF
    GOSUB chg_sam_replen(j%,SHL(a& AND 65535,1))
    ADD pt%,30
  NEXT j%
  GOSUB rec_result("done.",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song... ",FALSE)
  module&(101)=BYTE{pt%}        ! Longueur
  a&=BYTE{SUCC(pt%)}            ! Boucle
  ADD pt%,2
  IF a&>PRED(module&(101))
    a&=0
  ENDIF
  module&(102)=a&
  nbp%=0
  FOR i%=0 TO 127               ! La song
    song&(i%)=BYTE{ADD(pt%,i%)}
    nbp%=MAX(nbp%,song&(i%))
  NEXT i%
  INC nbp%
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples at "+STR$(bspd%*2)+"Hz basespeed.",TRUE)
  '
  ' Chargement des patterns
  '
  GOSUB rec_result("  Converting patterns... ",FALSE)
  GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbt%)+MKI$(nbl%)),nbp%,FALSE)
  IF flag_digital!
    pt%=ADD(admod%,&H440)       ! Les patterns (pour DT)
  ELSE
    pt%=ADD(admod%,&H43C)       ! Les patterns (modules courants)
  ENDIF
  b%=MUL(SUCC(a%),SHL(MUL(nbl%,nbr_track%),2))
  '
  ' Conversion des patterns
  '
  c%=MUL(nbl%,nbr_track%)
  FOR i%=0 TO PRED(nbp%)
    a%=FN adr_pat(i%)
    ~C:g_bmove%(L:pt%,L:a%,L:SHL(c%,2))
    ADD pt%,SHL(c%,2)
    ~C:g_convert_nt_2_gtk%(L:a%,L:c%)
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les samples
  '
  GOSUB rec_result("  Converting samples... ",FALSE)
  adi$=""
  FOR i%=1 TO 31
    adi$=adi$+MKL$(pt%)
    ADD pt%,FN length(i%)
  NEXT i%
  FOR i%=1 TO 31
    GOSUB decale_sample(i%,31,V:adi$)
  NEXT i%
  GOSUB rec_result("done.",TRUE)
ld_module_mod_mem_fin:
RETURN
PROCEDURE load_module_octamed           !!!
  ' Chargement d'un module au format OctaMED Pro Amiga
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_octamed_mem       !!!
  ' Chargement d'un module au format OctaMED Pro Amiga deja en memoire
  LOCAL a%,asc%,b%,c%,d%,e%,flags%,flags2%,i%,instrhdr%,j%,k%,l%
  LOCAL mmd0song%,mmd0block%,mmd0exp%,nbi%,nbs%,no%,rl%,rs%,sc%,t%,type%,wf%
  LOCAL numblock%
  LOCAL a$,adi$,b$,octstart$,samiff$,transpose$,map$
  ~FRE(0)
  GOSUB rec_result("It's an OctaMED Pro module (MMD).",TRUE)
  '
  ' Recherche des adresses de principaux chunks
  ' et des principales informations
  '
  GOSUB rec_result("  Converting module header... ",FALSE)
  mmd0song%=ADD(admod%,LONG{ADD(admod%,8)})     ! Pointe sur le header de la song
  mmd0block%=ADD(admod%,LONG{ADD(admod%,16)})   ! Pointe sur les offsets des patterns
  instrhdr%=ADD(admod%,LONG{ADD(admod%,24)})
  mmd0exp%=ADD(admod%,LONG{ADD(admod%,32)})     ! Pointe sur les donnees d'expansion
  ' Recherche nombre voies/piste
  numblock%=CARD{ADD(mmd0song%,504)}            ! Nombre de patterns
  t%=1
  map$=""
  FOR i%=0 TO PRED(numblock%)
    a%=LONG{ADD(mmd0block%,SHL(i%,2))}          ! Offset du header du pattern i
    IF a%>0
      t%=MAX(t%,CARD{ADD(admod%,a%)})
      l%=SUCC(CARD{ADD(ADD(admod%,a%),2)})
      map$=map$+MKI$(1)+MKI$(l%)
    ELSE
      map$=map$+MKI$(1)+MKI$(1)
    ENDIF
  NEXT i%
  FOR i%=0 TO SHL(PRED(numblock%),2) STEP 4
    CARD{ADD(V:map$,i%)}=t%
  NEXT i%
  GOSUB new_pattern_format(t%)
  GOSUB create_space_multipatchunk(map$,numblock%,TRUE)
  flags%=BYTE{ADD(mmd0song%,767)}
  flags2%=BYTE{ADD(mmd0song%,768)}
  nbi%=BYTE{ADD(mmd0song%,787)}                 ! Nbr d'instruments
  ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ' PRINT AT(1,5);CARD{ADD(mmd0song%,764)},SUCC(flag2% AND 31),BYTE{ADD(mmd0song%,769)}
  ' IF BTST(flags2%,5)
  '   PRINT "Ok"
  ' ENDIF
  ' ~INP(2)
  ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ' Le Tempo
  ' IF BTST(flags2%,5)
  '   tempo%=CARD{ADD(mmd0song%,764)}             ! BPM
  ' ENDIF
  ' b%=SUCC(flags2% AND 31)
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(numblock%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbi%)+" instruments,",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song chunk... ",FALSE)
  module&(101)=CARD{ADD(mmd0song%,506)}
  module&(102)=0
  FOR i%=0 TO PRED(FN song_length)
    song&(i%)=BYTE{ADD(ADD(mmd0song%,508),i%)}
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Converting pattern chunks... ",FALSE)
  transpose$=STRING$(64,35)
  FOR i%=0 TO PRED(numblock%)
    a%=LONG{ADD(mmd0block%,SHL(i%,2))}
    IF a%>0
      t%=CARD{ADD(admod%,a%)}
      l%=SUCC(CARD{ADD(admod%,ADD(a%,2))})
      IF t%>0 AND l%>0
        e%=ADD(admod%,ADD(a%,8))
        d%=SUB(nbr_track%,t%)
        b%=FN adr_pat(i%)
        c%=V:transpose$
        ~C:g_convert_mmd1_2_gtk%(L:e%,L:b%,L:c%,W:t%,W:l%,W:d%)
      ENDIF
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les headers d'instruments
  '
  GOSUB rec_result("  Converting instrument chunks and sample headers... ",FALSE)
  nbs%=0                                        ! Nombre actuel de samples decodes
  adi$=""
  samiff$="000000 432110 221100 110000 332210 543210 654321"
  octstart$="001224364860 121212122424 001212242436 001212243636 001212242424 121212121212 121212121212"
  FOR i%=1 TO nbi%
    a%=LONG{ADD(instrhdr%,SHL(PRED(i%),2))}
    IF a%>0
      ADD a%,admod%                             ! Pointe sur le header de l'instrument
      b%=ADD(mmd0song%,MUL(PRED(i%),8))         ! Pointe sur d'autres infos sur le sample
      t%=FN sbyte(BYTE{ADD(b%,7)})              ! Transposition generale de l'instrument
      GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(b%,6)},2))
      type%=INT{ADD(a%,4)}                      ! Type de l'instrument
      SELECT type%
      CASE 0 TO 6
        ' --- Sample de 1 a 7 octaves ---
        ' -------------------------------
      ld_mmd_samples:
        no%=VAL(MID$("1532467",SUCC(type%),1))  ! Nombre d'octaves dans l'instrument
        sc%=SUCC(nbs%)                          ! Sample en cours de traitement
        asc%=ADD(a%,6)                          ! Adr spl "   "    "    "
        FOR j%=0 TO PRED(no%)
          GOSUB chg_sam_nbits(sc%,1)
          GOSUB chg_sam_volume(sc%,&H100)
          GOSUB chg_sam_freq(sc%,8363)
          GOSUB chg_sam_finetune(sc%,0)         ! 0 par defaut, mais on voit plus tard si y en a
          rs%=SHL(CARD{b%},SUCC(j%))            ! Repeat
          rl%=SHL(CARD{ADD(b%,2)},SUCC(j%))     ! Replen
          IF type%=0                            ! Un sample/instr : on prend la longueur totale
            GOSUB chg_sam_length(sc%,LONG{a%} AND -2)
          ELSE                                  ! Sinon c'est repeat+replen
            GOSUB chg_sam_length(sc%,ADD(rs%,rl%))
          ENDIF
          GOSUB chg_sam_repeat(sc%,rs%)
          GOSUB chg_sam_replen(sc%,MAX(rl%,2))
          adi$=adi$+MKL$(asc%)
          ADD asc%,ADD(rs%,rl%)
          INC sc%
        NEXT j%
        ' Transpositions et affectation des samples aux instruments
        FOR j%=0 TO 5
          c%=ADD(VAL(MID$(samiff$,ADD(SUCC(MUL(type%,7)),j%),1)),SUCC(nbs%))
          d%=ADD(SUB(VAL(MID$(octstart$,ADD(SUCC(MUL(type%,13)),SHL(j%,1)),2)),MUL(j%,12)),t%)
          FOR k%=ADD(MUL(j%,12),36) TO ADD(MUL(j%,12),47)
            GOSUB chg_ins_sample(i%,k%,c%)      ! Sample
            GOSUB chg_ins_transp(i%,k%,d%)      ! Transposition
          NEXT k%
        NEXT j%
        FOR j%=1 TO 35
          GOSUB chg_ins_sample(i%,j%,FN isample(i%,36))
          GOSUB chg_ins_transp(i%,j%,FN itransp(i%,36))
        NEXT j%
        FOR j%=108 TO 127
          GOSUB chg_ins_sample(i%,j%,FN isample(i%,107))
          GOSUB chg_ins_transp(i%,j%,FN itransp(i%,107))
        NEXT j%
        GOSUB chg_ins_sample(i%,0,0)
        GOSUB chg_ins_transp(i%,0,0)
        ADD nbs%,no%
      CASE -1
        ' ---------- Synthetic ----------
        ' -------------------------------
        ' Ne prend pour l'instant en compte que la 1ere forme d'onde
        sc%=SUCC(nbs%)
        GOSUB chg_sam_nbits(sc%,1)
        GOSUB chg_sam_volume(sc%,&H100)
        GOSUB chg_sam_freq(sc%,8363)
        GOSUB chg_sam_finetune(sc%,0)
        wf%=ADD(a%,LONG{ADD(a%,278)})
        GOSUB chg_sam_length(sc%,SHL(CARD{wf%},1))
        GOSUB chg_sam_repeat(sc%,0)
        GOSUB chg_sam_replen(sc%,SHL(CARD{wf%},1))
        adi$=adi$+MKL$(ADD(wf%,2))
        FOR j%=1 TO 127
          GOSUB chg_ins_sample(i%,j%,sc%)
          GOSUB chg_ins_transp(i%,j%,SUB(t%,24))
        NEXT j%
        GOSUB chg_ins_sample(i%,0,0)
        GOSUB chg_ins_transp(i%,0,0)
        INC nbs%
        '
        '
        '
        '
      CASE -2
        ' ----------- Hybrid ------------
        ' -------------------------------
        '
        '
        '
        '
        b%=ADD(a%,8)                            ! Seulement valable pour Rep/Replen!!!
        a%=ADD(a%,LONG{ADD(a%,278)})            ! Pointe sur un instrument classique
        type%=INT{ADD(a%,4)}                    ! Nouveau type de l'instrument
        GOTO ld_mmd_samples
      ENDSELECT
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples.",TRUE)
  '
  ' Donnees d'expansion
  '
  GOSUB rec_result("  Converting expanded data... ",FALSE)
  IF mmd0exp%>admod%
    ' --- Finetunes ---
    a%=LONG{ADD(mmd0exp%,4)}
    b%=CARD{ADD(mmd0exp%,8)}
    c%=CARD{ADD(mmd0exp%,10)}
    IF a%>0 AND b%>0 AND c%=>4
      FOR i%=1 TO MIN(nbi%,b%)
        a$=FN ins_used_samples$(i%)
        IF LEN(a$)>0
          d%=FN sbyte(BYTE{ADD(admod%,ADD(a%,3))})
          FOR j%=0 TO SUB(LEN(a$),2) STEP 2
            GOSUB chg_sam_finetune(CARD{ADD(V:a$,j%)},d%)
          NEXT j%
        ENDIF
        ADD a%,c%                       ! Structure suivante
      NEXT i%
    ENDIF
    ' --- Noms des instruments ---
    a%=LONG{ADD(mmd0exp%,20)}           ! a% sur les noms
    b%=CARD{ADD(mmd0exp%,24)}           ! b% nbr de noms
    c%=CARD{ADD(mmd0exp%,26)}           ! c% taille d'un nom
    IF a%>0 AND b%>0 AND c%>0           ! S'il y a bien des noms
      FOR i%=1 TO MIN(nbi%,b%)
        GOSUB chg_instrname2(ADD(admod%,a%),c%,i%)
        a$=FN ins_used_samples$(i%)
        b$=SPACE$(28)
        BMOVE ADD(admod%,a%),V:b$,MIN(c%,28)
        IF LEN(a$)=2                    ! 1 seul sample
          GOSUB chg_samplename(b$,CARD{V:a$})
        ELSE IF LEN(a$)>2               ! Pluseurs samples d'octaves differents
          FOR j%=0 TO SUB(LEN(a$),2) STEP 2
            b$=LEFT$(b$,25)+"("+STR$(SUCC(SHR(j%,1)))+")"
            GOSUB chg_samplename(b$,CARD{ADD(V:a$,j%)})
          NEXT j%
        ENDIF
        ADD a%,c%                       ! Structure suivante
      NEXT i%
    ENDIF
    ' --- Nom de la chanson ---
    a%=LONG{ADD(mmd0exp%,44)}
    b%=LONG{ADD(mmd0exp%,48)}
    IF a%>0 AND b%>0
      GOSUB chg_songname2(ADD(a%,admod%),b%)
    ELSE
      GOSUB chg_songname("")
    ENDIF
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les donnees des samples
  '
  GOSUB rec_result("  Converting sample data... ",FALSE)
  IF nbs%>0
    FOR i%=1 TO nbs%
      GOSUB decale_sample(i%,nbs%,V:adi$)
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
RETURN
PROCEDURE load_module_669               !!!
  ' Chargement d'un module au format 669
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_669_mem
  ' Chargement d'un module au format 669 deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,i%,j%,nbs%,nbp%,res%,sec%,tem%,brk%,os$
  GOSUB rec_result("It's a 6669 Composer module (669).",TRUE)
  ~FRE(0)
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB new_pattern_format(9)           ! 8 + 1 voies
  GOSUB chg_songname2(ADD(admod%,2),108)
  nbs%=BYTE{ADD(admod%,110)}            ! nbs% = nombre de samples
  nbp%=BYTE{ADD(admod%,111)}            ! nbp% = nombre de patterns
  res%=BYTE{ADD(admod%,112)}            ! res% = position de rebouclage
  sec%=ADD(admod%,113)
  tem%=ADD(admod%,241)
  brk%=ADD(admod%,369)
  ticks%=4
  tempo%=80
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples,",TRUE)
  '
  ' Les headers des instruments
  '
  GOSUB rec_result("  Converting sample headers... ",FALSE)
  IF nbs%>0
    pt%=ADD(admod%,497)
    a%=0
    b%=ADD(497,ADD(MUL(nbs%,25),MUL(nbp%,&H600)))       ! b% = offset de sample
    os$=""
    FOR i%=1 TO nbs%
      os$=os$+MKL$(ADD(b%,admod%))
      GOSUB chg_samplename2(pt%,13,i%)
      GOSUB chg_instrname2(pt%,13,i%)
      ADD pt%,13
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      ADD b%,a%
      a%=a% AND -2
      GOSUB chg_sam_length(i%,a%)
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      a%=a% AND -2
      GOSUB chg_sam_repeat(i%,a%)
      a%=LONG{pt%}
      ADD pt%,4
      GOSUB intel_l(V:a%)
      IF a%<&HFFFF0
        a%=SUB(a%,FN replen(i%)) AND -2
      ELSE
        GOSUB chg_sam_repeat(i%,0)
        a%=2
      ENDIF
      GOSUB chg_sam_volume(i%,&H100)
      GOSUB chg_sam_replen(i%,a%)
      GOSUB chg_sam_freq(i%,&H12224)            ! 8740 Hz
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Converting pattern chunks... ",FALSE)
  IF nbp%>0
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(9)+MKI$(64)),nbp%,TRUE)
    pt%=ADD(admod%,ADD(497,MUL(nbs%,25)))
    FOR i%=0 TO PRED(nbp%)
      b%=FN adr_pat(i%)
      ~C:g_convert_669_2_gtk%(L:pt%,L:b%)
      LONG{b%}=ADD(&HA800,BYTE{ADD(tem%,i%)})           ! Vitesse du pattern
      LONG{ADD(b%,MUL(BYTE{ADD(brk%,i%)},45))}=&HD00    ! Fin du pattern
      ADD pt%,&H600
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song chunk... ",FALSE)
  FOR i%=0 TO 127
    IF BYTE{ADD(sec%,i%)}=255
      a%=i%
      i%=127
    ELSE
      song&(i%)=BYTE{ADD(sec%,i%)}
    ENDIF
  NEXT i%
  a%=MAX(1,a%)
  module&(101)=a%
  module&(102)=MIN(res%,PRED(a%))
  GOSUB rec_result("done.",TRUE)
  '
  ' Les instruments
  '
  GOSUB rec_result("  Converting sample chunks... ",FALSE)
  IF nbs%>0
    FOR i%=1 TO nbs%
      b%=FN length(i%)
      IF b%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        a%=FN adresse(i%)
        ~C:g_signe_sample%(L:a%,L:b%,W:1)
      ENDIF
    NEXT i%
  ENDIF
  FOR i%=2 TO 16 STEP 2
    CARD{ADD(V:balance$,i%)}=MUL(SHR(SUB(i%,2),1) AND 1,&HFFF)
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ~FRE(0)
RETURN
PROCEDURE load_module_mtm               !!!
  ' Chargement d'un module au format Multi Tracker
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_mtm_mem
  ' Chargement d'un module au format Multi Tracker deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,d%,i%,j%,k%,lon%,nbp%,nbs%,nbt%,sle%,nbl%,p1%,p2%,p3%,p4%
  LOCAL os$
  ~FRE(0)
  GOSUB rec_result("It's a Multi Tracker module (MTM).",TRUE)
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB clear_song(TRUE)
  GOSUB chg_songname2(ADD(admod%,4),20)
  GOSUB intel_w(ADD(admod%,24))
  GOSUB intel_w(ADD(admod%,28))
  nbt%=CARD{ADD(admod%,24)}             ! Nombre de pistes sauvees
  nbp%=SUCC(BYTE{ADD(admod%,26)})       ! Nombre de patterns
  lon%=SUCC(BYTE{ADD(admod%,27)})       ! Nombre de positions
  sle%=CARD{ADD(admod%,28)}             ! Song Length Extra-comment
  nbs%=BYTE{ADD(admod%,30)}             ! Nombre de samples
  nbl%=BYTE{ADD(admod%,32)}             ! Nombre de lignes
  GOSUB new_pattern_format(BYTE{ADD(admod%,33)})
  GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(BYTE{ADD(admod%,33)})+MKI$(nbl%)),nbp%,TRUE)
  module&(101)=MAX(lon%,1)
  FOR i%=0 TO PRED(nbr_track%)          ! Regle la balance de chaque piste
    CARD{ADD(V:balance$,SHL(i%,1))}=VAL("&H"+MID$("000100200300400500600700800924A48B6CC90DB4ED8FFF",SUCC(MUL(BYTE{ADD(admod%,ADD(i%,34))},3)),3))
  NEXT i%
  p1%=ADD(66,MUL(nbs%,37))              ! Pointe sur la sequence
  p2%=ADD(ADD(p1%,128),MUL(nbt%,192))   ! Pointe sur la disposition des pistes
  p3%=ADD(p2%,MUL(nbp%,64))             ! Pointe sur l'extra-comment
  p4%=ADD(p3%,sle%)                     ! Pointe sur les samples
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples.",TRUE)
  '
  ' Chargement des headers des samples
  '
  GOSUB rec_result("  Converting sample headers... ",FALSE)
  IF nbs%>0
    pt%=ADD(admod%,66)
    os$=""
    a%=p4%                              ! Offset du premier sample
    FOR i%=1 TO nbs%
      GOSUB chg_samplename2(pt%,22,i%)
      GOSUB chg_instrname2(pt%,22,i%)
      GOSUB intel_l(ADD(pt%,22))
      GOSUB intel_l(ADD(pt%,26))
      GOSUB intel_l(ADD(pt%,30))
      b%=LONG{ADD(pt%,22)}
      os$=os$+MKL$(ADD(admod%,a%))
      ADD a%,b%
      b%=b% AND -2
      ADD d%,b%
      c%=MAX(MIN(LONG{ADD(pt%,26)} AND -2,SUB(b%,2)),0)
      GOSUB chg_sam_nbits(i%,SUCC(BYTE{ADD(pt%,36)} AND 1))
      GOSUB chg_sam_length(i%,b%)
      GOSUB chg_sam_repeat(i%,c%)
      GOSUB chg_sam_replen(i%,MAX(MIN(SUB(LONG{ADD(pt%,30)},c%),SUB(b%,c%)) AND -2,2))
      GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(pt%,35)},2))
      GOSUB chg_sam_volume(i%,&H100)
      b%=BYTE{ADD(pt%,36)}
      IF b%>7
        SUB b%,16
      ENDIF
      GOSUB chg_sam_finetune(i%,b%)
      ADD pt%,37
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement de la song
  '
  GOSUB rec_result("  Converting song... ",FALSE)
  pt%=ADD(admod%,p1%)
  FOR i%=0 TO PRED(lon%)
    song&(i%)=BYTE{ADD(pt%,i%)}
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement des patterns
  '
  GOSUB rec_result("  Converting patterns... ",FALSE)
  d%=ADD(admod%,p2%)
  FOR i%=d% TO ADD(d%,SUB(MUL(nbp%,64),2)) STEP 2
    GOSUB intel_w(i%)
  NEXT i%
  pt%=ADD(admod%,ADD(p1%,128))
  FOR i%=1 TO nbt%
    b%=0
    FOR j%=0 TO MUL(PRED(nbp%),64) STEP 64
      a%=FN adr_pat(b%)
      FOR k%=j% TO ADD(j%,SHL(PRED(nbr_track%),1)) STEP 2
        IF i%=CARD{ADD(d%,k%)}
          ~C:g_convert_mtmv_2_gtk%(L:pt%,L:a%,W:nbr_track%,W:nbl%)
        ENDIF
        ADD a%,5
      NEXT k%
      INC b%
    NEXT j%
    ADD pt%,192
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Charge les instruments
  '
  GOSUB rec_result("  Converting samples... ",FALSE)
  IF nbs%>0
    FOR i%=1 TO nbs%
      b%=FN length(i%)
      IF b%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        a%=FN adresse(i%)
        c%=FN resol(i%)
        IF c%=2
          ~C:g_intel_16_bits%(L:a%,L:b%)
        ENDIF
        ~C:g_signe_sample%(L:a%,L:b%,W:c%)
      ENDIF
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  ~FRE(0)
RETURN
PROCEDURE load_module_s3m               !!!
  ' Chargement d'un module au format Scream Tracker 3
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_s3m_mem
  ' Chargement d'un module au format Scream Tracker 3 deja en memoire
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,c%,d%,convtrk$,ffv%,flg%,i%,j%,lon%,nbp%,nbs%,xxx1%,xxx2%,xxx3%,os$
  ~FRE(0)
  GOSUB rec_result("It's a Scream Tracker 3 module (S3M).",TRUE)
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB chg_songname2(admod%,28)
  GOSUB intel_w(ADD(admod%,&H20))
  GOSUB intel_w(ADD(admod%,&H22))
  GOSUB intel_w(ADD(admod%,&H24))
  GOSUB intel_w(ADD(admod%,&H2A))
  lon%=CARD{ADD(admod%,&H20)}           ! Longueur de la song (pair)
  nbs%=CARD{ADD(admod%,&H22)}           ! Nombre de samples
  nbp%=CARD{ADD(admod%,&H24)}           ! Nombre de patterns sauves
  ffv%=CARD{ADD(admod%,&H2A)}           ! File Format Version
  ticks%=BYTE{ADD(admod%,&H31)}         ! Vitesse
  tempo%=BYTE{ADD(admod%,&H32)}         ! Tempo
  xxx1%=ADD(&H60,SUCC(lon%) AND -2)     ! Ca doit toujours etre pair mais on ne sait jamais...
  xxx2%=ADD(xxx1%,SHL(nbs%,1))
  xxx3%=ADD(xxx2%,SHL(nbp%,1))
  '
  ' Recherche du nombre de voies
  '
  nbt%=0                                ! Nombre de voies
  convtrk$=""
  FOR i%=0 TO 31
    b%=BYTE{ADD(admod%,ADD(i%,&H40))} AND 127
    IF b%<16
      convtrk$=convtrk$+CHR$(nbt%)
      CARD{ADD(V:balance$,SHL(nbt%,1))}=MUL(SHR(b%,3),&HFFF)
      INC nbt%
    ELSE
      convtrk$=convtrk$+CHR$(255)
    ENDIF
  NEXT i%
  IF nbt%>0
    GOSUB new_pattern_format(nbt%)
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbt%)+MKI$(64)),nbp%,TRUE)
    '
    ' Les pan positions
    '
    IF BYTE{ADD(admod%,&H35)}=252
      FOR i%=0 TO PRED(nbt%)
        a%=BYTE{ADD(ADD(admod%,xxx3%),i%)}
        IF BTST(a%,5)
          a%=a% AND 15
          CARD{ADD(V:balance$,SHL(i%,1))}=MIN(DIV(MUL(a%,&H1000),15),&HFFF)
        ENDIF
      NEXT i%
    ENDIF
    GOSUB rec_result("done.",TRUE)
    GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
    GOSUB rec_result("  "+STR$(nbs%)+" samples",TRUE)
    '
    ' Chargement du header des samples
    '
    os$=""
    IF nbs%>0
      GOSUB rec_result("  Converting sample headers... ",FALSE)
      FOR i%=1 TO nbs%
        a%=ADD(admod%,ADD(xxx1%,SHL(PRED(i%),1)))
        GOSUB intel_w(a%)
        pt%=ADD(admod%,SHL(CARD{a%},4))
        a%=0
        IF BYTE{pt%}=1                    ! Est-ce bien un sample ?
          IF BYTE{ADD(pt%,&H1E)}=0        ! Sample non compacte
            GOSUB chg_samplename2(ADD(pt%,&H30),28,i%)
            GOSUB chg_instrname2(ADD(pt%,&H30),28,i%)
            GOSUB intel_w(ADD(pt%,&HE))
            GOSUB intel_l(ADD(pt%,&H10))
            GOSUB intel_l(ADD(pt%,&H14))
            GOSUB intel_l(ADD(pt%,&H18))
            GOSUB intel_l(ADD(pt%,&H20))
            flg%=BYTE{ADD(pt%,&H1F)}      ! Flags divers
            a%=MIN(MAX(LONG{ADD(pt%,&H10)},0),&HFFFFFE) AND -2
            IF BTST(flg%,0)               ! Boucle
              b%=MIN(MAX(LONG{ADD(pt%,&H14)},0) AND -2,SUB(a%,2))
              c%=MIN(MAX(SUB(MAX(LONG{ADD(pt%,&H18)},0) AND -2,b%),2),SUB(a%,b%))
            ELSE                          ! Pas boucle
              b%=0
              c%=2
            ENDIF
            GOSUB chg_sam_freq(i%,LONG{ADD(pt%,&H20)} AND 65535)
            GOSUB chg_sam_nbits(i%,SUB(1,BTST(flg%,2)))
            GOSUB chg_sam_length(i%,a%)
            GOSUB chg_sam_repeat(i%,b%)
            GOSUB chg_sam_replen(i%,c%)
            GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(pt%,&H1C)},2))
            GOSUB chg_sam_volume(i%,&H100)
            os$=os$+MKL$(ADD(admod%,SHL(CARD{ADD(pt%,&HE)},4)))
          ELSE
            os$=os$+MKL$(0)
          ENDIF
        ELSE
          os$=os$+MKL$(0)
        ENDIF
      NEXT i%
      GOSUB rec_result("done.",TRUE)
    ENDIF
    IF lon%>0 AND nbt%>0
      '
      ' Chargement de la sequence
      '
      GOSUB rec_result("  Converting song... ",FALSE)
      a%=0
      b%=0
      REPEAT
        song&(a%)=BYTE{ADD(admod%,ADD(b%,&H60))}
        IF song&(a%)<254
          INC a%
        ENDIF
        INC b%
      UNTIL b%=lon%                     ! OR BYTE{ADD(admod%,ADD(b%,&H60))}=255
      song&(a%)=0
      module&(101)=a%
      GOSUB rec_result("done.",TRUE)
      '
      ' Chargement des patterns
      '
      GOSUB rec_result("  Converting patterns... ",FALSE)
      FOR i%=0 TO PRED(nbp%)
        a%=ADD(admod%,ADD(xxx2%,SHL(i%,1)))
        GOSUB intel_w(a%)
        pt%=ADD(admod%,SHL(CARD{a%},4))
        a%=CARD{pt%}                    ! Longueur du pattern
        GOSUB intel_w(ADD(V:a%,2))      ! Mais qu'est-ce que j'en fais ???
        ADD pt%,2
        b%=FN adr_pat(i%)
        c%=V:convtrk$
        ~C:g_convert_s3m_2_gtk%(L:pt%,L:b%,L:c%,W:nbr_track%)
      NEXT i%
      GOSUB rec_result("done.",TRUE)
    ENDIF
    '
    ' Chargement des sample
    '
    IF nbs%>0
      GOSUB rec_result("  Converting samples... ",FALSE)
      FOR i%=1 TO nbs%
        a%=FN length(i%)
        IF a%>0
          GOSUB decale_sample(i%,nbs%,V:os$)
          d%=FN adresse(i%)
          b%=FN resol(i%)
          IF b%=2               ! 16 bits
            ~C:g_intel_16_bits%(L:d%,L:a%)
          ENDIF
          IF ffv%=2
            ~C:g_signe_sample%(L:d%,L:a%,W:b%)
          ENDIF
        ENDIF
      NEXT i%
      GOSUB rec_result("done.",TRUE)
    ENDIF
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_module_ult               !!!
  ' Chargement d'un module au format Ultra Tracker
  ' header$ : 4096 octets du debut du module
RETURN
PROCEDURE load_module_ult_mem
  ' Chargement d'un module au format Ultra Tracker
  ' header$ : 4096 octets du debut du module
  LOCAL pt%,a%,b%,bidi%,c%,d%,e%,i%,j%,nbp%,nbs%,ofp%,patt_seq%,res%,shs%,ver%,pat$,os$
  ~FRE(0)
  GOSUB rec_result("It's an Ultra Tracker module (ULT).",TRUE)
  GOSUB rec_result("  Converting module header... ",FALSE)
  ver%=1                                ! Numero de version du format
  shs%=64                               ! Taille d'un header de sample
  SELECT VAL(MID$(header$,13,3))
  CASE 2
    ver%=2
  CASE 3
    ver%=3
  CASE 4
    ver%=4
    shs%=66
  ENDSELECT
  GOSUB chg_songname2(ADD(admod%,15),32)
  res%=ADD(MUL(BYTE{ADD(admod%,47)},32),49)     ! Offset des descripteurs de samples
  nbs%=BYTE{ADD(admod%,PRED(res%))}
  patt_seq%=ADD(res%,MUL(nbs%,shs%))            ! Offset de la song
  nbp%=SUCC(BYTE{ADD(admod%,ADD(patt_seq%,257))})       ! Nombre de patterns
  GOSUB new_pattern_format(SUCC(BYTE{ADD(admod%,ADD(patt_seq%,256))}))
  IF ver%>2
    FOR i%=0 TO PRED(nbr_track%)
      CARD{ADD(V:balance$,SHL(i%,1))}=MUL(BYTE{ADD(ADD(admod%,ADD(patt_seq%,258)),i%)},&H111)
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples,",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song... ",FALSE)
  i%=0
  REPEAT
    a%=BYTE{ADD(admod%,ADD(patt_seq%,i%))}
    IF a%<nbp%
      song&(i%)=a%
      INC i%
    ENDIF
  UNTIL a%=>nbp% OR i%=>256
  module&(101)=i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement des patterns
  '
  GOSUB rec_result("  Converting patterns... ",FALSE)
  IF ver%<3
    ofp%=ADD(patt_seq%,258)
  ELSE
    ofp%=ADD(patt_seq%,ADD(258,nbr_track%))
  ENDIF
  IF nbp%>0
    GOSUB create_space_multipatchunk(STRING$(nbp%,MKI$(nbr_track%)+MKI$(64)),nbp%,FALSE)
    FOR j%=0 TO PRED(nbr_track%)
      FOR i%=0 TO PRED(nbp%)
        a%=ADD(admod%,ofp%)
        b%=FN adr_trk(i%,0,j%)
        a%=C:g_convert_ult_2_gtk%(L:a%,L:b%,W:nbr_track%)       ! Convertit et prend la longueur de cette voie
        ADD ofp%,a%
      NEXT i%
    NEXT j%
  ENDIF
  GOSUB rec_result("done.",TRUE)
  '
  ' Chargement des samples
  '
  IF nbs%>0
    GOSUB rec_result("  Converting samples... ",FALSE)
    os$=""
    FOR i%=1 TO nbs%
      pt%=ADD(admod%,ADD(res%,MUL(PRED(i%),shs%)))
      GOSUB chg_samplename2(pt%,28,i%)
      GOSUB chg_instrname2(pt%,28,i%)
      GOSUB intel_l(ADD(pt%,44))
      GOSUB intel_l(ADD(pt%,48))
      GOSUB intel_l(ADD(pt%,52))
      GOSUB intel_l(ADD(pt%,56))
      GOSUB intel_w(ADD(pt%,SUB(shs%,2)))
      bidi%=BYTE{ADD(pt%,61)}
      b%=SUB(LONG{ADD(pt%,56)},LONG{ADD(pt%,52)})       ! Longueur
      c%=LONG{ADD(pt%,44)}                              ! Loop start
      d%=LONG{ADD(pt%,48)}                              ! Loop end
      IF BTST(bidi%,2)                                  ! 16 bits ?
        ADD b%,b%
        ADD c%,c%
        ADD d%,d%
      ENDIF
      os$=os$+MKL$(ADD(admod%,ofp%))
      ADD ofp%,b%
      b%=MIN(MAX(b% AND -2,0),&HFFFFFE)
      IF BTST(bidi%,3) OR BTST(bidi%,4)                 ! Bouclage
        c%=MAX(MIN(c% AND -2,SUB(b%,2)),0)
        d%=MAX(SUB(MIN(d%,b%),c%),2) AND -2
      ELSE
        c%=0
        d%=2
      ENDIF
      GOSUB chg_sam_length(i%,b%)
      GOSUB chg_sam_repeat(i%,c%)
      GOSUB chg_sam_replen(i%,d%)
      d%=CARD{ADD(pt%,SUB(shs%,2))} AND 15      ! Finetune
      IF d%>7
        SUB d%,16
      ENDIF
      GOSUB chg_sam_finetune(i%,d%)
      GOSUB chg_ins_volume(i%,BYTE{ADD(pt%,60)})
      GOSUB chg_sam_volume(i%,&H100)
      GOSUB chg_sam_nbits(i%,SUB(1,BTST(bidi%,2)))
      IF ver%>3                         ! Frequence d'echantillonnage
        GOSUB intel_w(ADD(pt%,SUB(shs%,4)))
        GOSUB chg_sam_freq(i%,CARD{ADD(pt%,SUB(shs%,4))})
      ENDIF
    NEXT i%
    FOR i%=1 TO nbs%
      a%=FN length(i%)
      IF a%>0
        GOSUB decale_sample(i%,nbs%,V:os$)
        IF FN resol(i%)=2       ! 16 bits
          d%=FN adresse(i%)
          ~C:g_intel_16_bits%(L:d%,L:a%)
        ENDIF
      ENDIF
    NEXT i%
    GOSUB rec_result("done.",TRUE)
  ENDIF
  ~FRE(0)
RETURN
PROCEDURE load_module_dtm_mem
  LOCAL a%,b%,c%,adsq%,adpatt%,adinst%,finmod%,i%,j%,k%,l%,nbs%,nbp%,pt%
  LOCAL adp$,adi$,map$
  ~FRE(0)
  GOSUB rec_result("It's a Digital Tracker module (DTM).",TRUE)
  '
  ' Identification des chunks
  '
  finmod%=ADD(admod%,lonmod%)
  adp$=STRING$(1024,0)
  adi$=STRING$(1024,0)
  map$=STRING$(256,MKI$(1)+MKI$(1))
  a%=admod%
  REPEAT
    SELECT LONG{a%}
    CASE "S.Q."
      adsq%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "PATT"
      adpatt%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "INST"
      adinst%=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "DAPT"
      LONG{ADD(V:adp$,SHL(CARD{ADD(a%,12)},2))}=a%
      CARD{ADD(V:map$,ADD(SHL(CARD{ADD(a%,12)},2),2))}=CARD{ADD(a%,14)}
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    CASE "DAIT"
      LONG{ADD(V:adi$,SHL(CARD{ADD(a%,8)},2))}=a%
      ADD a%,ADD(LONG{ADD(a%,4)},8)
    ENDSELECT
    a%=C:g_dtm_next_chunk%(L:a%,L:finmod%)
  UNTIL a%>=finmod%
  '
  ' Infos generales
  '
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB new_pattern_format(CARD{ADD(adpatt%,8)})
  GOSUB chg_songname2(ADD(admod%,22),20)
  IF CARD{ADD(admod%,14)}<>0
    ticks%=CARD{ADD(admod%,14)}                 ! Vitesse
  ENDIF
  IF CARD{ADD(admod%,16)}<>0                    ! Tempo
    tempo%=CARD{ADD(admod%,16)}
  ENDIF
  nbs%=CARD{ADD(adinst%,8)}
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples,",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song chunk... ",FALSE)
  module&(101)=CARD{ADD(adsq%,8)}
  module&(102)=CARD{ADD(adsq%,10)}
  ARRAYFILL song&(),0
  FOR i%=0 TO PRED(module&(101))
    song&(i%)=BYTE{ADD(ADD(adsq%,16),i%)}
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Converting pattern chunks... ",FALSE)
  nbp%=CARD{ADD(adpatt%,10)}
  FOR i%=0 TO SHL(PRED(nbp%),2) STEP 4
    CARD{ADD(V:map$,i%)}=nbr_track%
  NEXT i%
  GOSUB create_space_multipatchunk(map$,nbp%,FALSE)
  FOR i%=0 TO PRED(nbp%)
    a%=LONG{ADD(V:adp$,SHL(i%,2))}      ! Adresse du pattern
    IF a%<>0
      l%=CARD{ADD(a%,14)}
      IF l%>0
        ADD a%,16                       ! Adresse des donnees
        b%=FN adr_pat(i%)
        c%=MUL(l%,nbr_track%)
        IF LONG{ADD(adpatt%,12)}=&H322E3034     ! '2.04'
          ~C:g_convert_dtm_2_gtk%(L:a%,L:b%,L:c%)
        ELSE                                    ! Ancien format
          BMOVE a%,b%,SHL(c%,2)
          ~C:g_convert_nt_2_gtk%(L:b%,L:c%)
        ENDIF
      ENDIF
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  '
  ' Les instruments
  '
  GOSUB rec_result("  Converting sample chunks... ",FALSE)
  IF nbs%>0
    FOR i%=1 TO nbs%
      IF LONG{ADD(V:adi$,SHL(PRED(i%),2))}>admod%
        a%=ADD(ADD(adinst%,10),MUL(PRED(i%),50))
        GOSUB chg_samplename2(ADD(a%,18),22,i%)
        GOSUB chg_instrname2(ADD(a%,18),22,i%)
        c%=LONG{ADD(a%,4)} AND -2
        GOSUB chg_sam_length(i%,c%)
        IF c%>0
          GOSUB chg_sam_freq(i%,LONG{ADD(a%,46)})
          GOSUB chg_sam_nbits(i%,SHR(BYTE{ADD(a%,41)},3))
          b%=LONG{ADD(a%,14)} AND -2
          IF b%>2
            GOSUB chg_sam_repeat(i%,MIN(SUB(c%,2),MAX(0,LONG{ADD(a%,10)} AND -2)))
            GOSUB chg_sam_replen(i%,MIN(SUB(c%,FN repeat(i%)),MAX(2,b%)))
          ELSE
            GOSUB chg_sam_repeat(i%,0)
            GOSUB chg_sam_replen(i%,2)
          ENDIF
          c%=BYTE{ADD(a%,8)}
          IF c%>7
            SUB c%,16
          ENDIF
          GOSUB chg_sam_finetune(i%,c%)
          GOSUB chg_ins_volume(i%,SHL(BYTE{ADD(a%,9)},2))
          GOSUB chg_sam_volume(i%,&H100)
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
  ~FRE(0)
  IF nbs%>0
    FOR i%=0 TO PRED(nbs%)
      IF FN length(SUCC(i%))>0
        LONG{ADD(V:adi$,SHL(i%,2))}=ADD(LONG{ADD(V:adi$,SHL(i%,2))},10)
      ELSE
        LONG{ADD(V:adi$,SHL(i%,2))}=0
      ENDIF
    NEXT i%
    FOR i%=1 TO nbs%
      GOSUB decale_sample(i%,nbs%,V:adi$)
    NEXT i%
  ENDIF
  GOSUB rec_result("done.",TRUE)
RETURN
PROCEDURE load_module_xm_mem            !!!
  LOCAL a%,b%,c%,d%,i%,j%,l%,hs%,nbi%,nbl%,nbp%,nbt%,pt%,sl%,snum%,sr%,tem%
  LOCAL transp$,adi$,map$
  ~FRE(0)
  GOSUB rec_result("It's a FastTracker 2 module (XM).",TRUE)
  '
  ' Header du module
  '
  GOSUB rec_result("  Converting module header... ",FALSE)
  GOSUB chg_songname2(ADD(admod%,17),20)
  GOSUB intel_l(ADD(admod%,60))
  GOSUB intel_w(ADD(admod%,64))
  GOSUB intel_w(ADD(admod%,66))
  GOSUB intel_w(ADD(admod%,68))
  GOSUB intel_w(ADD(admod%,70))
  GOSUB intel_w(ADD(admod%,72))
  GOSUB intel_w(ADD(admod%,76))
  GOSUB intel_w(ADD(admod%,78))
  pt%=ADD(ADD(60,admod%),LONG{ADD(admod%,60)})  ! Pointe sur le 1er pattern
  sl%=CARD{ADD(admod%,64)}              ! Song length
  sr%=CARD{ADD(admod%,66)}              ! Song repeat
  nbt%=CARD{ADD(admod%,68)}             ! Nombre de tracks
  nbp%=CARD{ADD(admod%,70)}             ! Nombre de patterns
  nbi%=CARD{ADD(admod%,72)}             ! Nombre d'instruments
  ticks%=CARD{ADD(admod%,76)}           ! Vitesse
  tempo%=CARD{ADD(admod%,78)}           ! Tempo
  '
  ' Recherche du nombre de lignes
  ' DesINTELisation des mots dans les headers des patterns
  '
  map$=""
  nbl%=1
  a%=pt%
  FOR i%=1 TO nbp%
    GOSUB intel_l(a%)
    GOSUB intel_w(ADD(a%,5))
    GOSUB intel_w(ADD(a%,7))
    nbl%=CARD{ADD(a%,5)}
    map$=map$+MKI$(nbt%)+MKI$(nbl%)
    ADD a%,ADD(LONG{a%},CARD{ADD(a%,7)})
  NEXT i%
  GOSUB new_pattern_format(nbt%)
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns,",TRUE)
  GOSUB rec_result("  "+STR$(nbi%)+" instruments,",TRUE)
  '
  ' La song
  '
  GOSUB rec_result("  Converting song... ",FALSE)
  module&(101)=sl%
  module&(102)=sr%
  FOR i%=0 TO PRED(FN song_length)
    song&(i%)=BYTE{ADD(ADD(admod%,80),i%)}
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les patterns
  '
  GOSUB rec_result("  Converting patterns... ",FALSE)
  GOSUB create_space_multipatchunk(map$,nbp%,FALSE)
  FOR i%=0 TO PRED(nbp%)
    IF BYTE{ADD(pt%,4)}=0               ! Packing type 0
      l%=CARD{ADD(pt%,5)}
      a%=ADD(pt%,9)
      b%=FN adr_pat(i%)
      ~C:g_convert_ft2_2_gtk%(L:a%,L:b%,W:nbr_track%,W:l%)
      pt%=ADD(a%,CARD{ADD(pt%,7)})
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  '
  ' Les instruments et headers des samples
  '
  GOSUB rec_result("  Converting instruments and sample headers... ",FALSE)
  snum%=1                               ! Sample courant
  adi$=""
  FOR i%=1 TO nbi%
    GOSUB intel_l(pt%)
    GOSUB intel_w(ADD(pt%,27))
    hs%=LONG{pt%}                       ! Taille du header d'instr
    c%=CARD{ADD(pt%,27)}                ! Nombre de samples dans l'instr
    GOSUB chg_instrname2(ADD(pt%,4),22,i%)
    IF c%=0
      ADD pt%,hs%                       ! Si pas de sample, instr suivant
    ELSE
      GOSUB chg_ins_volume(i%,256)
      FOR j%=1 TO 95                    ! Affectation des samples pour chaque note
        GOSUB chg_ins_sample(i%,j%,ADD(BYTE{ADD(pt%,ADD(33,j%))},snum%))
      NEXT j%
      FOR j%=96 TO 127
        GOSUB chg_ins_sample(i%,j%,FN isample(i%,95))
      NEXT j%
      GOSUB chg_ins_sample(i%,0,0)
      transp$=STRING$(256,0)            ! Table des transposition pour chaque sample
      GOSUB intel_l(ADD(pt%,29))
      a%=LONG{ADD(pt%,29)}              ! Taille des Sample Headers
      ADD pt%,hs%                       ! Pointe sur le premier header de sample
      ' Scanne chaque header de sample
      b%=0                              ! Taille totale des sample data de l'instrument
      FOR j%=1 TO c%                    ! DesINTELise tous les headers
        GOSUB intel_l(pt%)
        GOSUB intel_l(ADD(pt%,4))
        GOSUB intel_l(ADD(pt%,8))
        BYTE{ADD(V:transp$,snum%)}=BYTE{ADD(pt%,16)}    ! Memorise la transposition
        adi$=adi$+MKL$(b%)
        d%=LONG{pt%}
        ADD b%,d%
        d%=d% AND -2
        GOSUB chg_sam_length(snum%,d%)
        IF BTST(BYTE{ADD(pt%,14)},0) OR BTST(BYTE{ADD(pt%,14)},1)
          GOSUB chg_sam_repeat(snum%,LONG{ADD(pt%,4)} AND -2)
          GOSUB chg_sam_replen(snum%,MIN(MAX(LONG{ADD(pt%,8)},2),SUB(FN length(snum%),FN repeat(snum%))) AND -2)
        ELSE
          GOSUB chg_sam_repeat(snum%,0)
          GOSUB chg_sam_replen(snum%,2)
        ENDIF
        GOSUB chg_sam_volume(snum%,SHL(BYTE{ADD(pt%,12)},2))
        GOSUB chg_sam_freq(snum%,8363)
        GOSUB chg_sam_finetune(snum%,DIV(FN sbyte(BYTE{ADD(pt%,13)}),16))
        GOSUB chg_sam_nbits(snum%,SUB(1,BTST(BYTE{ADD(pt%,14)},4)))
        GOSUB chg_sam_balance(snum%,SHL(BYTE{ADD(pt%,15)},4))
        GOSUB chg_samplename2(ADD(pt%,18),22,snum%)
        ADD pt%,a%
        INC snum%                       ! *** Attention faut pas depasser 255!!!!!
      NEXT j%
      FOR j%=1 TO c%                    ! Les adresses des samples dans le XM
        LONG{ADD(V:adi$,SHL(SUB(PRED(snum%),j%),2))}=ADD(LONG{ADD(V:adi$,SHL(SUB(PRED(snum%),j%),2))},pt%)
      NEXT j%
      ADD pt%,b%                        ! Saute les donnees de sample
      FOR j%=1 TO 95                    ! Affecte les transpositions a chaque note suivant les samples
        GOSUB chg_ins_transp(i%,j%,BYTE{ADD(V:transp$,FN isample(i%,j%))})
      NEXT j%
      FOR j%=96 TO 127
        GOSUB chg_ins_transp(i%,j%,FN itransp(i%,95))
      NEXT j%
      GOSUB chg_ins_transp(i%,0,0)
    ENDIF
  NEXT i%
  GOSUB rec_result("done.",TRUE)
  GOSUB rec_result("  "+STR$(snum%)+" samples,",TRUE)
  '
  ' Deplacement des samples et conversion en absolu
  '
  IF snum%>1
    GOSUB rec_result("  Converting sample data... ",FALSE)
    FOR i%=1 TO PRED(snum%)
      GOSUB decale_sample(i%,PRED(snum%),V:adi$)
      a%=FN adresse(i%)
      b%=FN length(i%)
      c%=FN resol(i%)
      IF c%=2                           ! 16 bits
        ~C:g_intel_16_bits%(L:a%,L:b%)
      ENDIF
      ~C:g_delta_2_absolu%(L:a%,L:b%,W:c%)
    NEXT i%
    GOSUB rec_result("done.",TRUE)
  ENDIF
RETURN
PROCEDURE load_module_mgt_mem           !!!
  LOCAL nbt%,nbp%,nbs%
  LOCAL version%,nb_musics%,nb_orders%,nb_tracks%,attributes%
  LOCAL pt_musics%,pt_sequence%,pt_sample_infos%,pt_patterns%,pt_track_ptr%,pt_sample_data%
  ~FRE(0)
  GOSUB rec_result("It's a MegaTracker module (MGT).",TRUE)
  '
  ' Header du fichier
  '
  version%=BYTE{ADD(admod%,4)}
  nbt%=CARD{ADD(admod%,8)}
  nb_musics%=CARD{ADD(admod%,10)}
  nb_orders%=CARD{ADD(admod%,12)}
  nbp%=CARD{ADD(admod%,14)}
  nb_tracks%=CARD{ADD(admod%,16)}
  nbs%=CARD{ADD(admod%,18)}
  attributes%=CARD{ADD(admod%,20)}
  pt_musics%=ADD(admod%,LONG{ADD(admod%,26)})
  pt_sample_infos%=ADD(admod%,LONG{ADD(admod%,34)})
  pt_patterns%=ADD(admod%,LONG{ADD(admod%,38)})
  pt_track_ptr%=ADD(admod%,LONG{ADD(admod%,42)})
  pt_sample_data%=ADD(admod%,LONG{ADD(admod%,46)})
  GOSUB rec_result("  Format version: "+STR$(SHR(version%,4))+"."+STR$(version% AND 15)+".",TRUE)
  GOSUB rec_result("  "+STR$(nbp%)+" patterns.",TRUE)
  GOSUB rec_result("  "+STR$(nbs%)+" samples.",TRUE)
  '
  IF ADD(LONG{ADD(admod%,50)},LONG{ADD(admod%,54)})>FN zone_free2
    erreur%=1
  ELSE
    '
    ' Musique
    '
    GOSUB chg_songname2(ADD(pt_music%,0),32)
    pt_sequence%=ADD(admod%,LONG{ADD(pt_music%,32)})
    module&(101)=CARD{ADD(pt_music%,36)}
    module&(102)=CARD{ADD(pt_music%,38)}
    tempo%=CARD{ADD(pt_music%,40)}
    FOR i%=0 TO PRED(module&(101))
      song&(i%)=CARD{ADD(pt_sequence%,SHL(i%,1))}
    NEXT i%
  ENDIF
RETURN
PROCEDURE save_instrument
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_instrument$<>""
      a$=npath_div$+nfile_instrument$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE INSTRUMENT",0,0,PRED(scr_ncol%))
      FILESELECT npath_div$+"*.INS",nfile_instrument$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING INSTRUMENT "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_instrument2
      GOSUB separe_nom_chemin(a$)
      nfile_instrument$=nfile_$
      npath_div$=npath_$
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_instrument2
  ' Fournir a$ nom du module, instr% numero de l'instrument
  LOCAL a%,i%
  LOCAL b$
  erreur%=0
  warning%=0
  OPEN "o",#0,a$
  SEEK #0,0
  '
  ' Travail preparatoire
  '
  ' Cherche les samples utilises par cet instrument
  lsam$=STRING$(256,0)
  FOR i%=0 TO 127
    a%=FN isample(instr%,i%)
    IF a%<>0
      BYTE{ADD(V:lsam$,a%)}=1
    ENDIF
  NEXT i%
  '
  ' Chunk de l'instrument
  '
  BPUT #0,V:instrset%(0,instr%),instrset%(1,instr%)
  '
  ' Chunks des samples
  '
  FOR i%=1 TO 255
    IF BYTE{ADD(V:lsam$,i%)}<>0
      a%=MAX(FN adrsamchk(i%)*(-flag_registered2!),&H1563)      ! *** 2eme protection
      BPUT #0,a%,FN lonsamchk(i%)
    ENDIF
  NEXT i%
  CLOSE #0
RETURN
PROCEDURE load_instrument
  LOCAL a$
  IF km%=2 AND nfile_instrument$<>""
    a$=npath_div$+nfile_instrument$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD SAMPLE",0,0,PRED(scr_ncol%))
    FILESELECT npath_div$+"*.INS",nfile_instrument$,a$
  ENDIF
  IF FN exist(a$)
    CLS
    GOSUB cadre_texte("WAITING : LOADING INSTRUMENT "+a$+"...",0,0,PRED(scr_ncol%))
    GOSUB load_instrument2
    IF erreur%=0
      GOSUB separe_nom_chemin(a$)
      nfile_instrument$=nfile_$
      npath_div$=npath_$
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
  IF erreur%=1
    GOSUB aff_message("NOT AN INSTRUMENT.")
  ELSE IF erreur%=2
    GOSUB aff_message("NOT ENOUGH MEMORY TO LOAD THIS INSTRUMENT !")
  ELSE IF erreur%=3
    GOSUB aff_message("TOO MANY SAMPLES IN THIS INSTRUMENT")
  ENDIF
RETURN
PROCEDURE load_instrument2
  ' Nom fourni dans a$
  LOCAL a%,b%,c%,i%,j%,lchk%,nbs%,posact%,totlon%
  LOCAL chk$,sam$
  ~FRE(0)
  erreur%=0
  warning%=0
  OPEN "i",#0,a$
  totlon%=LOF(#0)
  posact%=0
  '
  ' Chargement du chunk de l'instrument
  '
  chk$=STRING$(8,0)
  SEEK #0,posact%
  BGET #0,V:chk$,8
  ADD posact%,8
  IF LEFT$(chk$,4)="INST"                       ! Verifie que c'est bien un instrument
    lchk%=LONG{ADD(V:chk$,4)}
    chk$=chk$+STRING$(SUB(lchk%,8),0)
    BGET #0,ADD(V:chk$,8),SUB(lchk%,8)
    ADD posact%,SUB(lchk%,8)
    ' Table de conversion de numero d'instrument
    sam$=STRING$(256,0)
    nbs%=0                                      ! Nombre de samples
    a%=0
    FOR i%=1 TO 127
      b%=BYTE{ADD(ADD(V:chk$,60),SHL(i%,1))}
      IF BYTE{ADD(V:sam$,b%)}=0 AND b%>0
        INC nbs%
        REPEAT
          INC a%
          EXIT IF a%>255
        UNTIL FN length(a%)=0                   ! Cherche un sample libre : longueur nulle
        IF a%<=255
          BYTE{ADD(V:sam$,b%)}=a%
        ELSE
          erreur%=3                             ! Plus de sample libre : erreur
          i%=999
        ENDIF
      ENDIF
    NEXT i%
    IF erreur%<>0
      GOTO ld_instr2_fin
    ENDIF
    CARD{ADD(V:chk$,8)}=instr%
    CARD{ADD(V:chk$,60)}=0
    FOR i%=1 TO 127                             ! Nouveaux numeros de sample
      BYTE{ADD(ADD(V:chk$,60),SHL(i%,1))}=BYTE{ADD(V:sam$,BYTE{ADD(ADD(V:chk$,60),(SHL(i%,1)))})}
    NEXT i%
    BMOVE V:chk$,V:instrset%(0,instr%),316
    '
    ' Chargement des samples
    '
    IF nbs%>0
      a%=0                                      ! Nombre de samples charges
      WHILE posact%<totlon% AND a%<nbs%
        chk$=STRING$(64,0)
        SEEK #0,posact%
        BGET #0,V:chk$,64
        ADD posact%,64
        lchk%=LONG{ADD(V:chk$,4)}               ! Longueur totale du chunk du sample
        c%=LONG{ADD(V:chk$,46)}                 ! Longueur en octets
        d%=CARD{ADD(V:chk$,8)}                  ! Ancien numero du sample
        b%=BYTE{ADD(V:sam$,d%)}                 ! Nouveau numero du sample
        IF b%<>0                                ! S'il etait bien declare dans le chunk de l'instrument
          CARD{ADD(V:chk$,8)}=b%
          GOSUB chg_taille_sample(b%,c%)        ! Change d'abord la taille
          BMOVE V:chk$,FN adrsamchk(b%),64      ! Transfert ensuite le chunk
          BGET #0,FN adresse(b%),c%             ! Puis transfert les donnees (taille indiquee dans Length)
          ADD posact%,SUB(lchk%,64)             ! Pointe sur le chunk suivant
          BYTE{ADD(V:sam$,d%)}=0                ! Indique que le sample est deja charge
          INC a%
        ELSE                                    ! Sample qui etait en trop
          ADD posact%,SUB(lchk%,64)
        ENDIF
      WEND
    ENDIF
    IF a%<nbs%
      warning%=1                                ! Tous les samples n'ont pas ete trouves
    ENDIF
    FOR i%=1 TO 255
      ~C:rr_boucle_sample%(W:i%)
    NEXT i%
  ELSE
    erreur%=1
  ENDIF
ld_instr2_fin:
  CLOSE #0
RETURN
PROCEDURE load_prefs
  LOCAL a$
  IF km%=2 AND nfile_sample$<>""
    a$=npath_prefs$+nfile_prefs$
  ELSE
    CLS
    GOSUB cadre_texte("LOAD PREFERENCES",0,0,PRED(scr_ncol%))
    FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
  ENDIF
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("WAITING : LOADING PREFERENCES "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB load_prefs2(a$,FALSE)
    ENDIF
  ENDIF
  GOSUB bee(FALSE)
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE load_prefs2(fic$,first_time!) !!!
  LOCAL a%,b%,i%
  LOCAL a$,lig$,p$,p1$,p2$,dejafait_touche$
  LOCAL error!
  dejafait_touche$=STRING$(255,0)
  OPEN "i",#0,fic$
  WHILE NOT EOF(#0)
    LINE INPUT #0,lig$
    IF LEN(lig$)>2
      ' Transforme les caracteres non ASCII en espaces
      FOR i%=0 TO PRED(LEN(lig$))
        IF BYTE{ADD(V:lig$,i%)}<32
          BYTE{ADD(V:lig$,i%)}=32
        ENDIF
      NEXT i%
      lig$=TRIM$(lig$)
      a%=INSTR(lig$,"=")
      IF a%>1
        p$=UPPER$(TRIM$(LEFT$(lig$,PRED(a%))))  ! p$ contient le nom de la variable
        p1$=RIGHT$(lig$,SUB(LEN(lig$),a%))      ! p1$ contient le reste brut de la ligne
        b%=INSTR(p1$,";")
        IF b%>0
          p2$=UPPER$(TRIM$(LEFT$(p1$,PRED(b%))))        ! p2$ contient le 2eme terme sans commentaire
        ELSE
          p2$=UPPER$(TRIM$(p1$))
        ENDIF
        '
        ' Main pannel
        ' -----------
        '
        ' Touches
        '
        IF p$="KEYBOARD_TYPE"
          IF p2$="QWERTY"
            keyboard_type%=1
          ELSE
            keyboard_type%=0
          ENDIF
        ELSE IF p$="KEYBOARD_BUFFER"
          IF p2$="ON"
            flag_keyboard_buffer!=TRUE
          ELSE
            flag_keyboard_buffer!=FALSE
          ENDIF
        ELSE IF LEFT$(p$,6)="KEYDEF"
          p$=TRIM$(RIGHT$(p$,SUB(LEN(p$),6)))
          GOSUB load_prefs_analyse_touche(p$,p2$)
          '
          ' Disk
          '
        ELSE IF p$="PROGRAM_PATH"
          npath_prog$=p2$
        ELSE IF p$="MODULE_PATH"
          npath_module$=p2$
        ELSE IF p$="SAMPLE_PATH"
          npath_sample$=p2$
        ELSE IF p$="AUTOLOAD_PATH"
          npath_autoload$=p2$
        ELSE IF p$="PREF_PATH"
          npath_prefs$=p2$
        ELSE IF p$="MISC_PATH"
          npath_div$=p2$
        ELSE IF p$="MODULE_EXTENSION"
          next_module$=p2$
        ELSE IF p$="SAMPLE_EXTENSION"
          next_sample$=p2$
        ELSE IF p$="MODULE_FILE"
          IF p2$<>"/"
            nfile_module$=p2$
          ELSE
            nfile_module$=""
          ENDIF
        ELSE IF p$="SAMPLE_FILE"
          IF p2$<>"/"
            nfile_sample$=p2$
          ELSE
            nfile_sample$=""
          ENDIF
        ELSE IF p$="AUTOLOAD_FILE"
          IF p2$<>"/"
            nfile_autoload$=p2$
          ELSE
            nfile_autoload$=""
          ENDIF
        ELSE IF p$="PREF_FILE"
          IF p2$<>"/"
            nfile_prefs$=p2$
          ELSE
            nfile_prefs$=""
          ENDIF
        ELSE IF p$="SAVE_CONFIG_GT2"
          IF p2$="TRUE"
            flag_gt2cnf!=TRUE
          ELSE
            flag_gt2cnf!=FALSE
          ENDIF
        ELSE IF p$="MODULE_BACKUP"
          IF p2$="TRUE"
            flag_backup_modules!=TRUE
          ELSE
            flag_backup_modules!=FALSE
          ENDIF
          '
          ' Divers
          '
        ELSE IF p$="SYSTEM_MEMORY"
          system_memory%=MAX(VAL(p2$),16384)
        ELSE IF p$="COLOR_PAL"
          error!=FALSE
          a$=""
          FOR i%=0 TO 15
            IF LEN(p2$)<3
              error!=TRUE
            ELSE
              a$=a$+LEFT$(p2$,3)
              p2$=TRIM$(RIGHT$(p2$,SUB(LEN(p2$),3)))
            ENDIF
          NEXT i%
          IF NOT error!
            color_pal$=a$
          ENDIF
        ELSE IF p$="GRMODE_OVERSCAN"
          IF p2$="YES"
            grmode_overscan%=1
          ELSE IF p2$="NO"
            grmode_overscan%=0
          ELSE
            grmode_overscan%=-1
          ENDIF
        ELSE IF p$="GRMODE_80COL"
          IF p2$="YES"
            grmode_80colonnes%=1
          ELSE IF p2$="NO"
            grmode_80colonnes%=0
          ELSE
            grmode_80colonnes%=-1
          ENDIF
        ELSE IF p$="GRMODE_400LINES"
          IF p2$="YES"
            grmode_entrelace%=1
          ELSE IF p2$="NO"
            grmode_entrelace%=0
          ELSE
            grmode_entrelace%=-1
          ENDIF
        ELSE IF p$="GRMODE_PRESERVE"
          IF p2$="YES"
            grmode_preserve%=1
          ELSE IF p2$="NO"
            grmode_preserve%=0
          ENDIF
        ELSE IF p$="GRMODE_SKIPXBRA"
          IF p2$="YES"
            grmode_skipxbra%=1
          ELSE
            grmode_skipxbra%=0
          ENDIF
        ELSE IF p$="GTLOGO_COLOR"
          graoumf_logo_color%=VAL(p2$)
        ELSE IF p$="PATTERN_LINE_MAX"
          haut_lig%=MIN(MAX(VAL(p2$) OR 1,1),99999)
          IF NOT first_time!
            haut_lig%=MIN(DIV(SUB(scr_haut%,180),6) OR 1,haut_lig%)
          ENDIF
        ELSE IF p$="INSTRUMENT"
          instr%=MIN(MAX(VAL(p2$),1),255)
        ELSE IF p$="SAMPLE"
          sample%=MIN(MAX(VAL(p2$),1),255)
        ELSE IF p$="LINE_STEP"
          IF p2$="NEXT LINE TAKEN"
            line_step%=256
          ELSE IF p2$="NEXT NOTE"
            line_step%=257
          ELSE IF p2$="NEXT FX"
            line_step%=258
          ELSE IF p2$="NEXT VOLUME"
            line_step%=259
          ELSE
            line_step%=MIN(MAX(VAL(p2$),-64),64)
          ENDIF
        ELSE IF p$="NUMBER_OF_TRACKS"
          IF first_time!
            nbr_track%=MIN(MAX(VAL(p2$),1),32)
          ENDIF
        ELSE IF p$="PRESET"
          n_preset%=MIN(MAX(PRED(VAL(p2$)),0),31)
        ELSE IF p$="OCTAVE"
          octave%=MIN(MAX(PRED(VAL(p2$)),0),6)
        ELSE IF p$="MENU"
          IF p2$="DISK"
            ss_menu%=1
          ELSE IF p2$="TOOLS"
            ss_menu%=2
          ELSE IF p2$="INSTRUMENTS"
            ss_menu%=3
          ELSE IF p2$="SAMPLES"
            ss_menu%=4
          ELSE IF p2$="ENVELOPES"
            ss_menu%=5
          ELSE IF p2$="CONTROL"
            ss_menu%=6
          ELSE
            ss_menu%=MIN(MAX(VAL(p2$),1),5)
          ENDIF
        ELSE IF p$="NUMPAD"
          IF p2$="DRUMKIT"
            drumpad_flag%=1
          ELSE
            drumpad_flag%=0
          ENDIF
        ELSE IF p$="PATTERN_DISPLAY"
          type_affpiste%=MIN(MAX(VAL(p2$),0),2)
        ELSE IF p$="BLOCK_REPLACE"
          IF p2$="TRUE"
            replace_block%=1
          ELSE
            replace_block%=0
          ENDIF
          '
          ' Tools
          '
        ELSE IF p$="BLOCK_TYPE"
          IF p2$="PATTERN"
            trackpat%=1
          ELSE IF p2$="PRESET"
            trackpat%=2
          ELSE
            trackpat%=0
          ENDIF
        ELSE IF p$="BLOCK_SONG"
          IF p2$="TRUE"
            bl_flagsong!=TRUE
          ELSE
            bl_flagsong!=FALSE
          ENDIF
        ELSE IF p$="BLOCK_MASK"
          IF p2$="TRUE"
            maskblock%=1
          ELSE
            maskblock%=0
          ENDIF
        ELSE IF p$="BLOCK_MASK1"
          '
          '
          '
        ELSE IF p$="BLOCK_MASK2"
          '
          '
          '
        ELSE IF p$="TOOLS_ECHO_STEP"
          bl_echo_lines%=MIN(MAX(VAL(p2$),1),64)
        ELSE IF p$="TOOLS_ECHO_FDBKVAL"
          bl_echo_feedback%=MIN(MAX(VAL(p2$),0),100)
        ELSE IF p$="TOOLS_ECHO_FADESTEP"
          bl_echo_fadestep%=MIN(MAX(VAL(p2$),0),256)
        ELSE IF p$="TOOLS_ECHO_CONT"
          IF p2$="TRUE"
            bl_echo_cont!=TRUE
          ELSE
            bl_echo_cont!=FALSE
          ENDIF
        ELSE IF p$="TOOLS_ECHO_FEEDBACK"
          IF p2$="TRUE"
            bl_echo_fdbk!=TRUE
          ELSE
            bl_echo_fdbk!=FALSE
          ENDIF
        ELSE IF p$="NOTE_EXTENSION"
          '
          '
          '
          '
          ' Envelopes
          '
        ELSE IF p$="ENVELOPE"
          env_num&=MIN(MAX(VAL(p2$),1),64)
        ELSE IF p$="ENV_SECTION"
          IF p2$="KEYOFF"
            env_sect&=1
          ELSE
            env_sect&=0
          ENDIF
        ELSE IF p$="ENVELOPE_TYPE"
          IF p2$="TONE"
            ss_menue%=1
          ELSE IF p2$="PANNING"
            ss_menue%=2
          ELSE
            ss_menue%=0
          ENDIF
        ELSE IF p$="ENVELOPE_COPY"
          env_copy&=MIN(MAX(VAL(p2$),1),64)
          '
          '
          '
          '
          '
          ' Sample Editor
          ' -------------
        ELSE IF p$="KEEP_BUFFER"
          IF first_time!
            IF p2$="TRUE"
              flag_keep_buffer!=TRUE
            ELSE
              flag_keep_buffer!=FALSE
            ENDIF
          ENDIF
          '
          ' Mix
          '
        ELSE IF p$="MIX_MASTER_VOLUME"
          se.mix_master_volume%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
          '
          ' Record
          '
        ELSE IF p$="REC_INPUT_DEVICE"
          se.rec_input_device%=0
        ELSE IF p$="REC_CHANNEL"
          IF INSTR(p2$,"R")>0
            se.rec_canal%=2
            IF INSTR(p2$,"L")>0
              se.rec_canal%=3
            ENDIF
          ELSE
            se.rec_canal%=1
          ENDIF
        ELSE IF p$="REC_ADC_FREQUENCY"
          IF p2$="32780"
            se.rec_adc_freq%=2
          ELSE IF p2$="24585"
            se.rec_adc_freq%=3
          ELSE IF p2$="19668"
            se.rec_adc_freq%=4
          ELSE IF p2$="16390"
            se.rec_adc_freq%=5
          ELSE IF p2$="12292"
            se.rec_adc_freq%=7
          ELSE IF p2$="9834"
            se.rec_adc_freq%=9
          ELSE IF p2$="8195"
            se.rec_adc_freq%=11
          ELSE
          ENDIF
        ELSE IF p$="REC_EXT_FREQUENCY"
          se.rec_ext_freq%=MIN(MAX(VAL(p2$),2000),65000)
        ELSE IF p$="REC_TRIGGER"
          IF p2$="TRUE"
            se.rec_flag_trigger!=TRUE
          ELSE
            se.rec_flag_trigger!=FALSE
          ENDIF
        ELSE IF p$="REC_TRIGGER_LEVEL"
          se.rec_trigger%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
          '
          ' Frequency
          '
        ELSE IF p$="FREQ_NEW_SAMPLE_FREQ"
          se.freq_nfe%=MIN(MAX(VAL(p2$),2000),65000)
        ELSE IF p$="FREQ_OLD_NOTE_FREQ"+STR$(se.freq_ofn%)
          se.freq_ofn%=MIN(MAX(VAL(p2$),20),32500)
        ELSE IF p$="FREQ_NEW_NOTE_FREQ"+STR$(se.freq_nfn%)
          se.freq_nfn%=MIN(MAX(VAL(p2$),20),32500)
        ELSE IF p$="FREQ_INTERPOLATION"""
          IF p2$="LINEAR"
            se.freq_iptype%=1
          ELSE IF p2$="3RD DEGREE"
            se.freq_iptype%=2
          ELSE
            se.freq_iptype%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_DISPLAY"
          IF p2$="LOGARITHMIC"
            se.freq_fftdisp%=1
          ELSE
            se.freq_fftdisp%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_WINDOW"
          IF p2$="BLACKMAN"
            se.freq_fftwin%=1
          ELSE
            se.freq_fftwin%=0
          ENDIF
        ELSE IF p$="FREQ_FFT_NOTE_DISPLAY"
          IF p2$="FALSE"
            se.freq_fftnoteon!=FALSE
          ELSE
            se.freq_fftnoteon!=TRUE
          ENDIF
        ELSE IF p$="FREQ_FFT_NUM_OF_POINTS"
          se.freq_fft_pnbr%=MIN(MAX(VAL(p2$),1),1024)
          '
          ' Flanger
          '
        ELSE IF p$="FLANGER_DRY_LEVEL"
          se.flanger_dry%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_WET_LEVEL"
          se.flanger_wet%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_LEFT_SOURCE"
          se.flanger_lsource%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="FLANGER_RIGHT_SOURCE"
          se.flanger_rsource%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="FLANGER_DELAY"
          se.flanger_time%=MIN(MAX(VAL(p2$)*1000,0),10000)
        ELSE IF p$="FLANGER_FREQ"
          se.flanger_freq%=MIN(MAX(VAL(p2$)*1000,0),50000)
        ELSE IF p$="FLANGER_DEPTH"
          se.flanger_depth%=MIN(MAX(VAL(p2$)*1000,0),6350)
        ELSE IF p$="FLANGER_FDBK_L_L"
          se.flanger_fdbkll%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_L_R"
          se.flanger_fdbklr%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_R_R"
          se.flanger_fdbkrr%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_FDBK_R_L"
          se.flanger_fdbkrl%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="FLANGER_INIT_PHASE"
          se.flanger_phase%=DIV(VAL(p2$)*4096,360) AND 4095
        ELSE IF p$="FLANGER_WAVE_TYPE"
          IF p2$="SQUARE"
            se.flanger_wave%=1
          ELSE IF p2$="TRIANGLE"
            se.flanger_wave%=2
          ELSE IF p2$="RAMPDOWN"
            se.flanger_wave%=3
          ELSE IF p2$="RAMPUP"
            se.flanger_wave%=4
          ELSE
            se.flanger_wave%=0
          ENDIF
        ELSE IF p$="FLANGER_STEREO"
          IF p2$="TRUE"
            se.flanger_stereo!=TRUE
          ELSE
            se.flanger_stereo!=FALSE
          ENDIF
          '
          ' Delay
          '
        ELSE IF p$="DELAY_FLAGS"
          se.delay_flags%=VAL(p2$) AND &H1F
        ELSE IF p$="DELAY_FEEDBACK"
          se.delay_feedback%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="DELAY_FEEDTIME"
          se.delay_timefeed%=MIN(MAX(VAL(p2$),0),99999)
        ELSE IF p$="DELAY_DRYLEVEL"
          se.delay_dry%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="DELAY_WETLEVEL"
          se.delay_wet%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="DELAY_MUTE_IN"
          se.delay_mutein%=MIN(MAX(VAL(p2$),0),99999)
        ELSE IF p$="DELAY_SOURCE"
          se.delay_source%=MIN(MAX(VAL(p2$),0),255)
          '
          ' Reverberation
          '
        ELSE IF p$="REVERB_SOURCE"
          se.rev_source%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="REVERB_DRYLEVEL"
          se.rev_drylevel%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="REVERB_REVERBLEVEL"
          se.rev_revlevel%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="REVERB_EARLYREFLEVEL"
          se.rev_ereflevel%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="REVERB_NBRTAPS"
          se.rev_nbrtaps%=MIN(MAX(VAL(p2$),1),8)
        ELSE IF p$="REVERB_NBRCOMB"
          se.rev_nbrcomb%=MIN(MAX(VAL(p2$),1),16)
        ELSE IF p$="REVERB_COMBGAIN"
          se.rev_combgain%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="REVERB_APRLEVEL"
          se.rev_aprg%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="REVERB_APRDELAY"
          se.rev_aprdelay%=MIN(MAX(VAL(p2$),0),99999)
          '
          ' Song To Disk
          '
        ELSE IF p$="SONG2DISK_STARTPOS"
          se.s2d_posstart%=MAX(VAL(p2$),0)
        ELSE IF p$="SONG2DISK_STARTLINE"
          se.s2d_linestart%=MAX(VAL(p2$),0)
        ELSE IF p$="SONG2DISK_ENDPOS"
          se.s2d_posend%=MAX(VAL(p2$),0)
        ELSE IF p$="SONG2DISK_ENDLINE"
          se.s2d_lineend%=MAX(VAL(p2$),0)
        ELSE IF p$="SONG2DISK_OUTPUT"
          IF p2$="DISK"
            se.s2d_out%=2
          ELSE
            se.s2d_out%=1
          ENDIF
        ELSE IF p$="SONG2DISK_STEREO"
          IF p2$="STEREO"
            se.s2d_stereo%=2
          ELSE
            se.s2d_stereo%=1
          ENDIF
        ELSE IF p$="SONG2DISK_BITS"
          IF p2$="16"
            se.s2d_bits%=2
          ELSE
            se.s2d_bits%=1
          ENDIF
        ELSE IF p$="SONG2DISK_SPEED"
          se.s2d_lineend%=MIN(MAX(PRED(VAL(p2$)),0),7)
        ELSE IF p$="SONG2DISK_MAXLENGTH"
          se.s2d_maxsize%=MIN(MAX(VAL(p2$),1),4194304)
        ELSE IF p$="SONG2DISK_2NDTIME"
          IF p2$="TRUE"
            se.s2d_2ndtime!=TRUE
          ELSE
            se.s2d_2ndtime!=FALSE
          ENDIF
          '
          ' Compression
          '
        ELSE IF p$="COMP_SOURCE"
          se.comp_source%=MIN(MAX(VAL(p2$),0),255)
        ELSE IF p$="COMP_LEVEL"
          se.comp_level%=DIV(32768*MIN(MAX(VAL(p2$),0),999.9),100)
        ELSE IF p$="COMP_SPEED"
          se.delay_timefeed%=MIN(MAX(VAL(p2$)*1000,0),99999)
          '
          ' Other stuff /sjx.
          '
        ELSE IF p$="USER_ID"
          user%=VAL(p2$)
          '
          ' (end)
          '
        ENDIF
      ENDIF
    ENDIF
  WEND
  CLOSE #0
RETURN
PROCEDURE load_prefs_analyse_touche(f$,t$)
  LOCAL a%,am%,ae%,bm%,be%,numero_fonction%,param%
  LOCAL parametre!,groupement!,trouve!
  LOCAL a$,code$,code1$,code2$
  '
  ' Un peu de menage
  '
  WHILE INSTR(f$,"  ")>0                        ! Vide les doubles-espaces
    a%=INSTR(f$,"  ")
    f$=LEFT$(f$,a%)+RIGHT$(f$,PRED(SUB(LEN(f$),a%)))
  WEND
  '
  WHILE INSTR(t$,"+")>0                         ! Vide les "+"
    a%=INSTR(t$,"+")
    t$=LEFT$(t$,PRED(a%))+RIGHT$(t$,SUB(LEN(t$),a%))
  WEND
  WHILE INSTR(t$,"  ")>0                        ! Vide les doubles-espaces
    a%=INSTR(t$,"  ")
    LET t$=LEFT$(t$,a%)+RIGHT$(t$,PRED(SUB(LEN(t$),a%)))
  WEND
  '
  ' Affectations
  '
  RESTORE keycode_names
  numero_fonction%=0
  trouve!=FALSE
  READ code$
  WHILE code$<>"***" AND NOT trouve!
    code1$=code$
    IF LEFT$(code$,1)="*"                       ! Un parametre ?
      code$=RIGHT$(code$,PRED(LEN(code$)))
      parametre!=TRUE
    ELSE
      parametre!=FALSE
    ENDIF
    IF LEFT$(code$,1)="^"                       ! Un groupement ?
      code$=RIGHT$(code$,PRED(LEN(code$)))
      groupement!=TRUE
    ELSE
      groupement!=FALSE
    ENDIF
    IF LEFT$(f$,LEN(code$))=code$               ! C'est le bon code
      IF parametre!
        f$=RIGHT$(f$,SUB(LEN(f$),LEN(code$)))   ! Recupere le parametre
        WHILE INSTR(f$," ")>0                   ! Enleve les espaces sinon c'est galere
          a%=INSTR(f$," ")
          f$=LEFT$(f$,PRED(a%))+RIGHT$(f$,SUB(LEN(f$),a%))
        WEND
        param%=VAL(f$)                          ! Hop on l'a!
      ELSE
        param%=0
      ENDIF
      '
      code2$=code1$                             ! Cherche si l'emplacement est libre
      WHILE BYTE{ADD(V:dejafait_touche$,numero_fonction%)}<>0 AND code2$=code1$ AND code2$<>"***"
        READ code2$                             ! Sinon trouve dans la meme serie un autre emplacement
        INC numero_fonction%
      WEND
      IF code2$=code1$                          ! Si c'est bon...
        GOSUB cherche_combinaison_touches(t$,am%,ae%,bm%,be%)
        keydef_val%(0,numero_fonction%)=ae%
        keydef_val%(1,numero_fonction%)=be%
        keydef_mask%(0,numero_fonction%)=am%
        keydef_mask%(1,numero_fonction%)=bm%
        keydef_param%(numero_fonction%)=param%
        BYTE{ADD(V:dejafait_touche$,numero_fonction%)}=1
        trouve!=TRUE
      ENDIF
    ENDIF
    INC numero_fonction%
    READ code$
  WEND
RETURN
PROCEDURE save_prefs
  LOCAL a$
  IF flag_registered!
    IF km%=2 AND nfile_prefs$<>""
      a$=npath_prefs$+nfile_prefs$
    ELSE
      CLS
      GOSUB cadre_texte("SAVE PREFERENCES",0,0,PRED(scr_ncol%))
      FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
    ENDIF
    IF a$<>""
      CLS
      GOSUB cadre_texte("WAITING : SAVING PREFERENCES "+a$+"...",0,0,PRED(scr_ncol%))
      GOSUB save_prefs2(a$)
      GOSUB separe_nom_chemin(a$)
      nfile_prefs$=nfile_$
      npath_prefs$=npath_$
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE save_prefs2(fic$)
  LOCAL i%,j%,n%
  LOCAL a$,b$,lig$,old$
  LOCAL param!,groupement!
  OPEN "o",#0,fic$
  PRINT #0,";*****************************************************************************"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*                              GRAOUMF TRACKER                              *"
  PRINT #0,";*                        by Laurent de Soras 1994-95                        *"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*                              Preference file                              *"
  PRINT #0,";*                          Last update: "+LEFT$(DATE$+"  ",10)+"                          *"
  PRINT #0,";*                                                                           *"
  PRINT #0,";*****************************************************************************"
  PRINT #0,"; Tab = 8"
  PRINT #0
  PRINT #0,"; Text following a "";"" is a comment and ignored by Graoumf Tracker."
  PRINT #0,"; In the file names, a ""/"" means no file."
  PRINT #0,"; ""$"" means the value is in hexadecimal."
  PRINT #0
  PRINT #0
  PRINT #0
  '
  '
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  PRINT #0,";============================================================================;"
  PRINT #0,";                       Keyboard                                             ;"
  PRINT #0,";============================================================================;"
  PRINT #0
  lig$="keyboard_type = "+FN get_elt_in_list$("azerty,qwerty",keyboard_type%)
  GOSUB write_comment("azerty or qwerty")
  lig$="keyboard_buffer = "+FN offon$(flag_keyboard_buffer!)
  GOSUB write_comment("Keep pressed keys in memory")
  PRINT #0
  PRINT #0,"; Names of available keys:"
  PRINT #0,";   a-z, esc, tab, space, return, backspace, help, undo, ins, del, clr"
  PRINT #0,";   up, down, left, right, F1-F10, <, #, &, 1, pad0, padpoint, nokey"
  PRINT #0,"; This keys are considered as groups:"
  PRINT #0,";   fkeys, numpad"
  PRINT #0,"; Following keys can be combined with others:"
  PRINT #0,";   shift (left or right), lshift, rshift, ctrl, alt, caps, nocaps"
  PRINT #0,"; You can define two combinations, separated by ""/""."
  PRINT #0
  old$=""
  RESTORE keycode_names
  FOR i%=0 TO 83
    ' Nom de la fonction
    READ a$
    FOR j%=0 TO PRED(LEN(a$))                   ! Conversion en minuscules
      a%=BYTE{ADD(V:a$,j%)}
      IF a%>=65 AND a%<91
        BYTE{ADD(V:a$,j%)}=a% OR &H20
      ENDIF
    NEXT j%
    IF a$=old$
      INC n%
    ELSE
      n%=1
    ENDIF
    old$=a$
    ' Attributs
    IF LEFT$(a$,1)="*"
      param!=TRUE
      a$=RIGHT$(a$,PRED(LEN(a$)))
    ELSE
      param!=FALSE
    ENDIF
    IF LEFT$(a$,1)="^"
      groupement!=TRUE
      a$=RIGHT$(a$,PRED(LEN(a$)))
    ELSE
      groupement!=FALSE
    ENDIF
    lig$=a$
    ' Parametre
    IF param!
      IF keydef_val%(0,i%)=0                    ! Touche non definie
        b$="n"
        IF groupement!
          b$=b$+STR$(n%)
        ENDIF
      ELSE
        b$=STR$(keydef_param%(i%))
      ENDIF
      SELECT i%
      CASE 45 TO 54                             ! Ne met pas de "+" sur les lines
        lig$=lig$+b$
      DEFAULT
        IF b$<>"0"
          lig$=lig$+" + "+b$
        ENDIF
      ENDSELECT
    ENDIF
    lig$="keydef"+CHR$(9)+lig$+STRING$(MAX(SUCC(DIV(SUB(31,LEN(lig$)),8)),1),9)  ! Tab a la 41eme colonne
    ' Nom des touches
    lig$=lig$+"= "+FN donne_combinaison_touche$(keydef_mask%(0,i%),keydef_val%(0,i%),keydef_mask%(1,i%),keydef_val%(1,i%))
    ' Groupement
    IF groupement!
      lig$=lig$+CHR$(9)+"; Group"
    ENDIF
    ' Ligne terminee
    PRINT #0,lig$
  NEXT i%
  PRINT #0
  PRINT #0
  PRINT #0
  '
  '
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  PRINT #0,";============================================================================;"
  PRINT #0,";                       Main pannel                                          ;"
  PRINT #0,";============================================================================;"
  PRINT #0
  lig$="system_memory = "+STR$(system_memory%)
  GOSUB write_comment("Memory for the system (bytes). Min: 16384")
  lig$="color_pal ="
  FOR i%=0 TO 15
    lig$=lig$+" "+HEX$(SHR(PEEK(ADD(&HFFFF9800,SHL(i%,2))),4),1)
    lig$=lig$+HEX$(SHR(PEEK(ADD(&HFFFF9801,SHL(i%,2))),4),1)
    lig$=lig$+HEX$(SHR(PEEK(ADD(&HFFFF9803,SHL(i%,2))),4),1)
  NEXT i%
  PRINT #0,lig$
  lig$="grmode_overscan = "+FN get_elt_in_list$("leave,no,yes",SUCC(grmode_overscan%))
  GOSUB write_comment("yes, no, leave")
  lig$="grmode_80col = "+FN get_elt_in_list$("leave,no,yes",SUCC(grmode_80colonnes%))
  GOSUB write_comment("yes, no, leave")
  lig$="grmode_400lines = "+FN get_elt_in_list$("leave,no,yes",SUCC(grmode_entrelace%))
  GOSUB write_comment("yes, no, leave")
  lig$="grmode_preserve = "+FN get_elt_in_list$("no,yes",grmode_preserve%)
  GOSUB write_comment("yes, no")
  lig$="grmode_skipxbra = "+FN get_elt_in_list$("no,yes",grmode_skipxbra%)
  GOSUB write_comment("yes, no")
  lig$=""
  PRINT #0,"gtlogo_color = "+STR$(graoumf_logo_color%)
  GOSUB write_comment("RGB for 16 colors")
  lig$="number_of_tracks = "+STR$(nbr_track%)
  GOSUB write_comment("1-32")
  lig$="instrument = "+STR$(instr%)
  GOSUB write_comment("1-255")
  lig$="sample = "+STR$(sample%)
  GOSUB write_comment("1-255")
  lig$="preset = "+STR$(n_preset%)
  GOSUB write_comment("1-32")
  lig$="line_step = "
  SELECT line_step%
  CASE -255 TO 255
    lig$=lig$+STR$(line_step%)
  CASE 256
    lig$=lig$+"next line taken"
  CASE 257
    lig$=lig$+"next note"
  CASE 258
    lig$=lig$+"next FX"
  CASE 259
    lig$=lig$+"next volume"
  ENDSELECT
  GOSUB write_comment("Jump n-1 lines when entering a note")
  lig$="octave = "+STR$(SUCC(octave%))
  GOSUB write_comment("1-7")
  lig$="pattern_display = "+STR$(type_affpiste%)
  GOSUB write_comment("0 (without effect), 1 (normal) or 2 (with")
  GOSUB write_comment("volume column)")
  a%=DIV(SUB(scr_haut%,180),6) OR 1
  IF a%=haut_lig%
    a%=99999
  ELSE
    a%=haut_lig%
  ENDIF
  lig$="pattern_line_max = "+STR$(a%)
  GOSUB write_comment("Maximum number of lines displayed on screen.")
  GOSUB write_comment("99999 (or very high #) = resolution limit.")
  lig$="numpad = "+FN get_elt_in_list$("samples,drumkit",drumpad_flag%)
  GOSUB write_comment("samples, drumkit")
  lig$="menu = "+FN get_elt_in_list$("disk,tools,instruments,samples,envelopes",PRED(ss_menu%))
  GOSUB write_comment("disk, tools, instruments, samples, envelopes, control")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Disk"
  PRINT #0,";------"
  PRINT #0
  lig$=";program_path = "+npath_prog$
  GOSUB write_comment("Path of GTPLAY.PGT and DUMTRACK.PGT. Usually")
  GOSUB write_comment("unused.")
  PRINT #0,"module_path = "+npath_module$
  PRINT #0,"sample_path = "+npath_sample$
  PRINT #0,"autoload_path = "+npath_autoload$
  PRINT #0,"pref_path = "+npath_prefs$
  PRINT #0,"misc_path = "+npath_div$
  PRINT #0
  PRINT #0,"module_ext = "+next_module$
  PRINT #0,"sample_ext = "+next_sample$
  PRINT #0
  PRINT #0,"module_file = ";
  IF nfile_module$<>""
    PRINT #0,nfile_module$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"sample_file = ";
  IF nfile_sample$<>""
    PRINT #0,nfile_sample$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"autoload_file = ";
  IF nfile_autoload$<>""
    PRINT #0,nfile_autoload$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0,"pref_file = ";
  IF nfile_prefs$<>""
    PRINT #0,nfile_prefs$
  ELSE
    PRINT #0,"/"
  ENDIF
  PRINT #0
  PRINT #0,"save_config_gt2 = "+FN falsetrue$(flag_gt2cnf!)
  PRINT #0,"module_backup = "+FN falsetrue$(flag_backup_modules!)
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Tools"
  PRINT #0,";-------"
  PRINT #0
  lig$="block_type = "+FN get_elt_in_list$("track,pattern,preset",trackpat%)
  GOSUB write_comment("track, pattern, preset")
  lig$="block_song = "+FN falsetrue$(bl_flagsong!)
  GOSUB write_comment("If it's on the whole song or just 1 pattern")
  PRINT #0,"block_replace = "+FN falsetrue$(replaceblock%)
  PRINT #0,"block_mask = "+FN falsetrue$(maskblock%)
  ' block_mask1 = ??? ?? ???? ??	; * Not implemented *
  ' block_mask2 = ??? ?? ???? ??	; * Not implemented *
  lig$="tools_echo_step = "+STR$(bl_echo_lines%)
  GOSUB write_comment("1-64")
  lig$="tools_echo_fdbkval = "+STR$(bl_echo_feedback%)
  GOSUB write_comment("Feedback value (0-100 per cent)")
  lig$="tools_echo_fadestep = "+STR$(bl_echo_fadestep%)
  GOSUB write_comment("0-255")
  PRINT #0,"tools_echo_cont = "+FN falsetrue$(bl_echo_cont!)
  lig$="tools_echo_feedback = "+FN falsetrue$(bl_echo_fdbk!)
  GOSUB write_comment("Feedback (logarithmic fade) or linear fade")
  PRINT #0
  ' note_extension = ???? ??	; * Not implemented *
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Envelopes"
  PRINT #0,";-----------"
  PRINT #0
  lig$="envelope = "+STR$(env_num&)
  GOSUB write_comment("1-64")
  lig$="env_section = "+FN get_elt_in_list$("attack,keyoff",env_sect&)
  GOSUB write_comment("attack, keyoff")
  lig$="envelope_type = "+FN get_elt_in_list$("volume,tone,panning",ss_menue%)
  GOSUB write_comment("volume, tone, panning")
  lig$="envelope_copy = "+STR$(env_copy&)
  GOSUB write_comment("1-64")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; MIDI"
  PRINT #0,";------"
  PRINT #0
  PRINT #0,"midi_in = "+FN falsetrue$(midi_flag_data_in!)
  lig$="midi_sync = "+FN get_elt_in_list$("none,in,out",midi_flag_synchro%)
  GOSUB write_comment("none, in, out")
  ' PRINT #0,"midi_in_note_off = "+FN falsetrue$(midi_flag_note_off!)
  ' PRINT #0,"midi_in_velocity = "+FN falsetrue$(midi_flag_velocity!)
  PRINT #0,"midi_in_polyphonic = "+FN falsetrue$(midi_polyphonic_mode!)
  PRINT #0
  PRINT #0
  PRINT #0
  '
  '
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  PRINT #0,";============================================================================;"
  PRINT #0,";                       Sample Editor                                        ;"
  PRINT #0,";============================================================================;"
  PRINT #0
  lig$="keep_buffer = "+FN falsetrue$(flag_keep_buffer!)
  GOSUB write_comment("true: keep better the buffer when loading")
  GOSUB write_comment("a module (but it's slower)")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Mix"
  PRINT #0,";-----"
  PRINT #0
  lig$="mix_master_volume = "+FN pourcent$(se.mix_master_volume%,32768)
  GOSUB write_comment("%")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Frequency"
  PRINT #0,";-----------"
  PRINT #0
  lig$="freq_new_sample_freq = "+STR$(se.freq_nfe%)
  GOSUB write_comment("Hz")
  lig$="freq_old_note_freq = "+STR$(se.freq_ofn%)
  GOSUB write_comment("Hz")
  lig$="freq_new_note_freq = "+STR$(se.freq_nfn%)
  GOSUB write_comment("Hz")
  lig$="freq_interpolation = "+FN get_elt_in_list$("none,linear,3rd degree",se.freq_iptype%)
  GOSUB write_comment("none, linear")
  lig$="freq_fft_display = "+FN get_elt_in_list$("linear,logarithmic",se.freq_fftdisp%)
  GOSUB write_comment("linear, logarithmic")
  lig$="freq_fft_window = "+FN get_elt_in_list$("rectangle,Blackman",se.freq_fftwin%)
  GOSUB write_comment("rectangle, Blackman")
  PRINT #0,"freq_fft_note_display = "+FN falsetrue$(se.freq_fftnoteon!)
  lig$="freq_fft_num_of_points = "+STR$(se.freq_fft_pnbr%)
  GOSUB write_comment("1-1024")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Flanger"
  PRINT #0,";---------"
  PRINT #0
  lig$="flanger_dry_level = "+FN pourcent$(se.flanger_dry%,32768)
  GOSUB write_comment("%")
  lig$="flanger_wet_level = "+FN pourcent$(se.flanger_wet%,32768)
  GOSUB write_comment("%")
  lig$="flanger_left_source = "
  IF se.flanger_lsource%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.flanger_lsource%)
  ENDIF
  GOSUB write_comment("Left source: buffer or sample # (1-255)")
  lig$="flanger_right_source = "
  IF se.flanger_rsource%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.flanger_rsource%)
  ENDIF
  GOSUB write_comment("Right source: buffer or sample # (1-255)")
  lig$="flanger_delay = "+STR$(se.flanger_time%/1000)
  GOSUB write_comment("Flanger delay (ms). Maximum: 10 ms")
  lig$="flanger_freq = "+STR$(se.flanger_freq%/1000)
  GOSUB write_comment("Flanger LFO frequency (Hz). Maximum: 50 Hz")
  lig$="flanger_depth = "+STR$(se.flanger_depth%/1000)
  GOSUB write_comment("Flanger depth (ms). Maximum: 6.35 ms")
  lig$="flanger_fdbk_l_l = "+FN pourcent$(se.flanger_fdbkll%,32768)
  GOSUB write_comment("Feedback Left -> Left (%)")
  lig$="flanger_fdbk_l_r = "+FN pourcent$(se.flanger_fdbklr%,32768)
  GOSUB write_comment("Feedback Left -> Right (%)")
  lig$="flanger_fdbk_r_r = "+FN pourcent$(se.flanger_fdbkrr%,32768)
  GOSUB write_comment("Feedback Right -> Right (%)")
  lig$="flanger_fdbk_r_l = "+FN pourcent$(se.flanger_fdbkrl%,32768)
  GOSUB write_comment("Feedback Right -> Left (%)")
  lig$="flanger_init_phase = "+STR$(MUL(se.flanger_phase%,360)/4096)
  GOSUB write_comment("Initial phase (0-359¯)")
  lig$="flanger_wave_type = "+FN get_elt_in_list$("sin,square,triangle,rampdown,rampup",se.flanger_wave%)
  GOSUB write_comment("sin, square, triangle, rampdown or rampup")
  lig$="flanger_stereo = "+FN falsetrue$(se.flanger_stereo!)
  GOSUB write_comment("false = mono, true = stereo")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Delay"
  PRINT #0,";-------"
  PRINT #0
  lig$="delay_flags = "+STR$(se.delay_flags%)
  GOSUB write_comment("+1: Tap 1 on, +2: Tap 2 on, +4: Tap 3 on, +8: Tap 4 on, +16: Mute in, +32: Multi-tap mode")
  lig$="delay_feedback = "+FN pourcent$(se.delay_feedback%,32768)
  GOSUB write_comment("%")
  lig$="delay_feedtime = "+STR$(se.delay_timefeed%)
  GOSUB write_comment("(ms)")
  lig$="delay_drylevel = "+FN pourcent$(se.delay_dry%,32768)
  GOSUB write_comment("%")
  lig$="delay_wetlevel = "+FN pourcent$(se.delay_wet%,32768)
  GOSUB write_comment("%")
  lig$="delay_mute_in = "+STR$(se.delay_mutein%)
  GOSUB write_comment("(ms)")
  lig$="delay_source = "
  IF se.delay_source%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.delay_source%)
  ENDIF
  GOSUB write_comment("Source: buffer or sample # (1-255)")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Reverberation"
  PRINT #0,";---------------"
  PRINT #0
  lig$="reverb_source = "
  IF se.rev_source%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.rev_source%)
  ENDIF
  GOSUB write_comment("Source: buffer or sample # (1-255)")
  lig$="reverb_drylevel = "+FN pourcent$(se.rev_drylevel%,32768)
  GOSUB write_comment("%")
  lig$="reverb_reverblevel = "+FN pourcent$(se.rev_revlevel%,32768)
  GOSUB write_comment("%")
  lig$="reverb_earlyreflevel = "+FN pourcent$(se.rev_ereflevel%,32768)
  GOSUB write_comment("Early reflection level (%)")
  lig$="reverb_nbrtaps = "+STR$(se.rev_nbrtaps%)
  GOSUB write_comment("Nbr of taps for early reflection (1-16)")
  lig$="reverb_nbrcomb = "+STR$(se.rev_nbrcomb%)
  GOSUB write_comment("Nbr of comb filters (1-8)")
  lig$="reverb_combgain = "+FN pourcent$(se.rev_combgain%,32768)
  GOSUB write_comment("%")
  lig$="reverb_aprlevel = "+FN pourcent$(se.rev_aprg%,32768)
  GOSUB write_comment("All Pass Reverb level (%)")
  lig$="reverb_aprdelay = "+STR$(se.rev_aprdelay%)
  GOSUB write_comment("All Pass Reverb delay (ms)")
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Song To Disk"
  PRINT #0,";--------------"
  PRINT #0
  lig$="song2disk_startpos = $"+HEX$(se.s2d_posstart%)
  GOSUB write_comment("Start position")
  lig$="song2disk_startline = $"+HEX$(se.s2d_ligstart%)
  GOSUB write_comment("Start line")
  lig$="song2disk_endpos = $"+HEX$(se.s2d_posend%)
  GOSUB write_comment("End position")
  lig$="song2disk_endline = $"+HEX$(se.s2d_ligend%)
  GOSUB write_comment("End line")
  lig$="song2disk_output = "+FN get_elt_in_list$("block,disk",PRED(se.s2d_out%))
  GOSUB write_comment("block, disk")
  lig$="song2disk_stereo = "+FN get_elt_in_list$("mono,stereo",PRED(se.s2d_stereo%))
  GOSUB write_comment("mono, stereo")
  lig$="song2disk_bits = "+STR$(MUL(se.s2d_bits%,8))
  GOSUB write_comment("Resolution (8 or 16 bits)")
  lig$="song2disk_speed = "+STR$(SUCC(se.s2d_speed%))
  GOSUB write_comment("Speed (1 = fast, 8 = low)")
  lig$="song2disk_maxlength = "+STR$(se.s2d_maxsize%)
  GOSUB write_comment("Kb")
  ' PRINT #0,"song2disk_2ndtime = "+fn falsetrue$(se.s2d_2ndtime!)
  PRINT #0
  '
  '
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; Compression"
  PRINT #0,";-------------"
  PRINT #0
  lig$="comp_source = "
  IF se.comp_source%=0
    lig$=lig$+"buffer"
  ELSE
    lig$=lig$+STR$(se.comp_source%)
  ENDIF
  GOSUB write_comment("Source: buffer or sample # (1-255)")
  lig$="comp_level = "+FN pourcent$(se.comp_level%,32768)
  GOSUB write_comment("%")
  lig$="comp_speed = "+STR$(se.comp_speed%/1000)
  GOSUB write_comment("(ms)")
  PRINT #0
  PRINT #0
  PRINT #0
  '
  '
  '
  ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  '
  PRINT #0,";-----------------------------------------------------------------------------"
  PRINT #0,"; End of file"
  CLOSE #0
RETURN
PROCEDURE write_comment(a$)
  ' Ecrit sur le fichier #0 un commentaire au bout de la variable lig$
  ' Utilise et modifie lig$
  ' Tab a la 33eme colonne
  lig$=lig$+STRING$(MAX(SUCC(DIV(SUB(31,LEN(lig$)),8)),1),9)
  lig$=lig$+"; "+a$
  PRINT #0,lig$
  lig$=""
RETURN
PROCEDURE autoload
  ' Autochargement de modules/samples
  ' Module
  LOCAL i%,sample%,erreur%
  LOCAL cat$,a$,baze$,masque_fichier$,dta$
  ~FRE(0)
  SHOWM
  GOSUB bee(TRUE)
  flag_autoload!=TRUE
  dta$=STRING$(44,0)
  masque_fichier$=npath_autoload$+next_module$+CHR$(0)
  ~FRE(0)
  ~GEMDOS(&H1A,L:V:dta$)
  IF GEMDOS(&H4E,L:V:masque_fichier$,1)=>0
    baze$=""
    i%=ADD(V:dta$,30)
    WHILE PEEK(i%)<>0
      baze$=baze$+CHR$(PEEK(i%))
      INC i%
    WEND
    a$=npath_autoload$+baze$
    GOSUB aff_message("WAITING : AUTOLOADING MODULE "+a$)
    GOSUB load_module2
    IF play%=1
      GOSUB play_song(TRUE)
    ELSE IF play%=2
      GOSUB play_pattern(TRUE)
    ELSE
      GOSUB stop_voices
    ENDIF
    IF erreur%>0
      GOSUB separe_nom_chemin(a$)
      npath_module$=npath_$
      nfile_module$=nfile_$
    ENDIF
    IF ss_menu%=1
      GOSUB affiche_icones_diskb
    ENDIF
    GOSUB affiche_info_song
    GOSUB affiche_info_sample
    GOSUB affiche_info_preset
    GOSUB affiche_c_pattern
  ENDIF
  ' Samples
  masque_fichier$=npath_autoload$+next_sample$+CHR$(0)
  ~GEMDOS(&H1A,L:V:dta$)
  IF GEMDOS(&H4E,L:V:masque_fichier$,1)=>0
    cat$=""
    REPEAT
      baze$=""
      i%=ADD(V:dta$,30)
      WHILE PEEK(i%)<>0
        baze$=baze$+CHR$(PEEK(i%))
        INC i%
      WEND
      cat$=cat$+baze$+CHR$(0)
    UNTIL LEN(cat$)>32000 OR GEMDOS(&H4F)<0
    sample%=1
    REPEAT
      IF FN length(sample%)=0     ! Trouve une place pour charger
        i%=INSTR(cat$,CHR$(0))
        baze$=LEFT$(cat$,PRED(i%))
        a$=npath_autoload$+baze$
        cat$=RIGHT$(cat$,SUB(LEN(cat$),i%))
        GOSUB aff_message("WAITING : AUTOLOADING SAMPLE "+a$)
        GOSUB load_sample2(FALSE)
        IF erreur%=1
          GOSUB aff_message("NOT ENOUGH MEMORY TO LOAD THIS SAMPLE !")
          IF FN length(sample%)<>0
            GOSUB affiche_info_sample
            INC sample%
          ENDIF
        ENDIF
      ELSE
        GOSUB affiche_info_sample
        INC sample%
      ENDIF
    UNTIL sample%=256 OR LEN(cat$)=0
    sample%=1
    GOSUB affiche_info_sample
  ENDIF
fin_autoload:
  flag_autoload!=FALSE
  GOSUB bee(FALSE)
  SHOWM
RETURN
PROCEDURE make_directory
  LOCAL a$,bouton%
  CLS
  GOSUB cadre_texte("MAKE NEW DIRECTORY",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    CLS
    GOSUB separe_nom_chemin(a$)
    IF nfile_$<>""
      GOSUB dialog("DISK","Do you really want|to create a new directory|"+a$+"\|ON DISK ?","YES|CANCEL",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("CREATING DIRECTORY "+a$+"\...",0,0,PRED(scr_ncol%))
        MKDIR a$
        npath_div$=a$+"\"
      ENDIF
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE delete_directory
  LOCAL bouton%,e%
  LOCAL a$,b$
  CLS
  GOSUB cadre_texte("DELETE DIRECTORY",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    CLS
    GOSUB separe_nom_chemin(a$)
    IF FN exist(npath_$+"*.*")
      GOSUB dialog("STOP","Directory|"+npath_$+"|must be empty","Cancel",MOUSEX,MOUSEY)
    ELSE
      GOSUB dialog("DISK","Do you really want|to delete directory|"+npath_$+"|on disk ?","Ok|Cancel",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("DELETING DIRECTORY "+npath_$+"...",0,0,PRED(scr_ncol%))
        a$=LEFT$(npath_$,PRED(LEN(npath_$)))
        b$=a$+CHR$(0)
        e%=GEMDOS(58,L:V:b$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+"during deleting directory|"+a$+"\","Cancel",MOUSEX,MOUSEY)
        ENDIF
        GOSUB separe_nom_chemin(a$)
        npath_div$=npath_$
      ENDIF
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE delete_file
  LOCAL bouton%,e%
  LOCAL b$
  CLS
  GOSUB cadre_texte("DELETE FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB dialog("FILE","Do you really|want to delete|"+a$+"|on disk ?","Ok|Cancel",MOUSEX,MOUSEY)
      IF bouton%=0
        CLS
        GOSUB cadre_texte("DELETING FILE "+a$+"...",0,0,PRED(scr_ncol%))
        b$=a$+CHR$(0)
        e%=GEMDOS(65,L:V:a$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+" during deleting|file "+a$,"Cancel",MOUSEX,MOUSEY)
        ENDIF
        GOSUB separe_nom_chemin(a$)
        npath_div$=npath_$
      ENDIF
    ELSE
      GOSUB dialog("FILE","File not found:|"+a$,"Cancel",MOUSEX,MOUSEY)
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE format_disk                   !!!
RETURN
PROCEDURE rename_file
  LOCAL e%
  LOCAL a$,b$,c$,d$,e$,f$
  ~FRE(0)
  CLS
  GOSUB cadre_texte("RENAME A FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_div$+"*.*","",a$
  IF a$<>""
    IF FN exist(a$)
      CLS
      GOSUB cadre_texte("SELECT NEW NAME OF "+a$,0,0,PRED(scr_ncol%))
      GOSUB separe_nom_chemin(a$)
      npath_div$=npath_$
      c$=nfile_$
      FILESELECT npath_div$+"*.*",c$,b$
      GOSUB separe_nom_chemin(b$)
      d$=nfile_$
      IF d$<>"" AND d$<>c$ AND npath_$=npath_div$
        CLS
        GOSUB cadre_texte("RENAMING "+a$+" AS "+d$+"...",0,0,PRED(scr_ncol%))
        f$=a$+CHR$(0)
        e$=b$+CHR$(0)
        e%=GEMDOS(86,0,L:V:f$,L:V:e$)
        IF e%<0
          GOSUB dialog("FILE","Error "+STR$(e%)+" during renaming.","Ok",MOUSEX,MOUSEY)
        ENDIF
      ELSE IF npath_$<>npath_div$
        GOSUB dialog("RENAME","Old and new file|must be in the|same path!","Cancel",MOUSEX,MOUSEY)
      ENDIF
    ELSE
      GOSUB dialog("FILE","File not found:|"+a$,"Cancel",MOUSEX,MOUSEY)
    ENDIF
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE separe_nom_chemin(aaaa$)
  ' Chercher le nom et le chemin
  ' Renvoie npath_$ et nfile_$
  LOCAL iiii%,flag%
  nfile_$=""
  npath_$=""
  flag%=0
  FOR iiii%=LEN(aaaa$) DOWNTO 1
    IF MID$(aaaa$,iiii%,1)="\" AND flag%=0
      flag%=1
      npath_$=LEFT$(aaaa$,iiii%)
    ELSE IF flag%=0
      nfile_$=MID$(aaaa$,iiii%,1)+nfile_$
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE selpath_module
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR MODULE",0,0,PRED(scr_ncol%))
  FILESELECT npath_module$+next_module$,nfile_module$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_module$=nfile_$
    npath_module$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_sample
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR SAMPLE",0,0,PRED(scr_ncol%))
  FILESELECT npath_sample$+next_sample$,nfile_sample$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_sample$=nfile_$
    npath_sample$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_prefs
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR PREFERENCE FILE",0,0,PRED(scr_ncol%))
  FILESELECT npath_prefs$+"*.INF",nfile_prefs$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_prefs$=nfile_$
    npath_prefs$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE selpath_autoload
  LOCAL a$
  CLS
  GOSUB cadre_texte("SELECT PATH FOR AUTOLOAD",0,0,PRED(scr_ncol%))
  FILESELECT npath_autoload$+next_module$,nfile_autoload$,a$
  IF a$<>""
    GOSUB separe_nom_chemin(a$)
    nfile_autoload$=nfile_$
    npath_autoload$=npath_$
  ENDIF
  GOSUB affiche_panneau_principal
RETURN
'
' Gestion du clavier
' ------------------
PROCEDURE gestion_clavier
  '
  ' Recupere le code clavier
  '
  IF GEMDOS(11)<>0                              ! une touche ?
    KEYGET clavier%
    GOSUB vide_buffer_clavier
    clavier%=clavier% AND &H1FFF00FF
  ELSE
    clavier%=SHL(BIOS(11,-1) AND &H1F,24)       ! Kbshift
  ENDIF
  IF clavier%>0
    '
    ' Trafique le code clavier et identifie la fonction
    '
    a%=FN key_trafique_code_clavier(clavier%)
    clavier%=LONG{a%}
    numero_touche%=CARD{ADD(a%,4)}
    IF INT{ADD(a%,6)}<>-1
      fonction_trouvee!=TRUE
      numero_fonction%=CARD{ADD(a%,6)}
    ELSE
      fonction_trouvee!=FALSE
    ENDIF
    asciicode%=clavier% AND 255                 ! Remise a jour apres les modifs
    scancode%=SHR(clavier%,16) AND 255          ! Idem
    '
    ' Sauts aux sous-routines
    '
    IF fonction_trouvee!
      SELECT numero_fonction%
      CASE 0 TO 7
        ON SUCC(numero_fonction%) GOSUB key_cursor_left,key_cursor_right,key_prev_line,key_next_line,key_prev_octave,key_next_octave,key_prev_column,key_next_column
      CASE 8 TO 15
        ON SUB(numero_fonction%,7) GOSUB key_prev_bar,key_next_bar,key_prev_songpos,key_next_songpos,key_prev_preset,key_next_preset,key_dec_step,key_inc_step
      CASE 16 TO 23
        ON SUB(numero_fonction%,15) GOSUB key_dec_high,key_inc_high,key_play_line,key_play_song,key_cont_song,key_play_pattern,key_cont_pattern,key_stop_edit
      CASE 24 TO 31
        ON SUB(numero_fonction%,23) GOSUB key_prev_instr,key_next_instr,key_prev_sample,key_next_sample,key_expand,key_cpu_time,key_replay_freq,key_interpolation_one_track
      CASE 32 TO 39
        ON SUB(numero_fonction%,31) GOSUB key_interpolation_all_tracks,key_load_module,key_save_module,key_resync_screen,key_snapshot,key_samplepad_drumpad,key_help,key_block_start
      CASE 40 TO 47
        ON SUB(numero_fonction%,39) GOSUB key_block_end,key_instr_under_cursor,key_clear_note,key_clear_effect,key_clear_volume,key_clear_whole_note,key_copy_block_track,key_copy_block_pattern
      CASE 48 TO 51
        ON SUB(numero_fonction%,47) GOSUB key_copy_block_preset,key_copy_block_track_cursor,key_insert_line_pattern,key_insert_line_track
      CASE 52 TO 55
        ON SUB(numero_fonction%,51) GOSUB key_insert_line_preset,key_insert_line_pattern_rotate,key_insert_line_track_rotate,key_insert_line_preset_rotate
      CASE 56 TO 63
        ON SUB(numero_fonction%,55) GOSUB key_delete_line_pattern,key_delete_line_track,key_delete_line_preset,key_delete_line_pattern_rotate,key_delete_line_track_rotate,key_delete_line_preset_rotate,key_line,key_line
      CASE 64 TO 71
        ON SUB(numero_fonction%,63) GOSUB key_line,key_line,key_line,key_line,key_line,key_line,key_line,key_line
      CASE 72 TO 79
        ON SUB(numero_fonction%,71) GOSUB key_select_preset,key_select_preset,key_rec_preset,key_rec_preset,key_instr_sample_drum,key_instr_sample_drum,key_rec_instr_sample_drum,key_rec_instr_sample_drum
      CASE 80 TO 87
        ON SUB(numero_fonction%,79) GOSUB key_track_onoff,key_track_onoff,key_rec_track_onoff,key_rec_track_onoff,rien,rien,rien,rien
      ENDSELECT
    ELSE
      '
      ' Si aucune fonction speciale trouvee, c'est peut-etre une note
      '
      GOSUB teste_touches_notes
    ENDIF
  ENDIF
RETURN
FUNCTION key_trafique_code_clavier(clavier%)
  ' Trafique le code du clavier et trouve la bonne fonction
  LOCAL a%,b%,c%,d%,e%,f%
  a%=ADD(SHL(play%,16),edit%)
  b%=V:keydef_mask%(0,0)
  c%=V:keydef_val%(0,0)
  d%=V:scancode2ascii$(0,keyboard_type%)
  e%=V:scancode2ascii$(1,keyboard_type%)
  f%=V:scancode2ascii$(2,keyboard_type%)
  a%=C:g_find_key_function%(L:clavier%,L:a%,W:84,L:b%,L:c%,L:d%,L:e%,L:f%)
  RETURN a%
ENDFUNC
PROCEDURE teste_touches_notes
  IF edit%=1
    '
    ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
    '
    ' Touches en mode Edit
    ' --------------------
    IF scancode%<54 AND curs_x%=0               ! Frappe d'une note en mode d'edition
      a%=t_note%(scancode%)
      IF a%<>-1 AND ADD(a%,MUL(octave%,12))<104
        ADD a%,ADD(MUL(octave%,12),24)          ! Ajuste a la bonne note
        FOR i%=0 TO PRED(nbr_track%)
          b%=LONG{SUCC(FN adr_strk(songpos%,posligne%,i%))}
          d%=BYTE{FN adr_strk(songpos%,posligne%,i%)}
          IF i%=preset&(curs_col%,n_preset%)
            c%=ADD(SHL(instr%,24),ADD(b% AND ext_note1%,ext_note2%))
            IF play%=0
              BYTE{ADD(V:pattern_bidon%(8),MUL(i%,5))}=a%
              LONG{SUCC(ADD(V:pattern_bidon%(8),MUL(i%,5)))}=c%
            ENDIF
            BYTE{FN adr_strk(songpos%,posligne%,i%)}=a%
            LONG{SUCC(FN adr_strk(songpos%,posligne%,i%))}=c%
          ELSE IF play%=0
            BYTE{ADD(V:pattern_bidon%(8),MUL(i%,5))}=d%
            LONG{SUCC(ADD(V:pattern_bidon%(8),MUL(i%,5)))}=b%
          ENDIF
        NEXT i%
        IF BTST(clavier%,8)
          curs_x%=2
          GOSUB curseur_a_droite                ! + Shift : va sur le premier chiffre de l'effet
        ELSE
          GOSUB next_line
        ENDIF
        IF play%=0
          GOSUB play_pattern_bidon
        ENDIF
      ENDIF
    ELSE IF scancode%>1 AND scancode%<12 AND curs_x%>0
      ' Touches 0 - 9
      a%=PRED(scancode%) MOD 10
      b%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
      POKE ADD(b%,SHR(SUCC(curs_x%),1)),ADD(PEEK(ADD(b%,SHR(SUCC(curs_x%),1))) AND SHR(240,SHL(curs_x% AND 1,2)),SHL(a%,SHL(curs_x% AND 1,2)))
      BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
      GOSUB play_pattern_bidon
      IF BTST(clavier%,8)
        GOSUB curseur_a_droite                  ! + Shift : Chiffre suivant
      ELSE
        GOSUB next_line
      ENDIF
    ELSE IF ((asciicode%>64 AND asciicode%<71) OR (asciicode%>96 AND asciicode%<103)) AND curs_x%>0
      ' Touches A - F
      a%=SUB(asciicode% AND &HDF,55)
      b%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
      POKE ADD(b%,SHR(SUCC(curs_x%),1)),ADD(PEEK(ADD(b%,SHR(SUCC(curs_x%),1))) AND SHR(240,SHL(curs_x% AND 1,2)),SHL(a%,SHL(curs_x% AND 1,2)))
      BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
      GOSUB play_pattern_bidon
      IF BTST(clavier%,8)
        GOSUB curseur_a_droite                  ! + Shift : Chiffre suivant
      ELSE
        GOSUB next_line
      ENDIF
    ENDIF
  ELSE
    '
    ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
    '
    ' Touches en mode Stop
    ' --------------------
    IF scancode%<54 AND edit%=0 AND play%=0     ! Frappe d'une note en mode Stop
      a%=t_note%(scancode%)
      IF a%<>-1 AND ADD(a%,MUL(octave%,12))<104
        ADD a%,ADD(MUL(octave%,12),24)          ! Ajuste a la bonne note
        FOR i%=0 TO PRED(nbr_track%)
          IF i%=preset&(curs_col%,n_preset%)
            BYTE{ADD(V:pattern_bidon%(8),MUL(i%,5))}=a%
            LONG{SUCC(ADD(V:pattern_bidon%(8),MUL(i%,5)))}=ADD(SHL(instr%,24),ext_note2%)
          ELSE
            BYTE{ADD(V:pattern_bidon%(8),MUL(i%,5))}=0
            LONG{SUCC(ADD(V:pattern_bidon%(8),MUL(i%,5)))}=0
          ENDIF
        NEXT i%
        GOSUB play_pattern_bidon
      ENDIF
    ENDIF
    '
    ' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
    '
    ' Touches en mode Play sans Edit
    ' ------------------------------
    IF play%<>0 AND edit%=0
      IF scancode%<54                           ! Frappe d'une note en mode play
        a%=t_note%(scancode%)
        IF a%<>-1 AND ADD(a%,MUL(octave%,12))<104
          ADD a%,ADD(MUL(octave%,12),24)        ! Ajuste a la bonne note
          i%=preset&(curs_col%,n_preset%)
          b%=LONG{SUCC(FN adr_strk(songpos%,posligne%,i%))}
          c%=ADD(SHL(instr%,24),ADD(b% AND ext_note1%,ext_note2%))
          a$=CHR$(a%)+MKL$(c%)
          ~C:rr_play_one_note%(L:V:a$,W:i%)
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE vide_buffer_clavier
  IF NOT flag_keyboard_buffer!
    WHILE GEMDOS(11)<>0
      ~GEMDOS(7)
    WEND
  ENDIF
RETURN
' Touches valables tout le temps
PROCEDURE key_next_octave
  octave%=SUCC(octave%) MOD 7
  GOSUB affiche_barre_info
RETURN
PROCEDURE key_prev_octave
  DEC octave%
  WHILE octave%<0
    ADD octave%,7
  WEND
  GOSUB affiche_barre_info
RETURN
PROCEDURE key_next_column
  INC curs_col%
  IF curs_col%>PRED(MIN(nbr_colonnes%(n_preset%),nbr_col%))
    curs_col%=0
  ENDIF
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_prev_column
  DEC curs_col%
  IF curs_col%<0
    curs_col%=PRED(MIN(nbr_colonnes%(n_preset%),nbr_col%))
  ENDIF
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_cpu_time
  DPOKE r_flag_mt_display%,DPEEK(r_flag_mt_display%) XOR 1
  IF DPEEK(r_flag_mt_display%)=0            ! Attend la fin de la VBL pour remettre le noir
    PAUSE 1
    SLPOKE &HFFFF9800,&H0
    GOSUB aff_message("CPU time not displayed.")
  ELSE
    GOSUB aff_message("CPU time displayed.")
  ENDIF
RETURN
PROCEDURE key_expand
  GOSUB chg_type_affpiste(SUCC(type_affpiste%) MOD 3)
  curs_x%=0
  curs_col%=MIN(curs_col%,PRED(nbr_col%))
  CARD{ADD(V:para_affiche_pattern$,72)}=type_affpiste%
  GOSUB cadre_ext(1,160,SUB(scr_ncol%,3),SUB(scr_haut%,164),9,9,9,9)
  GOSUB affiche_cadre_voies
  GOSUB affiche_info_preset
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_replay_freq
  c%=FN mod_tempo
  a%=CARD{r_adr_replay_frequency%}
  SELECT a%
  CASE 49170
    b%=32780
    d%=&H102
  CASE 32780
    b%=24585
    d%=&H103
  CASE 24585
    b%=19668
    d%=&H104
  CASE 19668
    b%=16390
    d%=&H105
  CASE 16390
    b%=12292
    d%=&H107
  DEFAULT
    b%=49170
    d%=&H101
  ENDSELECT
  IF b%>a%                                  ! C'est pour eviter des bugs dus a une desychro entre
    CARD{r_adr_replay_frequency%}=b%        ! nombre d'ech a calculer / frequence de replay, a
    GOSUB chg_tempo(c%)                     ! cause du double buffer.
    PAUSE 5                                 ! *** Principe a verifier plus en detail
    SDPOKE &HFFFF8934,d%
  ELSE
    SDPOKE &HFFFF8934,d%
    PAUSE 5
    CARD{r_adr_replay_frequency%}=b%
    GOSUB chg_tempo(c%)
  ENDIF
  GOSUB aff_message("Replay in "+STR$(b%/1000)+" KHz.")
RETURN
PROCEDURE key_interpolation_one_track
  b%=preset&(curs_col%,n_preset%)
  a%=ABS(SGN(FN track_interpol(b%))) XOR 1
  CARD{ADD(ADD(r_info_track%,r_interpol_t%),MUL(r_itl%,b%))}=a%
  IF a%<>0
    GOSUB aff_message("Interpolation on track "+STR$(SUCC(b%))+".")
  ELSE
    GOSUB aff_message("Interpolation disabled on track "+STR$(SUCC(b%))+".")
  ENDIF
RETURN
PROCEDURE key_interpolation_all_tracks
  a%=ABS(SGN(FN track_interpol(preset&(curs_col%,n_preset%)))) XOR 1
  FOR i%=0 TO PRED(nbr_track%)
    CARD{ADD(ADD(r_info_track%,r_interpol_t%),MUL(r_itl%,i%))}=a%
  NEXT i%
  IF a%<>0
    GOSUB aff_message("Interpolation on all the tracks.")
  ELSE
    GOSUB aff_message("Interpolation disabled on all the tracks.")
  ENDIF
RETURN
PROCEDURE key_inc_step
  IF line_step%>-256 AND line_step%<256
    line_step%=SUCC(line_step%) MOD FN nbr_lines3
  ELSE
    line_step%=1
  ENDIF
  GOSUB affiche_info_song
RETURN
PROCEDURE key_dec_step
  IF line_step%>-256 AND line_step%<256
    line_step%=MAX(PRED(line_step%) MOD FN nbr_lines3,-15)
  ELSE
    line_step%=1
  ENDIF
  GOSUB affiche_info_song
RETURN
PROCEDURE key_load_module
  km%=1
  GOSUB load_module
  km%=0
RETURN
PROCEDURE key_save_module
  km%=1
  GOSUB save_module
  km%=0
RETURN
PROCEDURE key_resync_screen
  GOSUB resync_tv_screen
RETURN
PROCEDURE key_snapshot
  GOSUB aff_message("Please clic on 2 corners for the snapshot")
  GOSUB snapshot
RETURN
PROCEDURE key_stop_edit
  GOSUB stop_edit
RETURN
PROCEDURE key_block_start
  GOSUB block_start
RETURN
PROCEDURE key_block_end
  GOSUB block_end
RETURN
PROCEDURE key_cont_song
  GOSUB edit_mode_off
  GOSUB play_song(TRUE)
RETURN
PROCEDURE key_cont_pattern
  GOSUB edit_mode_off
  GOSUB play_pattern(TRUE)
RETURN
PROCEDURE key_samplepad_drumpad
  drumpad_flag%=SUCC(drumpad_flag%) MOD 3
  GOSUB affiche_barre_info
RETURN
PROCEDURE key_line
  posligne%=MIN(keydef_param%(numero_fonction%),PRED(FN nbr_lines3))
  IF play%>0
    DPOKE r_mod_linepos%,posligne%
  ELSE
    GOSUB affiche_c_pattern
  ENDIF
RETURN
PROCEDURE key_prev_instr
  instr%=MAX(PRED(instr%),1)
  GOSUB affiche_info_sample
RETURN
PROCEDURE key_next_instr
  instr%=MIN(SUCC(instr%),255)
  GOSUB affiche_info_sample
RETURN
PROCEDURE key_prev_sample
  sample%=MAX(PRED(sample%),1)
  GOSUB affiche_info_sample
RETURN
PROCEDURE key_next_sample
  sample%=MIN(SUCC(sample%),255)
  GOSUB affiche_info_sample
RETURN
PROCEDURE key_select_preset
  a%=presetpad%(ADD(keydef_param%(numero_fonction%),numero_touche%))
  GOSUB chg_preset(a%)
RETURN
PROCEDURE key_rec_preset
  presetpad%(ADD(keydef_param%(numero_fonction%),numero_touche%))=n_preset%
  GOSUB aff_message("Preset #"+STR$(a%)+" recorded on presetpad.")
RETURN
PROCEDURE key_track_onoff
  a%=trackpad%(ADD(keydef_param%(numero_fonction%),numero_touche%))
  IF a%<nbr_track%
    GOSUB chg_a_track_onoff(a%,ABS(SGN(FN track_onoff(a%))) XOR 1)
  ENDIF
RETURN
PROCEDURE key_rec_track_onoff
  a%=preset&(curs_col%,n_preset%)
  IF a%<nbr_track%
    trackpad%(ADD(keydef_param%(numero_fonction%),numero_touche%))=a%
    GOSUB aff_message("Track #"+STR$(a%)+" recorded on trackpad.")
  ENDIF
RETURN
PROCEDURE key_prev_line
  DEC posligne%
  IF posligne%<0
    posligne%=PRED(FN nbr_lines3)
  ENDIF
  IF play%>0
    DPOKE r_mod_linepos%,posligne%
  ELSE
    GOSUB affiche_c_pattern
  ENDIF
RETURN
PROCEDURE key_next_line
  INC posligne%
  IF posligne%=>FN nbr_lines3
    posligne%=0
  ENDIF
  IF play%>0
    DPOKE r_mod_linepos%,posligne%
  ELSE
    GOSUB affiche_c_pattern
  ENDIF
RETURN
PROCEDURE key_instr_sample_drum
  a%=ADD(keydef_param%(numero_fonction%),numero_touche%)
  IF drumpad_flag%=0                            ! Numero d'instrument
    instr%=drumpad%(a%,0)
    GOSUB affiche_info_sample
  ELSE IF drumpad_flag%=1                       ! Numero de sample
    sample%=drumpad%(a%,1)
    GOSUB affiche_info_sample
  ELSE                                          ! Sort une note du drumpad
    IF edit%=1
      LPOKE FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%)),drumpad%(a%,2)
      GOSUB next_line
    ENDIF
  ENDIF
RETURN
PROCEDURE key_rec_instr_sample_drum
  a%=ADD(keydef_param%(numero_fonction%),numero_touche%)
  IF drumpad_flag%=0                            ! Instrument
    drumpad%(a%,0)=instr%
    GOSUB aff_message("Instrument #"+HEX$(instr%,2)+" recorded on samplepad.")
  ELSE IF drumpad_flag%=1                       ! Sample
    drumpad%(a%,1)=sample%
    GOSUB aff_message("Sample #"+HEX$(instr%,2)+" recorded on samplepad.")
  ELSE                                          ! Drum
    b%=LPEEK(FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%)))
    drumpad%(a%,2)=b%
    IF (b% AND &HFF000000)>0
      c%=SHR(b%,24)       ! c% = note
      GOSUB aff_message(MID$(gamme$,SUCC(SHL(c% MOD 12,1)),2)+STR$(SUB(DIV(c%,12),2),1)+" "+HEX$(SHR(b%,16) AND 255)+HEX$(b%,4)+" recorded on drumpad.")
    ELSE
      GOSUB aff_message("--- "+HEX$(SHR(b%,16) AND 255)+HEX$(b%,4)+" recorded on drumpad.")
    ENDIF
  ENDIF
RETURN
PROCEDURE key_help
  GOSUB help(4)             ! Page des effets
RETURN
PROCEDURE key_instr_under_cursor
  a%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
  b%=BYTE{SUCC(a%)}
  IF b%<>0
    instr%=b%
    GOSUB affiche_info_sample
  ENDIF
RETURN
PROCEDURE key_prev_bar
  posligne%=PRED(posligne%) AND -16
  IF posligne%<0
    posligne%=PRED(FN nbr_lines3) AND -16
  ENDIF
  IF play%>0
    DPOKE r_mod_linepos%,posligne%
  ELSE
    GOSUB affiche_c_pattern
  ENDIF
RETURN
PROCEDURE key_next_bar
  posligne%=ADD(posligne%,16) AND -16
  IF posligne%=>FN nbr_lines3
    posligne%=0
  ENDIF
  IF play%>0
    DPOKE r_mod_linepos%,posligne%
  ELSE
    GOSUB affiche_c_pattern
  ENDIF
RETURN
PROCEDURE key_cursor_left
  GOSUB curseur_a_gauche
RETURN
PROCEDURE key_cursor_right
  GOSUB curseur_a_droite
RETURN
PROCEDURE key_prev_songpos
  d%=-1
  GOSUB chg_songpos
RETURN
PROCEDURE key_next_songpos
  d%=1
  GOSUB chg_songpos
RETURN
PROCEDURE key_prev_preset
  GOSUB chg_preset(PRED(n_preset%) AND 31)
RETURN
PROCEDURE key_next_preset
  GOSUB chg_preset(SUCC(n_preset%) AND 31)
RETURN
PROCEDURE key_dec_high
  haut_lig%=MAX(SUB(haut_lig%,2),1)
  CARD{ADD(V:para_affiche_pattern$,6)}=haut_lig%
  GOSUB cadre_ext(1,ADD(MUL(haut_lig%,6),170),SUB(scr_ncol%,3),11,9,9,9,9)
  GOSUB affiche_cadre_voies
  GOSUB affiche_info_preset
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_inc_high
  haut_lig%=MIN(ADD(haut_lig%,2),DIV(SUB(scr_haut%,180),6) OR 1)
  CARD{ADD(V:para_affiche_pattern$,6)}=haut_lig%
  GOSUB affiche_cadre_voies
  GOSUB affiche_info_preset
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_play_line
  IF play%=0
    FOR i%=0 TO PRED(nbr_track%)
      b%=LONG{SUCC(FN adr_strk(songpos%,posligne%,i%))}
      d%=BYTE{FN adr_strk(songpos%,posligne%,i%)}
      BYTE{ADD(V:pattern_bidon%(8),MUL(i%,5))}=d%
      LONG{SUCC(ADD(V:pattern_bidon%(8),MUL(i%,5)))}=b%
    NEXT i%
    GOSUB next_line
    GOSUB play_pattern_bidon
  ENDIF
RETURN
PROCEDURE key_play_song
  GOSUB play_song(0)
RETURN
PROCEDURE key_play_pattern
  GOSUB play_pattern(0)
RETURN
' Touches en mode Edit
PROCEDURE key_clear_note
  a%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
  LPOKE a%,LPEEK(a%) AND 65535
  BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
  GOSUB play_pattern_bidon
  GOSUB next_line
RETURN
PROCEDURE key_copy_block_track
  trackpat_s%=trackpat%
  trackpat%=0
  GOSUB paste_block
  trackpat%=trackpat_s%
  GOSUB affiche_c_pattern
  GOSUB aff_message("Track copied.")
RETURN
PROCEDURE key_copy_block_pattern
  trackpat_s%=trackpat%
  trackpat%=1
  GOSUB paste_block
  trackpat%=trackpat_s%
  GOSUB affiche_c_pattern
  GOSUB aff_message("Pattern copied.")
RETURN
PROCEDURE key_copy_block_preset
  trackpat_s%=trackpat%
  trackpat%=2
  GOSUB paste_block
  trackpat%=trackpat_s%
  GOSUB affiche_c_pattern
  GOSUB aff_message("Preset copied.")
RETURN
PROCEDURE key_copy_block_track_cursor
  trackpat_s%=trackpat%
  bl_trk_s&=bl_trk&
  trackpat%=0
  bl_trk&=preset&(curs_col%,n_preset%)
  GOSUB paste_block
  trackpat%=trackpat_s%
  bl_trk&=bl_trk_s&
  GOSUB affiche_c_pattern
  GOSUB aff_message("Track copied.")
RETURN
PROCEDURE key_clear_effect
  a%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
  LPOKE a%,LPEEK(a%) AND -65536
  BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
  GOSUB play_pattern_bidon
  GOSUB next_line
RETURN
PROCEDURE key_clear_volume
  a%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
  POKE ADD(a%,4),0
  BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
  GOSUB play_pattern_bidon
  GOSUB next_line
RETURN
PROCEDURE key_clear_whole_note
  a%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
  LPOKE a%,0
  POKE ADD(a%,4),0
  BMOVE FN adr_sline(songpos%,posligne%),V:pattern_bidon%(8),MUL(nbr_track%,5)
  GOSUB play_pattern_bidon
  GOSUB next_line
RETURN
PROCEDURE key_insert_line_pattern
  GOSUB insert_line_pattern(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_insert_line_track
  GOSUB insert_line_track(song&(songpos%),posligne%,preset&(curs_col%,n_preset%),STRING$(5,0))
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_insert_line_preset
  GOSUB insert_line_preset(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_insert_line_pattern_rotate
  GOSUB insert_r_line_pattern(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_insert_line_track_rotate
  GOSUB insert_r_line_track(song&(songpos%),posligne%,preset&(curs_col%,n_preset%))
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_insert_line_preset_rotate
  GOSUB insert_r_line_preset(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_pattern
  GOSUB delete_line_pattern(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_track
  GOSUB delete_line_track(song&(songpos%),posligne%,preset&(curs_col%,n_preset%),STRING$(5,0))
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_preset
  GOSUB delete_line_preset(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_pattern_rotate
  GOSUB delete_r_line_pattern(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_track_rotate
  GOSUB delete_r_line_track(song&(songpos%),posligne%,preset&(curs_col%,n_preset%))
  GOSUB affiche_c_pattern
RETURN
PROCEDURE key_delete_line_preset_rotate
  GOSUB delete_r_line_preset(song&(songpos%),posligne%)
  GOSUB affiche_c_pattern
RETURN
' Divers
PROCEDURE cherche_combinaison_touches(t$,VAR am%,ae%,bm%,be%)
  LOCAL a$
  LOCAL a%,p%
  LOCAL deux_touches!
  deux_touches!=FALSE
  am%=&HF000100
  bm%=&HF000100
  ae%=0
  be%=0
  WHILE LEN(t$)
    GOSUB separe_chaine(t$,a$)
    IF a$="NOKEY"
      am%=0
      bm%=0
      ae%=0
      be%=0
      t$=""
    ELSE IF a$="/"
      deux_touches!=TRUE
      SWAP am%,bm%
      SWAP ae%,be%
    ELSE IF a$="SHIFT"
      am%=(am% AND -&H3000001) OR &H100         ! Ne prend plus en compte les bits
      ae%=(ae% AND -&H3000001) OR &H100         ! seuls de Lshift et Rshift
    ELSE IF a$="RSHIFT"
      am%=(am% AND -&H101) OR &H1000000         ! Retire l'attribut 'Shift quelconque'
      ae%=(ae% AND -&H101) OR &H1000000
    ELSE IF a$="LSHIFT"
      am%=(am% AND -&H101) OR &H2000000         ! Retire l'attribut 'Shift quelconque'
      ae%=(ae% AND -&H101) OR &H2000000
    ELSE IF a$="CTRL"
      am%=am% OR &H4000000
      ae%=ae% OR &H4000000
    ELSE IF a$="ALT"
      am%=am% OR &H8000000
      ae%=ae% OR &H8000000
    ELSE IF a$="CAPS"
      am%=am% OR &H10000000
      ae%=ae% OR &H10000000
    ELSE IF a$="NOCAPS"
      am%=am% OR &H10000000
      ae%=ae% AND -&H10000001
    ELSE IF a$="NUMPAD"
      am%=(am% AND &HFF00FB00) OR &H200         ! Retire Scan+Ascii+Fkeys
      ae%=(ae% AND &HFF00FB00) OR &H200
    ELSE IF a$="FKEYS"
      am%=(am% AND &HFF00FD00) OR &H400         ! Retire Scan+Ascii+Pad
      ae%=(ae% AND &HFF00FD00) OR &H400
    ELSE IF a$="ESC"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H10000
    ELSE IF a$="TAB"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &HF0000
    ELSE IF a$="SPACE"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H390000
    ELSE IF a$="RETURN"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H1C0000
    ELSE IF a$="BACKSPACE"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &HE0000
    ELSE IF a$="DEL"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H530000
    ELSE IF a$="HELP"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H620000
    ELSE IF a$="UNDO"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H610000
    ELSE IF a$="INS"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H520000
    ELSE IF a$="CLR"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H470000
    ELSE IF a$="UP"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H480000
    ELSE IF a$="DOWN"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H500000
    ELSE IF a$="LEFT"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H4B0000
    ELSE IF a$="RIGHT"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H4D0000
    ELSE IF a$="PAD0"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H700000
    ELSE IF a$="PADPOINT"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H710000
    ELSE IF (a$>="F1" AND a$<="F9") OR a$="F10"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      a%=ADD(&H3A,VAL(RIGHT$(a$,PRED(LEN(a$)))))
      ae%=(ae% AND &HFF00FC00) OR SHL(a%,16)
    ELSE IF a$="#"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H2B0000
    ELSE IF a$="<" OR a$=">"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H600000
    ELSE IF a$="&" OR a$="1"
      am%=(am% AND &HFFFFFC00) OR &HFF0000      ! Retire Ascii+Pad+Fkeys et met le Scan
      ae%=(ae% AND &HFF00FC00) OR &H20000
    ELSE IF a$>="A" AND a$<="Z"
      am%=(am% AND &HFF00FCFF) OR &HFF          ! Retire Scan+Pad+Fkeys et met l'Ascii
      ae%=(ae% AND &HFF00FC00) OR ASC(a$)
    ENDIF
  WEND
  IF deux_touches! OR ae%=0
    SWAP am%,bm%
    SWAP ae%,be%
  ENDIF
RETURN
PROCEDURE separe_chaine(VAR reste$,premier$)
  ' Separe une chaine en 2 elements, separes par un espace
  LOCAL p%
  reste$=TRIM$(reste$)
  p%=INSTR(reste$," ")
  IF p%=0
    premier$=reste$
    reste$=""
  ELSE
    premier$=LEFT$(reste$,PRED(p%))
    reste$=TRIM$(RIGHT$(reste$,SUB(LEN(reste$),p%)))
  ENDIF
RETURN
'
' Procedures diverses
' -------------------
PROCEDURE attente_interruptible(secondes%)
  ' Attend un certain temps, ou qu'on appuie sur une touche ou la souris
  LOCAL flag_sortie!
  MUL secondes%,50                              ! Transforme en 50eme de secondes
  flag_sortie!=FALSE
  WHILE secondes%>0 AND (NOT flag_sortie!)
    IF GEMDOS(11)<>0
      ~GEMDOS(7)
      flag_sortie!=TRUE
    ELSE IF MOUSEK<>0
      flag_sortie!=TRUE
    ENDIF
    PAUSE 1
    DEC secondes%
  WEND
  GOSUB vide_buffer_clavier
RETURN
PROCEDURE teste_enregistrement2
  autodestruction_flag!=FALSE          ! I hate to imagine what that was supposed to do. /sjx.
  flag_registered2!=TRUE
  ' LOCAL a,b,a$,c$,i,user
  ' IF FN exist(npath_prog$+treg_str2$)
  '   OPEN "i",#0,npath_prog$+treg_str2$
  '    IF LOF(#0)=1032
  '     c$=STRING$(1032,0)
  '   BGET #0,V:c$,1032
  '    a=0                               ! Teste la somme de controle
  '     b=1
  '      FOR i=0 TO 1027
  '     a=a+b*(BYTE{ADD(V:c$,i)} XOR 255)
  '      b=b+1
  '     NEXT i
  '   IF a=LONG{V:c$+1028}
  '      user=LONG{V:c$+512}
  '       a=&H5BA3
  '     a$=""
  '      FOR i=0 TO 510 STEP 2
  '         b=CARD{V:c$+i}
  '    a$=a$+MKI$(b XOR a)
  '          a=(a-b) AND &HFFFF
  '  NEXT i
  '   IF a$=MID$(c$,517,512) AND user<>10
  '      flag_registered2!=TRUE
  '     ELSE
  '        GOTO erreur_user.reg2
  '       ENDIF
  '        flag_registered2!=(a$=MID$(c$,517,512) AND user<>10)
  '  IF user=10
  '     autodestruction_flag!=TRUE            ! Peut servir...
  '    ENDIF
  '   ELSE
  '      GOTO erreur_user.reg2
  '     ENDIF
  '    ELSE
  '    erreur_user.reg2:
  '    ENDIF
  '    CLOSE #0
  '  ENDIF
RETURN
PROCEDURE edite_chaine(aaaa$,xxxx%,yyyy%,llll%,tttt%)
  ' Edite la chaine a$ en (xxxx%,yyyy%), longueur max llll%, type tttt%
  ' tttt% : 0=alphanum, 1=hexa, 2=decimal, 3=virgule flo, 4=virgule fixe (non fait)
  ' Renvoie bbbb$
  LOCAL curs%,cla%,flig%,i%
  aaaa$=RIGHT$(aaaa$,llll%)
  WHILE LEN(aaaa$)<llll%
    IF tttt%=1
      aaaa$="0"+aaaa$
    ELSE IF tttt%=0
      aaaa$=aaaa$+" "
    ELSE
      aaaa$=" "+aaaa$
    ENDIF
  WEND
  IF tttt%=0
    curs%=1
  ELSE
    curs%=llll%
  ENDIF
  cla%=0
  GOSUB vide_buffer_clavier
  REPEAT
    GOSUB affchaine_notrans(aaaa$,xxxx%,yyyy%,1)
    GOSUB affchaine_notrans(CHR$(7),ADD(xxxx%,PRED(curs%)),yyyy%,1)
    GOSUB affchaine_trans(MID$(aaaa$,curs%,1),SHL(ADD(xxxx%,PRED(curs%)),1),yyyy%,0)
    cla%=INP(2)
    IF tttt%=1 AND cla%>96 AND cla%<123
      SUB cla%,32
    ENDIF
    SELECT cla%
    CASE 8      ! Backspace
      IF curs%>1
        aaaa$=LEFT$(aaaa$,SUB(curs%,2))+RIGHT$(aaaa$,SUB(llll%,PRED(curs%)))
        IF tttt%=1
          aaaa$=aaaa$+"0"
        ELSE
          aaaa$=aaaa$+" "
        ENDIF
        DEC curs%
      ENDIF
    CASE 127    ! Delete
      aaaa$=LEFT$(aaaa$,PRED(curs%))+RIGHT$(aaaa$,SUB(llll%,curs%))
      IF tttt%=1
        aaaa$=aaaa$+"0"
      ELSE
        aaaa$=aaaa$+" "
      ENDIF
    CASE 203    ! <-
      IF curs%>1
        DEC curs%
      ENDIF
    CASE 205    ! ->
      IF curs%<llll%
        INC curs%
      ENDIF
    CASE 32 TO 126
      IF tttt%=0 OR (tttt%=1 AND ((cla%>47 AND cla%<58) OR (cla%>64 AND cla%<71))) OR (tttt%=2 AND cla%>47 AND cla%<58) OR (tttt%=3 AND ((cla%>47 AND cla%<58) OR (cla%=46 AND INSTR(aaaa$,".")=0)))
        IF curs%<llll%
          aaaa$=LEFT$(aaaa$,PRED(curs%))+CHR$(cla%)+MID$(aaaa$,curs%,SUB(llll%,curs%))
          INC curs%
          flig%=0
        ELSE
          IF flig%=1 AND tttt%<>0
            aaaa$=RIGHT$(aaaa$+CHR$(cla%),llll%)
          ELSE
            aaaa$=LEFT$(aaaa$,PRED(curs%))+CHR$(cla%)
          ENDIF
          flig%=1
        ENDIF
      ENDIF
    ENDSELECT
  UNTIL cla%=13
  GOSUB affchaine_notrans(aaaa$,xxxx%,yyyy%,1)
  bbbb$=aaaa$
RETURN
PROCEDURE edite_mask1(mmmm1$,mmmm2$,xxxx%,yyyy%,ffff%,tttt%)
  LOCAL aaaa$,pppp%,aaaa%,kkkk1%,kkkk2%
  HIDEM
  pppp%=MUL(tttt%,3)
  GOTO edite_mask1_aff
  DO
    kkkk1%=GEMDOS(7)
    kkkk2%=ASC(UPPER$(CHR$((kkkk1% AND 127))))  ! Code ascii
    kkkk1%=SHR(kkkk1%,16) AND 255               ! Code clavier
    IF kkkk1%=75        ! Fleche gauche
      pppp%=MAX(PRED(pppp%),MUL(tttt%,3))
    ELSE IF kkkk1%=77   ! Fleche droite
      pppp%=MIN(SUCC(pppp%),8)
    ENDIF
    IF pppp%=0
      IF kkkk2%=63      ! Point d'interrogation
        BYTE{V:mmmm1$}=ffff%
        BYTE{V:mmmm2$}=0
        pppp%=1
      ELSE
        IF kkkk1%=20                    ! Note vide
          BYTE{V:mmmm1$}=NOT ffff%
          BYTE{V:mmmm2$}=0
          pppp%=1
        ELSE IF kkkk1%<54               ! Note
          aaaa%=t_note%(kkkk1%)
          IF aaaa%<>-1 AND ADD(aaaa%,MUL(octave%,12))<60
            ADD aaaa%,ADD(MUL(octave%,12),24)           ! Ajuste a la bonne note
            BYTE{V:mmmm1$}=NOT ffff%
            BYTE{V:mmmm2$}=aaaa%
            pppp%=1
          ENDIF
        ENDIF
      ENDIF
    ELSE IF pppp%>0
      SELECT kkkk2%
      CASE 63                     ! ?
        LONG{SUCC(V:mmmm1$)}=ADD(LONG{SUCC(V:mmmm1$)} AND (NOT SHR(&HF0000000,SHL(PRED(pppp%),2))),ffff% AND SHR(&HF0000000,SHL(PRED(pppp%),2)))
        LONG{SUCC(V:mmmm2$)}=LONG{SUCC(V:mmmm2$)} AND (NOT SHR(&HF0000000,SHL(PRED(pppp%),2)))
        pppp%=MIN(SUCC(pppp%),8)
      CASE 48 TO 57,65 TO 70      ! Hexa
        aaaa%=SUB(kkkk2%,48)
        IF kkkk2%>64
          SUB aaaa%,7
        ENDIF
        LONG{SUCC(V:mmmm1$)}=ADD(LONG{SUCC(V:mmmm1$)} AND (NOT SHR(&HF0000000,SHL(PRED(pppp%),2))),(NOT ffff%) AND SHR(&HF0000000,SHL(PRED(pppp%),2)))
        LONG{SUCC(V:mmmm2$)}=ADD(LONG{SUCC(V:mmmm2$)} AND (NOT SHR(&HF0000000,SHL(PRED(pppp%),2))),SHL(aaaa%,SUB(28,SHL(PRED(pppp%),2))))
        pppp%=MIN(SUCC(pppp%),8)
      ENDSELECT
    ENDIF
    ' Affichage
  edite_mask1_aff:
    IF tttt%=0
      IF BYTE{V:mmmm1$}=(ffff% AND 255)
        aaaa$="?  "
      ELSE
        IF BYTE{V:mmmm2$}=0
          aaaa$="---"
        ELSE
          aaaa$=MID$(gamme$,SUCC(SHL(BYTE{V:mmmm2$} MOD 12,1)),2)+STR$(SUB(DIV(BYTE{V:mmmm2$},12),2),1)
        ENDIF
      ENDIF
    ELSE
      aaaa$=""
    ENDIF
    FOR aaaa%=MUL(tttt%,2) TO 7
      IF (SHL(LONG{SUCC(V:mmmm1$)},SHL(aaaa%,2)) AND &HF0000000)=(ffff% AND &HF0000000)
        aaaa$=aaaa$+"?"
      ELSE
        aaaa$=aaaa$+HEX$(SHR(LONG{SUCC(V:mmmm2$)},SUB(28,SHL(aaaa%,2))) AND 15,1)
      ENDIF
    NEXT aaaa%
    aaaa%=pppp%
    IF tttt%=1
      SUB aaaa%,3
    ELSE
      IF pppp%>0
        ADD aaaa%,2
      ENDIF
    ENDIF
    GOSUB affchaine_notrans(aaaa$,xxxx%,yyyy%,1)
    EXIT IF kkkk2%=13
    GOSUB affchaine_notrans(CHR$(7),ADD(xxxx%,aaaa%),yyyy%,1)
    GOSUB affchaine_trans(MID$(aaaa$,SUCC(aaaa%),1),SHL(ADD(xxxx%,aaaa%),1),yyyy%,0)
  LOOP
  SHOWM
  zzzz1$=mmmm1$
  zzzz2$=mmmm2$
RETURN
PROCEDURE dialog(tit$,txt$,but$,x%,y%)
  ' Boite de dialogue. txt$=texte, | pour changer de ligne, but$=boutons, | pour separer les boutons
  ' x% et y% milieu de la boite, tit$ titre
  ' Renvoie bouton% (0 - n-1)
  LOCAL a%,b%,i%,j%,ntxt%,nbut%,oldp%,ox%,ox2%,oy%,oy2%,p%,tmax1%,tmax2%,tx%,ty%
  LOCAL xm%,xm2%,ym%,km%
  LOCAL ok!
  LOCAL ptxt$,pbut$
  HIDEM
  '
  ' Recherche du nombre de lignes de texte, indices et longueurs
  '
  ptxt$=""
  p%=1
  oldp%=p%
  ntxt%=1
  tmax1%=0
  REPEAT
    IF MID$(txt$,p%,1)="|"
      ptxt$=ptxt$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
      tmax1%=MAX(tmax1%,SUB(p%,oldp%))
      oldp%=SUCC(p%)
      INC ntxt%
    ENDIF
    INC p%
  UNTIL p%>LEN(txt$)
  ptxt$=ptxt$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
  tmax1%=MAX(tmax1%,SUB(p%,oldp%))
  '
  ' Recherche du nombre de boutons, indices et longueurs
  '
  pbut$=""
  p%=1
  oldp%=p%
  nbut%=1
  tmax2%=6
  REPEAT
    IF MID$(but$,p%,1)="|"
      pbut$=pbut$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
      tmax2%=MAX(tmax2%,SUB(p%,oldp%))
      oldp%=SUCC(p%)
      INC nbut%
    ENDIF
    INC p%
  UNTIL p%>LEN(but$)
  pbut$=pbut$+MKI$(oldp%)+MKI$(SUB(p%,oldp%))
  tmax2%=MAX(tmax2%,SUB(p%,oldp%))
  ADD tmax2%,2                                  ! 1 espace de chaque cote du bouton
  '
  ' Definition de la taille de la boite
  '
  tx%=MAX(ADD(tmax1%,4),MUL(ADD(tmax2%,2),nbut%))
  ty%=ADD(MUL(ntxt%,8),34)                      ! 1+ 12 + 1+4+(8*l-2)+4+1 + 1+1+8+1+1 +1
  ox%=MIN(MAX(SUB(SHR(x%,3),SHR(tx%,1)),0),SUB(scr_ncol%,SUCC(tx%)))
  oy%=MIN(MAX(SUB(y%,SUB(ty%,6)),0),SUB(scr_haut%,ADD(ty%,4)))
  ox2%=SUB(ADD(ox%,tx%),PRED(MUL(ADD(tmax2%,2),nbut%)))
  oy2%=ADD(oy%,SUB(ty%,12))
  '
  ' Affichage de la boite
  '
  GOSUB save_background(SHL(ox%,3),oy%,SHL(SUCC(tx%),3),ADD(ty%,4))
  GOSUB cadre_int(SUCC(ox%),ADD(oy%,4),PRED(tx%),PRED(ty%),0,0,0,0)
  GOSUB cadre_int(ox%,oy%,PRED(tx%),PRED(ty%),9,9,10,8)
  GOSUB cadre_ext(SUCC(ox%),ADD(oy%,14),SUB(tx%,3),ADD(SHL(ntxt%,3),5),1,9,8,10)
  IF tit$<>""
    GOSUB affchaine_trans(tit$,SHL(SUCC(ox%),1),ADD(oy%,4),8)
  ENDIF
  ' Le texte
  FOR i%=0 TO PRED(ntxt%)
    a%=CARD{ADD(V:ptxt$,SHL(i%,2))}
    b%=CARD{ADD(V:ptxt$,ADD(SHL(i%,2),2))}
    ' GOSUB affchaine_trans(MID$(txt$,a%,b%),SUB(ADD(SHL(ox%,1),tx%),b%),ADD(ADD(oy%,18),SHL(i%,3)),0)
    ' Texte centre ----^
    GOSUB affchaine_trans(MID$(txt$,a%,b%),ADD(SHL(ox%,1),4),ADD(ADD(oy%,18),SHL(i%,3)),0)
  NEXT i%
  ' Les boutons
  FOR i%=0 TO PRED(nbut%)
    GOSUB cadre_texte_b(MID$(but$,CARD{ADD(V:pbut$,SHL(i%,2))},CARD{ADD(V:pbut$,ADD(SHL(i%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),i%)),oy2%,PRED(tmax2%))
  NEXT i%
  '
  ' Gestion de la souris et du clavier
  '
  SHOWM
  GOSUB wait_mouse(TRUE)
  bouton%=-1                                    ! Aucun bouton selectionne pour l'instant
  ok!=FALSE
  REPEAT
    REPEAT
      km%=MOUSEK
    UNTIL km%<>0 OR GEMDOS(11)<>0               ! Attend qu'on appuie sur le bouton de la souris ou une touche
    IF km%<>0
      ' --- Gestion souris ---
      REPEAT                                    ! Quand on appuie, la selection des boutons suit
        MOUSE xm%,ym%,km%                       ! la souris jusqu'au relachement
        xm2%=SHR(xm%,3)
        a%=DIV(SUB(xm2%,ox2%),ADD(tmax2%,2))
        b%=SUB(xm2%,ox2%) MOD ADD(tmax2%,2)
        IF a%>=0 AND a%<nbut% AND b%<tmax2% AND ym%>=oy2% AND ym%<ADD(oy2%,10)  ! On est bien sur un bouton, a% en est son numero
          IF a%<>bouton%                    ! Si on a change de bouton depuis la derniere fois,
            IF bouton%>=0                   ! Deselectionne le precedent bouton
              GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
            ENDIF
            bouton%=a%
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),1)
            ok!=TRUE
          ENDIF
        ELSE                                ! On n'est plus sur un bouton
          IF bouton%>=0                     ! Deselectionne le precedent bouton
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
          ENDIF
          bouton%=-1
          ok!=FALSE
        ENDIF
        SHOWM
      UNTIL km%=0
    ELSE
      ' --- Gestion clavier ---
      a%=GEMDOS(7) AND 255                      ! Caractere ASCII
      IF a%=>48 AND a%<58                       ! <1> - <0>
        a%=SUB(a%,39) MOD 10                    ! "1" > 0, ... "9" > 8, "0" > 9
        IF a%<nbut%                             ! a% numero du bouton selectionne
          IF bouton%>=0                         ! Deselectionne le precedent bouton
            GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),0)
          ENDIF
          bouton%=a%
          GOSUB cadre_texte2_b(MID$(but$,CARD{ADD(V:pbut$,SHL(bouton%,2))},CARD{ADD(V:pbut$,ADD(SHL(bouton%,2),2))}),ADD(ox2%,MUL(ADD(tmax2%,2),bouton%)),oy2%,PRED(tmax2%),1)
        ENDIF
        ok!=FALSE
      ELSE IF a%=13 AND bouton%>=0              ! <Return>
        ok!=TRUE
      ENDIF
      SHOWM
    ENDIF
  UNTIL bouton%>=0 AND ok!
  '
  GOSUB restore_background
RETURN
PROCEDURE wait_mouse(flag!)
  IF flag!
    REPEAT
    UNTIL MOUSEK=0
  ENDIF
RETURN
PROCEDURE bee(flag!)
  ' Souris en forme de fleche (False) ou d'abeille (True)
  HIDEM
  DEFMOUSE flag! AND 2
  SHOWM
RETURN
PROCEDURE intel_w(aaaa%)
  LOCAL bbbb%
  bbbb%=BYTE{SUCC(aaaa%)}
  BYTE{SUCC(aaaa%)}=BYTE{aaaa%}
  BYTE{aaaa%}=bbbb%
RETURN
PROCEDURE intel_3(aaaa%)
  LOCAL bbbb%
  bbbb%=BYTE{ADD(aaaa%,2)}
  BYTE{ADD(aaaa%,2)}=BYTE{aaaa%}
  BYTE{aaaa%}=bbbb%
RETURN
PROCEDURE intel_l(aaaa%)
  LOCAL bbbb%
  bbbb%=BYTE{ADD(aaaa%,3)}
  BYTE{ADD(aaaa%,3)}=BYTE{aaaa%}
  BYTE{aaaa%}=bbbb%
  bbbb%=BYTE{SUCC(aaaa%)}
  BYTE{SUCC(aaaa%)}=BYTE{ADD(aaaa%,2)}
  BYTE{ADD(aaaa%,2)}=bbbb%
RETURN
PROCEDURE mem_rotation(aaaa%,llll%,dddd%)
  ' Rotation de memoire :
  ' adresse aaaa%, longueur llll%, deplacement dddd%
  LOCAL bbbb%,tttt%,adr_t%
  IF llll%>0
    tttt%=MAX(16384,SUB(FRE(0),16384)) AND -4   ! Laisse toujours 16 Ko de libre mais min 16 Ko.
    DIM mem_rotation%(PRED(SHR(tttt%,2)))       ! Deplacement par pas de tttt% bytes
    adr_t%=V:mem_rotation%(0)
    dddd%=dddd% MOD llll%                       ! Meilleure direction de deplacement
    IF ABS(dddd%)>SHR(llll%,2)
      SUB dddd%,MUL(llll%,SGN(dddd%))
    ENDIF
    IF dddd%=>0
      WHILE dddd%>0                             ! Deplacement positif (vers la droite)
        bbbb%=MIN(dddd%,tttt%)
        ~C:g_bmove%(L:ADD(aaaa%,SUB(llll%,bbbb%)),L:adr_t%,L:bbbb%)
        ~C:g_bmove%(L:aaaa%,L:ADD(aaaa%,bbbb%),L:SUB(llll%,bbbb%))
        ~C:g_bmove%(L:adr_t%,L:aaaa%,L:bbbb%)
        SUB dddd%,bbbb%
      WEND
    ELSE
      WHILE dddd%<0                             ! Deplacement negatif (vers la gauche)
        bbbb%=MIN(-dddd%,tttt%)
        ~C:g_bmove%(L:aaaa%,L:adr_t%,L:bbbb%)
        ~C:g_bmove%(L:ADD(aaaa%,bbbb%),L:aaaa%,L:SUB(llll%,bbbb%))
        ~C:g_bmove%(L:adr_t%,L:ADD(aaaa%,SUB(llll%,bbbb%)),L:bbbb%)
        ADD dddd%,bbbb%
      WEND
    ENDIF
    ERASE mem_rotation%()
  ENDIF
RETURN
PROCEDURE help(page%)
  LOCAL i%,j%,k%,xp%,yp%,xm%,ym%,km%,flag_fin!,a$
  HIDEM
  flag_fin!=FALSE
  xp%=SUB(SHR(scr_ncol%,1),36)
  yp%=SUB(SHR(scr_haut%,1),81)
  GOSUB cadre_texte("PREVIOUS PAGE",xp%,ADD(yp%,152),32)
  GOSUB cadre_texte("EXIT",ADD(xp%,33),ADD(yp%,152),5)
  GOSUB cadre_texte("NEXT PAGE",ADD(xp%,39),ADD(yp%,152),32)
  pmax%=&H7FFFFFFF
  GOSUB aff_helppage(page%,xp%,yp%)
  REPEAT
    SHOWM
    MOUSE xm%,ym%,km%
    IF ym%>ADD(yp%,162) OR ym%<ADD(yp%,151)
      km%=0
    ENDIF
    DIV xm%,8
    IF km%<>0
      IF xm%>PRED(xp%) AND xm%<ADD(xp%,33) AND page%>0
        GOSUB cadre_texte2("PREVIOUS PAGE",xp%,ADD(yp%,152),32,1)
        GOSUB wait_mouse(TRUE)
        DEC page%
        GOSUB aff_helppage(page%,xp%,yp%)
        GOSUB cadre_texte("PREVIOUS PAGE",xp%,ADD(yp%,152),32)
      ELSE IF xm%>ADD(xp%,38) AND xm%<ADD(xp%,72) AND page%<help_pmax%
        GOSUB cadre_texte2("NEXT PAGE",ADD(xp%,39),ADD(yp%,152),32,1)
        GOSUB wait_mouse(TRUE)
        INC page%
        GOSUB aff_helppage(page%,xp%,yp%)
        GOSUB cadre_texte("NEXT PAGE",ADD(xp%,39),ADD(yp%,152),32)
      ELSE IF xm%>ADD(xp%,32) AND xm%<ADD(xp%,39)
        flag_fin!=TRUE
      ENDIF
    ENDIF
    IF GEMDOS(11)<>0
      k%=SHR(GEMDOS(7),16) AND 255
      GOSUB vide_buffer_clavier
      SELECT k%
      CASE 1,28,114
        flag_fin!=TRUE
      CASE 75
        IF page%>0
          GOSUB cadre_texte2("PREVIOUS PAGE",xp%,ADD(yp%,152),32,1)
          DEC page%
          GOSUB aff_helppage(page%,xp%,yp%)
          GOSUB cadre_texte("PREVIOUS PAGE",xp%,ADD(yp%,152),32)
        ENDIF
      CASE 77
        IF page%<help_pmax%
          GOSUB cadre_texte2("NEXT PAGE",ADD(xp%,39),ADD(yp%,152),32,1)
          INC page%
          GOSUB aff_helppage(page%,xp%,yp%)
          GOSUB cadre_texte("NEXT PAGE",ADD(xp%,39),ADD(yp%,152),32)
        ENDIF
      ENDSELECT
    ENDIF
  UNTIL flag_fin!
  GOSUB cadre_texte2("EXIT",ADD(xp%,33),ADD(yp%,152),5,1)
  GOSUB wait_mouse(TRUE)
  GOSUB cadre_texte("EXIT",ADD(xp%,33),ADD(yp%,152),5)
  GOSUB affiche_panneau_principal
  GOSUB aff_message("GRAOUMF TRACKER v"+STR$(gtk_version%/10000)+mes_registred$)
RETURN
PROCEDURE aff_helppage(page%,xp%,yp%)
  LOCAL j%
  GOSUB cadre_int(xp%,yp%,71,151,8,8,9,8)
  GOSUB affiche_one_graoumf_logo(ADD(SHL(xp%,3),128),ADD(yp%,16))
  FOR j%=0 TO 23
    GOSUB affchaine_trans(help$(j%,page%),SHL(SUCC(xp%),1),ADD(ADD(yp%,4),MUL(j%,6)),10)
  NEXT j%
RETURN
PROCEDURE prefs                         !!!
  GOSUB cadre_int(2,16,75,167,9,9,10,8)
  ~GEMDOS(7)
  GOSUB affiche_panneau_principal
RETURN
PROCEDURE clear_mem(aaaa%,llll%)
  ' Vide une partie de la memoire (methode rapide en GfA)
  ' aaaa% = adresse, llll% = longueur
  ' Ne fait rien si longueur <= 0
  LOCAL l_clr%
  ~FRE(0)
  IF llll%>0
    l_clr%=1
    BYTE{aaaa%}=0                               ! Efface le premier octet
    WHILE l_clr%<=SHR(llll%,1)                  ! Efface au moins la moitie du
      BMOVE aaaa%,ADD(aaaa%,l_clr%),l_clr%      ! buffer par doublages successifs
      ADD l_clr%,l_clr%                         ! de la surface effacee
    WEND
    BMOVE aaaa%,ADD(aaaa%,l_clr%),SUB(llll%,l_clr%)     ! Le reste
  ENDIF
RETURN
PROCEDURE snapshot
  ' Effectue un snapshot de l'ecran au format TGA
  LOCAL a%,c1%,c2%,c3%,i%,j%,x1%,x2%,y1%,y2%
  LOCAL km%,xm%,ym%
  LOCAL a$,b$,c1$,c2$,c3$,header$,n$
  '
  ' Prend le morceau de l'ecran a capturer
  '
  SHOWM
  REPEAT
    MOUSE xm%,ym%,km%
  UNTIL km%<>0
  x1%=xm%
  y1%=ym%
  GOSUB wait_mouse(TRUE)
  REPEAT
    MOUSE xm%,ym%,km%
  UNTIL km%<>0
  a%=MIN(x1%,xm%)
  x2%=MAX(x1%,xm%)
  x1%=a%
  a%=MIN(y1%,ym%)
  y2%=MAX(y1%,ym%)
  y1%=a%
  INC snapshot_number%                          ! Nouveau snapshot
  '
  ' Le nom
  '
  a%=snapshot_number%
  n$=""
  FOR i%=1 TO 4
    n$=RIGHT$(STR$(a%),1)+n$
    DIV a%,10
  NEXT i%
  n$=npath_div$+"SNAP"+n$+".TGA"
  OPEN "o",#1,n$
  IF snapshot_format%=0
    '
    ' Format TGA 16 couleurs avec palette
    '
    ' --- Le header ---
    header$=CHR$(0)+CHR$(1)+CHR$(1)
    header$=header$+MKI$(0)+MKI$(16)+CHR$(24)
    header$=header$+MKI$(0)+MKI$(0)
    header$=header$+MKI$(SUCC(SUB(x2%,x1%)))+MKI$(SUCC(SUB(y2%,y1%)))
    header$=header$+CHR$(4)+CHR$(&X100000)
    GOSUB intel_w(ADD(V:header$,3))
    GOSUB intel_w(ADD(V:header$,5))
    GOSUB intel_w(ADD(V:header$,8))
    GOSUB intel_w(ADD(V:header$,10))
    GOSUB intel_w(ADD(V:header$,12))
    GOSUB intel_w(ADD(V:header$,14))
    BPUT #1,V:header$,LEN(header$)
    ' --- La palette ---
    a$=""
    FOR i%=0 TO 15
      a$=a$+CHR$(PEEK(ADD(&HFFFF9803,SHL(i%,2))))
      a$=a$+CHR$(PEEK(ADD(&HFFFF9801,SHL(i%,2))))
      a$=a$+CHR$(PEEK(ADD(&HFFFF9800,SHL(i%,2))))
    NEXT i%
    BPUT #1,V:a$,LEN(a$)
    ' --- L'image ---
    a$=STRING$(SHR(ADD(SUB(x2%,x1%),2),1),0)
    FOR j%=y1% TO y2%
      a%=V:a$
      FOR i%=x1% TO x2% STEP 2
        BYTE{a%}=ADD(SHL(PTST(i%,j%),4),PTST(SUCC(i%),j%))
        INC a%
      NEXT i%
      BPUT #1,V:a$,LEN(a$)
    NEXT j%
  ELSE
    '
    ' Format TGA 24 bits
    '
    ' --- Le header ---
    header$=CHR$(0)+CHR$(0)+CHR$(2)
    header$=header$+MKI$(0)+MKI$(0)+CHR$(0)
    header$=header$+MKI$(0)+MKI$(0)
    header$=header$+MKI$(SUCC(SUB(x2%,x1%)))+MKI$(SUCC(SUB(y2%,y1%)))
    header$=header$+CHR$(24)+CHR$(&X100000)
    GOSUB intel_w(ADD(V:header$,3))
    GOSUB intel_w(ADD(V:header$,5))
    GOSUB intel_w(ADD(V:header$,8))
    GOSUB intel_w(ADD(V:header$,10))
    GOSUB intel_w(ADD(V:header$,12))
    GOSUB intel_w(ADD(V:header$,14))
    BPUT #1,V:header$,LEN(header$)
    ' --- L'image ---
    c1$=""
    c2$=""
    c3$=""
    FOR i%=0 TO 15
      c1$=c1$+CHR$(PEEK(ADD(&HFFFF9803,SHL(i%,2))))
      c2$=c2$+CHR$(PEEK(ADD(&HFFFF9801,SHL(i%,2))))
      c3$=c3$+CHR$(PEEK(ADD(&HFFFF9800,SHL(i%,2))))
    NEXT i%
    a$=STRING$(MUL(SUCC(SUB(x2%,x1%)),3),0)
    b$=""
    FOR j%=y1% TO y2%
      a%=V:a$
      c1%=V:c1$
      c2%=V:c2$
      c3%=V:c3$
      FOR i%=x1% TO x2%
        b%=PTST(i%,j%)
        BYTE{a%}=BYTE{ADD(c1%,b%)}
        INC a%
        BYTE{a%}=BYTE{ADD(c2%,b%)}
        INC a%
        BYTE{a%}=BYTE{ADD(c3%,b%)}
        INC a%
      NEXT i%
      b$=b$+a$
      IF LEN(b$)>SUB(32700,LEN(a$)) OR j%=y2%
        BPUT #1,V:b$,LEN(b$)
        b$=""
      ENDIF
    NEXT j%
  ENDIF
  CLOSE #1
RETURN
PROCEDURE rec_result(a$,crlf!)
  ' Enregistre une chaine dans le fichier resultat.
  ' Ecran pour l'instant.
  IF NOT flag_autoload!
    PRINT a$;
    IF crlf!
      PRINT
    ENDIF
  ENDIF
RETURN
PROCEDURE decale_sample(i%,nbs%,adi%)
  ' adi$ commence au sample 1 et contient des adresses
  LOCAL a%,b%,c%,d%,j%,pt%
  a%=FN length(i%)
  d%=FN adresse(i%)
  b%=ADD(a%,d%)
  pt%=LONG{ADD(adi%,SHL(PRED(i%),2))}
  IF a%>0
    j%=i%                       ! Scanne les samples suivants
    WHILE j%<nbs%
      c%=LONG{ADD(adi%,SHL(j%,2))}
      EXIT IF c%<b% AND c%>d%
      INC j%
    WEND
    IF j%<nbs% OR flag_keep_buffer!     ! On a trouve un sample qui va se faire ecraser alors on tourne
      GOSUB mem_rotation(d%,SUB(ADD(pt%,a%),d%),a%)
      IF i%<nbs%                        ! Repositionne les samples qui etaient avant celui-la
        FOR j%=SHL(i%,2) TO SHL(PRED(nbs%),2) STEP 4
          IF LONG{ADD(adi%,j%)}<pt%
            LONG{ADD(adi%,j%)}=ADD(LONG{ADD(adi%,j%)},a%)
          ENDIF
        NEXT j%
      ENDIF
      ADD translate%,a%
    ELSE                        ! Pas de probleme, on effectue une simple copie et un deplacement du reste
      IF i%<255
        ~C:g_bmove%(L:d%,L:b%,L:SUB(FN adr_buffer,d%))
      ENDIF
      ~C:g_bmove%(L:pt%,L:d%,L:a%)
    ENDIF
    IF i%<255                   ! Reajuste les adresses des samples suivants
      FOR j%=SHL(SUCC(i%),2) TO &H3FC STEP 4
        LONG{ADD(r_adr_sample%,j%)}=ADD(LONG{ADD(r_adr_sample%,j%)},a%)
      NEXT j%
    ENDIF
  ENDIF
RETURN
PROCEDURE next_line
  SELECT line_step%
  CASE -255 TO 255
    ADD posligne%,line_step%
  CASE 256
    GOSUB cherche_next_line(&HFFFFFFFF,&HFF)
  CASE 257
    GOSUB cherche_next_line(&HFF000000,&H0)
  CASE 258
    GOSUB cherche_next_line(&HFFFF,&H0)
  CASE 259
    GOSUB cherche_next_line(&H0,&HFF)
  ENDSELECT
  WHILE posligne%=>FN nbr_lines3
    SUB posligne%,FN nbr_lines3
  WEND
  WHILE posligne%<0
    ADD posligne%,FN nbr_lines3
  WEND
  GOSUB affiche_c_pattern
RETURN
PROCEDURE cherche_next_line(mask1%,mask2%)
  LOCAL a%,b%,adr%,start%,ligne%
  start%=posligne%
  ligne%=start%
  REPEAT
    ligne%=SUCC(ligne%) MOD FN nbr_lines3
    adr%=FN adr_strk(songpos%,ligne%,preset&(curs_col%,n_preset%))
    a%=LONG{adr%} AND mask1%
    b%=BYTE{ADD(adr%,4)} AND mask2%
  UNTIL a%<>0 OR b%<>0 OR ligne%=start%
  posligne%=ligne%
RETURN
PROCEDURE curseur_a_gauche
  DEC curs_x%
  IF curs_x%<0
    curs_x%=VAL(MID$("268",SUCC(type_affpiste%),1))
    DEC curs_col%
    IF curs_col%<0
      curs_col%=PRED(MIN(nbr_colonnes%(n_preset%),nbr_col%))
    ENDIF
  ENDIF
  GOSUB affiche_c_pattern
RETURN
PROCEDURE curseur_a_droite
  INC curs_x%
  IF curs_x%>VAL(MID$("268",SUCC(type_affpiste%),1))
    curs_x%=0
    INC curs_col%
    IF curs_col%>PRED(MIN(nbr_colonnes%(n_preset%),nbr_col%))
      curs_col%=0
    ENDIF
  ENDIF
  GOSUB affiche_c_pattern
RETURN
PROCEDURE edit_mode_on
  edit%=1
  CARD{r_current_edit_mode%}=1
RETURN
PROCEDURE edit_mode_off
  edit%=0
  CARD{r_current_edit_mode%}=0
RETURN
PROCEDURE play_pattern_bidon
  DPOKE r_mod_songrep%,1
  DPOKE r_mod_songlen%,2
  DPOKE r_mod_songpos%,0
  DPOKE r_mod_numpat%,256
  DPOKE r_mod_patrep%,0
  LPOKE r_adr_module%,V:module_bidon%(0)
  LPOKE r_adr_song%,V:song_bidon%(0)
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
RETURN
PROCEDURE play_song(a!)
  GOSUB play_song2(a!)
  GOSUB aff_ps_pp_e
  GOSUB aff_message("Playing song...")
RETURN
PROCEDURE play_song2(a!)
  LOCAL old_play_mode%
  old_play_mode%=play%
  IF old_play_mode%=0 OR (NOT a!)
    GOSUB stop_voices
    play%=1
    CARD{r_current_play_mode%}=1
    LPOKE r_adr_module%,V:module&(0)
    LPOKE r_adr_song%,V:song&(0)
    DPOKE r_mod_songrep%,module&(102)
    DPOKE r_mod_songlen%,module&(101)
    DPOKE r_mod_songpos%,songpos%
    DPOKE r_mod_numpat%,song&(songpos%)
    IF a!
      DPOKE r_mod_linepos%,posligne%
    ELSE
      DPOKE r_mod_linepos%,0
    ENDIF
    DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
    debut_temps%=TIMER
  ELSE
    play%=1
    CARD{r_current_play_mode%}=1
    LPOKE r_adr_module%,V:module&(0)
    LPOKE r_adr_song%,V:song&(0)
    DPOKE r_mod_songrep%,module&(102)
    DPOKE r_mod_songlen%,module&(101)
  ENDIF
  IF edit%=0
    SLPOKE &HFFFF983C,&HE00000  ! Vert
  ENDIF
RETURN
PROCEDURE play_pattern(a!)
  LOCAL old_play_mode%
  old_play_mode%=play%
  IF old_play_mode%=0 OR (NOT a!)
    GOSUB stop_voices
    play%=2
    CARD{r_current_play_mode%}=2
    LPOKE r_adr_module%,V:module&(0)
    LPOKE r_adr_song%,V:song&(0)
    DPOKE r_mod_songrep%,songpos%
    DPOKE r_mod_songlen%,SUCC(songpos%)
    DPOKE r_mod_songpos%,songpos%
    DPOKE r_mod_numpat%,song&(songpos%)
    IF a!
      DPOKE r_mod_linepos%,posligne%
    ELSE
      DPOKE r_mod_linepos%,0
    ENDIF
    DPOKE r_mod_nbrvbl%,DPEEK(r_mod_speed%)
    debut_temps%=TIMER
  ELSE
    play%=2
    CARD{r_current_play_mode%}=2
    LPOKE r_adr_module%,V:module&(0)
    LPOKE r_adr_song%,V:song&(0)
    DPOKE r_mod_songrep%,songpos%
    DPOKE r_mod_songlen%,SUCC(songpos%)
  ENDIF
  GOSUB aff_ps_pp_e
  GOSUB aff_message("Playing pattern...")
  IF edit%=0
    SLPOKE &HFFFF983C,&HFF800000  ! Jaune
  ENDIF
RETURN
PROCEDURE stop_voices
  LOCAL i%
  FOR i%=0 TO PRED(nbr_track%)
    LONG{ADD(V:pattern_bidon%(8),MUL(i%,5))}=0
  NEXT i%
  CARD{r_current_play_mode%}=0
  GOSUB play_pattern_bidon
  DPOKE r_flag_stop_voices%,1
  play%=0
  IF edit%=0
    SLPOKE &HFFFF983C,&HFFFF00FF  ! Blanc
  ELSE
    SLPOKE &HFFFF983C,&HFF        ! Bleu
  ENDIF
  REPEAT
  UNTIL DPEEK(r_flag_stop_voices%)=0
RETURN
PROCEDURE stop_edit
  IF play%<>0
    IF play%=1
      GOSUB aff_message("Song stopped.")
    ELSE
      GOSUB aff_message("Pattern stopped.")
    ENDIF
    GOSUB stop_voices
    GOSUB edit_mode_off
    SLPOKE &HFFFF983C,&HFFFF00FF                ! Blanc
    IF NOT flag_cpu_display!
      GOSUB cadre_int(75,140,3,7,9,9,9,9)       ! Efface le temps machine si on ne le demande pas en mode Stop
    ENDIF
  ELSE
    GOSUB stop_voices
    IF edit%=0
      GOSUB edit_mode_on
      SLPOKE &HFFFF983C,&HFF                    ! Bleu
      GOSUB aff_message("Edit mode activated.")
    ELSE
      GOSUB edit_mode_off
      SLPOKE &HFFFF983C,&HFFFF00FF              ! Blanc
      GOSUB aff_message("Edit mode deactivated.")
    ENDIF
  ENDIF
  GOSUB aff_ps_pp_e
RETURN
PROCEDURE kill_sample(s%)
  GOSUB stop_voices
  GOSUB chg_taille_sample(s%,0)
  a$="SAMP"+MKL$(64)+MKI$(s%)+SPACE$(28)+MKI$(0)+MKI$(&HFFFF)+MKI$(8)+MKI$(8363)+MKL$(0)+MKL$(0)+MKL$(2)+MKI$(0)+MKI$(0)+MKI$(0)
  BMOVE V:a$,FN adrsamchk(s%),64
RETURN
PROCEDURE clear_patterns2
  ' Se contente de reduire les patterns a leur taille minimum
  LOCAL a%,b%,c%,i%,a$
  c%=1                                          ! 1 seule ligne pour tous les patterns vides
  b%=FN zone_start
  a%=ADD(MUL(MUL(c%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(c%)+MKI$(nbr_track%)
  FOR i%=0 TO 255
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB chg_pat_chunkadr(i%,b%)
    ADD b%,a%
  NEXT i%
  bl_start&=0
  bl_end&=0
  bl_pat&=0
RETURN
PROCEDURE clear_patterns
  LOCAL i%
  GOSUB clear_patterns2
  FOR i%=0 TO 255
    GOSUB clear_mem(FN adr_pat(i%),MUL(MUL(FN nbr_track(i%),FN nbr_lines(i%)),5))
  NEXT i%
  GOSUB garbage_collection
RETURN
PROCEDURE clear_song(flag!)
  ' Efface la song et les patterns
  ' Si flag! est faux, songname n'est pas efface
  LOCAL a%,b%,i%
  GOSUB stop_voices
  ARRAYFILL song&(),0
  GOSUB clear_patterns
  IF flag!
    FOR i%=2 TO 97
      module&(i%)=&H2020
    NEXT i%
  ENDIF
  module&(101)=1
  module&(102)=0
  songpos%=0
RETURN
PROCEDURE clear_samples
  ' Efface les samples
  GOSUB stop_voices
  GOSUB clear_samples2
  sample%=1
RETURN
PROCEDURE clear_samples2
  LOCAL i%,j%,a$
  j%=ADD(FN env_chunkadr(63,2),FN env_chunklen(63,2))
  a$="SAMP"+MKL$(64)+MKI$(0)+SPACE$(28)+MKI$(0)+MKI$(&HFFFF)+MKI$(8)+MKI$(8363)+MKL$(0)+MKL$(0)+MKL$(2)+MKI$(0)+MKI$(0)+MKI$(0)
  FOR i%=0 TO 255
    LONG{ADD(r_adr_sample%,SHL(i%,2))}=ADD(j%,MUL(i%,64))
    BMOVE V:a$,LONG{ADD(r_adr_sample%,SHL(i%,2))},64
    CARD{ADD(LONG{ADD(r_adr_sample%,SHL(i%,2))},8)}=i%
  NEXT i%
  GOSUB garbage_collection
RETURN
PROCEDURE clear_instr
  ' Efface les instruments (seulement les instr+env, pas les samples)
  LOCAL a%,b%,i%,j%
  FOR i%=0 TO 255
    instrset%(0,i%)=&H494E5354                  ! 'INST'
    instrset%(1,i%)=316                         ! Taille du chunk
    instrset%(2,i%)=ADD(SHL(i%,16),&H2020)      ! Numero + Nom
    FOR j%=3 TO 8
      instrset%(j%,i%)=&H20202020               ! Nom
    NEXT j%
    instrset%(9,i%)=&H20200000                  ! Nom + Type (sample)
    instrset%(10,i%)=&H100FFFF                  ! Volume + Autobalance
    instrset%(11,i%)=0                          ! Enveloppe volume + tonalite
    instrset%(12,i%)=0                          ! Enveloppe panning + reserve
    instrset%(13,i%)=0                          ! Reserve
    instrset%(14,i%)=0                          ! Reserve
    instrset%(15,i%)=SHL(i%,8)
    a%=ADD(SHL(i%,24),SHL(i%,8))
    b%=V:instrset%(16,i%)
    LONG{b%}=a%
    BMOVE b%,ADD(b%,4),4                        ! Remplit 252 octets avec le meme mot
    BMOVE b%,ADD(b%,8),8
    BMOVE b%,ADD(b%,16),16
    BMOVE b%,ADD(b%,32),32
    BMOVE b%,ADD(b%,64),64
    BMOVE b%,ADD(b%,128),124
  NEXT i%
  GOSUB clear_enveloppes
RETURN
PROCEDURE clear_enveloppes
  ' Efface les enveloppes de volume, tonalite et panning
  ' Dans la mem, les env sont rangees dans cet ordre : V T P  V T P  V T P...
  LOCAL i%,a%,deb%
  deb%=ADD(FN adr_patchunk(255),FN lon_patchunk(255))
  FOR i%=0 TO 63
    a%=ADD(deb%,MUL(i%,102))
    LONG{a%}=&H56454E56         ! 'VENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,0,a%)
    a%=ADD(ADD(deb%,34),MUL(i%,102))
    LONG{a%}=&H54454E56         ! 'TENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,1,a%)
    a%=ADD(ADD(deb%,68),MUL(i%,102))
    LONG{a%}=&H50454E56         ! 'PENV'
    LONG{ADD(a%,4)}=34
    CARD{ADD(a%,8)}=i%
    LONG{ADD(a%,10)}=&H20202020
    LONG{ADD(a%,14)}=&H20202020
    LONG{ADD(a%,18)}=&H20202020
    LONG{ADD(a%,22)}=&H20202020
    LONG{ADD(a%,26)}=&H20202020
    LONG{ADD(a%,30)}=&H10000
    GOSUB chg_env_chunkadr(i%,2,a%)
  NEXT i%
  env_poscurs&=0
  env_posaff&=0
  GOSUB garbage_collection
RETURN
PROCEDURE garbage_collection
  ' Regroupe les patterns, enveloppes et samples
  ' dans cet ordre, en bas de la memoire.
  ' garbage% aurorise la manipulation de chaque type de chunk
  LOCAL i%,j%,na%,oa%,l%
  ' Les patterns
  IF garbage%>0
    FOR i%=0 TO 255
      oa%=FN adr_patchunk(i%)
      IF i%>0
        na%=ADD(FN adr_patchunk(PRED(i%)),FN lon_patchunk(PRED(i%)))
      ELSE
        na%=FN zone_start
      ENDIF
      IF oa%<>na%
        l%=FN lon_patchunk(i%)
        GOSUB chg_pat_chunkadr(i%,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
  ' Les enveloppes
  IF garbage%>1
    FOR i%=0 TO 191
      oa%=FN env_chunkadr(DIV(i%,3),i% MOD 3)
      IF i%>0
        na%=ADD(FN env_chunkadr(DIV(PRED(i%),3),PRED(i%) MOD 3),FN env_chunklen(DIV(PRED(i%),3),PRED(i%) MOD 3))
      ELSE
        na%=ADD(FN adr_patchunk(255),FN lon_patchunk(255))
      ENDIF
      IF oa%<>na%
        l%=FN env_chunklen(DIV(i%,3),i% MOD 3)
        GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
  ' Les samples
  IF garbage%>2
    FOR i%=0 TO 255
      oa%=FN adrsamchk(i%)
      IF i%>0
        na%=ADD(FN adrsamchk(PRED(i%)),FN lonsamchk(PRED(i%)))
      ELSE
        na%=ADD(FN env_chunkadr(63,2),FN env_chunklen(63,2))
      ENDIF
      IF oa%<>na%
        l%=FN lonsamchk(i%)
        GOSUB chg_sam_chunkadr(i%,na%)
        ~C:g_bmove%(L:oa%,L:na%,L:l%)
      ENDIF
    NEXT i%
  ENDIF
RETURN
PROCEDURE create_space_patchunk(p%,t%,l%,flag!)
  ' Demenage la memoire pour obtenir un pattern de t% tracks, l% lignes
  ' Le header du chunk est modifie mais pas les donnees du pattern
  ' Si flag! n'est pas mis, seulement les patterns seront deplaces (on devra
  ' avoir verifie que la place pour cette operation a bien ete inseree entre
  ' les patterns et les enveloppes).
  LOCAL a%,b%,c%,i%,oldlen%,newlen%,dif%
  IF p%<255
    oldlen%=SUB(FN adr_patchunk(SUCC(p%)),FN adr_patchunk(p%))
  ELSE
    oldlen%=SUB(FN env_chunkadr(0,0),FN adr_patchunk(p%))
  ENDIF
  newlen%=ADD(MUL(MUL(t%,l%),5),32)
  dif%=SUB(newlen%,oldlen%)
  IF dif%<>0
    a%=ADD(FN adr_patchunk(p%),oldlen%)
    b%=ADD(FN adr_patchunk(p%),newlen%)
    c%=SUB(FN adr_buffer,a%)
    IF p%<255
      FOR i%=SUCC(p%) TO 255                      ! Change les adresses des patterns
        GOSUB chg_pat_chunkadr(i%,ADD(FN adr_patchunk(i%),dif%))
      NEXT i%
    ENDIF
    IF flag!
      FOR i%=0 TO 191                             ! Change les adresses des enveloppes
        GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),dif%))
      NEXT i%
      FOR i%=0 TO 255                             ! Change les adresses des samples
        GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
      NEXT i%
    ENDIF
    IF flag!
      ~C:g_bmove%(L:a%,L:b%,L:c%)
    ELSE IF p%<255
      ~C:g_bmove%(L:a%,L:b%,L:SUB(FN env_chunkadr(0,0),MAX(a%,b%)))
    ENDIF
  ENDIF
  GOSUB chg_pat_chunklen(p%,newlen%)
  GOSUB chg_pat_nbr_lines(p%,l%)
  GOSUB chg_pat_nbr_track(p%,t%)
RETURN
PROCEDURE create_space_multipatchunk(map$,nbp%,flag!)
  ' Comme ci-dessus mais pour plusieurs patterns (0...nbp%-1)
  ' map$ contient (NbTi.w,NbLi.w), i de 0 a nbp%-1
  ' Tous les chunks sont bien deplaces
  ' Si flag! est mis, les nouveaux patterns crees sont nettoyes
  LOCAL a%,b%,c%,d%,i%,dif%
  LOCAL a$
  ' Calcul de la place occupee par ces nouveaux patterns
  a%=0
  FOR i%=0 TO PRED(nbp%)
    ADD a%,ADD(MUL(MUL(CARD{ADD(V:map$,SHL(i%,2))},CARD{ADD(V:map$,ADD(SHL(i%,2),2))}),5),32)
  NEXT i%
  IF nbp%<256
    dif%=SUB(ADD(FN zone_start,a%),FN adr_patchunk(nbp%))
    ~C:g_bmove%(L:FN adr_patchunk(nbp%),L:ADD(FN zone_start,a%),L:SUB(FN adr_buffer,FN adr_patchunk(nbp%)))
    FOR i%=nbp% TO 255                            ! Change les adresses des patterns suivants
      GOSUB chg_pat_chunkadr(i%,ADD(FN adr_patchunk(i%),dif%))
    NEXT i%
    FOR i%=0 TO 191                               ! Change les adresses des enveloppes
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),dif%))
    NEXT i%
    FOR i%=0 TO 255                               ! Change les adresses des samples
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
    NEXT i%
  ELSE
    GOSUB create_space_for_patterns(SUB(a%,SUB(FN env_chunkadr(0,0),FN zone_start)))
  ENDIF
  ' Creation des nouveaux chunks a la bonne taille
  b%=FN zone_start
  FOR i%=0 TO PRED(nbp%)
    c%=CARD{ADD(V:map$,SHL(i%,2))}
    d%=CARD{ADD(V:map$,ADD(SHL(i%,2),2))}
    a%=ADD(MUL(MUL(c%,d%),5),32)
    a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(d%)+MKI$(c%)
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB chg_pat_chunkadr(i%,b%)
    IF flag!
      GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    ENDIF
    ADD b%,a%
  NEXT i%
RETURN
PROCEDURE create_space_for_patterns(l%)
  ' Deplace les chunks des enveloppes et des samples de facon a laisser
  ' l% octets en plus pour les patterns.
  LOCAL a%,b%,c%,i%
  IF l%>0
    a%=FN env_chunkadr(0,0)
    b%=ADD(a%,l%)
    c%=SUB(FN adr_buffer,a%)
    FOR i%=0 TO 191                               ! Change les adresses des enveloppes
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),l%))
    NEXT i%
    FOR i%=0 TO 255                               ! Change les adresses des samples
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),l%))
    NEXT i%
    ~C:g_bmove%(L:a%,L:b%,L:c%)
  ENDIF
RETURN
PROCEDURE change_pattern_high(p%,l%)
  LOCAL ol%
  ol%=FN nbr_lines(p%)
  GOSUB create_space_patchunk(p%,nbr_track%,l%,TRUE)
  IF l%>ol%
    GOSUB clear_mem(FN adr_line(p%,ol%),MUL(MUL(nbr_track%,SUB(l%,ol%)),5))
  ENDIF
  IF p%=bl_pat&
    bl_end&=MIN(bl_end&,PRED(l%))
    bl_start&=MIN(bl_start&,bl_end&)
  ENDIF
RETURN
PROCEDURE change_format(t%)
  LOCAL bouton%,a$,a%
  a$="DO YOU REALLY WANT TO CHANGE THE|PATTERN SIZE TO "+STR$(t%)+" TRACKS ?"
  IF t%<nbr_track%
    a$=a$+"|"+STR$(SUB(nbr_track%,t%))+" TRACK(S) WILL BE LOST"
    a$=a$+"||1. New song|2. Try to keep the song|3. Abort the operation"
  ENDIF
  GOSUB dialog("CHANGE NUMBER OF TRACKS",a$,"NEW|KEEP|CANCEL",xm%,ym%)
  IF bouton%=0
    GOSUB aff_message("WAITING : CONVERTING...")
    GOSUB bee(TRUE)
    GOSUB new_pattern_format(t%)
  ELSE IF bouton%=1
    GOSUB aff_message("WAITING : CONVERTING...")
    GOSUB bee(TRUE)
    GOSUB chg_pattern_format(t%)
  ENDIF
  GOSUB bee(FALSE)
  GOSUB affiche_info_song
  GOSUB affiche_info_preset
RETURN
PROCEDURE new_pattern_format(t%)
  ' Change le nbr de voies t%, de lignes 1 et efface la chanson
  LOCAL a%,b%,i%,j%
  LOCAL a$
  GOSUB stop_voices
  GOSUB clear_patterns2
  sample%=1
  instr%=1
  songpos%=0
  posligne%=0
  curs_col%=0
  curs_x%=0
  a%=nbr_track%
  nbr_track%=t%
  module&(100)=t%
  module&(101)=1        ! Longueur song
  module&(102)=0        ! Pt de bouclage
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  GOSUB create_space_for_patterns(MUL(MUL(MAX(SUB(nbr_track%,a%),0),5),256))
  GOSUB clear_song(FALSE)
  ARRAYFILL nbr_colonnes%(),nbr_track%
  para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
  module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
  module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  DPOKE r_master_vol%,DIV(&H3000,ADD(nbr_track%,3))
  DPOKE r_mod_songpos%,songpos%
  DPOKE r_mod_numpat%,song&(songpos%)
  DPOKE r_mod_speed%,6
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrtrack%,nbr_track%
  bl_start&=0
  bl_end&=0
  bl_trk&=0
  bl_pat&=0
  GOSUB stop_voices
  GOSUB all_track_on(FALSE)
  GOSUB balance_reset
RETURN
PROCEDURE chg_pattern_format(t%)
  ' Change le nbr de voies t% et essaie de garder la chanson
  ' Attention au format 32 piste/256 lignes, car utilisation d'une chaine de
  ' 32768 octets. Normalement pas de bug car GfA gere les chaines au mot pres
  LOCAL a%,b%,c%,d%,i%,j%,otp%
  LOCAL a$,b$
  GOSUB stop_voices
  IF t%>nbr_track%
    a%=0
    FOR i%=0 TO 255
      ADD a%,FN nbr_lines(i%)
    NEXT i%
    MUL a%,MUL(SUB(t%,nbr_track%),5)
    GOSUB create_space_for_patterns(a%)
    FOR i%=0 TO 255
      otp%=MUL(nbr_track%,FN nbr_lines(i%))
      a$=STRING$(MUL(otp%,5),0)
      BMOVE FN adr_pat(i%),V:a$,MUL(otp%,5)
      GOSUB create_space_patchunk(i%,t%,FN nbr_lines(i%),FALSE)
      GOSUB clear_mem(FN adr_pat(i%),MUL(MUL(t%,FN nbr_lines(i%)),5))
      a%=V:a$
      b%=FN adr_pat(i%)
      c%=MUL(nbr_track%,5)
      d%=MUL(t%,5)
      FOR j%=0 TO PRED(FN nbr_lines(i%))
        BMOVE a%,b%,c%
        ADD a%,c%
        ADD b%,d%
      NEXT j%
    NEXT i%
  ELSE
    FOR i%=0 TO 255
      otp%=MUL(nbr_track%,FN nbr_lines(i%))
      a$=STRING$(MUL(otp%,5),0)
      BMOVE FN adr_pat(i%),V:a$,MUL(otp%,5)
      GOSUB create_space_patchunk(i%,t%,FN nbr_lines(i%),FALSE)
      a%=V:a$
      b%=FN adr_pat(i%)
      c%=MUL(nbr_track%,5)
      d%=MUL(t%,5)
      FOR j%=0 TO PRED(FN nbr_lines(i%))
        BMOVE a%,b%,d%
        ADD a%,c%
        ADD b%,d%
      NEXT j%
    NEXT i%
  ENDIF
  GOSUB garbage_collection
  nbr_track%=t%
  module&(100)=t%
  FOR j%=0 TO 31
    FOR i%=0 TO 31
      preset&(i%,j%)=ADD(i%,j%) MOD nbr_track%
    NEXT i%
  NEXT j%
  ARRAYFILL nbr_colonnes%(),nbr_track%
  para_affiche_pattern$=MKI$(nbr_track%)+MKI$(nbr_lines%)+MKI$(MIN(nbr_col%,nbr_track%))+MKI$(haut_lig%)+STRING$(64,0)+MKI$(type_affpiste%)
  module_bidon%(50)=ADD(&HFF0000,nbr_lines%)
  module_bidon%(51)=ADD(SHL(nbr_track%,16),2)
  a%=ADD(MUL(MUL(nbr_lines%,nbr_track%),5),32)
  a$="PATD"+MKL$(a%)+MKI$(0)+SPACE$(16)+MKI$(0)+MKI$(nbr_lines%)+MKI$(nbr_track%)
  b%=V:pattern_bidon%(0)
  FOR i%=256 TO 257
    CARD{ADD(V:a$,8)}=i%
    BMOVE V:a$,b%,LEN(a$)
    GOSUB clear_mem(ADD(b%,32),SUB(a%,32))
    LONG{ADD(r_adr_pattern%,SHL(i%,2))}=b%
    ADD b%,a%
  NEXT i%
  curs_col%=0
  curs_x%=0
  bl_trk&=0
  bl_pat&=0
  DPOKE r_master_vol%,DIV(&H3000,ADD(nbr_track%,3))
  DPOKE r_mod_linepos%,0
  DPOKE r_mod_nbrtrack%,nbr_track%
  GOSUB stop_voices
  GOSUB all_track_on(FALSE)
RETURN
PROCEDURE chg_taille_sample(ns%,ls%)
  ' Ne teste pas s'il y a assez de place pour agrandir un sample
  ' N'utilise que les adresses des samples
  ' Ne change absolument rien aux chunks
  LOCAL olda%,newa%,lon%,i%,dif%
  ls%=ls% AND -2
  IF ns%<255
    olda%=FN adrsamchk(SUCC(ns%))
    newa%=ADD(ADD(FN adrsamchk(ns%),64),ls%)
    lon%=SUB(FN adr_buffer,olda%)
    ~C:g_bmove%(L:olda%,L:newa%,L:lon%)
    dif%=SUB(newa%,olda%)
    FOR i%=SUCC(ns%) TO 255
      GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),dif%))
    NEXT i%
    GOSUB clear_mem(ADD(newa%,lon%),-dif%)    ! Vide la fin du buffer de sample si on agrandit son espace
  ENDIF
RETURN
PROCEDURE chg_type_affpiste(n%)
  IF n%=0
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),6),32)    ! Nombre de pistes affichables sans volume ni effet
  ELSE IF n%=2
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),12),32)   ! Nombre de pistes affichables avec volume
  ELSE
    nbr_col%=MIN(DIV(SUB(scr_ncol%,4),10),32)   ! Nombre de pistes affichables sans volume
  ENDIF
  type_affpiste%=n%
RETURN
PROCEDURE chg_tempo(tempo%)
  CARD{r_mod_tempo%}=tempo%
  GOSUB chg_tempo2(tempo%)
RETURN
PROCEDURE chg_tempo2(tempo%)
  ' Change simplement la duree d'un tick, mais pas la valeur du tempo
  LOCAL vblpf%,spf%
  vblpf%=0
  REPEAT
    INC vblpf%
    spf%=ROUND(CARD{r_adr_replay_frequency%}*163840/(tempo%*vblpf%))    ! $10000 * replfreq*60/6/4 / tempo
  UNTIL spf%<78643200                           ! 1200 * $10000
  LONG{r_vblsize%}=spf%
  CARD{r_vblnumber%}=vblpf%
RETURN
PROCEDURE chg_speed(speed%)
  CARD{r_mod_speed%}=speed%
RETURN
PROCEDURE chg_songpos
  IF d%=0
    GOSUB edite_chaine(HEX$(songpos%,2),ADD(divbi&(0,0,16),12),ADD(divbi&(1,0,16),2),2,1)
    songpos%=VAL("$"+bbbb$)
  ELSE
    ADD songpos%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  songpos%=MIN(MAX(songpos%,0),PRED(module&(101)))
  GOSUB affiche_info_song
  GOSUB affiche_c_pattern
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF play%>0
    posligne%=MIN(DPEEK(r_mod_linepos%),PRED(FN nbr_lines2(songpos%)))
    DPOKE r_mod_linepos%,posligne%
    DPOKE r_mod_songpos%,songpos%
    DPOKE r_mod_numpat%,song&(songpos%)
  ENDIF
  IF km%>0 AND km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_pattern
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(song&(songpos%),2),ADD(divbi&(0,3,16),12),ADD(divbi&(1,3,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(song&(songpos%),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  song&(songpos%)=MIN(MAX(a%,0),255)
  GOSUB affiche_info_song
  GOSUB affiche_c_pattern
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF play%>0
    posligne%=MIN(DPEEK(r_mod_linepos%),PRED(FN nbr_lines2(songpos%)))
    DPOKE r_mod_linepos%,posligne%
    DPOKE r_mod_numpat%,song&(songpos%)
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_songlen
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(module&(101),2),ADD(divbi&(0,6,16),12),ADD(divbi&(1,6,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(module&(101),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  module&(101)=MIN(MAX(a%,SUCC(songpos%)),256)
  DPOKE r_mod_songlen%,module&(101)
  module&(102)=MIN(module&(102),PRED(module&(101)))
  DPOKE r_mod_songrep%,module&(102)
  GOSUB affiche_info_song
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_songrep
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(module&(102),2),ADD(divbi&(0,9,16),12),ADD(divbi&(1,9,16),2),2,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(module&(102),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  module&(102)=MIN(MAX(a%,0),PRED(module&(101)))
  DPOKE r_mod_songrep%,module&(102)
  GOSUB affiche_info_song
  IF ss_menu%=2 AND ss_menut%=3
    GOSUB affiche_icones_toolsb3
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_instrument
  IF d%=0
    GOSUB edite_chaine(HEX$(instr%,2),ADD(divbi&(0,12,16),12),ADD(divbi&(1,12,16),2),2,1)
    instr%=VAL("$"+bbbb$)
  ELSE
    ADD instr%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  instr%=MAX(MIN(instr%,255),1)
  GOSUB affiche_info_sample
  IF ss_menu%=1
    GOSUB affiche_icones_diskb
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_sample
  IF d%=0
    GOSUB edite_chaine(HEX$(sample%,2),ADD(divbi&(0,15,16),12),ADD(divbi&(1,15,16),2),2,1)
    sample%=VAL("$"+bbbb$)
  ELSE
    ADD sample%,MUL(d%,MAX(PRED(km%),1))
  ENDIF
  sample%=MAX(MIN(sample%,255),1)
  GOSUB affiche_info_sample
  IF ss_menu%=1
    GOSUB affiche_icones_diskb
  ENDIF
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_linestep
  LOCAL a%
  IF d%=0
    a%=FN popup(3,4,MOUSEX,MOUSEY)
    IF a%>=0
      line_step%=a% AND &HFFFF
    ENDIF
  ELSE
    IF line_step%>-256 AND line_step%<256
      ADD line_step%,MUL(d%,MAX(PRED(km%),1))
    ELSE
      line_step%=1
    ENDIF
  ENDIF
  IF line_step%>-256 AND line_step%<256
    line_step%=MAX(MIN(line_step%,PRED(FN nbr_lines3)),-PRED(FN nbr_lines3),-15)
  ENDIF
  GOSUB affiche_info_song
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_sample
  IF flag_nvl_boucle_sample%<=0
    IF d%=0
      GOSUB edite_chaine(HEX$(sample%,2),ADD(divbi&(0,0,14),11),ADD(divbi&(1,0,14),2),2,1)
      sample%=VAL("$"+bbbb$)
    ELSE
      ADD sample%,MUL(d%,MAX(PRED(km%),1))
    ENDIF
    sample%=MAX(MIN(sample%,255),1)
    GOSUB affiche_icones_sampleb
    GOSUB affiche_info_sample
    IF km%<3 AND d%<>0
      PAUSE SUB(13,MUL(km%,5))
    ENDIF
  ENDIF
RETURN
PROCEDURE chg_s_volume
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN volume(sample%),3),ADD(divbi&(0,13,14),8),ADD(divbi&(1,13,14),2),3,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN volume(sample%),MUL(d%,MAX(PRED(km%),1)))
  ENDIF
  GOSUB chg_sam_volume(sample%,MIN(MAX(a%,0),&HFFF))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_length                  !!!
RETURN
PROCEDURE chg_s_reppos
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN repeat(sample%),6),ADD(divbi&(0,7,14),7),ADD(divbi&(1,7,14),2),6,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN repeat(sample%),SHL(d%,SUB(MUL(km%,4),3)))
  ENDIF
  GOSUB chg_sam_repeat(sample%,MAX(MIN(a% AND -2,SUB(FN length(sample%),FN replen(sample%))),0))
  GOSUB affiche_icones_sampleb
  num_nvl_boucle_sample%=sample%
  flag_nvl_boucle_sample%=4
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_replen
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(HEX$(FN replen(sample%),6),ADD(divbi&(0,10,14),7),ADD(divbi&(1,10,14),2),6,1)
    a%=VAL("$"+bbbb$)
  ELSE
    a%=ADD(FN replen(sample%),SHL(d%,SUB(MUL(km%,4),3)))
  ENDIF
  GOSUB chg_sam_replen(sample%,MAX(MIN(a% AND -2,SUB(FN length(sample%),FN repeat(sample%))),2))
  GOSUB affiche_icones_sampleb
  flag_nvl_boucle_sample%=4
  num_nvl_boucle_sample%=sample%
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_finetune
  LOCAL a%,b%
  IF d%=0
  ELSE
    a%=ADD(FN finetune(sample%),d%)
  ENDIF
  GOSUB chg_sam_finetune(sample%,MIN(MAX(a%,-8),7))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_balance
  LOCAL a%,a$
  a%=FN autobal(sample%)
  IF d%=0
    IF a%<=&HFFF
      a$=HEX$(FN autobal(sample%),3)
    ELSE
      a$="???"
    ENDIF
    GOSUB edite_chaine(a$,ADD(divbi&(0,19,14),8),ADD(divbi&(1,19,14),2),3,0)
    IF INSTR(bbbb$,"?")>0
      a%=-1
    ELSE
      a%=VAL("$"+bbbb$)
    ENDIF
  ELSE
    IF a%>&HFFF
      a%=-1
    ENDIF
    a%=ADD(a%,SHL(d%,SUB(MUL(km%,4),3))) AND -2
  ENDIF
  GOSUB chg_sam_balance(sample%,MAX(MIN(a%,&HFFF),-1) AND &HFFFF)
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE SUB(13,MUL(km%,5))
  ENDIF
RETURN
PROCEDURE chg_s_freqech
  LOCAL a%
  IF d%=0
    GOSUB edite_chaine(STR$(FN freqech(sample%),5),ADD(divbi&(0,22,14),10),ADD(divbi&(1,22,14),2),5,2)
    a%=VAL(bbbb$)
  ELSE
    a%=ADD(FN freqech(sample%),MUL(d%,20^PRED(km%)))
  ENDIF
  GOSUB chg_sam_freq(sample%,MAX(MIN(a%,65000),2000))
  GOSUB affiche_icones_sampleb
  IF km%<3 AND d%<>0
    PAUSE 3
  ENDIF
RETURN
PROCEDURE chg_songname(nnnn$)
  LOCAL iiii%
  FOR iiii%=2 TO 17
    module&(iiii%)=&H2020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),32))
    BYTE{ADD(V:module&(2),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_songname2(aaaa%,llll%)
  LOCAL iiii%
  FOR iiii%=0 TO 31
    IF iiii%<llll%
      BYTE{ADD(V:module&(2),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(V:module&(2),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_songcomment(nnnn$)
  LOCAL iiii%
  FOR iiii%=18 TO 97
    module&(iiii%)=&H2020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),160))
    BYTE{ADD(V:module&(18),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_songcomment2(aaaa%,llll%)
  LOCAL iiii%
  FOR iiii%=0 TO 159
    IF iiii%<llll%
      BYTE{ADD(V:module&(18),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(V:module&(18),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
PROCEDURE chg_preset(p%)
  GOSUB cadre_texte(STR$(SUCC(n_preset%)),ADD(8,SHL(n_preset%,1)),130,1)
  n_preset%=p%
  GOSUB affiche_info_preset
RETURN
' Piste
PROCEDURE chg_track_onoff(t%,state%)
  ' Ne change pas l'affichage
  ' state% = 0 ou 1
  DPOKE ADD(ADD(r_info_track%,r_onoff_t%),MUL(r_itl%,t%)),state%
RETURN
PROCEDURE chg_a_track_onoff(t%,state%)
  ' Change l'affichage
  ' state% = 0 ou 1
  GOSUB chg_track_onoff(t%,state%)
  GOSUB cadre_texte2(STR$(SUCC(t%)),ADD(8,SHL(t%,1)),120,1,FN track_onoff(t%) XOR 1)
  GOSUB affiche_info_preset
RETURN
PROCEDURE all_track_on(flag!)
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_track_onoff(i%,1)
    IF flag!
      GOSUB cadre_texte2(STR$(SUCC(i%)),ADD(8,SHL(i%,1)),120,1,FN track_onoff(i%) XOR 1)
    ENDIF
  NEXT i%
RETURN
PROCEDURE balance_reset
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_balance(i%,MUL(SHR(SUCC(i%),1) AND 1,&HFFF))
  NEXT i%
RETURN
PROCEDURE set_balance(a$)
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_balance(i%,CARD{ADD(V:a$,SHL(i%,1))})
  NEXT i%
RETURN
PROCEDURE chg_t_balance(t%,b%)
  CARD{ADD(ADD(r_info_track%,r_bal_t%),MUL(r_itl%,t%))}=b%
RETURN
PROCEDURE track_volume_reset
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_mix_volume(i%,&H1000)
  NEXT i%
RETURN
PROCEDURE chg_t_mix_volume(t%,b%)
  CARD{ADD(ADD(r_info_track%,r_mix_volume_t%),MUL(r_itl%,t%))}=b%
  CARD{ADD(ADD(r_info_track%,r_mix_volume_e_t%),MUL(r_itl%,t%))}=FN vol_lin_2_exp(b%)
RETURN
PROCEDURE chg_t_mix_volume_e(t%,b%)
  CARD{ADD(ADD(r_info_track%,r_mix_volume_t%),MUL(r_itl%,t%))}=FN vol_exp_2_lin(b%)
  CARD{ADD(ADD(r_info_track%,r_mix_volume_e_t%),MUL(r_itl%,t%))}=b%
RETURN
PROCEDURE set_track_volume(a$)
  LOCAL i%
  FOR i%=0 TO 31
    GOSUB chg_t_mix_volume(i%,CARD{ADD(V:a$,SHL(i%,1))})
  NEXT i%
RETURN
' Pattern
PROCEDURE chg_pat_chunkadr(pppp%,aaaa%)
  LONG{ADD(r_adr_pattern%,SHL(pppp%,2))}=aaaa%
RETURN
PROCEDURE chg_pat_chunklen(pppp%,aaaa%)
  LONG{ADD(FN adr_patchunk(pppp%),4)}=aaaa%
RETURN
PROCEDURE chg_pat_nbr_track(pppp%,aaaa%)
  CARD{ADD(FN adr_patchunk(pppp%),30)}=aaaa%
RETURN
PROCEDURE chg_pat_nbr_lines(pppp%,aaaa%)
  CARD{ADD(FN adr_patchunk(pppp%),28)}=aaaa%
RETURN
PROCEDURE chg_patternname(nnnn$,pppp%)
  IF LEN(nnnn$)<16
    nnnn$=nnnn$+SPACE$(SUB(16,LEN(nnnn$)))
  ENDIF
  nnnn$=LEFT$(nnnn$,16)
  BMOVE V:nnnn$,ADD(FN adr_patchunk(pppp%),10),16
RETURN
PROCEDURE chg_patternname2(aaaa%,llll%,pppp%)
  LOCAL iiii%
  FOR iiii%=0 TO 15
    IF iiii%<llll%
      BYTE{ADD(ADD(FN adr_patchunk(pppp%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(FN adr_patchunk(pppp%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
' Sample
PROCEDURE chg_sam_chunkadr(ssss%,ffff%)
  LONG{ADD(r_adr_sample%,SHL(ssss%,2))}=ffff%
RETURN
PROCEDURE chg_sam_freq(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),44)}=ffff%
RETURN
PROCEDURE chg_sam_balance(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),40)}=ffff%
RETURN
PROCEDURE chg_sam_volume(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),58)}=ffff%
RETURN
PROCEDURE chg_sam_nbits(ssss%,ffff%)
  CARD{ADD(FN adrsamchk(ssss%),42)}=SHL(ffff%,3)
RETURN
PROCEDURE chg_sam_length(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),46)}=ffff%
  LONG{ADD(FN adrsamchk(ssss%),4)}=ADD(ffff%,64)
RETURN
PROCEDURE chg_sam_repeat(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),50)}=ffff%
RETURN
PROCEDURE chg_sam_replen(ssss%,ffff%)
  LONG{ADD(FN adrsamchk(ssss%),54)}=MAX(ffff%,2)
RETURN
PROCEDURE chg_sam_finetune(ssss%,ffff%)
  INT{ADD(FN adrsamchk(ssss%),60)}=ffff%
RETURN
PROCEDURE chg_samplename(nnnn$,ssss%)
  LOCAL iiii%
  FOR iiii%=10 TO 34 STEP 4
    LONG{ADD(FN adrsamchk(ssss%),iiii%)}=&H20202020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),28))
    BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_samplename2(aaaa%,llll%,ssss%)
  LOCAL iiii%
  FOR iiii%=0 TO 27
    IF iiii%<llll%
      BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(FN adrsamchk(ssss%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
' Instrument
PROCEDURE chg_ins_balance(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),42)}=ffff%
RETURN
PROCEDURE chg_ins_volume(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),40)}=ffff%
RETURN
PROCEDURE chg_ins_evol(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),44)}=ffff%
RETURN
PROCEDURE chg_ins_eton(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),46)}=ffff%
RETURN
PROCEDURE chg_ins_epan(ssss%,ffff%)
  CARD{ADD(V:instrset%(0,ssss%),48)}=ffff%
RETURN
PROCEDURE chg_ins_transp(ssss%,ffff%,gggg%)
  BYTE{ADD(V:instrset%(15,ssss%),SUCC(SHL(ffff%,1)))}=gggg%
RETURN
PROCEDURE chg_ins_sample(ssss%,ffff%,gggg%)
  BYTE{ADD(V:instrset%(15,ssss%),SHL(ffff%,1))}=gggg%
RETURN
PROCEDURE chg_instrname(nnnn$,ssss%)
  LOCAL iiii%
  FOR iiii%=10 TO 34 STEP 4
    LONG{ADD(V:instrset%(0,ssss%),iiii%)}=&H20202020
  NEXT iiii%
  FOR iiii%=0 TO PRED(MIN(LEN(nnnn$),28))
    BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=MAX(BYTE{ADD(V:nnnn$,iiii%)},32)
  NEXT iiii%
RETURN
PROCEDURE chg_instrname2(aaaa%,llll%,ssss%)
  LOCAL iiii%
  FOR iiii%=0 TO 27
    IF iiii%<llll%
      BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=MAX(BYTE{ADD(aaaa%,iiii%)},32)
    ELSE
      BYTE{ADD(ADD(V:instrset%(0,ssss%),10),iiii%)}=32
    ENDIF
  NEXT iiii%
RETURN
' Envelopes
PROCEDURE chg_env_chunkadr(num%,type%,adr%)
  SELECT type%
  CASE 0
    LONG{ADD(r_adr_evol%,SHL(num%,2))}=adr%
  CASE 1
    LONG{ADD(r_adr_eton%,SHL(num%,2))}=adr%
  CASE 2
    LONG{ADD(r_adr_epan%,SHL(num%,2))}=adr%
  ENDSELECT
RETURN
PROCEDURE chg_env_length(num%,type%,sect%,lon%)
  ' Change la longueur d'une section d'enveloppe
  ' Les commandes sont effacees
  LOCAL a%
  a%=SUB(lon%,FN env_sectlen(num%,type%,sect%))
  GOSUB chg_env_rellength(num%,type%,sect%,0,a%)
  a%=FN env_sectadr(num%,type%,sect%)
  FOR a%=a% TO PRED(ADD(a%,FN env_sectlen(num%,type%,sect%)))
    BYTE{a%}=0
  NEXT a%
RETURN
PROCEDURE chg_env_rellength(num%,type%,sect%,pos%,rlon%)
  ' Insere un certain nombre d'octets dans une enveloppe
  ' Marche aussi pour la reduction de la taille de l'enveloppe (lon% negatif)
  ' Pos% est en numero de commande et non en octets
  ' Le chunk est mis a jour
  LOCAL d%,i%,j%,l%,s%
  ' Calcul des adresses source et destination, et de la longueur du bloc a deplacer
  IF rlon%>=0                                   ! Deplacement positif
    s%=ADD(FN env_sectadr(num%,type%,sect%),FN pos_enveloppe(num%,type%,sect%,pos%))
    d%=ADD(s%,rlon%)
  ELSE                                          ! Deplacement negatif
    d%=ADD(FN env_sectadr(num%,type%,sect%),FN pos_enveloppe(num%,type%,sect%,pos%))
    s%=SUB(d%,rlon%)
  ENDIF
  l%=SUB(FN adr_buffer,s%)
  ' Deplacement des adresses des chunks d'enveloppes suivants
  IF num%<63 OR type%<2
    FOR i%=SUCC(ADD(MUL(num%,3),type%)) TO 191
      GOSUB chg_env_chunkadr(DIV(i%,3),i% MOD 3,ADD(FN env_chunkadr(DIV(i%,3),i% MOD 3),rlon%))
    NEXT i%
  ENDIF
  ' Deplacement des adresses des chunks de samples suivants
  FOR i%=0 TO 255
    GOSUB chg_sam_chunkadr(i%,ADD(FN adrsamchk(i%),rlon%))
  NEXT i%
  ' Deplacement du bloc en memoire
  ~C:g_bmove%(L:s%,L:d%,L:l%)
  LONG{ADD(FN env_chunkadr(num%,type%),4)}=ADD(FN env_chunklen(num%,type%),rlon%)
  IF sect%=0
    CARD{ADD(FN env_chunkadr(num%,type%),30)}=ADD(CARD{ADD(FN env_chunkadr(num%,type%),30)},rlon%)
  ENDIF
RETURN
PROCEDURE chg_env_adrjump(num%,type%,sect%,pos%,lon%)
  ' Change les adresses de saut apres une insertion ou destruction de commande
  ' Pos% en octets
  LOCAL a%,b%,c%,i%,l%
  a%=FN env_sectadr(num%,type%,sect%)
  l%=FN env_sectlen(num%,type%,sect%)
  WHILE i%<l%
    c%=BYTE{ADD(a%,i%)}
    IF c%=&H1 OR c%=&H4
      b%=CARD{SUCC(ADD(a%,i%))}
      IF b%>pos%
        CARD{SUCC(ADD(a%,i%))}=ADD(b%,lon%)
      ENDIF
    ENDIF
    ADD i%,FN env_comlen(c%)
  WEND
RETURN
PROCEDURE chg_envelopename(nnnn$,eeee%,tttt%)
  LOCAL a%,b%,i%
  a%=FN env_chunkadr(eeee%,tttt%)
  FOR i%=ADD(a%,10) TO ADD(a%,26) STEP 4
    LONG{i%}=&H20202020
  NEXT i%
  IF nnnn$<>""
    b%=V:nnnn$
    FOR i%=ADD(a%,10) TO ADD(a%,ADD(MIN(LEN(nnnn$),20),9))
      BYTE{i%}=MAX(BYTE{b%},32)
      INC b%
    NEXT i%
  ENDIF
RETURN
PROCEDURE chg_envelopename2(aaaa%,llll%,eeee%,tttt%)
  LOCAL a%,b%,i%
  a%=FN env_chunkadr(eeee%,tttt%)
  FOR i%=ADD(a%,10) TO ADD(a%,26) STEP 4
    LONG{i%}=&H20202020
  NEXT i%
  IF llll%>0
    FOR i%=ADD(a%,10) TO ADD(a%,ADD(MIN(LEN(nnnn$),20),9))
      BYTE{i%}=MAX(BYTE{aaaa%},32)
      INC aaaa%
    NEXT i%
  ENDIF
RETURN
' Midi
PROCEDURE chg_midi_monomode_channel_nbr(num%)
  midi_monomode_channel_nbr%=num%
RETURN
PROCEDURE chg_midi_monomode_instr_nbr(num%)
  midi_monomode_instr_nbr%=num%
RETURN
PROCEDURE chg_midi_in_instr(can%,ins%)
  ' can%: 0-15
  LOCAL i%
  midi_in_instr%(can%)=ins%
  FOR i%=0 TO 15
    CARD{ADD(r_midi_instr_map%,SHL(i%,1))}=midi_in_instr%(i%)
  NEXT i%
RETURN
PROCEDURE chg_midi_polymode_channel(trk%,can%)
  ' can%: 0, 1-16
  midi_in_channel%(trk%)=can%
  IF midi_polyphonic_mode!
    GOSUB reset_midi_track_state(trk%)
  ENDIF
RETURN
PROCEDURE chg_midi_flag_data_in(val!)
  midi_flag_data_in!=val!
  CARD{r_midi_in_on%}=val!
RETURN
PROCEDURE chg_midi_flag_note_off(can%,val%)
  ' can%: 1-16
  CARD{ADD(r_midi_in_noteoff_flag%,SHL(PRED(can%),1))}=val%
RETURN
PROCEDURE chg_midi_flag_velocity(can%,val!)
  ' can%: 1-16
  CARD{ADD(r_midi_in_velo_flag%,SHL(PRED(can%),1))}=val!
RETURN
PROCEDURE reset_all_midi_track_state
  ' Reinitialise toutes les pistes MIDI en mode Polyphonique
  LOCAL trk%,can%
  FOR trk%=0 TO 31
    GOSUB reset_midi_track_state(trk%)
  NEXT trk%
  FOR can%=0 TO 15
    GOSUB chg_midi_in_instr(can%,midi_in_instr%(can%))
  NEXT can%
RETURN
PROCEDURE reset_midi_track_state(trk%)
  ' Reinitialise une piste MIDI en mode Polyphonique
  LOCAL adr%
  adr%=ADD(r_midi_track_state%,MUL(trk%,r_midi_ts_next%))
  IF trk%<nbr_track%
    CARD{adr%}=midi_in_channel%(trk%)
  ELSE
    CARD{adr%}=0
  ENDIF
  CARD{ADD(adr%,2)}=0
  CARD{ADD(adr%,4)}=0
  CARD{ADD(adr%,6)}=0
  CARD{ADD(adr%,8)}=0
  LONG{ADD(adr%,10)}=0
  BYTE{ADD(adr%,14)}=0
RETURN
PROCEDURE chg_midi_flag_data_out(val!)
  midi_flag_data_out!=val!
  CARD{r_midi_out_on%}=val!
RETURN
'
' Fonctions de bloc
' -----------------
PROCEDURE insert_line_track(pat%,lig%,trk%,fil$)
  LOCAL i%,k%
  IF lig%<PRED(FN nbr_lines(pat%))
    k%=MUL(nbr_track%,5)
    FOR i%=FN adr_trk(pat%,PRED(FN nbr_lines(pat%)),trk%) TO FN adr_trk(pat%,SUCC(lig%),trk%) STEP -k%
      BMOVE SUB(i%,k%),i%,5
    NEXT i%
  ENDIF
  BMOVE V:fil$,FN adr_trk(pat%,lig%,trk%),5
RETURN
PROCEDURE insert_line_pattern(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_track%)
    GOSUB insert_line_track(pat%,lig%,j%,STRING$(5,0))
  NEXT j%
RETURN
PROCEDURE insert_line_preset(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_colonnes%(n_preset%))
    GOSUB insert_line_track(pat%,lig%,preset&(j%,n_preset%),STRING$(5,0))
  NEXT j%
RETURN
PROCEDURE insert_r_line_track(pat%,lig%,trk%)
  LOCAL a$
  a$=STRING$(5,0)
  BMOVE FN adr_trk(pat%,PRED(FN nbr_lines(pat%)),trk%),V:a$,5
  GOSUB insert_line_track(pat%,lig%,trk%,a$)
RETURN
PROCEDURE insert_r_line_pattern(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_track%)
    GOSUB insert_r_line_track(pat%,lig%,j%)
  NEXT j%
RETURN
PROCEDURE insert_r_line_preset(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_colonnes%(n_preset%))
    GOSUB insert_r_line_track(pat%,lig%,preset&(j%,n_preset%))
  NEXT j%
RETURN
PROCEDURE delete_line_track(pat%,lig%,trk%,fil$)
  LOCAL i%,k%
  IF lig%<PRED(FN nbr_lines(pat%))
    k%=MUL(nbr_track%,5)
    FOR i%=FN adr_trk(pat%,SUCC(lig%),trk%) TO FN adr_trk(pat%,PRED(FN nbr_lines(pat%)),trk%) STEP k%
      BMOVE i%,SUB(i%,k%),5
    NEXT i%
  ENDIF
  BMOVE V:fil$,FN adr_trk(pat%,PRED(FN nbr_lines(pat%)),trk%),5
RETURN
PROCEDURE delete_line_pattern(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_track%)
    GOSUB delete_line_track(pat%,lig%,j%,STRING$(5,0))
  NEXT j%
RETURN
PROCEDURE delete_line_preset(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_colonnes%(n_preset%))
    GOSUB delete_line_track(pat%,lig%,preset&(j%,n_preset%),STRING$(5,0))
  NEXT j%
RETURN
PROCEDURE delete_r_line_track(pat%,lig%,trk%)
  LOCAL a$
  a$=STRING$(5,0)
  BMOVE FN adr_trk(pat%,lig%,trk%),V:a$,5
  GOSUB delete_line_track(pat%,lig%,trk%,a$)
RETURN
PROCEDURE delete_r_line_pattern(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_track%)
    GOSUB delete_r_line_track(pat%,lig%,j%)
  NEXT j%
RETURN
PROCEDURE delete_r_line_preset(pat%,lig%)
  LOCAL j%
  FOR j%=0 TO PRED(nbr_colonnes%(n_preset%))
    GOSUB delete_r_line_track(pat%,lig%,preset&(j%,n_preset%))
  NEXT j%
RETURN
PROCEDURE block_start
  bl_pat&=song&(songpos%)
  bl_start&=posligne%
  bl_end&=MIN(MAX(bl_end&,posligne%),FN nbr_lines(bl_pat&))
  bl_trk&=preset&(curs_col%,n_preset%)
  REPEAT
  UNTIL MOUSEK=0
  GOSUB affiche_barre_info
RETURN
PROCEDURE block_end
  bl_pat&=song&(songpos%)
  bl_end&=posligne%
  bl_start&=MIN(bl_start&,posligne%)
  bl_trk&=preset&(curs_col%,n_preset%)
  REPEAT
  UNTIL MOUSEK=0
  GOSUB affiche_barre_info
RETURN
PROCEDURE paste_block
  LOCAL i&,l&,s%,d%,a%,i%,j%,k%,inf$
  i&=MUL(nbr_track%,5)
  l&=MIN(SUCC(SUB(bl_end&,bl_start&)),SUB(FN nbr_lines3,posligne%))
  IF trackpat%=0
    s%=FN adr_trk(bl_pat&,bl_start&,bl_trk&)
    d%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
    SUB d%,s%
    IF d%>0
      ADD s%,MUL(PRED(l&),i&)
      i&=-i&
    ENDIF
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(0)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_paste_note_block%(L:a%)
  ELSE IF trackpat%=1
    s%=FN adr_line(bl_pat&,bl_start&)
    d%=FN adr_sline(songpos%,posligne%)
    SUB d%,s%
    e%=ADD(s%,MUL(PRED(l&),i&))
    IF d%>0
      SWAP s%,e%
      i&=-i&
    ENDIF
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(1)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_paste_note_block%(L:a%)
  ELSE
    s%=FN adr_line(bl_pat&,bl_start&)
    d%=FN adr_sline(songpos%,posligne%)
    SUB d%,s%
    IF d%>0
      ADD s%,MUL(PRED(l&),i&)
      i&=-i&
    ENDIF
    a%=MIN(nbr_col%,nbr_colonnes%(n_preset%))
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(a%)+MKI$(2)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_paste_note_block%(L:a%)
  ENDIF
RETURN
PROCEDURE insert_block
  LOCAL bls2&,ble2&,blp2&,blt2&,pl2%
  IF NOT (posligne%<=bl_end& AND bl_pat&=song&(songpos%) AND ((bl_trk&=preset&(curs_col%,n_preset%) AND trackpat%=0) OR trackpat%>0))
    IF ADD(SUB(bl_end&,bl_start&),posligne%)<PRED(FN nbr_lines3)
      bls2&=posligne%
      ble2&=ADD(posligne%,SUB(bl_end&,bl_start&))
      blp2&=song&(songpos%)
      blt2&=bl_trk&
      pl2%=SUCC(ble2&)
      SWAP bl_start&,bls2&
      SWAP bl_end&,ble2&
      SWAP bl_pat&,blp2&
      SWAP posligne%,pl2%
      bl_trk&=preset&(curs_col%,n_preset%)
      GOSUB paste_block           ! Decale le morceau de pattern si necessaire
      SWAP bl_start&,bls2&
      SWAP bl_end&,ble2&
      SWAP bl_pat&,blp2&
      SWAP posligne%,pl2%
      bl_trk&=blt2&
    ENDIF
    GOSUB paste_block
  ENDIF
RETURN
PROCEDURE clear_block
  LOCAL i&,l&,s%,a%,i%,j%,k%
  i&=MUL(nbr_track%,5)
  l&=MIN(SUCC(SUB(bl_end&,bl_start&)),SUB(FN nbr_lines(bl_pat&),posligne%))
  IF trackpat%=0
    s%=FN adr_trk(bl_pat&,bl_start&,bl_trk&)
    inf$=MKL$(s%)+MKL$(0)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(0)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_clear_note_block%(L:a%)
  ELSE IF trackpat%=1
    s%=FN adr_line(bl_pat&,bl_start&)
    inf$=MKL$(s%)+MKL$(0)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(1)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_clear_note_block%(L:a%)
  ELSE
    s%=FN adr_line(bl_pat&,bl_start&)
    a%=MIN(nbr_col%,nbr_colonnes%(n_preset%))
    inf$=MKL$(s%)+MKL$(0)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(a%)+MKI$(2)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_clear_note_block%(L:a%)
  ENDIF
RETURN
PROCEDURE delete_block
  LOCAL bls2&,ble2&,pl2%
  bls2&=SUCC(bl_end&)
  ble2&=PRED(FN nbr_lines3)
  SWAP bl_start&,bls2&
  SWAP bl_end&,ble2&
  IF ble2&<PRED(FN nbr_lines3)
    pl2%=bls2&
    SWAP posligne%,pl2%
    GOSUB paste_block           ! Decale le morceau de pattern si necessaire
    SWAP posligne%,pl2%
  ENDIF
  bl_start&=SUB(FN nbr_lines3,SUCC(SUB(ble2&,bls2&)))
  GOSUB clear_block
  SWAP bl_start&,bls2&
  SWAP bl_end&,ble2&
RETURN
PROCEDURE note_up_general
  LOCAL i%,p%,oldp%
  IF bl_flagsong!               ! Scanne tous les patterns utilises par la song
    oldp%=bl_pat&
    FOR p%=0 TO FN last_pat_util
      i%=0
      REPEAT
        IF song&(i%)=p%
          bl_pat&=p%
          GOSUB note_up_block
          i%=FN song_length
        ELSE
          INC i%
        ENDIF
      UNTIL i%=>FN song_length
    NEXT p%
    bl_pat&=oldp%
  ELSE                          ! Simplement sur le bloc
    GOSUB note_up_block
  ENDIF
RETURN
PROCEDURE note_up_block
  LOCAL i&,l&,s%,a%,i%,j%,k%
  i&=MUL(nbr_track%,5)
  l&=MIN(SUCC(SUB(bl_end&,bl_start&)),FN nbr_lines(bl_pat&))
  IF trackpat%=0
    s%=FN adr_trk(bl_pat&,bl_start&,bl_trk&)
    inf$=MKL$(s%)+MKL$(1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(0)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ELSE IF trackpat%=1
    s%=FN adr_line(bl_pat&,bl_start&)
    inf$=MKL$(s%)+MKL$(1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(1)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ELSE
    s%=FN adr_line(bl_pat&,bl_start&)
    a%=MIN(nbr_col%,nbr_colonnes%(n_preset%))
    inf$=MKL$(s%)+MKL$(1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(a%)+MKI$(2)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ENDIF
RETURN
PROCEDURE note_down_general
  LOCAL i%,p%,oldp%
  IF bl_flagsong!               ! Scanne tous les patterns utilises par la song
    oldp%=bl_pat&
    FOR p%=0 TO FN last_pat_util
      i%=0
      REPEAT
        IF song&(i%)=p%
          bl_pat&=p%
          GOSUB note_down_block
          i%=FN song_length
        ELSE
          INC i%
        ENDIF
      UNTIL i%=>FN song_length
    NEXT p%
    bl_pat&=oldp%
  ELSE                          ! Simplement sur le bloc
    GOSUB note_down_block
  ENDIF
RETURN
PROCEDURE note_down_block
  LOCAL i&,l&,s%,a%,i%,j%,k%
  i&=MUL(nbr_track%,5)
  l&=MIN(SUCC(SUB(bl_end&,bl_start&)),FN nbr_lines(bl_pat&))
  IF trackpat%=0
    s%=FN adr_trk(bl_pat&,bl_start&,bl_trk&)
    inf$=MKL$(s%)+MKL$(-1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(0)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ELSE IF trackpat%=1
    s%=FN adr_line(bl_pat&,bl_start&)
    inf$=MKL$(s%)+MKL$(-1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(1)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ELSE
    s%=FN adr_line(bl_pat&,bl_start&)
    a%=MIN(nbr_col%,nbr_colonnes%(n_preset%))
    inf$=MKL$(s%)+MKL$(-1)+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(a%)+MKI$(2)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_transpose_note_block%(L:a%)
  ENDIF
RETURN
PROCEDURE swap_block
  LOCAL i&,l&,s%,d%,a%,i%,j%,k%
  i&=MUL(nbr_track%,5)
  l&=MIN(SUCC(SUB(bl_end&,bl_start&)),SUB(FN nbr_lines3,posligne%))
  IF trackpat%=0
    s%=FN adr_trk(bl_pat&,bl_start&,bl_trk&)
    d%=FN adr_strk(songpos%,posligne%,preset&(curs_col%,n_preset%))
    SUB d%,s%
    IF d%>0
      ADD s%,MUL(PRED(l&),i&)
      i&=-i&
    ENDIF
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(0)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_swap_note_block%(L:a%)
  ELSE IF trackpat%=1
    s%=FN adr_line(bl_pat&,bl_start&)
    d%=FN adr_sline(songpos%,posligne%)
    SUB d%,s%
    e%=ADD(s%,MUL(PRED(l&),i&))
    IF d%>0
      SWAP s%,e%
      i&=-i&
    ENDIF
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(nbr_colonnes%(n_preset%))+MKI$(1)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_swap_note_block%(L:a%)
  ELSE
    s%=FN adr_line(bl_pat&,bl_start&)
    d%=FN adr_sline(songpos%,posligne%)
    SUB d%,s%
    IF d%>0
      ADD s%,MUL(PRED(l&),i&)
      i&=-i&
    ENDIF
    a%=MIN(nbr_col%,nbr_colonnes%(n_preset%))
    inf$=MKL$(s%)+MKL$(ADD(s%,d%))+MKL$(i&)+MKI$(l&)+MKL$(V:bl_maska1$)+MKL$(V:bl_maska2$)+MKL$(V:bl_maskb1$)+MKL$(V:bl_maskb2$)+MKI$(maskblock%)+MKI$(replaceblock%)+MKI$(nbr_track%)+MKI$(a%)+MKI$(2)+MKL$(V:preset&(0,n_preset%))
    a%=V:inf$
    ~C:g_swap_note_block%(L:a%)
  ENDIF
RETURN
PROCEDURE echo_block                    !!!
  ' Ne fait pour l'instant que sur une piste
  LOCAL a%,b%,i%,pt%
  LOCAL buf$
  buf$=STRING$(MUL(bl_echo_lines%,5),0)
  pt%=0
  FOR i%=bl_start& TO bl_end&
    a%=FN adr_trk(bl_pat&,i%,bl_trk&)
    ' Sortie du buffer
    IF BYTE{a%}=0 AND BYTE{ADD(V:buf$,pt%)}<>0
      LONG{a%}=LONG{ADD(V:buf$,pt%)}
      BYTE{ADD(a%,4)}=BYTE{ADD(ADD(V:buf$,pt%),4)}
    ENDIF
    ' Entree dans le buffer
    IF BYTE{a%}<>0
      IF NOT bl_echo_cont!
        buf$=STRING$(MUL(bl_echo_lines%,5),0)
      ENDIF
      b%=LONG{a%}
      LONG{ADD(V:buf$,pt%)}=b%
      IF (b% AND &HF000)=&H2000
        b%=MIN(b% AND &H1FF,&H100)
        CARD{ADD(ADD(V:buf$,pt%),2)}=0
      ELSE
        b%=BYTE{ADD(a%,4)}
        IF b%=0
          IF BYTE{ADD(a%,2)}=0
            b%=&H100
          ELSE
            b%=FN volume(BYTE{SUCC(a%)})
          ENDIF
        ENDIF
      ENDIF
      IF bl_echo_fdbk!                  ! Avec feedback
        b%=DIV(MUL(b%,bl_echo_feedback%),100)
      ELSE                              ! Avec fade
        b%=MAX(SUB(b%,bl_echo_fadestep%),0)
      ENDIF
      BYTE{ADD(ADD(V:buf$,pt%),4)}=b%
      IF b%=0
        LONG{ADD(V:buf$,pt%)}=0
      ENDIF
    ENDIF
    pt%=ADD(pt%,5) MOD MUL(bl_echo_lines%,5)
  NEXT i%
RETURN
PROCEDURE volume_slide(pat%,lig%,trk%)
  LOCAL a%,b%,c%,d%,i%,v1%,v2%
  b%=-1
  c%=-1
  ' Recherche du premier effet de volume a partir du curseur en montant
  a%=lig%
  REPEAT
    d%=FN adr_trk(pat%,a%,trk%)
    IF BYTE{ADD(d%,4)}<>0 OR (BYTE{ADD(d%,2)} AND &HF0)=&H20 OR (BYTE{ADD(d%,2)} AND &HF0)=&H30
      b%=a%
    ENDIF
    DEC a%
  UNTIL a%<0 OR b%>=0
  ' Recherche du premier effet de volume a partir du curseur en descendant
  a%=lig%
  REPEAT
    d%=FN adr_trk(pat%,a%,trk%)
    IF BYTE{ADD(d%,4)}<>0 OR (BYTE{ADD(d%,2)} AND &HF0)=&H20 OR (BYTE{ADD(d%,2)} AND &HF0)=&H30
      c%=a%
    ENDIF
    INC a%
  UNTIL a%>=FN nbr_lines(pat%) OR c%>=0
  IF b%>=0 AND c%>=0 AND SUB(c%,b%)>1
    ' Volume de depart
    a%=FN adr_trk(pat%,b%,trk%)
    v1%=BYTE{ADD(a%,4)}
    IF (BYTE{ADD(a%,2)} AND &HF0)=&H20
      v1%=MIN(CARD{ADD(a%,2)} AND &HFFF,&H100)
    ELSE IF (BYTE{ADD(a%,2)} AND &HF0)=&H30
      v1%=2^(MIN(CARD{ADD(a%,2)} AND &HFFF,&H800)/256)
    ENDIF
    ' Volume d'arrivee
    a%=FN adr_trk(pat%,c%,trk%)
    v2%=BYTE{ADD(a%,4)}
    IF (BYTE{ADD(a%,2)} AND &HF0)=&H20
      v2%=MIN(CARD{ADD(a%,2)} AND &HFFF,&H100)
    ELSE IF (BYTE{ADD(a%,2)} AND &HF0)=&H30
      v2%=2^(MIN(CARD{ADD(a%,2)} AND &HFFF,&H800)/256)
    ENDIF
    ' Volume fade
    FOR i%=SUCC(b%) TO PRED(c%)
      a%=FN adr_trk(pat%,i%,trk%)
      d%=ADD(v1%,DIV(MUL(SUB(v2%,v1%),SUB(i%,b%)),SUB(c%,b%)))
      BYTE{ADD(a%,4)}=MIN(255,MAX(1,d%))
    NEXT i%
  ENDIF
RETURN
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                      Procedures pour le Drum Editor                      *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' General
' -------
PROCEDURE drum_editor           !!!
  LOCAL de.nbr_lines%
  de.nbr_lines%=MIN(DIV(SUB(scr_haut%,ADD(divbi&(1,34,30),5)),SUCC(divbi&(3,34,30))),nbr_track%)
  GOSUB affiche_panneau_drum
  ~GEMDOS(7)
RETURN
PROCEDURE affiche_panneau_drum  !!!
  LOCAL i%,j%
  DEFMOUSE 0
  HIDEM
  GOSUB cadre_int(0,0,PRED(scr_ncol%),39,9,9,10,8)
  GOSUB cadre_int(0,40,PRED(scr_ncol%),SUB(PRED(scr_haut%),40),9,9,10,8)
  GOSUB affiche_bloc_icones(0,23,30,0,0)
  GOSUB cadre_ext(ADD(divbi&(0,4,30),8),ADD(divbi&(1,4,30),2),2,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,7,30),9),ADD(divbi&(1,7,30),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,10,30),8),ADD(divbi&(1,10,30),2),2,5,0,13,12,14)
  GOSUB cadre_ext(ADD(divbi&(0,13,30),8),ADD(divbi&(1,13,30),2),2,5,0,13,12,14)
  IF de.display_type%=0
    FOR i%=0 TO PRED(de.nbr_lines%)
      GOSUB affiche_icone(34,30,0,MUL(i%,10),FALSE)
      GOSUB affiche_icone(35,30,0,MUL(i%,10),FALSE)
      GOSUB cadre_ext(ADD(divbi&(0,34,30),1),ADD(divbi&(1,34,30),ADD(MUL(i%,10),2)),SUB(divbi&(2,34,30),2),5,0,13,12,14)
    NEXT i%
    GOSUB cadre_ext(15,62,SUB(scr_ncol%,17),5,0,13,12,14)
    GOSUB cadre_ext(15,70,SUB(scr_ncol%,17),PRED(MUL(de.nbr_lines%,10)),0,13,12,14)
  ELSE
    FOR i%=0 TO PRED(de.nbr_lines%)
      FOR j%=23 TO 33
        GOSUB affiche_icone(j%,30,0,MUL(i%,10),FALSE)
      NEXT j%
      GOSUB cadre_ext(ADD(divbi&(0,23,30),1),ADD(divbi&(1,23,30),ADD(MUL(i%,10),2)),SUB(divbi&(2,23,30),2),5,0,13,12,14)
      GOSUB cadre_ext(ADD(divbi&(0,24,30),4),ADD(divbi&(1,24,30),ADD(MUL(i%,10),2)),11,5,0,13,12,14)
      GOSUB cadre_ext(ADD(divbi&(0,24,30),17),ADD(divbi&(1,24,30),ADD(MUL(i%,10),2)),2,5,0,13,12,14)
      GOSUB cadre_ext(ADD(divbi&(0,28,30),6),ADD(divbi&(1,28,30),ADD(MUL(i%,10),2)),1,5,0,13,12,14)
      GOSUB cadre_ext(ADD(divbi&(0,31,30),1),ADD(divbi&(1,31,30),ADD(MUL(i%,10),2)),SUB(divbi&(2,31,30),2),5,0,13,12,14)
    NEXT i%
    IF scr_ncol%>=86
      GOSUB cadre_ext(81,62,SUB(scr_ncol%,83),5,0,13,12,14)
      GOSUB cadre_ext(81,70,SUB(scr_ncol%,83),PRED(MUL(de.nbr_lines%,10)),0,13,12,14)
    ENDIF
  ENDIF
RETURN
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                     Procedures pour le Sample Editor                     *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' General
' -------
PROCEDURE sample_editor                 !!!
  ' Le buffer doit avoir une taille de 4 au minimum, et sa longueur doit etre paire
  ' La longueur de la fenetre affichee doit etre paire et avoir une taille minimum de 2
  ' Sa position aussi doit etre paire
  ' Idem pour l'espace entre les curseurs
  LOCAL a%,b%,c%,d%,i%,j%,k%,noact_delay%,orx%,ory%,orc%,hwin%,lwin%,xm%,xm2%,ym%,ym2%,km%,srt%
  LOCAL a,temp1,temp2,temp3
  LOCAL flag_exit!,flag_relachement!
  LOCAL a$,b$,info_tr$,aaaa$
  se.sample_editor_flag!=TRUE
  se.pas_sous_menu!=FALSE
  ~FRE(0)
  CLS
  GOSUB bee(TRUE)
  info_tr$=STRING$(34,0)        ! Des infos pour le replay des samples
  flag_relachement!=TRUE        ! Il faut relÉcher le bouton apres avoir clique sur une icone
  a%=FN adr_buffer
  b%=FN lon_buffer
  ~C:g_invert_memory%(L:a%,L:b%,W:2)                            ! Remet le buffer dans le bon sens
  GOSUB mise_a_jour_sample_buffer(TRUE)
  orx%=SHR(SUB(scr_larg%,640),1) AND -8                         ! Origine X du panneau
  orc%=SHR(orx%,3)                                              ! Idem, en colonnes
  IF scr_haut%>399
    hwin%=MIN(SUB(scr_haut%,148),152) AND -4                    ! Hauteur de la fenetre du sample
  ELSE IF scr_haut%>240 OR scr_haut%<220
    hwin%=MIN(SUB(scr_haut%,148),72) AND -4
  ELSE
    hwin%=DIV(SUB(scr_haut%,156),2) AND -4
  ENDIF
  lwin%=SUB(scr_larg%,96)                                       ! Sa largeur
  ory%=ADD(hwin%,8)                                             ! Origine Y du panneau
  GOSUB affiche_panneau_sample
  '
  ' Boucle principale
  '
  flag_exit!=FALSE
  REPEAT
    SHOWM
    MOUSE xm%,ym%,km%
    ' Curseurs
    IF km%>0 AND xm%>=16 AND xm%<ADD(lwin%,16) AND ym%>3 AND ym%<ADD(4,hwin%)
      IF km%=1                  ! Curseur gauche
        HIDEM
        GOSUB efface_2_curs
        temp1=SUB(xm%,16)
        temp2=win_lon%-1.0E-07
        temp3=PRED(lwin%)
        a%=MIN(SUB(ADD(mark_1%,mark_len%),2),ADD(INT(temp1*temp2/temp3),win_pos%)) AND -2
        mark_len%=SUB(ADD(mark_1%,mark_len%),a%)
        mark_1%=a%
        GOSUB affiche_2_curs
        SHOWM
        GOSUB affchaine_notrans(HEX$(mark_1%,6),ADD(orc%,8),ADD(ory%,2),1)
        se.volume_ok!=FALSE
        noact_delay%=5
      ELSE IF km%=2             ! Curseur droit
        HIDEM
        GOSUB efface_2_curs
        temp1=SUB(xm%,16)
        temp2=win_lon%
        temp3=PRED(lwin%)
        a%=INT(temp1*temp2/temp3) AND -2
        mark_len%=MAX(MIN(SUB(ADD(a%,win_pos%),mark_1%),SUB(FN lon_buffer,mark_1%)),2)
        GOSUB affiche_2_curs
        SHOWM
        GOSUB affchaine_notrans(HEX$(ADD(mark_1%,mark_len%),6),ADD(orc%,66),ADD(ory%,2),1)
        se.volume_ok!=FALSE
        noact_delay%=5
      ENDIF
      GOSUB affchaine_notrans(HEX$(mark_len%,6),ADD(orc%,29),ADD(ory%,2),1)
    ENDIF
    ' Test des icones
    xm2%=SUB(xm%,orx%)
    ym2%=SUB(ym%,ory%)
    IF km%>0
      ' Bloc d'icones principal
      a%=V:divbi&(0,0,0)
      srt%=C:g_teste_icones%(L:a%,W:2,W:xm2%,W:ym2%)
      IF srt%=>0
        GOSUB sample_editor.icones_principales
      ELSE
        a%=V:divbi&(0,0,0)
        srt%=C:g_teste_icones%(L:a%,W:3,W:xm2%,W:ym2%)
        IF srt%=>0
          GOSUB sample_editor.indicateurs_principaux
        ELSE
          a%=V:divbi&(0,0,0)
          srt%=C:g_teste_icones%(L:a%,W:4,W:xm2%,W:ym2%)
          IF srt%>=0
            ss_menu2%=SUCC(srt%)
            GOSUB sample_editor.affiche_sm
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    ' Test des sous-menus (souris et touches)
    SELECT ss_menu2%
    CASE 1 TO 4
      ON ss_menu2% GOSUB se.sm_gere_volume,se.sm_gere_mix,se.sm_gere_record,se.sm_gere_marks
    CASE 5 TO 8
      ON SUB(ss_menu2%,4) GOSUB se.sm_gere_freq,se.sm_gere_delay,se.sm_gere_flanger,se.sm_gere_reverb
    CASE 9 TO 12
      ON SUB(ss_menu2%,8) GOSUB se.sm_gere_song2disk,se.sm_gere_compression,se.sm_gere_distortion
    ENDSELECT
    ' Test du clavier
    GOSUB sample_editor.touches
    IF noact_delay%>0
      DEC noact_delay%
    ENDIF
  UNTIL flag_exit!
  '
  CLS
  b%=FN lon_buffer                              ! Inverse le buffer pour pouvoir
  a%=FN adr_buffer                              ! garder son debut si les
  ~C:g_invert_memory%(L:a%,L:b%,W:2)            ! samples grandissent
  se.sample_editor_flag!=FALSE
RETURN
PROCEDURE sample_editor.icones_principales
  GOSUB affiche_icone(srt%,2,orc%,ory%,1)
  GOSUB wait_mouse(TRUE)
  SELECT srt%
  CASE 0                        ! Exit
    flag_exit!=TRUE
  CASE 1                        ! Zoom : saisit l'image entre les curseurs
    win_pos%=mark_1%
    win_lon%=mark_len%
    GOSUB affiche_sample
  CASE 2                        ! Zoom out : longueur de fenetre multipliee par 2
    win_pos%=MAX(0,SUB(win_pos%,SHR(win_lon%,1)) AND -2)
    win_lon%=MIN(SHL(win_lon%,1),SUB(FN lon_buffer,win_pos%))
    GOSUB affiche_sample
  CASE 3                        ! Copy sample => block
    GOSUB copy_sample_to_block
    se.volume_ok!=FALSE
    noact_delay%=5
  CASE 4                        ! Copy block => sample
    GOSUB copy_block_to_sample
  CASE 5                        ! Swap block <=> sample
    GOSUB swap_sample_and_block
    se.volume_ok!=FALSE
    noact_delay%=5
  CASE 6                        ! Clear
    GOSUB dialog("CLEAR","Clear block ?","Ok|Cancel",xm%,ym%)
    IF bouton%=0
      GOSUB bee(TRUE)
      GOSUB clear_mem(ADD(FN adr_buffer,mark_1%),mark_len%)
    ENDIF
    se.volume_ok!=FALSE
    noact_delay%=5
    GOSUB affiche_sample
  CASE 7                        ! Cut
    GOSUB dialog("CUT","Cut block ?","Ok|Cancel",xm%,ym%)
    IF bouton%=0
      GOSUB bee(TRUE)
      GOSUB se.sm_chg_marks(ADD(mark_1%,mark_len%),mark_1%)
      IF ADD(mark_1%,mark_len%)<FN lon_buffer
        BMOVE ADD(FN adr_buffer,ADD(mark_1%,mark_len%)),ADD(FN adr_buffer,mark_1%),SUB(FN lon_buffer,ADD(mark_1%,mark_len%))
      ENDIF
      GOSUB clear_mem(ADD(FN adr_buffer,SUB(FN lon_buffer,mark_len%)),mark_len%)
    ENDIF
    se.volume_ok!=FALSE
    noact_delay%=5
    GOSUB affiche_sample
  CASE 8                        ! Keep
    GOSUB dialog("KEEP","Keep your block|and clear the rest ?","Ok|Cancel",xm%,ym%)
    IF bouton%=0
      GOSUB bee(TRUE)
      IF mark_1%>0
        BMOVE ADD(FN adr_buffer,mark_1%),FN adr_buffer,mark_len%
        mark_1%=0
        win_pos%=0
        win_lon%=FN lon_buffer
      ENDIF
      IF mark_len%<FN lon_buffer
        GOSUB clear_mem(ADD(FN adr_buffer,ADD(mark_1%,mark_len%)),SUB(FN lon_buffer,ADD(mark_1%,mark_len%)))
      ENDIF
    ENDIF
    GOSUB affiche_sample
  CASE 9                        ! Flip
    GOSUB bee(TRUE)
    a%=ADD(FN adr_buffer,mark_1%)
    ~C:g_invert_memory%(L:a%,L:mark_len%,W:win_bits%)
    GOSUB affiche_sample
  CASE 10                       ! Gap (block)
    GOSUB dialog("GAP","Insert blank space in the buffer,|length of the block ?","Ok|Cancel",MOUSEX,MOUSEY)
    IF bouton%=0
      GOSUB bee(TRUE)
      GOSUB se.sm_chg_marks(mark_1%,ADD(mark_1%,mark_len%))
      a%=ADD(FN adr_buffer,mark_1%)
      IF ADD(mark_1%,mark_len%)<FN lon_buffer
        BMOVE a%,ADD(a%,mark_len%),SUB(FN lon_buffer,ADD(mark_1%,mark_len%))
      ENDIF
      GOSUB clear_mem(a%,mark_len%)
    ENDIF
    se.volume_ok!=FALSE
    noact_delay%=5
    GOSUB affiche_sample
  CASE 11                       ! Gap (sample)
    GOSUB dialog("GAP","Insert blank space in the buffer,|length of the sample #"+HEX$(sample%,2)+" ?","Ok|Cancel",MOUSEX,MOUSEY)
    IF bouton%=0
      GOSUB bee(TRUE)
      a%=ADD(FN adr_buffer,mark_1%)
      b%=MUL(DIV(FN length(sample%),FN resol(sample%)),win_bits%)
      IF ADD(mark_1%,b%)<FN lon_buffer
        GOSUB se.sm_chg_marks(mark_1%,ADD(mark_1%,b%))
        BMOVE a%,ADD(a%,b%),SUB(FN lon_buffer,ADD(mark_1%,b%))
      ENDIF
      GOSUB clear_mem(a%,MIN(b%,SUB(FN lon_buffer,mark_1%)))
    ENDIF
    se.volume_ok!=FALSE
    noact_delay%=5
    GOSUB affiche_sample
  CASE 12                       ! Play
    GOSUB play_one_sample(48)
    GOSUB affiche_sample
  CASE 13                       ! Fine
    GOSUB dialog("ADJUST FINE POSITION","What cursor do you|want to adjust?","Left|Right|Cancel",MOUSEX,MOUSEY)
    IF bouton%=0
      a%=FN sample_editor.set_fine_position(mark_1%)
      mark_len%=SUB(ADD(mark_1%,mark_len%),a%)
      mark_1%=a%
      GOSUB mise_a_jour_sample_buffer(TRUE)
    ELSE IF bouton%=1
      a%=FN sample_editor.set_fine_position(ADD(mark_1%,mark_len%))
      mark_len%=SUB(a%,mark_1%)
      GOSUB mise_a_jour_sample_buffer(TRUE)
    ENDIF
    GOSUB affiche_panneau_sample
  CASE 14                       ! Swap cursor
    GOSUB swap_block_cursors
    GOSUB mise_a_jour_sample_buffer(TRUE)
    GOSUB affiche_sample
  CASE 15                       ! Reset cursors
    IF win_lon%<>FN lon_buffer
      win_pos%=0                        ! 1) Fenetre maximale
      win_lon%=FN lon_buffer
    ELSE
      mark_1%=0                         ! 2) Block maximum
      mark_len%=FN lon_buffer
      se.volume_ok!=FALSE
      noact_delay%=5
    ENDIF
    GOSUB affiche_sample
  CASE 16                       ! Load sample
    se.pas_sous_menu!=TRUE
    GOSUB load_sample(TRUE)
    se.pas_sous_menu!=FALSE
  CASE 17                       ! Save sample
    se.pas_sous_menu!=TRUE
    GOSUB save_sample(TRUE)
    se.pas_sous_menu!=FALSE
  ENDSELECT
  GOSUB affiche_icone(srt%,2,orc%,ory%,0)
RETURN
PROCEDURE sample_editor.indicateurs_principaux
  SELECT srt%
    ' ------------------------------------------------------------------------
  CASE 0                        ! Left position
    GOSUB edite_chaine(HEX$(win_pos%,6),ADD(orc%,divbi&(0,0,3)),ADD(ory%,ADD(divbi&(1,0,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>=0 AND a%<=mark_1%
      win_pos%=a%
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 1                        ! Left cursor
    GOSUB edite_chaine(HEX$(mark_1%,6),ADD(orc%,divbi&(0,1,3)),ADD(ory%,ADD(divbi&(1,1,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>=0 AND a%<ADD(mark_1%,mark_len%)
      mark_len%=SUB(ADD(mark_1%,mark_len%),a%)
      mark_1%=a%
      GOSUB mise_a_jour_sample_buffer(TRUE)
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 2                        ! Bits
    GOSUB dialog("CONVERT BUFFER","DO YOU REALLY WANT|TO CONVERT BUFFER|TO "+STR$(SHL(SUB(3,win_bits%),3))+" BITS ?","OK|CANCEL",MOUSEX,MOUSEY)
    IF bouton%=0
      GOSUB bee(TRUE)
      a%=FN adr_buffer
      IF win_bits%=1                      ! De 8 a 16
        MUL mark_1%,2
        MUL mark_len%,2
        MUL mark_2%,2
        MUL mark_rep%,2
        MUL win_pos%,2
        MUL win_lon%,2
        win_bits%=2
        GOSUB mise_a_jour_sample_buffer(TRUE)
        b%=SHR(FN lon_buffer,1)
        ~C:g_copy_sample_8_2_16%(L:a%,L:a%,L:b%)
      ELSE                                ! de 16 a 8
        mark_1%=SHR(mark_1%,1) AND -2
        mark_len%=SHR(mark_len%,1) AND -2
        mark_2%=SHR(mark_2%,1) AND -2
        mark_rep%=SHR(mark_rep%,1) AND -2
        win_pos%=SHR(win_pos%,1) AND -2
        win_lon%=SHR(win_lon%,1) AND -2
        win_bits%=1
        GOSUB mise_a_jour_sample_buffer(TRUE)
        b%=FN lon_buffer
        ~C:g_copy_sample_16_2_8%(L:a%,L:a%,L:b%)
        b%=SHR(b%,1)
        GOSUB clear_mem(ADD(a%,b%),b%)
      ENDIF
    ENDIF
    GOSUB affiche_sample
    ' ------------------------------------------------------------------------
  CASE 3                        ! Block length
    GOSUB edite_chaine(HEX$(mark_len%,6),ADD(orc%,divbi&(0,3,3)),ADD(ory%,ADD(divbi&(1,3,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>0 AND ADD(mark_1%,a%)<=FN lon_buffer
      mark_len%=a%
      GOSUB mise_a_jour_sample_buffer(TRUE)
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 5                        ! Repeat pos
    GOSUB edite_chaine(HEX$(mark_rep%,6),ADD(orc%,divbi&(0,5,3)),ADD(ory%,ADD(divbi&(1,5,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>=0 AND a%<FN lon_buffer
      mark_rep%=a%
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 6                        ! Buffer frequency
    GOSUB edite_chaine(STR$(freq_buffer%,5),ADD(orc%,divbi&(0,6,3)),ADD(ory%,ADD(divbi&(1,6,3),2)),5,2)
    GOSUB se.change_buffer_frequency(VAL(bbbb$),TRUE)
    ' ------------------------------------------------------------------------
  CASE 7                        ! Sample number
    IF km%=1                            ! Bouton gauche : edite le numero
      GOSUB edite_chaine(HEX$(sample%,2),ADD(orc%,divbi&(0,7,3)),ADD(ory%,ADD(divbi&(1,7,3),2)),2,1)
      a%=VAL("$"+bbbb$)
      IF a%>0
        sample%=a%
      ENDIF
    ELSE                                ! Bouton droit : menu 'Samples' du panneau principal
      GOSUB wait_mouse(TRUE)
      GOSUB affiche_icones_sample
      GOSUB bee(FALSE)
      ss_menu%=4
      REPEAT
        SHOWM
        MOUSE xm%,ym%,km%
        IF km%<>0 AND ym%>34 AND ym%<105 AND xm%>159 AND xm%<640
          GOSUB gere_icones_sample
        ELSE IF km%<>0
          a%=1
        ELSE
          a%=0
        ENDIF
        IF GEMDOS(11)<>0
          a%=SHR(GEMDOS(7),16)
        ENDIF
      UNTIL (a% AND 255)=1              ! ESC pour sortir de la
      GOSUB affiche_panneau_sample
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 8                        ! Right cursor
    GOSUB edite_chaine(HEX$(ADD(mark_1%,mark_len%),6),ADD(orc%,divbi&(0,8,3)),ADD(ory%,ADD(divbi&(1,8,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>mark_1% AND a%<=FN lon_buffer
      mark_len%=SUB(a%,mark_1%)
      GOSUB mise_a_jour_sample_buffer(TRUE)
    ENDIF
    ' ------------------------------------------------------------------------
  CASE 9                        ! Right position
    GOSUB edite_chaine(HEX$(ADD(win_pos%,win_lon%),6),ADD(orc%,divbi&(0,9,3)),ADD(ory%,ADD(divbi&(1,9,3),2)),6,1)
    a%=VAL("$"+bbbb$) AND -2
    IF a%>ADD(mark_1%,mark_len%) AND a%<=FN lon_buffer
      win_lon%=SUB(a%,win_pos%)
    ENDIF
    ' ------------------------------------------------------------------------
  ENDSELECT
  GOSUB affiche_sample
RETURN
PROCEDURE sample_editor.touches
  IF GEMDOS(11)<>0            ! Une touche ?
    clavier%=GEMDOS(7)
    GOSUB vide_buffer_clavier
    touch_ascii%=clavier% AND 255
    clavier%=SHR(clavier%,16) AND 4095
    GOSUB vide_buffer_clavier
    SELECT clavier%
      ' ----------------------------------------------------------------------
    CASE 57                   ! Espace : Swap cursors
      GOSUB swap_block_cursors
      GOSUB mise_a_jour_sample_buffer(TRUE)
      GOSUB affiche_sample
      ' ----------------------------------------------------------------------
    CASE 71                   ! Clr Home : sample + 1
      sample%=MIN(SUCC(sample%),255)
      GOSUB affiche_sample
      ' ----------------------------------------------------------------------
    CASE 82                   ! Insert : sample - 1
      sample%=MAX(PRED(sample%),1)
      GOSUB affiche_sample
      ' ----------------------------------------------------------------------
    CASE 3097                 ! Ctrl + Alt + P : SnapShot
      GOSUB snapshot
      ' ----------------------------------------------------------------------
    ENDSELECT
  ENDIF
RETURN
PROCEDURE sample_editor.affiche_sm
  LOCAL iii%
  FOR iii%=0 TO 10
    IF iii%=PRED(ss_menu2%)
      GOSUB cadre_texte2_b(divbn$(iii%,4),ADD(orc%,divbi&(0,iii%,4)),ADD(ory%,divbi&(1,iii%,4)),divbi&(2,iii%,4),-1)
    ELSE
      GOSUB cadre_texte2(divbn$(iii%,4),ADD(orc%,divbi&(0,iii%,4)),ADD(ory%,divbi&(1,iii%,4)),divbi&(2,iii%,4),0)
    ENDIF
  NEXT iii%
  GOSUB cadre_int(orc%,ADD(ory%,80),79,59,13,13,14,12)
  GOSUB wait_mouse(TRUE)
  SELECT ss_menu2%
  CASE 1 TO 4
    ON ss_menu2% GOSUB se.sm_affsm_volume,se.sm_affsm_mix,se.sm_affsm_record,se.sm_affsm_marks
  CASE 5 TO 8
    ON SUB(ss_menu2%,4) GOSUB se.sm_affsm_freq,se.sm_affsm_delay,se.sm_affsm_flanger,se.sm_affsm_reverb
  CASE 9 TO 12
    ON SUB(ss_menu2%,8) GOSUB se.sm_affsm_song2disk,se.sm_affsm_compression,se.sm_affsm_distortion
  ENDSELECT
RETURN
FUNCTION sample_editor.set_fine_position(curs%)
  LOCAL a%,b%,oldcurs%
  LOCAL clavier%,ascii_code%,scan_code%
  LOCAL exit_flag!
  ' Detourne les variables suivantes:
  LOCAL hwin%,lwin%,win_pos%,win_lon%
  LOCAL xm%,ym%,km%
  '
  ' Affichage de la fenetre Sample plein ecran
  '
  CLS
  hwin%=SUB(scr_haut%,8) AND -8
  lwin%=SUB(scr_larg%,32)
  GOSUB cadre_int(0,0,PRED(scr_ncol%),ADD(hwin%,7),9,9,10,8)
  GOSUB cadre_ext(2,4,PRED(SHR(lwin%,3)),PRED(hwin%),0,9,8,10)   ! Fenetre du sample
  win_lon%=SHL(SUB(scr_ncol%,4),3)
  GOSUB sample_editor.set_fine_position.redraw
  '
  ' Gestion du curseur
  '
  exit_flag!=FALSE
  REPEAT
    oldcurs%=curs%
    IF GEMDOS(11)<>0
      KEYGET clavier%
      GOSUB vide_buffer_clavier
      clavier%=clavier% AND &H1FFF00FF
      a%=FN key_trafique_code_clavier(clavier%)
      clavier%=LONG{a%}
      scan_code%=SHR(clavier%,16) AND 255
      ascii_code%=clavier% AND 255
      SELECT scan_code%
      CASE 1,57       ! Esc, Space bar
        exit_flag!=TRUE
      CASE 75         ! Left
        GOSUB sample_editor.set_fine_position.to_left
      CASE 77         ! Right
        GOSUB sample_editor.set_fine_position.to_right
      DEFAULT
        SELECT ascii_code
        CASE 13       ! Return/Enter
          exit_flag!=TRUE
        ENDSELECT
      ENDSELECT
    ENDIF
    MOUSE xm%,ym%,km%
    IF km%=1
      IF xm%>=16 AND xm%<ADD(lwin%,16)
        curs%=ADD(win_pos%,SUB(xm%,16))
      ELSE
        IF xm%<16
          GOSUB sample_editor.set_fine_position.to_left
        ELSE
          GOSUB sample_editor.set_fine_position.to_right
        ENDIF
      ENDIF
    ELSE IF km%=2
      exit_flag!=TRUE
    ENDIF
    IF curs%<>oldcurs%
      HIDEM
      GOSUB efface_curseur(SUB(oldcurs%,win_pos%),1)
      GOSUB affiche_curseur(SUB(curs%,win_pos%),1)
      SHOWM
    ENDIF
  UNTIL exit_flag!
  RETURN curs%
ENDFUNC
PROCEDURE sample_editor.set_fine_position.to_left
  curs%=MIN(win_pos%,ADD(win_pos%,SUB(SHR(win_lon%,1),128)))
  oldcurs%=curs%
  GOSUB sample_editor.set_fine_position.redraw
RETURN
PROCEDURE sample_editor.set_fine_position.to_right
  curs%=MIN(MAX(ADD(win_pos%,win_lon%),ADD(win_pos%,ADD(SHR(win_lon%,1),128))),FN lon_buffer) AND -2
  oldcurs%=curs%
  GOSUB sample_editor.set_fine_position.redraw
RETURN
PROCEDURE sample_editor.set_fine_position.redraw
  win_pos%=MIN(MAX(SUB(curs%,SHR(win_lon%,1)),0),SUB(FN lon_buffer,win_lon%)) AND -2
  a%=ADD(FN adr_buffer,win_pos%)
  b%=SHR(SUB(scr_ncol%,4),1)
  HIDEM
  ~C:g_affiche_sample%(L:a%,L:win_lon%,W:win_bits%,W:4,W:b%,W:hwin%)
  GOSUB affiche_curseur(SUB(curs%,win_pos%),1)
  SHOWM
RETURN
' Affichage
PROCEDURE affiche_sample                !!!
  ' Point de repetition a afficher
  LOCAL a%,b%,c%,d%,e%,i%,k,l
  GOSUB mise_a_jour_sample_buffer(FALSE)
  GOSUB bee(FALSE)
  ~FRE(0)
  IF win_lon%>0
    a%=ADD(FN adr_buffer,win_pos%)
    b%=SHR(lwin%,4)
    HIDEM
    ~C:g_affiche_sample%(L:a%,L:win_lon%,W:win_bits%,W:4,W:b%,W:hwin%)
  ENDIF
  GOSUB affchaine_notrans(HEX$(win_pos%,6),ADD(orc%,divbi&(0,0,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(mark_1%,6),ADD(orc%,divbi&(0,1,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(STR$(SHL(win_bits%,3),2),ADD(orc%,divbi&(0,2,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(mark_len%,6),ADD(orc%,divbi&(0,3,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(FN lon_buffer,6),ADD(orc%,divbi&(0,4,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(mark_rep%,6),ADD(orc%,divbi&(0,5,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(STR$(freq_buffer%,5),ADD(orc%,divbi&(0,6,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(sample%,2),ADD(orc%,divbi&(0,7,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(ADD(mark_1%,mark_len%),6),ADD(orc%,divbi&(0,8,3)),ADD(ory%,2),1)
  GOSUB affchaine_notrans(HEX$(ADD(win_pos%,win_lon%),6),ADD(orc%,divbi&(0,9,3)),ADD(ory%,2),1)
  GOSUB affiche_2_curs
  SHOWM
RETURN
PROCEDURE affiche_fft
  ' Affichage de la FFT
  LOCAL a%,b%,c%,d%,e%,i%,k,l
  IF scr_haut%>=220
    GOSUB bee(FALSE)
    e%=SUB(scr_larg%,32)
    GOSUB cadre_ext(2,ADD(ory%,144),PRED(SHR(e%,3)),SUB(scr_haut%,ADD(ory%,149)),0,9,8,10)
    IF se.freq_fftdisp%=1
      k=SUB(scr_haut%,ADD(ory%,148))/LOG(&H7FFF)
    ELSE
      a%=1
      FOR i%=0 TO PRED(se.freq_fftlon%)
        a%=MAX(a%,fft&(i%))
      NEXT i%
      k=SUB(scr_haut%,ADD(ory%,148))/a%
    ENDIF
    l=se.freq_fftlon%/e%
    HIDEM
    FOR i%=0 TO PRED(e%)
      IF se.freq_fftdisp%=1
        b%=LOG(MAX(fft&(INT(i%*l)),1))*k
      ELSE
        b%=fft&(INT(i%*l))*k
      ENDIF
      IF b%>=1
        a%=SUB(scr_haut%,ADD(b%,4))
        c%=i%
        ~C:g_affiche_marqueur_sample%(L:e%,W:1,W:a%,W:e%,W:b%,L:c%,W:0)
      ENDIF
    NEXT i%
    IF se.freq_fftnoteon!
      c%=MUL(SUB(se.freq_ofn%,se.freq_fftmin%),e%)/SUB(se.freq_fftmax%,se.freq_fftmin%)
      IF c%>=0 AND c%<e%                            ! La note proposee pour le sample
        a%=ADD(ory%,144)
        b%=SUB(scr_haut%,ADD(ory%,148))
        ~C:g_affiche_marqueur_sample%(L:e%,W:1,W:a%,W:e%,W:b%,L:c%,W:1)
      ENDIF
    ENDIF
  ENDIF
  SHOWM
RETURN
PROCEDURE affiche_panneau_sample
  ' En entree : orc%, ory%, hwin%, scr_ncol% et parametres de fenetre
  LOCAL i%
  CLS
  GOSUB bee(FALSE)
  GOSUB cadre_int(0,0,PRED(scr_ncol%),ADD(hwin%,7),9,9,10,8)
  GOSUB cadre_ext(2,4,PRED(SHR(lwin%,3)),PRED(hwin%),0,9,8,10)  ! Fenetre du sample
  GOSUB cadre_ext(ADD(SHR(lwin%,3),4),4,1,PRED(hwin%),0,9,8,10) ! Vu-metre G
  GOSUB cadre_ext(ADD(SHR(lwin%,3),8),4,1,PRED(hwin%),0,9,8,10) ! Vu-metre D
  GOSUB cadre_int(orc%,ory%,79,19,13,13,14,12)                  ! Infos buffer
  GOSUB cadre_int(orc%,ADD(ory%,20),79,59,9,9,10,8)             ! Menu general
  FOR i%=0 TO 9
    GOSUB affchaine_trans(divbn$(i%,3),SUB(SHL(ADD(orc%,divbi&(0,i%,3)),1),SUB(LEN(divbn$(i%,3)),SUCC(divbi&(2,i%,3)))),ADD(ory%,ADD(divbi&(1,i%,3),12)),14)
    GOSUB cadre_ext(ADD(orc%,divbi&(0,i%,3)),ADD(ory%,ADD(divbi&(1,i%,3),2)),divbi&(2,i%,3),5,0,13,12,14)
  NEXT i%
  GOSUB affiche_bloc_icones(0,18,2,orc%,ory%)
  GOSUB grise_icone(5,2,orc%,ory%)              ! Swap Sample and Block
  GOSUB sample_editor.affiche_sm
  GOSUB affiche_sample
RETURN
PROCEDURE affiche_curseur(pos%,plan%)
  ' Affiche un curseur de sample
  ~C:g_affiche_marqueur_sample%(L:win_lon%,W:win_bits%,W:4,W:lwin%,W:hwin%,L:pos%,W:plan%)
RETURN
PROCEDURE efface_curseur(pos%,plan%)
  ' Efface un curseur de sample
  ~C:g_efface_marqueur_sample%(L:win_lon%,W:win_bits%,W:4,W:lwin%,W:hwin%,L:pos%,W:plan%)
RETURN
PROCEDURE affiche_2_curs
  HIDEM
  GOSUB affiche_curseur(SUB(mark_1%,win_pos%),1)
  GOSUB affiche_curseur(SUB(ADD(mark_1%,mark_len%),win_pos%),1)
  IF mark_2%=>win_pos% AND mark_2%<=ADD(win_pos%,win_lon%)
    GOSUB affiche_curseur(SUB(mark_2%,win_pos%),2)
  ENDIF
  SHOWM
RETURN
PROCEDURE efface_2_curs
  HIDEM
  IF mark_2%=>win_pos% AND mark_2%<=ADD(win_pos%,win_lon%)
    GOSUB efface_curseur(SUB(mark_2%,win_pos%),2)
  ENDIF
  GOSUB efface_curseur(SUB(ADD(mark_1%,mark_len%),win_pos%),1)
  GOSUB efface_curseur(SUB(mark_1%,win_pos%),1)
  SHOWM
RETURN
' Divers
PROCEDURE se.change_buffer_frequency(freq%,disp!)
  ' Change proprement la frequence du buffer
  ' Pas de changement si la valeur est trop petite/trop grande
  ' Reinitialise les parametres FFT
  IF freq%>=2000 AND freq%<65536
    freq_buffer%=freq%
  ENDIF
  se.freq_fft_pend%=SHR(freq_buffer%,1)
  se.freq_fft_pstart%=0
  IF disp!
    GOSUB affiche_sample
    IF ss_menu2%=5
      GOSUB se.sm_actsm_freq
    ENDIF
  ENDIF
RETURN
PROCEDURE mise_a_jour_sample_buffer(flag!)
  ' Mise a jour de la fenetre
  mark_1%=MAX(MIN(SUB(FN lon_buffer,2),mark_1%),0) AND -2               ! Marqueur de debut de bloc dans le sample
  mark_len%=MAX(MIN(mark_len%,SUB(FN lon_buffer,mark_1%)),2) AND -2     ! Marqueur de fin de bloc
  mark_2%=MAX(MIN(mark_2%,FN lon_buffer),0) AND -2                      ! Ancien marqueur de fin (pointilles)
  mark_rep%=MIN(MAX(mark_1%,mark_rep%),ADD(mark_1%,SUB(mark_len%,2)))   ! Marqueur de repetition
  win_pos%=MAX(MIN(win_pos%,mark_1%),0) AND -2                          ! Debut de la fenetre de sample
  win_lon%=MIN(MAX(win_lon%,SUB(ADD(mark_1%,mark_len%),win_pos%)),SUB(FN lon_buffer,win_pos%)) AND -2   ! Longueur de la fenetre
  IF flag!
    se.volume_ok!=FALSE                                           ! Le bloc a pu etre modifie
  ENDIF
  noact_delay%=5
RETURN
PROCEDURE play_one_sample(note%)
  ' Joue le buffer a la note note%
  ' Sans repetition pour l'instant
  LOCAL a%,b%,adr_arret%,old_note%,old_mark_2%
  LOCAL flag_a!
  LOCAL repeatbuffer$
  repeatbuffer$=STRING$(1024,0)
  old_note%=note%                               ! Memorise la note d'entree
  old_mark_2%=mark_2%
  HIDEM
  REPEAT
    IF MOUSEK=1                                 ! Bouton gauche de la souris : rejoue la note
      note%=old_note%
    ENDIF
    IF note%<>0
      CARD{ADD(V:info_tr$,2)}=win_bits%
      CARD{ADD(V:info_tr$,4)}=freq_buffer%
      CARD{ADD(V:info_tr$,6)}=&H800
      CARD{ADD(V:info_tr$,10)}=note%
      LONG{ADD(V:info_tr$,12)}=ADD(FN adr_buffer,mark_1%)
      LONG{ADD(V:info_tr$,22)}=MAX(SUB(mark_len%,2),0)
      LONG{ADD(V:info_tr$,26)}=2
      LONG{ADD(V:info_tr$,30)}=V:repeatbuffer$
      a%=V:info_tr$
      b%=preset&(curs_col%,n_preset%)
      adr_arret%=C:rr_play_one_sample%(L:a%,W:b%)
      note%=0
      flag_a!=FALSE
      GOSUB wait_mouse(TRUE)
    ENDIF
    IF GEMDOS(11)<>0
      ~GEMDOS(7)
      flag_a!=TRUE
    ELSE IF MOUSEK=2
      flag_a!=TRUE
    ENDIF
    VSYNC
    IF mark_2%=>win_pos% AND mark_2%<=ADD(win_pos%,win_lon%)
      GOSUB efface_curseur(SUB(mark_2%,win_pos%),2)
    ENDIF
    mark_2%=ADD(mark_1%,LONG{ADD(adr_arret%,16)}) AND -2        ! Memorise la position du sample
    IF mark_2%=>win_pos% AND mark_2%<=ADD(win_pos%,win_lon%)
      GOSUB affiche_curseur(SUB(mark_2%,win_pos%),2)
    ENDIF
  UNTIL LONG{ADD(adr_arret%,22)}=0 OR flag_a!   ! Attend la fin naturelle du sample ou stop utilisateur
  IF NOT flag_a!                                ! Pas de stop utilisateur: ne memorise pas la nouvelle position
    mark_2%=old_mark_2%
  ENDIF
  CARD{ADD(V:info_tr$,2)}=win_bits%             ! Stop
  CARD{ADD(V:info_tr$,4)}=freq_buffer%
  CARD{ADD(V:info_tr$,6)}=0
  CARD{ADD(V:info_tr$,10)}=48
  LONG{ADD(V:info_tr$,12)}=FN adr_buffer
  LONG{ADD(V:info_tr$,22)}=0
  LONG{ADD(V:info_tr$,26)}=2
  LONG{ADD(V:info_tr$,30)}=FN adr_buffer
  a%=V:info_tr$
  b%=preset&(curs_col%,n_preset%)
  ~C:rr_play_one_sample%(L:a%,W:b%)
  GOSUB wait_mouse(TRUE)
RETURN
PROCEDURE copy_sample_to_block
  LOCAL a%,b%,c%,d%
  a%=MUL(DIV(FN length(sample%),FN resol(sample%)),win_bits%) AND -2    ! Place prise dans le buffer apres conversion
  b%=FN adresse(sample%)                ! Adresse du sample
  c%=ADD(FN adr_buffer,mark_1%)         ! Adresse destination
  IF win_bits%<>FN resol(sample%)       ! On doit faire une conversion de resolution ?
    GOSUB dialog("COPY TO BLOCK","Convert "+STR$(SHL(FN resol(sample%),3))+" bits sample|to "+STR$(SHL(win_bits%,3))+" bits buffer ?","Ok|Cancel",MOUSEX,MOUSEY)
    IF bouton%=0        ! Conversion ok
      IF a%>mark_len%
        GOSUB dialog("COPY TO BLOCK","Copy sample #"+HEX$(sample%,2)+" to block.|Sample is too large :","Clip|Overflow|Cancel",xm%,ym%)
        IF bouton%=0            ! Clip
          GOSUB bee(TRUE)
          IF win_bits%=2
            d%=SHR(mark_len%,1)
            ~C:g_copy_sample_8_2_16%(L:b%,L:c%,L:d%)
          ELSE
            d%=SHL(mark_len%,1)
            ~C:g_copy_sample_16_2_8%(L:b%,L:c%,L:d%)
          ENDIF
          mark_2%=MIN(ADD(mark_1%,a%),FN lon_buffer)    ! Pointe sur la fin virtuelle du sample
        ELSE IF bouton%=1       ! Overflow
          mark_2%=ADD(mark_1%,mark_len%)        ! Sauve l'ancienne position
          mark_len%=MIN(a%,SUB(FN lon_buffer,mark_1%))
          GOSUB bee(TRUE)
          IF win_bits%=2
            d%=SHR(mark_len%,1)
            ~C:g_copy_sample_8_2_16%(L:b%,L:c%,L:d%)
          ELSE
            d%=SHL(mark_len%,1)
            ~C:g_copy_sample_16_2_8%(L:b%,L:c%,L:d%)
          ENDIF
        ENDIF
      ELSE                      ! Ca tient
        GOSUB bee(TRUE)
        IF win_bits%=2
          d%=SHR(a%,1)
          ~C:g_copy_sample_8_2_16%(L:b%,L:c%,L:d%)
        ELSE
          d%=SHL(a%,1)
          ~C:g_copy_sample_16_2_8%(L:b%,L:c%,L:d%)
        ENDIF
        mark_2%=ADD(mark_1%,a%)         ! Pointe sur la fin du sample
      ENDIF
      freq_buffer%=FN freqech(sample%)
    ENDIF
  ELSE                  ! C'est le meme nombre de bits pour le buffer et le sample
    IF a%>mark_len%
      GOSUB dialog("COPY TO BLOCK","Copy sample #"+HEX$(sample%,2)+" to block.|Sample is too large :","Clip|Overflow|Cancel",xm%,ym%)
      IF bouton%=0      ! Clip
        GOSUB bee(TRUE)
        BMOVE b%,c%,mark_len%
        mark_2%=MIN(ADD(mark_1%,a%),FN lon_buffer)      ! Pointe sur la fin virtuelle du sample
        freq_buffer%=FN freqech(sample%)
      ELSE IF bouton%=1 ! Overflow
        GOSUB bee(TRUE)
        mark_2%=ADD(mark_1%,mark_len%)  ! Sauve l'ancienne position
        mark_len%=MIN(a%,SUB(FN lon_buffer,mark_1%))
        BMOVE b%,c%,mark_len%
        freq_buffer%=FN freqech(sample%)
      ENDIF
    ELSE                ! Ca tient
      GOSUB bee(TRUE)
      BMOVE b%,c%,a%
      mark_2%=ADD(mark_1%,a%)   ! Pointe sur la fin du sample
      freq_buffer%=FN freqech(sample%)
    ENDIF
  ENDIF
  GOSUB mise_a_jour_sample_buffer(TRUE)
  GOSUB bee(FALSE)
  GOSUB affiche_sample
RETURN
PROCEDURE copy_block_to_sample
  LOCAL a%,b%
  GOSUB dialog("COPY TO SAMPLE","Copy block to|sample #"+HEX$(sample%,2)+" ?","Ok|Cancel",MOUSEX,MOUSEY)
  a%=SUB(mark_len%,FN length(sample%))  ! Difference de taille entre le nouveau et l'ancien sample
  IF bouton%=0
    GOSUB bee(TRUE)
    IF a%>0             ! On manque de place
      IF SUB(FN lon_buffer,ADD(mark_1%,mark_len%))<a%
        ' S'il n'y a pas assez de place a droite du block pour creer un nouveau sample, rotation
        b%=FN length(sample%)
        GOSUB chg_taille_sample(sample%,0)      ! Vide d'abord le sample
        GOSUB chg_sam_length(sample%,0)
        GOSUB chg_sam_repeat(sample%,0)
        GOSUB chg_sam_replen(sample%,2)
        mark_len%=MIN(mark_len%,SUB(FN lon_buffer,256))   ! Si jamais on essaie de remplacer tt le buffer (->len=0)
        BMOVE ADD(FN adr_buffer,b%),FN adr_buffer,SUB(FN lon_buffer,b%) ! Puis deplace le buffer (les FN... sont pour le nouveau buffer)
        GOSUB mem_rotation(FN adresse(sample%),SUB(ADD(FN adr_buffer,ADD(mark_1%,mark_len%)),FN adresse(sample%)),mark_len%)
        GOSUB chg_sam_length(sample%,mark_len%)
        IF sample%<255                          ! Reactualise les adresses des samples deplaces
          FOR i%=SUCC(sample%) TO 255
            LONG{ADD(r_adr_sample%,SHL(i%,2))}=ADD(LONG{ADD(r_adr_sample%,SHL(i%,2))},mark_len%)
          NEXT i%
        ENDIF
        GOSUB mise_a_jour_sample_buffer(TRUE)
      ELSE              ! Sinon on elimine la fin du buffer pour faire de la place dans les samples
        BMOVE FN adr_buffer,ADD(FN adr_buffer,a%),SUB(FN lon_buffer,a%)
        GOSUB chg_taille_sample(sample%,mark_len%)
        GOSUB chg_sam_length(sample%,mark_len%)
        GOSUB mise_a_jour_sample_buffer(FALSE)
        BMOVE ADD(FN adr_buffer,mark_1%),FN adresse(sample%),mark_len%
      ENDIF
    ELSE IF a%<0        ! On va creer de la place
      GOSUB chg_taille_sample(sample%,mark_len%)        ! Deplace d'abord les samples
      GOSUB chg_sam_length(sample%,mark_len%)
      GOSUB mise_a_jour_sample_buffer(FALSE)
      BMOVE SUB(FN adr_buffer,a%),FN adr_buffer,ADD(FN lon_buffer,a%)   ! Puis le buffer (les FN... sont pour le nouveau buffer)
      GOSUB clear_mem(ADD(FN adr_buffer,ADD(FN lon_buffer,a%)),-a%)
      BMOVE ADD(FN adr_buffer,mark_1%),FN adresse(sample%),mark_len%
    ELSE
      BMOVE ADD(FN adr_buffer,mark_1%),FN adresse(sample%),mark_len%
    ENDIF
    GOSUB chg_sam_freq(sample%,freq_buffer%)
    GOSUB chg_sam_nbits(sample%,win_bits%)
    GOSUB chg_sam_repeat(sample%,0)
    GOSUB chg_sam_replen(sample%,2)
    GOSUB chg_sam_volume(sample%,&H100)
    ~C:rr_boucle_sample%(W:sample%)
  ENDIF
  GOSUB bee(FALSE)
  GOSUB affiche_sample
RETURN
PROCEDURE swap_sample_and_block         !!!
RETURN
PROCEDURE swap_block_cursors
  LOCAL a%
  IF mark_2%>mark_1%
    a%=mark_2%
    mark_2%=ADD(mark_1%,mark_len%)
    mark_len%=SUB(a%,mark_1%)
  ENDIF
RETURN
'
' Sous-menus du Sample Editor
' ---------------------------
' Volume
PROCEDURE se.sm_affsm_volume
  GOSUB cadre_int(orc%,ADD(ory%,80),29,29,13,13,14,12)          ! Cadre volume
  GOSUB cadre_int(orc%,ADD(ory%,110),29,29,13,13,14,12)         ! Cadre volume sur effets
  GOSUB cadre_int(ADD(orc%,30),ADD(ory%,80),17,59,13,13,14,12)  ! Cadre gain
  GOSUB cadre_int(ADD(orc%,48),ADD(ory%,80),31,59,13,13,14,12)  ! Cadre fade
  GOSUB affchaine_trans("GAIN",ADD(SHL(orc%,1),62),ADD(ory%,82),14)
  GOSUB affchaine_trans("FADE",ADD(SHL(orc%,1),98),ADD(ory%,82),14)
  GOSUB affchaine_trans("FADE PARAMETERS",ADD(SHL(orc%,1),98),ADD(ory%,107),14)
  GOSUB affchaine_trans("PRESETS",ADD(SHL(orc%,1),144),ADD(ory%,107),14)
  GOSUB affchaine_trans("VOLUME ON EFFECTS",ADD(SHL(orc%,1),2),ADD(ory%,117),14)
  GOSUB affiche_bloc_icones_b(0,15,5,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,0,5),7)),ADD(ory%,ADD(divbi&(1,0,5),2)),4,5,0,13,12,14)     ! Volume
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,11,5),11)),ADD(ory%,ADD(divbi&(1,11,5),2)),4,5,0,13,12,14)  ! Fade start
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,12,5),11)),ADD(ory%,ADD(divbi&(1,12,5),2)),4,5,0,13,12,14)  ! Fade end
  GOSUB se.sm_actsm_volume
RETURN
PROCEDURE se.sm_actsm_volume
  ' Var locales de Sample_Editor :
  ' Utilise aaaa$
  GOSUB affiche_icone_b(15,5,orc%,ory%,NOT se.flag_best_volume!)
  GOSUB affiche_icone_b(16,5,orc%,ory%,se.flag_best_volume!)
  IF se.volume_ok!
    aaaa$=FN pourcent$(se.volume_spl%,32768)
  ELSE
    aaaa$="     "
  ENDIF
  GOSUB affchaine_notrans(aaaa$,ADD(orc%,ADD(divbi&(0,0,5),7)),ADD(ory%,ADD(divbi&(1,0,5),2)),1)
  GOSUB affchaine_notrans(FN pourcent$(se.volume_fade_start%,32768),ADD(orc%,ADD(divbi&(0,11,5),11)),ADD(ory%,ADD(divbi&(1,11,5),2)),1)
  GOSUB affchaine_notrans(FN pourcent$(se.volume_fade_end%,32768),ADD(orc%,ADD(divbi&(0,12,5),11)),ADD(ory%,ADD(divbi&(1,12,5),2)),1)
  GOSUB grise_icone(16,5,orc%,ory%)
  SHOWM
RETURN
PROCEDURE se.sm_gere_volume
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, aaaa$
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:5,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 0                    ! Set volume
        IF NOT se.volume_ok!            ! Calcule le volume actuel si ce n'est deja fait
          GOSUB bee(TRUE)
          se.volume_spl%=FN spl_cherche_volume(mark_1%,mark_len%,win_bits%)
        ENDIF
        aaaa$=FN pourcent$(se.volume_spl%,32768)
        GOSUB edite_chaine(aaaa$,ADD(orc%,ADD(divbi&(0,0,5),7)),ADD(ory%,ADD(divbi&(1,0,5),2)),5,3)
        GOSUB bee(TRUE)
        a%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)                  ! Nouveau volume
        GOSUB spl_chg_volume(mark_1%,mark_len%,VAL(aaaa$)*327.68,a%,a%,win_bits%)
        se.volume_spl%=FN spl_cherche_volume(mark_1%,mark_len%,win_bits%)
        se.volume_ok!=TRUE
        GOSUB affiche_sample
        GOSUB se.sm_actsm_volume
        ' --------------------------------------------------------------------
      CASE 11                   ! Fade start
        GOSUB edite_chaine(FN pourcent$(se.volume_fade_start%,32768),ADD(orc%,ADD(divbi&(0,9,5),11)),ADD(ory%,ADD(divbi&(1,9,5),2)),5,3)
        se.volume_fade_start%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)       ! Nouveau volume de debut de fade
        GOSUB se.sm_actsm_volume
        ' --------------------------------------------------------------------
      CASE 12                   ! Fade end
        GOSUB edite_chaine(FN pourcent$(se.volume_fade_end%,32768),ADD(orc%,ADD(divbi&(0,10,5),11)),ADD(ory%,ADD(divbi&(1,10,5),2)),5,3)
        se.volume_fade_end%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100) ! Nouveau volume de fin de fade
        GOSUB se.sm_actsm_volume
        ' --------------------------------------------------------------------
      CASE 15                   ! Volume : No change
        se.flag_best_volume!=FALSE
        GOSUB se.sm_actsm_volume
        ' --------------------------------------------------------------------
      CASE 16                   ! Volume : Best *** Non selectionnable pour l'instant ***
        ' se.flag_best_volume!=TRUE
        ' GOSUB se.sm_actsm_volume
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,5,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 1                  ! Volume ?
          GOSUB bee(TRUE)
          se.volume_spl%=FN spl_cherche_volume(mark_1%,mark_len%,win_bits%)
          se.volume_ok!=TRUE
          GOSUB bee(FALSE)
          GOSUB se.sm_actsm_volume
          ' ------------------------------------------------------------------
        CASE 2 TO 9             ! +1, +2, +3, +6, -1, -2, -3, -6 dB
          GOSUB bee(TRUE)
          a%=10000*(10^(VAL(MID$("+1+2+3+6-1-2-3-6",SUB(SHL(srt%,1),3),2))/10))
          GOSUB spl_chg_volume(mark_1%,mark_len%,10000,a%,a%,win_bits%)
          se.volume_spl%=FN spl_cherche_volume(mark_1%,mark_len%,win_bits%)
          se.volume_ok!=TRUE
          GOSUB affiche_sample
          GOSUB se.sm_actsm_volume
          ' ------------------------------------------------------------------
        CASE 10                 ! Fade !
          GOSUB bee(TRUE)
          GOSUB spl_chg_volume(mark_1%,mark_len%,32768,se.volume_fade_start%,se.volume_fade_end%,win_bits%)
          se.volume_spl%=FN spl_cherche_volume(mark_1%,mark_len%,win_bits%)
          se.volume_ok!=TRUE
          GOSUB affiche_sample
          GOSUB se.sm_actsm_volume
          ' ------------------------------------------------------------------
        CASE 13                 ! Fade in
          se.volume_fade_start%=0
          se.volume_fade_end%=32768
          GOSUB se.sm_actsm_volume
          ' ------------------------------------------------------------------
        CASE 14                 ! Fade out
          se.volume_fade_start%=32768
          se.volume_fade_end%=0
          GOSUB se.sm_actsm_volume
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,5,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(TRUE)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
  IF noact_delay%=1 AND (NOT se.volume_ok!)     ! Si le volume n'est plus valable suite a une manip
    GOSUB affchaine_notrans("     ",ADD(orc%,ADD(divbi&(0,0,5),7)),ADD(ory%,ADD(divbi&(1,0,5),2)),1)
  ENDIF
RETURN
PROCEDURE spl_chg_volume(dddd%,llll%,vvvv1%,vvvv2%,vvvv3%,bbbb%)
  ' Change le volume du sample position dddd%, longueur llll%,
  ' ancien volume vvvv1%, nouveaux volumes vvvv2% et 3 (debut-fin)
  ' Bbbb% est la resolution du sample (1 ou 2)
  LOCAL aaaa%,iiii1%,iiii2%,vvvv4%
  IF llll%>0 AND vvvv1%<>0
    aaaa%=ADD(FN adr_buffer,dddd%)
    vvvv4%=vvvv2%*32768/vvvv1%
    iiii1%=INT(SUB(vvvv3%,vvvv2%)*32768/vvvv1%/SHR(llll%,PRED(bbbb%)))
    iiii2%=(SUB(vvvv3%,vvvv2%)*32768/vvvv1%/SHR(llll%,PRED(bbbb%))-iiii1%)*2147483647
    ~C:g_change_volume_sample%(L:aaaa%,L:llll%,L:vvvv4%,L:iiii1%,L:iiii2%,W:bbbb%)
  ENDIF
RETURN
' Mixage
PROCEDURE se.sm_affsm_mix
  ' Var locales de Sample_Editor :
  ' Utilise i%, a% et b%
  GOSUB cadre_int(orc%,ADD(ory%,80),13,19,13,13,14,12)                  ! Cadre mix!
  GOSUB cadre_int(ADD(orc%,14),ADD(ory%,80),15,19,13,13,14,12)          ! Cadre master
  GOSUB cadre_int(ADD(orc%,30),ADD(ory%,80),9,19,13,13,14,12)           ! Cadre presets
  FOR i%=1 TO 5
    a%=ADD(orc%,MUL(DIV(i%,3),40))
    b%=ADD(ory%,ADD(80,MUL(i% MOD 3,20)))
    GOSUB cadre_int(a%,b%,1,19,13,13,14,12)                             ! Cadre piste 1a
    GOSUB cadre_int(ADD(a%,38),b%,1,19,13,13,14,12)                     ! Cadre piste 1b
    GOSUB cadre_int(SUCC(a%),b%,5,19,13,13,14,12)                       ! Cadre piste 2
    GOSUB affchaine_trans(STR$(i%),ADD(SHL(a%,1),5),ADD(b%,2),14)       ! Numero de piste
  NEXT i%
  GOSUB affiche_bloc_icones_b(0,46,6,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,1,6),7)),ADD(ory%,ADD(divbi&(1,1,6),2)),4,5,0,13,12,14) ! Master
  FOR i%=7 TO 43 STEP 8
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,i%,6),6)),ADD(ory%,ADD(divbi&(1,i%,6),2)),4,5,0,13,12,14)                     ! Start
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,SUCC(i%),6),4)),ADD(ory%,ADD(divbi&(1,SUCC(i%),6),2)),4,5,0,13,12,14)         ! End
    GOSUB cadre_ext(ADD(orc%,SUCC(divbi&(0,ADD(i%,3),6))),ADD(ory%,ADD(divbi&(1,ADD(i%,3),6),2)),1,5,0,13,12,14)        ! Numero
    GOSUB cadre_ext(ADD(orc%,SUCC(divbi&(0,ADD(i%,6),6))),ADD(ory%,ADD(divbi&(1,ADD(i%,6),6),2)),27,5,0,13,12,14)       ! Samplename
  NEXT i%
  GOSUB se.sm_actsm_mix
RETURN
PROCEDURE se.sm_actsm_mix
  ' Var locales de Sample_Editor :
  ' Utilise a%, i%, j%, aaaa$
  GOSUB affchaine_notrans(FN pourcent$(se.mix_master_volume%,32768),ADD(orc%,ADD(divbi&(0,1,6),7)),ADD(ory%,ADD(divbi&(1,1,6),2)),1)
  FOR i%=0 TO 4
    j%=ADD(MUL(i%,8),6)
    GOSUB affiche_icone_b(j%,6,orc%,ory%,se.mix_param%(0,i%) AND 1)             ! On
    GOSUB affiche_icone_b(ADD(j%,3),6,orc%,ory%,se.mix_param%(0,i%) AND 2)      ! Loop
    a%=se.mix_param%(1,i%)                              ! Numero de sample
    IF a%>0
      GOSUB affchaine_notrans(HEX$(a%,2),ADD(orc%,SUCC(divbi&(0,ADD(j%,4),6))),ADD(ory%,ADD(divbi&(1,ADD(j%,4),6),2)),1)
      aaaa$=FN samplename$(a%)
    ELSE
      GOSUB affchaine_notrans("  ",ADD(orc%,SUCC(divbi&(0,ADD(j%,4),6))),ADD(ory%,ADD(divbi&(1,ADD(j%,4),6),2)),1)
      aaaa$="Block                       "
    ENDIF
    GOSUB affchaine_notrans(aaaa$,ADD(orc%,SUCC(divbi&(0,ADD(j%,7),6))),ADD(ory%,ADD(divbi&(1,ADD(j%,7),6),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.mix_param%(2,i%),32768),ADD(orc%,ADD(divbi&(0,ADD(j%,1),6),6)),ADD(ory%,ADD(divbi&(1,ADD(j%,1),6),2)),1)    ! Volume de debut
    GOSUB affchaine_notrans(FN pourcent$(se.mix_param%(3,i%),32768),ADD(orc%,ADD(divbi&(0,ADD(j%,2),6),4)),ADD(ory%,ADD(divbi&(1,ADD(j%,2),6),2)),1)    ! Volume de fin
  NEXT i%
  SHOWM
RETURN
PROCEDURE se.sm_gere_mix
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, i%, flag_relachement!, aaaa$
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:6,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 6,14,22,30,38        ! Sample On/Off
        se.mix_param%(0,DIV(SUB(srt%,6),8))=se.mix_param%(0,DIV(SUB(srt%,6),8)) XOR 1
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 9,17,25,33,41        ! Loop on/off
        se.mix_param%(0,DIV(SUB(srt%,9),8))=se.mix_param%(0,DIV(SUB(srt%,9),8)) XOR 2
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 1                    ! Master volume
        GOSUB edite_chaine(FN pourcent$(se.mix_master_volume%,32768),ADD(orc%,ADD(divbi&(0,1,6),7)),ADD(ory%,ADD(divbi&(1,1,6),2)),5,3)
        se.mix_master_volume%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 7,15,23,31,39        ! Volume de debut
        IF km%=2
          se.mix_param%(2,DIV(SUB(srt%,7),8))=se.mix_param%(3,DIV(SUB(srt%,7),8))
        ELSE
          GOSUB edite_chaine(FN pourcent$(se.mix_param%(2,DIV(SUB(srt%,7),8)),32768),ADD(orc%,ADD(divbi&(0,srt%,6),6)),ADD(ory%,ADD(divbi&(1,srt%,6),2)),5,3)
          se.mix_param%(2,DIV(SUB(srt%,7),8))=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        ENDIF
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 8,16,24,32,40        ! Volume de fin
        IF km%=2
          se.mix_param%(3,DIV(SUB(srt%,8),8))=se.mix_param%(2,DIV(SUB(srt%,8),8))
        ELSE
          GOSUB edite_chaine(FN pourcent$(se.mix_param%(3,DIV(SUB(srt%,8),8)),32768),ADD(orc%,ADD(divbi&(0,srt%,6),4)),ADD(ory%,ADD(divbi&(1,srt%,6),2)),5,3)
          se.mix_param%(3,DIV(SUB(srt%,8),8))=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        ENDIF
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 10,18,26,34,42       ! Numero de sample
        IF km%=1
          GOSUB edite_chaine(HEX$(se.mix_param%(1,DIV(SUB(srt%,10),8)),2),ADD(orc%,SUCC(divbi&(0,srt%,6))),ADD(ory%,ADD(divbi&(1,srt%,6),2)),2,1)
          se.mix_param%(1,DIV(SUB(srt%,10),8))=VAL("$"+bbbb$)
        ELSE
          se.mix_param%(1,DIV(SUB(srt%,10),8))=sample%
        ENDIF
        GOSUB se.sm_actsm_mix
        ' --------------------------------------------------------------------
      CASE 11,12,19,20,27,28,35,36,43,44        ! Sample + ou -
        se.mix_param%(1,DIV(SUB(srt%,11),8))=MAX(MIN(ADD(se.mix_param%(1,DIV(SUB(srt%,11),8)),SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,11) MOD 8,km%))),255),0)
        GOSUB se.sm_actsm_mix
        IF km%=1
          PAUSE 2
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 13,21,29,37,45       ! Simples icones non cliquables
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,6,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0                  ! Mix !
          GOSUB bee(TRUE)
          GOSUB spl_mixage_samples(mark_1%,mark_len%,win_bits%,se.mix_master_volume%)
          se.volume_ok!=FALSE
          noact_delay%=5
          GOSUB affiche_sample
          ' ------------------------------------------------------------------
        CASE 2 TO 5             ! Presets
          se.mix_master_volume%=DIV(32768,srt%)
          FOR i%=0 TO 4
            IF i%<srt%  ! On
              se.mix_param%(0,i%)=se.mix_param%(0,i%) OR 1
              se.mix_param%(2,i%)=32768
              se.mix_param%(3,i%)=32768
            ELSE        ! Off
              se.mix_param%(0,i%)=se.mix_param%(0,i%) AND -2
            ENDIF
          NEXT i%
          GOSUB se.sm_actsm_mix
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,6,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE spl_mixage_samples(dddd%,llll%,bbbb%,mmmm%)
  ' Mixe plusieurs samples (infos dans se.mix_param%())
  ' Buffer commencant en position dddd%, de longueur llll%,
  ' de resolution bbbb% (1 ou 2)
  ' Master volume mmmm% (/32768)
  LOCAL iiii%,iiii1%,iiii2%,ssss%,aaaa$
  IF llll%>0
    aaaa$=""
    nnnn%=0
    FOR iiii%=0 TO 4
      IF BTST(se.mix_param%(0,iiii%),0)
        ssss%=se.mix_param%(1,iiii%)
        IF ssss%=0                                              ! Buffer
          aaaa$=aaaa$+MKI$(bbbb%)+MKL$(ADD(FN adr_buffer,dddd%))+MKL$(-1)+MKL$(llll%)+MKL$(0)
        ELSE                                                    ! Sample
          aaaa$=aaaa$+MKI$(FN resol(ssss%))+MKL$(FN adresse(ssss%))
          IF ADD(FN repeat(ssss%),FN replen(ssss%))>2 AND BTST(se.mix_param%(0,iiii%),1)        ! Boucle
            aaaa$=aaaa$+MKL$(FN repeat(ssss%))+MKL$(ADD(FN repeat(ssss%),FN replen(ssss%)))+MKL$(0)
          ELSE                                                  ! Pas boucle
            aaaa$=aaaa$+MKL$(-1)+MKL$(FN length(ssss%))+MKL$(0)
          ENDIF
        ENDIF
        aaaa$=aaaa$+MKL$(se.mix_param%(2,iiii%)*mmmm%/32768)+MKL$(0)
        iiii1%=INT(SUB(se.mix_param%(3,iiii%),se.mix_param%(2,iiii%))*mmmm%/SHR(llll%,PRED(bbbb%))/32768)        ! Calcul des increments de volume
        iiii2%=SHL((SUB(se.mix_param%(3,iiii%),se.mix_param%(2,iiii%))*mmmm%/SHR(llll%,PRED(bbbb%))/32768-iiii1%)*2147483647,1)
        aaaa$=aaaa$+MKL$(iiii1%)+MKL$(iiii2%)
        INC nnnn%
      ENDIF
    NEXT iiii%
    IF nnnn%>0
      aaaa$=MKL$(ADD(FN adr_buffer,dddd%))+MKL$(llll%)+MKI$(bbbb%)+MKI$(nnnn%)+aaaa$
      aaaa%=V:aaaa$
      ~C:g_mixage_sample%(L:aaaa%)
    ENDIF
  ENDIF
RETURN
' Record
PROCEDURE se.sm_affsm_record
  GOSUB cadre_int(orc%,ADD(ory%,80),23,19,13,13,14,12)          ! Cadre Sample/presample
  GOSUB cadre_int(orc%,ADD(ory%,100),23,39,13,13,14,12)         ! Cadre Trigger/frequency
  GOSUB cadre_int(ADD(orc%,24),ADD(ory%,80),13,29,13,13,14,12)  ! Cadre Channel
  GOSUB cadre_int(ADD(orc%,24),ADD(ory%,110),13,29,13,13,14,12) ! Cadre Monitor
  GOSUB cadre_int(ADD(orc%,38),ADD(ory%,80),25,59,13,13,14,12)  ! Cadre Input Device
  GOSUB cadre_int(ADD(orc%,64),ADD(ory%,80),15,59,13,13,14,12)  ! Cadre Input Level
  GOSUB affiche_bloc_icones_b(0,12,7,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,7,7),10)),ADD(ory%,ADD(divbi&(1,7,7),2)),4,5,0,13,12,14)        ! Frequency
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,11,7),6)),ADD(ory%,ADD(divbi&(1,11,7),2)),4,5,0,13,12,14)       ! Level
  GOSUB cadre_ext(ADD(orc%,65),ADD(ory%,97),4,5,0,13,12,14)     ! Level (L)
  GOSUB cadre_ext(ADD(orc%,74),ADD(ory%,97),4,5,0,13,12,14)     ! Level (R)
  GOSUB affchaine_trans("INPUT LEVEL",ADD(SHL(orc%,1),133),ADD(ory%,117),14)
  GOSUB affchaine_trans("LEFT",ADD(SHL(orc%,1),131),ADD(ory%,87),14)
  GOSUB affchaine_trans("RIGHT",ADD(SHL(orc%,1),148),ADD(ory%,87),14)
  GOSUB affchaine_trans("dB",ADD(SHL(orc%,1),142),ADD(ory%,97),14)
  GOSUB affchaine_trans("CHANNEL",SUB(SHL(ADD(orc%,divbi&(0,14,7)),1),3),SUB(ADD(ory%,divbi&(1,14,7)),8),14)
  GOSUB affchaine_trans("INPUT DEVICE",SHL(ADD(orc%,45),1),ADD(ory%,87),14)
  GOSUB se.sm_actsm_record
RETURN
PROCEDURE se.sm_actsm_record
  ' Variable locales de Sample_Editor :
  ' Utilise aaaa$
  GOSUB affiche_icone_b(12,7,orc%,ory%,se.rec_flag_trigger!)    ! Trigger on/off
  GOSUB affiche_icone_b(13,7,orc%,ory%,se.rec_canal%=1)         ! Left
  GOSUB affiche_icone_b(14,7,orc%,ory%,se.rec_canal%=3)         ! Left+Right
  GOSUB affiche_icone_b(15,7,orc%,ory%,se.rec_canal%=2)         ! Right
  GOSUB affiche_icone_b(16,7,orc%,ory%,se.rec_input_device%=0)  ! Falcon ADC
  GOSUB affiche_icone_b(17,7,orc%,ory%,se.rec_input_device%=1)  ! ST Replay pro
  GOSUB affchaine_notrans(FN pourcent$(se.rec_trigger%,32768),ADD(orc%,ADD(divbi&(0,11,7),6)),ADD(ory%,ADD(divbi&(1,11,7),2)),1)        ! Niveau de trigger
  IF se.rec_input_device%=0             ! DAC CODEC Falcon
    aaaa$=MID$("xxxxx4917032780245851966816390xxxxx12292xxxxx 9834xxxxx 8195",SUCC(MUL(se.rec_adc_freq%,5)),5)
  ELSE
    aaaa$=STR$(se.rec_ext_freq%,5)      ! DAC exterieur
  ENDIF
  GOSUB affchaine_notrans(aaaa$,ADD(orc%,ADD(divbi&(0,7,7),10)),ADD(ory%,ADD(divbi&(1,7,7),2)),1)
  GOSUB affchaine_notrans(STR$(-(SHR(NOT PEEK(&HFFFF8939),4) AND 15)*1.5,5),ADD(orc%,65),ADD(ory%,97),1)   ! Level (L)
  GOSUB affchaine_notrans(STR$(-((NOT PEEK(&HFFFF8939)) AND 15)*1.5,5),ADD(orc%,74),ADD(ory%,97),1)        ! Level (R)
  GOSUB grise_icone(17,7,orc%,ory%)
  SHOWM
RETURN
PROCEDURE se.sm_gere_record             !!!
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, i%, flag_relachement!, aaaa$
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:7,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 2,3                  ! Level +/- (L)
        SPOKE &HFFFF8939,ADD(PEEK(&HFFFF8939) AND 15,MAX(0,MIN(240,ADD(PEEK(&HFFFF8939) AND 240,SUB(80,SHL(srt%,5))))))
        GOSUB se.sm_actsm_record
        IF km%=1
          PAUSE 4
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 4,5                  ! Level +/- (R)
        SPOKE &HFFFF8939,ADD(PEEK(&HFFFF8939) AND 240,MAX(0,MIN(15,ADD(PEEK(&HFFFF8939) AND 15,SUB(9,SHL(srt%,1))))))
        GOSUB se.sm_actsm_record
        IF km%=1
          PAUSE 4
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 8                    ! Frequence +
        IF se.rec_input_device%=0
          se.rec_adc_freq%=VAL("$"+MID$("11234151719",se.rec_adc_freq%,1))
          GOSUB se.sm_actsm_record
          IF km%=1
            PAUSE 4
          ENDIF
          flag_relachement!=FALSE
        ENDIF
        ' --------------------------------------------------------------------
      CASE 9                    ! Frequence -
        IF se.rec_input_device%=0
          se.rec_adc_freq%=VAL("$"+MID$("23457191B1B",se.rec_adc_freq%,1))
          GOSUB se.sm_actsm_record
          IF km%=1
            PAUSE 4
          ENDIF
          flag_relachement!=FALSE
        ENDIF
        ' --------------------------------------------------------------------
      CASE 7                    ! Frequency
        IF se.rec_input_device%<>0
          GOSUB edite_chaine(STR$(se.rec_ext_freq%,5),ADD(orc%,ADD(divbi&(0,7,7),10)),ADD(ory%,ADD(divbi&(1,7,7),2)),5,2)
          se.rec_ext_freq%=MIN(49170,MAX(2000,VAL(bbbb$)))
        ENDIF
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 11                   ! Trigger level
        GOSUB edite_chaine(FN pourcent$(se.rec_trigger%,32768),ADD(orc%,ADD(divbi&(0,11,7),6)),ADD(ory%,ADD(divbi&(1,11,7),2)),5,3)
        se.rec_trigger%=MAX(MIN(DIV(32768*VAL(bbbb$),100),32768),0)
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 12                   ! Trigger on/off
        se.rec_flag_trigger!=NOT se.rec_flag_trigger!
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 13                   ! Left
        se.rec_canal%=1
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 14                   ! Left + Right
        se.rec_canal%=3
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 15                   ! Right
        se.rec_canal%=2
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 16                   ! ADC Falcon
        se.rec_input_device%=0
        GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      CASE 17                   ! ADC ST Replay pro *** Non selectionnable pour l'instant ***
        '   se.rec_input_device%=1
        '   GOSUB se.sm_actsm_record
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,7,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0                  ! Sample
          aaaa$=MKL$(ADD(FN adr_buffer,mark_1%))+MKL$(mark_len%)+MKL$(0)+MKI$(0)+MKI$(win_bits%)+MKI$(se.rec_canal%)+MKI$(MUL(se.rec_trigger%,-se.rec_flag_trigger!))
          IF se.rec_input_device%=0             ! Utilisation de l'ADC du Falcon
            aaaa$=aaaa$+MKI$(se.rec_adc_freq%)
            BMOVE V:aaaa$,g_adr_record_inf%,22
            ~C:g_start_sample_recording%(W:0)
            REPEAT
              a%=C:g_cherche_volume_buffer_stereo%(W:0)
              GOSUB spl_affiche_vumetre(SHR(a%,16),a% AND 65535,0,0)
              IF GEMDOS(11)<>0
                ~GEMDOS(7)
                CARD{g_flag_sample_rec%}=0
              ELSE IF MOUSEK=2
                CARD{g_flag_sample_rec%}=0
              ENDIF
            UNTIL CARD{g_flag_sample_rec2%}=4
            freq_buffer%=DIV(98340,SUCC(se.rec_adc_freq%))
          ELSE IF se.rec_input_device%=1        ! Utilisation de la carte ST Replay pro
            '
            '
            '
            '
            freq_buffer%=se.rec_ext_freq%
          ENDIF
          mark_2%=MIN(ADD(mark_1%,LONG{ADD(g_adr_record_inf%,8)}),ADD(mark_1%,mark_len%))
          GOSUB spl_affiche_vumetre(0,0,0,0)
          GOSUB affiche_sample
          ' ------------------------------------------------------------------
        CASE 1                  ! Presample
          aaaa$=MKL$(ADD(FN adr_buffer,mark_1%))+MKL$(mark_len%)+MKL$(0)+MKI$(1)+MKI$(win_bits%)+MKI$(se.rec_canal%)+MKI$(MUL(se.rec_trigger%,-se.rec_flag_trigger!))
          IF se.rec_input_device%=0             ! Utilisation de l'ADC du Falcon
            aaaa$=aaaa$+MKI$(se.rec_adc_freq%)
            BMOVE V:aaaa$,g_adr_record_inf%,22
            ~C:g_start_sample_recording%(W:0)
            REPEAT
              a%=C:g_cherche_volume_buffer_stereo%(W:0)
              GOSUB spl_affiche_vumetre(SHR(a%,16),a% AND 65535,0,0)
              IF GEMDOS(11)<>0
                ~GEMDOS(7)
                CARD{g_flag_sample_rec%}=0
              ELSE IF MOUSEK=2
                CARD{g_flag_sample_rec%}=0
              ENDIF
            UNTIL CARD{g_flag_sample_rec2%}=4
            freq_buffer%=DIV(98340,SUCC(se.rec_adc_freq%))
          ELSE IF se.rec_input_device%=1        ! Utilisation de la carte ST Replay pro
            '
            '
            '
            '
            freq_buffer%=se.rec_ext_freq%
          ENDIF
          GOSUB spl_affiche_vumetre(0,0,0,0)
          a%=LONG{ADD(g_adr_record_inf%,8)}
          IF BTST(CARD{ADD(g_adr_record_inf%,12)},1)
            GOSUB bee(TRUE)
            GOSUB mem_rotation(ADD(FN adr_buffer,mark_1%),mark_len%,-a%)
            GOSUB bee(FALSE)
          ENDIF
          PAUSE 2
          GOSUB affiche_sample
          ' ------------------------------------------------------------------
        CASE 6                  ! Auto
          GOSUB spl_auto_set_input_level(TRUE)
          ' ------------------------------------------------------------------
        CASE 10                 ! Monitor
          GOSUB spl_auto_set_input_level(FALSE)
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,7,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE spl_auto_set_input_level(flag!)
  ' Si flag!=TRUE, adapte le niveau d'entree a la source
  ' Si flag!=FALSE, simple monitoring
  LOCAL a%,a1%,a2%,b%,c%,d%,v1%,v2%,old_mat_cnx%,a$
  ~FRE(0)
  v1%=0
  v2%=0
  old_mat_cnx%=LPEEK(&HFFFF8930)                ! Sauve l'ancienne connection de la matrice
  ~XBIOS(&H8B,W:3,W:&X1001,W:0,W:1,W:1)         ! Connecte le DAC et le DMArec a l'ADC
  a$=MKL$(XBIOS(2))+MKL$(2048)+MKL$(0)+MKI$(0)+MKI$(2)+MKI$(1)+MKI$(32769)+MKI$(1)
  BMOVE V:a$,g_adr_record_inf%,22
  ~C:g_start_sample_recording%(W:0)
  REPEAT
    a%=C:g_cherche_volume_buffer_stereo%(W:0)
    a1%=SHR(a%,16)
    a2%=a% AND 65535
    ' Teste la droite
    IF a2%<v2%                                  ! Moins fort que d'habitude, le plafond descend lentement
      v2%=SHR(ADD(MUL(v2%,253),MUL(a2%,3)),8)   ! Inertie 253/256 (ancien) - 3/256 (nouveau)
    ELSE                                        ! Plus fort, le plafond s'adapte rapidement
      v2%=SHR(ADD(MUL(v2%,6),MUL(a2%,10)),4)    ! Inertie 6/16 (ancien) - 10/16 (nouveau)
    ENDIF
    IF flag!
      b%=PEEK(&HFFFF8939) AND 15
      d%=b%
      IF a2%>32700                              ! Saturation ?
        d%=MAX(SUB(b%,4),0)                     ! alors - 6 dB cash
      ELSE IF v2%>0
        c%=ROUND(10*LOG10(v2%/24576)/1.5)       ! Rapport volume / 75% de volmax en dB/1.5
        d%=MIN(MAX(SUB(b%,c%),0),15)            ! Augmente ou diminue en consequence
        v2%=v2%*(10^(SUB(d%,b%)*0.15))
      ENDIF
      SPOKE &HFFFF8939,ADD(d%,PEEK(&HFFFF8939) AND &HF0)
    ENDIF
    ' Teste la gauche
    IF a1%<v1%                                  ! Moins fort que d'habitude, le plafond descend lentement
      v1%=SHR(ADD(MUL(v1%,253),MUL(a1%,3)),8)   ! Inertie 253/256 (ancien) - 3/256 (nouveau)
    ELSE                                        ! Plus fort, le plafond s'adapte rapidement
      v1%=SHR(ADD(MUL(v1%,6),MUL(a1%,10)),4)    ! Inertie 6/16 (ancien) - 10/16 (nouveau)
    ENDIF
    IF flag!
      b%=SHR(PEEK(&HFFFF8939),4)
      d%=b%
      IF a1%>32700                              ! Saturation ?
        d%=MAX(SUB(b%,4),0)                     ! alors - 6 dB cash
      ELSE IF v1%>0
        c%=ROUND(10*LOG10(v1%/24576)/1.5)       ! Rapport volume / 75% de volmax en dB/1.5
        d%=MIN(MAX(SUB(b%,c%),0),15)            ! Augmente ou diminue en consequence
        v1%=v1%*(10^(SUB(d%,b%)*0.15))
      ENDIF
      SPOKE &HFFFF8939,ADD(SHL(d%,4),PEEK(&HFFFF8939) AND 15)
    ENDIF
    ' Affiche le resultat
    GOSUB affchaine_notrans(STR$(-(SHR(NOT PEEK(&HFFFF8939),4) AND 15)*1.5,5),ADD(orc%,65),ADD(ory%,97),1)   ! Level (L)
    GOSUB affchaine_notrans(STR$(-((NOT PEEK(&HFFFF8939)) AND 15)*1.5,5),ADD(orc%,74),ADD(ory%,97),1)        ! Level (R)
    IF GEMDOS(11)<>0
      ~GEMDOS(7)
      CARD{g_flag_sample_rec%}=0
      flag_s!=TRUE
    ELSE IF MOUSEK=2
      CARD{g_flag_sample_rec%}=0
    ELSE
      GOSUB spl_affiche_vumetre(a1%,a2%,v1%,v2%)
    ENDIF
  UNTIL CARD{g_flag_sample_rec2%}=4             ! Fini ?
  SLPOKE &HFFFF8930,old_mat_cnx%                ! Reprend l'ancienne config de la matrice
  GOSUB spl_affiche_vumetre(0,0,0,0)
RETURN
PROCEDURE spl_affiche_vumetre(vvvv1%,vvvv2%,mmmm1%,mmmm2%)
  LOCAL aaaa%
  aaaa%=SUB(SHR(scr_ncol%,1),4)         ! Gauche
  ~C:g_affiche_vumetre%(W:vvvv1%,W:mmmm1%,W:aaaa%,W:4,W:hwin%)
  aaaa%=SUB(SHR(scr_ncol%,1),2)         ! Droite
  ~C:g_affiche_vumetre%(W:vvvv2%,W:mmmm2%,W:aaaa%,W:4,W:hwin%)
RETURN
' Marks
PROCEDURE se.sm_affsm_marks
  GOSUB cadre_int(orc%,ADD(ory%,80),39,49,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,40),ADD(ory%,80),39,49,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,12,8,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,23,8)),ADD(ory%,ADD(divbi&(1,23,8),2)),20,45,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,24,8)),ADD(ory%,ADD(divbi&(1,24,8),2)),20,45,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,25,8)),ADD(ory%,ADD(divbi&(1,25,8),2)),5,45,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,26,8)),ADD(ory%,ADD(divbi&(1,26,8),2)),5,45,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,27,8)),ADD(ory%,ADD(divbi&(1,27,8),2)),5,45,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,28,8)),ADD(ory%,ADD(divbi&(1,28,8),2)),5,45,0,13,12,14)
  GOSUB affchaine_trans("NAME",ADD(SHL(ADD(orc%,divbi&(0,23,8)),1),17),ADD(ADD(ory%,divbi&(1,23,8)),52),14)
  GOSUB affchaine_trans("POS",ADD(SHL(ADD(orc%,divbi&(0,25,8)),1),3),ADD(ADD(ory%,divbi&(1,25,8)),52),14)
  GOSUB affchaine_trans("LENGTH",SHL(ADD(orc%,divbi&(0,27,8)),1),ADD(ADD(ory%,divbi&(1,27,8)),52),14)
  GOSUB se.sm_actsm_marks
RETURN
PROCEDURE se.sm_actsm_marks
  GOSUB se.sm_update_marks
  FOR i%=0 TO 9
    GOSUB affiche_icone_b(ADD(i%,13),8,orc%,ory%,se.mark_selected% AND SHL(1,i%))
    GOSUB affchaine_notrans(se.mark$(i%),ADD(orc%,divbi&(0,ADD(23,DIV(i%,5)),8)),ADD(ory%,ADD(ADD(divbi&(1,ADD(23,DIV(i%,5)),8),MUL(i% MOD 5,10)),2)),1)
    GOSUB affchaine_notrans(HEX$(se.mark%(0,i%),6),ADD(orc%,divbi&(0,ADD(25,DIV(i%,5)),8)),ADD(ory%,ADD(ADD(divbi&(1,ADD(25,DIV(i%,5)),8),MUL(i% MOD 5,10)),2)),1)
    GOSUB affchaine_notrans(HEX$(se.mark%(1,i%),6),ADD(orc%,divbi&(0,ADD(27,DIV(i%,5)),8)),ADD(ory%,ADD(ADD(divbi&(1,ADD(27,DIV(i%,5)),8),MUL(i% MOD 5,10)),2)),1)
  NEXT i%
  GOSUB affiche_icone_b(12,8,orc%,ory%,se.mark_set!)
  SHOWM
RETURN
PROCEDURE se.sm_gere_marks
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, i%
  ~FRE(0)
  IF km%>0
    GOSUB se.sm_update_marks
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:8,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 12                   ! Set
        se.mark_set!=NOT se.mark_set!
        GOSUB se.sm_actsm_marks
        ' --------------------------------------------------------------------
      CASE 13 TO 22             ! Selection d'un numero de preset
        se.mark_selected%=se.mark_selected% XOR SHL(1,SUB(srt%,13))
        GOSUB se.sm_actsm_marks
        ' --------------------------------------------------------------------
      CASE 23,24                ! Name
        a%=ADD(MUL(SUB(srt%,23),5),DIV(SUB(ym2%,divbi&(1,srt%,8)),10))
        GOSUB edite_chaine(se.mark$(a%),ADD(orc%,divbi&(0,srt%,8)),ADD(ory%,ADD(divbi&(1,srt%,8),ADD(MUL(a% MOD 5,10),2))),21,0)
        se.mark$(a%)=bbbb$
        GOSUB se.sm_actsm_marks
        ' --------------------------------------------------------------------
      CASE 25,26                ! Pos
        a%=ADD(MUL(SUB(srt%,25),5),DIV(SUB(ym2%,divbi&(1,srt%,8)),10))
        GOSUB edite_chaine(HEX$(se.mark%(0,a%),6),ADD(orc%,divbi&(0,srt%,8)),ADD(ory%,ADD(divbi&(1,srt%,8),ADD(MUL(a% MOD 5,10),2))),6,1)
        se.mark%(0,a%)=MIN(VAL("$"+bbbb$),SUB(FN lon_buffer,2)) AND -2
        se.mark%(1,a%)=MIN(se.mark%(1,a%),SUB(FN lon_buffer,se.mark%(0,a%))) AND -2
        GOSUB se.sm_actsm_marks
        ' --------------------------------------------------------------------
      CASE 27,28                ! Length
        a%=ADD(MUL(SUB(srt%,27),5),DIV(SUB(ym2%,divbi&(1,srt%,8)),10))
        GOSUB edite_chaine(HEX$(se.mark%(1,a%),6),ADD(orc%,divbi&(0,srt%,8)),ADD(ory%,ADD(divbi&(1,srt%,8),ADD(MUL(a% MOD 5,10),2))),6,1)
        se.mark%(1,a%)=MIN(VAL("$"+bbbb$),SUB(FN lon_buffer,se.mark%(0,a%))) AND -2
        GOSUB se.sm_actsm_marks
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,8,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0 TO 9             ! Activation ou enregistrement d'un preset
          IF se.mark_set!
            se.mark%(0,srt%)=mark_1%
            se.mark%(1,srt%)=mark_len%
            se.mark_set!=FALSE
          ELSE
            mark_1%=se.mark%(0,srt%)
            mark_len%=se.mark%(1,srt%)
          ENDIF
          IF km%=2
            win_pos%=mark_1%
            win_lon%=mark_len%
          ENDIF
          GOSUB affiche_sample
          GOSUB se.sm_actsm_marks
          ' ------------------------------------------------------------------
        CASE 10                 ! All
          se.mark_selected%=&X1111111111
          GOSUB se.sm_actsm_marks
          ' ------------------------------------------------------------------
        CASE 11                 ! Reset
          FOR i%=0 TO 9
            IF (se.mark_selected% AND SHL(1,i%))=SHL(1,i%)
              se.mark%(0,i%)=0
              se.mark%(1,i%)=FN lon_buffer
              se.mark$(i%)=SPACE$(21)
            ENDIF
          NEXT i%
          se.mark_selected%=0
          GOSUB se.sm_actsm_marks
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,8,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(TRUE)
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_update_marks
  ' Corrige les marques si la longueur du buffer a ete modifiee
  LOCAL i%
  FOR i%=0 TO 9
    IF se.mark%(0,i%)>SUB(FN lon_buffer,2)
      se.mark%(0,i%)=0
      se.mark%(1,i%)=FN lon_buffer
      se.mark$(i%)=SPACE$(21)
    ELSE
      se.mark%(1,i%)=MIN(se.mark%(1,i%),SUB(FN lon_buffer,se.mark%(0,i%))) AND -2
    ENDIF
  NEXT i%
RETURN
PROCEDURE se.sm_chg_marks(oooo%,nnnn%)
  ' Reactualise les marques pour l'insertion ou la destruction d'une sequence dans le buffer
  ' oooo% = ancienne pos, nnnn% = nouvelle pos
  LOCAL i%
  IF oooo%<=nnnn%
    FOR i%=0 TO 9
      IF se.mark%(0,i%)>=oooo%
        ADD se.mark%(0,i%),SUB(nnnn%,oooo%)
      ELSE IF ADD(se.mark%(0,i%),se.mark%(1,i%))>=oooo%
        ADD se.mark%(1,i%),SUB(nnnn%,oooo%)
      ENDIF
    NEXT i%
  ELSE
    FOR i%=0 TO 9
      IF se.mark%(0,i%)>=oooo%
        ADD se.mark%(0,i%),SUB(nnnn%,oooo%)
      ELSE IF se.mark%(0,i%)>=nnnn%
        SUB se.mark%(1,i%),SUB(oooo%,se.mark%(0,i%))
        IF se.mark%(1,i%)=>2
          se.mark%(0,i%)=nnnn%
        ELSE
          se.mark%(0,i%)=0
          se.mark%(1,i%)=FN lon_buffer
          se.mark$(i%)=SPACE$(21)
        ENDIF
      ELSE IF se.mark%(0,i%)<=nnnn% AND ADD(se.mark%(0,i%),se.mark%(1,i%))>nnnn%
        IF ADD(se.mark%(0,i%),se.mark%(1,i%))>=oooo%
          SUB se.mark%(1,i%),SUB(oooo%,nnnn%)
        ELSE
          se.mark%(1,i%)=SUB(nnnn%,se.mark%(0,i%))
        ENDIF
      ENDIF
    NEXT i%
  ENDIF
RETURN
' Frequency
PROCEDURE se.sm_affsm_freq
  GOSUB cadre_int(orc%,ADD(ory%,80),13,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,14),ADD(ory%,80),20,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,35),ADD(ory%,80),13,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,49),ADD(ory%,80),30,59,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,11,9,orc%,ory%)
  GOSUB affiche_bloc_icones_b(14,3,9,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,8,9),5)),ADD(ory%,ADD(divbi&(1,8,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,8,9),13)),ADD(ory%,ADD(divbi&(1,8,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,9,9),5)),ADD(ory%,ADD(divbi&(1,9,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,9,9),13)),ADD(ory%,ADD(divbi&(1,9,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,10,9),5)),ADD(ory%,ADD(divbi&(1,10,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,10,9),13)),ADD(ory%,ADD(divbi&(1,10,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,14,9),6)),ADD(ory%,ADD(divbi&(1,14,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,15,9),6)),ADD(ory%,ADD(divbi&(1,15,9),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,16,9),9)),ADD(ory%,ADD(divbi&(1,16,9),2)),3,5,0,13,12,14)
  GOSUB affchaine_trans("RESAMPLE",ADD(SHL(orc%,1),2),ADD(ory%,82),14)
  GOSUB affchaine_trans("SHRINK/EXPND",ADD(SHL(orc%,1),2),ADD(ory%,107),14)
  GOSUB affchaine_trans("SAMPLE FREQUENCY",ADD(SHL(orc%,1),30),ADD(ory%,82),14)
  GOSUB affchaine_trans("SAMPLE NOTE  DISP:",ADD(SHL(orc%,1),30),ADD(ory%,107),14)
  GOSUB affchaine_trans("INTERPOLATION",ADD(SHL(orc%,1),71),ADD(ory%,82),14)
  GOSUB affchaine_trans("FFT     NOTE:",ADD(SHL(orc%,1),100),ADD(ory%,82),14)
  GOSUB affchaine_trans("DISPLAY",ADD(SHL(orc%,1),132),ADD(ory%,82),14)
  GOSUB affchaine_trans("WINDOW",ADD(SHL(orc%,1),132),ADD(ory%,107),14)
  GOSUB se.sm_actsm_freq
  GOSUB affiche_fft
RETURN
PROCEDURE se.sm_actsm_freq
  LOCAL a%,a$
  se.freq_fft_pend%=MIN(se.freq_fft_pend%,SHR(freq_buffer%,1))
  se.freq_fft_pstart%=MIN(se.freq_fft_pstart%,se.freq_fft_pend%)
  GOSUB affchaine_notrans(STR$(freq_buffer%,5),ADD(orc%,ADD(divbi&(0,8,9),5)),ADD(ory%,ADD(divbi&(1,8,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_nfe%,5),ADD(orc%,ADD(divbi&(0,8,9),13)),ADD(ory%,ADD(divbi&(1,8,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_ofn%,5),ADD(orc%,ADD(divbi&(0,10,9),5)),ADD(ory%,ADD(divbi&(1,10,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_nfn%,5),ADD(orc%,ADD(divbi&(0,10,9),13)),ADD(ory%,ADD(divbi&(1,10,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_fft_pstart%,5),ADD(orc%,ADD(divbi&(0,14,9),6)),ADD(ory%,ADD(divbi&(1,14,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_fft_pend%,5),ADD(orc%,ADD(divbi&(0,15,9),6)),ADD(ory%,ADD(divbi&(1,15,9),2)),1)
  GOSUB affchaine_notrans(STR$(se.freq_fft_pnbr%,4),ADD(orc%,ADD(divbi&(0,16,9),9)),ADD(ory%,ADD(divbi&(1,16,9),2)),1)
  a%=FN freq2note(se.freq_ofn%)
  a$=TRIM$(MID$(gamme2$,SUCC(SHL(ADD(a%,120) MOD 12,1)),2))+" "+STR$(SUB(DIV(a%,12),2))
  a$=SPACE$(SUB(5,LEN(a$)))+a$
  GOSUB affchaine_notrans(a$,ADD(orc%,ADD(divbi&(0,9,9),5)),ADD(ory%,ADD(divbi&(1,9,9),2)),1)
  a%=FN freq2note(se.freq_nfn%)
  a$=TRIM$(MID$(gamme2$,SUCC(SHL(ADD(a%,120) MOD 12,1)),2))+" "+STR$(SUB(DIV(a%,12),2))
  a$=SPACE$(SUB(5,LEN(a$)))+a$
  GOSUB affchaine_notrans(a$,ADD(orc%,ADD(divbi&(0,9,9),13)),ADD(ory%,ADD(divbi&(1,9,9),2)),1)
  GOSUB affiche_icone_b(11,9,orc%,ory%,se.freq_iptype%=0)       ! None
  GOSUB affiche_icone_b(12,9,orc%,ory%,se.freq_iptype%=1)       ! Linear
  GOSUB affiche_icone_b(13,9,orc%,ory%,se.freq_iptype%=2)       ! 3rd degree
  GOSUB affiche_icone_b(17,9,orc%,ory%,se.freq_fftdisp%=0)      ! Linear FFT disp
  GOSUB affiche_icone_b(18,9,orc%,ory%,se.freq_fftdisp%=1)      ! dB FFT disp
  GOSUB affiche_icone_b(19,9,orc%,ory%,se.freq_fftwin%=0)       ! Window : none
  GOSUB affiche_icone_b(20,9,orc%,ory%,se.freq_fftwin%=1)       ! Window : Blackman
  GOSUB affiche_icone_b(21,9,orc%,ory%,se.freq_fftnoteon!)      ! Voyant pour la visibilite de la note sur la FFT
  GOSUB affiche_icone_b(22,9,orc%,ory%,se.freq_fft_cflag!)      ! Voyant pour le calcul de la note lors de la FFT
  GOSUB grise_icone(13,9,orc%,ory%)
  SHOWM
RETURN
PROCEDURE se.sm_gere_freq               !!!
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, d%, i%, a, flag_relachement!, aaaa$
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:9,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 8                    ! Freq -> Freq
        IF SUB(SHR(xm2%,3),divbi&(0,8,9))<11
          GOSUB edite_chaine(STR$(freq_buffer%,5),ADD(orc%,ADD(divbi&(0,8,9),5)),ADD(ory%,ADD(divbi&(1,8,9),2)),5,2)
          IF VAL(bbbb$)>=2000 AND VAL(bbbb$)<=65535
            freq_buffer%=VAL(bbbb$)
            GOSUB affiche_sample
          ENDIF
        ELSE
          GOSUB edite_chaine(STR$(se.freq_nfe%,5),ADD(orc%,ADD(divbi&(0,8,9),13)),ADD(ory%,ADD(divbi&(1,8,9),2)),5,2)
          IF VAL(bbbb$)>=2000 AND VAL(bbbb$)<=65535
            se.freq_nfe%=VAL(bbbb$)
          ENDIF
        ENDIF
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 9                    ! Note -> Note
        IF SUB(SHR(xm2%,3),divbi&(0,9,9))<11
          a%=FN freq2note(se.freq_ofn%)
          b%=5
        ELSE
          a%=FN freq2note(se.freq_nfn%)
          b%=13
        ENDIF
        a$=TRIM$(MID$(gamme2$,SUCC(SHL(ADD(a%,120) MOD 12,1)),2))+" "+STR$(SUB(DIV(a%,12),2))
        a$=SPACE$(SUB(5,LEN(a$)))+a$
        GOSUB edite_chaine(a$,ADD(orc%,ADD(divbi&(0,9,9),b%)),ADD(ory%,ADD(divbi&(1,9,9),2)),5,0)
        a%=1
        WHILE a%<=7
          EXIT IF INSTR(UPPER$(bbbb$),MID$("CDEFGAB",a%,1))<>0
          INC a%
        WEND
        IF a%<=7
          b%=SUB(VAL("$"+MID$("024579B",a%,1)),INSTR(bbbb$,"#")<>0)     ! Numero de la note
          a%=-2
          WHILE a%<=9
            EXIT IF INSTR(bbbb$,STR$(a%))<>0
            INC a%
          WEND
          IF a%<=9
            ADD b%,MUL(ADD(a%,2),12)
            a%=FN note2freq(b%)
            IF SUB(SHR(xm2%,3),divbi&(0,9,9))<11
              se.freq_ofn%=a%
            ELSE
              se.freq_nfn%=a%
            ENDIF
          ENDIF
        ENDIF
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 10                   ! Freq note -> Freq note
        IF SUB(SHR(xm2%,3),divbi&(0,10,9))<11
          GOSUB edite_chaine(STR$(se.freq_ofn%,5),ADD(orc%,ADD(divbi&(0,10,9),5)),ADD(ory%,ADD(divbi&(1,10,9),2)),5,2)
          IF VAL(bbbb$)>8 AND VAL(bbbb$)<65535
            se.freq_ofn%=VAL(bbbb$)
          ENDIF
        ELSE
          GOSUB edite_chaine(STR$(se.freq_nfn%,5),ADD(orc%,ADD(divbi&(0,10,9),13)),ADD(ory%,ADD(divbi&(1,10,9),2)),5,2)
          IF VAL(bbbb$)>8 AND VAL(bbbb$)<65535
            se.freq_nfn%=VAL(bbbb$)
          ENDIF
        ENDIF
        GOSUB affiche_fft
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 11 TO 13             ! Type d'interpolation
        se.freq_iptype%=MIN(SUB(srt%,11),1)     ! *** 3eme degre non encore disponible
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 14                   ! FFT : Start
        GOSUB edite_chaine(STR$(se.freq_fft_pstart%,5),ADD(orc%,ADD(divbi&(0,14,9),6)),ADD(ory%,ADD(divbi&(1,14,9),2)),5,2)
        se.freq_fft_pstart%=MIN(se.freq_fft_pend%,MAX(0,VAL(bbbb$)))
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 15                   ! FFT : End
        GOSUB edite_chaine(STR$(se.freq_fft_pend%,5),ADD(orc%,ADD(divbi&(0,15,9),6)),ADD(ory%,ADD(divbi&(1,15,9),2)),5,2)
        se.freq_fft_pend%=MAX(se.freq_fft_pstart%,MIN(SHR(freq_buffer%,1),VAL(bbbb$)))
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 16                   ! FFT : Nbr of points
        GOSUB edite_chaine(STR$(se.freq_fft_pnbr%,5),ADD(orc%,ADD(divbi&(0,16,9),9)),ADD(ory%,ADD(divbi&(1,16,9),2)),4,2)
        se.freq_fft_pnbr%=MIN(1024,MAX(1,VAL(bbbb$)))
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 17                   ! Affichage FFT lineaire
        se.freq_fftdisp%=0
        GOSUB affiche_fft
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 18                   ! Affichage FFT logarithmique
        se.freq_fftdisp%=1
        GOSUB affiche_fft
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 19                   ! Fenetrage FFT rectangulaire
        se.freq_fftwin%=0
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 20                   ! Fenetrage FFT Blackman
        se.freq_fftwin%=1
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 21                   ! Voyant pour la note sur la FFT
        se.freq_fftnoteon!=NOT se.freq_fftnoteon!
        GOSUB affiche_fft
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      CASE 22                   ! Calcul note on/off
        se.freq_fft_cflag!=NOT se.freq_fft_cflag!
        GOSUB se.sm_actsm_freq
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,9,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0                  ! Convert
          IF km%=2      ! Si c'est le bouton droit, on change simplement la freq d'ech
            a%=DIV(MUL(freq_buffer%,se.freq_nfn%),se.freq_ofn%)
            IF a%<=65535 AND a%>=2000
              se.freq_nfe%=a%
              se.freq_ofn%=se.freq_nfn%
              GOSUB se.change_buffer_frequency(a%,TRUE)
            ENDIF
          ELSE
            a=(se.freq_nfe%*se.freq_ofn%)/(freq_buffer%*se.freq_nfn%)     ! Rapport d'agrandissement
            a%=mark_len%
            b%=(a%*a) AND -2
            IF a>1
              GOSUB dialog("RESAMPLE","NEW SAMPLE TOO LONG","CLIP|OVERFLOW",xm%,ym%)
              IF bouton%=0      ! Clip
                b%=mark_len%
              ELSE              ! Overflow
                b%=MIN(b%,SUB(FN lon_buffer,mark_1%))
              ENDIF
              a%=(b%/a) AND -2
            ENDIF
            GOSUB bee(TRUE)
            c%=ADD(FN adr_buffer,mark_1%)
            ~C:g_change_sample_frequency%(L:c%,L:c%,L:a%,L:b%,W:win_bits%,W:se.freq_iptype%)
            se.freq_ofn%=se.freq_nfn%
            mark_2%=ADD(mark_1%,mark_len%)
            mark_len%=b%
            GOSUB se.change_buffer_frequency(se.freq_nfe%,FALSE)
            GOSUB affiche_panneau_sample
          ENDIF
          ' ------------------------------------------------------------------
        CASE 1 TO 3             ! /2 /3 /4
          IF DIV(freq_buffer%,SUCC(srt%))>=2000
            se.freq_nfe%=DIV(freq_buffer%,SUCC(srt%))
            se.freq_nfn%=se.freq_ofn%
            GOSUB se.sm_actsm_freq
          ENDIF
          ' ------------------------------------------------------------------
        CASE 4 TO 6             ! x2 x3 x4
          IF MUL(freq_buffer%,SUB(srt%,2))<=65535
            se.freq_nfe%=MUL(freq_buffer%,SUB(srt%,2))
            se.freq_nfn%=se.freq_ofn%
            GOSUB se.sm_actsm_freq
          ENDIF
          ' ------------------------------------------------------------------
        CASE 7                  ! Do FFT
          IF km%=2                      ! Bouton droit : on reinitialise la gamme
            se.freq_fft_pstart%=0
            se.freq_fft_pend%=SHR(freq_buffer%,1)
          ENDIF
          GOSUB se.sm_actsm_freq
          GOSUB bee(TRUE)
          b%=ADD(FN adr_buffer,mark_1%)
          ' Fenetrage Blackman
          IF se.freq_fftwin%=1
            c%=FRE(0)
            IF mark_len%<SUB(c%,32768)
              c%=1
              DIM blackman%(SHR(mark_len%,2))
              a%=V:blackman%(0)
              IF win_bits%=2            ! 16 bits
                a=PI*4/SUB(mark_len%,2)
                FOR i%=0 TO PRED(SHR(mark_len%,1))
                  INT{a%}=INT{b%}*(0.42-COS(i%*a)*0.5+0.08*COS(SHL(i%,1)*a))
                  ADD a%,2
                  ADD b%,2
                NEXT i%
              ELSE                      ! 8 bits
                a=PI*2/PRED(mark_len%)
                FOR i%=0 TO PRED(mark_len%)
                  d%=BYTE{b%}
                  IF d%>127
                    SUB d%,256
                  ENDIF
                  BYTE{a%}=d%*(0.42-COS(i%*a)*0.5+0.08*COS(SHL(i%,1)*a))
                  INC a%
                  INC b%
                NEXT i%
              ENDIF
              b%=V:blackman%(0)
            ELSE
              c%=0
            ENDIF
          ELSE
            c%=0
          ENDIF
          ' Calcul proprement dit
          a%=FN se.sm_fft_tot(se.freq_fft_pstart%,se.freq_fft_pend%,freq_buffer%,se.freq_fft_pnbr%,b%,mark_len%,win_bits%,se.freq_fft_cflag!,TRUE)
          IF c%=1
            FOR i%=0 TO PRED(se.freq_fftlon%)
              fft&(i%)=MAX(MIN(fft&(i%)/0.42,&H7FFF),0)
            NEXT i%
            ERASE blackman%()
          ENDIF
          IF a%>0
            se.freq_ofn%=a%
          ENDIF
          GOSUB affiche_panneau_sample
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,9,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
' Delay
PROCEDURE se.sm_affsm_delay
  ' Utilise i%
  GOSUB cadre_int(orc%,ADD(ory%,80),40,29,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,41),ADD(ory%,80),38,49,13,13,14,12)
  GOSUB cadre_int(orc%,ADD(ory%,110),20,29,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,21),ADD(ory%,110),7,29,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,30,10,orc%,ory%)
  FOR i%=0 TO 3
    GOSUB affchaine_trans(STR$(SUCC(i%)),ADD(SHL(orc%,1),84),ADD(ADD(ory%,87),MUL(i%,10)),14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,ADD(MUL(i%,3),1),10),11)),ADD(ory%,ADD(divbi&(1,ADD(MUL(i%,3),1),10),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,ADD(MUL(i%,3),2),10),6)),ADD(ory%,ADD(divbi&(1,ADD(MUL(i%,3),2),10),2)),4,5,0,13,12,14)
  NEXT i%
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,12,10),14)),ADD(ory%,ADD(divbi&(1,12,10),2)),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,15,10),1)),ADD(ory%,ADD(divbi&(1,15,10),2)),27,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,17,10),10)),ADD(ory%,ADD(divbi&(1,17,10),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,18,10),10)),ADD(ory%,ADD(divbi&(1,18,10),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,19,10),12)),ADD(ory%,ADD(divbi&(1,19,10),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,20,10),12)),ADD(ory%,ADD(divbi&(1,20,10),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,23,10),1)),ADD(ory%,ADD(divbi&(1,23,10),2)),4,5,0,13,12,14)
  GOSUB se.sm_actsm_delay
RETURN
PROCEDURE se.sm_actsm_delay
  ' Utilise aaaa$, i%
  se.delay_timefeed%=MIN(se.delay_timefeed%,SUB(FRE(0),16384)*1000/MUL(freq_buffer%,win_bits%))
  FOR i%=0 TO 3
    se.delaytime%(i%)=MIN(se.delaytime%(i%),SUB(FRE(0),16384)*1000/MUL(freq_buffer%,win_bits%))
    GOSUB affiche_icone_b(MUL(i%,3),10,orc%,ory%,BTST(se.delay_flags%,i%))
    GOSUB affchaine_notrans(STR$(se.delaytime%(i%),5),ADD(orc%,ADD(divbi&(0,ADD(MUL(i%,3),1),10),11)),ADD(ory%,ADD(divbi&(1,ADD(MUL(i%,3),1),10),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.delaylevel%(i%),32768),ADD(orc%,ADD(divbi&(0,ADD(MUL(i%,3),2),10),6)),ADD(ory%,ADD(divbi&(1,ADD(MUL(i%,3),2),10),2)),1)
  NEXT i%
  GOSUB affchaine_notrans(FN pourcent$(se.delay_feedback%,32768),ADD(orc%,ADD(divbi&(0,17,10),10)),ADD(ory%,ADD(divbi&(1,17,10),2)),1)
  GOSUB affchaine_notrans(STR$(se.delay_timefeed%,5),ADD(orc%,ADD(divbi&(0,18,10),10)),ADD(ory%,ADD(divbi&(1,18,10),2)),1)
  GOSUB affchaine_notrans(FN pourcent$(se.delay_dry%,32768),ADD(orc%,ADD(divbi&(0,19,10),12)),ADD(ory%,ADD(divbi&(1,19,10),2)),1)
  GOSUB affchaine_notrans(FN pourcent$(se.delay_wet%,32768),ADD(orc%,ADD(divbi&(0,20,10),12)),ADD(ory%,ADD(divbi&(1,20,10),2)),1)
  GOSUB affchaine_notrans(STR$(se.delay_mutein%,5),ADD(orc%,ADD(divbi&(0,23,10),1)),ADD(ory%,ADD(divbi&(1,23,10),2)),1)
  IF se.delay_source%=0
    GOSUB affchaine_notrans("  ",ADD(orc%,ADD(divbi&(0,12,10),14)),ADD(ory%,ADD(divbi&(1,12,10),2)),1)
    aaaa$="Block                       "
  ELSE
    GOSUB affchaine_notrans(HEX$(se.delay_source%,2),ADD(orc%,ADD(divbi&(0,12,10),14)),ADD(ory%,ADD(divbi&(1,12,10),2)),1)
    aaaa$=FN samplename$(se.delay_source%)
  ENDIF
  GOSUB affchaine_notrans(aaaa$,ADD(orc%,ADD(divbi&(0,15,10),1)),ADD(ory%,ADD(divbi&(1,15,10),2)),1)
  GOSUB affiche_icone_b(21,10,orc%,ory%,se.delay_flags% AND &H10)
  GOSUB affiche_icone_b(22,10,orc%,ory%,se.delay_flags% AND &H20)
  SHOWM
RETURN
PROCEDURE se.sm_gere_delay
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, aaaa$, flag_relachement!
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:10,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 0,3,6,9              ! Tap On/Off
        se.delay_flags%=se.delay_flags% XOR SHL(1,DIV(srt%,3))
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 1,4,7,10             ! Tap delay time
        a%=DIV(PRED(srt%),3)
        GOSUB edite_chaine(STR$(se.delaytime%(a%),5),ADD(orc%,ADD(divbi&(0,srt%,10),11)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,2)
        se.delaytime%(a%)=MAX(VAL(bbbb$),0)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 2,5,8,11             ! Tap level
        a%=DIV(SUB(srt%,2),3)
        GOSUB edite_chaine(FN pourcent$(se.delaylevel%(a%),32768),ADD(orc%,ADD(divbi&(0,srt%,10),6)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,3)
        se.delaylevel%(a%)=DIV(MIN(MAX(VAL(bbbb$),0),999.9)*32768,100)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 12                   ! Sample source
        IF km%=1
          GOSUB edite_chaine(HEX$(se.delay_source%,2),ADD(orc%,ADD(divbi&(0,srt%,10),14)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),2,0)
          se.delay_source%=VAL("$"+bbbb$)
        ELSE
          se.delay_source%=sample%
        ENDIF
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 13,14                ! Sample source +/-
        se.delay_source%=MAX(MIN(ADD(se.delay_source%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,13),km%))),255),0)
        GOSUB se.sm_actsm_delay
        IF km%=1
          PAUSE 4
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 17                   ! Feedback
        GOSUB edite_chaine(FN pourcent$(se.delay_feedback%,32768),ADD(orc%,ADD(divbi&(0,srt%,10),10)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,3)
        se.delay_feedback%=DIV(MIN(MAX(VAL(bbbb$),0),999.9)*32768,100)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 18                   ! Time Feed
        GOSUB edite_chaine(STR$(se.delay_timefeed%,5),ADD(orc%,ADD(divbi&(0,srt%,10),10)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,2)
        se.delay_timefeed%=MAX(VAL(bbbb$),1)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 19                   ! Dry level
        GOSUB edite_chaine(FN pourcent$(se.delay_dry%,32768),ADD(orc%,ADD(divbi&(0,srt%,10),12)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,3)
        se.delay_dry%=DIV(MIN(MAX(VAL(bbbb$),0),999.9)*32768,100)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 20                   ! Wet level
        GOSUB edite_chaine(FN pourcent$(se.delay_wet%,32768),ADD(orc%,ADD(divbi&(0,srt%,10),12)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,3)
        se.delay_wet%=DIV(MIN(MAX(VAL(bbbb$),0),999.9)*32768,100)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 21                   ! Multi-tap mode
        se.delay_flags%=se.delay_flags% XOR &H10
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 22                   ! Mute in On/Off
        se.delay_flags%=se.delay_flags% XOR &H20
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 23                   ! Mute in : Time
        GOSUB edite_chaine(STR$(se.delay_mutein%,5),ADD(orc%,ADD(divbi&(0,srt%,10),1)),ADD(ory%,ADD(divbi&(1,srt%,10),2)),5,2)
        se.delay_mutein%=MAX(VAL(bbbb$),0)
        GOSUB se.sm_actsm_delay
        ' --------------------------------------------------------------------
      CASE 15                   ! Indicateur du nom du sample : rien...
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,10,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 24 TO 29           ! Presets 1-6
          a%=SUCC(MUL(SUB(srt%,24),4))
          se.delay_feedback%=DIV(MUL(32768,VAL(MID$("70  50  20  50  70  95",a%,4))),100)
          se.delay_timefeed%=VAL(MID$("150 500 1000500 800 10",a%,4))
          se.delay_dry%=MUL(32768,-(srt%<>28))
          se.delay_wet%=DIV(MUL(32768,VAL(MID$("30  30  30  20  100 95",a%,4))),100)
          se.delay_flags%=&H0
          IF srt%=27
            se.delay_flags%=&H11
            se.delaytime%(0)=1200
            se.delaylevel%(0)=32768
          ELSE IF srt%=28
            se.delay_flags%=&H1F
            se.delaytime%(0)=0
            se.delaylevel%(0)=32768
            se.delaytime%(1)=200
            se.delaylevel%(1)=16384
            se.delaytime%(2)=400
            se.delaylevel%(2)=9830
            se.delaytime%(3)=600
            se.delaylevel%(3)=6553
          ENDIF
          GOSUB se.sm_actsm_delay
          ' ------------------------------------------------------------------
        CASE 16                 ! Do
          GOSUB se.sm_actsm_delay
          IF (NOT BTST(se.delay_flags%,4)) OR (se.delay_flags% AND &HF)
            GOSUB bee(TRUE)
            a%=SHL(INT(se.delay_timefeed%*freq_buffer%/1000),1)
            b%=a%
            FOR i%=0 TO 3
              IF BTST(se.delay_flags%,i%) AND BTST(se.delay_flags%,4)
                b%=MAX(b%,SHL(INT(se.delaytime%(i%)*freq_buffer%/1000),1))
              ENDIF
            NEXT i%
            SUB b%,a%
            DIM dlybuf%(SHR(ADD(a%,MAX(b%,2)),2))
            aaaa$=STRING$(48,0)
            IF se.delay_source%=0
              LONG{V:aaaa$}=ADD(FN adr_buffer,mark_1%)
              LONG{ADD(V:aaaa$,16)}=mark_len%
              BYTE{ADD(V:aaaa$,44)}=win_bits%
            ELSE
              LONG{V:aaaa$}=FN adresse(se.delay_source%)
              LONG{ADD(V:aaaa$,16)}=FN length(se.delay_source%)
              BYTE{ADD(V:aaaa$,44)}=FN resol(se.delay_source%)
            ENDIF
            LONG{ADD(V:aaaa$,4)}=ADD(FN adr_buffer,mark_1%)
            LONG{ADD(V:aaaa$,8)}=V:dlybuf%(0)
            LONG{ADD(V:aaaa$,12)}=ADD(V:dlybuf%(0),SUCC(a%) AND -2)
            LONG{ADD(V:aaaa$,20)}=mark_len%
            LONG{ADD(V:aaaa$,24)}=SHL(se.delay_feedback%,1)
            LONG{ADD(V:aaaa$,28)}=a%
            LONG{ADD(V:aaaa$,32)}=b%
            LONG{ADD(V:aaaa$,36)}=SHL(se.delay_dry%,1)
            IF BTST(se.delay_flags%,5)
              LONG{ADD(V:aaaa$,40)}=INT(se.delay_mutein%*freq_buffer%/1000)
            ELSE
              LONG{ADD(V:aaaa$,40)}=&H7FFFFFFF
            ENDIF
            BYTE{ADD(V:aaaa$,45)}=win_bits%
            IF BTST(se.delay_flags%,4)
              c%=0
              FOR i%=0 TO 3
                IF BTST(se.delay_flags%,i%)
                  aaaa$=aaaa$+MKL$(SHL(INT(se.delaytime%(i%)*freq_buffer%/1000),1))+MKL$(se.delaylevel%(i%)*se.delay_wet%/16384)
                  INC c%
                ENDIF
              NEXT i%
              CARD{ADD(V:aaaa$,46)}=c%
            ELSE
              CARD{ADD(V:aaaa$,46)}=1
              aaaa$=aaaa$+MID$(aaaa$,29,4)+MKL$(SHL(se.delay_wet%,1))
            ENDIF
            GOSUB affiche_panneau_progression("Please wait...",LONG{ADD(V:aaaa$,16)},-1,-1)
            c%=V:aaaa$
            ~C:g_fx_delay%(L:c%)
            WHILE LONG{g_progression_pos%}<LONG{g_progression_len%}
              GOSUB affiche_progression(LONG{g_progression_pos%})
              ~C:g_fx_delay%(L:0)
            WEND
            ERASE dlybuf%()
            GOSUB affiche_panneau_sample
          ENDIF
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,10,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
' Flanger
PROCEDURE se.sm_affsm_flanger
  IF ss_menu2.fl%=2
    GOSUB se.sm_affsm_flanger2
  ELSE
    GOSUB cadre_int(orc%,ADD(ory%,80),15,59,13,13,14,12)
    GOSUB cadre_int(ADD(orc%,16),ADD(ory%,80),21,59,13,13,14,12)
    GOSUB cadre_int(ADD(orc%,38),ADD(ory%,80),21,59,13,13,14,12)
    GOSUB cadre_int(ADD(orc%,60),ADD(ory%,80),19,29,13,13,14,12)
    GOSUB affiche_bloc_icones_b(0,16,19,orc%,ory%)
    GOSUB affchaine_trans("FLANGER",ADD(SHL(orc%,1),2),ADD(ory%,87),14)
    GOSUB affchaine_trans("MIX",ADD(SHL(orc%,1),34),ADD(ory%,87),14)
    GOSUB affchaine_trans("PARAMETERS",ADD(SHL(orc%,1),78),ADD(ory%,87),14)
    GOSUB affchaine_trans("PRESETS",ADD(SHL(orc%,1),122),ADD(ory%,87),14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,4,19),13)),ADD(ory%,ADD(divbi&(1,4,19),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,5,19),13)),ADD(ory%,ADD(divbi&(1,5,19),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,6,19),12)),ADD(ory%,ADD(divbi&(1,6,19),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,7,19),12)),ADD(ory%,ADD(divbi&(1,7,19),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,8,19),13)),ADD(ory%,ADD(divbi&(1,8,19),2)),3,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,9,19),12)),ADD(ory%,ADD(divbi&(1,9,19),2)),4,5,0,13,12,14)
    GOSUB se.sm_actsm_flanger
  ENDIF
RETURN
PROCEDURE se.sm_actsm_flanger
  ' Var locales de Sample_Editor utilisees:
  ' i%
  IF ss_menu2.fl%=2
    GOSUB se.sm_actsm_flanger2
  ELSE
    GOSUB affchaine_notrans(FN pourcent$(se.flanger_dry%,32768),ADD(orc%,ADD(divbi&(0,4,19),13)),ADD(ory%,ADD(divbi&(1,4,19),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.flanger_wet%,32768),ADD(orc%,ADD(divbi&(0,5,19),13)),ADD(ory%,ADD(divbi&(1,5,19),2)),1)
    GOSUB affchaine_notrans(STR$(se.flanger_time%/1000,5),ADD(orc%,ADD(divbi&(0,6,19),12)),ADD(ory%,ADD(divbi&(1,6,19),2)),1)
    GOSUB affchaine_notrans(STR$(se.flanger_freq%/1000,5),ADD(orc%,ADD(divbi&(0,7,19),12)),ADD(ory%,ADD(divbi&(1,7,19),2)),1)
    GOSUB affchaine_notrans(STR$(se.flanger_depth%/1000,4),ADD(orc%,ADD(divbi&(0,8,19),13)),ADD(ory%,ADD(divbi&(1,8,19),2)),1)
    GOSUB affchaine_notrans(STR$(se.flanger_phase%/2048+0.000488,5),ADD(orc%,ADD(divbi&(0,9,19),12)),ADD(ory%,ADD(divbi&(1,9,19),2)),1)
    FOR i%=10 TO 15
      GOSUB grise_icone(i%,19,orc%,ory%)
    NEXT i%
  ENDIF
RETURN
PROCEDURE se.sm_gere_flanger
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, i%, j%, a$, b$, aaaa$, flag_relachement!
  ~FRE(0)
  IF ss_menu2.fl%=2
    GOSUB se.sm_gere_flanger2
  ELSE
    IF km%>0
      a%=V:divbi&(0,0,0)
      srt%=C:g_teste_icones%(L:a%,W:19,W:xm2%,W:ym2%)
      IF srt%>=0
        SELECT srt%
          ' Radio-boutons, Flip-flops ou champs de texte
          ' ------------------------------------------------------------------
        CASE 4          ! Dry level
          GOSUB edite_chaine(FN pourcent$(se.flanger_dry%,32768),ADD(orc%,ADD(divbi&(0,4,19),13)),ADD(ory%,ADD(divbi&(1,4,19),2)),5,3)
          se.flanger_dry%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        CASE 5          ! Flange level
          GOSUB edite_chaine(FN pourcent$(se.flanger_wet%,32768),ADD(orc%,ADD(divbi&(0,5,19),13)),ADD(ory%,ADD(divbi&(1,5,19),2)),5,3)
          se.flanger_wet%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        CASE 6          ! Flange time
          GOSUB edite_chaine(STR$(se.flanger_time%/1000,5),ADD(orc%,ADD(divbi&(0,6,19),12)),ADD(ory%,ADD(divbi&(1,6,19),2)),5,3)
          se.flanger_time%=MIN(MAX(VAL(bbbb$)*1000,0),50000)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        CASE 7          ! Flange freq
          GOSUB edite_chaine(STR$(se.flanger_freq%/1000,5),ADD(orc%,ADD(divbi&(0,7,19),12)),ADD(ory%,ADD(divbi&(1,7,19),2)),5,3)
          se.flanger_freq%=MIN(MAX(VAL(bbbb$)*1000,0),50000)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        CASE 8          ! Flange depth
          GOSUB edite_chaine(STR$(se.flanger_depth%/1000,4),ADD(orc%,ADD(divbi&(0,8,19),13)),ADD(ory%,ADD(divbi&(1,8,19),2)),4,3)
          se.flanger_depth%=MIN(MAX(VAL(bbbb$)*1000,0),99999)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        CASE 9          ! Init phase
          GOSUB edite_chaine(STR$(se.flanger_phase%/2048+0.000488,5),ADD(orc%,ADD(divbi&(0,9,19),12)),ADD(ory%,ADD(divbi&(1,9,19),2)),5,3)
          se.flanger_phase%=MIN(MAX(VAL(bbbb$)*2048,0),4095)
          GOSUB se.sm_actsm_flanger
          ' ------------------------------------------------------------------
        DEFAULT
          ' Icones normales
          GOSUB affiche_icone_b(srt%,19,orc%,ory%,-1)
          GOSUB wait_mouse(TRUE)
          SELECT srt%
            ' ----------------------------------------------------------------
          CASE 0        ! 2nd page
            ss_menu2.fl%=2
            ' ----------------------------------------------------------------
          CASE 1,2,3    ! Calcul
            IF se.flanger_stereo!
              GOSUB se.sm_do_flanger(srt%)
            ELSE
              GOSUB se.sm_do_flanger(0)
            ENDIF
            GOSUB affiche_panneau_sample
            ' ----------------------------------------------------------------
          CASE 10 TO 15 ! Presets
            '
            '
            '
            '
            ' ----------------------------------------------------------------
          ENDSELECT
          GOSUB affiche_icone_b(srt%,19,orc%,ory%,0)
        ENDSELECT
        GOSUB wait_mouse(flag_relachement!)
        flag_relachement!=TRUE
        GOSUB vide_buffer_clavier
        IF ss_menu2.fl%<>1
          GOSUB sample_editor.affiche_sm
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_affsm_flanger2
  GOSUB cadre_int(orc%,ADD(ory%,80),51,29,13,13,14,12)
  GOSUB cadre_int(orc%,ADD(ory%,110),51,29,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,52),ADD(ory%,80),13,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,66),ADD(ory%,80),13,29,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,13,20,orc%,ory%)
  GOSUB affchaine_trans("FEEDBACK",ADD(SHL(orc%,1),3),ADD(ory%,97),14)
  GOSUB affchaine_trans("FEEDBACK",ADD(SHL(orc%,1),3),ADD(ory%,127),14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,1,20),13)),ADD(ory%,ADD(divbi&(1,1,20),2)),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,4,20),1)),ADD(ory%,ADD(divbi&(1,4,20),2)),27,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,5,20),13)),ADD(ory%,ADD(divbi&(1,5,20),2)),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,8,20),1)),ADD(ory%,ADD(divbi&(1,8,20),2)),27,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,9,20),14)),ADD(ory%,ADD(divbi&(1,9,20),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,10,20),13)),ADD(ory%,ADD(divbi&(1,10,20),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,11,20),14)),ADD(ory%,ADD(divbi&(1,11,20),2)),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,12,20),13)),ADD(ory%,ADD(divbi&(1,12,20),2)),4,5,0,13,12,14)
  GOSUB se.sm_actsm_flanger2
RETURN
PROCEDURE se.sm_actsm_flanger2
  GOSUB affchaine_notrans(FN pourcent$(se.flanger_fdbkll%,32768),ADD(orc%,ADD(divbi&(0,9,20),14)),ADD(ory%,ADD(divbi&(1,9,20),2)),1)
  IF se.flanger_lsource%>0
    a$=HEX$(se.flanger_lsource%,2)
    b$=FN samplename$(se.flanger_lsource%)
  ELSE
    a$="  "
    b$="Block"+SPACE$(23)
  ENDIF
  GOSUB affchaine_notrans(a$,ADD(orc%,ADD(divbi&(0,1,20),13)),ADD(ory%,ADD(divbi&(1,1,20),2)),1)
  GOSUB affchaine_notrans(b$,ADD(orc%,ADD(divbi&(0,4,20),1)),ADD(ory%,ADD(divbi&(1,4,20),2)),1)
  IF se.flanger_stereo!
    GOSUB affchaine_notrans(FN pourcent$(se.flanger_fdbklr%,32768),ADD(orc%,ADD(divbi&(0,10,20),13)),ADD(ory%,ADD(divbi&(1,10,20),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.flanger_fdbkrr%,32768),ADD(orc%,ADD(divbi&(0,11,20),14)),ADD(ory%,ADD(divbi&(1,11,20),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.flanger_fdbkrl%,32768),ADD(orc%,ADD(divbi&(0,12,20),13)),ADD(ory%,ADD(divbi&(1,12,20),2)),1)
    IF se.flanger_rsource%>0
      a$=HEX$(se.flanger_rsource%,2)
      b$=FN samplename$(se.flanger_rsource%)
    ELSE
      a$="  "
      b$="Block"+SPACE$(23)
    ENDIF
  ELSE
    GOSUB affchaine_notrans("     ",ADD(orc%,ADD(divbi&(0,10,20),13)),ADD(ory%,ADD(divbi&(1,10,20),2)),1)
    GOSUB affchaine_notrans("     ",ADD(orc%,ADD(divbi&(0,11,20),14)),ADD(ory%,ADD(divbi&(1,11,20),2)),1)
    GOSUB affchaine_notrans("     ",ADD(orc%,ADD(divbi&(0,12,20),13)),ADD(ory%,ADD(divbi&(1,12,20),2)),1)
    a$="  "
    b$=SPACE$(28)
  ENDIF
  GOSUB affchaine_notrans(a$,ADD(orc%,ADD(divbi&(0,5,20),13)),ADD(ory%,ADD(divbi&(1,5,20),2)),1)
  GOSUB affchaine_notrans(b$,ADD(orc%,ADD(divbi&(0,8,20),1)),ADD(ory%,ADD(divbi&(1,8,20),2)),1)
  GOSUB affiche_icone_b(13,20,orc%,ory%,NOT se.flanger_stereo!)
  GOSUB affiche_icone_b(14,20,orc%,ory%,se.flanger_stereo!)
  FOR i%=0 TO 4
    GOSUB affiche_icone_b(ADD(i%,15),20,orc%,ory%,se.flanger_wave%=i%)
  NEXT i%
RETURN
PROCEDURE se.sm_gere_flanger2
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, aaaa$, flag_relachement!
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:20,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 1            ! Numero du sample gauche
        IF km%=1
          GOSUB edite_chaine(HEX$(se.flanger_lsource%,2),ADD(orc%,ADD(divbi&(0,1,20),13)),ADD(ory%,ADD(divbi&(1,1,20),2)),2,1)
          se.flanger_lsource%=VAL("$"+bbbb$)
        ELSE
          se.flanger_lsource%=sample%
        ENDIF
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 2,3          ! Sample gauche +/-
        se.flanger_lsource%=MAX(MIN(ADD(se.flanger_lsource%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,2),km%))),255),0)
        GOSUB se.sm_actsm_flanger2
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 5            ! Numero du sample droit
        IF km%=1
          GOSUB edite_chaine(HEX$(se.flanger_rsource%,2),ADD(orc%,ADD(divbi&(0,5,20),13)),ADD(ory%,ADD(divbi&(1,5,20),2)),2,1)
          se.flanger_rsource%=VAL("$"+bbbb$)
        ELSE
          se.flanger_rsource%=sample%
        ENDIF
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 6,7          ! Sample droit +/-
        se.flanger_rsource%=MAX(MIN(ADD(se.flanger_rsource%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,6),km%))),255),0)
        GOSUB se.sm_actsm_flanger2
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 9            ! Feedback L -> L
        GOSUB edite_chaine(FN pourcent$(se.flanger_fdbkll%,32768),ADD(orc%,ADD(divbi&(0,9,20),14)),ADD(ory%,ADD(divbi&(1,9,20),2)),5,3)
        se.flanger_fdbkll%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 10           ! Feedback L -> R
        GOSUB edite_chaine(FN pourcent$(se.flanger_fdbklr%,32768),ADD(orc%,ADD(divbi&(0,10,20),13)),ADD(ory%,ADD(divbi&(1,10,20),2)),5,3)
        se.flanger_fdbklr%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 11           ! Feedback R -> R
        GOSUB edite_chaine(FN pourcent$(se.flanger_fdbkrr%,32768),ADD(orc%,ADD(divbi&(0,11,20),14)),ADD(ory%,ADD(divbi&(1,11,20),2)),5,3)
        se.flanger_fdbkrr%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 12           ! Feedback R -> L
        GOSUB edite_chaine(FN pourcent$(se.flanger_fdbkrl%,32768),ADD(orc%,ADD(divbi&(0,12,20),13)),ADD(ory%,ADD(divbi&(1,12,20),2)),5,3)
        se.flanger_fdbkrl%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 13           ! Mono
        se.flanger_stereo!=FALSE
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 14           ! Stereo
        se.flanger_stereo!=TRUE
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      CASE 15 TO 19     ! Type d'onde
        se.flanger_wave%=SUB(srt%,15)
        GOSUB se.sm_actsm_flanger2
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,20,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0          ! 1st page
          ss_menu2.fl%=1
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,20,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
      IF ss_menu2.fl%<>2
        GOSUB sample_editor.affiche_sm
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_do_flanger(type%)
  LOCAL a%,amp%,i%,tbuf%,time%
  LOCAL a$,b$
  LOCAL a
  ' Calcul de la table de sinus
  a$=STRING$(8192,0)
  SELECT se.flanger_wave%
  CASE 0                                        ! Sinus
    a=PI/2048
    a%=V:a$
    FOR i%=0 TO 1024
      INT{a%}=ROUND(SIN(i%*a)*4096)
      ADD a%,2
    NEXT i%
    a%=ADD(V:a$,2050)
    FOR i%=4 TO 4092 STEP 4
      INT{a%}=INT{SUB(a%,i%)}
      ADD a%,2
    NEXT i%
    a%=ADD(V:a$,4094)
    FOR i%=0 TO 2048
      INT{a%}=-INT{SUB(a%,4096)}
      ADD a%,2
    NEXT i%
  CASE 1                                        ! Carre
    FOR i%=V:a$ TO ADD(V:a$,4094) STEP 2
      CARD{i%}=4096
    NEXT i%
    FOR i%=ADD(V:a$,4096) TO ADD(V:a$,8190) STEP 2
      CARD{i%}=-4096
    NEXT i%
  CASE 2                                        ! Triangle
    a%=0
    FOR i%=V:a$ TO ADD(V:a$,2046) STEP 2
      CARD{i%}=a%
      ADD a%,4
    NEXT i%
    FOR i%=ADD(V:a$,2048) TO ADD(V:a$,6142) STEP 2
      CARD{i%}=a%
      SUB a%,4
    NEXT i%
    FOR i%=ADD(V:a$,6144) TO ADD(V:a$,8190) STEP 2
      CARD{i%}=a%
      ADD a%,4
    NEXT i%
  CASE 3                                        ! Ramp down
    a%=0
    FOR i%=V:a$ TO ADD(V:a$,4094) STEP 2
      CARD{i%}=a%
      SUB a%,2
    NEXT i%
    a%=4096
    FOR i%=ADD(V:a$,4096) TO ADD(V:a$,8190) STEP 2
      CARD{i%}=a%
      SUB a%,2
    NEXT i%
  CASE 4                                        ! Ramp up
    a%=0
    FOR i%=V:a$ TO ADD(V:a$,4094) STEP 2
      CARD{i%}=a%
      ADD a%,2
    NEXT i%
    a%=-4096
    FOR i%=ADD(V:a$,4096) TO ADD(V:a$,8190) STEP 2
      CARD{i%}=a%
      ADD a%,2
    NEXT i%
  ENDSELECT
  amp%=se.flanger_depth%*freq_buffer%/1000000 AND -2
  time%=MAX(ADD(se.flanger_time%*freq_buffer%/500000,amp%) AND -2,4)
  tbuf%=ADD(time%,amp%)
  DIM buffer1%(SHR(tbuf%,2)),buffer2%(SHR(tbuf%,2))
  ' Bloc d'infos pour le flanger
  b$=STRING$(256,0)
  LONG{V:b$}=FN se.sm_adresse_sample(se.flanger_lsource%)
  LONG{ADD(V:b$,4)}=FN se.sm_adresse_sample(se.flanger_rsource%)
  LONG{ADD(V:b$,8)}=ADD(FN adr_buffer,mark_1%)
  LONG{ADD(V:b$,12)}=V:buffer1%(0)
  LONG{ADD(V:b$,16)}=V:buffer2%(0)
  LONG{ADD(V:b$,20)}=V:a$
  LONG{ADD(V:b$,24)}=FN se.sm_longueur_sample(se.flanger_lsource%)
  LONG{ADD(V:b$,28)}=FN se.sm_longueur_sample(se.flanger_rsource%)
  LONG{ADD(V:b$,32)}=mark_len%
  LONG{ADD(V:b$,36)}=tbuf%
  CARD{ADD(V:b$,40)}=FN se.sm_resol_sample(se.flanger_lsource%)
  CARD{ADD(V:b$,42)}=FN se.sm_resol_sample(se.flanger_rsource%)
  CARD{ADD(V:b$,44)}=win_bits%
  LONG{ADD(V:b$,48)}=SHL(se.flanger_fdbkll%,1)
  LONG{ADD(V:b$,52)}=SHL(se.flanger_fdbklr%,1)
  LONG{ADD(V:b$,56)}=SHL(se.flanger_fdbkrl%,1)
  LONG{ADD(V:b$,60)}=SHL(se.flanger_fdbkrr%,1)
  LONG{ADD(V:b$,64)}=SHL(se.flanger_dry%,1)
  LONG{ADD(V:b$,68)}=SHL(se.flanger_dry%,1)
  LONG{ADD(V:b$,72)}=SHL(se.flanger_wet%,1)
  LONG{ADD(V:b$,76)}=SHL(se.flanger_wet%,1)
  LONG{ADD(V:b$,80)}=&H10000000*se.flanger_freq%/MUL(freq_buffer%,1000)
  LONG{ADD(V:b$,84)}=amp%
  LONG{ADD(V:b$,88)}=time%
  CARD{ADD(V:b$,92)}=se.flanger_phase%
  SELECT type%
  CASE 0                        ! Mono
    CARD{ADD(V:b$,46)}=1
    LONG{ADD(V:b$,52)}=0                        ! Fdbklr = 0
    LONG{ADD(V:b$,56)}=0                        ! Fdbkrl = 0
    LONG{ADD(V:b$,68)}=0                        ! Dryr = 0
    LONG{ADD(V:b$,76)}=0                        ! Wetr = 0
  CASE 1                        ! Left
    CARD{ADD(V:b$,46)}=1
  CASE 2                        ! Right
    CARD{ADD(V:b$,46)}=2
  CASE 3                        ! Mix
    CARD{ADD(V:b$,46)}=7
  ENDSELECT
  '
  GOSUB affiche_panneau_progression("Please wait...",LONG{ADD(V:b$,32)},-1,-1)
  a%=V:b$
  ~C:g_fx_stereo_flanger%(L:a%)
  WHILE LONG{g_progression_pos%}<LONG{g_progression_len%}
    GOSUB affiche_progression(LONG{g_progression_pos%})
    ~C:g_fx_stereo_flanger%(L:0)
  WEND
  ERASE buffer1%(),buffer2%()
  ~FRE(0)
RETURN
' Reverb
PROCEDURE se.sm_affsm_reverb
  IF ss_menu2.rev%=2
    GOSUB se.sm_affsm_reverb2
  ELSE
    GOSUB cadre_int(orc%,ADD(ory%,80),24,19,13,13,14,12)
    GOSUB cadre_int(orc%,ADD(ory%,100),24,39,13,13,14,12)
    GOSUB cadre_int(ADD(orc%,25),ADD(ory%,80),23,39,13,13,14,12)
    GOSUB cadre_int(ADD(orc%,49),ADD(ory%,80),23,39,13,13,14,12)
    GOSUB affiche_bloc_icones_b(0,16,21,orc%,ory%)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,2,21),16)),ADD(ory%,ADD(divbi&(1,2,21),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,3,21),16)),ADD(ory%,ADD(divbi&(1,3,21),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,4,21),16)),ADD(ory%,ADD(divbi&(1,4,21),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,5,21),15)),ADD(ory%,ADD(divbi&(1,5,21),2)),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,8,21),15)),ADD(ory%,ADD(divbi&(1,8,21),2)),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,11,21),15)),ADD(ory%,ADD(divbi&(1,11,21),2)),4,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,12,21),8)),ADD(ory%,ADD(divbi&(1,12,21),2)),1,5,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,15,21),1)),ADD(ory%,ADD(divbi&(1,15,21),2)),27,5,0,13,12,14)
    GOSUB affchaine_trans("EARLY REFLECTION",ADD(SHL(orc%,1),52),ADD(ory%,87),14)
    GOSUB affchaine_trans("COMB FILTERS",ADD(SHL(orc%,1),100),ADD(ory%,87),14)
    GOSUB se.sm_actsm_reverb
  ENDIF
RETURN
PROCEDURE se.sm_actsm_reverb
  IF ss_menu2.rev%=2
    GOSUB se.sm_actsm_reverb2
  ELSE
    GOSUB affchaine_notrans(FN pourcent$(se.rev_drylevel%,32768),ADD(orc%,ADD(divbi&(0,2,21),16)),ADD(ory%,ADD(divbi&(1,2,21),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.rev_revlevel%,32768),ADD(orc%,ADD(divbi&(0,3,21),16)),ADD(ory%,ADD(divbi&(1,3,21),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.rev_ereflevel%,32768),ADD(orc%,ADD(divbi&(0,4,21),16)),ADD(ory%,ADD(divbi&(1,4,21),2)),1)
    GOSUB affchaine_notrans(STR$(se.rev_nbrtaps%,2),ADD(orc%,ADD(divbi&(0,5,21),15)),ADD(ory%,ADD(divbi&(1,5,21),2)),1)
    GOSUB affchaine_notrans(STR$(se.rev_nbrcomb%,2),ADD(orc%,ADD(divbi&(0,8,21),15)),ADD(ory%,ADD(divbi&(1,8,21),2)),1)
    GOSUB affchaine_notrans(FN pourcent$(se.rev_combgain%,32768),ADD(orc%,ADD(divbi&(0,11,21),15)),ADD(ory%,ADD(divbi&(1,11,21),2)),1)
    IF se.rev_source%>0
      GOSUB affchaine_notrans(HEX$(se.rev_source%,2),ADD(orc%,ADD(divbi&(0,12,21),8)),ADD(ory%,ADD(divbi&(1,12,21),2)),1)
      GOSUB affchaine_notrans(FN samplename$(se.rev_source%),ADD(orc%,ADD(divbi&(0,15,21),1)),ADD(ory%,ADD(divbi&(1,15,21),2)),1)
    ELSE
      GOSUB affchaine_notrans("  ",ADD(orc%,ADD(divbi&(0,12,21),8)),ADD(ory%,ADD(divbi&(1,12,21),2)),1)
      GOSUB affchaine_notrans("Block"+SPACE$(23),ADD(orc%,ADD(divbi&(0,15,21),1)),ADD(ory%,ADD(divbi&(1,15,21),2)),1)
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_gere_reverb
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, i%, j%, a$, flag_relachement!
  LOCAL freq_buf_real
  ~FRE(0)
  IF ss_menu2.rev%=2
    GOSUB se.sm_gere_reverb2
  ELSE
    IF km%>0
      a%=V:divbi&(0,0,0)
      srt%=C:g_teste_icones%(L:a%,W:21,W:xm2%,W:ym2%)
      IF srt%>=0
        SELECT srt%
          ' Radio-boutons, Flip-flops ou champs de texte
          ' ------------------------------------------------------------------
        CASE 2                  ! Dry level
          GOSUB edite_chaine(FN pourcent$(se.rev_drylevel%,32768),ADD(orc%,ADD(divbi&(0,2,21),16)),ADD(ory%,ADD(divbi&(1,2,21),2)),5,3)
          se.rev_drylevel%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 3                  ! Reverb level
          GOSUB edite_chaine(FN pourcent$(se.rev_revlevel%,32768),ADD(orc%,ADD(divbi&(0,3,21),16)),ADD(ory%,ADD(divbi&(1,3,21),2)),5,3)
          se.rev_revlevel%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 4                  ! Early reflection level
          GOSUB edite_chaine(FN pourcent$(se.rev_ereflevel%,32768),ADD(orc%,ADD(divbi&(0,4,21),16)),ADD(ory%,ADD(divbi&(1,4,21),2)),5,3)
          se.rev_ereflevel%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 5                  ! Nombre de taps
          GOSUB edite_chaine(STR$(se.rev_nbrtaps%,2),ADD(orc%,ADD(divbi&(0,5,21),15)),ADD(ory%,ADD(divbi&(1,5,21),2)),2,2)
          se.rev_nbrtaps%=MIN(MAX(VAL(bbbb$),1),16)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 6,7                ! Nombre de taps +/-
          se.rev_nbrtaps%=MAX(MIN(ADD(se.rev_nbrtaps%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,6),km%))),16),1)
          GOSUB se.sm_actsm_reverb
          IF km%=1
            PAUSE 8
          ENDIF
          flag_relachement!=FALSE
          ' ------------------------------------------------------------------
        CASE 8                  ! Nombre de comb filters
          GOSUB edite_chaine(STR$(se.rev_nbrcomb%,2),ADD(orc%,ADD(divbi&(0,8,21),15)),ADD(ory%,ADD(divbi&(1,8,21),2)),2,2)
          se.rev_nbrcomb%=MIN(MAX(VAL(bbbb$),1),8)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 9,10               ! Nombre de comb filters +/-
          se.rev_nbrcomb%=MAX(MIN(ADD(se.rev_nbrcomb%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,9),km%))),8),1)
          GOSUB se.sm_actsm_reverb
          IF km%=1
            PAUSE 8
          ENDIF
          flag_relachement!=FALSE
          ' ------------------------------------------------------------------
        CASE 11                 ! Gain general de combs
          GOSUB edite_chaine(FN pourcent$(se.rev_combgain%,32768),ADD(orc%,ADD(divbi&(0,11,21),15)),ADD(ory%,ADD(divbi&(1,11,21),2)),5,3)
          se.rev_combgain%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 12                 ! Sample source
          GOSUB edite_chaine(HEX$(se.rev_source%,2),ADD(orc%,ADD(divbi&(0,12,21),8)),ADD(ory%,ADD(divbi&(1,12,21),2)),2,2)
          se.rev_source%=MIN(MAX(VAL("$"+bbbb$),0),255)
          GOSUB se.sm_actsm_reverb
          ' ------------------------------------------------------------------
        CASE 13,14              ! Source +/-
          se.rev_source%=MAX(MIN(ADD(se.rev_source%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,13),km%))),255),0)
          GOSUB se.sm_actsm_reverb
          IF km%=1
            PAUSE 8
          ENDIF
          flag_relachement!=FALSE
          ' ------------------------------------------------------------------
        CASE 15                 ! Nom du sample source
          ' Aucun effet
          ' ------------------------------------------------------------------
        DEFAULT
          ' Icones normales
          GOSUB affiche_icone_b(srt%,21,orc%,ory%,-1)
          GOSUB wait_mouse(TRUE)
          SELECT srt%
            ' ----------------------------------------------------------------
          CASE 0                ! 2nd page
            ss_menu2.rev%=2
            ' ----------------------------------------------------------------
          CASE 1                ! Reverberation
            GOSUB bee(TRUE)
            SHOWM
            ' Calcule la longueur totale de tous les buffers
            b%=0                                ! Longueur totale
            FOR i%=0 TO PRED(se.rev_nbrtaps%)
              b%=MAX(b%,se.rev_tapdelay%(i%))
            NEXT i%
            freq_buf_real=freq_buffer%
            a%=ADD(ADD(INT(freq_buf_real*b%/500000),2),1023) AND -1024
            se.rev_buffer$(0)=STRING$(a%,0)
            a%=ADD(INT(freq_buf_real*se.rev_adlydelay%/500000),1023) AND -1024
            se.rev_buffer$(1)=STRING$(a%,0)
            a%=ADD(INT(freq_buf_real*se.rev_aprdelay%/500000),1023) AND -1024
            se.rev_buffer$(2)=STRING$(a%,0)
            FOR i%=0 TO PRED(se.rev_nbrcomb%)
              a%=ADD(INT(freq_buf_real*se.rev_combdelay%(i%)/500000),1023) AND -1024
              se.rev_buffer$(ADD(i%,3))=STRING$(a%,0)
            NEXT i%
            a$=STRING$(4096,0)
            ' Creation du bloc de parametres
            IF se.rev_source%>0
              LONG{V:a$}=FN adresse(se.rev_source%)
              LONG{ADD(V:a$,8)}=FN length(se.rev_source%)
              CARD{ADD(V:a$,16)}=FN resol(se.rev_source%)
            ELSE
              LONG{V:a$}=ADD(FN adr_buffer,mark_1%)
              LONG{ADD(V:a$,8)}=mark_len%
              CARD{ADD(V:a$,16)}=win_bits%
            ENDIF
            LONG{ADD(V:a$,4)}=ADD(FN adr_buffer,mark_1%)
            LONG{ADD(V:a$,12)}=mark_len%
            CARD{ADD(V:a$,18)}=win_bits%
            LONG{ADD(V:a$,20)}=SHL(se.rev_drylevel%,1)
            LONG{ADD(V:a$,24)}=SHL(se.rev_ereflevel%,1)
            LONG{ADD(V:a$,28)}=SHL(se.rev_revlevel%,1)
            LONG{ADD(V:a$,32)}=V:se.rev_buffer$(0)
            LONG{ADD(V:a$,36)}=LEN(se.rev_buffer$(0))
            LONG{ADD(V:a$,40)}=V:se.rev_buffer$(1)
            LONG{ADD(V:a$,44)}=LEN(se.rev_buffer$(1))
            LONG{ADD(V:a$,48)}=V:se.rev_buffer$(2)
            LONG{ADD(V:a$,52)}=LEN(se.rev_buffer$(2))
            LONG{ADD(V:a$,56)}=SHL(se.rev_aprg%,1)
            LONG{ADD(V:a$,60)}=-SHL(se.rev_aprg%,1)
            LONG{ADD(V:a$,64)}=SUB(65536,INT(se.rev_aprg%*se.rev_aprg%/16384))  ! 1 - g^2
            CARD{ADD(V:a$,68)}=se.rev_nbrtaps%
            FOR i%=0 TO PRED(se.rev_nbrtaps%)   ! On rajoute 1 sample au delay, c'est normal ------v
              LONG{ADD(V:a$,ADD(70,SHL(i%,3)))}=ADD(INT(freq_buf_real*se.rev_tapdelay%(i%)/500000),3) AND -2
              LONG{ADD(V:a$,ADD(74,SHL(i%,3)))}=SHL(se.rev_taplevel%(i%),1)
            NEXT i%
            CARD{ADD(V:a$,198)}=se.rev_nbrcomb%
            FOR i%=0 TO PRED(se.rev_nbrcomb%)
              LONG{ADD(V:a$,ADD(200,MUL(i%,28)))}=V:se.rev_buffer$(ADD(i%,3))
              LONG{ADD(V:a$,ADD(204,MUL(i%,28)))}=LEN(se.rev_buffer$(ADD(i%,3)))
              a%=SUCC(INT(freq_buf_real*se.rev_combdelay%(i%)/500000)) AND -2
              LONG{ADD(V:a$,ADD(208,MUL(i%,28)))}=a%
              a%=INT(se.rev_combgain%*(SUB(32768,se.rev_comblpf%(i%))/16384))
              LONG{ADD(V:a$,ADD(212,MUL(i%,28)))}=a%
              LONG{ADD(V:a$,ADD(216,MUL(i%,28)))}=SHL(se.rev_comblpf%(i%),1)
            NEXT i%
            LONG{ADD(V:a$,424)}=SUCC(INT(freq_buf_real*se.rev_aprdelay%/500000)) AND -2
            LONG{ADD(V:a$,428)}=SUCC(INT(freq_buf_real*se.rev_adlydelay%/500000)) AND -2
            '
            GOSUB affiche_panneau_progression("Please wait...",LONG{ADD(V:a$,12)},-1,-1)
            a%=V:a$
            ~C:g_reverberation%(L:a%)
            WHILE LONG{g_progression_pos%}<LONG{g_progression_len%}
              GOSUB affiche_progression(LONG{g_progression_pos%})
              ~C:g_reverberation%(L:0)
            WEND
            '
            FOR i%=0 TO ADD(se.rev_nbrcomb%,2)
              se.rev_buffer$(i%)=""
            NEXT i%
            ~FRE(0)
            GOSUB bee(FALSE)
            GOSUB affiche_panneau_sample
            ' ----------------------------------------------------------------
          ENDSELECT
          GOSUB affiche_icone_b(srt%,21,orc%,ory%,0)
        ENDSELECT
        GOSUB wait_mouse(flag_relachement!)
        flag_relachement!=TRUE
        GOSUB vide_buffer_clavier
        IF ss_menu2.rev%<>1
          GOSUB sample_editor.affiche_sm
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_affsm_reverb2
  ' Var locales de Sample_Editor :
  ' i%
  GOSUB cadre_int(orc%,ADD(ory%,80),18,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,19),ADD(ory%,80),18,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,38),ADD(ory%,80),29,29,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,38),ADD(ory%,110),29,29,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,1,22,orc%,ory%)
  GOSUB affiche_bloc_icones_b(4,2,22,orc%,ory%)
  GOSUB affiche_bloc_icones_b(9,5,22,orc%,ory%)
  FOR i%=1 TO 6 STEP 5
    GOSUB cadre_ext(ADD(orc%,divbi&(0,i%,22)),ADD(ory%,divbi&(1,i%,22)),1,41,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,divbi&(0,SUCC(i%),22)),ADD(ory%,divbi&(1,SUCC(i%),22)),4,41,0,13,12,14)
    GOSUB cadre_ext(ADD(orc%,divbi&(0,ADD(i%,2),22)),ADD(ory%,divbi&(1,ADD(i%,2),22)),4,41,0,13,12,14)
  NEXT i%
  FOR i%=11 TO 13
    GOSUB cadre_ext(ADD(orc%,ADD(divbi&(0,i%,22),6)),ADD(ory%,ADD(divbi&(1,i%,22),2)),4,5,0,13,12,14)
  NEXT i%
  GOSUB affchaine_trans("EARLY REFLECTION",ADD(SHL(orc%,1),2),ADD(ory%,82),14)
  GOSUB affchaine_trans("COMB FILTERS",ADD(SHL(orc%,1),40),ADD(ory%,82),14)
  GOSUB affchaine_trans("#",ADD(SHL(orc%,1),3),ADD(ory%,134),14)
  GOSUB affchaine_trans("DELAY",ADD(SHL(orc%,1),8),ADD(ory%,134),14)
  GOSUB affchaine_trans("GAIN",ADD(SHL(orc%,1),21),ADD(ory%,134),14)
  GOSUB affchaine_trans("#",ADD(SHL(orc%,1),41),ADD(ory%,134),14)
  GOSUB affchaine_trans("DELAY",ADD(SHL(orc%,1),46),ADD(ory%,134),14)
  GOSUB affchaine_trans("LPF",ADD(SHL(orc%,1),60),ADD(ory%,134),14)
  GOSUB affchaine_trans("ALL PASS REVERB",ADD(SHL(orc%,1),78),ADD(ory%,87),14)
  GOSUB affchaine_trans("ALIGNEMENT DELAY",ADD(SHL(orc%,1),78),ADD(ory%,117),14)
  GOSUB se.sm_actsm_reverb2
RETURN
PROCEDURE se.sm_actsm_reverb2
  ' Var locales de Sample_Editor :
  ' a%, b%, c%, i%
  a%=se.rev_tappos%
  b%=se.rev_combpos%
  FOR i%=0 TO 36 STEP 6
    IF a%<16
      IF a%<se.rev_nbrtaps%
        c%=1
      ELSE
        c%=12
      ENDIF
      GOSUB affchaine_notrans(STR$(SUCC(a%),2),ADD(orc%,divbi&(0,1,22)),ADD(ory%,ADD(divbi&(1,1,22),i%)),c%)
      GOSUB affchaine_notrans(STR$(se.rev_tapdelay%(a%)/1000,5),ADD(orc%,divbi&(0,2,22)),ADD(ory%,ADD(divbi&(1,2,22),i%)),c%)
      GOSUB affchaine_notrans(FN pourcent$(se.rev_taplevel%(a%),32768),ADD(orc%,divbi&(0,3,22)),ADD(ory%,ADD(divbi&(1,3,22),i%)),c%)
    ELSE
      GOSUB affchaine_notrans(SPACE$(2),ADD(orc%,divbi&(0,1,22)),ADD(ory%,ADD(divbi&(1,1,22),i%)),1)
      GOSUB affchaine_notrans(SPACE$(5),ADD(orc%,divbi&(0,2,22)),ADD(ory%,ADD(divbi&(1,2,22),i%)),1)
      GOSUB affchaine_notrans(SPACE$(5),ADD(orc%,divbi&(0,3,22)),ADD(ory%,ADD(divbi&(1,3,22),i%)),1)
    ENDIF
    IF b%<8
      IF b%<se.rev_nbrcomb%
        c%=1
      ELSE
        c%=12
      ENDIF
      GOSUB affchaine_notrans(STR$(SUCC(b%),2),ADD(orc%,divbi&(0,6,22)),ADD(ory%,ADD(divbi&(1,6,22),i%)),c%)
      GOSUB affchaine_notrans(STR$(se.rev_combdelay%(b%)/1000,5),ADD(orc%,divbi&(0,7,22)),ADD(ory%,ADD(divbi&(1,7,22),i%)),c%)
      GOSUB affchaine_notrans(FN pourcent$(se.rev_comblpf%(b%),32768),ADD(orc%,divbi&(0,8,22)),ADD(ory%,ADD(divbi&(1,8,22),i%)),c%)
    ELSE
      GOSUB affchaine_notrans(SPACE$(2),ADD(orc%,divbi&(0,6,22)),ADD(ory%,ADD(divbi&(1,6,22),i%)),1)
      GOSUB affchaine_notrans(SPACE$(5),ADD(orc%,divbi&(0,7,22)),ADD(ory%,ADD(divbi&(1,7,22),i%)),1)
      GOSUB affchaine_notrans(SPACE$(5),ADD(orc%,divbi&(0,8,22)),ADD(ory%,ADD(divbi&(1,8,22),i%)),1)
    ENDIF
    INC a%
    INC b%
  NEXT i%
  GOSUB affchaine_notrans(STR$(se.rev_aprdelay%/1000,5),ADD(orc%,ADD(divbi&(0,11,22),6)),ADD(ory%,ADD(divbi&(1,11,22),2)),1)
  GOSUB affchaine_notrans(FN pourcent$(se.rev_aprg%,32768),ADD(orc%,ADD(divbi&(0,12,22),6)),ADD(ory%,ADD(divbi&(1,12,22),2)),1)
  GOSUB affchaine_notrans(STR$(se.rev_adlydelay%/1000,5),ADD(orc%,ADD(divbi&(0,13,22),6)),ADD(ory%,ADD(divbi&(1,13,22),2)),1)
RETURN
PROCEDURE se.sm_gere_reverb2
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, b%, c%, aaaa$, flag_relachement!
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:22,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 2            ! Tap delay
        a%=DIV(SUB(ym2%,divbi&(1,srt%,22)),6)
        b%=ADD(a%,se.rev_tappos%)
        GOSUB edite_chaine(STR$(se.rev_tapdelay%(b%)/1000,5),ADD(orc%,divbi&(0,srt%,22)),ADD(ory%,ADD(divbi&(1,srt%,22),MUL(a%,6))),5,3)
        se.rev_tapdelay%(b%)=MAX(MIN(VAL(bbbb$)*1000,250000),0)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 3            ! Tap level
        a%=DIV(SUB(ym2%,divbi&(1,srt%,22)),6)
        b%=ADD(a%,se.rev_tappos%)
        GOSUB edite_chaine(FN pourcent$(se.rev_taplevel%(b%),32768),ADD(orc%,divbi&(0,srt%,22)),ADD(ory%,ADD(divbi&(1,srt%,22),MUL(a%,6))),5,3)
        se.rev_taplevel%(b%)=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 4,5          ! Position +/- dans liste des taps
        se.rev_tappos%=MAX(MIN(SUB(se.rev_tappos%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,4),km%))),9),0)
        GOSUB se.sm_actsm_reverb2
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 7            ! Comb delay
        a%=DIV(SUB(ym2%,divbi&(1,srt%,22)),6)
        b%=ADD(a%,se.rev_combpos%)
        GOSUB edite_chaine(STR$(se.rev_combdelay%(b%)/1000,5),ADD(orc%,divbi&(0,srt%,22)),ADD(ory%,ADD(divbi&(1,srt%,22),MUL(a%,6))),5,3)
        se.rev_combdelay%(b%)=MAX(MIN(VAL(bbbb$)*1000,250000),0)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 8            ! Comb LPF gain
        a%=DIV(SUB(ym2%,divbi&(1,srt%,22)),6)
        b%=ADD(a%,se.rev_combpos%)
        GOSUB edite_chaine(FN pourcent$(se.rev_comblpf%(b%),32768),ADD(orc%,divbi&(0,srt%,22)),ADD(ory%,ADD(divbi&(1,srt%,22),MUL(a%,6))),5,3)
        se.rev_comblpf%(b%)=DIV(32768*MIN(MAX(VAL(bbbb$),0),100),100)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 9,10         ! Position +/- dans liste des comb filters
        se.rev_combpos%=MAX(MIN(SUB(se.rev_combpos%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,9),km%))),1),0)
        GOSUB se.sm_actsm_reverb2
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 11           ! APR delay
        GOSUB edite_chaine(STR$(se.rev_aprdelay%/1000,5),ADD(orc%,ADD(divbi&(0,srt%,22),6)),ADD(ory%,ADD(divbi&(1,srt%,22),2)),5,3)
        se.rev_aprdelay%=MAX(MIN(VAL(bbbb$)*1000,250000),0)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 12           ! APR gain
        GOSUB edite_chaine(FN pourcent$(se.rev_aprg%,32768),ADD(orc%,ADD(divbi&(0,srt%,22),6)),ADD(ory%,ADD(divbi&(1,srt%,22),2)),5,3)
        se.rev_aprg%=DIV(32768*MIN(MAX(VAL(bbbb$),0),100),100)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 13           ! Alignement delay
        GOSUB edite_chaine(STR$(se.rev_adlydelay%/1000,5),ADD(orc%,ADD(divbi&(0,srt%,22),6)),ADD(ory%,ADD(divbi&(1,srt%,22),2)),5,3)
        se.rev_adlydelay%=MAX(MIN(VAL(bbbb$)*1000,250000),0)
        GOSUB se.sm_actsm_reverb2
        ' --------------------------------------------------------------------
      CASE 1,6          ! Numero de tap/comb
        ' Aucun effet
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,22,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0          ! 1st page
          ss_menu2.rev%=1
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,22,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
      IF ss_menu2.rev%<>2
        GOSUB sample_editor.affiche_sm
      ENDIF
    ENDIF
  ENDIF
RETURN
' Song to disk
PROCEDURE se.sm_affsm_song2disk
  GOSUB cadre_int(orc%,ADD(ory%,80),15,39,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,16),ADD(ory%,80),25,19,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,16),ADD(ory%,100),25,19,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,34),ADD(ory%,80),7,39,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,42),ADD(ory%,80),26,39,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,69),ADD(ory%,80),10,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,57),ADD(ory%,120),11,19,13,13,14,12)
  GOSUB affiche_bloc_icones_b(4,8,23,orc%,ory%)
  GOSUB affiche_bloc_icones_b(20,1,23,orc%,ory%)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,0,23)),ADD(ADD(ory%,divbi&(1,0,23)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,1,23)),ADD(ADD(ory%,divbi&(1,1,23)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,2,23)),ADD(ADD(ory%,divbi&(1,2,23)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(orc%,divbi&(0,3,23)),ADD(ADD(ory%,divbi&(1,3,23)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,10,23)),17),ADD(ADD(ory%,divbi&(1,10,23)),2),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,11,23)),15),ADD(ADD(ory%,divbi&(1,11,23)),2),6,5,0,13,12,14)
  GOSUB affchaine_trans("POS",ADD(SHL(orc%,1),2),ADD(ory%,97),14)
  GOSUB affchaine_trans("LINE",ADD(SHL(orc%,1),2),ADD(ory%,107),14)
  GOSUB affchaine_trans("START",ADD(SHL(orc%,1),12),ADD(ory%,87),14)
  GOSUB affchaine_trans("END",ADD(SHL(orc%,1),24),ADD(ory%,87),14)
  GOSUB affchaine_trans("TO:",ADD(SHL(orc%,1),70),ADD(ory%,87),14)
  GOSUB affchaine_trans("SECURITY",ADD(SHL(orc%,1),86),ADD(ory%,87),14)
  GOSUB affchaine_trans("REC SPEED",ADD(SHL(orc%,1),140),ADD(ory%,87),14)
  GOSUB se.sm_actsm_song2disk
RETURN
PROCEDURE se.sm_actsm_song2disk
  ' Var locales de Sample_Editor utilisees:
  ' i%
  GOSUB affchaine_notrans(HEX$(se.s2d_posstart%,2),ADD(orc%,divbi&(0,0,23)),ADD(ADD(ory%,divbi&(1,0,23)),2),1)
  GOSUB affchaine_notrans(HEX$(se.s2d_posend%,2),ADD(orc%,divbi&(0,1,23)),ADD(ADD(ory%,divbi&(1,1,23)),2),1)
  GOSUB affchaine_notrans(HEX$(se.s2d_ligstart%,2),ADD(orc%,divbi&(0,2,23)),ADD(ADD(ory%,divbi&(1,2,23)),2),1)
  GOSUB affchaine_notrans(HEX$(se.s2d_ligend%,2),ADD(orc%,divbi&(0,3,23)),ADD(ADD(ory%,divbi&(1,3,23)),2),1)
  GOSUB affchaine_notrans(STR$(se.s2d_maxsize%*1024/MUL(freq_buffer%,MUL(se.s2d_bits%,se.s2d_stereo%)),5),ADD(ADD(orc%,divbi&(0,10,23)),17),ADD(ADD(ory%,divbi&(1,10,23)),2),1)
  GOSUB affchaine_notrans(STR$(se.s2d_maxsize%,7),ADD(ADD(orc%,divbi&(0,11,23)),15),ADD(ADD(ory%,divbi&(1,11,23)),2),1)
  GOSUB affiche_icone_b(4,23,orc%,ory%,se.s2d_bits%<>2)
  GOSUB affiche_icone_b(5,23,orc%,ory%,se.s2d_bits%=2)
  GOSUB affiche_icone_b(6,23,orc%,ory%,se.s2d_stereo%<>2)
  GOSUB affiche_icone_b(7,23,orc%,ory%,se.s2d_stereo%=2)
  GOSUB affiche_icone_b(8,23,orc%,ory%,se.s2d_out%<>2)
  GOSUB affiche_icone_b(9,23,orc%,ory%,se.s2d_out%=2)
  GOSUB affiche_icone_b(21,23,orc%,ory%,se.s2d_monitor!)
  FOR i%=0 TO 7
    GOSUB affiche_icone_b(ADD(12,i%),23,orc%,ory%,se.s2d_speed%=i%)
  NEXT i%
  se.s2d_prediv%=VAL("$"+MID$("1234579B",SUCC(se.s2d_speed%),1))
RETURN
PROCEDURE se.sm_gere_song2disk
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, aaaa$, flag_relachement!
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:23,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' --------------------------------------------------------------------
      CASE 0            ! Start pos
        GOSUB edite_chaine(HEX$(se.s2d_posstart%,2),ADD(orc%,divbi&(0,srt%,23)),ADD(ory%,ADD(divbi&(1,srt%,23),2)),2,1)
        se.s2d_posstart%=MIN(MAX(0,VAL("$"+bbbb$)),PRED(FN song_length))
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 1            ! End pos
        GOSUB edite_chaine(HEX$(se.s2d_posend%,2),ADD(orc%,divbi&(0,srt%,23)),ADD(ory%,ADD(divbi&(1,srt%,23),2)),2,1)
        se.s2d_posend%=MIN(MAX(0,VAL("$"+bbbb$)),PRED(FN song_length))
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 2            ! Start line
        GOSUB edite_chaine(HEX$(se.s2d_ligstart%,2),ADD(orc%,divbi&(0,srt%,23)),ADD(ory%,ADD(divbi&(1,srt%,23),2)),2,1)
        se.s2d_ligstart%=MIN(MAX(0,VAL("$"+bbbb$)),PRED(FN nbr_lines(se.s2d_posstart%)))
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 3            ! End line
        GOSUB edite_chaine(HEX$(se.s2d_ligend%,2),ADD(orc%,divbi&(0,srt%,23)),ADD(ory%,ADD(divbi&(1,srt%,23),2)),2,1)
        se.s2d_ligend%=MIN(MAX(0,VAL("$"+bbbb$)),PRED(FN nbr_lines(se.s2d_posend%)))
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 4            ! 8 bits
        se.s2d_bits%=1
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 5            ! 16 bits
        se.s2d_bits%=2
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 6            ! Mono
        se.s2d_stereo%=1
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 7            ! Stereo
        se.s2d_stereo%=2
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 8            ! To block
        se.s2d_out%=1
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 9            ! To sample
        se.s2d_out%=2
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 10           ! Maximum duration
        GOSUB edite_chaine(STR$(se.s2d_maxsize%*1024/MUL(freq_buffer%,MUL(se.s2d_bits%,se.s2d_stereo%)),5),ADD(ADD(orc%,divbi&(0,srt%,23)),17),ADD(ory%,ADD(divbi&(1,srt%,23),2)),5,2)
        se.s2d_maxsize%=MIN(MAX(0,VAL(bbbb$)*MUL(freq_buffer%,MUL(se.s2d_bits%,se.s2d_stereo%))/1024),99999)
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 11           ! Maximum size
        GOSUB edite_chaine(STR$(se.s2d_maxsize%,5),ADD(ADD(orc%,divbi&(0,srt%,23)),15),ADD(ory%,ADD(divbi&(1,srt%,23),2)),7,2)
        se.s2d_maxsize%=MIN(MAX(0,VAL(bbbb$)),3999999)
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 12 TO 19     ! Recording speed
        se.s2d_speed%=SUB(srt%,12)
        se.s2d_prediv%=VAL("$"+MID$("1234579B",SUCC(se.s2d_speed%),1))
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      CASE 21           ! Monitor
        se.s2d_monitor!=NOT se.s2d_monitor!
        GOSUB se.sm_actsm_song2disk
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,23,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 20         ! Record
          IF se.s2d_out%=2
            GOSUB se.sm_record_song_to_disk
          ELSE
            GOSUB se.sm_record_song_to_block
          ENDIF
          se.volume_ok!=FALSE
          GOSUB affiche_panneau_sample
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,23,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_record_song_to_block
  LOCAL ok!
  IF mark_len%<MUL(se.s2d_bits%,se.s2d_stereo%)
    GOSUB dialog("STOP","Block too small.","Cancel",MOUSEX,MOUSEY)
    GOSUB affiche_panneau_sample
  ELSE IF freq_buffer%<12000
    GOSUB dialog("STOP","Recording frequency must be|greater than 12 KHz.","Cancel",MOUSEX,MOUSEY)
    GOSUB affiche_panneau_sample
  ELSE
    ok!=TRUE
    IF se.s2d_monitor! AND freq_buffer%<DIV(DIV(98340,SUCC(se.s2d_prediv%)),3)
      GOSUB dialog("WARNING","Please select a lower recording frequency|to avoid bugs.","Continue|Cancel",MOUSEX,MOUSEY)
      IF bouton%=1
        ok!=FALSE
      ENDIF
      GOSUB affiche_panneau_sample
    ENDIF
    IF ok!
      IF se.s2d_monitor!
        GOSUB se.sm_do_record_song_to_block
      ELSE
        GOSUB se.sm_do_record_song_to_block_norealtime
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE se.sm_do_record_song_to_block
  LOCAL longueur%
  LOCAL sortie!
  GOSUB stop_voices
  GOSUB bee(TRUE)
  '
  ' Preparation des routines d'enregistrement
  '
  longueur%=mark_len% AND -win_bits%
  CARD{ADD(r_songrecord_state%,2)}=se.s2d_posstart%
  CARD{ADD(r_songrecord_state%,4)}=se.s2d_ligstart%
  CARD{ADD(r_songrecord_state%,6)}=se.s2d_posend%
  CARD{ADD(r_songrecord_state%,8)}=se.s2d_ligend%
  LONG{ADD(r_songrecord_state%,10)}=g_rec_sam_buffer%
  LONG{ADD(r_songrecord_state%,14)}=ADD(g_rec_sam_buffer%,4096)
  CARD{ADD(r_songrecord_state%,18)}=se.s2d_2ndtime! AND 1
  CARD{ADD(r_songrecord_state%,24)}=se.s2d_prediv%
  CARD{ADD(r_songrecord_state%,26)}=freq_buffer%
  CARD{ADD(r_songrecord_state%,32)}=1           ! Realtime
  CARD{r_songrecord_state%}=0
  LONG{g_sngrec_paramadr%}=r_songrecord_state%
  LONG{ADD(g_sngrec_paramadr%,4)}=ADD(FN adr_buffer,mark_1%)    ! Adresse du buffer
  LONG{ADD(g_sngrec_paramadr%,8)}=longueur%     ! Taille du buffer
  LONG{ADD(g_sngrec_paramadr%,12)}=0            ! Position du buffer
  LONG{ADD(g_sngrec_paramadr%,16)}=longueur%    ! Taille maxi
  LONG{ADD(g_sngrec_paramadr%,20)}=0            ! Position du sample
  CARD{ADD(g_sngrec_paramadr%,24)}=1            ! Type (1 = bouclage)
  CARD{ADD(g_sngrec_paramadr%,26)}=1            ! Flag (0 = arret)
  CARD{ADD(g_sngrec_paramadr%,28)}=win_bits%
  CARD{ADD(g_sngrec_paramadr%,30)}=1            ! Mono
  songpos%=se.s2d_posstart%
  sortie!=FALSE
  SLPOKE LONG{r_adr_adr_inter%},r_songrecord_routine%
  GOSUB play_song2(0)
  ~C:g_start_song_recording%(W:0)
  '
  ' Boucle d'enregistrement
  '
  REPEAT
    ' Position finale atteinte ?
    IF CARD{r_songrecord_state%}=4
      ~C:g_stop_song_recording%(W:0)
      sortie!=TRUE
    ENDIF
    ' Depasse le temps imparti ou la taille maxi ?
    IF CARD{ADD(g_sngrec_paramadr%,26)}=0
      sortie!=TRUE
    ENDIF
    ' Arret de l'utilisateur ?
    IF GEMDOS(11)<>0
      ~GEMDOS(7)
      sortie!=TRUE
    ENDIF
  UNTIL sortie!
  '
  ' On s'arrete d'enregistrer si on est sorti avant la fin
  '
  IF CARD{ADD(g_sngrec_paramadr%,26)}<>0
    ~C:g_stop_song_recording%(W:0)
  ENDIF
  IF CARD{r_songrecord_state%}<3
    CARD{r_songrecord_state%}=3
  ENDIF
  REPEAT
  UNTIL CARD{r_songrecord_state%}=4 AND CARD{ADD(g_sngrec_paramadr%,26)}=0
  CARD{r_songrecord_state%}=0
  mark_2%=ADD(mark_1%,LONG{ADD(g_sngrec_paramadr%,20)})
  GOSUB stop_voices
  GOSUB bee(FALSE)
RETURN
PROCEDURE se.sm_do_record_song_to_block_norealtime
  LOCAL adr_dest%,convlen1%,convlen2%,framelen%,longueur%,rec_pos%
  LOCAL cur_songpos%,old_songpos%
  LOCAL buffer$
  '
  GOSUB stop_voices
  GOSUB wait_mouse(TRUE)
  GOSUB bee(TRUE)
  '
  GOSUB affiche_panneau_progression("Please wait...",SUB(se.s2d_posend%,se.s2d_posstart%),-1,-1)
  old_songpos%=-1
  '
  ' Prepare l'enregistrement
  '
  buffer$=STRING$(8192,0)                       ! Il faut au moins 1200 * 2 * 2 octets
  longueur%=mark_len% AND -win_bits%
  CARD{ADD(r_songrecord_state%,2)}=se.s2d_posstart%
  CARD{ADD(r_songrecord_state%,4)}=se.s2d_ligstart%
  CARD{ADD(r_songrecord_state%,6)}=se.s2d_posend%
  CARD{ADD(r_songrecord_state%,8)}=se.s2d_ligend%
  LONG{ADD(r_songrecord_state%,10)}=V:buffer$
  CARD{ADD(r_songrecord_state%,18)}=se.s2d_2ndtime! AND 1
  CARD{ADD(r_songrecord_state%,24)}=se.s2d_prediv%
  CARD{ADD(r_songrecord_state%,26)}=freq_buffer%
  CARD{ADD(r_songrecord_state%,32)}=0           ! Pas de realtime
  CARD{r_songrecord_state%}=0
  SLPOKE LONG{r_adr_adr_inter%},r_songrecord_routine%
  songpos%=se.s2d_posstart%
  GOSUB play_song2(0)
  rec_pos%=0                                    ! Position dans l'enregistrement
  REPEAT                                        ! Attend le debut de l'enregistrement
    IF GEMDOS(11)<>0                            ! Arret clavier?
      ~GEMDOS(7)
      CARD{r_songrecord_state%}=3
      GOTO se.sm_do_record_song_to_block_norealtime_end
    ENDIF
    IF MOUSEK=2                                 ! Arret souris?
      CARD{r_songrecord_state%}=3
      GOTO se.sm_do_record_song_to_block_norealtime_end
    ENDIF
  UNTIL CARD{r_songrecord_state%}=2
  '
  ' Boucle d'enregistrement
  '
  WHILE CARD{r_songrecord_state%}=2
    IF rec_pos%>=longueur%                      ! Fin atteinte?
      CARD{r_songrecord_state%}=3
    ENDIF
    IF GEMDOS(11)<>0                            ! Arret clavier?
      ~GEMDOS(7)
      CARD{r_songrecord_state%}=3
    ENDIF
    IF MOUSEK=2                                 ! Arret souris?
      CARD{r_songrecord_state%}=3
    ENDIF
    ~C:rr_songrecord_routine_no_realtime%()
    framelen%=LONG{ADD(r_songrecord_state%,34)}
    convlen1%=MIN(framelen%,DIV(MUL(SUB(longueur%,rec_pos%),4),win_bits%))
    convlen2%=MUL(DIV(convlen1%,4),win_bits%)
    adr_dest%=ADD(FN adr_buffer,ADD(mark_1%,rec_pos%))
    ~C:g_convert_stereo16%(L:V:buffer$,L:adr_dest%,L:convlen1%,W:win_bits%,W:1)
    ADD rec_pos%,convlen2%
    cur_songpos%=CARD{r_mod_songpos%}
    IF cur_songpos%<>old_songpos%
      GOSUB affiche_progression(SUB(cur_songpos%,se.s2d_posstart%))
      old_songpos%=cur_songpos%
    ENDIF
  WEND
se.sm_do_record_song_to_block_norealtime_end:
  GOSUB stop_voices
  mark_2%=ADD(mark_1%,rec_pos%) AND -2
  GOSUB bee(FALSE)
RETURN
PROCEDURE se.sm_record_song_to_disk
  LOCAL erreur%
  LOCAL ok!
  LOCAL nfic$
  erreur%=0
  IF flag_registered!
    IF mark_len%<&H10000
      GOSUB dialog("STOP","Block too small. It must be greater than 64 Ko.|If you have a slow hard drive, the buffer must be as big|as possible, and select the lower recording speed.","Cancel",MOUSEX,MOUSEY)
      GOSUB affiche_panneau_sample
    ELSE IF freq_buffer%<12000
      GOSUB dialog("STOP","Recording frequency must be greater than 12 KHz.|For a low recording frequency, please select a low|recording speed.","Cancel",MOUSEX,MOUSEY)
      GOSUB affiche_panneau_sample
    ELSE
      ok!=TRUE
      IF se.s2d_monitor! AND freq_buffer%<DIV(DIV(98340,SUCC(se.s2d_prediv%)),3)
        GOSUB dialog("WARNING","Please select a lower recording frequency|to avoid bugs.","Continue|Cancel",MOUSEX,MOUSEY)
        IF bouton%=1
          ok!=FALSE
        ENDIF
        GOSUB affiche_panneau_sample
      ENDIF
      IF ok!
        FILESELECT npath_sample$+next_sample$,nfile_sample$,nfic$
        GOSUB affiche_panneau_sample
        IF nfic$<>""
          IF se.s2d_monitor!
            GOSUB se.sm_do_record_song_to_disk(nfic$)
          ELSE
            GOSUB se.sm_do_record_song_to_disk_norealtime(nfic$)
          ENDIF
          GOSUB separe_nom_chemin(nfic$)
          nfile_sample$=nfile_$
          npath_sample$=npath_$
        ENDIF
      ENDIF
    ENDIF
  ELSE
    GOSUB dialog("SHAREWARE!","PLEASE REGISTER","Now!",MOUSEX,MOUSEY)
    GOSUB affiche_panneau_sample
  ENDIF
RETURN
PROCEDURE se.sm_do_record_song_to_disk(nfic$)
  '
  ' Attention, erreurs de disk non reperees!
  '
  LOCAL a%,longueur%,moitie%,next_buffer%,pointeur%
  LOCAL fin!,sortie!
  LOCAL handle_fichier%,code_erreur_fichier%
  LOCAL filename$
  LOCAL b$,npath_$,nfile_$
  GOSUB stop_voices
  GOSUB wait_mouse(TRUE)
  GOSUB bee(TRUE)
  filename$=nfic$+CHR$(0)
  handle_fichier%=GEMDOS(60,L:V:filename$,W:0)
  '
  ' Entete du format .AVR
  '
  IF next_sample$="*.AVR"
    GOSUB separe_nom_chemin(nfic$)      ! Recupere le nom
    b$=LEFT$(nfile_$,8)
    IF INSTR(b$,".")>1
      b$=LEFT$(b$,PRED(INSTR(b$,".")))
      IF LEN(b$)<8
        b$=b$+STRING$(SUB(8,LEN(b$)),0)
      ENDIF
    ENDIF
    b$="2BIT"+b$+MKI$(se.s2d_stereo%=2)+MKI$(SHL(se.s2d_bits%,3))+MKI$(-1)
    b$=b$+MKI$(0)+MKI$(-1)+MKI$(&HFF00)+MKI$(freq_buffer%)+MKL$(0)+MKL$(0)+MKL$(0)      ! Longueur en samples pour 1 canal
    b$=b$+"This sample passed through GRAOUMF TRACKER (c) Laurent de Soras"
    b$=b$+STRING$(SUB(128,LEN(b$)),0)
    code_erreur_fichier%=FN fwrite(handle_fichier%,128,V:b$)
  ENDIF
  '
  ' Preparation des routines d'enregistrement
  '
  longueur%=mark_len% AND -SHL(MUL(se.s2d_bits%,se.s2d_stereo%),1)
  moitie%=SHR(longueur%,1)
  CARD{ADD(r_songrecord_state%,2)}=se.s2d_posstart%
  CARD{ADD(r_songrecord_state%,4)}=se.s2d_ligstart%
  CARD{ADD(r_songrecord_state%,6)}=se.s2d_posend%
  CARD{ADD(r_songrecord_state%,8)}=se.s2d_ligend%
  LONG{ADD(r_songrecord_state%,10)}=g_rec_sam_buffer%
  LONG{ADD(r_songrecord_state%,14)}=ADD(g_rec_sam_buffer%,4096)
  CARD{ADD(r_songrecord_state%,18)}=se.s2d_2ndtime! AND 1
  CARD{ADD(r_songrecord_state%,24)}=se.s2d_prediv%
  CARD{ADD(r_songrecord_state%,26)}=freq_buffer%
  CARD{ADD(r_songrecord_state%,32)}=1           ! Realtime
  CARD{r_songrecord_state%}=0
  LONG{g_sngrec_paramadr%}=r_songrecord_state%
  LONG{ADD(g_sngrec_paramadr%,4)}=ADD(FN adr_buffer,mark_1%)
  LONG{ADD(g_sngrec_paramadr%,8)}=mark_len%
  LONG{ADD(g_sngrec_paramadr%,12)}=0
  LONG{ADD(g_sngrec_paramadr%,16)}=MUL(se.s2d_maxsize%,1024)
  LONG{ADD(g_sngrec_paramadr%,20)}=0
  CARD{ADD(g_sngrec_paramadr%,24)}=1
  CARD{ADD(g_sngrec_paramadr%,26)}=1
  CARD{ADD(g_sngrec_paramadr%,28)}=se.s2d_bits%
  CARD{ADD(g_sngrec_paramadr%,30)}=se.s2d_stereo%
  songpos%=se.s2d_posstart%
  next_buffer%=1
  sortie!=FALSE
  fin!=FALSE
  SLPOKE LONG{r_adr_adr_inter%},r_songrecord_routine%
  GOSUB play_song2(0)
  ~C:g_start_song_recording%(W:0)
  '
  ' Boucle d'enregistrement
  '
  REPEAT
    ' Position finale atteinte ?
    IF CARD{r_songrecord_state%}=4
      ~C:g_stop_song_recording%(W:0)
      sortie!=TRUE
    ENDIF
    ' Depasse le temps imparti ou la taille maxi ?
    IF CARD{ADD(g_sngrec_paramadr%,26)}=0
      sortie!=TRUE
    ENDIF
    ' Arret de l'utilisateur ?
    IF GEMDOS(11)<>0
      ~GEMDOS(7)
      sortie!=TRUE
    ENDIF
    ' On peut sauver un buffer ?
    pointeur%=LONG{ADD(g_sngrec_paramadr%,12)}
    IF next_buffer%=0
      IF pointeur%<moitie%
        code_erreur_fichier%=FN fwrite(handle_fichier%,moitie%,ADD(FN adr_buffer,ADD(mark_1%,moitie%)))
        next_buffer%=1
      ENDIF
    ELSE
      IF pointeur%>=moitie%
        code_erreur_fichier%=FN fwrite(handle_fichier%,moitie%,ADD(FN adr_buffer,mark_1%))
        next_buffer%=0
      ENDIF
    ENDIF
  UNTIL sortie!
  '
  ' On s'arrete d'enregistrer si on est sorti avant la fin
  '
  IF CARD{ADD(g_sngrec_paramadr%,26)}<>0
    ~C:g_stop_song_recording%(W:0)
  ENDIF
  IF CARD{r_songrecord_state%}<3
    CARD{r_songrecord_state%}=3
  ENDIF
  REPEAT
  UNTIL CARD{r_songrecord_state%}=4 AND CARD{ADD(g_sngrec_paramadr%,26)}=0
  CARD{r_songrecord_state%}=0
  GOSUB stop_voices
  '
  ' On sauve le debut du buffer qu'on enregistrait au moment de l'arret
  '
  pointeur%=LONG{ADD(g_sngrec_paramadr%,12)}
  IF next_buffer%=0
    code_erreur_fichier%=FN fwrite(handle_fichier%,SUB(pointeur%,moitie%),ADD(FN adr_buffer,ADD(mark_1%,moitie%)))
  ELSE
    code_erreur_fichier%=FN fwrite(handle_fichier%,pointeur%,ADD(FN adr_buffer,mark_1%))
  ENDIF
  '
  ' Sauve la taille dans l'entete si format .AVR
  '
  IF next_sample$="*.AVR"
    a%=DIV(LONG{ADD(g_sngrec_paramadr%,20)},MUL(se.s2d_bits%,se.s2d_stereo%))   ! Samples pour un canal
    code_erreur_fichier%=GEMDOS(66,L:&H1A,W:handle_fichier%,0)
    code_erreur_fichier%=FN fwrite(handle_fichier%,4,V:a%)      ! Taille totale du sample enregistre
  ENDIF
  '
se.sm_do_record_song_to_disk_end:
  code_erreur_fichier%=GEMDOS(62,W:handle_fichier%)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
  ENDIF
  GOSUB bee(FALSE)
RETURN
PROCEDURE se.sm_do_record_song_to_disk_norealtime(nfic$)
  '
  ' Attention, erreurs de disk non reperees!
  '
  LOCAL a%,adr_dest%,convlen1%,convlen2%,framelen%,longueur%,rec_pos%
  LOCAL cur_songpos%,old_songpos%
  LOCAL b$,buffer$
  LOCAL handle_fichier%,code_erreur_fichier%
  LOCAL filename$
  '
  GOSUB stop_voices
  GOSUB wait_mouse(TRUE)
  GOSUB bee(TRUE)
  filename$=nfic$+CHR$(0)
  handle_fichier%=GEMDOS(60,L:V:filename$,W:0)
  '
  ' En-tete du format .AVR
  '
  IF next_sample$="*.AVR"
    GOSUB separe_nom_chemin(nfic$)      ! Recupere le nom
    b$=LEFT$(nfile_$,8)
    IF INSTR(b$,".")>1
      b$=LEFT$(b$,PRED(INSTR(b$,".")))
      IF LEN(b$)<8
        b$=b$+STRING$(SUB(8,LEN(b$)),0)
      ENDIF
    ENDIF
    b$="2BIT"+b$+MKI$(se.s2d_stereo%=2)+MKI$(SHL(se.s2d_bits%,3))+MKI$(-1)
    b$=b$+MKI$(0)+MKI$(-1)+MKI$(&HFF00)+MKI$(freq_buffer%)+MKL$(0)+MKL$(0)+MKL$(0)      ! Longueur en samples pour 1 canal
    b$=b$+"This sample passed through GRAOUMF TRACKER (c) Laurent de Soras"
    b$=b$+STRING$(SUB(128,LEN(b$)),0)
    code_erreur_fichier%=FN fwrite(handle_fichier%,128,V:b$)
  ENDIF
  '
  GOSUB affiche_panneau_progression("Please wait...",SUB(se.s2d_posend%,se.s2d_posstart%),-1,-1)
  old_songpos%=-1
  '
  ' Prepare l'enregistrement
  '
  buffer$=STRING$(8192,0)                       ! Il faut au moins 1200 * 2 * 2 octets
  longueur%=MUL(se.s2d_maxsize%,1024)
  CARD{ADD(r_songrecord_state%,2)}=se.s2d_posstart%
  CARD{ADD(r_songrecord_state%,4)}=se.s2d_ligstart%
  CARD{ADD(r_songrecord_state%,6)}=se.s2d_posend%
  CARD{ADD(r_songrecord_state%,8)}=se.s2d_ligend%
  LONG{ADD(r_songrecord_state%,10)}=V:buffer$
  CARD{ADD(r_songrecord_state%,18)}=se.s2d_2ndtime! AND 1
  CARD{ADD(r_songrecord_state%,24)}=se.s2d_prediv%
  CARD{ADD(r_songrecord_state%,26)}=freq_buffer%
  CARD{ADD(r_songrecord_state%,32)}=0           ! Pas de realtime
  CARD{r_songrecord_state%}=0
  SLPOKE LONG{r_adr_adr_inter%},r_songrecord_routine%
  songpos%=se.s2d_posstart%
  GOSUB play_song2(0)
  REPEAT                                        ! Attend le debut de l'enregistrement
    IF GEMDOS(11)<>0                            ! Arret clavier?
      ~GEMDOS(7)
      CARD{r_songrecord_state%}=3
      GOTO se.sm_do_record_song_to_disk_norealtime_end
    ENDIF
    IF MOUSEK=2                                 ! Arret souris?
      CARD{r_songrecord_state%}=3
      GOTO se.sm_do_record_song_to_disk_norealtime_end
    ENDIF
  UNTIL CARD{r_songrecord_state%}=2
  rec_pos%=0                                    ! Position dans l'enregistrement
  '
  ' Boucle d'enregistrement
  '
  WHILE CARD{r_songrecord_state%}=2
    IF rec_pos%>=longueur%                      ! Fin atteinte?
      CARD{r_songrecord_state%}=3
    ENDIF
    IF GEMDOS(11)<>0                            ! Arret clavier?
      ~GEMDOS(7)
      CARD{r_songrecord_state%}=3
    ENDIF
    IF MOUSEK=2                                 ! Arret souris?
      CARD{r_songrecord_state%}=3
    ENDIF
    ~C:rr_songrecord_routine_no_realtime%()
    framelen%=LONG{ADD(r_songrecord_state%,34)}
    convlen1%=MIN(framelen%,DIV(MUL(SUB(longueur%,rec_pos%),4),MUL(se.s2d_bits%,se.s2d_stereo%)))
    convlen2%=MUL(DIV(convlen1%,4),MUL(se.s2d_bits%,se.s2d_stereo%))
    adr_dest%=ADD(FN adr_buffer,mark_1%)
    ~C:g_convert_stereo16%(L:V:buffer$,L:adr_dest%,L:convlen1%,W:se.s2d_bits%,W:se.s2d_stereo%)
    code_erreur_fichier%=FN fwrite(handle_fichier%,convlen2%,adr_dest%)
    ADD rec_pos%,convlen2%
    cur_songpos%=CARD{r_mod_songpos%}
    IF cur_songpos%<>old_songpos%
      GOSUB affiche_progression(SUB(cur_songpos%,se.s2d_posstart%))
      old_songpos%=cur_songpos%
    ENDIF
  WEND
  GOSUB stop_voices
  '
  IF next_sample$="*.AVR"
    a%=rec_pos%
    code_erreur_fichier%=GEMDOS(66,L:&H1A,W:handle_fichier%,0)
    code_erreur_fichier%=FN fwrite(handle_fichier%,4,V:a%)      ! Taille totale du sample enregistre
  ENDIF
  '
se.sm_do_record_song_to_disk_norealtime_end:
  code_erreur_fichier%=GEMDOS(62,W:handle_fichier%)
  IF code_erreur_fichier%<0
    erreur%=code_erreur_fichier%
  ENDIF
  '
  GOSUB stop_voices
  GOSUB bee(FALSE)
RETURN
' Compression
PROCEDURE se.sm_affsm_compression
  GOSUB cadre_int(orc%,ADD(ory%,80),17,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,18),ADD(ory%,80),61,59,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,9,26,orc%,ory%)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,1,26)),7),ADD(ADD(ory%,divbi&(1,1,26)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,4,26)),1),ADD(ADD(ory%,divbi&(1,4,26)),2),27,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,5,26)),7),ADD(ADD(ory%,divbi&(1,5,26)),2),4,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,6,26)),7),ADD(ADD(ory%,divbi&(1,6,26)),2),1,5,0,13,12,14)
  GOSUB se.sm_actsm_compression
RETURN
PROCEDURE se.sm_actsm_compression
  se.comp_initvolume%=se.comp_level%            !!!!!!!!!!!!!!!!!!!!!!!! Pour l'instant...
  GOSUB affchaine_notrans(FN pourcent$(se.comp_level%,32768),ADD(ADD(orc%,divbi&(0,5,26)),7),ADD(ADD(ory%,divbi&(1,5,26)),2),1)
  GOSUB affchaine_notrans(STR$(DIV(se.comp_speed%,1000),2),ADD(ADD(orc%,divbi&(0,6,26)),7),ADD(ADD(ory%,divbi&(1,6,26)),2),1)
  IF se.comp_source%>0
    GOSUB affchaine_notrans(HEX$(se.comp_source%,2),ADD(orc%,ADD(divbi&(0,1,26),7)),ADD(ory%,ADD(divbi&(1,1,26),2)),1)
    GOSUB affchaine_notrans(FN samplename$(se.comp_source%),ADD(orc%,ADD(divbi&(0,4,26),1)),ADD(ory%,ADD(divbi&(1,4,26),2)),1)
  ELSE
    GOSUB affchaine_notrans("  ",ADD(orc%,ADD(divbi&(0,1,26),7)),ADD(ory%,ADD(divbi&(1,1,26),2)),1)
    GOSUB affchaine_notrans("Block"+SPACE$(23),ADD(orc%,ADD(divbi&(0,4,26),1)),ADD(ory%,ADD(divbi&(1,4,26),2)),1)
  ENDIF
RETURN
PROCEDURE se.sm_gere_compression
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, flag_relachement!
  LOCAL am%,b%,lon_sam%,taille_buffer%
  LOCAL a$,buffer$
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:26,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' ------------------------------------------------------------------
      CASE 1            ! Numero de sample
        GOSUB edite_chaine(HEX$(se.comp_source%,2),ADD(orc%,ADD(divbi&(0,srt%,26),7)),ADD(ory%,ADD(divbi&(1,srt%,26),2)),2,2)
        se.comp_source%=MIN(MAX(VAL("$"+bbbb$),0),255)
        GOSUB se.sm_actsm_compression
        ' --------------------------------------------------------------------
      CASE 2,3          ! Numero +/-
        se.comp_source%=MAX(MIN(ADD(se.comp_source%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,2),km%))),255),0)
        GOSUB se.sm_actsm_compression
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 4            ! Nom du sample source
        ' Aucun effet
        ' --------------------------------------------------------------------
      CASE 5            ! Level
        GOSUB edite_chaine(FN pourcent$(se.comp_level%,32768),ADD(orc%,ADD(divbi&(0,srt%,26),7)),ADD(ory%,ADD(divbi&(1,srt%,26),2)),5,3)
        se.comp_level%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_compression
        ' --------------------------------------------------------------------
      CASE 6            ! Speed
        DIV se.comp_speed%,1000
        GOSUB edite_chaine(STR$(se.comp_speed%,2),ADD(orc%,ADD(divbi&(0,srt%,26),7)),ADD(ory%,ADD(divbi&(1,srt%,26),2)),2,2)
        se.comp_speed%=MIN(MAX(VAL(bbbb$),1),99)
        MUL se.comp_speed%,1000
        GOSUB se.sm_actsm_compression
        ' --------------------------------------------------------------------
      CASE 7,8          ! Speed +/-
        DIV se.comp_speed%,1000
        se.comp_speed%=MAX(MIN(ADD(se.comp_speed%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,7),km%))),99),1)
        MUL se.comp_speed%,1000
        GOSUB se.sm_actsm_compression
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,26,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0          ! Do
          GOSUB bee(TRUE)
          a$=STRING$(256,0)
          speed%=MAX(INT(freq_buffer%*se.comp_speed%/1000000),1)
          taille_buffer%=MIN(SHL(DIV(freq_buffer%,50),1),60000) ! 1/50 de seconde en 16 bits
          buffer$=STRING$(taille_buffer%,0)
          IF se.comp_source%>0
            a%=FN length(se.comp_source%)
            b%=FN resol(se.comp_source%)
            lon_sam%=MUL(MIN(DIV(a%,b%),DIV(mark_len%,win_bits%)),b%)
            LONG{ADD(V:a$,0)}=FN adresse(se.comp_source%)       ! Adresse source
            CARD{ADD(V:a$,20)}=b%                               ! Resolution source
          ELSE
            LONG{ADD(V:a$,0)}=ADD(FN adr_buffer,mark_1%)
            CARD{ADD(V:a$,20)}=win_bits%
            lon_sam%=mark_len%
          ENDIF
          LONG{ADD(V:a$,12)}=lon_sam%                   ! Longueur source
          LONG{ADD(V:a$,4)}=ADD(FN adr_buffer,mark_1%)  ! Adresse dest.
          LONG{ADD(V:a$,16)}=taille_buffer%             ! Adresse buffer
          CARD{ADD(V:a$,22)}=win_bits%                  ! Resol dest
          LONG{ADD(V:a$,24)}=speed%                     ! Speed
          LONG{ADD(V:a$,28)}=SHL(se.comp_level%,1)      ! Niveau
          LONG{ADD(V:a$,32)}=SHL(se.comp_initvolume%,1) ! Volume initial
          LONG{ADD(V:a$,8)}=V:buffer$                   ! Adresse buffer
          a%=V:a$
          ~C:g_fx_compression%(L:a%)
          GOSUB affiche_sample
          GOSUB bee(FALSE)
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,26,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
' Distortion
PROCEDURE se.sm_affsm_distortion
  GOSUB cadre_int(orc%,ADD(ory%,80),15,59,13,13,14,12)
  GOSUB cadre_int(ADD(orc%,16),ADD(ory%,80),63,59,13,13,14,12)
  GOSUB affiche_bloc_icones_b(0,8,29,orc%,ory%)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,1,29)),7),ADD(ADD(ory%,divbi&(1,1,29)),2),1,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,4,29)),1),ADD(ADD(ory%,divbi&(1,4,29)),2),27,5,0,13,12,14)
  GOSUB cadre_ext(ADD(ADD(orc%,divbi&(0,5,29)),5),ADD(ADD(ory%,divbi&(1,5,29)),2),4,5,0,13,12,14)
  GOSUB se.sm_actsm_distortion
RETURN
PROCEDURE se.sm_actsm_distortion
  GOSUB affchaine_notrans(FN pourcent$(se.disto_gain%,32768),ADD(ADD(orc%,divbi&(0,5,29)),5),ADD(ADD(ory%,divbi&(1,5,29)),2),1)
  IF se.disto_source%>0
    GOSUB affchaine_notrans(HEX$(se.disto_source%,2),ADD(orc%,ADD(divbi&(0,1,29),7)),ADD(ory%,ADD(divbi&(1,1,29),2)),1)
    GOSUB affchaine_notrans(FN samplename$(se.disto_source%),ADD(orc%,ADD(divbi&(0,4,29),1)),ADD(ory%,ADD(divbi&(1,4,29),2)),1)
  ELSE
    GOSUB affchaine_notrans("  ",ADD(orc%,ADD(divbi&(0,1,29),7)),ADD(ory%,ADD(divbi&(1,1,29),2)),1)
    GOSUB affchaine_notrans("Block"+SPACE$(23),ADD(orc%,ADD(divbi&(0,4,29),1)),ADD(ory%,ADD(divbi&(1,4,29),2)),1)
  ENDIF
RETURN
PROCEDURE se.sm_gere_distortion         !!!
  ' Var locales de Sample_Editor :
  ' Necessite xm%, xm2%, ym%, ym2%, km%
  ' Utilise srt%, a%, flag_relachement!
  LOCAL adr_source%,adr_dest%,i%,pas%,sens%
  LOCAL gain,invgain,puissance
  ~FRE(0)
  IF km%>0
    a%=V:divbi&(0,0,0)
    srt%=C:g_teste_icones%(L:a%,W:29,W:xm2%,W:ym2%)
    IF srt%>=0
      SELECT srt%
        ' Radio-boutons, Flip-flops ou champs de texte
        ' ------------------------------------------------------------------
      CASE 1            ! Numero de sample
        GOSUB edite_chaine(HEX$(se.disto_source%,2),ADD(orc%,ADD(divbi&(0,srt%,29),7)),ADD(ory%,ADD(divbi&(1,srt%,29),2)),2,2)
        se.disto_source%=MIN(MAX(VAL("$"+bbbb$),0),255)
        GOSUB se.sm_actsm_distortion
        ' --------------------------------------------------------------------
      CASE 2,3          ! Numero +/-
        se.disto_source%=MAX(MIN(ADD(se.disto_source%,SUB(SHL(1,PRED(km%)),SHL(SUB(srt%,2),km%))),255),0)
        GOSUB se.sm_actsm_distortion
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      CASE 4            ! Nom du sample source
        ' Aucun effet
        ' --------------------------------------------------------------------
      CASE 5            ! Gain
        GOSUB edite_chaine(FN pourcent$(se.disto_gain%,32768),ADD(orc%,ADD(divbi&(0,srt%,29),5)),ADD(ory%,ADD(divbi&(1,srt%,29),2)),5,3)
        se.disto_gain%=DIV(32768*MIN(MAX(VAL(bbbb$),0),999.9),100)
        GOSUB se.sm_actsm_distortion
        ' --------------------------------------------------------------------
      CASE 6,7          ! Gain +/- (par pas de 5/10%)
        pas%=SUB(5,MUL(5,BTST(km%,1)))
        sens%=MUL(SUB(1,SHL(SUB(srt%,6),1)),pas%)
        a%=INT(se.disto_gain%*100/32768+0.0999)
        a%=ADD(MUL(DIV(a%,pas%),pas%),sens%)
        se.disto_gain%=DIV(32768*MIN(MAX(a%,0),999.9),100)
        GOSUB se.sm_actsm_distortion
        IF km%=1
          PAUSE 8
        ENDIF
        flag_relachement!=FALSE
        ' --------------------------------------------------------------------
      DEFAULT
        ' Icones normales
        GOSUB affiche_icone_b(srt%,29,orc%,ory%,-1)
        GOSUB wait_mouse(TRUE)
        SELECT srt%
          ' ------------------------------------------------------------------
        CASE 0          ! Do
          GOSUB bee(TRUE)
          gain=se.disto_gain%/32768
          puissance=se.disto_initpower%+MAX(SUB(se.disto_gain%,32768),0)/32768
          gain=gain*EXP(puissance)
          adr_dest%=ADD(FN adr_buffer,mark_1%)
          IF win_bits%=2
            gain=gain/32768
            invgain=32768/LOG(1+MAX(32768*gain,EXP(se.disto_initpower%)))
            FOR i%=0 TO PRED(SHR(mark_len%,1))
              a%=INT{adr_dest%}
              IF a%>0
                a%=LOG(1+a%*gain)*invgain
              ELSE IF a%<0
                a%=-LOG(1-a%*gain)*invgain
              ENDIF
              INT{adr_dest%}=a%
              ADD adr_dest%,2
            NEXT i%
          ELSE
            gain=gain/128
            invgain=128/LOG(1+MAX(128*gain,EXP(se.disto_initpower%)))
            FOR i%=0 TO PRED(mark_len%)
              a%=FN sbyte(BYTE{adr_dest%})
              IF a%>0
                a%=LOG(1+a%*gain)*invgain
              ELSE IF a%<0
                a%=-LOG(1-a%*gain)*invgain
              ENDIF
              BYTE{adr_dest%}=a%
              INC adr_dest%
            NEXT i%
          ENDIF
          GOSUB affiche_sample
          GOSUB bee(FALSE)
          ' ------------------------------------------------------------------
        ENDSELECT
        GOSUB affiche_icone_b(srt%,29,orc%,ory%,0)
      ENDSELECT
      GOSUB wait_mouse(flag_relachement!)
      flag_relachement!=TRUE
      GOSUB vide_buffer_clavier
    ENDIF
  ENDIF
RETURN
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                                Fonctions                                 *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
FUNCTION vire_xbra(adr%,id%,mask%,vire!)
  LOCAL a%,c%
  LOCAL flag!,found!
  found!=FALSE
  a%=LPEEK(adr%)
  flag!=FALSE
  WHILE LPEEK(MAX(SUB(a%,12),0))=CVL("XBRA")
    IF (LPEEK(SUB(a%,8)) AND mask%)=(id% AND mask%)
      found!=TRUE
      IF vire!
        c%=adr%
        IF flag!
          SUB c%,4
        ENDIF
        xbra_remove$=xbra_remove$+MKL$(c%)+MKL$(a%)
        SLPOKE c%,LPEEK(SUB(a%,4))
      ENDIF
    ENDIF
    adr%=a%
    a%=LPEEK(SUB(a%,4))
    flag!=TRUE
  WEND
  RETURN found!
ENDFUNC
FUNCTION exist(a$)
  ' Cherche si le fichier a$ existe (jockers autorises)
  LOCAL dta$,masque_fichier$
  dta$=STRING$(44,0)
  masque_fichier$=a$+CHR$(0)
  ~FRE(0)
  ~GEMDOS(&H1A,L:V:dta$)
  IF GEMDOS(&H4E,L:V:masque_fichier$,1)=>0
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
FUNCTION backup_file(a$)
  LOCAL e%,a%
  LOCAL b$,c$
  IF FN exist(a$)
    b$=RIGHT$(a$,4)
    a%=ADD(INSTR(b$,"."),SUB(LEN(a$),4))
    b$=LEFT$(a$,a%)                             ! On a le fichier sans l'extention (mais avec le .)
    c$=b$+"BAK"+CHR$(0)
    IF FN exist(c$)
      e%=SHL(GEMDOS(65,L:V:c$),16)              ! Detruit l'ancien .BAK
    ELSE
      e%=0
    ENDIF
    a$=a$+CHR$(0)
    ADD e%,GEMDOS(86,0,L:V:a$,L:V:c$) AND 65535 ! Renome
  ENDIF
  RETURN e%
  ~FRE(0)
ENDFUNC
FUNCTION last_pat_util
  ' Indique le dernier pattern utilise
  LOCAL aaaaa%,iiiii%
  aaaaa%=0
  FOR iiiii%=0 TO PRED(module&(101))
    aaaaa%=MAX(aaaaa%,song&(iiiii%))
  NEXT iiiii%
  RETURN aaaaa%
ENDFUNC
FUNCTION last_spl_util
  ' Indique le dernier sample utilise (min 1)
  LOCAL iiii%,aaaa%
  aaaa%=1
  FOR iiii%=1 TO 255
    IF FN length(iiii%)>0
      aaaa%=iiii%
    ENDIF
  NEXT iiii%
  RETURN aaaa%
ENDFUNC
FUNCTION last_spl_util2
  ' Indique le dernier instrument utilisant un sample non-vide en C-2 (min 1)
  LOCAL iiii%,aaaa%
  aaaa%=1
  FOR iiii%=1 TO 255
    IF FN length(FN isample(iiii%,48))>0
      aaaa%=iiii%
    ENDIF
  NEXT iiii%
  RETURN aaaa%
ENDFUNC
FUNCTION nbr_lines_maxi
  LOCAL iiii%
  aaaa%=1
  FOR iiii%=0 TO FN last_pat_util
    aaaa%=MAX(aaaa%,FN nbr_lines(iiii%))
  NEXT iiii%
  RETURN aaaa%
ENDFUNC
FUNCTION songcomment$
  LOCAL aaaa$
  aaaa$=SPACE$(160)
  BMOVE V:module&(18),V:aaaa$,160
  RETURN aaaa$
ENDFUNC
FUNCTION songname$
  LOCAL aaaa$
  aaaa$=SPACE$(32)
  BMOVE V:module&(2),V:aaaa$,32
  RETURN aaaa$
ENDFUNC
FUNCTION patternname$(pppp%)
  LOCAL aaaa$
  aaaa$=SPACE$(16)
  BMOVE ADD(FN adr_patchunk(pppp%),10),V:aaaa$,16
  RETURN aaaa$
ENDFUNC
FUNCTION samplename$(ssss%)
  LOCAL iiii%,aaaa$
  aaaa$=""
  FOR iiii%=10 TO 34 STEP 4
    aaaa$=aaaa$+MKL$(LONG{ADD(FN adrsamchk(ssss%),iiii%)})
  NEXT iiii%
  RETURN aaaa$
ENDFUNC
FUNCTION pourcent$(aaaa%,bbbb%)
  ' Transforme aaaa%/bbbb% en "xxx.x" %
  ' Arrondissement par exces
  RETURN RIGHT$("  "+STR$(INT(aaaa%*100/bbbb%+0.0999)),3)+"."+RIGHT$(STR$(INT(aaaa%*1000/bbbb%+0.999)),1)
ENDFUNC
FUNCTION pourcent2$(aaaa%,bbbb%)
  ' Transforme aaaa%/bbbb% en "xxx %" ou en "done." si 100% ou +
  ' Arrondissement par defaut
  IF aaaa%<bbbb%
    RETURN STR$(INT(aaaa%*100/bbbb%),3)+" %"
  ELSE
    RETURN "done."
  ENDIF
ENDFUNC
FUNCTION time_hmsd$(t%)
  LOCAL h%,m%,s%,d%
  LOCAL a$
  h%=DIV(t%,720000)
  m%=DIV(t%,12000) MOD 60
  s%=DIV(t%,200) MOD 60
  d%=t% MOD 200
  a$=STR$(h%)+":"+STR$(DIV(m%,10))+STR$(m% MOD 10)+"'"+STR$(DIV(s%,10))+STR$(s% MOD 10)+""""+STR$(DIV(d%,20))
  RETURN a$
ENDFUNC
FUNCTION fft(aaaa%,tttt%,llll%,ffffe%,ffff0%,bbbb%)
  ' aaaa% = adresse du sample, tttt %= adresse d'une table de 1.25*4096 sinus 16 bits
  ' llll% = longueur en octets, ffffe% = freq d'ech, ffff0% = freq recherchee
  ' bbbb% = nombre d'octets par sample
  LOCAL cccc%,dddd,eeee,ffff
  cccc%=C:g_trans_fourier%(L:aaaa%,L:llll%,L:ffffe%,L:ffff0%,W:bbbb%,L:tttt%)
  eeee=LONG{cccc%}
  ffff=LONG{ADD(cccc%,4)}
  dddd=SQR((eeee*eeee+ffff*ffff))/1073741824            ! Module (variant de 0 a 1)
  RETURN dddd
ENDFUNC
FUNCTION spl_cherche_volume(dddd%,llll%,bbbb%)
  ' Cherche le volume du sample position dddd%, longueur llll%, resol bbbb%
  LOCAL aaaa%,cccc%
  cccc%=ADD(FN adr_buffer,dddd%)
  aaaa%=C:g_cherche_volume_sample%(L:cccc%,L:llll%,W:bbbb%)
  aaaa%=SHL(aaaa%,SHL(SUB(2,bbbb%),3))              ! Recalibre /32768
  RETURN aaaa%
ENDFUNC
FUNCTION hexasigne$(vvvv%,llll%)
  ' Renvoie une chaine en hexa signe, avec llll% chiffre (+ le signe)
  IF vvvv%>=0
    RETURN "+"+HEX$(vvvv%,llll%)
  ELSE
    RETURN "-"+HEX$(ABS(vvvv%),llll%)
  ENDIF
ENDFUNC
FUNCTION valhexasigne(aaaa$)
  ' Renvoie la valeur d'une chaine hexa signee, avec ou sans '$'
  LOCAL a%
  a%=INSTR(aaaa$,"$")
  IF a%>0
    aaaa$=LEFT$(aaaa$,PRED(a%))+RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))
  ENDIF
  a%=INSTR(aaaa$,"+")
  IF a%>0
    RETURN VAL("$"+TRIM$(RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))))
  ELSE
    a%=INSTR(aaaa$,"-")
    IF a%>0
      RETURN -VAL("$"+TRIM$(RIGHT$(aaaa$,SUB(LEN(aaaa$),a%))))
    ELSE
      RETURN VAL("$"+TRIM$(aaaa$))
    ENDIF
  ENDIF
ENDFUNC
FUNCTION sbyte(a%)
  ' Retablit la signature d'un octet et enleve les bits inutiles
  a%=a% AND 255
  IF a%>127
    RETURN SUB(a%,256)
  ELSE
    RETURN a%
  ENDIF
ENDFUNC
FUNCTION squartet(a%)
  ' Retablit la signature d'un quartet et enleve les bits inutiles
  a%=a% AND 15
  IF a%>7
    RETURN SUB(a%,16)
  ELSE
    RETURN a%
  ENDIF
ENDFUNC
FUNCTION donne_combinaison_touche$(am%,ae%,bm%,be%)
  LOCAL scancode%
  LOCAL tot$,t$
  LOCAL all_keys_done!
  tot$=""
  IF ae%=0
    tot$="nokey"
  ELSE
    all_keys_done!=FALSE
    REPEAT
      ' Touche principale
      t$=""
      IF (am% AND &HFF)=&HFF                    ! Ascii
        t$=t$+CHR$(ae% AND &HFF)
      ELSE IF (am% AND &HFF0000)=&HFF0000       ! Scan
        scancode%=SHR(ae%,16) AND &HFF
        SELECT scancode%
        CASE 1                                  ! Esc
          t$=t$+"esc"
        CASE 2                                  ! &
          t$=t$+"&"
        CASE 14                                 ! Backspace
          t$=t$+"backspace"
        CASE 15                                 ! Tab
          t$=t$+"tab"
        CASE 28                                 ! Return
          t$=t$+"return"
        CASE 43                                 ! #
          t$=t$+"#"
        CASE 57                                 ! Space
          t$=t$+"space"
        CASE 59 TO 68                           ! F1 - F10
          t$=t$+"f"+STR$(SUB(scancode%,58))
        CASE 71                                 ! Clr
          t$=t$+"clr"
        CASE 72                                 ! Up
          t$=t$+"up"
        CASE 75                                 ! Left
          t$=t$+"left"
        CASE 77                                 ! Right
          t$=t$+"right"
        CASE 80                                 ! Down
          t$=t$+"down"
        CASE 82                                 ! Ins
          t$=t$+"ins"
        CASE 83                                 ! Del
          t$=t$+"del"
        CASE 96                                 ! <
          t$=t$+"<"
        CASE 97                                 ! Undo
          t$=t$+"undo"
        CASE 98                                 ! help
          t$=t$+"help"
        CASE 112                                ! Pad0
          t$=t$+"pad0"
        CASE 113                                ! Padpoint
          t$=t$+"padpoint"
        ENDSELECT
      ELSE IF BTST(ae%,9)                       ! Numpad
        t$=t$+"numpad"
      ELSE IF BTST(ae%,10)                      ! Fkeys
        t$=t$+"fkeys"
      ENDIF
      ' Touches auxiliaires
      IF BTST(ae%,8)                            ! Shift
        t$=t$+" + shift"
      ENDIF
      IF BTST(ae%,24)                           ! Rshift
        t$=t$+" + rshift"
      ENDIF
      IF BTST(ae%,25)                           ! Lshift
        t$=t$+" + lshift"
      ENDIF
      IF BTST(ae%,26)                           ! Ctrl
        t$=t$+" + ctrl"
      ENDIF
      IF BTST(ae%,27)                           ! Alt
        t$=t$+" + alt"
      ENDIF
      IF BTST(am%,28)
        IF BTST(ae%,28)                         ! caps
          t$=t$+" + caps"
        ELSE
          t$=t$+" + nocaps"                     ! No caps
        ENDIF
      ENDIF
      IF INSTR(t$," + ")=1
        t$=RIGHT$(t$,SUB(LEN(t$),3))
      ENDIF
      tot$=tot$+t$
      IF be%=0
        all_keys_done!=TRUE
      ELSE
        tot$=tot$+" / "
        SWAP am%,bm%
        SWAP ae%,be%
        bm%=0
        be%=0
      ENDIF
    UNTIL all_keys_done!
  ENDIF
  RETURN tot$
ENDFUNC
FUNCTION vol_exp_2_lin(b%)
  IF b%<=0
    RETURN 0
  ELSE
    RETURN MAX(MIN(ROUND(2^(b%/256)),&HFFFF),0)
  ENDIF
ENDFUNC
FUNCTION vol_lin_2_exp(b%)
  IF b%<=0
    RETURN 0
  ELSE
    RETURN MAX(MIN(ROUND(256*LOG(b%)/LOG(2)),&HFFF),0)
  ENDIF
ENDFUNC
' Sample Editor
FUNCTION se.sm_fft_tot(fmin%,fmax%,fech%,nfreq%,adr%,lon%,bits%,flagc!,flagd!)
  ' Renvoie dans fft&() les puissances (15 bits) de nfreq%
  ' frequences de fmin%...fmax% puis la frequence.w du sample
  LOCAL a%,i%,pc%,pctot%,pcnxt%,a,b,coef,p,pm,f1,f2,tabl$
  ~FRE(0)
  ARRAYFILL fft&(),0
  IF flagd!
    GOSUB bee(TRUE)
  ENDIF
  tabl$=STRING$(8192,0)
  a%=V:tabl$
  a=PI/2048
  FOR i%=0 TO 1024                      ! Calcul de la table
    INT{a%}=ROUND(SIN(i%*a)*32767)
    ADD a%,2
  NEXT i%
  FOR i%=4 TO 4092 STEP 4
    INT{a%}=INT{SUB(a%,i%)}
    ADD a%,2
  NEXT i%
  FOR i%=0 TO 2048
    INT{a%}=-INT{SUB(a%,4096)}
    ADD a%,2
  NEXT i%
  se.freq_fftmin%=fmin%
  se.freq_fftmax%=fmax%
  se.freq_fftech%=fech%
  se.freq_fftlon%=nfreq%
  ' FFT de chaque frequence
  pm=0
  f1=-1
  f2=0
  b=(fmax%-fmin%)/nfreq%
  IF b>1 AND b<100 AND flagc!
    pctot%=nfreq%+2*b
  ELSE
    pctot%=nfreq%
  ENDIF
  IF flagd!
    GOSUB affiche_panneau_progression("WAITING: FFT...",pctot%,-1,-1)
  ENDIF
  pc%=0
  pcnxt%=0
  FOR i%=0 TO PRED(nfreq%)
    a=f1
    f1=fmin%+i%*b                       ! Frequence a tester
    p=FN fft(adr%,V:tabl$,lon%,SHL(fech%,4),MAX(ROUND(f1*16),0),bits%)
    fft&(i%)=MAX(MIN(p*&H7FFF,&H7FFF),0)
    IF f1>=30
      coef=1/f1
    ELSE
      coef=0
    ENDIF
    IF p*coef>pm
      pm=p*coef
      f2=f1
    ENDIF
    IF GEMDOS(11)<>0
      IF SHR(GEMDOS(7),16)=1            ! ESC = arret
        i%=nfreq%
      ENDIF
    ENDIF
    IF flagd!                           ! Affichage du pourcentage de calcul
      GOSUB affiche_progression(pc%)
      GOSUB bee(TRUE)
      INC pc%
    ENDIF
  NEXT i%
  ' 2eme recherche pour la frequence du sample, precise
  IF flagc! AND b>1 AND b<=100          ! Scanning Hz par Hz
    FOR i%=f2-b TO f2+b
      p=FN fft(adr%,V:tabl$,lon%,fech%,MAX(i%,0),bits%)
      IF i%>=30
        coef=1/i%
      ELSE
        coef=0
      ENDIF
      IF p*coef>pm
        pm=p*coef
        f2=i%
      ENDIF
      IF GEMDOS(11)<>0
        IF SHR(GEMDOS(7),16)=1          ! ESC = arret
          i%=f2+b
        ENDIF
      ENDIF
      IF flagd!                         ! Affichage du pourcentage de calcul
        GOSUB affiche_progression(pc%)
        GOSUB bee(TRUE)
        INC pc%
      ENDIF
    NEXT i%
  ENDIF
  IF b>100 OR NOT flagc!        ! Si l'ecart est trop grand, pas de frequence pour le sample
    f2=0
  ENDIF
  RETURN ROUND(f2)
ENDFUNC
FUNCTION se.sm_adresse_sample(i%)
  IF i%=0
    RETURN ADD(FN adr_buffer,mark_1%)
  ELSE
    RETURN FN adresse(i%)
  ENDIF
ENDFUNC
FUNCTION se.sm_longueur_sample(i%)
  IF i%=0
    RETURN mark_len%
  ELSE
    RETURN FN length(i%)
  ENDIF
ENDFUNC
FUNCTION se.sm_resol_sample(i%)
  IF i%=0
    RETURN win_bits%
  ELSE
    RETURN FN resol(i%)
  ENDIF
ENDFUNC
' ASCIIsation de choix
FUNCTION get_elt_in_list$(l$,a%)
  ' Renvoie le a%ieme element (de 0 a ...) de la liste l$
  ' Les elements sont separes par des virgules
  LOCAL b%
  LOCAL b$
  IF a%<0
    b$=""
  ELSE
    REPEAT
      b%=INSTR(l$,",")
      IF b%>0
        b$=LEFT$(l$,PRED(b%))
        l$=RIGHT$(l$,SUB(LEN(l$),b%))
      ELSE
        b$=l$
        l$=""
      ENDIF
      DEC a%
    UNTIL a%<0
  ENDIF
  RETURN b$
ENDFUNC
FUNCTION falsetrue$(a%)
  IF a%<>0
    RETURN "true"
  ELSE
    RETURN "false"
  ENDIF
ENDFUNC
FUNCTION noyes$(a%)
  IF a%<>0
    RETURN "yes"
  ELSE
    RETURN "no"
  ENDIF
ENDFUNC
FUNCTION offon$(a%)
  IF a%<>0
    RETURN "on"
  ELSE
    RETURN "off"
  ENDIF
ENDFUNC
' Fichiers
FUNCTION fread(handle%,len%,adr%)
  er%=GEMDOS(63,W:handle%,L:len%,L:adr%)
  IF er%<>len% AND er%>=0
    er%=-1
  ENDIF
  RETURN er%
ENDFUNC
FUNCTION fwrite(handle%,len%,adr%)
  er%=GEMDOS(64,W:handle%,L:len%,L:adr%)
  IF er%<>len% AND er%>=0
    er%=-1
  ENDIF
  RETURN er%
ENDFUNC
' Menus Pop Up
FUNCTION popup(npop%,ligdef%,x_pix_midpos%,y_pix_midpos%)
  ' Gestion d'un menu pop up (possibilite de recursivite)
  ' Renvoie le numero du menu dans le mot fort, le code du choix dans le faible.
  ' Renvoie -1 si annulation
  LOCAL reponse%,choix%,old_choix%,couleur%
  LOCAL choisi!,select!
  LOCAL pix_width_ext%,pix_high_ext%,car_width_ext%,car_width_in%,car_high_in%
  LOCAL x_car_pos%,y_pix_pos%,xm%,ym%,km%,xm2%
  LOCAL a%,b%,i%,j%
  LOCAL a$,pop_background$
  '
  GOSUB wait_mouse(TRUE)
  '
  ' Recherche des dimensions et coordonnees du popup
  '
  car_high_in%=popup_nbrlines%(npop%)
  a%=4
  FOR i%=0 TO PRED(popup_nbrlines%(npop%))
    b%=LEN(popup_txt$(i%,npop%))
    IF NOT BTST(popup_code%(i%,npop%),18)       ! Si la ligne est selectionnable
      ADD b%,4                                  ! + 2 selected, + 2 pour la fleche (popup recursif)
    ENDIF
    a%=MAX(a%,b%)
  NEXT i%
  car_width_in%=a%
  pix_high_ext%=ADD(MUL(car_high_in%,8),8)
  pix_width_ext%=ADD(MUL(car_width_in%,8),16)
  car_width_ext%=SHR(pix_width_ext%,3)
  x_car_pos%=DIV(SUB(x_pix_midpos%,SHR(pix_width_ext%,1)),8)
  x_car_pos%=MAX(0,MIN(x_car_pos%,SUB(scr_ncol%,car_width_ext%)))
  IF ligdef%>=0 AND ligdef%<popup_nbrlines%(npop%)
    y_pix_pos%=SUB(y_pix_midpos%,ADD(MUL(ligdef%,8),8))
  ELSE
    y_pix_pos%=SUB(y_pix_midpos%,SHR(pix_high_ext%,1))
  ENDIF
  y_pix_pos%=MAX(0,MIN(y_pix_pos%,SUB(scr_haut%,pix_high_ext%)))
  '
  ' Sauvegarde du fond
  '
  GOSUB save_background(SHL(x_car_pos%,3),y_pix_pos%,pix_width_ext%,pix_high_ext%)
  '
  ' Affichage du popup
  '
  GOSUB cadre_int(x_car_pos%,y_pix_pos%,PRED(car_width_ext%),PRED(pix_high_ext%),13,13,14,12)
  y%=ADD(y_pix_pos%,5)
  FOR i%=0 TO PRED(popup_nbrlines%(npop%))
    a$=FN ligne_popup$(i%,npop%,select!)
    IF select!
      couleur%=12
    ELSE
      couleur%=14
    ENDIF
    GOSUB affchaine_trans(a$,ADD(SHL(x_car_pos%,1),2),y%,couleur%)
    ADD y%,8
  NEXT i%
  '
  ' Gestion du PopUp
  '
  old_choix%=-1
  choix%=-1
  choisi!=FALSE
  reponse%=-1
  WHILE NOT choisi!
    SHOWM
    MOUSE xm%,ym%,km%
    xm2%=SHR(xm%,3)
    IF xm2%>=x_car_pos% AND xm2%<ADD(x_car_pos%,car_width_ext%)
      a%=INT(SUB(ym%,ADD(y_pix_pos%,5))/8)
      IF a%>=0 AND a%<popup_nbrlines%(npop%)
        choix%=a%
      ELSE
        choix%=-1
      ENDIF
    ELSE
      choix%=-1
    ENDIF
    ' Affichage de l'inversion video
    IF old_choix%<>choix%
      IF old_choix%>=0
        a$=FN ligne_popup$(old_choix%,npop%,select!)
        IF select!
          couleur%=12
        ELSE
          couleur%=14
        ENDIF
        GOSUB cadre_int(SUCC(x_car_pos%),ADD(ADD(y_pix_pos%,4),MUL(old_choix%,8)),SUB(car_width_ext%,3),7,13,13,13,13)
        GOSUB affchaine_trans(a$,ADD(SHL(x_car_pos%,1),2),ADD(ADD(y_pix_pos%,5),MUL(old_choix%,8)),couleur%)
      ENDIF
      IF choix%>=0
        IF NOT BTST(popup_code%(choix%,npop%),18)
          a$=FN ligne_popup$(choix%,npop%,select!)
          GOSUB cadre_int(SUCC(x_car_pos%),ADD(ADD(y_pix_pos%,4),MUL(choix%,8)),SUB(car_width_ext%,3),7,12,12,12,12)
          GOSUB affchaine_trans(a$,ADD(SHL(x_car_pos%,1),2),ADD(ADD(y_pix_pos%,5),MUL(choix%,8)),14)
        ENDIF
      ENDIF
      SHOWM
    ENDIF
    old_choix%=choix%
    ' Clic
    IF km%>0
      IF choix%>=0 AND km%<>2
        IF NOT BTST(popup_code%(choix%,npop%),18)
          IF BTST(popup_code%(choix%,npop%),16)
            a%=FN popup(popup_code%(choix%,npop%) AND &HFFFF,0,ADD(SHL(x_car_pos%,3),32),ADD(ADD(y_pix_pos%,20),MUL(choix%,8)))
            IF a%<>-1
              reponse%=a%
              choisi!=TRUE
            ENDIF
          ELSE
            reponse%=ADD(popup_code%(choix%,npop%) AND &HFFFF,SHL(npop%,16))
            choisi!=TRUE
          ENDIF
        ENDIF
      ELSE
        reponse%=-1
        choisi!=TRUE
      ENDIF
    ENDIF
  WEND
  '
  ' Restitution du fond
  '
  GOSUB restore_background
  '
  GOSUB wait_mouse(TRUE)
  RETURN reponse%
ENDFUNC
FUNCTION ligne_popup$(nlig%,npop%,VAR select!)
  ' Renvoie une ligne du popup telle qu'elle apparait dans le menu
  ' Renvoie select!: TRUE = selectionnable, FALSE = non selectionnable
  LOCAL a$
  IF BTST(popup_code%(nlig%,npop%),18)          ! Non selectionnable
    select!=FALSE
    a$=popup_txt$(nlig%,npop%)
  ELSE
    select!=TRUE
    IF BTST(popup_code%(nlig%,npop%),17)
      a$=MKI$(&H820)+popup_txt$(nlig%,npop%)    ! Checked + Espace
    ELSE
      a$=MKI$(&H2020)+popup_txt$(nlig%,npop%)
    ENDIF
    IF BTST(popup_code%(nlig%,npop%),16)
      a$=a$+MKI$(&H2003)                        ! Espace + fleche droite
    ENDIF
  ENDIF
  RETURN a$
ENDFUNC
' Instruments
FUNCTION instrname$(ssss%)
  LOCAL iiii%,aaaa$
  aaaa$=""
  FOR iiii%=10 TO 34 STEP 4
    aaaa$=aaaa$+MKL$(LONG{ADD(V:instrset%(0,ssss%),iiii%)})
  NEXT iiii%
  RETURN aaaa$
ENDFUNC
FUNCTION ins_deb_zone(nnnn%,pppp%)
  ' Cherche le debut d'une zone isosample dans la table des samples d'un instrument
  LOCAL aaaa%
  aaaa%=FN isample(nnnn%,pppp%)
  WHILE pppp%>1
    EXIT IF FN isample(nnnn%,PRED(pppp%))<>aaaa%
    DEC pppp%
  WEND
  RETURN pppp%
ENDFUNC
FUNCTION ins_fin_zone(nnnn%,pppp%)
  ' Cherche la fin d'une zone isosample dans la table des samples d'un instrument
  LOCAL aaaa%
  aaaa%=FN isample(nnnn%,pppp%)
  WHILE pppp%<127
    EXIT IF FN isample(nnnn%,SUCC(pppp%))<>aaaa%
    INC pppp%
  WEND
  RETURN pppp%
ENDFUNC
FUNCTION ins_used_samples$(nnnn%)
  ' Renvoie une chaine de MOTS contenant les numeros des samples utilises dans
  ' l'instrument specifie (sauf 0)
  LOCAL aaaa%,iiii%,jjjj%,pppp%
  LOCAL ffff!
  LOCAL aaaa$
  aaaa$=""
  FOR iiii%=0 TO 127
    aaaa%=FN isample(nnnn%,iiii%)
    IF aaaa%>0
      ffff!=TRUE
      IF LEN(aaaa$)>0
        FOR jjjj%=0 TO SUB(LEN(aaaa$),2) STEP 2
          IF CARD{ADD(V:aaaa$,jjjj%)}=aaaa%
            ffff!=FALSE
            jjjj%=LEN(aaaa$)
          ENDIF
        NEXT jjjj%
      ENDIF
      IF ffff!
        pppp%=0
        WHILE pppp%<LEN(aaaa$)
          EXIT IF CARD{ADD(V:aaaa$,pppp%)}>aaaa%
          ADD pppp%,2
        WEND
        aaaa$=LEFT$(aaaa$,pppp%)+MKI$(aaaa%)+RIGHT$(aaaa$,SUB(LEN(aaaa$),pppp%))
      ENDIF
    ENDIF
  NEXT iiii%
  RETURN aaaa$
ENDFUNC
FUNCTION ins_cherche_sample(ssss%,dddd%)
  ' Cherche dans quel instrument se trouve le sample ssss%
  ' La recherche commence a l'instrument dddd%
  LOCAL iiii%
  LOCAL ffff!
  ffff!=FALSE
  WHILE dddd%<=255
    FOR iiii%=1 TO 127
      IF FN isample(dddd%,iiii%)=ssss%
        ffff!=TRUE
      ENDIF
    NEXT iiii%
    EXIT IF ffff!
    INC dddd%
  WEND
  IF ffff!
    RETURN dddd%
  ELSE
    RETURN 0
  ENDIF
ENDFUNC
' Enveloppes
FUNCTION env_chunkadr(num%,type%)
  IF type%=0
    RETURN LONG{ADD(r_adr_evol%,SHL(num%,2))}
  ELSE IF type%=1
    RETURN LONG{ADD(r_adr_eton%,SHL(num%,2))}
  ELSE
    RETURN LONG{ADD(r_adr_epan%,SHL(num%,2))}
  ENDIF
ENDFUNC
FUNCTION env_chunklen(num%,type%)
  RETURN LONG{ADD(FN env_chunkadr(num%,type%),4)}
ENDFUNC
FUNCTION envelopename$(num%,type%)
  LOCAL i%,a$
  a$=""
  FOR i%=10 TO 26 STEP 4
    a$=a$+MKL$(LONG{ADD(FN env_chunkadr(num%,type%),i%)})
  NEXT i%
  RETURN a$
ENDFUNC
FUNCTION env_sectadr(num%,type%,sect%)
  IF sect%=0
    RETURN ADD(FN env_chunkadr(num%,type%),32)
  ELSE
    RETURN ADD(FN env_chunkadr(num%,type%),ADD(32,CARD{ADD(FN env_chunkadr(num%,type%),30)}))
  ENDIF
ENDFUNC
FUNCTION env_sectlen(num%,type%,sect%)
  LOCAL length%
  IF sect%=0
    length%=CARD{ADD(FN env_chunkadr(num%,type%),30)}
  ELSE
    length%=SUB(SUB(FN env_chunklen(num%,type%),32),FN env_sectlen(num%,type%,0))
  ENDIF
  RETURN length%
ENDFUNC
FUNCTION pos_enveloppe(num%,type%,sect%,pos%)
  ' Type de l'enveloppe (0,1 ou 2), numero de l'enveloppe (0-63),
  ' Attack/Key off (0 ou 1), position recherchee
  ' Retourne la position en octets relativement au debut des donnees du numero
  ' d'une commande
  ' Retourne -1 si la position n'existe pas
  LOCAL a%,b%,c%,l%,p%
  a%=FN env_sectadr(num%,type%,sect%)
  l%=FN env_sectlen(num%,type%,sect%)
  p%=0                  ! Compteur en positions
  c%=0                  ! Compteur en octets
  WHILE c%<l%
    EXIT IF p%>=pos%
    b%=BYTE{a%}         ! Commande
    ADD a%,FN env_comlen(b%)
    ADD c%,FN env_comlen(b%)
    INC p%
  WEND
  IF c%>=l%
    RETURN -1
  ELSE
    RETURN c%
  ENDIF
ENDFUNC
FUNCTION numcom_enveloppe(num%,type%,sect%,pos%)
  ' Type de l'enveloppe (0,1 ou 2), numero de l'enveloppe (0-63),
  ' Attack/Key off (0 ou 1), position en octets recherchee
  ' Retourne le numero de la commande correspondant a une position en octets
  LOCAL a%,b%,c%,l%,p%
  a%=FN env_sectadr(num%,type%,sect%)
  l%=FN env_sectlen(num%,type%,sect%)
  p%=0                  ! Compteur en positions
  c%=0                  ! Compteur en octets
  WHILE c%<l% AND c%<pos%
    b%=BYTE{a%}         ! Commande
    ADD a%,FN env_comlen(b%)
    ADD c%,FN env_comlen(b%)
    INC p%
  WEND
  RETURN p%
ENDFUNC
FUNCTION env_comlen(com%)
  ' Renvoie le nombre d'octets pris par une commande + son parametre
  LOCAL len%
  SELECT com%
  CASE &H3,&H82,&H85,&H86,&H89,&H8A,&HA2,&HA5,&HA6,&HC2
    len%=2
  CASE &H1,&H2,&H4,&H80,&H81,&HA0,&HA1,&HC0,&HC1
    len%=3
  DEFAULT
    len%=1
  ENDSELECT
  RETURN len%
ENDFUNC
'
'
'
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
' *                                                                          *
' *                             Donnees diverses                             *
' *                                                                          *
' *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
'
' 0
icones_disk:
DATA 17,0,5
DATA 0,"LOAD MOD",21,35,9,9, 1,"SAVE MOD",31,35,9,9
DATA 2,"LOAD PREF",21,45,9,9, 3,"SAVE PREF",31,45,9,9
DATA 4,"LOAD PATT",21,55,9,9, 5,"SAVE PATT",31,55,9,9
DATA 6,"LOAD SONG",21,65,9,9, 7,"SAVE SONG",31,65,9,9
DATA 8,"PATH OF                 ",20,80,24,9
DATA 9," ",20,90,59,9
DATA 10,"MODULE FILE      ",43,35,17,9
DATA 11,"MAKE DIR",62,35,8,9, 12,"DEL DIR",71,35,8,9
DATA 13,"RENAME",62,45,8,9, 14,"DEL FILE",71,45,8,9
DATA 15,"FORMAT",71,55,8,9
DATA 16," ",77,75,1,9
' 1
icones_tools:
DATA 24,0,5
DATA 0,"START",21,40,9,11, 1,"PASTE",33,35,7,9, 2,"CLEAR",41,45,7,9, 3,"N/O UP",49,45,9,9
DATA 4,"END",21,53,9,11, 5,"INSERT",33,45,7,9, 6,"DELETE",41,55,7,9, 7,"N/O DOWN",49,55,9,9
DATA 8,"SWAP",33,55,7,9, 9,"REPLACE",53,75,7,9, 10,"ALL",21,75,7,9, 11,"TRACK",61,30,7,9
DATA 12,"TRANSP",53,85,7,9, 13,"MASK",21,85,7,9, 14,"PATTERN",61,40,7,9, 15,"PRESET",61,50,7,9
DATA 16,"MASK ON               ",29,75,22,9, 17,"REPLACE BY            ",29,85,22,9
DATA 18,"EXT NOTE       ",63,77,15,9
DATA 19,"SONG",71,40,7,9, 20,"INSTR",71,50,7,9, 21,"ALL",71,60,7,9
DATA 22,".../...",72,90,7,9
DATA 23,"SONG",61,60,7,9
' 2
icones_sample1:
DATA 18,0,0
DATA 0,"EXIT",70,70,9,9
DATA 1,"ZOOM",0,20,9,9, 2,"ZOOM OUT",10,20,9,9
DATA 3,"COPY SPL => BLOCK",0,30,19,9
DATA 4,"COPY BLOCK => SPL",0,40,19,9
DATA 5,"SWAP BLOCK AND SPL",0,50,19,9
DATA 6,"CLEAR",0,70,5,9, 7,"CUT",6,70,3,9, 8,"KEEP",10,70,4,9, 9,"FLIP",15,70,4,9
DATA 10,"GAP (BLK)",0,60,9,9, 11,"GAP (SPL)",10,60,9,9
DATA 12,"PLAY",20,30,9,29
DATA 13,"FINE POS",20,60,9,9
DATA 14,"SWAP CURS",20,70,9,9
DATA 15,"RESET CUR",20,20,9,9
DATA 16,"LOAD SAMPLE", 68, 50, 11, 9
DATA 17,"SAVE SAMPLE", 68, 60, 11, 9
' 3
icones_sample2:
DATA 10,0,0
DATA 0,"POS L",1,0,5,9, 1,"CURS L",8,0,5,9, 2,"BITS",25,0,1,9, 3,"BLOCK",29,0,5,9, 4,"BUFFER",36,0,5,9
DATA 5,"REPEAT",43,0,5,9, 6,"FREQ",50,0,4,9, 7,"SAMPLE",60,0,1,9, 8,"CURS R",66,0,5,9, 9,"POS R",73,0,5,9
' 4
icones_sample3:
DATA 11,0,0
DATA 0,"VOLUME",40,20,9,9, 1,"MIX",40,30,9,9, 2,"RECORD",40,40,9,9
DATA 3,"MARKS",40,50,9,9, 4,"FREQUENCY",40,60,9,9, 5,"DELAY",40,70,9,9
DATA 6,"FLANGER",50,20,9,9, 7,"REVERB",50,30,9,9, 8,"SONG2DISK",50,40,9,9
DATA 9,"COMPRESS.",50,50,9,9, 10,"DISTO",50,60,9,9
' 5
icones_sample_sm1:
DATA 17,0,0
DATA 0,"VOLUME      %",15,90,13,9
DATA 1,"VOLUME ?",1,85,12,19
DATA 2,"+ 1 dB",31,90,7,9, 3,"+ 2 dB",31,100,7,9, 4,"+ 3 dB",31,110,7,9, 5,"+ 6 dB",31,120,7,9
DATA 6,"- 1 dB",39,90,7,9, 7,"- 2 dB",39,100,7,9, 8,"- 3 dB",39,110,7,9, 9,"- 6 dB",39,120,7,9
DATA 10,"FADE !",49,90,29,9
DATA 11,"FADE START      %",49,115,17,9
DATA 12,"FADE END        %",49,125,17,9
DATA 13,"FADE IN",69,115,9,9
DATA 14,"FADE OUT",69,125,9,9
DATA 15,"NO CHANGE",1,125,13,9, 16,"BEST",15,125,13,9
' 6
icones_sample_sm2:
DATA 46,0,0
DATA 0,"MIX !",1,85,11,9, 1,"MASTER      %",15,85,13,9
DATA 2,"2",31,85,1,9, 3,"3",33,85,1,9, 4,"4",35,85,1,9, 5,"5",37,85,1,9
DATA 6,"ON",5,100,3,9, 7,"START      %",9,100,12,9, 8,"END      %",22,100,10,9, 9,"LOOP",33,100,5,9
DATA 10," ",1,110,3,9, 11,"¸",5,110,1,9, 12,"˝",7,110,1,9, 13," ",9,110,29,9
DATA 14,"ON",5,120,3,9, 15,"START      %",9,120,12,9, 16,"END      %",22,120,10,9, 17,"LOOP",33,120,5,9
DATA 18," ",1,130,3,9, 19,"¸",5,130,1,9, 20,"˝",7,130,1,9, 21," ",9,130,29,9
DATA 22,"ON",45,80,3,9, 23,"START      %",49,80,12,9, 24,"END      %",62,80,10,9, 25,"LOOP",73,80,5,9
DATA 26," ",41,90,3,9, 27,"¸",45,90,1,9, 28,"˝",47,90,1,9, 29," ",49,90,29,9
DATA 30,"ON",45,100,3,9, 31,"START      %",49,100,12,9, 32,"END      %",62,100,10,9, 33,"LOOP",73,100,5,9
DATA 34," ",41,110,3,9, 35,"¸",45,110,1,9, 36,"˝",47,110,1,9, 37," ",49,110,29,9
DATA 38,"ON",45,120,3,9, 39,"START      %",49,120,12,9, 40,"END      %",62,120,10,9, 41,"LOOP",73,120,5,9
DATA 42," ",41,130,3,9, 43,"¸",45,130,1,9, 44,"˝",47,130,1,9, 45," ",49,130,29,9
' 7
icones_samples_sm3:
DATA 18,0,0
DATA 0,"SAMPLE",1,85,9,9, 1,"PRESAMPLE",13,85,9,9
DATA 2,"¸",65,105,1,9, 3,"˝",67,105,1,9, 4,"¸",75,105,1,9, 5,"˝",77,105,1,9
DATA 6,"AUTO",69,105,5,9
DATA 7,"FREQUENCY      Hz",1,105,17,9, 8,"¸",19,105,1,9, 9,"˝",21,105,1,9
DATA 10,"MONITOR",25,120,11,9
DATA 11,"LEVEL      %",10,125,12,9, 12,"TRIGGER",1,125,8,9
DATA 13,"L",25,95,3,9, 14,"L+R",29,95,3,9, 15,"R",33,95,3,9
DATA 16,"FALCON 030 D.A.C.",39,95,23,9, 17,"ST REPLAY PRO CARDRIDGE",39,105,23,9
' 8
icones_samples_sm4:
DATA 29,0,0
DATA 0,"1",1,80,1,9, 1,"2",1,90,1,9, 2,"3",1,100,1,9, 3,"4",1,110,1,9, 4,"5",1,120,1,9
DATA 5,"6",41,80,1,9, 6,"7",41,90,1,9, 7,"8",41,100,1,9, 8,"9",41,110,1,9, 9,"10",41,120,1,9
DATA 10,"ALL",65,130,3,9, 11,"RESET",74,130,5,9
DATA 12,"SET",0,130,5,9
DATA 13,"1",44,130,1,9, 14,"2",46,130,1,9, 15,"3",48,130,1,9, 16,"4",50,130,1,9, 17,"5",52,130,1,9
DATA 18,"6",54,130,1,9, 19,"7",56,130,1,9, 20,"8",58,130,1,9, 21,"9",60,130,1,9, 22,"10",62,130,1,9
DATA 23," ",4,80,20,49, 24," ",44,80,20,49
DATA 25," ",26,80,20,49, 26," ",66,80,20,49
DATA 27," ",33,80,20,49, 28," ",73,80,20,49
' 9
icones_samples_sm5:
DATA 23,0,0
DATA 0,"CONVERT",1,90,11,9
DATA 1,"/2",1,115,3,9, 2,"/3",5,115,3,9, 3,"/4",9,115,3,9
DATA 4,"x2",1,125,3,9, 5,"x3",5,125,3,9, 6,"x4",9,125,3,9
DATA 7,"DO",50,90,13,9
DATA 8,"Hz        =>      ",15,90,18,9
DATA 9,"NOTE      =>      ",15,115,18,9
DATA 10,"Hz        =>      ",15,125,18,9
DATA 11,"NONE",36,95,11,9, 12,"LINEAR",36,105,11,9, 13,"3RD DEGREE",36,115,11,9
DATA 14,"START      Hz",50,105,13,9, 15,"END        Hz",50,115,13,9
DATA 16,"# OF PTS     ",50,125,13,9
DATA 17,"LINEAR",66,90,6,9, 18,"dB",73,90,5,9
DATA 19,"NONE",66,115,12,9, 20,"BLACKMAN",66,125,12,9
DATA 21," ",33,107,0,5, 22," ",63,82,0,5
' 10
icones_samples_sm6:
DATA 30,0,0
DATA 0,"ON",44,85,2,9, 1,"DELAY TIME      ms",47,85,18,9, 2,"LEVEL      %",66,85,12,9
DATA 3,"ON",44,95,2,9, 4,"DELAY TIME      ms",47,95,18,9, 5,"LEVEL      %",66,95,12,9
DATA 6,"ON",44,105,2,9, 7,"DELAY TIME      ms",47,105,18,9, 8,"LEVEL      %",66,105,12,9
DATA 9,"ON",44,115,2,9, 10,"DELAY TIME      ms",47,115,18,9, 11,"LEVEL      %",66,115,12,9
DATA 12,"SAMPLE SOURCE   ",29,130,16,9, 13,"¸",46,130,1,9, 14,"˝",48,130,1,9, 15," ",50,130,29,9
DATA 16,"DO",30,113,9,13
DATA 17,"FEEDBACK       % ",1,85,17,9, 18,"TIME FEED      ms",1,95,17,9
DATA 19,"DRY LEVEL        %",21,85,18,9, 20,"DELAY LEVEL      %",21,95,18,9
DATA 21,"MULTI-TAP MODE",1,115,18,9
DATA 22,"MUTE IN :",1,125,9,9, 23,"      ms",11,125,8,9
DATA 24,"1",22,115,1,9, 25,"2",24,115,1,9, 26,"3",26,115,1,9
DATA 27,"4",22,125,1,9, 28,"5",24,125,1,9, 29,"6",26,125,1,9
' 11
icones_tools2:
DATA 11,0,5
DATA 0,".../...",72,90,7,9
DATA 1,"ECHO",21,40,7,9, 2,"CONT",31,40,7,9
DATA 3,"EVERY   LINES",21,55,13,9, 4,"¸",35,55,1,9, 5,"˝",37,55,1,9
DATA 6," ",21,70,1,9, 7,"FEEDBACK     %",24,70,14,9
DATA 8," ",21,85,1,9, 9,"FADESTEP      ",24,85,14,9
DATA 10,"VOLUME SLIDE",41,35,15,9
' 12
icones_instr:
DATA 42,0,5
DATA 0," ",21,34,1,7, 1," ",24,34,19,7
DATA 2," ",21,40,1,7, 3," ",24,40,19,7
DATA 4," ",21,46,1,7, 5," ",24,46,19,7
DATA 6," ",21,52,1,7, 7," ",24,52,19,7
DATA 8," ",21,58,1,7, 9," ",24,58,19,7
DATA 10," ",21,64,1,7, 11," ",24,64,19,7
DATA 12," ",21,70,1,7, 13," ",24,70,19,7
DATA 14," ",21,76,1,7, 15," ",24,76,19,7
DATA 16,"¸",45,35,1,9, 17,"˝",45,45,1,9
DATA 18,"FROM      ",49,60,10,9, 19,"¸",60,60,1,9, 20,"˝",62,60,1,9
DATA 21,"TO        ",49,70,10,9, 22,"¸",60,70,1,9, 23,"˝",62,70,1,9
DATA 24,"VOLUME    ",49,85,10,9, 25,"¸",60,85,1,9, 26,"˝",62,85,1,9
DATA 27,"VOLUME   ",65,45,9,9, 28,"¸",75,45,1,9, 29,"˝",77,45,1,9
DATA 30,"TON      ",65,55,9,9, 31,"¸",75,55,1,9, 32,"˝",77,55,1,9
DATA 33,"PAN      ",65,65,9,9, 34,"¸",75,65,1,9, 35,"˝",77,65,1,9
DATA 36,"¸",27,85,1,9, 37,"˝",29,85,1,9
DATA 38,"¸",44,85,1,9, 39,"˝",46,85,1,9
DATA 40,"LIST",65,80,13,14
DATA 41,"GROUP",52,35,7,19
' 13
icones_instr_list:
DATA 17,0,5
DATA 0,"1st PAGE",69,75,9,19
DATA 1,"¸",53,35,1,9, 2,"˝",53,45,1,9
DATA 3,"TOP",56,35,3,9
DATA 4,"LOAD INSTRUMENT",61,35,17,9
DATA 5,"LOAD & KEEP SPL",61,45,17,9
DATA 6,"SAVE INSTRUMENT",61,55,17,9
DATA 7," ",21,35,30,5
DATA 8," ",21,41,30,5
DATA 9," ",21,47,30,5
DATA 10," ",21,53,30,5
DATA 11," ",21,59,30,5
DATA 12," ",21,65,30,5
DATA 13," ",21,71,30,5
DATA 14," ",21,77,30,5
DATA 15," ",21,83,30,5
DATA 16," ",21,89,30,5
' 14
icones_sample:
DATA 34,0,5
DATA 0,"SAMPLE       ",21,35,13,9, 1,"¸",35,35,1,9, 2,"˝",37,35,1,9
DATA 3,"NAME                             ",39,35,33,9
DATA 4,"LENGTH       ",21,50,13,9, 5,"¸",35,50,1,9, 6,"˝",37,50,1,9
DATA 7,"REPEAT       ",21,60,13,9, 8,"¸",35,60,1,9, 9,"˝",37,60,1,9
DATA 10,"REPLEN       ",21,70,13,9, 11,"¸",35,70,1,9, 12,"˝",37,70,1,9
DATA 13,"VOLUME     ",41,50,11,9, 14,"¸",53,50,1,9, 15,"˝",55,50,1,9
DATA 16,"FINETUNE   ",41,60,11,9, 17,"¸",53,60,1,9, 18,"˝",55,60,1,9
DATA 19,"BALANCE    ",41,70,11,9, 20,"¸",53,70,1,9, 21,"˝",55,70,1,9
DATA 22,"FREQUENCY      ",59,50,15,9, 23,"¸",75,50,1,9, 24,"˝",77,50,1,9
DATA 25,"NBR OF BITS    ",59,60,15,9, 26,"¸",75,60,1,9, 27,"˝",77,60,1,9
DATA 28,"KILL",74,35,4,9
DATA 29,"LIST",71,75,7,19
DATA 30,"LOAD",21,85,7,9, 31,"SAVE",29,85,7,9
DATA 32,"SAMPLE FILE      ",50,85,17,9
DATA 33,"SIGNED",39,85,8,9
' 15
icones_sample_list:
DATA 15,0,5
DATA 0,"1st PAGE",69,75,9,19
DATA 1,"¸",53,35,1,9, 2,"˝",53,45,1,9
DATA 3,"TOP",56,35,3,9
DATA 4,"INSTRUMENT ?",61,35,17,9
DATA 5," ",21,35,30,5
DATA 6," ",21,41,30,5
DATA 7," ",21,47,30,5
DATA 8," ",21,53,30,5
DATA 9," ",21,59,30,5
DATA 10," ",21,65,30,5
DATA 11," ",21,71,30,5
DATA 12," ",21,77,30,5
DATA 13," ",21,83,30,5
DATA 14," ",21,89,30,5
' 16
icones_panneau_principal:
DATA 28,0,0
DATA 0,"POSITION      ",0,0,14,9, 1,"¸",15,0,1,9, 2,"˝",17,0,1,9
DATA 3,"PATTERN       ",0,10,14,9, 4,"¸",15,10,1,9, 5,"˝",17,10,1,9
DATA 6,"LENGTH        ",0,20,14,9, 7,"¸",15,20,1,9, 8,"˝",17,20,1,9
DATA 9,"REPEAT        ",0,30,14,9, 10,"¸",15,30,1,9, 11,"˝",17,30,1,9
DATA 12,"INSTRUMENT    ",0,45,14,9, 13,"¸",15,45,1,9, 14,"˝",17,45,1,9
DATA 15,"SAMPLE        ",0,55,14,9, 16,"¸",15,55,1,9, 17,"˝",17,55,1,9
DATA 18,"STEP   ",7,65,7,9, 19,"¸",15,65,1,9, 20,"˝",17,65,1,9
DATA 21,"SONGNAME                                 ",0,110,41,9
DATA 22,"INSTRNAME                             ",42,110,37,9
DATA 23,"TRACKS   ",0,80,9,9, 24,"LINES    ",0,90,9,9
DATA 25," ",0,65,6,9
DATA 26,"ON/OFF",0,120,7,9, 27,"PRESET",0,130,7,9
' 17
icones_enveloppe_volume:
DATA 49,0,5
DATA 0," ",21,35,3,5
DATA 1," ",21,41,3,5
DATA 2," ",21,47,3,5
DATA 3," ",21,53,3,5
DATA 4," ",21,59,3,5
DATA 5," ",21,65,3,5
DATA 6," ",21,71,3,5
DATA 7," ",21,77,3,5
DATA 8," ",21,83,3,5
DATA 9," ",21,89,3,5
DATA 10," ",26,35,15,5
DATA 11," ",26,41,15,5
DATA 12," ",26,47,15,5
DATA 13," ",26,53,15,5
DATA 14," ",26,59,15,5
DATA 15," ",26,65,15,5
DATA 16," ",26,71,15,5
DATA 17," ",26,77,15,5
DATA 18," ",26,83,15,5
DATA 19," ",26,89,15,5
DATA 20," ",68,35,10,5
DATA 21," ",68,41,10,5
DATA 22," ",68,47,10,5
DATA 23," ",68,53,10,5
DATA 24," ",68,59,10,5
DATA 25," ",68,65,10,5
DATA 26," ",68,71,10,5
DATA 27," ",68,77,10,5
DATA 28," ",68,83,10,5
DATA 29," ",68,89,10,5
DATA 30,"¸",43,35,1,9, 31,"˝",43,45,1,9
DATA 32,"¸",65,35,1,9, 33,"˝",65,45,1,9
DATA 34,"VOLUME",46,35,6,9, 35,"TONE",53,35,5,9, 36,"PAN",59,35,4,9
DATA 37,"ATTACK",47,45,7,9, 38,"KEY OFF",55,45,7,9
DATA 39,"ENVELOPE   ",43,60,11,9, 40,"¸",55,60,1,9, 41,"˝",57,60,1,9
DATA 42,"CLR ENV",59,60,7,9
DATA 43," ",44,70,21,9
DATA 44,"DEL COM",43,85,7,9
DATA 45,"COPY",52,85,6,9, 46," ",59,85,3,9, 47,"¸",63,85,1,9, 48,"˝",65,85,1,9
' 18
icones_tools3:
DATA 16,0,5
DATA 0,".../...",72,90,7,9
DATA 1,"¸",44,35,1,9, 2,"˝",44,45,1,9
DATA 3,"TOP",47,35,3,9
DATA 4,"INSERT POS",52,35,11,9, 5,"DELETE POS",52,45,11,9
DATA 6," ",21,35,30,5
DATA 7," ",21,41,30,5
DATA 8," ",21,47,30,5
DATA 9," ",21,53,30,5
DATA 10," ",21,59,30,5
DATA 11," ",21,65,30,5
DATA 12," ",21,71,30,5
DATA 13," ",21,77,30,5
DATA 14," ",21,83,30,5
DATA 15," ",21,89,30,5
' 19
icones_samples_sm7_1:
DATA 16,0,0
DATA 0,"2nd PAGE",61,115,17,19
DATA 1,"LEFT CHANNEL",1,95,13,9, 2,"RIGHT CHANNEL",1,105,13,9, 3,"MIX L & R CHN",1,115,13,9
DATA 4,"DRY LEVEL         %",17,95,19,9, 5,"FLANGE LEVEL      %",17,105,19,9
DATA 6,"FLANGE TIME      ms",39,95,19,9
DATA 7,"FLANGE FREQ      Hz",39,105,19,9
DATA 8,"FLANGE DEPTH     ms",39,115,19,9
DATA 9,"INIT PHASE       „ ",39,125,19,9
DATA 10,"1",61,95,1,9, 11,"2",64,95,1,9, 12,"3",67,95,1,9
DATA 13,"4",70,95,1,9, 14,"5",73,95,1,9, 15,"6",76,95,1,9
' 20
icones_samples_sm7_2:
DATA 20,0,0
DATA 0,"1st PAGE",67,115,11,19
DATA 1,"LEFT SOURCE    ",1,85,15,9, 2,"¸",17,85,1,9, 3,"˝",19,85,1,9, 4," ",21,85,29,9
DATA 5,"RIGHT SOURCE   ",1,115,15,9, 6,"¸",17,115,1,9, 7,"˝",19,115,1,9, 8," ",21,115,29,9
DATA 9,"LEFT ˛ LEFT        %",10,95,20,9, 10,"LEFT ˛ RIGHT      %",31,95,19,9
DATA 11,"RIGHT ˛ RIGHT      %",10,125,20,9, 12,"RIGHT ˛ LEFT      %",31,125,19,9
DATA 13,"MONO",67,85,11,9, 14,"STEREO",67,95,11,9
DATA 15,"SIN",53,85,11,9, 16,"SQUARE",53,95,11,9, 17,"TRIANGLE",53,105,11,9
DATA 18,"RAMP DOWN",53,115,11,9, 19,"RAMP UP",53,125,11,9
' 21
icones_samples_sm8_1:
DATA 16,0,0
DATA 0,"EXTRA",71,120,8,19
DATA 1,"REVERBERATION",1,85,22,9
DATA 2,"DRY LEVEL            %",1,105,22,9
DATA 3,"REVERB LEVEL         %",1,115,22,9
DATA 4,"EARLY REF LEVEL      %",1,125,22,9
DATA 5,"NUMBER OF TAPS   ",26,95,17,9, 6,"¸",44,95,1,9, 7,"˝",46,95,1,9
DATA 8,"NUMBER OF C.F.   ",50,95,17,9, 9,"¸",68,95,1,9, 10,"˝",70,95,1,9
DATA 11,"OVERALL GAIN        %",50,105,21,9
DATA 12,"SOURCE   ",26,125,9,9, 13,"¸",36,125,1,9, 14,"˝",38,125,1,9
DATA 15," ",40,125,29,9
' 22
icones_samples_sm8_2:
DATA 14,0,0
DATA 0,"MAIN PAGE",68,120,11,19
DATA 1," ",1,90,1,41, 2," ",4,90,4,41, 3," ",10,90,4,41
DATA 4,"¸",16,90,1,9, 5,"˝",16,100,1,9
DATA 6," ",20,90,1,41, 7," ",23,90,4,41, 8," ",29,90,4,41
DATA 9,"¸",35,90,1,9, 10,"˝",35,100,1,9
DATA 11,"DELAY      ms",39,95,13,9, 12,"GAIN       % ",53,95,13,9
DATA 13,"DELAY      ms",39,125,13,9
' 23
icones_song2disk:
DATA 22,0,0
DATA 0," ",7,95,1,9, 1," ",12,95,1,9
DATA 2," ",7,105,1,9, 3," ",12,105,1,9
DATA 4,"8 BITS",17,85,7,9, 5,"16 BITS",25,85,7,9
DATA 6,"MONO",17,105,7,9, 7,"STEREO",25,105,7,9
DATA 8,"BLOCK",35,95,5,9, 9,"DISK",35,105,5,9
DATA 10,"MAXIMUM DURATION      s ",43,95,24,9
DATA 11,"MAXIMUM SIZE          Kb",43,105,24,9
DATA 12,"1  HIGH",70,95,8,9, 13,"2",70,105,2,9, 14,"3",73,105,2,9, 15,"4",76,105,2,9
DATA 16,"5",70,115,2,9, 17,"6",73,115,2,9, 18,"7",76,115,2,9, 19,"8   LOW",70,125,8,9
DATA 20,"RECORD",1,125,9,9
DATA 21,"MONITOR",58,125,9,9
' 24
texte_icone1:
DATA 17,0,0
DATA 0,"PLAY SONG",20,0,11,9, 1,"EDIT",32,0,11,9, 2,"INSERT POS",44,0,11,9
DATA 3,"PREFS",56,0,11,9, 4,"SCORE",68,0,11,9
DATA 5,"PLAY PAT.",20,10,11,9, 6,"STOP",32,10,11,9, 7,"DELETE POS",44,10,11,9
DATA 8,"DRUM EDITOR",56,10,11,9, 9,"SAMP EDITOR",68,10,11,9
DATA 10,"DISK",20,20,6,9, 11,"TOOLS",27,20,6,9, 12,"INSTRUMENTS",34,20,11,9
DATA 13,"SAMPLES",46,20,7,9, 14,"ENVELOPES",54,20,9,9, 15,"CONTROL",64,20,9,9
DATA 16,"MIDI",74,20,5,9
' 25
icones_control:
DATA 50,0,5
DATA 0,"VOLUMES",21,75,9,19, 1,"RESET",44,35,5,9
DATA 2," ",21,40,2,47, 3," ",21,92,2,5
DATA 4," ",26,40,2,47, 5," ",26,92,2,5
DATA 6," ",31,40,2,47, 7," ",31,92,2,5
DATA 8,"TEMPO    ",36,75,9,9, 9,"¸",46,75,1,9, 10,"˝",48,75,1,9
DATA 11,"SPEED    ",36,85,9,9, 12,"¸",46,85,1,9, 13,"˝",48,85,1,9
DATA 14,"01-08",36,45,6,9, 15,"09-16",43,45,6,9
DATA 16,"17-24",36,55,6,9, 17,"25-32",43,55,6,9
DATA 18," ",56,32,2,5, 19,"ˇ",60,31,1,7, 20,"˛",62,31,1,7, 21," ",52,40,11,5
DATA 22," ",56,49,2,5, 23,"ˇ",60,48,1,7, 24,"˛",62,48,1,7, 25," ",52,57,11,5
DATA 26," ",56,66,2,5, 27,"ˇ",60,65,1,7, 28,"˛",62,65,1,7, 29," ",52,74,11,5
DATA 30," ",56,83,2,5, 31,"ˇ",60,82,1,7, 32,"˛",62,82,1,7, 33," ",52,91,11,5
DATA 34," ",70,32,2,5, 35,"ˇ",74,31,1,7, 36,"˛",76,31,1,7, 37," ",66,40,11,5
DATA 38," ",70,49,2,5, 39,"ˇ",74,48,1,7, 40,"˛",76,48,1,7, 41," ",66,57,11,5
DATA 42," ",70,66,2,5, 43,"ˇ",74,65,1,7, 44,"˛",76,65,1,7, 45," ",66,74,11,5
DATA 46," ",70,83,2,5, 47,"ˇ",74,82,1,7, 48,"˛",76,82,1,7, 49," ",66,91,11,5
' 26
icones_samples_sm9:
DATA 9,0,0
DATA 0,"DO",1,85,15,49
DATA 1,"SOURCE   ",19,125,9,9, 2,"¸",29,125,1,9, 3,"˝",31,125,1,9
DATA 4," ",33,125,29,9
DATA 5,"LEVEL       %",19,85,13,9
DATA 6,"SPEED    ",19,105,9,9, 7,"¸",29,105,1,9, 8,"˝",31,105,1,9
' 27
icones_midi1:
DATA 15,0,5
DATA 0,"IN",26,34,3,9, 1,"OUT",30,34,3,9
DATA 2,"IN",26,46,3,9, 3,"OUT",30,46,3,9
DATA 4," ",0,0,0,0
DATA 5," ",0,0,0,0
DATA 6,"MONOPHONIC",21,75,12,9, 7,"POLYPHONIC",21,85,12,9
DATA 8,"CHANNEL      ",48,45,13,9, 9,"¸",62,45,1,9, 10,"˝",64,45,1,9
DATA 11,"INSTRUMENT   ",48,55,13,9, 12,"¸",62,55,1,9, 13,"˝",64,55,1,9
DATA 14,"P.M. CONF",67,85,11,9
' 28
icones_midi2:
DATA 42,0,5
DATA 0,"1",55,31,2,15, 1,"2",58,31,2,15, 2,"3",61,31,2,15, 3,"4",64,31,2,15
DATA 4,"5",67,31,2,15, 5,"6",70,31,2,15, 6,"7",73,31,2,15, 7,"8",76,31,2,15
DATA 8,"9",55,48,2,15, 9,"10",58,48,2,15, 10,"11",61,48,2,15, 11,"12",64,48,2,15
DATA 12,"13",67,48,2,15, 13,"14",70,48,2,15, 14,"15",73,48,2,15, 15,"16",76,48,2,15
DATA 16,"17",55,65,2,15, 17,"18",58,65,2,15, 18,"19",61,65,2,15, 19,"20",64,65,2,15
DATA 20,"21",67,65,2,15, 21,"22",70,65,2,15, 22,"23",73,65,2,15, 23,"24",76,65,2,15
DATA 24,"25",55,82,2,15, 25,"26",58,82,2,15, 26,"27",61,82,2,15, 27,"28",64,82,2,15
DATA 28,"29",67,82,2,15, 29,"30",70,82,2,15, 30,"31",73,82,2,15, 31,"32",76,82,2,15
DATA 32,"MIDI CHANNEL     ",21,35,17,9, 33,"¸",39,35,1,9, 34,"˝",41,35,1,9
DATA 35,"INSTRUMENT       ",21,45,17,9, 36,"¸",39,45,1,9, 37,"˝",41,45,1,9
DATA 38,"SELECT CURRENT PRESET",21,60,21,9
DATA 39,"REMOVE MIDI CHANNEL",21,70,21,9
DATA 40,"RESET",21,85,5,9
DATA 41,"GENERAL CONF",29,85,15,9
' 29
icones_samples_sm10:
DATA 8,0,0
DATA 0,"DISTORTION!",1,85,13,49
DATA 1,"SOURCE   ",17,125,9,9, 2,"¸",27,125,1,9, 3,"˝",29,125,1,9
DATA 4," ",31,125,29,9
DATA 5,"GAIN      %",17,85,11,9, 6,"¸",29,85,1,9, 7,"˝",31,85,1,9
' 30
icones_drumeditor_main:
DATA 36,0,0
DATA 0,"RECORD",1,5,9,9, 1,"PLAY",1,15,9,9, 2,"STOP",1,25,9,9
DATA 3,"REAL TIME",18,45,9,9
DATA 4,"TEMPO      ",12,5,11,9, 5,"¸", 24,5,1,9, 6,"˝",26,5,1,9
DATA 7,"BEAT LEN   ",12,15,11,9, 8,"¸", 24,15,1,9, 9,"˝",26,15,1,9
DATA 10,"PAT LEN    ",12,25,11,9, 11,"¸",24,25,1,9, 12,"˝",26,25,1,9
DATA 13,"PATTERN    ",29,5,11,9, 14,"¸",41,5,1,9, 15,"˝",43,5,1,9
DATA 16,"IMPORT",29,15,7,9, 17,"EXPORT",37,15,7,9
DATA 18,"MAIN MENU",67,5,11,9
DATA 19,"SCORE",1,45,7,9, 20,"INFOS",9,45,7,9
DATA 21,"ˇ",29,45,3,9, 22,"˛",33,45,3,9
DATA 23,"",1,70,12,9
DATA 24,"PAN                 ",14,70,20,9
DATA 25,"VOL",35,70,3,9, 26,"¸",39,70,1,9, 27,"˝",41,70,1,9
DATA 28,"TRACK   ",43,70,8,9, 29,"¸",52,70,1,9, 30,"˝",54,70,1,9
DATA 31,"",56,70,18,9, 32,"¸",75,70,1,9, 33,"˝",77,70,1,9
DATA 34,"",1,70,10,9, 35,"X",12,70,1,9
' 31
icones_control_2:
DATA 20,0,5
DATA 0,"1ST PAGE",36,75,9,19, 1,"RESET",44,35,5,9
DATA 2," ",21,40,2,47, 3," ",21,92,2,5
DATA 4," ",26,40,2,47, 5," ",26,92,2,5
DATA 6," ",31,40,2,47, 7," ",31,92,2,5
DATA 8,"01-08",36,45,6,9, 9,"09-16",43,45,6,9
DATA 10,"17-24",36,55,6,9, 11,"25-32",43,55,6,9
DATA 12," ",56,40,1,47, 13," ",59,40,1,47, 14," ",62,40,1,47, 15," ",65,40,1,47
DATA 16," ",68,40,1,47, 17," ",71,40,1,47, 18," ",74,40,1,47, 19," ",77,40,1,47
' Fin des donnees des sous-menus:
DATA -1
'
' 0
popup_mod_ext:
DATA 11
DATA "*.GT2",0
DATA "*.GTK",1
DATA "*.MOD",2
DATA "*.S3M",3
DATA "*.DTM",4
DATA "*.MMD",5
DATA "*.MTM",6
DATA "*.669",7
DATA "*.ULT",8
DATA "*.XM",9
DATA "*.*",10
' 1
popup_spl_ext:
DATA 5
DATA "*.AVR",0
DATA "*.SPL",1
DATA "*.WAV",2
DATA "*.VOC",3
DATA "*.*",4
' 2
popup_path_type:
DATA 7
DATA "System",0
DATA "Module",1
DATA "Preferences",2
DATA "Sample",3
DATA "Instrument",4
DATA "Autoload",5
DATA "Miscellaneous",6
' 3
popup_linestep:
DATA 8
DATA "Next volume",259
DATA "Next FX",258
DATA "Next note",257
DATA "Next line taken",256
DATA "1 line",1
DATA "2 lines",2
DATA "4 lines",4
DATA "8 lines",8
' 4
popup_midi_in_poly:
DATA 9
DATA "Channel type:",$40000
DATA "Melody",0
DATA "Drums",1
DATA "Note Off:",$40000
DATA "Transcribed",10
DATA "Ignored",11
DATA "Velocity:",$40000
DATA "Transcribed",20
DATA "Ignored",21
' Fin des donnees des pop-up:
DATA -1
'
touches_notes:
DATA 44,31,45,32,46,47,34,48,35,49,36,50,51,38,52,39,53
DATA 16,3,17,4,18,19,6,20,7,21,8,22,23,10,24,11,25,26,13,27,41
'
enveloppe_coms:
DATA $0,6
DATA "End",0,"Jump to ",0,"Wait ",50,"Set Counter ",1,"Loop to ",0,"Key Off",0
DATA $80,11
DATA "Volume ",$4000,"Vol Step ",0,"Vol Speed ",1
DATA "Tremolo On",0,"Tremolo Off",0,"Trem Width ",$10,"Trem Speed ",8
DATA "Tremor On",0,"Tremor Off",0,"TremorTime1 ",3,"TremorTime2 ",3
DATA $A0,7
DATA "Period ",$1000,"Tone Step ",0,"Tone Speed ",1
DATA "Vibrato On",0,"Vibrato Off",0,"Vib Width ",3,"Vib Speed ",8
DATA $C0,3
DATA "Panning ",$800,"Pan Step ",0,"Pan Speed ",1
'
rev_tap_delay_level:
DATA 0,0.213, 0.0349,0.135, 0.0714,0.051, 0.0178,0.217, 0.0371,0.153, 0.0317,0.174, 0.0627,0.157
rev_comb_delay_lpf:
DATA 0.0547,0.448, 0.07,0.496, 0.0448,0.408, 0.0646,0.476
'
keycode_names:
' A mettre dans l'ordre:
' * devant le nom: 1 parametre apres
' ^ devant le nom: groupement de touches
DATA "CURSOR LEFT","CURSOR RIGHT","PREV LINE","NEXT LINE"
DATA "PREV OCTAVE","NEXT OCTAVE","PREV COLUMN","NEXT COLUMN"
DATA "PREV BAR","NEXT BAR","PREV SONGPOS","NEXT SONGPOS"
DATA "PREV PRESET","NEXT PRESET","DEC STEP","INC STEP"
DATA "DEC HIGH","INC HIGH","PLAY LINE","PLAY SONG"
DATA "CONT SONG","PLAY PATTERN","CONT PATTERN","STOP/EDIT"
DATA "PREV INSTR","NEXT INSTR","PREV SAMPLE","NEXT SAMPLE"
DATA "EXPAND","CPU TIME","REPLAY FREQ","INTERPOLATION ONE TRACK"
DATA "INTERPOLATION ALL TRACKS","LOAD MODULE","SAVE MODULE","RESYNC SCREEN"
DATA "SNAPSHOT","INSTRPAD/SAMPLEPAD/DRUMPAD","HELP","BLOCK START"
DATA "BLOCK END","INSTR UNDER CURSOR","CLEAR NOTE","CLEAR EFFECT"
DATA "CLEAR VOLUME","CLEAR WHOLE NOTE","COPY BLOCK (TRACK)","COPY BLOCK (PATTERN)"
DATA "COPY BLOCK (PRESET)","COPY BLOCK (TRACK UNDER CURSOR)","INSERT LINE IN PATTERN","INSERT LINE IN TRACK"
DATA "INSERT LINE IN PRESET","ROTATE & INSERT LINE IN PATTERN","ROTATE & INSERT LINE IN TRACK","ROTATE & INSERT LINE IN PRESET"
DATA "DELETE LINE IN PATTERN","DELETE LINE IN TRACK","DELETE LINE IN PRESET","ROTATE & DELETE LINE IN PATTERN"
DATA "ROTATE & DELETE LINE IN TRACK","ROTATE & DELETE LINE IN PRESET","*LINE","*LINE"
DATA "*LINE","*LINE","*LINE","*LINE"
DATA "*LINE","*LINE","*LINE","*LINE"
DATA "*^SELECT PRESET","*^SELECT PRESET","*^REC PRESET","*^REC PRESET"
DATA "*^INSTR/SAMPLE/DRUM","*^INSTR/SAMPLE/DRUM","*^REC INSTR/SAMPLE/DRUM","*^REC INSTR/SAMPLE/DRUM"
DATA "*^TRACK ON/OFF","*^TRACK ON/OFF","*^REC TRACK ON/OFF","*^REC TRACK ON/OFF"
DATA "***","***"
'
key_scancode_to_ascii:
DATA "AZERTYUIOP","QSDFGHJKLM","WXCVBN,"
DATA "QWERTYUIOP","ASDFGHJKL:","ZXCVBNM"
'
default_keycodes:
DATA 84
DATA FFF0000,4B0000,F000100,0,0
DATA FFF0000,4D0000,F000100,0,0
DATA FFF0000,480000,F000100,0,0
DATA FFF0000,500000,F000100,0,0
DATA CFF0100,10100,F000100,0,0
DATA FFF0000,10000,F000100,0,0
DATA CFF0100,F0100,F000100,0,0
DATA FFF0000,F0000,F000100,0,0
DATA CFF0100,480100,F000100,0,0
DATA CFF0100,500100,F000100,0,0
DATA CFF0100,4B0100,F000100,0,0
DATA CFF0100,4D0100,F000100,0,0
DATA FFF0000,44B0000,F000100,0,0
DATA FFF0000,44D0000,F000100,0,0
DATA C0001FF,4000153,F000100,0,0
DATA F0000FF,4000053,F000100,0,0
DATA CFF0100,4480100,F000100,0,0
DATA CFF0100,4500100,F000100,0,0
DATA FFF0000,1C0000,F000100,0,0
DATA FFF0000,700000,F000100,0,0
DATA FFF0000,3E0000,F000100,0,0
DATA CFF0100,1C0100,CFF0100,700100,0
DATA CFF0100,3E0100,F000100,0,0
DATA FFF0000,390000,F000100,0,0
DATA FFF0000,520000,F000100,0,0
DATA FFF0000,470000,F000100,0,0
DATA 0,0,0,0,0
DATA 0,0,0,0,0
DATA F0000FF,4000045,F000100,0,0
DATA F0000FF,4000044,F000100,0,0
DATA F0000FF,4000052,F000100,0,0
DATA F0000FF,4000049,F000100,0,0
DATA C0001FF,4000149,F000100,0,0
DATA F0000FF,800004C,F000100,0,0
DATA F0000FF,8000053,F000100,0,0
DATA F0000FF,800004D,F000100,0,0
DATA F0000FF,C000050,F000100,0,0
DATA FFF0000,3F0000,F000100,0,0
DATA FFF0000,620000,F000100,0,0
DATA FFF0000,3B0000,F000100,0,0
DATA CFF0100,3B0100,F000100,0,0
DATA FFF0000,710000,F000100,0,0
DATA FFF0000,E0000,F000100,0,0
DATA CFF0100,E0100,F000100,0,0
DATA FFF0000,80E0000,F000100,0,0
DATA FFF0000,40E0000,F000100,0,0
DATA FFF0000,3C0000,F000100,0,0
DATA CFF0100,3C0100,F000100,0,0
DATA FFF0000,43C0000,F000100,0,0
DATA FFF0000,83C0000,F000100,0,0
DATA FFF0000,2520000,F000100,0,0
DATA FFF0000,4520000,F000100,0,0
DATA FFF0000,6520000,F000100,0,0
DATA FFF0000,3520000,F000100,0,0
DATA FFF0000,5520000,F000100,0,0
DATA FFF0000,7520000,F000100,0,0
DATA FFF0000,2530000,F000100,0,0
DATA FFF0000,4530000,F000100,0,0
DATA FFF0000,6530000,F000100,0,0
DATA FFF0000,3530000,F000100,0,0
DATA FFF0000,5530000,F000100,0,0
DATA FFF0000,7530000,F000100,0,0
DATA FFF0000,400000,F000100,0,0
DATA FFF0000,410000,F000100,0,10
DATA FFF0000,420000,F000100,0,20
DATA FFF0000,430000,F000100,0,30
DATA FFF0000,440000,F000100,0,3F
DATA CFF0100,400100,F000100,0,40
DATA CFF0100,410100,F000100,0,50
DATA CFF0100,420100,F000100,0,60
DATA CFF0100,430100,F000100,0,70
DATA CFF0100,440100,F000100,0,7F
DATA 0,0,0,0,0
DATA 0,0,0,0,10
DATA 0,0,0,0,0
DATA 0,0,0,0,10
DATA F000300,200,F000100,0,0
DATA F000200,1000200,F000100,0,10
DATA F000200,2000200,F000100,0,0
DATA F000200,3000200,F000100,0,10
DATA 0,0,0,0,0
DATA 0,0,0,0,10
DATA 0,0,0,0,0
DATA 0,0,0,0,10
'
help_text:
DATA "              ******************************************"
DATA "              *                                        *"
DATA "              *     G R A O U M F   T R A C K E R      *"
DATA "              *                                        *"
DATA "              *           Version Beta-demo            *"
DATA "              *      by Laurent de SORAS - 1994/96     *"
DATA "              *                                        *"
DATA "              *                                        *"
DATA "              *   "Tu fais moins l'malin maintenant,   *"
DATA "              *         tu fais moins l'malin !"       *"
DATA "              *                                        *"
DATA "              ******************************************"
DATA ""
DATA "                             ------------"
DATA "                             -   HELP   -"
DATA "                             ------------"
DATA ""
DATA "Graoumf Tracker is Shareware!!!"
DATA "You can copy me, but if you like me, you MUST send your money to my"
DATA "creator (100 FF, $25 or 30 DM):"
DATA "Laurent de Soras"
DATA "92 Avenue Albert 1er"
DATA "92500 Rueil-Malmaison"
DATA "FRANCE"
'
DATA "Notes"
DATA "-----"
DATA ""
DATA "C  C# D  D# E     F  F# G  G# A  A# B     C  C# D  D# E    F  F# G  G#"
DATA "----------------------------------------------------------------------"
DATA "   2     3           5     6    7            9     0          -     `"
DATA "A     Z     E     R     T     Y     U     I     O     P    ^     $"
DATA "----------------------------------------------------------------------"
DATA "   S     D           G     H     J           L     M"
DATA "W     X     C     V     B     N     ,     ;     :     ="
DATA "----------------------------------------------------------------------"
DATA ""
DATA "Standard keys (you can redefine them)"
DATA "-------------------------------------"
DATA ""
DATA "SHIFT + ˇ ou ˛            : Position +/-"
DATA "SHIFT + ¸ ou ˝            : Jump to the next bar"
DATA "TAB                       : Cursor on next column"
DATA "SHIFT + TAB               : Cursor on prev column"
DATA "CTRL + ˇ ou ˛             : Preset +/-"
DATA "BACKSPACE                 : Clear note & instr under the curseur"
DATA "SHIFT + BACKSPACE         : Clear effect"
DATA "CTRL + BACKSPACE          : Clear note, instr & effect"
DATA "ALT + BACKSPACE           : Clear volume"
'
DATA "CTRL + DELETE             : Delete note (track)"
DATA "Left SHIFT + DELETE       : Delete note (pattern)"
DATA "Left SHIFT + CTRL + DEL   : Delete note (preset)"
DATA "CTRL + INSERT             : Insert note (track)"
DATA "Left SHIFT + INSERT       : Insert note (pattern)"
DATA "Left SHIFT + CTRL + INS   : Insert note (preset)"
DATA "These 6 commands + r SHIFT: Rotation of the track/pattern/preset"
DATA "Numeric Pad (+right SHIFT): Select an instrument"
DATA "INSERT                    : Prev instrument"
DATA "CLR HOME                  : Next instrument"
DATA "ESC (+ SHIFT)             : Next (prev) octave"
DATA "F5                        : NumPad is Instr/Sample/Drum-pad"
DATA "Left SHIFT + Numeric Pad  : Assign an Instr/Sample/Note to a key"
DATA "0 on NumPad               : Play song"
DATA "SHIFT + RET or + 0 on Pad : Play pattern"
DATA "RETURN                    : Play line"
DATA "F4                        : Cont song"
DATA "SHIFT + F4                : Cont pattern"
DATA "F1                        : Define block start"
DATA "SHIFT + F1                : Define block end"
DATA "F2                        : Paste block (piste)"
DATA "SHIFT + F2                : Paste block (pattern)"
DATA "CTRL + F2                 : Paste block (preset)"
DATA "ALT + F2                  : Paste block (track under the cursor)"
'
DATA "F6 - F10 (+ SHIFT)        : Line 00, 10, 20, 30 et 3F (+40)"
DATA "CTRL + SHIFT + ¸          : Increase pattern window height"
DATA "CTRL + SHIFT + ˝          : Decrease pattern window height"
DATA "CTRL + D                  : Display CPU time"
DATA "CTRL + E                  : Change pattern display mode:"
DATA "                            - Note + Instr"
DATA "                            - Note + Instr + FX"
DATA "                            - Note + Instr + FX + Volume"
DATA "CTRL + I                  : Interpolation On/Off (track)"
DATA "CTRL + SHIFT + I          : Interpolation On/Off (pattern)"
DATA "CTRL + R                  : Change replay frequency"
DATA "CTRL + S                  : Increase the LineStep"
DATA "  + SHIFT                 : Decrease the LineStep"
DATA "ALT + L                   : Load module"
DATA "ALT + S                   : Save module"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'
DATA "Effects"
DATA "-------"
DATA ""
DATA "01xx : Portamento up"
DATA "02xx : Portamento down"
DATA "03xx : Tone portamento"
DATA "04xy : Vibrato"
DATA "05xx : Tone portamento + Vibrato"
DATA "06xy : Vibrato + Tone portamento"
DATA "07xy : Tremolo"
DATA "08xy : Detune"
DATA "09xx : Note delay"
DATA "0Axx : Cut note"
DATA "0Bxx : Go to position xx"
DATA "0C?x : Set vibrato waveform"
DATA "0Dxx : Break pattern"
DATA "0E?x : Set tremolo waveform"
DATA "0Fxx : Set global speed/Tempo"
DATA "10xy : Arpeggio"
DATA "11xx : Fine portamento up"
DATA "12xx : Fine portamento down"
DATA "13xy : Roll + Volume slide"
DATA "14xx : Linear volume slide up"
DATA "15xx : Linear volume slide down"
'
DATA "16xx : Exp. volume slide up"
DATA "17xx : Exp. volume slide down"
DATA "18xx : Linear volume slide up + Tone portamento"
DATA "19xx : Linear volume slide down + Tone portamento"
DATA "1Axx : Exp. volume slide up + Tone portamento"
DATA "1Bxx : Exp. volume slide down + Tone portamento"
DATA "1Cxx : Linear volume slide up + Vibrato"
DATA "1Dxx : Linear volume slide down + Vibrato"
DATA "1Exx : Exp. volume slide up + Vibrato"
DATA "1Fxx : Exp. volume slide down + Vibrato"
DATA "A0xx : Linear master volume slide up"
DATA "A1xx : Linear master volume slide down"
DATA "A4xx : Fine linear volume up"
DATA "A5xx : Fine linear volume down"
DATA "A6xx : Fine linear master volume up"
DATA "A7xx : Fine linear master volume down"
DATA "A8xx : Set number of frames"
DATA "A9xx : Set fine speed"
DATA "AAxx : Pattern delay"
DATA "ABxx : Extra fine tone portamento"
DATA "ACxx : Extra fine portamento up"
DATA "ADxx : Extra fine portamento down"
DATA "AExx : Left balance move"
DATA "AFxx : Right balance move"
'
DATA "B0xy : Tremor"
DATA "B1xx : Pattern loop"
DATA "B2xx : Set flags... +1: Linear interpolation on the track"
DATA "B3xx : Set Volume Envelope"
DATA "B4xx : Set Tone Evelope"
DATA "B5xx : Set Panning Envelope"
DATA "B6xx : Set Volume Envelope and Key Off"
DATA "B7xx : Set Tone Envelope and Key Off"
DATA "B8xx : Set Panning Envelope and Key Off"
DATA "BAxx : Fine Sample Offset"
DATA "BBxx : Very Fine Sample Offset"
DATA "BCxx : Increment Sample Position"
DATA "BDxx : Decrement Sample Position"
DATA "BExx : Auto Tempo"
DATA "BFxx : Auto Period"
DATA "C2xx : Set linear track volume"
DATA "C3xx : Set exponential track volume"
DATA "C4xx : Linear track volume slide up"
DATA "C5xx : Linear track volume slide down"
DATA "C6xx : Exponential track volume slide up"
DATA "C7xx : Exponential track volume slide down"
DATA "C8xx : Fine exponential track volume slide up"
DATA "C9xx : Fine exponential track volume slide down"
DATA ""
'
DATA "2xxx : Set linear volume"
DATA "3xxx : Set exp. volume"
DATA "4xxx : Set balance"
DATA "5xxx : Set master linear volume"
DATA "6xxx : Set master esp. volume"
DATA "7xyy : Roll"
DATA "8xyz : Roll + volume slide + set balance"
DATA "9xxx : Sample Offset"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'
DATA "THE CRUCIFICTION OF SEAN PENN"
DATA ""
DATA "We're gonna kill the California girls"
DATA "We're gonna fire the exploding load"
DATA "in the milkmaid maidenhead"
DATA "We're gonna find the meaning of feeling good"
DATA "And we're gonna stay there as long as we think we should"
DATA "  Mystery train"
DATA "  Three way plane"
DATA "  Expressway to yr skull"
DATA ""
DATA "                                               (SoNiC YoUTh / E.V.O.L)"
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
DATA ""
'    "1234567890123456789012345678901234567890123456789012345678901234567890"
DATA "***"
'
textes_blagues:
DATA "Mr et Mme BRICOT ont un fils,|comment l'appellent-ils ?||R : Judas","*"
DATA "Mr et Mme POTDANLAPOCHE ont une fille,|comment l'appellent-ils ?||R : Jessica","*"
DATA "Mr et Mme PEULAFENETRE ont trois fils,|comment les appellent-ils ?||R : Geoffroy, Angele, Firmin","*"
DATA "Mr et Mme HERGEBEL ont un fils,|comment l'appellent-ils ?||R : Octave","*"
DATA "Mr et Mme PAFROI ont sept fils,|comment les appellent-ils ?||R : Eva, Aude, Anne, Marc, Sanson, Gilles et Ella","*"
DATA "Mr et Mme PROVISTSAPU ont trois fils,|comment les appellent-ils ?||R : Quentin, Gaspard, Alain","*"
DATA "Mr et Mme LIOTEKDAKAJOU ont un fils,|comment l'appellent-ils ?||R : Habib","*"
DATA "Mr et Mme REMORD ont un fils,|comment l'appellent-ils ?||R : Yves","*"
DATA "Mr et Mme POURLAVERLCARLAGE ont un fils,|comment l'appellent-ils ?||R : Vladimir","*"
DATA "Mr et Mme CREMENT ont un fils,|comment l'appellent-ils ?||R : Alex","*"
DATA "Mr et Mme TANANANANANANA ont deux fils,|comment les appellent-ils ?||R : Starsky et Hutch","*"
DATA "Mr et Mme LFRIGO ont cinq fils,|comment les appellent-ils ?||R : Steve, Eude, Hubert, Yann, Adam","*"
DATA "Mr et Mme ERVITMONSLIP ont un fils,|comment l'appellent-ils ?||R : Jean-Philippe","*"
DATA "Mr et Mme ZELPOURMONMOTEUR ont un fils,|comment l'appellent-ils ?||R : Didier","*"
DATA "Mr et Mme MAIJAVALPA ont un fils,|comment l'appellent-ils ?||R : Jesus","*"
DATA "Mr et Mme MAROLEX ont une fille,|comment l'appellent-ils ?||R : Eleonore","*"
DATA "Mr et Mme PONSABLDUMATOS ont une fille,|comment l'appellent-ils ?||R : Therese","*"
DATA "Mr et Mme LUTFINALE ont une fille,|comment l'appellent-ils ?||R : Sheila","*"
DATA "Mr et Mme CHMONFILS ont un fils,|comment l'appellent-ils ?||R : Thierry","*"
DATA "Mr et Mme BIENUNPTICASCROUTE ont un fils,|comment l'appellent-ils ?||R : Humphrey","*"
DATA "Mr et Mme BISTROJAISOIF ont un fils,|comment l'appellent-ils ?||R : Alonzo","*"
DATA "Mr et Mme CONERY ont une fille,|comment l'appellent-ils ?||R : Aretha","*"
DATA "Mr et Mme PUDBIERDANLFRIGO ont un fils,|comment l'appellent-ils ?||R : Roger","*"
DATA "Mr et Mme ITZEGOUDWAITOUZESTATION ont une fille,|comment l'appellent-ils ?||R : Eloise","*"
DATA "Mr et Mme POURIEN ont trois fils,|comment les appellent-ils ?||R : Yvon, Paul et Mickey","*"
DATA "Mr et Mme AMAR ont cinq fils,|comment les appellent-ils ?||R : Ella, Pacome, Ancel, Helene,|Nadege","*"
DATA "Mr et Mme NAIBOURREDAITA ont trois fils,|comment les appelent-ils ?||R : Derek, Tom, Jean","*"
DATA "Mr et Mme ORER ont un fils,|qui est l'ami du fils de|Mr et Mme JEUNER. Comment|s'appelle le fils des ORER ?||R : Rick|Car Rick ORER, l'ami du petit des JEUNER","*"
DATA "Mr et Mme MACOUVERTURMEGRAT ont une fille,|comment l'appellent-ils ?||R : Sandra","*"
DATA "Mr et Mme SURLELITETPASSURLECANAPE ont un chien,|comment l'appelent-ils ?||R : Medor","*"
DATA C'est un chat|qui se fait eventrer|par John Borg|qui a besoin de|nouvelles|cordes.||Le chat dit :|"C'est du racket!"
DATA "*","C'est deux Corses qui se promenent.|Tout d'un coup, l'un deux se retourne"
DATA "et ecrase un escargot. L'autre :|- Ben pourquoi t'as fait ca ?"
DATA "- Ca faisait un quart d'heure|que cette bestiole nous suivait!","*"
DATA "2 vieilles dames discutent|sur la terrasse d'un cafe :"
DATA "- J'ai l'impression que l'homme la-bas,|il nous regarde avec envie."
DATA "- Tu m'etonnes, c'est l'antiquaire!","*"
DATA "Saviez-vous qu'il y a deux|sortes de Pastis ?|- Le Pastis 51 au gout d'anis|- Le Pastis 69 au gout d'anus","*"
DATA "C'est un type qui veut se suicider."
DATA "Pour son dernier jour, il se lave, se coiffe,"
DATA "se relave, met du Petrol Hane, du parfum,"
DATA "enfile ses plus beaux habits."
DATA "Il monte en haut de la Tour Eiffel, et saute."
DATA "Le corps s'ecrase, suivi plusieurs secondes"
DATA "apres de ses cheveux.|Pourquoi ?|"
DATA "R : parceque Petrol Hane ralentit|la chute des cheveux...","*"
DATA "C'est un gars qui a une moumoute et|qui va chez le coiffeur"
DATA "La, rien a faire, les ciseaux|n'arrivent pas a couper les cheveux.|Pourquoi ?|"
DATA "R : parceque les faux tifs ne sont pas coupables","*"
DATA "Pourquoi les Somaliens ne prennent-|ils pas de medicament ?||R : C'est marque dessus :|"A prendre apres chaque repas","*"
DATA "Qu'est-ce qui est le plus|dur a manger dans|un legume ?||R : la chaise roulante","*"
DATA "Quel est le point commun entre|un myopathe et un spaghetti ?||R : Le spaghetti bouge quand|on le suce...","*"
DATA "Qu'est-ce qui est vert|et qui devient rouge|quand on appuie sur|un bouton ?||R : Une grenouille dans un mixer","*"
DATA "Qu'est-ce qui est vert|et qui pue au fond des bois ?||R : Un scout mort","*"
DATA "Qu'est-ce qui est rouge|et qui a plus de cervelle|que Kurt Cobain ?||R : Son plafond","*"
DATA "Qu'est-ce qui est petit, rouge,|et qui avance en faisant|beaucoup de bruit ?||R : Un bebe sucant des lames de rasoir","*"
DATA "Qu'est-ce qui est petit, rouge,|et qui ne tourne pas dans|les couloirs ?||R : Un enfant avec un javelot|dans la tete.","*"
DATA "Qu'est-ce qu'une boite jaune a|l'exterieur et noire a l'interieur ?||R : Une R4 de la Poste","*"
DATA "Qu'y a-t-il de pire qu'un|bebe dans une poubelle ?||R : Un bebe dans deux poubelles","*"
DATA "Qu'est-ce qu'un combat|d'eunuques ?||R : c'est un combat sanglant","*"
DATA "C'est J.C. Vandame qui rentre|dans sa bagnole et qui|fout l'contact","*"
DATA "C'est Stallone qui va au|bal et qui se rend beau","*"
DATA "C'est un mec qui rentre|dans un cafe et PLOUF!","*"
DATA "C'est un sanglier qui|croise un cochon:|- Ca se passe bien pour|toi la chimiotherapie ?","*"
DATA "Vous connaissez l'histoire|de Paf le chien ?||C'est un chien qui traverse|l'autoroute et PAF le chien!","*"
DATA "Vous connaissez l'histoire|de Scroutch l'escargot ?||C'est un escargot qui passe|sous un rouleau compresseur|et SCROUTCH l'escargot!","*"
DATA "Vous connaissez l'histoire|de Zip le pingouin ?||C'est un pingouin qui se promene|sur la banquise et ZIP le pingouin!","*"
DATA "Vous connaissez l'histoire|de Flip-Flop la girafe ?||C'est un helicoptere qui fait du|rase-motte et FLIP-FLOP la girafe!","*"
DATA "Vous connaissez l'histoire|de Tiens la vieille ?||C'est une vieille qui se fait|frapper et TIENS la vieille!","*"
DATA "***"
