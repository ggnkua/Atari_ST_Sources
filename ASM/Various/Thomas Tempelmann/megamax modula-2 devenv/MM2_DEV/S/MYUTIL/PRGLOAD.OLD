  MODULE PrgLoad; (*$E MAC  -> Linker erzeugt ACC-Endung *)  (*!* Hinweis/Copyright:!* ------------------!*   Die Verîffentlichungsrechte dieses Programms und seiner Quellen liegt!*   beim Autor Thomas Tempelmann und der Zeitschrift TOS (ICP-Verlag,!*   MÅnchen-Vaterstetten).!*!*   Mit Erwerb der Zeitschrift "TOS" steht es Ihnen frei, das Programm!*   zu nutzen. Das Programm ist also keine Freeware oder PD!!*   Sie dÅrfen das Programm verÑndern, jedoch nicht selbst "verbesserte"!*   Versionen dieses Programm verbreiten. Dies obliegt allein dem Urheber,!*   also Thomas Tempelmann.!*!*   Ich hoffe, Sie beachten diese Hinweise. Ich wÑre schwer enttÑuscht,!*   wenn plîtzlich eine Version 2.1, die nicht von mir stammt, auf!*   dem PD- oder Raubkopiermarkt erscheint. Dann kînnte dies der letzte!*   Beitrag von mir gewesen sein. Fairness und Vertrauen sind wichtig!*   fÅr das Weiterleben dieser Form der Softwareverîffentlichung!!*!*   FÅr weitere Fragen und WÅnsche wenden Sie sich bitte an mich:!*      Thomas Tempelmann, Nordendstr. 64, D-8000 MÅnchen 40.!*!* öber dieses Programm:!* ---------------------!*   In der Ausgabe 4/91 der Zeitschrift TOS finden Sie die ausfÅhrliche!*   Beschreibung dieses nÅtzlichen Programms.!*!*   Dieses Modul ist ohne énderungen nur mit Megamax Modula-2 (System 2.2,!*   Compiler 4.0) oder hîher Åbersetzbar. Desweiteren gehîren die beiden!*   Quellen des Moduls "PrgLoader" (PRGLOADE.D & PRGLOADE.I) zu diesem!*   Programm und mÅssen zuvor Åbersetzt werden.!*!* Mîgliche Verbesserungen:!* ------------------------!* - öberwachen, ob "UsedHeapSize" bei jedem Programmlauf gleich bleibt.!* - Selbstmodifizierenden Code erkennen und dann Warnung anzeigen mit!*   Option, das Programm freizugeben.!*!*----------------------------------------------------------------------------!* 22.10.88  TT  Grunderstellung ModLoad!* 21.12.88  TT  Fertigstellung der Version 1.0 aus ModLoad 1.0!* 20.12.90  TT  Fertigstellung der Version 2.0 aus ModLoad 1.3!*----------------------------------------------------------------------------!*)  (*$R-,S-  Keine Bereichs-, öberlauf- und Stack-PrÅfungen erzeugen *)  FROM PrgLoader IMPORT"QueryLoaded, LoadProgram, UnLoadProgram, ProgramLoaded, CallProgram,"UsedHeapSize, LoaderResults;  FROM SYSTEM IMPORT"ASSEMBLER, CAST, ADDRESS, ADR, TSIZE, BYTE, WORD, LONGWORD;  FROM AESWindows IMPORT"UpdateWindow;  FROM AESForms IMPORT"FormAlert;  FROM AESMisc IMPORT"ShellFind;  FROM AESMisc IMPORT"SelectFile;  FROM EasyGEM0 IMPORT"WrapAlert;  FROM MOSGlobals IMPORT"PathStr, NameStr, FileStr, SfxStr, MemArea;  FROM FileNames IMPORT"FileName, PathConc, SplitPath, SplitName;  FROM Files IMPORT"File, Open, Close, EOF, State, Access;  FROM Text IMPORT"EOL, ReadFromLine, ReadLn;  FROM StrConv IMPORT"CardToStr, StrToLCard;  FROM GEMEnv IMPORT"InitApplication, ExitApplication;  FROM AESEvents IMPORT"MessageEvent, MessageBuffer, accOpen;  FROM AESMenus IMPORT"RegisterAcc;  FROM PrgCtrl IMPORT"Accessory;  FROM MOSCtrl IMPORT"ProcessID (* Zeiger auf den aktuellen GEMDOS-Prozeû *);  FROM SysInfo IMPORT"UseStackFrame;  FROM Directory IMPORT"GetDefaultPath;  IMPORT FuncStrings, Strings, XBRA, BIOS;   CONST   LoaderStackSize = 4000; (* Stackgrîûe zum Aufruf des Loaders *) (Kennung = 'PrgL';       (* XBRA-Kennung fÅr TRAP #1-Handler *)(PrgName = 'PrgLoad';    (* Name dieses Moduls (auch ACC-Eintrag) *)(Version = '2.0';        (* Nicht Ñndern und verîffentlichen (s.o.)! *)(InfName = 'PRGLOAD.INF';(* Name der INF-Datei *)   TYPE PtrPexecPar = POINTER TO RECORD5mode: (loadExec, unused1, unused2, load, exec, create);5fileName: ADDRESS;5arg: ADDRESS;5env: ADDRESS3END; %PexecRes = RECORD2exitCode: INTEGER;2didExec: BOOLEAN;0END;  VAR"DefaultHeap: LONGCARD;    (* Heap-Grîûe, wenn keine andere Angabe *)"DidShowInfo, GotHeapSize, GetHeapSize: BOOLEAN;"Desktop: ADDRESS;         (* Prozeûkennung des Desktops, invariabel *) "myName: Strings.String;"path: ARRAY [0..127] OF CHAR;"arg: ARRAY [0..128] OF CHAR; "entry, at: ADDRESS;"carrier: XBRA.Carrier;"stackhi: ADDRESS;"doingPexec: BOOLEAN;"stackFrameOffs: SHORTCARD;"ok: BOOLEAN;   PROCEDURE Alert (s: ARRAY OF CHAR); "VAR button: CARDINAL;&ok: BOOLEAN;&msg: ARRAY [0..250] OF CHAR; "BEGIN$Strings.Assign (s, msg, ok);$(* Meldung mit FormAlert-Dialog anzeigen *)$WrapAlert (msg, 0);$Strings.Insert ('[0][', 0, msg, ok);$Strings.Append ('][ OK ]', msg, ok);$FormAlert (1, msg, button);"END Alert;  PROCEDURE doLoadWithMsg (REF name: ARRAY OF CHAR);"VAR result: LoaderResults;"BEGIN$IF ProcessID^ # Desktop THEN&Alert ("Das Laden ist nur vom Desktop aus mîglich!")$ELSE&SplitPath (name, path, arg);&LoadProgram (name, DefaultHeap, result);&IF result = noError THEN(Strings.Append (' wurde geladen', arg, ok)&ELSIF result = alreadyLoaded THEN(Strings.Append (' ist bereits geladen', arg, ok)&ELSE(Strings.Append (' kann nicht geladen werden', arg, ok)&END;&Alert (arg)$END;"END doLoadWithMsg;  PROCEDURE doUnLoadWithMsg (REF name: ARRAY OF CHAR);"VAR result: LoaderResults;"BEGIN$SplitPath (name, path, arg);$UnLoadProgram (name, result);$IF result = noError THEN&Strings.Append (' wurde freigegeben', arg, ok);$ELSE&Strings.Append (' war nicht geladen', arg, ok)$END;$Alert (arg)"END doUnLoadWithMsg;  PROCEDURE hdlPexec (par: PtrPexecPar): PexecRes;"(* Return: TRUE: alte Pexec-Funktion aufrufen, sonst Trap beenden *) "PROCEDURE getArg (dosArg: ADDRESS; VAR txt: ARRAY OF CHAR);$(*%* Wandelt Pexec-Argumentzeile in String um%*)$BEGIN&ASSEMBLER(MOVE.L  dosArg(A6),A0           ; A0: dosArg(MOVE.L  txt(A6),A1              ; A1: ADR (txt)(CLR     D0(MOVE.B  (A0)+,D0                ; LÑnge der Arg-Zeile(BRA     c&l MOVE.B  (A0)+,(A1)+             ; Zeile kopieren&c DBRA    D0,l(CLR.B   (A1)                    ; String-Ende mit 0C abschlieûen&END$END getArg; "VAR fn: POINTER TO FileStr;&sfx: SfxStr;&exitCode: LONGINT;&result: LoaderResults;&res: PexecRes;&ok: BOOLEAN; "BEGIN (* hdlPexec *)$res.didExec:= FALSE;$res.exitCode:= 0;$fn:= par^.fileName;$IF par^.mode = loadExec (*trifft immer zu, da schon vorher geprÅft*) THEN&IF (ProcessID^ = Desktop) & (BIOS.ControlKey IN BIOS.GetKBShift ()) THEN((* Das Laden ist nur vom Desktop aus erlaubt! *)(IF BIOS.LeftShift IN BIOS.GetKBShift () THEN*doUnLoadWithMsg (fn^)(ELSE*doLoadWithMsg (fn^)(END;(res.didExec:= TRUE&ELSE(IF GetHeapSize OR ProgramLoaded (fn^) THEN*(* hier normalerweise nur geladene Programme starten; nicht+* geladene Programme "normal" Åber GEMDOS starten lassen+* (s. 'hdlGemdos') *)*getArg (par^.arg, arg);*GotHeapSize:= TRUE;*CallProgram (fn^, arg, par^.env, exitCode);*res.exitCode:= SHORT (exitCode);*res.didExec:= TRUE(END&END;$END;$RETURN res"END hdlPexec;  VAR regStack: ARRAY [1..256] OF WORD; (* Stack fÅr Register-Sicherung *)  PROCEDURE hdlGemdos;"(*$L-*)"BEGIN$ASSEMBLER(BTST.B  #5,(A7)         ; War Supervisormode aktiv ?(BNE.B   super           ; Ja, dann stehen Arg. auf SSP(MOVE.L  USP,A0(CMPI.W  #$4B,(A0)       ; Pexec - Funktion ?(BEQ.B   hdlPexecUser dos     ; normale GEMDOS-Funktion ausfÅhren(MOVE.L  entry,A0(MOVE.L  -4(A0),A0(JMP     (A0) super   MOVE.W  stackFrameOffs,D0(CMPI.W  #$4B,6(A7,D0.W) ; Pexec - Funktion ?(BNE.B   dos             ; Nein -> GEMDOS aufrufen(LEA     6(A7,D0.W),A0   ; Basis d. Argumente nach A0 hdlPexecUser:(TST.W   doingPexec      ; ist dies der "Pexec" von "CallModule"?(BEQ     noPexec         ;   nein -> dann werten wir ihn selbst aus. (CLR.W   doingPexec(BRA     dos             ;   ja -> dann lassen wir ihn zum GEMDOS durch  noPexec ; prÅfen, ob Prg gestartet & ausgefÅhrt werden soll.(ADDQ.L  #2,A0(CMPI    #loadExec,PtrPexecPar.mode(A0)(BNE     dos (MOVE.L  stackhi,A1      ; neuen SP f. Modula-Funktionen laden(; Register auf regStack retten:(MOVEM.L D1-D7/A2-A6,-(A1)(MOVE.W  (A7)+,-(A1)     ; SR vom SSP retten(MOVE.L  (A7)+,-(A1)     ; PC vom SSP retten(TST.W   stackFrameOffs  ; StackFrame vorhanden?(BEQ     noSF1           ; nein(MOVE.W  (A7)+,-(A1)     ; StackFrame vom SSP retten noSF1:  MOVE.L  USP,A2(MOVE.L  A2,-(A1)        ; USP retten(MOVE.L  A7,-(A1)        ; SSP retten(MOVE.L  A1,stackhi(MOVE.L  A1,USP          ; den regStack auch fÅr Malloc-Aufruf nutzen(ANDI    #$CFFF,SR       ; User Mode aktivieren (; Stack f. Modula-Funktionen (Loader-Aufruf) reservieren(MOVE.L  A0,-(A7)(MOVE.L  #LoaderStackSize,-(A7)(MOVE    #$48,-(A7)      ; Malloc()(TRAP    #1(ADDQ.L  #6,A7(MOVE.L  (A7)+,A0(MOVE.L  D0,A3(LEA     LoaderStackSize(A3),A7 (MOVE    #1,doingPexec(MOVE.L  A0,(A3)+(JSR     hdlPexec        ; Pexec-Sonderbehandlung(CLR.W   doingPexec(MOVE.L  -(A3),D0        ; Pexec - RÅckgabewert (; Modula-Stack wieder freigeben(MOVE.L  stackhi,A7      ; regStack wieder fÅr SP verwenden(MOVE.L  D0,-(A7)(MOVE.L  A3,-(A7)(MOVE    #$49,-(A7)      ; Mfree()(TRAP    #1(ADDQ.L  #6,A7((; zurÅck in den Supervisor-Mode:(CLR.L   -(A7)(MOVE    #$20,-(A7)(TRAP    #1(ADDQ.L  #6,A7(MOVE.L  (A7)+,D0((MOVE.L  A7,A1(MOVE.L  (A1)+,A7        ; SSP zurÅck(MOVE.L  (A1)+,A0        ; USP zurÅck(MOVE.L  A0,USP(TST.W   stackFrameOffs  ; StackFrame vorhanden?(BEQ     noSF2           ; nein(MOVE.W  (A1)+,-(A7)     ; StackFrame zurÅck noSF2:  MOVE.L  (A1)+,-(A7)     ; PC zurÅck(MOVE.W  (A1)+,-(A7)     ; SR zurÅck(MOVEM.L (A1)+,D1-D7/A2-A6(MOVE.L  A1,stackhi (TST.W   D0(BEQ     dos             ; Wurde nicht ausgefÅhrt -> GEMDOS aufrufen((SWAP    D0              ; Exitcode liefern(EXT.L   D0(RTE$END"END hdlGemdos;"(*$L=*)  PROCEDURE readInfFile;"(*#* Liest die Datei "MODLOAD.INF" und lÑdt die darin angegebenen Module.#*)""VAR f: File;&s, s2: Strings.String;&heapValid: BOOLEAN;&pos: CARDINAL;&heap: LONGCARD;&result: LoaderResults;""BEGIN$s:= InfName;$ShellFind (s);$Open (f, s, readSeqTxt);$WHILE NOT EOF (f) DO&ReadFromLine (f, s);            (* Programmnamen einlesen *)&ReadLn (f);                     (* Zeilenende Åberlesen *)&Strings.Split (s, Strings.PosLen (' ', s, 0), s, s2, ok);&Strings.Upper (s);&pos:= 0;&heap:= StrToLCard (s2, pos, heapValid);&IF Strings.StrEqual (s, "HEAP") THEN(IF heapValid THEN DefaultHeap:= heap END&ELSE(IF NOT heapValid THEN heap:= DefaultHeap END;(LoadProgram (s, heap, result)   (* Programm laden *)&END$END;$Close (f);"END readInfFile;  PROCEDURE service; "VAR defbut, button: CARDINAL;&s: ARRAY [0..199] OF CHAR;&name: NameStr;&didShow, ok: BOOLEAN; "PROCEDURE showPrg (REF name: ARRAY OF CHAR; heapSize: LONGCARD;5noOfRuns: CARDINAL): BOOLEAN;$BEGIN&s:= "[0][ |";&Strings.Append (FileName (name), s, ok);&Strings.Append (" | |", s, ok);&IF noOfRuns > 0 THEN(Strings.Append ("Benutzte Heap-Grîûe: ", s, ok);(Strings.Append (CardToStr (heapSize, 0), s, ok);&ELSE(Strings.Append ("Wurde noch nicht gestartet", s, ok)&END;&Strings.Append (" | ][Weiter|Freigeben|Abbruch]", s, ok);&FormAlert (1, s, button);&IF button = 2 THEN(doUnLoadWithMsg (name)&END;&didShow:= TRUE;&RETURN button # 3$END showPrg; "BEGIN$IF GetHeapSize THEN&GetHeapSize:= FALSE;&IF NOT GotHeapSize THEN(Alert ('Sie haben doch noch kein Programm gestartet, oder?')&ELSIF UsedHeapSize = MAX (LONGCARD) THEN(Alert ('Das Programm scheint allen verfÅgbaren Speicher zu belegen')&ELSIF UsedHeapSize = 0 THEN(Alert ('Das Programm belegt keinen zusÑtzlichen Heap (Grîûe ist 0)')&ELSE(s:= 'Die belegte Heap-Grîûe ist:';(Strings.Append (CardToStr (UsedHeapSize,0), s, ok);(Alert (s)&END$END;$defbut:= 1;$LOOP&s:= "[0][         PrgLoad "+Version+"|"-+" |"-+"Erstellt von Thomas Tempelmann |"-+"     mit Megamax Modula-2|"-+"  fÅr das TOS-Magazin (4/91)]"-+"[Mehr...|Info|Ausgang]";&IF NOT DidShowInfo THEN(defbut:= 2&END;&FormAlert (defbut, s, button);&IF button = 3 THEN(EXIT&ELSIF button = 2 THEN(FormAlert (1, "[0][Autor:      |  Thomas Tempelmann  |"3+"  Nordendstraûe 64|  D-8000 MÅnchen 40|  West Germany]"3+"[ OK ]", button);(Alert ("AusfÅhrliche Informationen zu diesem Programm finden Sie ".+"im TOS-Magazin Ausgabe 4/91.");(DidShowInfo:= TRUE&ELSE (* button = 1 *)(s:=  "[0][ |WÑhlen Sie:| Geladene Programme zeigen |",+" Heap-Grîûe ermitteln/setzen| ";(IF ProcessID^ = Desktop THEN*(* Das Laden ist nur vom Desktop aus erlaubt! *)*Strings.Append ("Programm laden", s, ok)(END;(Strings.Append ("][ Zeige | Heap ", s, ok);(IF ProcessID^ = Desktop THEN*Strings.Append ("| Lade ", s, ok)(END;(Strings.Append ("]", s, ok);(FormAlert (1, s, button);(IF button = 3 THEN*name:= '';*GetDefaultPath (path);*SelectFile (path, name, ok);*IF ok & (name[0] # '') THEN,doLoadWithMsg (PathConc (path, name));*END(ELSIF button = 1 THEN*didShow:= FALSE;*QueryLoaded (showPrg);*IF NOT didShow THEN,Alert ("Es ist kein Programm geladen")*END(ELSE*FormAlert (1, "[0][ |WÑhlen Sie:|"=+" Benutzte Heap-Grîûe eines |"=+"   Programm ermitteln|"=+" Heap-Grîûe setzen| ]"=+"[Ermitteln|Setzen]", button);*IF button = 1 THEN,Alert ("Starten Sie ein Programm und kehren Sie dann zurÅck");,GotHeapSize:= FALSE;,GetHeapSize:= TRUE;,RETURN*ELSE,LOOP.s:= "[0][Voreingestellte Heap-Grîûe|"1+"zum Laden eines Programms: | |";.Strings.Append (CardToStr (DefaultHeap, 15), s, ok);.Strings.Append ("| ][Mehr|Weniger|OK]", s, ok);.FormAlert (3, s, button);.IF button = 1 THEN0DefaultHeap:= DefaultHeap + DefaultHeap DIV 2.ELSIF button = 2 THEN0DefaultHeap:= DefaultHeap - DefaultHeap DIV 3.ELSE0EXIT.END,END*END(END&END;&defbut:= 3$END (* LOOP *)"END service;  VAR msg: MessageBuffer;$menuID: CARDINAL;$button: CARDINAL;  BEGIN"InitApplication (ok);"IF NOT Accessory () THEN$Alert ('PrgLoad lÑuft nur als Accessory!')"ELSE$doingPexec:= FALSE;$DefaultHeap:= 8192;    (* Heap-Grîûe, wenn keine andere Angabe *)$GetHeapSize:= FALSE;$DidShowInfo:= FALSE;$IF UseStackFrame () THEN stackFrameOffs:= 2 ELSE stackFrameOffs:= 0 END;$Desktop:= ProcessID^;$(* 'hdlGemdos' in TRAP #1 einhÑngen *)$IF NOT XBRA.Installed (Kennung, $84 (* GEMDOS/TRAP#1 *), at) THEN&XBRA.Create (carrier, Kennung, CAST (ADDRESS, hdlGemdos), entry);&XBRA.Install (entry, at);&stackhi:= ADR (regStack) + SIZE (regStack);&myName:= PrgName;&Strings.Insert ('  ', 0, myName, ok);&RegisterAcc (ADR (myName), menuID , ok);&UpdateWindow (TRUE);&readInfFile;&UpdateWindow (FALSE);&LOOP(MessageEvent (msg);(IF (msg.msgType = accOpen) THEN*service(END&END$END"END END PrgLoad.  
(* $FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$000032B5$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DA$FFE9E9DAÄ$000034EBT.......T.......T.......T.......T.......T.......T.......T.......T.......T.......$FFED9C90$FFED9C90$00003311$0000331E$0000332D$00003298$000032B2$0000331B$00002FFC$00002F9B$000034E9$000034D0$000034EB$0000309E$000032EC$000032D4∏ÄÇ*)
