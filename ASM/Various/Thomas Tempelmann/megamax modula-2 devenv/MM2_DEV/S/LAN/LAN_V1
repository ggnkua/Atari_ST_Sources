 MODULE LANMonitor; (*$H+,Z+,R-*)  (* IMPORT TOSDebug; *)  IMPORT SYSTEM; FROM SYSTEM IMPORT ASSEMBLER, BYTE;  IMPORT MOSGlobals, PrgCtrl; IMPORT RandomGen;  IMPORT TOSIO; (*$E MOS *) IMPORT InOut, FuncStrings, StrConv; FROM InOut IMPORT WriteLn, Write, WriteCard, ReadCard, ReadLCard, Read,0GotoXY, WritePg, WriteString, WriteHex, WriteLHex,0KeyPressed, Done, WriteNum, WriteLNum;  FROM GEMDOS IMPORT Super; IMPORT VT52; FROM VT52 IMPORT Codes; IMPORT XBIOS; FROM Storage IMPORT ALLOCATE;   (*****************************************************************************)  MODULE TimerA; (*$L-*)  (*!* Der MFP ist mit 2.4576 MHz getaktet.!*)  FROM SYSTEM IMPORT ASSEMBLER;  EXPORT QUALIFIED Init, Delay1Bit, Delay1Byte,(DelayÊsUntil, DelayBytesUntil, StopProc;  TYPE    StopProc = PROCEDURE  (): BOOLEAN;  PROCEDURE Delay1Bit;"BEGIN$ASSEMBLER(; Delay: 1.5 * bitTime (6.51Ês) = 16 Zyklen(MOVEA.W #$FA00,A0(MOVE.B  #$DF,$0B(A0)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #4,$1F(A0)      ; TADR: Set Timer Count(MOVE.B  #1,$19(A0)      ; TACR: Timer Start (Teiler: 1/4)%l: BTST    #5,$0B(A0)      ; IPRA(BEQ     l(MOVE.B  #$00,$19(A0)    ; TACR: Timer Stop$END"END Delay1Bit;  PROCEDURE Delay1Byte;"BEGIN$ASSEMBLER(; Delay: 1.5 * byteTime (39Ês) = 58 Zyklen(MOVEA.W #$FA00,A0(MOVE.B  #$DF,$0B(A0)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #35,$1F(A0)     ; TADR: Set Timer Count(MOVE.B  #1,$19(A0)      ; TACR: Timer Start (Teiler: 1/4)%l: BTST    #5,$0B(A0)      ; IPRA(BEQ     l(MOVE.B  #$00,$19(A0)    ; TACR: Timer Stop$END"END Delay1Byte;  PROCEDURE DelayBytesUntil (n: CARDINAL; stop: StopProc; condition: BOOLEAN): BOOLEAN;"BEGIN$ASSEMBLER(; Delay: n * 1.5 * byteTime (39Ês) = n * 58.5 Zyklen(; RETURN: FALSE, wenn Zeit abgelaufen,(;         TRUE, wenn stop()=condition lieferte(MOVEM.L D3-D5/A4/A6,-(A7)(MOVE.W  -(A3),D5        ; condition(MOVE.L  -(A3),D4        ; stop (static link)(MOVE.L  -(A3),A4        ; stop (addr)(MOVE.W  -(A3),D3        ; n(MOVEA.W #$FA00,A6(MOVE.B  #$DF,$0B(A6)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #36,$1F(A6)     ; TADR: Set Timer Count(MOVE.B  #1,$19(A6)      ; TACR: Timer Start (Teiler: 1/4)(BRA     c%l: BTST    #5,$0B(A6)      ; IPRA(BNE     g(MOVE.L  D4,D2(JSR     (A4)(CMP.W   D0,D5(BNE     l(MOVEQ   #1,D0(BRA     e%g: MOVE.B  #$DF,$0B(A6)    ; IPRA: Clear Timer-A Pending Bit%c: DBRA    D3,l(MOVEQ   #0,D0%e: MOVE.B  #$00,$19(A6)    ; TACR: Timer Stop(MOVEM.L (A7)+,D3-D5/A4/A6$END"END DelayBytesUntil;  PROCEDURE DelayÊsUntil (n: CARDINAL; stop: StopProc; condition: BOOLEAN): BOOLEAN;"BEGIN$ASSEMBLER(; Delay: n Ês(; RETURN: FALSE, wenn Zeit abgelaufen,(;         TRUE, wenn stop()=condition lieferte(MOVEM.L D4-D5/A4/A6,-(A7)(MOVE.W  -(A3),D5        ; condition(MOVE.L  -(A3),D4        ; stop (static link)(MOVE.L  -(A3),A4        ; stop (addr)(MOVE.W  -(A3),D0        ; n(LSR     #2,D0           ; n DIV 4(MOVEA.W #$FA00,A6(MOVE.B  #$DF,$0B(A6)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  D0,$1F(A6)      ; TADR: Set Timer Count(MOVE.B  #2,$19(A6)      ; TACR: Timer Start (Teiler: 1/10)%l: MOVE.L  D4,D2(JSR     (A4)(CMP.W   D0,D5(BEQ     t(BTST    #5,$0B(A6)      ; IPRA(BEQ     l(MOVEQ   #0,D0(BRA     e%t: MOVEQ   #1,D0%e: MOVE.B  #$00,$19(A6)    ; TACR: Timer Stop(MOVEM.L (A7)+,D4-D5/A4/A6$END"END DelayÊsUntil;  PROCEDURE Delay (teiler, count: CARDINAL);"BEGIN$ASSEMBLER(MOVEA.W #$FA00,A0(MOVE.B  #$DF,$0B(A0)    ; IPRA: Clear Timer-A Pending Bit(MOVE.W  -(A3),D0(MOVE.W  -(A3),D1(MOVE.B  D0,$1F(A0)      ; TADR: Set Timer Count(MOVE.B  D1,$19(A0)      ; TACR: Timer Start%l: BTST    #5,$0B(A0)      ; IPRA(BEQ     l(MOVE.B  #$00,$19(A0)    ; TACR: Timer Stop$END"END Delay;  PROCEDURE Start (teiler, count: CARDINAL);"BEGIN$ASSEMBLER(MOVEA.W #$FA00,A0(MOVE.B  #$DF,$0B(A0)    ; IPRA: Clear Timer-A Pending Bit(MOVE.W  -(A3),D0(MOVE.W  -(A3),D1(MOVE.B  D0,$1F(A0)      ; TADR: Set Timer Count(MOVE.B  D1,$19(A0)      ; TACR: Timer Start%l: END"END Start;  PROCEDURE Stop;"BEGIN$ASSEMBLER(MOVE.B  #$00,$FFFA19    ; TACR: Timer Stop$END"END Stop;  PROCEDURE Down (): BOOLEAN;"BEGIN$ASSEMBLER(BTST    #5,$FFFA0B      ; IPRA(BEQ     no(BCLR    #5,$FFFA0B      ; IPRA: Clear Timer-A Pending Bit(MOVEQ   #1,D0(RTS$no: CLR     D0$END"END Down;  (* nur mit dieser optimierten Schleife sind auf dem Mega STE die!* 1.5*bitTime zu messen:"Start (1,4);"ASSEMBLER(MOVE.L  n,D1(MOVE.L  l,D0(MOVEQ   #5,D2(LEA     $FFFA0B,A0$lo: BTST    D2,(A0)         ; IPRA(BEQ     lo(BCLR    D2,(A0)         ; IPRA: Clear Timer-A Pending Bit(ADDQ.L  #1,D1(CMP.L   hz200,D0(BHI     lo(MOVE.L  D1,n"END; *)  PROCEDURE Init;"BEGIN$ASSEMBLER(MOVEA.W #$FA00,A0(MOVE.B  #$00,$19(A0)    ; TACR: Timer Stop(ANDI.B  #$DF,$13(A0)    ; IMRA: Mask Timer A IR(ORI.B   #$20,$07(A0)    ; IERA: Enable Timer-A Pending Bit(MOVE.B  #$DF,$0B(A0)    ; IPRA: Clear Timer-A Pending Bit$END"END Init;  (*$L=*) END (* MODULE *) TimerA;  (*****************************************************************************)  MODULE SCCDMA; (*$L-*)  FROM SYSTEM IMPORT WORD, ADDRESS, ASSEMBLER;  EXPORT QUALIFIED SetAddr, Addr, SetCount, Count, SetIn, SetOut, Enable,1Finished;  CONST DMA = $FFFF8C00;  PROCEDURE SetAddr (ad: ADDRESS);"BEGIN$ASSEMBLER(MOVE.L  -(A3),D0(MOVE.W  #DMA,A0(MOVEP.L D0,1(A0)$END"END SetAddr;  PROCEDURE Addr (): ADDRESS;"BEGIN$ASSEMBLER(MOVE.W  #DMA,A0(MOVEP.L 1(A0),D0$END"END Addr;  PROCEDURE SetCount (n: LONGCARD);"BEGIN$ASSEMBLER(MOVE.L  -(A3),D0(MOVE.W  #DMA,A0(MOVEP.L D0,9(A0)$END"END SetCount;  PROCEDURE Count (): LONGCARD;"BEGIN$ASSEMBLER(MOVE.W  #DMA,A0(MOVEP.L 9(A0),D0$END"END Count;  PROCEDURE SetControl (n: WORD);"BEGIN$ASSEMBLER(MOVE.W  -(A3),D0(MOVE.B  D0,DMA+$15$END"END SetControl;  PROCEDURE Control (): WORD;"BEGIN$ASSEMBLER(MOVEQ   #0,D0(MOVE.B  DMA+$15,D0$END"END Control;  PROCEDURE SetOut;"BEGIN$ASSEMBLER(BSET    #0,DMA+$15$END"END SetOut;  PROCEDURE SetIn;"BEGIN$ASSEMBLER(BCLR    #0,DMA+$15$END"END SetIn;  PROCEDURE Enable;"BEGIN$ASSEMBLER(BSET    #1,DMA+$15$END"END Enable;  PROCEDURE Disable;"BEGIN$ASSEMBLER(BCLR    #1,DMA+$15$END"END Disable;  PROCEDURE Finished (): BOOLEAN;"BEGIN$ASSEMBLER(MOVE.B  DMA+$15,D0(ANDI.W  #11000000%,D0   ; bus error oder zero count?(SNE     D0(ANDI.W  #1,D0$END"END Finished;  (*$L=*) END (* MODULE *) SCCDMA;  (*****************************************************************************)  MODULE SCC; (*$L-*)  FROM SYSTEM IMPORT WORD, ADDRESS, ASSEMBLER;  IMPORT Super; FROM PrgCtrl IMPORT TermCarrier, CatchProcessTerm; FROM MOSGlobals IMPORT MemArea;  EXPORT QUALIFIED Reg, SetReg, Reset, CTLA;  CONST CTLA = $FFFF8C81;  PROCEDURE Reg (n: CARDINAL): CARDINAL;"BEGIN$ASSEMBLER(MOVE    SR,-(A7)(MOVE    #$2500,SR(MOVEA.W #CTLA,A1(MOVE.W  -(A3),D0(BEQ     read0(MOVE.B  D0,(A1)          ; SCC A control&read0:(MOVE.B  (A1),D0(MOVE    (A7)+,SR$END;"END Reg;  PROCEDURE SetReg (no, value: CARDINAL);"BEGIN$ASSEMBLER(MOVE    SR,-(A7)(MOVE    #$2500,SR(MOVEA.W #CTLA,A1(MOVE.W  -(A3),D1        ; value(MOVE.W  -(A3),D0        ; no(BEQ     write0(MOVE.B  D0,(A1)         ; SCC A control&write0:(MOVE.B  D1,(A1)(MOVE    (A7)+,SR$END;"END SetReg;  (*$L=*)  (****** Vorsicht: ab hier $L+ ******)  PROCEDURE Reset;"BEGIN$SetReg (9, $C0);"END Reset;  PROCEDURE term;"VAR ssp: LONGCARD;"BEGIN$ssp:= Super (0);$SetReg (9, $C0);$ssp:= Super (ssp)"END term;  VAR carrier: TermCarrier;  BEGIN"CatchProcessTerm (carrier, term, MemArea{NIL,0}); END (* MODULE *) SCC;  (*****************************************************************************)  MODULE ALAP;  FROM SYSTEM IMPORT ADR, ASSEMBLER, BITNUM, BYTE, WORD, LONGWORD, ADDRESS, SHIFT; IMPORT SCC, SCCDMA, TimerA; FROM SCC IMPORT CTLA; IMPORT RandomGen; FROM XBIOS IMPORT GIOffBit; IMPORT Super, ALLOCATE;  (* I/O-Routinen fÅr Testausgaben *) IMPORT InOut; FROM FuncStrings IMPORT ConcStr; FROM StrConv IMPORT CardToStr;  EXPORT QUALIFIED"WriteFrame, WriteStatus,"Init, TransmitStatus, TransmitPacket, ReceiveFrame, ReceivePacket,"myAddress, fAdrValid, fAdrInUse, FramesReceived, Interrupts,"maxIFGtime, test, NewPacketBuffer, FrameStatus, anAddress, aLAPtype,"aDataField,"aFrame, aPacket, ptrPacket, maxDataSize, headPacket, tailPacket;   CONST   minFrameSize = 3;(maxFrameSize = 605;(maxDataSize = 600;(((* alle Zeitwerte sind in Ês angegeben *)(bitTime = 5 (* 4.34 *);(byteTime = 39;(minIDGtime = 400;(IDGslottime = 100;(maxIFGtime = 200; (* ist fÅr ENQ->ACK offenbar zu klein. 400-600 besser *)((maxDefers = 32;(maxCollsns = 32;(lapENQ = BYTE($81);(lapACK = BYTE($82);(lapRTS = BYTE($84);(lapCTS = BYTE($85);(wksTries = 2 (* 20!! *);((rxEnable = $DD;(setRTS   = $62;(txEnable = $6B;  TYPE    TransmitStatus = (transmitOK, excessDefers, excessCollsns, dupAddress);(ReceiveStatus = (receiveOK, receiving, nullReceive, frameError);(FrameStatus = (noFrame, lapDATAframe, lapENQframe, lapACKframe,(lapRTSframe, lapCTSframe, badframeCRC, badframeSize, badframeType,(overrunError, underrunError, undefined);((bitVector = SET OF BITNUM[0..7];(octet = BYTE;(anAddress = octet;(aLAPtype = octet;(aDataField = ARRAY [1..maxDataSize] OF octet;(ptrDataField = POINTER TO aDataField; (frameInterpretation = (raw, structured);(aFrame = RECORD3CASE :frameInterpretation OF5raw:7rawData: ARRAY [1..maxFrameSize] OF octet|5structured:7dstAddr: anAddress;7srcAddr: anAddress;7lapType: aLAPtype;7dataField: aDataField3END1END; (ptrPacket = POINTER TO aPacket;(aPacket = RECORD4status: FrameStatus;4length: [0..maxFrameSize];4next  : ptrPacket;4frame : aFrame;4no    : CARDINAL;2END;  VAR     myAddress: anAddress;(backoff: INTEGER;(fAdrValid: BOOLEAN;(fAdrInUse: BOOLEAN;(fCTSexpected: BOOLEAN;(deferCount, collsnCount: INTEGER;(deferHistory, collsnHistory: bitVector;(outgoingLength: INTEGER;(outgoingPacket: aFrame;((packetBuffers: CARDINAL;(tailPacket: ptrPacket;  (* zeigt aufs Ñlteste gÅltige Paket *)(headPacket: ptrPacket;  (* zeigt hinter jÅngstes Paket *)((* wenn head = tail, stehen keine neuen Pakete an. *)((FramesReceived, Interrupts: CARDINAL;((test: BOOLEAN;((IR_Vector [$360]: PROC;  (*$L-*)  PROCEDURE And (a,b:CARDINAL): CARDINAL;"BEGIN$ASSEMBLER(MOVE.W  -(A3),D0(AND.W   -(A3),D0$END"END And;  PROCEDURE Or (a,b:CARDINAL): CARDINAL;"BEGIN$ASSEMBLER(MOVE.W  -(A3),D0(OR.W    -(A3),D0$END"END Or;  PROCEDURE BClr (value, bitno:CARDINAL): CARDINAL;"BEGIN$ASSEMBLER(MOVE.W  -(A3),D1(MOVE.W  -(A3),D0(BCLR    D1,D0$END"END BClr;  PROCEDURE BSet (value, bitno:CARDINAL): CARDINAL;"BEGIN$ASSEMBLER(MOVE.W  -(A3),D1(MOVE.W  -(A3),D0(BSET    D1,D0$END"END BSet;  PROCEDURE In (bitno, value: CARDINAL): BOOLEAN;"BEGIN$ASSEMBLER(MOVE.W  -(A3),D0(MOVE.W  -(A3),D1(BTST    D1,D0(SNE     D0(ANDI    #1,D0$END"END In;  PROCEDURE BitCount (bits: BYTE): INTEGER;"BEGIN$ASSEMBLER(SUBQ.L  #1,A3(MOVE.B  -(A3),D1(MOVEQ   #0,D0(MOVEQ   #7,D2%l: LSR.B   #1,D1(BCC     c(ADDQ    #1,D0%c: DBRA    D2,l$END"END BitCount;  (*$L+*)  (* ------------- Beginn Low-Level ------------------- *)  PROCEDURE carrierSense (): BOOLEAN;"(*$L-*)"BEGIN$(* RETURN NOT (4 IN BITSET(SCC.Reg(0))) *)$ASSEMBLER(BTST    #4,CTLA(SEQ     D0(ANDI    #1,D0$END"END carrierSense;"(*$L=*)  PROCEDURE missingClock (): BOOLEAN;"(*$L-*)"BEGIN$(* RETURN (7 IN BITSET(SCC.Reg(10))) *)$ASSEMBLER(MOVEA.W #CTLA,A1(MOVE.B  #10,(A1)(TST.B   (A1)            ; RR10(SMI     D0(ANDI    #1,D0$END"END missingClock;"(*$L=*)  PROCEDURE resetError;"BEGIN$SCC.SetReg (0, $30)"END resetError;  PROCEDURE setAddress (n: BYTE);"BEGIN$SCC.SetReg(6, ORD(n))"END setAddress;  PROCEDURE enableRx;"BEGIN$SCC.SetReg(3, rxEnable)"END enableRx;  PROCEDURE resetRx;"BEGIN$ASSEMBLER(MOVEA.W #CTLA,A1(; resetRx(MOVE.B  #3,(A1)(MOVE.B  #$D0,(A1)       ; disableRx(MOVEQ   #2,D0&flushFIFO:(TST.B   2(A1)(DBRA    D0,flushFIFO((MOVE.B  #3,(A1)(MOVE.B  #rxEnable,(A1)  ; enableRx(; reset error(MOVE.B  #$30,(A1)((; MOVE.B  #1,(A1)(; MOVE.B  #$08,(A1)         ; enable IR on first Rx((; MOVE.B  #$20,(A1)         ; enable IR on next Rx$END"END resetRx;  PROCEDURE resetMissingClock ();"BEGIN$SCC.SetReg(14, $41);"END resetMissingClock;  (* ------------- Ende Low-Level ------------------- *)  PROCEDURE min (a,b: INTEGER): INTEGER;"BEGIN$IF a < b THEN RETURN a ELSE RETURN b END"END min;  PROCEDURE max (a,b: INTEGER): INTEGER;"BEGIN$IF a > b THEN RETURN a ELSE RETURN b END"END max;  PROCEDURE random (maxMin1: INTEGER): INTEGER;"BEGIN$RETURN RandomGen.RandomCard (0, maxMin1-1)"END random;  PROCEDURE Wr (REF s: ARRAY OF CHAR);"BEGIN$InOut.WriteString (s);$InOut.WriteLn;"END Wr;  PROCEDURE WriteFrame (REF packet: aPacket; no: CARDINAL);"VAR n: CARDINAL;"BEGIN$FOR n:= 1 TO 5 DO&IF n > packet.length THEN(InOut.WriteString ('   ');&ELSE(InOut.WriteHex (LONG (packet.frame.rawData [n]), 3);&END$END;$FOR n:= 6 TO no DO&IF n <= packet.length THEN(InOut.WriteHex (LONG (packet.frame.rawData [n]), 3);(IF (ORD (packet.frame.rawData [n]) >= 32) AND+(ORD (packet.frame.rawData [n]) < 128) THEN*InOut.Write ('/');*InOut.Write (CHAR(packet.frame.rawData [n]));(END&END$END;$InOut.WriteString (' ');"END WriteFrame;  PROCEDURE WriteStatus (status: FrameStatus);"BEGIN$CASE status OF&|badframeCRC: InOut.WriteString ('>badframeCRC<')&|badframeSize: InOut.WriteString ('>badframeSize<');&|badframeType: InOut.WriteString ('>badframeType<')&|overrunError: InOut.WriteString ('>overrunError<')&|underrunError: InOut.WriteString ('>underrunError<')&|lapACKframe: InOut.WriteString ('>ACKframe<')&|lapENQframe: InOut.WriteString ('>ENQframe<');&|lapRTSframe: InOut.WriteString ('>RTSframe<');&|lapDATAframe: InOut.WriteString ('>DATAframe<');&|noFrame: InOut.WriteString ('no frame!');$ELSE&InOut.WriteString ('unknown frame!');$END;"END WriteStatus;  (* --------------------------- *)  FORWARD AcquireAddress (hint: BYTE; server: BOOLEAN); FORWARD TransmitPacket (dstParam: anAddress; typeParam: aLAPtype; REF dataParam: aDataField; dataLength: INTEGER): TransmitStatus; FORWARD TransmitLinkMgmt (): TransmitStatus; FORWARD TransmitFrame (REF frame: aFrame; framesize: CARDINAL); FORWARD ReceiveFrame (VAR packet: ptrPacket): FrameStatus; FORWARD ReceiveLinkMgmt (VAR packet: ptrPacket): ReceiveStatus; FORWARD IR_Handler; FORWARD GetFrame;  PROCEDURE NewPacketBuffer;"VAR p, prev, last: ptrPacket; sr: CARDINAL;"BEGIN$ASSEMBLER(MOVE    SR,sr(A6)(MOVE    #$2500,SR$END;$NEW (p);$IF p # NIL THEN&IF packetBuffers = 0 THEN(headPacket:= p;(tailPacket:= p;(last:= p&ELSE(prev:= headPacket;(WHILE prev^.next # tailPacket DO*prev:= prev^.next(END;(last:= prev^.next;(prev^.next:= p&END;&INC (packetBuffers);&WITH p^ DO(next:= last;(status:= undefined;(no:= packetBuffers&END;$END;$ASSEMBLER(MOVE    sr(A6),SR$END;"END NewPacketBuffer;  PROCEDURE ResetReceiveBuffer;"BEGIN$tailPacket:= headPacket"END ResetReceiveBuffer;  PROCEDURE Init (hint: BYTE; server: BOOLEAN);"VAR i: CARDINAL;"BEGIN$backoff:= 0;$deferHistory:= bitVector {};$collsnHistory:= bitVector {};$deferCount:= 0;$collsnCount:= 0;$$WHILE packetBuffers < 2 DO&NewPacketBuffer$END;$$TimerA.Init;$$(**** SCC initialisieren ****)$(*%* Die Clock an RTxCA ist 3.672 MHz, benîtigte Baudrate ist 230400 Bit/s.%* Dazu mÅûte die Clock auf 1/16 geteilt werden.%* Da fÅr Receive DPLL verwendet wird, und DPLL den 16fachen Clk%* braucht, wird trotzdem kein Teiler verwendet. Stattdessen wird%* Åber den BRG geteilt.%*%* Der SCC arbeitet im Interrupt-Betrieb. Es wird der Non-Auto-Vektor-%* Modus verwendet, auf Adr. $360. Der IR lÑuft im Level 5.%* Da nur eine einzige IR-Quelle benutzt wird (IR on 1st Rx Char or%* special condition), wird die vector-includes-status-Option nicht%* verwerdet.%*)$GIOffBit ($7F);$SCC.Reset ();$(* X1 clock mode, SDLC mode, no parity *)$SCC.SetReg ( 4, 00100000%);$(* FM0 encoding, CRC preset 1 *)$SCC.SetReg (10, 11100000%);$(* Address: 0 *)$SCC.SetReg ( 6, 0);$(* SDCL flag *)$SCC.SetReg ( 7, 01111110%);$(* time constant: $0006 *)$SCC.SetReg (12, 6);$SCC.SetReg (13, 0);$(* FM mode *)$SCC.SetReg (14, 11000000%);$(* 8 Rx Bits *)$SCC.SetReg ( 3, 11010000%);$$(* Rx Clk: DPLL, Tx Clk: BRG *)$SCC.SetReg (11, 01110000%);$$(* activate DPLL, enable BRG *)$SCC.SetReg (14, 00100001%);$$(* 8 Tx Bits, SDLC CRC check *)$SCC.SetReg ( 5, 01100000%);$$(* *** IR vorbereiten *** *)$IR_Vector:= IR_Handler;$SCC.SetReg ( 2, SHORT (LONGCARD (ADR (IR_Vector)) DIV 4)); (* IR-Vektor *)$SCC.SetReg (15, 00000000%);$SCC.SetReg ( 1, 00001000%); (* IR on 1st Rx or special condition *)$SCC.SetReg ( 9, 00001000%); (* Enable IR (no VIS) *)$$enableRx;$$AcquireAddress (hint, server)"END Init;  PROCEDURE AcquireAddress (hint: BYTE; server: BOOLEAN); "VAR maxTrys, trys: CARDINAL;&ok: BOOLEAN;&ENQframe: aFrame;""BEGIN$IF CHAR(hint) > 0C THEN&myAddress:= hint$ELSIF server THEN&myAddress:= SHORT (random (127) + 128)$ELSE&myAddress:= SHORT (random (127) + 1)$END;$setAddress (myAddress);$trys:= 0;$$fAdrValid:= FALSE;$IF server THEN maxTrys:= wksTries * 6 ELSE maxTrys:= wksTries END;$fAdrInUse:= FALSE;$$WHILE trys < maxTrys DO&IF (TransmitPacket (myAddress, lapENQ, ENQframe.dataField, 0) = transmitOK)&OR fAdrInUse THEN(IF server THEN*myAddress:= SHORT (random (127) + 128)(ELSE*myAddress:= SHORT (random (127) + 1)(END;(setAddress (myAddress);(trys:= 0;&ELSE(INC (trys)&END$END; (* WHILE *)$$fAdrValid:= TRUE"END AcquireAddress;  PROCEDURE TransmitPacket (    dstParam: anAddress;>typeParam: aLAPtype;:REF dataParam: aDataField;>dataLength: INTEGER): TransmitStatus;"BEGIN$IF fAdrInUse THEN&RETURN dupAddress$ELSE&WITH outgoingPacket DO(dstAddr:= dstParam;(srcAddr:= myAddress;(lapType:= typeParam;(dataField:= dataParam (*!!! hier werden 600 Byte kopiert *)&END;&outgoingLength:= dataLength + 3;&RETURN TransmitLinkMgmt ()$END"END TransmitPacket;  PROCEDURE TransmitLinkMgmt (): TransmitStatus;""VAR deferTries, collsnTries, lclbackoff: INTEGER;&dummy, fBroadCast, fENQ: BOOLEAN;&RTSframe: aFrame;&rcvdFrame: FrameStatus;&rcvdPacket: ptrPacket;&status: TransmitStatus;&sr: CARDINAL;""BEGIN$WITH RTSframe DO&dstAddr:= outgoingPacket.dstAddr;&srcAddr:= myAddress;&lapType:= lapRTS$END;$$fBroadCast:= (outgoingPacket.dstAddr = BYTE($FF));$fENQ:= (outgoingPacket.lapType = lapENQ);$$IF BitCount (collsnHistory) > 2 THEN&backoff:= min (max (backoff*2,2), 16);&collsnHistory:= bitVector {}$ELSIF BitCount (deferHistory) < 2 THEN&backoff:= backoff DIV 2;&deferHistory:= bitVector {}$END;$$collsnHistory:= SHIFT (collsnHistory, 1);$deferHistory:= SHIFT (deferHistory, 1);$$deferTries:= 0;$collsnTries:= 0;$lclbackoff:= backoff;$$LOOP&REPEAT(IF carrierSense () THEN*lclbackoff:= max (lclbackoff, 2);*INCL (deferHistory, 0);**IF NOT TimerA.DelayBytesUntil (maxFrameSize, carrierSense, FALSE) THEN,(* carrierSense () = TRUE *),resetRx()*END;(END;((dummy:= TimerA.DelayÊsUntil (minIDGtime, carrierSense, TRUE)&UNTIL NOT carrierSense ();&&resetMissingClock ();&&dummy:= TimerA.DelayÊsUntil (random (lclbackoff) * IDGslottime, carrierSense, TRUE);&&IF carrierSense () OR missingClock () THEN(INC (deferCount);(lclbackoff:= max (lclbackoff, 2);(INCL (deferHistory, 0);(IF deferTries >= maxDefers THEN*status:= excessDefers; EXIT(END;(INC (deferTries);&ELSE((*$D-*)(fCTSexpected:= TRUE;((*!!! da ggf. noch andere IRs kamen:*ResetReceiveBuffer;(*)(IF fENQ THEN*TransmitFrame (outgoingPacket, 3)(ELSE*TransmitFrame (RTSframe, 3)(END;(rcvdFrame:= ReceiveFrame (rcvdPacket);(fCTSexpected:= FALSE;((IF rcvdPacket # NIL THEN*InOut.WriteCard (rcvdPacket^.no, 1); InOut.Write (' ');*WriteFrame (rcvdPacket^, 20);(END;((CASE rcvdFrame OF(|badframeCRC, badframeSize, badframeType, overrunError, underrunError:*Wr ('Answer: >frameError<');(|lapACKframe:*Wr ('Answer: >ACKframe<')(|lapENQframe:*Wr ('Answer: >ENQframe<');(|lapRTSframe:*Wr ('Answer: >RTSframe<');(|lapDATAframe:*Wr ('Answer: >DATAframe<');(|noFrame:*(*IF fAdrValid THEN Wr ('Answer: no frame!') END*)(ELSE*Wr ('Answer: unknown frame!');(END;(((*$D=*)(IF fAdrInUse THEN*status:= dupAddress; EXIT(ELSIF (rcvdFrame = noFrame) & fBroadCast(OR (rcvdFrame = lapCTSframe) & ~fENQ & ~fBroadCast THEN*TransmitFrame (outgoingPacket, outgoingLength);*status:= transmitOK; EXIT(END;((INC (collsnCount);(INCL (collsnHistory, 0);(IF collsnTries >= maxCollsns THEN*status:= excessCollsns; EXIT(END;(lclbackoff:= min (max (lclbackoff*2,2), 16);(INC (collsnTries)&END$END (* LOOP *);$RETURN status"END TransmitLinkMgmt; (*$D-*)  PROCEDURE TransmitFrameAsm;"(*$L-*)"BEGIN$ASSEMBLER(; A0: ^Daten, D0: Anzahl, A1: CTLA, A2: $FFFFFA00(; enableTxDrivers(MOVE.B  #5,(A1)(MOVE.B  #setRTS,(A1)((; Pause f. Sync-Pulse (1 Bit: 1.5 * bitTime (6.51Ês) = 16 Zyklen)(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #4,$1F(A2)      ; TADR: Set Timer Count(MOVE.B  #1,$19(A2)      ; TACR: Timer Start (Teiler: 1/4)%l: BTST    #5,$0B(A2)      ; IPRA(BEQ     l(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop((; disableTxDrivers(MOVE.B  #5,(A1)(MOVE.B  #$60,(A1)((; Pause f. Sync-Pulse (1 Bit: 1.5 * bitTime (6.51Ês) = 16 Zyklen)(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #4,$1F(A2)      ; TADR: Set Timer Count(MOVE.B  #1,$19(A2)      ; TACR: Timer Start (Teiler: 1/4)%l2 BTST    #5,$0B(A2)      ; IPRA(BEQ     l2(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop((; enableTxDrivers, enableTx(MOVE.B  #5,(A1)(MOVE.B  #txEnable,(A1)((; disableRx(MOVE.B  #3,(A1)(MOVE.B  #$D0,(A1)((; 2 * txFlag(; Delay: 2 * 1.5 * byteTime (39Ês) = 116 Zyklen(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #70,$1F(A2)     ; TADR: Set Timer Count(MOVE.B  #1,$19(A2)      ; TACR: Timer Start (Teiler: 1/4)%l3 BTST    #5,$0B(A2)      ; IPRA(BEQ     l3(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop((; resetCRC(MOVE.B  #$80,(A1)(%nextChar:(; TxChar(MOVE.B  (A0)+,2(A1)(NOP(NOP%notEmpty:(BTST    #2,(A1)(BEQ     notEmpty(SUBQ    #1,D0(BNE     nextChar((; resetUnderrun(MOVE.B  #$C0,(A1)((; TxFCS: wait for underrun%notUnder:(BTST    #6,(A1)(BEQ     notUnder((; TxFlag (?)%notEmpty2:(BTST    #2,(A1)(BEQ     notEmpty2((; enableTxDrivers, disableTx(MOVE.B  #5,(A1)(MOVE.B  #setRTS,(A1)((; txONEs (?)(; Delay: 1.5 * byteTime (39Ês) = 58 Zyklen(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  #35,$1F(A2)     ; TADR: Set Timer Count(MOVE.B  #1,$19(A2)      ; TACR: Timer Start (Teiler: 1/4)%l4 BTST    #5,$0B(A2)      ; IPRA(BEQ     l4(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop((; disableTxDrivers(MOVE.B  #5,(A1)(MOVE.B  #$60,(A1)((; resetMissingClock(MOVE.B  #14,(A1)(MOVE.B  #$41,(A1)((; enableRx(MOVE.B  #3,(A1)(MOVE.B  #rxEnable,(A1)$END;"END TransmitFrameAsm;"(*$L=*)  PROCEDURE TransmitFrame (REF frame: aFrame; frameSize: CARDINAL);"(*$L-*)"BEGIN$ASSEMBLER(MOVE    SR,D2(ORI     #$2700,SR(MOVEA.W #CTLA,A1(MOVEA.W #$FA00,A2(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(JSR     TransmitFrameAsm(MOVE    D2,SR$END;"END TransmitFrame;"(*$L=*)  PROCEDURE ReceivePacket (VAR dstParam: anAddress;9VAR srcParam: anAddress;9VAR typeParam: aLAPtype;9VAR dataParam: aDataField;9VAR dataLength: INTEGER);"VAR status: ReceiveStatus; packet: ptrPacket;"BEGIN$REPEAT UNTIL (ReceiveLinkMgmt (packet) = receiveOK) OR InOut.KeyPressed ();$WITH packet^.frame DO&dstParam:= dstAddr;&srcParam:= srcAddr;&typeParam:= lapType;&dataParam:= dataField (*!!! hier werden 600 Byte kopiert -> Ptr verw.*)$END;"END ReceivePacket;  PROCEDURE ReceiveLinkMgmt (VAR packet: ptrPacket): ReceiveStatus;""VAR status: ReceiveStatus;&rcvdStatus: FrameStatus;&CTSframe, ACKframe: aFrame;&sr: CARDINAL;""BEGIN$ASSEMBLER(MOVE    SR,sr(A6)(MOVE    #$2500,SR$END;$status:= receiving;$REPEAT&rcvdStatus:= ReceiveFrame (packet);&IF rcvdStatus # noFrame THEN(InOut.WriteCard (packet^.no, 1); InOut.Write (' ');(WriteFrame (packet^,99);(InOut.WriteLn;(WriteStatus (rcvdStatus); InOut.WriteLn;&END;&CASE rcvdStatus OF&|badframeCRC, badframeSize, badframeType, overrunError, underrunError:(status:= frameError&|lapACKframe:&|lapENQframe:(IF fAdrValid THEN*WITH ACKframe DO,dstAddr:= packet^.frame.srcAddr;,srcAddr:= myAddress;,lapType:= lapACK*END;*TransmitFrame (ACKframe, 3);(ELSE*fAdrInUse:= TRUE(END;(status:= nullReceive&|lapRTSframe:((* wird nun schon beim Empfang erledigt *)(HALT((**IF fAdrValid THEN,WITH CTSframe DO.dstAddr:= headPacket^.frame.srcAddr;.srcAddr:= myAddress;.lapType:= lapCTS,END;,TransmitFrame (CTSframe, 3);*ELSE,fAdrInUse:= TRUE;,status:= nullReceive*END;(*)&|lapDATAframe:(IF fAdrValid THEN*status:= receiveOK(ELSE*fAdrInUse:= TRUE;*status:= nullReceive(END;&|noFrame:(status:= nullReceive&ELSE&END$UNTIL status # receiving;$ASSEMBLER(MOVE    sr(A6),SR$END;$RETURN status"END ReceiveLinkMgmt;  PROCEDURE ReceiveFrame (VAR packet: ptrPacket): FrameStatus;""VAR status: FrameStatus; "BEGIN$ASSEMBLER(MOVEA.W #CTLA,A1(MOVEA.W #$FA00,A2(MOVE.L  tailPacket,A0((; *** warten auf Frame-Empfang (IR o. Polling) ***((MOVEQ   #0,D1($l1: MOVEQ   #maxIFGtime DIV 4,D0(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  D0,$1F(A2)      ; TADR: Set Timer Count(MOVE.B  #2,$19(A2)      ; TACR: Timer Start (Teiler: 1/10)$l0: ; zuerst prÅfen, ob evtl. noch ein Frame zu pollen ist,(; auch wenn noch weitere Pakete schon im Puffer warten.(;BTST    #0,(A1)(MOVE.B  #3,(A1)(BTST.B  #5,(A1)         ; RR3: Rx IR pending?(BNE     pollFrame(CMPA.L  headPacket,A0(BNE     gotFrame(BTST    #5,$0B(A2)      ; time over?(BEQ     l0(; IR-Receive nochmal prÅfen, falls IR zw. vorigem CMP und Time-Chk kam.(CMPA.L  headPacket,A0(BNE     gotFrame(((*(TST     test(BEQ     timeout((ADDQ    #1,D1(BRA     l1(*)($timeout:(; time out(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop(MOVE.L  packet(A6),A1(CLR.L   (A1)(MOVE    #noFrame,status(A6)(BRA.W   exit2($gotFrame:(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop(BRA     exit($pollFrame:(MOVE    SR,D2(ORI     #$0700,SR(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop(JSR     GetFrame(MOVE.B  #1,(A1)(MOVE.B  #$08,(A1)(; MOVE.B  #2,4(A1)(; TST.B   4(A1)                   ; RR2B(MOVE    D2,SR($exit:(MOVE.L  tailPacket,A0(MOVE.L  packet(A6),A1(MOVE.L  A0,(A1)(MOVE    aPacket.status(A0),status(A6)(MOVE.L  aPacket.next(A0),tailPacket($exit2:$END;$RETURN status "END ReceiveFrame;  PROCEDURE IR_Handler;"(*$L-*)"BEGIN$ASSEMBLER(ORI     #$0700,SR(MOVEM.L A0-A2/D0-D1,-(A7)((MOVEA.W #$FA00,A2(MOVEA.W #CTLA,A1(JSR     GetFrame((ADDQ.W  #1,Interrupts((MOVEM.L (A7)+,A0-A2/D0-D1(RTE$END;"END IR_Handler;"(*$L=*)  PROCEDURE GetFrame;"(*$L-*)"BEGIN$ASSEMBLER(MOVE.B  2(A1),D0                ; 1. char sofort holen(MOVE.L  headPacket,A0(MOVE.B  D0,aPacket.frame(A0)((MOVE.B  #2,4(A1)(BTST.B  #0,4(A1)                ; RR2B(BNE     specCond((MOVEQ   #100,D1&wait2:(BTST    #0,(A1)(DBNE    D1,wait2(MOVE.B  2(A1),aPacket.frame+1(A0)((MOVEQ   #2,D0(BRA     nextChar($specCond:(MOVE #$2500,SR BREAK($again:(CLR     D0($loop2:(; overrun?(MOVE.B  #1,(A1)   ; RR1(BTST.B  #5,(A1)(BEQ     noOverrun((MOVE    D0,aPacket.length(A0)(MOVE.W  #overrunError,aPacket.status(A0)(BRA.W   exit2($timeOut:(MOVE    D0,aPacket.length(A0)(MOVE.W  #noFrame,aPacket.status(A0)(BRA.W   exit2($noOverrun:(MOVEQ   #100,D1&wait4:(BTST    #0,(A1)(DBNE    D1,wait4(BEQ     timeOut(((*(BTST.B  #0,(A1)   ; Data avail?(BEQ     noDataNow ; !!!timeout berÅcksichtigen(*)((; *** read data ***(CMPI.W  #maxFrameSize,D0        ; incomingLength(BCS     getChar($sizeError:(MOVE    D0,aPacket.length(A0)(MOVE.W  #badframeSize,aPacket.status(A0)(BRA.W   exit2($getChar:(; headPacket^.frame.rawData [incomingLength]:= rxData ()(MOVE.B  2(A1),aPacket.frame(A0,D0.W)  ; RR8(ADDQ.W  #1,D0             ; incomingLength($nextChar:$noDataNow:(; end of frame?(MOVE.B  #1,(A1)   ; RR1(TST.B   (A1)(BPL     loop2((; CRC OK?(MOVE.B  #1,(A1)   ; RR1(BTST.B  #6,(A1)(BEQ     crcOK((MOVE    D0,aPacket.length(A0)(MOVE.W  #badframeCRC,aPacket.status(A0)(BRA.W   exit2($crcOK:(SUBQ.W  #2,D0           ; incomingLength(MOVE    D0,aPacket.length(A0)(CMPI.W  #minFrameSize,D0(BCS     sizeError(((* Der folgende Teil kann auch aus dem IR-Handler herausgenommen werden*)((; *** frameDone ***(TST.W   fAdrValid(BEQ     notValid((MOVE.B  aPacket.frame.lapType(A0),D0(BMI     ctrlFrame((MOVE.W  #lapDATAframe,aPacket.status(A0)(BRA.W   exit2(&ctrlFrame:(CMPI.B  #lapENQ,D0(BEQ     isENQ(CMPI.B  #lapACK,D0(BEQ     isACK(CMPI.B  #lapRTS,D0(BEQ     isRTS(CMPI.B  #lapCTS,D0(BEQ     isCTS&badFrame:(MOVE.W  #badframeType,aPacket.status(A0)(BRA     exit2&isENQ:(MOVE.W  #lapENQframe,aPacket.status(A0)(BRA     exit2&isACK:(MOVE.W  #lapACKframe,aPacket.status(A0)(MOVE.W  #1,fAdrInUse(BRA     exit2&isRTS:(MOVE.W  #lapRTSframe,aPacket.status(A0)(BRA     exit2&isCTS:(MOVE.W  #lapCTSframe,aPacket.status(A0)(TST.W   fCTSexpected(BNE     exit2(MOVE.W  #1,fAdrInUse(BRA     badFrame(&notValid:(CMPI.B  #$FF,aPacket.frame.dstAddr(A0)(BEQ     exit2((MOVE    #1,fAdrInUse(MOVE.W  #noFrame,aPacket.status(A0)($exit2:((CMPI.W  #lapRTSframe,aPacket.status(A0)(BNE     noRTS((; CTS senden, falls kein Broadcast(CMPI.B  #$FF,aPacket.frame.dstAddr(A0)(BEQ     noCTS(MOVE.B  #lapCTS,-(A7)(MOVE.B  aPacket.frame.srcAddr(A0),D0(LSL     #8,D0(MOVE.B  myAddress,D0(MOVE.W  D0,-(A7)(MOVE.L  A7,A0(MOVE.W  #3,D0(JSR     TransmitFrameAsm(ADDQ.L  #4,A7(MOVE.L  headPacket,A0&noCTS:(MOVE.W  #noFrame,aPacket.status(A0)(&noRTS:((; resetRx(MOVE.B  #3,(A1)(MOVE.B  #$D0,(A1)       ; disableRx((MOVEQ   #2,D0&flushFIFO:(TST.B   2(A1)(DBRA    D0,flushFIFO((; resetMissingClock(MOVE.B  #14,(A1)(MOVE.B  #$41,(A1)((MOVE.B  #3,(A1)(MOVE.B  #rxEnable,(A1)  ; enableRx((; reset error(MOVE.B  #$30,(A1)((MOVE.B  #$20,(A1)         ; enable IR on next Rx((; resetMissingClock(MOVE.B  #14,(A1)(MOVE.B  #$41,(A1)((ADDQ.W  #1,FramesReceived((MOVE.L  aPacket.next(A0),A0(MOVE.L  A0,headPacket((; reset IUS(MOVE.B  #$38,(A1)((; more IRs?((* hat wohl keinen Sinn, da das nicht so gemeldet wird*MOVE.B  #3,(A1)*TST.B   (A1)            ; RR3*BNE     again(*)(BTST    #0,(A1)(BNE     again((; MOVE.B  #1,(A1)(; MOVE.B  #$08,(A1)         ; enable IR on first Rx$END"END GetFrame;"(*$L=*)  BEGIN"packetBuffers:= 0; END (* MODULE *) ALAP;  (*****************************************************************************)  TYPE BS = SET OF [0..7];%RegSet = SET OF [0..15];  CONST ReadRegs  = RegSet {0,1,2,3,8,10,12,13,15};&WriteRegs = RegSet {0..15};&&RegsToDisplay = RegSet {0,1,2,3,8,10,12,13,15};&  PROCEDURE WriteReg (n: CARDINAL);"VAR reg: CARDINAL;"BEGIN$reg:= SCC.Reg (n);$WriteNum (reg, 16, 2, '0');$WriteString ('  ');$WriteNum (reg, 2, 8, '0');"END WriteReg;   VAR ch: CHAR;$rxIdx, n, c: CARDINAL;$lc: LONGCARD;$i: INTEGER;$ssp, li: LONGINT;$redraw, quit, ok, b: BOOLEAN;$by: BS;$$packet: ALAP.ptrPacket;$dstParam, srcParam: ALAP.anAddress;$typeParam: ALAP.aLAPtype;$dataParam: ALAP.aDataField;$txStatus: ALAP.TransmitStatus;$frameStatus: ALAP.FrameStatus;$dataLength: INTEGER;  BEGIN"WritePg;"ssp:= Super (0);""(*"WriteLn;"WriteString ('Start...');"FOR c:= 1 TO 5 DO$FOR n:= 1 TO 5*1000 DO&ASSEMBLER(MOVEA.W #$FA00,A2(MOVEQ   #50,D0(MOVE.B  #$DF,$0B(A2)    ; IPRA: Clear Timer-A Pending Bit(MOVE.B  D0,$1F(A2)      ; TADR: Set Timer Count(MOVE.B  #2,$19(A2)      ; TACR: Timer Start (Teiler: 1/10)$l0: BTST    #5,$0B(A2)      ; time over?(BEQ     l0(MOVE.B  #$00,$19(A2)    ; TACR: Timer Stop&END;$END;"END;"WriteString ('Stop!');"WriteLn;"*)""WriteLn;"WriteString ('Init...');"WriteLn;""ALAP.Init (0, FALSE);""ALAP.NewPacketBuffer;"ALAP.NewPacketBuffer;"ALAP.NewPacketBuffer;"ALAP.NewPacketBuffer;""WriteString ('OK');"WriteLn;""rxIdx:= 0;"redraw:= TRUE;"quit:= FALSE;"REPEAT$IF redraw THEN&GotoXY (4,0);&WriteString (' interrupts');&GotoXY (4,1);&WriteString (' frames received');&GotoXY (0,2);&FOR n:= 0 TO 15 DO(IF n IN ReadRegs THEN*WriteString ('Reg '); WriteNum (n, 16, 1, '0'); WriteString (': '); WriteLn;(END&END;&WriteString (VT52.Seq[clearEOS]);&&c:= 2;&FOR n:= 0 TO 15 DO(IF n IN ReadRegs THEN*IF n IN RegsToDisplay THEN GotoXY (7,c); WriteReg (n) END;*INC (c);(END;&END;&&GotoXY (0, 11);&WriteString ('myAddress: '); WriteHex (LONG (ALAP.myAddress), 3);&&redraw:= FALSE$END;$GotoXY (0,0);$WriteCard (ALAP.Interrupts, 4);$GotoXY (0,1);$WriteCard (ALAP.FramesReceived, 4);$$IF ALAP.headPacket # ALAP.tailPacket THEN&frameStatus:= ALAP.ReceiveFrame (packet);&GotoXY (40, rxIdx);&WriteCard (rxIdx, 2);&INC (rxIdx);&WriteString (': ');&ALAP.WriteFrame (packet^, 5);&InOut.WriteCard (packet^.no, 1); InOut.Write (' ');&ALAP.WriteStatus (packet^.status);$END;$$IF KeyPressed() THEN&GotoXY (0,14);&WriteString (VT52.Seq[clearEOS]);&WriteLn;&Read (ch); ch:= CAP (ch);&IF ch = 'Q' THEN(quit:= TRUE;&ELSIF ch = 'T' THEN(WriteLn;(WriteString ('Transmitting...');(WriteLn;(txStatus:= ALAP.TransmitPacket (BYTE($FF), BYTE($81), dataParam, 0);(ALAP.fAdrInUse:= FALSE;(WriteString ('Status: ');(CASE txStatus OF(| ALAP.transmitOK: WriteString ('transmitOK')(| ALAP.excessDefers: WriteString ('excessDefers')(| ALAP.excessCollsns: WriteString ('excessCollsns')(| ALAP.dupAddress: WriteString ('dupAddress')(END;(WriteLn;&ELSIF ch = 'R' THEN(WriteLn;(WriteString ('Receiving...');(WriteLn;(ALAP.ReceivePacket (dstParam, srcParam, typeParam, dataParam, dataLength);(IF InOut.KeyPressed () THEN*WriteString ('Aborted');*Read (ch)(ELSE*WriteString ('OK');(END&ELSIF ch = 'G' THEN(WriteLn;(WriteString ('Getting Addresses on Bus...');(WriteLn;(FOR n:= $15 TO $15 DO*ALAP.test:= TRUE;*txStatus:= ALAP.TransmitPacket (SHORT(n), BYTE($81), dataParam, 0);*IF txStatus = ALAP.dupAddress THEN,Write ('>'); WriteHex (n, 3); Write ('<'); WriteLn;*END;*ALAP.fAdrInUse:= FALSE;(END;(ALAP.test:= FALSE;(WriteLn;&ELSIF ch = ' ' THEN(WritePg;(rxIdx:= 0;(redraw:= TRUE&ELSIF ch = 'I' THEN(WriteString ('Init...');(WriteLn;(ALAP.Init (0, FALSE);&ELSIF (ch >= '0') & (ch <= '9') OR (ch >= 'A') & (ch <= 'F') THEN(Write (10C); (* BS *)(n:= ORD (ch) - ORD ('0'); IF n > 9 THEN DEC (n, 7) END;(IF n IN WriteRegs THEN*WriteString ('Write Reg '); WriteNum (n, 16, 1, '0');*WriteString ('? ');*ReadCard (c);*IF Done & (c <= 255) THEN,SCC.SetReg (n, c);*ELSE,WriteString ('No write!'); WriteLn*END(END&END;$END;"UNTIL quit;"ssp:= Super (ssp) END LANMonitor.  
(* $FFF006F0$00006FDE$FFF006F0$FFF006F0$0000798F$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$000036BC$FFF006F0$000045ED$FFF006F0$FFF006F0$FFF006F0$00007ECF$FFF006F0$00006F5F$00006E60$00003E9D$000069AB$FFF006F0$00004BE7$FFF006F0$FFF006F0$FFF006F0$FFF006F0$FFF006F0$00006073$FFF006F0$FFF006F0$FFF006F0$00002864$00003546$FFF006F0$FFF006F0Ä$00000025T.......T.......T.......T.......T.......T.......T.......T.......T.......T.......$000088C1$0000524C$000063F9$00006429$0000640F$00000025$000036C5$000036EF$000036C5$000036EF$0000373A$FFF006F0$FFF006F0$0000369B$000036C8$00003547òÄÇ*)
