2.1  Bedienung: Los geht's                                                2 -  1
________________________________________________________


2.      Bedienung  des  Systems


Wir haben uns bemht, die Verwendung von Fremdw”rtern zu vermeiden oder
diese  mit  šbersetzungen  zu  versehen.  Aber  gerade  im  Computerjargon
kommen viele aus dem Englischen bernomme Ausdrcke vor, die kaum direkt
bersetzbar sind oder Einsteigern gar nicht bekannt sein k”nnen. Stoen Sie in
diesem Handbuch auf solche Ausdrcke, sehen Sie doch einfach nach, ob wir
dazu eine Begriffserl„uterung im Anhang dieses Buchs  nachgetragen  haben.
Wir haben uns bemht, diese Ausdrcke kursiv hervorzuheben.


2.1    Los  geht's  -
          Installieren  und  Ausprobieren


Voraussetzungen

Wir gehen davon aus, da Sie vor Ihrem Atari ST-Computer sitzen und neben
diesem  Handbuch  die  mitgelieferten  Disketten  zur  Hand  haben.  (Die  Regi~
strierkarte, die der Lieferung beilag, haben Sie bestimmt schon ausgefllt, um
in den Genu aller Updates und Erweiterungen zu Megamax Modula zu kom~
men?)

Auerdem sollten Sie einige leere Disketten bereithalten, um Backup- (Sicher~
heits-) und Arbeitskopien anzulegen: 4 doppelseitige Disketten  fr  Backups;
zus„tzlich 2 Disketten fr die Zusammenstellung mageschneiderter Arbeits~
disketten. (Natrlich gengt auch etwas Platz auf einer Festplatte...)

Einige Worte zur Konfiguration des Rechners: Fr ein komfortables Arbeiten
mit Megamax Modula ist eine freie RAM-Kapazit„t von  2  MByte  und  einer
Festplatte wnschenswert.

Die Benutzung von Megamax Modula auf einem Atari mit nur 512 KByte RAM
ist nicht m”glich. Voraussetzung dafr w„re eine gegenber der mitgelieferten
stark verkleinerte Shell, die kein GEM benutzt.  Eine  solche  Shell  ist  zwar
schnell erstellt, aber wir weisen lieber darauf hin, den Atari auf mindestens
1 MByte aufzursten. In den Fachzeitschriften lassen sich einfach einzubauende
Speichererweiterungen schon fr ca. DM 300.- finden.
2.1  Bedienung: Los geht's                                                2 -  2
________________________________________________________


Die Modula-Disketten

Die Aufteilung und Anzahl der mitgelieferten Disketten variiert von Zeit zu Zeit,
so da wir Ihnen hier nur alle zumindest vorhandenen Dateien und Ordner auf~
zeigen, um Ihnen die šbersicht zu erleichtern. In der Regel werden die Disket~
ten zweiseitig beschrieben - wenn Sie sie nicht in den Computer einlesen k”n~
nen, wenden Sie sich bitte an Ihren H„ndler, damit er Ihnen die Disketten auf
einseitige umkopiert, oder an Application Systems. šber weitere Besonderheiten
und zus„tzliche Dateien werden Sie in der Datei LIESMICH.TXT informiert, die
sich auf einer der Disketten befindet.

    GEP ED           Ordner, der den Gepard-Editor enth„lt:
         _
       GEP ED.MOD     Der Gepard-Editor (nur unter der Shell zu starten!)
           _

    GME               Ordner; enth„lt die Dateien fr den Editor "GME"
       GME.MOD         Der Editor
       ...IMP              Zum GME geh”rende Module
       GMEMENUE.RSC  Die GEM-Resource-Datei fr den GME

    SRC               Ordner mit Quelltexten. Enth„lt vier Ordner fr:
       D                  Definitions-Texte. Achtung: Sind ggf. erst zu dekom-
                           primieren (siehe HINWEIS-Text auf der Diskette)
       DEMO             Diverse Demonstrationsprogramme
       MOS              Quellen zum Megamax-System, die Sie bei Bedarf
                           selbst modifizieren k”nnen (z.B. die Shell)
       UTILITY           Diverse Hilfsprogramme

    SYS               Ordner mit Modulen und anderen Systemdateien:
       IMP                Ordner mit den bersetzten Implementations-Modulen
                           (werden beim Ausfhren vieler Programme unter der
                           Shell ben”tigt)
       MOD              Ordner mit Compiler, Linker, Make usw.
       DEF               Ordner mit bersetzten Definitions-Modulen (werden
                           vom Compiler beim šbersetzen ben”tigt):
         MM2DEF.M2L     Enth„lt die unver„nderlichen DEF-Module der Mega-
                             max-Bibliothek in komprimierter Form.
         MM2SHELL.DEF   Ein einzelnes DEF-Modul: Es definiert die Resource-
                             Indices der Shell und kann sich „ndern, wenn die
                             GEM-Resource modifiziert wird.
       MODULA.ERR      Textdatei mit Fehlermeldungen fr den Compiler

    USER              Ordner fr Ihre eigenen (Quelltext-) Dateien.
       DEF               Hier kommen bersetze Definitions-Module rein
       IMP                Dito fr Implementations-Module
       MOD              Dito fr Haupt-Module
                        Die Quelltexte sollten auch hier im Ordner USER abgelegt
                        werden.
2.1  Bedienung: Los geht's                                                2 -  3
________________________________________________________


    TMP               Ordner, in dem die Shell interne Dateien zwischenzeitlich
                        ablegt (auch das Make-Programm!).

    TEMPLMON.Vxx   Ordner mit Maschinensprache-Monitor.

    MM2SHELL.PRG   Die Modula-Shell (Bedienungsoberfl„che)
    MM2SHELL.RSC   GEM-Resource-Datei fr die Shell
    MM2SHELL.RSD   Zusatzdatei zur Resource-Datei
    MM2SHELL.M2P   Parameter-Datei fr die Shell
    MM2SHELL.M2B   Batch-Datei - wird beim Shell-Start ausgefhrt
    MM2SHELL.HLP   Textdatei mit Hilfestellungen fr die Shell-Bedienung

    LIESMICH.TXT     Diese Datei unbedingt lesen! (z.B. nach dem Shell-Start
                        durch einen Doppelklick in den Editor laden)

    NRSC ASH.PRG   Programm zum Bearbeiten von GEM-Resourcen
          _
    NRSC.RSC         Resource-Datei zum Programm
           Das  "Resource  Construction"-Programm  wird  zur  Erstellung  von
           GEM-Menues und anderen GEM-Objekten ben”tigt. Mehr dazu finden
           Sie in den Kapiteln 5 und C.2.

    HD INST.PRG     Hiermit  kann  das  Modula-System  bequem  auf  der
       _
                        Festplatte installiert werden.

    DEMO enth„lt einige Beispielprogramme, die Ihnen vielleicht den Einstieg in
    Megamax Modula erleichtern. In UTILITY finden sich einige Hilfsprogramme,
    die Sie compilieren sollten, um dann die erzeugten Code-Dateien auf ihre
    Arbeitsdisk (Ordner SYSMOD) zu kopieren. Sehen Sie sich  alle  diese
    Dateien an, z.B., indem Sie sie in den Editor laden. Sie enthalten alle eine
    Information zu Beginn des Textes.

    Der Ordner MOS ist eher fr fortgeschrittene Benutzer interessant: Er
    enth„lt die Quelltexte einiger Module, die Sie ver„ndern k”nnen, um die
    Konfiguration der Bibliotheken und der Entwicklungsumgebung (Shell) Ihren
    eigenen Wnschen anzupassen.

    Besonders hilfreich ist der Ordner D. Er enth„lt die Definitionstexte, die
    auch  im  Kapitel  B  dieses  Handbuchs  abgedruckt  sind.  Aus  Erfahrung
    wissen wir, da man oft Funktionen nachschlagen will und es dann beim
    blichen Schreibtischchaos recht  unbequem  ist,  im  Handbuch  herumzu~
    bl„ttern. Wenn Sie gengend Massenspeicher (Festplatte) haben, reicht es
    nun  aus,  im  Editor  ein  neues  Fenster  zu  ”ffnen  und  den  ben”tigten
    Definitionstext hineinzuladen. Der  Gepard-Editor  erlaubt  es  sogar,  nach
    exportierten Bezeichnern zu suchen und dann die entsprechende Definitions-
    Textdatei  anzuzeigen  (mit  der  F6-Taste,  wenn  der  Cursor  auf  dem
    gesuchten Bezeichner steht!).
2.1  Bedienung: Los geht's                                                2 -  4
________________________________________________________


Installieren von Megamax Modula

Auf die Gefahr hin, da wir Sie langweilen: Haben Sie schon Backup-Kopien
aller gelieferten Disketten gemacht? Die Disketten sind nicht kopiergeschtzt.
Es  sollte  also  keine  Schwierigkeiten  bereiten,  Kopien  anzufertigen  und  die
Originale in Sicherheit zu bringen. Vorsicht: Vor dem Kopieren sollten Sie die
Originale schreibschtzen (Loch ist offen), um sie bei einer Verwechslung nicht
gleich zu l”schen!

Mit den Kopien in der Hand k”nnen Sie sich jetzt Ihre Arbeitsdisketten zusam~
menstellen. Wir beschreiben zwei verschiedene Rechner-Konfigurationen:
* Atari ST mit mindestens 1 MByte RAM, mindestens 720 KByte Diskettenplatz
* Atari ST mit mindestens 1 MByte RAM, Festplatte


Atari ST mit mindestens 1 MByte RAM, mindestens 720 KByte Diskettenplatz

Die gelieferten Disketten sind bereits sinnvoll aufgeteilt. Auf der Disk mit der
Shell   befinden   sich   neben   den   fr   die   Shell   notwendigen   Dateien
(MM2SHELL.M2P,  MM2SHELL.M2B,  MM2SHELL.RSC)  auch  die  Module,  die
resident  geladen  werden:  der  Compiler  (im  SYSMOD-Ordner)  und  beide
Editoren (Ordner GEP ED bzw. GME). Die andere Diskette enth„lt dann die
                       _
zum Arbeiten ben”tigten Dateien, wie  Definitions-Codes  (MM2DEF.M2L)  und
importierte Module (Ordner SYSIMP). Ihre selbst bersetzten Dateien werden
im USER-Ordner abgelegt, worin Sie auch Ihre Quelltexte ablegen k”nnen.

Sie k”nnen also die Shell von der einen Diskette starten; ist sie fertig, kann
die  andere  Disk  eingelegt  werden,  um  dann  eigene  Programme  oder  die
mitgelieferten Programme in den Ordnern DEMO und UTILITY zu bersetzen
und zu starten.

Beachten  Sie  aber,  da  die  Parameter-Datei  der  Shell  auf  der  Boot-Disk
abgelegt ist. Wenn Sie den Menpunkt Parameter ...speichern w„hlen oder die
Parameter beim Verlassen der Shell speichern wollen, mssen Sie zuvor die
Boot-Disk einlegen. Es passiert zwar nichts schlimmes, wenn Sie dies nicht
befolgen, allerdings wrde beim erneuten Start der Shell von der Boot-Disk
wieder die alte Parameter-Datei geladen werden. Notfalls k”nnen Sie die Datei
auch einfach auf die Boot-Disk zurckkopieren.

Ein „hnliches Disketten-Problem entsteht bei der  Benutzung  des  GME.  Der
Editor ben”tigt beim Start seine Resource-Datei GMEMENUE.RSC. Wenn Sie
nur ein Laufwerk haben, mssen Sie aufpassen, da beim Start des Editors
eine Disk mit dieser Datei im Ordner  GME  einliegt.  Wollen  Sie  Texte  von
anderen Disketten vom Laufwerk A: lesen, mssen Sie erst den Editor starten
(Tastendrcke:  Control-P,  Esc,  Return,  Control-E)  und  erst  dann  die  Disk
wechseln und im Editor die gewnschte Datei laden.
2.1  Bedienung: Los geht's                                                2 -  5
________________________________________________________


Besser ist es dann schon, zwei Laufwerke zu verwenden - dann braucht auch
die Boot-Disk mit der Shell und ihrer Parameter-Datei nicht entfernt werden,
so da das vorher beschriebene Problem ebenfalls nicht entsteht. Allerdings
mssen dazu erst einige Parameter in der Shell und die Suchpfade ge„ndert
werden.

Mssen aus Platzmangel mal  die  geladenen  Programme  (z.B.  Compiler  und
Editor) entfernt werden, werden sie bei erneuter Benutzung auf der gerade
eingelegten Diskette gesucht. Ggf. mssen Sie sich Editor und Compiler dazu
auf die Arbeitsdisk kopieren, damit Sie nicht jedesmal extra die Disk mit der
Shell wieder einlegen mssen.

Das Programm HD INST.PRG auf einer der Disketten wird beim Arbeiten nicht
                   _
ben”tigt und kann daher von dort entfernt werden, um Platz auf der Disk zu
gewinnen.

Um das Modula-System nach Ihren Wnschen zu konfigurieren, lesen Sie bitte
ber die Parameter von Shell, Editor  und  Compiler  sowie  ber  die  Batch-
Dateien fr die Suchpfad-Bestimmung in Kapitel 2.2 nach.

Im  Ordner  MAXIDISK.4MB  finden  Sie  eine  RAM-Disk,  die  sogar  die  darin
gespeicherten Daten komprimieren kann. Sobald Sie mit der  Bedienung  und
Konfiguration  vertraut  sind,  k”nnen  Sie  sich  eine  Boot-Disk  erstellen,  die
automatisch die RAM-Disk einrichtet und die von Ihnen ben”tigten Definitions~
module sowie die Fehlerdatei MODULA.ERR in die RAM-Disk kopiert. Wenn Sie
dann  die  Suchpfade  entsprechend  einstellen,  k”nnen  Sie  das  šbersetzen
erheblich beschleunigen.


Atari ST mit mindestens 1 MByte Speicher und Festplatte

Hier ist alles ganz einfach. Sie brauchen lediglich auf der Festplatte irgendwo
einen Ordner fr das  Modula-System  anzulegen  ("MM2"  w„re  ein  sch”ner
Name) und dann alle Dateien, so wie sie auf den Disketten angeordnet sind,
                                                          1
hineinzukopieren. Auf der Festplatte sollten dazu ca. 3 /  MB frei sein. Damit
                                                            2
es  auch  dabei  keine  Schwierigkeiten  gibt,  haben  wir  das  Programm
HD INST.PRG  vorbereitet.  Es  braucht  nur  gestartet  zu  werden  und  dann
   _
sollten Sie, wie vom Programm aufgefordert, die vier Disketten nacheinander
einlegen. Dann werden einfach alle Dateien auf die Festplatte kopiert. Weitere
Konfigurationen  brauchen  erstmal  nicht  vorgenommen  werden.  Sie  sollten
sp„ter aber noch die Definitions-Module in der Library decomprimieren. Lesen
Sie dazu Kapitel 2.4.

Schon ist alles vorbereitet - die Shell kann nun gestartet werden. Erst, wenn
Sie die Strukturen der Ordner „ndern wollen, mssen Sie die Parameter in
der Shell und die Suchpfade im Batch (MM2SHELL.M2B) anpassen. Doch dazu
sollten Sie erstmal Kapitel 2.2 durchlesen!
2.1  Bedienung: Los geht's                                                2 -  6
________________________________________________________


Speicherplatzmangel?!

Wenn  Sie  nun  die  Shell  starten,  sollten  nach  dem  Laden  von  Compiler
und  Editor  mindestens  noch  200  KB  (ca.  200.000  Byte)  Speicher  frei
sein,  sonst  werden  sich  bald  Compiler,  Editor  oder  Linker  diesbezglich
beschweren.  Vor  allem,  wenn  Sie  ein  Fan  von  Accessories  oder  AUTO-
Ordner-Programmen sind und Ihr Rechner nur ber 1 MB Speicher verfgt,
kann es dazu kommen. Den noch freien Speicher k”nnen Sie ber den Men~
punkt Info/Umgebungsinformationen erfahren.

Sie haben bei zu knappem Speicher keine Datenverluste zu befrchten! Reicht
der Speicher im Editor nicht mehr, kann immer noch der bisher erzeugte Text
gesichert werden, bei Compiler, Linker und anderen Dienstprogrammen kann
die  Operation  ja  sowieso  wiederholt  werden.  Um  den  freien  Speicher  zu
vergr”ern, haben Sie verschiedene M”glichkeiten:

* Geben Sie die sonst noch geladenen Programme aus dem Speicher frei (das
  zu startende Programm selbst braucht nicht entfernt werden). Dazu ”ffnen
  Sie das Resident-Fenster (Taste R) und ziehen die angezeigten Programme
  in den Abfalleimer. Dauerhaft k”nnen Sie auf das  Laden  der  Programme
  ganz  verzichten,  indem  Sie  die  Load-Anweisungen  aus  dem  Shell-Batch
  entfernen (siehe Kapitel 2.2).

* Verwenden Sie den Gepard-Editor. Er ben”tigt und belegt (als residentes
  Programm)  deutlich  weniger  Speicher  als  der  GME.  Ersetzen  Sie  dann
  die  Anweisung  LOAD  GME  durch  LOAD  GEP ED  in  der  Batch-Datei
                                                      _
  MM2SHELL.M2B. Diese nderung kann mit dem Editor durchgefhrt werden.

* Verzichten  Sie  auf  andere  residente  Programme,  wie  Accessories  oder
  AUTO-Ordner-Programme (z.B. Cache).

* Starten Sie den Compiler bzw. den Linker als gelinktes Programm von einer
  anderen Shell aus. Diese L”sung ist zwar nicht so komfortabel wie mit der
  Megamax-Shell, aber l”st dafr auch die gr”ten Platzprobleme. Siehe dazu
  die Erl„uterungen in den Quelltexten von LinkInit und CompInit (LINKINIT.M &
  COMPINIT.M im UTILITY-Ordner).
2.1  Bedienung: Los geht's                                                2 -  7
________________________________________________________


Mehr Geschwindigkeit...

Haben Sie keine Platzprobleme, k”nnen Sie Ihr System auf Geschwindigkeit
trimmen. Hier einige Tips:

Wenn Sie eine Festplatte haben, verwenden Sie unbedingt TOS 1.4 (Rainbow-
TOS, enth„lt u.A. die Zahl 1989 in der Info-Box des Desktops) oder h”her. Die
„lteren TOS-Versionen sind sehr, sehr langsam beim Speichern und Laden.
Das TOS 1.4 gibt es bei fast jedem Atari-H„ndler; oder sehen Sie mal in die
Kleinanzeigen der Computerzeitschriften.

Haben Sie TOS 1.4 (oder h”her), verwenden Sie das Cache-Programm von
Atari! Es heit beispielsweise CACHE90.PRG und geh”rt in den AUTO-Ordner.
Gegenber den meisten  anderen  Caches  puffert  dieser  nicht  wahllos  jeden
Sektor,  sondern  gezielt  FAT  und  Verzeichnisse.  Da  Megamax  Modula-2
intensiver als jedes andere Programm auf die Verzeichnisse zugreift, macht
sich der Atari-Cache hier besonders gut bemerkbar. Zudem: Da es im Grunde
kein Disk-Treiber ist, sondern lediglich die Puffer des GEMDOS erweitert, ist
es prinzipbedingt jedem anderen Cache berlegen.

Wie gesagt, Megamax Modula-2 greift h„ufig auf die Dateiverzeichnisse zu, um
Modulcodes  und  -definitionen  zu  laden.  Deshalb  sollten  die  am  h„ufigsten
ben”tigten Dateien m”glichst schnell gefunden werden. Dazu sollten  Sie  die
Suchpfade entsprechend ordnen: Am Besten w„re es, wenn sich alle Dateien
im jeweils ersten Suchpfad bef„nden.

Sie sollten die  Definitionsdateien  in  der  Bibliothek  MM2DEF.M2L  entpacken.
Mehr dazu im Kapitel 2.4.

šberhaupt  geniet  die  Bibliotheksdatei  einen  Sonderstatus:  Beim  Start  des
Compilers  wird  sie  einmal  ge”ffnet,  das  gesamte  Verzeichnis  wird  in  den
Speicher  geladen.  Die  darin  befindlichen  Dateien  werden  am  Schnellsten
gefunden.  Sie  k”nnen  Ihre  eigenen  Definitionsmodule  auch  in  diese  Datei
einfgen (mit dem LibManager, s. Kap. 2.4).

Benutzen  Sie  Turbo  ST  oder  Quick  ST.  Dies  sind  Programme,  die  die
GEM-Bildschirmausgaben um ein Vielfaches beschleunigen. Wir empfehlen Ihnen
Quick  ST,  das  auch  Erweiterungen  wie  Hyperscreen/Overscan  und  GDOS
untersttzt. Sie erhalten Quick ST gegen Einsendung eines Schecks ber 25
US Dollar bei folgender Adresse:

        Branch Always Software
        14150 N.E. 20th St. #302
        Bellevue
        WA 98007
        USA
2.1  Bedienung: Los geht's                                                2 -  8
________________________________________________________


Namenskonventionen

Falls Sie schon mit anderen Modula-2-Systemen gearbeitet haben, wollen wir
Sie gleich darauf hinweisen, da wir  andere  Endungen  bei  den  Dateinamen
verwenden. Die Quelltexte haben alle nur einen Buchstaben als Endung, und
zwar M fr Haupt-, I fr Implementations- und D fr Definitionsmodule. Die
entsprechenden Code-Dateien haben  MOD,  IMP  bzw.  DEF  als  Endung.  Der
Name der Code-Datei wird nicht aus dem der Quelldatei gebildet, sondern aus
den ersten acht Buchstaben des Modulnamens, der im Quelltext steht.

Wenn Sie gerne andere Endungen verwenden wollen, brauchen Sie lediglich die
Variablen im Quelltext der Shell (MM2SHELL.M) zu „ndern (suchen Sie dort
nach den z.Zt. verwendeten Endungen), bersetzen und die Shell neu zu linken
(siehe dazu Kapitel 2.6). Natrlich mssen Sie auch noch die Endungen der
mitgelieferten Dateien alle „ndern, auch die in der Library (MM2DEF.M2L).


Mathe-Koprozessor (FPU, SFP004, Atari TT)

W„hrend der Atari TT serienm„ig ber eine FPU verfgt, k”nnen Sie sie beim
Atari ST/STE nachrsten (z.B. SFP004 von Atari). Beim ST wird in der Regel
ein 68881, beim TT ein 68882 eingesetzt. Beide sind weitgehend identisch, so
da wir beim Prozessortyp keine Unterschiede machen brauchen.

Allerdings wird eine FPU im ST anders angesteuert als im TT. Aus Grnden,
die im Kapitel ber den Compiler (Kap. 3.4,  F-Direktive)  weiter  ausgefhrt
werden, mssen Sie die Shell bzw. alle gelinkten Programme mit den dafr
angepaten FPU-Modulen binden, um die FPU auch nutzen zu k”nnen. Dazu
verwenden Sie je nach Rechnertyp die Module aus den Ordnern ST FPU bzw.
                                                                       _
TT FPU.
   _

Das einfachste ist, die Module aus einem der Ordner in den IMP-Ordner zu
kopieren.  Dabei  werden  allerdings  die  "normalen"  Module,  die  keine  FPU
benutzen, berschrieben. Wenn Sie schon mit  der  nderung  der  Pfadlisten
vertraut sind, tragen Sie besser den passenden FPU-Ordner als jeweils ersten
Suchpfad bei DefaultPath und ImpPath ein. Dann werden die Dateien dieses
Ordners bevorzugt verwendet.

Linken  Sie  dann  die  Shell  neu,  damit  Programmodule,  die  unter  der  Shell
bersetzt und per Loadtime-Linking  gestartet  werden,  auch  gleich  die  FPU
mitbenutzen k”nnen. Wie Sie die Shell linken, erfahren Sie in Kapitel 2.6; oder
starten Sie einfach den Batch LINKSHEL.M2B.

Mit den FPU-Modulen gelinkte Programme k”nnen Sie nicht auf Rechnern ohne
die entsprechende Hardware einsetzen! Sie werden dann eine Fehlermeldung
erhalten.
2.1  Bedienung: Los geht's                                                2 -  9
________________________________________________________


Ein erstes Programm

Um Megamax Modula richtig nutzen zu k”nnen, sollten Sie als n„chstes die
Kapitel 2.2 (Shell), 2.3 (Editor) und 2.4 (Compiler) lesen. Bevor Sie gr”ere
Programme schreiben, verdient auch Kapitel 3 Ihre Aufmerksamkeit. Aber viel~
leicht sind Sie im  Moment  einfach  neugierig,  ob  Ihr  neues  Modula-System
berhaupt funktioniert? Dann tun Sie doch erstmal folgendes...

Shell starten

Bereiten  Sie  den  Atari  vor,  wie
oben fr Ihre Rechner-Konfiguration
beschrieben, und legen Sie ggf. die
Diskette  mit   MM2SHELL.PRG   in
Laufwerk   A   ein.   Starten   Sie
MM2SHELL.PRG     durch     einen
Doppelklick.  Nach  einiger  Zeit  er~
scheint eine Arbeitsfl„che, die dem
GEM-Desktop „hnelt:

Programm eingeben

Auf der Arbeitsfl„che finden Sie unter anderem eine Box Aktuelle Datei. Im
Namensfeld sollte hinter TEXT kein Name stehen. Um dies ggf. zu erreichen,
k”nnen  Sie  das  Feld  doppelt  anklicken  oder  Control-P  drcken.  Daraufhin
k”nnen Sie dann einen Text eingeben - drcken Sie Esc und dann Return als
Best„tigung. Dann ist das Feld der Aktuellen Datei leer.

Nun soll der Editor gestartet werden. Dazu halten Sie entweder
die  rechte  Maustaste  gedrckt,  w„hrend  mit  der  linken  das
Editieren-Symbol  doppelt  angelickt  wird,  oder  Sie  drcken
Control-E. Damit wird die - leere - aktuelle Datei bearbeitet.

Geben Sie nun das folgende Programm im Editor ein - bitte mit korrekter
Gro- und Kleinschreibung!
2.1  Bedienung: Los geht's                                                2 - 10
________________________________________________________



Programm sichern

Wenn     das     komplette
Programm   eingegeben   ist,
fahren Sie mit der Maus den
Menpunkt  Datei  an,  und
w„hlen  Sie  den  Unterpunkt
Sichern  oder  Sichern  als.
Damit  wird  die  Datei  im
Speicher wieder zurck auf
Disk geschrieben.


                                             Da  dem  Editor  aber  bisher  noch
                                             kein  Name  fr  die  Datei  bekannt
                                             war,  fragt  er  zuerst  danach.  Es
                                             erscheint  der  GEM-Datei-Selektor,
                                             in  dem  nun  ein  Name  fr  den
                                             Programmtext     anzugeben     ist.
                                             Nehmen   wir   ERSTESPR.M   und
                                             speichern es im Ordner USER.






Nun kann der Editor verlassen werden. Dazu ist
entweder Alternate-X zu drcken oder im Men
Beenden anzuw„hlen.




Programm bersetzen

Damit  von  nun  an  in  der  Shell
das Ansprechen der Datei einfacher
wird,  machen  wir  das  Modul  zur
Arbeitsdatei, indem N gedrckt oder
der  entsprechende  Menpunkt  in
der Shell angew„hlt wird.

Nun ist ein kleines Feld auf dem Desktop der Shell erschienen. Darin soll der
Name der Textdatei eingetragen werden. Dies kann manuell durch die Taste P
oder durch einen Doppelklick auf das Feld vorgenommen werden.
2.1  Bedienung: Los geht's                                                2 - 11
________________________________________________________


Bequemer ist es allerdings erstmal,
wenn  Sie  das  Verzeichnis  vom
Laufwerk  mit  der  Datei   ”ffnen
(Doppelklick  auf  das  Disk-Symbol)
und  dann  die  Datei,  wie   beim
Kopieren, auf das Feld ziehen.

Nun gengt ein Doppelklick auf das Ausfhren-Symbol oder ein
Druck auf die Taste A, um das Programm zu bersetzen und
dann zu starten (natrlich kann das šbersetzen auch erst durch
einen  separaten  Compiler-Aufruf  erreicht  werden).  Der  Compiler  wird
gestartet und zeigt in etwa folgendes Bild:










Nehmen wir aber  vorsichtshalber  an,  da  das  Programm  nicht  auf  Anhieb
fehlerfrei ist. In diesem Fall wird der Editor automatisch aufgerufen und zeigt
Ihnen mit dem Cursor die Fehlerposition an. Auerdem ist oben in invertierter
Schrift die Fehlermeldung des Compilers zu sehen. Korrigieren Sie den Text,
und  gehen  Sie  dann  erstmal  wieder  vor,  wie  schon  beschrieben  (Text
speichern, Editor verlassen, Programm ausfhren/bersetzen).

Zur Ausfhrung des Programms ist eigentlich nicht viel zu sagen:  Da  die
Ausgaben in ein Fenster geschrieben werden, haben Sie schon selbst bemerkt.
Vielleicht haben Sie auch schon ausprobiert, da das Fenster vergr”ert und
verschoben werden kann, wie Sie das so kennen? Die Standardausgaben (ber
das Modul InOut) fhren immer auf dieses Standard-Fenster, solange Sie un~
ter der Shell arbeiten (und nicht TOSIO extra importieren). Zus„tzlich steht
ein Window-Modul zur Verfgung, mit dem Sie auch mehrere Fenster beliebi~
ger Gr”en handhaben k”nnen. (Auerdem gibt's ein Terminal-Modul, das ohne
Fenster arbeitet.)
2.1  Bedienung: Los geht's                                                2 - 12
________________________________________________________


Nun wollen wir das Programm erweitern. Wir befinden uns in
der Shell. Dort aktivieren Sie erneut den Editor. Das geht nun
entweder durch Doppelklick auf das Editieren-Symbol oder die
Taste E.

Zurck im Editor, „ndern Sie die WriteString-Anweisungen:



Nun soll erneut bersetzt werden. Dies k”nnte mit dem Menpunkt Ende &
Comp veranlat werden: Der Editor speichert den Text automatisch, und der
Compiler beginnt mit der šbersetzung. Aber es geht auch noch schneller: Der
Editor erlaubt  es,  den  Compiler  zu  starten,  ohne  den
Text zu speichern und den Editor zu verlassen. Allerdings
wird  dann  auch  mehr  Speicherplatz  ben”tigt.  Diese
Funktion  wird  im  Men  durch  Compilieren  oder  durch
Drcken von Alternate-D aktiviert. Wenn allerdings der
Speicher  zum  šbersetzen  nicht  ausreicht,  meldet  der  Compiler  einen
entsprechenden  Fehler  und  Sie  mssen  mit  der  Funktion  Ende  &  Comp.
vorliebnehmen.

Nun wird der Compiler aber einen Fehler melden: Der Cursor steht auf dem
Wort Space, und die Meldung oben weist darauf hin, da dieser Bezeichner
unbekannt ist. Er mu natrlich erst importiert werden. Dazu fgen Sie hinter
dem InOut-Import noch folgende Zeile ein:



Wenn Sie wieder den Compiler starten, sollte er diesmal alles ohne Fehler
bersetzen. Verlassen Sie diesmal den Editor mit dem Befehl Ende & Ausf.
(Tastenbefehl:  Alternate-A).  Der  Text  wird  automatisch  gespeichert,  der
Compiler bersetzt das Programm (wenn Sie das nicht schon vorher im Editor
getan haben), und dann wird das Programm ausgefhrt.

Wenn Ihr Spieltrieb noch nicht ersch”pft ist, k”nnen Sie ja mal einen Lauf~
zeitfehler im Programm erzwingen (beispielsweise durch eine Division  durch
Null) - was dann passiert, k”nnen Sie im Kapitel 2.5 nachlesen.

Spaeshalber k”nnen Sie auch mal das Make (s. Kapitel 2.7) ausprobieren:
Aktivieren Sie im Tools-Men der Shell das Programm ModRef, oder drcken
Sie dazu die Taste F1. In der dann erscheinenden Selektor-Box w„hlen Sie ein
Programmodul aus, z.B. das neu erstellte ERSTESPR.M oder auch eines aus
dem DEMO- oder UTILITY-Ordner. Das Programm wird dann nach kurzer Zeit
wieder die Selektor-Box zeigen, worauf Sie entweder  noch  weitere  Module
ausw„hlen oder das Programm durch Klick auf den Abbruch-Knopf beenden. Es
wurde nun eine Datei mit der Endung M2M in dem Verzeichnis erzeugt, wo Sie
das erste Modul ausgew„hlt haben.
2.1  Bedienung: Los geht's                                                2 - 13
________________________________________________________


Suchen Sie die Datei mit der Endung M2M im Inhaltsverzeichnis, und ziehen
Sie  sie  dann  auf  das  Ausfhren-Symbol.  Erst  wird  das  Make-Programm
gestartet,  dann  werden  alle  Module,  die  Sie  vorher  ausgew„hlt  hatten,
bersetzt und daraufhin das erste Hauptmodul gestartet. Wiederholen Sie dies,
wird  das  Modul  gestartet,  ohne  erneut  bersetzt  zu  werden  -  das  Make
erkennt, da die Module bereits bersetzt sind.

Allerdings hat die Anwendung des Make hier noch keinen groen Sinn - bei
einzeln zum Ausfhren gebrachten Dateien funktioniert diese  Erkennung,  ob
das Modul schon bersetzt ist, sowieso schon direkt von der Shell aus ohne
Verwendung des Make. Und alle Module, die importiert werden, sind Bestand~
teile des Megamax-Systems und deshalb auch schon bersetzt. Erst, wenn
mehrere eigene Module importiert werden, lohnt es sich, das Make intensiver
zu nutzen. Mehr dazu in Kapitel 2.7.

Noch ein Tip zum Starten von Programmen, deren Namen Sie zwar wissen
aber  sie  nicht  erst  umst„ndlich  suchen  wollen,  vielleicht  sogar  erst  noch
bersetzen mssen. Wenn wir Ihnen hier erz„hlen, Sie sollen beispielsweise
das  Programm  TEXTDEMO  starten,  k”nnen  Sie  davon  ausgehen,  da  sich
dessen Quelltext in dem Ordner DEMO oder UTILITY befindet. So k”nnen Sie
nun eine Arbeitsdatei w„hlen (Taste N) und dort den Quelltextnamen (ohne den
Ordnernamen) eingeben (Taste P). Dieser wird in der Regel aus den ersten
acht Buchstaben des Modulnamens und  der  Endung  ".M"  bei  Hauptmodulen
gebildet. Bei unserem Beispiel also TEXTDEMO.M. Nun drcken Sie einfach die
Taste A oder machen einen Doppelklick aus das Ausfhren-Symbol. Dann wird,
falls das Modul noch nicht bersetzt wurde, der Compiler automatisch aktiviert,
daraufhin wird das Programm gestartet.
2.1  Bedienung: Los geht's                                                2 - 14
________________________________________________________

















                               Diese Seite ist leer

























          Trifft dies nicht zu, gehen Sie bitte wie folgt vor:
          Beschaffen Sie ein Blatt Papier (DIN A5). Prfen Sie, ob das Blatt leer, d.h., frei von
          Buchstaben, ist. Lochen Sie das Blatt mittig. Ein Brolocher leistet hierbei gute Dienste.
          Heften Sie das von Ihnen erzeugte Blatt auf diese Seite. Sie mu vollst„ndig verdeckt
          werden. Danke.
          Vers„umen Sie nicht, diesen Hinweis auf dieser Seite nachzutragen, damit die Betriebssicherheit
          Ihres Handbuchs auch weiterhin gew„hrleistet bleibt.
2.2  Bedienung: Shell                                                     2 - 15
________________________________________________________


2.2    Shell

šber die Modula-Shell steuern Sie die einzelnen  Komponenten  des  Modula-
Systems: Editor, Compiler, Linker... Die Shell untersttzt Sie dabei nicht nur
durch die GEM-Benutzeroberfl„che, sondern erledigt vieles auch automatisch
fr Sie - etwa den Aufruf des Editors nach šbersetzungsfehlern oder das
"heimliche" Linken (Binden) eines Moduls vor der Ausfhrung.


Aufruf der Shell

Wir gehen davon aus, da Sie sich eine Arbeitsdiskette zusammengestellt ha~
ben  (siehe  Kapitel  2.1).  Wenn  Sie  alle  dort  beschriebenen  Vorbereitungen
getroffen haben, klicken Sie die Modula-Shell MM2SHELL.PRG doppelt an. Das
Laden der Shell kann - je nach Konfiguration - eine Weile dauern, falls weitere
Module resident geladen werden (siehe 2.1). Wenn die Shell betriebsbereit ist,
meldet sie sich mit einer Menzeile und einem neuen Desktop. Es ist zu beach~
ten,  da  sich  im  Verzeichnis  der  Shell  zumindest  immer  die  Dateien
MM2SHELL.RSC und MM2SHELL.M2P befinden.


Das Shell-Desktop

Das  Monitor~
bild,  das  die
Shell     Ihnen
zeigt, erinnert
Sie      wahr~
scheinlich  ein
wenig  an  das
GEM-Desktop:
Am     oberen
Rand des Bild~
schirms   gibt
es eine Men~
zeile; darunter
eine  Arbeits~
fl„che, auf der  allerlei  Ger„te  'herumstehen'.  Verschaffen  wir  uns  erstmal
einen šberblick ber das Inventar:

Die Diskettensymbole erfllen eine Funktion, die Sie schon vom
GEM kennen - sie repr„sentieren die Massenspeicher, also Dis~
ketten, Festplatte oder RAM-Disk. Wenn Sie einen Kasten dop~
pelt anklicken, wird das Inhaltsverzeichnis in einem Fenster angezeigt. Die Na~
men der Symbole werden brigens von denen des GEM-Desktops bernommen.
2.2  Bedienung: Shell                                                     2 - 16
________________________________________________________



Ebenso  vertraut  sollte  Ihnen  der  Abfalleimer  sein.  Wie  beim
GEM-Desktop kann auch hier alles M”gliche hineingeworfen wer~
den.

Einige Unterschiede zum Desktop gibt es aber doch. Die Inhaltsverzeichnisse
k”nnen nur als Text dargestellt werden und nicht auch als Symbole (Icons).
Auch eine Sortierung nach Datum, Gr”e oder Extension ist z. Zt. nicht m”g~
lich (aber wenn Sie wollen, k”nnen Sie das selbst „ndern - doch dazu mehr im
Kapitel Fnf). Einzelne Dateien lassen sich wie gewohnt selektieren (einfach
anklicken) oder als Objekte auf andere schieben. Die Erweiterung der Selektion
geschieht, wie blich, durch Festhalten der Shift-Taste beim Anklicken. Auf
dem GEM-Desktop ist es auerdem m”glich, mehrere Dateien auf einmal zu
selektieren,  indem  neben  die  Datei-Symbole  bzw.  -Namen  gezeigt  und  mit
festgehaltener Maustaste ein Gummiband um die gewnschten Dateien gezogen
wird. In der Modula-Shell kann nicht neben die Namen geklickt werden - statt
dessen wird diese Multi-Selektion durch Festhalten der Control-Taste erreicht.

Wird eine einzelne Datei selektiert, erscheint ihr Name
brigens auch in der Anzeigebox fr die aktuelle Datei.
Je nachdem, ob es eine ausfhrbare Datei ist (Program~
me, Module, Make-, Batch- und Parameter-Dateien) oder nicht, wird sie als
CODE oder TEXT eingetragen. Die aktuelle Datei spielt bei der Aktivierung der
Shell-Funktionen ber Tastaturkommandos eine Rolle. Sie kann auch manuell
bestimmt werden durch Control-P oder einen Doppelklick auf das Anzeigefeld.

Teilweise wird die aktuelle  Datei  auch  durch  andere  Shell-Operationen  neu
definiert. Beispielsweise wird nach der Compilierung eines Moduls der erzeugte
Code zur aktuellen Code-Datei, so da sich dann, ohne langes Suchen in den
Disk-Verzeichnissen nach der Datei, das Modul bequem durch Control-A oder
einen Doppelklick auf das Ausfhren-Symbol bei gleichzeitigem Festhalten der
rechten Maus-Taste starten l„t.

Hinter dem Resident-Symbol verbirgt sich der Zugriff auf  die
residenten und geladenen Module in der Shell. Durch das ™ffnen
(Doppelklick) erh„lt man ein Fenster, das die z. Zt. geladenen
Module und Programme zeigt - es sind Kopien der ausfhrbaren Code-Dateien,
die von Disk geladen wurden, um schneller verfgbar zu sein. Genauso wie die
Dateien  der  Disk-Inhaltsverzeichnisse  k”nnen  die  geladenen  Module  durch
Ziehen in den Abfalleimer aus dem Speicher (der Shell) entfernt werden oder
umgekehrt  Code-Dateien  aus  Disk-Fenstern  auf  das  Resident-Symbol  oder
dessen Fenster gezogen werden, um sie neu zu laden. Das Resident-Fenster
kann auch durch Drcken der Taste R ge”ffnet werden.
2.2  Bedienung: Shell                                                     2 - 17
________________________________________________________


Durch  Festhalten  der  Alternate-Taste  beim  ™ffnen  des  Resident-Fensters
werden - statt nur der dazugeladenen - alle Module, die zum dem Zeitpunkt
geladen oder resident in der Shell eingelinkt sind, angezeigt - diese residenten
Module k”nnen jedoch nicht entfernt werden (das erreichen Sie nur, indem Sie
die Shell, in welche sie alle fest eingebunden sind, verlassen).

Auf das Linken gehen wir in Kapitel 2.6 intensiver ein - hier nur
als Information, da damit das Linker-Programm gestartet wird,
welches ein Modul so vorbereitet, da es danach auch auerhalb
der Modula-Shell ausgefhrt werden kann. Ein Doppelklick oder Druck auf die
Taste L bewirkt das Linken der aktuellen Arbeitsdatei.

Bleibt noch das Scannen-Symbol, das zur Suche nach Laufzeit~
fehlern dient. N„heres dazu in Kapitel 2.5. Um den Scanner fr
die Arbeitsdatei zu starten, kann ein Doppelklick darauf erfolgen
oder die Taste S gedrckt werden.  Nach  einem  erfolgten  Laufzeitfehler  in
einem Programm  kann  der  dabei  gefhrte  Fehler-Dialog  durch  zus„tzliches
Festhalten der Shift-Taste nochmal aktiviert werden.

Schlielich finden Sie auf dem Bildschirm die Symbole Editieren, Compilieren
und Ausfhren, deren Bedeutung Sie bereits im Kapitel "Ein erstes Programm"
erfahren haben. Auch sie werden  durch ihre Anfangsbuchstaben E, C und A
ber die Tastatur oder durch Doppelklick aktiviert, um die betreffende Opera~
tion mit der aktiven Arbeitsdatei auszul”sen.

Die Arbeitsdateien sind ein bequemes Mittel, um abwech~
selnd verschiedene Module zu bearbeiten. Es k”nnen bis
zu  zehn  von  ihnen  in  der  Shell  angesprochen  werden.  Die  Arbeitsdateien
werden in kleinen Feldern angezeigt, die durch Anklicken oder durch Drcken
der zugeh”rigen Tastenziffer angew„hlt werden k”nnen.

Ist  eine  Arbeitsdatei  selektiert  (die  Ziffer  des  Feldes  ist  zur  Kontrolle
invertiert),  kann  ein  bequemer  Doppelklick  auf  die  Symbole  Editieren,
Compilieren, Ausfhren, Linken oder Scannen, oder der Druck auf einen der
entsprechenden Anfangsbuchstaben, die gewnschte  Operation  bezglich  der
Arbeitsdatei  ausl”sen.   Dieselben   Funktionen   k”nnen   durch   zus„tzliches
Festhalten der Control-Taste oder der rechten Maus-Taste statt dessen auf
die aktuelle Datei angewandt werden.

Natrlich mu eine Datei nicht erst zur aktuellen oder Arbeitsdatei ernannt
werden, um sie beispielsweise in den Editor zu laden. Wie beim Kopieren von
Dateien k”nnen die Eintr„ge aus den Fenstern auch direkt auf die Symbole
gezogen werden.

Ein  Doppelklick  auf  Dateien  ist  auch  m”glich:  Je  nach  Art  der  Datei
- ausfhrbar oder nicht  -  wird  sie  gestartet  oder  in  den  Editor  geladen.
Dateien ohne Extension werden dabei wie Code-Dateien behandelt.
2.2  Bedienung: Shell                                                     2 - 18
________________________________________________________



Zu  Beginn  sind  noch  keine  Arbeitsdatei-
Felder auf dem Desktop vorhanden. Diese
mssen erst durch Drcken der Taste N
oder  Anw„hlen   des   Menpunkts   neue
Arbeitsdatei erzeugt werden. Entsprechend
k”nnen  sie  mit  l”sche  Arbeitsdatei  oder
der Taste Delete wieder entfernt werden.

Ein Modul wird alsdann als Arbeitsdatei bestimmt, indem entweder eine Quell~
textdatei auf ein solches Arbeitsfeld gezogen oder nach Drcken der Taste P
ihr Name manuell eingegeben wird.

Die  restlichen  Funktionen  des  Datei-Mens  entsprechen  denen  des  GEM-
Desktops,  die  jeweils  rechts  aufgefhrten  Tastencodes  dokumentieren  eine
optionale Anwahl ber die Tastatur.

šbrigens  k”nnen  alle  Objekte  einschlielich  der  Arbeitsdateifelder  auf  dem
Shell-Desktop beliebig positioniert werden, beim Verlassen der Shell werden
dann - auf Wunsch - alle Einstellungen gesichert.


Ausfhren von Programmen und anderen Dateien

Zum Ausfhren einer Datei ziehen Sie beispielsweise den Eintrag aus dem Datei~
verzeichnis auf das Ausfhren-Symbol. Auf diese Weise k”nnen Sie sowohl
bersetzte Module ausfhren, die dann automatisch mit den ben”tigten Impor~
ten gebunden werden, als auch komplett gebundene (gelinkte) Programme. Eine
andere M”glichkeit, Dateien zu starten, besteht darin, einen Doppelklick auf
den Eintrag im Fenster durchzufhren.

Es ist auch m”glich, Quelltextdateien zum Ausfhren zu bringen - in diesem
Fall wird erst nach dem vermutlichen Code-Dateinamen gesucht (dieser wird
aus  dem  Quelltext-Namen  und  den  m”glichen  Endungen  der  Code-Module
gebildet); wird er gefunden und ist das Datum der Code-Datei jnger als das
der Quelltextdatei, wird die Code-Datei sofort ausgefhrt, ansonsten wird vor~
her der Quelltext automatisch bersetzt. Dies funktioniert auch bei der aktiven
Arbeitsdatei (die ja immer ein Quelltext sein mu), indem ein Doppelklick auf
das Ausfhren-Symbol get„tigt oder die Taste A gedrckt wird. Voraussetzung
fr die Funktionalit„t dieses Mechanismus ist eine allzeit korrekt eingestellte
Systemzeit im Computer. Wie dies erreicht wird, erfahren Sie im Kapitel 2.7
bei der Anwendung des Make.
2.2  Bedienung: Shell                                                     2 - 19
________________________________________________________


Neben echten Code-Dateien und deren Quelltexten k”nnen auerdem Make-,
Batch- und Parameter-Dateien "ausgefhrt" werden:

* Wird eine Make-Datei (Endung M2M) ausgefhrt, startet die Shell das Make-
  Programm, welches dann prft, ob Module, die in der Make-Datei aufge~
  fhrt sind, neu bersetzt werden mssen (siehe Kapitel 2.7). Ist dies der
  Fall, startet die Shell daraufhin den Compiler,  der  dann  alle  notwendigen
  Module bersetzt - es sei denn, es tritt ein Fehler  auf:  Dann  wird  der
  Vorgang abgebrochen, der Fehler im Editor angezeigt, und der Make-Vorgang
  mu nach der Korrektur wiederholt werden.

* Eine Batch-Datei (Endung M2B) enth„lt eine Reihe von Anweisungen, die mit
  einem Texteditor erstellt werden k”nnen. Mit ihr k”nnen die Suchpfade fr
  Compiler, Editor und Programme sowie die Eintr„ge des Tool-Mens bestimmt
  und andere Programme  (auch  Compiler,  Linker,  Make)  gestartet  werden.
  N„heres weiter unten.

* Eine Parameter- oder Projekt-Datei hat die Endung M2P und enth„lt die Ein~
  stellungen der Shell, wie Arbeitsdateien,  Fensterpositionen,  Parameter  fr
  Editor, Shell, Compiler usw. Diese Dateien werden von der Shell durch das
  Sichern  der  Einstellungen  erzeugt.  Wird  eine  solche  Datei  "ausgefhrt",
  werden alle darin enthaltenen Einstellungen von der Shell bernommen.

Diese Art des Ausfhrens von Quelltexten, Make-, Batch- und Parameterdateien
ist  auch  bei  den  im  Tools-Men  eingetragenen  Funktionen  m”glich:  Wird
beispielsweise  eine  Datei  DEMO.M2M  als  Tool  eingetragen,  wird  bei  ihrer
Aktivierung ber das Tools-Men der Make-Vorgang eingeleitet, so, als wenn
die Datei auf das Ausfhren-Symbol gezogen oder doppelt angeklickt worden
w„re.


Ausfhren speziell von Code-Dateien

Vom GEM-Desktop her ist Ihnen bekannt, da Dateien mit den Endungen APP,
PRG, TOS und TTP ausfhrbar sind. Diese Programme sind mit anderen Ent~
wicklungssystemen (natrlich auch mit Megamax Modula-2) erstellt worden und
haben alle ein einheitliches Dateiformat, das vom Betriebssystem (GEMDOS)
verstanden wird, und somit k”nnen sie vom Desktop oder auch von anderen
Benutzeroberfl„chen (Shells) aus bequem gestartet werden. Diese Programme
haben alle erforderlichen Routinen fest eingebunden und definieren beispiels~
weise auch ihren eigenen Stack-Bereich.

Vom  Modula-Compiler  bersetzte  Module  sind  dagegen  noch  nicht  gelinkt
(gebunden), so da sie auch nicht ohne weiteres vom GEM-Desktop oder einer
anderen Shell gestartet werden k”nnen, weil sie in der Regel dieses fremde
Format nicht kennen. Deshalb verdienen diese Code-Module  auch  keine  der
bekannten  Programm-Endungen.  Ausfhrbar  sind  die  bersetzten  Module
2.2  Bedienung: Shell                                                     2 - 20
________________________________________________________


(natrlich nur die Haupt- und Implementations-, jedoch nicht die Definitionsmo~
dule) unter der Shell aber trotzdem, dank des sogenannten Loaders, welcher
ein in der Shell eingebundenes Modul darstellt, das eine dynamische Bindung
der ben”tigten Module und andere Vorbereitungen, beispielsweise das Anlegen
eines Stacks, automatisch durchfhrt.

Die bersetzen Code-Module k”nnen, entsprechend den gelinkten Programmen,
die Endungen MOD (analog zu APP und PRG), MOS (TOS) oder MTP (TTP)
tragen.  Wird  also  eine  Datei  mit  einer  dieser  Endungen  unter  der  Shell
ausgefhrt, wird sie wie die gelinkten Programme unter dem  GEM-Desktop
behandelt: Bei MOS-Dateien wird der TOS-Modus (weier Hintergrund, Maus
aus, Blinke-Cursor an) aktiviert, bei MTP-Dateien wird zus„tzlich nach einer
Kommandozeile  (Argumentzeile)   fr   das   Programm   gefragt.   Wird   ein
Code-Modul an den Linker zum Binden bergeben, erzeugt dieser passend zur
Endung  den  entsprechenden  Programmnamen  (Bsp:  "TEST.MOS"  wird  zu
"TEST.TOS").

Falls Ihnen brigens andere Endungen besser vertraut sind (OBJ, OBM, SYM,
usw.),  k”nnen  Sie  in  Kapitel  Fnf  nachlesen,  wie  einfach  Sie  dies  dem
Megamax-System beibringen k”nnen.

Der Linker kennt noch eine weitere Endung: Aus MAC  erzeugt  er  gelinkte
Dateien der Endung ACC; dies ist vorteilhaft, wenn Sie Accessories erzeugen
wollen - diese drfen in der Regel nicht ausgefhrt, sondern nur als ACC-
Dateien beim Booten des Rechners vom GEM aktiviert werden (es sei denn,
Sie verwenden die Funktion PrgCtrl.Accessory() zur Abfrage, ob das Programm
als normale Anwendung oder als Accessory gestartet wurde).

Durch das Festhalten der Shift-Taste beim Starten erhalten Sie die M”glichkeit
zur Eingabe einer Argumentzeile (Command Line) auch bei Programmen der
Endungen MOD, MOS, APP, PRG und TOS.

Ein Problem, das noch nicht ganz zufriedenstellend gel”st wurde, ist die Wahl
des aktuellen Verzeichnisses fr zu startende Programme. So gibt es Pro~
gramme, die als Hilfsprogramme der Shell dienen und  die  oft  gerne  stan~
dardm„ig auf den in der Shell aktuellen Pfad (der durch das oberste offene
Disk-Fenster  bestimmt  wird)  zugreifen  wollen,  beispielweise,  wenn  sie  den
GEM-Datei-Selektor anzeigen. Andererseits gibt es Anwendungen, die weitere,
dazu geh”rende Dateien nachladen wollen, wie zum Beispiel GEM-Resource-
Dateien (Endung RSC). Damit sie diese Dateien finden, ist es in der Regel so
zu l”sen, da sie im Verzeichnis gesucht werden, in dem auch das Programm
selbst steht. Davon macht beispielsweise auch die Modula-Shell Gebrauch: Sie
sucht bei ihrem Start die Dateien MM2SHELL.RSC und MM2SHELL.M2P im zu
dem Zeitpunkt aktuellen Verzeichnis,  welches  normalerweise  auch  dasjenige
ist, in welchem die Shell selbst steht, weil ja auch im GEM-Desktop das ent~
sprechende Fenster obenauf offen liegen mu, damit die Shell gestartet werden
kann.
2.2  Bedienung: Shell                                                     2 - 21
________________________________________________________


Nun gibt es aber auch beim GEM-Desktop die M”glichkeit, Programme nicht
aus dem vordersten, aktiven Fenster zu starten: Zielt man beim Starten auf
ein Programm in einem inaktiven Fenster und h„lt dabei die rechte Maus-Taste
fest, wird das Programm gestartet, w„hrend das vordere Fenster den aktuellen
Pfad  bestimmt.  Dies  machte  sogar  den  Entwicklern  des  TOS  bei  ATARI
Schwierigkeiten, denn je nach Version des TOS gibt es verschiedene Resultate:
Einmal wird das Programm berhaupt nicht gestartet, ein anderes Mal kann es
seine RSC-Datei nicht finden.

Die Megamax-Shell geht nun so vor: Wird das Programm von einem Fenster
gestartet,  wird  immer  der  Pfad  zum  aktuellen,  von  dem  das  Programm
stammt. Ebenso wird verfahren, wenn eine Arbeitsdatei gestartet wird. Wird
die  aktuelle  Datei  aufgerufen,  h„ngt  der  aktuelle  Pfad  vom  eingegebenen
Dateinamen  ab:  Ist  ein  Pfadname  im  Dateinamen  enthalten,  wird  dieser
aktiviert. Ist kein Pfadname enthalten, wird wiederum derjenige verwendet, von
dem das Programm gestartet wird (das funktioniert, weil die Programme dann
in den Ordnern gesucht werden k”nnen). Dies macht bei der aktuellen Datei
nur dann einen Unterschied, wenn ihr Name manuell eingegeben wurde (durch
Doppelklick  auf  dessen  Feld  oder  mittels  Control-P);  beim  Benennen  der
aktuellen Code-Datei durch Anklicken im Fenster oder nach einem Make- oder
šbersetzungsvorgang wird immer der vollst„ndige Pfadname mit bernommen.

Wollen Sie also ein bestimmtes Programm starten, das Sie nicht erst in den
Ordnern suchen wollen, brauchen Sie nur die aktuelle Datei zu  bestimmen,
indem Sie den Namen des Programms (mit Endung, aber ohne Pfad) eingeben
(Control-P) und dann starten (Control-A). Wollen Sie gar erreichen, da ein
Programm  einen  bestimmten  aktuellen  Pfad  erh„lt,  kann  dieser  bei  der
Bestimmung der aktuellen Datei als Pfad mit eingegeben werden. Dann wird
dieser Pfad zum aktuellen, das Programm wird jedoch, wenn es dort nicht
vorhanden  ist,  weiterhin  in  den  anderen  Ordnern  gesucht  und  von  dort
gestartet.

Bei den Systemprogrammen (Compiler, Linker, Make, Editor) und den unter
dem Tools-Men eingetragenen Programmen verh„lt es sich noch etwas anders.
Da die Systemprogramme als feste Bestandteile des Entwicklungssystems mit
der Shell  in  besonderer  Weise  kommunizieren  bzw.  die  Tools  oft  „hnliche
Funktionen erfllen,  kann  ihnen  der  aktuelle  Pfad  praktisch  egal  sein.  Aus
diesem Grund wird bei ihren Aufrufen normalerweise kein neuer aktueller Pfad
eingestellt, statt dessen bleibt der Pfad der Shell (oberstes Fenster) aktiv.
Damit nun aber auch andere Editoren oder Tools ihre ben”tigten Dateien (z. B.
RSC) nachladen k”nnen, gibt es auch hier die M”glichkeit, ihren aktuellen Pfad
zu definieren: Ist ein Systemprogramm oder ein Tool mit einem Pfadnamen
eingetragen, wird dieser Pfad beim Start aktiviert, ansonsten wird der Pfad
der Shell beibehalten.
2.2  Bedienung: Shell                                                     2 - 22
________________________________________________________


Um allgemein das Wechseln des Aktuellen Pfades beim Start eines Programms
zu verhindern, mu die Alternate-Taste bei Aktivierung der Ausfhren-Funktion
festgehalten werden.


Programmaufruf und -abbruch bei gelinkten Programmen

Wird   ein   gelinktes   Programm   ausgefhrt,   geschieht   dies,   wie   vom
GEM-Desktop her gewohnt: Das Programm wird in den Speicher geladen, falls
dies nicht schon vorher geschehen ist (siehe Laden von Code-Dateien), dann
wird  dessen  BSS-Bereich  (Speicher  fr  die  globalen  Variablen)  gel”scht,
zuletzt  wird  es  gestartet.  Endet  das  Programm,  wird  zur  Megamax-Shell
zurckgekehrt.

Tritt ein fataler Fehler im aufgerufenen, gelinkten Programm auf, so da eine
68000-Exception (Bus-Fehler, Adre-Fehler und weitere von dem Programm
nicht abgefangene Fehler) ausgel”st wird, erscheint statt der vom Desktop-
Start gewohnten B”mbchen die Scanner-Box (siehe Kapitel 2.5), in der aber
dann  keine  Lokalisation  der  Fehlerstelle  ber  Back  und  Frwd  m”glich  ist.
W„hlen Sie dann Quit, finden Sie sich in der Shell wieder. Dann kann es aber
sein, da die Maus nicht  mehr  sichtbar  ist  oder  andere  unsinnige  Effekte
eintreten. Wenn die Shell noch auf Eingaben reagiert, verlassen Sie die Shell,
z. B. mit Control-Q. Oft stellt dann  das  GEM-Desktop  den  Normalzustand
wieder her, so da Sie die Megamax-Shell erneut starten k”nnen. Bei solchen
Abstrzen von Progammen ist es aber in der Regel immer das Sicherste, so
bald wie m”glich einen Neustart des Rechners, beispielsweise durch Drcken
des RESET-Tasters, zu veranlassen, weil es m”glich ist, da das fehlerhafte
Programm auch Speicherbereiche, die dem TOS oder der Shell reserviert sind,
unkontrollierbar  berschrieben  hat,  was  sich  teilweise  erst  sehr  sp„t
bemerkbar macht.


Das Binden der Module

Wird ein vom Compiler bersetztes Modul gestartet, mssen zuerst die von
ihm importierten Module dazugebunden (gelinkt) werden.  Dies  wird  von  der
Prozedur CallModule des Loader-Moduls, die die Shell zum Starten sowohl von
gelinkten Programmen als auch von ungelinkten Modulen aufruft, automatisch
erledigt: Jedes ben”tigte Modul wird in den Speicher geladen, wird ein Modul
von  mehreren  anderen  importiert,  wird  es  selbstverst„ndlich  nur  einmal
geladen.  Danach  werden  die  Module  gebunden,  das  heit,  die  Referenzen
zwischen den Modulen (dies sind die importierten Prozeduren und Variablen)
werden fest verkettet. Diesen Vorgang nennt man Load-Time-Linking, weil das
Binden (Linken) der einzelnen Objekt-Module bei jedem Laden in den Speicher
von neuem erfolgt. Dem gegenber steht das einmalige Linken im voraus, bei
dem das Ergebnis als eine Datei (gelinktes Programm) erzeugt wird.
2.2  Bedienung: Shell                                                     2 - 23
________________________________________________________


Auf den ersten Blick nun erscheint es ineffektiv, bei jedem Start das Linken
durchzufhren,  anstatt  dies  einmal  zu  tun:  Wird  das  Programm  mehrmals
nacheinander ohne nderungen gestartet, vergeht viel mehr Zeit  durch  das
wiederholte  Laden  der  einzelnen  Code-Module  statt  der  einen  gelinkten
Programmdatei. Dies trifft aber nur bedingt zu. Ein Vorteil im dynamischen
(Load-Time-) Linken liegt darin, da die Fehlerbehandlung (Debugging) einfacher
zu  gestalten  ist,  zweitens  k”nnen  so  mehrere,  abwechselnd  gestartete
Progamme  leichter  Informationen  untereinander  austauschen,  und  zu  guter
Letzt ist es oft auch zeitsparender. Das kommt daher:

Der Loader (bzw. dessen Funktion CallModule) l„dt jedes ben”tigte Modul nur
einmal, auch wenn es von mehreren Modulen importiert wird. Dies ist sinnvoll
und  findet  bei  auch  jedem  normalen  Linker  anderer  Entwicklungssysteme
Verwendung.

Die Megamax-Shell besteht nun wiederum selbst aus vom Megamax-Compiler
bersetzten Modulen, die lediglich durch den Linker in eine Datei zusammengefgt
wurden. Nun bietet es sich an, diese schon im Speicher befindlichen Module bei
Bedarf  mitzubenutzen,  genauso  wie  dies  mit  den  nachgeladenen  Modulen
geschieht. Bedingung ist lediglich, da das Loader-Modul, das selbst ja auch
Bestandteil  der  Shell  ist,  ausreichend  Informationen  ber  die  in  der  Shell
befindlichen Module erh„lt. Dies wurde beim Linken der Shell durch eine beson~
dere Einstellung (Linken ohne Optimierung) erreicht.

Wird also der Loader aufgerufen, ein Modul zu starten (z. B. durch Ansprechen
der Ausfhren-Funktion der Shell), geht er wie bereits oben beschrieben vor:
Zuerst wird nachgesehen, ob sich das geforderte Modul schon im Speicher
befindet. Normalerweise ist dies beim Hauptmodul noch nicht der Fall,  also
wird es nachgeladen und der Loader merkt sich, da dieses Modul nun geladen
ist. Dann wird nachgesehen, welche Module importiert werden. Bei denen wird
genauso verfahren: Ist das Modul noch nicht im Speicher, wird es geladen und
dessen Importe ebenfalls bercksichtigt.

Ist ein Modul schon im Speicher, wird es nicht weiter verfolgt - in diesem Fall
kann  davon  ausgegangen  werden,  da  alle  seine  Importe  ebenfalls  schon
geladen sind. Es ist also nicht m”glich, auch nicht mit den Lade-/Entlade-
Funktionen des Loader-Moduls bzw. der Shell,  da  am  Ende  ein  Modul  im
Speicher verbleibt, dessen Importe nicht ebenfalls alle geladen sind!

Nach diesen Lade-Regeln nun werden die  in  der  Shell  vorhandenen  Module
immer als bereits geladen (speziell: resident) behandelt. Daraus folgt, da ein
Modul, das nur Module importiert, die schon in der Shell befindlich eingebunden
sind, praktisch keine Ladezeit mehr hat, weil lediglich das Hauptmodul selbst
von Disk geladen werden mu - das Binden dieses Moduls mit denen der Shell
geht so schnell, da Sie davon nichts merken.
2.2  Bedienung: Shell                                                     2 - 24
________________________________________________________


Nach der Bindung aller Module werden zuerst, wie bei gelinkten Programmen,
alle globalen Variablen gel”scht (Pointer auf NIL, REALs auf 0.0) und dann alle
Modulk”rper aufgerufen, das am tiefsten liegende von den anderen importierte
Modul  wird  zuerst,  das  oberste,  von  der  Shell  ausgew„hlte  Modul  zuletzt
initialisiert. Bei zirkularen Importen (A importiert B, B wiederum A) ist die
Reihenfolge undefiniert und kann jederzeit wechseln.

Wollen Sie die M”glichkeit nutzen, da mehrere durch CallModule gestartete
Anwendungen (Module) Daten ber gemeinsam importierte Module austauschen
(shared  data),  mssen  Sie  verhindern,  da  diese  gemeinsamen  Module
jedesmal neu  initialisiert  werden  und  neuen  Speicherplatz  fr  ihre  globalen
Variablen  erhalten.  Das  erreichen  Sie,  indem  Sie  solche  Module  mit  einer
besonderen Compiler-Direktive ($Y+, siehe Kapitel 3.4) bersetzen.

W„hrend der gesamten Initialisierungsphase und beim Start des Hauptmoduls
wird ein Stack verwendet, dessen Gr”e in Info/Umgebung unter Stackgr”e...
(fr Load-Time-Linking) einstellbar ist. Tritt w„hrend des Programmlaufs ein
Stack-šberlauf-Fehler auf, kann der Stack also ohne Neubersetzung fr den
n„chsten Start ver„ndert werden.  Die  Systemprogramme  (Compiler,  Linker,
Make sowie die Editoren GME und GEP ED) verwenden brigens eine eigene,
                                          _
fest in der Shell definierte Stackgr”e.
2.2  Bedienung: Shell                                                     2 - 25
________________________________________________________


Resident-Laden von Code-Dateien

Wenn ein gestartetes Modul abgelaufen ist, wird es wieder aus dem Speicher
entfernt. Auch die von ihm importierten Module, die noch von der Diskette
nachgeladen wurden, bleiben natrlich nicht im Speicher - bei einem  neuen
Start des Moduls wird alles erneut geladen. Um bei h„ufiger Benutzung eines
Moduls diese Ladezeiten zu eliminieren, k”nnen Sie Module in den Speicher
laden.   Dazu   dient   das   Resident-Symbol   auf   der   Arbeitsfl„che.   Das
Resident-Symbol  funktioniert  ganz  „hnlich  wie  die  Diskettensymbole.  Sie
k”nnen...

* einen Dateieintrag auf das Ladesymbol schieben, um das Modul
in den Speicher zu laden (Control-R l„dt die aktuelle Datei). Es
ist auch m”glich, gelinkte Programme auf diese Weise zu laden;

* das Ladesymbol doppelt anklicken, um ein Fenster mit dem Verzeichnis der
geladenen Module zu ”ffnen;

* Eintr„ge aus diesem Fenster mit der Maus auf das Ausfhren-Symbol schie~
ben oder doppelt anklicken, um sie auszufhren. Allerdings ist es auch m”glich,
ein Modul aus einem ganz normalen Dateifenster zur Ausfhrung zu bringen -
die Shell (der Loader) berprft, ob das Modul schon geladen ist, und fhrt
ggf. die geladene Version aus.

* Auerdem ist es m”glich, Eintr„ge aus dem Verzeichnis der geladenen Mo~
dule in den Abfalleimer zu schieben, um sie wieder aus dem RAM zu l”schen.
Beachten Sie aber, da das Ladesymbol keine normale RAM-Disk darstellt -
beim Laden werden die Module bereits fr die Ausfhrung vorbereitet (gelinkt);
daher ist es nicht m”glich, ein geladenes Modul auf ein Diskettensymbol zu
schieben oder an den Linker zu bergeben!

Ein anderer Weg, Module und gelinkte Programme resident laden zu lassen, ist
das Eintragen eines LOAD-Kommandos in eine Batch-Datei (s. Abschnitt weiter
unten in diesem Kapitel). Dies ist eine bequeme M”glichkeit, regelm„ig ben”tigte
Module resident in den Speicher zu laden, solange man sich in der Modula-
Shell befindet.

Die  so  geladenen  Module  werden  zwar  in  die  schon  residenten  Module
eingebunden (gelinkt), jedoch nicht intitialisiert! Die Initialisierung mit  Aufruf
der Modulk”rper wird weiterhin so vorgenommen, wie unter Binden der Module
beschrieben, also als wenn sie jedesmal bei Bedarf doch  von  Disk  geladen
werden wrden.

Zum Schlu noch ein Tip: W„hrend der Programmentwicklung k”nnen Sie den
Entwicklungszyklus (Edieren -  šbersetzen  -  Testen)  deutlich  beschleunigen,
falls Ihr Programm Module importiert, die nicht bereits in der Shell vorhanden
2.2  Bedienung: Shell                                                     2 - 26
________________________________________________________


sind (das merken Sie an den Diskettenzugriffen vor jedem Programmstart):
Dann sollten Sie die importierten Module laden. Das Programm, an dem Sie
gerade arbeiten, sollte dagegen nicht geladen sein - die geladene Version hat,
wie oben gesagt, immer Vorrang vor  dem  neu  bersetzten  Modul  auf  der
Diskette.

Das Laden ist meist dem Ablegen eines Moduls in der RAM-Disk vorzuziehen:
Ein Modul aus der RAM-Disk wird zur Ausfhrung jeweils ein zweites Mal in
den RAM kopiert und belegt dann doppelten Platz. Allerdings wird beim Laden
bereits Platz fr die globalen Variablen reserviert, der belegt bleibt, solange
das Modul im RAM verbleibt. Dies wiederum macht sich bei wenigen Program~
men deutlich bemerkbar (beispielsweise bei dem Programmeditor TEMPUS von
CCD).


Laden gelinkter Programme

Das Laden von gelinkten Programmen wird prinzipiell durch eine Sonderfunktion
des  GEMDOS  erm”glicht.  Aufgrund  einer  konzeptionellen  Schw„che  bei
besagter Funktion ist aber deren Anwendung leider nicht so "idiotensicher" wie
die des Ladens von Megamax-Modulen.

Das Problem ergibt sich bei der Reservierung des Stacks fr die Programme:
Ein gelinktes Programm, das normal gestartet wird, wird an den Beginn des
gr”ten freien Speicherbereichs geladen. Wird es dann aufgerufen, erh„lt es
erstmal den gesamten freien Speicher hinter dem Programmcode fr sich als
reservierten Speicher. Daraufhin berechnet es den fr sich selbst ben”tigten
Speicher und gibt den Rest wieder frei. Der selbst ben”tigte Speicher besteht
in der Regel aus dem Platz fr die globalen Variablen und dem Stack des
Programms.

Wird ein solches Programm nur geladen, mu der Loader, der dies organisiert,
dafr sorgen, da nur so viel Platz fr das Programm reserviert bleibt, wie es
sp„ter beim Start ben”tigen wird, damit der Rest des Speichers frei bleibt fr
weitere Anwendungen. Aufgrund der Konventionen aber  mu  das  Programm
erwarten k”nnen, da es den ben”tigten Speicher fr die Variablen und den
Stack  direkt  hinter  dem  Programmcode  vorfindet  (fr  die  Experten:  Die
Relozierung, die das GEMDOS beim Laden vornimmt, nimmt auch sofort die
Adrebestimmung der globalen Variablen im BSS-Segment - welches in der
Regel direkt hinter dem Programmcode oder dem DATA-Segment liegt - vor,
so da dieser Bereich sp„ter nicht mehr an eine andere Stelle verschoben
werden kann). Hier liegt das Problem:  Es  ist  zwar  allgemein  m”glich,  den
ben”tigten Platz fr die globalen Variablen zu ermitteln, die Stack-Gr”e aber
kann  nicht  vorausgesehen  werden.  So  mu  also  beim  Laden  abgesch„tzt
werden, wieviel Platz der Stack sp„ter ben”tigen wird. Zuviel Platz kann dem
Programm nicht schaden, nur wird der Platz ja schon beim Laden reserviert,
so da der verbleibende freie Speicher ggf. unn”tig eingeschr„nkt wird.
2.2  Bedienung: Shell                                                     2 - 27
________________________________________________________


Ist der Stack zu klein gew„hlt, ist es m”glich (aber nicht sicher), da das
geladene  Programm  w„hrend  seines  Aufrufs  fehlerhaft  arbeitet  oder  gar
abstrzt (Programm reagiert nicht mehr auf Eingaben, oder es erscheinen die
B”mbchen und das Programm kehrt in die Shell zurck).

Gegebenenfalls  mu  also  zuerst  ein  geladenes  Programm  mit  Vorsicht
angewendet werden (jedenfalls sollte es bei Unsicherheit nicht mit wichtigen
Originaldaten arbeiten, die es ja zerst”ren k”nnte).

Die meisten Fremdprogramme verwenden einen Stack von 8 bis 16 KByte (auch
Tempus kommt beispielsweise mit einem Stack von 8KB, =8192, zurecht). So
reicht  es  oft  aus,  zur  Sicherheit  den  Stack  beim  Laden  in  dieser  Gr”e
vorzusehen. Erst,  wenn  sich  ungew”hnliche  Effekte  bei  der  Benutzung  der
geladenen Programme zeigen, sollte der Stack jeweils vor dem erneuten Laden
durch Verdoppelung erh”ht werden.

Die Bestimmung des Stacks  beim  Laden  von  gelinkten  Programmen  erfolgt
durch den Wert, den auch der Loader beim Start von Modulen verwendet. Er
kann in den Umgebungsinformationen unter Stack-Gr”e fr Load-Time-Linking
bestimmt oder durch die Anweisung STACKSIZE in Batch-Dateien, am besten
direkt vor dem Laden des Programms mit LOAD, auf einen besonderen Wert
gesetzt werden.
2.2  Bedienung: Shell                                                     2 - 28
________________________________________________________


Die Menzeile der Shell

Die  Menzeile  am  oberen  Bildschirmrand  bietet  die  Menpunkte  MM2Shell,
Datei, Parameter, Info und ggf. Tools an. Unter MM2Shell erreichen Sie wie
blich die Accessories sowie eine Meldung ber die Version der Shell. Der
Menpunkt Datei wurde schon weiter oben behandelt.

Unter Parameter finden sich:

Shell: Siehe unten.
Editor: Siehe Kapitel 2.3
Compiler: Siehe Kapitel 2.4
Linker: Siehe Kapitel 2.6
speichern: Sichert die Einstellungen aller Parameter, der Symbol- und Fenster~
  positionen  und  der  Umgebungseinstellungen,  jedoch  nicht  den  Status  der
  geladenen Module, der ber die Menzeile abrufbaren Tools und der Such~
  pfade  (diese  Einstellungen  sind  ber  die  Batch-Dateien  bestimmbar).  Die
  Einstellungen  werden  in  der  Datei  gesichert,  die  zu  dem  Zeitpunkt  als
  Parameterdatei unter Parameter/Shell... eingestellt ist.

Die Raute bei den Tastenangaben im Parameter-Men zeigt brigens an, da
diese Funktionen mit der Alternate-Taste in Verbindung mit dem Buchstaben zu
erreichen sind, w„hrend der Pfeil fr die Control-Taste steht.


Unter Info finden sich:

Umgebung: Siehe unten.
Hilfe: Zeigt den Inhalt der Textdatei MM2SHELL.HLP an, falls sich diese im
  Verzeichnis der Shell befindet.


Unter Tools k”nnen Sie bis zu zehn eigene ausfhrbare
Dateien eintragen (mittels der Anweisung Tool in  einer
Batch-Datei). Diese erscheinen dann  unter  dem  Tools-
Menpunkt und k”nnen auch ber die Funktionstasten an~
gew„hlt werden.
2.2  Bedienung: Shell                                                     2 - 29
________________________________________________________


Die Shell-Parameter (Parameter/Shell...)

Erzeuge Fenster:
Wurzel ”ffnet  Fenster  bei
Doppelklick  in   gewohnter
Weise.  Der  aktuelle  Pfad
kann  statt  dessen   ent~
weder  durch  die  hiesige
Standardeinstellung    oder
durch Festhalten der Shift-
Taste   beim   Doppelklick
ge”ffnet werden.

Kopier- und L”schbest„tigung bestimmen, ob bei den entsprechenden Dateiope~
rationen eine Best„tigung gefordert werden soll.

Abbruch mit Control-C: Ist diese Option aktiv, k”nnen von der Shell gestartete
Programme mit Control-C abgebrochen werden, w„hrend sie Ein- oder Ausga~
ben ber die Module TextWindows oder InOut durchfhren. Auch ist es dann
m”glich, mit Control-Enter Programme zu jeder Zeit abzubrechen - dies sollte
aber nur dann geschehen, wenn Control-C nicht wirkt und das Programm nicht
gerade Betriebssystemaufrufe (z.B. Zugriff auf die Disk oder Grafikausgaben
auf dem Bildschirm) durchfhrt, da es sonst zu Fehlverhalten des Systems
kommen kann. N„here Informationen im Definitionstext des Moduls UserBreak.

Anwender eines Drucker-Spoolers oder der Flexdisk sollten die Option Maximaler
Kopierpuffer gegebenenfalls deaktivieren, ansonsten bietet es sich fast immer
an, diese Option zu nutzen, denn dadurch wird bei Kopiervorg„ngen fast der
gesamte  Speicherplatz  verwendet,  um  den  Kopiervorgang  m”glichst  schnell
durchzufhren.

Unter Make wird der Name des Make-Programms eingetragen - dies ist in der
Regel MM2Make.

In Temp. Pfad sollte ein Ordnername eingetragen werden, in dem die Shell und
die Hilfsprogramme kurzzeitig kleine Dateien ablegen k”nnen. So  legt  Make
dort beispielsweise die Steuerdatei der evtl. zu bersetzenden Module fr den
Compiler ab. Nach M”glichkeit sollte dieser Pfad auf einem schnellen Ger„t
liegen, also eher auf einer RAM-Disk als einer Diskette - ein Pfad auf der
Harddisk reicht natrlich auch aus.

Die Batch-Datei (mit der Endung M2B) ist diejenige, die ausgefhrt wird, wenn
die  darunter  angegebene  Parameterdatei  (teilweise  auch  als  Projekt-Datei
bezeichnet) aktiviert oder "ausgefhrt" wird. Diese  wiederum  kann  aktiviert
werden, indem sie - vorausgesetzt, sie hat die Dateiendung M2P - auf ge~
wohnte  Weise  (Doppelklick,  Ziehen  auf  das  Ausfhren-Symbol,  Starten  als
Tool)  "ausgefhrt"  wird.  Einen  Sonderstatus  geniet  die  Parameterdatei
2.2  Bedienung: Shell                                                     2 - 30
________________________________________________________


MM2SHELL.M2P: Sie wird beim Starten der Shell, wenn sie  sich  in  deren
Verzeichnis befindet, automatisch ausgefhrt. Somit mu die Batch-Datei, die
beim Start der Shell ausgefhrt werden soll, nicht zwingend "MM2SHELL.M2B"
heien, sondern lediglich als Batch-Datei der Parameterdatei MM2SHELL.M2P
definiert sein.

Um eine neue Parameter- oder Batch-Datei zu erstellen, k”nnen Sie folgen~
dermaen  vorgehen:  Tragen  Sie  eine  beliebige  Datei  der  Endung  M2B  als
Batch-Datei und ebenso eine der Endung M2P (z. B. MM2SHELL.M2P fr die
Autostart-Parameter) als Parameterdatei ein. Dann verlassen Sie den Shell-
Parameter-Dialog und w„hlen Parameter/speichern... an. So werden die aktu~
ellen Einstellungen unter der gew„hlten Parameterdatei gesichert.


Die Umgebungsinformationen (Info/Umgebung...)

Letzter  Code/L„nge  infor~
mieren ber die vom letzten
Compileraufruf erzeugte Code-
Datei und dessen L„nge.

Normalerweise    wird    der
aktuelle   Pfad   durch   das
oberste,   ge”ffnete   Disk-
Fenster bestimmt. Ist jedoch
keins offen,  kann  der  Pfad
hier abgelesen oder auch ge„ndert werden. Das ndern des Pfades hat keinen
Erfolg, wenn ein Fenster ge”ffnet ist - dieses hat dann Vorrang.

Die Default-Make-Datei wird aktiviert, wenn in der Shell die Taste M gedrckt
wird oder wenn vom Editor (GEP_ED oder GME) aus die Make-Funktion ange~
w„hlt wird. Das Aktivieren einer Make-Datei bewirkt den Aufruf des Make-
Programms, welches dann aufgrund der Informationen aus der Make-Datei (mit
Endung M2M) prft, ob Dateien zu bersetzen sind und daraufhin dann den
Compiler dazu aufruft. N„heres in Kapitel 2.7.

Die Stack-Gr”e fr das Load-Time-Linking wird den Anwendungsmodulen zur
Verfgung gestellt, wenn sie unter der Shell gestartet werden (gelinkte Program~
me haben bereits intern eine feste Einstellung - beim Linken von Megamax-
Modulen kann dieser Wert ebenfalls bestimmt werden, allerdings in den Lin~
ker-Optionen). Der anfangs eingestellte Wert von 16 K Bytes kann zu klein
sein, wenn das Programm rekursiv arbeitet oder groe Datenstrukturen als
lokale Variablen verwendet (Sie erfahren dies dann w„hrend des Programm~
laufs durch die Fehlermeldung "Stack-šberlauf").

Taste nach TOS-Programmen: Wartet beim Ende von TOS-Programmen auf
einen Tastendruck, damit eventuelle Ausgaben noch gelesen werden k”nnen.
2.2  Bedienung: Shell                                                     2 - 31
________________________________________________________


Der aktuell freie Speicherplatz wird in zwei Werten angezeigt. Der linke gibt
den gr”ten  zusammenh„ngenden  Bereich,  der  rechte  den  gesamten  freien
Platz an.


Tasten-Funktionen

Zusammenfassend haben folgende Tasten in der Shell eine Funktion:

Anfangsbuchstaben der Symbole: Sie bearbeiten alle die jeweils aktive Arbeits~
datei, es sei denn, es wird zus„tzlich die Control-Taste gedrckt - dann wird
stattdessen die aktuelle Datei bearbeitet.

  A        Ausfhren (von Programmen, Modulen, Make, Batch, Projektdateien)
                 Wird dabei Shift festgehalten, kann eine Argumentzeile (wie
                 bei  TTP  bzw.  MTP-Programmen)  eingegeben  werden,  beim
                 Festhalten von Alternate bleibt der aktuelle Pfad erhalten.
  C        Compilieren (šbersetzen)
  +         Compilieren, dann Ausfhren
  E        Laden der Datei in den Editor
  L         Linken (Binden der Module zu einem Programm)
  S        Aktivieren des Scanners
                 Falls  vorher  bei  einem  Programmaufruf  ein  Laufzeitfehler
                 auftrat und die Scanner-Dialogbox erschien, kann durch Ein~
                 gabe von Shift-S der letzte Dialog wiederholt werden, um eine
                 andere Textposition anzuscannen (siehe Kapitel 2.5).
  P        Eingabe der Arbeits- oder aktuellen Datei ber Tastatur.

Weitere spezielle Funktionen, die nicht aus den Menzeilen ersichtlich sind:

  M        Make-Vorgang mit der Default-Make-Datei einleiten.
  Ctrl-R   Laden der aktuellen Code-Datei.
  R        Anzeige der geladenen Module und gelinkten Programme.
  Alt-R    Anzeige aller im Speicher vorhandenen (residenten) Module.

Bleiben noch folgende versteckte Funktionen:

  Esc      Neuanzeige des Inhalts des obersten Fensters, z.B. nach Wechseln
            einer Diskette;
            W„hrend des Starts der Shell kann durch Druck auf diese Taste
            verhindert werden, da Programme durch den Start-Batch geladen
            werden.
  Home    Schliet das Verzeichnis des aktiven Fensters.
  Clr       (Shift-Home)  Schliet  das  aktive  Fenster.  Werden  beide  Shift-
            Tasten festgehalten, werden alle Fenster geschlossen.
  Ctrl-Q   Beenden der Shell ohne Nachfrage zum Sichern der Einstellungen.
2.2  Bedienung: Shell                                                     2 - 32
________________________________________________________


Batch-Dateien

In Batch-Dateien k”nnen h„ufig ben”tigte Shell-Operationen und -Einstellungen
beschrieben und dann jederzeit zur Ausfhrung gebracht werden. Auerdem
werden hiermit die Suchpfade der Dateien fr Shell, Editor, Compiler, Linker
und Make eingegeben. Die Batch-Datei ist ein normaler ASCII-Text, der alle
Anweisungen  im  Klartext  enth„lt,  daher  k”nnen  Sie  diese  Datei  mit  dem
mitgelieferten Editor bearbeiten.

Eine besondere Batch-Datei ist diejenige, die in den Shell-Parametern unter
Batch-Datei  eingetragen  ist:  Sie  wird  automatisch  beim  Start  der  Shell
ausgefhrt. šblicherweise enth„lt diese Datei Anweisungen, um Module (auch
gelinkte Programme) zu laden und um vor allem die Suchpfade zu bestimmen,
damit berhaupt ein Arbeiten in der Shell m”glich ist.

Im  folgenden  wird  zun„chst  die  Syntax  der  Batch-Dateien  beschrieben  (in
Backus-Naur-Form, siehe Anhang A.6); anschlieend erl„utern wir die Funktion
der einzelnen Anweisungen:

Syntax der Batch-Dateien

anweisung  =    IF SHELLSTART anweisung <cr> |
                    _
                  WAIT text <cr> |
                  * text <cr> |

                  SETPATH pfad <cr> |
                  SETDRIVE laufwerk <cr> |
                  SETDIR pfad <cr> |

                  DELETETOOLS <cr> |
                  TOOL dateiname <cr> |

                  LOAD dateiname <cr> |
                  UNLOAD dateiname <cr> |

                  STACKSIZE cardinal <cr> |
                  EXEC dateiname  argument  <cr> |
                  IF EXITCODE integer anweisung <cr> |
                    _

                  DEFOUT   pfad   <cr> |
                  IMPOUT   pfad   <cr> |
                  MODOUT   pfad   <cr> |
                  MAINOUTPUTPATH   pfad   <cr> |

                  COMPILE dateiname <cr> |
                  MAKE   dateiname   <cr> |
2.2  Bedienung: Shell                                                     2 - 33
________________________________________________________


                  LINKSTACKSIZE cardinal <cr> |
                  NO OPTIMIZE <cr> |
                     _
                  PART OPTIMIZE <cr> |
                       _
                  FULL OPTIMIZE <cr> |
                       _
                  DRIVER   '+' | '-'   dateiname <cr> |
                  DELETEDRIVERS <cr> |
                  LINK dateiname <cr> |

                  DEFAULTPATH pfad-liste <cr> |
                  DEFPATH pfad-liste <cr> |
                  IMPPATH pfad-liste <cr> |
                  MODPATH pfad-liste <cr> |
                  SOURCEPATH pfad-liste <cr>  .

pfad-liste  =     <cr> Leerzeichen  Leerzeichen  pfad   .
pfad        =     laufwerk       ''         name | '..'   ''   .
dateiname  =   pfad name
name       =   prefix   '.' suffix              (einfacher Dateiname ohne Pfad )
laufwerk   =   Buchstabe ':'
prefix      =   Bis zu acht Buchstaben oder Ziffern
suffix      =   Bis zu drei Buchstaben oder Ziffern
argument  =   Ein Wort (Text, der nicht durch Leerzeichen unterbrochen ist)
text        =   Beliebiger Text
cardinal    =   Positive, ganze Zahl (0 bis 2^32-1)
integer     =   Ganze Zahl (-32767 bis 32768)

Die Anweisungen sowie alle Teile von Datei- und Pfadnamen drfen sowohl in
Gro- als auch Kleinbuchstaben geschrieben sein.

Um einen Batch sowohl fr die Erstinitialisierung fr die Shell als auch allge~
mein verwendbar zu machen, ist es teilweise notwendig, bestimmte Funktionen
darin  nur  beim  Start  der  Shell  durchzufhren.  Wird  die  Anweisung
IF SHELLSTART vor eine normale Anweisung gestellt, wird sie nur berck~
  _
sichtigt, wenn der Batch beim Starten der Shell automatisch ausgefhrt wird.

Mit WAIT wird der dahinter stehende Text in einer Alert-Box angezeigt und
erst bei Best„tigung des OK-Knopfs wird der Batch weiter abgearbeitet.

Teilweise  ist  es  wnschenswert,  bestimmte  Disk-Verzeichnisse  als  aktuelle
Pfade einzustellen. Jedes Laufwerk kann dabei ein eigenes aktuelles Verzeichnis
haben, zus„tzlich gibt es ein aktuelles Laufwerk; das aktuelle Laufwerk bestimmt
mit seinem aktuellem Verzeichnis (Dir) den aktuellen Pfad. SETDRIVE w„hlt
mit  einem  angefgten  Laufwerksbuchstaben  das  aktuelle  Laufwerk,  SETDIR
bestimmt, falls beim Pfadnamen  kein  Laufwerk  angegeben  ist,  das  aktuelle
Verzeichnis des aktuellen Laufwerks, sonst den Pfad des angegebenen Lauf~
werks - das aktuelle Laufwerk wird jedoch nicht gewechselt (so kann damit das
2.2  Bedienung: Shell                                                     2 - 34
________________________________________________________


Verzeichnis auf einem anderen Laufwerk bestimmt werden). SETPATH schlie~
lich setzt den aktuellen Pfad, also das aktuelle Laufwerk mitsamt dem Ver~
zeichnis.

War  das  zu  kompliziert?  Dann  andersrum:  Normalerweise  verwenden  Sie
SETPATH.  Damit  geben  Sie  Laufwerk  und  Verzeichnis  an,  die  dann  zum
aktuellen werden. Das hat die gleiche Funktion wie die Eingabe des aktuellen
Pfads in den Umgebungsinformationen.

Wollen Sie aber auch die Pfade der anderen Laufwerke festlegen, verwenden
Sie fr jedes Laufwerk SETDIR. Das w„re beispielsweise ntzlich, wenn Sie die
Disk-Fenster in der Shell mit Shift bzw. der Einstellung Erzeuge Fenster auf
aktuellem Pfad (s. Shell-Parameter) ”ffnen wollen - dann wird der mit SETDIR
fr das Laufwerk bestimmte Pfad  ge”ffnet.  Ebenso  wird  beim  GEM-Datei-
Selektor  ab  TOS  1.4  beim  Anklicken  eines  Laufwerks  dessen  aktuelles
Verzeichnis angezeigt.

Die Eintr„ge im Tools-Men k”nnen mit TOOL bestimmt werden. Bis zu zehn
Tools k”nnen eingetragen werden. Die Meneintr„ge werden nacheinander auf~
gefllt. Die dort aufgefhrten Programme k”nnen durch die Menanwahl oder
eine  Funktionstaste  bequem  ausgefhrt  werden.

Fr die Dateinamen bei TOOL gilt: Wird ein Pfad angegeben, wird beim Start
des Programms der Pfad zum aktuellen Pfad, ansonsten bleibt der in der Shell
gerade aktuelle Pfad erhalten.

Um alle Tools-Eintr„ge zu l”schen, dient die Anweisung DELETETOOLS.

Die LOAD-Anweisung veranlat die Shell, das angegebene Modul in den Spei~
cher zu laden, so, als ob es auf das Resident-Symbol gezogen wrde. Die
Module stehen dann zum direkten Aufruf oder auch zum Import  in  andere
Module  zur  Verfgung  und  mssen  nicht  wiederholt  von  Diskette  geladen
werden. Besonders  interessant  ist  die  M”glichkeit,  Editor  und  Compiler  zu
laden - der Aufruf ist anschlieend ohne Wartezeit m”glich. UNLOAD gibt ge~
ladene Module entsprechend wieder frei.

Mit EXEC kann ein Programm oder Modul gestartet werden. Wenn es endet,
wird hinter der EXEC-Anweisung in der Batch-Datei fortgefahren. Nach der
Rckkehr kann ber IF EXITCODE der Rckgabewert des Progamms geprft
                        _
werden.  Nur,  wenn  er  zutrifft,  wird  die  dahinter  stehende  Anweisung
ausgefhrt.  Dies  kann  zum  Beispiel  Verwendung  finden,  um  auf  abnorme
Abbruchbedingungen  eines  Programms  zu  reagieren:  Jedes  Programm  kann
beim Terminieren einen Integer-Wert zurckgeben. Bei Megamax-Programmen
kann dies ber die Prozedur TermProcess aus dem Modul PrgCtrl geschehen.
Jedes Programm das normal terminiert, liefert als Rckgabewert  (Exitcode)
Null. Nun k”nnten Sie ein Programm schreiben, das mit einem anderen Wert
2.2  Bedienung: Shell                                                     2 - 35
________________________________________________________


terminiert, um beispielsweise damit dem Aufrufer anzuzeigen, da ein anderes
Programm gestartet werden soll. Nehmen wir an, das Programm heit A und
wenn es den Wert Eins zurckgibt, soll B gestartet werden. Also ist ein Batch
zu schreiben, der die folgenden beiden Zeilen enth„lt:
      EXEC  A
      IF EXITCODE  1  B
        _
Wird dieser Batch gestartet, l„t er A ausfhren. Terminiert A, wird B nur
gestartet, wenn der Exitcode von A Eins ist.

STACKSIZE erlaubt die Einstellung der Stackgr”e, die gestarteten Programmen
zur  Verfgung  gestellt  wird.  Normalerweise  wird  die  Stack-Gr”e  in  den
Umgebungsinfomationen (s.o.) bestimmt, jedoch kann es notwendig sein, diesen
Wert vor dem Starten bestimmter Module mit dem EXEC-Befehl zu „ndern.

Ein Modula-Programm kann  mit  COMPILE  und  einem  angefgten  Quelltext-
(Source-) Namen bersetzt werden. Tritt dabei ein šbersetzungsfehler auf,
wird eine entsprechende Meldung angezeigt. Der Fehler kann dann wahlweise
ignoriert werden, so da der Batch bei der n„chsten Anweisung fortf„hrt oder
der Editor gestartet wird (dann ist die Batch-Abarbeitung abgebrochen  und
mu bei Bedarf erneut gestartet werden).

Mit  DEFOUT,   IMPOUT,   MODOUT   und   MAINOUTPUTPATH   k”nnen   die
Ausgabepfade des Compilers abweichend von der Standard-Einstellung (siehe
Kapitel  2.4,  Compiler)  bestimmt  werden.  Allerdings  werden  sie  nicht
automatisch am Ende des Batch-Laufs wieder auf ihre alten Werten gestellt.
DEFOUT, IMPOUT und MODOUT  k”nnen  nicht  rckg„ngig  gemacht  werden,
h”chstens   durch   Neudefinition   der   Suchlisten   (DEFPATH,   IMPPATH,
MODPATH). Dagegen kann MAINOUTPUTPATH  durch  eine  leere  Pfadangabe
wieder ungltig gemacht werden. Nach einem Compiler-Fehler mit Aufruf des
Editors (oder Abbruch des Batch-Laufs) wird diese Anweisung allerdings nicht
mehr ausgefhrt - dann mu ggf. die Einstellung des Ausgabe-Pfads in den
Compiler-Optionen (Parameter/Compiler) rckg„ngig gemacht werden.

Der Make-Vorgang kann durch die Anweisung MAKE gestartet werden. Wird
kein  Name  einer  Make-Datei  (Endung  M2M,  mit  Hilfsprogramm  ModRef
erstellt) angegeben, wird die Default-Make-Datei der Umgebungsinformationen
verwendet, ansonsten die angegebene.  Bei  einem  Fehler  in  der  Make-Datei
oder beim darauf folgenden šbersetzungsvorgang wird so verfahren, wie schon
oben bei der COMPILE-Anweisung beschrieben.

Um ein Programm im Batch zu binden, ist LINK zu verwenden. Der dahinter
anzugebende Modulname darf eine Pfadangabe enthalten. Ist dies der Fall, wird
die zu erzeugende gelinkte Programmdatei auf dem angegebenen Pfad erzeugt,
ansonsten dort, woher das angegebene Modul stammt. Der Optimierungsgrad,
die Stack-Gr”e, die das gelinkte Programm verwenden soll sowie die einzu~
bindenden Treiber-Module werden normalerweise in der Dialogbox des Linkers
2.2  Bedienung: Shell                                                     2 - 36
________________________________________________________


(Parameter/Linker) bestimmt (dazu mehr in Kapitel 2.6 ber den Linker). Diese
Eintragungen k”nnen aber optional auch vom Batch ver„ndert werden (natrlich
mssen sie vor dem betreffenden Linker-Aufruf abgearbeitet werden!):

LINKSTACKSIZE bestimmt mit der angegebenen Zahl die Stackgr”e fr das
zu linkende Programm; sie sollte mindestens 2000 (Bytes) betragen. Mit einer
der Anweisungen NO OPTIMIZE, PART OPTIMIZE oder FULL OPTIMIZE wird
                      _                  _                      _
keine, verkrzte bzw. vollst„ndige Optimierung des Programms erreicht. Nach
DRIVER  kann  ein  Treiber-  (Konfigurations-)  Modul  angegeben  werden.
Insgesamt  k”nnen  bis  zu  acht  solcher  Module  eingetragen  werden.  Dem
Modulnamen hinter  DRIVER  kann  ein  Plus-  oder  Minuszeichen  vorangestellt
werden  (ohne  Leerzeichen!),  je  nachdem  wird  es  als  selektiertes  oder
abgeschaltetes Modul eingetragen (nur selektierte Module werden beim Linken
als Treiber mit eingebunden) ist kein solches Zeichen vor dem Namen, wird
das Modul als selektiert bernommen. Ein bereits konfiguriertes Modul wird
nicht doppelt eingetragen, sondern die neue Definition berschreibt dann die
alte. Durch  die  Anweisung  DELETEDRIVERS  k”nnen  allerdings  alle  Treiber-
Eintragungen gel”scht werden.

Um die weiteren Eintr„ge der Batch-Datei zu erkl„ren, holen wir etwas weiter
aus - als Vorwarnung spendieren wir eine neue šberschrift:


Suchpfade und Pfadlisten

Zu guter Letzt k”nnen Sie in der Batch-Datei verschiedene Pfadlisten angeben -
also Listen von Directories, die beim Suchen verschiedener Dateitypen abge~
sucht werden sollen. Vier dieser Pfadlisten werden ausschlielich vom Modula-
System selbst (Compiler, Linker) benutzt:

DEFPATH       fr bersetzte Definitionsmodule:
                 Hier sucht der Compiler die Definitionsdateien (Endung DEF)
                 der importierten Module.
                 Im ersten angegebenen Pfad legt der Compiler neu erzeugte
                 (bersetzte) Definitionsdateien ab.

IMPPATH       fr bersetzte Implementationsmodule,
MODPATH      fr bersetzte Haupt- (Programm-) Module:
                 Auf  diesen  beiden  Pfadlisten  sucht  der  Linker  (nicht  der
                 Loader!)  nach  einzubindenden  Modul-Codes,  die  vom  zu
                 linkenden Programm importiert werden.
                 Im ersten angegebenen Pfad legt der Compiler neu erzeugte
                 (bersetzte) Implementations- bzw. Haupt-Modul-Codes ab.

SOURCEPATH  fr alle Quelltexte (Sourcen):
                 Hier suchen Compiler und Editor nach den Quelltexten, wenn
                 diese nicht auf dem angegebenen Pfad zu finden sind.
2.2  Bedienung: Shell                                                     2 - 37
________________________________________________________


Die Modula-Shell selbst (bzw. deren Loader) sucht alle Module, die ausgefhrt
werden sollen, in der DEFAULTPATH-Liste. Das gilt auch fr Module, die per
LOAD-Anweisung in der Batch-Datei geladen werden sollen. Eventuelle LOAD-
Anweisungen in der Batch-Datei, die beim Shell-Start automatisch ausgefhrt
wird,  sollten  also  hinter  der  dort  -  notwendigerweise  -  aufgefhrten
DEFAULTPATH-Definition stehen.

Auerdem steht die DEFAULTPATH-Liste Systemprogrammen, wie dem Make,
zur Verfgung: Die Variable StdPaths im Modul ShellMsg enth„lt eine kodierte
Form dieser Liste (vom Datentyp PathList). In der Dokumentation (Definitions~
modul) zum Modul Paths erfahren Sie, wie Sie durch einfachen Aufruf einer
Prozedur eine Datei in allen Verzeichnissen dieser (oder auch einer anderen)
Pfadliste suchen lassen k”nnen. Um auf einfache Weise anwenderfreundliche
Programme zu verwirklichen, ist die Benutzung dieser Suchfunktion vor dem
Zugriff  auf  Dateien  sehr  empfehlenswert.  Um  die  Pfadliste  fr  gelinkte
Programme, also auerhalb der Shell, anzulegen, gibt es das Modul InitPathList
im UTILITY-Ordner.

Vorsicht!
      Es ist unbedingt darauf  zu  achten,  da  nach  einer  Pfadlisten-
      Anweisung  die  in  den  folgenden  Zeilen  aufgefhrten  Pfade  alle
      mindestens  um  ein  Leerzeichen  eingerckt  sind  und  keine
      Leerzeilen bis zum Ende der Liste vorkommen!

Die Syntax der Pfadnamen wird weiter unten erkl„rt fr den Fall, da Sie mit
ihr noch nicht vertraut sind.

Wird ein Pfadname mit einem Sternchen (und einem darauf folgenden Ordner-
Trennstrich,  also  "*")  angefhrt,  wird  es  von  den  Systemprogrammen
(Compiler, Make, Shell usw.) durch den Pfad der Shell ersetzt (dieser steht im
Modul ShellMsg). Damit k”nnen die Pfade so angegeben werden, da die Shell
zusammen mit ihren Unterverzeichnissen problemlos in jeden beliebigen Ordner
(einer ausreichend groen Harddisk) kopiert werden kann und erstmal keine
Korrekturen an den Pfadlisten vorgenommen zu werden brauchen, um mit dem
System arbeiten zu k”nnen. Dies wurde brigens auch bei der Zusammen~
stellung des Megamax-Systems  auf  Ihren  erworbenen  Disketten  ausgenutzt
(siehe die Batch-Datei MM2SHELL.M2B).

Am  Ende  der  Pfadliste  kann  ein  Fragezeichen  als  Dateiname  eingetragen
werden.  Dies  bewirkt,  da  die  GEM-Dateiauswahl-Funktion  (File-Selektor)
aufgerufen wird, wenn eine gesuchte Datei nicht auf den vorigen Pfaden der
Liste gefunden werden kann.
2.2  Bedienung: Shell                                                     2 - 38
________________________________________________________


Der Aufbau einer Pfadangabe ist zwar nicht Megamax-spezifisch,  soll  aber
doch noch kurz erl„utert werden:

* Die Laufwerksangabe durch Laufwerksbuchstaben und Doppelpunkt ist optio~
nal; wenn sie fehlt, wird das gerade aktive Laufwerk benutzt.

* Der folgende Schr„gstrich gibt an, da vom Stamm-Inhaltsverzeichnis (auch
Wurzel- oder Root-Directory) des Laufwerks ausgegangen wird. Fehlt er, dann
beginnt der Pfad im gerade aktiven Verzeichnis, das sich der Atari zu jedem
Laufwerk einzeln merkt.

*  Beginnen  Sie  im  aktiven  Verzeichnis,  so  k”nnen  Sie  zun„chst  ins
bergeordnete Verzeichnis heraufsteigen, indem Sie '..' folgen lassen.

* Nachdem nun der Ausgangspunkt des Pfades definiert ist, k”nnen Sie sich
von dort beliebig tief in Ordner (Subdirectories) 'hineinwhlen'. Die Ordnerna~
men werden in der Reihenfolge angegeben, in der Sie immer tiefer in sie 'hin~
eintauchen'. Zur Trennung der Namen dient wieder der Schr„gstrich.

* Am Ende eines Pfadnamens sollte immer ein Schr„gstrich stehen (ggf. fgt
die Shell beim Einlesen des Pfades selbst einen an).

Um die Verwirrung etwas zu lindern, hier ein Beispiel. Betrachten wir folgende
Directory-Struktur:

      Disk A:             <Wurzel>
                             5 8
                  MODULA      ZAEH
                     5 8
              SHELL     LIBRARY
                           5 8
                       IMP      DEF

Angenommen, Sie wollen einen Pfad ins 'DEF'-Verzeichnis konstruieren (etwa
fr die DEFPATH-Liste in der Batch-Datei). Die ausfhrlichste Angabe w„re
"A:MODULALIBRARYDEF".  Das  funktioniert  natrlich  nur,  solange  die
Diskette in Laufwerk A bleibt... Aber  Sie  wissen  ja,  da  gerade  die  Shell
gestartet worden ist - also wird sicher das richtige Laufwerk gerade aktiv
sein. Daher gengt die Angabe "MODULALIBRARYDEF".

Beide  oben  genannten  Pfade  beginnen  im  Wurzelverzeichnis.  Wenn  der
MODULA-Ordner in einen anderen Ordner hineinkopiert wird (oder wenn Sie
LIBRARY und SHELL  direkt  ins  Wurzelverzeichnis  legen),  schicken  Sie  den
Rechner auf den Holzweg. Noch flexibler ist es daher, den Pfad relativ zum
aktiven  Verzeichnis  (SHELL,  nehmen  wir  an)  anzugeben!  ..LIBRARYDEF
tut's,  solange  der  LIBRARY-Ordner  neben  dem  SHELL-Ordner  in  einem
bergeordneten Verzeichnis steht.
2.2  Bedienung: Shell                                                     2 - 39
________________________________________________________


Umgang mit mehreren Projekten

Unter einem Projekt bei Megamax Modula-2 verstehen wir die Arbeit an einem
Programmpaket, das mehrere Module umfat und das seine eigene, individuelle
Umgebung hat.

Ein Beispiel: Nehmen wir an, Sie arbeiten abwechselnd an zwei Programmen,
das eine sei ein kleines Terminal-Programm (zur Daten-Kommunikation ber
Telefon), das andere ein Grafikprogramm zur Darstellung von physikalischen
Vorg„ngen. Nun bietet es sich an, die jeweils projekt-spezifischen Dateien in
getrennten Ordner zu sammeln. Denken wir uns, Sie h„tten zwei Ordner auf
Ihrer  Harddisk  (ja,  sowas  braucht  man  heutzutage),  je  einen  fr  jedes
Programmpaket,  in  denen  die  jeweiligen  Quelltext-Dateien  abgelegt  werden
sollen.

Da die beiden Programme vielleicht auch verschiedene Optionen (Stack-Gr”e,
Treiber-Module usw.) ben”tigen, sollten Sie sich dafr je eine Projekt-Datei
anlegen. Diese Projekt-Dateien sind praktisch die Parameter-Dateien mit den
Endungen M2P.  Wenn  Sie  alles  richtig  installiert  haben,  k”nnen  Sie  durch
einfache Aktionen zwischen Ihren beiden Projekten hin- und herwechseln und
finden bei beiden die individuellen Einstellungen und Arbeitsdateien vor.

Kommen wir also zum Erstellen einer Projekt-Datei. Zuerst erstellen Sie eine
Batch-Datei, die die gewnschten Suchpfade enth„lt. Nehmen Sie am besten
Ihre Standard-Batch-Datei MM2SHELL.M2B und ver„ndern Sie die Pfadlisten
darin, so da die zus„tzlichen Ordner fr das jeweilige Projekt bercksichtigt
werden. Am besten ist es, diese Pfade immer als erstes in die Listen  zu
schreiben,  damit  sie  Vorrang  vor  den  restlichen  haben.  Speichern  Sie  die
Batch-Datei dann unter einem anderen Namen wieder ab.

Daraufhin  tragen  Sie  den  Namen  hinter  der  Batch-Datei  in  den  Shell-
Parametern ein. Dann vergeben Sie auch einen neuen Namen fr die dortige
Parameter-Datei. Nun k”nnen Sie Ihr Disk-Verzeichnis des  Projekt-Ordners
”ffnen, die verwendeten Quelltexte als Arbeitsdateien eintragen und sonstige
Parameter einstellen, beispielsweise die  Stack-Gr”e  oder,  wenn  das  feste
Linken  des  Programms  ”fter  ben”tigt  wird,  auch  die  Linker-Optionen
(verwendete Konfigurationsmodule usw.).

Sehr ntzlich ist auch das Erzeugen einer Make-Datei zum Hauptmodul des
Projekts  (siehe  Kapitel  2.7  zum  Erstellen  einer  Make-Datei),  die  dann  als
Default-Make in den Umgebungsinformationen eingetragen wird.

Sind alle Einstellungen vorgenommen, kann durch Drcken von Control-X, der
Anwahl des Menpunkts Parameter sichern oder einfach durch Verlassen der
Shell mit Parameter-Sicherung  die  vorher  als  Parameter-Datei  eingegebene
Projekt-Datei  gespeichert  werden.  Wenn  Sie  dann  die  Shell  neu  aufrufen,
2.2  Bedienung: Shell                                                     2 - 40
________________________________________________________


wird  erstmal  wieder  die  Standard-Einstellung  aus  der  Parameter-Datei
MM2SHELL.M2P  vorgenommen.  Sie  k”nnen  nun  aber  jederzeit  die  neu
angelegte Projekt-Datei ausfhren, um deren Einstellungen wieder hervorzu~
holen, z.B. indem Sie die Projekt-Datei im Disk-Inhaltsverzeichnis suchen und
durch Doppelklick oder durch Ziehen auf das Ausfhren-Symbol aktivieren. Ein
anderer,  sehr  bequemer  Weg  ist,  die  oft  verwendeten  Projekt-Dateien  als
Tools in der Standard-Batch-Datei einzutragen.

Sie k”nnen sogar schon beim Start der Shell dafr sorgen, da statt  der
Standard-Parameter-Datei MM2SHELL.M2P eine andere verwendet wird: Dazu
mssen Sie die Shell unter dem GEM-Desktop fr Dateien der Endung M2P
anmelden. Dann gengt ein Doppelklick auf die Projekt-Datei, um die Shell zu
starten und das Projekt sofort vor sich  zu  haben.  Um  dies  zu  erreichen,
klicken  Sie  im  GEM-Desktop  die  Shell  MM2SHELL.PRG  einfach  (also  nicht
starten!) an. Dann w„hlen Sie in der Menzeile Extras/Anwendung anmelden.
Dort  geben  Sie  dann  als  geforderte  Endung  "M2P"  ein  und  klicken  auf
installieren. Zuletzt w„hlen Sie Arbeit sichern an. Daraufhin k”nnen Sie nun
auf jede M2P-Datei doppelt klicken, um die Shell damit zu starten. (Bei „lteren
TOS-Versionen mssen Sie aber darauf achten, da sich die Projekt-Dateien
im  Verzeichnis  der  Shell  befinden,  da  diese  sonst  nicht  gefunden  wird.
Probieren Sie dies ggf. aus.)
2.2  Bedienung: Shell                                                     2 - 41
________________________________________________________


Fehlermeldungen der Shell

Beim Programmieren kann erfahrungsgem„ einiges schiefgehen. Im Megamax
Modula-System gibt es vier Kategorien von Fehlermeldungen, die  in  solchen
F„llen erscheinen k”nnen.

* Ladefehler k”nnen auftreten, wenn ein Modul ausgefhrt werden soll und nicht
alle ben”tigten Module zur Verfgung stehen. Die  Fehlermeldungen  beginnen
mit '<Modulname> konnte nicht ausgefhrt werden', gefolgt von einer Beschreibung
des Problems. Diese Meldungen werden vom  Loader  erzeugt;  Erl„uterungen
finden Sie im Kapitel 5.

* Laufzeitfehler treten bei der Ausfhrung fehlerhafter Anwenderprogramme
auf. Die Fehlerbeschreibung, der Modul- und der Prozedurname werden ange~
zeigt. Sie k”nnen sich entscheiden zwischen

    Back/Forward:
    erlauben die Suche nach der Fehlerposition im Text (siehe 2.5);
    Exit
    verl„t die Fehlersuche und bietet drei weitere M”glichkeiten:

    Cont
    setzt das Programm fort. Bei manchen fatalen Fehlern ist eine sinnvolle
    Fortsetzung nicht m”glich, und diese Option wird nicht angeboten.
    Quit
    bricht das Programm ab und kehrt zurck zur Shell.
    Edit
    l„t die durch Forward/Back bestimmte Fehlerstelle suchen und im Editor
    anzeigen, sofern der Quelltext des Moduls vorhanden ist. (siehe 2.5)

Eine kommentierte Liste der Fehlermeldungen steht im Anhang A.2.

*  šbersetzungsfehler  entstehen  natrlich  beim  Compilieren.  Eine  Liste  der
Fehlermeldungen  enth„lt  der  Anhang  A.1;  wie  Sie  auf  šbersetzungsfehler
reagieren k”nnen, beschreibt Kapitel 2.4.

* Bedienungsfehler in der Shell. So kommen Meldungen, wenn Sie mehr als
sieben  Fenster  ”ffnen,  mehr  als  zehn  Arbeitsdateien  anfordern,  mehr
Programme laden wollen, als freier Speicher zur Verfgung steht, usw. Die
Meldungen sind alle selbsterkl„rend.
2.2  Bedienung: Shell                                                     2 - 42
________________________________________________________





















                               Diese Seite wurde blank geputzt.
2.3  Bedienung: Editor                                                    2 - 43
________________________________________________________


2.3   Editor


Einfhrung

Als Teil des Megamax Modula-Systems haben Sie auch einen eigenen Editor
erhalten (genau genommen sogar zwei!). Er dient zur Eingabe (und Korrektur)
der  Programmtexte.  Die  Texte  werden  als  Standard-ASCII-Dateien  (direkt
lesbare Textdateien) abgelegt und dem Compiler bergeben.

Der Editor ist speziell zum Schreiben von Programmtexten konzipiert worden.
Ihre  Briefe  werden  Sie  vielleicht  auch  weiterhin  mit  einer  speziellen
Textverarbeitung  schreiben  wollen;  zum  Programmieren  bietet  Ihnen  der
Megamax-  Editor  aber  eine  Reihe  ntzlicher  Sonderfunktionen  bei  ber~
sichtlicher Bedienung.


Wahl des Editors

Prinzipiell k”nnen Sie jeden Editor verwenden, der normale Textdateien erzeugt
- die optimale Zusammenarbeit mit Shell und Compiler des Modula-Systems
erlauben allerdings nur die beiden mitgelieferten Editoren. (Die Zusammenarbeit
der Programme wird durch die Shell organisiert. Da Sie diese im Quelltext
erhalten, k”nnen Sie auch eine Anpassung fr Ihren Lieblingseditor vornehmen,
wenn Sie sich nicht umstellen m”chten - die wichtigste nderung drfte die
šbergabe der Fehlerposition und -meldung betreffen.)

Unser Standard-Editor heit GME. Unter anderem erlaubt er, mehrere Texte
im  Speicher  zu  bearbeiten,  bietet  jedoch  bisher  noch  keine  echten  GEM-
Fenster,  statt  dessen  werden  die  Texte  auf  Befehl  abwechselnd  auf  dem
Bildschirm angezeigt. Die Bedienung ist dem Konzept des legend„ren Editors
Word-Star nachempfunden. Der GME ist einfach zu bedienen, vor allem wegen
seiner GEM-Menleiste, deswegen empfehlen wir den Programmier-Einsteigern
diesen Editor zur Benutzung.

Alternativ bieten wir einen kompakteren und schnelleren Editor, der allerdings
mehr Eingew”hnung verlangt: Der Gepard-Editor (GEP ED). Auch er arbeitet
                                                         _
optimal  mit  dem  Entwicklungssystem  zusammen.  Er  ist,  wie  der  GME,  in
Modula geschrieben, hat jedoch einige deutliche  Optimerungen  in  Assembler
erfahren. Er belegt nur ca. 50KByte (GME: 150) des Speichers in der Shell
und ist deshalb bei knappem Speicher dem GME vorzuziehen.
2.3  Bedienung: Editor                                                    2 - 44
________________________________________________________


Der GME wurde aus einem Universaleditor  entwickelt,  der  auch  zur  Text~
verarbeitung geeignet war. Demgegenber ist der Gepard-Editor speziell auf
das Programmentwickeln zugeschnitten und bietet keine GEM-Oberfl„che - fr
die  Veteranen:  Sein  Konzept  ist  dem  des  UCSD-Programmeditors  nach~
empfunden, nur ist er wesentlich schneller. Der Editor ist gew”hnungsbedrftig,
aber  unglaublich  effektiv  fr  Vielprogrammierer  -  wir  Megamax-Entwickler
verwenden ihn alle!

Beide Editoren erlauben es, den Programmtext im  Speicher  zu  bersetzen,
ohne da der Text abgespeichert und der Editor verlassen zu werden braucht.
Dies verkrzt die Turn-Around-Zeit (Zeit zwischen Editieren, šbersetzen und
Starten) deutlich.

Auch Tempus (von CCD) l„t sich sehr bequem als Editor verwenden. Einzig
die Fehleranzeige vom Compiler beherrscht er nicht - die Shell sieht aber eine
Option vor, so da Compilerfehler  vor  dem  Editor-Start  angezeigt  werden.
Nach einer Best„tigung mit der Return-Taste wird der Editor gestartet und er
zeigt dann die Fehlerposition im geladenen Text an.

Bei Tempus k”nnen Sie ein Programm zwar nicht im Speicher direkt berset~
zen lassen, aber der Komfort kommt auch hier nicht zu kurz: Drcken Sie
Control-1 (Sie mssen die Eins vom rechten Ziffernblock verwenden!), wird der
Text automatisch gespeichert, Tempus verlassen und automatisch der Compiler
gestartet, der dann den Programmtext bersetzt, den Sie von der Shell an den
Editor beim Aufruf bergeben hatten (und das ist in der Regel auch der, den
Sie dann mit Control-1 zum šbersetzen abspeichern lassen). Control-2 teilt
der Shell mit, da sie nach erfolgreicher šbersetzung dieses Modul starten
soll,  Control-3  bewirkt  nicht  das  šbersetzen  des  geladenen  Programms,
sondern aktiviert das Default-Make, das in der Shell auch ber die Taste M
ausl”sbar ist. Schlielich l„t Control-4 nach dem - erfolgreichen - Make-Lauf
das Programm wiederum gleich starten.

Leider lassen sich die Versionen 2.00 bis 2.04 von Tempus nicht resident in
der Shell laden: Beim wiederholten Start in der Shell wrde er nicht mehr
funktionieren. Wenden Sie sich in diesem Falle ggf. an CCD, um eine neuere,
korrigierte Version zu erhalten. Alle anderen Versionen lassen sich resident
laden, aber ben”tigen sehr (wirklich sehr) viel mehr Speicher als die Programm~
datei lang ist. Auch hier sollten Sie sich nicht verwirren lassen - das mu so
sein!
2.3  Bedienung: Editor                                                    2 - 45
________________________________________________________


Vorbereitungen und Parameter fr den Editor

Bevor der Editor Ihres Ver~
trauens von der Shell richtig
aufgerufen   werden   kann,
mu    zumindest    dessen
Dateiname bekannt  gemacht
werden.      Unter      dem
Menpunkt Parameter/Editor
sind  alle  Optionen  fr  den
Editor erreichbar. Hier kann
hinter Editor:  dessen  Name
eingetragen werden. Soll der
GME verwendet werden, kann dieser Name, wie im Bild zu sehen, verwendet
werden. Fr den  Gepard-Editor  ist  GEP ED  einzutragen,  bei  allen  anderen
                                            _
Editoren ist ihr vollst„ndiger Dateiname inclusive seiner Endung zu verwenden
(Tempus: TEMPUS.PRG). Bei Editoren, die andere Dateien nachladen mssen,
wie eine RSC-Datei oder Konfigurationen, mu auerdem deren Pfadname mit
angegeben werden. Haben Sie beispielsweise einen Editor namens EDIT.PRG,
der im Ordner C:TEXTE mitsamt seiner Resource-Datei EDIT.RSC steht, ist
C:TEXTEEDIT.PRG einzutragen.

Die mitgelieferten Editoren k”nnen, da sie mit dem Megamax-Modula-System
erstellt  wurden,  auf  die  Pfadlisten  in  ShellMsg  zugreifen,  speziell  auf  die
Suchpfade fr die Quelltexte (ber SourcePath in Batch zu bestimmen). So
brauchen  Sie  beim  Laden  eines  Textes  diesen  nicht  erst  in  den  vielen
Verzeichnissen zu suchen, statt dessen sucht der Editor die Datei selbst„ndig
auf den Source-Pfaden. Wird ein anderer Editor verwendet, kann die Shell das
bernehmen, wenn sie beim Editor-Aufruf den Dateinamen bergibt. Dazu mu
nur die Option Shell durchsucht Source-Pfade fr den Editor aktiviert sein.
Dann reicht es beispielsweise, in der Shell mit Control-P den Namen eines
Textes ohne dessen Pfad einzutippen und dann den Editor mit Control-E zu
starten.

Wenn Editoren es nicht verm”gen, eine Fehlermeldung beim Aufruf bergeben
zu bekommen, um sie dann anzuzeigen, mu die Shell dies erledigen. Dazu
dient der Schalter Shell zeigt Compiler-Fehler vor Editor-Aufruf an.  Ist  er
eingeschaltet, zeigt die Shell nach einem Compiler-Fehler diesen an, und erst
nach Drcken der Return-Taste wird der Editor gestartet. Vertr„gt der Editor
die  Fehlermeldung  nicht  (z.B.  TEMPUS),  mu  auerdem  weiter  unten  bei
Argumentzeile der Schalter Fehlermeldung deaktiviert sein.

Die Tempor„ren Dateien dienen zur šbergabe von Informationen an den Editor
und zurck an die Shell. Der einzige uns bekannte Editor, der diese Art der
Parameterbergabe untersttzt ist der Emacs-Editor. Der ist programmierbar,
und so hat ein Megamax-Anwender ein Programm erstellt, das es erlaubt, von
der  Shell  Textname,  Fehlermeldung  und  -position  anzunehmen  und  beim
2.3  Bedienung: Editor                                                    2 - 46
________________________________________________________


Verlassen die Shell wiederum zum Compiler-Start zu veranlassen, wie dies
auch bei den von den beiden Megamax-Editoren m”glich ist. Sind Sie an dieser
EMACS-Einbindung interessiert, wenden Sie sich an Application Systems.

In  der  Argumentzeile  an  den  Editor  k”nnen  Textname,  Fehlermeldung  und
-position  vom  Compiler  bzw.  von  der  Shell  beim  Aufruf  an  den  Editor
bergeben werden. Die Megamax-Editoren erlauben alle šbergaben. TEMPUS
beispielsweise  erlaubt  die  Angabe  der  Cursorposition,  jedoch  nicht  die  der
Meldung, soda diese dann zu deaktivieren w„re.

Wollen Sie einen Editor verwenden, der noch andere  Bedingungen  an  seine
Benutzung stellt, z.B. da bei der Fehlerposition die Werte fr Spalte und Zeile
zu vertauschen w„ren, k”nnen Sie dies selbst an der Shell-Source vornehmen:
Der Editor-Aufruf wird in der Funktion hdedit vorbereitet. Die Fehlermeldung
vom Compiler wird bei einem der Aufrufe von hdedit aufbereitet. Nach der
Anpassung mu die Shell neu bersetzt und dann gelinkt werden. Zum Linken
bietet  sich  der  Batch  LINKSHEL.M2B  an,  der  dazu  alle  erforderlichen
Parameter einstellt.


Aufruf des Editors

Den Editor k”nnen Sie auf drei Wegen starten:

    * Aus der Shell: Klicken Sie das Editor-Symbol auf der Ar~
    beitsfl„che an (Editieren der Arbeitsdatei)  oder  legen  Sie
    einen Dateinamen auf dem Editor-Symbol ab. Wollen Sie ein
    neues Dokument beginnen, so geben Sie zun„chst einen leeren Namen an.

    * Nach šbersetzungsfehlern: Je nach Wahl der Editor-Optionen ruft die
    Shell den Editor sofort auf oder bietet Ihnen erst den Aufruf des Editors
    an. Wenn Sie dann diese Option w„hlen, wird automatisch der fehlerhafte
    Text geladen, der Cursor wird an der Fehlerstelle positioniert, und in der
    Kopfzeile des Editors erscheint eine Fehlerbeschreibung.

    * Nach Laufzeit-Fehlern: Wenn Ihnen der Text des fehler~
    haften Programms zur Verfgung steht, k”nnen Sie  nach
    Laufzeitfehlern die Scanner-Funktion w„hlen. Der Compiler
    ermittelt die Textposition,  an  der  der  Fehler  auftrat,  und  zeigt  Ihnen,
    genau wie bei šbersetzungsfehlern, die Fehlerstelle mit Beschreibung im
    Editor.


Bedienung des Editors

Die Bedienung der beiden Editoren wird in separaten Anleitungen beschrieben,
die Sie im Anhang finden.
2.4  Bedienung: Compiler                                                 2 - 47
________________________________________________________


2.4    Compiler

Hier erl„utern wir die eigentliche Handhabung des Modula-Compilers. Wenn Sie
sich ber den bersetzten Sprachumfang oder die Compiler-Optionen in Quell~
texten informieren wollen, lesen Sie bitte Kapitel 3 dieses Handbuchs.


Aufruf des Compilers

Der Compiler wird aus der Shell gestartet, indem Sie
* eine Textdatei aus einem Disk-Fenster mit der Maus greifen
  und auf das Compiler-Symbol schieben;
* das Compiler-Symbol doppelt anklicken, um die Arbeitsdatei zu bersetzen;
* die Taste C drcken, um die Arbeitsdatei zu bersetzen (o. Ctrl-C fr die
  aktuelle Datei).

Der Pfad der Quelldatei mu nicht angegeben werden - der Compiler sucht die
Datei automatisch auf den Source-Pfaden (SourcePath in der Batch-Datei).

Falls die angegebene Textdatei vom Compiler nicht gelesen werden kann, fragt
der Compiler Sie nochmals nach einem Datei-Namen. Durch eine Leereingabe
k”nnen Sie den Compiler dann auch wieder verlassen. Wenn der Text gefunden
wird, beginnt der Compiler die šbersetzung.

Die  Endungen  (Suffix,  Extension)  der  Quelldatei-Namen  sind  beliebig.  Bei
Megamax Modula verwenden wir in der Regel
  .M  fr Haupt-Modul-Quellen (Bsp: MSHELL.M, TEXTDEMO.M),
  .I   fr Implementationsmodul-Quellen (Bsp: DEBUG.I, MOSCONFI.I),
  .D  fr Definitionsmodul-Quellen (Bsp: INOUT.D, DEBUG.D).

Ben”tigte Definitionsmodule  werden  automatisch  gesucht.  Als  Name  werden
dabei die ersten 8 Zeichen des Modulnamens (also nicht des Dateinamens!),
gefolgt von der Extension .DEF, angenommen. Diese Dateien werden auf allen
Pfaden  gesucht,  die  Sie  in  der  Batch-Datei  als  DefPath  angegeben  haben
(siehe Kapitel 2.2 - Shell).
2.4  Bedienung: Compiler                                                 2 - 48
________________________________________________________


Die erzeugten Dateien

Den  Namen  der  erzeugten  Code-Datei  bestimmt  der  Compiler  ebenfalls
automatisch. Wieder werden die ersten 8 Zeichen des Modulnamens verwendet;
die Extension lautet

  .MOD  fr Programm-Modul-Codes,
  .DEF   fr Definitions-Codes und
  .IMP   fr Implementations-Codes.

Andere  Endungen  k”nnen  Sie  ber  die  Compileroption  $E  einstellen  (siehe
Kapitel 3.3, Compileroptionen), z.B. MOS oder MTP („quivalent zu TOS und
TTP bei gelinkten Programmen, w„hrend MOD wie PRG behandelt wird).

Die Standard-Endungen k”nnen Sie aber auch ver„ndern - n„heres dazu in
Kapitel 5.

Der  Ausgabepfad  fr  das  bersetzte  Modul  wird  normalerweise  ber  die
Suchpfade bestimmt, die in der Batch-Datei stehen, welche beim Start der
Shell ausgefhrt wird: Der Compiler w„hlt jeweils den ersten Pfad aus der
Pfadliste fr Definitions-, Implementations- oder Programm-Module. šber die
Batch-Anweisungen  DEFOUT,  IMPOUT  und  MODOUT  k”nnen  aber  auch
individuelle  Ausgabepfade  eingestellt  werden  -  sind  dahinter  keine  Pfade
angegeben, wird die Code-Datei in das Verzeichnis geschrieben, aus dem die
jeweilige Quell-Datei stammt.

Ist allerdings ein Pfad ber die Batch-Anweisung MainOutputPath oder ber die
Compiler-Parameter  in  der  Shell  (siehe  folgenden  Abschnitt  Compiler-
Parameter)  eingegeben,  hat  dieser  Vorrang  vor  allen   anderen   Pfad-
Bestimmungen!


šbersetzungsfehler

Findet der Compiler in dem bersetzten Programmtext einen Fehler, bricht er
den šbersetzungsvorgang ab und meldet dies der Shell, die dann entweder den
Editor  sofort  aufruft  oder  erst  ein  Fenster  ”ffnet,  in  dem  sie  Ihnen  die
Fehlermeldung  pr„sentiert  und  Sie  vor  die  Wahl  stellt,  die  Fehlerstelle  im
Editor zu korrigieren oder die šbersetzung ganz abzubrechen.

Um als Fehlermeldung eine Beschreibung des Problems ausgeben zu k”nnen,
ben”tigt der Compiler die Fehlerdatei. Sie heit normalerweise 'MODULA.ERR'
Fehlt diese Datei, dann wird nur eine Fehlernummer angezeigt, deren Bedeu~
tung Sie im Anhang A.1 des Handbuchs nachschlagen k”nnen. Dort finden Sie
zu vielen Fehlermeldungen auch zus„tzliche Hinweise, die bei der Behebung des
Fehlers helfen k”nnen.
2.4  Bedienung: Compiler                                                 2 - 49
________________________________________________________


Compiler-Parameter

šber die Anwahl Parameter/
Compiler im Men der Shell
k”nnen Sie die globalen Op~
tionen  des  Compilers  ein~
stellen.

Ist  Ausgabe  der  Kurzmel~
dungen  mit  einem  H„kchen
versehen, werden die Namen
der importierten Module, der
bersetzten Prozeduren und
die  Anzahl  der  bersetzten
Zeilen ausgegeben. Die gleiche Funktion kann  in  Programmtexten  durch  die
Compileroption $Q gesteuert werden (siehe 3.3, Compilerdirektiven; dort finden
Sie auch Tips zur Anwendung dieser Option).

Ausgabepfad:  Soll  ein  bersetztes  Modul  nicht  auf  dem  Pfad  gespeichert
werden,  der  in  der  Start-Batch-Datei  fr  die  entsprechende  Modulart
angegeben ist, kann hier ein anderer Pfad eingetragen werden, der dann auf
alle erzeugten Modularten wirkt. Dieser Pfad kann auch mit dem Batch-Befehl
MAINOUTPUTPATH bestimmt werden. Siehe auch Kapitel 2.2 zu den Batch-
Anweisungen.

Die Direktiven erlauben die Beeinflussung des Verhaltens des Compilers beim
šbersetzen. Beispielsweise k”nnen Sie bestimmen, ob zus„tzlicher Code fr
Laufzeitprfungen erzeugt werden soll. N„heres zur Funktion den Direktiven in
Kapitel 3.4. Statt die Direktiven in den Quelltext einzufgen, k”nnen sie hier in
der Eingabezeile voreingestellt werden. Jeder Direktiven-Buchstabe mu dabei
mit  einem  Plus-  bzw.  Minuszeichen  eingeleitet  werden,  mehrere  Direktiven
werden  durch  Leerzeichen  getrennt.  Im  Bild  sehen  Sie  beispielsweise  die
Direktiven $Z+ und $R-.

In der Library MM2DEF.M2L sind (fast) alle bersetzten Definitionsdateien der
Megamax-Bibliotheken  zusammengefat.  Dies  spart  Platz  auf  der  Disk  und
beschleunigt den šbersetzungsvorgang. Normalerweise sollte deshalb der Name
der  Datei  (mit  Pfad)  unter  Bibliothek  eingetragen  sein.  Ist  eine  Bibliothek
angegeben, haben die darin enthaltenen DEF-Dateien immer Vorrang vor den
separaten Definitions-Modulen in den Ordnern, die in der Pfadliste DefPath im
Batch angegeben werden k”nnen! Unter Umst„nden kann dies nicht erwnscht
sein - dann braucht einfach nur der Bibliotheksname gel”scht zu werden. Zur
Kontrolle, woher ein Definitionsmodul beim šbersetzen geladen wird, kann die
Anzeige der Kurzinformationen aktiviert werden.

Die Textdatei mit den Fehlermeldungen fr den Compiler wird in Fehlerdatei
eingetragen, ggf. mitsamt dem Pfad.
2.4  Bedienung: Compiler                                                 2 - 50
________________________________________________________


Protokoll: Auf Wunsch erzeugt der Compiler  ein  šbersetzungsprotokoll.  Die
Ausgabebreite  (Anzahl  Spalten)  und  der  Name  der  Protokolldatei  (mit
Pfadangabe) k”nnen eingestellt werden. Der Inhalt der Protokolldatei wird in
einem speziellen Abschnitt auf einer der folgenden Seiten beschrieben.


Definitions-Codes: Bibliothek und Komprimierung

Die  bersetzten  Definitionsmodule  werden  vom  Compiler  praktisch  immer
ben”tigt,  darber  hinaus  st”ren  sie  nur,  weil  sie  sonst  in  keiner  Weise
Verwendung finden.

Deshalb haben wir es erm”glicht, da die Definitions-Codes alle in einer Datei
zusammengefat werden k”nnen. Damit ist das Weiterkopieren einfacher, es
werden nicht unz„hlige Verzeichnis-Eintr„ge auf der Disk verschwendet, und
der Compiler kann sogar schneller darauf zugreifen.

Diese Datei, in der die Definitions-Codes zusammengefat sind, nennen  wir
Bibliotheks-Datei oder auch Library (das ist engl. und heit in etwa das selbe).
Das Lesen der einzelnen Definitionen aus der Library ist fr den Compiler sehr
einfach.  Demgegenber  ist  es  aber  aufwendig,  st„ndig  neue  Dateien  darin
einzufgen  oder  auszutauschen.  Darum  bietet  es  sich  an,  nur  solche
Definitionen in die Library einzufgen, die keines st„ndigen Erneuerns bedrfen.
Die trifft vor allem auf die beim Megamax-System mitgelieferten MOS-Module
zu - die „ndern h”chstens wir, und das k”nnen wir dann gerade noch selbst
bew„ltigen.  Sie  selbst  k”nnen  also  auch  Definitions-Codes  hinzufgen,  nur
sollten Sie sich dieses Aspekts bewut sein - wird die Definition ver„ndert,
mu sie in der verwendeten Library aktualisiert werden, denn der Compiler
kann neu bersetzte Definitionen nicht automatisch in der Library ablegen, und
die Library hat immer  Vorrang  vor  den  Definitions-Codes  in  den  normalen
Verzeichnissen.

Die Definitions-Codes in die Library-Datei einzufgen, hat also zwei Vorteile:
Erstens sind sie darin hbsch  und  unauff„llig  verpackt,  zweitens  kann  der
Compiler schneller darauf zugreifen, als dies bei den Einzeldateien m”glich ist.
Natrlich mssen Sie nicht alle Ihre Definitions-Codes in die Library quetschen,
denn der Compiler kann  sie  selbstverst„ndlich  auch  finden,  wenn  sie  ganz
normal  einzeln  in  den  Verzeichnissen  vorliegen:  Der  Compiler  sucht  beim
Importieren  zuerst  in  der  Library,  dann  in  der  DefPaths-Liste,  welche  im
Batch (meist MM2SHELL.M2B) bestimmt werden kann.

Mit dem Utility-Programm LibManager (ggf. erst bersetzen!) k”nnen Sie die
Library  bearbeiten.  Sie  k”nnen  sich  deren  Inhalt  ansehen  sowie  Dateien
einfgen, herauskopieren oder l”schen. Das Programm  ist  mengefhrt  und
daher (hoffentlich) selbsterkl„rend.
2.4  Bedienung: Compiler                                                 2 - 51
________________________________________________________


Eine weitere Optimierung besteht darin, die Definitionen zu komprimieren. Die
Codes in der mitgelieferten Library  MM2DEF.M2L  sind  bereits  komprimiert.
Dadurch ergibt sich eine Platzersparnis von ca. 55%. Der Compiler erkennt
beim Importieren automatisch, ob die Definitions-Codes komprimiert sind, und
expandiert sie dann selbstst„ndig.

Jeder Definitions-Code kann komprimiert werden - der Compiler macht keinen
Unterschied, ob die Datei in der Library oder als Einzeldatei vorliegt.

Allerdings  hat  die  Kodierung  auch  einen  Nachteil:  Durch  das  notwendige
Expandieren dauert die Bearbeitung solcher Importe l„nger. Sind Sie stolzer
Besitzer  einer  Hard-Disk,  sollten  Sie  daher  die  Dateien  der  Library  alle
dekomprimieren, damit der Compiler damit keine unn”tige Zeit mehr verbringen
mu.


Dekomprimieren der Dateien in der Library

Mit den Programmen Encode und Decode (UTILITY-Ordner) k”nnen die Dateien
(eigentlich jede beliebige Datei) gepackt und wieder entpackt  werden.  Beide
Programme sind sehr einfach anzuwenden: Beim Start wird nach einer Datei~
angabe gefragt. Geben Sie dann entweder die einzelne Datei  an  oder  ver~
wenden Sie Wildcards (z.B. D:MM2DEF*.*), um mehrere Dateien in einem
Verzeichnis auf einmal anzusprechen. Wundern Sie sich nicht, da das Kompri~
mieren relativ lange dauert - wir haben bisher  nur  die  Dekomprimierungs-
Algorithmen zeitlich optimiert, weil dies erstmal am wichtigsten war.

Wollen Sie nun die gepackte Library MM2DEF.M2L dekomprimieren, k”nnen Sie
nicht einfach die ganze Datei auf einmal entpacken. Statt dessen mssen Sie
erst mit dem LibManager alle Dateien herauskopieren, dann diese Einzeldateien
alle mit Decode dekomprimieren und am Ende alle Dateien wieder zu einer
neuen Library zusammenfgen (wiederum durch Verwendung von LibManager).


Protokoll

Ein šbersetzungsprotokoll kann bei der Suche nach Laufzeitfehlern oder auch
beim Verstehen eines fremden Programms ntzlich sein, da es  neben  dem
Quelltext noch zus„tzliche Angaben enth„lt.

Ein typisches Compilerprotokoll sieht z. B. so aus:

Megamax Modula Compiler 3.4h                            02-Nov-87   18:59

       1     0    D            MODULE Beispiel;
       2    0    D
2.4  Bedienung: Compiler                                                 2 - 52
________________________________________________________


       3    0    D            VAR     a: CARDINAL;
       4    0    D                      l: LONGCARD;
       5    0    D
       6    0    D            PROCEDURE square (c: CARDINAL): LONGCARD;
       7     1     D              BEGIN
       8    1     $00146           RETURN LONG (c) * LONG (c)
       9    1     $0015A        END square;
      10    0    D
      11     0    D            BEGIN
      12    0    $0016A        a := 55;
      13    0    $00174        l := square (a)
      14    0    $00180      END Beispiel.

Global variables:
                   $00002      l
                   $00000      a

Die erste Spalte enth„lt durchlaufende Zeilennummern fr den Text. Dann folgt
ein Z„hler fr die Schachtelungstiefe von  Prozeduren  und  Modulen,  dessen
Nutzen Sie bei etwas komplizierteren  Programmen  als  dem  obigen  Beispiel
erkennen werden.

Die dritte Spalte gibt die Adresse des Zeilenanfangs im Codemodul an. Diese
Angabe ist immer relativ zum Modulanfang zu verstehen. Die gleiche relative
Adresse meldet Ihnen das System auch, wenn ein Laufzeitfehler auftritt - im
Protokoll k”nnen Sie so auf einen Blick die Fehlerzeile orten.  (Eine  andere
M”glichkeit der Fehlersuche bietet allerdings der Scanner - siehe Kapitel 2.5
'Debugger'.) Wenn Deklarationszeilen bersetzt werden, erscheint statt einer
Adresse ein "D" im Protokoll.

Durch das Einfgen der zus„tzlichen Spalten in das Protokoll passen die fol~
genden Zeilen des Programmtextes oft nicht mehr komplett auf eine Zeile von
80 Zeichen. Der Compiler bricht dann im Protokoll den Rest der Zeile um.
Wenn Sie allerdings das Protokoll (z.B. auf einem Drucker) mit mehr als 80
Zeichen Breite ausgeben wollen, k”nnen Sie das Format im Parameter-Men
auf andere Zeilenl„ngen einstellen.

Am Schlu der Protokolldatei folgt eine Liste der globalen Variablen mit den
jeweiligen relativen Adressen (die erste Variable liegt auf der rel. Adresse 0).

Die Startadressen der globalen Variablen und der Module k”nnen Sie durch
verschiedene  Funktionen  in  den  Modulen  Loader  und  ModCtrl  ermitteln
(Beispielprogramme in Ordnern DEMO & UTILITY: GPA, ModList und TraceMod).
In  der  Shell  werden  durch  Alternate-R  jedes  vorhandene  Modul  sowie  die
Startadressen und L„ngen des Codes angezeigt, ebenso wie mit ModList.
2.5  Bedienung: Debugger                                                 2 - 53
________________________________________________________


2.5    Debugger

Megamax  Modula  untersttzt  Sie  bei  der  Fehlersuche  durch  spezielle
Debugging-Funktionen  (die  šbersetzung  "Entwanzen"  kennen  Sie  vermutlich
schon). Ein spezielles  Debugger-Programm  werden  Sie  allerdings  vergeblich
suchen - beim Suchen helfen Ihnen der Compiler pers”nlich und das Imple~
mentations-Modul Debug. Diese Debug-Funktionen ersparen Ihnen die bliche
Fehlersuche bei compilierten Sprachen durch Einfgen diverser Testausgaben in
den Programmtext; sie helfen auch beim Aufspren vertrackter Probleme.

Fr  "harmlosere"  F„lle  bietet  Megamax  Modula  eine  weitere  Hilfe  bei  der
Fehlersuche:  das  Auffinden  der  Programmstelle  im  Test,  an  der  ein
Laufzeitfehler  auftrat.  Diese  Scan-Funktion  ist  im  letzten  Abschnitt  dieses
Kapitels beschrieben.


šbersetzen im Debug-Modus

Wollen Sie ein Programm 'debuggen', fgen Sie bitte als erstes ein 'IMPORT
Debug' in die Importliste ein (falls das Programm im TOS-Modus l„uft, also die
Endung MOS oder MTP hat, importieren Sie besser TOSDebug). Das Modul
Debug enth„lt die Laufzeitfunktionen, die bei der Fehlersuche ben”tigt werden,
und mu daher im RAM zur Verfgung stehen.

Mit der Compiler-Option (*$D+*) im Programmtext schalten Sie den Compiler
in  den  Debug-Modus  um.  Fr  alle  Programmzeilen,  die  in  diesem  Modus
bersetzt werden, erzeugt der Compiler zus„tzlichen Code, so da diese Zeilen
schrittweise,  mit  Ausgabe   des   Programmtextes   und   der   berechneten
Ausdrcke, ausgefhrt werden k”nnen.

Natrlich  braucht  dieser  zus„tzliche  Code  auch  zus„tzlichen  Platz  im
bersetzten Modul. Auerdem ist die Ausfhrung von Programmen im Debug-
Modus wesentlich langsamer als im Normalfall - das 'Debuggen' einer 5000
mal durchlaufenen Schleife beschert Ihnen nicht nur jede Menge Bildschirm~
ausgaben sondern auch eine ausgedehnte Kaffeepause.

Sie  sollten  daher  die  M”glichkeit  nutzen,  gezielt  einzelne  Programmteile
zwischen (*$D+*) und (*$D-*) einzuschlieen und zu untersuchen. Oft ist es
sinnvoll,  zun„chst  das  Hauptprogramm  zu  berprfen  und  herauszufinden,
welche Prozedur fehlerhaft ist. In einem weiteren Compilerlauf kann dann diese
Prozedur im Debug-Modus bersetzt werden.
2.5  Bedienung: Debugger                                                 2 - 54
________________________________________________________


Ausfhren im Debug-Modus

Ein  Programm,  das  im  Debug-Modus  bersetzt  wurde,  enth„lt  zus„tzliche
TRAP-Anweisungen,  die  das  Modul  'Debug'  abf„ngt.  'Debug'  sorgt  fr  die
Ausgabe  der  ausgefhrten  Zeilen  und  berechneten  Ausdrcke;  zus„tzlich
erlaubt das Modul die Beeinflussung der Ausfhrung ber die Tastatur.

Die  normale  Anzeige  jeder  Programmzeile  besteht  aus  der  Textzeile  des
Programms; darunter werden alle in dieser Zeile berechneten arithmetischen
Ausdrcke ('Expressions' in der Syntaxbeschreibung) in der Reihenfolge ihrer
Berechnung  ausgegeben.  Die  Reihenfolge  dieser  Ausgaben  ist  nicht  immer
einfach zu berblicken und soll am folgenden Beispiel erl„utert werden:

IF ORD(a) = b+c THEN d:=e; f:=h+(2*g)END;

Nach  dem  IF  steht  laut  Modula-Syntax  eine  'Boolean  Expression',  die
ausgegeben  wird.  Bei  der  Berechnung  dieses  Ausdrucks  wird  jedoch  eine
weitere 'Expression' ausgerechnet, n„mlich das Argument der Funktion ORD -
dessen Wert erscheint also als erste Ausgabe. Der Wert b+c wird dagegen
nicht  angezeigt,  denn  links  und  rechts  vom  Gleichheitszeichen  stehen
syntaktisch nur Simple Expressions.

Die  im  THEN-Teil  berechneten  Ausdrcke  erscheinen  natrlich  nur,  wenn
dieser Zweig ausgefhrt wird. Der erste Ausdruck ist der auf <d> zugewiesene
Wert, also <e>. Bei der Berechnung des Ausdrucks, der auf <f> zugewiesen
wird, ist wiederum ein zus„tzlicher Ausdruck auszuwerten: In Klammern steht
laut Syntaxdiagramm wieder eine 'Expression'. Also wird erst der Wert <2*g>
ausgegeben, dann <h+2*g>.

Auer 'Expressions' werden noch die Werte von Variablen angezeigt, die als
Parameter an Prozeduren bergeben werden.

Allgemeiner Tip: Wenn mehr (oder weniger) Werte ausgegeben werden, als Sie
erwarten,  sehen  Sie  im  Syntaxdiagramm  nach,  wo  wirklich  'Expressions'
stehen. Um die Ausgabe eines Teilausdrucks zu erzwingen, ist es oft m”glich,
ihn  in  Klammern  zu  setzen  -  innerhalb  der  Klammern  wird  wieder  eine
vollst„ndige Expression erwartet und ausgegeben.
2.5  Bedienung: Debugger                                                 2 - 55
________________________________________________________


Leertaste   veranlat Ausfhrung und Ausgabe der n„chsten Zeile
            oder schaltet von laufender Ausfhrung auf Einzelschritt.
<Return>    schaltet von Einzelschritt auf laufende Ausfhrung.
<H>         w„hlt Ausgabe von Skalaren als Hexadezimalzahlen.
<D>         w„hlt Ausgabe von Skalaren als Dezimalzahlen.
<S>         Eingabe einer Schrittweite: die eingegebene Anzahl Zeilen
            wird ohne Ausgaben (schneller) ausgefhrt.
<A>         aktiviert die Ausgabe wieder, wenn sie durch <S>
            unterdrckt wurde.
<L>         schaltet zus„tzliche Ausgabe der Zeilenadresse zu jeder
            Programmzeile ein/aus.
<R>         veranlat einmalige Ausgabe aller CPU-Register.

Die  gleichen  Kontrollfunktionen  k”nnen  statt  von  der  Tastatur  auch  vom
laufenden Programm aus umgeschaltet werden. Dazu k”nnen Steuervariablen
aus dem Modul 'Debug' importiert und ver„ndert werden. Das erfordert zwar
einige zus„tzliche Anweisungen im Programm, erleichtert aber manchmal die
gezielte  Fehlersuche  sehr  -  z.B.  wenn  die  Debug-Ausgaben  erst  aktiviert
werden  sollen,  wenn  eine  Variable  einen  bestimmten  Wert  hat  oder  eine
Prozedur mit vorgegebenen Argumenten aufgerufen wurde. Die Funktion der
Steuervariablen im einzelnen:

Continous:  BOOLEAN   =  "laufende Ausfhrung ohne Warten"
Active:     BOOLEAN   =  "folgende <Step> Schritte ohne Anzeige ausfhren"
Step:       LONGCARD =   Anzahl der Schritte, die ohne Anzeige auszu~
                             fhren sind (zus„tzlich mu Active = FALSE sein)
LineAddr:   BOOLEAN   =  "zu jeder Programmzeile Adresse ausgeben"
Hex:        BOOLEAN   =  "Skalare als Hexadezimalzahlen ausgeben"


Der Scanner - Suchen der Fehlerposition

In vielen F„llen werden Sie das Debug-Modul zur Fehlersuche
aber gar nicht ben”tigen - es gibt noch eine einfache und oft
wesentlich  schnellere  M”glichkeit,  Programmierfehlern  auf  die
Spur zu kommen. Oft gengt es ja zu wissen, welche Stelle des Programms
(im  Text)  gerade  ausgefhrt  wurde,  als  ein  Laufzeitfehler  auftrat.  Dabei
untersttzt Sie der 'Scanner', den Sie auf der Shell-Arbeitsfl„che als Lupe
abgebildet sehen.

Hinter dem Scanner verbirgt sich in Wirklichkeit wiederum  der  Compiler  -
allerdings  in  einer  Betriebsart,  die  keine  Codedatei  erzeugt,  sondern  nur
so  lange  'ins  Blaue'  bersetzt,  bis  eine  bestimmte  Adresse  im  erzeugten
Codemodul erreicht ist. Dann stoppt der Scanner und ruft den Editor auf, um
die erreichte Textstelle zu zeigen.
2.5  Bedienung: Debugger                                                 2 - 56
________________________________________________________


Wenn  ein  Laufzeitfehler  auftritt,  ermittelt  das  Modula-System,  in  welchem
Modul und auf welcher relativen Adresse innerhalb des Moduls die Ausfhrung
unterbrochen wurde. Sie k”nnen w„hlen:

* Exit, um die angezeigte Fehlerposition im Programmtext zu suchen.
* Back, um statt der angezeigten Fehlerposition die Position des Aufrufers zu
  sehen (s.u.);
* Frwd, um entsprechend wieder die Position des n„chsttieferen Aufrufs zu
  bekommen.

Nach Wahl von Exit haben Sie nochmals die M”glichkeit, durch Quit zur Shell
zurckzukehren oder durch Cont das Programm doch fortzusetzen. Durch Edit
schlielich starten Sie den Scanner, der Ihnen die gefundene Fehlerstelle dann
im Editor pr„sentiert.

Gelegentlich  mssen  Sie  noch  etwas  mehr  tun,  um  den  Ursprung  eines
Laufzeitfehlers zu finden: Unter  Umst„nden  ruft  das  fehlerhafte  Programm
eine Prozedur (evtl. in einem anderen Modul) mit falschen Parametern auf, und
erst dort wird der Fehler ausgel”st. Dann interessiert Sie natrlich nicht die
Position in der Prozedur, sondern die des falschen Aufrufs. In diesem  Fall
klicken Sie in der ScannerBox bitte nicht Exit, sondern Back an - eine neue
Scanner-Box  zeigt  Ihnen  Modulnamen  und  Adresse  des  Aufrufers.  Dieses
Rckverfolgen  zum  Aufrufer  k”nnen  Sie  wiederholen,  bis  das  'verd„chtige'
Modul erreicht ist. Sind Sie in der Aufrufer-Kette zu weit 'geklettert', dann
k”nnen  Sie  mit  Frwd  wieder  tiefer  steigen.  Wenn  Sie  den  eigentlichen
Verursacher des Fehlers gefunden haben, w„hlen Sie Exit, und nach einem
Scannerlauf wird die Position in diesem Modul angezeigt.


Manuelles Starten des Scanners

Bei der oben beschriebenen Bedienung des Scanners ist das Scanner-Symbol
auf der Arbeitsfl„che noch gar nicht benutzt worden. In zwei F„llen kommt
dieses Symbol zur Anwendung:

* Wenn Sie nach einem Laufzeitfehler eine Adresse aus der  Aufruferkette
ausgew„hlt haben (durch 'Back'/'Forward'), die sich nach dem Scannen nicht
als  der  eigentliche  Verursacher  des  Fehlers  herausstellt.  In  diesem  Fall
m”chten  Sie  wahrscheinlich  noch  eine  andere  Adresse  aus  der  Kette
untersuchen.

* Wenn nach einem fatalen Laufzeitfehler die Shell und der  Scanner  nicht
mehr funktionieren (etwa nach šberschreiben wichtiger Speicherbereiche). Die
Fehlerposition im Code sollten Sie in jedem Fall noch erfahren; nach einem
Neustart  der  Shell  l„t  sich  die  zugeordnete  Textstelle  dann  durch  einen
manuellen Scanner-Aufruf (mit Eingabe der Adresse von Hand) feststellen.
2.5  Bedienung: Debugger                                                 2 - 57
________________________________________________________


Wollen Sie erneut die Aufrufkette zum vorangegangenen Laufzeitfehler sehen,
dann mssen Sie das Scanner-Symbol bei festgehaltener Shift-Taste anw„hlen
(z.B. mit Shift-S). Sie sehen dann die oben beschriebene Scanner-Box.

šbergeben Sie dagegen eine Datei an den Scanner, indem Sie sie auf das
Symbol schieben, so bekommen Sie die M”glichkeit, eine Fehleradresse  von
Hand einzugeben. Gemeint ist hier immer die relative Adresse innerhalb des
Moduls, wie sie auch nach Laufzeitfehlern angezeigt wird. Um die Arbeitsdatei
zu scannen, brauchen Sie das Scanner-Symbol nur doppelt anklicken.

Fragt der Scanner nach der relativen Position, ist der vorher beim Laufzeit~
fehler angezeigte Wert einzugeben. Dabei ist zu beachten, da der Wert, wie
bei  der  Anzeige,  mitsamt  dem  "$"-Zeichen  eingegeben  wird,  da  dies  eine
Hexadezimalzahl kennzeichnet.
2.5  Bedienung: Debugger                                                 2 - 58
________________________________________________________





















                               Auch diese Seite war zu kostbar,
                                     um leer zu bleiben.
2.6  Bedienung: Linker                                                    2 - 59
________________________________________________________


2.6    Linker

Funktion

In Kapitel 1.4 haben wir schon beschrieben,  warum  das  Megamax  Modula-
System eigentlich ohne Linker auskommt: Der Loader als Teil der Entwicklungs~
umgebung sorgt fr automatisches Load Time Linking, wenn Sie aus der Shell
ein Programm starten.

Wollen Sie  aber  ein  Modula-Programm  als  eigenst„ndige  TOS-  oder  PRG-
Anwendung verwenden, dann mu es komplett mit allen benutzten Modulen in
einer  Codedatei  abgelegt  werden,  damit  das  TOS  damit  zurechtkommt.
Auerdem mssen noch einige zus„tzliche Anweisungen eingefgt werden, um
fr die Module die gleiche Laufzeitumgebung bereitzustellen, wie sie bei Aufruf
aus der Shell herrscht.

Eine solche Codedatei erzeugt der  Linker  -  erfreulicherweise  kann  er  das
vollautomatisch.  Sie  bergeben  ihm  nur  den  Namen  des  Hauptmoduls;  der
Linker l„dt alle importierten Module dazu und fgt zus„tzlich  ein  spezielles
Initialisierungs-Modul  ein.  Das  resultierende  Programm  kann  dann  v”llig
unabh„ngig  vom  Modula-System,  z.B.  unter  dem  GEM-Desktop,  gestartet
werden;  daher  k”nnen  Sie  Programme  in  dieser  Form  auch  an  Dritte
weitergeben, die das Megamax Modula-System nicht besitzen  (siehe  Kapitel
1.5).

Bedienung

Der Linker wird aufgerufen wie alle anderen Systemprogramme: Legen Sie mit
der Maus eine Code-Datei auf dem Linker-Symbol auf der Arbeitsfl„che ab
(oder klicken Sie das Linker-Symbol an, um die Arbeitsdatei zu bergeben).
Bevor Sie den Linker starten, sollten Sie aber berprfen, ob folgende Voraus~
setzungen erfllt sind:

* Von allen Modulen, die in das Programm importiert werden, mu das ber~
setzte Implementationsmodul vorhanden sein. Zus„tzlich werden evtl. weitere
Module ben”tigt (siehe folgenden Abschnitt Konfigurationsmodule). Die Imple~
mentationsmodule werden auf den Pfaden der ImpPath-Liste (siehe Kap. 2.2,
Batch-Dateien) gesucht.

* Das fertig gelinkte Programm wird auf dem Pfad gespeichert, der fr das
bergebene Hauptmodul angegeben wurde. (Sie k”nnen hier bewut einen Pfad
-  durch  Doppelklick  auf  das  "aktuelle  Datei"-Fenster  oder  Control-P  -
angeben, auf dem das Hauptmodul gar nicht zu finden ist, um die Ausgabe zu
lenken;  das  Hauptmodul  wird  dann  auf  allen  Pfaden  der  ModPath-Liste
gesucht).  Auf  der  Zieldiskette  mu  gengend  Platz  sein  -  durch  die
zus„tzlichen Module wird das  gelinkte  Programm  im  allgemeinen  wesentlich
gr”er als das ursprngliche Modul.
2.6  Bedienung: Linker                                                    2 - 60
________________________________________________________


Wenn keine Schwierigkeiten auftreten, baut der Linker auf dem Bildschirm eine
Liste der importierten Module auf. Zuerst werden dabei stets die Konfigura~
tions-Module (s.u.) aufgenommen, gefolgt von ihren Importen. Dann folgen das
von Ihnen angegebene Hauptmodul und dessen Importe. Schlielich meldet der
Linker den erfolgreichen Ablauf und speichert das fertige Programm ab.

Fertig - mehr zu Bedienen gibt's in der Regel nicht! Es sei denn, Sie werden
mit einer der folgenden Fehlermeldungen konfrontiert:


Fehlermeldungen

Alle Meldungen beginnen mit der Angabe, welches Modul das Problem ausgel”st
hat  und  von  welchem  anderen  Modul  es  ben”tigt  wurde:  "Importing
<FehlerModul>  into  <KundenModul>".  Dann  folgt  eine  Fehlerbeschreibung.
Allgemein gilt: Der Linker interessiert sich immer fr bersetzte Implemen~
tationsmodule - alle Probleme k”nnen sich also nur auf diese Dateien beziehen.

Module not found
    Das  bersetzte  Implementationsmodul  wurde  auf  keinem  der  Pfade
    gefunden, die in der IMPPATH-Pfadliste in der Shell-Info definiert sind.
Wrong module format
    Die  geladene  Datei  ist  kein  korrekt  aufgebautes  Implementationsmodul;
    vermutlich ist die Datei besch„digt.
Error in relocating list
    Die  Relozierliste  (Bestandteil  jedes  bersetzten  Moduls)  ist  fehlerhaft;
    vermutlich ist die Datei besch„digt.
Bad module layout
    Das  Modul  wurde  mit  einer  alten  Compilerversion  bersetzt,  die  ein
    anderes Dateiformat erzeugt. Modul neu bersetzen!
File is damaged
    Beim Laden des Moduls ist ein Lesefehler aufgetreten.
Wrong module version
    Die gefundene Version des Moduls pat zu einem anderen Definitionsmodul
    als beim šbersetzen des Kundenmoduls vorlag. (Das Modul exportiert nicht
    genau die Bezeichner, die das Kundenmodul erwartet.) Ggf. beide Module
    neu bersetzen!
Out of memory
    Der Hauptspeicher reicht nicht aus.  Evtl.  vorhandene  Accessories  oder
    RAM-Disk entfernen.
Too many modules (list overflow)
    Mehr als die in den Parametern eingestellte Anzahl Module sollen gebunden
    werden. Erh”hen Sie den Wert Max. Module unter Parameter/Linker und
    wiederholen Sie den Linker-Aufruf.

Auerdem  sind  I/O  Error-Meldungen  m”glich.  Sie  enthalten  jeweils  eine
Beschreibung des Fehlers und beziehen sich stets auf die Ausgabe-Datei.
2.6  Bedienung: Linker                                                    2 - 61
________________________________________________________


Linker-Optionen

Beim  Menpunkt  Parameter
kann unter Linker eine Dia~
logbox ge”ffnet werden, die
das Einstellen aller Optionen
beim Linken zul„t.

In den acht Treiber-Feldern
werden  die  Initialisierungs-
und    Konfigurations-Module
eingetragen, die weiter unten
ausfhrlich  behandelt  wer~
den.  Die  Stackgr”e  wird
ebenfalls sp„ter erl„utert. Der Wert hinter Max. Module bestimmt, wie viele
Module maximal  zu  linken  sein  werden.  Ist  dieser  Wert  zu  klein  gew„hlt,
meldet der Linker einen Fehler und Sie mssen den Wert erh”hen. Er sollte
aber auch nicht unn”tig gro gew„hlt werden, weil je nach seiner Gr”e mehr
oder  weniger  Speicherplatz  von  vornherein  vom  Linker  reserviert  wird.
Besonders, wenn mangels Speicher ”fter die Fehlermeldung Out of memory
beim Linken erscheint, sollten Sie diesen Wert so klein wie m”glich halten.


Treiber- bzw. Konfigurations-Module

Zus„tzlich zu den Modulen, die Sie explizit (durch IMPORT-Anweisungen) in
Ihren  Programmen  benutzen,  kann  der  Linker  noch  weitere  Module  in  die
Code-Datei einbinden. Mindestens ein solches Modul wird (fast) immer ben”tigt,
um vor dem Start des Modula-Programms die Laufzeitumgebung vorzubereiten.
Weitere  Module,  die  mitgeliefert  wurden,  stellen  Ausgabefunktionen  auf
unterster Ebene fr TOS- oder GEM-Umgebung bereit.

Das System ist bereits so konfiguriert, da alle Programme 'gelinkt' werden
k”nnen, ohne da Sie sich um diese zus„tzlichen Module kmmern mten. Sie
k”nnen  die  Konfiguration  dieser  Module  aber  von  der  Shell  aus  mit  dem
Menpunkt Parameter/Linker einstellen. In der Dialogbox (s.o.) existiert eine
Liste  fr  mit  acht  Treibern.  Vor  jeden  dieser  Treiber  k”nnen  Sie  durch
Anklicken ein H„kchen setzen oder l”schen - nur die so markierten Modul~
namen werden beim Linken eingebunden. Normalerweise  sind  fnf  der  acht
m”glichen Namen eingetragen:

M2Init sorgt fr die Vorbereitung der Laufzeitumgebung. Dieses Modul mu in
jedem Codefile enthalten sein - bitte nur 'abschalten', wenn es extra verlangt
wird, wie z.B. beim Linken von MoreMem (UTILITY-Ordner) oder wenn  Sie
selber die Initialisierung in Ihrem Modul vornehmen wollen.
2.6  Bedienung: Linker                                                    2 - 62
________________________________________________________


GEMError bernimmt die Behandlung von Laufzeitfehlern. Wenn dieses Modul
vorhanden ist, werden Laufzeitfehler in einer Alert-Box mit Fehlerbeschreibung
und -position angezeigt. GEMError kann nur sinnvoll bei keine Optimierung oder
verkrzende Optimierung mit eingelinkt werden. Wird vollst„ndig optimiert, ist
statt dessen SimpleError einzubinden.

SimpleError ist eine einfachere Fehlerbehandlung als GEMError, die, falls ber~
haupt ein Fehlerabfangen erwnscht ist, bei vollst„ndig optimierten Programmen
gew„hlt werden mu.

Um Platz zu sparen, k”nnen Sie GEMError bzw. SimpleError auch weglassen -
dann erscheinen bei Laufzeitfehlern nur die allseits bekannten B”mbchen.

GEMIO enth„lt Ausgabefunktionen, auf die sich das InOut-Modul sttzt. Diese
Funktionen lenken die Ausgabe auf ein Fenster, wie Sie es vom Arbeiten mit
der  Megamax  Modula-Shell  kennen.  Leider  ist  die  Untersttzung  dieser
'hbschen' Ausgabe recht aufwendig, und die fertige Code-Datei wird relativ
lang.  Daher  k”nnen  Sie,  wenn  Ihr  Programm  sonst  keine  GEM-Funktionen
benutzt,  ohne  Programm„nderung  wahlweise  auch  TOS-Ausgabe  ber  das
TOSIO-Modul w„hlen:

TOSIO  enth„lt  die  gleichen  Ausgabefunktionen  wie  GEMIO,  allerdings  fr
Ausgabe auf dem TOS-Bildschirm (schwarz auf komplett weiem Grund mit
Textcursor, keine GEM-Funktionen, keine Maus). Wenn Sie dieses Modul statt
GEMIO aktivieren, geben alle InOut-Funktionen auf dem TOS-Bildschirm aus.
Damit das GEM-Desktop die richtigen Initialisierungen beim Starten durchfhrt,
sollte das fertig gebundene Programm von '.PRG' in '.TOS' umbenannt oder von
vornherein  das  Modul  durch  die  Option  $E  MOS  im  Quelltext  als  TOS-
Programm klassifiziert werden.

Achtung: TOSIO verwendet die BIOS-Funktionen zur Bildschirm-Ein-/Ausgabe
und erlaubt somit keine Datei-Umleitung (I/O-Redirection) von auen, z.B. ber
eine  Command-Shell.  Dafr  kann  solch  ein  Programm  nicht  einfach  durch
Eingabe von Control-C abgebrochen werden.

GEMDOSIO ist, ebenso wie TOSIO, fr TOS- und TTP-Programme zust„ndig.
Es  erlaubt  die  Umlenkung  von  Ein-/Ausgaben  ber  das  Modul  InOut  von
auerhalb  (beispielsweise  ber  eine  Command-Shell)  und  den  Programm~
abbruch ber Control-C, da die Ein-/Ausgaben ber die GEMDOS-Funktionen
geschehen. Ist Ihnen der Sinn dieser Anwendung nicht klar, verwenden Sie
besser TOSIO!

Nochmal in Kurzform: Benutzen Sie M2Init immer; entweder GEMError oder
SimpleError  wenn  ordentliche  Fehlermeldungen  gewnscht  sind;  entweder
GEMIO,  TOSIO  oder  GEMDOSIO,  wenn  InOut-Funktionen  benutzt  werden.
(Falls das Programm InOut gar nicht benutzt, sollten diese IO-Module weg~
gelassen werden, um das Programm nicht unn”tig zu vergr”ern.)
2.6  Bedienung: Linker                                                    2 - 63
________________________________________________________


Komprimierung (Optimierung) des zu erzeugenden Programms

Durch die Wahl einer der vier gezeigten
Optionen l„t sich bestimmen, inwieweit
die   zusammengefgten   Module   im
erzeugten     Programm     komprimiert
werden sollen.

Die erste Einstellung keine Optimierung fgt die Module ohne Komprimierung
zusammen. Zudem werden die Informationen ber alle Module mit eingebunden,
die  ben”tigt  werden,  wenn  das  Loadtime  Linking  vom  gelinkten  Programm
verwendet werden soll. Diese Option ist also zu w„hlen, wenn ein Programm
erzeugt wird, das den Loader importiert, um andere Module starten zu k”nnen,
z.B. bei der Shell dieses Systems (MM2Shell).

Alternativ  zu  keiner  Optimierung  k”nnen  auch  nur  Prozedurnamen  entfernt
werden.  Dadurch  bleiben  die  Module  vollst„ndig  erhalten,  nur  werden  die
Symboltabellen, die die einzelnen Prozedurnamen enthalten, entfernt. Loadtime
Linking ist dann weiterhin m”glich, nur ist das Scanning (s. Kap 2.5, Debugger)
und die Anzeige der Prozedurnamen bei Laufzeitfehlern nicht mehr m”glich.
Diese Komprimierung ist  fr  Sie  meist  nicht  von  Interesse.  Lediglich  beim
Linken der Shell (sofern Sie daran nderungen vorgenommen haben) sollten
Sie sie anstatt keiner Optimierung anwenden,  weil  Sie  dabei  ca.  10  KByte
einsparen.  Da  Sie  im  Allgemeinen  bei  Fehlern  in  den  MOS-Modulen  keine
Korrekturen vornehmen k”nnen, k”nnen Sie bei diesen Modulen ja ruhig auf die
M”glichkeit zum Scanning verzichten. Auf Module, die per Loadtime Link von
der Shell gestartet werden, hat dies keinen Einflu.

Die  Option  Prozedurnamen  erhalten  erzeugt  kompaktere  Programme.  Dabei
werden alle Funktionen entfernt, auf die es keine Referenz zur Laufzeit gibt.
Das  gelinkte  Programm  enth„lt  demnach  nur  Module  mit  Funktionen,  die
aufgerufen werden k”nnen und Module mit exportierten Variablen, die von den
ben”tigten Prozeduren benutzt werden. Zus„tzlich enthalten sind, wie bei den
vorigen Optionen,die Informationen ber die Module, die fr eine Laufzeitfehler~
analyse  (Anzeige  der  Prozedur-  und  Modulnamen  und  der  aufrufenden
Prozeduren) mittels des Moduls GEMError ben”tigt werden. In dieser Form ist
kein Load-Time-Linking vom gelinkten Programm aus m”glich.

Wenn weder vom Loadtime Linking (Starten von Modulen mittels des Loaders),
noch von der komfortablen  Fehleranalyse  (Import  von  GEMError)  Gebrauch
gemacht  werden  soll,  kann  die  letzte  Einstellung  vollst„ndige  Optimierung
gew„hlt  werden.  Sie  erzeugt  die  kompaktesten  Programme,  indem  im
Unterschied  zur  vorigen  Option  die  Informationen  zur  Fehleranalyse  weg~
gelassen  werden.  Damit  eventuelle  Fehler  trotzdem  ordentlich  angezeigt
werden, mu SimpleError statt GEMError eingebunden werden.
2.6  Bedienung: Linker                                                    2 - 64
________________________________________________________


Vorsicht:

Bei der vollst„ndigen Optimierung entfernt der Linker alle Module vollst„ndig,
die zwar importiert werden, aus denen aber keine Prozeduren oder Variablen
wirklich benutzt werden. Das heit: Importieren Sie ein Modul, das in seinem
Initialisierungscode (K”rper) lediglich Variablen anderer Module initialisiert oder
importierte Prozeduren dort aufruft, verschwinden diese Anweisungen!

Dieser  Effekt  tritt  nur  beim  optimierten  Linken  auf.  Haben  Sie  also  ein
Programm, das ungelinkt unter der Shell oder nicht-optimiert gelinkt fehlerfrei
l„uft, optimiert gelinkt aber nicht funktioniert, prfen Sie, ob die beschriebene
Situation bei Ihnen vorkommt. Sie k”nnen es auch daran erkennen, da solche
Module beim Linken zwar erst beim  Einladen  angezeigt  werden,  dann  aber
wieder vom Bildschirm gel”scht werden, weil sie vollst„ndig entfernt wurden.

Um  dies  zu  verhindern,  mssen  Sie  die  wegoptimierten  Module  mit  der
Direktive B+ bersetzen, entweder durch $B+ im Quelltext oder durch -B in
der Eingabezeile fr Direktiven in der Compiler-Parameter-Box.

Zusammenfassend seien pauschal diese Regeln zu befolgen:

* Accessories sollten m”glichst kurz sein und drfen nie mit einem Fehler
abbrechen,  da  dann  das  gesamte  System  nicht  mehr  funktionsf„hig  ist.
Deshalb ist am besten nach eingehendem Testen das Modul mit der Option
$R-  zu  compilieren,  um  Platz  zu  sparen,  und  das  Programm  dann  mit
vollst„ndiger Optimierung und  ohne  Fehlermodule  zu  linken  (also  in  Linker-
Optionen nur M2Init aktivieren).

* Die Shell MM2Shell wird mit der Einstellung keine Optimierung  oder  nur
Prozedurnamen  entfernen  und  den  Modulen  M2Init,  GEMIO  und  GEMError
gebunden. Max. Module sollte den Wert 100 haben. Falls der Linker nicht linken
will,  weil  der  freie  Speicher  nicht  ausreicht,  entfernen  Sie  die  resident
geladenen  Programme  (z.B.  Compiler  und  Editor).  Wenn  das  nicht  reicht,
entfernen Sie Ihre Accessories, residente Programme im AUTO-Ordner und
ggf. auch eine vorhandene RAM-Disk (dann mssen die Suchpfade ImpPath und
ModPath  ggf.  die  Pfadnamen  fr  die  IMP-  und  MOD-Dateien  auf  den
Laufwerken A: oder B: enthalten, damit die Modulcodes dann von Disk geladen
werden k”nnen).

* Sonstige Programme k”nnen in der Regel mit der vollst„ndigen Optimierung
gelinkt werden, um zu erreichen, da die Programme m”glichst wenig Platz auf
Disk und im Speicher beim Ausfhren belegen. Zur Sicherheit sollte allerdings
das Modul SimpleError mit eingebunden werden, damit in einem unerwarteten
Fehlerfall das Programm sich nicht gleich mit B”mbchen verabschiedet, sondern
statt dessen eine Meldung zeigt, um was fr einen Fehler es sich handelt. Ist
allerdings  mit  Laufzeitfehlern  zu  rechnen,  ist  es  sinnvoller,  verkrzende
Optimierung zu w„hlen und GEMError einzubinden. Dann ist bei einem Fehler
2.6  Bedienung: Linker                                                    2 - 65
________________________________________________________


die  Lokalisation  der  Ursache  einfacher.  Da  aber  in  diesem  Fall  meist  nur
Prozedurnamen, aber kein 'Offset' zum nachtr„glichen Scannen in der Shell
angezeigt werden kann, ist im ungnstigsten Fall keine Optimierung zu w„hlen.
Dann werden auch die Offsets bei Fehlern immer angezeigt. In der Shell kann
dann z.B. durch Ziehen des Quelltextes des zu scannenden Moduls auf die
Scan-Box der Offset eingegeben werden, um den Scanner zu aktivieren.

* Bei allen normalen Programmen, auch Accessories, mu M2Init als erstes
Treibermodul  eingebunden  werden,  weil  dieses  Modul  dafr  sorgt,  den
berflssigen Speicher freizugeben, die globalen Variablen (das BSS Segment)
zu l”schen und die einzelnen Module zu initialisieren (die Modulk”rper werden
alle nacheinander aufgerufen).

*  Es  ist  immer  darauf  zu  achten,  da  die  Module  GEMIO,  TOSIO  oder
GEMDOSIO nur dann eingebunden zu werden brauchen, wenn das Modul InOut
verwendet wird. Ansonsten erzeugt das Einbinden dieser Module nur unn”tig
lange Programme.


Stack-Gr”e

Ebenso wie bei Modulen, die unter der Shell mit Loadtime-Linking gestartet
werden, kann die Stackgr”e auch fr gelinkte Programme bestimmt werden
(siehe auch Kap. 2.2, Kommandozeile). Ist der Wert Null eingetragen, wird die
Standard-Gr”e verwendet, die in M2Init bestimmt ist (normalerweise  8192
Bytes). War beim Starten eines Moduls unter der Shell ein gr”erer Stack
n”tig, so ist dieser in der Regel genauso beim Linken in der Linker-Parameter-
Box einzustellen. Ist der Stack des gelinkten Programms zu klein, wird eine
entsprechende Fehlermeldung w„hrend des  Programmlaufs  angezeigt,  sofern
GEMError bzw. SimpleError mit eingebunden wurde.


Binden von Accessory-Programmen

šbrigens: Accessories (Endung ACC) k”nnen ohne weiteres mit dem Linker
erzeugt werden, ihre Endung mu nur ggf. auf ACC angepat werden, wenn
nicht schon im Programmtext mit einer Zeile wie (*$E MAC *) die Endung fr
den Linker vorbereitet wird. Mit Hilfe der Funktion PrgCtrl.Accessory kann das
Programm gar abfragen, ob es nun  als  normales  PRG-Programm  oder  als
Accessory  mit  Endung  ACC  gestartet  wurde,  und  entsprechend  reagieren
(Accessories mssen sich zus„tzlich in die Menleiste eintragen und drfen
nicht terminieren!).
2.6  Bedienung: Linker                                                    2 - 66
________________________________________________________


Fast Load-, Fast Code- und Fast Memory-Flags

In neueren TOS-Versionen werden drei neue Kennungen im Programmkopf von
gelinkten  Programmen  ausgewertet.  Das  Fast  Load-Flag  (seit  TOS  1.4)
bestimmt, ob ein Programm es n”tig hat, da beim Start seine TPA gel”scht,
also mit Null-Bytes beschrieben werden soll. Die  TPA  ist  der  gr”te  freie
Speicherblock, in dem das Programm selbst auch steht. Sie ist Bestandteil des
Heaps; dem Speicher, der mit dem Storage-Modul angefordert werden kann.
Ist das Flag gesetzt, wird die TPA  nicht  gel”scht.  Modula-Programme,  die
unter der Shell vom Loader gestartet werden, erhalten den Heap nie gel”scht,
so brauchen Sie es in der Regel auch nicht, wenn sie gelinkt gestartet werden.
Daher kann das Fast Load-Flag immer aktiviert bleiben.

Die Flags fr Fast Code und Fast Memory bestimmen bei Atari TT-Rechnern,
ob  der  "schnelle"  Speicher  dieses  Computers  mitbenutzt  werden  darf.
Einschr„nkungen  gibt  es  hier  nur  selten,  beispielsweise,  wenn  Sie  die
Videospeicher-Adresse in einen anderen Bereich legen wollen, denn dies darf
nur im "normalen" Speicher der ersten 16 MByte geschehen - das Fast RAM
liegt aber oberhalb der ersten 16 MB.

Fast Code bestimmt, ob der Programmcode im schnellen Speicher  ablaufen
darf,  Fast  Memory,  ob  bei  Speicheranforderungen  (vom  Heap)  auch  der
schnelle Speicher vergeben werden darf. Funktioniert ein Programm nicht auf
dem TT, sollten Sie zuerst diese Flags probeweise abschalten.


Arbeitsweise des Linkers

  Bekanntermaen wird der Linker dazu verwendet, um aus einem Hauptpro~
gramm und seinen Bibliotheken ein Programm zu erzeugen, das auch auerhalb
der Megamax-Shell ausfhrbar ist.

  Die Mindestanforderung an den Linker ist dabei, das Hauptmodul mit allen
importierten  Modulen  zusammenzufgen  und  die  Adressen  der  "externen"
Prozeduren und Variablen zu verketten. Auerdem mssen die Relozierinfor~
mationen  der  einzelnen  Module  vom  fr  das  Loader-Modul  verst„ndlichen
Format in das TOS-Format umgewandelt werden. Dann kann daraus eine Datei
erzeugt werden, in der am Anfang noch Informationen abgelegt werden, wie
lang der Programm- und der Variablenbereich sind und wo im Programmcode
der K”rper des Hauptmoduls liegt, also des Teils, in dem mit der Ausfhrung
begonnen werden soll.

  Nur reicht das in der Regel nicht aus, denn so wird zwar das Hauptmodul
beim Starten des gelinkten Programms ausgefhrt, aber die ihm untergeordne~
ten Module wurden nicht initialisiert. Es ist notwendig, zus„tzlich die K”rper
der anderen Module vorher auszufhren. Aus diesem Grund legt der Linker
2.6  Bedienung: Linker                                                    2 - 67
________________________________________________________


zwischen dem  Programmcode  und  der  Reloziertabelle  noch  eine  Liste  aller
Adressen der K”rper ab, und zwar in ihrer hierarchischen Reihenfolge, mit
dem tiefsten Modul beginnend. Damit diese K”rper nun ausgefhrt werden, mu
ein weiteres Modul eingebunden werden; wir empfehlen M2Init.

  M2Init, dessen K”rper als erstes Modul ausgefhrt wird, weil es vom Linker
als Hauptmodul verstanden wird, sorgt auerdem fr richtige Initialisierung des
Programms. Zuerst ermittelt es, ob es  als  Accessory  gestartet  wurde;  in
diesem Fall fordert es erst einmal Speicher an, um ihn als Stack verwenden
zu k”nnen. Im anderen Fall hat es bereits den gesamten freien Speicher als
Stackbereich erhalten und verkleinert ihn deshalb erstmal und gibt den unbe~
nutzten Bereich an das System zurck.

  Der Linker hat dafr gesorgt, da in dem Adreregister A0 die Adresse der
Base-Page und in A1 die Adresse der Liste mit den Verweisen auf die K”rper
der anderen Module bergeben werden. So ruft M2Init dann alle von ihm selbst
importierten Modulk”rper auf (sie stehen zu Beginn der Liste, die mit einem
NIL-Zeiger abschliet) und dann eine Prozedur aus dem Modul MOSCtrl, um
ihr die Adresse einer Tabelle mitzuteilen, welche ebenfalls vom Linker erzeugt
wurde, und in welcher, sofern nicht vollst„ndige Optimierung gew„hlt wurde,
die Informationen ber alle vorhandenen Module enthalten sind (z.B. Modulname,
Adresse und L„nge im Speicher, usw.). Diese Tabelle wird vom Modul ModBase
verwaltet und von ModCtrl und Loader mitverwendet. Sie wird z.B. ben”tigt,
um bei einer Fehleranzeige durch GEMError den Modulnamen  und  ggf.  den
Prozedurnamen zu ermitteln.

  Ist die Initialisierung des MOS-Systems abgeschlossen, werden die restlichen
Modulk”rper  ausgefhrt  (die  Liste  wird  fortgesetzt  und  wiederum  mit  NIL
abgeschlossen), wobei der letzte K”rper das eigentliche Hauptmodul ist.

  Nun ist es theoretisch unn”tig, immer die importierten  Module  vollst„ndig
einzubinden, da normalerweise nicht alle Prozeduren (zumindest bei den mitge~
lieferten Bibliotheksmodulen) verwendet werden. Deshalb gibt es die M”glich~
keit, die Programme optimiert  zu  linken.  Beim  Megamax  Modula-2  gibt  es
zwei Stufen der Optimierung. Beide haben gemeinsam, da alle Prozeduren, die
keinesfalls  ben”tigt  werden,  vor  dem  Zusammenbinden  aus  den  Modulen
entfernt werden. Ergibt sich dabei, da trotz Import-Anweisung eines Moduls
aus diesem weder Prozeduren noch Variablen verwendet werden, wird sogar
das gesamte Modul nicht eingebunden (dies ist daran zu erkennen, da solche
Modulnamen im Fenster nach dem Optimiervorgang wieder verschwinden). Dies
ist u.a. bei Modulen der Fall, die nur Konstanten enthalten (z.B. MOSGlobals).

  Soll ein Modul nicht komplett wegoptimiert werden k”nnen, obwohl es keine
Funktionen und Variablen exportiert, aber beispielsweise in seinem Modulk”rper
Variablen, die es aus anderen Modulen importiert hat, initialisiert oder auch
dort importierte Funktionen aufruft, mu in seinem Quelltext - am besten zu
Beginn - die Compiler-Option $B+ aufgefhrt werden!
2.6  Bedienung: Linker                                                    2 - 68
________________________________________________________


  Ob eine Prozedur ben”tigt wird, erkennt der Linker daran, da er nachsieht
- ausgehend von jedem Modulk”rper - welche Prozeduraufrufe darin vorkom~
men.  Diese  gefundenen  Prozeduren  werden  nun  wiederum  selbst  alle  auf
weitere Aufrufe berprft (eine an sich ganz einfache Sache). Es werden dabei
auch Prozeduren ermittelt, die zwar als Aufrufe von aufgerufenen Prozeduren
gefunden werden, jedoch nie ausgefhrt werden, weil eine damit verbundene
Bedingung niemals eintritt - aber dies kann der Linker nicht herausfinden und
optimiert sie deshalb nicht weg.

  Alle Prozeduren, die auf diesem Wege nicht gefunden wurden, werden als
nicht ben”tigt deklariert und somit beim  Binden  aus  den  Modulen  entfernt.
Lokale  Prozeduren  werden  brigens  immer  zusammen  mit  ihren  globalen
V„tern behandelt. Es kann nicht erkannt werden, da lokale Prozeduren nicht
ben”tigt werden. Es wird nur auf die globalen Rcksicht genommen und die
lokalen mssen mitziehen (informatisches Machtgefge). Prozeduren, die auf
dem „uersten Scope von lokalen Modulen ihren Platz haben, werden natrlich
wie  globale  Prozeduren  behandelt.  Bitte  erwarten  Sie  aber  nicht,  da  die
lokalen  Modulk”rper  auch  entfernt  werden,  wenn  das  globale  Modul  keine
Variablen oder Prozeduren aus dem lokalen Modul verwendet!

  Die  beiden  Optimierungsmodi  unterscheiden  sich  nur  darin,  da  beim
"vollst„ndigen Optimieren" auch  die  Informationen  ber  die  Module  fr  das
Modul  ModBase  und  die  Prozedurnamen  entfernt  werden,  wohingegen  beim
anderen Modus diese Daten erhalten bleiben, um dem Modul  GEMError  die
gewohnte Ausfhrlichkeit bei der Anzeige von Laufzeitfehlern zu bieten.
2.7  Bedienung: Make und ModRef                                        2 - 69
________________________________________________________


2.7    Make  und   ModRef


Prinzip eines Make

Das Make ist ein Hilfsprogramm, das nicht unbedingt zur Programmentwicklung
ben”tigt wird, das aber bei umfangreicheren Programmprojekten sehr hilfreich
ist.

Arbeiten Sie an einem Programm, das aus  mehreren  Modulen  besteht,  die
h„ufig ge„ndert werden, mssen Sie ja immer darauf achten, diese nderungen
vor einem neuen Programmstart zu bersetzen. Bei gleichzeitigen nderungen
in  mehreren  Modulen  kann  es  vorkommen,  da  Sie  dann  ein  Modul  zu
bersetzen vergessen. Bei Definitions„nderungen erhalten Sie dann meistens
eine Fehlermeldung vom Loader (welchen die Shell  dann  anzeigt)  oder  vom
Linker, da  ein  Versionskonflikt  zwischen  den  Modulen  vorliegt.  Im  ungn~
stigeren Fall wird nichts bemerkt und beim Start des Programms machen sich
dann  die  vermeintlichen  nderungen  nicht  bemerkbar,  was  zu  groer
Verwirrung fhren kann.

In diesem F„llen ist es also notwendig, alle betroffenen Module neu zu ber~
setzen. Wei man nicht, welche das sind, ist das dann sehr zeitaufwendig. Ein
Make versucht nun, anhand bestimmter Anhaltspunkte selbst herauszufinden,
welche Module nach erfolgten nderungen neu zu bersetzen sind. Hierzu gibt
es  verschiedene  Verfahren.  So  k”nnte  beispielsweise  der  Editor  jedes
ge„nderte Modul irgendwie markieren, indem es seinen Namen in eine Datei
schreibt. Dann k”nnte das Make diese Module alle compilieren lassen. Da das
Megamax-System  aber  jeden  beliebigen  Editor  zur  Programmentwicklung
zulassen soll, wrde dies Verfahren nicht helfen, weil kein Fremdeditor solch
eine Markierung vornehmen wrde.


Arbeitsweise von Make

Die  einzige  Markierung,  die  jeder  Editor  automatisch  nach  einer  nderung
vornimmt,  liegt  darin,  da  beim  Abspeichern  jedes  ge„nderten  Textes  das
Betriebssystem (GEMDOS) die aktuelle Tageszeit und das Datum der Datei mit
im Inhaltsverzeichnis speichert. So kann jedem Text angesehen werden, wann
er zuletzt - wahrscheinlich  nach  einer  nderung  -  gespeichert  wurde.  Da
ebenso die vom Compiler bersetzten Code-Dateien beim Abspeichern mit der
aktuellen Zeit vermerkt werden, kann das Make durch Vergleich der Zeiten
von Text- und Code-Datei entscheiden, welche Datei jnger ist: Ist ein Text
jnger,  mu  er  compiliert  werden,  wurde  er  daraufhin  bersetzt,  ist  der
resultierende Code jnger, woraufhin das Make beim wiederholten Start nun
alles als aktualisiert erkennt.
2.7  Bedienung: Make und ModRef                                        2 - 70
________________________________________________________


Darin liegt also das prinzipielle Vorgehen beim Megamax-Make. Voraussetzung
ist selbstverst„ndlich, da Datum und Zeit immer stimmen, damit  ein  nach
einer šbersetzung ver„nderter Text auch wirklich eine sp„tere Zeit als die
seines Codes erh„lt. Besitzen Sie einen Mega-ST, brauchen Sie sich  keine
Sorgen  darum  zu  machen,  weil  diese  Rechner  eine  Batterie-gepufferte
Echtzeituhr enthalten, die auch beim Ausschalten des Computers weiterl„uft
(vorausgesetzt,  Sie  haben  auch  eine  geladene  Batterie  eingesetzt).  Den
Besitzern von anderen ST-Computern bieten sich mehrere L”sungen: Auch fr
diese Rechner gibt es einsteckbare, nicht-flchtige Echtzeituhren zu kaufen.
Verfgen Sie nicht ber so einen Zusatz, mssen Sie die Zeit nach jedem
Rechnerstart  (auch  beim  Druck  auf  den  RESET-Taster)  neu  stellen.  Dazu
k”nnen  Sie  beispielsweise  das  bei  Ihrem  Atari  mitgelieferte  Accessory
CONTROL.ACC  verwenden.  Ebensogut  k”nnen  Sie  auch  aus  dem  UTILITY-
Ordner das Programm Timer (Dateiname: TIMER.M) compilieren, linken und als
Accessory mit der Endung ACC auf ihre Boot-Disk kopieren.

Am komfortabelsten fr Anwender ohne Echtzeituhr ist  es,  das  Programm
SetTime aus dem UTILITY-Ordner zu verwenden: Es mu bersetzt und gelinkt
und dann in den AUTO-Ordner kopiert werden. Schalten Sie den Rechner neu
ein, erkennt das Programm, da noch keine gltige Zeit eingestellt ist  und
fordert Sie dazu auf. Wenn Sie dann sp„ter den Rechner neu booten, ohne ihn
auszuschalten  (z.B.  durch  Druck  auf  den  RESET-Taster),  bertr„gt  das
Programm die im Tastatur-Chip des Atari gespeicherte Zeit (die erst beim
Ausschalten des Atari verloren geht) automatisch an das GEMDOS, welches
fr die Zeit der Dateien zust„ndig ist, eine erneute Eingabe bleibt Ihnen damit
erspart.

Das Verfahren des Zeitvergleichs bei den Dateien ist allerdings nicht optimal:
Es kann ja auch vorkommen, da in einem Modultext nur nderungen an der
Dokumentation vorgenommen werden, so da keine Neubersetzung notwendig
w„re. Das ist eben ein kleiner Seiteneffekt, der wohl auch von Ihnen akzeptiert
werden kann, oder? Nebenbei: Achten Sie auf die Dokumentationen  zu  den
mitgelieferten Editoren. So bietet Ihnen beispielsweise der Gepard-Editor die
M”glichkeit, den Text mit "K" zu speichern. Dann wird die vorige Zeit der
Datei beibehalten, so da Make nicht darauf anspricht.

Nun ist das Problem der Markierung von nderungen an den Modulen gel”st.
Aber es gibt noch  ein  weiteres:  ndern  Sie  ein  Definitionsmodul,  das  von
weiteren  Modulen  importiert  wird,  an  denen  Sie  aber  keine  nderungen
vornehmen, mssen diese trotzdem bersetzt werden. Damit das Make dies
erkennen  kann,  mu  es  ber  die  augenblicklichen  Import-Verh„ltnisse  der
beteiligten Module informiert sein. Es bietet sich an, ausgehend vom Haupt~
modul des Programms, alle importierten Module zu beschreiben, wiederum mit
deren Importen usw. Diese Beschreibung erfolgt in einer Datei, die dann vom
Make ausgewertet wird:
2.7  Bedienung: Make und ModRef                                        2 - 71
________________________________________________________


Das Make sieht sich zuerst die Definitionstexte in der Reihenfolge an, in der
sie importiert werden: Die Module, die selbst keine mehr importieren zuerst,
die, die von keinem  anderen  importiert  werden  zuletzt.  Ist  dabei  ein  Text
jnger als sein Code, oder existiert der Code gar noch nicht, wird es zur
šbersetzung markiert. Alle Definitionen, die ein markiertes Modul importieren,
werden  ebenfalls  markiert.  Dann  wird  ebenso  bei  den  Implementationen
verfahren: Ist die eigene Definition oder die eines Imports markiert oder ist
der Text jnger als der Code, bzw. fehlt der Code, wird es auch markiert.
Zuletzt werden alle markierten Module in eine Textdatei geschrieben und das
Make sorgt dafr, da die Module vom Compiler bersetzt werden.


Erstellung einer Make-Datei (ModRef)

In der Make-Datei wird  das  Hauptmodul  mitsamt  aller  importierter  Module
beschrieben. Um solch eine Datei zu erzeugen, kann das Programm ModRef
verwendet werden. Am besten melden Sie ModRef als Tool an (siehe Kap. 2.2,
Batch-Dateien).

Wird ModRef ausgefhrt, zeigt es den GEM-Datei-Selektor, mit dem dann ein
Hauptmodul (blicherweise Dateien mit der Endung "M") ausgew„hlt  werden
kann.  Dann  liest  das  Programm  den  Quelltext  ein  und  registiert  all  seine
Importe. Danach werden all die importierten Module gesucht, und zwar sowohl
die Code-Dateien von Definition und Implementation als auch die zugeh”rigen
Quelltexte.  Dabei  werden  Module  ignoriert,  deren  Definitions-Codes  in  der
unter den Compiler-Parametern eingetragenen Bibliotheks-Datei enthalten sind.
Das hat den Effekt, da solche Module dann nicht mehr vom Make geprft zu
werden brauchen, was bei den in der Bibliothek enthaltenen Megamax-Modulen
auch nicht mehr n”tig ist, da ihre  Codes  sowohl  vorhanden  sind  als  auch
normalerweise nicht ver„ndert werden.

Werden  Texte  von  Modulen  nicht  gefunden,  werden  sie  auch  nicht  in  der
Make-Datei  bercksichtigt,  zur  Sicherheit  erfolgt  aber  ein  Hinweis  vom
ModRef, da es bestimmte Dateien nicht finden konnte. Wenn Sie vor dem
Start  von  ModRef  nur  bestimmte  Verzeichnisse  als  Suchpfade  fr  die
Quelltexte eintragen (z.B. mit Hilfe von PathEdit), k”nnen Sie bequem Modul~
sammlungen fr verschiedene Projekte auseinander halten.

Sind  alle  Importe  festgestellt,  erscheint  der  Datei-Selektor  von  Neuem.
Normalerweise ist nun Abbruch zu w„hlen, woraufhin eine Make-Datei erzeugt
wird, die den Namen des Hauptmoduls tr„gt, jedoch mit der Endung M2M. Die
Datei  wird  im  selben  Verzeichnis  abgelegt  in  der  auch  der  Quelltext  des
Hauptmoduls  steht.  Statt  des  Abbruchs  kann  auch  ein  weiteres  Modul
angew„hlt werden. Dann wird dieses Modul samt seiner Importe ebenfalls in
die Make-Datei aufgenommen. Damit wird erreicht, da bei einem Make auch
zus„tzliche zum Projekt geh”rende Module gemaked werden k”nnen.
2.7  Bedienung: Make und ModRef                                        2 - 72
________________________________________________________


Wollen  Sie  gar  alle  Module  aus  einem  Verzeichnis  in  die  Make-Datei
aufnehmen,  k”nnen  Sie  den  Modulnamen  mit  Wildcards  eingeben,  also
beispielsweise *.M fr alle Hauptmodule des Verzeichnisses.

Mu h„ufig die selbe Make-Datei neu erzeugt werden (s.u.), kann dies ber
einen Batch vereinfacht werden: Schreiben Sie einen Batch, der die folgende
Zeile enth„lt:
  ModRef  <Quelltextnamen>
Melden Sie diese Textdatei (mit Endung M2B!) am besten als Tool an. Wird
dieser Batch ausgefhrt, wird nicht mehr mit dem Datei-Selektor nach dem
Quelltextnamen gefragt, sondern der angegebene verwendet. Es k”nnen auch
mehrere  Textnamen  hintereinander  aufgefhrt  werden,  um  dasselbe  zu
erreichen, wie durch die wiederholte Auswahl mit dem Datei-Selektor.

Es ist darauf zu achten, da bei jeder nderung der Import-Strukturen der
beteiligten  Module  die  Make-Datei  neu  erzeugt  wird!  Wird  dies  vergessen,
arbeitet das Make zwar meist einwandfrei, trotzdem zeigen sich beim Start
des Programms oft Fehler, wie beispielsweise Versionskonflikte.


Anwendung von Make

Das  Make-Programm  heit  MM2Make  und  wird  in  den  Shell-Parametern
eingetragen. Der Aufruf erfolgt, indem eine Make-Datei  (Endung  M2M)  zur
Ausfhrung gebracht wird, indem sie also beispielsweise aus einem Fenster auf
das Ausfhren-Symbol gezogen wird. Selbstverst„ndlich k”nnen Make-Dateien
auch als Tool angemeldet sein.

Einen Sonderstatus geniet die Make-Datei, die als Default-Make eingetragen
ist (unter Info/Umgebung). Sie kann jederzeit durch die Taste M in der Shell
oder durch eine Sonderfunktion beim Verlassen der Editoren (siehe Kapitel 2.3)
aktiviert werden.

Bei  der  Aktivierung  des  Make  wird  zuerst  die  betroffene  Make-Datei
eingelesen,  dann  werden,  wie  oben  beschrieben,  die  Datumseintr„ge  der
Dateien geprft. Am Ende wird eine Datei, die alle zu bersetzenden Texte
auffhrt, unter dem Namen MAKE.M2C im tempor„ren Pfad (einzustellen in
den Shell-Parametern) abspeichert. Sind keine Dateien zu bersetzen, liefert
MM2Make den ExitCode Eins, sonst Null. Daran erkennt die Shell dann, ob sie
daraufhin  den  Compiler  aufrufen  soll.  Der  bersetzt  dann  die  geforderten
Module alle auf einmal.

Zeigt das Make also den Fehler Ausgabedatei konnte nicht angelegt werden an,
liegt es meistens daran, da der tempor„re Pfad nicht auf ein vorhandenes,
beschreibbares Verzeichnis zeigt.
2.7  Bedienung: Make und ModRef                                        2 - 73
________________________________________________________


St”t  der  Compiler  beim  šbersetzen  auf  einen  Fehler,  wird  der  Editor
gestartet, um ihn wie gewohnt anzuzeigen. Ist der Fehler korrigiert, kann das
Make fortgesetzt werden, indem der Editor mit dem Kommando zum Make
verlassen wird. In diesem Fall wird nicht das Default-Make sondern die aktive
Make-Datei wieder verwendet, mit der ein erneuter Make-Aufruf stattfindet.

Wird der Editor nach einem Fehler nicht mit dem Make-Kommando verlassen,
erinnert die Shell daran, da der Make-Vorgang noch nicht abgeschlossen ist,
und bietet Ihnen an, diesen fortzufhren oder abzubrechen.

Sind syntaktische Fehler in der Make-Datei vorhanden, oder k”nnen ben”tigte
Dateien nicht gefunden werden, wird das Make abgebrochen und entweder die
Fehler auf dem Bildschirm angezeigt oder der Editor geladen, um dort den
Fehler in der Make-Datei anzuzeigen.


Alle Module unbedingt bersetzen (Build )

Wollen Sie alle Module einer Make-Datei unabh„ngig von ihrem Datum ber~
setzen, k”nnen Sie dies dem Make-Programm durch šbergabe der Option "-B"
mitteilen. Entweder starten Sie das Make-Programm manuell (im Batch oder
durch Doppelklick) und bergeben in der Argumentzeile den Make-Dateinamen
zusammen mit -B oder Sie tragen -B hinter dem Namen der Make-Datei in
den Umgebungsinformationen ein. Das hat sogar den Vorteil, da  das  "-B"
nach dem Make wieder daraus entfernt wird - denn einmal reicht's ja wohl.


Fehlermeldungen des Make

Zu wenig Speicher.
  Abhilfe: Residente Module/Programme entfernen.
Make-Datei ist leer.
  Die eingelesene Make-Datei enth„lt keine Daten
... hat ungltiges Datum.
  Die Zeit der angezeigten Datei liegt hinter der aktuellen Zeit.
Dateifehler: ...
  Fehler beim Einlesen oder Anlegen der Datei.
Modul ist doppelt deklariert.
  Jedes Modul darf nur einmal in der Make-Datei deklatiert werden.
... wurde nicht oder unvollst„ndig deklariert.
  Das Modul ist bei IMPORT angebeben aber nicht deklariert.
Datei(en) nicht gefunden.
  Die Datei(en) sind nicht auf den entspr. Suchpfaden zu finden.
Ausgabedatei konnte nicht angelegt werden. (Stimmt "Temp.Pfad"?)
  Wahrscheinlich ist der Temp. Pfad in den Shell-Parametern ungltig.
Syntaxfehler.
  Wahrscheinlich wurde zuvor ein Semikolon bei einer Modulliste vergessen.
2.7  Bedienung: Make und ModRef                                        2 - 74
________________________________________________________


Syntax der Make-Dateien

moduldefinition =
  <modulname> ( -IGNORE | codedefinition )

codedefinition =
  ( -MOD | -IMP | -DEF ) <dateiname>
    -MAIN  
  ( -NOSRC | sourcedefinition )

sourcedefinition =
  -SOURCE <dateiname>
    -INC <dateiliste)  
    -USES <dateiliste)  
    -IMPORT <modulliste)  

dateiliste =
    dateiname   ";"

modulliste =
    modulname   ";"

Jedes in der Modulliste (nach -IMPORT) vorkommende  Modul  mu  definiert
sein! Wird es mit -IGNORE definiert, wird es vom Make ignoriert. Mit -INC
k”nnen Dateien bestimmt werden, die mittels der Include-Direktive mit in den
Modulsource eingebettet sind. Mit -USES k”nnen weitere abh„ngige Dateien,
z.B. Resource-Dateien, aufgefhrt werden. -NOSRC besagt, da der Quelltext
zu  diesem  Code  vom  Make  nicht  bercksichtigt  werden  soll.  Die  Kennung
-MAIN sollte nur bei einem Modul auftauchen.  Damit  wird  das  Hauptmodul
markiert, das nach einem erfolgreichen Make-Proze ggf. gestartet werden
kann.
