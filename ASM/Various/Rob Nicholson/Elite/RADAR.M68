* @@@@@@	 @@   @@@@@ 	 @@   @@@@@@
*  @@  @@	@@@@   @@ @@	@@@@   @@  @@
*  @@  @@  @@  @@  @@  @@  @@  @@  @@  @@
*  @@@@@   @@  @@  @@  @@  @@  @@  @@@@@
*  @@ @@   @@@@@@  @@  @@  @@@@@@  @@ @@
*  @@  @@  @@  @@  @@ @@   @@  @@  @@  @@
* @@@  @@  @@  @@ @@@@@    @@  @@ @@@  @@

* Routines to draw the main and mini radar. The main radar doesn't use the
* normal sprite routine as the radar trace as generated by the program.
* As each trace is generated, the area underneath the trace is copied into
* a 'save' buffer. There are two buffers, one for each screen. The format of
* the data stored in these buffers can be found in REMOVE_RADAR. This routine
* copies the data back from the buffer's in reserve order to which they were
* drawn. This is to prevent problems with overlapping traces. The trace's can
* be in any of the 16 colours.

* Atari ST Version 1.0 17th May 1988 Copyright (c) 1988 Mr. Micro Ltd.
* Designed and coded by Rob Nicholson. Adapated from the MSX version.

	include macros
	include bitlist

	xref sqrt,magnitude_table,draw_sprite,check_cockpit,remove_sprite
	xref colour_masks,dot_to_addr,save1_buffer,save2_buffer,max1,max2
	xref find_bitmap

* ---- LOCAL CONSTANTS ----

max_y:			equ 9					maximum y value of blip
blip_x: 		equ 216 				position of mini-radar
blip_y: 		equ 134
x_scale:		equ 62					scaling factors for radar
y_scale:		equ 20
z_scale:		equ 16
radar_x:		equ 159 				centre of main radar
radar_y:		equ 170
radar_ymin: 	equ 137 				limits of radar on screen
radar_ymax: 	equ 191

* ---- LOCAL VARIABLES ----

	vars radar

radar_ptr:		ds.l 1					ptr: next free byte in buffer
line_count: 	ds.w 1					ctr: no. lines drawn (-1)
max_ptr:		ds.l 1					ptr: maximum free address (+1)

	end_vars radar

	module radar

* ********************************************
* **										**
* ** SCALE - SCALE AND TEST A COORD (MACRO) **
* **										**
* ********************************************

* Scales a coord to the radar if within range, otherwise returns.

* Syntax: SCALE reg,scaling_factor

* Entry: reg as required
* Exit:  reg scaled

* Regs: ?
* Subr: ?

scale: macro

	move.l \1,d3						abs(coord)
	if <mi> then.s
		neg.l d3
	endi
	cmp.l radar_scale(a6),d3			within range ?
	ret <hi>							no, return
	muls #\2,\1 						scale coord
	divs radar_scale+2(a6),\1

	endm

* **************************************************
* **											  **
* ** CALC_OFFSET - CALCULATE OFFSET ON MINI-RADAR **
* **											  **
* **************************************************

* Calculates the x or y offset for the mini-radar using the formula:

*		offset = (abs(coord)*scaling)/sqr(coord^2+z^2)

* Entry: D0.L = z coord
*		 D4.L = x or y coord
*		 D5.W = scaling factor
* Exit:  D4.W = offset

* Regs: ?
* Subr: ?

	subr calc_offset

	abs.l d0							abs(z)
	abs.l d4							abs(x or y)
	move.l d0,d6						calculate amount to reduce the
	or.l d4,d6							parameters to fit in 15 bits
	add.l d6,d6
	swap d6
	add d6,d6
	lea magnitude_table,a0
	move (a0,d6),d6
	lsr.l d6,d0 						reduce coords to fit in 15 bits
	lsr.l d6,d4
	mulu d0,d0							add squares
	move d4,d1
	mulu d1,d1
	add.l d1,d0
	if <ne> then.s
		jsr sqrt						take square root
		mulu d5,d4						abs(coord)*scaling_factor
		divu d2,d4						divide by distance
	else
		clr d4							divisor was zero!
	endi

	ret


* ************************************
* **								**
* ** MINI-RADAR - UPDATE MINI-RADAR **
* **								**
* ************************************

* Updates the position of the blip on the small circular radar. This radar
* tracks the position of either the planet or space station. This position of
* the blip within the circle is based upon the angles between the player and
* the object in question. When the object is behind the player, the blip is
* blue else it's green.

* Entry: None
* Exit:  None

* Regs: ?
* Subr: ?

	subr mini_radar,global

	tst witch_space(a6) 				in witch space ?
	ret <ne>							yes, return
	move this_obj(a6),d0				tracking this object ?
	cmp radar_obj(a6),d0
	ret <ne>							no, return
	jsr check_cockpit					check cockpit is displayed
	move.l zpos(a5),d0					calculate y offset
	move.l ypos(a5),d4
	moveq #max_y,d5
	bsr calc_offset
	push d4
	add d4,d4							fetch max_x from table
	lea max_x_table(pc),a0
	move (a0,d4),d5
	move.l zpos(a5),d0					calculate x offset
	move.l xpos(a5),d4
	bsr calc_offset
	pop d5								fetch y offset
	tst.l xpos(a5)						set sign of offsets
	if <mi> then.s
		neg d4
	endi
	tst.l ypos(a5)
	if <pl> then.s						(y is reversed)
		neg d5
	endi
	move.l scr_base(a6),d0				determine which sprite to use
	if.l d0 <eq> screen1_ptr(a6) then.s
		lea radar1_spr(a6),a4
	else
		lea radar2_spr(a6),a4
	endi
	add #blip_x,d4						position sprite
	move d4,sp_xpos(a4)
	add #blip_y,d5
	move d5,sp_ypos(a4)
	moveq #bit_infront,d0				assume object in front
	tst.l zpos(a5)						correct assumption ?
	if <mi> then.s						no
		moveq #bit_behind,d0
	endi
	jsr find_bitmap 					find blob bitmap
	move.l a0,data_ptr(a4)
	jmp draw_sprite 					draw sprite and exit


* *************************************************
* **											 **
* ** REMOVE_RADAR - REMOVE RADAR FROM SCREEN	 **
* **											 **
* *************************************************

* Removes the radar sprites from the current screen. Two 'save' buffers are
* maintained which contains a list of record in the format:

*	dc.l previous			- pointer to previous record
*	dc.l addr				- screen address
*	dc.w offset 			- offset between lines (144 or -176)
*	dc.w depth				- depth (-1)
*	dc.w data_words 		- saved data words

* Note - the width is the no. of words saved, NOT the no. words wide on the
* screen.

* Entry: None
* Exit:  None

* Regs: ?
* Subr: ?

	subr remove_radar,global

	move.l scr_base(a6),d0				decide which buffer to use
	if.l d0 <eq> screen1_ptr(a6) then.s
		move.l last1_ptr(a6),a0
		lea save1_buffer,a1
		lea max1,a2
		lea radar1_spr(a6),a4
	else
		move.l last2_ptr(a6),a0
		lea save2_buffer,a1
		lea max2,a2
		lea radar2_spr(a6),a4
	endi
	move.l a1,radar_ptr(a6) 			set pointer to start & end of buffer
	move.l a2,max_ptr(a6)
	repeat
		move.l a0,d1					end of buffer ?
		break.s if <eq> 				yes
		push.l (a0)+					save pointer to next record
		move.l (a0)+,a1 				fetch screen address
		move.w (a0)+,a2 				fetch offset between lines
		move.w (a0)+,d7 				fetch the depth
		loop 1							restore saved background
			loop 2,d5,4
				move.l (a0)+,(a1)+
			next 2,d5
			add a2,a1
		next 1
		pop.l a0						next record
	endr
	clr.l last_ptr(a6)					no last record
	jmp remove_sprite					remove mini-radar sprite blip


* **********************************
* **							  **
* ** RADAR - DRAW OBJECT ON RADAR **
* **							  **
* **********************************

* Draws the current object on the radar - if visible. Performs the following
* actions:

*	1 - Checks if the object is to be displayed on the radar.
*	2 - Checks if the object is within radar range and scales the coords to
*		the required sizes.
*	3 - Determines whether the trace is being drawn up or down and sets the
*		offset between the lines and the y increment as required.
*	4 - Calculates the screen address.
*	5 - Sets up a pointer to the relevant entry in the head masks table.
*	6 - Sets up the initial body clear and draw masks (from body_masks). It
*		is assumed that the body will be drawn 1st. This might not be the
*		true in the case of a short trace, but then again, life's like that!
*	7 - Checks if there is enough room in the 'save' buffer. The calculation
*		assumes that the full trace will be drawn.
*	8 - Stores any relevant header information in the 'save' buffer.
*	9 - Draws the stick. The routine loops round for each pixel line in the
*		trace, each time checking the y coord for valid values.
*  10 - Stores the actual drawn height in the 'save' buffer and updates the
*		'next free' pointer.

* Entry: A5 = ptr: object record
* Exit:  None

* Regs: ?
* Subr: ?

	subr radar,global

	btst #no_radar,flags(a5)			no radar blip ?
	ret <ne>							yes, return
	tst cockpit_on(a6)					cockpit on ?
	ret <eq>							no, return
	tst invisible(a6)					object invisible (cougar) ?
	ret <ne>							yes, return
	btst #angry,flags(a5)				angry with player ?
	if <ne> then.s						yes
		btst #2,loop_ctr(a6)			flash on and off
		ret <eq>
	endi
	movem.l xpos(a5),d0-d2				fetch object coords
	scale d0,x_scale					scale and check coords
	scale d1,y_scale
	scale d2,z_scale
	exg d1,d2							swap y and z coords
	move #-160,d5						assume drawing up the screen
	moveq #-1,d6
	tst d2								calculate height stick and adjust
	if <mi> then.s						to drawing down in required
		neg d2
		neg d5
		neg d6
	endi
	addq #2,d2
	sub #16,d5							adjust for auto-increment
	add #radar_x,d0 					calculate screen address
	neg d1
	add #radar_y,d1
	move d1,d3
	jsr dot_to_addr
	and #15,d0							point to head and body masks
	asl #2,d0
	lea head_masks(pc),a1
	lea body_masks(pc),a2
	lea (a1,d0),a1
	move.l (a2,d0),d0					start with body (assume)
	move.l d0,d1
	not.l d1
	move.l radar_ptr(a6),a4 			get pointer to next free byte
	move d2,d4							maximum space that could be used =
	asl #4,d4								depth*16+12 (bytes)
	add #12,d4
	ext.l d4							enough room in the buffer ?
	add.l a4,d4
	cmp.l max_ptr(a6),d4
	ret <hi>							no, don't draw
	move.l last_ptr(a6),(a4)			store pointer to previous record
	move.l a4,last_ptr(a6)				this record becomes the last record
	addq.l #4,a4
	move.l a0,(a4)+ 					store screen address
	move.w d5,(a4)+ 					store offset between lines
	push.l a4							save pointer to depth entry
	addq.l #2,a4						skip depth entry (filled in later)
	move ship_type(a5),d4				determine colour of radar blip
	lea blip_colours(pc),a3
	move.b (a3,d4),d4
	lea colour_masks,a3
	asl #3,d4
	lea (a3,d4),a3
	move #-1,line_count(a6) 			initialise line count
	repeat								loop for each pixel line
		break if d3 <lo> #radar_ymin	give up if outside the window
		break if d3 <hi> #radar_ymax
		if d2 <le> #2 then.s			drawing head
			move.l (a1),d0
			move.l d0,d1
			not.l d1
		endi
		swap d0 						left half
		swap d1
		move (a0),(a4)+ 				plane #0
		and d1,(a0)
		move 0(a3),d4
		and d0,d4
		or d4,(a0)+
		move (a0),(a4)+ 				plane #1
		and d1,(a0)
		move 2(a3),d4
		and d0,d4
		or d4,(a0)+
		move (a0),(a4)+ 				plane #2
		and d1,(a0)
		move 4(a3),d4
		and d0,d4
		or d4,(a0)+
		move (a0),(a4)+ 				plane #3
		and d1,(a0)
		move 6(a3),d4
		and d0,d4
		or d4,(a0)+
		swap d0 						right half
		swap d1
		tst d0							any thing to draw ?
		if <ne> then.s					yes
			move (a0),(a4)+ 			plane #0
			and d1,(a0)
			move 0(a3),d4
			and d0,d4
			or d4,(a0)+
			move (a0),(a4)+ 			plane #1
			and d1,(a0)
			move 2(a3),d4
			and d0,d4
			or d4,(a0)+
			move (a0),(a4)+ 			plane #2
			and d1,(a0)
			move 4(a3),d4
			and d0,d4
			or d4,(a0)+
			move (a0),(a4)+ 			plane #3
			and d1,(a0)
			move 6(a3),d4
			and d0,d4
			or d4,(a0)+
		else
			move.l (a0)+,(a4)+			no data, just copy background
			move.l (a0)+,(a4)+
		endi
		add d5,a0						next pixel line
		add d6,d3
		inc line_count(a6)
		dec d2
	until <eq>
	move.l a4,radar_ptr(a6) 			store pointer for next record
	pop.l a4							set depth entry
	move line_count(a6),(a4)

	ret


* ---- LOCAL DATA ----

* Table of maximum x values.

max_x_table:

	dc.w 9,9,9,8,8,7,7,6,4,0

* Head bit masks.

head_masks:

	dc.l %11110000000000000000000000000000	  ;0
	dc.l %01111000000000000000000000000000	  ;1
	dc.l %00111100000000000000000000000000	  ;2
	dc.l %00011110000000000000000000000000	  ;3
	dc.l %00001111000000000000000000000000	  ;4
	dc.l %00000111100000000000000000000000	  ;5
	dc.l %00000011110000000000000000000000	  ;6
	dc.l %00000001111000000000000000000000	  ;7
	dc.l %00000000111100000000000000000000	  ;8
	dc.l %00000000011110000000000000000000	  ;9
	dc.l %00000000001111000000000000000000	  ;A
	dc.l %00000000000111100000000000000000	  ;B
	dc.l %00000000000011110000000000000000	  ;C
	dc.l %00000000000001111000000000000000	  ;D
	dc.l %00000000000000111100000000000000	  ;E
	dc.l %00000000000000011110000000000000	  ;F

* Body bit masks.

body_masks:

	dc.l %11000000000000000000000000000000	  ;0
	dc.l %01100000000000000000000000000000	  ;1
	dc.l %00110000000000000000000000000000	  ;2
	dc.l %00011000000000000000000000000000	  ;3
	dc.l %00001100000000000000000000000000	  ;4
	dc.l %00000110000000000000000000000000	  ;5
	dc.l %00000011000000000000000000000000	  ;6
	dc.l %00000001100000000000000000000000	  ;7
	dc.l %00000000110000000000000000000000	  ;8
	dc.l %00000000011000000000000000000000	  ;9
	dc.l %00000000001100000000000000000000	  ;A
	dc.l %00000000000110000000000000000000	  ;B
	dc.l %00000000000011000000000000000000	  ;C
	dc.l %00000000000001100000000000000000	  ;D
	dc.l %00000000000000110000000000000000	  ;E
	dc.l %00000000000000011000000000000000	  ;F

* Colours of the blips for the different ship types.

blip_colours:

	dc.b yellow 	  trader
	dc.b lgt_blue	  pirate
	dc.b lgt_green	  shuttle
	dc.b magenta	  debris
	dc.b mid_blue	  police
	dc.b orange 	  bounty hunter
	dc.b red		  missile
	dc.b lgt_grey	  alien
