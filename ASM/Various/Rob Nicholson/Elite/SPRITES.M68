*	@@@@  @@@@@@  @@@@@@   @@@@@@  @@@@@@ @@@@@@@	@@@@
*  @@  @@  @@  @@  @@  @@	 @@    @ @@ @  @@	@  @@  @@
*  @@	   @@  @@  @@  @@	 @@ 	 @@    @@ @    @@
*	@@@@   @@@@@   @@@@@	 @@ 	 @@    @@@@ 	@@@@
*	   @@  @@	   @@ @@	 @@ 	 @@    @@ @ 	   @@
*  @@  @@  @@	   @@  @@	 @@ 	 @@    @@	@  @@  @@
*	@@@@  @@@@	  @@@  @@  @@@@@@	@@@@  @@@@@@@	@@@@

* Atari sprite routines for Elite. The sprite routine is also used to place
* bit maps at any position on the screen - not just for moving objects! See
* COMMON.M68 for a description of the sprite record.

* Sprites are used for:

*		1 - The cross-hair cursor on the local and galactic charts
*		2 - The range circle on the galactic chart (uses sprite clipping)
*		3 - The planets on the local chart. The same sprite is used many
*			times to place the bitmap. The background isn't saved.
*		4 - The missile instruments on the cockpit. Again, one sprite is
*			used to display the different missile bit maps.
*		5 - The 'E' and 'S' characters. Two sprites are used for each
*			character - one per screen (total four sprites).
*		6 - The mini-radar blip. Two sprites are used for the dual screen
*		7 - The view text at the top of the cockpit.

* Sprite are NOT used for:

*		1 - The main radar - this is generated by an algorithm.
*		2 - The sights in the main window - for speed purpose, this is a
*			direct copy onto the screen each frame (the window has just
*			been cleared).

* Atari Version 1.0 21st April 1988 Copyright (c) 1988 Mr. Micro Ltd.
* Designed and coded by Rob Nicholson.

	include macros

	xref dot_to_addr,monst,wait_key

* ---- LOCAL CONSTANTS ----

ror_opc:		equ $e07b				ror d0,d3 opcode
rol_opc:		equ $e17b				rol d0,d3 opcode

* ---- LOCAL VARIABLES ----

	vars sprites

mask:			ds.w 1					shift in mask
pl_0:			ds.w 1					shift in for planes
pl_1:			ds.w 1
pl_2:			ds.w 1
pl_3:			ds.w 1
skip_in:		ds.w 1					no. pixels to skip in
skip_down:		ds.w 1					no. pixels to skip down
data_width: 	ds.l 1					width of sprite data
clip_flags: 	ds.w 1					sprite clip flags
l_mask1:		ds.w 1					edge masks
l_mask2:		ds.w 1
r_mask1:		ds.w 1
r_mask2:		ds.w 1
pre_rotate: 	ds.w 1					pre-rotation flag
max_data:		ds.w 1					maximum no. of words
clip_ctr:		ds.w 1					ctr: clip counter
bit_spr:		ds.b sprite_len 		put_bitmap sprite record

	end_vars sprites

	module sprites


* *************************************
* **								 **
* ** KILL_SPRITES - KILL ALL SPRITES **
* **								 **
* *************************************

* Kills all sprites by clearing the 'data saved' flags.

* Entry: None
* Exit:  None

* Regs:  ?
* Subr:  ?

	subr kill_sprites,global

	lea sprite_list(pc),a0				list of sprites
	move #no_sprites-1,d7				loop for each sprite
	loop 1
		move (a0)+,d0
		bclr #back_saved,sp_flags(a6,d0)
	next 1

	ret


* ***********************************************
* **										   **
* ** REMOVE_SPRITE - REMOVE SPRITE FROM SCREEN **
* **										   **
* ***********************************************

* Removes a sprite from the screen by restoring the background.

* Entry: A4 = ptr: sprite record
* Exit:  None

* Regs:  ?
* Subr:  ?

	subr remove_sprite,global

	bclr #back_saved,sp_flags(a4)		background saved ?
	ret <eq>							no, return
	move.l buffer_ptr(a4),a0			get pointer to stored data
	move.l video_ptr(a4),a1 			get pointer to screen
	bsr restore_background				restore the background
	btst #dual_screen,sp_flags(a4)		dual screen sprite ?
	ret <eq>							no, return
	move.l buffer_ptr(a4),a0			get pointer to stored data
	move.l video_ptr(a4),d0 			calculate address in other screen
	move.l flip_screen(a6),d1
	eor.l d1,d0
	move.l d0,a1
	bra restore_background				restore the background


* *******************************************************
* **												   **
* ** RESTORE_BACKGROUND - RESTORE DATA BEHIND A SPRITE **
* **												   **
* *******************************************************

* Restores the data behind a sprite. The data is stored word wide in the
* sprites background buffer.

* Entry: A0 = ptr: saved data
*		 A1 = ptr: video ram address
*		 A4 = ptr: sprite record
* Exit:  A0 = ptr: next word in buffer

* Regs:  D0-D1, D6-D7, A0-A1 corrupt.
* Subr:  None

	subr restore_background

	move sp_width(a4),d1				calculate offset between lines
	inc d1
	asl #3,d1
	sub #160,d1
	neg d1
	move sp_depth(a4),d7				loop for each pixel line
	loop 1
		move sp_width(a4),d6			restore pixel line
		loop 2
			move.l (a0)+,(a1)+
			move.l (a0)+,(a1)+
		next 2,d6
		add d1,a1						next pixel line
	next 1

	ret


* *********************************
* **							 **
* ** DRAW_SPRITE - DRAW A SPRITE **
* **							 **
* *********************************

* Draws a sprite at any pixel position on the screen.

* Entry: A4 = ptr: sprite record
* Exit:  None

* Regs:  All corrupt.
* Subr:  ?

	subr draw_sprite,global

	bsr remove_sprite					remove old sprite
	bsr clip_sprite 					clip the sprite
	move.b d4,clip_flags(a6)			save clip flags
	ret <pl>							not visible, return
	and #15,d4							totally visible ?
	if <eq> then.s						yes
		bsr unclipped_sprite
	else.s
		bsr clipped_sprite
	endi
	btst #dont_save,sp_flags(a4)		save background ?
	if <eq> then.s						yes
		bset #back_saved,sp_flags(a4)	background has been saved
	endi
	btst #dual_screen,sp_flags(a4)		dual screen ?
	if <ne> then.s						yes
		move.l video_ptr(a4),a0 		get source screen address
		move.l a0,d0					calculate address in other screen
		move.l flip_screen(a6),d7
		eor.l d7,d0
		move.l d0,a1
		move sp_depth(a4),d7			copy modified area of screen
		loop 1
			movem.l a0/a1,-(sp)
			move sp_width(a4),d6
			loop 2
				move.l (a0)+,(a1)+
				move.l (a0)+,(a1)+
			next 2,d6
			movem.l (sp)+,a0/a1
			add a3,a0
			add a3,a1
		next 1
	endi

	ret


* *************************************************
* **											 **
* ** UNCLIPPED_SPRITE - DRAW AN UNCLIPPED SPRITE **
* **											 **
* *************************************************

* Draws a sprite without clipping. Note - this routine used self-modifiying
* code to speed up the rotates. A design is made before drawing the sprite as
* to whether rotates left or right are required.

* Entry: (D0,D1) = x,y screen coord
*		 D2 	 = width (in pixels)
*		 D3 	 = depth (in pixels)
*		 A1 	 = ptr: sprite data
* Exit:  None

* Regs:  ?
* Subr:  ?

	subr unclipped_sprite

	jsr dot_to_addr 					calculate screen address
	move.l a0,video_ptr(a4)
	lsr #4,d2							calculate width in words
	dec d2
	move d2,sp_width(a4)
	move d3,d7							calculate depth in pixels
	dec d7
	move d7,sp_depth(a4)
	and #15,d0							calculate no. rotations required
	lea edge_masks(pc),a2				calculate rotation masks
	move d0,d1
	add d1,d1
	move (a2,d1),d1
	move d1,d2
	not d2
	move.l buffer_ptr(a4),a2			get pointer to buffer
	move #160,a3						no. bytes per screen line
	if d0 <ls> #8 then					rotate count <= 8
		move #ror_opc,d3				use rotate right
	else.s
		move #rol_opc,d3				use rotate left
		sub #16,d0						adjust count
		neg d0
	endi
	if d3 <ne> fix1 then.s				need to modifiy
		move d3,fix1					modify rotates ** SMC **
		move d3,fix2
		move d3,fix3
		move d3,fix4
		move d3,fix5
	endi
	loop 1								loop for each pixel line
		push.l a0						save screen address
		move d2,mask(a6)				initialise shift in variables
		clr.l pl_0(a6)
		clr.l pl_2(a6)
		btst #dont_save,sp_flags(a4)	don't save the background ?
		if <ne> then.s					yes
			move.l a0,a2				just copy from screen to screen
		endi
		move sp_width(a4),d6			loop for each word across
		loop 2
			move.l 0(a0),(a2)+			save background in buffer
			move.l 4(a0),(a2)+
			move (a1)+,d3				get mask and rotate
fix1:		ror d0,d3
			move d3,d4					save shift out
			and d1,d3					extract rotated bits
			or mask(a6),d3				combine with shift in
			and d3,0(a0)				clear current setting
			and d3,2(a0)
			and d3,4(a0)
			and d3,6(a0)
			and d2,d4					extract shift out
			move d4,mask(a6)
			move.l pl_0(a6),d5			get shift in bits (planes #0 & #1)
			swap d5
			move (a1)+,d3				draw sprite in plane #0
fix2:		ror d0,d3
			move d3,d4
			and d1,d3
			or d5,d3
			or d3,(a0)+
			and d2,d4
			move d4,d5
			swap d5 					draw sprite in plane #1
			move (a1)+,d3
fix3:		ror d0,d3
			move d3,d4
			and d1,d3
			or d5,d3
			or d3,(a0)+
			and d2,d4
			move d4,d5
			move.l d5,pl_0(a6)			save shift out bits
			move.l pl_2(a6),d5			get shift in bits (planes #2 & #3)
			swap d5
			move (a1)+,d3				draw sprite in plane #2
fix4:		ror d0,d3
			move d3,d4
			and d1,d3
			or d5,d3
			or d3,(a0)+
			and d2,d4
			move d4,d5
			swap d5 					draw sprite in plane #3
			move (a1)+,d3
fix5:		ror d0,d3
			move d3,d4
			and d1,d3
			or d5,d3
			or d3,(a0)+
			and d2,d4
			move d4,d5
			move.l d5,pl_2(a6)			save shift out bits
		next 2,d6
		tst d0							any rotations ?
		if <ne> then.s					yes
			move mask(a6),d3			get mask
			or d1,d3
			move.l pl_0(a6),d4			draw sprite in planes #0 and #1
			move.l (a0),(a2)+
			and d3,0(a0)
			and d3,2(a0)
			or.l d4,(a0)+
			move.l pl_2(a6),d4			draw sprite in planes #2 and #3
			move.l (a0),(a2)+
			and d3,0(a0)
			and d3,2(a0)
			or.l d4,(a0)+
		endi
		pop.l a0						next pixel line
		add a3,a0
	next 1
	tst d0								rotations performed ?
	if <ne> then.s						yes
		inc sp_width(a4)				extra word stored
	endi

	ret


* *********************************************
* **										 **
* ** CLIPPED_SPRITE - DRAW AN CLIPPED SPRITE **
* **										 **
* *********************************************

* Draws a sprite with clipping. Note - this routine used self-modifiying
* code to speed up the rotates. A design is made before drawing the sprite as
* to whether rotates left or right are required.

* Entry: (D0,D1) = x,y screen coord
*		 D2 	 = width (in pixels)
*		 D3 	 = depth (in pixels)
*		 A1 	 = ptr: sprite data
* Exit:  None

* Regs:  ?
* Subr:  ?

	subr clipped_sprite

	jsr dot_to_addr 					calculate screen address
	move.l a0,video_ptr(a4)
	and #15,d0							calculate sprite width in words
	add d2,d0
	dec d0
	lsr #4,d0
	move d0,sp_width(a4)
	move d3,d7							calculate sprite depth in pixels
	dec d7
	move d7,sp_depth(a4)
	move.l data_ptr(a4),a2				calculate data width
	move (a2),d0
	move d0,d6
	mulu #10,d0
	move.l d0,data_width(a6)
	mulu skip_down(a6),d0				clip top edge of data
	add.l d0,a1
	lea edge_masks(pc),a2				edge mask table
	clr pre_rotate(a6)					clear masking flags
	clr l_mask1(a6) 					initialise masks
	clr r_mask1(a6)
	move #-1,l_mask2(a6)
	move #-1,r_mask2(a6)
	btst #0,d4							clipped on left ?
	if <ne> then.s						yes
		move clip_left(a4),d0			any words to skip ?
		and #15,d0
		move skip_in(a6),d1
		sub d0,d1
		dec d1
		if <pl> then.s					yes
			st pre_rotate(a6)			set pre-rotate flag
			lsr #4,d1					skip into data
			sub d1,d6
			dec d6
			mulu #10,d1
			add.l d1,a1
		endi
		add d0,d0						build left edge masks
		move (a2,d0),d0
		move d0,l_mask2(a6)
		not d0
		move d0,l_mask1(a6)
	endi
	btst #1,d4							clipped on right ?
	if <ne> then.s						yes
		move clip_right(a4),d0			build right edge masks
		inc d0
		and #15,d0
		if <ne> then.s
			add d0,d0
			move (a2,d0),d0
		endi
		move d0,r_mask1(a6)
		not d0
		move d0,r_mask2(a6)
	endi
	dec d6								set maximum data word
	move d6,max_data(a6)
	move sp_xpos(a4),d0 				calculate no. rotations required
	and #15,d0
	move d0,d1							calculate rotation masks
	add d1,d1
	move (a2,d1),d1
	move d1,d2
	not d2
	move.l buffer_ptr(a4),a2			get pointer to buffer
	move #160,a3						no. bytes per screen line
	if d0 <ls> #8 then					rotate count <= 8
		move #ror_opc,d3				use rotate right
	else.s
		move #rol_opc,d3				use rotate left
		sub #16,d0						adjust count
		neg d0
	endi
	if d3 <ne> fix11 then.s 			need to modifiy
		move d3,fix11					modify rotates ** SMC **
		move d3,fix12
		move d3,fix13
		move d3,fix14
		move d3,fix15
		move d3,fix16
		move d3,fix17
		move d3,fix18
		move d3,fix19
		move d3,fix20
	endi
	loop 1								loop for each pixel line
		movem.l a0/a1,-(sp) 			save screen and data pointers
		move d2,mask(a6)				initialise shift in variables
		tst pre_rotate(a6)				pre-rotation required ?
		if <eq> then.s					no
			clr.l pl_0(a6)
			clr.l pl_2(a6)
		else.s
			move (a1)+,d3				fetch pre-rotation bits
fix16:		ror d0,d3
			and d2,d3
			move d3,mask(a6)
			move (a1)+,d3
fix17:		ror d0,d3
			and d2,d3
			move d3,pl_0(a6)
			move (a1)+,d3
fix18:		ror d0,d3
			and d2,d3
			move d3,pl_1(a6)
			move (a1)+,d3
fix19:		ror d0,d3
			and d2,d3
			move d3,pl_2(a6)
			move (a1)+,d3
fix20:		ror d0,d3
			and d2,d3
			move d3,pl_3(a6)
		endi
		btst #dont_save,sp_flags(a4)	don't save the background ?
		if <ne> then.s					yes
			move.l a0,a2				just copy from screen to screen
		endi
		clr d6							start with word #0
		repeat
			move.l 0(a0),(a2)+			save background in buffer
			move.l 4(a0),(a2)+
			cmp max_data(a6),d6 		any data left ?
			if <le> then				yes
				move (a1)+,d3			get mask and rotate
fix11:			ror d0,d3
				move d3,d4				save shift out
				and d1,d3				extract rotated bits
				or mask(a6),d3			combine with shift in
				moveq #-1,d5			assume no extra mask
				tst d6					first word ?
				if <eq> then.s			yes
					or l_mask1(a6),d3	OR mask with left edge mask
					and l_mask2(a6),d5	AND mask with data mask
				endi
				cmp sp_width(a4),d6 	last word ?
				if <eq> then.s			yes
					or r_mask1(a6),d3	OR mask with right edge mask
					and r_mask2(a6),d5	AND mask with data mask
				endi
				and d3,0(a0)			clear current setting
				and d3,2(a0)
				and d3,4(a0)
				and d3,6(a0)
				and d2,d4				extract shift out
				move d4,mask(a6)
				move (a1)+,d3			draw sprite in plane #0
fix12:			ror d0,d3
				move d3,d4
				and d1,d3
				or pl_0(a6),d3
				and d5,d3
				or d3,(a0)+
				and d2,d4
				move d4,pl_0(a6)
				move (a1)+,d3			draw sprite in plane #1
fix13:			ror d0,d3
				move d3,d4
				and d1,d3
				or pl_1(a6),d3
				and d5,d3
				or d3,(a0)+
				and d2,d4
				move d4,pl_1(a6)
				move (a1)+,d3			draw sprite in plane #2
fix14:			ror d0,d3
				move d3,d4
				and d1,d3
				or pl_2(a6),d3
				and d5,d3
				or d3,(a0)+
				and d2,d4
				move d4,pl_2(a6)
				move (a1)+,d3			draw sprite in plane #3
fix15:			ror d0,d3
				move d3,d4
				and d1,d3
				or pl_3(a6),d3
				and d5,d3
				or d3,(a0)+
				and d2,d4
				move d4,pl_3(a6)
			else.s
				move mask(a6),d4		get mask
				or d1,d4
				or r_mask1(a6),d4
				move r_mask2(a6),d5 	get data mask
				move pl_0(a6),d3		draw sprite in plane #0
				and d5,d3
				and d4,(a0)
				or d3,(a0)+
				move pl_1(a6),d3		draw sprite in plane #1
				and d5,d3
				and d4,(a0)
				or d3,(a0)+
				move pl_2(a6),d3		draw sprite in plane #2
				and d5,d3
				and d4,(a0)
				or d3,(a0)+
				move pl_3(a6),d3		draw sprite in plane #3
				and d5,d3
				and d4,(a0)
				or d3,(a0)+
			endi
			inc d6						next word
		until d6 <hi> sp_width(a4)
		movem.l (sp)+,a0/a1 			next pixel line
		add a3,a0
		add.l data_width(a6),a1
	next 1

	ret


* ***************************************************
* **											   **
* ** CLIP_SPRITE - CLIPS SPRITE AGAINST THE WINDOW **
* **											   **
* ***************************************************

* Clips the current sprite against the specified window.

* Entry: A4 = sprite record pointer
* Exit:  IF sprite visible THEN
*			Bit 15 of D4 set (i.e. minus)
*			D4 bit 0 : clipped on left
*				   1 : clipped on right
*				   2 : clipped on top
*				   3 : clipped on bottom
*			(D0,D1) = x,y to draw
*			D2		= width to draw in pixels
*			D3		= depth to draw in pixels
*		 ELSE
*			Bit 15 of D4 reset (i.e. positive)
*		 ENDIF

* Regs:  ?
* Subr:  ?

	subr clip_sprite

	clr skip_in(a6) 					clear skip values
	clr skip_down(a6)
	movem sp_xpos(a4),d0/d1 			get x,y coordinate
	move.l data_ptr(a4),a1				get width and depth
	movem (a1)+,d2/d3
	asl #4,d2							convert width to pixels
	clr d4								assume not visible
	btst #clip_me,sp_flags(a4)			clip sprite ?
	if <eq> then.s						no
		bset #7,d4						sprite is visible and not clipped
		rts 							return
	endi
	if d0 <lt> clip_left(a4) then.s 	if sprite starts outside left edge
		sub clip_left(a4),d0			calculate no. pixels to skip in
		neg d0
		move d0,skip_in(a6)
		sub d0,d2						adjust width
		ret <le>						totally off left edge
		move clip_left(a4),d0			move into left edge
		bset #0,d4						clipped on left
	endi
	cmp clip_right(a4),d0				sprite start outside right edge ?
	ret <gt>							yes, don't draw sprite
	move d0,d5							sprite finish outside right edge ?
	add d2,d5
	dec d5
	if d5 <gt> clip_right(a4) then.s	yes
		move clip_right(a4),d2			calculate clipped width
		inc d2
		sub d0,d2
		bset #1,d4						clipped on right
	endi
	if d1 <lt> clip_top(a4) then.s		if sprite starts outside top edge
		sub clip_top(a4),d1 			calculate no. pixels to skip down
		neg d1
		move d1,skip_down(a6)
		sub d1,d3						adjust depth
		ret <le>						totally off top edge
		move clip_top(a4),d1			move into top edge
		bset #2,d4						clipped on top
	endi
	cmp clip_bottom(a4),d1				sprite start outside bottom edge ?
	ret <gt>							yes, don't draw sprite
	move d1,d5							sprite finish outside bottom edge ?
	add d3,d5
	dec d5
	if d5 <gt> clip_bottom(a4) then.s	yes
		move clip_bottom(a4),d3 		calculate clipped depth
		inc d3
		sub d1,d3
		bset #3,d4						clipped on bottom
	endi
	bset #7,d4							sprite is visible

	ret


* ********************************************
* **										**
* ** BUILD_SPRITE - BUILD SPRITE DEFINITION **
* **										**
* ********************************************

* Builds a sprite definition from the screen. The sprite must have been
* drawn at the top left of the screen. The sprite is built up into the 2nd
* half of the screen.

* Entry: D0 = depth of sprite (pixels)
*		 D1 = width of sprite (words)
*		 A4 = ptr: sprite record
* Exit:  None

* Regs: ?
* Subr: ?

	subr build_sprite,global

	move.l scr_base(a6),a0				source = screen base
	lea 16000(a0),a1					destn  = screen base + 16000
	move.l a1,data_ptr(a4)				set sprite data pointer
	move d1,(a1)+						store width and depth
	move d0,(a1)+
	dec d0								adjust counts for DBRA
	dec d1
	loop 1								loop for each pixel line
		push.l a0						save source screen ptr
		move d1,d7						loop for each word
		loop 2
			move 0(a0),d2				build mask
			or 2(a0),d2
			or 4(a0),d2
			or 6(a0),d2
			not d2
			move d2,(a1)+				store mask
			loop 3,d6,4 				store four planes
				move (a0)+,(a1)+
			next 3,d6
		next 2							next word
		pop.l a0						next pixel line
		add #160,a0
	next 1,d0

	ret


* **********************************************
* **										  **
* ** PUT_BITMAP - PUT A BIT MAP ON THE SCREEN **
* **										  **
* **********************************************

* Puts a bit map anywhere on the current screen. Uses the sprite routine. The
* data must in in normal sprite format (i.e. with sizes and mask).

* Entry: (D0,D1) = x,y coords
*		 A0 	 = ptr: bit map data
* Exit:  None

* Regs: ?
* Subr: ?

	subr put_bitmap,global

	lea bit_spr(a6),a4					use temporary sprite record
	bset #dont_save,sp_flags(a4)		don't save the background
	movem d0/d1,sp_xpos(a4) 			set sprite coords
	move.l a0,data_ptr(a4)				set sprite data pointer
	bra draw_sprite 					draw the sprite


* ---- LOCAL DATA ----

* List of all sprite records.

sprite_list:

	dc range_spr,cursor_spr,missile_spr,view_spr,radar1_spr,radar2_spr
	dc hyper_spr

no_sprites: equ (*-sprite_list)/2

* Edge masks for horizontal line.

edge_masks:

	dc.w %1111111111111111
	dc.w %0111111111111111
	dc.w %0011111111111111
	dc.w %0001111111111111
	dc.w %0000111111111111
	dc.w %0000011111111111
	dc.w %0000001111111111
	dc.w %0000000111111111
	dc.w %0000000011111111
	dc.w %0000000001111111
	dc.w %0000000000111111
	dc.w %0000000000011111
	dc.w %0000000000001111
	dc.w %0000000000000111
	dc.w %0000000000000011
	dc.w %0000000000000001
