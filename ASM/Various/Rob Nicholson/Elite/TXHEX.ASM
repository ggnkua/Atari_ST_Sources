comment \
 
@@@@@@ @@   @@  @@  @@ @@@@@@@ @@   @@
@ @@ @  @@ @@   @@  @@  @@   @  @@ @@ 
  @@     @@@    @@  @@  @@ @     @@@  
  @@     @@@    @@@@@@  @@@@     @@@  
  @@    @@ @@   @@  @@  @@ @    @@ @@ 
  @@   @@   @@  @@  @@  @@   @ @@   @@
 @@@@  @@   @@  @@  @@ @@@@@@@ @@   @@
                                       
Transmit hex text file via COM-LINK to terminal. The input file must be in
Motorola S-record format (as generated by QLINK). The hex file is converted
into a binary file during transmission, the format of each record being:

Data record -   dc.l load_address       ; top 8 bits always zero
                dc.b no_bytes
		dc.b data_bytes
		dc.b checksum
End record -    dc.l 0                  ; i.e. load_address = 0
                dc.l run_address
		
Version 2.02 5th June 1988 Copyright (c) 1988 Mr. Micro Ltd.
Designed and coded by Rob Nicholson.

Modification History:

1.0     25/03/88    Original 'bare bones' version.
1.01    12/04/88    Default extension of .HEX is assumed unless specified. File
                    name is displayed in error messages.
1.02    09/05/88    Program modified to work with either the primary printer
                    slot (378H) or the monochrome printer adapter (3BCH).
2.0     20/05/88    Program heavily modified to transmit data in binary format
                    to the ST. Requires RXHEX V2.0 or higher on the ST.
2.01    30/05/88    Size of file displayed at end of transfer.
2.02    05/06/88    Usage message printed when no parameters specified. The
                    file name is converted to upper case. Internal changes
		    made to use STR_XX routines.
\

    include easymac.def                 ; wonderful MACROSS

code segment byte public 'PROG'

    assume cs:code,ds:code,es:code,ss:nothing

    org 100h

first:  jmp main

version:    db "@[#]TXHEX           2.02    05/06/88",0

; **** CONSTANTS ****

display_output  equ 002h                ; DOS:  Display character
serial_output   equ 004h                ;       Serial character output
direct_io       equ 006h                ;       Direct input/output
display_string  equ 009h                ;       Display string
check_keyboard  equ 00bh                ;       check keyboard status
open_file       equ 03dh                ;       open file
close_file      equ 03eh                ;       close file
read_bytes      equ 03fh                ;       read bytes from file
move_file_ptr   equ 042h                ;       move file read/write ptr
wptr            equ word ptr            ; Useful abbreviations
bptr            equ byte ptr
buffer_size     equ 32768               ; size of disk buffer
cr              equ 13                  ; ASCII carraige return
lf              equ 10                  ;       line feed


; **** MACROS ****

; Invoke ROM-BIOS video service.

video macro service

    mov ah,&service
    int 10h

endm

; Invoke DOS service routine.

dos macro service,param

    ifnb <param>
        mov dx,offset &param
    endif
    mov ah,&service
    int 21h

endm

; Print a string of text (zero terminated).

text macro addr

    mov si,offset addr
    call print_string
    
    endm

; **** MAIN PROGRAM ****

    subr main

    text text1                          ; print title
    mov si,offset printer_ports         ; attempt to find a printer

next_port:

    mov dx,[si]                         ; get next port address
    inc si
    inc si
    or dx,dx                            ; end of list ?
    _if <eq>                            ; yes
        mov bx,offset text6             ; print error
	jmp error
    _endif
    _loop ah,0                          ; test for printer port
        mov al,ah
        out dx,al
        in al,dx
        cmp al,ah
	jne next_port
    _next ah
    mov data_port,dx                    ; save port address
    mov cl,ds:80h                       ; any command line parameter ?
    or cl,cl
    _if <eq>                            ; no
        mov si,offset text2             ; print error
	jmp error
    _endif
    dec cl                              ; copy file name into buffer
    xor ch,ch
    mov si,82h
    mov di,offset file_name
    rep movsb
    mov bptr [di],0                     ; terminate string
    mov si,offset file_name             ; search for '.'
    mov ah,'.'
    call str_search
    test al,al                          ; found ?
    _if <eq>                            ; no
        mov si,offset file_name         ; append default extension
	mov di,offset text5
	call str_cat
    _endi
    mov si,offset file_name             ; convert file name to upper case
    call str_upper
    xor al,al                           ; attempt to open file
    dos open_file,file_name
    _if <ct>                            ; error
        text text3                      ; print error message
	mov bx,offset file_name
	jmp error
    _endi
    mov file_handle,ax                  ; save file handle
    text text4                          ; print file name
    mov si,offset file_name
    call print_string
    text text7                          ; print transmitting
    xor cx,cx                           ; disk buffer is empty
    _repeat
        call read_byte                  ; read 'S'
	cmp al,'S'
	_if <ne>
	    jmp file_corrupt
	_endi
	call read_byte                  ; fetch record type
        sub al,"0"                      ; valid type ?
	cmp al,9
	_if <hi>                        ; no
	    mov bx,offset text10
	    jmp error
	_endi
	cbw                             ; execute relevant routine
	add ax,ax
	mov bp,offset record_table
	add bp,ax
	call [bp]
    _until <ct>                         ; until end of file
    mov bx,file_handle                  ; close file
    dos close_file
    text text12                         ; print lowest address
    mov ax,lowest+0
    mov bx,lowest+2
    call hex_long
    text text13                         ; print highest address (adjusted)
    mov ax,highest+0
    mov bx,highest+2
    sub ax,1
    sbb bx,0
    call hex_long
    text text14                         ; print total size
    mov ax,highest+0
    mov bx,highest+2
    sub ax,lowest+0
    sbb bx,lowest+2
    call hex_long
    text text15
    
    int 20h
        
    end_subr main


comment \

************************************
**                                **
** HEADER - PROCESS HEADER RECORD **
**                                **
************************************

Process a Motorola header record - just ignores the record.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

header proc

    _repeat                             ; skip until line feed read
        call read_byte
	cmp al,lf
    _until <eq>
    clc                                 ; not end of file
    
    ret                                 ; return
    
header endp


comment \

******************************************
**                                      **
** DATA_16 - PROCESS 16 BIT DATA RECORD **
**                                      **
******************************************

Processes a data record prefixed by a 16 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

data_16 proc

    call read_hex                       ; read byte count
    sub al,3                            ; remove extra data
    mov bptr record_size,al
    clrw address+2                      ; clear top 16 bits of address
    irp offset,<1,0>                    ; read bottom 16 bits of address
        call read_hex
	mov bptr address+offset,al
    endm
    jmp tx_data                         ; transmit data bytes and return

data_16 endp


comment \

******************************************
**                                      **
** DATA_24 - PROCESS 24 BIT DATA RECORD **
**                                      **
******************************************

Processes a data record prefixed by a 24 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

data_24 proc

    call read_hex                       ; read byte count
    sub al,4                            ; remove extra data
    mov bptr record_size,al
    clrb address+3                      ; clear top 8 bits of address
    irp offset,<2,1,0>                  ; read bottom 24 bits of address
        call read_hex
	mov bptr address+offset,al
    endm
    jmp tx_data                         ; transmit data bytes and return

data_24 endp


comment \

******************************************
**                                      **
** DATA_32 - PROCESS 32 BIT DATA RECORD **
**                                      **
******************************************

Processes a data record prefixed by a 32 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

data_32 proc

    call read_hex                       ; read byte count
    sub al,5                            ; remove extra data
    mov bptr record_size,al
    irp offset,<3,2,1,0>                ; read 32 bit address
        call read_hex
	mov bptr address+offset,al
    endm
    jmp tx_data                         ; transmit data bytes and return

data_32 endp


comment \

****************************************
**                                    **
** END_16 - PROCESS 16 BIT END RECORD **
**                                    **
****************************************

Process a end record prefixed by a 16 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

    subr end_16,global

    call zero_addr                      ; transmit zero address
    clr al                              ; process address (top 16 bits = 0)
    call tx_byte
    call tx_byte
    rept 2
        call read_hex
        call tx_byte
    endm
    stc                                 ; end of file
    
    ret                                 ; return
    
    end_subr end_16


comment \

****************************************
**                                    **
** END_24 - PROCESS 24 BIT END RECORD **
**                                    **
****************************************

Process a end record prefixed by a 24 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

end_24 proc

    call zero_addr                      ; transmit zero address
    clr al                              ; process address (top 8 bits = 0)
    call tx_byte
    rept 3
        call read_hex
        call tx_byte
    endm
    stc                                 ; end of file
    
    ret                                 ; return
    
end_24 endp    
    
    
comment \

****************************************
**                                    **
** END_32 - PROCESS 32 BIT END RECORD **
**                                    **
****************************************

Process a end record prefixed by a 32 bit address.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

end_32 proc

    call zero_addr                      ; transmit zero address
    rept 4                              ; process address
        call read_hex
        call tx_byte
    endm
    stc                                 ; end of file
    
    ret                                 ; return
    
end_32 endp    
    

comment \

***************************************
**                                   **
** ZERO_ADDR - TRANSMIT ZERO ADDRESS **
**                                   **
***************************************

Transmit a zero address to the Atari.

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

zero_addr proc


    call read_hex                       ; skip count
    clr al                              ; transmit zero x 4
    rept 4
	call tx_byte
    endm
    
    ret                                 ; return
    
zero_addr endp


comment \

***********************************
**                               **
** TX_DATA - TRANSMIT DATA BYTES **
**                               **
***********************************

Transmits data bytes to Atari.

Entry: AH = byte counter
Exit:  None

Regs: ?
Subr: ?

\

    subr tx_data

    irp offset,<3,2,1,0>                ; transmit address
        mov al,bptr address+offset
	call tx_byte
    endm
    mov ax,address+0                    ; lowest address yet ?
    mov dx,address+2
    sub ax,lowest+0
    sbb dx,lowest+2
    _if <ct>                            ; yes
        movw lowest+0,address+0
	movw lowest+2,address+2
    _endi
    mov ax,record_size                  ; add record size to address
    add address+0,ax
    _if <ct>
        inc address+2
    _endi
    mov ax,address+0                    ; highest address yet ?
    mov dx,address+2
    sub ax,highest+0
    sbb dx,highest+2
    _if <cf>                            ; yes
        movw highest+0,address+0
	movw highest+2,address+2
    _endi
    mov ah,bptr record_size             ; transmit no. bytes
    mov al,ah
    call tx_byte
    clrb checksum                       ; clear the checksum
    _loop                               ; loop for each byte
        call read_hex                   ; read byte
	call tx_byte                    ; transmit byte
	add checksum,al                 ; add to checksum
    _next ah                            ; next byte
    mov al,checksum                     ; transmit checksum
    call tx_byte
    call read_byte                      ; skip checksum in file
    call read_byte
    call read_byte                      ; skip CRLF
    call read_byte
    clc                                 ; no end of file
    
    ret                                 ; return
    
    end_subr tx_data


comment \

*************************************************
**                                             **
** READ_HEX - READ A BYTE STORED AS HEX DIGITS **
**                                             **
*************************************************

Reads a byte stored as two hex digits.

* Entry: None
* Exit:  AL = byte

* Regs: ?
* Subr: ?
    
\

    subr read_hex

    call read_byte                      ; read high nibble
    sub al,"0"                          ; convert to binary
    cmp al,10
    _if <hi>
        sub al,7
    _endi
    shl al,1                            ; shift into high nible
    shl al,1
    shl al,1
    shl al,1
    push ax                             ; read low nibble
    call read_byte
    sub al,"0"                          ; convert to binary
    cmp al,10
    _if <hi>
        sub al,7
    _endi
    pop dx                              ; combine nibbles
    or al,dl
    
    ret                                 ; return
    
read_hex endp    
    

comment \

*****************************
**                         **
** TX_BYTE - TRANSMIT BYTE **
**                         **
*****************************

Action: Transmits a byte via the Com-Link to the terminal

Entry:  AL = byte to transmit
Exit:   None

Regs:   DX and flags corrupt.
Subr:   None

\

    subr tx_byte
    
    push ax                             ; save byte
    mov dx,data_port                    ; output data byte
    out dx,al
    inc dx                              ; strobe on
    inc dx
    clr al
    out dx,al
    mov ah,al                           ; clear timeout counter
    dec dx                              ; wait for ACK
    _repeat
        dec ah                          ; timeout ?
	_if <eq>                        ; yes
	    call timeout_check
	_endi
        in al,dx                        ; repeat until acknowledged
	and al,64
    _until <eq>
    inc dx                              ; clear strobe
    inc al
    out dx,al
    dec dx                              ; wait for no ACK
    _repeat
        in al,dx
	and al,64
    _until <ne>
    pop ax                              ; restore byte
    
    ret                                 ; return
    
tx_byte endp


comment \

***********************************************
**                                           **
** TIMEOUT_CHECK - CHECK KEYBOARD ON TIMEOUT **
**                                           **
***********************************************

Checks the keyboard when timeout occurs.

Entry: None
Exit:  None

Regs: BX, CX and DX preserved.
Subr: INT 21

\

timeout_check proc

    save <bx,cx,dx>                     ; save registers
    mov dl,255                          ; key pressed ?
    dos direct_io
    _if <ne>                            ; yes
        cmp al,3                        ; break ?
	_if <eq>                        ; yes
	    mov dx,data_port            ; clear strobe
	    inc dx
	    inc dx
	    mov al,1
	    out dx,al
	    mov bx,offset text8         ; print error
	    jmp error
	_endi
    _endi
    xor ah,ah                           ; clear timeout counter
    restore <dx,cx,bx>                  ; restore registers
    
    ret                                 ; return
    
timeout_check endp    


comment \    

***************************************
**                                   **
** READ_BYTE - READ A BYTE FROM DISK **
**                                   **
***************************************

Reads a byte from the disk buffer, filling it up from the disk if required.

Entry:  CX = no. bytes left in buffer (set to zero at start)
        BX = ptr: disk buffer
Exit:   None

Regs:   ?
Subr:   ?

\

    subr read_byte

    test cx,cx                          ; anything left in the buffer ?
    _if <eq>                            ; no
        push ax                         ; save counter
        mov cx,buffer_size              ; try and fill the buffer from disk
        mov dx,offset buffer
        mov bx,file_handle
        dos read_bytes
	_if <ct>                        ; disk error
	    mov bx,offset text11
	    jmp error
	_endif
        test ax,ax                      ; end of file ?
        _if <eq>                        ; yes
	    mov bx,offset text10
	    jmp error
	_endi
        mov bx,offset buffer            ; reset file pointer
        mov cx,ax                       ; no. bytes left
	pop ax                          ; restore counter
    _endi
    dec cx                              ; reduce no. bytes left in buffer
    mov al,[bx]                         ; fetch next byte
    inc bx

    ret                                 ; return

read_byte endp


comment \

*******************************************
**                                       **
** PRINT_STRING - PRINT A STRING OF TEXT **
**                                       **
*******************************************

Prints a string of text for the screen.

Entry: DS:SI = ptr: ASCIIZ string to print.
Exit:  None

Regs: ?
Subr: ?

\
    
    subr print_string

    _while
        mov al,[si]                     ; end of string ?
	inc si
	test al,al
	_is <ne>                        ; no
	    call print_char             ; print character
    _wend
    
    ret                                 ; return
    
    end_subr print_string


comment \

*****************************************
**                                     **
** HEX_LONG - PRINT A LONG WORD IN HEX **
**                                     **
*****************************************

Prints a long word (24 bits) in hex.

Entry: BL+AX = 24 bit number (AX=low word)
Exit:  None

Regs: ?
Subr: ?

\

    subr hex_long

    xchg ax,bx                          ; print bits 16..23
    call hex_byte
    xchg ax,bx                          ; print bits 8..15
    xchg al,ah
    call hex_byte
    xchg al,ah                          ; print bits 0..7
    call hex_byte
    
    ret                                 ; return
    
    end_subr hex_long
    

comment \

************************************
**                                **
** HEX_BYTE - PRINT A BYTE IN HEX **
**                                **
************************************

Prints a byte in hex to the console.

Entry: AL = byte to print
Exit:  None

Regs: All preserved
Subr: HEX_DIGIT

\

    subr hex_byte
    
    save <ax,ax>                        ; save AX
    rept 4                              ; print high nibble
        ror al,1
    endm
    call hex_nibble
    pop ax                              ; print low nibble
    call hex_nibble
    pop ax                              ; restore AX
    
    ret                                 ; return    
    
    end_subr hex_byte
    

comment \

****************************************
**                                    **
** HEX_NIBBLE - PRINT A NIBBLE IN HEX **
**                                    **
****************************************

Prints a nibble (4 bits) in hex.

Entry: AL = hex nibble (top four bits ignored)
Exit:  None

Regs: AL corrupt,
Subr: PRINT_CHAR

\

    subr hex_nibble
    
    and al,15                           ; mask out unwanted bits
    cmp al,10                           ; convert to ASCII
    sbb al,69h
    das
    jmp print_char                      ; print character
    
    end_subr hex_nibble
    

comment \

************************************
**                                **
** PRINT_CHAR - PRINT A CHARACTER **
**                                **
************************************

Prints a character to the screen.

Entry: AL
Exit:  None

Regs: All preserved.
Subr: INT 21

\

    subr print_char

    save <ax,bx,cx,dx,si,di>            ; save registers
    mov dl,al                           ; print character
    dos display_output
    restore <di,si,dx,cx,bx,ax>         ; restore registers
    
    ret                                 ; return
    
    end_subr print_char


comment \

**********************************************
**                                          **
** STR_SEARCH - SEARCH STRING FOR CHARACTER **
**                                          **
**********************************************

Searches a string for a specified character.

Entry:  DS:SI = ptr: string to search
Exit:   IF character found THEN
            AL = character
	    SI = ptr: position in string
	ELSE
	    AL = 0
	ENDI

Regs: AH/SI corrupt.
Subr: None

\

    subr str_search
    
    _repeat
        lodsb                           ; fetch character
	cmp ah,al                       ; character found ?
	_break_if <eq>                  ; yes, exit search
	test al,al                      ; until end of string
    _until <eq>
    
    ret                                 ; return
    
    end_subr str_search
    

comment \

***********************************
**                               **
** STR_CAT - CONCATINATE STRINGS **
**                               **
***********************************

Concatinates (adds together) two strings. Make sure the base string is large
enough for both strings!

Entry: DS:SI = base string
       DS:DI = string to add
Exit:  None

Regs: AL/CX/SI/DI/ES corrupt.
Subr: None

\

    subr str_cat
    
    xchg si,di                          ; find the final zero
    mov cx,-1
    clr al
    repnz scasb
    dec di                              ; copy string onto base string
    _repeat
        lodsb
	stosb
	test al,al
    _until <eq>
    
    ret                                 ; return
    
    end_subr str_cat


comment \

**********************************************
**                                          **
** STR_UPPER - CONVERT STRING TO UPPER CASE **
**                                          **
**********************************************

Converts a string of characters to upper case.

Entry: DS:SI = ptr: ASCIIZ string to convert
Exit:  DS:SI = ptr: byte after final zero

Regs: ?
Subr: ?

\

    subr str_upper
    
    _repeat
        mov al,[si]                     ; fetch next character
	cmp al,'a'                      ; lower case ?
	_if <hs>                        ; maybe
	    cmp al,'z'
	    _if <ls>                    ; yes
	        sub bptr [si],32        ; convert to upper case
	    _endi
	_endi
	inc si                          ; until end of string
	test al,al
    _until <eq>
    
    ret
    
    end_subr str_upper


comment \

*************************************
**                                 **
** FILE_CORRUPT - HEX FILE CORRUPT **
**                                 **
*************************************

This routine is called whenever a record header in the range S4 to S6 is
encountered (which should never happen).

Entry: None
Exit:  None

Regs: ?
Subr: ?

\

file_corrupt proc

    mov bx,offset text10                ; print error message
    
error:

    call print_string                   ; print string    
    int 20h                             ; exit program
    
file_corrupt endp    

; **** VARIABLES ****

file_name       db 128 dup (?)          ; file name buffer
file_handle     dw 1 dup(?)             ; files handle (DOS)
checksum        db 0,0                  ; file checksum
data_port       dw 0                    ; data port address
line_buffer     db 128 dup (?)          ; input line buffer
address         dw 0,0                  ; record address
lowest          dw -1,-1                ; lowest address yet
highest         dw 0,0                  ; highest address yet
record_size     dw 0                    ; size of record

; **** LOCAL DATA ****

; List of printer port addresses

printer_ports: dw 378h,3bch,0

; Table of vectors for each record type.

record_table label word

    dw offset header
    dw offset data_16,offset data_24,offset data_32
    dw offset file_corrupt,offset file_corrupt,offset file_corrupt
    dw offset end_16,offset end_24,offset end_32
    
text1:  db "TXHEX V2.02 (c) 1988 Mr. Micro Ltd.",10,13,10,0
text2:  db "Usage: TXHEX <file_name>",10,13,10
        db "Where: <file_name> = name of the file to transmit. Default",10,13
	db "                     extension is .HEX",10,13,10
        db "Transmits a hex file to the Atari via the printer port of",10,13
	db "the IBM PC. The hex file is converted into binary format",10,13
	db "during transmitting. RXHEX version 2.0 or higher must be used",10,13
	db "on the Atari ST",0
text3:  db 7,"Unable to open ",0
text4:  db "File: ",0
text5:  db ".hex",0
text6:  db 7,"Unable to find printer port!",0
text7:  db ", transmitting .. ",0
text8:  db 7," *BREAK*",10,13,0
text10: db 7,"** FILE CORRUPTED **",0
text11: db 7,"** DISK ERROR **",0
text12: db 16 dup(8)
        db "$",0
text13: db " to $",0
text14: db " = $",0
text15: db " bytes sent.",13,10,0


buffer:

code ends

    end first
  
