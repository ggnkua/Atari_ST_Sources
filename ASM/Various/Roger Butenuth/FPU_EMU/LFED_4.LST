PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   1
Source File: D:\PC\FPU_EMU\LFED_4.S

   1                                    ;---------------------------------------------------------------------
   2                                    ;Programm-/Routinen-Name:	Line-F Emulation Driver / LFED
   3                                    ;						 Version 1.00
   4                                    ;Datum: 15.02.92
   5  
   6                                    ;Aufgabe/Kurzdoku: Line-F-Emulator fÅr die Benutzung eines MC68881
   7                                    ;in einem Atari ST/STE mit MC68000 (also auch der SFP004-Karte).
   8                                    ;Mit LFED ist die Nutzung der FPU in vollem Umfang gewÑhrleistet und
   9                                    ;kann von jedem Programm angesprochen werden, welches FPU-UnterstÅtzung
  10                                    ;verlangt. MC68030 (TT) optimierte Programme sind hiervon natÅrlich
  11                                    ;ausgenommen, da der MC68000 dessen InstructionSet nicht versteht!
  12  
  13                                    ;Wird ein MC68882 als FPU genutzt, mÅssen einige kleinere Anpassungen
  14                                    ;vorgenommen werden, da dieser an verschiedenen Stellen öbertragungen
  15                                    ;des PC's erwartet.
  16  
  17                                    ;Author: Roger Butenuth (c't 04/90 Seite 430 ff.)
  18                                    ;		 Michael Hauschild (XBRA-Erweiterungen und alle folgenden
  19                                    ;		 Versionen)  
  20  
  21                                    ;	(c)	Smart Systems '92
  22                                    ;		Windhornstraûe 2 / 3016 Seelze 1
  23                                    ;		Telefon (05137) 9 20 09
  24  
  25                                    ;Dokumentation: 
  26  
  27                                    ;Der Treiber installiert sich unter Beachtung des XBRA-Protokolls, 
  28                                    ;d.h. er erkennt sein Vorhandensein und gibt eine Meldung aus, falls
  29                                    ;versucht wird, ihn erneut zu installieren.
  30  
  31                                    ;Nicht unterstÅtzte FPU-Befehle:
  32  
  33                                    ;	FTRAP, FSAVE, FRESTORE
  34  
  35                                    ;Erkannte BUGS in Version 1.00:
  36  
  37                                    ;	FMOVE (An),FP0-FPn  ... dieser ist eigentlich kein BUG !
  38  
  39                                    ;	Es tritt ein BUS-Error beim Terminieren von Programmen auf, die
  40                                    ;	die FPU nutzen und fÅr das Terminieren die C-Funktion return() 
  41                                    ;	verwenden. Der Grund hierfÅr ist ein Restore der FPU-Register
  42                                    ;	mit FMOVEM (diese werden am Programmbegin gesichert). Man kann
  43                                    ;	dieses SAUBER umgehen, indem man aus FPU-nutzenden Funktionen
  44                                    ;	mit exit() zurÅckkehrt - dann sollte auch kein Bus-Error mehr
  45                                    ;	auftreten (siehe FPU_TST2.C oder auch BGIDEMO.C)
  46  
  47                                    ;ACHTUNG: bei den Assembler-Options muû -S Flag gesetzt werden 
  48                                    ;(wegen ReTurn from Exception / RTE) ! 
  49  
  50                                    ;Letzte énderung:
  51                                    ;	19.05.92	Freigabe der Version 1.00, da der BUG mit FMOVE und
  52                                    ;				return(0) gefixt ist!
  53  
  54                                    ;---------------------------------------------------------------------
  55                                    ;-------------- macro - definitions ----------------------------------
  56  
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   2
Source File: D:\PC\FPU_EMU\LFED_4.S

  57                                    .MACRO Supexec
  58                                    	move.w		#38,-(sp)		;Supexec()
  59                                    	trap		#14				;XBIOS
  60                                    	addq.l		#6,sp			;Stack aufrÑumen
  61                                    .ENDM			
  62                                    		
  63                                    ;-------------- set FPU-register-addresses ---------------------------
  64                                    	
  65                                    response 	equ 	$fffa40	;in a6 (Coprozessor-Basisregister)
  66                                    control		equ		$02		;Alle weiteren Register relativ zu
  67                                    save		equ		$04		;response
  68                                    restore		equ		$06		
  69                                    command		equ		$0a		;in a5
  70                                    condition	equ		$0e
  71                                    operand		equ		$10		;in a4
  72                                    reg_selec	equ		$14
  73                                    ins_add		equ		$18
  74                                    lineF		equ		$2c		;Line-F / TRAP-No. 11
  75  
  76                                    ;-------------- start of code ----------------------------------------
  77  
  78                                    			.TEXT
  79 00000000' 4879 00000000'           			pea.l		Install			;Installations-Routine
  80                                    			Supexec						;SVC
  58 00000006' 3F3C 0026               +	move.w		#38,-(sp)		;Supexec()
  59 0000000A' 4E4E                    +	trap		#14				;XBIOS
  60 0000000C' 5C8F                    +	addq.l		#6,sp			;Stack aufrÑumen
  81 0000000E' B2BC 4C46 4544           			cmp.l		#"LFED",d1		;ist "LFED" ?
  82 00000014' 6700 0424                			beq			Terminate		;ja -> dann terminieren
  83                                    			
  84 00000018' 4879 00000000`           start:		pea.l		titel			;Titel-Daten holen
  85 0000001E' 3F3C 0009                			move.w		#9,-(sp)		;Cconws 
  86 00000022' 4E41                     			trap		#1				;GEMDOS-Call
  87 00000024' 5C8F                     			addq.l		#6,sp			;Stack-Korrektur
  88                                    	
  89 00000026' 4879 00000000'           			pea			setvec			;Im Supervisormodus Vektor setzen
  90                                    			Supexec						;SVC
  58 0000002C' 3F3C 0026               +	move.w		#38,-(sp)		;Supexec()
  59 00000030' 4E4E                    +	trap		#14				;XBIOS
  60 00000032' 5C8F                    +	addq.l		#6,sp			;Stack aufrÑumen
  91                                    						
  92 00000034' 206F 0004                			movea.l		4(sp),a0		;Basepageadresse holen
  93 00000038' 223C 0000 0100           			move.l		#$100,d1		;BasepagelÑnge
  94 0000003E' D2A8 000C                			add.l		$0c(a0),d1		;+TextlÑnge
  95 00000042' D2A8 0014                			add.l		$14(a0),d1		;+DatenlÑnge
  96 00000046' D2A8 001C                			add.l		$1c(a0),d1		;+BSS-LÑnge
  97 0000004A' 2F01                     			move.l		d1,-(sp)		;LÑnge des belegten Speichers
  98 0000004C' 3F3C 0031                			move.w		#$31,-(sp)		;an GEMDOS melden
  99 00000050' 4E41                     			trap		#1
 100                                    			
 101 00000052' 23F8 002C 00000000'      setvec:		move.l		lineF,oldtrap	;Alten Line-F-Vektor retten
 102 0000005A' 21FC 00000000'002C       			move.l		#newtrap,lineF	;Neuen Line-F-Vektor setzen
 103 00000062' 4E75                     			rts
 104                                    			
 105 00000064' 5842 5241                xb_magic:	.dc.b		"XBRA"			;XBRA-Struktur vor neuem Trap
 106 00000068' 4C46 4544                xb_id:		.dc.b		"LFED"			;XBRA-Kennung
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   3
Source File: D:\PC\FPU_EMU\LFED_4.S

 107  
 108 0000006C' 0000 0000                oldtrap:	.dc.l		0				;Platz fÅr alten Line-F-Vektor
 109  
 110                                    ;-------------- lineF-handler -----------------------------------------
 111  
 112 00000070' 23C1 00000000"           newtrap:	move.l		d1,rd1			;D1 retten (nur fÅr eigenen Trap)
 113 00000076' 222F 0002                			move.l		2(sp),d1		;PC nach D1
 114 0000007A' B2BC 00FC 0000           			cmp.l		#$fc0000,d1		;PC-ROM-Anfang
 115 00000080' 6D 08                    			blt.s		my_trap			;PC<ROM-Anfang -> kam aus dem RAM
 116 00000082' 2079 00000000'           			movea.l		oldtrap,a0		;Adresse der alten Trap-Routine
 117 00000088' 4ED0                     			jmp			(a0)			;Alte Routine anspringen
 118  
 119 0000008A' 2239 00000000"           my_trap:	move.l		rd1,d1			;D1 zurÅckholen
 120 00000090' 48F9 7FFF 00000000"      			movem.l		d0-a6,dregs		;Register retten
 121 00000098' 4E68                     			move.l		usp,a0			;USP retten
 122 0000009A' 23C8 00000000"           			move.l		a0,rusp			;Åber Umweg
 123 000000A0' 4DF9 00FF FA40           			lea			response,a6		;#response nach A6
 124 000000A6' 4BEE 000A                			lea			command(a6),a5	;#command  nach A5
 125 000000AA' 49EE 0010                			lea			operand(a6),a4	;#operand  nach A4
 126 000000AE' 47F9 00000000"           			lea			dregs,a3		;#dregs    nach A3
 127 000000B4' 206F 0002                			movea.l		2(sp),a0		;PC nach A0
 128 000000B8' 3210                     			move.w		(a0),d1			;Kommando nach D1
 129 000000BA'                          again:				;-------- Einsprung fÅr weitere FPU-Befehle
 130 000000BA' C27C 01C0                			and.w		#%0000000111000000,d1	;Spezialteil ausmaskieren
 131 000000BE' 6600 012C                			bne			spezial			;Ein Bit gesetzt->Spezialbefehl
 132 000000C2' 3228 0002                			move.w		2(a0),d1		;zweiten Befehlsteil in D1 merken
 133 000000C6' 3A81                     			move.w		d1,(a5)			;Befehl in FPU schreiben (A3==#command)
 134 000000C8'                          do_ca:				;-------- Einsprung fÅr weiter Nachfragen an FPU
 135 000000C8' 3016                     			move.w		(a6),d0			;Response lesen
 136 000000CA' 0800 000C                			btst		#12,d0			;erstes Modusbit testen
 137 000000CE' 6600 00C0                			bne			rw_1x			;==1 -> springen
 138 000000D2' 0800 000B                			btst		#11,d0			;zweites Modusbit testen
 139 000000D6' 67 3A                    			beq.s		rw_00			;==0 -> springen
 140                                    			;-------- %xxx01, Null-Primitive/Transfer Single CPU-Register
 141 000000D8' 0800 000A                			btst		#10,d0			;Register Åbertragen?
 142 000000DC' 66 28                    			bne.s		rw_sngl			;JA -> Transfer Single CPU-Register
 143 000000DE' 0800 000F                			btst		#15,d0			;CA (Come Again) gesetzt?
 144 000000E2' 66 E4                    			bne.s		do_ca			;JA -> weiter fragen, sonst fertig
 145 000000E4' 5888                     			addq.l		#4,a0			;A0 um reine BefehlslÑnge weiter
 146                                    					;(Alles andere wurde in calc_add erledigt)
 147 000000E6' 3210                     			move.w		(a0),d1			;erstes Befehlswort holen
 148 000000E8' 3001                     			move.w		d1,d0			;und nach D0
 149 000000EA' C07C F000                			and.w		#$f000,d0		;wieder COP-Befehl?
 150 000000EE' 0A40 F000                			eor.w		#$f000,d0
 151 000000F2' 67 C6                    			beq.s		again			;JA -> direkt weiter machen
 152 000000F4' 2F48 0002                			move.l		a0,2(sp)		;neuen PC eintragen
 153 000000F8' 2079 00000000"           			movea.l		rusp,a0			;USP wieder restaurieren
 154 000000FE' 4E60                     			move.l		a0,usp			;wieder Åber Umweg
 155 00000100' 4CD3 7FFF                			movem.l		(a3),d0-a6		;Register restaurieren
 156 00000104' 4E73                     			rte							;Trap beenden
 157  
 158 00000106' C27C 0070                rw_sngl:	and.w		#%1110000,d1	;Registernummer ausmaskieren (nur Dn)
 159 0000010A' E449                     			lsr.w		#2,d1			;D1=Nummer*4
 160 0000010C' 28B3 1000                			move.l		(a3,d1.w),(a4)	;Register Åbertragen (a4==#operand,a3==#dregs)
 161 00000110' 60 B6                    			bra.s		do_ca			;danach kommt immer noch etwas
 162                                    			
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   4
Source File: D:\PC\FPU_EMU\LFED_4.S

 163 00000112'                          rw_00:		;-------- %xxx00, Transfer multiple coprocessor registers
 164 00000112' 6100 01DE                			bsr 		calc_add		;Operandenadresse nach A1 holen
 165 00000116' 382E 0014                			move.w		reg_selec(a6),d4	;Registerliste nach D4 holen
 166 0000011A' 0800 000D                			btst		#13,d0			;Dr-Bit testen
 167 0000011E' 67 36                    			beq.s		w_00			;==0 -> Daten in FPU schreiben
 168                                    						
 169 00000120' 0800 000C                			btst		#12,d0			;Predekrementmodus?
 170 00000124' 67 12                    			beq.s		r_pred			;==0 -> ja, springen
 171                                    			
 172 00000126' 7007                     			moveq		#7,d0			;SchleifenzÑhler fÅr 8 Bits
 173                                    			
 174 00000128' E34C                     .l_1:		lsl.w		#1,d4			;ein Bit ins Carry
 175 0000012A' 64 06                    			bcc.s		.l_2 			;nur bei Bit==1 etwas machen
 176 0000012C' 22D4                     			move.l		(a4),(a1)+		;1 (A4==#operand)
 177 0000012E' 22D4                     			move.l		(a4),(a1)+		;2
 178 00000130' 22D4                     			move.l		(a4),(a1)+		;3 Langworte fÅr jedes Register
 179 00000132' 51C8 FFF4                .l_2:		dbra		d0,.l_1			;fÅr alle 8 Bits
 180  
 181 00000136' 6090                     			bra			do_ca			;nochmal FPU befragen
 182                                    			
 183 00000138' 7007                     r_pred:		moveq		#7,d0			;SchleifenzÑhler fÅr 8 Bits
 184  
 185 0000013A' E34C                     .l_1:		lsl.w		#1,d4			;ein Bit ins Carry
 186 0000013C' 64 0A                    			bcc.s		.l_2			;nur bei Bit==1 etwas machen
 187 0000013E' 22D4                     			move.l		(a4),(a1)+		;1 (A4==#operand)
 188 00000140' 22D4                     			move.l		(a4),(a1)+		;2
 189 00000142' 22D4                     			move.l		(a4),(a1)+		;3 Langworte fÅr jedes Register
 190 00000144' 92FC 0018                			suba.w		#24,a1			;Dekrement durchfÅhren
 191 00000148' 51C8 FFF0                .l_2:		dbra		d0,.l_1			;fÅr alle 8 Bits
 192  
 193 0000014C' D2FC 000C                			adda.w		#12,a1			;A1 wieder auf letztes Register
 194 00000150' 2489                     			move.l		a1,(a2)			;A1 als Registerinhalt abspeichern
 195  
 196 00000152' 6000 FF74                			bra			do_ca			;Nochmal FPU fragen
 197                                    			
 198 00000156' 3010                     w_00:		move.w		(a0),d0			;erstes Befehlswort holen
 199 00000158' C038 0038                			and.b		%111000,d0		;Adressierungsart maskieren
 200 0000015C' B038 0018                			cmp.b		%011000,d0		;Gleich (An)+ ?
 201 00000160' 67 14                    			beq.s		w_post			;JA -> Postinkrementmodus
 202  
 203 00000162' 7007                     			moveq		#7,d0			;SchleifenzÑhler fÅr 8 Bits
 204  
 205 00000164' E34C                     .l_1:		lsl.w		#1,d4			;ein Bit ins Carry
 206 00000166' 64 06                    			bcc.s		.l_2			;nur bei Bit==1 etwas machen
 207 00000168' 2899                     			move.l		(a1)+,(a4)		;1 (A4==#operand)
 208 0000016A' 2899                     			move.l		(a1)+,(a4)		;2
 209 0000016C' 2899                     			move.l		(a1)+,(a4)		;3 Langworte fÅr jedes Register
 210 0000016E' 51C8 FFF4                .l_2:		dbra		d0,.l_1			;fÅr alle 8 Bits
 211  
 212 00000172' 6000 FF54                			bra			do_ca			;Nochmal FPU fragen
 213                                    			
 214 00000176' 92FC 000C                w_post:		suba.w		#12,a1			;Inkrement von calc_add aufheben
 215  
 216 0000017A' 7007                     			moveq		#7,d0			;SchleifenzÑhler fÅr 8 Bits
 217  
 218 0000017C' E34C                     .l_1:		lsl.w		#1,d4			;ein Bit ins Carry
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   5
Source File: D:\PC\FPU_EMU\LFED_4.S

 219 0000017E' 64 06                    			bcc.s		.l_2			;nur bei Bit==1 etwas machen
 220 00000180' 2899                     			move.l		(a1)+,(a4)		;1 (A4==#operand)
 221 00000182' 2899                     			move.l		(a1)+,(a4)		;2
 222 00000184' 2899                     			move.l		(a1)+,(a4)		;3 Langworte fÅr jedes Register
 223 00000186' 51C8 FFF4                .l_2:		dbra		d0,.l_1			;fÅr alle 8 Bits
 224 0000018A' 2489                     			move.l		a1,(a2)			;A1 als Registerinhalt abspeichern
 225                                    			
 226 0000018C' 6000 FF3A                			bra			do_ca			;Nochmal FPU fragen
 227                                    			
 228 00000190' 0800 000B                rw_1x:		btst		#11,d0			;zweites Modusbit testen
 229 00000194' 66 52                    			bne.s		rw_11			;==1 -> springen (Trap, Error)
 230 00000196' 0800 000D                			btst		#13,d0			;DR-Bit testen
 231 0000019A' 67 26                    			beq.s		w_10			;==0 -> Daten an FPU schreiben
 232                                    			;--------  %xx110, evaluate effective address and transfer data
 233 0000019C' 6100 0154                			bsr			calc_add		;Operandenadresse berechnen
 234                                    										;A1=Operandenadresse, d1.l=OperandenlÑnge
 235 000001A0' B27C 0002                			cmp.w		#2,d1			;LÑnge-2
 236 000001A4' 6F 0A                    			ble.s		r_bw			;<=2 -> Wort- oder Byteoperand
 237                                    			
 238 000001A6' 22D4                     r_11:		move.l		(a4),(a1)+		;ein Langwort lesen (a4==#operand)
 239 000001A8' 5981                     			subq.l		#4,d1			;und runterzÑhlen
 240 000001AA' 6E FA                    			bgt.s		r_11			;>0 -> weiter Åbertragen
 241 000001AC' 6000 FF1A                			bra			do_ca			;Nochmal FPU befragen
 242                                    			
 243 000001B0' 0801 0000                r_bw:		btst		#0,d1			;Byte?
 244 000001B4' 66 06                    			bne.s		r_byte			;JA!
 245 000001B6' 3294                     			move.w		(a4),(a1)		;Word-Operand lesen (A4==#operand)
 246 000001B8' 6000 FF0E                			bra			do_ca			;Nochmal FPU befragen
 247                                    			
 248 000001BC' 1294                     r_byte:		move.b		(a4),(a1)		;Byteoperand lesen (A4==#operand)
 249 000001BE' 6000 FF08                			bra			do_ca			;Nochmal FPU befragen
 250                                    			
 251 000001C2'                          w_10:		;--------  %xx010, evaluate effective address and transfer data
 252 000001C2' 6100 012E                			bsr			calc_add		;Operandenadresse berechnen
 253                                    										;A1=Operandenadresse, d1.l=OperandenlÑnge
 254 000001C6' B27C 0002                			cmp.w		#2,d1			;LÑnge-2
 255 000001CA' 6F 0A                    			ble.s		w_bw			;<=2 -> Wort- oder Byteoperan
 256                                    			
 257 000001CC' 2899                     w_11:		move.l		(a1)+,(a4)		;Langwort schreiben (a4==#operand)
 258 000001CE' 5981                     			subq.l		#4,d1			;und runterzÑhlen
 259 000001D0' 6E FA                    			bgt.s		w_11			;>0 -> weiter Åbertragen
 260 000001D2' 6000 FEF4                			bra			do_ca			;Nochmal FPU befragen
 261                                    			
 262 000001D6' 0801 0000                w_bw:		btst		#0,d1			;Byte?
 263 000001DA' 66 06                    			bne.s		w_byte			;JA!
 264 000001DC' 3891                     			move.w		(a1),(a4)		;Word schreiben (A4==#operand)
 265 000001DE' 6000 FEE8                			bra			do_ca			;Nochmal FPU befragen
 266                                    			
 267 000001E2' 1891                     w_byte:		move.b		(a1),(a4)		;Byte schreiben (A4==#operand)
 268 000001E4' 6000 FEE2                			bra			do_ca			;Nochmal FPU befragen
 269                                    			
 270 000001E8'                          rw_11:		;-------- %xxx11, take pre-instruction exception
 271 000001E8' 6000 00F8                			bra 		cop_error		;Error-Handler anspringen
 272                                    			;(hier sollte man eine genauere Fehleranalyse machen)!
 273                                    			
 274 000001EC'                          spezial:				;Sprungbefehle etc.
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   6
Source File: D:\PC\FPU_EMU\LFED_4.S

 275 000001EC' B27C 0040                			cmp.w		#%001000000,d1	;FScc, FDBcc oder FTRAPcc
 276 000001F0' 67 14                    			beq.s		s_trap
 277 000001F2' B27C 0080                			cmp.w		#%010000000,d1	;Branch mit 16Bit-Offset
 278 000001F6' 6700 0096                			beq			s_br16
 279 000001FA' 0A41 00C0                			eor.w		#%011000000,d1	;Branch mit 32Bit-Offset
 280 000001FE' 6700 00B8                			beq			s_br32
 281 00000202' 6000 00DE                			bra			cop_error		;FSAVE/FRESTORE nicht unterstÅtzt
 282                                    			
 283 00000206' 3010                     s_trap:		move.w		(a0),d0			;erstes Befehlswort nach D0
 284 00000208' 3200                     			move.w		d0,d1			;und nach D1 retten
 285 0000020A' C07C 0038                			and.w		#%111000,d0		;wichtige Bits ausmaskieren
 286 0000020E' B07C 0008                			cmp.w		#%001000,d0		;FDBcc?
 287 00000212' 67 34                    			beq.s		s_fdbcc			;JA -> springen
 288 00000214' B07C 0038                			cmp.w		#%111000,d0		;FTRAP?
 289 00000218' 6700 00C8                			beq			cop_error		;JA -> Fehler (s.o.)
 290                                    										;sonst FScc
 291 0000021C' 3D68 0002 000E           			move.w		2(a0),condition(a6)	;Bedingung an FPU schicken
 292 00000222' 7001                     			moveq		#1,d0			;OperandenlÑnge=1 (fÅr calc_add)
 293 00000224' 6100 00CC                			bsr			calc_add		;OperandenlÑnge berechnen
 294                                    			
 295 00000228' 3016                     .l_1:		move.w		(a6),d0			;Response lesen
 296 0000022A' 0800 0008                			btst		#8,d0			;IA-Bit testen
 297 0000022E' 67 0E                    			beq.s		.l_2			;==0 -> fertig
 298 00000230' C07C 1800                			and.w		#%1100000000000,d0	;Bit 11 und 12 ausmaskieren
 299 00000234' 0A40 1800                			eor.w		#%1100000000000,d0	;Beide gesetzt?
 300 00000238' 66 EE                    			bne.s		.l_1			;nicht Beide ==1 -> warten
 301 0000023A' 6000 00A6                			bra			cop_error		;sonst Exception aufgetreten
 302                                    			
 303 0000023E' 0800 0000                .l_2:		btst		#0,d0			;Antwortbit testen
 304 00000242' 56D1                     			sne			(a1)			;je nach Bit setzen/lîschen
 305 00000244' 6000 FE82                			bra			do_ca			;nochmal FPU befragen
 306                                    			
 307 00000248' 3D68 0002 000E           s_fdbcc:	move.w		2(a0),condition(a6)	;Bedingung an FPU schicken
 308 0000024E' C27C 0007                			and.w		#%111,d1		;Registernummer maskieren (D1=(A0))
 309 00000252' E549                     			lsl.w		#2,d1			;D1=Nummer*4
 310 00000254' 43F3 1000                			lea			(a3,d1.w),a1	;A1 enthÑlt Adresse des Datenregisters
 311 00000258' 2211                     			move.l		(a1),d1			;Dn holen
 312 0000025A' 5341                     			subq.w		#1,d1			;Dn=Dn-1
 313 0000025C' 2281                     			move.l		d1,(a1)			;Dn zurÅckschreiben
 314 0000025E' 2448                     			movea.l		a0,a2			;alten PC nach A2 holen
 315 00000260' 5488                     			addq.l		#2,a0			;PC 2 weiter (fÅr "nicht springen")
 316                                    						
 317 00000262' 3016                     .l_1:		move.w		(a6),d0			;Response lesen
 318 00000264' 0800 0008                			btst		#8,d0			;IA-Bit testen
 319 00000268' 67 0C                    			beq.s		.l_2			;==0 -> fertig
 320 0000026A' C07C 1800                			and.w		#%1100000000000,d0	;Bit 11 und 12 ausmaskieren
 321 0000026E' 0A40 1800                			eor.w		#%1100000000000,d0	;Beide gesetzt?
 322 00000272' 66 EE                    			bne.s		.l_1			;nicht Beide ==1 -> warten
 323 00000274' 606C                     			bra			cop_error		;sonst Exception aufgetreten
 324                                    			
 325 00000276' 0800 0000                .l_2:		btst		#0,d0			;Antwortbit testen
 326 0000027A' 6600 FE4C                			bne			do_ca			;TRUE -> das war's schon
 327 0000027E' D4EA 0004                			adda.w		4(a2),a2		;16Bit Sprungdist. add. (A2=PC)
 328 00000282' 5241                     			addq.w		#1,d1			;Dn==1 ?
 329 00000284' 6700 FE42                			beq			do_ca			;JA -> kein Sprung (Schleifenende)
 330 00000288' 204A                     			movea.l		a2,a0			;sonst "Sprung" (neuen PC laden)
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   7
Source File: D:\PC\FPU_EMU\LFED_4.S

 331 0000028A' 6000 FE3C                			bra			do_ca			;nochmal FPU befragen
 332                                    			
 333 0000028E' 3D50 000E                s_br16:		move.w		(a0),condition(a6)	;Bedingung an FPU schicken
 334  
 335 00000292' 3016                     .l_1:		move.w		(a6),d0			;Response lesen
 336 00000294' 0800 0008                			btst		#8,d0			;IA-Bit testen
 337 00000298' 67 0C                    			beq.s		.l_2			;==0 -> fertig
 338 0000029A' C07C 1800                			and.w		#%1100000000000,d0	;Bit 11 und 12 ausmaskieren
 339 0000029E' 0A40 1800                			eor.w		#%1100000000000,d0	;Beide gesetzt?
 340 000002A2' 66 EE                    			bne.s		.l_1			;nicht Beide ==1 -> warten
 341 000002A4' 603C                     			bra			cop_error		;sonst Exception aufgetreten
 342                                    			
 343 000002A6' 0800 0000                .l_2:		btst		#0,d0			;Antwortbit testen
 344 000002AA' 6700 FE1C                			beq			do_ca			;FALSE -> das war's schon
 345 000002AE' D0E8 0002                			adda.w		2(a0),a0		;16Bit Sprungdistanz addieren
 346 000002B2' 5588                     			subq.l		#2,a0			;ein Wort zurÅck (weil spÑter
 347                                    			;noch addiert wird und nur 2 addiert werden mÅûte)
 348 000002B4' 6000 FE12                			bra			do_ca			;nochmal FPU befragen
 349                                    			
 350 000002B8' 3D50 000E                s_br32:		move.w		(a0),condition(a6)	;Bedingung an FPU schicken
 351  
 352 000002BC' 3016                     .l_1:		move.w		(a6),d0			;Response lesen
 353 000002BE' 0800 0008                			btst		#8,d0			;IA-Bit testen
 354 000002C2' 67 0E                    			beq.s		.l_2			;==0 -> fertig
 355 000002C4' C07C 1800                			and.w		#%1100000000000,d0	;Bit 11 und 12 ausmaskieren
 356 000002C8' 0A40 1800                			eor.w		#%1100000000000,d0	;Beide gesetzt?
 357 000002CC' 66 EE                    			bne.s		.l_1			;nicht Beide ==1 -> warten
 358 000002CE' 6012                     			bra			cop_error		;sonst Exception aufgetreten
 359 000002D0' 5488                     			addq.l		#2,a0			;Befehl ist 3 Worte lang
 360                                    										;(nun: (A0)=Distanz)			
 361 000002D2' 0800 0000                .l_2:		btst		#0,d0			;Antwortbit testen
 362 000002D6' 6700 FDF0                			beq			do_ca			;TRUE -> das war's schon
 363 000002DA' D1D0                     			adda.l		(a0),a0			;32Bit Sprungdistanz addieren
 364 000002DC' 5988                     			subq.l		#4,a0			;ein Wort zurÅck (weil spÑter
 365                                    			;noch addiert wird und nur 2 addiert werden mÅûte)
 366 000002DE' 6000 FDE8                			bra			do_ca			;nochmal FPU befragen
 367                                    			
 368 000002E2'                          cop_error:		;Error_Handler fÅr einen TRAP der FPU (sehr einfach gehalten).
 369                                    				;Es wird ein Reset der FPU durchgefÅhrt und das aktuelle
 370                                    				;Programm terminiert. Return-Code = 881.
 371 000002E2' 3D7C 0000 0002           			move.w		#0,control(a6)	;FPU-Reset (kein clr.w verwenden!)
 372 000002E8' 3F3C 0371                			move.w		#881,-(sp)		;Return-Code
 373 000002EC' 3F3C 004C                			move.w		#$4c,-(sp)		;Funktion Pterm(881)
 374 000002F0' 4E41                     			trap		#1				;des GEMDOS aufrufen
 375                                    			
 376 000002F2'                          calc_add:
 377                                    	;Operandenadresse berechnen. A0 muû die Adresse des Line-F-Befehls 
 378                                    	;enthalten, D0 im unteren Byte die OperandenlÑnge. Die zu berechnende
 379                                    	;Adresse wird in A1 abgelegt. A0 wird um die LÑnge der zusÑtzlichen
 380                                    	;Daten erhîht. ZusÑtzlichen wird in D1 die LÑnge des Operanden zurÅck-
 381                                    	;gegeben (in Bytes, als Langwort). D2, D3, A2 werden zerstîrt. Bei den
 382                                    	;Adressierungsarten -(An), (An)+ steht in A2 ein Zeiger auf die Stelle,
 383                                    	;in der der Inhalt des Adressregisters An steht (wird fÅr FMOVEM 
 384                                    	;gebraucht).
 385                                    	
 386 000002F2' 4281                     			clr.l		d1				;LÑnge als Langwort lîschen
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   8
Source File: D:\PC\FPU_EMU\LFED_4.S

 387 000002F4' 1200                     			move.b		d0,d1			;und Byte einkopieren
 388 000002F6' 3410                     			move.w		(a0),d2			;Erstes Befehlswort nach D2
 389 000002F8' 3602                     			move.w		d2,d3			;und nach D3 retten
 390 000002FA' C67C 0038                			and.w		#%111000,d3		;Adressierungsart ausmaskieren
 391 000002FE' E24B                     			lsr.w		#1,d3			;D3=Adressierungsart*4 (Langworte!)
 392 00000300' 43F9 00000000`           			lea			cs_tab,a1		;Sprungtabellenadresse nach A1
 393 00000306' 2271 3000                			move.l		(a1,d3.w),a1	;Adresse der Routine nach A1
 394 0000030A' 4ED1                     			jmp			(a1)			;und Routine anspringen
 395                                    			
 396 0000030C'                          c_drd:		;%000	Data Register Direct:		Dn
 397 0000030C'                          c_ard:		;%001	Address Register Direct:	An
 398 0000030C' 43D3                     			lea			(a3),a1			;A1 auf Registerfeld
 399 0000030E' C47C 000F                			and.w		#%1111,d2		;Registernummer ausmaskieren
 400                                    			;(und ein Bit vom Modus, 0 fÅr Daten-, 1 fÅr Adressregister)
 401 00000312' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 (+Modusbit!)
 402 00000314' 5842                     			addq.w		#4,d2			;+4 (fÅr OperandenlÑnge)
 403 00000316' 9441                     			sub.w		d1,d2			;wahre LÑnge abziehen
 404 00000318' D2C2                     			adda.w		d2,a1			;Offset auf Registerfeldanfang add.
 405 0000031A' 4E75                     			rts
 406                                    			
 407 0000031C'                          c_ari:		;%010	Address Register Indirect:	(An)
 408 0000031C' C47C 0007                			and.w		#%111,d2		;Registernummer ausmaskieren
 409 00000320' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 
 410 00000322' 2273 2020                			move.l		32(a3,d2.w),a1	;Adresse nach A1
 411 00000326' 4E75                     			rts
 412                                    			
 413 00000328'                          c_arpo:		;%011	ARI with Postincrement:		(An)+
 414 00000328' C47C 0007                			and.w		#%111,d2		;Registernummer ausmaskieren
 415 0000032C' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 
 416 0000032E' 45F3 2020                			lea 		32(a3,d2.w),a2	;Adresse Adressregister nach A2
 417 00000332' 2252                     			movea.l		(a2),a1			;Adresse (Inhalt A.-Reg.) nach A1
 418 00000334' 0801 0000                			btst		#0,d1			;D1 ungerade? (Byteoperand)
 419 00000338' 66 04                    			bne.s		.l_2			;JA -> Spezialbehandlung
 420                                    			
 421 0000033A' D392                     .l_1:		add.l		d1,(a2)			;Inkrement durchfÅhren
 422 0000033C' 4E75                     			rts
 423                                    			
 424 0000033E' B47C 001C                .l_2:		cmp.w		#4*7,d2			;ist A7 gemeint?
 425 00000342' 66 F6                    			bne.s		.l_1			;NEIN -> normal vorgehen
 426 00000344' 5492                     			addq.l		#2,(a2)			;sonst (bei Byte) 2 addieren,
 427 00000346' 4E75                     			rts							;damit Stack gerade bleibt!
 428                                    			
 429 00000348'                          c_arpr:		;%100	ARI with Predecrement:		-(An)
 430 00000348' C47C 0007                			and.w		#%111,d2		;Registernummer ausmaskieren
 431 0000034C' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 
 432 0000034E' 45F3 2020                			lea 		32(a3,d2.w),a2	;Adresse Adressregister nach A2
 433 00000352' 0801 0000                			btst		#0,d1			;D1 ungerade? (Byteoperand)
 434 00000356' 66 06                    			bne.s		.l_2			;JA -> Spezialbehandlung
 435                                    			
 436 00000358' 9392                     .l_1:		sub.l		d1,(a2)			;Inkrement durchfÅhren
 437 0000035A' 2252                     			movea.l		(a2),a1			;Adresse (Inhalt des A.-Reg.) nach A1
 438 0000035C' 4E75                     			rts
 439                                    			
 440 0000035E' B47C 001C                .l_2:		cmp.w		#4*7,d2			;ist A7 gemeint?
 441 00000362' 66 F4                    			bne.s		.l_1			;NEIN -> normal vorgehen
 442 00000364' 5592                     			subq.l		#2,(a2)			;sonst (bei Byte) 2 subtrahieren,
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page   9
Source File: D:\PC\FPU_EMU\LFED_4.S

 443                                    			   							;damit Stack gerade bleibt!
 444 00000366' 2252                     			movea.l		(a2),a1			;Adresse (Inhalt A.-Reg.) nach A1
 445 00000368' 4E75                     			rts
 446                                    			
 447 0000036A'                          c_ar16:		;%101	ARI with Displacement:		d16(An)
 448 0000036A' C47C 0007                			and.w		#%111,d2		;Registernummer ausmaskieren
 449 0000036E' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 
 450 00000370' 2273 2020                			movea.l		32(a3,d2.w),a1	;Adresse nach A1
 451 00000374' 3428 0004                			move.w		4(a0),d2		;3. Befehlswort nach D2 (Offset)
 452 00000378' D2C2                     			adda.w		d2,a1			;Offset auf Adresse addieren
 453 0000037A' 5488                     			addq.l		#2,a0			;A0 ein Wort (d16) weiter
 454 0000037C' 4E75                     			rts
 455                                    			
 456 0000037E'                          c_ar08:		;%110	ARI with Index:				d8(An,Xn)
 457 0000037E' C47C 0007                			and.w		#%111,d2		;Registernummer ausmaskieren
 458 00000382' E54A                     			lsl.w		#2,d2			;D2="Registernummer"*4 
 459 00000384' 2273 2020                			movea.l		32(a3,d2.w),a1	;Adresse nach A1
 460 00000388' 3428 0004                			move.w		4(a0),d2		;3. Befehlswort nach D2 (Offset)
 461 0000038C' 3602                     			move.w		d2,d3			;und nach D3
 462 0000038E' C67C 00FF                			and.w		#$ff,d3			;Byte ausmaskieren (Byte-Offset)
 463 00000392' D2C3                     			adda.w		d3,a1			;Offset auf Adresse addieren
 464 00000394' 0802 000B                			btst		#11,d2			;1=long, 0=word
 465 00000398' 66 10                    			bne.s		c_ar81
 466 0000039A' C47C F000                			and.w		#%1111000000000000,d2	;Nummer von Dn und Modusbit
 467 0000039E' EA4A                     			lsr.w		#5,d2					;maskieren
 468 000003A0' EA4A                     			lsr.w		#5,d2			;D2=Registernummer*4 (+Modusbit)
 469 000003A2' D2F3 2002                			adda.w		2(a3,d2.w),a1	;16Bit-Index auf A1 addieren
 470 000003A6' 5488                     			addq.l		#2,a0			;A0 ein Wort (Kram & d8) weiter
 471 000003A8' 4E75                     			rts
 472                                    			
 473 000003AA' C47C F000                c_ar81:		and.w		#%1111000000000000,d2	;Nummer von Dn und Modusbit
 474 000003AE' EA4A                     			lsr.w		#5,d2					;maskieren
 475 000003B0' EA4A                     			lsr.w		#5,d2			;D2=Registernummer*4 (+Modusbit)
 476 000003B2' D3F3 2000                			adda.l		(a3,d2.w),a1	;32Bit-Index auf A1 addieren
 477 000003B6' 5488                     			addq.l		#2,a0			;A0 ein Wort (Kram & d8) weiter
 478 000003B8' 4E75                     			rts
 479                                    			
 480 000003BA'                          c_pc:		;%111	absolut short/long, PC-Relativ (ohne/mit Index)
 481                                    			;oder direkt
 482 000003BA' 0802 0002                			btst		#2,d2			;Immidiate?
 483 000003BE' 66 20                    			bne.s		immi			;!=0 -> JA
 484 000003C0' 0802 0001                			btst		#1,d2			;PC-Relativ?
 485 000003C4' 66 22                    			bne.s		pc_rel			;!=0 -> JA
 486 000003C6' 0802 0000                			btst		#0,d2			;Long?
 487 000003CA' 66 0C                    			bne.s		c_long			;!=0 -> JA
 488                                    										;sonst Short
 489 000003CC' 3428 0004                			move.w		4(a0),d2		;Wortadresse holen,
 490 000003D0' 48C2                     			ext.l		d2				;Auf Langwort erweitern
 491 000003D2' 2242                     			movea.l		d2,a1			;und als Operandenadresse merken
 492 000003D4' 5488                     			addq.l		#2,a0			;A0 ein Wort (Short-Addr.) weiter
 493 000003D6' 4E75                     			rts
 494  
 495 000003D8' 2268 0004                c_long:		movea.l		4(a0),a1		;Langwortadresse holen
 496 000003DC' 5888                     			addq.l		#4,a0			;A0 zwei Worte (Long-Addr.) weiter
 497 000003DE' 4E75                     			rts
 498                                    			
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page  10
Source File: D:\PC\FPU_EMU\LFED_4.S

 499 000003E0' 2248                     immi:		movea.l		a0,a1   		;Langwortadresse holen
 500 000003E2' 5889                     			addq.l		#4,a1			;Beide Befehlsworte Åberspringen
 501 000003E4' D1C1                     			adda.l		d1,a0			;A0 Åber Operand hinwegsetzen
 502 000003E6' 4E75                     			rts
 503                                    			
 504 000003E8' 0802 0000                pc_rel:		btst		#0,d2			;mit Index?
 505 000003EC' 66 0C                    			bne.s		pc_idx			;!=0 -> JA
 506 000003EE' 2248                     			movea.l		a0,a1			;PC nach A1
 507 000003F0' D2E8 0004                			adda.w		4(a0),a1		;Offset addieren
 508 000003F4' 5889                     			addq.l		#4,a1			;+4 fÅr LÑnge des FPU-Befehls
 509 000003F6' 5488                     			addq.l		#2,a0			;A0 zwei (16Bit-Offset) weiter
 510 000003F8' 4E75                     			rts
 511                                    			
 512 000003FA' 2248                     pc_idx:		move.l		a0,a1			;PC nach A1
 513 000003FC' 4242                     			clr.w		d2				;oberes Byte lîschen
 514 000003FE' 1428 0005                			move.b		5(a0),d2		;Offset nach D2
 515 00000402' D2C2                     			adda.w		d2,a1			;und addieren
 516 00000404' 5889                     			addq.l		#4,a1			;+4 fÅr LÑnge des FPU-Befehls
 517 00000406' 1428 0004                			move.b		4(a0),d2			;D2=Registernummer*16 und Modusbit
 518                                    										;(high-byte ist noch 0)
 519 0000040A' 0802 0003                			btst		#3,d2			;Long-Bit testen
 520 0000040E' 66 0E                    			bne.s		pc_i_l			;!=0 -> Long-Index
 521 00000410' C47C 01F0                			and.w		#%111110000,d2	;Restinformation ausblenden
 522 00000414' E44A                     			lsr.w		#2,d2			;D2=Registernummer*4 und Modusbit
 523 00000416' D2F3 2002                			adda.w		2(a3,d2.w),a1	;Word-Index addieren
 524 0000041A' 5488                     			addq.l		#2,a0			;A0 zwei (16Bit-Offset) weiter
 525 0000041C' 4E75                     			rts
 526                                    			
 527 0000041E' C47C 01F0                pc_i_l:		and.w		#%111110000,d2	;Restinformation ausblenden
 528 00000422' E44A                     			lsr.w		#2,d2			;D2=Registernummer*4 und Modusbit
 529 00000424' D3F3 2000                			adda.l		(a3,d2.w),a1	;Long-Index addieren
 530 00000428' 5488                     			addq.l		#2,a0			;A0 zwei (16Bit-Offset) weiter
 531 0000042A' 4E75                     			rts			;ENDE von calc_add ***
 532  
 533                                    ;-------------- installation-handler ---------------------------------
 534  
 535 0000042C' 2078 002C                Install:	movea.l		lineF,a0 		;Vektor nach A0
 536 00000430' 2028 FFF4                        	move.l		(-12.b,a0),d0	;falls "XBRA" -> jetzt in D0
 537 00000434' 2228 FFF8                			move.l		(-8.b,a0),d1	;falls "LFED" -> jetzt in D1
 538 00000438' 4E75                     			rts 
 539                                    			
 540 0000043A' 4879 00000000`           Terminate:	pea			failure			;Fehlermeldung
 541 00000440' 3F3C 0009                			move.w		#9,-(sp)		;Cconws
 542 00000444' 4E41                     			trap		#1				;GEMDOS
 543 00000446' 3F3C 0000                			move.w		#0,-(sp)		;richtig terminieren
 544 0000044A' 4E41                     			trap		#1				;mit Pterm(0)/GEMDOS
 545 0000044C'                          						
 546                                    ;-------------- data-segment -----------------------------------------
 547                                    			
 548                                    			.DATA
 549                                    			
 550 00000000` 00000000'00000000'
     00000008` 00000000'00000000'       cs_tab:		.dc.l	c_drd,c_ard,c_ari,c_arpo	;Sprungtabelle fÅr
 551 00000010` 00000000'00000000'
     00000018` 00000000'00000000'       			.dc.l	c_arpr,c_ar16,c_ar08,c_pc	;Adressierungsarten
 552  
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page  11
Source File: D:\PC\FPU_EMU\LFED_4.S

 553 00000020` 0A0D 1B70                titel:      .dc.b 	10, 13, 27, 112	;CR/invers on
 554 00000024` 2020 4C69 6E65 2D46 
     0000002C` 2D45 6D75 6C61 7469 
     00000034` 6F6E 2D44 7269 7665 
     0000003C` 7220 4C46 4544 2020 
     00000044` 0A0D                     			.ASCII	"  Line-F-Emulation-Driver LFED  ", 10, 13 
 555 00000046` 2020 2020 2020 2020 
     0000004E` 5665 7273 696F 6E20 
     00000056` 312E 3030 2020 2020 
     0000005E` 2020 2020 2020 2020 
     00000066` 0A0D                                 .ASCII	"        Version 1.00            ", 10, 13
 556 00000068` 1B71                     			.dc.b	27, 113         ;invers off
 557 0000006A` 2020 2028 6329 2062 
     00000072` 7920 536D 6172 7420 
     0000007A` 5379 7374 656D 7320 
     00000082` 2739 320A 0D             			.ASCII  "   (c) by Smart Systems '92", 10, 13
 558 00000087` 204D 6963 6861 656C 
     0000008F` 2048 6175 7363 6869 
     00000097` 6C64 202F 2053 6565 
     0000009F` 6C7A 650A 0D             			.ASCII  " Michael Hauschild / Seelze", 10, 13
 559 000000A4` 2050 686F 6E65 3A20 
     000000AC` 3035 3133 3720 2F20 
     000000B4` 3920 3230 2030 390A 
     000000BC` 0D00                     			.ASCII  " Phone: 05137 / 9 20 09", 10, 13, 0
 560  
 561 000000BE` 0A0D                     failure:	.dc.b	10, 13	;CR
 562 000000C0` 204C 4645 4420 616C 
     000000C8` 7265 6164 7920 696E 
     000000D0` 7374 616C 6C65 6400      			.ASCIIZ	" LFED already installed"
 563 000000D8` 0A0D                     			.dc.b	10, 13	;CR
 564 000000DA`                          			
 565                                    ;-------------- blockstorage-segment ---------------------------------
 566                                    			
 567                                    			.BSS
 568  
 569 00000000"                          dregs:		.ds.l	(8+7)	;Platz fÅr Register (D0-D7/A0-A6)
 570 0000003C"                          rusp:		.ds.l	1		;Platz fÅr USP (A7)
 571 00000040"                          rd1:		.ds.l	1		;Platz fÅr D1
 572 00000044"  
 573                                    ;-------------- end of code ------------------------------------------
 574  
 575                                    			.END
PASM 68040 Macro Assembler  Version Nov 12 1991  (C) 91 Pure Software  Page  12
Source File: D:\PC\FPU_EMU\LFED_4.S



Symbols:
========

Name                  Value      Scope      Relocation base

.l_1                  00000228   Local      TEXT
.l_1                  00000262   Local      TEXT
.l_1                  00000292   Local      TEXT
.l_1                  000002BC   Local      TEXT
.l_1                  0000033A   Local      TEXT
.l_1                  00000358   Local      TEXT
.l_1                  0000017C   Local      TEXT
.l_1                  00000164   Local      TEXT
.l_1                  00000128   Local      TEXT
.l_1                  0000013A   Local      TEXT
.l_2                  0000033E   Local      TEXT
.l_2                  00000132   Local      TEXT
.l_2                  000002A6   Local      TEXT
.l_2                  000002D2   Local      TEXT
.l_2                  0000023E   Local      TEXT
.l_2                  0000035E   Local      TEXT
.l_2                  00000186   Local      TEXT
.l_2                  0000016E   Local      TEXT
.l_2                  00000276   Local      TEXT
.l_2                  00000148   Local      TEXT
Install               0000042C   File       TEXT
Terminate             0000043A   File       TEXT
again                 000000BA   File       TEXT
c_ar08                0000037E   File       TEXT
c_ar16                0000036A   File       TEXT
c_ar81                000003AA   File       TEXT
c_ard                 0000030C   File       TEXT
c_ari                 0000031C   File       TEXT
c_arpo                00000328   File       TEXT
c_arpr                00000348   File       TEXT
c_drd                 0000030C   File       TEXT
c_long                000003D8   File       TEXT
c_pc                  000003BA   File       TEXT
calc_add              000002F2   File       TEXT
command               0000000A   File       EQUATE
condition             0000000E   File       EQUATE
control               00000002   File       EQUATE
cop_error             000002E2   File       TEXT
cs_tab                00000000   File       DATA
do_ca                 000000C8   File       TEXT
dregs                 00000000   File       BSS
failure               000000BE   File       DATA
immi                  000003E0   File       TEXT
ins_add               00000018   File       EQUATE
lineF                 0000002C   File       EQUATE
my_trap               0000008A   File       TEXT
newtrap               00000070   File       TEXT
oldtrap               0000006C   File       TEXT
operand               00000010   File       EQUATE
pc_i_l                0000041E   File       TEXT
pc_idx                000003FA   File       TEXT
pc_rel                000003E8   File       TEXT
r_11                  000001A6   File       TEXT
r_bw                  000001B0   File       TEXT
r_byte                000001BC   File       TEXT
r_pred                00000138   File       TEXT
rd1                   00000040   File       BSS
reg_selec             00000014   File       EQUATE
response              00FFFA40   File       EQUATE
restore               00000006   File       EQUATE
rusp                  0000003C   File       BSS
rw_00                 00000112   File       TEXT
rw_11                 000001E8   File       TEXT
rw_1x                 00000190   File       TEXT
rw_sngl               00000106   File       TEXT
s_br16                0000028E   File       TEXT
s_br32                000002B8   File       TEXT
s_fdbcc               00000248   File       TEXT
s_trap                00000206   File       TEXT
save                  00000004   File       EQUATE
setvec                00000052   File       TEXT
spezial               000001EC   File       TEXT
start                 00000018   File       TEXT
titel                 00000020   File       DATA
w_00                  00000156   File       TEXT
w_10                  000001C2   File       TEXT
w_11                  000001CC   File       TEXT
w_bw                  000001D6   File       TEXT
w_byte                000001E2   File       TEXT
w_post                00000176   File       TEXT
xb_id                 00000068   File       TEXT
xb_magic              00000064   File       TEXT
