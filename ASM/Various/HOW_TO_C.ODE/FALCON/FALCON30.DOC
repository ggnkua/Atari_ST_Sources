*************************************************************************
*        			        				*
* THE MEGAMIGHTY    /ððððððð    /ððððððð /ððððððð			* 
*		     /ððððððððð /ððððððððð /ððððððððð		        *
*		     /ððð///ððð /ððð///ððð /ððð///ððð		        *
*		     /ððð  /ððð /ððð  /ððð /ððð  /ððð		        *
*		     /ððð  /ððð /ððððððððð /ðððððððð/		        *
*		     /ððð  /ððð /ððððððððð /ðððððððð	                *
*		     /ððð  /ððð /ððð///ððð /ððð///ððð		        * 
*		     /ððð  /ððð /ððð  /ððð /ððð  /ððð		        *
*		     /ððððððððð /ððð  /ððð /ððððððððð		        *
*		     /ððððððð// /ððð  /ððð /ððððððð//		        *
*		     ////////   ////  //// ////////		        *
*		     							*
* presentent : LISTE DES FONCTIONS XBIOS FALCON 030			*
*            ----------------------------------------      	        *
*	       								*
*	      Copiees & Traduites par nos soins afin que tout le monde  *
*	      puisse enfin profiter de son Falcon et le programmer      *
*	      sans aller mendier un kit de developpement nul chez	*
*	      Atari....						        *
*	        							*
************************************************************************* 
  	       
  	    	
Cette liste est divisee en 3 sections :

- Video 
- Son
- DSP

Elle se borne a referencer la liste des nouvelles fonctions ajoutees
dans le systeme (du moins jusque la version du TOS 4.01). Il n'y a 
aucune note sur le brochage des circuits. Vous trouverez a la fin une
petite annexe decrivant le brochage des sorties Falcon.
	
********************
* VIDEO FALCON 030 *
********************

Il vaut mieux effectuer toutes les sorties sur l'ecran par le biais des
fonctions GEM VDI. Cette technique permet de tirer parti des resolutions
elevees et d'un grand nombre de couleurs.

Les modes 1,2,4 et 8 bits par pixels sont organises comme sur le
ST, le STE ou le TT. Dans le mode 16 bits par pixel, il n'y a plus de
palette, chaque pixel est organise ainsi : RRRRRGGGGGGBBBBB. Il existe
egalement un mode overlay ou les 16 bits sont organises ainsi :
RRRRRGGGGXBBBBB. Le bit X est utilise comme bit d'overlay.

NDT :Notez que les fonctions video du TT ont ete enlevees et aboutissent
     sur un RTS. 

Le cookie video (_VDO) vaut 0x00000300.

FONCTIONS XBIOS
---------------

Les descriptions des fonctions sont donnees en C. Les fichiers
d'en-tete correspondants sont dans le dossier BINDINGS.
Le numero des fonctions est donne en decimal.

Fonction 5 : Setscreen
----------------------
int Setscreen (long log,long phys,int rez,int mode)

Setscreen() a ete etendue pour supporter les nouveaux modes video du
Falcon. Si vous passez 3 pour le parametre rez et un mode video pour
le parametre mode, Setscreen reallouera la ram necessaire a l'ecran
et reinitialisera le VDI.
Les developpeurs devraient preferer l'utilisation de Setscreen() a
celle de VsetMode car contrairement a Setscreen, VsetMode ne realloue
pas la ram et ne reinitialise pas le VDI.

Fonction 88 : Vsetmode
----------------------
int Vsetmode (int mode)

La fonction Vsetmode place le Falcon dans un mode video specifique.
Mode est un mot de 16 bits ou chaque bit a sa signification :

Octet de poids faible :    S O P V 8 N N N

      N  Bits par pixels : 4 -> 16 bits
                           3 -> 8  bits
                           2 -> 4  bits
                           1 -> 2  bits
                           0 -> 1  bit

      8 Flag 80 colonnes : 1 -> mode 80 colonnes
                           0 -> mode 40 colonnes

      V Flag VGA         : 1 -> mode moniteur VGA
                           0 -> mode TV

      P Flag PAL         : 1 -> mode PAL
                           0 -> mode NTSC

      O Flag Overscan    : 1 -> Overscan ON (impossible en VGA)
                           0 -> Overscan OFF

Octet de poids fort : X X X X X X X F

      F Flag Vertical    : 1 -> Entrelace (TV) / Double ligne (VGA) ON
                           0 -> OFF

      X Reserve

En retour de fonction on obtient l'ancien mode video. Si on passe
-1 en parametre, on recupere le mode video courant.
Quelques modes ne sont pas permis. 40 colonnes 1 bit par pixel ou
80 colonnes VGA 16 bits par pixels ne sont pas possibles.

Fonction 89 : mon_type
----------------------
int mon_type(void)

Cette fonction renvoie le type de moniteur utilise. Les valeurs 
possibles sont :

0 -> Moniteur monochrome ST
1 -> Moniteur couleur ST
2 -> Moniteur VGA
3 -> Television

Fonction 90 : VsetSync
----------------------
void VsetSync(int external)

Indique au systeme quel type de synchronisation video va etre
utilise. External est un mot dont les 3 premiers bits ont une
signification : 0 0 0 0 0 H V C

C -> Synchronisation externe
V -> Synchronisation verticale externe
H -> Synchronisation horizontale externe

Fonction 91 : VgetSize
----------------------
long VgetSize(int mode)

Renvoie la taille de l'ecran en octets. 

Fonction 93 : VsetRGB
---------------------
void VsetRGB(int index,int count,long *array)

Initialise les couleurs avec des valeurs RGB. L'initialisation de
la palette commence a la couleur index et est faite "count" fois.
Les valeurs RGB a placer dans la palette sont dans le tableau "array"
dont l'adresse est passee en parametre. Cette fonction est appelee par
la fonction VDI vs_color(). Le format du tableau est xRGB ou x n'est
pas utilise. Pour initialiser une couleur seule, il vaut mieux utiliser
la fonction VDI vs_color().

Fonction 94 : VgetRGB
---------------------
void VgetRGB(int index,int count,long *array)

Recupere la valeur des couleurs de la palette en commen‡ant a la
couleur "index" pour "count" couleurs. Les valeurs sont placees dans
le tableau "array" dont l'adresse est passee en parametre. Le format
du tableau est le mˆme que pour VsetRGB : xRGB ou x est inutilise.
Pour lire la valeur d'une seule couleur, il vaut mieux utiliser la
fonction VDI vq_color().

Fonction 150 : VsetMask
-----------------------
void VsetMask(int andmask,int ormask)

VsetMask est utilise pour initialiser les masques AND et OR utilises
par le VDI pour modifier les valeurs utilisees pour vs_color().
Les valeurs des couleurs renvoyees par vs_color() sont "AND"ees puis
"OR"ees avec les masques passes en parametre. Les valeurs des masques
par defaut sont pour AND=0xFFFF et pour OR=0x0000, cette combinaison
ne produit aucun effet. Ceci permet a une application de mettre 
n'importe quelle couleur en transparent (ou pas) dans le mode 15
bits par pixel avec overlay. L'appel a cette fonction place automati-
quement le systeme en mode overlay true color (15 bits/pixels). Cette
fonction ne peut etre utilisee qu'en mode true color. 

*****************************
* SYSTEME SONORE FALCON 030 *
*****************************

L'Atari Falcon 030 a un cookie (_SND) qui indique la configuration
du systeme sonore :

Bit 0 : PSG Yamaha
Bit 1 : DMA 8 bits
Bit 2 : CODEC 16 bits
Bit 3 : DSP
Bit 4 : Matrice de connexion.

Les trois exemples suivant illustrent les differentes fa‡ons d'organiser
les donnees sonores en memoire (G: voie gauche, D: voie droite) :

Une piste stereo 16 bits :  G   D   G   D  ...
                            mot mot mot mot

Une piste stereo 8 bits  :  G   D   G   D   G   D  ...
                            oct oct oct oct oct oct

4 pistes stereo 16 bits  :  G0  D0  G1  D1  G2  D2  G3  D3  G0  D0 ...
                            int int int int int int int int int int

Fonction 128 : locksnd
----------------------
long locksnd(void);

Cette fonction est utilisee comme semaphore pour locker le systeme
sonore. Elle renvoie 1 si le systeme a ete locke.

Fonction 129 : unlocksnd
------------------------
long unlocksnd(void)

Cette fonction est utilisee pour liberer le systeme sonore pour les
autres applications. Elle renvoie 0 si il n'y a pas eu d'erreur.

Fonction 130 : soundcmd
-----------------------
long soundcmd(int mode,int data)

Cette fonction est utilisee pour fixer ou lire des parametres du
systeme sonore. Si un nombre negatif est passe en parametre, la
configuration courante est renvoyee.

Mode : 0 (LTATTEN) -> Fixe l'attenuation en sortie de la voie gauche.
                      L'attenuation est mesuree en pas de -1.5Db.
                      data = xxxx xxxx LLLL xxxx ou LLLL est l'attenuation.

       1 (RTATTEN) -> Idem mais pour la voie droite.

       2 (LTGAIN)  -> Fixe le gain en entree de la voie gauche. Le gain
                      est mesure en pas de 1.5 Db.
                      data = xxxx xxxx LLLL xxxx ou LLLL est le gain.

       3 (RTGAIN)  -> Idem mais pour la voie gauche.

       4 (ADDERIN) -> Indique a l'additionneur 16 bits d'ou il doit
                      recevoir ses entrees, soit l'ADC, soit la matrice
                      soit les deux. Data est un champ de bits :
                      data = xxxx xxxx xxxx xxMA 
                      M : Matrice (1/0 On Off)
                      A : ADC (Analog Digital Converter) (1/0 On Off)

       5 (ADCINPUT)-> Fixe l'entree de l'ADC. L'entree peut etre les
                      voies gauche et droite du PSG ou les voies gauche
                      et droite du micro. L'entree est un champ de bit
                      ou un bit a 0 indique une entree venant du micro et
                      un bit a 1 indique une entree venant du PSG.
                      data = xxxx xxxx xxxx xxLR
                      L : voie gauche
                      R : voie droite

       6 SETPRESCALE  Utilise pour la compatibilite. Cette valeur de
                      predivision est utilisee quand la valeur de
                      predivision interne de DEVCONNECT est a zero.
                      data = 0 -> invalide (6.25 KHz)
                             1 -> divise par 640 (12.5 KHz)
                             2 -> divise par 320 (25 KHz)
                             3 -> divise par 160 (50 KHz)
                      Renvoie la valeur de division courante.

Fonction 131 : setbuffer
------------------------
long setbuffer(int reg,long begaddr,long endaddr)

Cette fonction est utilisee pour jouer ou enregistrer des echantillons.
reg indique si il s'agit d'enregistrement ou un playback et begaddr
et endaddr fixent l'adresse de debut de fin du buffer. (L'adresse de
fin n'est pas comprise dans le buffer).

reg : 0 -> playback
      1 -> enregistrement

Fonction 132 : setmode
----------------------
long setmode(int mode)

Cette fonction est utilisee pour fixer le mode d'enregistrement ou de
playback. Les modes sont les suivants :

mode : 0 -> 8 bits stereo
       1 -> 16 bits stereo
       2 -> 8 bits mono

Fonction 133 : settracks
------------------------
long settracks(int playtracks,int rectracks)

Cette fonction est utilisee pour fixer le nombre de pistes en 
enregistrement ou en playback. Notez que ce sont des pistes
stereo. En 8 bits mono, le mˆme echantillon sera rejoue en mˆme
temps sur les deux voies.

playtracks : 0 a 3
rectracks  : 0 a 3

Fonction 134 : setmontracks 
---------------------------
long setmontracks(int montrack)

Cette fonction (monitoring) est utilisee pour fixer la sortie du haut 
parleur interne sur l'une des 4 voies. Le haut parleur interne ne peut
rejouer qu'une voie a la fois.

montrack : 0 a 3

Fonction 135 : setinterrupt
---------------------------
long setinterrupt(int src_inter,int cause)

Cette fonction est utilisee pour fixer quel type d'interruption va
se declancher lors de la fin d'un echantillon. L'interruption
peut venir soit du Timer A mis en mode event_count ou de l'interruption 7
du MFP.

scr_inter : 0 -> timer A
            1 -> MFP i7
cause     : 0 -> pas d'interruption
            1 -> Playback
            2 -> Enregistrement
            3 -> Playback ou Enregistrement

Fonction 136 : buffoper
-----------------------
long buffoper(int mode)

Cette fonction est utilisee pour contr“ler la restitution ou l'enregis-
trement d'echantillons. Le parametre mode est un champ de bits. Si
on passe -1 en parametre, le statut actuel est renvoye.

mode : 0 0 0 0 RR RE PR PE
       RR -> Record Repeat (1 : ON, 0 : OFF)
       RE -> Record Enable (1 : ON, 0 : OFF)
       PR -> Play Repeat   (1 : ON, 0 : OFF)
       PE -> Play Enable   (1 : ON, 0 : OFF)

Note: Le systeme sonore possede une file FIFO de 32 octets. Lors du
      transfert de donnees dans le buffer, l'application doit verifier
      que le bit record enable (RE) a ete mis a zero. Si le bit a ete
      mis a zero, la file FIFO a ete videe, dans le cas contraire,
      l'application doit vider la file en mettant le bit RE a zero.

Fonction 137 : dsptristate
--------------------------
long dsptristate(int dspxmit,int dsprec)

Cette fonction est utilisee pour placer le DSP en tristate a partir
de la matrice.

dspxmit : 0 -> Tristate
          1 -> Enable
dsprec :  0 -> Tristate
          1 -> Enable

Fonction 138 : gpio
-------------------
long gpio(int mode,int data)

Cette fonction est utilisee pour communiquer par la biais des broches
d'entrees/sorties a usage general (General Purpose I/O) du connecteur
DSP. Seuls les 3 bits les plus faibles sont utilises, les autres sont
reserves. Cet appel, dependant du mode, peut etre utilise pour fixer la
direction des bits d'E/S, pour lire ou ecrire des bits. Lors d'un
RESET, ces trois lignes sont fixees en sortie.

mode  : 0 -> direction E/S   data : 1 -> sortie
                                    0 -> entree
        1 -> lecture         data : etat du port GPIO
                             la valeur lue est renvoyee par la fonction
        2 -> ecriture        data : valeur ecrite

Fonction 139 : devconnect
-------------------------
long devconnect(int src,int dst,int srcclk,int prescale,int protocol)

Cette fonction est utilisee pour connecter un circuit source a un
circuit destination dans la matrice. Cette fonction est aussi utilisee
pour fixer la predivision de l'horloge et le protocole de transmission.

src: circuit source a connecter a un ou plusieurs destinations.
     0 -> DMA playback (DMAPLAY)
     1 -> Emission DSP (DSPXMIT)
     2 -> Entree externe (EXTINP)
     3 -> Micro/PSG (ADC)

dst: Destination a connecter a la source. Ce mot est un champ de bits :
     Bit 0 -> Enregistrement DMA (DMAREC)
     Bit 1 -> Reception DSP (DSPRECV)
     Bit 2 -> Sortie externe (EXTOUT)
     Bit 3 -> Casque ou haut-parleur interne (DAC)

srcclk: L'horloge que le circuit source va utiliser.
        0 -> Horloge interne 25.175 MHz (Pour son DMA STE)
        1 -> Horloge externe (pour CD ou DAT)
        2 -> Horloge interne 32 MHz

prescale: predivision de l'horloge. Le taux d'echantillonage est la valeur
          de l'horloge divisee par 256 et redivisee par la valeur de
          prescale. La valeur doit etre comprise entre 1 et 12. 
          Si prescale=0, le systeme sonore utilisera alors la valeur
          de SETPRESCALE fixee grace a la fonction soundcmd().
          
Fonction 140 : sndstatus
------------------------
long sndstatus(int reset)

Cette fonction renvoie l'etat courant du CODEC. L'etat est renvoye dans
les 4 bits de poids faible. Le clipping gauche droite est indique si il
a eu lieu durant la conversion Analogique->Digital et le filtrage.

reset : 1 -> reinitialise le systeme sonore.

Apres cet appel, le circuit sonore est initialise ainsi :

- DSP en mode tristate
- Gain et Attenuation a zero
- Connexions dans la matrice coupees
- ADDERIN enable
- Mode 8 bits stereo
- Piste Playback et Enregistrement sur piste 0
- Monitoring sur piste 0
- Interruptions interdites
- Operations avec buffer interdites

Retour : 0 0 L R S S S S 

S -> etat codec : 0 -> Pas d'erreur
                  1 -> Champ de contr“le invalide
                  2 -> Format Sync invalide (coupe le son)
                  3 -> Valeurs invalides pour l'horloge (coupe le son)

L -> clipping gauche
R -> clipping droit

Fonction 141 : buffptr
----------------------
long buffptr(struct *pointer)

Cette fonction renvoie la position courante des pointeurs dans les
buffers d'enregistrement et de playback. Ces pointeurs indiquent
ou la donnee est lue/ecrite dans les buffers.

struct *pointer : Un pointeur sur une structure de 4 longs.

structure : pointeur sur buffer lecture (long)
            pointeur sur buffer ecriture (long)
            reserve (long)
            reserve (long)

**********************
* DSP MOTOROLA 56001 *
**********************

Les communications entre les applications et le DSP sur le Falcon 030
doivent etre faits par le biais des fonctions TOS fournies. N'accedez
pas directement au hardware du DSP, celui-ci pouvant eventuellement
changer dans des futures machines.

La memoire du DSP
-----------------

La RAM que le DSP utilise pour stocker des donnees ou des programmes
est une RAM statique de 32 Kmots (soit 96 Ko). Cette memoire est
constituee comme suit : l'espace programme est un bloc continu de 32 K mots.
Les espaces de stockage des donnees X et Y sont deux blocs separes de
16 K chacun. X et Y peuvent etre accedes comme des blocs commen‡ant
a 0 ou 16K. L'espace programme recouvre physiquement a la fois les 
memoires X et Y donc, un programme DSP devra en tenir compte afin d'eviter
d'avoir des donnees ou des programmes qui entrent en conflit. Notez que
X:0, X:16K et P:16K representent le mˆme emplacement physique en memoire
(NDT: X: signifie acces a la memoire X et P: acces a la memoire programme),
de mˆme, Y:0, Y:16K et P:0 representent le mˆme emplacement physique.

Les programmes DSP
------------------

Certaines etapes doivent etre suivies pour le developpement de programmes
DSP sur Atari. Une partie des 32 Kmots de la memoire DSP est allouee
pour le systeme et pour les routines residentes et ne sont donc pas
utilisables pour les programmes DSP. Une application doit utiliser la
fonction Dsp_Available pour determiner la memoire disponible pour son
programme DSP. Si la taille est satisfaisante, l'application doit
reserver cet emplacement memoire avec la fonction Dsp_Reserve. Cette
fonction empˆchera la memoire programme d'etre corrompue par le systeme.
Il est aussi necessaire a l'application d'empˆcher l'accres au DSP par
une autre application grace a la fonction Dsp_Lock. Cet appel doit ˆtre
fait avant tout autre appel qui va utiliser le DSP. Faire ceci vous
assurera que l'etat du DSP ne sera pas modifie par quelqu'un d'autre
pendant que votre application l'utilisera. Quand l'application n'utilise
plus le DSP, elle doit appeler la fonction Dsp_Unlock pour permettre
aux autres applications de l'utiliser. Si la fonction Dsp_Lock retourne
une valeur "DSP occupe", l'application doit attendre et faire des
Dsp_Lock jusqu'a ce que le DSP ne soit plus occupe. Si vous ne suivez
pas ces etapes, des situations imprevues peuvent se produire. Avant
de faire un appel a Dsp_Unlock, l'application doit etre sur que son
programme DSP a restaure l'IPR (X:$FFFF) et MR a son etat original.

Sous-programmes DSP
-------------------

L'existence de sous-programmes DSP permet au systeme d'avoir plusieurs
processus DSP resident au mˆme moment. Ceci permet un gain de temps
et evite d'avoir a recharger le programme dans la memoire DSP a chaque
utilisation. Ces sous-programmes resteront residents jusqu'a ce qu'ils
soient effaces par un autre sous-programme ou par un programme DSP 
qui a besoin de memoire. Les sous-programmes DSP sont soumis a plus de
contraintes et de restrictions que les programmes DSP. Le code du sous
programme doit etre entierement relogeable. Lors de l'ecriture du code
d'un sous-programme, il faut veiller a ce que le code debute a l'adresse
0. Quand un sous-programme est appele par une commande h“te, le sous
programme peut obtenir son PC de depart a travers le port h“te. Cet
emplacement de depart qui est envoye par le TOS doit etre lu par le
sous-programme, qu'il l'utilise ou pas pour sa relocation. La taille
d'un sous-programme ne peut pas depasser 1024 Kmots. Un sous-programme
de taille plus grande devrait plutot etre execute en tant que programme.
Le code sera reloge quelque part dans la ram externe du DSP. Veillez
a ce que toutes les adresses utilisees dans le programme (adresses de
fin pour les do loop par exemple) soient relogeables par rapport au PC.
Toute donnee initialisee doit etre declaree dans l'espace programme. Un
bloc de memoire X et Y a ete prevu pour les variables non declarees.
Cet espace est situe dans les 256 plus haut mots dans les deux memoires
X et Y (X:3F00 - X:3FFF). Cet espace peut etre utilise librement par
les sous-programmes mais comme cet espace est utilise par tous les
sous-programmes, il n'est pas sur que la memoire sera preservee la fois
suivante que le sous-programme sera execute. Les programmes h“te doivent
utiliser la fonction Dsp_Lock avant d'executer un sous-programme DSP.
Comme les sous-programmes DSP sont executes comme des interruptions, ils
doivent etre termines par l'instruction RTI. Le sous-programme ne doit
pas presumer de l'etat du DSP car son etat est determine par d'autres
programmes precedemment executes et non pas par le boot. Une sequence
type d'appels pour executer un sous-programme se presente ainsi :

   if (!Dsp_Lock())
      {
      ability=Dsp_RequestUniqueAbility();
      handle=Dsp_LoadSubroutine(ptr,size,ability);
      status=Dsp_RunSubroutine(handle);
      Dsp_DoBlock(data_in,size_in,data_out,size_out);
      Dsp_Unlock();
      }

Une fa‡on plus efficace d'executer un sous-programme peut etre de verifier
d'abord si le sous_programme existe deja dans la memoire du DSP.

   if (!Dsp_Lock())
      {
      handle=Dsp_InqSubrAbility(ability);
      if (handle)
         {
         status=Dsp_RunSubroutine(handle);
         Dsp_DoBlock(data_in,size_in,data_out,size_out);
         Dsp_Unlock();
         }
      }

Identification des programmes (ability)
---------------------------------------

L'identification d'un programme (et d'un sous-programme) doit ˆtre
fournie au systeme lors du chargement d'un process dans la memoire DSP.
Cette identification est soit une identification predefinie et qui a 
ete enregistree aupres d'Atari ou une identification unique qui a ete
recuperee lors d'un appel a la fonction Dsp_RequestUniqueAbility.
Cette identification peut etre utilisee pour determiner si l'application
doit recharger le process DSP ou si il existe deja dans la memoire DSP.
Une fois charges, les programmes DSP sont accessibles a toutes les
applications qui veulent les utiliser.


Fonctions de transfert
~~~~~~~~~~~~~~~~~~~~~~

Fonction 96 : Dsp_DoBlock
-------------------------
Dsp_DoBlock(char *data_in,long size_in,char *data_out,long size_out)

Dsp_DoBlock transfert un bloc de donnees entre l'application et le
processus dans le DSP. Les donnees pointees par data_in vont etre 
transferees a raison de "size_in" mots DSP (le nombre d'octets contenus
dans un mot DSP est retourne par la fonction Dsp_GetWordSize). Il est
important de noter qu'aucun handchecking ne sera effectue durant le
transfert, il est suppose que le DSP est capable d'accepter les donnees
a la vitesse ou elles sont envoyees. La fonction va attendre que le 
1er mot soit accepte par le DSP avant de commencer le transfert. Apres
que toutes les donnees aient ete transferees au DSP, la fonction va
attendre jusqu'a ce que le DSP ait fini de traiter les donnees et soit
prˆt a en renvoyer a l'application (quand le bit RXDF du registre ISR
est mis). A ce moment, "size_out" mots sont lus du DSP et stockes dans
le buffer pointe par "data_out". Une fois encore, aucun handchecking
n'est effectue. Si aucune donnee n'est attendue de la part du DSP,
un zero doit etre place dans size_out. De mˆme, si aucune donnee ne
doit etre envoyee, un zero doit etre place dans size_in. Size_in et
size_out sont des longs mots qui indiquent la taille du tableau, en
aucun cas, ils ne doivent depasser 64 Ko.

Fonction 97 : Dsp_BlkHandShake
------------------------------
Dsp_BlkHanShake (char *data_in,long size_in,char *data_out,long size_out)

Cette fonction est identique a la precedente, a cette difference pres
qu'une phase de handchecking a lieu durant le transfert du bloc. Cette
fonction est plus lente que Dsp_DoBlock et doit seulement etre utilise
lorsque la routine doit emettre/recevoie des donnees plus rapidement
que le processus DSP peut le faire. Size_in et size_out sont deux
long mots qui indiquent la taille du tableau. Ils ne peuvent depasser 64Ko.

Fonction 98 : Dsp_BlkUnpacked
-----------------------------
Dsp_Unpacked(long *data_in,long size_in,long *data_out,long size_out)

Dsp_BlkUnpacked est une autre fonction de transfert de bloc qui travaille
de maniere similaire a Dsp_DoBlock. Cette routine fonctionne seulement
sur les versions de TOS dont la fonction Dsp_GetWordSize renvoie une
valeur inferieure ou egale a 4. Data_in et data_out sont des tableaux de
longs mots de 32 bits. Size_in et size_out sont le nombre de longs
mots des tableaux et le nombre de mots DSP a transferer. Les donnees
sont cadrees sur les octets de poids faible et envoyes au DSP, de mˆme
les donnees venant du DSP sont placees dans les octets de poids faible
du tableau size_out. Par exemple, si Dsp_GetWordSize renvoie 3 (24 bits),
les 24 bits les plus faibles de chaque long mot contiendront les donnees
DSP tandis que les 8 bits les plus forts contiendront des valeurs sans
importance. (Note: Ces 8 bits ne contiendront pas necessairement zero).
Size_in et size_out sont des longs mots qui indiquent la taille des
tableaux qui ne doit pas depasser 64 Ko.

Fonction 123 : Dsp_BlkWords
---------------------------
Dsp_BlkWords(int *data_in,long size_in,int *data_out,long size_out)

Dsp_BlkWords envoie ou re‡oit des blocs de mots signes sur 16 bits.
Les mots ont leur signe etendu avant d'etre transferes. Data_in et
data_out sont des tableaux de mots de 16 bits. Size_in et size_out
indiquent la taille des tableaux qui sont limites a 64 Ko.

Fonction 124 : Dsp_BlkBytes
---------------------------
Dsp_BlkBytes(char *data_in,long size_in,char *data_out,long size_out)

Dsp_Blkbytes envoit ou re‡oit des octets. Le signe des octets n'est
pas etendu avant le transfert. Data_in et data_out sont des tableaux
d'octets et size_in et size_out indiquent la taille des tableaux
limites a 64 Ko.

Fonction 127 : Dsp_MultBlocks
-----------------------------
Dsp_MultBlocks(long numsend,long numreceive,struct dspblock sendblocks[],
               struct dspblock receiveblocks[]);

struct dspblock
  {
  int   blocktype;    
  long  blocksize;
  long  blocaddr;
  }

Dsp_MultBlocks peut etre utilise pour envoyer et recevoir plusieurs blocs
de donnees au DSP en utilisant un seul appel Trap. Les parametres
numsend et numreceive representent le nombre d'elements dspblock a
lire ou a ecrire. Sendblocks et receiveblocks sont les adresses de deux
tableaux de dspblock qui contiennent les donnees a envoyer ou recevoir
du DSP. Un bloc dspblock est compose du type de bloc, de sa taille et
de l'adresse du bloc. Le type de bloc indique au systeme quel type de
donnee va etre contenu dans le bloc. (0 = long, 1 = entier 16 bits signes,
2 = octets non signes). Blocksize est le nombre de blocs a transmettre
ou recevoir. Blocaddr est un pointeur sur le buffer de reception / emission.

Fonction 99 : Dsp_InStream
--------------------------
Dsp_InStream(char *data_in,long block_size,long num_blocks,long *blocks_done);

Dsp_InStream va transmettre des donnees d'un buffer vers le DSP via une
interruption. Chaque fois que l'interruption se produit en indiquant a
la routine que le DSP est prˆt pour recevoir d'autres donnees, block_size
mots seront transmis au DSP. Durant le transfert, aucun handchecking
ne sera effectue. La routine continuera a generer des interruptions
jusqu'a ce que "num_blocks" blocs soient effectivement transferres vers
le DSP. A ce moment la routine d'interruption avertira le DSP pour
qu'il stoppe d'attendre la reception. Dsp_InStream actualise un pointeur
(blocks_done) pour que la routine d'appel puisse savoir combien de
blocs ont ete transferres. La routine d'appel peut verifier periodiquement
cette valeur pour voir si la transmission est terminee. Lorsqu'une trans-
mission est faite de fa‡on continue, il vaut mieux preferer cette fonction
a la fonction Dsp_DoBlock, cette derniere sera utilisee si un gros bloc
de donnees est a transmettre de fa‡on ponctuelle.

Fonction 100 : Dsp_OutStream
----------------------------
Dsp_OutStream(char *data_out,long block_size,long num_blocks,long *blocks_done);

Dsp_OutStream va remplir un buffer pointe par data_out via une interruption
DSP. L'appel est similaire a Dsp_InStream excepte que les donnees sont
transferrees du DSP vers le buffer a chaque interruption.
 
Fonction 101 : Dsp_IOStream
---------------------------
Dsp_IOStream(char *data_in,char *data_out,long block_insize,
             long block_outsize,long num_blocks,long *blocks_done)

Dsp_IOStream est une forme specialisee des deux fonctions precedentes.
Elle combine les deux precedentes et permet ainsi d'economiser une
interruption. Lorsque cette fonction est appelee la premiere fois, un
premier bloc est envoye vers le DSP, puis a chaque interruption, 
un bloc est lu du DSP puis un lui est envoye. Les parametres passes
sont les mˆmes que dans les fonctions precedentes. Data_in et Data_out
indiquent les buffers d'entree et de sortie. Bloc_insize et bloc_outsize
indiquent la taille des blocs en mots DSP. Num_blocks est le nombre de
blocs a transferrer et blocks_done pointe sur une valeur qui indique
de maniere continue le nombre de blocs qui ont ete transferrees.

Fonction 126 : Dsp_SetVectors
-----------------------------
Dsp_SetVectors(void (*receiver),long (*transmitter))

Dsp_SetVectors permet a l'application d'installer une fonction qui va
etre appelee quand une interruption est re‡ue du DSP. Receiver doit
pointer sur une fonction qui va etre appelee quand le DSP aura envoye
des donnees vers l'application. Transmitter doit pointer vers une
routine qui sera appele en interruption lorsque le DSP demandera des
donnees. Si transmitter renvoie une valeur differente de zero, les trois
octets de poids faible du mot long seront envoyes au DSP (comme vu
precedemment), aucune donnee ne sera transmise si le mot de 32 bits
retourne vaut 0. (Pour envoyer un 0 au DSP, placez une valeur differente
de 0 dans l'octet superieur). Si receiver ou transmitter valent 0L,
l'interruption correspondante sera inhibee. L'application doit enlever
ses interruptions en utilisant la fonction Dsp_RemoveInterrupts.

Fonction 102 : Dsp_RemoveInterrupts
-----------------------------------
Dsp_RemoveInterrupts(int mask)

Dsp_RemoveInterrupts va avertir le DSP d'arrˆter de generer des
interruptions lors de l'emission ou de la reception. Mask est un masque
de 8 bits qui represente l'interruption a stopper. 

1 -> Pas d'interruption quand le DSP est prˆt a emettre.
2 -> Pas d'interruption quand le DSP est prˆt a re‡evoir.
3 -> Supprime les deux types d'interruptions.

Fonction 103 : Dsp_GetWordSize
------------------------------
int Dsp_GetWordSize(void)

Dsp_GetWordSize renvoie le nombre d'octets contenus dans un mot DSP.
Il est important pour les applications d'utiliser cette fonction pour
determiner certaines valeurs comme la taille des buffers et la taille
des blocs. La valeur retournee par cette routine pourrait changer dans
des versions futures du Falcon.
                              
Fonctions de controle des programmes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fonction 104 : Dsp_Lock
-----------------------
int Dsp_Lock(void)

Dsp_Lock doit etre appele avant tout autre appel a l'une des fonctions
de la librairie DSP. Cette fonction est utilisee par les applications
pour locker le DSP et pour savoir si il l'est deja ou non. Si la fonction
retourne -1, le DSP est deja locke, si elle retourne 0, le DSP est libre,
vous pouvez donc effectuer une autre fonction DSP. Le DSP sera locke
jusque ce que la fonction Dsp_Unlock soit appelee.

Fonction 105 : Dsp_Unlock
-------------------------
void Dsp_Unlock(void)

Dsp_Unlock doit etre utilise en conjonction avec Dsp_Lock (decrit 
precedemment). Un appel a cette fonction indique au systeme que vous
avez fini d'utiliser le DSP et qu'une autre application peut en disposer.

Fonction 106 : Dsp_Available
----------------------------
void Dsp_Available(long *xavailable,long *yavailable)

Dsp_Available renvoie la memoire disponible dans le DSP (voir le para-
graphe sur l'organisation de la memoire). xavailable contient la
memoire disponible X et yavailable la memoire disponible Y. L'espace
memoire disponible commence toujours pour X et Y a l'adresse 0.
Souvenez vous que l'espace programme recouvre les espaces memoires X et Y,
les 64 mots les plus bas de la memoire Y sont utilises pour les vecteurs
d'interruption.

Fonction 107 : Dsp_Reserve
--------------------------                     
int Dsp_Reserve(long xreserve,long yreserve)

Dsp_Reserve reserve de la memoire pour un programme DSP. L'espace
memoire demande ne doit pas depasser la taille renvoyee par
Dsp_Available. Cette fonction doit etre appelee pour etre sur que
votre programme DSP ne sera pas ecrase par un sous-programme DSP.
Cette memoire reservee le sera tant qu'un autre appel Dsp_Reserve ne
sera pas fait. Cela permet a un programme DSP de rester resident.
Xreserve indique l'espace a reserver dans la memoire X et yreserve
dans la memoire Y. Si la fonction renvoie 0, il n'y a pas eu d'erreur.
Si elle renvoie -1, une erreur s'est produite dans la reservation.

Note : Les fonctions Dsp_Available et Dsp_Reserve sont implementes
       uniquement pour resoudre les conflits entre les programmes et
       les sous-programmes. La presence de ces fonctions dans le
       systeme d'exploitation ne signifie pas qu'il existe un systeme
       de gestion de la memoire dans le DSP. La fonction Dsp_Available
       renvoie la memoire disponible pour les programmes qui n'est
       pas actuellement occupee par des sous-programmes. La valeur
       retournee par cette fonction ne tient pas compte de la memoire
       precedemment reservee par Dsp_Reserve. Cette espace memoire
       est susceptible d'etre modifie si un sous-programme est charge
       dans la memoire DSP. La fonction Dsp_Reserve est utilisee 
       uniquement pour savoir si il y a assez de memoire disponible
       pour charger le programme. La quantite de memoire reservee pour
       les programmes peut simplement etre change par un autre appel
       Dsp_Reserve avec plus ou moins de memoire.

Fonction 108 : Dsp_LoadProg
---------------------------
int Dsp_LoadProg(char *file,int ability,char *buffer)

Dsp_LoadProg va charger a partir du disque un programme a executer par
le DSP. Le programme doit etre au format ascii ".LOD" et ne peut exceder
l'espace memoire retourne par la fonction Dsp_Reserve. File est un
pointeur sur le nom du fichier. Ability est un code sur 16 bits qui
decrit le programme (identificateur). Buffer pointe sur un bloc de
memoire ou le loader va pouvoir placer le code DSP qu'il va generer. La
taille du buffer peut etre calcule par la formule :
3 * ( nombre de mots pour le programme / nombre de mots de donnees) +
(3 * nombre de blocs dans le programme)).
Si la fonction retourne 0, aucune erreur ne s'est produite, si la
fonction renvoie -1, une erreur s'est produite avant que le programme
puisse etre execute.

Fonction 109 : Dsp_ExecProg
---------------------------
Dsp_ExecProg(char *codeptr,long codesize,int ability)

Dsp_ExecProg execute un programme DSP qui se trouve en memoire au
format binaire. Cette fonction est plus rapide que Dsp_LoadProg puisqu'elle
n'a pas a lire le fichier sur disque et n'a pas a le convertir au format
binaire. Codeptr doit pointer sur un bloc de code DSP binaire. Codesize
indique le nombre d'octets a transferrer depuis ce bloc vers le DSP.
Le parametre ability identifie le programme. Codesize ne doit pas 
depasser la taille memoire reservee avec Dsp_Reserve.

Fonction 110 : Dsp_ExecBoot
---------------------------
Dsp_ExecBoot(char *codeptr,long codesize,int ability)

Dsp_Execboot va charger dans les 512 mots de la memoire interne du DSP
un programme de boot. Un reset du DSP doit etre fait avant de charger
ce programme. Ce programme doit fonctionner soit comme un programme a
part entiere soit etre utilise pour charger un programme plus grand.
Notez que cette fonction existe uniquement pour des tests lors du
developpement. SEULS LES DEBUGGERS OU LES PROGRAMMES SIMILAIRES QUI
VEULENT PRENDRE LE CONTROLE TOTAL DU DSP DOIVENT UTILISER CETTE
FONCTION. Les applications doivent utiliser Dsp_LoadProg et Dsp_ExecProg.
Codeptr pointe sur un bloc de code binaire DSP. Codesize indique
le nombre d'octets a transferrer depuis ce bloc vers le DSP. Seuls les
512 premiers mots de ce code vont etre transferes.

Fonction 111 : Dsp_LodToBinary
------------------------------
long Dsp_LodToBinary(char *file,char *codeptr)

Dsp_LodToBinary lit le fichier ".LOD" pointe par file. La fonction
convertit ensuite le fichier au format binaire pour etre utilise par
les fonctions Dsp_ExecBoot ou Dsp_ExecProg. Codeptr pointe sur un
bloc de memoire qui est assez large pour que la fonction y place le
code binaire. La fonction renvoie la taille du programme en mots DSP.
Un nombre negatif indique qu'une erreur s'est produite durant la
conversion.

Fonction 112 : Dsp_TriggerHC
----------------------------
Dsp_TriggerHC(int vector)

Seuls deux vecteurs HC sont disponibles par les programmes DSP. (Ce
sont les vecteurs $13 et $14). Tous les autres vecteurs sont utilises
par le systeme et les sous-programmes DSP. Notez que lorsqu'un programme
est charge pour etre execute, la table des vecteurs est automatiquement
rechargee. Tous les vecteurs exceptes les vecteurs $13 et $14 vont ˆtre
reecrits par le systeme.

Fonction 113 : Dsp_RequestUniqueAbility
---------------------------------------
int Dsp_RequestUniqueAbility(void)

Dsp_RequestUniqueAbility permet a une application d'identifier de
fa‡on unique leur programme DSP. La valeur renvoyee par la fonction
est un identificateur qui est unique pour la session courante. L'utilisation
de cette valeur avec des fonctions comme Dsp_InqSubrAbility permet
a l'application de determiner si le code est deja resident dans la DSP
et evite ainsi a le recharger a nouveau.

Fonction 114 : Dsp_GetProgAbility
---------------------------------
int Dst_GetProgAbility(void)

Dsp_GetProgAbility renvoie l'identificateur du programme actuellement
resident dans le DSP. Cet identificateur permet de determiner si un
autre programme va devoir etre charge dans le DSP ou si celui qui s'y
trouve deja pourra effectuer la tƒche demandee.

Fonction 115 : Dsp_FlushSubroutines
-----------------------------------
void Dsp_FlushSubroutines(void)

Dsp_VoidFlushSubroutines doit etre appele si l'application a besoin
de plus de memoire que celle renvoyee par Dsp_Available. Quand cet
appel est fait, tous les sous programmes actuellement residents dans
le DSP seront effaces et la memoire qui leur etait allouee sera liberee.
Dsp_Available peut alors etre appele de nouveau pour determiner la
memoire totale disponible. Dans la mesure du possible, les applications
devront tenter d'utiliser la memoire disponible et eviter d'utiliser
cette fonction. Les performances generales du systeme seront meilleures
si les programmes DSP utilises frequemment restent dans le DSP au lieu
d'y etre souvent charges.

Fonction 116 : Dsp_LoadSubroutine
---------------------------------
int Dsp_LoadSubroutine(char *ptr,long size,int ability)

Dsp_LoadSubroutine va installer un sous-programme DSP en memoire DSP
pour etre utilise plus tard. Ptr doit pointer sur un bloc de code DSP.
Ce code doit respecter les indications specifiees dans le paragraphe
"sous-programme DSP". La taille de ce sous-programme ainsi que son
identificateur sont passes respectivement dans les parametres size
et ability. La fonction renvoie un handle positif si le sous programme
a ete correctement installe. Un handle egal a zero sera renvoye si
la fonction n'a pas reussi l'installation. Le sous-programme restera
resident dans le DSP jusqu'a ce que tous les emplacements disponibles
pour les sous-programmes soient occupes et qu'ils soient remplaces par
d'autres sous-programmes. Il peut aussi etre efface par la fonction
Dsp_FlushSubroutines.

Fonction 117 : Dsp_InqSubrAbility
---------------------------------
int Dsp_InqSubrAbility(int ability)

Dsp_InqSubrAbility renvoie le handle d'un sous-programme installe
si l'identificateur du sous-programme correspond a l'identificateur
passe en parametre. Rechercher un sous-programme qui existe deja en
memoire permet d'eviter a l'y charger a nouveau d'ou un gain de temps.
Si le systeme ne trouve pas le sous-programme DSP, la fonction retourne
un zero. Dans ce cas, il faut utiliser la fonction Dsp_LoadSubroutine
pour installer ce sous-programme.

Fonction 118 : Dsp_RunSubroutine
--------------------------------
int Dsp_RunSubroutine(int handle)

Dsp_RunSubroutine execute un sous-programme DSP resident identifie par
un handle. Avant que cet appel soit fait, le sous-programme aura du ˆtre
identifie grace aux fonctions Dsp_iInqSubrAbility ou Dsp_LoadSubroutine.
La valeur renvoyee permet de savoir si le sous-programme a ete correctement
lance. Une valeur negative signifie une erreur. Un zero signifie que
l'execution a ete correctement realisee.

Fonction 119 : Dsp_Hf0
----------------------
int Dsp_Hf0(int flag)

Dsp_Hf0 va lire ou ecrire le bit 3 du HSR. Si flag est soit un zero soit
un 1, la valeur de flag sera ecrite dans le bit HSR. Si flag contient
0xFFFF, la fonction va renvoyer la valeur du bit 3 du HSR (soit 1 soit 0)
sans changer sa valeur.

Fonction 120 : Dsp_Hf1
----------------------
int Dsp_Hf1(int)

Dsp_Hf1 est identique a la fonction precedente mais agit sur le bit 4.

Fonction 121 : Dsp_Hf2
----------------------
int Dsp_Hf2(void)

Renvoie la valeur du bit 3 du HCR. Notez que ce bit peut seulement ˆtre
lu par l'application et pas ecrit.

Fonction 122 : Dsp_Hf3
----------------------
int Dsp_Hf3(void)

Idem a la fonction precedente mais renvoie la valeur du bit 4 du HCR.

Fonction 125 : Dsp_Hstat
------------------------
char Dsp_HStat(void)

Dsp_HStat renvoie la valeur du port DSP ISR. Cette fonction permet
a l'application permet de savoir si le port h“te est prˆt a transmettre
ou a recevoir. Referez vous au manuel du DSP56000 pour avoir une
description du registre ISR.

***********
* ANNEXES *
***********


Interruptions
~~~~~~~~~~~~~

Niveau        Priorite
7 (+ haute)   Bus
6             Interruptions MFP et DSP
5             IC reseau 85C30
4             Signal VSYNC (VBL)
3             Bus
2             Signal HSYNC (HBL)
1             Bus

Matrix coupling
~~~~~~~~~~~~~~~

To make the system performance in the audio part as good as possible Atari
designed a miniature 'telephone exchange' that can easily connect the
source devices to the receiving devices. Also it is possible to make more
than one connection at a time.


    Source devices

        EXT INPUT ---*-------*------*------*
         CHANNEL     |       |      |      |
                     |       |      |      |
           DSP    ---*-------*------*------*
        TRANSMIT     |       |      |      |
                     |       |      |      |
           ADC    ---*-------*------*------*
                     |       |      |      |
                     |       |      |      |
           DMA    ---*-------*------*------*
        PLAYBACK     |       |      |      |
                    DMA     DAC    DSP     EXT OUTPUT
                   RECORD        RECEIVE     CHANNEL

                        Receiving Devices


Ports andn interfacing
~~~~~~~~~~~~~~~~~~~~~~

DSP CONNECTOR (DB26 Female)
---------------------------

Pin   Signal                           Pin   Signal

1     GP0                              14    GND
2     GP1                              15    SRD
3     GP2                              16    GND
4     P_DATA                           17    +12V
5     P_CLK                            18    GND
6     P_SYNC                           19    R_DATA
7     n/c                              20    R_CLK
8     GND                              21    R_SYNC
9     +12V                             22    EXT_INT
10    GND                              23    STD
11    SC0                              24    SCK
12    SC1                              25    GND
13    SC2                              26    EXCLK                         


SCSI CONNECTOR (flat 50 pins SCSI II Female)
--------------------------------------------

Pin   Signal                           Pin   Signal

1-10  GND                              37    Not Connected
11    +5V                              38    +5V
12-14 Not Connected                    39    Not Connected
15-25 GND                              40    GND
26    SCSI 0                           41    ATN
27    SCSI 1                           42    GND
28    SCSI 2                           43    BSY
29    SCSI 3                           44    ACK
30    SCSI 4                           45    RST
31    SCSI 5                           46    MSG
32    SCSI 6                           47    SEL
33    SCSI 7                           48    C/D
34    Parity                           49    REQ
35-36 GND                              50    I/O


SERIAL PORT (DB9 MALE)                                                         
----------------------

Pin   Signal

1     Carrier Detect                   5     GND
2     Receive                          6     Data set ready
3     Transmit                         7     Request to Send
4     Data Terminal Ready              8     Clear to Send
                                       9     Ring Indicator

PARALLEL PORT (DB25 Female)
---------------------------

The parallel port has extra signal to ease the connection of scanners.

Pin   Signal

1     Strobe          8     Data 6
2     Data 0          9     Data 7
3     Data 1         10     Acknowledge
4     Data 2         11     Busy
5     Data 3         12-16  Not Connected
6     Data 4         17     Select
7     Data 5         18-25  GND


MONITOR CONNECTOR (DB19 Male)
-----------------------------

Pin   Signal                           Pin   Signal

1     Red                              11    GND
2     Green                            12    Composite Sync/Video
3     Blue                             13    Horizontal Sync
4     Mono/Overlay                     14    Vertical Sync
5     GND                              15    External Clock Input
6     Red GND                          16    External SYNC Enable
7     Green GND                        17    +12V
8     Blue GND                         18    M1
9     Audio out                        19    M0
10    GND


SCC LAN-port CONNECTOR (8-pin Mini DIN Female RS-422)
-----------------------------------------------------

Pin   Signal

1     Handshake Output (DTR RS 423)           5     - Received Data
2     Handshake Input or External Clock       6     + Transmitted Data
3     - Transmit Data                         7     General-purpose Input
4     GND                                     8     + Receive


ENHANCED JOYSTICK (DB15 Male)
-----------------------------

Port A                                 Port B
------				       ------

Pin   Signal                           Pin   Signal

1     UP 0                             1     UP 1
2     DOWN 0                           2     DOWN 1
3     LT 0                             3     LT 1
4     RT 0                             4     RT 1
5     PAD0Y                            5     PAD1Y
6     FIRE 0 / LIGHT GUN               6     FIRE 1
7     VCC (+5 VDC)                     7     VCC
8     Not Connected                    8     Not Connected
9     GND                              9     GND
10    FIRE 2                           10    FIRE 3
11    UP 2                             11    UP 3
12    DOWN 2                           12    DOWN 3
13    LT 2                             13    LT 3
14    RT 2                             14    RT 3
15    PAD0X                            15    PAD1X                    


MIDI PORT (DIN 5 Female)
------------------------

MIDI OUT                               MIDI  IN
--------			       --------

Pin   Signal                           Pin   Signal

1     Thru Transmit                    1     Not Connected
2     GND                              2     Not Connected
3     Thru Loop Return                 3     Not Connected
4     Out Transmit                     4     In Receive
5     Out Loop Return                  5     In Loop Return


