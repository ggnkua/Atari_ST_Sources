Porting F68KANS


1. General


People working on applications should never read this document. It 
adresses the system  developer, who has to port F68KANS to a new 
machine and to bring the features of the system to the application 
developer.

To do the things shown here, more than F68KANS is necessary. You 
typically will need the tools of a system developer like an 
assembler or C-Compiler. Additionly, one will need the knowlegde 
how to use these things. Dealing with this document means to leave 
the security of Forth programming.  


The primary idea of F68KANS was to obtain system, which is easy to 
port to a variaty of machines with same CPU.
To reach this goal, some precautions have been taken in the basic 
design. A portable system has to fulfill the following:

-	Being independent from the special I/O-capabilities of a 
special machine.
-	Being independent from any address konfiguration in order to 
avoid complicated mechanisms of loading. 

Both has been achieved with F68KANS. Even more: F68KANS allows in 
spite of its system independence a complete usage of every special 
system resource.


To make this possible F68KANS divides into two basic parts:

-	The Forth-Kernel (called the 'system` itself). This part 
typically comes as a binary file. All Forth definitions of the 
user a contained in this file. Unless introduced explicitely 
by the programmer, this file does not contain any reference to 
a special machine or operating environment.

-	The loader, which connects the 'system' to the environment. 
This program may be very simple up to very complex depending 
on the volume of system resources it gives the system and the 
the developement environment. 

Now this document explains the task of the loader and the 
interface between the loader and the system in detail. Knowing 
these things is important for porting the complete F68KANS 
environment to a new machine or just extending the existing 
functionality. 

The structures in mermory I will explain in the form of 
C-sourcecode, because it is widely spread and really near to 
pseudocode.
To study this document I suggest to print out the content of the 
file 'LOADER.C' from the original Atari-loader and to follow the 
explanation in the example of this implementation.

2. Loading the system

The first task of the loader is to load the binary image of the 
system into the main memory of the computer. In case that some 
parts of the system are already in ROM the loader has to take care 
that these parts are initialized appropriatly.
The forth-system consists of two parts:

-	the code segment
-	the data segment


In most cases both parts together with a header are stored in one 
binary file. This is the form of my distribution. The header is of 
the following format: 

	struct header
		{
          int magic;
          unsigned long codesize;
          unsigned long datasize;
          int dont_care[9];
        } header; 



I have not chosen this format by accident, but it is the default 
header of a file generated by a assembler in my Atari system.

The first two bytes contain a 'magic number' which allow the 
loader to recognize a valid F68KANS image file. In the 
distribution delivered by myself these to bytes contain the two 
characters 'JP', which are the initials of my name.

The two following long-values (4 bytes) contain the lengths of the 
code- and data-segments as they are following in the file. 
The next 18 bytes following are without any meaning. Together, the 
header has a total length of 28 bytes.

After analyzing the header, the loader has to carefully store the 
two segments into the main memory. For that, two buffers of 
appropriate size have to be allocated. When choosing the size of 
these buffers, one should think of the things one intends to do 
with the system. It is important to know that F68KANS strictly 
seperates code and data. This means that applications compiling a 
lot of code but using only few data need a large code-segment. 
Applications handling large amounts of data (see ALLOT) or simply 
generating large numbers of Forth-words (headers are data!) will 
need a large data-segment.    
Needless to say that the buffers have to be greater than the 
segments and may not intersect.

After allocating the buffers, simply load the corresponding parts 
of the file into the buffers. If you do not intend to compile 
anything you may write-protect the code-segment.

Now not all concerning memory is done. F68KANS needs additional 
memory areas for data- and return-stack as well as for the 
terminal input buffer TIB. I suggest 2kB for the datastack, about 
1kB for the returnstack and 256 bytes for the TIB.

Now having all necessary addresses it is time the make F68KANS 
taking notice of them. Therefore exits a structure, which later is 
passed as a parameter to the system. One has to store all the 
pointers into this structure:
   
	typedef struct {
		long registers[16];		/* to be filled by F68K */
 		void *data;				/* A3 */
		void *code;				/* A5 */
		void *datastack;		/* A6 */
		void *retstack;  		/* A7 */
		void *TIBptr; 	
		long codelen;
		long datalen;
		SI_group *si;
	} FORTHPARAS; 

	FORTHPARAS forthparas; 



The first entry registers[] is filled by F68KANS itself when 
initializing. It is filled with the contents of the registers. 
This shall give loaders in critical environments the possibility 
to use the register context of the loader when executing loader 
functions.
The following two entries are pointers containing the addresses of 
code- and data-segment. The three next contain the addresses of 
data- and return-stack and of TIB. The variables codelen and 
datalen do not contain the lengths of the segments found in the 
file but the size of the corresponding buffers in memory.
The last entry *si is of interest in the following chapters. 

When the structure is filled so far one can say the system is 
loaded. Now one has to submit some basic I/O-functions.

3. Basic I/O


A standard F68KANS binary image contains no information on how to 
emit or receive a single character. These things are for a 
textoriented system of some importance.
On the other hand, the handling of I/O is very system dependent. 
for this reason all necessary functions are provided by the loader 
program. While initializing F68KANS stores the pointers to these 
functions into internal variables, so that they can be used for 
all I/O. To make this work there some precautions that the 
I/O-functions must hold to interface with F68KANS.


Four functions are necessary:

	KEY		Receive single character
	EMIT	Emit single character
	KEY?	Check input state of console
	EMIT?	Check output state of console


That's all! F68KANS will do as a basis system even with only first 
two.


With the definition of the parameter interface I oriented myself 
at mechanisms my C-compiler is using, taking not into account some 
it's special features. This make me hope that the interface my be 
realized under different systems in the same was.

To say it the short way:

-	all functions get theire parameters on the 68k's returnstack, 
addressed with register A7. All values on this stack are 32 
bit. This is true also for the interfaces to external 
libraries described later.
-	all functions return only one value of 32 bit. This value 
comes in register D0. 



Example:

KEY gets no parameter from Forth. So the returnstack is not 
important. But KEY returns the character read expanded to 32 bit.


	long cdecl key(void);
	{
		return (long)Bconin(CONSOLE);
	} 


On the other hand, EMIT returns nothing, but takes one parameter 
(the character to emit) from the stack, which has to be long:

	void cdecl emit(ch)   
	long ch;
	{
		Bconout(CONSOLE,(int)ch);
	} 


People used to C may have noticed the 'cdecl' modifier. By this 
modifier MY C-compiler is forced to handle parameters on the 
stack. Otherwise it would expect parameters in registers, which 
cannot be provided by F68KANS.

Using this convention ist extremely important! Otherwise F68KANS 
will not run under any circumstances!

If you cannot force your C-compiler using this conventions, you 
will have to take a different compiler or to enclose your 
functions in little assembler modules. If you write our loader in 
assembler anyway, you should not have any problems at all.

Similar to the things to do with the memory segments, F68KANS has 
to take notice from the functions. For this reason there exists 
the most complex structure in the whole business. This structure 
is of further importance when using additional library functions. 

In the same structure, where you laid down all the memory 
parameters, there is a pointer to a structure of type 'SI_group'.
'SI'is an acronym for 'System Interface'. This pointer 
consequently points to a group of system interfaces. 'Group' means 
that it points to a further field of pointer, which then point to 
the SI themselves.
 

Such a SI has the following structure:

	typedef void* cdecl SI_funcarr;
	typedef struct { 	
		char  		SI_id[4];
		SI_funcarr 	SI_fa;
 	} SI_group; 


A SI consists alway of a unique identifier of four character and 
following a pointer to a field of functions. So a set of functions 
can be taken together under a describing name (e.g. BIOS, GRAF, 
FLOT). With this name F68KANS later can find out, wether a special 
loader offers the functions it needs to execute somme special 
functionality. So, if there is a loader for a text terminal 
without graphics, F68KANS can find out this fact and will not 
perform any graphics program.
 

To achieve it's basic functionality, there always has to be at 
least one SI named 'BIOS'. Additionaly, the 'BIOS'-SI has to be 
the first entry in the pointer array. In my C-source it looks like 
this: 


	SI_funcarr SI_BIOS_fa[] = {
		key, 
		key_quest, 
		emit, 
		emit_quest
	};   


	SI_group SI[2];

	/*
	 * initialisation of system interface
	 */
	strcpy(SI[0].SI_id, "BIOS");
	SI[0].SI_fa = SI_BIOS_fa; 

	strcpy(SI[1].SI_id, "    ");
	SI[1].SI_fa = NULL; 


First, the array of functions is filled with the necessary BIOS 
functions. The the array of all SI's is allocated and then filled 
with the appropriate values. You can see that the string 'BIOS' 
and and the pointer to the array of functions SI_BIOS_fa is placed 
into the 0th SI-entry.
There always has to be one additional dummy SI with four spaces as 
its name. The entry is used a end-of-list sign when using multiple 
SI.

At last, the address of the SI has to be written to the 
FORTHPARAS-structure:

	forthparas.si	 = SI; 



4. Starting the System 

All is prepared now. A simple jump to the start of the codesegment 
after pushing the address of the FORTHPARAS-structure to the 
returnstack should make F68KANS runs:


	typedef void cdecl FUNC(FORTHPARAS*); 
	(*(FUNC*)codeseg)(&forthparas); 


Now F68KANS looks for the first pointer in the SI-field and checks 
wether it finds the name 'BIOS'. If not, F68KANS stops and returns 
to the loader. When it finds the 'BIOS'-SI, it copies the four 
pointer into internal vectors and use them for its I/O performed 
by KEY and EMIT.

After that, all the memory parameters are evaluated and copied 
into the appropriate registers and internal variables.


5. Using extended functionality


Many forth systems suffer from the fact, that they are closes 
systems which, when they are good, allow access to the basic 
resources of the environment. But what happens, when a very good 
new graphic library appears??

In this case, F68KANS offers the opportunity to extend the loader 
with the desired functionality. I myself used this opportunity to 
implement many system functions (file, float, ...) in an extensive 
way, because the libraries I have for that are much better than I 
can ever do it myself. And: I avoid reinventing the wheel.


How does the work?

By adding new system interfaces, of course!

One simply has to add the interface described above the all 
functions needed. As an example I will show some interface 
definitions for some standard C-functions:


	void *cdecl _fopen( char *filename, long len, 
						char *mode, long mlen )
	{ 
	char str1[256];
	char str2[256];

		memcpy( str1, filename, (size_t)len );
		str1[len] = '\0'; 	
		memcpy( str2, mode, (size_t)mlen );
		str2[mlen] = '\0'; 	
	
		return (void *)fopen( str1, str2 ); 
	}


	long cdecl _fputc( long ch, void *file )
	{ return (long)fputc( (int)ch, (FILE*)file ); }


	long cdecl _fputs( char *s, long len, void *file )
	{ 
	char str[256];

		memcpy( str, s, (size_t)len );
		str[len] = '\0'; 	
		return (long)fputs( str, (FILE*)file ); 
	}


	long cdecl _fread( void *ptr, long size, 
						long count, void *file )
	{ 
		return (long)fread( ptr, (size_t)size, 
							(size_t)count, (FILE*)file ); 
	} 



In a similar way to 'BIOS' a new SI named 'CLIB' is created and 
added to the list of the other SIs:


	SI_group SI[3];

	/*
	 * initialisation of system interface
	 */
	strcpy(SI[0].SI_id, "BIOS");
	SI[0].SI_fa = SI_BIOS_fa; 

	strcpy(SI[1].SI_id, "CLIB");
	SI[1].SI_fa = SI_CLIB_fa; 

	strcpy(SI[2].SI_id, "    ");
	SI[2].SI_fa = NULL; 



In contrast to 'BIOS', now on Forth-side there has to be a 
mechanismen, which finds, evaluates and executes the new functions 
in the new SI. This has been implemented with some very simple 
Forth words. 

The most important is the defining word 'systeminterface'. It is 
used this way:  


	systeminterface initCLIB CLIB  CONSTANT CLIBBASE  


With that, the later very important word 'initCLIB' and the 
constant 'CLIBBASE' are defined.

'initCLIB' is created using the name of the SI 'CLIB'. This word 
always has to be executed before using any of the new functions. 
'initCLIB' checks, wether the 'CLIB'-SI is present and initializes 
the SI by storing its address into an internal variable.
This is necessary, because the forth words to be defined, which 
execute the library functions, access these using only an index to 
the array of functions. The base address of this array may change 
from session to session.

The Forth-words executing the functions have to handle the 
parameters correctly. So there is a simple parameter description. 
By default, three different types of input parameters are 
possible:


-	_n		Integer
-	_a		Address
-	_s		String


Notice the underscores!! They are part of the name!

There are four different output parameters:

-	nothing		No returnvalue
-	outint		Integer
-	outptr		Address
-	outstr		String


Strings are common Forth-strings identified by address and length. 


Now, to define a library-function-executing-word there is the 
defining word 'SI:'. It creates a word with a given name, which 
calles the corresponding function with given parameter 
description:


	CLIBBASE 0
			_n	SI: _fgetc	outint ( FILE* -- char )
		_n	_a	SI: _fgetpos outint ( FILE* long* -- ior )
	_a	_n	_n	SI: _fgets	outstr ( char* n FILE* -- c-addr u )
			_n	SI:	_fileno	outint ( FILE* -- handle )
		_s	_s	SI: _fopen	outint 
							( c-addr1 u1 c-addr2 u2 -- FILE* )
		_n	_n	SI:	_fputc	outint ( char FILE* -- char )
		_s	_n	SI:	_fputs	outint ( c-addr u FILE* -- len2 )   
	2DROP

(Note that 'FILE*' beeing a real pointer is handled as a simple 
integer on Forth-side, because the pointer itself does not have 
any meaning for Forth and a NULL-pointer (FILE* == NULL) evaluates 
to a integer 0). 

You now can use the functions '_fputs' as follows: 

	S" Hello World!"  FILEID @  _fputs   . 


The constant CLIBBASE will never be used any more, so that you may 
skip its definition. Here it has be defined for clarity only.

I think, these examples show the usage of the interface to a 
sufficient extent.


The only critical point in the business is that you have to take 
care that the order of the functions in the SI-array of functions 
and in the Forth declaration is the same.

Before using the new functions it is important that the 
initializing word defined by 'systeminterface' ('initCLIB') REALLY 
has been executed. Otherwise F68KANS may crash! This is even more 
important, when the system has been saved by 'SAVE-SYSTEM'. The 
initializing words have to be executed at the start of EVERY 
session. I myself fell into this trap several times and started to 
look for bug in the library functions or the definition of the 
interface. So: be carefull!!
 


