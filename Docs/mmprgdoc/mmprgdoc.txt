
Programmierdokumentation zu MagiCMac

Autor: Thomas Tempelmann (e-mail: 72377.351@compuserve.com o. tt@muc.de)

Die private Weitergabe und Verbreitung dieses Textes ber Mailboxen
ist gestattet. Die aktuellste Version sollte sich jeweils in der
ASH-Mailbox (06221/300389) sowie unter <http://www.muc.de/~tt/>
befinden und kann auch beim Autor per E-Mail (s.o.) angefordert werden.


Hinweis:
  Dieser Text benutzt ATARI-Umlaute!

nderungen:
02.03.95: Beschreibung zu getBaseMode korrigiert (Mac/Atari vertauscht)
03.03.95: Cookie-Version 1.02:
          XBRA-Kette wird nicht mehr mit Null-Zeiger sondern mit Zeiger
          auf RTS-Instruktion abgeschlossen;
          Beschreibung zu mapAppSwitch korrigiert (Supervisor, Finder).
26.03.95: Cookie erweitert um printDescPtr und configKernel.
01.05.95: Cookie-Version 1.04:
          Neuer Zeiger 'atariModePossible' im Cookie hinzugefgt.
          Beschreibung zu mapAppSwitch erweitert (Funktionen 3 und 4).
          Virtual Memory und erforderlichen Supervisor-Modus erl„utert.
13.06.95: Cookie-Version 1.05 (MM-Version 1.2.1):
          Neues Flag zeigt an, wenn MagiCMac auf einem PowerPC l„uft.
          In diesem Fall zeigt der CPU-Cookie zwar an, es handle sich
          um eine 68020, jedoch sind einige 68040-Instruktionen vorhanden,
          z.B. MOVE16. Auerdem kann dann ber den Mixed Mode Manager
          PPC-nativer Code eingebunden werden (s. Inside Macintosh: PPC
          System Software).
13.07.95: Cookie-Version 1.06 (MM-Version 1.2.2):
          'versionOfMacAppl' neu.
          Doku zu 'callMacContext' erweitert.
26.07.95: Doku erweitert zu: 'modeAtari', macAppSwitch', 'controlSwitch',
          'auxControl'.
07.08.95: XCMD-Doku neu, Cookie 1.08.
07.08.95: Proc-Typen in Header-File korrekt spezifiziert, 'giveTimeToMac' neu.
          Cookie 1.09.
24.08.95: 'minStackSize' neu - wer einen eigenen Supervisor-Stack verwendet,
          mu diese Konstante beachten!
10.09.95: Mehrere Abs„tze zu Interrupt- und Mac-Tasks erweitert.
20.10.95: Neue Flags im Cookie ber Verfgbarkeit der I/O-Bereiche.
          Cookie 1.10 (MM-Version 1.2.4).
28.10.95: Einschr„nkungen beim BIOS/XBIOS sowie Cookies neu dokumentiert.
07.11.95: Neues Kapitel "Allgemeine Regeln";
          Cache-L”schen auch bei 68020 n”tig wg. Speed Doubler.
23.01.96: Neues Kapitel "Die Tastaturbelegung".
13.06.96: Kap. ber MacMiNT-Funktionen neu
19.06.96: Cookie: stackLoad/stackUnload neu. Korrektur des Bsp-Codes fr
          Wechsel in den Supervisor-Modus auf Mac-Seite (Label 'ok1' fehlte).
          Beispiel fr "Interrupt-Handler unter MagiCMac" hinzugefgt.
10.09.96: Cookie.configKernel um Funktion (#5) zum Umschalten zur Mac-Seite
          erweitert.
          Cookie 1.12 (MM-Version 2.0.4).


------------------------------------------
Allgemeine Regeln - Sauber programmiereren
------------------------------------------

Wenn auch die spezifische Implementation von MagiCMac nicht fr jeden ATARI-Programmierer
von Interesse ist, so gibt es doch einige Grundregeln, die man auch auf ATARI-Ebene
einhalten sollte, um weitgehend sicher zu sein, da die Programme auch auf MagiCMac
laufen k”nnen.

ù Selbstmodifizierender Code / XBRA-Verkettungen (Assembler-Programmierung)

  Wenn Code ver„ndert wird, mu unbedingt der CPU-Cache gel”scht werden. Wer XBRA-
  Verkettungen ber eine Library-Funktion erzeugt, mu damit rechnen, da auch hier
  Code modifiziert wird, welche aber vermutlich von der Lib-Funktion nicht mit dem
  n”tigen Cache-L”sch-Code versehen wurde.
  Zwar kann man durch Ausprobieren feststellen, da dies auf einer 68020 mit ihrem
  kleinen Cache nicht n”tig w„re, jedoch kann man nie sicher sein: Auf dem Mac gibt
  es einen 68K-Emulator fr die PowerPC-Maschinen, der eine 68020 simuliert, jedoch
  1. einen gr”eren Cache als die echte 68020 hat (incl. Datencache, der sonst erst bei
  der 68030 vorhanden ist) und 2. auch noch den Code in PowerPC-Code kompiliert. Wird
  dann der Code vom ATARI-Programm ver„ndert, kann der Emulator das nur erkennen, wenn
  ein Befehl zum Cache-L”schen ausgefhrt wird.
  Ebenso ist ein Cache-L”schen bei den 68040/60-CPUs in der Regel vonn”ten! Aktuelle
  Macs, sofern sie keine PowerMacs sind, haben meist eine 68040 drin, so da jedes
  Programm, das eigenm„chtig im TEXT-Segment Ver„nderungen vornimmt, unbedingt auch
  den Code zum Cache-L”schen ("Flushen") der 68040/60 enthalten mu!
  Hier ist der Code, mit dem in solchen F„llen der gesamte Cache zu l”schen ist:

  Fr 68020/30 (zur Erkennung einfach den _CPU-Cookie mit 20 und 30 vergleichen!):
    MOVE  CACR,D0
    ORI.W #$0808,D0
    MOVE  D0,CACR
  oder auch so:
    DC.W  $4E7A,$0002,$0040,$0808,$4E7B,$0002
  
  Fr 68040/60:
    NOP
    CPUSHA DC/IC
  oder:
    DC.W   $4E71,$F4F8
  
  Es existiert auch eine Library mit Funktionen zum L”schen der Caches, die von C-
  und BASIC-Routinen bequem aufgerufen werden kann. Sie kann u.A. bei T. Tempelmann
  (s.u.) per E-Mail bezogen werden.
  
ù Interrupts sperren (Assembler-Programmierung)

  Falls kurzzeitig die Interrupts gesperrt werden mssen, dann danach niemals das SR
  auf den festen Wert $2300 setzen, sondern m”glichst vor dem Sperren das alte SR
  sichern (z.B. auf dem Stack) und hinterher wieder zurckladen. Wenn unbedingt ein
  Rcksetzen des SR, unabh„ngig vom alten SR, erfolgen soll, dann die Interrupt-Maske
  auf Null und nicht auf Drei setzen, also z.B. MOVE #$2000,SR statt MOVE #$2300,SR.
  Das ATARI-Betriebssystem sorgt dann automatisch fr das Umsetzen auf Maskenwert 3,
  w„hrend beim Mac die Maske auf 0 bleibt, sonst geht n„mlich nix mehr.

ù Hardware-Zugriffe.

  Bevor man bestimmte Hardware-Register direkt programmieren will (z.B. den Centronics-
  Port zum Drucken), sollte man den Cookie "_MCH" prfen. Ist sein Wert $FFFFFFFF, dann
  heit das, da keine ATARI-Hardware vorhanden ist (das Prg also z.B. auf dem Macintosh
  l„uft) und deswegen auch erst gar nicht versucht werden sollte, auf die Hardware
  zuzugreifen, weil dort dann RAM sein k”nnte, was natrlich nicht durch solche Zugriffe
  ver„ndert werden darf.

ù Supervisor-Modus

  Seit den Multitask-Betriebssystemen, wie MultiTOS und MagiC, sollte kein Programm mehr
  den Supervisor-Stackpointer eigenm„chtig umsetzen, z.B., um einen gr”eren Stack zu
  haben, weil sonst unabsehbare Abstrze passieren k”nnen (auf den PCI-Macs ist z.B. ein
  sehr groer Supervisor-Stack notwendig, mind. 8MB, u.U. aber auch 24MB - dies kann nur
  das Betriebssystem wissen und korrekt installieren).
  
  Wichtig: Um in den Supervisor-Modus zu gelangen, keinesfalls die GEMDOS-Funktion Super()
  verwenden, sondern Supexec() aus dem XBIOS! Nur Supexec() kann sicherstellen, da ein
  ausreichend groer Supervisor-Stack verwendet wird.


-----------------------
Allgemeines zu MagiCMac
-----------------------

Den Kern der "Emulation" der Atari-Umgebung auf dem Macintosh liegt in der
Umprogrammierung der PMMU. Sowohl Atari- als auch Macintosh-Programme gehen davon
aus, da sie in den untersten 2 KB des Adreraums bestimmte Variablen (die sog.
Systemvariablen) vorfinden. Wenn nun ein Atari-Programm l„uft, erwartet es aber
dort andere Werte als z.B. das Mac-Betriebssystem. Der sog. Kernel von MagiCMac
sorgt nun dafr, da je nachdem, ob gerade eine Mac- oder eine Atari-Routine
l„uft, die passenden Systemvariablen im unteren Adrebereich vorliegen. Dies
geschieht durch entsprechende Programmierung der PMMU, einem Coprozessor fr die
Speicherverwaltung.

So gibt es also zwei MMU-Modi: Den Mac- und den Atari-Modus. Zwischen ihnen kann
mittels zweier Routinen hin- und hergeschaltet werden (s.u.). Ausgehend davon,
da das Mac-Modus der normale Modus ist, gibt es folgende Ver„nderungen beim
šbergang in den Atari-Modus:

1. Ein Speicherbereich, der irgendwo auf dem Macintosh-Heap alloziert wurde, wird
ab Adresse $0 im Atari-Adreraum eingeblendet. Dieser Bereich ist zwischen 4 und
32KB lang und enth„lt garantiert ausschlielich die Exception-Vektortabelle und
die dokumentierten Systemvariablen.

2. Der Adreraum von $00FF8000 bis $00FFFFFF (und entsprechend $FFFF8000 bis
$FFFFFFFF) wird ausgeblendet.
Dies ist beim Atari der I/O-Adreraum, der normalerweise beim Macintosh nicht
zur Verfgung steht (dort ist beim Macintosh h”chstens RAM).
Damit Programme nicht irrtmlich diesen Adreraum als RAM ansprechen, falls beim
Macintosh dort solches vorliegt, wird durch diese Ausblendung jeder Zugriff zu
einem Bus-Fehler fhren. Allerdings ist es m”glich, da spezielle
Atari-kompatible Hardware im Macintosh installiert wird, woraufhin dieser
Adreraum dann diese Harware an den entsprechenden Stellen einblendet. Das heit:
Ein Programm, das erkennt, da es unter MagiC auf dem Mac l„uft, sollte nicht
automatisch davon ausgehen, da keine Atari-Hardware im I/O-Bereich vorhanden ist,
sondern sollte weiterhin mit einem Testzugriff (durch Umlenken des
Bus-Fehler-Vektors) prfen, ob Zugriffe auf die Bausteine m”glich sind.

3. RAM, das weder zur TPA von MagiC, noch zum MagiC OS oder den Kernel-Daten und
-Routinen geh”rt, ist im Atari-Adreraum nicht vorhanden, d.h. Zugriffe auerhalb
des speziell fr Atari-Programme reservierten Bereichs fhren zu einem
Bus-Fehler. Dies schtzt andere Macintosh-Applikationen besser vor fehlerhaften
Atari-Programmen.
Dieser Schutz funktioniert allerdings nur bei 68K-Rechnern, nicht bei PowerPCs!


----------------------------------------------
Zusammenarbeit von MagiC und MacOS (Mac-Tasks)
----------------------------------------------

MagiCMac h„ngt sich direkt in alle Interrupt-Vektoren, die der Macintosh benutzt.
Wenn MagiC l„uft und ein Hardware-Interrupt auftritt, schaltet MagiCMac die MMU
zurck in den normalen Macintosh-Modus. Am Ende der Intr-Routine wird zurck
in den Atari-Modus gewechselt und das unter MagiC laufende Programm fortgefhrt.
Solange der Mac-Modus aktiv ist, mischt sich MagiCMac nicht weiter in die
Intr-Bearbeitung ein, sondern nur, solange der Atari-Modus aktiv ist.

Immer dann, wenn vom Mac-Modus zurck in den Atari-Modus gewechselt wird,
wird noch berprft, ob eine bestimmte Zeit verstrichen ist (in Ticks gemessen;
ein Tick ist ca. 1/60s), um dann ggf. periodische Aufgaben zu erledigen. Diese
werden hier Mac-Tasks genannt.

Mac-Tasks erledigen u.A. folg. Dinge:
- Pollen der Mac-Events (Aufruf d. Mac-Funktion GetOSEvent bzw. WaitNextEvent).
- Auswerten von Befehl-Q und Befehl-W.
- Auswerten externer Apple-Events, z.B. Suspend/Resume (MagiCMac in den
  Hintergrund schalten) und externes Beenden.
- Rechenzeitabgabe an andere Macintosh-Applikationen (durch WaitNextEvent).

Die Entscheidung, ob zum Pollen der Events GetOSEvent oder WaitNextEvent (WNE)
benutzt wird, kann ber die Preferences und auch eine Cookie-Funktion (s.u.)
eingestellt werden. Nur, wenn WNE benutzt wird, wird auch Rechenzeit an andere
Mac-Applikationen abgegeben.

Mac-Tasks drfen nur ausgefhrt werden, wenn sicher ist, da gerade keine andere
MacOS-Funktion bearbeitet wird, denn das MacOS ist nicht reentrant. Mac-Tasks
werden deshalb nur dann ausgefhrt, wenn alle folg. Bedingungen zutreffen:
- Nach der Unterbrechung (Interrupt oder Aufruf von modeAtari) wird der
  Atari-Modus aktiv sein und die Interrupt-Level-Maske ist Null, d.h, es ist
  kein anderer Interrupt in Bearbeitung (um dies sicherzustellen, mu in
  Intr-Handlern, die vom Mac-Modus in den Atari-Modus wechseln, intrLock
  korrekt benutzt werden, s.u.).
- Es wird gerade keine Routine im Mac-Kontext ausgefhrt (s. callMacContext).
- MagiCMac ist nicht dabei, sich zu beenden.


-------------------------
Exceptions unter MagiCMac
-------------------------

Ein Atari-Programm kann, wie auf einem echten Atari, die Exception-Vektoren
benutzen, sprich: umlenken. Allerdings darf das Programm dabei nur die
Exception-Vektoren im Adrebereich zw. $0 und $400 benutzen, nicht etwa die, auf
die das VBR zeigt (denn es zeigt woanders hin!). Wer sich daran nicht h„lt, kann
Schwierigkeiten mit sp„teren Versionen von MagiCMac bekommen. Programme, die die
PMMU benutzen, z.B. OUTSIDE, k”nnen unter MagiCMac nicht laufen.

Folgende Atari-Interrupts werden z.Zt. vom Kernel simuliert:
- $070: Autovektor-Interupt Level 4 (VBL).
- $114: MFP-Interrupt 5 (200 Hz System-Timer).
- $118: MFP-Interrupt 6 (IKBD). Allerdings wird hier nur das Ereignis von
  Tastendrcken und Mausbewegungen simuliert, d.h., der Interrupt-Handler erf„hrt
  die spezifische Art des Ereignisses auf eine andere Art als beim Atari.
Die Interrupts treten bedingt durch die Mac-Hardware jedoch evtl. mit anderen
Priorit„ten auf; die Interrupt-Maske des SR hat somit u.U. andere Werte als beim
Atari.
Der Vektor bei $400 (etv_timer) wird natrlich vom MagiC OS auch angesprungen,
als Unterroutine vom Interrupt-Handler fr MFP Intr. 5, ganz wie beim
Original-Atari auch. Ebenso kann sich ein Programm, das Maus- oder
Tastenereignisse erfahren m”chte, ber die XBIOS-Funktion Kbdvbase() in die
Ereignisvektoren ganz wie beim Atari einh„ngen.

Noch ein wichtiger Hinweis zu Interrupts: Beim Mac mu, damit Tastatur, Maus und
Timer funktionieren, die Interrupt-Maske (im CPU-Register SR) stets auf Null
stehen. Beim Atari dagegen steht sie normalerweise auf Drei. Programme, die nun
Code, wie z.B. MOVE #$2300,SR enthalten, werden einen Macintosh in einen
Schlafzustand versetzen, bei dem nur noch ein Reset hilft. Wer also die
Interrupt-Maske nur zeitweise ver„ndert sollte dies so machen (funktioniert auf
Atari und Mac gleichermaen):
  MOVE SR,-(A7)    ; altes SR merken
  ORI  #$0700,SR   ; alle Interrupts fr einen kritischen Zugriff sperren
  ...
  MOVE (A7)+,SR    ; am Ende altes SR wiederherstellen
Wer unbedingt den Rechner wieder in einen Grundzustand bringen will, sollte nicht
MOVE #$2300,SR sondern besser MOVE #$2000,SR benutzen. Auf dem Atari wird dann in
krzester Zeit von der HBL- Interrupt-Routine das SR auf $2300 hochgesetzt. So
kommt man auf beiden Maschinen mit dem selben Code zum Ziel.

--------------------------------
Interrupt-Handler unter MagiCMac
--------------------------------

Werden Interrupt- oder andere asynchrone Routinen mittels MacOS-Funktionen
installiert und sollen dann diese Funktionen vom Mac- in den Atari-Modus schalten,
sind einige Dinge zu beachten, die weiter unten genauer beschrieben sind:
- Deinstallation der Routine beim Beenden von MagiCMac (s. macAppSwitch).
- Setzen eines Semaphores (s. intrLock/intrUnlock) vor/nach ATARI-Modusumschaltung.
- Abfrage, ob zu dem Zeitpunkt eine Atari-Modusumschaltung berhaupt m”glich ist
  (s. atariModePossible).
- Vor der Umschaltung in den Atari-Modus mu sichergestellt sein, da der Stack
  Pointer (SP) innerhalb des Atari-Adreraums befindet, weil es sonst zum
  doppelten Bus-Error kommt und die CPU stehen bleibt.
  Merke: 1. Es kann sein, da der Aufruf der Routine durch das MacOS dann erfolgt,
  wenn eine andere Mac-Applikation l„uft und dann ist der aktuelle Stack nicht der
  von MagiCMac. 2. Bei den 68K-Maschinen ist im Atari-Modus nur der Adreraum
  der 2 TPAs, den untersten 32KB, ggf. der I/O-Bereich sowie der Bereich der
  MagiCMac-Applikation sichtbar, anderer Speicher vom MacOS und anderen Mac-
  Applikationen wird ausgeblendet, dort gibt's dann nur Bus-Errors.
  Fazit: Um sicherzustellen, da beim Schalten in den Atari-MMU-Modus der SP
  im Atari-Adreraum liegt, mu vorher ein Stack-Bereich dafr reserviert werden
  und dieser dann benutzt werden. Um sicherzustellen, da der Stack gro genug
  ist (1-2 KB sind deutlich zu wenig!), ist der Cookie-Wert 'minStackSize' zu
  beachten (s.u.)!
  Um diesen Stack zu benutzen, sollte das Programm A7 nicht selbst auf das Ende
  des Stack-Bereichs setzen, sondern dazu die Funktion 'stackLoad' aufrufen,
  weil auch das MacOS ber diese Stack-nderung informiert werden mu.
- Immer in den Supervisor-Modus wechseln, bevor 'modeAtari' aufgerufen wird
  (sonst l„uftºs nicht unter Virtual Memory).
  Dazu wird folgender Code vorgeschlagen:
    clr     d0
    move    sr,d0
    btst    #13,d0
    bne     ok1
    moveq   #8,D0        ;   EnterSupervisorMode
    dc.w    $A08D        ;   _DebugUtil, „ndert nur D0/A0/A7
  ok1:
    move    d0,-(a7)     ; Sichern des alten SR
    ; hier nun modeAtari ... modeMac usw. aufrufen.
    move.w  (a7)+,sr     ; Wiederherstellen des alten Supervisor- oder User-Modus
- Mac-Subroutinen drfen in der Regel nur die Register D0-D2/A0/A1 ver„ndern,
  jedoch nicht, wie beim Atari oft blich, A2!

Als Beispiel fr eine korrekte Anwendung dieser Regeln folgt hier die Abbildung
der MagiCMac-Routine, die den 200Hz-Vektor unter MagiC aufruft:

        ; alle Regs retten, die zerst”rt werden k”nnten
        movem.l d0-d2/a0/a1,-(a7)
        
        move.l  atariModePossible,a1
        tst.b   (a1)               ; drfen wir modeAtari rufen?
        beq     nocall

        ; in den Supervisor-Modus wechseln
        clr     d0
        move    sr,d0
        btst    #13,d0
        bne     ok1
        moveq   #8,D0
        _DebugUtil                 ; „ndert nur D0/A0/A7
ok1:    move.w  d0,-(a7)

        ; Intr-Semaphore setzen
        move.l  intrLock,a1
        jsr     (a1)

        ; Stack im MagiC-Adrebereich benutzen (stackLoad: s. unten)
        lea     StackDesc,a0  ; Stack, mind. so gro wie 'minStackSize'
        move.l  stackLoad,a1
        jsr     (a1)

        ; ATARI-Kontext aktivieren
        move.l  modeAtari,a1
        jsr     (a1)

        ; 200Hz-Handler aufrufen (Exception simulieren)
        move    #$0114,-(a7)       ; Exc Format Word
        pea     excrtn
        move    sr,-(a7)
        move.l  $114,a0            ; MFP: 200Hz Interrupt
        jmp     (a0)

excrtn: ; Rckkehr von 200Hz-Handler, aufr„umen:
        move.l  modeMac,a1
        jsr     (a1)
        move.l  stackUnload,a1
        jsr     (a1)
        move.l  intrUnlock,a1
        jsr     (a1)
        move    (a7)+,sr           ; SR zurck
nocall: movem.l (a7)+,d0-d2/a0/a1
        ; das war's fr den MagiC-spezifischen Teil.


--------------------------------------------------
Einschr„nkungen der MagiC-Betriebssystemfunktionen
--------------------------------------------------

MagiCMac implementiert nicht alle Funktionen, die MagiC fr ATARIs bietet.
AES, VDI & GEMDOS sind m.W. vollst„ndig implementiert, beim BIOS & XBIOS gibt
es aber Einschr„nkungen. Es ist jedoch m”glich, da durch Zus„tze, wie McSTout
oder einen Sound-Treiber, einige der Funktionalit„ten wiederhergestellt werden.

ù Nicht implementierte bzw. ignorierte Funktionen beim XBIOS:
  Initmous, Mpfint, Ikbdws, Jdisint, Jenabint, Giaccess, Offgibit, Ongibit,
  Xbtimer, Dosound, 

Auerdem gibt es Einschr„nkungen bei einigen Funktionen, haupts„chlich in
Verbindung mit dem Dateisystem und den Devices:

ù Das MIDI-Device ist z.Zt. nicht benutzbar, es sei denn, die Hardware-Erweiterung
  McSTout mit MIDI-Option ist installiert. Es kann auch sein, da MIDI sp„ter ber
  eine der seriellen Schnittstellen des Macs realisiert wird, so da man lediglich
  sagen kann: Ob MIDI benutzbar ist, mu der Benutzer festlegen - ein Programm kann
  das praktisch nicht selbst erkennen!
  Fr Midiws() gilt das gleiche.

ù Das IKBD-Device ist nicht vorhanden.

ù Liefert Getpbp() Null, kann es sein, da eine Mac-formatierte Disk einliegt,
  die sich dennoch mit den Dateifunktionen ber Laufwerk A: ansprechen l„t.

ù Liegt eine Mac-formatierte Disk im Floppy-Laufwerk, liefert Rwabs() einen Fehler
  ("drive not ready"). Die Dateien auf der Disk k”nnen ggf. dennoch mit den GEMDOS-
  Dateifunktionen angesprochen werden.

ù Drvmap() liefert auch gesetzte Bits bei den Laufwerken, die Mac-formatiert sind
  und somit nur ber GEMDOS und nicht mit Rwabs() ansprechbar sind.

ù Getrez() liefert m.W. immer 2 (ST-High), ist also unbrauchbar.

ù Setscreen() kann die phys. Adresse nur „ndern, wenn der Benutzer MagiCMac im
  ST-Aufl”sungsemulationsmodus (z.B. f. ST-High) gestartet hat. Um zu erkennen,
  um dies der Fall ist, sollte man zuerst die Adr. mit Setscreen zu „ndern
  versuchen und dann mit Physbase() ermitteln, ob sich die Adresse „ndern lie.

ù Floprd(), Flopwr(), und Flopver() funktionieren nicht, wenn Mac-formatierte
  Disks eingelegt sind (erst ab MM 1.2.2 implementiert).
  Die Bad-Sector-Liste bei Flopver() meldet im Fehlerfall alle Sektoren der
  Spur als defekt, da die genaue Spur nicht ermittelt werden kann.

ù Flopfmt() kann seit MM 1.2.2 Disks formatieren, aber nur 80 Spuren, 2 Seiten
  und je nach eingelegter Disk 9 bzw. 18 Sektoren pro Spur. šber den MgMc-Cookie
  kann hierzu ermittelt werden, was fr eine Disk (DD oder HD) sich im Laufwerk
  befindet. Nicht wundern: Der Mac bietet nur eine Funktion, um alle Spuren auf
  einmal zu formatieren. Deswegen wird das bei MM so gel”st, da bei Aufruf von
  Flopfmt() fr Spur 0 (bzw. 79, je nachdem, wo angefangen wird) gleich die ganze
  Disk formatiert wird und bei Aufruf von Flopfmt fr die restlichen Spuren nichts
  passiert, die Funktion also sofort mit Fehlercode Null zurckkehrt.
  Auch ist es so, da im Fall eines Formatierproblems fr alle Spuren ein Fehler
  gemeldet wird. Die zu formatierende Disk mu folglich v”llig in Ordnung sein.

ù Rsconf(): Die MFP-spezifischen Parameter werden ignoriert.

ù Puntaes() kennt mehrere Modi (siehe MagiC-Doku), MagiCMac wird ggf. beendet.


--------------------
Die Tastaturbelegung
--------------------

Generell werden die selben Tastencodes (Scan-Codes) erzeugt, wie unter
MagiC fr ATARI.

Fr Macintosh gibt es verschiedene Tastaturen mit unterschiedlich vielen
Tasten:
Die "Erweiterte" (auch "Design-Tastatur") haben ein Layout wie bliche
PC-Tastaturen, also 15 F-Tasten und auch einen umfangreicheren Cursor-
Block (s.u.). Es gibt auch viele Tastaturen, die weit weniger Tasten als
ein ATARI haben, z.B. die "Standard" (eingeschr„nkter Cursor-Block) sowie
insbesondere die der PowerBooks (portable Macs).

Die Sondertasten vom ATARI k”nnen bei den eingeschr„nkten Tastaturen
durch Kombination mit der Befehlstaste (dies ist eine weitere Umschalttaste
neben Shift, Ctrl und Alt, die jeder Mac hat) erzeugt werden, jedoch sind
nicht alle ATARI-Tasten auf diese Weise erzeugbar. So hat ein Benutzer z.B.
bei Signum das Problem, da er nicht an die Zeichen kommt, die auf dem
Ziffernblock liegen, wenn er ein PowerBook benutzt (man sollte wissen, da
man an den meisten PowerBook wiederum eine "Erweiterte" Tastatur anschlieen
kann, um dieses Problem zu l”sen, jedoch ist das keine L”sung fr Jedermann).

Mit den groen Tastaturen ("Erweiterte", "Design") kann der Benutzer Tasten
benutzen, die auf dem ATARI nicht vorhanden sind.
Zur Zeit erzeugen diese Tasten folgende Scan-Codes (ASCII-Code ist undefiniert
und sollte ignoriert werden):

  Page Up   - 73
  Page Down - 81
  End       - 79
  F11       - 69
  F12       - 70
  F14       - 55

Alle Werte natrlich dezimal.
Die anderen Tasten, wie z.B. F13 oder F15, sind bereits als bliche ATARI-
Tasten belegt, hier z.B. Help und Undo.

In einer sp„teren Version wird es m”glich sein, da jeder Benutzer seine am
Macintosh vorhandenen Tasten frei mit ASCII- und Scan-Codes belegt. Dann
hat er die Freiheit, Kombinationen von Scan- und ASCII-Code zu definieren,
die beim ATARI nicht vorkommen. Deshalb sollte jedes ATARI-Programm genau
wissen, ob es nun an einer Taste oder an einem ASCII-Wert interessiert ist
und je nachdem auch nur den Scan-Code oder den ASCII-Anteil eines Tastencodes
auswerten und keine Annahmen ber den anderen Teil machen, solange das m”glich
ist (keine Panik - der Benutzer wird nicht jegliche Freiheit erhalten, so
wird er z.B. bei dem Cursortasten an die bisher blichen Kombinationen
gebunden bleiben).


---------------------------
Dateisysteme unter MagiCMac
---------------------------

MagiCMac untersttzt z.Zt. zwei Dateisysteme:

1. FAT-Dateisysteme nach TOS-Konventionen. So k”nnen Floppy-Disks sowie Hard-Disks
im Atari-blichen Format mit allen TOS-Funktionen (GEMDOS, aber auch z.B. Rwabs)
angesprochen werden.

2. Mac-Dateisysteme. Da diese keine FAT haben, ist der Zugriff auf diese Laufwerke
nur ber GEMDOS, nicht jedoch ber BIOS, m”glich.

Das Mac-Dateisystem unter MagiCMac:

MagiC erlaubt, „hnlich wie MiNT, die Einbindung von Treibern fr andere Dateisysteme.
Mehr zur Implementation solcher Treiber findet sich in anderen Dokumentationen
vom MagiC-Autor Andreas Kromke. Diese Dokus sind z.B. ber ASH erh„ltlich.

Da die GEMDOS-Funktionen meist direkt auf die Mac-Dateisystemfunktionen
abgebildet sind, k”nnen alle unter Mac OS benutzbaren Dateiformate auch unter
MagiCMac benutzt werden, d.h., sobald man ein Laufwerk auf dem Mac "mounten"
kann, ist es oder ein Ordnerinhalt davon auch als Laufwerk unter MM anmeldbar.
Damit k”nnen in der Regel auch CD-ROMs oder Netzwerklaufwerke ohne weitere
Treiber in MagiCMac benutzt werden.

MagiCMac erlaubt z.B. auch das Mac-typische Auswerfen von Diskette (sp„ter auch
andere Laufwerke, also CD-ROMs usw.). Wie das geht, steht ebenfalls in den o.g.
Dokus.


-------------------------------------------
Besonderheiten bei Power Macintosh Rechnern
-------------------------------------------

1.
Die von MagiC nicht benutzten, aber im Mac-Adreraum vorhandenen Adrebereiche
k”nnen nicht ausgeblendet und damit auch nicht zugriffsgeschtzt werden. D.h.,
da bei Zugriffen auerhalb der TPA und dem Programm- und Heap-Bereich von
MagiCMac keine Bus-Errors gemeldet werden, wie es bei den 68K-Rechnern der Fall
ist.

2.
Bei den PowerMac-Modellen seit Mitte 1995 wird der obere Adrebereich fr PCI-
Karten und/oder ROM verwendet. So erh„lt man beim Zugriff auf den Atari-I/O-
Bereich bei $FFFF8000-$FFFFFFFF keinen Bus-Error sondern undefinierte Daten.
Dies ist leider nicht zu „ndern.
Es wird daher empfohlen, da Programme nur auf den I/O-Bereich bei $00FF8000-
$00FFFFFF zugreifen, um entweder das Vorhandensein von Bausteinen zu prfen
(indem ein Zugriff darauf gemacht wird und geprft wird, ob dabei ein Bus-Error
auftritt) oder mit der Hardware-Erweiterung "McSTout" arbeiten zu k”nnen fr
den Fall, da sie auch fr die PCI-Macs verfgbar gemacht wird.
Programme k”nnen diesen Umstand ggf. an Bit 5 in 'Cookie.flags1' erkennen (s.u.).


----------------------
Cookies unter MagiCMac
----------------------

MagiCMac legt folg. Cookies an:

ù _CPU: enth„lt den Wert 20, 30 oder 40 - auf 68000-Rechnern l„uft MM nicht,
  bei PowerPC-Rechnern wird eine 68020 angezeigt.

ù _FPU: die blichen Werte; bei einer 68040 (nicht 68LC040!) steht standard-
  m„ig ab MM 2.0.4 der Wert 8 drin (vorher 0).

ù _MCH: $FFFFFFFF - zeigt an, da keine Atari-kompatible HW vorhanden ist.

ù _VDO: $FFFFFFFF - (wie bei _MCH)

ù _SND: 0.

ù _FDC: $014D6163 - Die 3 letzten Bytes ergeben den Text "Mac"

ù MagX: Werte siehe MagiC-Doku.

ù MgMc: s.u.

ù MNAM: Zeiger auf 0-terminierten String mit Namen des Rechners. Dient nur zur
  Information fr den Benutzer.

ù PMMU: 0 (zeigt an, da die MMU belegt ist und nicht von anderen Prgs benutzt
  werden darf).


---------------
Der MgMc-Cookie
---------------

MagiCMac legt einen Cookie mit der Kennung "MgMc" an. Sein Argument ist ein
Zeiger auf folgende Struktur:

struct MgMcCookie {
 short   vers;              // Cookie-Version im BCD-Format ($0214 entspr. 2.14).
 short   size;              // Gr”e der gesamten Struktur in Bytes.
 long    flags1;            // Flags, Beschreibung siehe unten.
 PixMap  *scrnPMPtr;        // Zeiger auf Screen-Beschr. (s. Inside Macintosh)
 Boolean *updatePalette;    // Ist zu setzen, um Farbtabellen zu restaurieren.
 ProcPtr modeMac;           // MMU-Umschaltung auf Mac-Modus. Zerst”rt keine Regs.
 ProcPtr modeAtari;         // MMU-Umschaltung auf Atari-Modus. Zerst. keine Regs.
 ProcPtr getBaseMode;       // Liefert in D0.W MMU-Modus (0:Mac, sonst Atari).
                            // Zerst”rt sonst keine Regs.
 ProcPtr getIntrCount;      // Liefert in D0.L Intr-Semaphore-Z„hler (0:frei).
                            // Zerst”rt sonst keine Regs.
 ProcPtr intrLock;          // Erh”ht Interrupt-Semaphore-Z„hler. Z. k. Regs.
 ProcPtr intrUnlock;        // Erniedrigt Interrupt-Semaphore-Z„hler. Z. k. Regs.
 ProcPtr callMacContext;    // Fhrt Routine im Mac-Kontext aus, Proc-Adr auf
                            // Stack. Ver„ndert D0-D2/A0/A1/A5/A7.
 Ptr     atariZeroPage;     // Zeiger auf den Atari-Speicherbereich $0-$800
                            // im Mac-Adreraum
 Ptr     macA5;             // Wert des A5-Registers im Mac-Kontext
 ProcPtr macAppSwitch;      // Aufruf durch MagiC-Kernel (D0/4(A7): 0:Suspend,
                            // 1:Resume, 2:Quit, 3/4: 'atariModePossible' wechselt)
 ProcPtr controlSwitch;     // Aufruf durch MagiC-Kernel (D0/4(A7):
                            // Atari-Screen 0:Hide, 1:Show)
 long    hardwareAttr1;     // z.Zt. undefiniert.
 long    hardwareAttr2;     // z.Zt. undefiniert.
 Ptr     magiC_BP;          // Zeiger auf Base Page des MagiC OS.
 Ptr     auxOutName;        // Zeiger auf Pascal-String fr AUX-Ausgabe-Device
 Ptr     auxInName;         // Zeiger auf Pascal-String fr AUX-Eingabe-Device
 ProcPtr auxControl;        // Aufruf durch MagiC-Kernel (D0/4(A7): 0:Suspend,
                            // 1:Resume, 2:Quit)
 PrintDesc *printDescPtr;
 GenProc configKernel;      // Aufruf nach C-Konvention, in Atari-Modus
 Boolean *atariModePossible;// Zgr. auf ein Flag, das anzeigt, ob der Aufruf von
                            // modeAtari augenblicklich erlaubt ist.
 MacVersion *versionOfMacAppl; // (ab v1.06) Version der MagiCMac-Applikation
 void    *hwEmulSupport;    // (ab1.07) fr internen Gebrauch.
 FlpDrvInfo *floppyDrvInfoPtr; // (ab 1.07) zeigt auf Infos fr Laufwerke A: und B:
 XCMDMgrRec *xcmdMgrPtr;    // (ab 1.08) XCMD-Interface
 ProcPtr giveTimeToMac;     // (ab 1.09) Aufrufen im Mac-Context, wenn Idle.
 long    minStackSize;      // (ab 1.09) Mindest-Supervisor Stack-Gr”e
 GenProc ext;               // (ab 1.10) Hilfsroutinen, Aufruf aus Atari-Modus
 GenProc extMac;            // (ab 1.10) wie "ext", Aufruf aus Mac-Kontext
 ProcPtr stackLoad;         // (ab 1.11 / MagiCMac 2.0)
 ProcPtr stackUnload;       // (ab 1.11 / MagiCMac 2.0)
 long    reserved[3];       // z.Zt. undefiniert.
};

typedef long (*GenProc) (short function, void *data);

typedef Boolean (*PrSetupProc) (Boolean alwaysInteractively);
typedef void (*VoidProcPtr) (void);

typedef struct {
 THPrint     printHdl;      // Printer-Konfiguration (f. NVDI)
 PrSetupProc doPrintSetup;  // Printer-Konfig-Dialog (f. NVDI)
 VoidProcPtr saveSetup;     // Printer-Konfig. sichern (f. NVDI)
 long        reserved[7];
} PrintDesc;

typedef struct {    /* 'vers' resource definition, see Inside Mac docs */
    byte    vm;     /* first part of version number in BCD */
    byte    vn;     /* second and third part of version number in BCD */
    byte    vt;     /* development: 0x20, alpha: 0x40, beta: 0x60, release: 0x80 */
    byte    vd;     /* stage of prerelease version */
    short   region; /* region code */
    char    str[];  /* two version strings */
} MacVersion;

typedef struct {
    Boolean inserted;       /* true: disk is inserted and available to GEMDOS/BIOS functions */
    Boolean highDensity;    /* true: HD disk inserted, false: none or DD disk inserted */
    short   res1;           /* reserved */
    long    res2;           /* reserved */
} FlpDrvInfo;

typedef struct {
    void    *start;
    long    length;
} MemArea;

(Die XCMD-Strukturen sind in MgMc_API.h enthalten)


Hinweise:

ù Unbenutzte Bits und undefinierte Werte sind stets Null!

ù "short" hat 16 Bit, "long" 32 Bit, "char" 8 Bit (signed)

ù Alle Zeiger bleiben konstant, d.h., es ist erlaubt, sich einmal die
Zeigerinhalte zu kopieren und damit dann zu arbeiten.

ù Aufruf nach C-Konvention bedeutet, da Parameter auf dem Stack bergeben werden
und da Register D0-D2/A0-A2 zerst”rt werden k”nnen.

ù flags1: Gesetze Bits bedeuten jeweils:
  0: 640*400-Emulation aktiv. (sp„ter ggf. auch fr andere Aufl”sungs-Emulationen,
     z.B. ST-Mittel und ST-Low).
  1: Rechte und linke Shift-Tasten liefern verschiedene Scan-Codes. Dies ist nur
     bei der "Erweiterten" und der "Design"-Tastatur beim Mac m”glich, alle anderen
     Tastaturen k”nnen die beiden Tasten nicht unterscheiden und MM simuliert dann
     immer nur das Drcken der linken oder rechten Shift-Taste (ist ggf. vom
     Anwender konfigurierbar).
  2: (ab Cookie-vers 1.01) 2-Tasten-Maus ist angeschlossen, d.h. der Anwender kann
     bequem die rechte und linke Maus-Taste benutzen. Normalerweise haben Mac-M„use
     nur eine Taste und so mu der Anwender die rechte Taste unter MagiCMac mit
     Hilfe eines Tastaturkommandos simulieren.
  3: (ab Cookie-vers 1.05) MagiCMac l„uft in der 68K-Emulation auf einem PowerPC-
     Rechner.
  4: (ab Cookie-vers 1.10) Der untere I/O-Bereich ($00FF8000-$00FFFFFF) ist nicht
     als solcher vorhanden, d.h., dort kann sich ganz normales RAM, wie an jeder
     anderen Stelle auch, befinden. In diesem Fall wird auch keine Unterscheidung
     zw. ST- und TT-RAM gemacht - das ganze von MagicMac benutzte RAM, auch das
     oberhalb von 16MB, wird als ST-RAM verfgbar gemacht.
     Das bedeutet natrlich, da in diesem Fall Programme keine I/O-Zugriffe auf
     diesem Bereich machen drfen! Ist dieses Bit gel”scht, kann ein Programm
     jedoch dort Zugriffe machen und mit einem Bus-Error rechnen, falls keine
     Atari-kompatible Hardware (wie z.B. "McSTout") dort installiert ist.
  5: (ab Cookie-vers 1.10) Der obere I/O-Bereich ($FFFF8000-$FFFFFFFF) ist nicht
     als solcher zug„nglich (s. "Besonderheiten bei Power Macintosh Rechnern");
     bei Zugriff erh„lt man keinen Bus-Error sondern Daten aus dem Macintosh-ROM.

ù macAppSwitch/controlSwitch: Hier k”nnen sich Atari-Routinen per XBRA einh„ngen.
Sie werden dann im Atari-Modus (Supervisor-Modus) aufgerufen, wenn eines der
angegebenen Ereignisse eintritt. Dies ist z.B. n”tig, wenn ein Atari-Programm
sich bestimmter Macintosh-Routinen bedient. So kann sich z.B. ein Programm, das
die Sound-Routinen des Mac benutzt, hierber informieren lassen, wenn MagiCMac
beendet wird, um dann die Sound-Kan„le zu schlieen und Speicher frei- zugeben.
Folgende Werte werden in D0.W und auf dem Stack bergeben (und mssen dort
auch bleiben):
macAppSwitch:
  0: Suspend: MagiCMac tritt in den Hintergrund - eine andere Mac-Applikation
     kommt in den Vordergrund (z.B. der Finder).
  1: Resume: MagiCMac ist wieder die Vordergrundapplikation auf Mac-Seite.
  2: Quit: MagiCMac wird nun beendet.
  3: Das Flag 'atariModePossible' (s.u.) wird danach FALSE (0)
  4: Das Flag 'atariModePossible' (s.u.) ist wieder TRUE (1)
controlSwitch:
  0: Hide: Maus- und Tastaturkontrolle fr MagiC setzen aus, weil z.B. ein Mac-
     Dialog ge”ffnet ist. Es sollten dann auch keine Ausgaben auf den Bildschirm
     geschehen (z.B. bei Interruptroutinen), weil damit sonst der Mac-Dialog
     berschrieben werden k”nnte.
  1: Show: Gegenteil von Hide.
Aufruf beider Routinen im Atari-Supervisor-Modus, der USP ist undefiniert!

ù Falls getBaseMode in einem Interrupt aufgerufen wird, liefert die Funktion den
Modus, der zum Zeitpunkt vor der Interrupt-Bearbeitung bestand.

ù modeMac kann jederzeit aufgerufen werden, auch in Interrupt-Routinen, sofern
sich das Programm z.Zt. im Atari-Modus und im Supervisor-Modus befindet. Danach
kann auf den gesamten Mac-Adreraum zugegriffen werden. Der Speicher, der im
Atari-Modus bei Adresse Null beginnt, beginnt im Mac-Modus dort, wohin
atariZeroPage zeigt. Wurde von einer normalen Atari-Anwendung aus mittels modeMac
in den Mac-Modus gewechselt, drfen nur solche MacOS-Routinen aufgerufen werden,
die auch im Interrupt aufgerufen werden drfen (s. Inside Macintosh), ggf. mu
dazu noch das Register A5 mit dem Wert aus macA5 belegt werden. Andere Routinen
sollten nur ber callMacContext aufgerufen werden (s.u.), insbesondere solche,
die QuickDraw-Routinen benutzen -- ggf. ist das auszuprobieren. Falls ein Aufruf
von callMacContext n”tig ist, erkennt man es oft daran, da sonst Busfehler
auftreten oder keine Texte in Dialogboxen usw. erscheinen.

ù modeAtari: Bevor diese Funktion aufgerufen werden kann, mssen folg. Bedingungen
zutreffen:
1. Der Mac-Modus mu aktiv sein.
2. Die CPU mu sich im Supervisor-Modus befinden. Unter Virtual Memory laufen Mac-
Programme und auch die Mac-Interrupt-Routinen im User-Modus. Falls von dort heraus
zeitweise in den Atari-Modus gewechselt werden soll, mu zuvor in den Supervisor-
Modus gewechselt werden. Siehe dazu "EnterSupervisorMode" weiter oben.
3. Der aktuelle Stack mu im Atari-Adreraum liegen, sonst bleibt die CPU sofort
wg. doppeltem Bus-Error stehen, sofern das Programm auf einem 68K-Rechner l„uft,
weil dann andere Bereiche, also auch der Stack-Bereich, nicht mehr ansprechbar
sind. Beachte hierzu auch 'minStackSize'!
4. 'atariModePossible' mu anzeigen, da der MMU-Switch erlaubt ist (s.u.).
Andernfalls erscheint bei installiertem MacsBug die Meldung: "Fatal Error:
Atari-Mode currently not available (MMU-Tables invalid)".

ù intrLock mu aufgerufen werden, bevor von einer Macintosh-Routine, die im
Interrupt laufen k”nnte, eine Umschaltung in den Atari-Modus erfolgt. Zus„tzlich
mu vor der Umschaltung damit gerechnet werden, da ein fremder Stack aktiv ist,
der nicht zum Adreraum des Atari-Modus geh”rt. Deshalb mu zuvor auf einen Stack
(siehe 'minStackSize') aus dem Atari-Adreraum gewechselt werden. Nach der
Rckschaltung in den Mac-Modus mu selbstverst„ndlich intrUnlock aufgerufen
werden.
Mit Hilfe dieser Intr-Semaphore wird erkannt, wann die CPU Befehle unter MagiC
im Nicht-Interrupt-Zustand ausfhrt. Dieser Zustand mu erkannt werden, weil nur
dann die Macintosh-Hintergrundprozesse und sonstige Macintosh-Routinen gefahrlos
vom MagiCMac-Kernel durch seine Interrupt-Kontrollroutinen aufgerufen werden
k”nnen.
(W„hrend Interrupt-Routinen oder Macintosh-Routinen abgearbeitet werden, darf
keine Mac-Routine vom MagiCMac-Kernel aufgerufen werden, weil das MacOS nicht
reentrant ist. W„hrend dieser Zeit werden keine Mac-Events bearbeitet; auch
Befehl-W/-Q funktionieren dann nicht).

ù callMacContext dient dazu, die notwendige Macintosh-Umgebung zum Aufruf
beliebiger MacOS-Routinen herzustellen. Die Routine mu im Mac-Modus aufgerufen
werden, im Supervisor-Modus und nicht aus einem Interrupt heraus. Dazu ist auf
dem Stack die Adresse der Routine zu bergeben, die als Subroutine im Mac-Kontext
aufzurufen ist. Fr die aufgerufene Routine wird der normale User-Stack von
MagiCMac verwendet, zudem wird das Register A5 mit macA5 geladen und im Falle,
da Virtual Memory aktiv ist, auch in den User-Modus geschaltet.
Da diese Funktion den Stack wechselt, ist keine Parameterbergabe ber den Stack
m”glich. Die Register D0-D2/A0/A1/A5/A7 werden sowohl beim Aufruf als auch bei
der Rckkehr der Subroutine ver„ndert (jedoch haben A5/A7 nach Rckkehr von
'callMacContext' die selben Werte wie vor dem Aufruf). Die anderen Register
werden nicht ver„ndert und k”nnen zur Parameterbergabe und -rckgabe benutzt
werden.
Die Ausfhrung dieser Subroutine bringt implizit den Aufruf von intrLock und
intrUnlock mit sich, das heit, w„hrenddessen werden keine Mac-Tasks (s.o.)
bearbeitet, auch wenn dabei zeitweise in den Atari-Modus gewechselt wird.
Um trotzdem die Bearbeitung von Mac-Tasks zu erm”glichen, kann die Funktion
'giveTimeToMac' (s.u.) aufgerufen werden.

ù auxControl ist fr den HSMODEM-Treiber gedacht: Der Word-Parameter auf dem
Stack bestimmt, ob die Ports freigegeben werden sollen (2: ganz schlieen, 0:
schlieen, aber ggf. DTR halten) oder eine Wiederbelegung des Ports erlaubt ist
(1). Zwischen (0) und (1) k”nnen sich die Namen (auxInPort, auxOutPort) ge„ndert
haben.
Aufruf im Atari-Supervisor-Modus, der USP ist undefiniert!

ù configKernel bietet Zugriff auf einige der Einstellungen, die sonst nur ber
die Mac-Seite interaktiv zug„nglich sind. Dazu wird in der Regel im "function"-
Parameter eine Funktionsnummer und im "data"-Par. ein Zeiger auf eine Variable
bergeben, die vor dem Aufruf den zu setzenden Wert enthalten mu oder -1 fr den
Fall, da kein neuer Wert gesetzt werden soll. Nach dem Aufruf enth„lt die Var.
den aktuellen Wert (nicht implementierte Funktionen liefern -1).
Die Einstellungen werden in die "Preferences" bernommen, wenn nichts anderes
angegeben ist.
Die Funktionen:
  1 - data zeigt auf ein Byte, das bestimmt, ob der 200Hz-Timer durch den MacOS-
      Timer simuliert werden soll (0:nein, 1:ja/default).
  2 - Bestimmt, ob Mac-Hintergrundprozesse aufgerufen werden sollen. Sonst wie 1.
  3 - Bestimmt, ob IDLE-Zustand bei Powerbooks erlaubt ist. Sonst wie 1.
  4 - Wie 1, fr das Flag 'UnlockMemOnMacSide' (s. a. atariModePossible): Ist
      es ungleich Null, wird der von MagiCMac belegte Speicher fr die TPA
      zum Auslagern freigegeben, falls Virtual Memory aktiv ist. Andernfalls
      l„t er sich nicht auslagern. Wird z.Zt. nicht in den Prefs gesichert.
  5 - (ab Cookie-Version 1.12) ndert keinen Preferences-Wert sondern aktiviert
      die Umschaltung zur Mac-Seite (wie durch Drcken von Befehl-W). 'data'
      mu beim Aufruf auf ein Byte zeigen. M”gliche Werte des Bytes: -1: keine
      nderung (fr Status-Abfrage), 1: Zur ATARI-Seite schalten, 2: zur Mac-
      Seite schalten. Andere Werte sind reserviert.
      Der Rckgabewert ist 1 bzw. 2, je nachdem, welche Seite z.Zt. sichtbar ist.
      Achtung: Das Umschalten kann sich um einige Zehntelsekunden verz”gern;
      solange liefert der Rckgabewert noch den alten Status.

ù atariModePossible zeigt auf ein Byte, das anzeigt, ob augenblicklich ein Wechsel
vom Mac- in den Atari-MMU-Modus m”glich ist (0=verboten, 1=erlaubt). Solange der
Macintosh ohne Virtual Memory (auch RAM-Doubler) l„uft, ist der Aufruf von
'modeAtari' immer m”glich, wenn jedoch VM aktiv ist und das Flag
"UnlockMemOnMacSide" (s. Prefs-Datei) auch ungleich Null ist, wird beim Wechsel
vom MagiC- zum Mac-Bildschirm der von MM fr die TPA belegte Speicher zum
Auslagern freigegeben. Sobald die VM-Verwaltung jedoch einen Block auslagert,
sind die von MM berechneten MMU-Tabellen nicht mehr gltig und mten vor der
n„chsten Umschaltung in den Atari-Modus erst neu berechnet werden. Dies wird
jedoch nicht automatisch getan, sondern erst, wenn zurck zum Atari-Bildschirm
gewechselt wird. Aus diesem Grund drfen Interrupt- und andere asynchrone Routinen,
die unter MagiCMac mittels MacOS-Funktionen installiert sind, unter den
beschriebenen Umst„nden keine Atari-Modusumschaltung vornehmen. Atari-Programme,
die sich in die Atari-Vektoren einh„ngen (z.B. den VBL-Vektor bei $70), mssen
dies alles nicht beachten, weil im Fall, da die MMU-Tabellen ungltig werden,
die Atari-Interrupts erst gar nicht mehr simuliert werden.
Fr den Fall, da weitere Manahmen ergriffen werden sollen, bevor bzw. nachdem
sich der Status des Flags „ndert, kann auch eine Routine ber macAppSwitch (s.o.)
installiert werden, die dann mit den Werten 3 und 4 in D0.W dieses Ereignis
anzeigt).

ù šber 'versionOfMacAppl' kann die Versionskennung von der laufenden
MagiCMac-Applikation ermittelt werden (also die Kennung, die auch im
Finder angezeigt werden kann. Damit k”nnen Programme sich auf die
MM-Versionen einstellen.

ù 'giveTimeToMac' dient dazu, Zeit an die Mac-Event-Bearbeitung von MagiCMac
abzugeben, wenn sich der Rechner l„ngere Zeit (sinnvoll ab 1/60s) im Mac-Modus
befindet, z.B., w„hrend auf Beendigung von asynchronen Bearbeitungen gewartet
wird. 'giveTimeToMac' kann dann beliebig oft aufgerufen werden; die Mac-Events
werden trotzdem nur so oft gepollt, wie in den Prefs eingestellt ist (normal:
jede 1/60s, dies ist auch die maximale Frequenz).
Um die Routine aufzurufen, mu der vollst„ndige Mac-Context hergestellt sein,
d.h., der Applikations-Stack aktiv und A5 entspr. gesetzt sein (dies wird z.B.
durch 'callMacContext' erreicht.
Die Routine macht keine sonstigen Aktionen, die nicht auch sonst passieren,
wenn der Atari-Modus aktiv ist und dabei automatisch zyklisch die Mac-Events
gepollt werden. Als Besonderheit gilt, da die Routine nicht ein anstehendes
Quit-Kommando auswertet, damit die Routine, die 'giveTimeToMac' aufruft, davon
ausgehen kann, da sie gleich wieder drankommt (sofern nicht ein fataler Fehler
auftritt).

ù 'minStackSize' gibt die Mindestgr”e fr Supervisor-Stacks an, falls ein Programm
selbst so einen Stack reservieren mu (beispielsweise dann, wenn eine Callback-
Routine vom MacOS aufgerufen wird und diese dann eine Routine im Atari-Modus
aufrufen will, weil dazu sichergestellt werden mu, da sich der SP beim Umschalten
in den Atari-Modus innerhalb des Atari-Adreraums befindet und dies nur durch einen
eigenen, lokalen Stack zu bewerkstelligen ist). Achtung: Man sollte sich unbedingt
an diesen Wert halten, da z.B. zwar auf den 68K-Maschinen in der Regel 5KB reichen,
auf den neueren PCI-PowerMacs jedoch schon ber 12KB n”tig sind, wenn das Netzwerk
(EtherTalk) aktiv ist!
Am Besten ist es jedoch, wenn man v”llig darauf verzichtet, einen eigenen Supervisor-
Stack anzulegen, um solche Schwierigkeiten in Zukunft zu vermeiden. Im Zweifel
sollte mit dem Autor dieses Textes Kontakt aufgenommen werden!

ù 'ext' bietet diverse Hilfsfunktionen des MagiCMac-Kernels. Aufruf mu aus dem
Atari-Modus (User- oder Supervisor-Modus) geschehen.
Aufrufe aus Interrupts sind nicht erlaubt.
Dazu wird im "function"-Parameter eine Funktionsnummer und im "data"-Par. ein Zeiger
auf evtl. zus„tzlich ben”tigte Daten bergeben. Bei Aufruf nicht definierter Funktions-
nummern wird immer als Funktionsergebnis -1 zurckgegeben.
Die Funktionen:
  0 - ('extMax')
      "data" ist unbenutzt (Null bergeben!), zurckgeliefert wird die h”chste
      implementierte Funktionsnummer.
  1 - ('extAlert')
      Zeigt einen generischen Mac-Dialog (Alert) an. "data" zeigt auf einen
      Null-terminierten String (maximal 255 Zeichen lang!), der in dem Dialog
      angezeigt wird. Achtung: Umlaute mssen Mac-Codes haben. Zum Zeilentrennen
      einfach ein CR einfgen. Rckgabe: Immer Null.
  2 - ('extAUXOpenErr')
      Zeigt einen Mac-Alert an mit dem (entspr. der Sprache angepaten) Text, da
      der serielle Port nicht ge”ffnet werden kann, weil er belegt ist (wird
      von HSMODEM/MACM1 ben”tigt). "data" ist unbenutzt. Rckgabe: Immer Null.
  3 - ('extFSSpecToPath')
      Konvertiert einen Macintosh-Dateipfad in einen GEMDOS-konformen Pfad (Umlaute
      werden ggf. auch konvertiert, konform zu den anderen GEMDOS-Funktionen).
      "data" zeigt auf folg. Struktur: Zuerst ein FSSpec (siehe Mac-Doku), dahinter
      ein Puffer mit Platz fr 256 Zeichen. Dieser Puffer wird von der Funktion mit
      einem C-String gefllt, der einen vollst„ndigen Pfadnamen beschreibt, mit dem
      ber GEMDOS-Dateifunktionen auf die Datei zugegriffen werden kann.
      Es kann in sp„teren MM-Versionen auch vorkommen, da dies ein Pfad auf dem
      Pseudo-Laufwerk "u:\" ist, in dem dann alle z.Zt. vorhandenen Mac-Laufwerke
      verfgbar sind. Dabei mu auch damit gerechnet werden, da es sich um Datei- 
      und Ordnernamen handelt, die nicht ins 8.3-Schema passen.
      Handelt es sich um einen Ordner, ist der Pfad auf jeden Fall mit "\"
      abgeschlossen.
      Wenn kein Pfad ermittelt werden kann, weil z.B. keines der konfigurierten
      MagiC-Laufwerke den betreffenden Ordner sichtet, gibt die Funktion den Wert
      -2 zurck. Im Erfolgsfall wird 0 geliefert.
      Achtung: Diese Funktion kostet u.U. verh„ltnism„ig viel Zeit, verglichen zu
      einem Fsfirst-Aufruf, da jedes Laufwerk nach dem Verzeichnis durchsucht werden
      mu - daher nicht sorglos dauernd aufrufen, wenn es vermeidbar ist.
  4 - ('extDoMacTasks')
      Gibt Zeit an Mac-Aplikationen ab. Dabei werden auch Cmd-Q und Cmd-W sowie
      andere Apple-Events ausgewertet. Wird haupts„chlich vom MagiCMac-Accessory
      benutzt, um kooperativ Zeit abzugeben. Wenn dies nicht in einer gewissen
      Frequenz passiert (die Frequenz ist im Prefs-File einstellbar), nimmt sich
      der MagiCMac-Kernel die Freiheit, die "Mac-Tasks" preemptiv aufzurufen.
      Dies hat keine Nachteile, sondern 'extDoMacTasks' bietet umgekehrt die
      M”glichkeit, h„ufiger Zeit an die Mac-Apps abzugeben, als dies durch des
      Kernels preempt. Mechanismus m”glich w„re. Dieser Vorteil wird genutzt,
      um MagiC-Applikationen auch ein wenig Zeit abzugeben, wenn MagiCMac im
      Hintergrund l„uft.
  5 - ('extMgMcACCMsg')
      Interne Funktion (fr MAGICMAC.ACC).

ù 'extMac': Selbe Funktionen, wie bei 'ext', jedoch mu Aufruf aus dem Mac-Kontext
(siehe 'callMacContext') geschehen. Ist vorteilhaft, wenn sich das Programm wg.
Aufruf anderer Mac-Funktionen bereits im Mac-Modus befindet.
Aufrufe aus Interrupts sind i.d.R. nicht erlaubt.

ù 'stackLoad' aktiviert einen neuen CPU-Stack (A7).
Dies ist dann n”tig, wenn aus einem Mac-Kontext, bei dem ein beliebiger CPU-Stack
aktiv ist, eine Routine im ATARI-Kontext aufgerufen werden soll, also, bevor ein
Modus-Wechsel mit "modeAtari" erfolgt. Das Wechseln auf einen anderen Stack ist
dann n”tig, weil evtl. der Bereich, den A7  gerade benutzt, durch den Wechsel zum
Atari-Modus ausgeblendet wird und es dann zu einem CPU-Stillstand k„me (siehe
auch Kap. "Interrupt-Handler unter MagiCMac").
Anstatt einfach selbst den A7 azf den neuen Stack zu setzen, sollte 'stackLoad'
benutzt werden. Diese Funktion tut im Grunde das selbe, jedoch informiert sie
zusaetzlich das MacOS davon (durch Setzen weniger globaler Variablen). Damit
wird erreicht, dass das MacOS waehrenddessen nicht den A7 periodisch berprft.
Denn sonst k”nnte es auf bestimmten MacOS-Versionen (vor 7.5 und wieder ab 7.5.3)
zur Meldung eines Stack-šberlaufs durch das MacOS kommen, obwohl dies gar nicht
der Fall ist.
Falls Virtual Memory aktiviert ist, wird hiermit auerdem erreicht, da dieser
Stack-Bereich nicht ausgelagert werden kann, was sonst u.U. einen Rechnerstillstand
zur Folge haben kann.
Benutzung: In A0 ist ein Zeiger auf ein MemArea-Struktur (s.o.) zu bergeben.
Darin mu der Zeiger auf den Beginn (niedrigste Adresse) des Stacks sowie
seine L„nge (beachte 'minStackSize'!) enthalten sein. Die Routine zerst”rt die
Register A0 und A1 und setzt A7 auf den Wert von <MemArea.start+MemArea.length>.

ù 'stackUnload':
Dioe Umkehrung zu 'stackLoad'. Aufzurufen, wenn der zuvor aktiv gewesene Stack
wieder benutzt werden soll.
Die Routine zerst”rt das Register A0 (A7 erh„lt wieder den Wert von vor dem
stackLoad-Aufruf).


------------------
MacMiNT-Funktionen
------------------

MacMiNT, ein MiNT-Derivat, das auf MacOS l„uft, bietet einige Mac-spezifische
Dateifunktionen an. Diese sind ab MM 2.0 auch enthalten:

    typedef struct {
        long fdType;            /*the type of the file, e.g. 'TEXT' */
        long fdCreator;         /*file's creator, e.g. 'MgMc' */
        unsigned short fdFlags; /*flags ex. hasbundle,invisible,locked, etc.*/
        short fdLocation1;      /*icon's location in folder (vertical)*/
        short fdLocation2;      /*rest of location (horizontical) */
        short fdFldr;           /*unused*/
    } FInfo;
    
    #define FMACOPENRES             (('F' << 8) | 72)
    #define FMACGETTYCR             (('F' << 8) | 73)
    #define FMACSETTYCR             (('F' << 8) | 74)

'FMACGETTYCR' und 'FMACSETTYCR' ermitteln bzw. setzen die MacFinderInfo (FInfo)
einer Datei. Diese Funktionen k”nnen mit Fcntl() oder Dcntl() benutzt werden.
'FMACOPENRES' sollte nur auf eine frisch ge”ffnete Datei angewendet werden: Damit
wird erreicht, dass die folgenden Read/Write/Seek-Zugriffe auf die Resource-Fork
anstatt auf die Data-Fork erfolgen.

Anwendungsbeispiele hierzu befinden sich in der Source-Datei "XFS_DEMO.C"


--------------
MagiCMac XCMDs
--------------

XCMDs sind kleine externe Code-Module fr Macintosh-Applikationen. Sie k”nnen
in der Regel ziemlich einfach mit den Entwicklungswerkzeugen unter MacOS erzeugt
werden (z.B. mit Metrowerks CodeWarrior oder Symantec C).
Ab Version 1.2.2 erlaubt MagiCMac auch die einfache Benutzung solcher CODE-Module
von Programmen aus, die unter MagiC laufen. Dies erleichtert die Entwicklung
von Programmen oder Treibern, die Funktionen vom Macintosh nutzen wollen, weil
diese Teile dann mit einem Macintosh-Compiler erstellt werden k”nnen, anstatt
umst„ndlich die Interfaces unter einem Atari-Entwicklungssystem noch einmal
nachbilden zu mssen.

Ein Beispiel fr ein solches XCMD befindet sich im Ordner "Demo XCMD". Das erzeugte
Modul kann dann einfach in den Ordner "MagiCMac XCMDs" gelegt werden. Dieser Ordner
mu sich im selben Verzeichnis wie die MagiCMac-Applikation befinden.
Beim Start von MagiCMac wird dieser Ordner nach Dateien mit dem Dateityp 'xCmd'
durchsucht und die darin enthaltenen XCMD-Resourcen geladen und ausgefhrt.
Diese XCMDs k”nnen sich dabei bei MagiCMac registrieren und stehen damit MagiC-
Programmen zur Verfgung.
Eine Anwendung zeigt das Pure C-Programm im Ordner "MGMC_API". Es zeigt, wie
einfach ein installiertes XCMD ge”ffnet und aufgerufen werden kann.
Die dazu ber den Cookie (xcmdMgrPtr) angebotenen Funktionen gehen dabei automatisch
ggf. in den Supervisormodus und schalten auf die Mac-Umgebung (per callMacContext)
um und regeln auch die Parameterbergabe. Der Aufruf der XCMD-Funktionen auf diese
Weise ist also nur erlaubt, wenn der Atari-Modus aktiv ist und wenn der Aufruf nicht
von einem Interrupt aus erfolgt.
Wenn die XCMD-Funktionen aus Interrupts oder im Mac-Modus aufgerufen werden sollen,
kann ber "xcmdMgrPtr->getAdr" die Einsprungadresse des XCMD-Dispatchers ermittelt
werden und dann direkt angesprungen werden.

Weitere Informationen zu XCMDs bedindet sich im Quelltext "Demo XCMD.c".


---------------------------

Das w„r's erstmal.
Wer Fragen hat oder wer bestimmte Features fr die Atari-Mac-Schnittstelle
vermit, werde sich bitte an den Autor des MagiCMac-Kernels, bevor er an Internas
herumbastelt, die bei der n„chsten MagiCMac-Version dann vielleicht nicht mehr
funktionieren:
  Thomas Tempelmann
  Trkenstr. 31
  D-80799 Mnchen
  Tel. 089 28659090, Fax 28659089, E-mail: 72377.351@compuserve.com
