NVDI 4.1 Programmer's Guide
===========================

Stand: 03.03.96 (vorl„ufige Fassung)

(c) 1995-96 by Wilfried Behne

Intentionen, Konditionen, Ovationen
-----------------------------------

"Neue Version - neue Fragen" - mit dem Erscheinen von NVDI ist die
Anzahl der Anfragen zu NVDI bei mir rapide gestiegen. Zum Teil waren es
NVDI-Besitzer, die an weitergehenden Informationen interessiert waren, zum
Teil aber auch Programmierer, die NVDI nicht besitzen und ihre Programme
an NVDI anpassen wollten.

Diese vorl„ufige Funktionsbeschreibung zu NVDI ist ist in die Teile

-  Datentypen und Strukturen
-  Versionsabfragen
-  Funktionsumfang
-  Ger„tetreiber und Offscreen-Bitmaps
-  Farbeinstellungen
-  Verknpfung und Zeichenbereich
-  Linien und nicht gefllte Grafikprimitive
-  Gefllte Grafikprimitive
-  Marker
-  Textausgaben mit Bitmap- und Vektorfonts
-  Rasterfunktionen
-  Eingabefunktionen
-  Textmodus und VT52
-  Druckerspezifische Funktionen
-  Beispiele fr Bindings

gegliedert. Fr die Vollst„ndigkeit und Richtigkeit der gemachten Angaben wird
keinerlei Gew„hr bernommen.

Konditionen
-----------

Diese Dokumentation ist Public Domain, d.h. sie darf frei kopiert und benutzt
werden. Der entgeldliche Vertrieb ist untersagt. Zuwiderhandlungen werden
strafrechtlich verfolgt.

Zu NVDIGUID.LZH geh”ren folgende Dateien:

   - NVDIGUID.TXT
   - MAPPING\MAPLIKE4.MAP     (SPDCHAR.MAP fr Speedo 4.2)
   - MAPPING\MAPPIN01.IMG     (Zeichenbelegung in NVDI 4.1, Seite 1 - 300 dpi)
   - MAPPING\MAPPIN02.IMG     (Zeichenbelegung in NVDI 4.1, Seite 2 - 300 dpi)
   - MAPPING\MAPPIN03.IMG     (Zeichenbelegung in NVDI 4.1, Seite 3 - 300 dpi)
   - MAPPING\MAPPIN04.IMG     (Zeichenbelegung in NVDI 4.1, Seite 4 - 300 dpi)
   - MAPPING\MAPPIN05.IMG     (Zeichenbelegung in NVDI 4.1, Seite 5 - 300 dpi)
   - MAPPING\MAPPIN06.IMG     (Zeichenbelegung in NVDI 4.1, Seite 6 - 300 dpi)
   - PATCH\PATCH_NV.TTP       (Korrekturen fr NVDI 3.x)
   - DRUCKEN.TC\...           (Beispielprogramm fr Truecolor-Ausdruck)
   
Das Archiv darf nur komplett mit diesen Dateien weitergegeben werden!
Es ist erlaubt, die Dateien fr die eigenen Anforderungen zu ver„ndern. Es ist
jedoch NICHT erlaubt, diese ver„nderten Dateien weiterzugeben.

Fr Wnsche, Anregungen und Fehlerkorrekturen habe ich natrlich immer ein
offenes Ohr.

Disclaimer
----------
Speedo ist ein eingetragenes Warenzeichen von Bitstream Inc., TrueType und
TrueType GX sind eingetragene Warenzeichen von Apple Computer, Inc, PostScript
ist ein eingetragenes Warenzeichen von Adobe Systems Inc. Die meisten hier
erw„hnten Produkte sind in der Regel durch Warenzeichen geschtzt. Das Fehlen
gesonderter Hinweise bedeutet nicht, da diese Produkte frei von Rechten Dritter
sind.




Datentypen und Strukturen
=========================

ù Benutzte Datentypen

Die Deklarationen und Beschreibungen arbeiten mit den folgenden Datentypen:

BYTE     8 Bit, vorzeichenbehaftet, -128 bis 127
UBYTE    8 Bit, kein Vorzeichen, 0 bis 255
WORD     16 Bit, vorzeichenbehaftet, -32768 bis 32767
UWORD    16 Bit, kein Vorzeichen, 0 bis 65535
LONG     32 Bit, vorzeichenbehaftet, -2147483648 bis 2147483647
ULONG    32 Bit, kein Vorzeichen, 0 bis 4294967295
fix31    32 Bit, vorzeichenbehaftet, -2147483648 bis 2147483647

BYTE wird normalerweise in den C-Bindings fr die šbergabe von Zeichenketten
benutzt. Fr die meisten VDI-Funktionen werden die BYTE-Werte erweitert (und
zwar so, als ob sie vorzeichenlos w„ren), da z.B. der Index eines Zeichens im
Bereich 0-65535 liegen kann.

Der Standard-Typ des VDIs ist WORD. Die Felder contrl, intin, ptsin, intout und
ptsout sind als WORD deklariert. Die Interpretation der Werte h„ngt aber vom
jeweiliegen VDI-Aufruf ab. Koordinaten in ptsin werden als vorzeichenbehaftet
betrachtet (-32768 bis +32768), Werte in intin oftmals als vorzeichenlos.

Der Typ fix31 wird im Zusammenhang mit Vektorfonts gebraucht, wo mit Positonen
und Schrittweiten in 1/65536 gerechnet wird (1 Pixel Weite entspricht 65536).
Die oberen 16 Bit repr„sentieren den Vorkommaanteil und die unteren 16 Bit die
Nachkommastellen. Beispiele:

hex.        dez.
$00010000   65536    1.0 Pixel
$0001c000  114688    1.75 Pixel
$fffec000  -81920   -1.25 Pixel
$fffe4000 -114688   -1.75 Pixel

Wer Schrittbreiten (beispielsweise von vqt_advance32()) aufsummiert und
anschlieend die Pixelposition fr Cursorpositionierung berechnen m”chte sollte
wie folgt vorgehen:

WORD  fix31_to_pixel( fix31 a )
{
   WORD  b;

   b = (WORD) (( a + 32768L ) >> 16 ); /* runden !! */
   return( b );                        /* Pixelwert zurckgeben */
}

Man darf nie, nie, niemals den Nachkommateil einfach abschneiden!


ù Strukturen und Felder fr VDI-Aufrufe

Die folgenden Felder und Strukturen werden fr VDI-Aufrufe ben”tigt:

WORD  contrl[12];

In contrl werden die Funktionsnummer, die Anzahl der Eingaben, das Handle der
Workstation und einige Funktionsabh„ngige Paramter bergeben. Die Eingaben
werden grunds„tzlich wie folgt eingetragen:

contrl[0]:     Funktionsnummer
contrl[1]:     Anzahl der Eingabe-Koordinatenpaare (in ptsin)
contrl[3]:     Anzahl der Eingabe-Integers (in intin)
contrl[5]:     Unterfunktionsnummer
contrl[6]:     Workstation-Handle
contrl[7..n]:  abh„ngig von der Funktion

Die Ausgaben werden in den folgenden Elementen zurckgegeben:

contrl[2]:     Anzahl der Ausgabekoordinatenpaare (in ptsout)
contrl[4]:     Anzahl der Ausgabe-Integers (in intout)
contrl[6]:     Workstation-Handle (nur bei v_opnwk()/v_opnvwk()/v_opnbm())

Die Felder ptsin und ptsout werden benutzt, um Koordinatenpaare oder Mae in
Pixeln (z.B. die Breite einer Linie oder die H”he eines Zeichens) zu
bergeben. Die Gr”e der Felder h„ngt von den aufgerufenen Funktionen ab.
Eine sinnvolle Deklaration k”nnte wie folgt aussehen:

WORD  ptsin[1024];   /* Platz fr 512 Eingabe-Koordinatenpaare */
WORD  ptsout[256];   /* Platz fr 128 Ausgabe-Koordinatenpaare */

Worte wie der Index eines Zeichens oder der Index einer Farbe werden in intin
und intout bergeben. Auch hier h„ngt letztendlich die Gr”e der Felder von
den aufgerufenen Funktionen ab. Eine sinnvolle Deklaration k”nnte wie folgt
aussehen:

WORD  intin[1024];   /* Platz fr 1024 Eingabe-Worte */
WORD  intout[512];   /* Platz fr 512 Ausgabe-Worte */

Um das VDI aufzurufen, mu der folgende Paramterblock mit den Adressen der
oben beschriebenen Felder bestckt werden. Die Adresse des Parameterblocks
wird in Register d1 eingetragen und Register d0.w enth„lt 115. Anschlieend
wird ein Systemaufruf mit dem Befehl trap #2 ausgel”st.

typedef struct
{
   WORD  *contrl;    /* Zeiger auf contrl */
   WORD  *intin;     /* Zeiger auf intin */
   WORD  *ptsin;     /* Zeiger auf ptsin */
   WORD  *intout;    /* Zeiger auf intout */
   WORD  *ptsout;    /* Zeiger auf ptsout */
} VDIPB;

Farbeinstellungen:

Bei vs_color(), vq_color() und vs_calibrate() werden RGB-Intensit„ten in
Promille bergeben, wofr am zweckm„igsten die RGB-Struktur benutzt wird:

typedef struct
{
   WORD  red;        /* Rot-Intensit„t in Promille (0-1000) */
   WORD  green;      /* Grn-Intensit„t in Promille (0-1000) */
   WORD  blue;       /* Blau-Intensit„t in Promille (0-1000) */
} RGB1000;

Rasterfunktionen:

VDI-Funktionen, die Raster verknpfen, erwarten als Rasterbeschreibung einen
oder mehrere sogenannte MFDBs, "Memory Form Definition Block".

typedef struct
{
   void  *fd_addr;   /* Adresse des Rasters oder 0 fr Bildschirm/Bitmap */
   WORD  fd_w;       /* Breite des Rasters in Pixeln */
   WORD  fd_h;       /* H”he des Rasters in Zeilen */
   WORD  fd_wdwidth; /* Breite einer Rasterzeile in Worten */
   WORD  fd_stand;   /* Format 0: ger„tespezifisch, 1: Standardformat */
   WORD  fd_nplanes; /* Anzahl der Ebenen */
   WORD  fd_r1;      /* reserviert, sollte 0 sein */
   WORD  fd_r2;      /* reserviert, sollte 0 sein */
   WORD  fd_r3;      /* reserviert, sollte 0 sein */
} MFDB;

Wenn fd_addr eine 0 enth„lt, mu der Rest des MFDBs nicht ausgefllt werden. Die
Rasteroperationen vrt_cpyfm() und vro_cpyfm() beziehen sich dann automatisch auf
den Bildschirm (oder im Fall eines Druckertreibers auf die Druckerbitmap). Die
reservierten Worte fd_r1, fd_r2 und fd_r3 sollten hinsichtlich zuknftiger
Erweiterungen auf 0 gesetzt werden!

Metafiles:

Metafiles beginnen mit dem folgenden Header:

typedef struct
{
   WORD  mf_header;     /* -1, Metafile-Kennung */
   WORD  mf_length;     /* L„nge des Headers in Worten (normalerweise 24) */
   WORD  mf_version;    /* Versionsnummer des Formats, hier 101 fr 1.01 */
   WORD  mf_ndcrcfl;    /* NDC/RC-Flag, normalerweise 2 (Rasterkoordinaten) */
   WORD  mf_extents[4]; /* optional - maximale Ausmae der Grafik */
   WORD  mf_pagesz[2];  /* optional - Seitengr”e in 1/10 mm */
   WORD  mf_coords[4];  /* optional - Koordinatensystem */
   WORD  mf_imgflag;    /* Flag fr durch v_bit_image() eingebundene IMGs */
   WORD  mf_resvd[9];
} METAHDR;

Die Angaben in mf_extents, mf_pagesz und mf_coords sind optional. Falls ein
Programm sie nicht gesetzt hat, enthalten diese Felder Nullen. Das IMG-Flag
zeigt an, ob Aufrufe von v_bit_image() im Metafile gespeichert sind.

Bei vqt_xfntinfo() wird die XFNT_INFO-Struktur ben”tigt, in oft ben”tigt Angaben
ber einen Font eingetragen werden:

typedef struct
{
   LONG  size;             /* L„nge der Struktur, mu vor vqt_xfntinfo() gesetzt werden */
   WORD  format;           /* Fontformat, z.B. 4 fr TrueType */
   WORD  id;               /* Font-ID, z.B. 6059 */
   WORD  index;            /* Index */
   BYTE  font_name[50];    /* vollst„ndiger Fontname, z.B. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* Name der Fontfamilie, z.B. "Century725 BT" */
   BYTE  style_name[50];   /* Name des Fontstils, z.B. "Italic" */
   BYTE  file_name1[200];  /* Name der 1. Fontdatei, z.B. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* Name der optionalen 2. Fontdatei */
   BYTE  file_name3[200];  /* Name der optionalen 3. Fontdatei */
   WORD  pt_cnt;           /* Anzahl der Punkth”hen fr vst_point(), z.B. 10 */
   WORD  pt_sizes[64];     /* verfgbare Punkth”hen,
                              z.B. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;


ù Zeichenketten

Grunds„tzlich werden Strings beim VDI in intin und intout bergeben, wobei pro
Zeichen ein Wort benutzt wird. Diese šbergabe hat den Vorteil, da auch andere
Kodierungen als ASCII benutzbar sind und da auch mehr als 256 Zeichen eines
Fonts benutzt werden k”nnen.

Die C-Bindings fr Funktionen wie v_ftext(),vqt_name(), vqt_extent() usw.
arbeiten mit normalen C-Strings und wandeln sie frs VDI um. Die L„nge eines
derartigen Strings wird dabei in contrl[3] bzw. contrl[4] eingetragen, wobei kein
abschlieendes Null-Byte oder -Wort vorhanden ist!
Wer z.B eine in intout ausgegebene  Zeichenkette in einen C-String wandeln
m”chte, mu contrl[4]  Elemente kopieren, dabei die oberen 8 Bit abschneiden und
anschlieend ein Null-Byte anh„ngen.

void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE) *src++;   /* nur das Low-Byte kopieren */
      len--;
   }
   *des++ = 0;                   /* Ende des Strings */
}

WORD c_str_to_vdi( UBYTE *src, UWORD *des )
{
   WORD  len;

   len = 0;
   
   while (( *des++ = *src++ ) != 0 )
      len++;

   return( len );                /* L„nge des Strings ohne Null-Byte */
}

Wenn es sich bei einem Funktionsparameter um einen C-String handelt, wird das in
der Regel explizit erw„hnt.




Versionsabfragen
================

Um herauszufinden, welche NVDI-Version man vor sich hat und welchen
Funktionsumfang sie hat, mu der "NVDI"-Cookie gesucht werden, der die
Versionsnummer im BCD-Format enth„lt (z.B. 0x0301 fr Version 3.01 und 0x0410 
fr Version 4.10).

Wer die Offscreen-Bitmaps nutzen m”chte, sollte nach dem "EdDI"-Cookie suchen.
Das auf die Kennung folgende Langwort ist die Adresse eines Dispatchers, der mit
der Funktionsnummer in Register d0.w aufgerufen wird. Fr den Aufruf gelten die
Pure C-Konventionen, d.h. Register d0-d2/a0-a1 und der Stack werden zur
Parameterbergabe benutzt, d0-d2/a0-a1 k”nnen ver„ndert werden). Die Funktion 0
liefert die EdDI-Versionsnummer im BDC-Format (0x0110 fr Version 1.10).

typedef struct
{
  BYTE   id[4];         /* enth„lt hier 0x4e564449 = 'NVDI' */
  LONG   value;         /* zeigt auf die NVDI-Struktur */
} COOKIE;

typedef struct
{
   UWORD nvdi_version;  /*  z.B. 0x0301 fr Version 3.01 */
   ULONG nvdi_datum;    /*  z.B. 0x18061990L fr 18.06.1990 */
} NVDI_STRUC;




Funktionsumfang
===============

Hier folgt eine kurze Auflistung der untersttzten Funktionen mit Angabe, ab
welcher Version diese Funktion zur Verfgung steht.

contrl[0]   contrl[5]   Funktionsname           Verfgbarkeit

Treiber und Verwaltung:

   1           0        v_opnwk();
   2           0        v_clswk();
   100         0        v_opnvwk();
   101         0        v_clsvwk();
   3           0        v_clrwk();
   4           0        v_updwk();
   5           22       v_clear_disp_list();
   100         1        v_opnbm();              ab EdDI 1.00
   101         1        v_clsbm();              ab EdDI 1.00
   102         0        vq_extnd();
   102         1        vq_scrninfo();          ab EdDI 1.00
   248         0        vq_devinfo();           ab NVDI 3.00
   248         4242     vq_ext_devinfo();       ab NVDI 3.00

Farbeinstellungen:

   5           76       vs_calibrate();         je nach Treiber
   5           77       vq_calibrate();         je nach Treiber
   14          0        vs_color();
   26          0        vq_color();

Verknpfung und Zeichenbereich:

   32          0        vswr_mode();
   129         0        vs_clip();

Linien und nicht gefllte Grafikprimitive:

   5           99       v_bez_qual();           ab NVDI 2.10
   6           0        v_pline();
   6           13       v_bez();                ab NVDI 2.10
   11          2        v_arc();
   11          6        v_ellarc();
   11          8        v_rbox();
   11          13       v_bez_on();             ab NVDI 2.10
   11          13       v_bez_off();            ab NVDI 2.10
   15          0        vsl_type();
   16          0        vsl_width();
   17          0        vsl_color();
   35          0        vql_attributes();
   108         0        vsl_ends();
   113         0        vsl_udsty();

Gefllte Grafikprimitive:

   9           0        v_fillarea();
   9           13       v_bez_fill();           ab NVDI 2.10
   11          1        v_bar();
   11          3        v_pieslice();
   11          4        v_circle();
   11          5        v_ellipse();
   11          7        v_ellpie();
   11          9        v_rfbox();
   23          0        vsf_interior();
   24          0        vsf_style();
   25          0        vsf_color();
   37          0        vqf_attributes();
   103         0        v_contourfill();
   104         0        vsf_perimeter();
   112         0        vsf_udpat();
   114         0        vr_recfl();

Marker:

   7           0        v_pmarker();
   18          0        vsm_type();
   19          0        vsm_height();
   20          0        vsm_color();
   36          0        vqm_attributes();

Textausgabe:

   8           0        v_gtext();
   11          10       v_justified();
   12          0        vst_height();
   13          0        vst_rotation();
   21          0        vst_font();
   22          0        vst_color();
   38          0        vqt_attributes();
   39          0        vst_alignment();
   106         0        vst_effects();
   107         0        vst_point();
   116         0        vqt_extent();
   117         0        vqt_width();
   119         0        vst_load_fonts();
   120         0        vst_unload_fonts();
   130         0        vqt_name();             ab NVDI 3.00 erweitert
   131         0        vqt_fontinfo();
   190         0        vqt_char_index();       ab NVDI 4.00
   229         0        vqt_xfntinfo();         ab NVDI 3.02
   230         0        vst_name();             ab NVDI 3.02
   230         100      vqt_name_and_id();      ab NVDI 3.02
   231         0        vst_width();            ab NVDI 3.00
   232         0        vqt_fontheader();       ab NVDI 3.00
   234         0        vqt_trackkern();        ab NVDI 3.00
   235         0        vqt_pairkern();         ab NVDI 3.00
   236         0        vst_charmap();          ab NVDI 3.00
   236         0        vst_map_mode();         ab NVDI 4.00
   237         0        vst_kern();             ab NVDI 3.00
   237         0        vst_track_offset();     ab NVDI 3.00
   239         0        v_getbitmap_info();     ab NVDI 3.00
   240         0        vqt_f_extent();         ab NVDI 3.00
   240         4200     vqt_real_extent()       ab NVDI 3.00
   241         0        v_ftext();              ab NVDI 3.00
   241         0        v_ftext_offset();       ab NVDI 3.00
   243         0        v_getoutline();         ab NVDI 3.00
   246         0        vst_arbpt32();          ab NVDI 3.00
   247         0        vqt_advance32();        ab NVDI 3.00
   252         0        vst_setsize32();        ab NVDI 3.00
   253         0        vst_skew();             ab NVDI 3.00

Rasterfunktionen:

   105         0        v_get_pixel();          nur bei Bildschirmtreibern
   109         0        vro_cpyfm();            ab NVDI 4 erweitert
   110         0        vr_trnfm();
   121         0        vrt_cpyfm();            ab NVDI 4 erweitert

Eingabefunktionen:

   33          0        vsin_mode();
   28          0        vrq_locator();
   28          0        vsm_locator();
   30          0        vrq_choice();
   30          0        vsm_choice();
   31          0        vrq_string();
   31          0        vsm_string();
   111         0        vsc_form();
   115         0        vqin_mode();
   128         0        vex_timv();
   122         0        v_show_c();
   123         0        v_hide_c();
   124         0        vq_mouse();
   125         0        vex_butv();
   126         0        vex_motv();
   127         0        vex_curv();
   128         0        vq_key_s();

Textmodus und VT52:

   5           1        vq_chcells();
   5           2        v_exit_cur();
   5           3        v_enter_cur();
   5           4        v_curup();
   5           5        v_curdown();
   5           6        v_curright();
   5           7        v_curleft();
   5           8        v_curhome();
   5           9        v_eeos();
   5           10       v_eeol();
   5           11       v_curaddress();
   5           12       v_curtext();
   5           13       v_rvon();
   5           14       v_rvoff();
   5           15       vq_curaddress();

Druckerspezifische Funktionen

   5           23       v_bit_image();
   5           27       v_orient();             je nach Treiber
   5           28       v_copies();             je nach Treiber
   5           29       v_trays();              je nach Treiber
   5           36       vq_tray_names()         je nach Treiber
   5           37       v_page_size()           je nach Treiber
   5           38       vq_page_name()          je nach Treiber
   5         2000       v_escape2000()          je nach Treiber



Ger„tetreiber und Offscreen-Bitmaps
===================================

ù OPEN WORKSTATION (VDI 1)

Mit dieser Funktion ”ffnen Sie eine physikalische Workstation. Dazu wird ein in
der ASSIGN.SYS-Datei eingetragener Ger„tetreiber geladen und den Eingaben
entsprechend initialisiert.

Wenn die Initialisierung erfolgreich verlaufen ist, wird in contrl[6] eine
Kennung (im weiteren Verlauf Handle genannt) zurckgegeben, andernfalls eine
Null.

Wichtig: Der Bildschirmtreiber wird nach Abarbeitung des AUTO-Ordners vom AES
         ge”ffnet. Anwenderprogramme mssen daher zur  Bildschirmausgabe eine
         virtuelle  Workstation  (VDI  100) ”ffnen.

Dekl.:  void v_opnwk( WORD *work_in, WORD *handle, WORD *work_out );
Aufruf: v_opnwk( work_in, &handle, work_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        1                   v_opnwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        11                  Eintr„ge in intin
contrl[6]        0 oder 1
intin[0..10]     work_in[0..10]

Ausgaben:

contrl[2]        6                   Eintr„ge in ptsout
contrl[4]        45                  Eintr„ge in intout
contrl[6]        handle
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Bedeutung von work_in[0..10]:
work_in[0]: Ger„teidentifikationsnummer.  Mit  ihr w„hlen Sie den zu  ladenden
            Ger„tetreiber.

            1-10 : Bildschirmtreiber
            1:    aktuelle Aufl”sung
            2:    320*200,  16 Farben
            3:    640*200,  4 Farben
            4:    640*400,  monochrom
            6:    640*480,  16 Farben  (TT)
            8:    1280*960, monochrom  (TT)
            9:    320*480,  256 Farben (TT)

            ab 11:Plottertreiber
            ab 21:Druckertreiber
            ab 31:Metafiletreiber
            ab 41:Kamera
            ab 51:Grafiktablett
            ab 61:Memory-Treiber

work_in[1]: Linientyp
work_in[2]: Linienfarbe
work_in[3]: Markertyp
work_in[4]: Markerfarbe
work_in[5]: Zeichensatznummer
work_in[6]: Textfarbe
work_in[7]: Flltyp
work_in[8]: Fllmuster-Index
work_in[9]: Fllmuster-Farbe
work_in[10]:Koordinatenflag 0: NDC , 2: RC

Bedeutung von work_out[0..56]:
work_out[0]:  Adressierbare Rasterbreite (Wertebereich 0 - xmax)
work_out[1]:  Adressierbare Rasterh”he   (Wertebereich 0 - ymax)
work_out[2]:  Ger„tekoordinatenflag
              0: genaue Skalierung m”glich (z.B. Bildschirm)
              1: keine genaue Skalierung m”glich (Film-Recorder)
work_out[3]:  Breite eines Pixels in Mikrometern
work_out[4]:  H”he eines Pixels in Mikrometern
work_out[5]:  Anzahl der Zeichenh”hen (0: beliebig ver„nderbar)
work_out[6]:  Anzahl der Linientypen
work_out[7]:  Anzahl der Linienbreiten (0: beliebig ver„nderbar)
work_out[8]:  Anzahl der Markertypen
work_out[9]:  Anzahl der Markergr”en (0: beliebig ver„nderbar)
work_out[10]: Anzahl der verfgbaren Zeichens„tze
work_out[11]: Anzahl der Muster
work_out[12]: Anzahl der Schraffuren
work_out[13]: Anzahl der Farben
work_out[14]: Anzahl der GDPs
work_out[15] bis work_out[24]:
              Liste der GDPs, deren Ende durch -1 gekennzeichnet ist.
work_out[25] bis work_out[34]:
              Liste der Attribute der GDPs:
              0: Linie
              1: Marker
              2: Text
              3: ausgefllter Bereich
              4: keine Attribute
work_out[35]: Farbdarstellungsflag
work_out[36]: Textrotationsflag
work_out[37]: Fl„chenfllung
work_out[38]: CELLARRAY-Flag
work_out[39]: Anzahl der Farbabstufungen (0: mehr als 32767)
work_out[40]: Kontrolle des Mauszeigers
              1: Tastatur
              2: Tastatur und Maus (oder anderes Ger„t)
work_out[41]: Ger„t fr variierende Eingaben
              1: Tastatur
              2: anderes Ger„t
work_out[42]: Auswahltasten
              1: Funktionstasten
              2: anderes Tastenfeld
work_out[43]: String-Eingabe
              1: Tastatur
work_out[44]: Ger„te-Typ
              0: nur Ausgabe
              1: Eingabe
              2: Ein- u. Ausgabe
              4: Metafile-Ausgabe
work_out[45]: geringste Zeichenbreite
work_out[46]: geringste Zeichenh”he
work_out[47]: gr”te Zeichenbreite
work_out[48]: gr”te Zeichenh”he
work_out[49]: geringste Linienbreite
work_out[50]: 0
work_out[51]: gr”te Linienbreite
work_out[52]: 0
work_out[53]: geringste Markerbreite
work_out[54]: geringste Markerh”he
work_out[55]: gr”te Markerbreite
work_out[56]: gr”te Markerh”he

Bei NVDI-Drucker- und IMG-Treibern kann auerdem das Seitenformat und der
Ausgabekanal gesetzt werden. Bei META.SYS wirkt sich die Einstellung des
Seitenformats nicht aus (sollte auf 0 gesetzt werden), der Dateiname wird aber
fr den Metafile bernommen.

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        1                   v_opnwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        16                  Eintr„ge in intin
contrl[6]        0 oder 1
intin[0..15]     work_in[0..15]

Ausgaben:
wie oben beschrieben

Bedeutung von work_in[11..15]:
work_in[11]:   Seitenformat
               #define  PAGE_DEFAULT   0     /* Voreinstellung benutzen */
               #define  PAGE_A3        1     /* DIN A3 */
               #define  PAGE_A4        2     /* DIN A4 */
               #define  PAGE_A5        3     /* DIN A5 */
               #define  PAGE_B5        4     /* DIN B5 */

               #define  PAGE_LETTER    16    /* Letter size */
               #define  PAGE_HALF      17    /* Half size */
               #define  PAGE_LEGAL     18    /* Legal size */
               #define  PAGE_DOUBLE    19    /* Double size */
               #define  PAGE_BROAD     20    /* Broad sheet size */

work_in[12/13]: Zeiger auf einen GEMDOS-Dateinamen (C-String) oder Null
work_in[14]:    0, reserviert
work_in[15]:    0, reserviert


ù CLOSE WORKSTATION (VDI 2)

"CLOSE WORKSTATION" schliet eine physikalische Workstation. Vorher sollten alle
virtuellen Workstations geschlossen werden.
Bei Druckertreibern werden vor dem Schlieen ggf. die noch gepufferten Kommandos
ausgefhrt, bei Metafiletreibern wird der Metafile geschloen. Man beachte, da
das Schlieen der Workstation bei Druckertreibern keinen Seitenvorschub ausl”st.

Dekl.:  void v_clswk( WORD handle );
Aufruf: v_clswk( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        2                   v_clswk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù OPEN VIRTUAL SCREEN WORKSTATION (VDI 100)

"OPEN VIRTUAL SCREEN WORKSTATION" ”ffnet eine virtuelle Bildschirm-Workstation
auf einer bereits ge”ffneten physikalischen Workstation. Dadurch k”nnen die
Zugriffe verschiedener Programme mit ihren unterschiedlichen Einstellungen
koordiniert werden. Fr Bildschirmtreiber mssen Sie das Handle der
AES-Bildschirm-Workstation nach der Anmeldung Ihres Programmes beim AES mit.

  aes_handle = graf_handle(&gr_hwchar,&gr_hhchar,&gr_hwbox,&gr_hhbox);
  handle = aes_handle;

ermitteln.

Dekl.:  void v_opnvwk( WORD *work_in, WORD *handle, WORD *work_out );
Aufruf: v_opnvwk( work_in, &handle, work_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        100                 v_opnvwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        11                  Eintr„ge in intin
contrl[6]        handle              Handle der physikalischen Workstation
intin[0..10]     work_in[0..10]

Ausgaben:

contrl[2]        6                   Eintr„ge in ptsout
contrl[4]        45                  Eintr„ge in intout
contrl[6]        handle              Handle der virtuellen Workstation
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Die Bedeutung der Ein- und Ausgaben ist mit denen von "OPEN WORKSTATION"
identisch.


ù CLOSE VIRTUAL SCREEN WORKSTATION (VDI 101)

Mit dieser Funktion wird eine ge”ffnete virtuelle Workstation geschlossen.

Dekl.:  void v_clsvwk( WORD handle );
Aufruf: v_clsvwk( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        101                 v_clsvwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:
contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù CLEAR WORKSTATION (VDI 3)

Diese Funktion l”scht den Bildschirm. Bei Plottern oder Druckern wird ein
Seitenvorschub durchgefhrt und der Druckpuffer gel”scht.

Deklaration: void v_clrwk( WORD handle );
Aufruf:      v_clrwk( handle);

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        3                   v_clrwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù CLEAR DISPLAY LIST (VDI 5, Escape 22)

Diese Funktion l”scht bei Plottern oder Druckern den Druckerpuffer. Im Gegensatz
zu CLEAR WORKSTATION wird jedoch kein Seitenvorschub durchgefhrt.
Diese Funktion sollte z.B. dann aufgerufen werden, wenn der Benutzer die
Grafikausgaben vor dem Ausdruck (also vor dem UPDATE WORKSTATION) abbrechen
m”chte.

Deklaration: void v_clear_disp_list( WORD handle );
Aufruf:      v_clear_disp_list( handle);

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   v_escape
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        22                  Unterfunktionsnummer v_clear_disp_list
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù UPDATE WORKSTATION (VDI 4)

Diese Funktion wird auf Ger„ten wie z.B. Druckern aufgerufen, die VDI-Kommandos
in einer Liste puffern. "UPDATE WORKSTATION" veranlat die Ausfhrung dieser
gepufferten Kommandos. Bei Bildschirm-Workstations oder Offscreen-Bitmaps mu
diese Funktion nicht aufgerufen werden, da Grafikkommandos sofort abgearbeitet
werden.

Dekl.:  void v_updwk( WORD handle );
Aufruf: v_updwk( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        4                   v_updwk
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù OPEN BITMAP (VDI 100, 1)

Der Aufruf von "OPEN BITMAP" erzeugt eine Offscreen-Bitmap auf der mit
VDI-Funktionen gezeichnet werden kann. Die Bitmap kann entweder bergeben werden
oder das VDI alloziert selber den dafr n”tigen Speicher. Die zu bergebenden
Pixelgr”en werden bei den Vektorfonts beachtet, so da die Mahaltigkeit
gew„hrt ist.
Die Benutzung von Offscreen-Bitmaps bietet sich auch dann an, wenn man Effekte
wie starkes Flackern vermeiden m”chte. In diesem Fall baut man Teile der Grafik
in der Bitmap auf und bertr„gt die Bitmap mit vrt_cpyfm() oder vro_cpyfm() auf den
Bildschirm.

Dekl.:  void v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out );
Aufruf: v_opnbm( work_in, &bitmap, &handle, work_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        100                 v_opnbm
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        20                  Eintr„ge in intin
contrl[5]        1                   Unterfunktionsnummer fr v_opnbm
contrl[6]        handle              Handle der physikalischen Workstation
contrl[7..8]     bitmap              Zeiger auf einen MFDB der Bitmap
intin[0..19]     work_in[0..19]

Ausgaben:

contrl[2]        6                   Eintr„ge in ptsout
contrl[4]        45                  Eintr„ge in intout
contrl[6]        handle              Handle der Bitmap
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Bedeutung von work_in:
work_in[0..10]:   wie bei v_opnwk()/v_opnvwk() definiert
work_in[11]:      Breite -1 (z.B. 1279)
work_in[12]:      H”he -1 (z.B. 959)
work_in[13]:      Breite eines Pixels in Mikrometern
work_in[14]:      H”he eines Pixels in Mikrometern
work_in[15..19]:  mu 0 sein, wenn das ger„tespezifische Format benutzt wird

Bedeutung von bitmap:
Bitmap ist ein Zeiger auf einen MFDB. Falls bitmap->fd_addr gleich NULL ist, so
wird anhand der Gr”enangaben in work_in Speicher fr die Bitmap angefordert
(die Bitmap wird im Gegensatz zu v_opnvwk() gel”scht).

Um eine Bitmap im ger„tespezifischen Format zu ”ffnen, mu bitmap->fd_nplanes
eine Null oder die Ebenenanzahl des Schirms enthalten (work_out[4] bei
vq_extnd()). Ist bitmap->fd_nplanes 1, wird eine monochrome Bitmap angelegt.

Die Eintr„ge des MFDB (fd_addr, fd_w, fd_h, fd_wdwidth, fd_stand, fd_nplanes)
werden vom VDI-Treiber gesetzt und an die aufrufende Applikation zurckgegeben.
Wenn nicht nicht gengend Speicher vorhanden ist, wird der Inhalt des MFDBs
nicht ver„ndert; ein Null-Handle wird zurckgegeben.

Wenn bitmap->fd_addr ungleich NULL ist, wird dieser Eintrag als Zeiger auf eine
Bitmap interpretiert. Wenn die Bitmap im Standardformat vorliegt, wird sie ins
ger„tespezifische Format umgewandelt. Liegt sie schon im ger„tespezifischen
Format vor, so wird sie nicht umgewandelt. Falls die Aufl”sung der Bitmap (d.h.
die Anzahl der Farben und Planes) nicht untersttzt wird, gibt v_opnbm() ein
Null-Handle zurck.

Ab EdDI 1.1 kann v_opnbm() mit zus„tzlichen Parametern in work_in[15..19]
aufgerufen werden. Es wird dann versucht, eine Bitmap in dem durch diese
Parameter beschriebenen Format zu ”ffnen. Sollte fr das angegebene Format kein
Treiber vorhanden sein, kann die Bitmap nicht erzeugt werden.

work_in[15..16]:  Anzahl der gleichzeitig darstellbaren Farben
work_in[17]:      Anzahl der Planes
work_in[18]:      Pixelformat
work_in[19]:      Bitreihenfolge

Pixelformat und Bitreihenfolge werden bei vq_scrninfo() genauer beschrieben. Mit
den folgenden Parametern kann z.B. eine Offscreen-Bitmap mit 256 Farben und
Interleaved Planes erzeugt werden:

work_in[15..16] = 256;  /* 256 gleichzeitig darstellbare Farben */
work_in[17] = 8;        /* 8 Farbebenen */
work_in[18] = 0;        /* Interleaved Planes */
work_in[19] = 1;        /* normale Bitreihenfolge (Motorola-Format) */


ù CLOSE BITMAP (VDI 101, 1)

Die Funktion v_clsbm() schliet die mit handle bezeichnete Bitmap. Wenn der
Speicher bei v_opnbm() vom VDI alloziert wurde, gibt sie diesen Speicher wieder
frei.

Dekl.:  void v_clsbm( WORD handle );
Aufruf: v_clsbm( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        101                 v_clsbm
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        1                   Unterfunktionsnummer fr v_clsbm()
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù EXTENDED INQUIRE FUNCTION (VDI 102)

Von dieser Funktion werden entweder die Parameter von v_opnwk()/v_opnvwk() oder
erweiterte Ausknfte zum Ger„tetreiber und zum Ger„t zurckgeliefert.

Dekl.:  void vq_extnd( WORD handle, WORD flag, WORD *work_out );
Aufruf: vq_extnd( handle, owflag, work_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        102                 vq_extnd
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         flag                Informationstyp

Ausgaben:

contrl[2]        6                   Eintr„ge in ptsout
contrl[4]        45                  Eintr„ge in intout
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Bedeutung von flag:
0: Parameter von v_opnwk()/v_opnvwk()
1: erweiterte Parameter

Bedeutung von work_out:
work_out[0]:  Bildschirmtyp
              0: kein Bildschirm
              1: getrennter Text- und Grafikmodus und getrennter
                 Bildspeicher
              2: getrennter Text- und Grafikmodus mit gemeinsamem
                 Bildspeicher
              3: gemeinsamer Text- und Grafikmodus mit getrenntem
                 Bildspeicher
              4: gemeinsamer Text- und Grafikmodus mit gemeinsamem
                 Bildspeicher
work_out[1]:  Anzahl der Farbabstufungen
work_out[2]:  Anzahl der Texteffekte
work_out[3]:  Flag fr Vergr”erung des Rasters
              0: Vergr”erung nicht m”glich
              1: Vergr”erung m”glich
work_out[4]:  Anzahl der Bildebenen
work_out[5]:  "Color lookup table"-Untersttzung
              0: nicht m”glich
              1: m”glich
work_out[6]:  Anzahl der 16*16-Pixel-Raster-Operationen pro Sekunde
work_out[7]:  Verfgbarkeit der Fl„chenfllung (v_contourfill)
              0: nicht verfgbar
              1: verfgbar
work_out[8]:  Textrotation
              0: nicht m”glich
              1: in 90-Grad-Schritten
              2: in 1/10-Grad-Schritten
work_out[9]:  Anzahl der Schreibmodi
work_out[10]: Eingabemodi
              0: keine
              1: Request
              2: Request und Sample
work_out[11]: Textausrichtung:
              0: nicht verfgbar
              1: verfgbar
work_out[12]: Farbstiftwechsel
              0: nicht m”glich
              1: m”glich
work_out[13]: Farbbandwechsel
              0: nicht m”glich
              1: farbige Zeilen
              2: farbige Zeilen und Rechtecke
work_out[14]: maximale   Anzahl   der   Koordinatenpaare   fr   Polyline,
              Polymarker, und Filled Area oder -1 (unbegrenzt)
work_out[15]: maximale L„nge des intin-Array oder -1 (unbegrenzt)
work_out[16]: Anzahl der Maustasten
work_out[17]: Verfgbarkeit von Linientypen fr breite Linien
              0: nicht verfgbar
              1: verfgbar
work_out[18]: Anzahl der Schreibmodi fr breite Linien
work_out[19]: Clipping-Flag
              0: Clipping aus
              1: Clipping an
work_out[20]: 0: keine genaueren Pixelgr”en in den folgenden Feldern
              1: Pixelausmae werden in 1/10 Mikrometern zurckgeliefert
              2: Pixelausmae werden in 1/100 Mikrometern zurckgeliefert
              3: Pixelausmae werden in 1/1000 Mikrometern zurckgeliefert

work_out[21]: Pixelbreite in 1/10, 1/100 oder 1/1000 Mikrometern
work_out[22]: Pixelh”he in 1/10, 1/100 oder 1/1000 Mikrometern
work_out[23]: horizontale Aufl”sung in dpi
work_out[24]: vertikale Aufl”sung in dpi
work_out[28]: Bezier-Flag. Bit 1 gibt Auskunft ber die Bezierf„higkeiten
              0: Keine Beziers
              1: Beziers

work_out[30]: Rasterflags
              Bit 0: Raster k”nnen bei vro_cpyfm()/vrt_cpyfm() skaliert werden (1)

work_out[40]: nicht bedruckbarer linker Rand in Pixeln (nur Drucker usw.)
work_out[41]: nicht bedruckbarer oberer Rand in Pixeln (nur Drucker usw.)
work_out[42]: nicht bedruckbarer rechter Rand in Pixeln (nur Drucker usw.)
work_out[43]: nicht bedruckbarer unterer Rand in Pixeln (nur Drucker usw.)

work_out[44]: Papierformat (nur Drucker usw.)

work_out[45..48]: Clipping-Rechteck

Bemerkungen:
Wenn work_out[20] einen Wert ungleich 0 enth„lt, werden in den Elementen 21-24
und 40-43 zus„tzliche Informationen ber Pixelgr”e und nicht bedruckbare
R„nder bergeben. Die nicht bedruckbaren R„nder werden normalerweise nur bei
Druckertreibern zurckgeliefert. Sie erm”glichen Applikationen, Dokumente zu
zentrieren oder dem Benutzer ein zutreffendes Bild der ausgedruckten Seite zu
liefern, indem die R„nder im Dokument angezeigt werden (der bei v_opnwk() in
work_in[0/1] zurckgelieferte Bereich ist der bedruckbare Bereich).

Das Papierformat in work_out[44] ist analog zu v_opnwk() definiert.

Wenn genauere Pixelgr”en zurckgeliefert werden, sollte man diese besonders
beim Drucken zur Positionsberechnung der einzelnen Grafikobjekte benutzen, denn
die Benutzung der Werte in work_out[3..4] kann im schlimmsten Fall auf einem
DIN A4 Blatt zu einer Ungenauigkeit von insgesamt 2 bis 3 mm fhren.

Die Rckgabe des Clipping-Flags (work_out[19]) und des Clipping-Rechtecks
(work_out[45..48]) ist GEM 2.x-kompatibel. Unter dem ATARI-VDI wird das
Clipping-Flag nicht zurckgegeben, wohl aber das Clipping-Rechteck (obwohl das
nicht dokumentiert ist) - Benutzung also auf eigene Gefahr!

Die  Rckgabe  des  Bezier-Flag (work_out[28], Bit 1) ist GEM/3-kompatibel. Im
ATARI-VDI ist work_out[28] reserviert und enth„lt eine Null.


ù INQUIRE SCREEN INFORMATION (VDI 102, 1)

"INQUIRE SCREEN INFORMATION" liefert genauere Angaben ber Bildschirmformat
(auch ger„tespezifisches Format genannt).
Diese Informationen sind in erster Linie interessant fr Programme, die
-  schnell Raster aufbauen (dithern) und diese mit vro_cpyfm() kopieren m”chten.
-  farbige Raster speichern (XIMGs, TIFFs, JPEGs).

Dekl.:  void vq_scrninfo( WORD handle, WORD *work_out );
Aufruf: vq_scrninfo( handle, work_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        102                 vq_scrninfo
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[5]        1                   Unterfunktionsnummer von vq_scrninfo()
contrl[6]        handle
intin[0]         2                   erweiterte Informationen ausgeben

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        272                 Eintr„ge in intout
intout[0..272]   work_out[0..272]    erweiterte Informationen

Bedeutung von work_out:
work_out[0]:   Formatangabe:
               0: Interleaved Planes, wortweise (ATARI Grafik)
               1: Standardformat (komplette Planes)
               2: Packed Pixels
               -1: unbekanntes Format; nicht direkt beschreibbar
work_out[1]:   Verfgbarkeit einer CLUT:
               0: keine CLUT (z.B. TTM 194)
               1: Hardware-CLUT
               2: Software-CLUT (Hicolor oder Truecolor)
work_out[2]:   Anzahl der Ebenen (Bits) pro Pixel
work_out[3/4]: Farbanzahl oder 0L (mehr als 2*10^31 Farben)
work_out[5]:   Breite einer Zeile in Bytes (erst ab EdDI 1.1)
work_out[6/7]: Adresse der Bitmap (erst ab EdDI 1.1)
work_out[8]:   Anzahl der Bits fr die Rot-Intensit„t
work_out[9]:   Anzahl der Bits fr die Grn-Intensit„t
work_out[10]:  Anzahl der Bits fr die Blau-Intensit„t
work_out[11]:  Anzahl der Bits fr den Alpha-Channel oder „hnliches
work_out[12]:  Anzahl der Bits fr Genlock
work_out[13]:  Anzahl der nicht benutzen Bits
work_out[14]:  Bitorganisation (erst ab EdDI 1.1)

               Bei 2-256 Farben:

               Bitnummer | Bedeutung des Bits
               ----------|--------------------------------------------------
                  0      | normale Bitreihenfolge

               Bei 32768 Farben (16 Planes):

               Bitnummer | Bedeutung des Bits
               ----------|--------------------------------------------------
                  0      | normale Bitreihenfolge, d.h. 1 Overlay-Bit,
                         | 5 Rot-Bits, 5 Grn-Bits, 5 Blau-Bits
                         |
                  1      | Falcon-Format, d.h.  5 Rot-Bits, 5 Grn-Bits,
                         | 1 Overlay-Bit, 5 Blau-Bits
                         |
                  7      | Bytes vertauscht: Intel-Modell

               Bei 65536 Farben (16 Planes):

               Bitnummer | Bedeutung des Bits
               ----------|--------------------------------------------------
                  0      | normale Bitreihenfolge, d.h. 5 Rot-Bits,
                         | 6 Grn-Bits, 5 Blau-Bits
                         |
                  7      | Bytes vertauscht: Intel-Modell

               Bei 16777216 Farben (24 Planes):

               Bitnummer | Bedeutung des Bits
               ----------|--------------------------------------------------
                  0      | normale Bitreihenfolge, d.h. 8 Rot-Bits,
                         | 8 Grn-Bits, 8 Blau-Bits
                         |
                  7      | Bytes vertauscht: Intel-Modell

               Bei 16777216 Farben (32 Planes):

               Bitnummer | Bedeutung des Bits
               ----------|--------------------------------------------------
                  0      | normale Bitreihenfolge, d.h. 8 Overlay-Bits,
                         | 8 Rot-Bits, 8 Grn-Bits, 8 Blau-Bits
                         |
                  7      | Bytes vertauscht: Intel-Modell

Falls eine Hardware-CLUT (intout[1] == 1) vorhanden ist:
work_out[16-271]: Pixelwert des zugeh”rigen VDI-Farbindexes

Falls Hicolor, Truecolor oder „hnliches vorhanden ist:
work_out[16..31]:    Zuordnung von Bitnummer im Pixel zum Bit der Rotintensit„t
work_out[32..47]:    Zuordnung von Bitnummer im Pixel zum Bit der Grnintens.
work_out[48..63]:    Zuordnung von Bitnummer im Pixel zum Bit der Blauintensit„t
work_out[64..79]:    Zuordnung der Bitnummer fr Alpha-Channel
work_out[80..95]:    Zuordnung der Bitnummer fr Genlock
work_out[96..127]:   unbenutzte Bits
work_out[128..271]:  reserviert (0)

   Beispiele:
   ----------

   In 256 Farben auf dem Falcon wrden folgende Ausgaben erfolgen:

   work_out | Wert   | Bedeutung
   ---------|--------|-----------------------------------------------------
      0     |   0    | Interleaved Planes, wortweise
      1     |   1    | Hardware-CLUT vorhanden
      2     |   8    | 8 Bit pro Pixel
      3/4   | 256    | 256 verschiedene Farben gleichzeitig m”glich
      5     | xxxx   | Bitmapbreite in Bytes (erst ab EdDI 1.1)
      6/7   | xxxxL  | Bitmapadresse (erst ab EdDI 1.1)
      8     |   6    | 6 Bits fr die Rot-Intensit„t
      9     |   6    | 6 Bits fr die Grn-Intensit„t
     10     |   6    | 6 Bits fr die Blau-Intensit„t
     11     |   0    | kein Bit fr Alpha-Channel
     12     |   0    | kein Bit fr Genlock
     13     |   0    | kein unbenutzes Bit
     14     |   1    | normale Bitreihenfolge (erst ab EdDI 1.1)
            |        |
     16     |   0    | Pixelwert fr VDI-Farbindex 0
     17     | 255    | Pixelwert fr VDI-Farbindex 1
     18     |   2    | Pixelwert fr VDI-Farbindex 2
     ...    | ...    |
    271     |  15    | Pixelwert fr VDI-Farbindex 255

   In Hicolor auf dem Falcon wrden folgende Ausgaben erfolgen:

   work_out | Wert   | Bedeutung
   ---------|--------|-----------------------------------------------------
      0     |   2    | Packed Pixels
      1     |   2    | Hicolor bzw. Truecolor
      2     |  16    | 16 Bit pro Pixel
      3/4   | 32768  | 32768 verschiedene Farben gleichzeitig m”glich
      5     | xxxx   | Bitmapbreite in Bytes (erst ab EdDI 1.1)
      6/7   | xxxxL  | Bitmapadresse (erst ab EdDI 1.1)
      8     |   5    | 5 Bits fr die Rot-Intensit„t
      9     |   5    | 5 Bits fr die Grn-Intensit„t
     10     |   5    | 5 Bits fr die Blau-Intensit„t
     11     |   0    | kein Bit fr Alpha-Channel
     12     |   1    | ein Bit fr Genlock
     13     |   0    | kein unbenutzes Bit
     14     |   2    | Falcon 15-Bit-Format mit 1 Overlay-Bit (erst ab EdDI 1.1)
            |        |
     16     |  11    | Bit 0 der Rot-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 11 des Pixels
     17     |  12    | Bit 1 befindet sich in Bit 12 des Pixels
     18     |  13    | ...
     19     |  14    | ...
     20     |  15    | Bit 4 der Rot-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 15 des Pixels
     21..31 |  -1    | Bits werden nicht fr Rot-Intensit„t benutzt
            |        |
            |        |
     32     |   6    | Bit 0 der Grn-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 6 des Pixels
     33     |   7    | Bit 1 befindet sich in Bit 7 des Pixels
     34     |   8    | ...
     35     |   9    | ...
     36     |  10    | Bit 4 der Grn-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 10 des Pixels
     37..37 |  -1    | Bits werden nicht fr Grn-Intensit„t benutzt
            |        |
            |        |
     48     |   0    | Bit 0 der Blau-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 0 des Pixels
     49     |   1    | Bit 1 befindet sich in Bit 1 des Pixels
     50     |   2    | ...
     51     |   3    | ...
     52     |   4    | Bit 4 der Blau-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 4 des Pixels
     53..63 |  -1    | Bits werden nicht fr Blau-Intensit„t benutzt
            |        |
            |        |
     64..79 |  -1    | kein Alpha-Channel
            |        |
            |        |
     80     |   5    | Bit fr Genlock
     81..95 |  -1    | nicht fr Genlock benutzt
            |        |
            |        |
     96..127|  -1    | keine unbenutzten Bits
            |        |

   In Hicolor auf einer VGA-Grafikkarte wrden folgende Ausgaben erfolgen:

   work_out | Wert   | Bedeutung
   ---------|--------|-----------------------------------------------------
      0     |   2    | Packed Pixels
      1     |   2    | Hicolor bzw. Truecolor
      2     |  16    | 16 Bit pro Pixel
      3/4   | 32768  | 32768 verschiedene Farben gleichzeitig m”glich
      5     | xxxx   | Bitmapbreite in Bytes (erst ab EdDI 1.1)
      6/7   | xxxxL  | Bitmapadresse (erst ab EdDI 1.1)
      8     |   5    | 5 Bits fr die Rot-Intensit„t
      9     |   5    | 5 Bits fr die Grn-Intensit„t
     10     |   5    | 5 Bits fr die Blau-Intensit„t
     11     |   0    | kein Bit fr Alpha-Channel
     12     |   0    | kein Bit fr Genlock
     13     |   1    | ein unbenutzes Bit
     14     |  129   | 15 Bit in Intel-Darstellung (gggbbbbb-xrrrrrgg;erst ab EdDI 1.1)
            |        |
     16     |   2    | Bit 0 der Rot-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 2 des Pixels
     17     |   3    | Bit 1 befindet sich in Bit 3 des Pixels
     18     |   4    | ...
     19     |   5    | ...
     20     |   6    | Bit 4 der Rot-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 6 des Pixels
     21..31 |  -1    | Bits werden nicht fr Rot-Intensit„t benutzt
            |        |
            |        |
     32     |  13    | Bit 0 der Grn-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 13 des Pixels
     33     |  14    | Bit 1 befindet sich in Bit 14 des Pixels
     34     |  15    | ...
     35     |   0    | ...
     36     |   1    | Bit 4 der Grn-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 1 des Pixels
     37..37 |  -1    | Bits werden nicht fr Grn-Intensit„t benutzt
            |        |
            |        |
     48     |   8    | Bit 0 der Blau-Intensit„t (niederwertigstes Bit)
            |        | befindet sich in Bit 8 des Pixels
     49     |   9    | Bit 1 befindet sich in Bit 9 des Pixels
     50     |  10    | ...
     51     |  11    | ...
     52     |  12    | Bit 4 der Blau-Intensit„t (h”chstwertigstes Bit)
            |        | befindet sich in Bit 12 des Pixels
     53..63 |  -1    | Bits werden nicht fr Blau-Intensit„t benutzt
            |        |
            |        |
     64..79 |  -1    | kein Alpha-Channel
            |        |
            |        |
     80..95 |  -1    | nicht fr Genlock benutzt
            |        |
            |        |
     96     |   7    | unbenutztes Bit
     97..127|  -1    | keine unbenutzten Bits
            |        |

Bemerkungen:
Die Ausgaben in work_out[5..7/14] sind erst ab EdDI-Version 1.1 vorhanden und
sollen die Erkennung des Formats erleichtern. Bevor man auf sie zugreift, sollte
man noch die Version des EdDI-Cookies getestet haben.


ù INQUIRE DEVICE STATUS INFORMATION (VDI 248)

Vq_devinfo() liefert zurck, ob ein Treiber vorhanden ist und ob er schon 
ge”ffnet wurde. Auerdem wird der Dateiname (z.B. XVGA256.SYS) und der
Klartextname (VGA 256 Farben) des Treibers zurckgeliefert. Wenn der Dateiname
leer ist, ist der Treiber nicht vorhanden.


Dekl.:  void  vq_devinfo( WORD handle, WORD device, WORD *dev_open,
                          BYTE *file_name, BYTE *device_name );
Aufruf: vq_devinfo( handle, device, &dev_open, file_name, device_name );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        248                 vq_devinfo
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         device              VDI-Ger„tenummer (0-99)

Ausgaben:

contrl[2]        p                   Anzahl der W™RTER in ptsout
contrl[4]        i                   Anzahl der W”rter in intout

ptsout[0]        dev_open            0: Treiber ist noch nicht ge”ffenet
                                     1: Treiber ist bereits ge”ffnet
ptsout[1..p-1]   device_name         Klartextname des Treibers als C-String
intout[0..i-1]   file_name           Dateiname des Treibers

Bemerkungen:
Der Dateiname wird wortweise zurckgeliefert, d.h. 1 Wort pro Buchstabe, wobei
contrl[4] die L„nge angibt. Der Klartextname wird als nullterminierter C-String
zurckgeliefert - contrl[2] enth„lt die Anzahl der _W™RTER_ in ptsout.


ù INQUIRE EXTENDED DEVICE STATUS INFORMATION (VDI 248, 4242)

hnlich wie vq_devinfo() liefert vq_ext_devinfo() Treibernamen und
Informationen ber den Treiber zurck. Das Format ist aber etwas sinnvoller.

Dekl.:  WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                              BYTE *file_path, BYTE *file_name, BYTE *name );

Aufruf: dev_open = vq_ext_devinfo( handle, device, &dev_exists, file_path,
                                   file_name, name );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        248                 vq_devinfo
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        7                   Eintr„ge in intin
contrl[5]        4242                Unterfunktionsnummer
contrl[6]        handle
intin[0]         device              VDI-Ger„tenummer (0-99)
intin[1/2]       file_path           Zeiger auf den Datei-Pfad
intin[3/4]       file_name           Zeiger auf den Dateinamen
intin[5/6]       name                Zeiger auf den Klartextnamen

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        dev_exists          0: kein Treiber unter dieser Ger„tekennung
                                     != 0: Treiber vorhanden
intout[1]:       dev_open            0: Treiber wurde noch nicht ge”ffnet
                                     != 0: Treiber wurde bereits ge”ffnet

Alle zurckgelieferten Zeichenketten sind C-Strings.


Besonderheiten einzelner Treiber
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
ù Wechsel des Druckernamens, -typs oder der -aufl”sung

   Wenn die Voreinstellung eines Treibers ge„ndert wird, d.h. wenn die 
   Aufl”sung, die Anzahl der Farben usw. sich „ndern, wird vom Treiber-CPX eine 
   AES-Mitteilung verschickt.

   #define  PRN_CHANGED 82

   mbuf[0] = PRN_CHANGED;
   mbuf[1] = app_id;          /* Applikationsnummer */
   mbuf[2] = 0;               /* Nachricht hat keine šberl„nge */
   mbuf[3] = id;              /* Ger„tenummer */
   mbuf[4] = 1;               /* hat sich ge„ndert */
   mbuf[5] = 0;
   mbuf[6] = 0;
   mbuf[7] = 0;

ù Druckertreiber - Ger„tekennungen 21 bis 30

   Bei NVDI-Druckertreibern kann bei v_opnwk() das Seitenformat und das
   GEMDOS-Ausgabeger„t gesetzt werden. Zus„tzlich zu den normalen Eingaben bei
   v_opnwk() mssen die folgenden Parameter bergeben werden:

   contrl[3]   16

   intin[11]         Seitenformat
                     #define  PAGE_DEFAULT   0     /* Voreinstellung benutzen */
                     #define  PAGE_A3        1     /* DIN A3 */
                     #define  PAGE_A4        2     /* DIN A4 */
                     #define  PAGE_A5        3     /* DIN A5 */
                     #define  PAGE_B5        4     /* DIN B5 */

                     #define  PAGE_LETTER    16    /* Letter size */
                     #define  PAGE_HALF      17    /* Half size */
                     #define  PAGE_LEGAL     18    /* Legal size */
                     #define  PAGE_DOUBLE    19    /* Double size */
                     #define  PAGE_BROAD     20    /* Broad sheet size */

   intin[12/13]      Zeiger auf einen GEMDOS-Dateinamen (C-String) oder Null
   intin[14]   0     reserviert
   intin[15]   0     reserviert

   Um zu berprfen, ob das Papierformat tats„chlich eingestellt werden konnte, 
   sollte man anschlieend vq_extnd() aufrufen.

   NICHT ZU EMPFEHLEN:
   Man kann Breite und H”he der vom Druckertreiber zu erzeugenden Bitmap setzen,
   indem man in ptsin[0/1] Breite - 1, H”he - 1 und in contrl[1] eine 1 eintr„gt
   und anschlieend v_opnwk() oder vq_extnd() aufruft. Dieses Verfahren ist
   NICHT ZU EMPFEHLEN, da eine Applikation nie genau absch„tzen kann, wie gro
   die Bitmap tats„chlich sein darf, damit der Drucker sie vernnftig ausgeben
   kann.

   Ausdruck von Rasterbildern
   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
   Zur Ausgabe von (Farb-) Bildern sollten die Funktionen vrt_cpyfm()/ bzw. 
   vro_cpyfm() benutzt werden. Sie lassen sich in NVDI fr Druckertreiber (und 
   IMG, usw.) genauso wie die Funktionen des Bildschirmtreibers ansprechen.
   Der einzige 
   Unterschied besteht darin, da Raster nicht innerhalb der Druckerbitmap 
   verschoben werden k”nnen (Quell- und Ziel- MFDB mit fd_addr == 0L), da die 
   Druckerbitmap i.A. aus mehreren Scheiben besteht, die nacheinander aufbereitet 
   werden. Da Kopieren innerhalb der Ger„tebitmap bei der Druckausgabe keinen 
   Sinn macht, stellt dieser Unterschied aber keine Einschr„nkung dar.
   
   Der Druckertreiber puffert die Bitmap ggf. in der Display-List falls nicht 
   gengend Speicher vorhanden ist; es ist also nicht erforderlich, die Bitmap
   bis zur Ausgabe mit v_updwk() im Speicher zu halten.   

   Wenn die Bitmap skaliert werden mu, sollte ein Programm wenn m”glich nicht 
   selber die Bitmap vergr”ern, sondern vrt/vro_cpyfm() die Arbeit berlassen. 
   Dadurch steigt die Ausgabequalit„t, es mssen weniger Daten auf der 
   Festplatte gepuffert werden, und der Ausdruck wird beschleunigt. Ob der 
   Treiber skalieren kann, erf„hrt man bei Aufruf von vq_extnd().
   
   Bei Ausgabe von Farbbildern im 8-Farbmodus sollten Raster vor dem Dithern 
   mit einer Korrekturfunktion behandelt werden. Hier empfiehlt sich eine 
   Gamma-Korrektur mit Exponent von 0,3 bis 0,4, damit das Bild nicht vollkommen 
   matt und bers„ttigt aussieht.
   
   Im Truecolor-Modus bernimmt der Treiber Farbkorrektur, Schwarz-Separation 
   und andere qualit„tsverbessernde Manahmen selber - Bitmaps sollten hier ohne 
   vorhergehende Korrektur und ohne Rasterung an den Treiber geschickt werden.
 
   Bitmapformat bei Druckertreibern
   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
   Genauso wie fr den Bildschirm liefert vq_scrninfo() auch fr Drucker das 
   Format der Bitmap zurck. In der Regel gibt es hier nur 3 verschiedene 
   Formate: 
   
      (1) Monochrome Bitmap, wenn der Treiber 2 Farben hat.
      
      (2) Drei hintereinanderliegende Ebenen, wenn der Treiber 8 Farben hat.

      (3) Packed Pixels mit 32 Bit, wenn der Treiber im Truecolor-Modus l„uft.
   
   Da die Formate (1) und (3) wohl selbsterkl„rend sind, sei hier nur noch auf 
   Format (2) eingegangen:
   
   Bei 8 Farben besteht eine farbige Bitmap aus 3 vollst„ndigen, hintereinander 
   im Speicher liegenden Ebenen (Planes). Das ger„tespezifische Rasterformat 
   entspricht also dem Standardformat. Die Zuordnung von VDI-Farbindex zum 
   Pixelwert folgt der Standardeinteilung, die fr alle VDI-Treiber in den 
   ersten 16 bzw. 8 Farben gilt:
   
   VDI-Farbindex     Pixelwert      Farbe
   0                 0 (000)        wei
   1                 7 (111)        schwarz
   2                 1 (001)        rot
   3                 2 (010)        grn
   4                 4 (100)        blau
   5                 6 (110)        cyan
   6                 3 (011)        gelb
   7                 5 (101)        magenta
   
   Pixelwert         VDI-Farbindex  Farbe
   0 (000)           0              wei
   1 (001)           2              rot
   2 (010)           3              grn
   3 (011)           6              gelb
   4 (100)           4              blau
   5 (101)           7              magenta
   6 (110)           5              cyan
   7 (111)           1              schwarz

   vrt/vro_cpyfm() und „ltere Druckertreiber
   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
   In „lteren Druckertreibern haben diese beiden Funktionen einen Fehler der 
   dazu fhrt, das Bitmaps, die nur eine Zeile hoch sind, evtl. nicht ausgegeben  
   werden. Deswegen sollte die bei vrt/vro_cpyfm() bergebene Bitmap mindestens 
   zwei Zeilen hoch sein. 


ù META.SYS - Ger„tekennung 31

   Der Metafile-Treiber speichert alle an ihn gerichteten Aufrufe in einem
   GEM-Metafile, der sich im aktuellen Verzeichnis der Applikation befindet und
   als Voreinstellung den Namen GEMFILE.GEM hat. M”chte man den Namen „ndern,
   sollte man direkt nach v_opnwk() die Funktion vm_filename() aufrufen, der man
   einen kompletten Dateinamen mit dem gewnschten Pfad und Namen bergeben
   sollte.
   Damit andere Programme den Metafile vernnftig darstellen k”nnen, sollten die
   Funktionen v_meta_extents(), vm_pagesize() und vm_coords() aufgerufen werden.

ù MEMORY.SYS - Ger„tekennung 61

   Der Treiber MEMORY.SYS stellt eine monochrome Bitmap zur Verfgung, auf die
   mit allen VDI-Befehlen zugegriffen werden kann. Die Aufl”sung dieser Bitmap
   wird bei v_opnwk() gesetzt. Hierzu wird in ptsin[0/1] Breite - 1 und H”he - 1
   bergeben, contrl[1] mu eine 1 enthalten. Nach v_opnwk() wird die Adresse
   der Bitmap in contrl[0/1] zurckgeliefert.
   Bei vq_extnd() kann man ebenfalls die Aufl”sung setzen. Auerdem besteht hier
   die M”glichkeit, einen eigenen Buffer zu šbergeben. In diesem Fall enth„lt
   contrl[3] eine 3 und intin[1/2] ist ein Zeiger auf den Buffer.
   Aufgrund der gr”erern Flexiblit„t empfehlen wir OffScreenbitmaps anstelle
   des MEMORY.SYS-Treibers zu verwenden.

ù IMG.SYS - Ger„tekennung 91 bis 99

   Genauso wie bei den NVDI-Druckertreibern kann man hier das Seitenformat und
   den Namen der IMG-Datei setzen - s.o.

   Eine weitere M”glichkeit den Dateinamen zu bergeben gibt es bei vq_extnd():

   contrl[1] = 4;
   ptsin[2] = 1157;
   ptsin[3/4] = Zeiger auf Dateinamen (BYTE *);
   ptsin[5/6] = Zeiger auf Fehlervariable (WORD *);
   ptsin[7] = 0;

ù Faxtreiber - meist Ger„tekennung 81 bis 90

   Faxtreiber verhalten sich „hnlich wie Druckertreiber. Man kann bei Ihnen aber
   weder Seitenformat noch das GEMDOS-Ger„t angeben. Man sollte auch nicht
   versuchen, die Gr”e der Bitmap zu ver„ndern.




Farbeinstellungen
=================

ù SET COLOR REPRESENTATION (VDI 14)

Mit dieser Funktion kann man die Farbabstufung einer Farbnummer  festlegen. Die
Intensit„t von Rot, Grn und Blau wird jeweils in Promille (0-1000) angegeben.
Bei Ger„ten mit einer CLUT (Grafiksysteme bis 8 Planes/ 256 Farben) wirken sich
die Einstellungen sofort auf alle Punkte aus, die bisher auf dem Bildschirm mit
dem Farbindex <index> gezeichnet wurden.

Bei mehr als 256 gleichzeitig darstellbaren Farben benutzen Grafiksysteme in der
Regel keine CLUT sondern eine direkte RGB-Zuordnung pro Pixel (siehe hierzu auch
vq_scrninfo()). Die einzelnen Pixel enthalten dann statt eines Farbindex einen
direkten RGB-Wert (z.B. je 8 Bit fr R,G und B und 8 Bit Overlay). Bei einer
solchen Organisation stellt das VDI pro Workstation 256 lokale Farbstifte und
eine Pseudo-Palette zur Verfgung, fr die man  mit vs_color() die Farbwerte
setzen kann. Eine nderung  wirkt sich also erst dann aus, wenn man wieder mit
dem Farbstift zeichnet und wirkt sich immer nur auf die mit <handle> bezeichnete
Workstation aus.

Dekl.:  void vs_color( WORD handle, WORD index, RGB1000 *rgb_in );
Aufruf: vs_color( handle, index, &rgb_in );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        14                  vs_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        4                   Eintr„ge in intin
contrl[6]        handle
intin[0]         index               Farbnummer
intin[1..3]      rgb_in              Farbintensit„ten von Rot, Grn, Blau

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù INQUIRE COLOR REPRESENTATION (VDI 26)

"INQUIRE COLOR REPRESENTATION" gibt Auskunft ber die eingestellten
Farbintensit„ten, wobei die M”glichkeit besteht, zwischen der bergebenen und
der tats„chlich eingestellten Intensit„t zu unterscheiden.

Dekl.:  WORD vq_color( WORD handle, WORD color_index, WORD flag,
                       RGB1000 *rgb_out );
Aufruf: valid = vq_color( handle, color_index, set_flag, &rgb_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        26                  vq_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         Farbnummer
intin[1]         flag                Flag fr Art der Intensit„t

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        4                   Eintr„ge in intout
intout[0]        valid               Farbindex auerhalb der Grenzen
intout[1..3]     rgb_out             Intensit„t von Rot, Grn und Blau

Bedeutung von flag:
0: es wird die vom  Anwender bei vs_color bergebene Farbintensit„t
   zurckgegeben.
1: es wird die tats„chlich eingestellte Farbintensit„t zurckgegeben

Bemerkung:
Die an vs_color bergebene und die eingestellte Farbintensit„t k”nnen bei
Systemen mit einer CLUT voneinander abweichen, wenn die Anzahl der m”glichen
Farbabstufungen zu klein ist. Bei Direct-RGB (keine CLUT) wird meistens die
tats„chlich eingestellte Intensit„t auch als die vom Anwender bergebene
Intensit„t zurckgeliefert, da die Anzahl der Abstufungen ausreichend gro ist.


ù SET CALIBRATION (VDI 5, ESCAPE 76)

Mit SET CALIBRATION kann man die Farbkalibration ein- oder ausschalten und kann
eine Kalibrationstabelle bergeben. Eine Kalibrationstabelle besteht aus 1001
RGB-Eintr„gen, die fr den Wertebereich 0 bis 1000 Promille jedem Eingabewert
einen korrigierten Promille-Wert zuordnet. Bevor man diese Funktion aufruft,
sollte man mit vq_clibrate() feststellen, ob sie berhaupt vorhanden ist.

Dekl.:  WORD vs_calibrate( WORD handle, WORD flag, RGB1000 *table );
Aufruf: cal_flag = vs_calibrate( handle, flag, &table );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   v_escape()
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[5]        76                  Unterfunktionsnummer vs_calibrate()
contrl[6]        handle
intin[0..1]      table               Zeiger auf Kalibrationstabelle oder 0L
intin[2]         flag                Kalibration aus (0) oder ein (1)
Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        cal_flag            Kalibration aus (0) oder ein (1)

Bemerkung:
Die Farbkalibration ist im gesamten System fr den mit <handle> bezeichneten
Treiber gltig. Daher sollte sie nicht von einzelnen Anwendungen, sondern nur
durch ein CPX-Modul oder Accessory eingestellt werden.


ù INQUIRE CALIBRATION (VDI 5, ESCAPE 77)

Diese Funktion liefert zurck, ob Funktionen zur Kalibrierung vorhanden sind und
ob die Kalibrierung eingeschaltet ist. Wenn contrl[4] einen 0 enth„lt, wird
Kalibrierung nicht untersttzt.

Dekl.:  WORD vq_calibrate( WORD handle, WORD *flag );
Aufruf: exists = vq_calibrate( handle, &flag );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   v_escape()
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        77                  Unterfunktionsnummer vq_calibrate()
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        exists              Eintr„ge in intout (0 oder 1)
intout[0]        flag                Kalibration aus (0) oder ein (1)





Verknpfung und Zeichenbereich
==============================

ù SET WRITING MODE (VDI 32)

Diese Funktion w„hlt die Verknpfung der Grafikoperationen aus.  Bei  šbergabe
eines nicht vorhandenen Modus wird Modus 1 (REPLACE) angew„hlt.

Dekl.:  WORD vswr_mode( WORD handle, WORD mode );
Aufruf: set_mode = vswr_mode( handle, mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        32                  vswr_mode
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         mode                gewnschter Verknpfungsmodus

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_mode            ausgew„hlter Verknpfungsmodus

Bedeutung von mode:
1, REPLACE:          Alles, was sich unter dem Grafik-Element befindet, wird
                     berdeckt.
2, TRANSPARENT:      Nur die gesetzen Pixel des Grafik-Elementes berdecken den
                     Hintergrund.
3, XOR:              Pixel des Grafik-Elementes darunterliegende Pixel werden
                     mit einer XOR-Funktion verknpft.
4, REV. TRANSPARENT: Die nicht gesetzten Pixel des Grafik-Elements berdecken
                     den Hintergrund.


ù SET CLIPPING RECTANGLE (VDI 129)

Mit  dieser  Funktion  kann  man  den  Arbeitsbereich  der   Grafikoperationen
begrenzen oder freigeben.  Ist der Arbeitsbereich begrenzt worden,  so  werden
berstehende Teile nicht ausgegeben.

Dekl.:  void vs_clip( WORD handle, WORD clip_flag, WORD *area );
Aufruf: vs_clip( handle, clip_flag, area );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        129                 vs_clip
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         clip_flag           0: Clipping aus, 1: Clipping an
ptsin[0..3]      area[0..3]          Arbeitsbereich

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bemerkung:
Das Clipping sollte aus Sicherheitsgrnden immer eingeschaltet werden, da die
Ausgaberoutinen beim šberschreiten der Bildschirmgrenzen sehr schnell groe
Speicherbereiche berschreiben, was zu unerfreulichen Abtrzen und Datenmll
fhren kann.

Wenn der Arbeitsbereich den ganzen Bildschirm einbeziehen soll, ist es  ratsam,
bei vs_clip() die bei v_opnvwk() erhaltenen Bildschirmausmae einzustellen.




Linien und nicht gefllte Grafikprimitive
=========================================

ù POLYLINE (VDI 6)

"POLYLINE" zeichnet einen Linienzug. Alle angegebenen Punkte werden nacheinander
mit Linien verbunden. Es mssen mindestens zwei Koordinatenpaare bergeben
werden.

Dekl.:  void v_pline( WORD handle, WORD count, WORD *xyarr );
Aufruf: v_pline( handle, count, xyarr );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        6                   v_pline
contrl[1]        n                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù OUTPUT BEZIER (VDI 6, 13)

Diese Funktion zeichnet eine ungefllte Bezierkurve.

Dekl.:  void v_bez( WORD handle, WORD count, WORD *xyarr, char *bezarr,
                    WORD *extent,int *totpts, WORD *totmoves );

Aufruf: v_bez( handle, count, xyarr, bezarr, extent, totpts, totmoves );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        6                   v_bez
contrl[1]        n                   Eintr„ge in ptsin
contrl[3]        (n+1)/2             Eintr„ge in intin
contrl[5]        13                  signalisiert v_bez
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten
intin[0..(n+1)/2-1] bezarr[0..n-1]   Punkttypen

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        6                   Eintr„ge in intout

intout[0]        totpts              Anzahl der berechneten Punkte
intout[1]        totmoves            Anzahl der Unterbrechungen im Linienzug
intout[2..5]                         reserviert
ptsout[0..3]     extent[0..3]        Koordinaten des umschlieenden Rechtecks

Bedeutung der Punkttypen:
Bit 0:   Startpunkt eines 4-Punkte Beziersegments (2 Ankerpunkte und zwei
         Richtungspunkte). Der Endpunkt eines Beziersegments kann auch der
         Startpunkt des n„chsten Beziers sein - er kann aber kein "jump point"
         sein.

Bit 1:   "jump point". Dieser Punkt und der vorhergehende werden nicht
         verbunden. Ntzlich um Enklaven oder Exklaven zu zeichnen.

Bit 2-7 sind undefiniert. Ist im Punkttyp Bit 0 gel”scht, verh„lt sich die
Bezierfunktion wie "POLYLINE" mit der Erweiterung, ber den "jump point"
Enklaven oder Exklaven zeichnen zu k”nnen.

Bemerkung:
Die im Byte-Array bezarr bergebenen Punkttypen mssen vom C-Binding vertauscht
werden, da diese Funktion leider diesbezglich kompatibel zum PC-GEM ist.
bezarr[0] wird ins Low-Byte von intin[0] und bezarr[1] ins High-Byte von
intin[0] geschrieben.


ù ARC (VDI 11, GDP 2)

"ARC" zeichnet einen Kreisbogen, dessen Start- und Endwinkel in 1/10 Grad von 0
bis 3600 angegeben werden.

Dekl.:  void v_arc( WORD handle, WORD x, WORD y, WORD radius,
                    WORD begang, WORD endang );
Aufruf: v_arc( handle, x, y, radius, begang, endang );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        4                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        2                   v_arc
contrl[6]        handle
intin[0]         begang              Startwinkel
intin[1]         endang              Endwinkel
ptsin[0]         x
ptsin[1]         y
ptsin[6]         radius              Radius

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ELLIPTICAL ARC (VDI 11, GDP 6)

"ELLIPTICAL ARC" zeichnet einen Ellipsenbogenausschnitt. Die Winkelangabe
erfolgt in 1/10 Grad von 0 bis 3600.

Dekl.:  void v_ellarc( WORD handle, WORD x, WORD y, WORD x_radius,
                       WORD y_radius, WORD begang, WORD endang );
Aufruf: v_ellarc( handle, x, y, x_radius, y_radius, begang, endang );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        6                   v_ellarc
contrl[6]        handle
intin[0]         begang              Startwinkel
intin[1]         endang              Endwinkel
ptsin[0]         x
ptsin[1]         y
ptsin[2]         xradius             Radius in horizontaler Richtung
ptsin[3]         yradius             Radius in vertikaler Richtung

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ROUNDED RECTANGLE (VDI 11, GDP 8)

Ein Rechteck mit gerundeten Ecken wird gezeichnet.

Dekl.:  void v_rbox( WORD handle, WORD *rect );
Aufruf: v_rbox( handle, rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        8                   v_rbox
contrl[6]        handle
ptsin[0..3]      rect[0..3]          Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ENABLE BEZIER CAPABILITIES (VDI 11, GDP 13)

Diese Funktion ist aus Kompatibilit„tsgrnden vorhanden. Sie sorgt dafr, da
Aufrufe von v_pline() ohne die Unterfunktionsnummer 13 als Aufrufe von v_bez()
und Aufrufe von v_fillarea() ohne die Unterfunktiosnummer als Aufrufe von
v_bez_fill() aufgefat werden. v_bez_on() wird normalerweise nur verwendet, um
festzustellen, ob Beziers vorhanden sind - in diesem Fall ist retval ungleich 0
(vorher sollte man intout[0] auf 0 setzen!).

Dekl.:  WORD v_bez_on( WORD handle );
Aufruf: retval = v_bez_on( handle );

Variable         Belegung         Bedeutung
Eingaben:

contrl[0]        11               GDP
contrl[1]        1                Eintr„ge in ptsin - signalisiert v_bez_on
contrl[3]        0                Eintr„ge in intin
contrl[5]        13               v_bez_on
contrl[6]        handle

Ausgaben:

intout[0]        retval           Beziertiefe

Bedeutung von retval:
<retval> kann einen Wert von 0 (keine Beziers) bis 7 (maximale Qualit„t)
annehmen, der ein ungef„hres Ma fr die Kurvenqualit„t darstellt -
normalerweise kann man von diesem Wert nur ableiten, ob Beziers vorhanden sind.


ù DISABLE BEZIER CAPABILITIES (VDI 11, GDP 13)

Diese Funktion ist aus Kompatibilit„tsgrnden vorhanden. Sie schaltet die
Sonderbehandlung fr v_bez() und v_bez_fill() aus.

Dekl.:  void v_bez_off( WORD handle );
Aufruf: v_bez_off( handle );

Variable         Belegung         Bedeutung
Eingaben:

contrl[0]        11               GDP
contrl[1]        0                Eintr„ge in ptsin - signalisiert v_bez_off
contrl[3]        0                Eintr„ge in intin
contrl[5]        13               v_bez_off
contrl[6]        handle

Ausgaben:

-


ù SET BEZIER QUALITY (VDI 5, ESCAPE 99)

Mit dieser Funktion wird die Qualit„t der Bezierfunktionen eingestellt. Die
Qualit„t kann in Prozent von 0 - 100 eingestellt werden.

Dekl.:  WORD v_bez_qual( WORD handle, WORD qual, WORD *set_qual );
Aufruf: v_bez_qual( handle, qual, &set_qual );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[5]        99
contrl[6]        handle
intin[0]         32                  intin[0..1] signaliseren v_bez_qual()
intin[1]         1
intin[2]         qual                gewnschte Bezierqualit„t in Prozent

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_qual            eingestellte Bezierqualit„t in Prozent


ù SET POLYLINE LINE TYPE (VDI 15)

Mit "SET POLYLINE LINE TYPE" kann man den Linientyp festlegen. Wenn der
gewnschte Linientyp nicht einstellbar ist, wird der Linientyp 1 (durchgehende
Linie) eingestellt.

Dekl.:  WORD vsl_type( WORD handle, WORD type );
Aufruf: set_type = vsl_type( handle, type );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        15                  vsl_type
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         type                gewnschter Linientyp

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_type            ausgew„hlter Linientyp

Bedeutung von type:
1: %1111111111111111  (durchgehende Linie)
2: %1111111111110000  (langer Strich)
3: %1110000011100000  (Punkte)
4: %1111111100011000  (Strich, Punkt)
5: %1111111100000000  (Strich)
6: %1111000110011000  (Strich, Punkt, Punkt)
7: benutzerdefiniert ber vsl_udsty()


ù SET POLYLINE LINE WIDTH (VDI 16)

Diese Funktion setzt die Linienbreite, wobei nur ungerade Werte eingestellt
werden (ggf. wird auf den n„chstkleineren Wert gerundet). Linien die breiter als
1 Pixel sind werden von den meisten Treibern nur ohne Muster gezeichnet.

Dekl.:  WORD vsl_width( WORD handle, WORD width );
Aufruf: set_width = vsl_width( handle, width );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        16                  vsl_width
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0]         width               gewnschte Linienbreite

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0]        set_width           ausgew„hlte Linienbreite

Bemerkung:
Die Linienbreite orientiert sich immer an der horizontalen Pixelgr”e.


ù SET POLYLINE COLOR INDEX (VDI 17)

Der Farbindex fr Linien wird gesetzt. Bei ungltigem Index wird der Farbindex 1
gesetzt.

Dekl.:  WORD vsl_color( WORD handle, WORD color_index );
Aufruf: set_color = vsl_color( handle, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        17                  vsl_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         gewnschte Linienfarbe

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_color           ausgew„hlte Linienfarbe


ù INQUIRE CURRENT POLYLINE ATTRIBUTES (VDI 35)

Diese Funktion gibt die aktuellen Linienattribute zurck.

Dekl.:  void vql_attributes( WORD handle, WORD *attrib );
Aufruf: vql_attributes( handle, attrib );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        35                  vql_attributes
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        5                   Eintr„ge in intout
intout[0]        attrib[0]           Linientyp
intout[1]        attrib[1]           Linienfarbe
intout[2]        attrib[2]           Schreibmodus
intout[3]        attrib[4]           Linienanfangsform
intout[4]        attrib[5]           Linienendform
ptsout[0]        attrib[3]           Linienbreite


ù SET POLYLINE END STYLES (VDI 108)

Das Aussehen der Linienenden wird mit "SET POLYLINE END STYLES" bestimmt. Bei
ungltigen Angaben wird das betreffende Linienende eckig.

Dekl.:  void vsl_ends( WORD handle, WORD beg_style, WORD end_style );
Aufruf: vsl_ends( handle, beg_style, end_style );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        108                 vsl_ends
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         beg_style           Aussehen des Linienanfangs
intin[1]         end_style           Aussehen des Linienendes

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von beg_style und end_style:
0: eckig
1: Pfeil
2: abgerundet


ù SET USER-DEFINED LINE STYLE PATTERN (VDI 113)

Mit dieser Funktion legt man den benutzerdefinierten Linientyp von "SET POLYLINE
LINE TYPE" fest.

Dekl.:  void vsl_udsty( WORD handle, WORD pattern );
Aufruf: vsl_udsty( handle, pattern );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        113                 vsl_udsty
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         pattern             benutzerdefiniertes Linienmuster

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout




Gefllte Grafikprimitive
========================

ù FILLED AREA (VDI 9)

Durch "FILLED AREA" wird eine beliebige, gefllte Fl„che gezeichnet.

Dekl.:  void v_fillarea( WORD handle, WORD count, WORD *xyarr );
Aufruf: v_fillarea( handle, count, xyarr );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        9                   v_fillarea
contrl[1]        n                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù OUTPUT FILLED BEZIER (VDI 9, 13)

Diese Funktion zeichnet eine gefllte Bezierkurve.

Dekl.:  void v_bez_fill( WORD handle, WORD count, WORD *xyarr, UBYTE *bezarr,
                         WORD *extent, WORD *totpts, WORD *totmoves );
Aufruf: v_bez_fill( handle, count, xyarr, bezarr, extent, totpts, totmoves );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        9                   v_bez_fill
contrl[1]        n                   Eintr„ge in ptsin
contrl[3]        (n+1)/2             Eintr„ge in intin
contrl[5]        13                  signalisiert v_bez_fill
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten
intin[0..(n+1)/2-1] bezarr[0..n-1]   Punkttypen

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        6                   Eintr„ge in intout
intout[0]        totpts              Anzahl der berechneten Punkte
intout[1]        totmoves            Anzahl der Unterbrechungen im Linienzug
intout[2..5]                         reserviert
ptsout[0..3]     extent[0..3]        Koordinaten des umschlieenden Rechtecks

Bedeutung der Punkttypen:
Bit 0:   Startpunkt eines 4-Punkte Beziersegments (2 Ankerpunkte und zwei
         Richtungspunkte). Der Endpunkt eines Beziersegments kann auch der
         Startpunkt des n„chsten Beziers sein - er kann aber kein "jump point"
         sein.

Bit 1:   "jump point". Dieser Punkt und der vorhergehende werden nicht
         verbunden. Ntzlich um Enklaven oder Exklaven zu zeichnen.

Bit 2-7 sind undefiniert. Ist im Punkttyp Bit 0 gel”scht, verh„lt sich die
Bezierfunktion wie "FILLED AREA" mit der Erweiterung, ber den "jump point"
Enklaven oder Exklaven zeichnen zu k”nnen.

Bemerkung:
Die im Byte-Array bezarr bergebenen Punkttypen mssen vom C-Binding vertauscht
werden, da diese Funktion leider diesbezglich kompatibel zum PC-GEM ist.
bezarr[0] wird ins Low-Byte von intin[0] und bezarr[1] ins High-Byte von
intin[0] geschrieben.


ù BAR (VDI 11, GDP 1)

Von dieser Funktion wird ein ausgeflltes Rechteck gezeichnet. Im Gegensatz zu
"FILLED RECTANGLE" wird eine Umrahmung ausgegeben.

Dekl.:  void v_bar( WORD handle, WORD *rect );
Aufruf: v_bar( handle, rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        1                   v_bar
contrl[6]        handle
ptsin[0..3]      rect[0..3]          Koordinaten des Rechtecks

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù PIE (VDI 11, GDP 3)

Diese Funktion zeichnet einen Kreisfl„chenausschnitt. Die Winkel werden in
1/10 Grad von 0 bis 3600 angegeben.

Dekl.:  void v_pieslice( WORD handle, WORD x, WORD y, WORD radius,
                         WORD begang, WORD endang );
Aufruf: v_pieslice( handle, x, y, radius, begang, endang );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        4                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        3                   v_pieslice
contrl[6]        handle
intin[0]         begang              Startwinkel
intin[1]         endang              Endwinkel
ptsin[0]         x
ptsin[1]         y
ptsin[6]         radius              Radius

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù CIRCLE (VDI 11, GDP 4)

Die Funktion "CIRCLE" zeichnet eine Kreisfl„che.

Dekl.:  void v_circle( WORD handle, WORD x, WORD y, WORD radius );
Aufruf: v_circle( handle, x, y, radius );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        3                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        4                   v_circle
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y
ptsin[4]         radius              Radius

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ELLIPSE (VDI 11, GDP 5)

Diese Funktion zeichnet eine Ellipsenfl„che.

Dekl.:  void v_ellipse( WORD handle, WORD x, WORD y,
                        WORD x_radius, WORD y_radius  );
Aufruf: v_ellipse( handle, x, y, x_radius, y_radius );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        5                   v_ellipse
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y
ptsin[2]         x_radius            Radius in horizontaler Richtung
ptsin[3]         y_radius            Radius in vertikaler Richtung

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ELLIPTICAL PIE (VDI 11, GDP 7)

Die Funktion "ELLIPTICAL PIE" zeichnet einen Ellipsenfl„chenausschnitt. Die
Angabe der Winkel geschieht in Zehntelgrad von 0 bis 3600.

Dekl.:  void v_ellpie( WORD handle, WORD x, WORD y, WORD x_radius,
                       WORD y_radius, WORD begang, WORD endang );
Aufruf: v_ellpie( handle, x, y, x_radius, y_radius, begang, endang );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        7                   v_ellpie
contrl[6]        handle
intin[0]         begang              Startwinkel
intin[1]         endang              Endwinkel
ptsin[0]         x
ptsin[1]         y
ptsin[2]         x_radius            Radius in horizontaler Richtung
ptsin[3]         y_radius            Radius in vertikaler Richtung

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù FILLED ROUNDED RECTANGLE (VDI 11, GDP 9)

Diese Funktion zeichnet ein ausgeflltes, abgerundetes Reckteck.

Dekl.:  void v_rfbox( WORD handle, WORD *rect );
Aufruf: v_rfbox( handle, rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        9                   v_rfbox
contrl[6]        handle
ptsin[0..3]      rect[0..3]          Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù SET FILL INTERIOR INDEX (VDI 23)

Der  Flltyp  kann  mit  dieser Funktion ausgew„hlt werden. Bei šbergabe eines
ungltigem Flltyps wird der Typ 0 (leer) eingestellt.

Dekl.:  WORD vsf_interior( WORD handle, WORD interior );
Aufruf: set_interior = vsf_interior( handle, interior );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        23                  vsf_interior
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         interior             gewnschter Flltyp

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_interior        ausgew„hlter Flltyp

Bedeutung von interior:
0: leer
1: voll
2: gemustert
3: schraffiert
4: benutzerdefiniert


ù SET FILL STYLE INDEX (VDI 24)

Mit dieser Funktion wird der zum Flltyp geh”rende Fllindex gesetzt.

Dekl.:  WORD vsf_style( WORD handle, WORD style_index );
Aufruf: set_style = vsf_style( handle, style_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        24                  vsf_style
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         style_index         gewnschter Fllindex

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_sytle           ausgew„hlter Fllindex


ù SET FILL COLOR INDEX (VDI 25)

Der Farbindex fr Fllmuster wird mit dieser Funktion ausgew„hlt. Bei einem
ungltigen Index wird Farbindex 1 eingestellt. Der Farbindex hat keine
Auswirkung auf mehrfarbige Muster (siehe auf vsf_udpat); er sollte hier auf 1
gesetzt werden.

Dekl.:  WORD vsf_color( WORD handle, WORD color_index );
Aufruf: set_color = vsf_color( handle, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        25                  vsf_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         gewnschter Farbindex

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_color           ausgew„hlter Farbindex


ù INQUIRE CURRENT FILL AREA ATTRIBUTES (VDI 37)

Diese Funktion gibt Auskunft ber die aktuellen Fllattribute.

Dekl.:  void vqf_attributes( WORD handle, WORD *attrib );
Aufruf: vqf_attributes( handle, attrib );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        37                  vqm_attributes
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        5                   Eintr„ge in intout
intout[0]        attrib[0]           Flltyp
intout[1]        attrib[1]           Fllfarbe
intout[2]        attrib[2]           Fllmusterindex
intout[3]        attrib[3]           Schreibmodus
intout[4]        attrib[4]           Umrahmungs-Flag


ù CONTOUR FILL (VDI 103)

Diese Funktion fllt vom Startpunkt aus eine Fl„che, wobei diese Fl„che durch
den Bildrand oder eine andere Farbe begrenzt wird. Ger„tetreiber, die mit einer
Display-List arbeiten (Druckertreiber, IMG-Treiber,...) untersttzen
v_contourfill() nicht oder k”nnen sie nur dann ausfhren, wenn gengend Speicher
vorhanden ist.

Dekl.:  void v_contourfill( WORD handle, WORD x, WORD y, WORD color_index );
Aufruf: v_contourfill( handle, x, y, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        103                 v_contourfill
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         Farbindex
ptsin[0]         x
ptsin[1]         y

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù SET FILL PERIMETER VISIBILITY (VDI 104)

Die  Umrahmung einer gefllten Fl„che (Rechteck, Polygon, Ellipse, ...) kann mit
dieser Funktion ein- oder ausgeschaltet werden.

Dekl.:  WORD vsf_perimeter( WORD handle, WORD flag );
Aufruf: set_perimeter = vsf_perimter( handle, flag );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        104                 vsf_perimeter
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         flag                gewnschtes Umrahmungs-Flag

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_perimeter       ausgew„hltes Umrahmungs-Flag

Bedeutung von flag:
0: keine Umrahmung
1: Umrahmung

ù SET USER-DEFINED FILL PATTERN (VDI 112)

Mit  "SET USER-DEFINED FILL PATTERN" kann ein  benutzerdefiniertes  Fllmuster
von 16*16 Pixel (16 Worte pro Musterebene) festgelegt werden. Mehrfarbige Muster
werden im Standardformat bergeben und mssen die gleiche Ebenenanzahl haben wie
der Bildschirm. Die Ausnahme von dieser Regel sind die Direct-RGB-Modi (mehr als
8 Ebenen mit direkter RGB-Zuordnung) wie True-Color. Hier wird das Muster immer
als True-Color-Muster mit 32-Bit-Pixeln (xRGB) bergeben.

Dekl.:  void vsf_udpat( WORD handle, WORD *pattern, WORD planes );
Aufruf: vsf_udpat( handle, pattern, planes );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        112                 vsf_udpat
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        16n                 Eintr„ge in intin (Musterebenen*16)
contrl[6]        handle
intin[0..16n-1]  pattern[0..16n-1]   Musterebenen

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bemerkung:
Bei Mehrfarbmustern sollte man die Fllfarbe auf 1 setzen und als Schreibmodus
REPLACE anw„hlen.


ù FILLED RECTANGLE (VDI 114)

"FILLED RECTANGLE" zeichnet ein ausgeflltes Rechteck ohne Umrahmung.

Dekl.:  void vr_recfl( WORD handle, WORD *rect );
Aufruf: vr_recfl( handle, rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        114                 vr_recfl
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0..3]      rect[0..3]          Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout




Marker
======

ù POLYMARKER (VDI 7)

Diese Funktion zeichnet Marker an den angegebenen Stellen.

Dekl.:  void v_pmarker( WORD handle, WORD count, WORD *xyarr );
Aufruf: v_pmarker( handle, count, xyarr );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        7                   v_pmarker
contrl[1]        n                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù SET POLYMARKER TYPE (VDI 18)

Mit  dieser  Funktion  wird der gewnschte Marker  ausgew„hlt.  Im  Fall  einer
fehlerhaften Markernummer wird Markertyp 3 benutzt.

Dekl.:  WORD vsm_type( WORD handle, WORD type );
Aufruf: set_type = vsm_type( handle, type );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        18                  vsm_type
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         type                gewnschter Markertyp

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_type            ausgew„hlter Markertyp

Bedeutung von type:
1: Punkt
2: Plus
3: Sternchen
4: Quadrat
5: Kreuz
6: Raute


ù SET POLYMARKER HEIGHT (VDI 19)

Die Markergr”e kann mittels "SET POLYMARKER HEIGHT" eingestellt werden. Falls
die eingestellte H”he nicht existiert, wird die n„chstkleinere H”he eingestellt.
Der Markertyp 1 (Punkt) hat immer die H”he 1.

Dekl.:  WORD vsm_height( WORD handle, WORD height );
Aufruf: set_height = vsm_height( handle, height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        19                  vsm_height
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[1]         height              gewnschte Markerh”he

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0]        set_width           ausgew„hlte Markerbreite
ptsout[1]        set_height          ausgew„hlte Markerh”he


ù SET POLYMARKER COLOR INDEX (VDI 20)

Diese Funktion setzt den Farbindex der Marker. Bei ungltigem Index wird der
Farbindex 1 gesetzt.

Dekl.:  WORD vsm_color( WORD handle, WORD color_index );
Aufruf: set_color = vsm_color( handle, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        20                  vsm_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         gewnschte Markerfarbe

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_color           ausgew„hlte Markerfarbe


ù INQUIRE CURRENT POLYMARKER ATTRIBUTES (VDI 36)

"INQUIRE CURRENT POLYMARKER ATTRIBUTES" gibt Auskunft ber die eingestellten
Markerattribute.

Dekl.:  void vqm_attributes( WORD handle, WORD *attrib );
Aufruf: vqm_attributes( handle, attrib );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        36                  vqm_attributes
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        3                   Eintr„ge in intout
intout[0]        attrib[0]           Markertyp
intout[1]        attrib[1]           Markerfarbe
intout[2]        attrib[2]           Schreibmodus
ptsout[0]        attrib[4]           Markerbreite
ptsout[1]        attrib[3]           Markerh”he




Textausgaben mit Bitmap- und Vektorfonts
========================================

Zun„chst ein paar generelle Erkl„rungen und Anmerkungen zum Thema Text...

Font-ID und Index:

Der Index eines Fonts ist eine Zahl zwischen 1 und der verfgbaren Fontanzahl.
Je nach Anzahl der auf dem jeweiligen Rechner installierten Fonts hat ein Font
wie z.B. "Swiss 721" einen unterschiedlichen Index.
Die Font-ID ist dagegen eine Kennung, die grunds„tzlich fr einen Font
unabh„ngig vom System immer gleich ist - fr "Swiss 721" z.B. 5003. Ausnahmen
von dieser Regel sind aber bei Fonts m”glich, die keine verwendbare Font-ID
haben. In diesem Fall wird versucht, eine eindeutige ID zu erzeugen. Da es aber
m”glich ist, da eine derart erzeugte ID fr einen Font nicht auf allen Systemen
identisch ist, sollten Programme fr eine eindeutige Zuordnung des Fonts auer
der ID auch den Namen abspeichern.

Vektorfont oder Bitmap-Font?

Wenn es sich bei einem eingstellten Font um einen Vektorfont handelt, liefert
vqt_name() 34 Eintr„ge in intout zurck und intout[33] enth„lt einen Wert
ungleich 0. Ist intout[33] 0 oder werden nur 33 Eintr„ge zurckgeliefert,
handelt es sich um einen Bitmap-Font.

quidistante Fonts (monospaced):

Fr manche Applikationen ist es zweckm„ig, bei der Ausgabe nur „quidistante
Fonts zu benutzen. Das sinnvollste Vorgehen dafr sieht wie folgt aus:

a) Wenn vqt_name() in erweiterter Form (35 Eintr„ge in intout) vorhanden ist,
   sollte einfach das entsprechende Bit in intout[34] abgetestet werden.
b) Wenn vqt_name() nur die Information bietet, da es sich um einen Vektorfont
   handelt (34 Eintr„ge in intout, intout[33] != 0), sollte fr Vektorfonts
   vqt_fontheader() aufgerufen und Bit 1 von FH_CLFGS geprft werden.
c) Wenn es sich nicht um einen Vektorfont handelt und a) und b) nicht zutreffen,
   mssen die Zeichenbreiten einzeln mit vqt_width() erfragt und miteinander
   verglichen werden.

Wer „quidistante Vektorfonts mit v_ftext() ausgibt, darf als Breite nicht mit
den Ausgaben von vst_height() oder vqt_width() rechnen, sondern mu sie bei
vqt_advance32() erfragen, da bei v_ftext() immer mit Breiten in 1/65536 Pixeln
positioniert wird. Bei Ausgabe ber v_gtext() sind die Rckgaben von vqt_width()
zutreffend.

H”he und Breite von Vektorfonts:

Die H”he und Breite eines Vektorfonts kann mit den Funktionen vst_arbpt32() und
und vst_setsize32() in 1/65536 pt eingestellt werden (1 pt ÷ 1/72" ÷ 353æm). 
Bei negativer H”he oder Breite wird der Text an der jeweiligen Achse gespiegelt.

Pair- und Track-Kerning:

Sowohl Pair- als auch Track-Kerning sind nach dem ™ffnen einer Workstation
ausgestellt. Um eine bessere Textdarstellung zu haben, sollte das Pair-Kerning
daher mit vst_kern() eingeschaltet werden.

Positionierung von Vektortext:

Bei der Ausgabe von Vektorfonts wird innerhalb des VDIs mit Schrittweiten von
1/65536 Pixel Aufl”sung gerechnet, um unabh„ngig vom verwendeten Ausgabeger„t
und dessen tats„chlicher Aufl”sung eine gleichbleibende Zeichenpositionierung zu
gew„hrleisten. Um die Bitmaps fr die einzelnen Zeichen auszugeben, werden diese
Festkommawerte in Pixel umgerechnet, indem 32768 hinzuaddiert und anschlieend
durch 65536 geteilt wird.

Wenn das Track-Kerning eingeschaltet ist, wird zu jeder Zeichenposition der bei
vqt_trackkern() zu erfragende Offset addiert.

Bei eingeschaltetem Pair-Kerning wird zu jeder Zeichenposition der von
vqt_pairkern() zurckgelieferte Offset addiert.

Pair- und Track-Kerning und die Positionierung in 1/65536 Pixeln werden nur
eingesetzt, wenn v_ftext() aufgerufen wird! Bei v_gtext() verhalten sich
Vektorfonts weitgehend wie Bitmap-Fonts und weder Kerning noch genaue
Positionierung werden benutzt.

Gr”e von Vektorfonts/Pixelgr”en:

Die meisten Bildschirmtreiber liefern eine Aufl”sung von ÷ 91 dpi zurck, nach
der sich auch die Gr”e der Vektorfonts richtet. Da nicht bei jedem Schirm 91
dpi vorhanden sind, sollten Programme bei Textdarstellung auf dem Bildschirm
nicht fest mit diesem Wert rechnen, sondern die Ausgaben von v_opnwk(),
v_opnvwk(), vq_extnd() und v_opnbm() beachten. Andernfalls k”nnen bei
abweichenden Pixelgr”en Darstellungsfehler auftreten.
Beim Ausdruck sollten die genaueren Pixelgr”en bei vq_extnd() beachtet werden,
damit die Textpositionierung m”glichst genau ist.

Hinzufgen und Entfernen von Fonts w„hrend der Laufzeit:

Mit Fontname k”nnen w„hrend der Laufzeit Vektorfonts entfernt oder hinzugefgt 
werden. Damit Applikationen darauf reagieren k”nnen, schickt Fontname beim 
Verlassen die AES-Mitteilung FNT_CHANGED.

   #define  FNT_CHANGED 83

   mbuf[0] = FNT_CHANGED;
   mbuf[1] = app_id;          /* Applikationsnummer */
   mbuf[2] = 0;               /* Nachricht hat keine šberl„nge */
   mbuf[3] = fonts_removed;   /* Anzahl der entfernten Fonts */
   mbuf[4] = fonts_added;     /* Anzahl der hinzugefgten Fonts */
   mbuf[5] = 0;
   mbuf[6] = 0;
   mbuf[7] = 0;

Wenn Fonts entfernt wurden, mu die betreffende Applikation vst_unload_fonts() 
und darauf vst_load_fonts() aufrufen. Anschlieend sollte berprft werden, ob 
die Fonts in den gerade ge”ffneten Dokumenten noch vorhanden sind.

Wurden Fonts hinzugefgt, sollten ebenfalls vst_unload_fonts() und vst_load_fonts() 
aufgerufen werden, um z.B. die Anzeige in einer Fontauswahl zu aktualisieren.

Fontauswahl:

Anstatt wertvolle Zeit fr die Entwicklung eines eigenen Fontselektors zu 
verschwenden, sollte die von MagiC/WDIALOG bereitgestellte Variante genutzt werden.
Siehe hierzu auch DOC_WDLG.TXT und die dazugeh”rigen Beispielsourcen.


ù TEXT (VDI 8)

"TEXT" gibt eine Zeichenkette mit Attributen aus. Ist ein Vektorfont
eingestellt, so wird weder Pair- noch Track-Kerning beachtet. Die
Zeichenpositionierung erfolgt auerdem pixelweise, d.h. vqt_width() liefert
hierfr die passenden Schrittgr”en.

Dekl.:  void v_gtext( WORD handle, WORD x, WORD y, BYTE *string );
Aufruf: v_gtext( handle, x, y, string );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        8                   v_gtext
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette
ptsin[0]         x
ptsin[1]         y

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù JUSTIFIED GRAPHICS TEXT (VDI 11, GDP 10)

"JUSTIFIED GRAPHICS TEXT" erm”glicht die  Ausgabe einer Zeichenkette mit
Attributen und Dehnung oder Stauchung auf die gewnschte L„nge, wobei entweder
Wort- oder Zeichenzwischenr„ume gedehnt werden k”nnen. Bei Vektorfonts bezieht
sich die L„ngenangabe auf die Summation der Zeichenbreiten - šberh„nge nach
links und rechts werden nicht bercksichtigt.

Dekl.:  void v_justified( WORD handle,int x, WORD y, BYTE *string, WORD length,
                          WORD word_space, WORD char_space );
Aufruf: v_justified( handle, x, y, string, length, word_space, char_space );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        11                  GDP
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        n+2                 Eintr„ge in intin
contrl[5]        10                  v_justified
contrl[6]        handle
intin[0]         word_space          <> 0: Wortzwischenr„ume dehnen
intin[1]         char_space          <> 0: Zeichenzwischenr„ume dehnen
intin[2..n+1]    string[0..n-1]      Zeichenkette
ptsin[0]         x
ptsin[1]         y
ptsin[2]         length              horizontale Textl„nge in Pixeln

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù SET CHARACTER HEIGHT, ABSOLUTE MODE (VDI 12)

Die Zeichenh”he von der Basislinie bis zur Zeichenzellenobergrenze wird mit
dieser Funktion gesetzt. Bei Bitmapfonts wird, wenn die gewnschte H”he nicht
als Bitmap vorliegt, vergr”ert oder verkleinert. Bei Vektorfonts stellen die
ausgegebenen Breiten char_width und cell_width gerundete Werte dar.

Dekl.:  void vst_height( WORD handle, WORD height, WORD *char_width,
                         WORD *char_height, WORD *cell_width, WORD *cell_height );
Aufruf: vst_height( handle, height, &char_width, &char_height, &cell_width,
                    &cell_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        12                  vst_height
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[1]         height              gewnschte Zeichenh”he

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0]        char_width          ausgew„hlte Zeichenbreite
ptsout[1]        char_height         ausgew„hlte Zeichenh”he
ptsout[2]        cell_width          ausgew„hlte Zeichenzellenbreite
ptsout[3]        cell_height         ausgew„hlte Zeichenzellenh”he


ù SET CHARACTER BASELINE VECTOR (VDI 13)

Mit  dieser  Funktion kann man die Textdrehung in 1/10  Grad  einstellen.  Fr
Bitmapfonts ist die Rotation nur in 90-Grad-Schritten m”glich; bei Vektorfonts
stufenlos.

Dekl.:  WORD vst_rotation( WORD handle, WORD angle );
Aufruf: set_angle = vst_rotation( handle, angle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        13                  vst_rotation
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         angle               gewnschter Rotationswinkel

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_angle           ausgew„hlter Rotationswinkel


ù SET TEXT FACE (VDI 21)

Diese Funktion w„hlt den Zeichensatz <font> aus. Sollte kein Zeichensatz mit
dieser ID vorhanden sein, wird auf den Systemzeichensatz umgeschaltet.

Dekl.:  WORD vst_font( WORD handle, WORD font );
Aufruf: set_font = vst_font( handle, font);

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        21                  vst_font
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         font                gewnschter Zeichensatz

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_font            ausgew„hlter Zeichensatz


ù SET GRAPHIC TEXT COLOR INDEX (VDI 22)

Diese  Funktion  setzt die Farbe des Textes. Bei ungltigem Farbindex wird der
Farbindex 1 gesetzt.

Dekl.:  WORD vst_color( WORD handle, WORD color_index );
Aufruf: set_color = vst_color( handle, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        22                  vst_color
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         color_index         gewnschte Textfarbe

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_color           ausgew„hlte Textfarbe


ù INQUIRE CURRENT GRAPHIC TEXT ATTRIBUTES (VDI 38)

Die gesetzten Textattribute werden von dieser Funktion geliefert.

Dekl.:  void vqt_attributes( WORD handle, WORD *attrib );
Aufruf: vqt_attributes( handle, attrib );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        38                  vqt_attributes
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        6                   Eintr„ge in intout
intout[0]        attrib[0]           Zeichensatznummer
intout[1]        attrib[1]           Textfarbe
intout[2]        attrib[2]           Textrotation in 1/10 Grad
intout[3]        attrib[3]           horizontale Ausrichtung
intout[4]        attrib[4]           vertikale Ausrichtung
intout[5]        attrib[5]           Schreibmodus
ptsout[0]        attrib[6]           Zeichenbreite
ptsout[1]        attrib[7]           Zeichenh”he
ptsout[2]        attrib[8]           Zeichenzellenbreite
ptsout[3]        attrib[9]           Zeichenzellenh”he

Bemerkung:
Das ATARI-VDI gibt fehlerhafterweise in intout[5] den Schreibmodus-1 zurck. Mit
NVDI geschieht das nur bei eingeschalteter Fehlerkompatibilit„t.


ù SET GRAPHIC TEXT ALIGNMENT (VDI 39)

Die horizontale und vertikale Ausrichtung eines Textes kann mit dieser Funktion
beeinflut werden. Bei falscher Eingabe fr horizontale Ausrichtung wird der
Text linksjustiert. Die  fehlerhafte Angabe der vertikalen Ausrichtung bewirkt
Ausrichtung an der Basislinie.

Dekl.:  void vst_alignment( WORD handle, WORD hor_in, WORD vert_in,
                            WORD *hor_out, WORD *vert_out );
Aufruf: vst_alignment( handle, hor_in, vert_in, &hor_out, &vert_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        39                  vst_alignment
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         hor_in              gewnschte horizontale Ausrichtung
intin[1]         vert_in             gewnschte vertikale Ausrichtung

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        hor_out             ausgew„hlte horizontale Ausrichtung
intout[1]        vert_out            ausgew„hlte vertikale Ausrichtung

Bedeutung von hor_in:
0: linksjustiert
1: zentriert
2: rechtsjustiert

Bedeutung von vert_in:
0: Basislinie
1: Halblinie
2: Zeichenoberkante
3: Zeichenzellenunterkante
4: Zeichenunterkante
5: Zeichenzellenoberkante


ù SET GRAPHIC TEXT SPECIAL EFFECTS (VDI 106)

Mit  "SET  GRAPHIC  TEXT SPECIAL EFFECTS" kann man,  wie  es  der  Name  schon
andeutet, spezielle Texteffekte einstellen.

Dekl.:  WORD vst_effects( WORD handle, WORD effect );
Aufruf: set_effect = vst_effects( handle, effect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        106                 vst_effects
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         effect              gewnschter Texteffekt

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_effect          ausgew„hlter Texteffekt

Bedeutung von effect (Bitnummer):
0: fett
1: hell
2: kursiv
3: unterstrichen
4: umrandet


ù SET CHARACTER HEIGHT, POINTS MODE (VDI 107)

Mit "SET CHARACTER HEIGHT, POINTS MODE" kann die Zeichenzellengr”e in Punkten
(1 pt  = 1/72") festgelegt werden.
Bei Bitmapfonts sucht diese Funktion den Font heraus, der in einfacher oder
doppelter Vergr”erung kleiner oder gleich der gewnschten H”he ist. Bei
Vektorfonts kann man mit vst_point() nur die vordefinierten H”hen anw„hlen (in
der Regel sind das 8, 9, 10, 11, 12, 14, 18, 24, 36, und 48 pt).

Dekl.:  WORD vst_point( WORD handle, WORD point,
                        WORD *char_width, WORD *char_height,
                        WORD *cell_width, WORD *cell_height );
Aufruf: set_point = vst_point( handle, point, &char_width, &char_height,
                               &cell_width, &cell_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        107                 vst_point
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         point               gewnschte Zeichenzellenh”he (1/72")

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_point           ausgew„hlte Zeichenzellenh”he (1/72")
ptsout[0]        char_width          ausgew„hlte Zeichenbreite
ptsout[1]        char_height         ausgew„hlte Zeichenh”he
ptsout[2]        cell_width          ausgew„hlte Zeichenzellenbreite
ptsout[3]        cell_height         ausgew„hlte Zeichenzellenh”he


ù INQUIRE TEXT EXTENT (VDI 116)

Bei Bitmapfonts ermittelt "INQUIRE  TEXT  EXTENT" die minimalen Ausmae eines
Rechtecks, das die bergebene Zeichenkette umrahmt. Bei Vektorfonts addiert
diese Funktion nur die Schrittweiten ohne Pair- oder Track-Kerning und
Zeichenberh„nge zu beachten.
Die Koordinaten der vier Eckpunkte werden relativ zu einem Koordinatensystem
ausgegeben, wobei die Punkte gegen den Uhrzeigersinn durchnummeriert sind. Der
erste Punkt liegt ohne Textdrehung in der linken unteren Ecke des Textrechtecks.

Dekl.:  void vqt_extent( WORD handle, BYTE *string, WORD *extent );
Aufruf: vqt_extent( handle, string, extent );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        116                 vqt_extent
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette

Ausgaben:

contrl[2]        4                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0..7]     extent[0..7]        Koordinaten des Textrechtecks


ù INQUIRE CHARACTER CELL WIDTH (VDI 117)

Bei Bitmapfonts lieferte diese Funktion die horizontalen Textausmae zurck.
Wendet man sie auf einen Vektorfont an, wird fr das Zeichen <index> die
gerundete Schrittweite zurckgegeben. Diese Schrittweite kann nur im
Zusammenhang mit v_gtext() benutzt werden. Versucht man die Schrittweiten auf
v_ftext() anzuwenden wird man falsche Zeichenpositionen berechnen.

Dekl.:  WORD vqt_width( WORD handle, WORD index,
                        WORD *cell_width, WORD *left_delta, WORD *right_delta );
Aufruf: status = vqt_width( handle, index,
                            &cell_width, &left_delta, &right_delta );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        117                 vqt_width
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         character           Zeichennummer

Ausgaben:

contrl[2]        3                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        status              Zeichennummer oder -1 (Fehler)
ptsout[0]        cell_width          Zeichenzellenbreite
ptsout[2]        left_delta          linker Abstand zur Zeichenzelle
ptsout[4]        right_delta         rechter Abstand zur Zeichenzelle

Bemerkung:
Um die Breite einer Zeichenkette zu ermitteln, ist der Aufruf von vqt_extent(),
vqt_f_extent() oder vqt_real_extent() zu  empfehlen.
Wer feststellen m”chte, ob ein Font „quidistant (monospaced) oder proportional
ist, sollte nicht alle Zeichenpaare ber vqt_width() vergleichen, sondern zuerst
prfen ob, vqt_name() hierber Informationen zurckgibt.


ù LOAD FONTS (VDI 119)

Diese Funktion l„dt die in ASSIGN.SYS fr das mit <handle> bezeichnete Ger„t
eingetragenen Bitmapfonts und sorgt dafr, da auch auf die Vektorfonts
zugegriffen werden kann. Zurckgegeben wird die Anzahl der zus„tzlich
verfgbaren Zeichens„tze.

Bevor man vst_load_fonts() aufruft, sollte man mit vq_gdos() berprfen, ob das
VDI Zeichens„tze nachladen kann.

Dekl.:  WORD vst_load_fonts( WORD handle, WORD select );
Aufruf: additional = vst_load_fonts( handle, 0 );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        119                 vst_load_fonts
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         select              0 (reserviert)

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        additional          Anzahl der geladenen Zeichens„tze


ù UNLOAD FONTS (VDI 120)

Der durch die Bitmapfonts belegte Speicher wird von "UNLOAD FONTS" freigegeben.

Dekl.:  void vst_unload_fonts( WORD handle, WORD select );
Aufruf: vst_unload_fonts( handle, 0);

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        120                 vst_unload_fonts
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         select              0 (reserviert)

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù INQUIRE FACE NAME AND INDEX (VDI 130)

In NVDI gibt es eine erweiterte Form von vqt_name():

Dekl.:  WORD vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format,
                       UWORD *flags );
Aufruf: id = vqt_ext_name( handle, index, name, &font_format, &flags );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        130                 vqt_name/vqt_ext_name
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        1                   mehr Informationen liefern!
contrl[6]        handle
intin[0]         index               Nummer (1 bis Maximalanzahl)
intin[1]         0                   reserviert

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        35                  Eintr„ge in intout
intout[0]        id                  Zeichensatznummer
intout[1..32]    name[0..31]         Zeichensatzname
intout[33]       name[32]            0: Bitmapfont, 1: Vektorfont
intout[34]       flags/font_format

Im High-Byte von intout[34] wird <flags> zurckgeliefert:

Bit 0:   quidistanz
         0: Font ist proportional
         1: Font ist „quidistant (monospaced)

Bit 4:   Symbolfont
         0: Font ist kein Symbolfont
         1: Font ist ein Symbolfont

Im Low-Byte von intout[34] wird <font_format> zurckgeliefert:
Bit 0:   Bitmap-Font
Bit 1:   Speedo-Font 
Bit 2:   TrueType-Font
Bit 3:   Type1-Font

Bemerkungen:
Um festzustellen, was fr einen Font man vor sich hat, mu man die Anzahl der
Eintr„ge in intout (contrl[4]) beachten. Ist contrl[4] 33, so sind keine
zus„tzlichen Informationen vorhanden und demzufolge mu es sich um einen
Bitmapfont handeln. Ist contrl[4] == 34, wird nur zus„tzlich in intout[33]
(name[32]) mitgeteilt, ob es sich um einen Vektorfont handelt. Nur wenn
contrl[4] == 35 ist, kann man mit intout[34] (flags) den Fonttyp genauer
feststellen und sofort erkennen, ob der Font „quidistant (monospaced) ist.

intout[34] wird nur zurckgeliefert, wenn contrl[3] > 1 und contrl[5] = 1!

Hinweis:
Ein Font wird als Symbolfont eingestuft (Bit 4 von <flags>), wenn er im Bereich 
'A'-'Z' und 'a'-'z' nicht vollst„ndig ist, oder wenn er laut der PANOSE- 
Klassifizierung "pictorial" ist. Das Flag ist daher nur als Anhaltpunkt zu 
betrachten (bei einem kyrillischen TrueType-Font w„re es z.B. auch gesetzt) und 
signalisiert, da die Zeichenbelegung im ASCII-Mapping (Modus 1 bei vst_charmap) 
nicht der normalen ATARI-Belegung entspricht.


ù INQUIRE CURRENT FACE INFORMATION (VDI 131)

Es wird Auskunft ber den aktuellen Zeichensatz gegeben, wobei die Attribute und
Vergr”erung/Verkleinerung bercksichtigt werden.

Dekl.:  void vqt_fontinfo( WORD handle, WORD *minADE, WORD *maxADE,
                           WORD *distances, WORD *maxwidth, WORD *effects );
Aufruf: vqt_fontinfo( handle, &minADE, &maxADE, distances, &max_width, effects );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        131                 vqt_fontinfo
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        5                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        minADE              niedrigste Zeichennummer
intout[1]        maxADE              h”chste Zeichennummer
ptsout[0]        maxwidth            Maximale Zeichenzellenbreite
ptsout[1]        distances[0]
ptsout[2]        effects[0]
ptsout[3]        distances[1]
ptsout[4]        effects[1]
ptsout[5]        distances[2]
ptsout[6]        effects[2]
ptsout[7]        distances[3]
ptsout[9]        distances[4]

Bedeutung von distances:
distances[0]: Abstand von der Untergrenze der Zeichenzelle zur Basislinie
distances[1]: Abstand der Unterl„nge zur Basislinie
distances[2]: Abstand der Halblinie zur Basislinie
distances[3]: Abstand der Zeichenobergrenze zur Basislinie
distances[4]: Abstand der Zeichenzellenobergrenze zur Basislinie

Bedeutung von effects:
effects[0]: Verbreiterung bei Texteffekten
effects[1]: linker Abstand bei Kursivschrift
effects[2]: rechter Abstand bei Kursivschrift


ù INQUIRE CHARACTER INDEX (VDI 190, 0)

vqt_char_index() konvertiert den bergebenen Index <src_index> entsprechend des 
Mappings <dst_mode> in einen direkten, einen ASCII- oder einen Unicode-Index. 
<src_mode> ist das Mapping von <src_index>.

Wenn eine Konvertierung nicht m”glich ist, wird in <dst_index> 0xffff 
zurckgeliefert. Um z.B. zu berprfen, ob der eingestellte Font ein Zeichen mit 
Unicode 0x201e ("quotedblbase", DOUBLE LOW-9 QUOTATION MARK, 99er Anfhrungs- 
zeichen unten) enth„lt, sollte die folgende Funktion aufgerufen werden:

WORD  is_char_available( WORD handle, UWORD unicode )
{
   UWORD direct_index;
   
   /* Unicode <unicode> in direkten Index wandeln */
   direct_index = vqt_char_index( handle, unicode, 2, 0 );
   
   if ( direct_index == 0xffff )
      return( 0 );                     /* Zeichen ist nicht verfgbar */
   else
      return( 1 );                     /* Zeichen ist verfgbar */
}


Dekl.:  UWORD vqt_char_index( WORD handle, UWORD src_index, WORD src_mode, 
                             WORD dst_mode );
Aufruf: dst_index = vqt_char_index( handle, src_index, src_mode, dst_mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        190                 vqt_char_index
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[5]        0                   Unterfunktionsnummer (mu gesetzt werden!)
contrl[6]        handle

intin[0]         src_index
intin[1]         src_mode            Mapping von <src_index>
intin[2]         dst_mode            Mapping von <dst_index>

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout

intout[0]        dst_index

Bedeutung von <src_mode>:
0: <src_index> ist ein direkter Index
1: <src_index> ist ein ASCII-Index 
2: <src_index> ist ein Unicode-Index

Bedeutung von <dst_mode>:
0: <dst_index> soll ein direkter Index sein
1: <dst_index> soll ein ASCII-Index sein
2: <dst_index> soll ein Unicode-Index sein

Bemerkung:
Soll ein Index vom ASCII-Format ausgehend oder ins ASCII-Format gewandelt 
werden, dann wird nur der Bereich von Index 32 bis 255 beachtet. Die 
Steuerzeichen 0 bis 31 werden nicht gewandelt, d.h. der Aufruf von
vqt_char_index( handle, 10, 1, 0 ) liefert 0xffff als Ergebnis.


ù INQUIRE EXTENDED FONT INFORMATION (VDI 229)

Die Funktion vqt_xfntinfo() liefert in einer XFNT_INFO-Struktur die mit <flags>
angeforderten Informationen ber einen Font. Wenn ein von 0 verschiedener Index
bergeben wird, sucht vqt_xfntinfo() den entsprechenden Font und liefert die durch
<flags> bezeichneten Eintr„ge. Wenn <index> 0 ist, wird der Font mit der ID <id>
gesucht. Sollte <id> ebenfalls 0 sein, werden Informationen ber den bereits
eingestellten Font zurckgegeben.

Damit die Informationen in die XFNT_INFO-Struktur eingetragen werden, mu die
Gr”e der Struktur mu in das Strukturelement <size> eingetragen werden.

Dekl.:  WORD vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index,
                           XFNT_INFO *info );
Aufruf: id = vqt_xfntinfo( handle, flags, id, index, &info );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        229                 vqt_xfntinfo
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        5                   Eintr„ge in intin
contrl[5]        0
contrl[6]        handle
intin[0]         flag                Bitvektor fr auszugebende Informationen
intin[1]         id                  ID des Fonts oder 0 fr eingestellten Font
intin[2]         index               Index des Fonts oder 0, wenn die ID benutzt
                                     werden soll
intin[3..4]      info                Zeiger auf die XFNT_INFO-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        3                   Eintr„ge in intout
intout[0]        font_format         Fontformat
intout[1]        font_id             ID des eingestellten Fonts
intout[2]        index               Index des eingestellten Fonts

Bedeutung von flags (Bitnummer):
0:    vollst„ndigen Fontnamen zurckgeben (font_name)
1:    Name der Fontfamilie zurckgeben (family_name)
2:    Stil des Fonts zurckgeben (style_name)
3:    Dateinamen des Fonts zurckgeben (file_name1)
4:    2. optionalen Dateinamen zurckgeben (file_name2)
5:    3. optionalen Dateinamen zurckgeben (file_name3)
8:    H”hen in pt ohne Vergr”erung zurckliefern (pt_cnt, pt_sizes)
9:    H”hen in pt fr doppelte Vergr”erung zurckliefern (pt_cnt, pt_sizes)

Bedeutung von font_format:
1: Bitmap-Font
2: Speedo-Font
4: TrueType-Font
8: Type 1-Font

Bit 8 und 9 von flags unterscheiden sich in der Funktion nur bei Bitmap-Fonts.
Ist Bit 8 gesetzt, werden die H”hen geliefert, die ohne Vergr”erung vorhanden
sind. Wenn Bit 9 gesetzt ist, werden die H”hen geliefert, bei denen vergr”ert
wird.

Beschreibung der XFNT_INFO-Struktur:

typedef struct
{
   LONG  size;             /* L„nge der Struktur, mu vor vqt_xfntinfo() gesetzt werden */
   WORD  format;           /* Fontformat, z.B. 4 fr TrueType */
   WORD  id;               /* Font-ID, z.B. 6059 */
   WORD  index;            /* Index */
   BYTE  font_name[50];    /* vollst„ndiger Fontname, z.B. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* Name der Fontfamilie, z.B. "Century725 BT" */
   BYTE  style_name[50];   /* Name des Fontstils, z.B. "Italic" */
   BYTE  file_name1[200];  /* Name der 1. Fontdatei, z.B. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* Name der optionalen 2. Fontdatei */
   BYTE  file_name3[200];  /* Name der optionalen 3. Fontdatei */
   WORD  pt_cnt;           /* Anzahl der Punkth”hen fr vst_point(), z.B. 10 */
   WORD  pt_sizes[64];     /* verfgbare Punkth”hen,
                              z.B. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;

Bei allen Zeichenketten in der XFNT_INFO-Struktur handelt es sich um C-Strings,
die mit einem 0-Byte abgeschlossen sind. Strukturelemente, die nicht mit <flags>
angefordert wurden, haben keinen definierten Inhalt.


ù SET TEXT FACE BY NAME (VDI 230, 0)

Diese Funktion sucht einen Font mit Namen <font_name> in einem der durch den
Bitvektor <font_format> angegebenen Fontformate und stellt ihn ein. Fehlende
oder berschssige Leerzeichen werden bei der Suche ignoriert. Wenn in den
angegebenen Fontformaten kein Font des gesuchten Namens vorhanden ist, wird der
Systemfont gesetzt.

Dekl.:  WORD vst_name( WORD handle, WORD font_format,
                       BYTE *font_name, BYTE *ret_name );
Aufruf: id = vst_name( handle, font_format, font_name, ret_name );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        230                 vst_name
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n + 1               Eintr„ge in intin
contrl[5]        0                   Unterfunktionsnummer: Font einstellen
contrl[6]        handle
intin[0]         font_format         zu bercksichtigende Fontformate
intin[1..n]      font_name[0..n-1]   einzustellender Fontname

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        m + 1               Eintr„ge in intout
intout[0]        id                  ID des eingestellten Fonts
intout[1..m]     ret_name[0..m-1]    Name des eingestellten Fonts

Bedeutung von font_format:
1: Bitmap-Font
2: Speedo-Font
4: TrueType-Font
8: Type 1-Font


ù INQUIRE FACE NAME AND ID BY NAME (VDI 230, 100)

Diese Funktion sucht einen Font mit Namen <font_name> in einem der durch den
Bitvektor <font_format> angegebenen Fontformate, wobei fehlende oder
berschssige Leerzeichen ignoriert werden. Wenn der Font gefunden wird, werden
Font-ID und Name in intout zurckgeliefert.
Falls kein Font auffindbar ist, wird eine 0 in intout[0] zurckgeliefert, um
einen Fehler zu signalisieren.

Dekl.:  WORD vqt_name_and_id( WORD handle, WORD font_format,
                              BYTE *font_name, BYTE *ret_name );
Aufruf: id = vqt_name_and_id( handle, font_format, font_name, ret_name );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        230                 vst_name
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[5]        100                 Unterfunktionsnummer: Font suchen
contrl[6]        handle
intin[0]         font_format         zu bercksichtigende Fontformate
intin[1..n]      font_name[0..n-1]   einzustellender Fontname

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        m                   Eintr„ge in intout
intout[0]        id                  ID des gefundenen Fonts oder 0
intout[1..m]     ret_name[0..m-1]    Name des gefundenen Fonts

Bedeutung von font_format:
1: Bitmap-Font
2: Speedo-Font
4: TrueType-Font
8: Type 1-Font


ù SET CHARACTER WIDTH, ABSOLUTE MODE (VDI 231)

Mit dieser Funktion kann man die Zeichenbreite in Pixeln setzen. Sobald der der
n„chste Aufruf von vst_height(), vst_point() oder vst_arbpt32() erfolgt, wird 
die Breite wieder zurckgesetzt.

Dekl.:  void vst_width( WORD handle, WORD width, WORD *char_width,
                        WORD *char_height, WORD *cell_width, WORD *cell_height );
Aufruf: vst_width( handle, width, &char_width, &char_height,
                   &cell_width, &cell_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        231                 vst_width
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0]         width               gewnschte Zeichenbreite

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0]        char_width          ausgew„hlte Zeichenbreite
ptsout[1]        char_height         ausgew„hlte Zeichenh”he
ptsout[2]        cell_width          ausgew„hlte Zeichenzellenbreite
ptsout[3]        cell_height         ausgew„hlte Zeichenzellenh”he

Bemerkungen:
Zum Einstellen des Breiten-H”hen-Verh„ltnisses ist es sinnvoller, vst_setsize32()
aufzurufen, da diese Funktion feinere Einstellungen erlaubt.


ù INQUIRE SPEEDO HEADER INFORMATION (VDI 232)

Die Funktion vqt_fontheader() kopiert den Header des eingestellten Speedo-Fonts
in einen Buffer und liefert, wenn vorhanden, einen Zeiger auf die dazugeh”rige
TDF-Datei. Der bergebene Buffer sollte sicherheitshalber 1 Kb gro sein, da die
L„nge des Speedo-Fontheader vom jeweiligen Font und m”glichen
Formaterweiterungen abh„ngt.
Fr andere Fontformate (TrueType, ...) wird versucht, den Header nachzubilden.

Man sollte daran denken, da fr jeden Aufruf von vqt_fontheader() eventuell
mehrfach auf die Festplatte zugegriffen werden mu - bei 300 oder mehr Fonts
kann das immerhin einige wenige Sekndchen dauern. Man sollte daher den h„ufigen
Aufruf dieser Funktion vermeiden oder wichtige Angaben selbst speichern und beim
Programmstart laden.


Dekl.:  void vqt_fontheader( WORD handle, void *buffer, BYTE *tdf_name );
Aufruf: vqt_fontheader( handle, buffer, tdf_name );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        232                 vqt_fontheader
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0..1]      buffer              Buffer fr den Fontheader

Ausgaben:
contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        n                   L„nge des TDF-Pfads
intout[0..n-1]   tdf_name[0..n-1]    absoluter Pfad und Name des TDFs

Bemerkung:

Fr Programmierer drften die folgenden Eintr„ge des Fontheaders am
interessantesten sein:

Name      Offset  L„nge   Beschreibung
FH_FNTNM    24     70     Name des Fonts (siehe auch vqt_name()),
                          z.B. "Century 725 Italic BT"
FH_NKTKS   258      2     Anzahl der Track-Kerning-Informationen
FH_NKPRS   260      2     Anzahl der Kerning-Paare, (siehe auch vst_kern())
FH_CLFGS   263      1     Klassifizierung, u.a. Italic und Monospace
FH_SFNTN   266     32     Name des korrespondierenden Postscript-Fonts,
                          z.B. "Century725BT-Italic"
FH_SFACN   298     16     Kurzname der Fontfamilie, z.B. "Century725 BT"
FH_FNTFM   314     14     Stil/Form, z.B. "Italic"
FH_ITANG   328      2     Schr„gstellung in 1/256-Grad (bei italic-Schnitten),
                          z.B 4480 (17,5 Grad)
FH_ORUPM   330      2     Aufl”sung des Fontrasters (ORUs), z.B. 2048


ù INQUIRE TRACK KERNING INFORMATION (VDI 234)

Diese Funktion liefert getrennt in x- und y- Richtung die pro Zeichen durch
Track-Kerning entstehende Verschiebung zurck.

Dekl.:  void vqt_trackkern( WORD handle, fix31 *x_offset, fix31 *y_offset );
Aufruf: vqt_trackkern( handle, &x_offset, &y_offset );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        234                 vqt_trackkern
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:
contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        4                   Eintr„ge in intout
intout[0..1]     x_offset            x-Verschiebung in 1/65536 Pixeln
intout[2..3]     y_offset            y-Verschiebung in 1/65536 Pixeln


ù INQUIRE PAIR KERNING INFORMATION (VDI 235)

Die Funktion vqt_pairkern() liefert die zwischen zwei Zeichen durch Pair-Kerning
entstehende Verschiebung zurck.

Dekl.:  void vqt_pairkern( WORD handle, WORD index1, WORD index2,
                           fix31 *x_offset, fix31 *y_offset );
Aufruf: vqt_pairkern( handle, index1, index2, &x_offset, &y_offset );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        235                 vqt_pairkern
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         index1              erstes Zeichen
intin[1]         index2              darauf folgendes Zeichen

Ausgaben:
contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        4                   Eintr„ge in intout
intout[0..1]     x_offset            x-Verschiebung in 1/65536 Pixeln
intout[2..3]     y_offset            y-Verschiebung in 1/65536 Pixeln

Bemerkung:
Wer aus Pure C vqt_pairkern() aufrufen m”chte, mu in der Regel ein eigenes 
Binding schreiben, da die Funktion aus der PCGEMLIB statt intout[0-3] auf ptsout 
zugreift und somit Zufallswerte zurckliefert.


ù SET CHARACTER MAPPING MODE (VDI 236)

Mit dieser Funktion kann man vom ASCII-Mapping auf direktes Mapping umschalten,
d.h. man erh„lt z.B. fr eine 65 nicht mehr das Zeichen A, sondern je nach
verwendetem Font das Zeichen, das sich unter diesem Index verbirgt. Wenn man auf
direktes Mapping umschaltet, „ndert sich auerdem die Anzahl der vorhandenen
Zeichen pro Font (minADE und maxADE bei vqt_fontinfo) von 256 auf die Zahl der
tats„chlich vorhandenen Zeichen.

Dekl.:  void vst_charmap( WORD handle, WORD mode );
Aufruf: void vst_charmap( handle, mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        236                 vst_charmap
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         mode                Zeichen-Mapping

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von mode:
0: direktes Mapping, keine Umsetzung des Zeichen-Index
1: Zeichen-Index wird als ASCII-Wert interpretiert

Bemerkungen:
Seit NVDI 4 gibt es eine erweiterte Form des Aufrufs, bei der das Mapping 
zurckgeliefert wird und mit der man auch Unicode als Verfahren w„hlen kann.

Dekl.:  WORD vst_map_mode( WORD handle, WORD mode );
Aufruf: set_mode = vst_map_mode( handle, mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        236                 vst_map_mode
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         mode                Zeichen-Mapping
intin[1]         1                   Mapping zurckliefern

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_mode            eingestelltes Mapping

Bedeutung von mode:
0: direktes Mapping, keine Umsetzung des Zeichen-Index
1: Zeichen-Index wird als ASCII-Wert interpretiert
2: Unicode

Wenn man Unicode anw„hlt und feststellen m”chte, ob ein bestimmtes Zeichen im 
eingestellten Font existiert, kann man vqt_width() fr dieses Zeichen aufrufen. 
Sollte vqt_width() als Index -1 zurckliefern, existiert das Zeichen nicht. 
Alternativ zu vqt_width() kann man auch vqt_char_index() aufrufen und den 
fraglichen Unicode in einen direkten Index wandeln lassen.


ù SET KERNING MODE (VDI 237)

Mit dieser Funktion kann man das gewnschte Track-Kerning und Pair-Kerning ein-
oder ausschalten. Informationen fr Track-Kerning sind in den meisten
Speedo-Fonts enhalten. Normale TrueType-Fonts bieten kein Track-Kerning. Die
neuen TrueType-GX-Fonts enthalten dagegen oftmals Daten fr Track-Kerning.

Dekl.:  void vst_kern( WORD handle, WORD track_mode, WORD pair_mode,
                       WORD *tracks, WORD *pairs );
Aufruf: vst_kern( handle, track_mode, pair_mode, &track, &pairs );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        237                 vst_kern
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         track_mode          Track-Kerning-Modus
intin[1]         pair_mode           Pair-Kerning aus oder ein

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        track               das gesetzte Track-Kerning
intout[1]        pairs               Anzahl der Kerning-Paare

Bedeutung von track_mode:
0: kein Track-Kerning
1: normal
2: tight
3: very tight

Bedeutung von pair_mode:
0: kein Pair-Kerning
1: Pair-Kerning benutzen

Bemerkungen:
Mit NVDI kann man ein selbstdefiniertes Track-Kerning einstellen. Der
Track-Modus (track_mode) wird dafr auf 255 gesetzt, der gewnschte zus„tzliche
Abstand in 1/65536 Pixeln wird in intin[2..3] eingetragen und contrl[3] mu eine
4 enthalten.

Dekl.:  void vst_track_offset( WORD handle, fix31 offset, WORD pair_mode,
                               WORD *tracks, WORD *pairs );
Aufruf: vst_track_offset( handle, offset, pair_mode, &tracks, &pairs );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        237                 vst_kern
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        4                   Eintr„ge in intin
contrl[6]        handle
intin[0]         255                 benutzerdefiniert
intin[1]         pair_mode           Pair-Kerning aus oder ein
intin[2..3]      offset              Abstand

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        track               das gesetzte Track-Kerning
intout[1]        pairs               Anzahl der Kerning-Paare


ù GET CHARACTER BITMAP INFORMATION (VDI 239)

Diese Funktion liefert den Zeiger auf die zu einem Zeichen geh”rende Bitmap und
deren Mae zurck. Die zurckgelieferten Offsets sind auch im Zusammenhang mit
v_getoutline() gltig.

Dekl.:  void v_getbitmap_info( WORD handle, WORD index,
                               fix31 *x_advance, fix31 *y_advance,
                               fix31 *x_offset, fix31 *y_offset,
                               WORD *width, WORD *height,  WORD *bitmap );
Aufruf: v_getbitmap_info( handle, index, &x_advance, &y_advance,
                          &x_offset, &y_offset, &width, &height, bitmap );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        239                 v_getbitmap_info
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         index               Zeichen-Index

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        12                  Eintr„ge in intout
intout[0]        width               Breite der Bitmap
intout[1]        height              H”he der Bitmap
intout[2..3]     x_advance           x-Abstand in 1/65536 Pixeln
intout[4..5]     y_advance           y-Abstand in 1/65536 Pixeln
intout[6..7]     x_offset            x-Verschiebung in 1/65536 Pixeln
intout[8..9]     y_offset            y-Verschiebung in 1/65536 Pixeln
intout[10..11]   bitmap              Zeiger auf die Bitmap

Bedeutung von x_advance, y_advance:
Dieser Advance-Vektor gibt den Abstand des n„chsten Zeichens in 1/65536 Pixeln an.

Bedeutung von x_offset, y_offset:
x_offset und y_offset geben den Abstand der Bitmap zur Position der Zeichenzelle
an. Das ist n”tig, da die Bitmap meistens kleiner als die Zeichenzelle ist (z.B.
bei Zeichen ohne Unterl„ngen).

Bemerkungen:
Um auch ohne NVDI nachvollziehbare Ausgaben zu bekommen, sollten die
Texteffekte (vst_effects()) ausgeschaltet sein (einige Versionen eines
Zusatzprogrammes fr Vektorfonts zeigen sonst sehr unterschiedlich Ergebnisse).
Da der Zeiger auf die Bitmap in der Regel in den Zeichen-Cache verweist, sollte
man sich die Bitmap direkt nach dem Aufruf kopieren (AES-Kontextswitch durch
wind_update() verhindern!!) - andernfalls k”nnte der Zeiger schon wieder
ungltig sein.
Auerdem sollte man v_getbitmap_info() nicht fr enorm groe Zeichen (z.B. 300
pt und mehr) aufrufen, da diese je nach Cache-Gr”e evtl. nicht mehr komplett
aufgebaut werden k”nnen. Die Bitmap enth„lt in diesem Fall nur einen Teil des
Zeichens.

Man sollte diese Funktion nicht mibrauchen, um eine eigene Textausgabe zu
bauen - es lohnt sich nicht und Pair-Kerning w„re auch nicht m”glich.


ù INQUIRE OUTLINE FONT TEXT EXTENT (VDI 240)

Ebenso wie bei vqt_extent() werden hier die Zeichenweiten addiert. Diese
Funktion beachtet aber Track- und Pair-Kerning und arbeitet intern mit 1/65536
Pixeln, d.h. erst bei der Umrechnung in Koordinaten wird gerundet. Texteffekte
wie z.B. Neigung ber vst_skew() werden ebenso wie linke und rechte šberh„nge
nicht beachtet.

Dekl.:  void vqt_f_extent( WORD handle, BYTE *string, WORD *extent );
Aufruf: vqt_f_extent( handle, string, extent );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        240                 vqt_fextent
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette

Ausgaben:

contrl[2]        4                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0..7]     extent[0..7]        Koordinaten des Textrechtecks

Fallen:
Aus Kompatibilit„tsgrnden verh„lt sich diese Funktion bei 90, 180 und 270 Grad
genauso unsinnig wie das alte vqt_extent() - der Bezugspunkt wird ge„ndert!

Bemerkungen:
Diese Funktion liefert nicht das den Text umgebende Rechteck. Sie addiert nur
die Schrittweiten und beachtet auch nicht linke oder rechte Zeichenberh„nge.
Sie ist im Prinzip nur zur Cursor-Positionierung gedacht. Wer aber mit dieser
Funktion die Gr”e eines neuzuzeichenenden Bildbereichs ermitteln m”chte, mu
links und rechts sicherheitshalber die Breite des gr”ten Zeichens hinzuaddieren
(und die Neigung beachten). Unter NVDI empfiehlt sich stattdessen die
Verwendung von vqt_real_extent().


ù INQUIRE REAL OUTLINE FONT TEXT EXTENT (VDI 240, 4200)

Diese Funktion wird z.Zt. nur von NVDI bereitgestellt.
Es wird das umgebende Viereck (es mu sich nicht immer um ein Rechteck handeln)
fr Textausgabe an der Stelle x,y zurckgeliefert. Dabei werden s„mtliche
Texteffekte, Rotation, Schr„gstellung, Pair-Kerning, Track-Kerning,
Zeichenberh„nge, horizontale und vertikale Ausrichtung bercksichtigt.

Dekl.:  void vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string,
                              WORD *extent );
Aufruf: vqt_real_extent( handle, x, y, string, extent )

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        240                 vqt_fextent
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[5]        4200                Unterfunktionsnummer
contrl[6]        handle
ptsin[0]         x                   x-Koordinate
ptsin[1]         y                   y-Koordinate
intin[0..n-1]    string[0..n-1]      Zeichenkette

Ausgaben:

contrl[2]        4                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0..7]     extent[0..7]        Koordinaten des umgebenden Textrechtecks


ù OUTLINE  FONT TEXT (VDI 241)

Diese Textausgabefunktion beachtet im Gegensatz zu v_gtext() Pair- und
Track-Kerning und berechnet intern die Zeichenpositionen in 1/65536 Pixeln,
wodurch eine bessere Zeichenpositionierung gew„hrleistet wird.

Dekl.:  void v_ftext( WORD handle, WORD x, WORD y, BYTE *string );
Aufruf: v_ftext( handle, x, y, string );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        241                 v_ftext
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette
ptsin[0]         x
ptsin[1]         y

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Es gibt fr v_ftext() noch eine weitere Variante, bei der man fr jedes Zeichen
den Abstand zum Vorg„nger selbst bestimmen kann:

Dekl.:  void v_ftext_offset( WORD handle, WORD x, WORD y, BYTE *string, WORD *offset );
Aufruf: v_ftext_offset( handle, x, y, string, offset );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        241                 v_ftext
contrl[1]        1+n                 Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette
ptsin[0]         x
ptsin[1]         y
ptsin[2]         offset[0]           x-Offset des ersten Zeichens
ptsin[3]         offset[1]           y-Offset des ersten Zeichens
ptsin[4..2*n+1]  xyoff[2..(2*n)-1]   x-Offset, y-Offset der folgenden Zeichen

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù GET CHARACTER OUTLINE (VDI 243)

Die Funktion v_getoutline() generiert aus einem Zeichen einen Bezierzug, mit dem 
man v_bez() oder v_bez_fill() aufrufen kann.

Dekl.:  void v_getoutline( WORD handle, WORD index, WORD *xyarr, BYTE *bezarr,
                           WORD max_pts, WORD *count );
Aufruf: v_getoutline( handle, index, xyarr, bezarr, max_pts, &count );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        243                 v_getoutline
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        6                   Eintr„ge in intin
contrl[6]        handle
intin[0]         index               Zeichen-Index
intin[1]         max_pts             Maximale auszugebende Punktanzahl
intin[2..3]      xyarray             Buffer fr die Koordinaten
intin[4..5]      bezarray            Buffer fr Punktinformationen (jump, bez)

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
intout[0]        count               Anzahl der ausgegebenen Punkte

Bemerkungen:
Wenn man die Informationen von v_getoutline() z.B. als Vektorgrafik benutzen
m”chte, so empfiehlt es sich, vor dem Aufruf eine groe Texth”he einzustellen. 
Andernfalls ist die Qualit„t des zurckgelieferten Beziers recht mager, da von 
der internen Darstellung in 1/65536 Pixeln auf Pixel gerundet wird, d.h. 16 Bit 
fallen weg. Die Texth”he sollte sich an der Rasteraufl”sung des Fonts 
orientieren (wird bei vqt_fontheader in FH_ORUPM zurckgeliefert, z.B. 2048 fr 
die meisten TrueType-Fonts).


ù SET CHARACTER HEIGHT BY ARBITRARY POINTS (VDI 246)

hnlich wie vst_point() kann man mit dieser Funktion die Zeichenh”he in Punkten
setzen. Man ist aber nicht an die Standard-Gr”en gebunden, sondern kann die
H”he in 1/65536 Punkten (pt) anw„hlen. Wenn man negative Gr”en einstellt,
werden die Zeichen and der x-Achse gespiegelt.

Dekl.:  fix31 vst_arbpt32( WORD handle, fix31 height,
                           WORD *char_width, WORD *char_height,
                           WORD *cell_width, WORD *cell_height );
Aufruf: set_point = vst_arbpt32( handle, height, &char_width, &char_height,
                                 &cell_width, &cell_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        246                 vst_arbpt32
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0..1]      height              H”he in 1/65536 Punkten

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0..1]     set_point           eingestellte H”he in 1/65536 Punkten
ptsout[0]        char_width          ausgew„hlte Zeichenbreite
ptsout[1]        char_height         ausgew„hlte Zeichenh”he
ptsout[2]        cell_width          ausgew„hlte Zeichenzellenbreite
ptsout[3]        cell_height         ausgew„hlte Zeichenzellenh”he

Bemerkungen:
Bei den zurckgelieferten Zeichenbreiten handelt es sich um gerundete Werte, die
man nicht ohne weiteres zur Breitenberechnung benutzen kann.


ù INQUIRE OUTLINE FONT TEXT ADVANCE PLACEMENT VECTOR (VDI 247)

Diese Funktion liefert fr ein Zeichen x- und y-Komponente fr die
Positionierung des folgenden Zeichens (es handelt sich nicht um die Breite des
Zeichens!).

Dekl.:  void  vqt_advance32( WORD handle, WORD index,
                             fix31 *x_advance, fix31 *y_advance );
Aufruf: vqt_advance32( handle, index, &x_advance, &y_advance );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        247                 vqt_advance32
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         index               Zeichen-Index

Ausgaben:

contrl[2]        4                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
ptsout[0]        x_adv_old           x-Abstand in Pixeln
ptsout[1]        y_adv_old           y-Abstand in Pixeln
ptsout[2]        x_rem_old           x-Nachkommarest (mod 16384)
ptsout[3]        y_rem_old           y-Nachkommarest (mod 16384)
ptsout[4..5]     x_advance           x-Abstand in 1/65536 Pixeln
ptsout[6..7]     y_advance           y-Abstand in 1/65536 Pixeln

Bemerkungen:
Die Werte in ptsout[0..3] werden nur noch aus Kompatibilit„tsgrnden
zurckgliefert. Stattdessen sollten x_advance und y_advance im genaueren
fix31-Format benutzt werden.
Es handelt sich bei x_advance und y_advance nur um den Abstand, der fr die
Positionierung des n„chsten Zeichens benutzt wird, d.h. x_advance beinhaltet
keine Zeichenberh„nge.


ù FLUSH OUTLINE FONT CACHE (VDI 251)

Diese Funktion l”scht die Fontcaches - Pr„dikat besonders wertvoll :-)


ù SET CHARACTER CELL WIDTH BY ARBITRARY POINTS (VDI 252)

Vst_setsize() setzt die Zeichenbreite in 1/65536 Punkten (pt). Die Zeichenbreite
wird beim n„chsten Aufruf von vst_height(), vst_point() oder vst_arbpt32() wieder
zurckgesetzt. Bei negativen Breiten werden die Zeichen an der y-Achse gespiegelt.

Dekl.:  fix31 vst_setsize32( WORD handle, fix31 width,
                             WORD *char_width, WORD *char_height,
                             WORD *cell_width, WORD *cell_height );
Aufruf: set_width = vst_setsize32( handle, width, &char_width, &char_height,
                                   &cell_width, &cell_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        252                 vst_setsize32
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0..1]      width               Zeichenbreite in 1/65536 Punkten

Ausgaben:

contrl[2]        2                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0..1]     set_width           eingestellte Breite in 1/65536 Punkten
ptsout[0]        char_width          ausgew„hlte Zeichenbreite
ptsout[1]        char_height         ausgew„hlte Zeichenh”he
ptsout[2]        cell_width          ausgew„hlte Zeichenzellenbreite
ptsout[3]        cell_height         ausgew„hlte Zeichenzellenh”he


ù SET OUTLINE FONT SKEW (VDI 253)

Mit dieser Funktion k”nnen Zeichen unabh„ngig von vst_effects() in
1/10-Grad-Schritten zwischen -90 und +90 Grad geneigt werden. Wie berall im VDI
sind auch hier die Winkel entgegen dem Uhrzeigersinn gerichtet. Positive Winkel
fhren zu einer Neigung nach links, wogegen negative Winkel Zeichen nach rechts
neigen.

Dekl.:  WORD  vst_skew( WORD handle, WORD skew );
Aufruf: set_skew = vst_skew( handle, skew );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        253                 vst_skew
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         skew                Neigung in 1/10-Grad

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_skew            eingestellte Neigung in 1/10-Grad

Bemerkungen:
Diese Funktion ist zwar eine ganz nette Spielerei, aber die erzeugten Zeichen
sehen grunds„tzlich schlechter aus als ein richtiger italic-Font.




Rasterfunktionen
================

ù COPY RASTER, OPAQUE (VDI 109)

"COPY RASTER, OPAQUE" kopiert pixelweise ein rechteckiges Raster auf ein anderes
rechteckiges Raster. Hierbei werden die angegebenen logischen Verknpfungen
beachtet. Beide Raster mssen entweder im ger„tespezifischen Format vorliegen
oder drfen nur 1 Ebene haben.

Immer dann, wenn der Bildschirm (oder das Ger„t, das durch <handle> angesprochen
wird), Quelle oder Ziel einer Rasteroperation ist, sollte fd_addr des MFDB auf
NULL gesetzt sein!

Im Zielraster wird nur geclippt, wenn fd_addr des Ziel-MFDBs NULL ist!

Das Quellraster wird (bisher) nicht geclippt!

Dekl.:  void vro_cpyfm( WORD handle, WORD vr_mode, WORD *xyarr,
                        MFDB *src_MFDB, MFDB *des_MFDB );
Aufruf: vro_cpyfm( handle, wr_mode, xyarr, &src_MFDB, &des_MFDB );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        109                 vro_cpyfm
contrl[1]        4                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     src_MFDB            Zeiger auf den MFDB des Quellrasters
contrl[9..10]    des_MFDB            Zeiger auf den MFDB des Zielrasters
intin[0]         wr_mode             logische Verknpfung
ptsin[0..7]      xyarr[0..7]         Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von wr_mode (logische Verknpfungen):
0:  Ergebnis=0
1:  Ergebnis=Quelle and Ziel
2:  Ergebnis=Quelle and (not Ziel)
3:  Ergebnis=Quelle
4:  Ergebnis=(not Quelle) and Ziel
5:  Ergebnis=Ziel (sinnlos!)
6:  Ergebnis=Quelle xor Ziel
7:  Ergebnis=Quelle or Ziel
8:  Ergebnis=not (Quelle or Ziel)
9:  Ergebnis=not (Quelle xor Ziel)
10: Ergebnis=not Ziel
11: Ergebnis=Quelle or (not Ziel)
12: Ergebnis=not Quelle
13: Ergebnis=(not Quelle) or Ziel
14: Ergebnis=not (Quelle and Ziel)
15: Ergebnis=1

Bedeutung von xyarr:
xyarr[0..3]: Koordinaten des Quellrechtecks
xyarr[4..7]: Koordinaten des Zielrechtecks

Bemerkung:
Normalerweise ignoriert vro_cpyfm() die Breite und H”he des Zielrechtecks und 
geht von den Maen des Quellrechtecks aus. Wenn ein Raster skaliert werden soll,
mu daher das oberste Bit im Verknpfungsmodus gesetzt werden (wr_mode | 0x8000).
Vro_cpyfm() beachtet dann unterschiedliche Ausmae und skaliert das Raster. Ob der 
Treiber Raster skalieren kann, wird bei vq_extnd() in work_out[30] zurckgeliefert.
Das oberste Bit im Verknpfungsmodus darf nur gesetzt werden, wenn der Treiber 
skalieren kann. 


ù COPY RASTER, TRANSPARENT (VDI 121)

Diese Funktion expandiert unter Bercksichtigung von Vorder -und
Hintergrundfarbe sowie des Schreibmodus ein zweifarbiges (aus einer Ebene
bestehendes) Quellraster zu einem mehrfarbigen Zielraster.

Ebenso wie bei vro_cpyfm() sollte auch bei vrt_cpyfm() fd_addr 0 sein, wenn der
Bildschirm Ziel einer Rasteroperation ist!

Dekl.:  void vrt_cpyfm( WORD handle, WORD wr_mode, WORD *xyarr,
                        MFDB *src_MFDB, MFDB *des_MFDB, WORD *color_index );
Aufruf: vrt_cpyfm( handle, wr_mode, xyarr, &src_MFDB, &des_MFDB, color_index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        121                 vrt_cpyfm
contrl[1]        4                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     src_MFDB            Zeiger auf den MFDB des Quellrasters
contrl[9..10]    des_MFDB            Zeiger auf den MFDB des Zielrasters
intin[0]         wr_mode             Schreibmodus
intin[1]         color_index[0]      Farbindex der gesetzten Punkte
intin[2]         color_index[1]      Farbindex der gel”schten Punkte
ptsin[0..7]      xyarr[0..7]         Koordinaten

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von xyarr:
xyarr[0..3]: Koordinaten des Quellrechtecks
xyarr[4..7]: Koordinaten des Zielrechtecks

Bemerkung:
Normalerweise ignoriert vrt_cpyfm() die Breite und H”he des Zielrechtecks und 
geht von den Maen des Quellrechtecks aus. Wenn ein Raster skaliert werden soll,
mu daher das oberste Bit im Schreibmodus gesetzt werden (wr_mode | 0x8000). 
Vrt_cpyfm() beachtet dann unterschiedliche Ausmae und skaliert das Raster. Ob der 
Treiber Raster skalieren kann, wird bei vq_extnd() in work_out[30] zurckgeliefert.
Das oberste Bit im Schreibmodus darf nur gesetzt werden, wenn der Treiber 
skalieren kann. 


ù TRANSFORM FORM (VDI 110)

Diese Funktion transformiert ein Raster vom Standardformat ins ger„tespezifische
Format und umgekehrt. Die Transformation kann "in place" geschehen, d.h. beide
MFDBs zeigen auf den gleichen Speicherbereich - in diesem Fall dauert aber
gerade das Transformieren groer Bl”cke ewig.

Dekl.:  void vr_trnfm( WORD handle, MFDB *src_MFDB, MFDB *des_MFDB );
Aufruf: vr_trnfm( handle, &src_MFDB, &des_MFDB );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        110                 vr_trnfm
contrl[1]        0                   Eintr„ge in ptsin
contrl[2]        0                   Eintr„ge in ptsout
contrl[3]        0                   Eintr„ge in intin
contrl[4]        0                   Eintr„ge in intout
contrl[6]        handle
contrl[7...8]    src_MFDB            Zeiger auf den MFDB des Quellrasters
contrl[9...10]   des_MFDB            Zeiger auf den MFDB des Zielrasters


ù GET PIXEL (VDI 105)

Fr bis zu 8 Farbebenen (256 gleichzeitig darstellbare Farben) ermittelt "GET
PIXEL" den Pixelwert und den Farbindex eines Pixels.

Bei Hicolor (15- oder 16-Bit) enth„lt pel den Pixelwert und index ist (meistens)
-1, da er nicht einwandfrei zuzuordnen ist.

Bei Truecolor enth„lt pel das Low-Word des Pixelwerts und index das High-Word.

Dekl.:  void v_get_pixel( WORD handle, WORD x, WORD y, WORD *pel, WORD *index );
Aufruf: v_get_pixel( handle, x, y, &pel, & index );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        105                 v_get_pixel
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        pel                 Pixelwert
intout[1]        index               Farbindex des Pixels


Rasteroperationen bei Offscreen-Bitmaps:
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
Rasteroperationen zwischen Bildschirm und Offscreen-Bitmap sollten
grunds„tzlich im ger„tespezifischen Format erfolgen.
Wenn als Ziel einer Rasteroperation eine Offscreen-Bitmap mit ihrem MFDB
angegeben wird und wenn das zu dieser Bitmap geh”rende Handle benutzt wird, so
wird beim Transfer anhand der ber vs_clip() auf dieser Workstation
eingestellten Koordinaten geclippt. Fr das Kopieren eines Rasters vom
Bildschirm in eine Offscreen-Bitmap sollte man also das VDI-Handle dieser
Bitmap benutzen.
Ist die Bitmap dagegen Quelle und der Bildschirm Ziel, so sollte man das Handle
der Bildschirm-Workstation benutzen, da dann das Raster anhand der
Bildschirm-Koordinaten abgeclippt wird. Wenn man das von v_opnbm()
zurckgelieferte Handle einer Bitmap benutzt und in fd_addr in einem MFDB 0
enth„lt, so werden die Daten der Bitmap statt dessen benutzt.




Eingabefunktionen
=================

Die Eingabefunktionen erm”glichen einem Programm, unter Bercksichtigung der
Eingabemodi Tastatur und Maus abzufragen. Auerdem bieten sie Routinen zum
einenklinken in Timer- und Maus- Interrupts.

Diese Funktionen sind prim„r fr den Eigner der physikalischen Workstation, d.h.
fr das AES gedacht. Applikationen sollten, sofern es keine zwingenden Grnde
fr ein anderes Vorgehen gibt, Maus- und Tastaturereignisse immer durch die
Event-Funktionen des AES abfragen, da andernfalls fr andere Applikationen
bestimmte Eingaben abgefangen werden.


ù SET INPUT MODE (VDI 33)

Mit "SET INPUT MODE" kann man fr ein bestimmtes Eingabeger„t den Eingabemodus
festlegen.

Dekl.:  void vsin_mode( WORD handle, WORD dev_type, WORD mode );
Aufruf: vsin_mode( handle, dev_type, mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        33                  vsin_mode
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         dev_type            Eingabeeinheit
intin[1]         mode                gewnschter Eingabemodus

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_mode            ausgew„hlter Eingabemodus

Bedeutung von dev_type:
1: Maus
2: Cursor
3: Funktionstasten
4: Tastatur

Bedeutung von mode:
REQUEST MODE   1: Warten bis eine Eingabe erfolgt und dann den Eingabewert
                  zurckgeben.
SAMPLE MODE    2: Eingabeeinheit abfragen und sofort den Eingabewert und den
                  Status zurckgeben.


ù INPUT LOCATOR, REQUEST MODE (VDI 28)

Mit dieser Funktion wird die Position des Mauszeigers ermittelt und eine neue
Position bergeben. Der Mauszeiger wird erst nach Druck einer Maustaste neu
positioniert.

Dekl.:  void vrq_locator( WORD handle, WORD x, WORD y, WORD *xout,
                               WORD *yout, WORD *term );
Aufruf: vrq_locator( handle, x, y, &xout, &yout, &term );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        28                  vrq_locator
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0]         x                   neue x-Koordinate des Mauszeigers
ptsin[1]         y                   neue y-Koordinate des Mauszeigers

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        term                Maustastenstatus+31
ptsout[0]        xout                alte x-Koordinate des Mauszeigers
ptsout[1]        yout                alte y-Koordinate des Mauszeigers


ù INPUT LOCATOR, SAMPLE MODE (VDI 28)

Mit dieser Funktion wird die Position des Mauszeigers ermittelt und eine  neue
Position  bergeben.  Tastenbet„tigungen  oder Mausposition  werden  nur  dann
gemeldet, wenn sie wirklich erfolgt sind.

Dekl.:  WORD vsm_locator( WORD handle,  WORD x,  WORD y,  WORD *xout,
                          WORD *yout, WORD *term );
Aufruf: status = vsm_locator( handle, x, y, &xout, &yout, &term );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        28                  vsm_locator
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
ptsin[0]         x                   neue x-Koordinate des Mauszeigers
ptsin[1]         y                   neue y-Koordinate des Mauszeigers

Ausgaben:

contrl[2]        0 oder 1            Eintr„ge in ptsout
contrl[4]        0 oder 1            Eintr„ge in intout
intout[0]        term                Maustastenstatus+31
ptsout[0]        xout                alte x-Koordinate des Mauszeigers
ptsout[1]        yout                alte y-Koordinate des Mauszeigers

Bedeutung von status (gebildet aus (contrl[4]<<1)|contrl[2]) (Bitnummer):
0: Positionsver„nderung
1: Tastendruck


ù INPUT CHOICE, REQUEST MODE (VDI 30)

Mit  dieser Funktion wird die Bet„tigung einer Funktionstaste  abgewartet  und
die Tastennummer (1-10) zurckgegeben.

Dekl.:  void vrq_choice( WORD handle, WORD ch_in, WORD *ch_out );
Aufruf: vrq_choice( handle, ch_in, &ch_out );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        30                  vrq_choice
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         ch_in               initialisierende Taste (0)

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        ch_out              ausgew„hlte Funktionstaste


ù INPUT CHOICE, SAMPLE MODE (VDI 30)

Sofern   eine  Funktionstaste  bet„tigt  wurde,   gibt  dieser  Funktion   die
Tastennummer (1-10) zurck.

Dekl.:  WORD vsm_choice( WORD handle, WORD *choice );
Aufruf: status = vsm_choice( handle, &choice );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        30                  vsm_choice
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0 oder 1            Eintr„ge in intout
intout[0]        choice              Tastennummer

Bedeutung von status (contrl[4]):
0: kein Tastendruck
1: Tastendruck erfolgt


ù INPUT STRING,REQUEST MODE (VDI 31)

Diese Funktion gibt eine Zeichenkette von der Tastatur zurck, wenn RETURN
gedrckt oder die maximale L„nge erreicht wird.

Dekl.:  void vrq_string( WORD handle, WORD max_length, WORD echo_mode,
                              WORD *echo_xy, BYTE *string );
Aufruf: vrq_string( handle, max_length, echo_mode, echo_xy, string );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        31                  vrq_string
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         max_length          maximale L„nge der Zeichenkette
intin[1]         echo_mode           0: keine Ausgabe, 1: Ausgabe
ptsin[0]         echo_xy[0]
ptsin[1]         echo_xy[1]

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        n                   Eintr„ge in intout
intout[0..n-1]   string[0..n-1]      Eingabepuffer

Bedeutung von max_length:
max_length gibt die maximale L„nge der Zeichenkette an. Ist max_length negativ,
so wird der Absolutbetrag als L„nge betrachtet, und statt der ASCII-Codes werden
Scan-Codes bergeben.


ù INPUT STRING,SAMPLE MODE (VDI 31)

Diese Funktion gibt eine Zeichenkette von der Tastatur  zurck, wenn RETURN
gedrckt oder die maximale L„nge erreicht wird. Sofern keine Eingaben gemacht
werden, bricht die Funktion ab.

Dekl.:  WORD vsm_string( WORD handle, WORD max_length, WORD echo_mode,
                             WORD *echo_xy, BYTE *string );
Aufruf: status = vsm_string( handle,  max_length, echo_mode, echo_xy, string );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        31                  vsm_string
contrl[1]        1                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[6]        handle
intin[0]         max_length          maximale L„nge der Zeichenkette
intin[1]         echo_mode           0: keine Ausgabe, 1: Ausgabe
ptsin[0]         echo_xy[0]
ptsin[1]         echo_xy[1]

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        n                   Eintr„ge in intout
intout[0..n-1]   string[0..n-1]      Eingabepuffer

Bedeutung von max_length:
max_length  gibt  die  maximale L„nge  der  Zeichenkette  an.  Ist  max_length
negativ,  so  wird der Absolut-Betrag als L„nge benutzt und statt  der  ASCII-
Codes werden Scan-Codes bergeben.

Bedeutung von status (contrl[4]):
0:    keine Eingabe
<> 0: L„nge der Zeichenkette


ù SET MOUSE FORM (VDI 111)

Das Aussehen des Mauszeigers kann mit "SET MOUSE FORM" frei definiert werden.

Dekl.:  void vsc_form( WORD handle, WORD *cursor );
Aufruf: vsc_form( handle, cursor );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        111                 vsc_form
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        37                  Eintr„ge in intin
contrl[6]        handle
intin[0..36]     cursor[0..36]       Mauszeigerdefinition

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von cursor:
pcur_form[0]:       relative Koordinate des horizontalen Aktionspunktes
pcur_form[1]:       relative Koordinate des vertikalen Aktionspunktes
pcur_form[2]:       mu 1 sein (REPLACE)
pcur_form[3]:       Farbindex der Hintergrundmaske
pcur_form[4]:       Farbindex der Vordergrundmaske
pcur_form[5..20]:   Hintergrundmaske
pcur_form[21..36]:  Vordergrundmaske

Bemerkung:
Zum Setzen der Mausform sollte in GEM-Programmen unbedingt die AES-Funktion
graf_mouse() verwendet werden.  Andernfalls wird die Mausform-Verwaltung des AES
nachhaltig verwirrt.

Mit NVDI ist es m”glich, die aktuelle Mausform zurckgeliefert zu bekommen.

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        111                 vgc_form
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        37                  Eintr„ge in intout
intout[0..36]    cursor[0..36]       Mauszeigerdefinition


ù INQUIRE INPUT MODE (VDI 115)

Diese Funktion ermittelt den Eingabemodus eines Ger„tes.

Dekl.:  void vqin_mode( WORD handle, WORD dev_type, WORD *input_mode );
Aufruf: vqin_mode( handle, dev_type, &input_mode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        115                 vqin_mode
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         dev_type            Ger„tenummer (siehe vsin_mode)

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[1]        input_mode          Eingabe-Modus


ù EXCHANGE TIMER INTERRUPT VECTOR (VDI 118)

Mit dieser Funktion kann man eine eigene Routine im Timerinterrupt (etv_timer)
aufrufen lassen. Diese Routine mu an ihrem Ende alle ver„nderten Register
restaurieren und die alte Timerinterruptroutine anspringen.

Dekl.:  void vex_timv( WORD handle, void *tim_addr, void **otim_addr,
                       WORD *tim_conv );
Aufruf: vex_timv( handle, tim_addr, &otim_addr, &tim_conv );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        118                 vex_timv
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     tim_addr            Adresse der neuen Interruptroutine

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
contrl[9..10]    otim_addr           Adresse der alten Interruptroutine
intout[0]        tim_conv            Interruptintervall in ms


ù SHOW CURSOR (VDI 122)

Mit "SHOW CURSOR" wird ein vorhergehender "HIDE CURSOR"-Aufruf aufgehoben. Wenn
man den Mauszeiger sofort erscheinen lassen m”chte, mu der Parameter <reset>
Null sein.

Dekl.:  void v_show_c( WORD handle, WORD reset );
Aufruf: v_show_c( handle, reset );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        122                 v_show_c
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[6]        handle
intin[0]         reset

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bedeutung von reset:
0:    Mauszeiger sofort anzeigen
<> 0: Hide-Counter dekrementieren und gegebenenfalls Mauszeiger zeichnen

Bemerkung:
Zum  Ein-/Ausschalten der Maus sollte in GEM-Programmen unbedingt die
AES-Funktion graf_mouse() verwendet werden.


ù HIDE CURSOR (VDI 123)

Diese Funktion schaltet den Mauszeiger aus.

Dekl.:  void v_hide_c( WORD handle );
Aufruf: v_hide_c( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        123                 v_hide_c
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bemerkung:
Zum  Ein-/Ausschalten der Maus sollte in GEM-Programmen unbedingt die
AES-Funktion graf_mouse() verwendet werden.


ù SAMPLE MOUSE BUTTON STATE (VDI 124)

Diese Funktion gibt Informationen ber die Mauszeiger-Position und den  Status
der Maustasten zurck.

Dekl.:  void vq_mouse( WORD handle, WORD *status, WORD *x, WORD *y );
Aufruf: vq_mouse( handle, &status, &x, &y );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        124                 vq_mouse
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        1                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        status              Maustastenstatus
ptsout[0]        x
ptsout[1]        y

Bedeutung von status:
0: keine Maustaste gedrckt
1: linke Maustaste gedrckt
2: rechte Maustaste gedrckt
3: beide Maustasten gedrckt

Bemerkung:
In GEM-Programmen sollte die AES-Funktion graf_mkstate() oder die 
Event-Funktionen verwendet werden, um nur die fr die eigene Applikation 
bestimmten Informationen ber Position und Status der Maustastenstatus zu 
erhalten. 


ù EXCHANGE BUTTON CHANGE VECTOR (VDI 125)

Mit "EXCHANGE BUTTON CHANGE VECTOR" kann man eine Routine installieren, die beim
Druck einer Maustaste aufgerufen wird und in Register d0.w den Status der
Maustasten erth„lt. Diese Routine mu alle ver„nderten Register wiederherstellen
und die alte Maustasten-Status-Routine aufrufen.

Dekl.:  void vex_butv( WORD handle, void *pusrcode, void **psavcode );
Aufruf: vex_butv( handle, pusrcode, &psavcode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        125                 vex_butv
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     pusrcode            Adresse der neuen Routine

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
contrl[9..10]    psavcode            Adresse der alten Routine


ù EXCHANGE MOUSE MOVEMENT VECTOR (VDI 126)

Diese Funktion erlaubt im Fall von Mausbewegungen den Aufruf einer Anwender-
Routine, der in d0.w und d1.w die Koordinaten des Mauszeigers bergeben werden.
Alle ver„nderten Register mssen von dieser Routine restauriert werden.
Anschlieend sollte die alte Mausbewegungsroutine aufgerufen werden.

Dekl.:  void vex_motv( WORD handle, void *pusrcode, void **psavcode );
Aufruf: vex_motv( handle, pusrcode, &psavcode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        126                 vex_motv
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     pusrcode            Adresse der neuen Routine

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
contrl[9..10]    psavcode            Adresse der alten Routine


ù EXCHANGE CURCOR CHANGE VECTOR (VDI 127)

Mit "EXCHANGE CURSOR CHANGE VECTOR" kann man eine Routine installieren, die bei
Mausbewegungen aufgerufen wird. Der Aufruf dieser Routine erfolgt, nachdem die
ber vex_motv() eingetragene Routine aufgerufen und die Mauszeiger-Koordinaten,
die man in d0.w und d1.w erh„lt, geclippt wurden. Alle  ver„nderten  Register
mssen wiederhergestellt werden. Anschlieend sollte die alte Routine aufgerufen
werden.

Dekl.:  void vex_curv( WORD handle, void *pusrcode, void **psavcode );
Aufruf: vex_curv( handle, pusrcode, &psavcode );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        127                 vex_curv
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle
contrl[7..8]     pusrcode            Adresse der neuen Routine

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout
contrl[9..10]    psavcode            Adresse der alten Routine


ù SAMPLE KEYBOARD STATE INFORMATION (VDI 128)

Diese Funktion gibt den Status der CONTROL-, ALTERNATE- sowie der SHIFT-
Taste(n) zurck.

Dekl.:  void vq_key_s( WORD handle, WORD *status );
Aufruf: vq_key_s( handle, &status );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        128                 vq_key_s
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        pstatus             Tastenstatus

Bedeutung von pstatus (Bitnummer):
0: rechte Shift-Taste
1: linke Shift-Taste
2: Control-Taste
3: Alternate-Taste

Bemerkung:
In GEM-Programmen sollten die AES Event-Funktionen verwendet werden, um nur die
fr die eigene Applikation bestimmten Informationen ber den Tastaturstatus zu
erhalten.




Textmodus und VT52
==================

ù INQUIRE ADDRESSABLE ALPHA CHARACTER CELLS (VDI 5, ESCAPE 1)

Diese Funktion gibt ber die Anzahl der Zeilen und Spalten des Textbildschirmes
Auskunft. Wenn <rows> und <colums> 0 sind, gibt es auf dem Ger„t keinen
Textmodus.

Dekl.:  void vq_chcells( WORD handle, WORD *rows, WORD *columns );
Aufruf: vq_chcells( handle, &rows, &columns );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        1                   vq_chcells
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        rows                Zeilenanzahl
intout[1]        columns             Spaltenanzahl


ù EXIT ALPHA MODE (VDI 5, ESCAPE 2)

"EXIT ALPHA MODE" schaltet den Textmodus aus.

Dekl.:  void v_exit_cur( WORD handle );
Aufruf: v_exit_cur( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        2                   v_exit_cur
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ENTER ALPHA MODE (VDI 5, ESCAPE 3)

Mit dieser Funktion gelangt man in den Textmodus. Der Bildschirm wird gel”scht
und der Text-Cursor in die linke obere Ecke gesetzt.

Dekl.:  void v_enter_cur( WORD handle );
Aufruf: v_enter_cur( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        3                   v_enter_cur
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ALPHA CURSOR UP (VDI 5, ESCAPE 4)

Der Text-Cursor wird von dieser Funktion eine Zeile nach oben bewegt. Sofern er
sich in der obersten Zeile befindet, geschieht nichts.

Dekl.:  void v_curup( WORD handle );
Aufruf: v_curup( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        4                   v_curup
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ALPHA CURSOR DOWN (VDI 5, ESCAPE 5)

Der Text-Cursor wird um eine Zeile nach unten bewegt. Befindet sich der Cursor
in der untersten Zeile, so passiert nichts.

Dekl.:  void v_curdown( WORD handle );
Aufruf: v_curdown( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        5                   v_curdown
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ALPHA CURSOR RIGHT (VDI 5, ESCAPE 6)

"ALPHA CURSOR RIGHT" bewegt den Text-Cursor nach rechts, wobei am Zeilenende
nichts geschieht.

Dekl.:  void v_curright( WORD handle );
Aufruf: v_curright( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        6                   v_curright
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ALPHA CURSOR LEFT (VDI 5, ESCAPE 7)

Der Text-Cursor wird von dieser Funktion nach links bewegt. Es passiert nichts,
wenn er sich bereits am Zeilenanfang befinden sollte.

Dekl.:  void v_curleft( WORD handle );
Aufruf: v_curleft( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        7                   v_curleft
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù HOME ALPHA CURSOR (VDI 5, ESCAPE 8)

Von dieser Funktion wird der Text-Cursor in die linke obere Ecke gesetzt.

Dekl.:  void v_curhome( WORD handle );
Aufruf: v_curhome( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        8                   v_curhome
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ERASE TO END OF ALPHA SRCEEN (VDI 5, ESCAPE 9)

Der Bildschirm wird von der aktuellen Cursor-Position ab gel”scht.

Dekl.:  void v_eeos( WORD handle );
Aufruf: v_eeos( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        9                   v_eeos
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù ERASE TO END OF ALPHA TEXT LINE (VDI 5, ESCAPE 10)

Diese Funktion l”scht ab der Cursor-Position die aktuelle Zeile.

Dekl.:  void v_eeol( WORD handle );
Aufruf: v_eeol( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        10                  v_eeol
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù DIRECT ALPHA CURSOR ADDRESS (VDI 5, ESCAPE 11)

Mit "DIRECT ALPHA CURSOR ADDRESS" kann der Text-Cursor direkt positioniert
werden.

Dekl.:  void v_curaddress( WORD handle, WORD row, WORD column );
Aufruf: v_curadress( handle, row, column );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        11                  v_curaddress
contrl[6]        handle
intin[0]         row                 Zeile
intin[1]         column              Spalte

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù OUTPUT CURSOR ADDRESSABLE ALPHA TEXT (VDI 5, ESCAPE 12)

Diese Funktion gibt an der aktuellen Cursor-Position eine Zeichenkette aus.

Dekl.:  void v_curtext( WORD handle, BYTE *string );
Aufruf: v_curtext( handle, string );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[5]        12                  v_curtext
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù REVERSE VIDEO ON (VDI 5, ESCAPE 13)

Diese Funktion schaltet auf inverse Textausgabe um.

Dekl.:  void v_rvon( WORD handle );
Aufruf: v_rvon( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        13                  v_rvon
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù REVERSE VIDEO OFF (VDI 5, ESCAPE 14)

Die inverse Textausgabe wird ausgeschaltet.

Dekl.:  void v_rvoff( WORD handle );
Aufruf: v_rvoff( handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        14                  v_rvoff
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù INQUIRE CURRENT ALPHA CURCOR ADDRESS (VDI 5, ESCAPE 15)

Von dieser Funktion wird die Position des Text-Cursors zurckgegeben.

Dekl.:  void vq_curaddress( WORD handle, WORD *row, WORD *column );
Aufruf: vq_curaddress( handle, &row, &column );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        15                  vq_curaddress
contrl[6]        handle

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        row                 Zeile
intout[1]        column              Spalte




Druckerspezifische Funktionen
=============================


Die im folgenden beschriebenen Funktionen sind nicht bei jedem 
Druckertreiber vorhanden. Bevor man die Rckgabewerte auswertet, 
mu daher abgetestet werden, ob berhaupt Rckgaben vorhanden sind 
(contrl[2] und contrl[4] testen).

Bei Funktionen wie v_orient() oder v_page_size(), die evtl. Speicher 
anfordern mssen, kann es vorkommen, da zu wenig Speicher vorhanden 
ist, und daher kein Ausdruck m”glich ist. Der Treiber sollte dann 
mit v_clswk() geschlossen werden.


ù OPEN WORKSTATION (VDI 1)

Diese Funktion erlaubt bei NVDI-Treiber auch das Setzen des Ausgabe-
kanals und des Papierformats:

Siehe Beschreibung im Abschnitt "Ger„tetreiber und Offscreen-Bitmaps".


ù EXTENDED INQUIRE FUNCTION (VDI 102)

Bei NVDI-Treibern liefert diese Funktion zus„tzlich das Papierformat 
und die Gr”e der nicht bedruckbaren R„nder zurck:

Siehe Beschreibung im Abschnitt "Ger„tetreiber und Offscreen-Bitmaps".


ù OUTPUT BIT IMAGE FILE (VDI 5, ESCAPE 23)

Dekl.:  void v_bit_image( WORD handle, BYTE *name, WORD aspect, 
                          WORD x_scale, WORD y_scale, WORD h_align,
                          WORD v_align, WORD *xyarray );

Aufruf: void v_bit_image( handle, name, aspect, x_scale, y_scale,
                          h_align, v_align, xyarray );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        5 + n               Eintr„ge in intin
contrl[5]        23                  v_bit_image
contrl[6]        handle
intin[0]         aspect              Abbilundsmastab
intin[1]         x_scale             Skalierung der x-Achse
intin[2]         y_scale             Skalierung der y-Achse
intin[3]         h_align             horizontale Ausrichtung
intin[4]         v_align             vertikale Ausrichtung
intin[5..n+4]    file_name[...]      Dateiname
ptsin[0..3]      xyarray[0..3]       Ausgaberechteck

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù SET ORIENTATION (VDI 5, ESCAPE 27)

Mit dieser Funktion kann eingestellt werden, ob die Seiten im Hoch- 
oder Querformat ausgegeben werden. Wird <orient> -1 ist, wird die 
bisherige Orientierung zurckgeliefert.

Wenn nicht gengend Speicher zur Verfgung steht, um die Orientierung 
zu „ndern, liefert v_orient() -1 zurck. In diesem Fall mu die 
Druckerworkstation mit v_clswk() geschlossen werden!

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden und die 
Orientierung nicht „nderbar.

Dekl.:  WORD v_orient( WORD handle, WORD orient );
Aufruf: set_orient = v_orient( handle, orient );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[5]        27                  v_orient
contrl[6]        handle
intin[0]         orient              Ausrichtung

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_orient          gesetzte Ausrichtung

Bedeutung von <orient>:
-1: Ausrichtung erfragen
0:  Hochformat setzen
1:  Querformat setzen

Bedeutung von <set_orient>:
-1: Fehler (zu wenig Speicher) => Workstation schlieen
0:  Hochformat eingestellt
1:  Querformat eingestellt


ù SET NUMBER OF COPIES (VDI 5, ESCAPE 28)

Mit v_copies() kann die Anzahl der auszugebenden Exemplare einer 
Druckseite eingestellt werden.

Wenn <copies> -1 ist, wird die Anzahl der eingestellten Kopien 
zurckgeliefert.

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden. 
Kopien einer Seite mssen dann durch mehrmaliges Aufbauen der 
Grafik und anschlieendes v_updwk() erzeugt werden.

Dekl.:  WORD v_copies( WORD handle, WORD copies );
Aufruf: set_copies = v_copies( handle, copies );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[5]        28                  v_copies
contrl[6]        handle
intin[0]         copies              Anzahl der Exemplare

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_copies          gesetzte Exemplare


ù SET INPUT AND OUTPUT TRAY (VDI 5, ESCAPE 29)

Diese Funktion erlaubt das Setzen des Papiereinzugs und -auswurfs. 
Sollte der Einzug oder Auswurf nicht vorhanden sein, wird die 
Standard-Einstellung gesetzt (Einzug 0 und Auswurf 0).

Die Namen der Einzge und Papierauswrfe k”nnen mit vq_tray_names() 
erfragt werden.

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden. 

Dekl.:  void v_trays( WORD handle, WORD input, WORD output,
                      WORD *set_input, WORD *set_output );
Aufruf: v_trays( handle, input, output, &set_input, &set_output );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        2                   Eintr„ge in intin
contrl[5]        29                  v_tray
contrl[6]        handle
intin[0]         input               Einzug
intin[1]         output              Auswurf

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        set_input           gesetzter Einzug
intout[1]        set_output          gesetzter Auswurf

Bedeutung von <input>:
-1: manueller Einzug
0:  Standard-Einzug (Kasette 1)
1:  Kasette 2
...

Bedeutung von <output>:
0: Standard-Auswurf (normalerweise vorne)
1: Papierauswurf 2 (normalerweise hinten)
...


ù INQUIRE TRAY NAMES (VDI 5, ESCAPE 36)

INQUIRE TRAY NAMES liefert die Namen des gerade eingestellten 
Einzugs und des Auswurfs zurck.

Wenn <input_name> oder <output_name> 0L sind, wird der Name nicht 
zurckgeliefert.

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden. 

Dekl.:  void vq_tray_names( WORD handle, BYTE *input_name, BYTE *output_name,
                            WORD *input, WORD *output );
Aufruf: vq_tray_names( handle, input_name, output_name, &input, &output );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        4                   Eintr„ge in intin
contrl[5]        36                  vq_tray_names
contrl[6]        handle
intin[0/1]       input_name          Zeiger auf den Einzug-Namen
intin[2/3]       output_name         Zeiger auf den Auswurf-Namen

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        2                   Eintr„ge in intout
intout[0]        input               Papiereinzug
intout[1]        output              Papierauswurf


ù SET PAGE SIZE (VDI 5, ESCAPE 37)

Mit v_page_size() kann ein anderes Seitenformat gesetzt werden (siehe
auch v_opnwk() fr Drucker). Sollte ein angefordertes Seitenformat 
nicht existieren, wird die Standard-Einstellung benutzt.

Wenn der Rckgabewert <set_page> -1 ist, mu die Workstation 
geschlossen werden, da nicht gengend Speicher vorhanden ist.

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden. 

Dekl.:  WORD v_page_size( WORD handle, WORD page_id );
Aufruf: set_page = v_page_size( handle, page_id );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[5]        37                  v_page_size
contrl[6]        handle
intin[0]         page_id             Papierformat

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        1                   Eintr„ge in intout
intout[0]        set_page            eingestelltes Papierformat

Bedeutung von <page_id>:
0:  PAGE_DEFAULT, Voreinstellung benutzen
1:  PAGE_A3, DIN A3
2:  PAGE_A4, DIN A4
3:  PAGE_A5, DIN A5
4:  PAGE_B5, DIN B5

16: PAGE_LETTER, Letter size
17: PAGE_HALF, Half size
18: PAGE_LEGAL, Legal size
19: PAGE_DOUBLE, Double size
20: PAGE_BROAD, Broad sheet size

Bedeutung von <set_page>:
-1: Fehler (nicht gengend Speicher) => Workstation schlieen
sonst wie <page_size>


ù INQUIRE PAGE NAME (VDI 5, ESCAPE 38)

INQURIE PAGE NAME ermittelt den Namen eines Seitenformats und 
liefert die physikalische Gr”e des Seitenformats (d.h. H”he und 
Breite inklusive nicht bedruckbarer R„nder; z.B. 210000 * 2970000 
Mikrometer bei DIN A4).

Wenn <set_page> -1 ist, ist das Seitenformat <page_id> dem Treiber nicht 
bekannt, page_width und page_height werden dann nicht zurckgeliefert.

Sollte contrl[4] 0 sein, ist diese Funktion nicht vorhanden. 

Dekl.:  WORD vq_page_name( WORD handle, WORD page_id, BYTE *page_name,
                           LONG *page_width, LONG *page_height );
Aufruf: set_page = vq_page_name( handle, page_id, page_name,
                                 &page_width, &page_height );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[5]        38                  vq_page_name
contrl[6]        handle
intin[0]         page_id             Papierformat
intin[1/2]       page_name           Zeiger auf den Papiernamen oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        5                   Eintr„ge in intout
intout[0]        set_page            Papierformat oder -1 (Fehler)
intout[1/2]      page_width          Papierbreite in Mikrometern
intout[3/4]      page_height         Papierh”he in Mikrometern


ù ESCAPE 2000 (VDI 5, ESCAPE 2000)

Im Gegensatz zu v_copies() (ESCAPE 28) stellt diese Funktion die Anzahl 
der Duplikate einer Seite ein, d.h. zu jeder Seite werden zus„tzlich
<times> Kopien der Seite gedruckt.

Dekl.:  void v_escape2000( WORD handle, WORD times );
Aufruf: v_escape2000( handle, times );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        1                   Eintr„ge in intin
contrl[5]        2000                v_escape2000
contrl[6]        handle
intin[0]         times               Anzahl der zus„tzlichen Kopien

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bemerkung:
Diese Funktion ist nicht in jedem Druckertreiber verfgbar, und da sie 
keine Rckgabewerte hat, kann ein aufrufendes Programm nicht feststellen, 
ob v_escape2000() berhaupt existiert. Der Aufruf von v_copies() ist 
daher vorzuziehen.




Metafile-spezifische Funktionen
===============================

ù OUTPUT BIT IMAGE FILE (VDI 5, ESCAPE 23)

Der Name eines anzuzeigenden IMGs wird von dieser Funktion im 
Metafile abgespeichert:

Beschreibung und Aufruf siehe "Druckerspezifische Funktionen"


ù UPDATE METAFILE EXTENTS (VDI 5, ESCAPE 98)

Diese Funktion tr„gt die neuen Gr”en-Informationen im Metafile-Header ein.

Dekl.:  void v_meta_extents( WORD handle, WORD x_min, WORD y_min,
                             WORD x_max, WORD y_max );
Aufruf: v_meta_extents( handle, x_min, y_min, x_max, y_max );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        2                   Eintr„ge in ptsin
contrl[3]        0                   Eintr„ge in intin
contrl[5]        98                  v_meta_extents
contrl[6]        handle
ptsin[0]         x_min
ptsin[1]         y_min
ptsin[2]         x_max
ptsin[3]         y_max

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù WRITE METAFILE ITEM (VDI 5, ESCAPE 99)

WRITE METAFILE ITEM erm”glicht es einer Applikation, eigene Befehle im 
Metafile abzuspeichern. Die Befehlsnummer von 0 bis 100 sind reserviert, 
alle darber liegenden Nummern k”nnen jedoch benutzt werden.

Die Befehlsnummer wird in a_intin[0] bergeben.

Dekl.:  void v_write_meta( WORD handle, WORD num_intin, WORD *a_intin,
                           WORD num_ptsin, WORD *a_ptsin );
Aufruf: void v_write_meta( handle, num_intin, a_intin, num_ptsin, a_ptsin );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        num_ptsin           Eintr„ge in ptsin
contrl[3]        num_intin           Eintr„ge in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         a_intin[0]          Befehlsnummer
intin[1..num_intin - 1] a_intin[..]  benutzerdefinierte Information
ptsin[0..num_ptsin - 1] a_ptsin[..]  benutzerdefinierte Information

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù PHYSICAL PAGE SIZE (VDI 5, ESCAPE 99, Opcode 0)

...ist eine Unterfunktion von WRITE METAFILE ITEM und setzt die 
Seitengr”e in 1/10 mm.

Dekl.:  void vm_pagesize( WORD handle, WORD pgwidth, WORD pgheight );
Aufruf: vm_pagesize( handle, pgwidth, pgheight );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        3                   Eintr„ge in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         0                   vm_pagesize
intin[1]         pgwidth             Breite in 1/10 mm
intin[2]         pgheight            H”he in 1/10 mm

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù COORDINATE WINDOW (VDI 5, ESCAPE 99, Opcode 1)

...ist eine Unterfunktion von WRITE METAFILE ITEM und setzt das 
benutzte Koordinatensystem des Metafiles.

Dekl.:  void vm_coords( WORD handle, WORD llx, WORD lly,
                        WORD urx, WORD ury );
Aufruf: vm_coords( handle, llx, lly, urx, ury );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        5                   Eintr„ge in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         1                   vm_coords
intin[1]         llx                 x-Koordinate links unten
intin[2]         lly                 y-Koordinate links unten
intin[3]         urx                 x-Koordinate rechts oben
intin[4]         ury                 y-Koordinate rechts oben

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout


ù CHANGE GEM VDI FILE NAME (VDI 5, ESCAPE 100)

Mit dieser Funktion kann der Name des Metafiles ge„ndert werden. Der
bergebene Name kann (sollte) einen kompletten Dateinamen mit 
absoluter Laufwerksangabe enthalten, z.B. "E:\PICS\FLIWATšT.GEM".

Der bei v_opnwk() angelegte Metafile "GEMFILE.GEM", der im aktuellen 
Verzeichnis erzeugt wurde, wird geschlossen (und von NVDI gel”scht!). 
Daher sollte vm_filename() direkt nach v_opnwk() aufgerufen werden.

Dekl.:  void vm_filename( WORD handle, BYTE *filename );
Aufruf: vm_filename( handle, filename );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        5                   ESCAPE
contrl[1]        0                   Eintr„ge in ptsin
contrl[3]        n                   Eintr„ge in intin
contrl[5]        100                 vm_filename
contrl[6]        handle
intin[0..n - 1]  filename[0..n-1]    Dateiname

Ausgaben:

contrl[2]        0                   Eintr„ge in ptsout
contrl[4]        0                   Eintr„ge in intout

Bemerkungen:
ltere Metafile-Treiber l”schen im Gegensatz zum NVDI-Treiber evtl. 
GEMFILE.GEM nicht, wenn vm_filename() aufgerufen wird. Daher ist zu 
empfehlen, da diese Datei nach vm_filename() explizit mit Fdelete() 
gel”scht wird.





Beispiele fr Bindings
======================

Diese Beispiel-Bindings gehen davon aus, da <pb>, <contrl>, <intin>, <ptsin>,
<intout> und <ptsout> global definiert sind. Die Funktion vdi() ist als
void vdi( VDIPB *pb ) definiert. WORD, UWORD usw. sind normalerweise in PORTAB.H
definiert, fix31 sollte als LONG definiert werden.

/* Strukturdefinitionen */

typedef struct
{
   void  *fd_addr;         /* Adresse des Rasters oder 0 fr Bildschirm/Bitmap */
   WORD  fd_w;             /* Breite des Rasters in Pixeln */
   WORD  fd_h;             /* H”he des Rasters in Zeilen */
   WORD  fd_wdwidth;       /* Breite einer Rasterzeile in Worten */
   WORD  fd_stand;         /* Format 0: ger„tespezifisch, 1: Standardformat */
   WORD  fd_nplanes;       /* Anzahl der Ebenen */
   WORD  fd_r1;            /* reserviert, sollte 0 sein */
   WORD  fd_r2;            /* reserviert, sollte 0 sein */
   WORD  fd_r3;            /* reserviert, sollte 0 sein */
} MFDB;

typedef struct
{
   WORD  red;              /* Rot-Intensit„t in Promille (0-1000) */
   WORD  green;            /* Grn-Intensit„t in Promille (0-1000) */
   WORD  blue;             /* Blau-Intensit„t in Promille (0-1000) */
} RGB1000;

typedef struct
{
   LONG  size;             /* L„nge der Struktur, mu vor vqt_xfntinfo() gesetzt werden */
   WORD  format;           /* Fontformat, z.B. 4 fr TrueType */
   WORD  id;               /* Font-ID, z.B. 6059 */
   WORD  index;            /* Index */
   BYTE  font_name[50];    /* vollst„ndiger Fontname, z.B. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* Name der Fontfamilie, z.B. "Century725 BT" */
   BYTE  style_name[50];   /* Name des Fontstils, z.B. "Italic" */
   BYTE  file_name1[200];  /* Name der 1. Fontdatei, z.B. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* Name der optionalen 2. Fontdatei */
   BYTE  file_name3[200];  /* Name der optionalen 3. Fontdatei */
   WORD  pt_cnt;           /* Anzahl der Punkth”hen fr vst_point(), z.B. 10 */
   WORD  pt_sizes[64];     /* verfgbare Punkth”hen,
                              z.B. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;

/* Funktionsprototypen */
void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len );
WORD  c_str_to_vdi( UBYTE *src, UWORD *des );
WORD  fix31_to_pixel( fix31 a );
void  vs_color( WORD handle, WORD index, RGB1000 *rgb_in );
WORD  vq_color( WORD handle, WORD color_index, WORD flag, RGB1000 *rgb_out );
WORD  vs_calibrate( WORD handle, WORD flag, RGB1000 *table );
WORD  vq_calibrate( WORD handle, WORD *flag );
void  v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out );
void  v_clsbm( WORD handle );
void  vq_scrninfo( WORD handle, WORD *work_out );
WORD  vq_devinfo2( WORD handle, WORD device, WORD *dev_exists, BYTE *file_name, BYTE *real_name );
WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                      BYTE *file_path, BYTE *file_name, BYTE *name );
WORD  vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format, UWORD *flags );
void  vst_width( WORD handle, WORD width, WORD *char_width, WORD *char_height,
                 WORD *cell_width, WORD *cell_height );
void  vst_track_offset( WORD handle, fix31 offset, WORD pair_mode, WORD *tracks, WORD *pairs );
void  vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string, WORD *extent );
WORD  vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index, XFNT_INFO *info );
WORD  vst_name( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name );
WORD  vqt_name_and_id( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name );

/* VDI-String in einen C-String umwandeln */
void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE) *src++;   /* nur das Low-Byte kopieren */
      len--;
   }
   *des++ = 0;                   /* Ende des Strings */
}

/* C-String in einen VDI-String umwandeln */
WORD  c_str_to_vdi( UBYTE *src, UWORD *des )
{
   WORD  len;

   len = 0;
   
   while (( *des++ = *src++ ) != 0 )
      len++;

   return( len );                /* L„nge des Strings ohne Null-Byte */
}

/* Positionsangabe in fix31-Darstellung in Pixel-Koordinate umrechnen */
WORD  fix31_to_pixel( fix31 a )
{
   WORD  b;

   b = (WORD) (( a + 32768L ) >> 16 ); /* runden !! */
   return( b );                        /* Pixelwert zurckgeben */
}

void  vs_color( WORD handle, WORD index, RGB1000 *rgb_in )
{
   intin[0] = index;
   intin[1] = rgb_in->red;
   intin[2] = rgb_in->green;
   intin[3] = rgb_in->blue;

   contrl[0] = 14;
   contrl[1] = 0;
   contrl[3] = 4;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );
}

WORD  vq_color( WORD handle, WORD color_index, WORD flag, RGB1000 *rgb_out )
{
   intin[0] = color_index;
   intin[1] = flag;

   contrl[0] = 26;
   contrl[1] = 0;
   contrl[3] = 2;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   *rgb_out = *(RGB1000 *) (intout + 1);
   return( intout[0] );
}

WORD  vs_calibrate( WORD handle, WORD flag, RGB1000 *table )
{
   *(RGB1000 **)intin = table;
   intin[2] = flag;

   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 3;
   contrl[5] = 76;
   contrl[6] = handle;

   vdi( &pb );

   return( intout[0] );
}

WORD  vq_calibrate( WORD handle, WORD *flag )
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 77;
   contrl[6] = handle;

   vdi( &pb );

   if ( contrl[4] > 0 )
   {
      *flag = intout[0];
      return( 1 );
   }
   else
   {
      *flag = 0
      return( 0 );
   }
}

void  v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out )
{
   /* Wenn work_in[15..19] 0 enthalten, wird eine Bitmap im ger„tespezifischen
      Format oder mit nur 1 Ebene erzeugt (h„ngt vom MFDB ab). Anderfalls wird
      versucht eine Bitmap mit der Farbanzahl <work_in[15..16]>, <work_in[17]>
      Ebenen, dem Pixelformat <work_in[18]> und der Bitreihenfolge <work_in[19]>
      anzulegen. Falls kein passender Offscreen-Treiber vorhanden ist, kann die
      Bitmap nicht ge”ffnet werden.
   */

   pb[1] = work_in;
   pb[3] = work_out;
   pb[4] = work_out + 45;

   contrl[0] = 100;
   contrl[1] = 0;
   contrl[3] = 20;
   contrl[5] = 1;
   *(MFDB *)&contrl[7] = bitmap;

   vdi( &pb );

   *handle = contrl[6];
   pb[1] = intin;
   pb[3] = intout;
   pb[4] = ptsout;
}

void  v_clsbm( WORD handle )
{
   contrl[0] = 101;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 1;
   contrl[6] = handle;
   vdi( &pb );
}

void  vq_scrninfo( WORD handle, WORD *work_out )
{
   pb[3] = work_out;

   intin[0] = 2;
   contrl[0] = 102;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi( &pb );

   pb[3] = intout;
}

WORD  vq_devinfo2( WORD handle, WORD device, WORD *dev_exists, BYTE *file_name, BYTE *real_name )
{
   contrl[0] = 248;                 /* Funktionsnummer */
   contrl[1] = 0;
   contrl[3] = 1;                   /* ID wird bergeben */
   contrl[5] = 0;
   contrl[6] = handle;
   intin[0] = device;               /* Ger„t */

   vdi( &pb );

   *dev_exists = 0;                 /* Treiber ist nicht vorhanden */
   *file_name = 0;
   *real_name = 0;

   if ( contrl[4] && intout[0] )    /* Treiber vorhanden? */
   {
      WORD  i;
      WORD  len;

      *dev_exists = 1;              /* Treiber ist vorhanden */

      for ( i = 0; i < contrl[4]; i++ )
      {
         *file_name = (BYTE) intout[i];
         if ( *file_name == ' ' )    /* Trennung durch Leerzeichen? */
         {
            /* letztes Leerzeichen? */
            if (( i < contrl[4] ) && ( intout[i+1] != ' ' ))
            {
               *file_name = '.';    /* Leerzeichen ersetzen */
               file_name++;
            }
         }
         else
            file_name++;
      }
      *file_name++ = 0;             /* Endeeeee */

      if (( contrl[2] == 1 ) && ( contrl[1] > 0 )) /* !?+*~"İ)%&#/(^= */
         len = contrl[1];
      else
         len = contrl[2] - 1;

      for ( i = 1; i <= len; i++ )  /* Klartextnamen kopieren */
         *((WORD *)real_name)++ = ptsout[i];
      *real_name++ = 0;             /* sicherheitshalber */
   }

   return( ptsout[0] );             /* Treiber ge”ffnet oder nicht */
}

WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                      BYTE *file_path, BYTE *file_name, BYTE *name )
{
   intin[0] = device;
   *(BYTE **)&intin[1] = file_path;
   *(BYTE **)&intin[3] = file_name;
   *(BYTE **)&intin[5] = name;

   contrl[0] = 248;
   contrl[1] = 0;
   contrl[3] = 7;
   contrl[5] = 4242;
   contrl[6] = handle;

   vdi( &pb );

   *dev_exists = intout[0];
   return( intout[1] );
}

WORD  vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format, UWORD *flags )
{
   intin[0] = index;
   intin[1] = 0;

   contrl[0] = 130;
   contrl[1] = 0;
   contrl[3] = 2;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi( &pb );

   vdi_str_to_c( (UWORD *)&intout[1], (UBYTE *) name, 31 );

   if ( contrl[4] <= 34 )
   {
      *flags = 0;
      *font_format = 0;
      if ( contrl[4] == 33 )
         name[32] = 0;
      else
         name[32] = (BYTE) intout[33];
   }
   else
   {
      name[32] = (BYTE) intout[33];
      *flags = (intout[34] >> 8) & 0xff;
      *font_format = intout[34] & 0xff;
   }

   return( intout[0] );
}

void  vst_width( WORD handle, WORD width, WORD *char_width, WORD *char_height,
                 WORD *cell_width, WORD *cell_height );
{
   ptsin[0] = width;

   contrl[0] = 231;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   *char_width = ptsout[0];
   *char_height = ptsout[1];
   *cell_width = ptsout[2];
   *cell_height = ptsout[3];
}

void  vst_track_offset( WORD handle, fix31 offset, WORD pair_mode, WORD *tracks, WORD *pairs )
{
   contrl[0] = 237;
   contrl[1] = 0;
   contrl[3] = 4;
   contrl[6] = handle;

   intin[0] = 255;
   intin[1] = pair_mode;
   *(fix31 *)&intin[2] = offset;

   vdi( &pb );

   *tracks = intout[0];
   *pairs = intout[1];
}

void  vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string, WORD *extent )
{
   WORD  len;
   WORD  i;

   ptsin[0] = x;
   ptsin[1] = y;

   len = c_str_to_vdi( (UBYTE *) string, (UWORD *) intin );

   contrl[0] = 240;
   contrl[1] = 1;
   contrl[3] = len;
   contrl[5] = 4200;
   contrl[6] = handle;

   vdi( &pb );

   for ( i = 0; i < 8; i++ )
      *extent++ = ptsout[i];
}

WORD  vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index, XFNT_INFO *info )
{
   info->size = (LONG) sizeof( XFNT_INFO );

   intin[0] = flags;
   intin[1] = id;
   intin[2] = index;
   *(XFNT_INFO **)&intin[3] = info;

   contrl[0] = 229;
   contrl[1] = 0;
   contrl[3] = 5;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   return( intout[1] );
}

WORD  vst_name( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name )
{
   WORD  len;

   intin[0] = font_format;
   len = c_str_to_vdi( (UBYTE *) font_name, (UWORD *)&intin[1] );

   contrl[0] = 230;
   contrl[1] = 0;
   contrl[3] = 1 + len;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   if ( ret_name )
      vdi_str_to_c( (UWORD *)&intout[1], ret_name, contrl[4] );

   return( intout[0] );
}

WORD  vqt_name_and_id( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name )
{
   WORD  len;

   intin[0] = font_format;
   len = c_str_to_vdi( (UBYTE *) font_name, (UWORD *) intin + 1 );

   contrl[0] = 230;
   contrl[1] = 0;
   contrl[3] = 1 + len;
   contrl[5] = 100;
   contrl[6] = handle;

   vdi( &pb );

   if ( ret_name )
      vdi_str_to_c( (UWORD *)&intout[1], ret_name, contrl[4] );

   return( intout[0] );
}


