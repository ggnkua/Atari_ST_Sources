

                       ππππππππππππππππππππππππππππππ
                              CHAPITRE nr¯ 2:
         
                       * PREMIERS PAS EN ASSEMBLEUR *
           
                       ππππππππππππππππππππππππππππππ



              *** UTILISATION LOGICIELLE DE L'ASSEMBLEUR ***
              ππππππππππππππππππππππππππππππππππππππππππππππ

 -   Comme  nous l'avons vu dans le chapitre prÇcÇdent, programmer en
     assembleur n'est possible qu'avec : un êDITEUR, un ASSEMBLEUR et
     un LINKER.

 1) l'êDITEUR:    .C'est l'êDITEUR qui permet la saisie de votre listing:
    ππππππππππ
                   Vous  Çcrirez  votre  programme grÉce aux fonctions de
                   l'Çditeur. L'Çditeur sauvera et chargera vos listings.

                   Les fichiers sauvÇs sont des fichiers ASCII (tout com-
                   me les fichiers de ce livre digital) et peuvent ätre
                   modifiÇs Ö volontÇ avec l'Çditeur.

                   Un tel fichier est nommÇ CODE SOURCE.

                   Les fonctions de l'Çditeur varient avec l'utilitaire
                   (DEVPAC,METACOMCO,PROFIMAT...) et simplifient l'entrÇe
                   du texte (listing).

                  .Un fichier issu d'un Çditeur ne peut pas àtre executÇ!

                   Il faudra d'abord l'ASSEMBLER puis le LINKER.


 2) l'ASSEMBLEUR .l'ASSEMBLAGE constitue la deuxiäme Çtape:
    ππππππππππππ
                  Les codes ASCII (texte) du listing sonts traduits par
                  l'Assembleur et sont convertis (codÇs) en BINAIRE (le
                  binaire est reconnu directement par l'ordinateur,con-
                  trairement au texte ASCII)

                  Le fichier (listing) une fois traitÇ (AssemblÇ) est
                  sauvÇ sur la disquette  sous le format d'un fichier
                  en BINAIRE appelÇ CODE OBJET.

3) le LINKER     .l'êDITION DE LIENS est la derniäre Çtape:
   πππππππππ
                  Le CODE OBJET est chargÇ et le LINKER intägrera les
                  MACROS INSTRUCTIONS qui constituent la bibliothäque
                  si le fichier SOURCE le demandait. -->

                                    πππππππππππππ
Je m'explique:
ππππππππππππππ
  .En assembleur vous pouvez creÇr des MACRO-INSTRUCTIONS
   (voir chapitre prÇcÇdent).

  .Une MACRO n'est rien d'autre qu'une nouvelle instruction (paramÇtrable)
   qui sera incluse par le LINKER chaque fois qu'il rencontrera son nom
   dans le CODE OBJET.

Un exp:
πππππππ
  .Vous crÇez une MACRO qui affiche 'SALUT' sur l'Çcran:

   Cette MACRO dÇlimite en rÇalitÇ un PROGRAMME dont la fonction
   est d'afficher 'SALUT' sur l'Çcran et vous la nommez 'ECRIS':

             dÇbut de la Macro

   ECRIS     .
             .
             .                      le listing qui permet d'afficher
             .                      'SALUT' sur l'Çcran
             .

             Fin de la Macro  
  
   Chaque fois que le LINKER rencontrera 'ECRIS' (le nom de la MACRO) ,
   dans le CODE OBJET, il reÇcrira la portion de programme 'ECRIS' Ö la 
   place de la MACRO.

     .Une MACRO n'est donc pas un sous-programme, elle permet juste une
      une meilleur lisibilitÇ dans le listing.

     .Une macro sera reÇcrite entiärement Ö chaque appel: On perd donc
      un peu plus de MêMOIRE , mais c'est bien plus rapide qu'un sous-
      programme.

     .Les Macros permettent une meilleur lisibilitÇ du listing puisque
      Vous n'avez plus Ö taper la ROUTINE correspondant au nom de la
      Macro, le Linker s'en charge.

  .Vous pouvez donc vous crÇer une BIBLIOTHEQUE de MACROS ( c.Ö.d. des
   fichiers  dÇfinissant  des  MACROS ) pour les appeler quand vous en 
   aurrez besoin dans votre listing...

   Le LINKER s'occupe de charger les MACROS utilisÇes dans le listing
   (si le listing en contient...) et de les reÇcrires entiärement.

   Il suffira d'indiquer (au dÇbut du listing) le nom du fichier qui
   contient les MACROS utilisÇes, ou de dÇfinir les MACROS utilisÇes
   au dÇbut du listing.
                            (NOUS VERRONS COMMENT EN DêTAIL ...)

  .Nous,nous crÇerons des MACROS pour les fonctions du GEM,de l'XBIOS,
   du BIOS et du VDI ( Des MACROS qui se chargent d'appeler les fonc-
   tions dÇsirÇes en passant les paramätres nÇcessaires pour plus de
   rapiditÇ et de convivialitÇ )

                                   ππππππππππππππ

                .le LINKER crÇera aussi la PAGE DE BASE, qui contient
                 des renseignements sur le prg indispensables au sys-
                 täme d'exploitation pour pouvoir charger et executer
                 le prg LINKê.
                 VoilÖ pourquoi le LINKAGE est indispenssable mäme si
                 le listing ne contient pas de Macros.
                 
                      (Je dÇtaillerais quand je parlerais du GEMDOS)


                .Le fichier ainsi obtenu sera sauvÇ et pourra ätre 
                 executÇ.



 RêSUMê:
 ππππππ
     * êDITEUR *              * ASSEMBLEUR *              * LINKER *

      |listing|    ------->    |code objet|   -------> |prg executable|





                    *** QUELQUES NOTIONS êLêMENTAIRES ***
                    πππππππππππππππππππππππππππππππππππππ

VoilÖ quelques notions TRêS IMPORTANTES:

1)  le BINAIRE: 
    πππππππππππ
 .         Habituellement, pour calculer, on utilise un systäme dÇcimal,
  c.Ö.d. que ce systäme est composÇ de 10 chiffres: 0,1,2,3,4,5,6,7,8,9
  :C'est une BASE de 10.

  Si on dÇsire exprimmer un ensemble dont la quantitÇ dÇpasse 9: on aug-
  mente le chiffre d'une unitÇ et on obtient un nombre:10,11,12,13,14...

 .Le systäme BINAIRE (ou de BASE 2),est composÇ de 2 chiffres: 0 et 1

   Ainsi, si on veut exprimmer un ensemble dont la quantitÇ dÇpasse 1
   ( c.Ö.d. >1 en systäme dÇcimal !! ) on augmente d'une unitÇ.

Donc:
VoilÖ comment on compte en BINAIRE:0,1,10,11,100,101,111,1000,1001,1011...

.On SUPPOSERA que toute composante de la mÇmoire de l'ordi est reprÇsentÇe
 (ou codÇe) en BINaire.

.On nomme le 0 et le 1 du systäme BINaire prÇsent dans les composantes de
 la structure de l'ordi par BIT.

.Un BIT peut ätre nul (ou Çteint):0    OU     activÇ (ou encore allumÇ):1
                                       ππ
.Le BIT est donc la plus petite structure modifiable et reconnaissable 
 par l'ordi.

.On dÇfinit par OCTET un groupe de 8 BITS. (L'OCTET est aussi appelÇ BYTE 
 en Anglais, ne le confondez pas avec 'bit' !)

.On dÇfinit par  MOT un groupe de 2 OCTETS (donc de 16 BITS)

.On dÇfinit par LONG MOT un groupe de 2 MOTS (donc de 4 OCTETS ou 32 BITS)

.Ces regroupements sont arbitraires et conscernent des BITS consÇcutifs
 (qui se suivent) en mÇmoire.

 CONSêQUENCES: Les composantes internes de l'ordi. peuvent àtre exprimÇes
 ππππππππππππ en BITS,OCTETS,MOTS ou LONGS MOTS.

RêSUMê:
πππππππ
-  Un BIT prend soit la valeur 1 (activÇ) soit la valeur 0 (Çteind)
      πππ
-  Un OCTET est un groupe de 8 BITS consÇcutifs en mÇmoire
      πππππ
-  Un MOT est un groupe de 2 OCTETS consÇcutifs en mÇmoire
      πππ
-  Un LONG MOT est un groupe de 2 MOTS consÇcutifs en mÇmoire
      ππππππππ
Pour schÇmatiser, on pourrait dire que la mÇmoire de l'ordi. est composÇe
d'une multitude de petites cases (BITS) pouvant prendre soit 1 soit 0 com-
me valeurs suivant les actions du Microprocesseur et pouvant ätres regrou-
pÇes (arbitrairement) sous la forme d'OCTETS, de MOTS ou de LONGS MOTS.

EXP:
πππ         {    0                                est un BIT
extraits de {    01011101                         est un OCTET, ou 8 BITS
  mÇmoire   {    0101110111010110                 est un MOT,  ou 16 BITS
            {    01011101110101101000100100101101 est un LONG MOT,ou 32 B


2) L'HEXADECIMAL:
   πππππππππππππ
 .l'HEXADECIMAL est un systäme de BASE 16,les 16 composantes de ce systäme
  sont:0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F

  Ainsi, pour exprimer un ensemble dont la quantitÇ dÇpasse F (soit 16 en
  BASE de 10), on change d'unitÇ: 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,10,11,12,
  ,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20,21,22...

  Comme vous pouvez le constater, la vÇritable utilitÇ de ce systäme est
  qu'un grand nombre est reprÇsentÇ par un minimum de chiffres.


 .Un OCTET est reprÇsentÇ en HEXA. par 2 chiffres 

 .Un MOT est reprÇsentÇ en HEXA. par 4 chiffres

 .Un LONG MOT est reprÇsentÇ en HEXA. par 8 chiffres 


 3) NOTATIONS:
    ππππππππππ
-      Dans un listing en ASS. ,les chiffres codÇs  en BINaire sont 
  reprÇsentÇs avec le prÇfixe ' % ', ceux codÇs en HEXAdÇcimal avec
  le prÇfixe ' $ '.

  ( L'utilisation de la BASE de 10 n'a pas besoin d'ätre indiquÇe )

  Apräs le Linkage, tous les chiffres seront automatiquement codÇs en
  HexadÇcimal.

EXP:           %01001011   est un chiffre codÇ en BINAIRE (et un OCTET)
ππππ           $1F0A       est un chiffre codÇ en HEXA.   (et un MOT)
                101001     est un chiffre codÇ en DêCIMAL !


 4) REMARQUES:
    ππππππππππ
 -  Le BIT le plus Ö gauche d'un OCTET,d'un MOT,d'un LONG MOT est appellÇ
    M.S.B ( Most Significant Bit ) ou Bit de plus fort poids.

 -  C'est ce bit qui permet de signer ( positif / nÇgatif ) un nombre.
    Il est activÇ pour un nombre nÇgatif.

 -  Il n'est utilisÇ que pour signer un nombre !

  EXP:  $FFFFFFFF est un L-M qui vaut -1 en dÇcimal
  ππππ  %1111111111111111 est un MOT qui vaut -1 en dÇcimal
        %11111110 est un OCTET qui vaut -2 en dÇcimal et
        %00000010 en est un qui vaut 2:Pour inverser le signe de l'OCTET,
         on a donc 'prolongÇ' le 1 le plus Ö gauche jusqu'au MSB.

  :Exemples träs thÇoriques, pas de panique,ce n'est pas vraiment utile
   en pratique (et màme franchement inutile, je vous rassure...) car il
   existe des instructions qui font toutes sortes d'opÇrations sur les
   BITS,OCTETS,MOTS et L-M... (et personne ne vous oblige Ö travailler en
   systäme Binaire!)

  - D'apräs nos dÇfinitions: (le MSB n'est utilisÇ que pour signer le bit,
                              l'octet,le mot ou le long-mot)

             donc:            *         -2^7  Û OCTET < 2^7
                                        -128  Û OCTET < 128

                              *        -2^15  Û  MOT  < 2^15
                                       -32768 Û  MOT  < 32768

                              *        -2^31  Û  L-M  < 2^31
                                  -2147483648 Û  L-M  < 2147483648

  áa par contre, c'est Ö retenir: Les dÇbordements (OCTET trop grand...)
  provoquent des erreurs.

 5) RêCAPITULATION:
     πππππππππππππππ
 .Une composante de la structure de l'ordi. : REGISTRE,VARIABLE... (termes
  expliquÇs bientot) peut prendre la forme de BIT,OCTET,MOT ou LONG MOT.

  En thÇorie... Nous Çtudierons les exceptions:Le choix est plus limitÇ en
                rÇalitÇ.


    CONSêQUENCES:   .Une VARIABLE dÇfinie en tant que MOT ne pourra donc
    πππππππππππππ    pas avoir une valeur supÇrieure Ö 32768. (par exp.)

              NB:    Cette variable ne pourra qu'ätre un Long Mot (Si sa
              πππ    valeur peut àtre contenue dans un L-M , sinon cela
                     provoquerait une erreur puisque l'ordi ne reconnait
                     pas de composante dont la quantitÇ depasse le L-M.)
                     (en thÇorie...)

       REMARQUES:   .Une Variable pouvant ätre contenue dans un OCTET,
       ππππππππππ    donc dont la valeur est <128 peut aussi ätre con-
                     tenue dans un MOT ou un L-M.

                     Mais il faut faire attention Ö ce que la composante
                     (ici la variable) puisse ätre dÇfinie sur un MOT ou
                     un L-M (Dans cet exemple prÇcis, c'est possible)

                    .Il faudra donc pour chaque composante de la structure
                     interne de l'ordi. indiquer les diffÇrentes formes
                     qu'elle peut prendre (BIT,OCTET,MOT,L-M...).

                     Nous le feront avec prÇcision.

  C'est pour cela qu'il faudra savoir les diffÇrentes formes que peut 
  prendre ce que nous utilisons pour programmer (Registres,variables...)
  et aussi par quoi sont dÇfinit ces formes (BIT,OCTET...).
  VoilÖ pourquoi l'Assembleur est träs stricte dans sa programmation.


6) IMPORTANT:
   ππππππππππ

Les ensembles tels que les OCTETS,MOTS,L-M sont composÇs de BITS,ces BITS
sont numÇrotÇs ainsi (dans les OCTETS,MOT,L-M,REGISTRES,VARIABLES...):

                        De la DROITE vers la GAUCHE.

     31 30 .  .  .     .  .  . 15  .  .  .  9  8  7  6  5  4  3  2  1  0
    [*][ ][.][.][.][ ][ ][ ][ ][*][.][.][.][ ][ ][*][ ][ ][ ][ ][ ][ ][*]

 - Un OCTET est donc numÇrotÇ de la droite vers la gauche de 0 Ö 7

 - Un MOT , de 0 Ö 15

 - Un L-M , de 0 Ö 31

 - Le BIT 0 est le bit de PLUS FAIBLE POIDS (ou LSB:Least significant Bit)

 - Le BIT 7 (15 pour un MOT,31 pour un L-M) est le bit de POIDS le plus
   FORT (ou MSB)

   AINSI:
   ππππππ                     <-----------  poids FORT

                     31<-- ...[][][][][][][][][][][][][]...  -->0

                               poids FAIBLE ---------->

   DONC: Un MOT est composÇ de 2 OCTETS, un de poids FAIBLE (bits 0 Ö 7) et
   πππππ un de poids FORT: (bits 8 Ö 15)

         Un L-M est composÇ de 2 MOTS, un de poids FAIBLE (bits 0 Ö 15) et
         un de poids FORT (bits 16 Ö 31)

                           CETTE NOTION EST FONDAMENTALE 
                           πππππππππππππππππππππππππππππ


                              *** LA MêMOIRE ***
                              ππππππππππππππππππ

 - On admettra que la mÇmoire est une suite de nombres codÇs en BINaire.

    :Nous savons maintenant que ces nombres peuvent ätres regrouppÇs en
     OCTETS,MOTS,L-M.

 -      La programmation en assembleur permet de changer le contenu 
        de la mÇmoire.

.La mÇmoire est changÇe quand l'ordinateur effectue une tÖche (un calcul,
 une recherche quelconque...).
 Dans ce cas, l'ordi. s'occupe  d'ordonner sa mÇmoire , c'est en fonction
 de cet ordre que telle ou telle action se produit,l'utilisateur n'inter-
 vient donc pas: C'est ce qui se passe Ö chaque instant, un ordinateur 
 n'est donc jamais au repos (il verifie si on change de disquette,efface
 l'ecran cinquante fois par seconde).

. La mÇmoire de l'ordi. peut aussi àtre changÇe par l'utilisateur,c'est le
 but de la programmation.La consÇquence en est un Çtat prÇvu (programmÇ)
 de la mÇmoire,donc telle ou telle action est effectuÇe.
 Ceci est possible en utilisant des instructions propres au langage uti-
 lisÇ ou en modifiant directement une portion de la mÇmoire.Cette derni-
 äre opÇration s'effectue träs facilement en ASSembleur et avec une prÇ-
 cision de l'ordre du BIT.
 On peut donc DÇplacer un OCTET,un MOT, un L-M (qu'on aura pu dÇfinir)
 dans la mÇmoire.(lÖ oó c'est possible...)

 Pour se repÇrer dans la vaste mÇmoire de notre ordi. , on a dÇcoupÇ la
 mÇmoire et on a nommÇ chaque portion de la mÇmoire par une ADRESSE (com-
 me pour des Adresses dans une rue...)

 ThÇoriquement, il serait possible de mettre un BIT,OCTET,MOT ou L-M Ö
 n'importe quelle ADRESSE, mais en rÇalitÇ ceci n'est pas possible.

     - L'utilisateur n'a accäs qu'Ö une partie de la mÇmoire.
       (nous verrons laquelle)

     - Il faut tenir compte de la paritÇ et de l'imparitÇ des ADRESSES:
       On ne peut pas mettre n'importe quoi Ö n'importe quelle adresse.

 EN EFFET: Si on SCHêMATISE la structure de la mÇmoire, celle-ci ressemble 
 ππππππππ  Ö une bande de longueur limitÇe (dÇbut et fin) et d'une LAR-
           GEUR de 16 BITS, dont les diffÇrentes parties sont numÇrotÇes 
           ADRESSêES) tout les 8 BITS. (Ö chaque OCTET)




                             etc...

              bits: 15        7        0
              πππππ .|        |        |
                  x-2|--------|--------|
        |           x|10001011|--------|   OCTET :10001011 Ö l'adresse x
        |         x+2|--------|10001101|   OCTET :10001101 en x+3 octets
        |         x+4|--------|--------|
        |         x+6|00101100|10110011|   MOT  :0010110010110011
        |           .|--------|--------|         en x+6 octets
       \|/          .|--------|--------|
        '        x+12|11011111|01110100|   L-M  :110111110111010001011011-
     SENS des       .|01011011|01110100|         01110100
     adresses       .|--------|--------|         en x+12 octets
    CROISSANTES     .|--------|--------|
    πππππππππππ  x+20|--------|-------1|   BIT  :1  Ö l'adresse x+21 octets
        |           .|--------|--------|
        |           .|OCT FORT| FAIBLE |
       \|/          .|ππππππππ| ππππππ |
        '           15        7        0

                             ETC...

                          +-------+
                          |MêMOIRE| : ( Exemple d'organisation )
                          +-------+


- Observez bien cet exemple, il est träs simple Ö comprendre et ce schÇma
  devra àtre dans votre täte Ö chaque fois que vous programmerez en ASS.

- Vous pouvez constater que:

             * La mÇmoire est adressable au niveau de l'octet *
               ππππππππππππππππππππππππππππππππππππππππππππππ
      *    :Entre 2 adresses diffÇrentes X et X+1 ou X-1, il y a   *
      *     8 BITS ou un OCTET.                                    *

                     bits n¯ 7  6  5  4  3  2  1  0

            X-1  ---------->
                            [ ][ ][ ][ ][ ][ ][ ][ ]
            X    ---------->
                            [ ][ ][ ][ ][ ][ ][ ][ ]
            X+1  ---------->
                            [ ][ ][ ][ ][ ][ ][ ][ ]


       * La mÇmoire peut ätre reprÇsentÇe comme un PUITS dans lequel on
         JETTE des donnÇes:BITS,OCTET,MOTS,L-M:

         La largeur de ce puit est d'un MOT (soit 16 Bits)
         La profondeur dÇpend de la taille de la mÇmoire.

         Le but du jeu:  Jetter nos donnÇes dans le puit sans dÇformer
                         les donnÇes.

   c.Ö.d: Si vous y jettez un MOT: 1010101110110110 (=2 octets,1 de
          poids fort (Ö droite) et un de poids faible (Ö gauche) ) Ö
          une adresse x paire.


                      1010101110110110
                             |
                            \|/

                    |--------|--------|
  ADRESSES PAIRES   |--------|--------|  ADRESSES IMPAIRES
  πππππππππππππππ   |--------|--------|  πππππππππππππππππ
           bit nr¯ 15        7        0

                   
                       vous obtenez:

  ADRESSES PAIRES  x|10101011|10110110|  ADRESSES IMPAIRES
  πππππππππππππππx+2|--------|--------|  πππππππππππππππππ
                    |--------|--------|
           bit nr¯ 15        7        0

               - Le MOT a ÇtÇ posÇ Ö l'adresse x (PAIRE)

               . L'Oct de poids FORT est Ö l'adresse x (PAIRE)
               . L'Oct de poids FAIBLE Ö l'adresse x+1 (IMPAIRE)


            par contre, si vous jetez ce mot Ö une adresse impaire:



                               10101011
                      10110110
                              |
                             \|/

                     |--------|--------|
  ADRESSES PAIRES    |--------|--------|    ADRESSES IMPAIRES
  πππππππππππππππ    |--------|--------|    πππππππππππππππππ
            bit nr¯ 15        7        0

                   
                   
                        vous obtenez:

                  x-3|--------|--------|
  ADRESSES PAIRES x-1|--------|10101011|x   ADRESSES IMPAIRES
  πππππππππππππππ    |10110110|--------|x+2 πππππππππππππππππ
                     |--------|--------|
            bit nr¯ 15        7        0


               - Le MOT a ÇtÇ posÇ Ö l'adresse x (IMPAIRE)

               . L'Oct de poids FORT est Ö une adresse IMPAIRE :x
               . L'Oct de poids FAIBLE Ö une adresse PAIRE     :x+1

            Dans ce cas, on ne respecte plus les rägles de notre 'jeu'
            Si on devait jeter un autre MOT Ö l'adresse x-3 dans notre
            puits, son Oct FORT ne pourrait pas se maintenir et dÇgrin-
            golerait en x-1!

            ATTENTION,en rÇalitÇ ceci ne se produirait pas, Je simplifie
            seulement mon explication...

     En fait, pour pouvoir dÇplacer (poser) des MOTS dans la mÇmoire, il
     faut veiller Ö ce que l'adresse de destination soit PAIRE!

            Pour notre exemple, il faut donc poser le MOT sous cette
            forme dans la mÇmoire (dans notre 'puits')

                        +----------------+
                        |1010101110110110|
                        +----------------+
                                 |
                                \|/

                        |--------|--------|
  ADRESSES PAIRES      x|10101011|10110110|x+1   ADRESSES IMPAIRES
  πππππππππππππππ       |--------|--------|      πππππππππππππππππ
               bit nr¯ 15        7        0

                  .L'Oct de poids FORT (10101011) est Ö l'adresse x
                   qui est PAIRE

                  .L'Oct de poids FAIBLE (10110110) est Ö l'adresse x+1
                   qui est IMPAIRE


            * Il en est de mäme lorsqu'il s'agit d'un L-M:
              ππππππππππππππππππππππππππππππππππππππππππππ

       VoilÖ comment poser un L-M, lÖ aussi il faut que l'adresse de
       destination soit PAIRE, pour  Çviter les mÇmes  complications
       que dans notre exemple prÇcÇdent.



                        +-----------------+
                        |1110001001100100-|
                        |1010110011010001 |
                        +-----------------+
                                 |
                                \|/

                        |--------|--------|
  ADRESSES PAIRES       |--------|--------|      ADRESSES IMPAIRES
  πππππππππππππππ       |--------|--------|      πππππππππππππππππ
                       x|11100010|01100100|x+1
                     x+2|10101100|11010001|x+3
                        |--------|--------|
               bit nr¯ 15        7        0

                  .Le MOT de poids FORT (1110001001100100) est Ö
                   l'adresse x ,qui est PAIRE

                  .Le MOT de poids FAIBLE (1010110011010001) est Ö
                   l'adresse x+2 ,qui est PAIRE


            * Pour un OCTET ou un BIT
              πππππππππππππππππππππππ

                 - La paritÇ n'a plus d'importance!

      Ainsi, pour un Octet: on a:
             ππππππππππππππ

                      01000110
                          |
                         \|/

                     |--------|--------|
  ADRESSES PAIRES   x|01000110|--------|x+1   ADRESSES IMPAIRES
  πππππππππππππππ    |--------|--------|      πππππππππππππππππ
            bit nr¯ 15        7        0


                     .L'Oct (01000110) est Ö une adresse x ,PAIRE

           OU:
           ππ
                              01000110
                                  |
                                 \|/

                     |--------|--------|
  ADRESSES PAIRES x-1|--------|01000110|x     ADRESSES IMPAIRES
  πππππππππππππππ    |--------|--------|      πππππππππππππππππ
            bit nr¯ 15        7        0


                     .L'Oct (01000110) est Ö une adresse x ,IMPAIRE


             Pour un BIT: on a
             ππππππππππππ


                         0
                         |
                        \|/

                     |--------|--------|
  ADRESSES PAIRES   x|-------0|--------|x+1   ADRESSES IMPAIRES
  πππππππππππππππ    |--------|--------|      πππππππππππππππππ
            bit nr¯ 15        7        0


                     .Le BIT (0) est Ö une adresse x ,PAIRE

          OU:
          πππ


                                  0
                                  |
                                 \|/

                     |--------|--------|
  ADRESSES PAIRES x-1| -------|-------0|x     ADRESSES IMPAIRES
  πππππππππππππππ    |--------|--------|      πππππππππππππππππ
            bit nr¯ 15        7        0


                     .Le BIT (0) est Ö une adresse x ,IMPAIRE




                          *** RêCAPITULATION ***
                          ππππππππππππππππππππππ

 * Un BIT peut ätre, soit Ö une adresse PAIRE, soit Ö une adresse IMPAIRE
      πππ                               πππππ                     πππππππ
 * Un OCTET peut ätre, soit Ö une adresse PAIRE, soit une adresse IMPAIRE
      πππππ                               πππππ                   πππππππ
 * Un MOT est toujours situÇ Ö une adresse PAIRE en mÇmoire
      πππ                                  πππππ
 * Un L-M est toujours situÇ Ö une adresse PAIRE en mÇmoire
      πππ                                  πππππ
   ( Le non respect de cette rägle entraine un 'plantage' de l'ordi ! )

 * STRUCTURE de la MêMOIRE:
                   ππππππππ


                            etc...
              bits: 15        7        0
              πππππ .|        |        |
                  x-2|--------|--------|x-1
        |           x|00001011|--------|  OCTET :00001011 Ö l'adresse x
        |         x+2|--------|10110010|  OCTET :10110010 en x+3 octets
        |         x+4|--------|--------|         (impaire)
        |         x+6|10001011|10110110|  MOT  :1000101110110110
        |           .|--------|--------|        en x+6 octets (paire)
       \|/          .|--------|--------|
        '        x+12|01101100|00000000|  L-M  :011011000000000010111010-
     SENS des       .|10111010|01110111|        01110111
     adresses       .|--------|--------|        en x+12 octets (paire)
    CROISSANTES     .|--------|--------|
    πππππππππππ  x+20|--------|-------1|  BIT  :1  Ö l'adresse x+21 octets
        |           .|--------|--------|           (impaire)
        |           .|oct FORT| FAIBLE |
       \|/          .|ππππππππ| ππππππ |
        '           15        7        0
                     |       etc...    |
 Adresses PAIRES     |        |        |     Adresses IMPAIRES
 πππππππππππππππ                             πππππππππππππππππ
                          +-------+
                          |MêMOIRE|
                          +-------+

              Exemple d'organisation de la mÇmoire.
              πππππππππππππππππππππππππππππππππππππ
                 (Octets,Mots,L-M,Bits fictifs)





                   *** ORGANISATION DE LA MêMOIRE ***
                   ππππππππππππππππππππππππππππππππππ

- On distingue: .L'espace programme, qui contient les instructions de vos
                 programmes codÇes en BINaire.

                .L'espace donnÇes, qui contient les donnÇes du prg et les
                 zones de la mÇmoire que vous avez initalisÇ. (en BIN)

                .Ces 2 zones sont dans la mÇmoire vive (RAM), on ne peut
                 pas Çcrire sur la mÇmoire morte (ROM) car elle contient
                 tous les renseignements dont l'ordi a besoin pour fonc-
                 tionner correctement.
                 La RAM est la mÇmoire disponible en Çcriture au progra-
                 mmeur (elle peut bien sur aussi àtre effacÇe.)

                 On dispose d'environ 512 Ko de mÇmoire vive sur un 520ST
                 (un Kilo Octet=1024 Octets.) et d'1 MÇga Octet soit 1024
                 Ko sur un 1040ST.   




                        πππππππππππππππππππππππ

- Vous voilÖ pràts Ö prÇsent Ö commencer la programmation proprement dite:
  retenez bien tout ce qui a ÇtÇ dit ici (notez le quelquepart si vous le
  jugez utile), relisez encore une fois  si la tàte vous tourne, car dans
  le prochain chapitre, les choses sÇrieuses commencent.





     PIECHOCKI Laurent
     8,impasse Bellevue                           Suite dans DEBUTS.DOC
     57980 TENTELING                                         ππππππππππ


