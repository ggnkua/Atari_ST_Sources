
                           πππππππππππππππππππππ
                             CHAPITRE   nr¯ 5:  

                             *** LE GEMDOS ***

                            ππππππππππππππππππππ


 
                      *** LES FONCTIONS DU GEMDOS ***
                      πππππππππππππππππππππππππππππππ

- Les fonctions du GEMDOS peuvent àtre directement appelÇes en ASS.,
  il suffit:

   .De passer les paramätres dont la fonction Ö besoin dans la pile
    systäme (MOTS ou L-M).
  
   .De passer le code de la fonction dans la pile systäme.(MOT)

   .D'appeller le GEMDOS avec un  TRAP #1 


- Il en est d'ailleurs de màme pour les fonctions du BIOS et de l'XBIOS.
  ( Seul le nr¯ du TRAP change : TRAP #13 pour le BIOS et TRAP #14 pour
  l'XBIOS )

- ATTENTION !  Les fonctions du GEMDOS,BIOS et XBIOS donnent souvent des
  informations en retour: dans certains registres de donnÇes et certains
  registres d'adresses.
  Il faudra veiller Ö sauvegarder les registres conscernÇs avant 
  d'appeler une de ces fonctions pour ne pas perdre leur contenu.
  (avec MOVEM par exp.)

- Avant d'utiliser les fonctions du GEMDOS,BIOS et de l'XBIOS, il faudra
  rÇserver une certaine quantitÇ de mÇmoire car lorsque le systäme d'ex-
  ploitation lance votre programme, on doit allouer la quantitÇ de mÇmoire
  dont le programme a rÇellement besoin.
  (Pour Çviter les chevauchements de donnÇes en mÇmoire)
  Le systäme d'exploitation (le Bureau GEM) va lire la PAGE de BASE qui
  se trouve en tàte de votre programme .PRG (cf le chapitre INTRODUCTION)
  avant de l'Çxecuter.
  Cette PAGE de BASE a une taille de $100 (256) octets et contient toutes
  les informations dont le systäme d'exploitation a besoin pour le char-
  gement du PRG, mais c'est Ö nous d'indiquer la taille de la mÇmoire
  qu'il faudra qu'il rÇserve.
  Apräs le chargement du programme, SP pointe sur la PAGE de BASE, on 
  pourra donc facilement lire les diffÇrentes donnÇes que contient la
  PAGE de BASE en incrÇmentant SP par exemple.

  Organisation de la PAGE de BASE:
                     ππππππππππππ
  Octet:$00=DÇbut de la Page de Base
  πππππ $04=Pointeur de la fin de la mÇmoire libre
        $08=Pointeur du dÇbut du prg
        $0C=Taille de la zone TEXT
        $10=Pointeur sur la zone DATA
        $14=Taille de la zone DATA
        $18=Pointeur sur la zone BSS
        $1C=Taille de la zone BSS
        $20=Pointeur du tampon DTA
        $24=Pointeur de la page de base du PRG appelant (päre)
        $80=La ligne de commande

  Pour indiquer la taille de la mÇmoire Ö rÇserver, il existe une fonction
  du GEMDOS, les paramätres Ö passer sont:

  .le nombre d'OCTETS Ö rÇserver (L-M)
  .Un L-M qui est le pointeur de la fin de la mÇmoire libre
  .un MOT Çgal Ö 0
  
  Le code de la fonction est $4A (fonction 'SETBLOCK')

  Pour trouver le nombre d'octets Ö rÇserver (la taille totale du PRG) 
  grÉce Ö la Page de Base, on additionne:

  .La taille de la Page de Base ($100 octets)
  .La place occupÇe par les instructions (L-M en $C(SP) car SP pointe sur
   le dÇbut de la page de base)
  .La taille de la zone DATA (L-M en $14(SP) )
  .La taille de la zone BSS  (L-M en $1C(SP) )
  
  On pose le rÇsultat dans un registre dn et on le pose comme paramätre
  (L-M) dans la pile systäme (MOVE.L  dn,-(SP) ) suivit d'un L-M qui est
  le pointeur de la fin de la mÇmoire libre et d'un MOT Çgal Ö 0: 
  (MOVE  #0,-(SP) ) 
  Puis on empile le code de la fonction SETBLOCK :MOVE  #$4A,-(SP)
  et on appelle le GEMDOS avec TRAP #1.

  Cette initialisation devra àtre faite au dÇbut de tout programme.
  ππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππ
  Pour Çviter de tout retaper Ö chaque fois, nous allons crÇer une
  MACRO INSTRUCTION qui le fera Ö notre place.

  On dÇlimite une MACRO par les directives:
  
  MACRO (Apräs le nom de la Macro pour marquer le dÇbut de la MACRO)
  πππππ
  ENDM  (A la fin de la MACRO pour marquer la fin de celle-ci)
  ππππ

     Exp: Une MACRO nommÇe AJOUTE qui additionne les mots de poids faibles
     ππππ des registre d0 et d1 s'Çcrira:


        TEXT

ajoute  MACRO            ;dÇbut de la macro
        ADD.W    d0,d1   ;la Macro proprement dite
        ENDM             ;Fin de la Macro

    ; Cette MACRO pourra ensuite àtre utilisÇe:

        MOVE     #3,d0
        MOVE     #5,d1
        ajoute           ;appel de la MACRO 'ajoute'
        MOVE     d1,res

        BSS

res     DS.W     1       ;On trouvera le mot 5+3=8 en 'res'

        END

  La MACRO pourra àtre utilisÇe aussi souvent que vous le dÇsirez, mais
  il faudra veiller Ö ne pas mettre de Labels dans votre MACRO car ils
  seraient reÇcrits plusieurs fois et ceci provoquerait des erreurs...

  On peut ensuite sauver la MACRO dans un fichier.

  Pour indiquer au LINKER que vous allez utiliser une MACRO qui se trouve
  dans un fichier externe, il faudra utiliser la DIRECTIVE:

  INCLUDE   "fichier.xxx"
  πππππππ
  Il faudra l'utiliser avant que la premiäre MACRO de 'fichier.xxx' soit
  utilisÇe. 
  Tout le fichier sera ASSEMBLê Ö part, mais seuls les MACROs utilisÇes
  seront incluses.
  

  Mais revenons Ö notre fonction du GEMDOS 'setblock':

  Le Listing de la Macro SETBLOCK sera:

          TEXT

SETBLOCK  MACRO               ;dÇbut macro
          move.l    a7,a5     ;USP dans a5
          lea       pile,a7   ;'pile' est l'adresse pointant sur une zone
                              ;de la mÇmoire rÇservÇe pour certaines 
                              ;fonctions. 
                              ;(le nom du label est quelconque...)
                              ;(Il faut bien sur rÇserver cette zone avec
                              ;DS.x place:200 octets suffisent en gÇnÇral)
          move.l   4(a5),a5   ;adresse de fin de la mÇmoire libre dans a5
          move.l   $c(a5),d0  ;Longeur zone TEXT dans d0
          add.l    $14(a5),d0 ;ajoute taille de la zone DATA 
          add.l    $1C(a5),d0 ;ajoute taille de la zone BSS
          add.l    #$100,d0   ;ajoute taille de P. de B. Ö d0

          move.l   d0,-(sp)   ;EMPILE la place Ö rÇserver (1¯ paramätre)
          move.l   a5,-(sp)   ;EMPILE a5                  (2¯ paramätre)
          move     #0,-(sp)   ;EMPILE mot=0               (3¯ paramätre)
          move     #$4a,-(sp) ;EMPILE le CODE de SETBLOCK
          trap     #1         ;appel du GEMDOS ->Çxecution de la fonction.
          add.l    #12,sp     ;De retour, on incrÇmente SP pour qu'il
                              ;retrouve sa valeur initiale.

          ENDM                ;fin de la MACRO

          END                 ;fin assemblage


 Nous allons sauver cette macro dans le fichier 'INIT_TOS.L'.


 Tous les programmes que nous Çcrirons devront donc ressembler Ö cela:
 πππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππππ
 
     TEXT

     INCLUDE   "INIT_TOS.L"   ;Linkage du fichier


     SETBLOCK                 ;appel de la MACRO SETBLOCK

     .                        ;les instructions 
     .                        ;qui forment le prg
     .

     DATA                     ;la zone data

     .                        ;avec les donnÇes initialisÇes
     .
     .

     BSS                      ;la zone bss

     .                        ;avec les rÇservations
     .
     .

     DS.B      200            ;et de la place rÇservÇe pour les besoins 
pile DS.B      1              ;des fonctions GEMDOS,BIOS,XBIOS que nous
                              ;allons utiliser.     (En amont du label
                              ;'pile').USP pointe sur 'pile' et sera dÇ-
                              ;crÇmentÇ quand on passera les paramätres
                              ;aux fonctions ( MOVE.x source,-(SP) )
                              ;:N'oubions pas que seule la mÇmoire dont
                              ;le programme a rÇellement besoin nous est 
                              ;rÇservÇe apräs SETBLOCK.
     END


  Le listing de la macro instruction SETBLOCK se trouve dans le fichier
  INIT_TOS.L sur cette disquette et vous est entiärement disponible.


 NB:Il faudra donc toujours veiller Ö rÇserver de la mÇmoire en zone
 ππ BSS en amont de l'adresse pointÇe par le label que nous avons
    nommÇ 'PILE'.
    On n'a pas besoin d'Çconomiser de place en rÇservant peu de 
    mÇmoire, la taille du segment BSS n'intervenant pas dans la
    taille du PRG...
    

- Je vais maintenant Çnumerer les diffÇrentes fonctions du GEMDOS.

  Seules les fonctions utilisÇes couremment seront ÇtudiÇes, pour les
  autres, il faudra vous rÇfärer Ö LA BIBLE DU ST,mais je doute que
  vous aurez Ö vous en servir dans un futur proche...

  Pour chaque fonction, je vous donnerai:

  .Le CODE et le NOM de la fonction
      ππππ       πππ
  .Les PARAMETRES Ö passer
       ππππππππππ
  .Le BUT de la fonction
      πππ

  .Une MACRO INSTRUCTION qui utilise la fonction ÇtudiÇe si celle-ci 
   peut nous àtre souvent utile...

       Toutes ces macro instructions que nous allons crÇer Ö partir des 
   fonctions du GEMDOS,BIOS et XBIOS seront rassemblÇes dans le fichier
   MACROS.L et vous pourrez bien sur vous en servir Ö chaque fois que
   vous le dÇsirerez.



                      *** LES FONCTIONS DU GEMDOS ***
                      πππππππππππππππππππππππππππππππ

$00 (TERM),pas de paramätre
πππ
TERM permet de mettre fin au programme et de revenir au programme appelant
(ou programme päre).
C.Ö.d. que si on utilise la fonction TERM du gemdos, le prg s'arräte et
revient soit au BUREAU GEM ( si le programme a uniquement ÇtÇ chargÇ Ö
partir du DESKTOP) soit Ö l'instruction suivant l'instruction d'appel,du
programme PERE.Dans ce dernier cas, le PRG utilisant la fonction TERM est
nommÇ programme FILS et a ÇtÇ chargÇ par le programme dit 'PERE'.

TERM      MACRO               ;macro TERM nommÇe 'TERM'
          CLR.W     -(SP)     ;code de TERM
          TRAP      #1        ;appel GEMDOS
          ENDM                ;fin MACRO


$01 (CCONIN),pas de paramätre
πππ
CCONIN attend un caractäre au clavier et l'affiche Ö la position courante
du curseur.
La fonction donne en retour,le code ASCII de la touche enfoncÇe dans l'oc-
tet de poids faible du mot de poids faible de d0 et le SCANCODE de la tou-
che dans l'octet de poids faible du mot de poids fort de d0.
Le SCANCODE permet de repärer les touches qui n'ont pas de code ASCII
(comme les touches de fonction) et il permet aussi de distinguer les
touches qui ont le màme code ASCII (comme les chiffres du pavÇ numÇri-
que et ceux du bloc principal)

Le code ASCII et le SCANCODE peuvent àtre atteints de cette maniäre par
exemple:

     MOVE      #$01,-(SP)     ;CODE de CCONIN
     TRAP      #1             ;-->gemdos
     ADDQ.L    #2,SP          ;on reinitialise SP
     CMPI.B    #'A',d0        ;compare l'octet de poids faible du mot de
                              ;poids faible de d0 avec le code ASCII de
                              ;'A' soit $41
     BEQ       oui
     SWAP.W    d0             ;SWAP les 2 mots de d0
     CMPI.B    #0,d0          ;le SCANCODE est-il nul ???
     BNE       non
     etc...
  
NB:Vous avez remarquÇ que j'ai Çcris:CMPI  #'A',d0.
ππ êcrire 'A' ou le code ASCII de A soit $41 est identique.
   Vous pouvez donc par exemple remplacer MOVE  #$42,d0 par MOVE  #'B',d0
   ,ceci rend le listing plus lisible si vous utilisez des instructions
   qui doivent dÇplacer des donnÇes reprÇsentant des codes ASCII...
   L'assembleur fera la rectification. (tout comme MOVE source,an est
   acceptÇ et remplacÇ par MOVEA source,an)
 
CCONIN    MACRO                    ;La macro Çquivalente
          MOVE      #$1,-(SP)
          TRAP      #1
          ADDQ.L    #2,SP
          ENDM

          
$02  (CCONOUT), MOT=code ascii
πππ
CCONOUT affiche le caractäre reprÇsentÇ par le code ASCII qu'on passe
comme paramätre sur la pile Ö la position courante du curseur.

CCONOUT   MACRO     $\1         ;ici, $\1 indique Ö l'assembleur qu'on
                                ;va passer un paramätre Ö la macro.
          move      \1,-(SP)    ;on empile le paramätre \1
          move      #2,-(SP)    ;puis le code de CCONOUT   
          trap      #1          ;gemdos
          addq.l    #4,SP       ;correction de la pile   
          ENDM                  ;fin de la MACRO

Comme vous pouvez le constater, on vient de crÇer une MACRO instruction
qui admet un PARAMETRE.
On l'indique Ö l'assembleur par la directive : MACRO   $\1
   
Le paramätre pourra àtre par exemple:#'A' ou d0 ou #$48 etc...

Exemples d'utilisation de la macro CCONOUT (avec un paramätre):
ππππππππ
     CCONOUT   #'a'

va afficher un 'a' Ö l'Çcran

     MOVE      #'a',d0
     CCONOUT   d0

idem

     CCONOUT   #53

va afficher le caractäre de code ascii 53.



$03 (CAUXIN),pas de paramätre
πππ
CAUXIN permet la reception d'un caractäre par l'interface RS232.
Si il n'y a pas eu d'erreur, le code ascii du caractäre retourne dans
l'octet de poids faible de d0.

     MOVE      #$3,-(SP)
     TRAP      #1
     ADDQ.L    #2,SP

$04 (CAUXOUT),MOT=code ascii
πππ
CAUXOUT provoque l'Çmission du caractäre dont le code ASCII a ÇtÇ passÇ
comme paramätre dans pile vers l'interface RS232.

     MOVE      #'A',-(SP)     ;envoie un 'A'
     MOVE      #$4,-(SP)
     TRAP      #1
     ADDQ.L    #4,SP


$05 (CPRNOUT),MOT=code ascii
πππ
CPRNOUT emmet le caractäre dont le code ASCII a ÇtÇ empilÇ vers 
l'imprimante.
Si le caractäre a ÇtÇ bien envoyÇ,on obtient le mot -1 dans d0.
Si l'imprimante est incapable de recevoir le caractäre, on obtient un
mot Çgal Ö 0 dans d0.

     MOVE      #'A',-(SP)     ;on imprime un 'A'
     MOVE      #$5,-(SP)      ;code de CPRNOUT
     TRAP      #1
     ADDQ.L    #4,SP

$06 (CRAWIO),MOT=$FF ou code ascii
πππ
CRAWIO admet deux types de paramätres.
Si le paramätre est un MOT Çgal Ö $FF, CRAWIO teste si une touche du
clavier EST enfoncÇe.(comme INKEY en BASIC)
Si une touche a ÇtÇ enfoncÇe, son code ascii et son scancode rentre dans
d0, sinon d0 reste inchangÇ.
Si le paramätre est diffÇrent de $FF, cette valeur est interprÇtÇe comme
le code ascii d'un caractäre Ö envoyer Ö l'Çcran.

INKEY     MACRO                   ;CRAWIO avec $FF comme paramätre
          MOVE      #$FF,-(SP)
          MOVE      #$6,-(SP)
          TRAP      #1
          ENDM

  Exemple d'utilisation de la macro INKEY:
  πππππππ
teste     INKEY               ;appel de la macro  INKEY
          CMPI.B    #'A',d0   ;compare le code ascii de d0 avec 'A'
          BEQ       oui       ;touche 'A' enfoncÇe ? Si oui va en 'oui'
          JMP       teste     ;sinon revient en 'teste'     
oui       NOP  

Tant que la touche 'A' n'est pas enfoncÇe, on saute en 'teste'.


$07 (CRAWCIN),pas de paramätre
πππ
CRAWCIN attend qu'on appuye sur une touche.
Le caractäre reconnu n'est pas affichÇ, mais le code ascii et le scancode
de la touche enfoncÇe est transmis Ö d0 en retour.

WAIT      MACRO               ;macro d'attente d'un touche
          MOVE      #$7,-(SP) ;code de CRAWCIN
          TRAP      #1
          ADDQ.L    #2,SP     ;codes de la touche dans d0.
          ENDM
              
$08 (CNECIN),pas de paramätre
πππ
Fonction IDENTIQUE Ö CRAWCIN, sauf qu'ici, frapper CONTROL-C met fin au
PRG (comme avec PTERM), CONTROL-S arräte l'affichage ,CONTROL-Q reprend
l'affichage interompu par control-s.

$09 (PRINT LINE),L-M=adresse d'une chaine de caractäres terminÇe par un
πππ              octet nul.

Cette fonction permet d'afficher une chaine de caractäres Ö l'Çcran.
La chaine de caractäres Ö afficher doit se trouver dans la zone DATA
et doit àtre terminÇe par un octet NUL.

PRINTLINE      MACRO     $\1       ;MACRO avec \1 paramätre:L'adresse de
                                   ;la chaine de caractäres Ö afficher.
               PEA       \1        ;EMPILE l'adresse \1.
               MOVE      #$9,-(SP) ;code de PRINTLINE
               TRAP      #1
               ADDQ.L    #6,SP
               ENDM
 
Exemple d'utilisation de la macro PRINTLINE:
πππππππ
          PRINTLINE      laurent
          PRINTLINE      exp2
          PRINTLINE      exp3

          DATA

laurent   DC.B           'laurent PIECHOCKI 8,impasse Bellevue 57980',0
exp2      DC.B           53,54,56,80,45,25,0
exp3      DC.B           27,'E',7,'LAURENT',25,0


 NB:  Pour obtenir des effets tels que l'effacement de l'Çcran,le saut de 
 πππ  lignes... il existe des codes spÇciaux qu'il faut transmettre aux
      fonctions telles que PRINTLINE,CCONOUT... 

      Les codes prÇcÇdÇs de la valeur ascii 27 (ESC).
      πππππππππππππππππππππππππππππππππππππππππππππππ
      27,'E'  :Çfface l'Çcran
      27,'B'  :positionne le curseur une ligne plus bas
      27,'A'  :positionne le curseur une ligne plus haut
      27,'C'  :positionne le curseur une ligne plus Ö droite
      27,'D'  :positionne le curseur une ligne plus Ö gauche
      27,'J'  :Çfface l'Çcran Ö partir de la position actuelle du curseur
      27,'L'  :insÇre une ligne
      27,'M'  :Çfface la ligne ou se trouve le curseur
      27,'I'  :scroll le curseur et le texte vers le haut
      27,'H'  :positionne le curseur Ö line 1,colonne 1
      27,'K'  :Çfface une ligne du curseur Ö la fin de la ligne

      27,'Y',x,y :positionne le curseur Ö la ligne x-32 et Ö la colonne
                  y-32                             ππππ
                  ππππ
      27,'b',x   :Change la couleur de l'Çcriture en couleur nr¯ x
      27,'c',x   :Change la couleur du fond en couleur nr¯ x
      27,'f'     :Fait disparaitre le curseur
      27,'e'     :Fait rÇapparaitre le curseur
      27,'j'     :MÇmorise la position du curseur
      27,'k'     :Positionne le curseur Ö la position mÇmorisÇe
      27,'p'     :Mode VIDêO-INVERSE de l'Çcriture
      27,'q'     :Retour en VIDêO normale


      Ainsi, si j'Çcris:  
      ππππππππππππππππππ
        PRINTLINE  efface
   
        DATA

efface  DC.B       27,'E','laurent',0

      ou
      ππ
        CCONOUT    #27
        CCONOUT    #'E'
        PRINTLINE  laurent

        DATA

laurent DC.B       'laurent',0


On efface l'Çcran (ESC,'E') et on affiche la chaine de caractäre:'laurent'


$0A (READLINE),L-M pointant sur un buffer
πππ
READLINE permet l'entrÇe d'une certaine quantitÇ de caractäres Ö l'Çcran.
(comme INPUT en BASIC).
La chaine de caractäre peut àtre modifiÇe en cours d'Çdition avec 
[Bascspace] et [Delete] et sera validÇe par [Return] ou [Enter].
(CONTROL-C provoque la fin du programme)

Il faut fournir l'adresse d'un buffer organisÇ commme il suit:

En zone BSS : DS.B   nombre maximum de caractäres Ö rentrer+2
πππππππππππ
Il faut avoir placÇ au dÇbut de ce buffer un OCTET reprÇsentant le nombre
maximum de caractäres Ö rentrer ( MOVE.B  x,buffer ) avant d'utiliser la
fonction READLINE.

Apräs le retour de la fonction:
En 'buffer'+1 se trouve le nombre de caractäres rentrÇs 
En 'buffer'+2 se trouve le dÇbut de la chaine de caractäres rentrÇe.

READLINE       MACRO          $\1       ;paramätre=adresse du buffer
               PEA            \1
               MOVE           #$0A,-(SP)
               TRAP           #1
               ADDQ.L         #6,SP
               ENDM

   Exemple d'utilisation de la macro READLINE:
   πππππππππππππππππππππ
     MOVE.B    #5,resu   ;5 caractäres Ö rentrer
     LEA       resu,a5   ;adresse de 'resu' dans a5
     READLINE  resu      ;readline
     addq.l    #2,a5     ;a5 pointe sur la chaine de carac. entrÇe
     MOVE.B    #0,zero   ;pose un OCTET nul Ö la fin de la chaine pour
     PRINTLINE a5        ;afficher le chaine avec PRINTLINE
     TOUCHE              ;on attend une touche
     BUREAU              ;en on quitte le prg     

     BSS

resu DS.B      7         ;rÇservation pour READLINE
zero DS.B      1         ;rÇservation pour l'octet nul qui finira la 
                         ;chaine pour PRINTLINE




$0B (CONIN STAT),pas de paramätre
πππ
L'appel Ö cette fonction donne en d0 un MOT Çgal Ö -1 si le tampon de
mÇmorisation des touches enfoncÇes contient des caractäres.
d0=0 si il n'y a pas de caractäres disponibles dans ce tampon.

     MOVE      #$B,-(SP)
     TRAP      #1
     ADDQ.L    #2,SP
     TST.W     D0
     BNE       rien

$0E (SETDRIVE),MOT=NR¯ du drive Ö activer.
πππ
SETDRIVE permet d'activer le drive dont le nr¯ est passÇ en paramätre dans
la pile systäme.
0=Drive A
1=Drive B  etc...

En retour, la fonction donne d0 qui est organisÇ de telle sorte que le
seul bit actif de d0 reprÇsente le dernier lecteur activÇ.
(nr¯ du bit actif=nr¯ du drive)


DRIVE     MACRO     $\1            ;param. \1=nr¯ du drive
          MOVE      \1,-(SP)      
          MOVE      #$E,-(SP)
          TRAP      #1
          ADDQ.L    #4,SP
          ENDM

     Exp d'utilisation:
     ππππππππππππππππππ
     DRIVE     #2

Le DRIVE C est activÇ.
Si le dernier Drive actif Çtait le drive B, on aurait:

d0=%0000000000000010
                  |
                 \|/

           bit nr¯1=drive B


$19 (CURRENT DISK),pas de paramätre
πππ
Cette fonction permet de savoir quel DRIVE est ACTIF.
Le nr¯ du drive actif est retournÇ dans d0 selon le format prÇcÇdent.

WATHDRIVE      MACRO                    ;Quel est le drive actif ?
               MOVE      #$19,-(SP)
               TRAP      #1
               ADDQ.L    #2,SP     
               ENDM

$1A (SETDTA),L-M=adresse du tampon DTA
πππ
SETDTA installe le tampon DTA qui est utilisÇ par certaines fonctions du
gemdos qui opärent sur les fichiers.
Ce tampon doit avoir une taille de 44 octets, son adresse doit àtre 
empilÇe dans la pile systäme et doit ätre PAIRE.

Pour obtenir une adresse paire, on peut rÇinitialiser le PC avec la direc-
tive BSS ou encore utiliser des directives appropriÇes ( mais spÇcifiques Ö
Ö l'assembleur utilisÇ ) :ALIGN.W pour PROFIMAT
                         :CNOP 0,2 pour METACOMCO

On peut aussi tout simplement faire une rectification en ajoutant 1 OCTET
Ö une adresse infÇrieure (DS.B  1), ceci a pour effet d'augmenter la va-
leur de l'adresse du DTA:adresse impaire+1=adresse paire.

 
          PEA       buffer
          MOVE      #$1A,-(SP)
          TRAP      #1
          ADDQ.L    #6,SP

          BSS

buffer    DS.B      44


$20 (SUPER),L-M=0 ou L-M=nouvelle valeur de SP
πππ
VoilÖ la fonction qui permet de passer EN MODE SUPERVISEUR.

Si le paramätre que vous fournissez est un L-M=0, SUPER activera le MODE
SUPERVISEUR et retournera dans d0 la valeur de SP.
Il faudra sauvegarder cette adresse car elle nous sera indispensable pour
revenir en MODE UTILISATEUR (Pour quitter le prg par exp)

Si on empile un autre L-M que 0,il sera interprÇtÇ comme la nouvelle 
valeur de SP et d0 contiendra l'ancienne valeur de SP.

SUPER     MACRO                    ;on passe en MODE SUPERVIEUR
          CLR.L     -(SP)
          MOVE.W    #$20,-(SP)
          TRAP      #1
          ADDQ.L    #6,SP
          MOVE.L    d0,sauv_sp     ;on sauve SP en 'sauv_sp'
          ENDM

Il faudra bien entendu rÇserver un L-M en 'sauv_sp' !

Pour revenir en MODE UTILISATEUR (indispensable pour quitter le programme
par exemple...):
On utilise la màme fonction, mais on y passe comme paramätre l'ancienne
valeur de SP qui a ÇtÇ sauvÇe en sauv_sp.

USER      MACRO                    ;on revient en MODE UTILISATEUR
          MOVE.L    sauv_sp,-(SP)  ;on restore SP
          MOVE.W    #$20,-(SP)
          TRAP      #1
          ADDQ.L    #6,SP
          ENDM



$2A  (GET DATE),pas de paramätre
πππ
Permet d'obtenir la DATE de l'horloge du bureau GEM dans d0 sous la forme:

Bits 0 Ö  4=jour
Bits 5 Ö  8=mois
Bits 9 Ö 15=(annÇe-1980)

     MOVE      #$2A,-(SP)
     TRAP      #1
     ADDQ.L    #2,SP

Exemple: si d0=%0001000000100001

La date est:

JOUR:bits 0 Ö 4 :%00001=le 1¯
MOIS:bits 5 Ö 8 :%00001=Janvier
AN  :bits 9 Ö 15:%0001000=8+1980=1988


$2B (SET DATE),MOT=date 
πππ
SET DATE permet de positionner l'horloge du GEM sur la date que vous lui
transmettez en paramätre.

La date (MOT) est au format prÇcÇdement dÇcrit.

bits 0 Ö 4:jour
bits 5 Ö 8:mois
bits 9 Ö 15:(annÇe-1980)

Si la date est incorrecte (45/20/1745...),d0 revient avec la valeur -1,
sinon il revient avec la valeur 0.

     MOVE      #%00010000000100001,-(SP)     ;le 1¯ janvier 1988
     MOVE      #$2A,-(SP)
     TRAP      #1
     ADDQ.L    #4,SP


$2C (GET TIME),pas de paramätre
πππ
GET TIME donne en retour l'heure de l'horloge du GEM dans d0 sous la
forme:

bits 0 Ö 4  :(secondes/2)
bits 5 Ö 10 :minutes 
bits 11 Ö 15:heure 

     Exemple:

test MOVE      #$2C,-(SP)     ;GET TIME
     TRAP      #1
     ADDQ.L    #2,SP
                              ;d0 contient l'heure
     AND.W     #%11111,d0     ;on MASQUE les bits 0 Ö 4 de d0:
                              ;les bits 5 Ö 15 de d0 sont donc effacÇs.
                              ;il reste les secondes.

     MULS      #2,d0          ;x2 car secondes=(secondes/2) dans d0
     CMPI      #30,d0         ;a-t-on secondes=30 ?
     BEQ       oui            ;si oui:va en 'oui'
     JMP       test           ;sinon revient et redemande l'heure. 

$2D (SET TIME),MOT=heure
πππ
SET TIME charge l'heure de l'horloge du GEM avec le paramätre qu'on lui
fournit.

L'heure doit àtre codÇe sous la forme:

bits 0 Ö 4  :(secondes/2)
bits 5 Ö 10 :minutes 
bits 11 Ö 15:heures 

     Exemple:

     MOVE      #%0001000000100001,-(SP)
     MOVE      #$2D,-(SP)
     TRAP      #1
     ADDQ.L    #4,SP

On positionne l'horloge sur 2h,1 min,2 sec


$31 (KEEP PROCESS),MOT=0,L-M=nb d'octets Ö protäger.
πππ
KEEP PROCESS permet, tout comme PTERM de mettre fin au programme et de
revenir au programme 'päre'.

Avec PTERM, le programme quittÇ est effacÇ de la mÇmoire dÇfinitivement,
tandis qu'avec KEEP PROCESS, on rÇserve un certaine quantitÇ d'OCTETS en
mÇmoire (paramätre 2) et on y place le programme Ö quitter.

Ceci est important pour les programmes sous interruption par exemple, 
nous en reparlerons... 

KEEP      MACRO     $\1            ;paramätre=nb d'octets Ö rÇserver
          CLR.W     -(SP)
          MOVE.L    #\1,-(SP)     
          MOVE      #$31,-(SP)
          TRAP      #1
          ADDQ.L    #8,SP
          ENDM

Exemple d'utilisation:

          KEEP   1024

On place le PRG dans le KO rÇservÇ et on le quitte...

NB:Faites bien attention Ö ce que vous rÇservez suiffisament de mÇmoire...
ππ

$3C (CREATE),MOT=attribut du fichier,L-M=adresse du nom de fichier
πππ

CREATE permet de crÇer un fichier dans lequel vous pourrez poser des 
donnÇes.

Le 1¯ paramätre est l'attribut du fichier:

0=fichier accessible en Lecture et Ecriture
1=fichier accessible en Lecture uniquement
2=fichier invisible
4=fichier systäme (invisible au desktop)
8 fichier label de volume (invisible au desktop)

Le 2¯ paramätre est l'adresse pointant sur le nom du fichier:

OrganisÇ ainsi:      'A:\fichier\nom.ext',0

Si le nom du programme Ö crÇer est 'nom.ext' et si il se trouve dans le
fichier 'fichier' (inutile si il n'est pas dans un fichier...).
'A:' indique qu'il se trouve sur l'unitÇ de disquette A.
La chaine de caractäre doit se terminer par un octet NUL.

En retour, CREATE retourne en d0 le nr¯ du FILE HANDLE du fichier.
Ce nr¯ sert Ö distinguer les diffÇrents programmes externes chargÇs.


CREER     MACRO     $\1,$\2,$\3         ;CREATE avec 3 paramätres
          MOVE      #\1,-(SP)           ;\1=attribut du fichier
          PEA       \2                  ;\2=adresse du nom 
          MOVE      #$3C,-(SP)
          TRAP      #1
          ADDA.L    #8,SP
          MOVE      d0,\3               ;\3=adresse de sauvegarde de d0.
          ENDM

Exemple d'utilisation:

          CREER     0,prg,handle        ;fichier en mode Lecture/Ecriture

          DATA

prg       DC.B      'A:\laurent.gag',0  ;nom du fichier Ö crÇer

          BSS

handle    DS.W      1                   ;1 Mot pour le handle


$3D  (OPEN),MOT=attribut,L-M=adresse du nom de fichier Ö ouvrir
πππ
OPEN permet d'ouvrir le fichier crÇÇ avec CREATE pour pouvoir l'utiliser
plus tard (lecture ou Çcriture).

Le 1¯ paramätre Ö fournir est l'attribut du fichier Ö ouvrir
Le 2¯ paramätre Ö fournir est l'adresse du nom du fichier Ö ouvrir.

Si OPEN ne rencontre pas de problämes (fichier prÇsent et accessible),
d0 revient avec le nr¯ du handle du fichier, sinon il revient avec une
valeur nÇgative. ( C'est un code d'erreur, voir la liste Ö la fin du 
chapitre.)

OUVRIR    MACRO     $\1,$\2,$\3    ;OPEN avec 3 paramätres
          MOVE      #\1,-(SP)      ;\1=attribut
          PEA       \2             ;\2=adresse du nom du fichier
          MOVE      #$3D,-(SP)
          TRAP      #1
          ADDQ.L    #8,SP
          MOVE      d0,\3          ;\3=adresse pour sauvegarder le handle
          ENDM

Exemple d'utilisation:

          OUVRIR    0,prg,handle   ;ouverture du fichier (attribut L/E)

          DATA

prg       DC.B      'A:\nom.ext',0 ;nom du fichier Ö ouvrir

          BSS

handle    DS.W      1              ;1 Mot pour le handle


$3E (CLOSE),MOT=nr¯ du handle
πππ
Si le fichier a ÇtÇ ouvert avec OPEN, il sera refermÇ par CLOSE, il faut
passer le nr¯ du handle du fichier Ö fermer comme paramätre.

En retour, si le fichier a ÇtÇ correctement fermÇ, d0=0.

FERMER    MACRO     $\1            ;MACRO Ö 1 paramätre
          MOVE      \1,-(SP)       ;\1=nr¯ du handle
          MOVE      #$3E,-(SP)
          TRAP      #1
          ADDQ.L    #4,SP
          ENDM

Exemple d'utilisation: 

          FERMER    handle

          BSS

handle    DS.W      1         ;ici a ÇtÇ posÇ le handle du fichier.



$3F (READ),L-M=adresse du buffer,L-M=nombre d'octets Ö lire,MOT=nr¯ handle
πππ
READ permet de lire un fichier ouvert par OPEN.
Il faut fournir les paramätres suivants Ö READ:
1¯: L'adresse d'un buffer dans lequel les donnÇes lues seront dÇposÇes
2¯: Le nombre d'octets Ö lire dans le fichier
3¯: Le nr¯ de handle du fichier

D0 retourne avec le nombre d'octets lus ou un code d'erreur nÇgatif.

LIRE      MACRO          $\1,$\2,$\3    ;MACRO Ö 3 paramätres
          PEA            \1             ;\1=adresse du buffer
          MOVE.L         \2,-(SP)       ;\2=nombre d'octets Ö lire
          MOVE           \3,-(SP)       ;\3=nr¯ du handle
          MOVE           #$3F,-(SP)
          TRAP           #1
          ADDA.L         #12,SP
          ENDM

Exemple d'utilisation:

          LIRE      pose,#1024,handle ;lire 1 KO de donnÇes

          BSS

pose      DS.B      1024 ;le buffer pour les 1024 octets Ö lire
handle    DS.W      1    ;ici se trouve le nr¯ du handle



$40 (WRITE),L-M=adresse du buffer des donnÇes Ö Çcrire,L-M=nombre d'octets
πππ         Ö Çcrire,MOT=nr¯ du handle.

WRITE permet d'Çcrire des donnÇes dans un fichier ouvert avec OPEN.

Les paramätres Ö passer sont:
1¯:L'adresse du buffer qui contient les donnÇes Ö Çcrire dans le fichier.
2¯:Le nombre d'octets Ö Çcrire dans le fichier
3¯:Le nr¯ du handle

D0 retourne avec 0 si tout est OK ou avec un code d'erreur nÇgatif.


ECRIRE    MACRO     $\1,$\2,$\3         ;3 paramätres
          PEA       \1                  ;\1=adresse du buffer
          MOVE.L    \2,-(SP)            ;\2=nb d'octets Ö Çcrire
          MOVE      \3,-(SP)            ;\3=nr¯ du handle
          MOVE      #$40,-(SP)
          TRAP      #1
          ADDA.L    #12,SP
          EDNM

     Exemple d'utilisation:

          ECRIRE    donnee,#10,handle

          BSS

donnee    DS.B      10   ;les 10 octets Ö Çcrire
handle    DS.W      1    ;ici a ÇtÇ sauvÇ le handle


$43 (FATTRIB),MOT=attribut,MOT=Çcrire ou lire,L-M=adresse du nom du 
πππ           fichier Ö modifier

FATTRIB permet de changer ou de lire l'attribut d'un fichier.
Les paramätres Ö passer sont:

1¯:L'attribut Ö Çcrire (si on dÇsire le changer,sinon mettre 0)

 0=fichier accessible en Lecture et Ecriture
 1=fichier accessible en Lecture uniquement
 2=fichier invisible
 4=fichier systäme (invisible au desktop)
 8=fichier label de volume (invisible au desktop)
10=fichier sous-rÇpertoire (uniquement pour la lecture!)
$20=fichier Çcrit et refermÇ correctement (uniquement pour la lecture!)

2¯:Un Mot Çgal Ö 1 si FATTRIB doit CHANGER l'attribut
   Un Mot Çgal Ö 0 si FATTRIB doit LIRE l'attribut, dans ce cas,l'attribut
   du fichier retourne dans d0. (ou un code d'erreur nÇgatif)
 
3¯:L'adresse pointant sur le nom du fichier Ö modifier ou lire

FATRIB    MACRO          $\1,$\2,$\3         ;macro Ö 3 paramätres
          MOVE           \1,-(SP)            ;\1=attribut
          MOVE           \2,-(SP)            ;\2=Çcriture ou lecture
          PEA            \3                  ;\3=adresse du nom du fichier
          MOVE           #$43,-(SP)
          TRAP           #1
          ADDA.L         #10,SP
          ENDM

     Exemple d'utilisation:

          FATRIB         #$02,#1,prg

          DATA

prg       DC.B           'A:\auto\laurent.tab',0

FATTRIB va cacher le fichier 'laurent.tab' du fichier 'auto' au desktop.


$4B (PEXEC),L-M=addresse de l'environnement,L-M=adresse de la ligne de 
πππ         commande,L-M=adresse du nom du fichier,MOT=mode de chargement                          

PEXEC permet de charger un fichier externe suivant 3 modes.

En mode 0:Le prg est chargÇ, PEXEC transmet la ligne de commande et l'en-
          vironnement au prg chargÇ puis l'exectute.
          (la ligne de commande et l'environnement sont des paramätres qui
           peuvent ätres passÇs Ö des programmes du type .TTP ou .APP) 
En mode 3:Le prg est chargÇ, PEXEC transmet la ligne de commande et l'en-
          vironnement au prg et on obtient dans d0 l'adresse ou celui-ci 
          se trouve.
En mode 4:Le prg chargÇ en mode 3 est executÇ.(dans ce cas,l'environnement
          et la ligne de commande ne doivent pas ätres utilisÇs)

Les paramätres Ö passer Ö PEXEC sont:

1¯:L'adresse de l'environnement
2¯:l'adresse de la ligne de commande
3¯:l'adresse du nom du fichier
4¯:le mode de chargement (0,3 ou 4)

Le prg qui utilise PEXEC est nommÇ programme PERE, le prg chargÇ par
PEXEC est le programme FILS.
Le prg PERE reste en mÇmoire apräs avoir utilisÇ PEXEC.

PEXEC     MACRO     $\1,$\2,$\3    ;MACRO Ö 3 paramätres
          PEA       \1             ;\1=adresse de l'environnement
          PEA       \2             ;\2=adresse de la ligne de commande
          PEA       \3             ;\3=adresse du nom du prg
          MOVE      \4,-(SP)       ;\4=mode
          MOVE      #$4B,-(SP)
          TRAP      #1
          ADDA.L    #16,SP
          ENDM

     Exemple d'utilisation:

          PEXEC     nul,zero,prg,#0

          DATA

nul       DC.B      0                    ;pas d'environnement
zero      DC.B      0                    ;pas de ligne de commande
prg       DC.B      'A:\laurent.prg\',0  ;le prg Ö charger et executer en
                                         ;mode 0

NB: Pour les Çventuelles inclusions de fichiers ASSEMBLEUR sous un
ππ  programme en GFA BASIC , il suffit d'utiliser la fonction EXEC
    du GFA, et de passer le paramätre dans la ligne de commande.
    Le programme fils en assembleur pourra lire le paramätre qui 
    se trouve au $80 äme octet de la page de base,il s'exÇcutera
    ensuite en prennant compte du paramätre, et en utilisant la
    fonction PTERM du Gemdos, il redonnera la main au programme
    päre en GFA...

$4E (SEARCH),MOT=attribut du fichier,L-M=adresse du nom du fichier Ö
πππ          chercher
  
SEARCH cherche si le fichier dont le nom lui est communiquÇ est prÇsent
sur la disquette.
Si il est prÇsent, d0 revient avec la valeur 0 et le tampon DTA qui aura
prÇalablement ÇtÇ installÇ avec la fonction SETDTA ($1A) sera organisÇ
ainsi:

Octet  21     :attribut du fichier
Octets 22 Ö 23:Heure d'installation du fichier
Octets 24 Ö 25:Date d'installation du fichier
Octets 26 Ö 29:Taille du fichier en octets
Octets 30 Ö 43:NOM et SUFFIXE du fichier trouvÇ

Si le fichier n'a pas ÇtÇ trouvÇ par SEARCH, d0 retourne avec le code
d'erreur -33 (fichier non trouvÇ)

NB:Les fichiers avec l'attribut Volume Label ne peuvent pas àtre reconnus
ππ par SEARCH...

   Si le nom du fichier est du type:

.  'A:\file.*',0 :On ne tient alors plus compte du SUFFIXE du fichier
   πππππππππππ
.  'A:\*.ext',0  :On ne tient que compte du SUFFIXE
   ππππππππππ
.  'A:\*.*',0    :=Tous les fichiers
   ππππππππ
.  'A:\A??.ext',0:les ? peuvent àtre n'importe quelle lettre 
   ππππππππππππ
   (par exemple ABC.ext et AXX.?AA peuvent àtre identifiÇs par A??.*)
  
Mais dans ces cas,plusieurs nom conviennent pour SEARCH (par exp si on
cherche 'A:\PRG.*',0: 'A:\PRG.EXT',0 et 'A:\PRG.DOC',0 conviennent),
SEARCH prendra alors le 1¯ fichier du rÇpertoire qui convient.


SEARCH    MACRO     $\1,$\2,$\3    ;MACRO Ö 3 paramätres
          PEA       \1             ;\1=adresse du tampon DTA (44 octets)
          MOVE      #$1A,-(SP)     ;SETDTA
          TRAP      #1
          ADDQ.L    #6,SP          ;Le tampon DTA est installÇ

          MOVE      \2,-(SP)       ;\2=attribut du fichier
          PEA       \3             ;\3=adresse du nom du fichier
          MOVE      #$4E,-(SP)     ;SEARCH
          TRAP      #1
          ADDQ.L    #8,SP
          ENDM

     Exemple d'utilisation:

          SEARCH    dta,#0,prg          ;attribut=Lecture/Çcriture
          CMPI      #-33,d0             ;file not found ??
          BEQ       pas_trouve_fichier  ;alors va en pas_trouve_fichier

          DATA


prg       DC.B      'A:\fichier\nom.ext',0   ;Le prg Ö chercher

          BSS

dta       DS.B      44                       ;44 oct. rÇservÇs pour le DTA


$4F (SEARCH NEXT),pas de paramätre
πππ          
Si on utilise SEARCH et qu'on cherche des fichiers dont le nom peut varier
(PRG.* par exp) et si plusieurs fichiers correspondent Ö ce nom,nous avons
vu que le 1¯ fichier du rÇpertoire qui convient est selectionnÇ.
Avec SEARCH NEXT,on peut chercher les autres fichiers qui conviennent au
nom de fichier Ö choix multiples.
SEARCH NEXT retourne une valeur NULLE dans d0 si il n'y a plus de fichiers
dont le nom convient au nom de fichier recherchÇ.
On pourra donc par exemple (Pour trouver les fichier du type 'x.*') tester
l'existence d'autres fichiers dont le nom convient en intÇgrant SEARCH
NEXT dans une boucle en testant d0 (si d0=0 il faudra sortir:on utilisera
donc TST.W  d0 puis DBEQ dn,boucle...)
  
     MOVE      #$4F,-(SP)
     TRAP      #1
     ADDQ.L    #2,SP


$56 (FRENAME),L-M=adresse du nouveau nom,L-M=adresse de l'ancien nom,
πππ           MOT=0

FRENAME permet de changer le nom d'un fichier.
Il suffit de passer l'adresse pointant sur le nouveau nom de fichier et
l'adresse pointant sur l'ancien nom de fichier comme paramätres.

D0 retourne avec une valeur nulle ou un message d'erreur nÇgatif.

RENAME    MACRO     $\1,$\2   ;MACRO a 2 paramätres
          PEA       \1        ;\1=adresse du nouveau nom de fichier
          PEA       \2        ;\2=adresse de l'ancien nom
          MOVE      #0,-(SP)  ;\3=0
          MOVE      #$56,-(SP)
          TRAP      #1
          ADDA.L    #12,SP
          ENDM
          
     Exemple d'utilisation:

          RENAME nouveau,ancien

          DATA

nouveau   DC.B      'A:\zzzzz.zzz',0    ;nouveau nom de fichier
ancien    DC.B      'A:\zzzzz.aaa',0    ;ancien nom



                              πππππππππππππ

ANNEXE:  Les codes d'erreur du GEMDOS:
πππππππ
-32:numÇro de fonction non valable
-33:fichier inexistant
-34:nom d'accäs inexistant
-35:trop de fichiers ouverts
-36:saisie impossible
-37:numÇro de rÇfÇrence non valable
-39:mÇmoire insuffisante
-46:unitÇ de disquette non valable
-49:plus d'autres fichiers


                           ππππππππππππππππππππ

  VoilÖ pour ce qui est des fonctions du GEMDOS.

  Je n'ai pas enumÇrÇ toutes les fonctions du GEMDOS, les autres ne vous
  serviront d'ailleurs pratiquement jamais:
  Seules les fonctions interressantes ont ÇtÇ prÇsentÇes ici.

  Vous pouvez däs Ö prÇsent foncer sur votre ASSEMBLEUR et crÇer vos 
  premiers programmes:
  Ils ne risquent pas encore d'ätres gÇniaux, mais au moins ils auront
  le mÇrite d'àtre en ASSEMBLEUR et de vous permettre de progresser.
  Bon courage...

  Les autres,lisez donc le prochain chapitre sur les fonction du BIOS et
  du XBIOS qui se trouve sur la disquette nr¯ 2.
                                ππππππππππππππππ
  Les exercices viendront ensuite, et avec eux VOS premiers programmes en
  ASSEMBLEUR dignes de ce nom...


  PIECHOCKI Laurent
  8,impasse Bellevue                    suite dans:BIOS.DOC (DISK 2)
  57980 TENTELING                                  πππππππππππππππππ




  

