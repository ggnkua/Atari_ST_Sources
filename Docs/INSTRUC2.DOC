
       SUITE DU COURS SUR LES INSTRUCTIONS du fichier INSTRUC.DOC
       ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹



   LSL    #BBB,dn   (.B),[.W],(.L)             (Local Shift Left)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   LSL      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou 

   LSL.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de faire un d‚calage de #BBB ou dm (suivant la syntaxe) BITS
   du registre de donn‚e dn vers la gauche.
   Les bits de remplacement sont NULS.

   Il faut n‚anmoins que 1<= #BBB <= 8 pour la 1ø forme.
                         ¹¹¹¹¹¹¹¹¹¹¹¹¹   

  Pour la 3ø forme,les modes d'adressage autoris‚s pour l'op‚rande
  destination sont:
  ¹¹¹¹¹¹¹¹¹¹¹
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   
   Mais dans ce cas, l'op‚ration ne peut que porter le d‚calage sur
   1 SEUL BIT.

   
   C.….d. que par exemple si  d0=%10000101110001101111011100000110 (mot)
   ¹¹¹¹¹¹
   Et que j'‚cris   LSL.W  #1,dn 
 
                 ou MOVE.W #1,d1
                    LSL.W  d1,d0  ,on obtient: 

                              d0=%00001011100011011110111000001100 
                                  <--------                       <--:0    

   Tous les Bits du MOT de poids faible du registre de donn‚e dn (.W)
   ont ‚t‚ d‚cal‚s d'1 bit vers la gauche:

   Le bit de plus faible poids rentrant est toujours remplac‚ par un 
   bit NUL.
   
   C.….d. :  Qu'on sort #BBB ou dm BITS de dn par la gauche et que les
   bits de remplacement qui rentrent … droite de dn sont des bits NULS.

   Le contenu de dn est donc chang‚, le MSB a aussi des chances d'ˆtre
   chang‚,c'est pourquoi le SIGNE de dn ne sera pas forcement conserv‚.

   Le CCR sera chang‚ en fonction de la nouvelle valeur de dn.
      ¹¹¹
   N=1 si le MSB est 1, sinon il est ‚gal … 0
   Z=1 si tous les bits de dn sont nuls, sinon il est ‚gal … 0
   V est toujours mis … 0
   C et X sont mis … la valeur du DERNIER BIT SORTI de dn.
    

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   MOVE     #%1111111101010101,d0  
   LSL.B    #5,d0

   On oppŠre un d‚calage de 5 bits de l'OCTET de poids faible de d0
   (seuls les bits 0 … 7 de d0 sont donc conscern‚s par lsl.B)

   On obtient: 
 
   CCR        --------<------<:0
 
   X=C=0  <-  1111111110100000 dans d0   

   5 bits 0 sont rentr‚s … droite de L'octet de poids faible de d0, le
   dernier bit … sortir de d0 etait nul: le bit X=C=0 dans le CCR




   LSR    #BBB,dn   (.B),[.W],(.L)             (Local Shift Right)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   LSR      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   LSR.W  destination (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de faire un d‚calage de #BBB ou dm (suivant la syntaxe) BITS
   du registre de donn‚e dn vers la droite
   Les bits de remplacement sont NULS.

   Il faut n‚anmoins que 1<= #BBB <= 8 pour la 1ø forme.
                         ¹¹¹¹¹¹¹¹¹¹¹¹¹   
   Pour la 3ø forme,les modes d'adressage autoris‚s pour l'op‚rande
   destination sont:
   ¹¹¹¹¹¹¹¹¹¹¹
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   
   Mais dans ce cas, l'op‚ration ne peut que porter le d‚calage sur
   1 SEUL BIT.

   C.….d. que par exemple si  d0=%10000101110001101111011100000110 (mot)
   ¹¹¹¹¹¹
   Et que j'‚cris   LSR.W  #1,dn 
 
                 ou MOVE.W #1,d1
                    LSR.W  d1,d0  ,on obtient: 

                              d0=%01000010111000110111101110000011 
                             0:-->                        ------->   

   Tous les Bits du MOT de poids faible du registre de donn‚e dn (.W)
   ont ‚t‚ d‚cal‚s d'1 bit vers la droite:

   Le bit de plus fort poids rentrant est toujours remplac‚ par un 
   bit NUL.
   
   C.….d. :  Qu'on sort #BBB ou dm BITS de dn par la droite et que les
   bits de remplacement qui rentrent … gauche de dn sont des bits NULS.

   Le contenu de dn est donc chang‚, le MSB a aussi des chances d'ˆtre
   chang‚,c'est pourquoi le SIGNE de dn ne sera pas forcement conserv‚.

   Le CCR sera chang‚ en fonction de la nouvelle valeur de dn.
      ¹¹¹
   N=1 si le MSB est 1, sinon il est ‚gal … 0
   Z=1 si tous les bits de dn sont nuls, sinon il est ‚gal … 0
   V est toujours mis … 0
   C et X sont mis … la valeur du DERNIER BIT SORTI de dn.
    

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%1111111101010101,d0  
   LSR.B    #5,d0

   On oppŠre un d‚calage de 5 bits de l'OCTET de poids faible de d0
 
   (seuls les bits 0 … 7 de d0 sont donc conscern‚s par lsr.B)

   On obtient: 
 
       ------0:>------>     CCR
 
   d0 :1111111100000010  -> X=C=1         

   5 bits 0 sont rentr‚s … gauche de L'octet de poids faible de d0, le
   dernier bit … sortir de d0 ‚tait ‚gal … 1: le bit X=C=1 dans le CCR




   ASL    #BBB,dn   (.B),[.W],(.L)             (Arithmetic Shift Left)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ASL      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ASL.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Cette instruction est identique … LSL.

   Mais avec ASL, le bit V du CCR est mis … 1 si le MSB de l'op‚rande
   destination est chang‚.    ¹¹¹



   
   ASR    #BBB,dn   (.B),[.W],(.L)             (Arithmetic Shift Right)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ASR      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ASR.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de faire un d‚calage de #BBB ou dm (suivant la syntaxe) BITS
   du registre de donn‚e dn vers la droite
   Les bits de remplacement sont ‚gaux au bit de plus fort poids.

   Il faut n‚anmoins que 1<= #BBB <= 8 pour la 1ø forme.
                         ¹¹¹¹¹¹¹¹¹¹¹¹¹   
   Pour la 3ø forme,les modes d'adressage autoris‚s pour l'op‚rande
   destination sont:
   ¹¹¹¹¹¹¹¹¹¹¹
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   
   Mais dans ce cas, l'op‚ration ne peut que porter la ROTATION sur
   1 SEUL BIT.

   C.….d. que par exemple si  d0=%10000101110001101111011100000110 (mot)
   ¹¹¹¹¹¹  
                              MSB=1
                  
   Et que j'‚cris   ASR.W  #1,dn 
 
                 ou MOVE.W #1,d1
                    ASR.W  d1,d0  ,on obtient: 

                              d0=%11000010111000110111101110000011 
                         MSB=1:-->                        ------->   


   Tous les Bits du MOT de poids faible du registre de donn‚e dn (.W)
   ont ‚t‚ d‚cal‚s d'1 bit vers la droite:

   Le bit de plus faible poids sort par la droite.  
   Le bit … remplacer est identique au MSB pr‚c‚dant la rotation.
   
   C.….d. :  Qu'on sort #BBB ou dm BITS de dn par la droite et qu'ils
   rentre des bits ‚gaux au bit de plus fort poids … gauche,… la place
   du bit manquant.
   
   Le contenu de dn est donc chang‚ mais son SIGNE est CONSERV car le
   MSB reste inchang‚.

   Le CCR sera chang‚ en fonction de la nouvelle valeur de dn.
      ¹¹¹
   N=1 si le MSB est 1, sinon il est ‚gal … 0
   Z=1 si tous les bits de dn sont nuls, sinon il est ‚gal … 0
   V est mis … 1 si le MSB de l'op‚rande destination a ‚t‚ chang‚.
   C et X sont mis … la valeur du DERNIER BIT SORTI de dn.
    

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%1111111101010101,d0  
   ASR.W    #5,d0

   bit nrø15=1

   On oppŠre un d‚calage de 5 bits du MOT de poids faible de d0
   (seuls les bits 0 … 15 de d0 sont donc conscern‚s par asr.W)

   On obtient: 
 
   MSB>--------------->     CCR
 
   d0 :1111111111111010  -> X=C=1 … la fin        

   5 bits sont sortis … droite du MOT de poids faible de d0 et on a
   plac‚ sucessivement 5 bits ‚gaux … 1 (bit nrø15=1) … la place du
   bit de plus fort poids du MOT.
   Le signe de d0 reste conserv‚.

   le dernier bit … sortir de d0 ‚tait ‚gal … 1:
   le bit X=C=1 dans le CCR




   ROL    #BBB,dn   (.B),[.W],(.L)             ROtate Left
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROL      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROL.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de faire une ROTATION de #BBB ou dm (suivant la syntaxe) BITS
   du registre de donn‚e dn vers la gauche.
   Les bits de remplacement sont ‚gaux ceux qui viennent de sortir.

   Il faut n‚anmoins que 1<= #BBB <= 8 pour la 1ø forme.
                         ¹¹¹¹¹¹¹¹¹¹¹¹¹   
   Pour la 3ø forme,les modes d'adressage autoris‚s pour l'op‚rande
   destination sont:
   ¹¹¹¹¹¹¹¹¹¹¹
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   
   Mais dans ce cas, l'op‚ration ne peut que porter la ROTATION sur
   1 SEUL BIT.

   C.….d. que par exemple si  d0=%10000101110001101111011100000110 (mot)
   ¹¹¹¹¹¹
                  
   Et que j'‚cris   ROL.W  #1,dn 
 
                 ou MOVE.W #1,d1
                    ROL.W  d1,d0  ,on obtient: 

                              d0=%00001011100011011110111000001101 
                            <-----                                <:1


   Tous les Bits du MOT de poids faible du registre de donn‚e dn (.W)
   ont ‚t‚ d‚cal‚s d'1 bit vers la gauche:

   Le bit de plus fort poids sort par la gauche et revient par la
   droite. (rotation)
   
   C.….d. :  Qu'on sort #BBB ou dm BITS de dn par la gauche et qu'ils
   rentrent … nouveau … droite, … la place des bits manquants.
      
   Le contenu de dn est donc chang‚, le MSB risque donc aussi d'ˆtre
   chang‚:le signe du registre ne sera donc pas forcement conserv‚.

   Le CCR sera chang‚ en fonction de la nouvelle valeur de dn.
      ¹¹¹
   N=1 si le MSB est 1, sinon il est ‚gal … 0
   Z=1 si tous les bits de dn sont nuls, sinon il est ‚gal … 0
   V est mis … 1 si le MSB de l'op‚rande destination a ‚t‚ chang‚.
   C est mis … la valeur du DERNIER BIT SORTI de dn.
   X n'est pas affect‚. 

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%1111111101010101,d0  
   ROL.B    #5,d0


   On oppŠre un d‚calage de 5 bits de l'OCTET de poids faible de d0
   (seuls les bits 0 … 7 de d0 sont donc conscern‚s par rol.B)

   On obtient: 
 
       -------C<------<:C     CCR
 
   d0 :1111111110101010  ->   C=0 … la fin        

   5 bits sont sortis … gauche de l'octet de poids faible de d0 et ont
   ‚t‚ remis … la place du bit de plus faible poids de l'octet.   

   le dernier bit … sortir de d0 ‚tait ‚gal … 0:
   le bit C=0 dans le CCR



   ROR    #BBB,dn   (.B),[.W],(.L)             ROtate Right
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROR      dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROR.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de faire une ROTATION de #BBB ou dm (suivant la syntaxe) BITS
   du registre de donn‚e dn vers la droite.
   Les bits de remplacement sont ‚gaux ceux qui viennent de sortir.

   Il faut n‚anmoins que 1<= #BBB <= 8 pour la 1ø forme.
                         ¹¹¹¹¹¹¹¹¹¹¹¹¹   
   Pour la 3ø forme,les modes d'adressage autoris‚s pour l'op‚rande
   destination sont:
   ¹¹¹¹¹¹¹¹¹¹¹
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   
   Mais dans ce cas, l'op‚ration ne peut que porter la ROTATION sur
   1 SEUL BIT.

   C.….d. que par exemple si  d0=%10000101110001101111011100000110 (mot)
   ¹¹¹¹¹¹
                  
   Et que j'‚cris   ROR.W  #1,dn 
 
                 ou MOVE.W #1,d1
                    ROR.W  d1,d0  ,on obtient: 

                              d0=%01000010111000110111101110000011 
                               -->                                --->  


   Tous les Bits du MOT de poids faible du registre de donn‚e dn (.W)
   ont ‚t‚ d‚cal‚s d'1 bit vers la droite:

   Le bit de plus faible poids sort par la droite et revient par la
   gauche. (rotation)
   
   C.….d. :  Qu'on sort #BBB ou dm BITS de dn par la droite et qu'ils
   rentrent … nouveau … gauche, … la place des bits manquants.
      
   Le contenu de dn est donc chang‚, le MSB risque donc aussi d'Štre
   chang‚:le signe du registre ne sera donc pas forcement conserv‚.

   Le CCR sera chang‚ en fonction de la nouvelle valeur de dn.
      ¹¹¹
   N=1 si le MSB est 1, sinon il est ‚gal … 0
   Z=1 si tous les bits de dn sont nuls, sinon il est ‚gal … 0
   V est mis … 1 si le MSB de l'op‚rande destination a ‚t‚ chang‚.
   C est mis … la valeur du DERNIER BIT SORTI de dn.
   X n'est pas affect‚. 

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   MOVE     #%1111111101010101,d0  
   ROR.B    #5,d0


   On oppŠre un d‚calage de 5 bits de l'OCTET de poids faible de d0
   (seuls les bits 0 … 7 de d0 sont donc conscern‚s par ror.B)

   On obtient: 
 
       -------C>------>:C       CCR
 
   d0 :1111111110101010  ->   C=1 … la fin        

   5 bits sont sortis … droite de l'octet de poids faible de d0 et ont
   ‚t‚ remis … la place du bit de plus fort poids de l'octet.   

   le dernier bit … sortir de d0 ‚tait ‚gal … 1:
   le bit C=1 dans le CCR


   
   ROXL   #BBB,dn   (.B),[.W],(.L)             ROtate Left with eXtend
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROXL     dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROXL.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

 

   ROXL est identique … ROL … part qu'ici le bit X du CCR est ( tout
   comme le bit C) charg‚ avec le dernier bit qui vient de sortir et
   que c'est lui qui est recopi‚ … la place du bit manquant.



   ROXR   #BBB,dn   (.B),[.W],(.L)             ROtate Right with eXtend
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROXR     dm,dn   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   ROXR.W  destination  (.W)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹


   ROXR est identique … ROR … part qu'ici le bit X du CCR est ( tout
   comme le bit C) charg‚ avec le dernier bit qui vient de sortir et
   que c'est lui qui est recopi‚ … la place du bit manquant.


  

   BTST   source,dn  (.B),[.W],(.L)         (TeST a Bit)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   BTST  source,destination   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de tester la valeur (0 ou 1) d'un BIT.

   Si le BIT est NUL:   le bit Z du CCR est mis … 1
                 ¹¹¹           ¹                  ¹    
   Si le BIT est ACTIF: le bit Z du CCR est mis … 0
                 ¹¹¹¹¹         ¹                  ¹     

   Pour la premiŠre forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹¹ 
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹

   dn
   #BBB  
 
  (avec 0<= NRø <=32,  modulo 32)
       
   L'op‚rande destination est un registre de donn‚e.
              ¹¹¹¹¹¹¹¹¹¹¹      
   Pour la seconde forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹   

   dn
   #BBB

   (avec 0<= NRø <=32,  modulo 32)

   L'op‚rande destination indique la donn‚e … traiter, elle admet les
   modes d'adressage:

   dn
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)
   d(pc)
   d(pc,rn)


   ¶ part le bit Z du CCR, les bits du CCR ne sont pas affect‚s par 
   l'instruction.     ¹¹¹   


   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%0111101101100101,d0 
   BTST.B   #3,d0                  ;Test le bit nrø3 de d0
   BEQ      zero                   ;Z=1 ?
   BNE      un                     ;Z=0 ?

   On teste le BIT nrø3 de l'octet de poids faible du mot
   %0111101101100101.
   Il est ‚gal … 0: Z=1 dans le CCR, on saute en 'zero'



   BSET   source,dn  (.B),[.W],(.L)         (test a Bit and SET)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   BSET  source,destination   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de tester la valeur (0 ou 1) d'un BIT.

.   Si le BIT est NUL:   le bit Z du CCR est mis … 1
                 ¹¹¹           ¹               ¹   
.   Si le BIT est ACTIF: le bit Z du CCR est mis … 0
                 ¹¹¹¹¹                         ¹           
.   AprŠs le test, le BIT conscern‚ est mis … 1
                     ¹¹¹               ¹¹¹¹¹¹¹

   Pour la premiŠre forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹   

   dn
   #BBB  
 
  (avec 0<= NRø <=32,  modulo 32)
       
   L'op‚rande destination est un registre de donn‚e.
              ¹¹¹¹¹¹¹¹¹¹¹        ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹   
   Pour la seconde forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹   

   dn
   #BBB

   (avec 0<= NRø <=32,  modulo 32)

   L'op‚rande destination indique la donn‚e … traiter, elle admet les
   modes d'adressage:

   dn
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)


   ¶ part le bit Z du CCR, les bits du CCR ne sont pas affect‚s par 
   l'instruction.     ¹¹¹


   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%0111101101100101,d0 
   BSET.B   #3,d0                  ;Test le bit nrø3 de d0 et SET … 1
   BEQ      zero                   ;Z=1 ?
   BNE      un                     ;Z=0 ?

   On teste le BIT nrø3 de l'octet de poids faible du mot
   %0111101101100101.
   Il est ‚gal … 0: Z=1 dans le CCR, on saute en 'zero'.
   Le bit nrø3 a ‚t‚ mis … 1:donc d0=%0111101101101101




   BCHG   source,dn  (.B),[.W],(.L)         (Bit CHanGe)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   BCHG  source,destination   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de tester la valeur (0 ou 1) d'un BIT.

   Si le BIT est NUL: le bit Z du CCR est mis … 1

   Si le BIT est ACTIF: le bit Z du CCR est mis … 0

   AprŠs le test, le bit conscern‚ est chang‚ en son oppos‚:
 
 .  0 si il ‚tait ‚gal … 1
 .  1 si il ‚tait ‚gal … 0
 
   Pour la premiŠre forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹

   dn
   #BBB  
 
  (avec 0<= NRø <=32,  modulo 32)
       
   L'op‚rande destination est un registre de donn‚e.
              ¹¹¹¹¹¹¹¹¹¹¹        ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   Pour la seconde forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹    
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹

   dn
   #BBB

   (avec 0<= NRø <=32,  modulo 32)

   L'op‚rande destination indique la donn‚e … traiter, elle admet les
   modes d'adressage:

   dn
   BBBB
   BB

   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)


   ¶ part le bit Z du CCR, les bits du CCR ne sont pas affect‚s par 
   l'instruction.     ¹¹¹


   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   MOVE     #%0111101101100101,d0 
   BTST.B   #3,d0                  ;Test le bit nrø3 de d0
   BEQ      zero                   ;Z=1 ?
   BNE      un                     ;Z=0 ?

   On teste le BIT nrø3 de l'octet de poids faible du mot
   %0111101101100101.
   Il est ‚gal … 0: Z=1 dans le CCR, on saute en 'zero'.
   Le bit nrø3 a ‚t‚ chang‚ en son oppos‚:donc d0=%0111101101101101




   BCLR   source,dn  (.B),[.W],(.L)         (Bit CLeaR)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   BCLR  source,destination   (.B),[.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Permet de tester la valeur (0 ou 1) d'un BIT.

 .  Si le BIT est NUL:   le bit Z du CCR est mis … 1
                  ¹¹¹           ¹                  ¹ 
 .  Si le BIT est ACTIF: le bit Z du CCR est mis … 0
                  ¹¹¹¹¹         ¹                  ¹  
 .  AprŠs le test, le bit conscern‚ est mis … 0.
                      ¹¹¹               ¹¹¹¹¹¹¹   

   Pour la premiŠre forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹

   dn
   #BBB  
 
  (avec 0<= NRø <=32,  modulo 32)
       
   L'op‚rande destination est un registre de donn‚e.
              ¹¹¹¹¹¹¹¹¹¹¹        ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   Pour la seconde forme:
           ¹¹¹¹¹¹¹¹¹¹¹¹¹
   L'op‚rande source indique le NRø du bit … tester, elle admet les
   modes d'adressage:           ¹¹

   dn
   #BBB

   (avec 0<= NRø <=32,  modulo 32)

   L'op‚rande destination indique la donn‚e … traiter, elle admet 
   les modes d'adressage:

   dn
   BBBB
   BB
   (an)
   -(an)
   (an)+
   d(an)
   d(an,rn)


   ¶ part le bit Z du CCR, les bits du CCR ne sont pas affect‚s par 
   l'instruction.     ¹¹¹


   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   MOVE     #%0111101101100101,d0 
   BTST.B   #3,d0                  ;Test le bit nrø3 de d0
   BEQ      zero                   ;Z=1 ?
   BNE      un                     ;Z=0 ?

   On teste le BIT nrø3 de l'octet de poids faible du mot
   %0111101101100101.
   Il est ‚gal … 0: Z=1 dans le CCR, on saute en 'zero'
   Le bit nrø3 de d0 a ‚t‚ mis … 0:d0 reste inchang‚



  
   ADDX     dm,dn     (.B),[.W],(.L)        (ADD with eXtend)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   ADDX   -(am),-(an) (.B),[.W],(.L) 
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   ADDX est identique … ADD, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR et ajout‚e … (dans) l'op‚rande destination.

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
    d'une op‚ration provoque une retenue.
   Ceci permet donc de faire des additions avec une pr‚cision sup‚rieure
   … un L-M: on peut donc additionner deux L-M avec ADDX !
 
   Tous les bits du CCR sont affect‚s par ADDX.
                    ¹¹¹
   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une addition avec
   ¹¹  ADDX, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR avant  
       l'addition.


  
   ABCD.B     dm,dn       (.B)        (ADD Decimal with eXtend)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   ABCD.B   -(am),-(an)   (.B)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   ABCD est identique … ADD, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR et ajout‚e … (dans) l'op‚rande destination.

   Seule la taille .B est autoris‚e.

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
   d'une op‚ration provoque une retenue.

   Les bits du V et N du CCR ne sont pas affect‚s par ABCD.
                         ¹¹¹
   Le bit C est mis … 1 seulement si il y a une retenue D‚cimale.

   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une addition avec
   ¹¹  ABCD, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR avant  
       l'addition.



  
   SUBX     dm,dn     (.B),[.W],(.L)        (SUBtract with eXtend)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   SUBX   -(am),-(an) (.B),[.W],(.L) 
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   SUBX est identique … SUB, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR et retranch‚e … (dans) l'op‚rande destination.

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
   d'une op‚ration provoque une retenue.
   Ceci permet donc de faire des soustractions avec une pr‚cision 
   sup‚rieure … un L-M: on peut donc soustraire deux L-M avec SUBX !
 
   Tous les bits du CCR sont affect‚s par SUBX.
                    ¹¹¹
   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une addition avec
   ¹¹  SUBX, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR avant  
       la soustraction.

  
   SBCD.B     dm,dn       (.B)        (Subtract Decimal with eXtend)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou
 
   SBCD.B   -(am),-(an)   (.B)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   SBCD est identique … SUB, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR et ajout‚e … (dans) l'op‚rande destination.

   Seule la taille .B est autoris‚e.

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
   d'une op‚ration provoque une retenue.

   Les bits du V et N du CCR ne sont pas affect‚s par SBCD.
                         ¹¹¹
   Le bit C est mis … 1 seulement si il y a une retenue D‚cimale.

   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une soustraction
   ¹¹  avec SBCD, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR
       avant la soustraction.



   NEGX    source   (.B),[.W],(.L)         (NEGate with eXtend) 
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   NEGX est identique … NEG, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR avant d'Štre soustraite de 0.

   L'op‚rande source admet les modes d'adressage:
              ¹¹¹¹¹¹      
     dn
     an
     BBBB
     BB
     (an)
     (an)+
     -(an)
     d(an)
     d(an,rn)

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
   d'une op‚ration provoque une retenue.
 
   Tous les bits du CCR sont affect‚s par NEGX.
                    ¹¹¹
   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une negation avec
   ¹¹  NEGX, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR avant  
       la n‚gation.


  
   NBCD.B    source       (.B)        (Negate Decimal with eXtend)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   NBCD est identique … NEG, sauf qu'ici l'op‚rande source est augment‚e
   du bit X du CCR puis soustraite de 0.

   Seule la taille .B est autoris‚e.

   L'op‚rande source admet les modes d'adressage:
              ¹¹¹¹¹¹ 
     dn
     an
     BBBB
     BB
     (an)
     (an)+
     -(an)
     d(an)
     d(an,rn)

   Le bit X du CCR est une copie du bit C et est mis … 1 si le r‚sultat
   d'une op‚ration provoque une retenue.

   Les bits du V et N du CCR ne sont pas affect‚s par NBCD.
                         ¹¹¹
   Le bit C est mis … 1 seulement si il y a une retenue D‚cimale.

   NB: Pour ‚viter q'une retenue ant‚rieure perturbe une n‚gation avec
   ¹¹  NBCD, on peut mettre le bit X du CCR … 0 avec MOVE #0,CCR avant  
       la n‚gation.




   JMP    desination      (JuMP)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   JMP permet d'effectuer un saut … l'adresse destination.

   L'op‚rande destination admet les modes d'adressage:
              ¹¹¹¹¹¹¹¹¹¹¹ 
     BBBB
     BB
     (an)
     d(an)
     d(an,rn)
     d(pc)
     d(pc,rn)

   
   Le saut se fait en chargeant la valeur actuelle du PC avec la valeur
   du PC … l'adresse destination.

   Le CCR n'est pas affect‚.
      ¹¹¹
     
   Exemples d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   JMP    ici
   ou
   LEA.L  ici,a0
   JMP    (a0)
   ou
   JMP    4(pc)
   etc...



   BRA    Label        (BRAnch)
   ¹¹¹¹¹¹¹¹¹¹¹¹

   BRA permet d'effectuer un saut … l'adresse point‚e par le Label
   (comme avec JMP)

   Le saut se fait en chargeant la valeur actuelle du PC avec la valeur
   du PC … l'adresse destination.

   Le CCR n'est pas affect‚.
      ¹¹¹

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹  
   BRA    laurent
  


   JSR    Destination    (Jump Sub Routine)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹

   Comme JMP, JSR permet d'effectuer un saut … l'adresse point‚e par
   l'op‚rande destination.

   L'op‚rande destination admet les modes d'adressage:
              ¹¹¹¹¹¹¹¹¹¹¹ 
     BBBB
     BB
     (an)
     d(an)
     d(an,rn)
     d(pc)
     d(pc,rn)

   
   De plus, l'adresse de l'instruction qui suit JSR est d‚pos‚e dans
   la pile systŠme (SP):

   On distingue 2 types de PILES:
  .La pile systŠme et les piles implant‚es par l'utilisateur.
  .La pile systŠme est point‚e par le registre A7 ou SP.
  .La diff‚rence entre ces 2 piles r‚side dans le fait qu'elles sont
   g‚r‚es de fa‡on entiŠrement ind‚pendantes.
  .Si on se trouve en MODE SUPERVISEUR, la pile systŠme nous est 
   disponible.
  .Si on se trouve en MODE UTILISATEUR, la pile est nomm‚e la pile
   utilisateur.

   La PILE systŠme est une partie particuliŠre de la m‚moire, elle
   est motament utilis‚e par les instructions de saut pour y d‚poser
   l'adresse de retour … l'instruction.

          |--------|--------|
          |--------|--------|   PILE  
          |--------|--------|   systŠme
          |--------|--------|

   On peut ranger des donn‚es dans cette pile. (c'est comme ‡a par exp
   qu'on passe les paramŠtres aux fonctions du Bios,Xbios,Gemdos)    

   Le rangement des donn‚es dans la Pile systŠme se fait :

   .Soit par pr‚d‚cr‚mentation du pointeur de pile SP  ( -(sp) )

    - Dans ce cas, la lecture des donn‚es se fera par mode (sp)+

   .Soit par postincr‚mentation du pointeur de pile SP ( (sp)+ )  
                     
    - Dans ce cas, la lecture des donn‚es se fera par mode -(sp)


   NB:Je vous rappelle que le SP (Stack Pointer) doit uniquement pointer
   ¹¹ des adresses PAIRES !
      Les d‚cr‚mentations ou incr‚mentations du SP d'1 unit‚ seront donc
      interdites.


   Exemple d'empilement de donn‚es en mode pr‚d‚cr‚ment‚:
   ¹¹¹¹¹¹¹  
   MOVE   #5-(sp)   ;5=%101
   MOVE   #3-(sp)   ;3=%11
 
   On obtient:

          |--------|--------|         
 SP ----->|00000000|00000011|       /|\   On empile les donn‚es 
          |00000000|00000101|        |    en mode -(SP)
 SP avant>|--------|--------|

   SP a ‚t‚ d‚cr‚ment‚ de 4 unit‚s ( -(sp) 2 fois avec .W )


   MOVE   (sp)+,d0
   MOVE   (sp)+,d1

   On obtient:

          |--------|--------|         
 SP avant>|00000000|00000011|        |    On d‚pile les donn‚es 
          |00000000|00000101|       \|/   en mode (SP)+
 SP ----->|--------|--------|        

   SP a ‚t‚ incr‚ment‚ de 4 unit‚s ( (sp)+ 2 fois avec .W )

   d0 contiendra le MOT 3
   d1 contiendra le MOT 5

   SP retrouve sa valeur initiale apr‚s le d‚pilement des donn‚es.

   NB:   Il sera important de veiller … redonner sa valeur initiale au 
   ¹¹  SP aprŠs s'Štre servi de la PILE systŠme car la taille de celle-
       ci est limit‚e.


   Mais revennons … JSR:    Nous avons vu que l'instruction d‚pose 
   l'adresse de la prochaine instruction qui suit JSR dans la pile
   systŠme avant d'effectuer un saut … l'adresse destination.

   SP est donc d‚cr‚ment‚ de 4 unit‚s (car une adresse est contenue 
   dans un L-M)

   La pile systŠme ressemblera donc … cela aprŠs un JSR:

          |--------|--------|         
 SP ----->|XXXXXXXX|XXXXXXXX|       /|\   L'adresse ( L-M ) de retour 
          |XXXXXXXX|XXXXXXXX|        |    aprŠs JSR est point‚e par
 SP avant>|--------|--------|             SP qui a ‚t‚ d‚cr‚ment‚ de
                                          4 unit‚s ( -(SP) avec .L )


  Cette adresse sera d‚pil‚e par la suite … la fin du sous programme
  par une instruction sp‚cifique et sera charg‚e dans le PC: 
  Ceci provoquera le retour … l'instruction suivant JSR.

  JSR diffŠre donc de JMP par le fait que JSR sauve l'adresse de la
  prochaine instruction qui la suit dans la pile systŠme, ceci afin
  qu'il soit possible de revenir … cette adresse aprŠs avoir saut‚
  … l'adresse destination de JSR.
   


  BSR     label          (Branch Sub Routine)  
  ¹¹¹¹¹¹¹¹¹¹¹¹¹

  BSR est identique … JSR, sauf que certains assembleurs permettent de
  fixer la longueur du d‚placement (BRA.S (Mot) ou BRA.L (L-M) )
   
  (Ceci n'a pas de r‚el int‚rˆt pour nous ...)



  RTS     (ReTurn from Sub routine) 
  ¹¹¹

  C'est, (comme son nom l'indique) l'instruction qui marque la fin du
  sous programme et qui oppŠre un saut … la prochaine instruction qui
  suit l'instruction appellante JSR.

  RTS d‚pile (par mode postincr‚ment‚) l'adresse d‚pos‚e par JSR et la
  charge dans le PC:ceci a pour effet de provoquer un saut … l'adresse
  qui suit JSR.
 
  SP retrouve donc sa valeur initiale.

  Le CCR n'est pas modifi‚ par RTS.
     ¹¹¹

  Exemple d'utilisation:
  ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
       MOVE    #3,d0   ;mot 3 dans d0
       MOVE    #8,d1   ;mot 8 dans d1
       JSR     ajoute  ;Appel du sous-programme 'ajoute'
       MOVE    d0,resu ;met le mot de poids faible de d0 en 'resu'

       ......          ;on considŠre qu'ici se trouve une instruction
                       ;qui stoppe le programme pour ‚viter d'aller
                       ;plus loin...

ajoute ADD     d1,d0   ;sous programme 'ajoute'
       RTS             ;fin du sous programme,retour ^

       BSS

resu   DS.W    1       ;r‚serve un mot

       END  


En 'resu', on trouvera le MOT 8+3=11




    RTR        (ReTurn & Restore CCR)
    ¹¹¹
    RTR est identique … RTS sauf que RTR:

    .D‚pile 1 MOT de la pile systŠme par mode postincr‚ment‚ et le place
     dans le CCR.

    .D‚pile 1 L-M de la pile systŠme par mode postincr‚mant‚ et le place
     dans le PC, tout comme RTS.

    Il faudra bien entendu que les 3 premiers MOTS point‚s par SP 
    correspondent aux besoins de RTR.
 

    Exemple d'utilisation:
    ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹      
         MOVE  #3,d0  ;3 dans d0
         MOVE  d0,d1  ;d0 dans d1
         JSR   test   ;va au sous prg 'test' et pose l'adresse de la 
                      ;prochaine instruction dans SP.
         MOVE  #1,d3   
          
         ..........   ;fin d'execution du prg pour ne pas aller plus loin
   
test     MOVE  sr,-(sp)  ;sous-prg 'test':pose le SR (mot) dans la pile
                         ;(la pile contient donc … son sommet le SR (mot)
                         ;puis l'adresse pos‚e par JSR (l-m) )
         SUB   d0,d1     ;soustrait d0 de d1: d0=d1, le bit Z du CCR est
                         ;mis … 1.(avant SUB il ‚tait … 0)
         RTR             ;on d‚pile le SR puis l'adresse pos‚e par JSR et
                         ;on revient
 
 AprŠs ˆtre revenu du sous-programme, le bit Z du CCR sera donc nul car 
 RTR a restor‚ le SR que nous avons d‚pos‚ avant la soustraction ...





 MOVEM   registres/registres,destination       [.W],(.L)
 ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
 ou

 MOVEM   source,registres/registres            [.W],(.L)
 ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹


 MOVEM permet la sauvegarde (1ø forme) ou la restoration (2ø forme) des
 registres an et dn.

 Seules les tailles .W ou .L sont autoris‚es.

 Pour la 1ø forme:
 ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
 L'op‚rande destination admet les modes d'adressage:
            ¹¹¹¹¹¹¹¹¹¹¹
     BBBB
     BB
     (an)
     -(an)
     d(an)
     d(an,rn)
     d(pc)
     d(pc,rn)

 On utilise communement le mode d'adressage -(an), dans ce cas, les
 registres sont empil‚s en m‚moire par adresses d‚croissantes, dans
 l'odre: a7->a0 , d7->d0 

 Si l'op‚rande source est du type: d0-d7/a0-a7 ,tous les registres sont
 transf‚r‚s.
 
 Sinon, on indique le 1ø registre DN et le dernier registre DM … 
 transfŠrer (s‚par‚s du signe -) puis le 1ø registre AN et le dernier
 registre AM … transfŠrer (s‚par‚s du signe -).
 De plus:
 On s‚pare les registres DN et AN du signe / dans l'op‚rande source.

 NB:La forme dn-dm/an-am est identique … la forme an-am/dn-dm pour
 ¹¹ l'op‚rande source.
    (de  mŠme que la forme d0/d1/a0 est identique … la forme d0-d1/a0)

 Le registre de donn‚e an destination est donc d‚cr‚ment‚ d'un nombre
 ‚gal … la taille x de MOVEM.x (2 si .W,4 si .L) multipli‚ par le 
 nombre total de registres … transferer.

 Exp: MOVEM.L  d3-d5/a0-a2,-(SP)
 ¹¹¹
 On empile les registres a2,a1 puis d5,d4,d3 dans la pile systŠme.
 SP est d‚cr‚ment‚ de 6*4=24 unit‚s et pointe sur d3, le dernier 
 registre empil‚.

      MOVEM.L  a5-a7,-(SP)

 On empile les registres a7,a6,a5 dans la pile systŠme.
 SP est d‚cr‚ment‚ de 3*4=12 unit‚s et pointe sur a5, le dernier
 registre empil‚

     MOVEM.W  d3/a0-a1,-(SP)

 On empile les mots de poids faible des registres a1,a0,d3 dans la pile
 systŠme.
 SP est d‚cr‚ment‚ de 3*2=6 unit‚s et pointe sur le mot de poids faible
 de d3, le dernier mot empil‚.


 
 Pour la 2ø forme:
 ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹         
 L'op‚rande source admet les modes d'adressage:
            ¹¹¹¹¹¹
     BBBB
     BB
     (an)
     (an)+
     d(an)
     d(an,rn)
     d(pc)
     d(pc,rn)

 On utilise communement le mode d'adressage (an), dans ce cas, les
 registres sont d‚pil‚s de la m‚moire par adresses croissantes, et
 remis dans les registres dans l'odre: d0->d7 , a0->a7 

 Si l'op‚rande source est du type: d0-d7/a0-a7 ,tous les registres sont
 modifi‚s.
 
 Sinon, on indique le 1ø registre DN et le dernier registre DM … 
 charger (s‚par‚s du signe -) puis le 1ø registre AN et le dernier
 registre AM … charger (s‚par‚s du signe -).
 De plus:
 On s‚pare les registres DN et AN du signe / dans l'op‚rande source.

 NB:La forme dn-dm/an-am est identique … la forme an-am/dn-dm pour
 ¹¹ l'op‚rande source.
    (de  mŠme que la forme d0/d1/a0 est identique … la forme d0-d1/a0)

 Le registre de donn‚e an destination est donc incr‚ment‚ d'un nombre
 ‚gal … la taille x de MOVEM.x (2 si .W,4 si .L) multipli‚ par le 
 nombre total de registres … modifier.
 Le registre an destination retrouve donc sa valeur initiale aprŠs le
 chargement des registres.
 ATTENTION, il faudra veiller … ce que les donn‚es n‚cessaires soient 
 pr‚sentes … l'adresse indiqu‚e.

 Exp: MOVEM.L  (SP)+,d3-d5/a0-a2
 ¹¹¹
 On d‚pile les L-M point‚s par SP et on les copies dans d3,d4,d5 puis 
 a0,a1,a2. 
 Dans la pile systŠme, SP est incr‚ment‚ de 6*4=24 unit‚s.

      MOVEM.L  (SP)+,a5-a7

 On d‚pile les L-M point‚s par SP et on les copies dans le registres a5,
 a6,a7.
 Dans la pile systŠme,SP est incr‚ment‚ de 3*4=12 unit‚s.

     MOVEM.W  (SP)+,d3/a0-a1

 On d‚pile les mots point‚s par SP dans les mots de poids faible des 
 registres d3,a0,a1.
 Dans la piles systŠme, SP est incr‚ment‚ de 3*2=6 unit‚s.

 

 MOVEM n'influence pas le CCR.
                          ¹¹¹

 Exemple d'utilisation:
 ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
 MOVE     #3,d0          ;mot 3 dans d0
 MOVE     #4,d1          ;mot 4 dans d1
 MOVEM.L  d0-d1,-(SP)    ;on sauvegarde d0 et d1 (voir sch‚ma 1) 
 ADD      d0,d1          ;d1=d0+d1=3+4=7
 MOVEM.L  (SP)+,d0-d1    ;on restore d0 et d1 (voir sch‚ma 2)

 Finalement: on a d0=3 et d1=4 … la fin du prg car les registres d0 et 
             d1 ont ‚t‚ sauvegard‚s puis recharg‚s.  
 
 sch‚ma 1:
 ¹¹¹¹¹¹¹¹¹
 MOVEM.L  d0-d1,-(SP)

 On EMPILE les L-M d1=4=%100 puis d0=3=%11 dans la Pile SystŠme:


                  |--------|--------|
                  |--------|--------|         
                  |--------|--------|             PILE   
SP aprŠs les 2--->|00000000|00000000|            SYSTEME
d‚cr‚mentations   |00000000|00000011|
                  |00000000|00000000|         
                  |00000000|00000100|   
   SP avant ----->|--------|--------|


 sch‚ma 2:
 ¹¹¹¹¹¹¹¹¹
 MOVEM.L  (SP)+,d0-d1

 On DPILE les L-M point‚s par SP au cours des incr‚mentations et on
 les places dans d0 et d1.

                  |--------|--------|
                  |--------|--------|         
                  |--------|--------|             PILE   
  SP avant  ----->|00000000|00000000|            SYSTEME
                  |00000000|00000011|
                  |00000000|00000000|         
                  |00000000|00000100|   
SP aprŠs les 2 -->|--------|--------|
incr‚mentations (.L)

 


   
   MOVEP   dn,d(an)      [.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
   ou

   MOVEP  d(an),dn       [.W],(.L)
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹
  
   MOVEP permet de sauvegarder (1ø forme) ou recharger (2ø forme) un
   registre de donn‚e dn (son mot de poids faible pour MOVEP.W ou le
   registre en entier pour MOVEP.L) point‚ par un mode d'adressage du
   type indirect avec d‚placement d(an).

   MOVEP est une instruction trŠs particuliŠre car le registre de donn‚e
   dn est sauv‚ (ou charg‚) de la maniŠre suivante:

   Pour MOVEP.W:

   L'octet de poids faible de dn est sauvegard‚ ou charg‚ … partir de
   l'adresse point‚e par d(an) ( ou d(an)+1 si cette adresse ‚tait 
   IMPAIRE )

   L'octet de poids fort de dn est sauvegard‚ ou charg‚ … partir de
   l'adresse point‚e par d(an)+2 ( ou d(an)+3 si cette adresse ‚tait 
   IMPAIRE )


   Pour MOVEP.L

   L'octet de poids faible de dn est sauvegard‚ ou charg‚ … partir de
   l'adresse point‚e par d(an) ( ou d(an)+1 si cette adresse ‚tait 
   IMPAIRE )

   L'octet de poids fort du mot de poids faible de dn est sauvegard‚ ou
   charg‚ … partir de l'adresse point‚e par d(an)+2 ( ou d(an)+3 si cette
   adresse ‚tait IMPAIRE )

   L'octet de poids faible du mot de poids fort de dn est sauvegard‚ ou
   charg‚ … partir de l'adresse point‚e par d(an)+4 ( ou d(an)+5 si cette
   adresse ‚tait IMPAIRE )

   L'octet de poids fort de dn est sauvegard‚ ou charg‚ … partir de
   l'adresse point‚e par d(an)+6 (ou d(an)+7 si cette adresse ‚tait 
   IMPAIRE )


   EN RSUM:
   ¹¹¹¹¹¹¹¹¹¹
   MOVEP.L dn,d(an): Si d(an) pointe une adresse PAIRE.
                        ¹¹¹¹¹                    ¹¹¹¹¹ 

           OCTETS                MMOIRE
           ¹¹¹¹¹¹                ¹¹¹¹¹¹¹     
         poids fort
   dn:    ********      -------> d(an)       paire
   ¹¹                            d(an)+1     impaire
          ********      -------> d(an)+2     paire
                                 d(an)+3     impaire
          ********      -------> d(an)+4     paire
                                 d(an)+5     impaire
          ********      -------> d(an)+6     paire
        poids faible     



   MOVEP.L dn,d(an): Si d(an) pointe une adresse IMPAIRE.
                        ¹¹¹¹¹                    ¹¹¹¹¹¹¹ 

           OCTETS                MMOIRE
           ¹¹¹¹¹¹                ¹¹¹¹¹¹¹     
         poids fort
   dn:    ********      -------> d(an)+1     paire
   ¹¹                            d(an)+2     impaire
          ********      -------> d(an)+3     paire
                                 d(an)+4     impaire 
          ********      -------> d(an)+5     paire
                                 d(an)+6     impaire
          ********      -------> d(an)+7     paire
        poids faible


   MOVEP permet donc TOUJOURS de poser un registre de donn‚e en m‚moire  
   sur des adresses PAIRES.(Par alternance d'octets 'vides' et d'octets
   contenus dans dn qui se situent eux toujours … des adresses paires )


   MOVEP n'influence pas le CCR.
                            ¹¹¹

   Exemple d'utilisation:
   ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹    
   MOVE.L      #%00000000000000001111111100000001,d0
   LEA         aa,a0
   MOVEP       d0,0(a0)

   BSS

aa DS.B        43 


'aa' est une adresse paire (BSS initialise la PC) en 0(a0) on trouve donc
l'octet de poids le plus fort de d0 soit %00000000.
'aa'+1 est une adresse impaire.
'aa'+2 est une adresse paire, en 2(a0) on trouve l'octet de poids faible
du mot de poids fort de d0 soit %00000000
'aa'+3 est une adresse impaire
'aa'+4 est une adresse paire, en 4(a0) on trouve l'octet de poids fort
du mot de poids faible de d0 soit %11111111
'aa'+5 est une adresse impaire
'aa'+6 est une adresse paire, en 6(a0) on trouve l'octet de plus faible
poids de d0 soit %00000001

Tous ces octets sont situ‚s … des adresses paires.



  PEA     source   (Push Effective Address)
  ¹¹¹¹¹¹¹¹¹¹¹¹¹¹

  PEA pose l'adresse de l'op‚rande source dans la pile systŠme sous la
  forme d'un L-M, SP sera donc d‚cr‚cment‚ de 4 unit‚s.

  L'op‚rande source admet les modes d'adressage:
             ¹¹¹¹¹¹  
     BBBB
     BB
     (an)
     d(an)
     d(an,rn)
     d(pc)
     d(pc,rn)

  Le CCR n'est pas affect‚ par PEA.
     ¹¹¹
  Exemple d'utilisation:
  ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹   
     PEA      eee      ;pose l'adresse point‚e par le label 'eee' dans la
                       ;pile systŠme.(voir 1ø)
     MOVE.L   (SP)+,a0 ;d‚pile le L-M point‚ par SP et le pose dans a0
                       ;(voir 2ø)
     JMP      (a0)     ;saute … l'adresse point‚e par a0 (donc en 'eee')

     MOVE     #4,d0

eee  MOVE     #3,d1

     END
  
Finalement: d1=3 et d0 est inutilis‚.

1ø)  La pile systŠme ressemblera donc … cela aprŠs un PEA:
¹¹¹
          |--------|--------|         
 SP ----->|XXXXXXXX|XXXXXXXX|       /|\  L'adresse ( L-M ) de l'op‚rande 
          |XXXXXXXX|XXXXXXXX|        |   source est empil‚e dans la pile 
 SP avant>|--------|--------|            systŠme:SP est donc d‚cr‚ment‚
                                         de 4 unit‚s ( -(SP) avec .L )


2ø)  La pile systŠme ressemblera ensuite … cela aprŠs MOVE.L  (SP)+,a0
¹¹¹    
          |--------|--------|         
 SP avant>|XXXXXXXX|XXXXXXXX|        |    L'adresse ( L-M ) de point‚e
          |XXXXXXXX|XXXXXXXX|       \|/   par SP est pos‚e dans a0.
 SP ----->|--------|--------|             SP qui a ‚t‚ incr‚ment‚ de
                                          4 unit‚s ( (SP)+ avec .L )

   a0=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX (l'adresse pos‚e par PEA)



                             ¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹


  PIECHOCKI Laurent
  8,impasse Bellevue              Suite dans le fichier INSTRUC3.DOC
  57980 TENTELING                                       ¹¹¹¹¹¹¹¹¹¹¹¹



       
