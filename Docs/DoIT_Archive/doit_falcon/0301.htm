<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- last modified on 23.12.2003 -->
<html>
<head>
<title>
DOITF030 - Tips u. Tricks zum Atari Falcon F030: Spezifikation - Atari Falcon F030
</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Generator" content="UDO6 PL14 for TOS">
<meta name="Email" content="support@doitarchive.de">
<link rev=made href="mailto:support@doitarchive.de" title="E-Mail">
<link rel=home href="doitf030.htm" title="Homepage">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF0000" vlink="#800080">

<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="03.htm" target="UDOcon"><img src="udo_up.gif" alt="Falcon F030 System" border=0 width="24" height="24"></a>
<a href="03.htm" target="UDOcon"><img src="udo_lf.gif" alt="Falcon F030 System" border=0 width="24" height="24"></a>
<a href="0302.htm" target="UDOcon"><img src="udo_rg.gif" alt="Falcon F030" border=0 width="24" height="24"></a>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr>
<td valign=top width="8">&nbsp;</td><td valign=top width="100%">
<h1><a name="Spezifikation_20-_20Atari_20Falcon_20F030">3.1 Spezifikation - Atari Falcon F030</a></h1>
<p align=center><img src="image/line.gif" border=0 width="637" height="6"></p><br>
<p><tt>Atari F030 Spezifikation (englisch)</tt>
</p>
<p>From rmccall@mcs.dundee.ac.uk (Rod McCall) Newsgroups:
comp.sys.atari.st,comp.sys.atari.st.tech
<br>Subject: Falcon Spec Sheet
<br>Date: 12 Dec 1994 10:18:59 GMT
<br>
</p>
<p>Atari Falcon 030 Specifications
<br>_______________________________
<br>
</p>
<pre>
 CPU: Motorola 68030 32-bit microprocessor @ 16MHz w/ 32-bit bus
 FPU: Motorola 68881/68882 @ 16MHz (optional)
 DSP: Motorola 56001 Digital Signal Processor running in parallel @ 32MHz
         w/ 32kWords (24-bit) of local zero wait state static RAM
 ROM: 512kB
 RAM: 1, 4 or 16MB(14MB usable) on daughterboard (RAM is 32-bit wide)

 Expansion bus: Internal 'Processor-Direct' slot for 386SX emulation
                (third party 386SX emulator nearly completed) or other
                co-processors/etc.

Video:
        (See below for specific video modes/resolutions.)
        16-bit BLiTTER @ 16MHz (also handles hard drive access)
        Accepts external video sync to allow high quality genlocking
        Overlay mode for easy video titling and special effects
        Overscan support
        <a href="0305.htm" target="UDOcon">Hardware</a>-assisted horizontal fine scrolling
        VIDEL (video controller) sits on 32-bit bus

<a href="0907.htm" target="UDOcon">Audio</a>:
        Stereo 16-bit Analog-to-Digital DMA input
        Stereo 16-bit Digital-to-Analog DMA output
        Eight 16-bit audio DMA record/playback channels
        SDMA sound/DMA co-processor

Ports:  128kB cartridge port
        2*9-pin mouse/joystick ports
        2*15-pin STe enhanced analog/digital controller ports (Atari also
        has new analog controllers w/ a joystick, 3 fire buttons, and a
        12-key keypad)

MIDI IN, OUT/THRU

        Bi-directional parallel port
        RS232C serial port
        SCSI II w/ DMA
        Analog RGB/VGA/composite video connector
        Stereo headphone out (1/8&quot; mini-jack)
        Stereo microphone in (1/8&quot; mini-jack)
        DSP port (up to 1MHz data transfer rate)
        RF modulator for TV hookup
        Localtalk compatible LAN (up to 250kbaud transfer rate)

Misc:
        Internal 1.44MB 3.5&quot; HD floppy
        Internal IDE 2.5&quot; hard drive (optional)
        Pre-emptive mulitasking OS (MultiTOS) w/ adaptive prioritization
        and inter-process communication (also 68040 compatible)
        Realtime clock and battery backed up RAM
        1040ST-style case w/ internal fan
        North American availability in mid-October

Price:
        1MB/no HD -  $799 list
        4MB/65MB  - $1399 list

</pre>
<div align=center><tt> Resolutions available on the Atari Falcon030 (c) 1992 Atari
Corp.
<br>Written by John Townsend</tt>
<br>
</div>
<div align=center>
=========================================================================
<br>This document may be re-printed again and again as long as the
Atari
<br>copyright remains intact.
=========================================================================
<br>
</div>
<p>A couple of notes: Unlike previous machines, there are just too
many resolutions to give each resolution a name. Therefore, I will do
my best to describe what the resolution is and which monitor it is on.
</p>
<pre>
 - NOTE: TV and a Color Monitor are the same.. by Color Monitor, I am
   talking about the standard SC1224. By VGA, I mean a standard VGA
   Monitor.

 40 column modes ( &quot;column&quot; means the number of x pixels divided by 8)
 ---------------
    4 color, normal, TV:         320x200,    4 colors, 2 planes
   16 color, normal, TV:         320x200,   16 colors, 4 planes
  256 color, normal, TV:         320x200,  256 colors, 8 planes
 True color, normal, TV:         320x200,  true color

    4 color, interlace, TV:      320x400,    4 colors, 2 planes
   16 color, interlace, TV:      320x400,   16 colors, 4 planes
  256 color, interlace, TV:      320x400,  256 colors, 8 planes
 True color, interlace, TV:      320x400,  true color

    4 color, normal, VGA:        320x480,    4 colors, 2 planes
   16 color, normal, VGA:        320x480,   16 colors, 4 planes
  256 color, normal, VGA:        320x480,  256 colors, 8 planes
 True color, normal, VGA:        320x480,  true color

    4 color, line-doubling, VGA: 320x240,    4 colors, 2 planes
   16 color, line-doubling, VGA: 320x240,   16 colors, 4 planes
  256 color, line-doubling, VGA: 320x240,  256 colors, 8 planes
 True color, line-doubling, VGA: 320x240,  true color

 80 column modes
 ---------------
    2 color, normal, TV:         640x200,    2 colors, 1 plane
    4 color, normal, TV:         640x200,    4 colors, 2 planes
   16 color, normal, TV:         640x200,   16 colors, 4 planes
  256 color, normal, TV:         640x200,  256 colors, 8 planes
 True color, normal, TV:         640x200,  true color

    4 color, interlace, TV:      640x400,    4 colors, 2 planes
   16 color, interlace, TV:      640x400,   16 colors, 4 planes
  256 color, interlace, TV:      640x400,  256 colors, 8 planes
 True color, interlace, TV:      640x400,  true color

    2 color, normal, VGA:        640x480,    2 colors, 1 plane
    4 color, normal, VGA:        640x480,    4 colors, 2 planes
   16 color, normal, VGA:        640x480,   16 colors, 4 planes
  256 color, normal, VGA:        640x480,  256 colors, 8 planes

    4 color, line-doubling, VGA: 640x240,    4 colors, 2 planes
   16 color, line-doubling, VGA: 640x240,   16 colors, 4 planes
  256 color, line-doubling, VGA: 640x240,  256 colors, 8 planes

</pre>
<p>and lastly.. there are compability modes for ST Low, ST Medium,
and ST High on both VGA monitors and SC1224 monitors. (On a color
monitor, ST High is achieved by using the intex ace mode).
</p>
<p>Also, the ST Monochrome monitor (the SM124) will work with Falcox
30 as well. However, it only supports one resolution: ST High
Resolution.
</p>
<p>All modes on a T0 can be overscanned. This means multiplying the X
and Y resolution by 1.2. For0 xample, modes with 320 pixels of
horizontal resolution (X res) will become 384 pixels across, and modes
with 640 pixels will become 768 across. Overscanning is done in the X
and Y resolution. You can't do them independently. Special Note: On a
VGA monitor, overscan is &quot;faked&quot;.. since the video hardware
doesn't have the capability to do overscan on a VGA monitor, we made
it so that if a overscan mode is set on a VGA monitor, you still see
the normal size screen, but the screen is a window onto the bigger
overscanned image. Make sense? We did this for compatibility. This way
if a game that has an overscanned starup picture can use the same pic
on both the VGA monitor and the TV monitor. Pretty cool, eh?
&lt;grin&gt;
</p>
<p>BTW.. Overscan can NOT be set from the desktop. The AES and
<a href="030505.htm" target="UDOcon">Desktop</a> will work just fine with it, but because you can't see the
parts of the screen, we thought that that option shouldn't be
available from the desktop. We don't want to confuse people. However,
Overscan can be set using a new XBIOS call (Vsetmode()).. so it is
still available.
</p>
<p>I hope I haven't made any mistakes. I triple-checked this document
in search of errors and I couldn't find any. If you do find some, send
me Email on GEnie (to TOWNS) or CIS (70007,1135) and let me know.
</p>
<p>- John Townsend, Atari Corp.
</p>
<p>P.S. Anyone who would like to reprint this message, please do so!
The smaller the number of times I have to type that message, the more
my fingers with thank you! ;-)
</p>
<p>After looking at this one more time.. one point to clear up: By
saying SC1224 Color Monitor, I mean any Color Monitor that Atari have
manufactured for the ST/Mega/STE/MegaSTE computers. Clear as mud? ;-)
</p>
<p>This article is written by Wilfred Kilwinger (Support Manager) for
Atari Briefing, the newsletter by Atari (Benelux) B.V. for the Atari
user groups. It was specifically stated that it could be reproduced. I
have translated it in English with the assumption that an English
translation would be considered the same as the original.
</p>
<p>The original also contained a description of all the features of
the Falcon which have been reproduced here a zillion of times so I did
not include these.
</p>
<p><tt>Atari custom chips</tt>
</p>
<p><tt>VIDEL</tt>
</p>
<p>The VIDEL takes care of the video functions of the system
including overscan, overlay mode and true color graphics
</p>
<p><tt>COMBEL</tt>
</p>
<p>The COMBEL is the system manager of the Atari Falcon030. This chip
controls all system functions. Also the BLITTER is built in in this
chip.
</p>
<p><tt>SDMA</tt>
</p>
<p>The SDMA is the Sound DMA and controls the sound part. We have
built in a unique matrix switch function in this chip (more details in
the second part)
</p>
<p><tt>KEYBOARD PROCESSOR</tt>
</p>
<p>The keyboard processor has been improved and is now also suitable
for high resolution mice.
</p>
<p>Besides the above custom chips the Atari Falcon030 has a number of
standard chips like the Motorola 68030 and 56001 DSP. Another
important chip is the CODEC in which the 16 bit AD and DA converters
are located.
</p>
<pre>
Video modi

As you can see in the survey of Operating System calls
the video hardware is complete sotware controllable. The following
combinations can a.o. be chosen:

Mode      Resolution  Bit planes  Colors  Palette

ST LOW     320x200       4           16     4096
ST MED     640x200       2            4     4096
ST HIGH    640x400       1            2     4096

True Color 640x480       8          256   262144
           320x200     15bpp      32768     N/A

The last mode asks for some explanation. Here there is no color palette but
15 bits per pixel to describe the pixel itself. The format is
RRRRRGGGGGXBBBBB. VDI supports this mode thus programs that have not been
written for this mode specifically can use it nevertheless.
X is the overlay bit and can be used for video titling and special effects.

          320x200     16bpp      65         N/A

This mode is called the slideshow mode, is not supported by the VDI, you
are on you own. X is an extra green bit.


True Color in 640x480 is not possible because of the bandwidth of VGA monitors.

Mode      Resolution Bit planes   Colors    Palette

VGA      320 of 640   1,4,8       2,16,256  262144 (Overscan
Video    200 of 400

With Video we mean the Atari SC-monitors, the TV modulator and/or the
composite video output.

All modes can be gegenlocked. With adaptors we convert
the 15-pole video bus to thee standard Atari or VGA connections.

       |----|
       -    -
      /      \
     /        \
    /          \
    |          |
    -|--------|-


Matrix coupling

To make the system performance in the audio part as good as possible Atari
designed a miniature 'telephone exchange' that can easily connect the
source devices to the receiving devices. Also it is possible to make more
than one connection at a time.


    Source devices

        EXT INPUT ---*-------*------*------*
         CHANNEL     |       |      |      |
                     |       |      |      |
           DSP    ---*-------*------*------*
        TRANSMIT     |       |      |      |
                     |       |      |      |
           ADC    ---*-------*------*------*
                     |       |      |      |
                     |       |      |      |
           DMA    ---*-------*------*------*
        PLAYBACK     |       |      |      |
                    DMA     DAC    DSP     EXT OUTPUT
                   RECORD        RECEIVE     CHANNEL

                        Receiving Devices


Ports and interfacing

DSP CONNECTOR (DB26 Female)
---------------------------

Pin   Signal                           Pin   Signal

1     GP0                              14    GND
2     GP1                              15    SRD
3     GP2                              16    GND
4     P_DATA                           17    +12V
5     P_CLK                            18    GND
6     P_SYNC                           19    R_DATA
7     n/c                              20    R_CLK
8     GND                              21    R_SYNC
9     +12V                             22    EXT_INT
10    GND                              23    STD
11    SC0                              24    SCK
12    SC1                              25    GND
13    SC2                              26    EXCLK


SCSI CONNECTOR (flat 50 pins SCSI II Female)
--------------------------------------------

Pin   Signal                           Pin   Signal

1-10  GND                              37    Not Connected
11    +5V                              38    +5V
12-14 Not Connected                    39    Not Connected
15-25 GND                              40    GND
26    SCSI 0                           41    ATN
27    SCSI 1                           42    GND
28    SCSI 2                           43    BSY
29    SCSI 3                           44    ACK
30    SCSI 4                           45    RST
31    SCSI 5                           46    MSG
32    SCSI 6                           47    SEL
33    SCSI 7                           48    C/D
34    Parity                           49    REQ
35-36 GND                              50    I/O


SERIAL PORT (DB9 MALE)
----------------------

Pin   Signal

1     Carrier Detect                   5     GND
2     Receive                          6     Data set ready
3     Transmit                         7     Request to Send
4     Data Terminal Ready              8     Clear to Send
                                       9     Ring Indicator

PARALLEL PORT (DB25 Female)
---------------------------

The parallel port has extra signal to ease the connection of scanners.

Pin   Signal

1     Strobe          8     Data 6
2     Data 0          9     Data 7
3     Data 1         10     Acknowledge
4     Data 2         11     Busy
5     Data 3         12-16  Not Connected
6     Data 4         17     Select
7     Data 5         18-25  GND


MONITOR CONNECTOR (DB19 Male)
-----------------------------

Pin   Signal                           Pin   Signal

1     Red                              11    GND
2     Green                            12    Composite Sync/Video
3     Blue                             13    Horizontal Sync
4     Mono/Overlay                     14    Vertical Sync
5     GND                              15    External Clock Input
6     Red GND                          16    External SYNC Enable
7     Green GND                        17    +12V
8     Blue GND                         18    M1
9     <a href="0907.htm" target="UDOcon">Audio</a> out                        19    M0
10    GND


SCC LAN-port CONNECTOR (8-pin Mini DIN Female RS-422)
-----------------------------------------------------

Pin   Signal

1     Handshake Output (DTR RS 423)           5     - Received Data
2     Handshake Input or External Clock       6     + Transmitted Data
3     - Transmit Data                         7     General-purpose Input
4     GND                                     8     + Receive


ENHANCED JOYSTICK (DB15 Male)
-----------------------------

Port A                                 Port B

Pin   Signal                           Pin   Signal

1     UP 0                             1     UP 1
2     DOWN 0                           2     DOWN 1
3     LT 0                             3     LT 1
4     RT 0                             4     RT 1
5     PAD0Y                            5     PAD1Y
6     FIRE 0 / LIGHT GUN               6     FIRE 1
7     VCC (+5 VDC)                     7     VCC
8     Not Connected                    8     Not Connected
9     GND                              9     GND
10    FIRE 2                           10    FIRE 3
11    UP 2                             11    UP 3
12    DOWN 2                           12    DOWN 3
13    LT 2                             13    LT 3
14    RT 2                             14    RT 3
15    PAD0X                            15    PAD1X


MIDI PORT (DIN 5 Female)
------------------------

MIDI OUT                               MIDI  IN

Pin   Signal                           Pin   Signal

1     Thru Transmit                    1     Not Connected
2     GND                              2     Not Connected
3     Thru Loop Return                 3     Not Connected
4     Out Transmit                     4     In Receive
5     Out Loop Return                  5     In Loop Return


New Operating System calls

This information is not complete, maybe subject to change and is certainly
not meant as documentation for programmers

DSP-calls

Dsp_DoBlock(a,b,c,d)                    (void) xbios(500,a,b,c,d)
Dsp_BlkHandShake(a,b,c,d)               (void) xbios(501,a,b,c,d)
Dsp_BlkUnpacked(a,b,c,d)                (void) xbios(502,a,b,c,d)
Dsp_InStream(a,b,c,d)                   (void) xbios(503,a,b,c,d)
Dsp_OutStream(a,b,c,d)                  (void) xbios(504,a,b,c,d)
Dsp_IOStream(a,b,c,d,e,f)               (void) xbios(505,a,b,c,d,e,f)
Dsp_RemoveInterrupts(a)                 (void) xbios(506,a)
Dsp_GetWordSize()                       (int)  xbios(507)
Dsp_Lock()                              (int)  xbios(508)
Dsp_Unlock()                            (void) xbios(509)
Dsp_Available(a,b)                      (void) xbios(510,a,b)
Dsp_Reserve(a,b)                        (int) xbios(511,a,b)
Dsp_LoadProg(a,b,c)                     (int) xbios(512,a,b,c)
Dsp_ExecProg(a,b,c)                     (void) xbios(513,a,b,c)
Dsp_ExecBoot(a,b,c)                     (void) xbios(514,a,b,c)
Dsp_LodToBinary(a,b)                    (long) xbios(515,a,b)
Dsp_TriggerHC(a)                        (void) xbios(516,a)
Dsp_RequestUniqueAbility()              (int)  xbios(517)
Dsp_GetProgAbility()                    (int)  xbios(518)
Dsp_FlushSubroutines()                  (void) xbios(519)
Dsp_LoadSubroutine(a,b,c)               (int)  xbios(520,a,b,c)
Dsp_InqSubrAbility(a)                   (int)  xbios(521,a)
Dsp_RunSubroutine(a)                    (int)  xbios(522,a)
Dsp_Hf0(a)                              (int)  xbios(523,a)
Dsp_Hf1(a)                              (int)  xbios(524,a)
Dsp_Hf2()                               (int)  xbios(525)
Dsp_Hf3()                               (int)  xbios(526)
Dsp_BlkWords(a,b,c,d)                   (void) xbios(527,a,b,c,d)
Dsp_BlkBytes(a,b,c,d)                   (void) xbios(528,a,b,c,d)
Dsp_HStat()                             (char) xbios(529)
Dsp_SetVectors(a,b)                     (void) xbios(530,a,b)

De volledige beschrijving van bovenstaande functie's staat in de Falcon030
Developers Documentation.


VIDEO SETMODE

int setmode( int modecode );

The setmode( int modecode ) call is used to place the Falcon/030 SHIFTER
into a specific mode. A bit-encoded value (called a &quot;modecode&quot;) is passed
to setmode() to set the mode. setmode() returns the previous mode that
was set.

To help make the building of modecode values easier, here is a table of
defines:

        #define VERTFLAG        0x100
        #define STMODES         0x80
        #define OVERSCAN        0x40
        #define PAL             0x20
        #define VGA             0x10
        #define TV              0x0

        #define COL80           0x08
        #define COL40           0x0
        #define NUMCOLS         7

        #define BPS16           4
        #define BPS8            3
        #define BPS4            2
        #define BPS2            1
        #define BPS1            0

Using these defines, you can build a modecode for any possible mode.
For example:

        For True Color Overscan:
        modecode = OVERSCAN|COL40|BPS16;

        For ST Medium Compatibility mode on a Color Monitor/TV:
        modecode = STMODES|COL80|BPS2;

        For ST Low Compatibility mode in PAL on a Color Monitor/TV:
        modecode = STMODES|PAL|COL80|BPS2;

        For 256 color, 80 column mode on a VGA monitor:
        modecode = VGA|COL80|BPS8;

If you have a modecode and wish to know how many bits per pixel it
has, use the following:

        if( modecode &amp; NUMCOLS ) == BPS16 )
        do_something_cool();    /* You have true color mode */

The setmode() call will return the previous modecode set. You must use
this value to get back to whatever mode you were in before you made your
setmode call.


int mon_type(void)

The mon_type() function will return the kind of monitor that is currently
in use. Here are the possible return values:

        0 = ST monochrome monitor
        1 = ST color monitor
        2 = VGA monitor
        3 = Television.


void ext_sync( int flag )

This function sets or clears external sync. If flag is set, external
sync is enabled. If flag is clear, then internal sync is used.


SOUND-calls

locksnd();
Used as a semiphore to lock the sound system. From other applications.

unlocksnd();
Used to release the sound system for other applications to use.

soundcmd(mode,data);
This command is used to get or set the following sound parameters.
If a negative number is used as the input then the current setting us
returned.

MODE    OPERATION       MEANING

O       LTATTEN Sets the current left channel output

1       RTATTEN Sets the current right channel output

2       LTGAIN  Sets the current left channel input gain.

3       RTGAIN  Sets the current right channel input gain.

4       ADDERIN Set the output of the 16 bit signed adder to
                receive it's input from the ADC, Matrix or
                both.

5       ADCINPUT        Set the input the the ADC. The input can either
                        be the left and right channel of the PSG or the
                        left and right channel of the microphone.

6       SETPRESCALE     Used for compatability. This prescale value
                        is used when the DEVCONNECT() internal
                        prescale value is set to zero.


setbuffer(reg,begaddr,endaddr);
This function is used to set the play or record buffers. REG selects
playback or record, while begaddr and endaddr are the buffers beginning
and ending locations.

        (int)   reg             - (0) Sets playback registers.
                                - (1) Sets record registers.
        (long)  begaddr - Sets the beginning address of the buffer.
        (long)  endaddr - Sets the ending address of the buffer.

setmode(mode);
This function is used to set record or playback mode. The modes are as
follows:

MODE            OPERATION
(int)   0      8 Bit Stereo
(int)   1      16 Bit Stereo
(int)   2      8 Bit Mono

settracks(playtracks,rectracks);
This function is used to sets the number of record or playback tracks.

setmontracks(montrack);
This function is used to set the output of the internal speaker to one of
the four tracks currently playing. The internal speaker is only capable of
outputing ONE track at a time.

setinterrupt(src_inter,cause);
This function is used to set which interrupt that will occur at the end of a
frame. If the frame repeat bit is on, this interrupt is used to allow for
double buffering the playing or recording of sound. Interrupts can come from
TimerA or the MFP i7.

buffoper(mode);
This function is used to control the operation of the play or record buffers
in the sound system. The input to this function is a bitmap. If mode is set
t0 -1 then the current status of x e buffer operation bits is returned.

NOTE:   The sound system contains a 32 byte FIFO. When transferring data to
the record buffer, software MUST check to see if the record enable (RE) bit
was cleared by the hardware. If the bit was cleared then the FIFO is flushed,
if not then software must flush the FIFO by clearing the record enable (RE)
bit.

dsptristate(dspxmit,dsprec);
This function is used to tristate the DSP from the data matrix.

gpio(mode,data);
This is used to communicate over the General Purpose I/O on the DSP connector.
Only the low order three bits are used. The rest are reserved. This call,
depending on the mode, can be used to set the direction of the I/O bits, read
the bits, or write the bits.

devconnect(src,dst,srcclk,prescale,protocol);
This function is used to attach a source device to any of the destination
devices in the matrix. Given a source device, this call will attach that one
source device to one or all of the destination devices. This call also sets
up the source clock and prescaler, protocol and protocol source if used.

sndstatus(reset);
This function gets the current status of the codec.

buffptr(pointer);
This function returns the current position of the play and record data buffer
pointers. These pointers indicate where the data is being read/written within
the buffers themselves. This function is also used to  determine how much
data has been written to the record buffer. See buffoper().


The above is not yet complete. Atari has also routines for
JPEG and andio conversion.
--
Piet* van Oostrum, Dept of Computer Science, Utrecht University,
Padualaan 14, P.O. Box 80.089, 3508 TB Utrecht, The Netherlands.
Telephone: +31 30 531806   Uucp:   uunet!mcsun!ruuinf!piet
Telefax:   +31 30 513791   <a href="15.htm" target="UDOcon">Internet</a>:  piet@cs.ruu.nl   (*`Pete')

</pre>
<p>http://www.mcc.ac.uk/&nbsp;dlms/Falcon/falcon.htlm
<br>
</p>
<p align=center><img src="image/sline.gif" border=0 width="640" height="2"></p><br>
<p align=center><img src="image/img1.gif" border=0 width="46" height="46"></p><br>

<hr>
<address>Copyright &copy; <a href="http://www.doitarchive.de">Robert Schaffner</a> (<a href="mailto:support@doitarchive.de">support@doitarchive.de</a>)<br>
Letzte Aktualisierung am 23. Dezember 2003</address>
</td></tr></table>
<table border=0 cellpadding=0 cellspacing=0 width="100%"><tr><td valign=top>
<a href="00con.htm" target="UDOcon"><img src="udo_hm.gif" alt="Home" border=0 width="24" height="24"></a>
<a href="03.htm" target="UDOcon"><img src="udo_up.gif" alt="Falcon F030 System" border=0 width="24" height="24"></a>
<a href="03.htm" target="UDOcon"><img src="udo_lf.gif" alt="Falcon F030 System" border=0 width="24" height="24"></a>
<a href="0302.htm" target="UDOcon"><img src="udo_rg.gif" alt="Falcon F030" border=0 width="24" height="24"></a>
</td></tr></table>
</body></html>
