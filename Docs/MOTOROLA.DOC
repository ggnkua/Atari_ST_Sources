

          Documentation on the MC68030 processor by Bj≥rn Ove èrthun
          Also known as Zynx/Inferiors (ex Imagina). or as Hei on irc


          I wrote this doc as there are no good docs on the 030. This doc
          will be ugraded a couple of times -  at least every month.
          The next version will include about 10 more pages about
          optimizing

          any ideas or suggestions contact:

          Bjorn Ove Arthun, ulsbergtunet 11, 4033 Forus, Norway
      

          I am a game developer. Check out my stargate 2000 game for the 
          Falcon on this web page:


          http://www-users.informatik.rwth-aachen.de/~neil/ad/


----------------------------------------------------------------------------

+--------------------------------------------------------------------------+
|Mnemonic   |Description              |Mnemonic |Description               |
+--------------------------------------------------------------------------+
|ACBD       |Add Decimal with Extend  |MULS     |Signed Multiply	
|ADD        |Add                      |MULU     |Unsigned Multiply
|ADDA       |Add Address              |---------|---------------------------
|ADDI       |Add Immediate            |NBCD     |Negate Decimal with Extend
|ADDQ       |Add Quick	            |NEG      |Negate
|ADDX       |Add with Extend          |NEGX     |Negate with Extend
|AND        |Logical AND              |NOP      |No Operation
|ANDI       |Logical AND Immediate    |NOT      |Logical Complement
|ASL, ASR   |Arithmetic Shift L/R     |---------|---------------------------
|-----------|                         |OR       |Logical inclusive Or
|Bcc        |Branch Conditionally     |ORI      |Logical inclusive Immediate
|BCHG       |Test Bit and change      |---------|---------------------------
|BFCLR      |Test Bit Field and Clr   |PACK     |Pack BCD
|BFEXTS     |Signed Bit Field Extract |PEA      |Push Effective Address
|BFEXTU     |Unsigned -----||-----    |---------|---------------------------
|BFFFO      |Bit Field Find First One |RESET    |Reset External Devices
|BFINS      |Bit Field Insert         |ROL, ROR |Rotate Left and Right
|BFSET      |Test Bit Field and Set   |ROXL,ROXR|Rotate with Extend
|BFTST      |Test Bit Field           |RTD      |Return and Deallocate
|BKPT       |Breakpoint               |RTE      |Return from Exception
|BRA        |Branch                   |RTM      |Return from Module
|BSET       |Test Bit and Set         |RTR      |Return from Restore Codes
|BSR        |Branch to Subroutine     |RTS      |Return from Subroutine
|BTST       |Test Bit                 |---------|---------------------------
|-----------|                         |SBCD     |Subtr. Decimal with Extend
|CALLM      |Call Module              |Scc      |Set Conditionally
|CAS        |Compare and Swap Operands|STOP     |Stop
|CAS2       |As above in Dual Mode    |SUB      |Subtract
|CHK        |Check Reg: Against Bound |SUBA     |Subtract Address
|CHK2       |Check Against Upper and  |SUBI     |Subtract Immediate
|           |Lower Bounds             |SUBQ     |Subtract Quick
|CLR        |Clear                    |SUBX     |Subtract with Extend
|CMP        |Compare                  |SWAP     |Swap Register words
|CMPA       |Compare Address          |---------|---------------------------
|CMPI       |Compare Immediate        |TAS      |Test Operand and Set
|CMPM       |Compare Memory to Memory |TRAP     |Trap
|CMP2       |Compare Register Against |TRAPcc   |Trap Conditionally
|           |Upper and Lower Bounds   |TRAPV    |Trap on Overflow
|-----------|                         |TST      |Test Operand
|DBcc       |Test Condition, Decrement|---------|---------------------------
|           |and Branch               |UNLK     |Unlink
|DIVS, DIVSL|Signed Divide            |UNPK     |Unpack
|DIVU, DIVUL|Unsigned Divide          |-------------------------------------
|-----------|                         |      CoProcessor Instructions 	
|EOR        |Exclusive Or             |-------------------------------------
|EORI       |Exclusive Or Immediate   |cpBcc    |Branch Conditionally
|EXG        |Exchange Registers       |cpDBcc   |Test Condition, 
|EXT, EXTB  |Signed Extend            |         |Decrement and Branch
|-----------|                         |cpGEN    |Coprocessor General Instr.
|ILLEGAL    |Take Illegal Instruction |cpRESTORE|Restore Internal State
|           |Trap                     |cpSAVE   |Save Internal State
|-----------|                         |cpScc    |Set Conditionally
|JMP        |Jump                     |cpTRAPcc |Trap Conditionally
|JSR        |Jump to Subroutine       |---------+---------------------------
|-----------|                         |	Unofficial Instructions
|LEA        |Load Effective Address   |-------------------------------------
|LINK       |Link and Allocate        |         |
|LSL, LSR   |Logical Shift Left and   |         |Not complete. :)
|           |Right                    |         |
|-----------|                         |         |
|MOVE       |Move                     |         |
|MOVEA      |Move Address             |         |
|MOVE CCR   |Move Condition Code Reg. |         |
|MOVE SR    |Move Status Register     |         |
|MOVE USP   |Move User Stack Pointer  |         |
|MOVEC      |Move Control Register    |         |
|MOVEM      |Move Multiple            |         |
|MOVEP      |Move Peripheral          |         |
|MOVEQ      |Move Quick               |         |
|MOVES      |Move Alternate Address   |         |
|           |Space                    |         |
+
|     Dual Mode: 64 bit processing intructions eg. Muls.l d0,d1:d2 
|	The Destination Operand is in 64 bit format 
+--------------------------------------------------------------------------+
|              Addressing Modes and Assembler Syntax
+--------------------------------------------------------------------------+
|Address Modes				Syntax
+--------------------------------------------------------------------------+

01. Data register direct			Dn
------------------------------------------------------------
02. Address register direct			An
------------------------------------------------------------
03. Address register indirect			(An)+
    with postincrement 		
------------------------------------------------------------
04. Address register indirect			-(An)
    with predecrement
------------------------------------------------------------
05. Address register indirect			(d16,An)
    with displacement
------------------------------------------------------------
06. Address register indirect			(d8,An,Xn)
    with index (8bit displacement)		
------------------------------------------------------------
07. Address register indirect			(bd,An,Xn)
    with index (base displacement)	
------------------------------------------------------------
08. Memory indirect postindexed			([bd,An],Xn,od)
------------------------------------------------------------
09. Memory indirect preindexed			([bd,An,Xn],od)
------------------------------------------------------------
0a. Absolute short				       (xxx).W
------------------------------------------------------------
0b. Absolute long				       (www).L
------------------------------------------------------------
0c. Program counter indirect			(d16,PC)
    with displacement
------------------------------------------------------------
0d. Program counter indirect with			(d8,PC,Xn)
    index (8-bit displacement)
------------------------------------------------------------
0e. Program counter indirect with			(bd,An,Xn)
    index (base displacement)
------------------------------------------------------------
0f. PC memory indirect postindexed			([bd,PC],Xn,od)
------------------------------------------------------------
10. PC memory indirect preindexed			([bd,PC,Xn],od)
------------------------------------------------------------
11. Immediate				#<data>
------------------------------------------------------------


+--------------------------------------------------------------------------+
|	        Instruction Assembler Syntax
+--------------------------------------------------------------------------+

           Instructions are separated by asterix lines.
****************************************************************************
Add Binary Coded Decimal w/extend

NAME	ABCD -- Add binary coded decimal

SYNOPSIS	ABCD	Dy,Dx
	ABCD	-(Ay),-(Ax)

	Size = Byte

FUNCTION
       Adds the source operand to the destination operand along with
	the extend bit, result is stored in the destination location.
	The addition is performed using binary coded decimal arithmetic.
	The operands, which are packed BCD numbers, can be addressed in
	two different ways:

	1. Data register to data register: The operands are contained
	   in the data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the
	   predecremented addressing mode using the address registers
	   specified in the instruction.

	This operation is a byte operation only.

	Normally the Z condition code bit is set via programming before
	the start of an operation. That allows successful tests for
	zero results upon completion of multiple-precision operations.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|---|---|---|---|---|-----------|
       | 1 | 1 | 0 | 0 |    Rx     | 1 | 0 | 0 | 0 | 0 |R/M|    Ry     |
       +---------------------------------------------------------------+

	R/M = 0 -> data register
	R/M = 1 -> address register
	Rx:   destination register
	Ry:   source register

RESULT
	X - Set the same as the carry bit.
	N - Undefined
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Undefined
	C - Set if a decimal carry was generated. Cleared otherwise.
****************************************************************************
ADD integer

NAME	ADD -- Add integer

SYNOPSIS	ADD	<ea>,Dn
	ADD	Dn,<ea>

	Size = Byte, Word, Long

FUNCTION	
	Source- and destination-operand are added using binary addition.
	The result is stored in the destination location
	The size of the operation may be specified as byte, word, or
	long. The mode of the instruction indicates which operand is the
	source and which is the destination as well as the operand size.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|-----------|-----------|-----------|
       | 1 | 1 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
       +---------------------------------------========================+
                                                          <ea>

OP-MODE	Byte	Word	Long
	~~~~	~~~~	~~~~
	000	001	010	(Dn) + (<ea>) -> Dn
	100	101	110	(<ea>) + (Dn) -> <ea>

REGISTER	One of the 8 datas registers

       If <ea> is source, allowed addressing modes are:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (d16,An)    |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+
	 * Word or Long only

       If <ea> is destination, allowed addressing modes are:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+
       When destination is an Address Register, ADDA instruction is used.

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.
****************************************************************************
ADD Address

NAME	ADDA -- Add address

SYNOPSIS	ADDA	<ea>,An

	Size = Word, Long

FUNCTION
       Adds the source operand to the destination address register,
	and stores the result in the destination address register. The
	size of the operation may be specified as word or long. The
	entire destination operand is used regardless of the operation
	size.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|-----------|-----------|-----------|
       | 1 | 1 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
       +---------------------------------------========================+
                                                         <ea>
       P-MODE	Indicates operation lenght:
       011->one Word operation: source operand is extended to 32 bits
       111->one Long operation
       REGISTER	One of the 8 address registers.
	<ea> is always source, all addressing modes are allowed.

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (d16,An)    |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT	None.
****************************************************************************
ADD Immediate

NAME	ADDI -- Add immediate

SYNOPSIS	ADDI	#<data>,<ea>

	Size = Byte, Word, Long

FUNCTION
       Adds the immediate data to the destination operand, and
	stores the result in the destination location. The size of the
	operation may be specified as byte, word, or long. The size
	of the immediate data matches the operation size.

FORMAT
                                                          <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|-------|-----------|-----------|
       | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | SIZE  |   MODE    |  REGISTER |
       |---------------------------------------------------------------|
       | 16 BITS DATA (with last Byte) |          8 BITS DATA          |
       |---------------------------------------------------------------|
       |             32 BITS DATA (included last Word)                 |
       +---------------------------------------------------------------+

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER	

       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

****************************************************************************

ADD 3-bit immediate Quick

NAME	ADDQ -- Add 3-bit immediate quick

SYNOPSIS	ADDQ	#<data>,<ea>

	Size = Byte, Word, Long

FUNCTION
       Adds the immediate value of 1 to 8 to the operand at the
	destination location. The size of the operation may be specified
	as byte, word, or long. When adding to address registers,
	the condition codes are not altered, and the entire destination
	address register is used regardless of the operation size.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|-------|-----------|-----------|
       | 0 | 1 | 0 | 1 |    DATA   | 0 | SIZE  |    MODE   |  REGISTER |
       +---------------------------------------========================+
                                                         <ea>

               			

DATA	000        ->represent value 8
	001 to 111 ->immediate data from 1 to 7

SIZE	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER	<ea> is always destination, addressing modes are the following:

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+
	 * Word or Long only.

RESULT	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

****************************************************************************

ADD integer with eXtend

NAME	ADDX -- Add integer with extend

SYNOPSIS	ADDX	Dy,Dx
	ADDX	-(Ay),-(Ax)

	Size = Byte, Word, Long

FUNCTION
       Adds the source operand to the destination operand along with
	the extend bit, and stores the result in the destination 
	location. The addition is performed using binary coded decimal
	arithmetic. The operands, which are packed BCD numbers, can
	be addressed in two different ways:

	1. Data register to data register: The operands are contained
	   in the data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the
	   predecrement addressing mode using the address registers
	   specified in the instruction.

	The size of operation can be specified as byte, word, or long.

	Normally the Z condition code bit is set via programming before
	the start of an operation. That allows successful tests for zero
	results upon completion of multiple-precision operations.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|-------|---|---|---|-----------|
       | 1 | 1 | 0 | 1 |    Rx     | 1 | SIZE  | 0 | 0 |R/M|    Ry     |
       +---------------------------------------------------------------+

	R/M = 0 -> data register
	R/M = 1 -> address register
	Rx:   destination register
	Ry:   source register

SIZE	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

****************************************************************************

Logical AND

NAME	AND -- Logical AND

SYNOPSIS	AND	<ea>,Dn
	AND	Dn,<ea>

	Size = Byte, Word, Long

FUNCTION
       Performs a bit-wise AND operation with the source operand
	and the destination operand and stores the result in the
	destination. The size of the operation may be specified as
	byte, word, or long. The contents of an address register may
	not be used as an operand.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|-----------|-----------|-----------|
       | 1 | 1 | 0 | 0 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
       +---------------------------------------========================+
                                                         <ea>

OP-MODE	Byte	Word	Long
	000	001	010	(Dn)AND(<ea>)-> Dn
	100	101	110	(<ea>)AND(Dn)-> <ea>


REGISTER

       One of the 8 datas registers
       If <ea> is source, allowed addressing modes are:

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (d16,An)    |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

       If <ea> is destination, allowed addressing modes are:

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

       AND between two datas registers is allowed if you consider the
       syntax where Dn is at destination's place.

       If you use this instruction with an immediate data, it does the
       same as instruction ANDI.
	

RESULT	X - Not affected
	N - Set if the most-significant bit of the result was set.
	    Cleared otherwise.
	Z - Set if the result was zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

****************************************************************************

Logical AND Immediate

NAME	ANDI -- Logical AND immediate

SYNOPSIS	ANDI	#<data>,<ea>

	Size = Byte, Word, Long

FUNCTION
       Performs a bit-wise AND operation with the immediate data and
	the destination operand and stores the result in the destination.
	The size of ther operation can be specified as byte, word, or
	long. The size of the immediate data matches the operation size.

FORMAT
                                                          <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|-------|-----------|-----------|
       | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | SIZE  |   MODE    |  REGISTER |
       |---------------------------------------------------------------|
       | 16 BITS DATA (with last Byte) |          8 BITS DATA          |
       |---------------------------------------------------------------|
       |             32 BITS DATA (included last Word)                 |
       +---------------------------------------------------------------+

SIZE	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
       <ea> is always destination, addressing modes are the following:

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT	X - Not affected
	N - Set if the most-significant bit of the result was set.
	    Cleared otherwise.
	Z - Set if the result was zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

****************************************************************************

Logical AND Immediate to CCR

NAME	ANDI to CCR -- Logical AND immediate to condition code register

SYNOPSIS	ANDI	#<data>,CCR

	Size = Byte

FUNCTION
	Performs a bit-wise AND operation with the immediate data and
	the lower byte of the status register.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |     8 BITS IMMEDIATE DATA     |
       +---------------------------------------------------------------+

RESULT
       X - Cleared if bit 4 of immed. operand is zero. Unchanged otherwise.
       N - Cleared if bit 3 of immed. operand is zero. Unchanged otherwise.
       Z - Cleared if bit 2 of immed. operand is zero. Unchanged otherwise.
       V - Cleared if bit 1 of immed. operand is zero. Unchanged otherwise.
       C - Cleared if bit 0 of immed. operand is zero. Unchanged otherwise.

****************************************************************************

Logical AND Immediate to SR (privileged)

NAME    ANDI to SR -- Logical AND immediate to status register (privileged)

SYNOPSIS	ANDI	#<data>,SR

	Size = Word

FUNCTION
	Performs a bit-wise AND operation with the immediate data and
	the status register. All implemented bits of the status register
	are affected.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
       | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
       |---------------------------------------------------------------|
       |                     16 BITS IMMEDIATE DATA                    |
       +---------------------------------------------------------------+

RESULT
       X - Cleared if bit 4 of immed. operand is zero. Unchanged otherwise.
       N - Cleared if bit 3 of immed. operand is zero. Unchanged otherwise.
       Z - Cleared if bit 2 of immed. operand is zero. Unchanged otherwise.
       V - Cleared if bit 1 of immed. operand is zero. Unchanged otherwise.
       C - Cleared if bit 0 of immed. operand is zero. Unchanged otherwise.

****************************************************************************

Arithmetic Shift Left and Arithmetic Shift Right

NAME	ASL, ASR -- Arithmetic shift left and arithmetic shift right

SYNOPSIS	ASd	Dx,Dy
	ASd	#<data>,Dy
	ASd	<ea>
	where d is direction, L or R

	Size = Byte, Word, Long

FUNCTION
	Performs an arithmetic shifting bit operation in the indicated
	direction, with an immediate data, or with a data register.
	If you shift address contents, you can only do ONE shift, and
	your operand is ONE word exclusively.

	ASL:              <--  
	      C <------ OPERAND <--- 0
	            |
	            |
	      X <---'
	       

	ASR:    -->
	.---> OPERAND ------> C
	|    T          |
	|    |          |
	`----'          `---> X

FORMAT
       In the case of the shifting of a register:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|-------|---|---|---|-----------|
       | 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 0 | 0 | REGISTER  |
       |   |   |   |   |  REGISTER |   |       |   |   |   |           |
       +---------------------------------------------------------------+

       In the case of the shifting of a memory area:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 0 | 0 | 0 |dr | 1 | 1 |    MODE   | REGISTER  |
       +---------------------------------------========================+
                                                         <ea>


NUMBER/REGISTER
       Specifies number of shifting or number of register which contents
       the number of shifting.
       If i/r = 0, number of shifting is specified in the instruction as
       immediate data
       If i/r = 1, it's specified in the data register.
       If dr = 0, right shifting
       If dr = 1, left shifting

SIZE   00->one Byte operation
       01->one Word operation
       10->one Long operation

REGISTER
       For a register shifting:
       Indicates the number of data register on which shifting is applied.

       For a memory shifting:
       <ea> indicates operand which should be shifted.
       Only addressing modes allowed are:

       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - Set according to the list bit shifted out of the operand.
           Unaffected for a shift count of zero.
       N - Set if the most-significant bit of the result is set. Cleared
           otherwise.
       Z - Set if the result is zero. Cleared otherwise.
       V - Set if the most significant bit is changed at any time during
           the shift operation. Cleared otherwise.
       C - Set according to the list bit shifted out of the operand.
           Cleared for a shift count of zero.

****************************************************************************
bingbangbong


Conditional branch

NAME	Bcc -- Conditional branch

SYNOPSIS	Bcc	<label>

	Size = Byte, Word, Long*

	* 68020+ only

FUNCTION
       If condition true then program execution continues at:
       (PC) + offset.
       PC value is instruction address more two.
       Offset is the relative value in bytes which separate Bcc instruction
       of mentioned label.
 
       Condition code 'cc' specifies one of the following:

0000 F  False        Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True         Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh         C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same  C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear  C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set    C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal    Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual        Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---------------|-------------------------------|
       | 0 | 1 | 1 | 0 |   CONDITION   |         8 BITS OFFSET         |
       |---------------------------------------------------------------|
       |            16 BITS OFFSET, IF 8 BITS OFFSET = $00             |
       |---------------------------------------------------------------|
       |            32 BITS OFFSET, IF 8 BITS OFFSET = $FF             |
       +---------------------------------------------------------------+

RESULT	None.

****************************************************************************

Bit Change

NAME   BCHG -- Bit change

SYNOPSIS
       BCHG	Dn,<ea>
       BCHG	#<data>,<ea>

       Size = Byte, Long

FUNCTION
       Tests a bit in the destination operand and sets the Z condition
       code appropriately, then inverts the bit in the destination.
       If the destination is a data register, any of the 32 bits can be
       specified by the modulo 32 number. When the destination is a memory
       location, the operation must be a byte operation, and therefore the
       bit number is modulo 8. In all cases, bit zero is the least
       significant bit. The bit number for this operation may be specified
       in either of two ways:

       1. Immediate -- The bit number is specified as immediate data.
       2. Register  -- The specified data register contains the bit number.

FORMAT
       In the case of BCHG Dn,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 |  REGISTER | 1 | 0 | 1 |    MODE   | REGISTER  |
       +---------------------------------------========================+
                                                         <ea>

       In the case of BCHG #<data,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |       NUMBER OF THE BIT       |
       +---------------------------------------------------------------+

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn *     |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+
        * Long only; for others modes: Byte only.

RESULT
       X - not affected
       N - not affected
       Z - Set if the bit tested is zero. Cleared otherwise.
       V - not affected
       C - not affected

***********************************************************

Bit Clear

NAME   BCLR -- Bit clear

SYNOPSIS    
       BCLR	Dn,<ea>
       BCLR	#<data>,<ea>

       Size = (Byte, Long)

FUNCTION
       Tests a bit in the destination operand and sets the Z
       condition code appropriately, then clears the bit in the destination.
       If the destination is a data register, any of the 32 bits can be
       specifice by the modulo 32 number. When the distination is a memory
       location, the operation must be a byte operation, and therefore the
       bit number is modulo 8. In all cases, bit zero is the least
       significant bit. The bit number for this operation may be specified
       in either of two ways:

       1. Immediate -- The bit number is specified as immediate data.
       2. Register  -- The specified data register contains the bit number.

FORMAT
       In the case of BCLR Dn,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 |  REGISTER | 1 | 1 | 0 |    MODE   | REGISTER  |
       +---------------------------------------========================+
                                                         <ea>

       In the case of BCLR #<data,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |    MODE   | REGISTER  |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |       NUMBER OF THE BIT       |
       +---------------------------------------------------------------+

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn *     |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+
        * Long only; for others modes: Byte only.

RESULT
       X - not affected
       N - not affected
       Z - Set if the bit tested is zero. Cleared otherwise.
       V - not affected
       C - not affected

***********************************************************
Bit Field Change

NAME   BFCHG -- Bit field change

SYNOPSIS
       BFCHG  <ea>{OFFSET:WIDTH}	(68020+)

       No size specs.

FUNCTION
       <ea> indicates destination operand which a part of bits have to be
       inverted. Offset enables to locate first bit of field; width specifies
       number of bits of this field. Field is tested, flags are set, and bits
       of field are inverted.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|-------------------|-----------------------|
       | 0 | 0 | 0 | 0 |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

       If Do = 0->Field "OFFSET" contains an immediate value which represents
       effective offset, value from 0 to 31.
       If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
       and 10 of field cleared) which contains effective offset. Signed value
       is represented on 32 bits., so it's extended from -2 EXP 31 to
       (+2 EXP 31) -1.

       If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
       which indicates a width from 1 to 31 bits. A value of 0 indicates a
       width of 32 bits.
       If Dw = 1->field "WIDTH" indicates number of a data register
       (bits 3 and 4 of field cleared) which contains width of bit field.
       The value modulo 32 can range from 1 to 31, indicating a width from
       1 to 31 bits. A value 0 indicates a width of 32 bits.

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Clear

NAME   BFCLR -- Bit field clear

SYNOPSIS
       BFCLR  <ea>{OFFSET:WIDTH}	(68020+)

       No size specs.

FUNCTION
       <ea> indicates destination operand which a part of bits have to be
       cleared. Offset enables to locate first bit of field; width specifies
       number of bits of this field. Field is tested, flags are set, and bits
       of field are cleared.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|-------------------|-----------------------|
       | 0 | 0 | 0 | 0 |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

       If Do = 0->Field "OFFSET" contains an immediate value which
       represents  effective offset, value from 0 to 31. If Do = 1->Field
       "OFFSET" indicates number of a data register (bits 9 and 10 of field
       cleared) which contains effective offset. Signed value is represented
       on 32 bits., so it's extended from -2 EXP 31 to (+2 EXP 31) -1.
       
       If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
       which indicates a width from 1 to 31 bits. A value of 0 indicates a
       width of 32 bits.
       If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
       and 4 of field cleared) which contains width of bit field. The value
       modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
       A value 0 indicates a width of 32 bits.

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Signed Extract

NAME
       BFEXTS -- Bit field signed extract

SYNOPSIS
       BFEXTS  <ea>{OFFSET:WIDTH},Dn	(68020+)

       No size specs.

FUNCTION
       <ea> indicates source operand which a part of bits have to be
       extracted and extended. Offset enables to locate first bit of field;
       width specifies	number of bits of this field. Field is extracted,
       and extended to 32 bits by the MSB of the field. Result is stored
       in the data register Dn.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 |    MODE   | REGISTER  |
       |---|-----------|---|-------------------|-----------------------|
       | 0 |  REGISTER |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

       If Do = 0->Field "OFFSET" contains an immediate value which
       represents effective offset, value from 0 to 31. If Do = 1->Field
       "OFFSET" indicates number of a data register (bits 9 and 10 of field
       cleared) which contains effective offset. Signed value is represented
       on 32 bits., so it's extended from -2 EXP 31 to (+2 EXP 31) -1.
       
       If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
       which indicates a width from 1 to 31 bits. A value of 0 indicates a
       width of 32 bits.
       If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
       and 4 of field cleared) which contains width of bit field. The value
       modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
       A value 0 indicates a width of 32 bits.
       
REGISTER
       <ea> specifies destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Unsigned Extract
NAME
       BFEXTU -- Bit field unsigned extract"

SYNOPSIS
       BFEXTU  <ea>{OFFSET:WIDTH},Dn  (68020+)

       No size specs.

FUNCTION
       <ea> indicates source operand which a part of bits have to be
       extracted and extended. Offset enables to locate first bit of field;
       width specifies	number of bits of this field. Field is extracted,
       and extended to 32 bits by zero. Result is stored in the data
       register Dn.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 |    MODE   | REGISTER  |
       |---|-----------|---|-------------------|-----------------------|
       | 0 |  REGISTER |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

      If Do = 0->Field "OFFSET" contains an immediate value which represents
      effective offset, value from 0 to 31.
      If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
      and 10 of field cleared) which contains effective offset. Signed value
      is represented on 32 bits., so it's extended from -2 EXP 31 to
      (+2 EXP 31) -1.

      If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
      which indicates a width from 1 to 31 bits. A value of 0 indicates a
      width of 32 bits.
      If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
      and 4 of field cleared) which contains width of bit field. The value
      modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
      A value 0 indicates a width of 32 bits.

REGISTER
       <ea> specifies destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Find First One set

NAME
       BFFFO -- Bit field find first one set

SYNOPSIS
       BFFFO	<ea>{OFFSET:WIDTH},Dn	(68020+)

       No size specs.

FUNCTION
       <ea> indicates source operand which a part of bits have to be
       examined. Offset enables to locate first bit of field; width
       specifies number of bits of this field. Field is examined,
       offset of first bit set is encountred, the MSB is stored in
       the data register Dn.
       Offset is equal to base offset more offset of bit into examined
       field.
       If no bits set are found, data register Dn contains a value which
       follows to initial offset more width of bit field. 
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 |    MODE   | REGISTER  |
       |---|-----------|---|-------------------|-----------------------|
       | 0 |  REGISTER |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

      If Do = 0->Field "OFFSET" contains an immediate value which represents
      effective offset, value from 0 to 31.
      If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
      and 10 of field cleared) which contains effective offset. Signed value
      is represented on 32 bits., so it's extended from -2 EXP 31 to
      (+2 EXP 31) -1.

      If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
      which indicates a width from 1 to 31 bits. A value of 0 indicates a
      width of 32 bits.
      If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
      and 4 of field cleared) which contains width of bit field. The value
      modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
      A value 0 indicates a width of 32 bits.

REGISTER
       <ea> specifies destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Insert

NAME
       BFINS -- Bit field insert

SYNOPSIS
       BFINS  Dn,<ea>{OFFSET:WIDTH}	(68020+)

       No size specs.

FUNCTION
       <ea> indicates destination operand which field of bits have to be
       inserted. Offset enables to locate first bit of field;
       width specifies	number of bits of this field.
       Bit field from Dn, which must be inserted in destination operand,
       is located in relation to bit zero. This bit zero, after insert,
       will have for offset: base offset more (width - 1).
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 |    MODE   | REGISTER  |
       |---|-----------|---|-------------------|-----------------------|
       | 0 |  REGISTER |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

      If Do = 0->Field "OFFSET" contains an immediate value which represents
      effective offset, value from 0 to 31.
      If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
      and 10 of field cleared) which contains effective offset. Signed value
      is represented on 32 bits., so it's extended from -2 EXP 31 to
      (+2 EXP 31) -1.

      If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
      which indicates a width from 1 to 31 bits. A value of 0 indicates a
      width of 32 bits.
      If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
      and 4 of field cleared) which contains width of bit field. The value
      modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
      A value 0 indicates a width of 32 bits.

REGISTER
       <ea> specifies destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Set

NAME   BFSET -- Bit field set 

SYNOPSIS
       BFSET  <ea>{OFFSET:WIDTH}	(68020+)

       No size specs.

FUNCTION
       <ea> indicates destination operand which a part of bits have to be
       set. Offset enables to locate first bit of field; width specifies
       number of bits of this field. Field is tested, flags are set, and bits
       of field are set.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|-------------------|-----------------------|
       | 0 | 0 | 0 | 0 |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

       If Do = 0->Field "OFFSET" contains an immediate value which represents
       effective offset, value from 0 to 31.
       If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
       and 10 of field cleared) which contains effective offset. Signed value
       is represented on 32 bits., so it's extended from -2 EXP 31 to
       (+2 EXP 31) -1.

       If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
       which indicates a width from 1 to 31 bits. A value of 0 indicates a
       width of 32 bits.
       If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
       and 4 of field cleared) which contains width of bit field. The value
       modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
       A value 0 indicates a width of 32 bits.

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

Bit Field Test

NAME   BFTST -- Bit field test

SYNOPSIS
       BFTST  <ea>{OFFSET:WIDTH}	(68020+)

       No size specs.

FUNCTION
       <ea> indicates destination operand which a part of bits have to be
       tested. Offset enables to locate first bit of field; width specifies
       number of bits of this field. Field is tested, flags are set.
       Be careful, this instruction operates from MSB to LSB!!

FORMAT
                                                         <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|-------------------|-----------------------|
       | 0 | 0 | 0 | 0 |Do |       OFFSET      |Dw |      WIDTH        |
       +---------------------------------------------------------------+

      If Do = 0->Field "OFFSET" contains an immediate value which represents
      effective offset, value from 0 to 31.
      If Do = 1->Field "OFFSET" indicates number of a data register (bits 9
      and 10 of field cleared) which contains effective offset. Signed value
      is represented on 32 bits., so it's extended from -2 EXP 31 to
      (+2 EXP 31) -1.

      If Dw = 0->field "WIDTH" contains an immediate value between 1 and 31
      which indicates a width from 1 to 31 bits. A value of 0 indicates a
      width of 32 bits.
      If Dw = 1->field "WIDTH" indicates number of a data register (bits 3
      and 4 of field cleared) which contains width of bit field. The value
      modulo 32 can go from 1 to 31, indicating a width from 1 to 31 bits.
      A value 0 indicates a width of 32 bits.

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------+ +-----------------------------+
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
       |-------------------------------| |-----------------------------|
       |     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| +-----------------------------+
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       +-------------------------------+

RESULT
       X - not affected
       N - Set if MSB of field is set. Cleared otherwise.
       Z - Set if all the bits of the field tested are zero.
           Cleared otherwise.
       V - Always cleared.
       C - Always cleared.

***********************************************************

BreaK-Point
NAME   BKPT -- Break-point

SYNOPSIS
       BKPT	#<data>

FUNCTION
       This instruction is used to support the program breakpoint
       function for debug monitors and real-time hardware emulators, and
       the operation will be dependent on the implementation. Execution of
       this instruction will cause the MC68010 to run a breakpoint
       acknowledge bus cycle and zeros on all address lines, but an
       MC68020 will place the immediate data on lines A2, A3, and A4, and
       zeros on lines A0 and A1.

       Whether the breakpoint acknowledge cycle is terminaled with
        _____    ____       ___  
       (DTACK), (BERR), or (VPA) the processor always takes an illegal
       instruction exception. During exception processing, a debug monitor
       can distinguish eight different software breakpoints by decoding the
       field in the BKPT instruction.

       For the MC68000 and the MC68HC000, this instruction causes an illegal
       instruction exception, but does not run the breakpoint acknowledge
       bus cycle.

       There are two possible responses on an MC68020: normal and exception.
       The normal response is an operation word (typically the instruction
                                                                  ______
       the BKPT originally replaced) on the data lines with the (DSACKx)
       signal asserted. The operation word is the executed in place of the
       breakpoint instruction.

       For the exception response, a bus error signal will cause the MC68020
       to take an illegal instruction exception, just as an MC68010 or
       MC68000 would do.

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
       | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |N∞ BREAKPT.|
       +---------------------------------------------------------------+

       Number of break-point: Value between 0 and 7.

RESULT None.

***********************************************************

Unconditional Branch

NAME   BRA -- Unconditional branch

SYNOPSIS
       BRA	<label>

       Size = Byte, Word
       Size = Byte, Word, Long	(68020+)

FUNCTION
       Program execution continues at location (PC) + offset.
       Offset is the relative gap between PC value at BRA ((PC) + 2)
       instruction execution time and mentioned label. 

FORMAT
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |         8 BITS OFFSET         |
       |---------------------------------------------------------------|
       |            16 BITS OFFSET, IF 8 BITS OFFSET = $00             |
       |---------------------------------------------------------------|
       |            32 BITS OFFSET, IF 8 BITS OFFSET = $FF             |
       +---------------------------------------------------------------+

RESULT   None.

***********************************************************

Bit Set

NAME   BSET -- Bit set

SYNOPSIS
       BSET	Dn,<ea>
       BSET	#<data>,<ea>

       Size = Byte, Long

FUNCTION
       Tests a bit in the destination operand and sets the Z condition code
       appropriately, then sets the bit in the destination.
       If the destination is a data register, any of the 32 bits can be
       specifice by the modulo 32 number. When the distination is a memory
       location, the operation must be a byte operation, and therefore the
       bit number is modulo 8. In all cases, bit zero is the least
       significant bit. The bit number for this operation may be specified
       in either of two ways:

       1. Immediate -- The bit number is specified as immediate data.
       2. Register  -- The specified data register contains the bit number.

FORMAT
       In the case of BSET Dn,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
       +---------------------------------------------------------------+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|-----------|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 |  REGISTER | 1 | 1 | 1 |    MODE   | REGISTER  |
       +---------------------------------------========================+
                                                         <ea>

       In the case of BSET #<data,<ea>:
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	                                                  <ea>
       +---------------------------------------========================+
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|---|---|-----------|-----------|
       | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |       NUMBER OF THE BIT       |
       +---------------------------------------------------------------+

REGISTER
       <ea> is always destination, addressing modes are the following:
       +-------------------------------- -------------------------------
       |Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
       |-------------------------------| |-----------------------------|
       |      Dn *     |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
       |-------------------------------| |-----------------------------|
       |      An       | -  |     -    | |    Abs.L      |111 |  001   |
       |-------------------------------| |-----------------------------|
       |     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
       |-------------------------------| |-----------------------------|
       |     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
       |-------------------------------| |-----------------------------|
       |    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    | 
       |-------------------------------| |-----------------------------|
       |   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
       |-------------------------------| |-----------------------------|
       |   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
       |-------------------------------| -------------------------------
       |([bd,An,Xi]od) |110 |N∞ reg. An|
       |-------------------------------|
       |([bd,An],Xi,od)|110 |N∞ reg. An|
       ---------------------------------
        * Long only; for others modes: Byte only.

RESULT
       X - not affected
       N - not affected
       Z - Set if the bit tested is zero. Cleared otherwise.
       V - not affected
       C - not affected

***********************************************************

Branch to Subroutine

NAME   BSR -- Branch to subroutine

SYNOPSIS
       BSR	<label>

       Size = (Byte, Word)
       Size = (Byte, Word, Long)	(68020+)

FUNCTION
       Pushes the long word address which follows the BSR instruction to
       stack.
       Program	execution continues at location (PC) + offset.
       Offset is the relative gap between PC value and label.
       This gap is calculated by complement to two and is coded on 8 bits
       or on 16 bits.

FORMAT
       -----------------------------------------------------------------
       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
       |---|---|---|---|---|---|---|---|-------------------------------|
       | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |         8 BITS OFFSET         |
       |---------------------------------------------------------------|
       |            16 BITS OFFSET, IF 8 BITS OFFSET = $00             |
       |---------------------------------------------------------------|
       |            32 BITS OFFSET, IF 8 BITS OFFSET = $FF             |
       -----------------------------------------------------------------

RESULT   None.

***********************************************************

Bit Test

NAME   BTST -- Bit test

SYNOPSIS
       BTST	Dn,<ea>
       BTST	#<data>,<ea>

       Size = Byte, Long

FUNCTION
	Tests a bit in the destination operand and sets the Z
	condition code appropriately. If the destination is a data register,
	any of the 32 bits can be specified by the modulo 32 number. When
	the distination is a memory location, the operation must be a byte
	operation, and therefore the bit number is modulo 8. In all cases,
       bit zero is the least significant bit. The bit number for this
	operation may be specified in either of two ways:

	1. Immediate -- The bit number is specified as immediate data.
	2. Register  -- The specified data register contains the bit number.

FORMAT
	In the case of BTST Dn,<ea>:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 0 | 0 | 0 | 0 |  REGISTER | 1 | 0 | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

	In the case of BTST #<data,<ea>:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|---|---|---|---|---|-------------------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |       NUMBER OF THE BIT       |
	-----------------------------------------------------------------

REGISTER
	In the case of BTST Dn,<ea>:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~
	<ea> is always destination, addressing modes are the following:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn *     |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Long only; for others modes: Byte only.

	In the case of BTST #<data,<ea>:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn *     |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   | 
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - not affected
	N - not affected
	Z - Set if the bit tested is zero. Cleared otherwise.
	V - not affected
	C - not affected

***********************************************************

Callm "CALL Module"
NAME
	CALLM -- Call module	(68020 ONLY)

SYNOPSIS

FUNCTION
	This instruction is 68020 ONLY and is used with, for cooperation
	with the PMMU MC68851. Be carreful, it's not available on 68030+.

RESULT

***********************************************************

Cas "Compare And Swap"
NAME
	CAS -- Compare and swap	(68020+)

SYNOPSIS
	CAS	Dc,Du,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	This instruction is a read-modify-write instruction and should
	NEVER be used on Amiga because of conflicts with customs chips.
	Destination operand, which is in memory at address specified
	by <ea>, is compared to  data register Dc (Data Compare). This
	register is used as reference in the principle of this instruction.
	If there's equality (Z=1), destination operand can be updated, i.e.
	the new operand Du (Data Update) is moved in destination.
	If there's no equality (Z=0), it's the reference register Dc which
	must be updated. So there's a move from destination operand to Dc.

FORMAT
                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|-------|---|---|---|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | SIZE  | 0 | 1 | 1 |   MODE    |  REGISTER |
	|---|---|---|---|---|-------|-----------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Du REGISTER| 0 | 0 | 0 |Dc REGISTER|
	-----------------------------------------------------------------

SIZE
	01->one Byte operation
	10->one Word operation
	11->one Long operation

REGISTER
	Du register: indicates number of data register, which contains the
	new value to update in destination operand.

	Dc register: indicates number of data register, which contains the
	reference value to compare to destination operand.

	<ea> is always destination, addressing modes are the following:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - not affected
	N - Set if the result of comparison is negative. Cleared otherwise.
	Z - Set if the result of comparison is zero. Cleared otherwise.
	V - Set if overflow. Cleared otherwise.
	C - Set if carry. Cleared otherwise.

***********************************************************

Cas2 "Compare And Swap (two-operand)"
NAME
	CAS2 --Compare and swap (two-operand)	(68020+)

SYNOPSIS
	CAS2	Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)

	Size = (Word, Long)

FUNCTION
	This instruction is a read-modify-write instruction and should
	NEVER be used on Amiga because of conflicts with customs chips
	Destination operand 1, which is in memory to specified address by
	(Rn1), is compared to data register Dc1. If there's equality (Z=1),
	destination operand 2, which is in memory to specified address by
	(Rn2), is compared to data register Dc2.

	If there's equality (Z=1), destination operand 1 can be updated, i.e.
	new operand Du1 (Data Update) is moved in destination (Rn1).

	And also, destination operand 2 can be updated, i.e. new operand Du2
	(Data Update) is moved in destination (Rn2).

	If there's no equality (Z=0), reference registers Dc1 and Dc2 have to
	be updated. So there's move from destination operand (Rn1) in Dc1, and
	from (Rn2) in Dc2.

FORMAT
	------------------------------------------------------------------
	| 15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|----|---|---|---|---|-------|---|---|---|---|---|---|---|---|---|
	| 0  | 0 | 0 | 0 | 1 | SIZE  | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	|----|-----------|---|-------|-----------|---|---|---|-----------|
	|D/A1|  Rn1 REG. | 0 | 0 | 0 |  Du1 REG. | 0 | 0 | 0 |  Dc1 REG. |
	|----|-----------|---|---|---|-----------|---|---|---|-----------|
	|D/A2|  Rn2 REG. | 0 | 0 | 0 |  Du2 REG. | 0 | 0 | 0 |  Dc2 REG. |
	------------------------------------------------------------------

SIZE
	10->one Word operation
	11->one Long operation

REGISTER
	D/A1 = 0: Rn1=Dn
	D/A1 = 1: Rn1=An
	D/A2 = 0: Rn2=Dn
	D/A2 = 1: Rn2=An

	Du1, Du2 registers: indicates number of data register, which contains
	the new value to update in destination operand.

	Dc1, Dc2 registers: indicates number of data register, which contains
	the reference value to compare to destination operand.

	Rn1, Rn2 registers: indicates number of destination registers.

RESULT
	X - not affected
	N - Set following to comparisons results.
	Z - Set if the result of comparisons is zero. Cleared otherwise.
	V - Set if overflow. Cleared otherwise.
	C - Set if carry. Cleared otherwise.

***********************************************************

Chk "CHecK bounds"
NAME
	CHK -- Check bounds

SYNOPSIS
	CHK	<ea>,Dn

	Size = (Word)
	Size = (Word, Long)	(68020+)

FUNCTION
	Compares the value in the data register specified to zero and to the
	upper bound. The upper bound is a twos complement integer. If the
	register value is less than zero or greater than the upper bound,
	a CHK instruction, vector number 6, occurs.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-------|---|-----------|-----------|
	| 0 | 1 | 0 | 0 |  REGISTER |  SIZE | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>


REGISTER
	<ea> specifies upper bound, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

SIZE
	11->one Word operation
	10->one Long operation

RESULT
	X - Not affected
	N - Set if Dn < 0; cleared if Dn > <ea>. Undefined otherwise.
	Z - Undefined.
	V - Undefined.
	C - Undefined.

***********************************************************

Chk2 "CHecK register against upper and lower bounds"
NAME
	CHK2 -- Check register against upper and lower bounds	(68020+)

SYNOPSIS
	CHK2	<ea>,Rn

	Size = (Byte, Word, Long)

FUNCTION
	<ea> indicates memory area of two bounds: in 1st memory position,
	lower bound, in 2nd memory position, upper bound. Those two values
	are adjacent in memory.
	For signed comparisons, the lowest arithmetic value, expressed as a
	two complement integer, have to be the lower bound.

	If Rn is a data register Dn and if size of operation is 8 or 16 bits,
	only the 8 or 16 bits of low weight of Dn and bounds are taken in
	count.
	In opposite, if Rn is an address register An, it must be extension
	of bounds sign and 32 bits of An are taken care.

	If Rn is located out of 2 bounds, a CHK instruction, vector number 6,
	occurs. 

FORMAT
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|-------|---|---|---|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | SIZE  | 0 | 1 | 1 |   MODE    | REGISTER  |
	|---|-----------|---|-------|---|---|---|-----------|-----------|
	|D/A| REGISTER  | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
	-----------------------------------------------------------------

REGISTER
	Register specifies the register Rn which contains the value to test.
	If D/A = 0: Rn = Dn
	If D/A = 1: Rn = An
	<ea> specifies bounds, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT
	X - Not affected
	N - Undefined.
	Z - Set if Rn is equal to one of the two bounds. Cleared otherwise.
	V - Undefined.
	C - Set if Rn is out of bounds. Cleared otherwise.


***********************************************************

Clr "CLeaR"
NAME
	CLR -- Clear

SYNOPSIS
	CLR	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Clears the destination operand to zero.

	On an MC68000 and MC68HC000, a CLR instruction does both a
	read and a write to the destination. Because of this, this
	instruction should never be used on custom chip registers.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |  SIZE |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT
	X - Not affected
	N - Always cleared
	Z - Always set
	V - Always cleared
	C - Always cleared


***********************************************************

Cmp "CoMPare"
NAME
	CMP -- Compare

SYNOPSIS
	CMP	<ea>,Dn

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the source operand from the destination data register and
	sets the condition codes according to the result. The data register
	is NOT changed.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 1 | 1 |  REGISTER |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

OP-MODE
	000	8 bits operation.
	001	16 bits operation.
	010	32 bits operation.

REGISTER
	The data register specifies destination Dn.
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Word and Long only.

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow occours. Cleared otherwise.
	C - Set if a borrow occours. Cleared otherwise.


***********************************************************

Cmp2 "CoMPare register against upper and lower bounds"
NAME
	Cmp2 -- Compare register against upper and lower bounds	(68020+)

SYNOPSIS
	CMP2	<ea>,Rn

FUNCTION
	Used to compare value of Rn (Dn or An) with two lower and upper
	bounds, which are stored in memory, at address given by <ea> (in
	two adjacent areas).
	Lower bound have to be stored before upper bound. Flags are set
	following to the result of comparison.

	If Rn is a data register Dn, and if operation is made on 8 or
	16 bits, only the 8 or 16 bits of Dn are taken in count.
	In opposite, in the case of Rn as an address register and if a 16
	bits operation is granted, the 32 bits of An are compared to bounds
	which are, them, extended on 32 bits by their signs.


FORMAT
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|-------|---|---|---|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | SIZE  | 0 | 1 | 1 |   MODE    | REGISTER  |
	|---|-----------|---|-------|---|---|---|-----------|-----------|
	|D/A| REGISTER  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
	-----------------------------------------------------------------

REGISTER
	Register specifies the register Rn which contains the value to test.
	If D/A = 0: Rn = Dn
	If D/A = 1: Rn = An
	<ea> specifies bounds, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |     -    | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |     -    | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT
	X - Not affected
	N - Undefined.
	Z - Set if Rn is equal to one of the two bounds. Cleared otherwise.
	V - Undefined.
	C - Set if Rn is out of bounds. Cleared otherwise.


***********************************************************

Cmpa "CoMPare Address"
NAME
	CMPA -- Compare address

SYNOPSIS
	CMPA	<ea>,An

	Size = (Word, Long)

FUNCTION
	Subtracts the source operand from the destination address
	register and sets the condition codes according to the result. The
	address register is NOT changed. Word sized source operands are
	sign extended to long for comparison.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 1 | 1 |  REGISTER |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

OP-MODE
	011	16 bits operation.
	111	32 bits operation.

REGISTER
	The address register specifies destination An.
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow occours. Cleared otherwise.
	C - Set if a borrow occours. Cleared otherwise.

***********************************************************

Cmpi "CoMPare Immediate"
NAME
	CMPI -- Compare immediate

SYNOPSIS
	CMP	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the source operand from the destination operand and sets
	the condition codes according to the result. The destination is
	NOT changed. The size of the immediate data matches the operation
	size.

FORMAT
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	|-------------------------------|-------------------------------|
	|         16 BITS DATA          |         8 BITS DATA           |
	|---------------------------------------------------------------|
	|                          32 BITS DATA                         |
	-----------------------------------------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow occours. Cleared otherwise.
	C - Set if a borrow occours. Cleared otherwise.


***********************************************************

Cmpm "CoMPare Memory"
NAME
	CMPM -- Compare memory

SYNOPSIS
	CMPM	(Ay)+,(Ax)+

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the source operand from the destination operand
	and sets the condition codes according to the result. The destination
	operand is NOT changed. Operands are always addressed with the
	postincrement mode.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 0 | 1 | 1 |Ax REGISTER| 1 | SIZE  | 0 | 0 | 1 |Ay REGISTER|
	----------------------------------------=========================
	                                                  <ea>

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	Ax register specifies destination operand (for post-incrementation).
	Ay register specifies source operand.

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow occours. Cleared otherwise.
	C - Set if a borrow occours. Cleared otherwise.


***********************************************************

cpBcc "Branch on CoProcessor condition"
NAME
	cpBcc -- Branch on coprocessor condition

SYNOPSIS
	cpBcc	<label>

	Offset size = (Word, Long)

FUNCTION
	If specified coprocessor condition is true, program execution
	continues to address pointed by searching PC more offset.
	Searching PC contains address of first word of offset. Offset is
	a signed value of 16 or 32 bits, which represents the relative gap
	in bytes between the searching PC and destination address.

FORMAT
	------------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6  | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|----|-----------------------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 1 |SIZE|COPROSSESSOR CONDITION |
	|----------------------------------------------------------------|
	|              OPTIONAL COPROCESSOR EXTENSION WORD               |
	|----------------------------------------------------------------|
	|                            16 BITS OFFSET                      |
	|----------------------------------------------------------------|
	|	        32 BITS OFFSET (LOW WEIGHT PART)                  |
	------------------------------------------------------------------

SIZE
	0->one Word operation
	1->one Long operation

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	"COPROSSESSOR CONDITION" field, specifies condition to test.
	This condition is addressed to coprocessor which, after examining
	this one, address directives to processor in order to execute
	the instruction.

RESULT
	Not affected.

***********************************************************

cpDBcc "Decrement and Branch on CoProcessor condition"
NAME
	cpDBcc -- Decrement and branch on coprocessor condition

SYNOPSIS
	cpDBcc	Dn,<label>

	Offset size = (Word)

FUNCTION
	If specified coprocessor condition is true, program execution
	continues with next instruction. Else 16 bits of data register which
	are used as a counter, are decremented of one.
	If Dn = -1, execution continues with next instruction.
	If Dn =! -1, execution continues to address pointed by searching PC
	more offset; searching PC containing address of first word of offset.
	Offset is a signed value of 16 bits, which represents the relative gap
	in bytes between the searching PC and destination address.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 0 | 1 | 0 | 0 | 1 | REGISTER  |
	|---|---|---|---|-----------|---|---|---|-----------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | COPROCESSOR CONDITION |
	|---------------------------------------------------------------|
	|              OPTIONAL COPROCESSOR EXTENSION WORD              |
	|---------------------------------------------------------------|
	|                            16 BITS OFFSET                     |
	-----------------------------------------------------------------

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	"COPROSSESSOR CONDITION" field, specifies condition to test.
	This condition is addressed to coprocessor which, after examining
	this one, address directives to processor in order to execute
	the instruction.

	Register field indicates the number of data register used as counter.

RESULT
	Not affected.

***********************************************************

cpGEN "GENeral CoProcessor intruction"
NAME
	cpGEN -- General coprocessor intruction

SYNOPSIS
	cpGEN	<coprocessor defined parameters>

	No size specs.

FUNCTION
	Command word specified is addressed to selected coprocessor.
	This one decode the command and address requests services to processor
	in order to execute services asked by the coprocessor.

FORMAT
                                                           <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 0 | 0 |    MODE   | REGISTER  |
	|---------------------------------------------------------------|
	|                  COPROCESSOR COMMAND WORD                     |
	|---------------------------------------------------------------|
	|     OPTIONAL COPROCESSOR EXTENSION WORD or OPTIONAL <ea>      |
	-----------------------------------------------------------------

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	<ea> field specifies place of operand not resident in the coprocessor.
	Allowed addressing modes are driven by the type of operation made.

	"COPROCESSOR COMMAND" field specifies operation to do.
	This word is transmit to coprocessor which, after analyse of this
	word, send directives to coprocessor in order to execute instruction.
	
RESULT
	Not affected or modified by the coprocessor.

***********************************************************

cpRESTORE "RESTORE CoProcessor instruction (PRIVILEGED)"
NAME
	cpRESTORE -- Restore coprocessor instruction (PRIVILEGED)

SYNOPSIS
	cpRESTORE	<ea>

	No size specs.

FUNCTION
	Restore internal state of coprocessor after it has been generally
	saved by cpSAVE.

FORMAT
                                                           <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 1 | 0 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

REGISTER
	<ea> field specifies place where is stored coprocessor context in
	memory.
	Allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.

***********************************************************

cpSAVE "SAVE CoProcessor instruction (PRIVILEGED)"
NAME
	cpSAVE -- Save coprocessor instruction	(PRIVILEGED)

SYNOPSIS
	cpSAVE	<ea>

	No size specs.

FUNCTION
	Save internal state of coprocessor.

FORMAT
                                                           <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 1 | 0 | 0 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

REGISTER
	<ea> field specifies place where is stored coprocessor context in
	memory.
	Allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.

***********************************************************

cpScc "Set one byte on CoProcessor condition"
NAME
	cpScc -- Set one byte on coprocessor condition

SYNOPSIS
	cpScc	<ea>

	Size = (Byte)

FUNCTION
	If given condition is true, byte specified by <ea> is loaded with $FF.
	Else it is loaded with $00.

FORMAT
                                                           <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 0 | 1 |    MODE   | REGISTER  |
	|---|---|---|---|-----------|---|---|---|-----------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | COPROCESSOR CONDITION |
	|---------------------------------------------------------------|
	|    OPTIONAL COPROCESSOR EXTENSION WORD or OPTIONAL <ea>       |
	-----------------------------------------------------------------

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	"COPROSSESSOR CONDITION" field, specifies condition to test.
	This condition is addressed to coprocessor which, after examining
	this one, address directives to processor in order to execute
	the instruction.

REGISTER
	<ea> field specifies place of destination byte.
	Allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.

***********************************************************

cpTRAPcc "Exception generation on CoProcessor condition"
NAME
	cpTRAPcc -- Exception generation on coprocessor condition

SYNOPSIS
	cpTRAPcc
	cpTRAPcc	#<data>

	No size specs, or size of data: (Word, Long).

FUNCTION
	If specified coprocessor condition is true, exception vector n∞7
	is generated. Value of saved PC is next instruction one (return
	address).
	If given condition is false, PC takes the value of next instruction.
	Immediate data placed at instruction end is an information which can
	be used by the exception sub-routine.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 0 | 1 | 1 | 1 | 1 |  OP-MODE  |
	|---|---|---|---|-----------|---|---|---|-----------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |COPROSSESSOR CONDITION |
	|---------------------------------------------------------------|
	|              OPTIONAL COPROCESSOR EXTENSION WORD              |
	|---------------------------------------------------------------|
	|                            16 BITS DATA or                    |
	|---------------------------------------------------------------|
	|	          32 BITS DATA (LOW WEIGHT PART)                |
	-----------------------------------------------------------------

OP-MODE
	010->instruction contains a 16 bits operand.
	011->instruction contains a 32 bits operand.
	100->instruction has no operands.

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	"COPROSSESSOR CONDITION" field, specifies condition to test.
	This condition is addressed to coprocessor which, after examining
	this one, address directives to processor in order to execute
	the instruction.

RESULT
	Not affected.

***********************************************************

Dbcc "Decrement and Branch Conditionally"
NAME
	DBcc -- Decrement and branch conditionally

SYNOPSIS
	DBcc	Dn,<label>

	Size of offset = (Word)

FUNCTION
	Controls a loop of instructions. The parameters are: a
	condition code, a data register (counter), and an offset value.
	The instruction first tests the condition (for termination); if it
	is true, no operation is performed. If the termination condition is
	not true, the low-order 16 bits of the counter are decremented by
	one. If the result is -1, execution continues at the next
	instruction, otherwise, execution continues at the specified
	address.

	Condition code 'cc' specifies one of the following:
0000 F  False            Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True             Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh             C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same      C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear      C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set        C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal        Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual            Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1


	Keep the following in mind when using DBcc instructions:
	1. A DBcc acts as the UNTIL loop contruct in high level
	   languages. E.g., DBMI would be "decrement and branch until
	   minus".
	2. Most assemblers accept DBRA or DBF for use when no condition
	   is required for termination of a loop.


        The DBcc will, unlike the Bcc instruction, take the branch only if
        the set of conditions are NOT satified. The loop will be terminated
        if the condition is true, or the counter is zero BEFORE a decrement,
        and wrap to -1. This mean that if you execute code like:

	move.w	#30,d0

.Loop
	move.l	(a0)+,(a1)+
	dbf	d0,.Loop

        then the copy will be executed *31* times, and 124 bytes of memory
        will be copied, not 120.

        A good practice is therefore to write:

	move.w	#31-1,d0

.Loop
	move.l	(a0)+,(a1)+
	dbf	d0,.Loop

        To compare two strings that may be in excess of 64k length for
        beeing equal, you could execute the following code:
	...

	move.l	#$53452-1,d0
	beq.s	.NoLength	; Zero length!
	bra.s	.StartOuterLoop	; The upper word contain count of 65536's...

.OuterLoop
	swap	d0

.InnerLoop
	cmp.b	(a0)+,(a1)+
	dbne	d0,.InnerLoop	; Remember, drop trough on condition TRUE.

.StartOuterLoop		        ; d0 will be $FFFF on 2.+ run-through
	bne.s	.NotEqual	; Dropped through due to Not Equal?
	swap	d0		; Get upper part of word...	
	dbf	d0,.OuterLoop
	...

        It would not be possible to use two sets of DBNEs, as SWAP
        changes the condition codes - and we don't want the drop-
        though to be on account of D0, instead of the compares...

        Another neat trick is to use instruction as a conditional
        decrementer; this code will decrement d0.w if the last
        instruction returned NOT EQUAL:
	...
	dbeq	d0,.Next

.Next
	...

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---------------|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 1 |   CONDITION   | 1 | 1 | 0 | 0 | 1 | REGISTER  |
	|---------------------------------------------------------------|
	|                      16 BITS OFFSET (d16)                     |
	-----------------------------------------------------------------

	"CONDITION" is one of the condition code given some lines before.
	"REGISTER" is the number of data register.
	Offset is the relative gap in byte to do branching.

RESULT
	Not affected.

***********************************************************

Divs "Signed DIVide"
NAME
	DIVS, DIVSL -- Signed divide

SYNOPSIS
	DIVS.W	<ea>,Dn     32/16 -> 16r:16q
	DIVS.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVS.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVSL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

FUNCTION
	Divides the signed destination operand by the signed source
	operand and stores the signed result in the destination.

	The instruction has a word form and three long forms. For the
	word form, the destination operand is a long word and the source
	operand is a word. The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination. The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words. The quotient is placed in the longword of the destination
	and the remainder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

FORMAT
	In the case of DIVS.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	In the case of DIVS.L and of DIVL.L:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 1 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the quotient is negative, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

***********************************************************

Divu "Unsigned DIVide"
NAME
	DIVU, DIVUL -- Unsigned divide

SYNOPSIS
	DIVU.W	<ea>,Dn     32/16 -> 16r:16q
	DIVU.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVU.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVUL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

FUNCTION
	Divides the unsigned destination operand by the unsigned
	source operand and stores the unsigned result in the destination.

	The instruction has a word form and three long forms. For the
	word form, the destination operand is a long word and the source
	operand is a word. The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination. The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words. The quotient is placed in the longword of the destination
	and the remainder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

FORMAT
	In the case of DIVU.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  | 0 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	In the case of DIVU.L and of DIVUL.L:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 0 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT

	X - Not affected
	N - See below.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

	According to the Motorola data books, the N flag is set if the
	quotient is negative, but in an unsigned divide, this seems to
	be impossible.


***********************************************************

Eor "Exclusive logical OR"
NAME
	EOR -- Exclusive logical OR

SYNOPSIS
	EOR	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an exclusive OR operation on the destination operand
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 1 | 1 |  REGISTER |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

OP-MODE
	100	8 bits operation.
	101	16 bits operation.
	110	32 bits operation.

REGISTER
	The data register specifies source Dn.
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	

***********************************************************

Eori "Exclusive OR Immediate"
NAME
	EORI -- Exclusive OR immediate

SYNOPSIS
	EORI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an exclusive OR operation on the destination operand
	with the source operand.

FORMAT
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | SIZE  |    MODE   | REGISTER  |
	|-------------------------------|-------------------------------|
	|   16 BITS IMMEDIATE DATA      |     8 BITS IMMEDIATE DATA     |
	|---------------------------------------------------------------|
	|                     32 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

SIZE
	00->8 bits operation.
	01->16 bits operation.
	10->32 bits operation.

REGISTER
	Immediate data is placed behind the word of operating code of
	the instruction on 8, 16 or 32 bits.

	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	


***********************************************************

EoriCCR "Exclusive OR Immediate to CCR"
NAME
	EORI to CCR -- Exclusive OR immediate to the condition code register

SYNOPSIS
	EORI	#<data>,CCR

	Size = (Byte)

FUNCTION
	Performs an exclusive OR operation on the condition codes
	register with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |     8 BITS IMMEDIATE DATA     |
	-----------------------------------------------------------------

RESULT
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	

***********************************************************

EoriSR "Exclusive OR immediated with SR (PRIVILEGED)"
NAME
	EORI to SR -- Exclusive OR immediated to the status register (PRIVILEGED)

SYNOPSIS
	EORI	#<data>,SR

	Size = (Word)

FUNCTION
	Performs an exclusive OR operation on the status register
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---------------------------------------------------------------|
	|                     16 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

RESULT
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	

***********************************************************

Exg "Register EXchanGe"
NAME
	EXG -- Register exchange

SYNOPSIS
	EXG	Rx,Ry

	Size = (Long)

FUNCTION
	Exchanges the contents of any two registers.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------------------|-----------|
	| 1 | 1 | 0 | 0 |Rx REGISTER| 1 |       OP-MODE     |Ry REGISTER|
	-----------------------------------------------------------------

	"Rx REGISTER" specifies a data or address register. If it's an
	exchange between a data register and an address register, this field
	define the data register.

	"Ry REGISTER" specifies a data or address register. If it's an
	exchange between a data register and an address register, this field
	define the address register.

OP-MODE
	01000->Exchange between data registers.
	01001->Exchange between address registers.
	10001->Exchange between data and address registers.

RESULT
	None.


***********************************************************

Ext "Sign EXTend"
NAME
	EXT, EXTB -- Sign extend

SYNOPSIS
	EXT.W	Dn	Extend byte to word
	EXT.L	Dn	Extend word to long word
	EXTB.L	Dn	Extend byte to long word	(68020+)

	Size = (Word, Long)

FUNCTION
	Extends a byte to a word, or a word to a long word in a data
	register by copying the sign bit through the upper bits. If the
	operation is from byte to word, bit 7 is copied to bits 8 through
	15. If the operation is from word to long word, bit 15 is copied
	to bits 16 through 31. The EXTB copies bit 7 to bits 8 through 31.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|-----------|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 |  OP-MODE  | 0 | 0 | 0 | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" specifies a data register.

OP-MODE
	010->Extending from 8 bits to 16 bits.
	011->Extending from 16 bits to 32 bits.
	111->Extending from 8 bits to 32 bits.

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Always cleared


***********************************************************

Illegal "Illegal processor instruction"
NAME
	ILLEGAL -- Illegal processor instruction

SYNOPSIS
	ILLEGAL

FUNCTION
	This instruction forces an Illegal Instruction exception,
	vector number 4. All other illegal instruction bit patterns,
	including, but not limited to, $fxxx and $axxx, are reserved for
	future expansion.
        The Hexa-decimal code of this instruction is: $4AFC 

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

Jmp "Unconditional far JuMP"
NAME
	JMP -- Unconditional far jump

SYNOPSIS
	JMP	<ea>

FUNCTION
	Program execution continues at the address specified by
	the operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	<ea> specifies address of next instruction.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

Jsr "Jump to far SubRoutine"
NAME
	JSR -- Jump to far subroutine

SYNOPSIS
	JSR	<ea>

FUNCTION
	Pushes the long word address of the instruction immediately
	following the JSR instruction onto the stack. The PC contains
	the address of the instruction word plus two. Program execution
	continues at location specified by <ea>.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	<ea> specifies address of next instruction.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.



***********************************************************

Lea "Load Effective Address"
NAME
	LEA -- Load effective address

SYNOPSIS
	LEA	<ea>,An

	Size = (Long)

FUNCTION
	Places the specified address into the destination address
	register. Note: All 32 bits of An are affected by this instruction.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	"REGISTER" indicates the number of address register

	<ea> specifies address which must be loaded in the address register.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

Link "Create local stack frame"
NAME
	LINK -- Create local stack frame

SYNOPSIS
	LINK	An,#<data>

	Size = (Word)
	Size = (Word, Long)		(68020+)

FUNCTION
	This instruction saves the specified address register onto
	the stack, then places the new stack pointer in that register. It
	then adds the specificed immediate data to the stack pointer. To
	allocate space on the stack for a local data area, a negative value
	should be used for the second operand.

	The use of a local stack frame is critically important to the
	programmer who wishes to write re-entrant or recursive functions.
	The creation of a local stack frame on the MC680x0 family is done
	through the use of the LINK and UNLK instructions. The LINK
	instruction saves the frame pointer onto the stack, and places a
	pointer to the new stack frame in it. The UNLK instruction
	restores the old stack frame. For example:

		link	a5,#-8		; a5 is chosen to be the frame
					; pointer. 8 bytes of local stack
					; frame are allocated.
		...
		unlk	a5		; a5, the old frame pointer, and the
					; old SP are restored.

	Since the LINK and UNLK instructions maintain both the frame pointer
	and the stack pointer, the following code segment is perfectly
	legal:

		link	a5,#-4

		movem.l	d0-a4,-(sp)
		pea	(500).w
		move.l	d2,-(sp)
		bsr.b	Routine

		unlk	a5
		rts

FORMAT
	For Word size:
	~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | REGISTER  |
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET (d)                     |
	-----------------------------------------------------------------

	For Long size:
	~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | REGISTER  |
	|---------------------------------------------------------------|
	|          32 BITS OFFSET (d) (16 bits of lower weight)         |
	|---------------------------------------------------------------|
	|          32 BITS OFFSET (d) (16 bits of upper weight)         |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of address register.
	OFFSET is a signed value, generally negative, which enables to move
	the stack pointer.

RESULT
	None.


***********************************************************

LSD "Logical Shift Left and Logical Shift Right"
NAME
	LSL, LSR -- Logical shift left and logical shift right

SYNOPSIS
	LSd	Dx,Dy
	LSd	#<data>,Dy
	LSd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
	Shift the bits of the operand in the specified direction.
	The carry bit set set to the last bit shifted out of the operand.
	The shift count for the shifting of a register may be specified in
	two different ways:

	1. Immediate - the shift count is specified in the instruction (shift
	               range 1-8).
	2. Register  - the shift count is contained in a data register
	               specified in the instruction (shift count mod 64)

	For a register, the size may be byte, word, or long, but for a memory
	location, the size must be a word. The shift count is also restricted
	to one for a memory location.

	LSL:              <--  
	      C <------ OPERAND <--- 0
	            |
	            |    (V = 0)
	      X <---'
	       

	LSR:
                 -->
	0 ---> OPERAND -------> C
                          |
	                  |
	                  `---> X

FORMAT
	In the case of the shifting of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 0 | 1 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the shifting of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 0 | 1 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of shifting or number of register which contents
	the number of shifting.
	If i/r = 0, number of shifting is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right shifting
	If dr = 1, left shifting

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register shifting:
	Indicates the number of data register on which shifting is applied.

	For a memory shifting:
	<ea> indicates operand which should be shifted.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set according to the last bit shifted out of the operand.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.


***********************************************************

MOVE "Move Source -> Destination"
NAME
	MOVE -- Source -> Destination

SYNOPSIS
	MOVE	<ea>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Move the content of the source to the destination location.
	The data is examined as it is moved, and the condition codes
	set accordingly.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|-------|-----------|-----------|-----------|-----------|
	| 0 | 0 |  SIZE |  REGISTER |    MODE   |    MODE   | REGISTER  |
	----------------************************=========================
	                    destination <ea>           source <ea>

REGISTER
	Destination <ea> specifies destination operand, addressing modes
	allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

	Source <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Word or Long only.

SIZE
	01->Byte
	11->Word
	10->Long

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.


***********************************************************

Movea "Move Address Source -> Destination"
NAME
	MOVEA -- Source -> Destination

SYNOPSIS
	MOVEA	<ea>,An

	Size = (Word, Long)

FUNCTION
	Move the contents of the source to the destination address
	register. Word sized operands are sign extended to 32 bits
	before the operation is done.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|-------|-----------|---|---|---|-----------|-----------|
	| 0 | 0 |  SIZE |  ADDRESS  | 0 | 0 | 1 |    MODE   | REGISTER  |
	|   |   |       |  REGISTER |   |   |   |           |           |
	----------------------------------------=========================
	                                              source <ea>

REGISTER
	"ADDRESS REGISTER" specifies the number of destination address
	register.

	Source <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Word or Long only.

SIZE
	11->Word, 32 bits of address register are altered by sign extension.
	10->Long

RESULT
	None.


***********************************************************

MoveFromCCR "CCR -> Destination"
NAME
	MOVE from CCR -- CCR -> Destination

SYNOPSIS
	MOVE	CCR,<ea>

	Size = (Word)

FUNCTION
	The content of the status register is moved to the destination
	location. The source operand is a word,	but only the low order
	byte contains the condition codes. The high order byte is set
	to all zeros.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

MoveToCCR "Source -> CCR"
NAME
	MOVE to CCR -- Source -> CCR

SYNOPSIS
	MOVE	<ea>,CCR

	Size = (Word)

FUNCTION
	The content of the source operand is moved to the condition codes.
	The source operand is a word, but only the low order byte is used
	to update the condition	codes. The high order byte is ignored.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.


***********************************************************

MoveFromSR "Move from SR (privileged)"
NAME
	MOVE from SR -- Move from status register (privileged)

SYNOPSIS
	MOVE	SR,<ea>

	Size = (Word)

FUNCTION
	The content of the status register is moved to the destination
	location. The operand size is a word.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

MoveToSR "Move to SR (PRIVILEGED)"
NAME
	MOVE to SR -- Move to status register (PRIVILEGED)

SYNOPSIS
	MOVE	<ea>,SR

	Size = (Word)

FUNCTION
	The content of the source operand is moved to the
	status register. The source operand size is a word
	and all bits of the status register are affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT

	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.


***********************************************************

MoveUSP "Move to/from USP (privileged)"
NAME
	MOVE USP -- Move to/from user stack pointer (privileged)

SYNOPSIS
	MOVE	USP,An
	MOVE	An,USP

	Size = (Long)

FUNCTION
	The contents of the user stack pointer are transfered either to
	or from the specified address register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |dr | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of address register.

	dr specifies move direction:
	0->An to USP
	1->USP to An

RESULT
	None.



***********************************************************

Movec "Move to/from control register"
NAME
	MOVEC -- Move to/from control register

SYNOPSIS
	MOVEC	Rc,Rn
	MOVEC	Rn,Rc

	Size = (Long)

FUNCTION
	Copy the contents of the specified control register to the specified
	general register or copy from the general register to the control
	register. This is always a 32-bit transfer even though the control
	register may be implemented with fewer bits.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |dr |
	|---|-----------|-----------------------------------------------|
	|A/D| REGISTER  |                CONTROL REGISTER               |
	-----------------------------------------------------------------

	A/D indicates type of Rn register:
	0->Rn=Dn
	1->Rn=An

	"REGISTER" indicates the number of Rn register.

	dr specifies direction of move:
	0->Rc to Rn.
	1->Rn to Rc.

	"CONTROL REGISTER" specifies one of the control registers:

	Hexa value	Control Register
	~~~~~~~~~~	~~~~~~~~~~~~~~~~
	000       	SFC
	001       	DFC
	002       	CACR
	800       	USP
	801       	VBR
	802       	CAAR
	803       	MSP
	804       	ISP

	All others hexa codes generates an exception: illegal instruction.

RESULT
	None.


***********************************************************

Movem "MOVE Multiple registers"
NAME
	MOVEM -- Move multiple registers

SYNOPSIS
	MOVEM	<register list>,<ea>
	MOVEM	<ea>,<register list>

	Size = (Word, Long)

FUNCTION
	Registers in the register list are either moved to or
	fetched from consecutive memory locations at the specified
	address. Data can be either word or long word, but if
	the register list is destination and the size is word,
	each register is filled with the source word sign extended
	to 32-bits.

	Also, in the case that the register list is the destination,
	register indirect with predecrement is not a valid source
	mode. If the register list is the source, then the
	destination may not be register indirect with postincrement.

		MOVEM.L	D0/D1/A0,(A2)+		;invalid
		MOVEM.W	-(A1),D5/D7/A4		;invalid

	The register list is accessed with D0 first through D7, followed
	by A0 through A7.

FORMAT
	                                                  <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6  | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|----|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 |dr | 0 | 0 | 1 |SIZE|    MODE   | REGISTER  |
	|----------------------------------------------------------------|
	|                    MASK FROM REGISTER LIST                     |
	------------------------------------------------------------------

	dr specifies move direction:
	0->registers to memory
	1->memory to registers

	MASK FROM REGISTER LIST specifies registers which must be moved and
	indicates their move order.

	For pre-decrementing, mask has the following format:
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	|D0 |D1 |D2 |D3 |D4 |D5 |D6 |D7 |A0 |A1 |A2 |A3 |A4 |A5 |A6 |A7 |
	------------------------------------------------------------=====
	                                                              |
	First register to be moved------------------------------------'

	For post-incrementing, mask has the following format:
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	|A7 |A6 |A5 |A4 |A3 |A2 |A1 |A0 |D7 |D6 |D5 |D4 |D3 |D2 |D1 |D0 |
	------------------------------------------------------------=====
	                                                              |
	First register to be moved------------------------------------'

SIZE
	0->16 bits.
	1->32 bits.

REGISTER
	<ea> specifies memory address of move.

	Move from registers to memory, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

	Move from memory to registers, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

Movep "MOVE Peripheral data"
NAME
	MOVEP -- Move peripheral data

SYNOPSIS
	MOVEP	Dx,(d,Ay)
	MOVEP	(d,Ay),Dx

	Size = (Word, Long)

FUNCTION
	Data is transfered between a data register and ever-other
	byte of memory at the selected address.
	Transfer is made between a data register and alterned bytes of memory
	at the selected address, must be specified in indirect mode to An with
	a 16 bits displacement.
	This instruction is of use with 8 bits peripheral programing.

	Example:
	~~~~~~~
		LEA	port0,A0	; A0 -> $FFFFFFFFFFFFFFFF
		MOVEQ	#0,D0
		MOVEP.L	D0,(0,A0)	; A0 -> $FF00FF00FF00FF00
		MOVE.L	#$55554444,D0
		MOVEP.L	D0,(1,A0)	; A0 -> $FF55FF55FF44FF44

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|---|---|---|-----------|
	| 0 | 0 | 0 | 0 |Dx REGISTER| OP-MODE   | 0 | 0 | 1 |Ay REGISTER|
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET                         |
	-----------------------------------------------------------------

OP-MODE
	100->16 bits move, memory to register
	101->32 bits move, memory to register
	110->16 bits move, register to memory
	111->32 bits move, register to memory

REGISTER
	Dx register specifies the number of data register.
	Ay register specifies the number of address register which takes place
	in indirect addressing with displacement.

RESULT
	None.


***********************************************************

Moveq "MOVE signed 8-bit data Quick"
NAME
	MOVEQ -- Move signed 8-bit data quick

SYNOPSIS
	MOVEQ	#<data:8>,Dn

	Size = (Long)

FUNCTION
	Move signed 8-bit data to the specified data register.
	The specified data is sign extended to 32-bits before
	it is moved to the register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------------------------------|
	| 0 | 1 | 1 | 1 | REGISTER  | 0 |        IMMEDIATE DATA         |
	-----------------------------------------------------------------

	"REGISTER" is one of the 8 datas registers. 

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.


***********************************************************

Moves "MOVE address Space (PRIVILEGED)"
NAME
	MOVES -- Move address space (PRIVILEGED)

SYNOPSIS
	MOVES	Rn,<ea>  (68010+)
	MOVES	<ea>,Rn  (68010+)

        Size = (Byte, Word, Long)

FUNCTION
        Moves contents (Byte, Word, Long) of register Rn to the addressed
        space by effective address in the addressable space specified by DFC.

	If destination is an address register, there's extension of operand
	sign to 32 bits.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | SIZE  |   MODE    | REGISTER  |
	|---|-----------|---|---|---|---|-------|-----------|-----------|
	|A/D|Rn REGISTER|dr | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	A/D indicates type of Rn register:
	0->Rn=Dn
	1->Rn=An

	"REGISTER" indicates the number of Rn register.

	dr specifies direction of move:
	0->memory to register.
	1->register to memory.

SIZE
	00->Byte
	01->Word
	10->Long

REGISTER
	<ea> specifies place of source or destination, allowed addressing
	modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.

	{"MOVE to/from USP" Link MoveUSP}	{"MOVEM" Link Movem}
	{"MOVEC" Link Movep}	{"MOVEP" Link Movep}


***********************************************************

MUL "Signed and Unsigned MULtiply"
NAME
	MULS -- Signed multiply
	MULU -- Unsigned multiply

SYNOPSIS
	MULS.W	<ea>,Dn		16*16->32
	MULS.L	<ea>,Dn		32*32->32	68020+
	MULS.L	<ea>,Dh:Dl	32*32->64	68020+

	MULU.W	<ea>,Dn		16*16->32
	MULU.L	<ea>,Dn		32*32->32	68020+
	MULU.L	<ea>,Dh:Dl	32*32->64	68020+

	Size = (Word)
	Size = (Word, Long)			68020+

FUNCTION
	Multiply two signed (MULS) or unsigned (MULU) integers
	to produce either a signed or unsigned, respectivly,
	result.

	This instruction has three forms. They are basically
	word, long word, and quad word. The first version is
	the only one available on a processore lower than a
	68020. It will multiply two 16-bit integers are produce
	a 32-bit result. The second will multiply two 32-bit
	integers and produce a 32-bit result.

	The third form needs some special consideration. It
	will multiply two 32-bit integers, specified by <ea>
	and Dl, the result is (sign) extended to 64-bits with
	the low order 32 being placed in Dl and the high order
	32 being placed in Dh.

FORMAT
	In the case of MULS.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	In the case of MULS.L:
	~~~~~~~~~~~~~~~~~~~~~                               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 1 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	In the case of MULU.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 0 | 0 | REGISTER  | 0 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	In the case of MULU.L:
	~~~~~~~~~~~~~~~~~~~~~                               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 0 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if overflow. Cleared otherwise.
	C - Always cleared.


***********************************************************

NBCD "Negate Binary Coded Decimal with extend"
NAME
	NBCD -- Negate binary coded decimal with extend

SYNOPSIS
	NBCD	<ea>

	Size = (Byte)

FUNCTION
	The specified BCD number and the extend bit are subtracted
	from zero. Therefore, if the extend bit is set a nines
	complement is performed, else a tens complement is performed.
	The result is placed back in the specified <ea>.

	It can be useful to set the zero flag before performing
	this operation so that multi precision operations can
	be correctly tested for zero.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

RESULT
	X - Set the same as the carry bit.
	N - Undefined.
	Z - Cleared it the result is non-zero, unchanged otherwise.
	V - Undefined.
	C - Set if a borrow was generated, cleared otherwise.


***********************************************************

Neg
NAME
	NEG -- Negate

SYNOPSIS
	NEG	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	The operand specified by <ea> is subtracted from
	zero. The result is stored in <ea>.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Set if overflow, otherwise cleared.
	C - Cleared if the result is zero, otherwise set.


***********************************************************

Negx "NEGate with eXtend"
NAME
	NEGX -- Negate with extend

SYNOPSIS
	NEGX	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Perform an operation similar to a NEG, with the
	exception that the operand and the extend bit are both
	subtracted from zero. The result then is being placed in
	the given <ea>.

	As with ADDX, SUBX, ABCD,
	SBCD, and NBCD, it can be useful to set
	the zero flag before performing this operation so that
	multi precision operations can be tested for zero.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Cleared if the result is non-zero, otherwise unchanged.
	V - Set if an overflow is generated, cleared otherwise.
	C - Set if a borrow is generated, otherwise cleared.


***********************************************************

Nop "No OPeration"
NAME
	NOP -- No operation

SYNOPSIS
	NOP

FUNCTION
	Nothing happens! This instruction will basically wait until
	all pending bus activity is completed. This allows
	synchronization of the pipeline	and prevents instruction overlap.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |
	-----------------------------------------------------------------

RESULT
	None.

***********************************************************

Not "Logical complement"
NAME
	NOT -- Logical complement

SYNOPSIS
	NOT	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	All bits of the specified operand are inverted and placed
	back in the operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Always cleared.
	C - Always cleared.


***********************************************************

Or "Logical OR"
NAME
	OR -- Logical OR

SYNOPSIS
	OR	<ea>,Dn
	OR	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an OR operation on the destination operand
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

OP-MODE
	Byte	Word	Long	Operation
	~~~~	~~~~	~~~~	~~~~~~~~~
	000	001	010	<ea> OR <Dn> --> <Dn>
	100	101	110	<Dn> OR <ea> --> <ea>

REGISTER
	If <ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

	If <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	

***********************************************************

Ori "Logical OR Immediate"
NAME
	ORI -- Logical OR immediate

SYNOPSIS
	ORI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an inclusive OR operation on the destination operand
	with the source operand.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	|-------------------------------|-------------------------------|
	|    16 BITS IMMEDIATE DATA     |     8 BITS IMMEDIATE DATA     |
	|---------------------------------------------------------------|
	|                    32 BITS IMMEDIATE DATA                     |
	-----------------------------------------------------------------

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	


***********************************************************

OriCCR "Logical OR immediate to CCR"
NAME
	ORI to CCR -- Logical OR immediate to the condition code register

SYNOPSIS
	ORI	#<data>,CCR

	Size = (Byte)

FUNCTION
	Performs an OR operation on the condition codes
	register with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |     8 BITS IMMEDIATE DATA     |
	-----------------------------------------------------------------

RESULT
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	

***********************************************************

OriSR "Logical OR immediated to SR (PRIVILEGED)"
NAME
	ORI to SR -- Logical OR immediated to the status register (PRIVILEGED)

SYNOPSIS
	ORI	#<data>,SR

	Size = (Word)

FUNCTION
	Performs an OR operation on the status register with
	the source operand, and leaves the result in the status
	register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	|                     16 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

RESULT
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	

***********************************************************

PACK "PACK binary coded decimal"
NAME
	PACK -- Pack binary coded decimal	(68020+)

SYNOPSIS
	PACK	-(Ax),-(Ay),#<adjustment>
	PACK	Dx,Dy,#<adjustment>

        Size = (Byte, Long)

FUNCTION
	Convert byte-per-digit unpacked BCD to packed two-digit-
	per-byte BCD.
	When operand is in a data register, 16 bits adjustment is added
	to source operand (16 bits). Then, bits 8 to 11 and 0 to 3 are
	packed and placed in the bits 0 to 7 of destination register.
	Others bits of this register are not altered.

	When operand is in memory, there's a research by pre-decrementing
	of the two bytes placed at given address. The two bytes are
	linked together, then adjustment is added, and the compacted result
	is stored at destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 0 | 0 | 0 |   Dy/Ay   | 1 | 0 | 1 | 0 | 0 |R/M|   Dx/Ax   |
	|---------------------------------------------------------------|
	|                    16 BITS ADJUSTMENT                         |
	-----------------------------------------------------------------

	R/M = 0 -> Direct addressing by data register.
	R/M = 1 -> Addressing by pre-decrementing.
	Register Dy/Ay specifies destination register.
	Register Dx/Ax specifies source register.
	"16 BITS ADJUSTMENT" is an immediate value added to source operand.

RESULT
	None.


***********************************************************

Pea "Push Effective Address"
NAME
	PEA -- Push effective address

SYNOPSIS
	PEA	<ea>

	Size = (Long)

FUNCTION
	Effective address is stored to stack. Stack is decreased.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> specifies destination operand, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

PFLUSH "Invalidate one or several entries in the ATC (PRIVILEGED)"
NAME
	PFLUSH -- Invalidate one or several entries in the ATC	(PRIVILEGED)

SYNOPSIS
	PFLUSHA
	PFLUSH	<FC>,#<FC validation>
	PFLUSH	<FC>,#<FC validation>,<ea>
	
	No size specs.

FUNCTION
	Those three instructions are used to invalidate one or several entries
	of the ATC (PMMU cache), i.e. to set the validation bits following to
	those zero entries.

	PFLUSHA invalidate all the 22 entries of cache.

	PFLUSH <FC>,#<FC validation> invalidate entry which follows mentionned
	Function Codes.

	PFLUSH <FC>,#<FC validation>,<ea> invalidate entry which address is
	specified in the destination, of course in taking care of Function
	Codes.

	FC validation bits allow to take care of 3 FC bits else only some of
	these bits.
	The status register of the PMMU, MMUSR, isn't affected by this
	instruction.

	<FC> operand can be mentioned:
	∑in immediate.
	∑by the three lower bits of a data register.
	∑by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|-------------------------------|
	| 0 | 0 | 1 |    MODE   | 0 | 0 |    FC     |         FC        | 
	|   |   |   |           |   |   |VALIDATION |                   |
	-----------------------------------------------------------------

	MODE field indicates the type of PFLUSH:
	001->invalidation of all entries.
	100->invalidation by Function Codes.
	110->invalidation by the Function Codes and <ea>.

	FC VALIDATION field indicates the FC bits to take care of.
	FC field indicates value of Function Codes of the entry to
	invalidate.

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

REGISTER
	<ea> specifies address to invalidate, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.


***********************************************************

PLOAD "LOAD of an entry in the ATC (PRIVILEGED)"
NAME
	PLOAD -- Load of an entry in the ATC (PRIVILEGED)

SYNOPSIS
	PLOADR	<FC>,<ea>
	PLOADW	<FC>,<ea>
	
	No size specs.

FUNCTION
	Those instructions are used to load in the ATC (PMMU cache), one entry
	following to logic specified <ea>. A research in table  is made for
	this cache modification and attributes of final descriptor are updated
	(bits U and M for PLOADW, bits U for PLOADR) according to the executed
	instruction. PLOADR makes a loading of an entry in the ATC, as if a
	read cycle was made. PLOADW makes a loading of an entry in the ATC,
	as if a write cycle was made.

	The status register of the PMMU, MMUSR, isn't affected by this
	instruction.

	<FC> operand can be mentioned:
	∑in immediate.
	∑by the three lower bits of a data register.
	∑by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|---|---|---|---|---|---|---|-----------------------|
	| 0 | 0 | 1 | 0 | 0 | 0 |R/W| 0 | 0 | 0 | 0 |         FC        | 
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->write access.
	1->read access.

	FC field indicates value of Function Codes of the entry to
	invalidate.

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

REGISTER
	<ea> specifies logic address to load, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.


***********************************************************

PMOVE "MOVE from or to PMMU registers (PRIVILEGED)"
NAME
	PMOVE -- Move from or to PMMU registers (PRIVILEGED)

SYNOPSIS
	PMOVE	MMU-reg,<ea>
	PMOVE	<ea>,MMU-reg
	PMOVEFD	<ea>,MMU-reg
	
	Size = (Word, Long, Quad).

FUNCTION
	This instruction is used to read or write PMMU registers.
	Transfert on CRP or SRP is for a Quadruple word (64 bits), TC, TT0,
	TT1 one's is for a Long word, and MMUSR one's is for a Word.

	PMOVEFD instruction does a move with invalidation or not  of PMMU
	cache. If FD bit is set in the instruction, the ATC isn't invalidated;
	if FD bit is cleared, ATC is invalidated.

	If value loaded in CRP or SRP follows to a not valid descriptor,
	the value is loaded but an exception of configuration error of PMMU
	is generated.

	For the TC register, a checking  on fields PS, IS, and TIx is made;
	if there's error on the total of mentioned bits, operand is loaded
	but an exception of configuration error of PMMU is generated.

	MMUSR isn't affected by those transferts, else it is placed in
	destination!!

FORMAT
	For CRP, SRP, TC registers:
	~~~~~~~~~~~~~~~~~~~~~~~~~~
	PMMU-reg field specifies PMMU register:
	000->TC
	010->SRP
	011->CRP
                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|---|---|-----------------------|
	| 0 | 1 | 0 |  MMU-reg  |R/W|FD | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	For TT0, TT1, registers:
        ~~~~~~~~~~~~~~~~~~~~~~~
	PMMU-reg field specifies PMMU register:
	010->TT0
	011->TT1

	FD bit: allows or not ATC invalidation:
	0->ATC invalidated.
	1->ATC NOT invalidated.

                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|---|---|-----------------------|
	| 0 | 0 | 0 |  MMU-reg  |R/W|FD | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	For MMUSR register:
	~~~~~~~~~~~~~~~~~~
                                                         <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|---|---|---|---|---|---|---|-----------------------|
	| 0 | 1 | 1 | 0 | 0 | 0 |R/W| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->Memory to PMMU register.
	1->PMMU register to memory.

REGISTER
	<ea> specifies memory address, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.


***********************************************************

PTEST "TESTs a logic address (PRIVILEGED)"
NAME
	PTEST -- TESTs a logic address (PRIVILEGED)

SYNOPSIS
	PTESTR	<FC>,<ea>,#<level>
	PTESTR	<FC>,<ea>,#<level>,An
	PTESTW	<FC>,<ea>,#<level>
	PTESTW	<FC>,<ea>,#<level>,An
	
	No size specs.

FUNCTION
	This instruction examines the ATC, if level is equal to zero,
	a research in the translation tables is made, if level is different
	of zero (1 to 7), then sets MMUSR bits.
	This instruction can also store, in an address register An, physical
	address encountred to last level of its research.

	PTESTR or PTESTW version is used to simulate a read or write cycle and
	like this, according to the informations founds, exactly set MMUSR.

	MMUSR bits are set of the following manner:

	MMUSR bits  |   PTEST level 0        |  PTEST level > 0
	~~~~~~~~~~  |   ~~~~~~~~~~~~~        |  ~~~~~~~~~~~~~~~
	B (bit 15)  | This bit is set if the |This bit is set if a bus error
	            | bit "Error Bus (B)" of |is generated during research in
	            | the ATC is set.        |the tables.
	----------------------------------------------------------------------
	L (bit 14)  | This bit is cleared    | This bit is set if an index
	            |                        |overflow a limit during a
	            |                        |research.
	----------------------------------------------------------------------
	S (bit 13)  | This bit is cleared    | This bit is set for indicating
	            |                        |a privilege violation: if S bit
	            |                        |of one of the descriptors met
	            |                        |is set and the FC2 bit mentioned
	            |                        |in the instruction is cleared
	            |                        |(user access). S isn't defined
	            |                        |if the bit I of MMUSR is set.
	----------------------------------------------------------------------
	W (bit 11)  | This bit is set if the | This bit is set if WP bit of
	            | bit WP in entry of the |one of the descriptors
	            | examined ATC is set.   |encountred is set. Undefined
	            | Undefined if I is set. |if I is set.
	----------------------------------------------------------------------
	I (bit 10)  | This bit is set if     |This bit is set if one of the
	            | required logic address |descriptors encountred isn't
	            | isn't in the ATC or if |valid (DT = 0) or if B or L of
	            | the bit B of this entry|MMUSR are set during research.
	            | is set.                |
	----------------------------------------------------------------------
	M (bit 9)   | This bit is set if the |This bit is set if the encountred
	            | bit M of designed entry|page descriptor has its bit M
	            | is set. Undefined if I |set. Undefined if I is set.
	            | is set.                |
	----------------------------------------------------------------------
	T (bit 6)   | This bit is set if     | This bit is cleared.
	            | mentioned logic address|
	            | is part of defined     |
	            | window by TT0 and/or   |
	            | TT1.                   |
	----------------------------------------------------------------------
	N (bits     |This field is cleared   | This field represents the number
	   2 to 0)  |                        | of level accessed during table
	            |                        | research.
	----------------------------------------------------------------------

	<FC> operand can be mentioned:
	∑in immediate.
	∑by the three lower bits of a data register.
	∑by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|-------------------------------|
	| 1 | 0 | 0 |   LEVEL   |R/W| A |    REG    |         FC        | 
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->write access.
	1->read access.

	FC field indicates value of Function Codes of the address to test

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

	Bit A specifies address register option:
	0-> no address register
	1-> address of last accessed descriptor is put in the register
	specified by REG.

	REG field indicates, if A = 1 the number of address register. Else
	if A = 0, REG = 0.

	LEVEL field indicates the highest logic level to go during research;
	if test in the ATC, LEVEL = 0.

REGISTER
	<ea> specifies logic address to test, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	Not affected.


***********************************************************

Reset "RESET external devices"
NAME
	RESET -- Reset external devices

SYNOPSIS
	RESET

FUNCTION
	RESET line is set, then external circuitery is reset.
	Processor state isn't modified, except PC, which allows restart
	of execution to the next instruction.
	If processor is NOT in supervisor state, there's generation of
	exception "privilege violation", vector n∞8.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

Reset "RESET external devices"
NAME
	RESET -- Reset external devices

SYNOPSIS
	RESET

FUNCTION
	RESET line is set, then external circuitery is reset.
	Processor state isn't modified, except PC, which allows restart
	of execution to the next instruction.
	If processor is NOT in supervisor state, there's generation of
	exception "privilege violation", vector n∞8.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

ROd "ROtate Left and ROtate Right"
NAME
	ROL, ROR -- Rotate left and rotate right

SYNOPSIS
	ROd	Dx,Dy
	ROd	#<data>,Dy
	ROd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
	Rotate the bits of the operand in the specified direction.
	The rotation count may be specified in two different ways:

	1. Immediate - the rotation count is specified in the instruction

	2. Register  - the rotation count is contained in a data register
	               specified in the instruction

	For a register, the size may be byte, word, or long, but for a memory
	location, the size must be a word. The rotation count is also
	restricted to one for a memory location.

                  .-------->--------.
	ROL:      |                 |
	      C <------ OPERAND <---'
	                  <---	       

	ROR:     ,-------<-------.
	         |               |
	         `--> OPERAND -----> C
	                --->

FORMAT
	In the case of the rotating of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 1 | 1 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the rotating of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 1 | 1 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of rotating or number of register which contents
	the number of rotating.
	If i/r = 0, number of rotating is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right rotating
	If dr = 1, left rotating

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register rotating:
	Indicates the number of data register on which rotating is applied.

	For a memory rotating:
	<ea> indicates operand which should be rotated.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.


***********************************************************

Roxd "ROtate Left with eXtend and ROtate Right with eXtend"
NAME
	ROXL, ROXD -- Rotate left with extend and rotate right with extend

SYNOPSIS
	ROXd	Dx,Dy
	ROXd	#<data>,Dy
	ROXd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
        A rotation is made on destination operand bits.
        Rotation uses bit X.

                  .-------->-----------.
	ROXL:     |                    |
	      C <------ OPERAND <- X --'
	                  <---	       

	ROXR:    ,---------<-------.
	         |                 |
	         `-- X -> OPERAND -----> C
	                   --->

FORMAT
	In the case of the rotating of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 1 | 0 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the rotating of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 1 | 0 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of rotating or number of register which contents
	the number of rotating.
	If i/r = 0, number of rotating is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right rotating
	If dr = 1, left rotating

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register rotating:
	Indicates the number of data register on which rotating is applied.

	For a memory rotating:
	<ea> indicates operand which should be rotated.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set by the last bit out of operand.
            Not changed if rotation is zero.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.


***********************************************************

Rtd "ReTurn and Deallocate parameter stack frame"
NAME
	RTD -- Return and deallocate parameter stack frame	(68010+)

SYNOPSIS
	RTD	#<offset>

FUNCTION
	PC is subtracted from stack and replace old PC address.
	Then offset is added to SP value.

	This instruction is useful to restore reserved space memory of
	stored arguments at time sub-routine is called.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET                         |
	-----------------------------------------------------------------

	"16 BITS OFFSET" is a signed 16 bits value to add to SP.

RESULT
	None.


***********************************************************

Rte "ReTurn from Exception (PRIVILEGED)"
NAME
	RTE -- Return from exception (PRIVILEGED)

SYNOPSIS
	RTE

FUNCTION
	SR and PC are restored by SP. All SR bits are affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |
	-----------------------------------------------------------------

RESULT
	SR is set following to the restored word taken from SP.


***********************************************************

Rtm "ReTurn from process Module"
NAME
	RTM -- Return from process module	(68020 ONLY)

SYNOPSIS
	RTM	Rn

FUNCTION
	Return from a process module called with CALLM.
	This instruction is 68020 ONLY and is used with, for cooperation
	with the PMMU MC68851. Be carreful, it's not available on 68030+.
        
RESULT
	Don't know!


***********************************************************

Rtr "ReTurn and Restore CCR"
NAME
	RTR -- Return and restore condition code register

SYNOPSIS
	RTR

FUNCTION
	CCR and PC are restored by SP.
	Supervisor byte of SR isn't affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
	-----------------------------------------------------------------

RESULT
	SR is set following to the restored word taken from SP.


***********************************************************

Rts "ReTurn from Subroutine"
NAME
	RTS -- Return from subroutine

SYNOPSIS
	RTS

FUNCTION
	PC is restored by SP.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 1 |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

Sbcd "Subtract Binary Coded Decimal with extend"
NAME
	SBCD -- Subtract binary coded decimal with extend

SYNOPSIS
	SBCD	Dy,Dx
	SBCD	-(Ay),-(Ax)

	Size = (Byte)

FUNCTION
	Subtracts the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.
        The subtraction is performed using binary coded decimal arithmetic.
        The operands, which are packed BCD numbers, can be addressed in two
        different ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	Normally the Z condition code bit is set via programming before the
	start of an operation. That allows successful tests for zero results
	upon completion of multiple-precision operations.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 0 | 0 | 0 |Ry REGISTER| 1 | 0 | 0 | 0 | 0 |R/M|Rx REGISTER|
	-----------------------------------------------------------------

	Ry specifies destination register.
	Rx specifies source register.
	If R/M = 0: Rx and Ry are datas registers.
	If R/M = 1: Rx and Ry are address registers used  for the pre-
	decrementing.

RESULT
	X - Set the same as the carry bit.
	N - Undefined
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Undefined
	C - Set if a decimal carry was generated. Cleared otherwise.


***********************************************************

Scc "Conditional Set"
NAME
	Scc -- Conditional set

SYNOPSIS
	Scc	<ea>

        Size = (Byte)

FUNCTION
        If condition is true then byte addressed by <ea> is set to $FF,
        else byte addressed by <ea> is set to $00.

	Condition code 'cc' specifies one of the following:
0000 F  False            Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True             Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh             C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same      C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear      C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set        C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal        Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual            Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---------------|---|---|-----------|-----------|
	| 0 | 1 | 0 | 1 | cc CONDITION  | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> specifies operand to set, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	None.


***********************************************************

Stop "Stop processor execution (PRIVILEGED)"
NAME
	STOP -- Stop processor execution (PRIVILEGED)

SYNOPSIS
	STOP	#<data:16>

FUNCTION
	Immediate data is moved to SR. PC is set to next instruction,
	and the processor stops fetch and execution of instruction.
	Execution restarts if if a TRACE exception, an interruption, or
	a RESET takes place.
	When STOP is executed, a TRACE exception is generated (if T = 1).
	An interruption is allowed if it level is higher than current one.
	An external RESET always will generate a RESET exception.
	If bit S is set to zero by the immediate data, execution of this
	instruction will generate a "privilege violation".

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
	|---------------------------------------------------------------|
	|                    16 BITS IMMEDIATE DATA                     |
	-----------------------------------------------------------------

RESULT
	SR is set according to immediate data.


***********************************************************

Sub "SUBtract"
NAME
	SUB -- Subtract

SYNOPSIS
	SUB	<ea>,Dn
	SUB	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
        Subtracts source operand to destination operand.
        Result is stored to destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>

OP-MODE
	Byte	Word	Long
	~~~~	~~~~	~~~~
	000	001	010	(Dn) - (<ea>) -> Dn
	100	101	110	(<ea>) - (Dn) -> <ea>

REGISTER
	One of the 8 datas registers

	If <ea> is source, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d16,An)    |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Word or Long only

	If <ea> is destination, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	When destination is an Address Register, SUBA instruction is used.

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.



***********************************************************

Suba "SUBtract Address"
NAME
	SUBA -- Subtract address

SYNOPSIS
	SUBA	<ea>,An

	Size = (Word, Long)

FUNCTION
        Subtracts source operand to destination operand.
        Source operand with a Word size is extended to 32 bits before
        operation. Result is stored to destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>
OP-MODE
	Indicates operation lenght:
	011->one Word operation: source operand is extended to 32 bits
	111->one Long operation

REGISTER
	<ea> is source, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d16,An)    |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
        None.


***********************************************************

Subi "SUBtract Immediate"
NAME
	SUBI -- Subtract immediate

SYNOPSIS
	SUBI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the immediate data to the destination operand, and
	stores the result in the destination location. The size of the
	operation may be specified as byte, word, or long.
        The size of the	immediate data matches the operation size.

FORMAT
                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | SIZE  |   MODE    |  REGISTER |
	|---------------------------------------------------------------|
	| 16 BITS DATA (with last Byte) |          8 BITS DATA          |
	|---------------------------------------------------------------|
	|             32 BITS DATA (included last Word)                 |
	-----------------------------------------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> is always destination, addressing modes are the following:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.



***********************************************************

Subq "SUBtract 3-bit immediate Quick"
NAME
	SUBQ -- Subtract 3-bit immediate quick

SYNOPSIS
	SUBQ	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the immediate value of 1 to 8 to the operand at the
	destination location. The size of the operation may be specified as
	byte, word, or long. When subtracting to address registers,
        the condition codes are not altered, and the entire destination
        address register is used regardless of the operation size.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 1 |    DATA   | 1 | SIZE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>

DATA
	000        ->represent value 8
	001 to 111 ->immediate data from 1 to 7

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> is always destination, addressing modes are the following:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N∞ reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------
	 * Word or Long only.

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.


***********************************************************

Subx "SUBtract with eXtend"
NAME
	SUBX -- Subtract with extend

SYNOPSIS
	SUBX	Dy,Dx
	SUBX	-(Ay),-(Ax)

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.
        The subtraction is performed using binary coded decimal arithmetic.
        The operands, which are packed BCD numbers, can be addressed in two
        different ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	The size of operation can be specified as byte, word, or long.

	Normally the Z condition code bit is set via programming before the
	start of an operation. That allows successful tests for zero results
	upon completion of multiple-precision operations.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 0 | 0 | 1 |    Rx     | 1 | SIZE  | 0 | 0 |R/M|    Ry     |
	-----------------------------------------------------------------

	R/M = 0 -> data register
	R/M = 1 -> address register
	Rx:   destination register
	Ry:   source register

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.



***********************************************************

Swap "SWAP register upper and lower words"
NAME
	SWAP -- Swap register upper and lower words

SYNOPSIS
        SWAP	Dn

        Size = (Word)

FUNCTION
        Swaps between 16 low bits and 16 high bits of register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of register on which swap is made.

RESULT
	X - Not affected
	N - Set if the most-significant bit of the result was set. Cleared
	    otherwise.
	Z - Set if the 32 bits result was zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.


***********************************************************

Tas "Test And Set operand"
NAME
	TAS -- Test and set operand

SYNOPSIS
	TAS	<ea>

	Size = (Byte)

FUNCTION
	Test of a byte addressed by <ea>, bits N and Z of SR are set
	according to result of test.
	Bit 7 of byte is set to 1. This instruction uses read-modify-write
	cycle, which is not dividable and allows synchronisation of several
	processors. But this instruction is NOT ALLOWED ON AMIGA!
	This instruction can easily be substituted by BSET.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> is destination, addressing modes are the following:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if MSB of byte is set. Cleared otherwise.
	Z - Set if byte is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

***********************************************************

Trap "Initiate processor TRAP"
NAME
	TRAP -- Initiate processor trap

SYNOPSIS
	TRAP	#<number>

FUNCTION
	Processor starts an exception process. TRAP number is pointed
	out by 4 bits into the instruction. 16 vectors are free to
	be used for TRAP (vectors from 32 to 47).
	So the <number> can go from 0 to 15.
	PC and SR are stored to SSP, and Vector is written to PC.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---------------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 0 |  N∞ of TRAP   |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

Trapcc "Conditional trap"
NAME
	TRAPcc -- Conditional trap		(68020+)

SYNOPSIS
	TRAPcc
	TRAPcc.w	#<data>
	TRAPcc.l	#<data>

FUNCTION
	If "cc CONDITION" is true then there's generation of a level 7
	exception, else execution continue normally.
	Immediate data is optional, if given, the exception sub-routine can
	use it.

	Condition code 'cc' specifies one of the following:
0000 F  False            Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True             Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh             C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same      C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear      C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set        C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal        Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual            Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---------------|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 1 | cc CONDITION  | 1 | 1 | 1 | 1 | 1 |  OP-MODE  |
	|---------------------------------------------------------------|
	|                OPTIONAL 16 BITS IMMEDIATE DATA                |
	|---------------------------------------------------------------|
	|                OPTIONAL 32 BITS IMMEDIATE DATA                |
	-----------------------------------------------------------------

OP-MODE
	010-> instruction followed of 16 bits.
	011-> instruction followed of 32 bits.
	100-> instruction with no immediate operand.

RESULT
	None.


***********************************************************

Trapv " Trap on oVerflow"
NAME

	TRAPv  -- Trap on overflow

SYNOPSIS
	TRAPV

FUNCTION
	If overflow capacity condition is true (V = 1) then there's
	generation of a level 7 exception, else execution continue
	normally.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 0 |
	-----------------------------------------------------------------

RESULT
	None.


***********************************************************

Tst "TeST operand for zero"
NAME
	TST -- Test operand for zero

SYNOPSIS
	TST	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Operand is compared with zero. Flags are set according to the result.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | SIZE  |   MODE    |  REGISTER |
	----------------------------------------=========================
                                                          <ea>

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> is destination, if size is 16 or 32 bits then all addressing
	modes are allowed. If size is 8 bits, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N∞ reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N∞ reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N∞ reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N∞ reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N∞ reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N∞ reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N∞ reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N∞ reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N∞ reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.


***********************************************************

Unlk "Free stack frame created by LINK"
NAME
	UNLK -- Free stack frame created by LINK

SYNOPSIS
	UNLK	An

FUNCTION
	This instruction does the inverse process of LINK instruction.
	Address register specified is moved in SP.
	Contents of SP is moved into address register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of address register, used as area
	pointer.

RESULT
	None.


***********************************************************

Unpk "Unpack binary coded decimal"
NAME
	UNPK -- Unpack binary coded decimal	(68020+)

SYNOPSIS
	UNPK	-(Ax),-(Ay),#<adjustment>
	UNPK	Dx,Dy,#<adjustment>

	No size specs

FUNCTION
	Convert packed two-digit-per-byte BCD to byte-per-digit
	unpacked BCD.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 0 | 0 | 0 |   Dy/Ay   | 1 | 1 | 0 | 0 | 0 |R/M|   Dx/Ax   |
	|---------------------------------------------------------------|
	|                    16 BITS ADJUSTMENT                         |
	-----------------------------------------------------------------

	R/M = 0 -> data register.
	R/M = 1 -> Memory by pre-decrementing.
	Register Dy/Ay specifies destination register.
	Register Dx/Ax specifies source register.
	"16 BITS ADJUSTMENT" is an immediate value added to source operand.

RESULT
	None.

+--------------------------------------------------------------------------+
|	        Instruction Cycles table
+--------------------------------------------------------------------------+
68030 Instruction times

CEA  - Add Calculate Effective Address time (CEA)
CIEA - Add Calculate Immediate Effective Address time (CIEA)
FEA  - Add Fetch Effective Address time (FEA)
FIEA - Add Fetch Immediate Effective Address time (FIEA)
JEA  - Add Jump Effective Address Time (JEA)


 (r/p/w)  r - Read Cycles
          p - Prefetch Cycles
          w - Write Cycles

                                    Head  Tail   I-Cache     No-Cache
     move	Rn,Dn                   2     0      2(0/0/0)    2(0/1/0)
     move	Rn,An                   2     0      2(0/0/0)    2(0/1/0)
FEA  move	EA,An                   0     0      2(0/0/0)    2(0/1/0)
FEA  move	EA,Dn                   0     0      2(0/0/0)    2(0/1/0)
     move	Rn,(An)                 0     1      3(0/0/1)    4(0/1/1)
FEA  move	SOURCE,(An)             2     0      4(0/0/1)    5(0/1/1)
     move	Rn,(An)+                0     1      3(0/0/1)    4(0/1/1)
FEA  move	SOURCE,(An)+            2     0      4(0/0/1)    5(0/1/1)
     move	Rn,-(An)                0     2      4(0/0/1)    4(0/1/1)
FEA  move	SOURCE,-(An)            2     0      4(0/0/1)    5(0/1/1)
FEA  move	EA,(d16,An)             2     0      4(0/0/1)    5(0/1/1)
FEA  move	EA,xxx.W                2     0      4(0/0/1)    5(0/1/1)
FEA  move	EA,xxx.L                0     0      6(0/0/1)    7(0/2/1)
FEA  move	EA,(d8,An,Xn)           4     0      6(0/0/1)    7(0/1/1)
FEA  move	EA,(d16,An)             2     0      8(0/0/1)    9(0/2/1)
FEA  move	EA,(d16,PC)             2     0      8(0/0/1)    9(0/2/1)
FEA  move	EA,(d16,An,Xn)          2     0      8(0/0/1)    9(0/2/1)
FEA  move	EA,(d16,PC,Xn)          2     0      8(0/0/1)    9(0/2/1)
FEA  move	EA,([d16,An],Xn)        2     0     10(1/0/1)   11(1/2/1)
FEA  move	EA,([d16,PC],Xn)        2     0     10(1/0/1)   11(1/2/1)
FEA  move	EA,([d16,An],d16)       2     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([d16,PC],d16)       2     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([d16,An],d32)       2     0     14(1/0/1)   16(1/3/1)
FEA  move	EA,([d16,PC],d32)       2     0     14(1/0/1)   16(1/3/1)
FEA  move	EA,([d16,An],Xn,d32)    2     0     14(1/0/1)   16(1/3/1)
FEA  move	EA,([d16,PC],Xn,d32)    2     0     14(1/0/1)   16(1/3/1)
FEA  move	EA,(B)                  4     0      8(0/0/1)    9(0/1/1)
FEA  move	EA,(d16,B)              4     0     10(0/0/1)   12(0/2/1)
FEA  move	EA,(d32,B)              4     0     14(0/0/1)   16(0/2/1)
FEA  move	EA,([B])                4     0     10(1/0/1)   11(1/1/1)
FEA  move	EA,([B].l)              4     0     10(1/0/1)   11(1/1/1)
FEA  move	EA,([B],d16)            4     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([B].l,d16)          4     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([B],d32)            4     0     14(1/0/1)   16(1/2/1)
FEA  move	EA,([B].l,d32)          4     0     14(1/0/1)   16(1/2/1)
FEA  move	EA,([d16,B])            4     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([d16,B].l)          4     0     12(1/0/1)   14(1/2/1)
FEA  move	EA,([d16,B],d16)        4     0     14(1/0/1)   17(1/2/1)
FEA  move	EA,([d16,B].l,d16)      4     0     14(1/0/1)   17(1/2/1)
FEA  move	EA,([d16,B],d32)        4     0     16(1/0/1)   19(1/3/1)
FEA  move	EA,([d16,B].l,d32)      4     0     16(1/0/1)   19(1/3/1)
FEA  move	EA,([d32,B])            4     0     16(1/0/1)   18(1/2/1)
FEA  move	EA,([d32,B].l)          4     0     16(1/0/1)   18(1/2/1)
FEA  move	EA,([d32,B],d16)        4     0     18(1/0/1)   21(1/3/1)
FEA  move	EA,([d32,B].l,d16)      4     0     18(1/0/1)   21(1/3/1)
FEA  move	EA,([d32,B],d32)        4     0     18(1/0/1)   23(1/3/1)
FEA  move	EA,([d32,B].l,d32)      4     0     18(1/0/1)   23(1/3/1)
     exg	Ry,Rx                   4     0      4(0/0/0)    4(0/1/0)
     movec	Cr,Rn                   6     0      6(0/0/0)    6(0/1/0)
     movec	Rn,usp vbr caar msp isp 6     0      6(0/0/0)    6(0/1/0)
     movec	Rn,sfc dfc cacr         4     0     12(0/0/0)   12(0/1/0)
     move	ccr,Dn                  2     0      4(0/0/0)    4(0/1/0)
CEA  move	ccr,mem                 2     0      4(0/0/1)    5(0/1/1)
     move	Dn,ccr                  4     0      4(0/0/1)    4(0/1/1)
CEA  move	EA,ccr                  0     0      4(0/0/1)    4(0/1/1)
     move	sr,Dn                   2     0      4(0/0/1)    4(0/1/1)
CEA  move	sr,mem                  2     0      4(0/0/1)    4(0/1/1)
FEA  move	EA,sr                   0     0      8(0/0/0)   10(0/1/0)
CIEA movem	EA,rl (+)               2     0     8+4n(n/0/0)	8+4n(n/1/0)
CIEA movem	rl,EA (+)               2     0     4+2n(0/0/n) 4+2n(0/1/n)
     movep.w Dn,(d16,An)            4     0     10(0/0/2)   10(0/1/2)
     movep.w (d16,An),Dn            2     0     10(2/0/0)   10(2/1/0)
     movep.l Dn,(d16,An)            4     0     14(0/0/4)   14(0/1/4)
     movep.l (d16,An),Dn            2     0     14(4/0/0)   14(4/1/0)
CIEA moves	EA,Rn                   3     0      7(1/0/0)    7(1/1/0)
CIEA moves	Rn,EA                   2     1      5(0/0/1)    6(0/1/1)
     move	usp,An                  4     0      4(0/0/0)    4(0/1/1)
     move	An,usp                  4     0      4(0/0/0)    4(0/1/0)
     swap	Dn                      4     0      4(0/0/0)    4(0/1/0)
     add	Rn,Dn                   2     0      2(0/0/0)    2(0/1/0)
     adda.w	Rn,An                   4     0      4(0/0/0)    4(0/1/0)
     adda.l	Rn,An                   2     0      2(0/0/0)    2(0/1/0)
FEA  add	EA,Dn                   0     0      2(0/0/0)    2(0/1/0)
FEA  adda.w	EA,An                   0     0      4(0/0/0)    4(0/1/0)
FEA  adda.l	EA,An                   0     0      2(0/0/0)    2(0/1/0)
FEA  add	Dn,EA                   0     1      3(0/0/1)    4(0/1/1)
     and	Dn,Dn                   2     0      2(0/0/0)    2(0/1/0)
FEA  and	EA,Dn                   0     0      2(0/0/0)    2(0/1/0)
FEA  and	Dn,EA                   0     1      3(0/0/1)    4(0/1/1)
     eor	Dn,Dn                   2     0      2(0/0/0)    2(0/1/0)
FEA  eor	Dn,EA                   0     1      3(0/0/1)    4(0/1/1)
     or	Dn,Dn                       2     0      2(0/0/0)    2(0/1/0)
     or	EA,Dn                       0     0      2(0/0/0)    2(0/1/0)
     or	Dn,EA                       0     1      3(0/0/1)    4(0/1/1)
     sub	Rn,Dn                   2     0      2(0/0/0)    2(0/1/0)
FEA  sub	EA,Dn                   0     0      2(0/0/0)    2(0/1/0)
FEA  sub	Dn,EA                   0     1      3(0/0/1)    4(0/1/1)
     suba.w	Rn,An                   4     0      4(0/0/0)    4(0/1/0)
     suba.l	Rn,An                   2     0      2(0/0/0)    2(0/1/0)
FEA  suba.w	EA,An                   0     0      4(0/0/0)    4(0/1/0)
FEA  suba.l	EA,An                   0     0      2(0/0/0)    2(0/1/0)
     cmp	Rn,Dn                   2     0      2(0/0/0)    2(0/1/0)
FEA  cmp	EA,Dn                   0     0      2(0/0/0)    2(0/1/0)
     cmpa	Rn,An                   4     0      4(0/0/0)    4(0/1/0)
FEA  cmpa	EA,An                   0     0      4(0/0/0)    4(0/1/0)
FIEA cmp2	EA,Rn (max)             2     0     20(1/0/0)   20(1/1/0)
FEA  muls.w	EA,Dn (max)             2     0     28(0/0/0)   28(0/1/0)
FIEA muls.l	EA,Dn (max)             2     0     44(0/0/0)   44(0/1/0)
FEA  mulu.w	EA,Dn (max)             2     0     28(0/0/0)   28(0/1/0)
FIEA mulu.l	EA,Dn (max)             2     0     44(0/0/0)   44(0/1/0)
     divs.w	Dn,Dn (max)             2     0     56(0/0/0)   56(0/1/0)
FEA  divs.w	EA,Dn (max)             0     0     56(0/0/0)   56(0/1/0)
FIEA divs.l	Dn,Dn (max)             6     0     90(0/0/0)   90(0/1/0)
FIEA divs.l	EA,Dn (max)             0     0     90(0/0/0)   90(0/1/0)
     divu.w	Dn,Dn (max)             2     0     44(0/0/0)   44(0/1/0)
FEA  divu.w	EA,Dn (max)             0     0     44(0/0/0)   44(0/1/0)
FIEA divu.l	Dn,Dn (max)             6     0     78(0/0/0)   78(0/1/0)
FIEA divu.l	EA,Dn (max)             0     0     78(0/0/0)   78(0/1/0)
     moveq	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
     addq	#(data),Rn              2     0      2(0/0/0)    2(0/1/0)
FEA  addq	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
     subq	#(data),Rn              2     0      2(0/0/0)    2(0/1/0)
FEA  subq	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA addi	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA addi	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA andi	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA andi	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA eori	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA eori	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA ori	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA ori	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA subi	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA subi	#(data),Mem             0     1      3(0/0/1)    4(0/1/1)
FIEA cmpi	#(data),Dn              2     0      2(0/0/0)    2(0/1/0)
FIEA cmpi	#(data),Mem             0     0      3(0/0/1)    2(0/1/0)
     abcd	Dn,Dn                   0     0      4(0/0/0)    4(0/1/0)
     abcd	-(An),-(An)             2     1     13(2/0/1)   14(2/1/1)
     sbcd	Dn,Dn                   0     0      4(0/0/0)    4(0/1/0)
     sbcd	-(An),-(An)             2     1     13(2/0/1)   14(2/1/1)
     addx	Dn,Dn                   2     0      2(0/0/0)    2(0/1/0)
     addx	-(An),-(An)             2     1      9(2/0/1)   10(2/1/1)
     subx	Dn,Dn                   2     0      2(0/0/0)    2(0/1/0)
     subx	-(An),-(An)             2     1      9(2/0/1)   10(2/1/1)
     cmpm	(An)+,(An)+             0     0      8(2/0/0)    8(2/1/0)
     pack	Dn,Dn,#(data)           6     0      6(0/0/0)    6(0/1/0)
     pack	-(An),-(An),#(data)     2     1     11(1/0/1)   11(1/1/1)
     unpk	Dn,Dn,#(data)           8     0      8(0/0/0)    8(0/1/0)
     unpk	-(An),-(An),#(data)     2     1     11(1/0/1)   11(1/1/1)
     clr	Dn                      2     0      2(0/0/0)    2(0/1/0)
CEA  clr	Mem                     0     1      3(0/0/1)    4(0/1/1)
     neg	Dn                      2     0      2(0/0/0)    2(0/1/0)
FEA  neg	Mem                     0     1      3(0/0/1)    4(0/1/1)
     negx	Dn                      2     0      2(0/0/0)    2(0/1/0)
FEA  negx	Mem                     0     1      3(0/0/1)    4(0/1/1)
     not	Dn                      2     0      2(0/0/0)    2(0/1/0)
FEA  not	Mem                     0     1      3(0/0/1)    4(0/1/1)
     ext	Dn                      4     0      4(0/0/0)    4(0/1/0)
     nbcd	Dn                      0     0      6(0/0/0)    6(0/1/0)
     scc	Dn                      4     0      4(0/0/0)    4(0/1/0)
CEA  scc	Mem                     0     1      5(0/0/1)    5(0/1/1)
     tas	Dn                      4     0      4(0/0/0)    4(0/1/0)
CEA  tas	Mem                     3     0     12(1/0/1)   12(1/1/1)
     tst	Dn                      0     0      2(0/0/0)    2(0/1/0)
FEA  tst	Mem                     0     0      2(0/0/0)    2(0/1/0)
     ls?	#(data),Dy              4     0      4(0/0/0)    4(0/1/0)
     ls?	Dx,Dy (shift << size)   6     0      6(0/0/0)    6(0/1/0)
     ls?	Dx,Dy (shift >> size)   8     0      8(0/0/0)    8(0/1/0)
FEA  ls?	Mem (by one)            0     0      4(0/0/1)    4(0/1/1)
     asl	#(data),Dy              2     0      6(0/0/0)    6(0/1/0)
     asl	Dx,Dy                   4     0      8(0/0/0)    8(0/1/0)
     asl	Mem (by one)            0     0      6(0/0/0)    6(0/1/0)
     asr	#(data),Dy              4     0      4(0/0/0)    4(0/1/0)
     asr	Dx,Dy (shift << size)   6     0      6(0/0/0)    6(0/1/0)
     asr	Dx,Dy (shift >> size)   10    0     10(0/0/0)   10(0/1/0)
FEA  asr	Mem (by one)            0     0      4(0/0/0)    4(0/1/0)
     ro?	#(data),Dy              4     0      6(0/0/0)    6(0/1/0)
     ro?	Dx,Dy                   6     0      8(0/0/0)    8(0/1/0)
FEA  ro?	Mem (by one)            0     0      6(0/0/1)    6(0/1/1)
     rox?	Dn                      10    0     12(0/0/0)   12(0/1/0)
FEA  rox?	Mem (by one)            0     0      4(0/0/0)    4(0/1/0)
     btst	#(data),Dn              4     0      4(0/0/0)    4(0/1/0)
     btst	Dn,Dn                   4     0      4(0/0/0)    4(0/1/0)
FIEA btst	#(data),Mem             0     0      4(0/0/0)    4(0/1/0)
FEA  btst	Dn,Mem                  0     0      4(0/0/0)    4(0/1/0)
     bchg	#(data),Dn              6     0      6(0/0/0)    6(0/1/0)
     bchg	Dn,Dn                   6     0      6(0/0/0)    6(0/1/0)
FIEA bchg	#(data),Mem             0     0      6(0/0/1)    6(0/1/1)
FEA  bchg	Dn,Mem                  0     0      6(0/0/1)    6(0/1/1)
     bclr	#(data),Dn              6     0      6(0/0/0)    6(0/1/0)
     bclr	Dn,Dn                   6     0      6(0/0/0)    6(0/1/0)
FIEA bclr	#(data),Mem             0     0      6(0/0/1)    6(0/1/1)
FEA  bclr	Dn,Mem                  0     0      6(0/0/1)    6(0/1/1)
     bset	#(data),Dn              6     0      6(0/0/0)    6(0/1/0)
     bset	Dn,Dn                   6     0      6(0/0/0)    6(0/1/0)
FIEA bset	#(data),Mem             0     0      6(0/0/1)    6(0/1/1)
CIEA bset	Dn,Mem                  0     0      6(0/0/1)    6(0/1/1)
     bftst	Dn                      8     0      8(0/0/0)    8(0/1/0)
CIEA bftst	Mem (< 5 bytes)         6     0     10(1/0/0)   10(1/1/0)
CIEA bftst	Mem (> 5 bytes)         6     0     14(2/0/0)   14(2/1/0)
     bfchg	Dn                      14    0     14(0/0/0)   14(0/1/0)
CIEA bfchg	Mem (< 5 bytes)         6     0     14(1/0/1)   14(1/1/1)
CIEA bfchg	Mem (> 5 bytes)         6     0     22(2/0/2)   22(2/1/2)
     bfclr	Dn                      14    0     14(0/0/0)   14(0/1/0)
CIEA bfclr	Mem (< 5 bytes)         6     0     14(1/0/1)   14(1/1/1)
CIEA bfclr	Mem (> 5 bytes)         6     0     22(2/0/2)   22(2/1/2)
     bfset	Dn                      14    0     14(0/0/0)   14(0/1/0)
CIEA bfset	Mem (< 5 bytes)         6     0     14(1/0/1)   14(1/1/1)
CIEA bfset	Mem (> 5 bytes)         6     0     22(2/0/2)   22(2/1/2)
     bfexts	Dn                      10    0     10(0/0/0)   10(0/1/0)
CIEA bfexts Mem (< 5 bytes)         6     0     12(1/0/0)   12(1/1/0)
CIEA bfexts	Mem (> 5 bytes)         6     0     18(2/0/0)   18(2/1/0)
     bfextu	Dn                      10    0     10(0/0/0)   10(0/1/0)
CIEA bfextu Mem (< 5 bytes)         6     0     12(1/0/0)   12(1/1/0)
CIEA bfextu	Mem (> 5 bytes)         6     0     18(2/0/0)   18(2/1/0)
     bfins	Dn                      12    0     12(0/0/0)   12(0/1/0)
CIEA bfins	Mem (< 5 bytes)         6     0     12(1/0/1)   12(1/1/1)
CIEA bfins	Mem (> 5 bytes)         6     0     18(2/0/2)   18(2/1/2)
     bfffo	Dn                      20    0     20(0/0/0)   20(0/1/0)
CIEA bfffo	Mem (< 5 bytes)         6     0     22(1/0/0)   22(1/1/0)
CIEA bfffo	Mem (> 5 bytes)         6     0     28(2/0/0)   28(2/1/0)
     bcc	(taken)                 6     0      6(0/0/0)    8(0/2/0)
     bcc.b	(not taken)             4     0      4(0/0/0)    4(0/1/0)
     bcc.w	(not taken)             6     0      6(0/0/0)    6(0/1/0)
     bcc.l	(not taken)             6     0      6(0/0/0)    8(0/2/0)
     dbcc	(false,cnt not expired) 6     0      6(0/0/0)    8(0/2/0)
     dbcc	(false,but cnt expired) 10    0     10(0/0/0)   13(0/3/0)
     dbcc	(true)                  6     0      6(0/0/0)    8(0/1/0)
     andi to sr                     4     0     12(0/0/0)   14(0/2/0)
     eori to sr                     4     0     12(0/0/0)   14(0/2/0)
     ori to sr                      4     0     12(0/0/0)   14(0/2/0)
     andi to ccr                    4     0     12(0/0/0)   14(0/2/0)
     eori to ccr                    4     0     12(0/0/0)   14(0/2/0)
     ori to ccr                     4     0     12(0/0/0)   14(0/2/0)
     bsr                            2     0      6(0/0/1)    9(0/2/1)
CIEA cas (succesful compare)        1     0     13(1/0/1)   13(1/1/1)
CIEA cas (unsuccesful compare)      1     0     11(1/0/0)   11(1/1/0)
     cas2 (succesful compare) (max) 2     0     24(2/0/2)   26(2/2/2)
     cas2 (unsuccesful compare)(max)2     0     24(2/0/0)   24(2/2/0)
     chk Dn,Dn (no Exception)       8     0      8(0/0/0)    8(0/1/0)
     chk Dn,Dn (Exception taken)    4     0     28(1/0/4)   30(1/3/4)
     chk EA,Dn (no Exception)       0     0      8(0/0/0)    8(0/1/0)
     chk EA,Dn (Exception taken)max 0     0     28(1/0/4)   30(1/3/4)
FIEA chk2 Mem,Rn (no Except.)max    2     0     18(1/0/0)   18(1/1/0)
FIEA chk2 Mem,Rn (Except.taken)mx   2     0     40(2/0/4)   42(2/3/4)
     JEA jmp                        4     0      4(0/0/0)    6(0/2/0)
     JEA jsr                        0     0      4(0/0/1)    7(0/2/1)
CEA  lea                            2     0      2(0/0/0)    2(0/1/0)
     link.w                         0     0      4(0/0/1)    5(0/1/1)
     link.l                         2     0      6(0/0/1)   7(0/2/1)
     nop                            0     0      2(0/0/0)    2(0/1/0)
CEA  pea                            0     2      4(0/0/1)    4(0/1/1)
     rtd                            2     0     10(1/0/0)   12(1/2/0)
     rtr                            1     0     12(2/0/0)   14(2/2/0)
     rts                            1     0      9(1/0/0)   11(1/2/0)
     unlk                           0     0      5(1/0/0)    5(1/1/0)
     bkpt                           1     0      9(1/0/0)    9(1/0/0)
     Interrupt (I-Stack)            0     0     23(2/0/4)   24(2/2/4)
     Interrupt (M-Stack)            0     0     33(2/0/8)   34(2/2/8)
     reset                          0     0     518(0/0/0)  518(0/1/0)
     stop                           0     0      8(0/0/0)    8(0/2/0)
     trace                          0     0     22(1/0/5)   24(1/2/5)
     trap #n                        0     0     18(1/0/5)   20(1/2/4)
     Illegal Instruction            0     0     18(1/0/5)   20(1/2/4)
     A-Line trap                    0     0     18(1/0/5)   20(1/2/4)
     F-Line trap                    0     0     18(1/0/5)   20(1/2/4)
     Priviledge Violation           0     0     18(1/0/5)   20(1/2/4)
     trapcc (Trap)                  2     0     22(1/0/5)   24(1/2/5)
     trapcc (No trap)               4     0      4(0/0/0)    4(0/1/0)
     trapcc.w (Trap)                5     0     24(1/0/5)   26(1/3/5)
     trapcc.w (No trap)             6     0      6(0/0/0)    6(0/1/0)
     trapcc.l (Trap)                6     0     26(1/0/5)   28(1/3/5)
     trapcc.l (No trap)             8     0      8(0/0/0)    8(0/2/0)
     trapv (Trap)                   2     0     22(1/0/5)   24(1/2/5)
     trapv (No trap)                4     0      4(0/0/0)    4(0/1/0)
     Bus Cycle Fault (Short)        0     0     36(1/0/10)  38(1/2/10)
     Bus Cycle Fault (Long)         0     0     62(1/0/24)  64(1/2/24)
     RTE (Normal Four Word)         1     0     18(4/0/0)   20(4/2/0)
     RTE (Six Word)                 1     0     18(4/0/0)   20(4/2/0)
     RTE (Throwaway)                1     0     12(4/0/0)   12(4/0/0)
     RTE (Coprocessor)              1     0     26(7/0/0)   26(7/2/0)
     RTE (Short Fault)              1     0     36(10/0/0)  26(10/2/0)
     RTE (Long Fault)               1     0     76(25/0/0)  76(25/2/0)

Fetch Effective Address (FEA)
                        Head        Tail         I-Cache     No-Cache
 Dn                     -           -            0(0/0/0)    0(0/0/0)
 An                     -           -            0(0/0/0)    0(0/0/0)
 (An)                   1           1            3(1/0/0)    3(1/0/0)
 (An)+                  0           1            3(1/0/0)    3(1/0/0)
 -(An)                  2           2            4(1/0/0)    4(1/0/0)
 (d16,An)               2           2            4(1/0/0)    4(1/1/0)
 (d16,PC)               2           2            4(1/0/0)    4(1/1/0)
 (xxx).w                2           2            4(1/0/0)    4(1/1/0)
 (xxx).l                1           0            4(1/0/0)    5(1/1/0)
 #(data).b              2           0            2(0/0/0)    2(0/1/0)
 #(data).w              2           0            2(0/0/0)    2(0/1/0)
 #(data).l              4           0            4(0/0/0)    4(0/1/0)
 (d16,An)               2           0            6(1/0/0)    7(1/1/0)
 (d16,PC)               2           0            6(1/0/0)    7(1/1/0)
 (d16,An,Xn)            4           0            6(1/0/0)    7(1/1/0)
 (d16,PC,Xn)            4           0            6(1/0/0)    7(1/1/0)
 ([d16,An])             2           0           10(2/0/0)   10(2/1/0)
 ([d16,PC])             2           0           10(2/0/0)   10(2/1/0)
 ([d16,An],Xn)          2           0           10(2/0/0)   10(2/1/0)
 ([d16,PC],Xn)          2           0           10(2/0/0)   10(2/1/0)
 ([d16,An],d16)         2           0           12(2/0/0)   13(2/2/0)
 ([d16,PC],d16)         2           0           12(2/0/0)   13(2/2/0)
 ([d16,An],Xn,d16)      2           0           12(2/0/0)   13(2/2/0)
 ([d16,PC],Xn,d16)      2           0           12(2/0/0)   13(2/2/0)
 ([d16,An],d32)         2           0           12(2/0/0)   14(2/2/0)
 ([d16,PC],d32)         2           0           12(2/0/0)   14(2/2/0)
 ([d16,An],Xn,d32)      2           0           12(2/0/0)   14(2/2/0)
 ([d16,PC],Xn,d32)      2           0           12(2/0/0)   14(2/2/0)
 (B)                    4           0            6(1/0/0)    7(1/1/0)
 (d16,B)                4           0            8(1/0/0)   10(1/1/0)
 (d32,B)                4           0           12(1/0/0)   13(1/2/0)
 ([B])                  4           0           10(2/0/0)   10(2/1/0)
 ([B].l)                4           0           10(2/0/0)   10(2/1/0)
 ([B],d16)              4           0           12(2/0/0)   13(2/1/0)
 ([B].l,d16)            4           0           12(2/0/0)   13(2/1/0)
 ([B],d32)              4           0           12(2/0/0)   14(2/2/0)
 ([B].l,d32)            4           0           12(2/0/0)   14(2/2/0)
 ([d16,B])              4           0           12(2/0/0)   13(2/1/0)
 ([d16,B].l)            4           0           12(2/0/0)   13(2/1/0)
 ([d16,B],d16)          4           0           14(2/0/0)   16(2/2/0)
 ([d16,B].l,d16)        4           0           14(2/0/0)   16(2/2/0)
 ([d16,B],d32)          4           0           14(2/0/0)   17(2/2/0)
 ([d16,B].l,d32)        4           0           14(2/0/0)   17(2/2/0)
 ([d32,B])              4           0           16(2/0/0)   17(2/2/0)
 ([d32,B].l)            4           0           16(2/0/0)   17(2/2/0)
 ([d32,B],d16)          4           0           18(2/0/0)   20(2/2/0)
 ([d32,B].l,d16)        4           0           18(2/0/0)   20(2/2/0)
 ([d32,B],d32)          4           0           18(2/0/0)   21(2/3/0)
 ([d32,B].l,d32)        4           0           18(2/0/0)   21(2/3/0)
           
Fetch Immediate Effective Address (FIEA)
                                    Head  Tail   I-Cache     No-Cache
 #(data).w,Dn                       2+op  0      2(0/0/0)    2(0/1/0)
 #(data).l,Dn                       4+op  0      4(0/0/0)    4(0/1/0)
 #(data).w,(An)                     1     1      3(1/0/0)    4(1/1/0)
 #(data).l,(An)                     1     0      4(1/0/0)    5(1/1/0)
 #(data).w,(An)+                    2     1      5(1/0/0)    5(1/1/0)
 #(data).l,(An)+                    4     1      7(1/0/0)    7(1/1/0)
 #(data).w,-(An)                    2     2      4(1/0/0)    4(1/1/0)
 #(data).l,-(An)                    2     0      4(1/0/0)    5(1/1/0)
 #(data).w,(d16,An)                 2     0      4(1/0/0)    5(1/1/0)
 #(data).l,(d16,An)                 4     0      6(1/0/0)    8(1/2/0)
 #(data).w,(xxx).w                  4     2      6(1/0/0)    6(1/1/0)
 #(data).l,(xxx).w                  6     2      8(1/0/0)    8(1/2/0)
 #(data).w,(xxx).l                  3     0      6(1/0/0)    7(1/2/0)
 #(data).l,(xxx).l                  5     0      8(1/0/0)    9(1/2/0)
 #(data).w,#(data).l                6+op  0      6(0/0/0)    6(0/2/0)
 #(data).w,(d8,An,Xn)               6     2      8(1/0/0)    8(1/2/0)
 #(data).w,(d8,PC,Xn)               6     2      8(1/0/0)    8(1/2/0)
 #(data).l,(d8,An,Xn)               8     2     10(1/0/0)   10(1/2/0)
 #(data).l,(d8,PC,Xn)               8     2     10(1/0/0)   10(1/2/0)
 #(data).w,(d16,An)                 4     0      8(1/0/0)    9(1/2/0)
 #(data).w,(d16,PC)                 4     0      8(1/0/0)    9(1/2/0)
 #(data).l,(d16,An)                 6     0     10(1/0/0)   11(1/2/0)
 #(data).l,(d16,PC)                 6     0     10(1/0/0)   11(1/2/0)
 #(data).w,(d16,An,Xn)              6     0      8(1/0/0)    9(1/2/0)
 #(data).w,(d16,PC,Xn)              6     0      8(1/0/0)    9(1/2/0)
 #(data).l,(d16,An,Xn)              8     0     10(1/0/0)   11(1/2/0)
 #(data).l,(d16,PC,Xn)              8     0     10(1/0/0)   11(1/2/0)
 #(data).w,([d16,An])               4     0     12(2/0/0)   14(2/2/0)
 #(data).w,([d16,PC])               4     0     12(2/0/0)   14(2/2/0)
 #(data).l,([d16,An])               6     0     14(2/0/0)   14(2/2/0)
 #(data).l,([d16,PC])               6     0     14(2/0/0)   14(2/2/0)
 #(data).w,([d16,An],Xn)            4     0     12(2/0/0)   12(2/2/0)
 #(data).w,([d16,PC],Xn)            4     0     12(2/0/0)   12(2/2/0)
 #(data).l,([d16,An],Xn)            6     0     14(2/0/0)   14(2/2/0)
 #(data).l,([d16,PC],Xn)            6     0     14(2/0/0)   14(2/2/0)
 #(data).w,([d16,An],d16)           4     0     14(2/0/0)   15(2/2/0)
 #(data).w,([d16,PC],d16)           4     0     14(2/0/0)   15(2/2/0)
 #(data).l,([d16,An],d16)           6     0     16(2/0/0)   17(2/3/0)
 #(data).l,([d16,PC],d16)           6     0     16(2/0/0)   17(2/3/0)
 #(data).w,([d16,An],Xn,d16)        4     0     14(2/0/0)   15(2/2/0)
 #(data).w,([d16,PC],Xn,d16)        4     0     14(2/0/0)   15(2/2/0)
 #(data).l,([d16,An],Xn,d16)        6     0     16(2/0/0)   17(2/3/0)
 #(data).l,([d16,PC],Xn,d16)        6     0     16(2/0/0)   17(2/3/0)
 #(data).w,([d16,An],d32)           4     0     14(2/0/0)   16(2/3/0)
 #(data).w,([d16,PC],d32)           4     0     14(2/0/0)   16(2/3/0)
 #(data).l,([d16,An],d32)           6     0     16(2/0/0)   18(2/3/0)
 #(data).l,([d16,PC],d32)           6     0     16(2/0/0)   18(2/3/0)
 #(data).w,([d16,An],Xn,d32)        4     0     14(2/0/0)   16(2/3/0)
 #(data).w,([d16,PC],Xn,d32)        4     0     14(2/0/0)   16(2/3/0)
 #(data).l,([d16,An],Xn,d32)        6     0     16(2/0/0)   18(2/3/0)
 #(data).l,([d16,PC],Xn,d32)        6     0     16(2/0/0)   18(2/3/0)
 #(data).w,(B)                      6     0      8(1/0/0)    9(1/1/0)
 #(data).l,(B)                      8     0     10(1/0/0)   11(1/2/0)
 #(data).w,(d16,B)                  6     0     10(1/0/0)   12(1/2/0)
 #(data).l,(d16,B)                  8     0     12(1/0/0)   14(1/2/0)
 #(data).w,(d32,B)                  10    0     14(1/0/0)   16(1/2/0)
 #(data).l,(d32,B)                  12    0     16(1/0/0)   18(1/3/0)
 #(data).w,([B])                    6     0     12(2/0/0)   12(2/1/0)
 #(data).l,([B])                    8     0     14(2/0/0)   14(2/2/0)
 #(data).w,([B].l)                  6     0     12(2/0/0)   12(2/1/0)
 #(data).l,([B].l)                  8     0     14(2/0/0)   14(2/2/0)
 #(data).w,([B],d16)                6     0     14(2/0/0)   15(2/2/0)
 #(data).l,([B],d16)                8     0     16(2/0/0)   17(2/2/0)
 #(data).w,([B].l,d16)              6     0     14(2/0/0)   15(2/2/0)
 #(data).l,([B].l,d16)              8     0     16(2/0/0)   17(2/2/0)
 #(data).w,([B],d32)                6     0     14(2/0/0)   16(2/2/0)
 #(data).l,([B],d32)                8     0     16(2/0/0)   18(2/3/0)
 #(data).w,([B].l,d32)              6     0     14(2/0/0)   16(2/2/0)
 #(data).l,([B].l,d32)              8     0     16(2/0/0)   18(2/3/0)
 #(data).w,([d16,B])                6     0     14(2/0/0)   15(2/2/0)
 #(data).l,([d16,B])                8     0     16(2/0/0)   17(2/2/0)
 #(data).w,([d16,B].l)              6     0     14(2/0/0)   15(2/2/0)
 #(data).l,([d16,B].l)              8     0     16(2/0/0)   17(2/2/0)
 #(data).w,([d16,B],d16)            6     0     16(2/0/0)   18(2/2/0)
 #(data).l,([d16,B],d16)            8     0     18(2/0/0)   20(2/3/0)
 #(data).w,([d16,B].l,d16)          6     0     16(2/0/0)   18(2/2/0)
 #(data).l,([d16,B].l,d16)          8     0     18(2/0/0)   20(2/3/0)
 #(data).w,([d16,B],d32)            6     0     16(2/0/0)   19(2/3/0)
 #(data).l,([d16,B],d32)            8     0     18(2/0/0)   21(2/3/0)
 #(data).w,([d16,B].l,d32)          6     0     16(2/0/0)   19(2/3/0)
 #(data).l,([d16,B].l,d32)          8     0     18(2/0/0)   21(2/3/0)
 #(data).w,([d32,B])                6     0     18(2/0/0)   19(2/2/0)
 #(data).l,([d32,B])                8     0     20(2/0/0)   21(2/3/0)
 #(data).w,([d32,B].l)              6     0     18(2/0/0)   19(2/2/0)
 #(data).l,([d32,B].l)              8     0     20(2/0/0)   21(2/3/0)
 #(data).w,([d32,B],d16)            6     0     20(2/0/0)   22(2/3/0)
 #(data).l,([d32,B],d16)            8     0     22(2/0/0)   24(2/3/0)
 #(data).w,([d32,B].l,d16)          6     0     20(2/0/0)   22(2/3/0)
 #(data).l,([d32,B].l,d16)          8     0     22(2/0/0)   24(2/3/0)
 #(data).w,([d32,B],d32)            6     0     20(2/0/0)   23(2/3/0)
 #(data).l,([d32,B],d32)            8     0     22(2/0/0)   25(2/4/0)
 #(data).w,([d32,B].l,d32)          6     0     20(2/0/0)   23(2/3/0)
 #(data).l,([d32,B].l,d32)          8     0     22(2/0/0)   25(2/4/0)


Calculate Effective Address (CEA)
                        Head        Tail         I-Cache     No-Cache
 Dn                     -           -            0(0/0/0)    0(0/0/0)
 An                     -           -            0(0/0/0)    0(0/0/0)
 (An)                   2+op        0            2(0/0/0)    2(0/0/0)
 (An)+                  0           0            2(0/0/0)    2(0/0/0)
 -(An)                  2+op        0            2(0/0/0)    2(0/0/0)
 (d16,An)               2+op        0            2(0/0/0)    2(0/0/0)
 (d16,PC)               2+op        0            2(0/0/0)    2(0/1/0)
 (xxx).w                2+op        0            2(0/0/0)    2(0/1/0)
 (xxx).l                4+op        0            4(0/0/0)    4(0/1/0)
 (d8,An,Xn)             4+op        0            4(0/0/0)    4(0/1/0)
 (d8,PC,Xn)             4+op        0            4(0/0/0)    4(0/1/0)
 (d16,An)               2           0            6(0/0/0)    6(0/1/0)
 (d16,PC)               2           0            6(0/0/0)    6(0/1/0)
 (d16,An,Xn)            6+op        0            6(0/0/0)    6(0/1/0)
 (d16,PC,Xn)            6+op        0            6(0/0/0)    6(0/1/0)
 ([d16,An])             2           0           10(1/0/0)   10(1/1/0)
 ([d16,PC])             2           0           10(1/0/0)   10(1/1/0)
 ([d16,An],Xn)          2           0           10(1/0/0)   10(1/1/0)
 ([d16,PC],Xn)          2           0           10(1/0/0)   10(1/1/0)
 ([d16,An],d16)         2           0           12(1/0/0)   13(1/2/0)
 ([d16,PC],d16)         2           0           12(1/0/0)   13(1/2/0)
 ([d16,An],Xn,d16)      2           0           12(1/0/0)   13(1/2/0)
 ([d16,PC],Xn,d16)      2           0           12(1/0/0)   13(1/2/0)
 ([d16,An],d32)         2           0           12(1/0/0)   13(1/2/0)
 ([d16,PC],d32)         2           0           12(1/0/0)   13(1/2/0)
 ([d16,An],Xn,d32)      2           0           12(1/0/0)   11(1/2/0)
 ([d16,PC],Xn,d32)      2           0           12(1/0/0)   13(1/2/0)
 (B)                    6+op        0            6(0/0/0)    6(0/1/0)
 (d16,B)                4           0            8(0/0/0)    9(0/1/0)
 (d32,B)                4           0           12(0/0/0)   12(0/2/0)
 ([B])                  4           0           10(1/0/0)   10(1/1/0)
 ([B].l)                4           0           10(1/0/0)   10(1/1/0)
 ([B],d16)              4           0           12(1/0/0)   13(1/1/0)
 ([B].l,d16)            4           0           12(1/0/0)   13(1/1/0)
 ([B],d32)              4           0           12(1/0/0)   13(1/2/0)
 ([B].l,d32)            4           0           12(2/0/0)   13(1/2/0)
 ([d16,B])              4           0           12(1/0/0)   13(1/1/0)
 ([d16,B].l)            4           0           12(1/0/0)   13(1/1/0)
 ([d16,B],d16)          4           0           14(1/0/0)   16(1/2/0)
 ([d16,B].l,d16)        4           0           14(1/0/0)   16(1/2/0)
 ([d16,B],d32)          4           0           14(1/0/0)   16(1/2/0)
 ([d16,B].l,d32)        4           0           14(1/0/0)   16(1/2/0)
 ([d32,B])              4           0           16(1/0/0)   17(1/2/0)
 ([d32,B].l)            4           0           16(1/0/0)   17(1/2/0)
 ([d32,B],d16)          4           0           18(1/0/0)   20(1/2/0)
 ([d32,B].l,d16)        4           0           18(1/0/0)   20(1/2/0)
 ([d32,B],d32)          4           0           18(1/0/0)   20(1/3/0)
 ([d32,B].l,d32)        4           0           18(1/0/0)   20(1/3/0)



Calculate Immediate Effective Address (CIEA)
Calculate Immediate Effective Address (CIEA) for WORDS
          (for LONGS add 2 for head and cycle count)

                        Head	Tail         I-Cache    No-Cache
 Dn                     2+op        0            2(0/0/0)    0(0/0/0)
 (An)                   2           0            2(0/0/0)    2(0/0/0)
 (An)+                  2+op        0            4(0/0/0)    2(0/0/0)
 -(An)                  2+op        0            2(0/0/0)    2(0/0/0)
 (d16,An)               4+op        0            4(0/0/0)    2(0/0/0)
 (d16,PC)               4+op        0            4(0/0/0)    2(0/1/0)
 (xxx).w                4+op        0            4(0/0/0)    2(0/1/0)
 (xxx).l                6+op        0            6(0/0/0)    4(0/1/0)
 (d8,An,Xn)             6+op        0            6(0/0/0)    4(0/1/0)
 (d8,PC,Xn)             6+op        0            6(0/0/0)    4(0/1/0)
 (d16,An)               4           0            8(0/0/0)    6(0/1/0)
 (d16,PC)               4           0            8(0/0/0)    6(0/1/0)
 (d16,An,Xn             4+op        0            8(0/0/0)    6(0/1/0)
 (d16,PC,Xn             4+op        0            8(0/0/0)    6(0/1/0)
 ([d16,An])             4           0           12(1/0/0)    6(1/1/0)
 ([d16,PC])             4           0           12(1/0/0)    6(1/1/0)
 ([d16,An],Xn)          8+op        0           10(2/0/0)   10(2/1/0)
 ([d16,PC],Xn)          8+op        0            0(2/0/0)   10(2/1/0)
 ([d16,An],d16)         4           0            2(2/0/0)   13(2/2/0)
 ([d16,PC],d16)         4           0            2(2/0/0)   13(2/2/0)
 ([d16,An],Xn,d16)      4           0            2(2/0/0)   13(2/2/0)
 ([d16,PC],Xn,d16)      4           0            2(2/0/0)   13(2/2/0)
 ([d16,An],d32)         4           0            2(2/0/0)   14(2/2/0)
 ([d16,PC],d32)         4           0            2(2/0/0)   14(2/2/0)
 ([d16,An],Xn,d32)      4           0            2(2/0/0)   14(2/2/0)
 ([d16,PC],Xn,d32)      4           0            2(2/0/0)   14(2/2/0)
 (B)                    8+op        0            6(1/0/0)    7(1/1/0)
 (d16,B)                6           0            8(1/0/0)   10(1/1/0)
 (d32,B)                6           0           12(1/0/0)   13(1/2/0)
 ([B])                  6           0           12(1/0/0)   12(1/1/0)
 ([B].l)                6           0           12(1/0/0)   12(1/1/0)
 ([B],d16)              6           0           14(1/0/0)   15(1/2/0)
 ([B].l,d16)            6           0           14(1/0/0)   15(1/2/0)
 ([B],d32)              6           0           14(1/0/0)   15(1/2/0)
 ([B].l,d32)            6           0           14(1/0/0)   15(1/2/0)
 ([d16,B])              6           0           14(1/0/0)   15(1/2/0)
 ([d16,B].l)            6           0           14(1/0/0)   15(1/2/0)
 ([d16,B],d16)          6           0           16(1/0/0)   18(1/2/0)
 ([d16,B].l,d16)        6           0           16(1/0/0)   18(1/2/0)
 ([d16,B],d32)          6           0           16(1/0/0)   18(1/2/0)
 ([d16,B].l,d32)        6           0           16(1/0/0)   18(1/2/0)
 ([d32,B])              6           0           18(1/0/0)   19(1/2/0)
 ([d32,B].l)            6           0           18(2/0/0)   19(2/2/0)
 ([d32,B],d16)          6           0           20(1/0/0)   22(1/3/0)
 ([d32,B].l,d16)        6           0           20(1/0/0)   22(1/3/0)
 ([d32,B],d32)          6           0           22(1/0/0)   24(1/3/0)
 ([d32,B].l,d32)        6           0           22(1/0/0)   24(1/3/0)


Jump Effective Address (JEA)
                     Head   Tail    I-Cache       No-Cache
 (An)                2+op   0       2(0/0/0)      2(0/0/0)
 (d16,An)            4+op   0       4(0/0/0)      4(0/0/0)
 $00.w               2+op   0       2(0/0/0)      2(0/0/0)
 $00.l               2+op   0       2(0/0/0)      2(0/0/0)
 (d8,An,Xn)          6+op   0       6(0/0/0)      6(0/0/0)
 (d8,An,PC)          6+op   0       6(0/0/0)      6(0/0/0)
 (d16,An)            2      0       6(0/0/0)      6(0/0/0)
 (d16,PC)            2      0       6(0/0/0)      6(0/0/0)
 (d16,An,Xn)         6+op   0       6(0/0/0)      6(0/0/0)
 (d16,PC,Xn)         6+op   0       6(0/0/0)      6(0/0/0)
 ([d16,An])          2      0      10(1/0/0)     10(1/1/0)
 ([d16,PC])          2      0      10(1/0/0)     10(1/1/0)
 ([d16,An],Xn)       2      0      10(1/0/0)     10(1/1/0)
 ([d16,PC],Xn)       2      0      10(1/0/0)     10(1/1/0)
 ([d16,An],d16)      2      0      12(1/0/0)     12(1/2/0)
 ([d16,PC],d16)      2      0      12(1/0/0)     12(1/2/0)
 ([d16,An],Xn,d16)   2      0      12(1/0/0)     12(1/2/0)
 ([d16,PC],Xn,d16)   2      0      12(1/0/0)     12(1/2/0)
 ([d16,An],d32)      2      0      12(1/0/0)     12(1/2/0)
 ([d16,PC],d32)      2      0      12(1/0/0)     12(1/2/0)
 ([d16,An],Xn,d32)   2      0      12(1/0/0)     12(1/2/0)
 ([d16,PC],Xn,d32)   2      0      12(1/0/0)     12(1/2/0)
 (B)                 6+op   0       6(0/0/0)      6(0/0/0)
 (d16,B)             4      0       8(0/0/0)      9(0/1/0)
 (d32,B)             4      0      12(0/0/0)     13(0/1/0)
 ([B])               4      0      10(1/0/0)     10(1/1/0)
 ([B].l)             4      0      10(1/0/0)     10(1/1/0)
 ([B],d16)           4      0      12(1/0/0)     12(1/1/0)
 ([B].l,d16)         4      0      12(1/0/0)     12(1/1/0)
 ([B],d32)           4      0      12(1/0/0)     12(1/1/0)
 ([B].l,d32)         4      0      12(1/0/0)     12(1/1/0)
 ([d16,B])           4      0      12(1/0/0)     13(1/1/0)
 ([d16,B].l)         4      0      12(1/0/0)     13(1/1/0)
 ([d16,B],d16)       4      0      14(1/0/0)     15(1/1/0)
 ([d16,B].l,d16)     4      0      14(1/0/0)     15(1/1/0)
 ([d16,B],d32)       4      0      14(1/0/0)     15(1/1/0)
 ([d16,B].l,d32)     4      0      14(1/0/0)     15(1/1/0)
 ([d32,B])           4      0      16(1/0/0)     17(1/2/0)
 ([d32,B].l)         4      0      16(1/0/0)     17(1/2/0)
 ([d32,B],d16)       4      0      18(1/0/0)     19(1/2/0)
 ([d32,B].l,d16)     4      0      18(1/0/0)     19(1/2/0)
 ([d32,B],d32)       4      0      18(1/0/0)     19(1/2/0)
 ([d32,B].l,d32)     4      0      18(1/0/0)     19(1/2/0)
+--------------------------------------------------------------------------+
|	    Optimizations
+--------------------------------------------------------------------------+

Clr.l	-(a0)	is 25% faster than
Clr.l	(a0)+

 move.l (a0,d0.l)	is faster than
 move.l (a0,d0.w)	
		same with adda.w <-> adda.l etc.

 move.b d0,-(a7)	will decrease a7 with 2!

Never use those silly #xx,([a0]) new modes, they are slower than
 move.l (a0),a0
 move.l #xx,(a0)
..unless you have no extra spare registers, but... that's rare.


time optimization on the Falcon is more like sparing BUS than CPU.
The st-ram is just too slow..... Adjust your writes to st-ram
Adjusting memory reads will not speed up, unless you get rid of a
whole instruction :).

The interrupts are exceedingly slow.  A simple movem*2  Trap and RTE
will take an enormous amount of cycles.

 movem.l all,-(sp)
 movem.l (sp)+,all
 rte

will take about 80 Cycles... ok, hehe...why use all regs.... ;-)
                                                                                                                                                                                                                        
                