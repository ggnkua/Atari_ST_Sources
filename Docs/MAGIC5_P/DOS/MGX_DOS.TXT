Beschreibung des DOS-Kernels von Mag!X V3.00/V4.xx
##################################################

Andreas Kromke
Hannover, den 2.6.96

Formatierung: Tabulatoren alle 5 Spalten


Vorwort zur Version 4.50:
-------------------------

In dieser Version wurden Threads und Signale implementiert. Threads werden
auf AES-Ebene behandelt und sind in THREADS.TXT beschrieben, dort sind
auch Anmerkungen zur Verwendung von Signalen in "multi threaded"-Programmen
enthalten. Zur generellen Beschreibung des Signalkonzepts von MagiC siehe
SIGNALE.TXT.



I Konzepte
==========


Das GEMDOS war bisher der konservativste Teil des Betriebssystems Mag!X. FÅr
Netzwerktreiber muûten praktisch sÑmtliche DOS- Aufrufe einschlieûlich
Pexec() nachgebildet werden, ohne auf einer tieferen Ebene eingreifen zu
kînnen. In Mag!X 1.x (wie in TOS) war das DOS nicht einmal reentrant, da ein
statisch angelegter Stack verwendet wurde.

In MultiTOS/MiNT wird das Problem dermaûen umgangen, daû gewissermaûen Åber
das GEMDOS ein System gelegt wird, das alle hîheren Verwaltungsaufgaben
erledigt, andere Dateisysteme einbinden kann und das GEMDOS nur noch als
"dummen" Dateisystemtreiber verwendet. Vorteil dieses Systems ist seine groûe
FlexibilitÑt und Erweiterbarkeit, ein entscheidender Nachteil aber der
gewaltive Overhead bei der Verwendung von "normalen" DOS- Dateisystemen. Dies
sind aber gerade diejenigen, die mit Abstand am hÑufigsten eingesetzt werden.
Hinzu kommt, daû das GEMDOS- Dateisystem mit dem Einsatz von MiNT nichts an
FunktionalitÑt, Komfort oder Geschwindigkeit gewinnen kann, da ja die alten
Routinen nur mit zusÑtzlichem Overhead ablaufen. Die Dateisystemzugriffe
unter MiNT sind also i.a. nicht reentrant, d.h. jeder Diskettenzugriff legt
wie unter MS-Windows den gesamten Rechner lahm.

Eine weitere Eigenschaft von MiNT ist das BemÅhen, die Funktionen, die alle
Dateisysteme gemeinsam haben, in den Kernel zu Åbernehmen. Dabei bleiben zwar
die Dateisystemtreiber (MiNT-XFSs) kompakt, aber durch den Inode-
orientierten Aufbau der Kernelfunktionen wird den Dateitreibern eine unter
UmstÑnden ungÅnstige Struktur aufgezwungen, auûerdem sind i.a. viele Aufrufe
des Dateisystemtreibers fÅr einen DOS- Aufruf notwendig. Schlieûlich ist der
MiNT- Kernel selbst sehr lang, liegt aber zum groûen Teil brach, solange
keine anderen Dateisysteme als DOS eingesetzt werden.

Unter Mag!X wurde ein anderer Ansatz gewÑhlt, der darin bestand, das gesamte
GEMDOS einschlieûlich der Lowlevel- Funktionen fÅr die Sektorpufferung von
Grund auf neu zu schreiben und in insgesamt drei, vier oder fÅnf Schichten zu
zerlegen, in die von auûen (durch nachgeladene Treiber) eingegriffen werden
kann. Als "Nebenwirkung" (dummdeutsch: Nebeneffekt) kam eine Erweiterung der
FunktionalitÑt des DOS- Dateisystems und ein zusÑtzliches Dateisystem auf
dem logischen Laufwerk U: heraus. Das gesamte Konzept einschlieûlich der
Zugriffe auf DOS- Dateisysteme ist reentrant und lÑuft im Hintergrund ab. So
ist es mîglich, auf Laufwerk A: Dateien zu bearbeiten, ohne den Rechner bei
den Diskettenzugriffen merklich zu bremsen. Dabei ist Mag!X bisher nur um
10k lÑnger geworden. Im Vergleich zu MiNT wurden aber mehr Funktionen in die
Dateisystemtreiber ausgelagert, was diese zwar lÑnger macht, aber ihnen die
Mîglichkeit gibt, die Funktionen wesentlich effizienter auszufÅhren. Das
DOS- Dateisystem ist eher noch etwas schneller als langsamer geworden.

Obwohl vollstÑndig in Assembler realisiert, handelt es sich um ein
objektorientiertes System mit virtuellen Funktionen und mehrstufigen
Vererbungen. Ein Dateideskriptor, wie in der Kernel verwendet und das XFS zur
VerfÅgung stellt, ist ein Objekt mit speziellen Daten und Funktionen. Das XFS
realisiert aber ein abgeleitetes Objekt mit weiteren Datenfeldern und
Funktionen. Der DFS- Untertreiber des DOS_XFS schlieûlich muû wiederum
weitere Funktionen und Daten im FD unterbringen und leitet die Klasse weiter
ab. Genauso sieht es mit dem DMD (drive medium descriptor) aus. Der Kernel
benîtigt nur wenige Angaben, die unteren Schichten jedoch wesentlich mehr,
aber immer wieder verschiedene.

Die Schichten im einzelnen:

1. Der DOS-Kernel. Die Funktionen werden in der Datei MGX_DOS.TXT
   beschrieben.
   Der Kernel liegt im Mag!X selbst und wird direkt von den Anwender-
   Programmen Åber trap #1 aufgerufen. Er enthÑlt Module fÅr die
   Speicherverwaltung, fÅr die Prozeûverwaltung und fÅr die Dateiverwaltung.
   Letztere hat die folgenden "Unterschichten".
2. Das Dateisystem (XFS = extended (?) file system). Sein Aufbau ist
   grundsÑtzlich verschieden von einem MiNT- XFS, erfÅllt aber denselben
   Zweck.
   MagiC fÅr Atari enthÑlt nur ein einziges XFS, das sogenannte "DOS_XFS",
   andere kînnen eingebunden werden. MagiC fÅr Macintosh enthÑlt zusÑtzlich
   intern das Mac-XFS.
   Der Aufbau eines XFS ist in der Datei MGX_XFS.TXT beschrieben.
   Speziell dieses Dateisystem greift wieder auf Untertreiber zu:
2a Ein DOS- Dateisystem (DFS) wird vom DOS_XFS aufgerufen. Hier stehen nur
   die Dateifunktionen, wÑhrend die Verzeichnisverwaltung im wesentlichen vom
   DOS_XFS Åbernommen wird.
   Mag!X direkt enthÑlt zwei DFSs. Eines fÅr Laufwerk U:, ein zweites fÅr
   FAT- Dateisysteme, die auf BIOS- Laufwerken liegen.
   Weitere DFSs kînnen eingebunden werden. Der Aufwand fÅr ein DFS ist
   wesentlich geringer als fÅr ein XFS, da viele Funktionen vom DOS_XFS
   bereits ausgefÅhrt werden. Die wesentliche Voraussetzung ist eine DOS-
   konforme Verzeichnisstruktur (mit 32-Byte-EintrÑgen und Dateinamen des
   Formats 8+3).
   Der Aufbau eines DFS ist in der Datei MGX_DFS.TXT beschrieben. Der Kernel
   selbst kommt mit dem DFS nicht in BerÅhrung, sondern steuert ihn
   transparent Åber das DOS_XFS an.
3. Die Dateitreiber (MX_DEV), die im wesentlichen das Lesen und Schreiben
   einer Datei erledigen. Sie werden vom XFS angelegt und verwaltet, aber
   bei Funktionen wie Fread() und Fwrite() direkt vom Kernel aufgerufen,
   wodurch extrem wenig Overhead entsteht.
   Das DOS_XFS enthÑlt tatsÑchlich nur einen Dateitreiber. Dieser erledigt
   z.B. bei Schreibzugriffen die Aktualisierung des Verzeichnisses und ruft
   wieder Untertreiber (MX_DDEV) auf.
3a Der Untertreiber MX_DDEV wird nur vom DOS-Dateitreiber des Dateisystems
   DOS_XFS aufgerufen.
   Der Benutzer kann eigene MX_DDEVs Åber das Verzeichnis U:\DEV\ einbinden.
   Der Aufbau des U-Dateisystems ist in MGX_UDFS.TXT beschrieben, der Aufbau
   der Struktur MX_DDEV in MGX_DFS.TXT. Der Kernel kommt mit den Untertreibern
   nicht in BerÅhrung.



II Die Systemfunktionen
=======================


unsigned WORD Sversion( void )
------------------------------

Liefert die DOS- Versionsnummer im Intel-Format. Der RÅckgabewert in Mag!X ist
tatsÑchlich "long", das Hiword ist 0.
Es wird die Version 0.19 gemeldet, die TOS 1.4 (?) entspricht. Eine sichere
Aussage Åber die Mag!X- Versionnummer erhÑlt man Åber die Mag!X- spezifischen
AES- Variablen. Auûer der DOS- Versionsnummer gibt es noch die TOS-
Versionnummer (ist immer 4.0 fÅr Falcon, 3.0 fÅr TT und 2.0 fÅr ST) und die
AES- Versionsnummer (4.00).

LONG Sconfig( WORD subfn, LONG flags)
-------------------------------------

siehe Handbuch zu Mag!X 2.00.


void Syield( void )
-------------------

Ruft in MagiC direkt appl_yield() auf. Im AUTO- Ordner wird dieser 
Befehl ignoriert.


void Ssync( void )
------------------

Opcode 0x150.
Synchronisiert alle "gemounteten" Dateisysteme.
Existiert ab V4.01 unter MagiC.


LONG Sysconf( WORD n)
---------------------

Liefert unter MiNT globale BeschrÑnkungen und FÑhigkeiten des Systems.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


void Salert( char *mesg )
-------------------------

Schickt unter MiNT eine Fehlermeldung in die Alert-Pipe 
u:\pipe\alert, von wo aus ein Programm etwa ein form_alert() machen 
kann. Was wohl bei einem öberlauf der Pipe unter MiNT passiert ?
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Srealloc( LONG len )
-------------------------

Alloziert fÅr den Bildschirmspeicher einen Bereich der LÑnge <len>. Ist
<len> == -1, wird die maximal mîgliche Grîûe des Bildschirmspeichers
zurÅckgegeben. Der Bildschirmspeicher ist ein Block des ST-RAM, dessen Eigner
der Bootprozeû ist. Die Adresse des Bildschirmspeichers (logbase oder
physbase) wird nicht beeinfluût.


WORD Tgetdate( void )
---------------------

Die Funktion ist unter Mag!X tatsÑchlich "unsigned long". Es wird die Uhrzeit
der DOS- Interrupt- Uhr geliefert, die fÅr das Festlegen der Dateidaten
verwendet wird.


WORD Tsetdate( WORD date )
--------------------------

Die Funktion ist unter Mag!X tatsÑchlich "unsigned long". Es wird sowohl die
Uhrzeit der DOS- Interruptuhr als auch die der Echtzeituhr verÑndert. D.h. im
ST die IKBD- Uhr, im Mega die "Mega"- Uhr und im TT die TT- Uhr.
RÅckgabewert ERROR, falls das Datum ungÅltig ist, sonst E_OK. Im Gegensatz zu
TOS werden Monat oder Tag 0 sowie Datum > 2099 als Fehler erkannt.


WORD Tgettime( void )
--------------------

Die Funktion ist unter Mag!X tatsÑchlich "unsigned long". Es wird die Uhrzeit
der DOS- Interrupt- Uhr geliefert, die fÅr das Festlegen der Dateidaten
verwendet wird.


WORD Tsettime( WORD time )
--------------------------

Die Funktion ist unter Mag!X tatsÑchlich "unsigned long". Es wird sowohl die
Uhrzeit der DOS- Interruptuhr als auch die der Echtzeituhr verÑndert. D.h. im
ST die IKBD- Uhr, im Mega die "Mega"- Uhr und im TT die TT- Uhr.
RÅckgabewert ERROR, falls die Zeit ungÅltig ist, sonst E_OK. Im Gegensatz zu
TOS werden Stunden > 23 als Fehler erkannt.



III Die Speicherverwaltungsfunktionen
=====================================


LONG Maddalt( void *start, ULONG size )
---------------------------------------

FÅgt den Block zur Mag!X- Speicherverwaltung hinzu. Der Block bleibt Eigentum
von DOS und darf nicht zurÅckgefordert werden. Wenn hinzugefÅgte Blîcke nicht
hintereinander liegen, ist die Anzahl der hinzufÅgbaren Blîcke auf ca. 12
beschrÑnkt.
RÅckgabe: ENSMEM    Startadresse oder BlocklÑnge ungerade oder zuviele
                    isolierte Blîcke angemeldet
          E_OK      Block ist angemeldet.


void *Mxalloc( ULONG size, WORD mode )
--------------------------------------

mode == 0: nur ST-RAM
        1: nur alternatives RAM
        2: lieber ST-RAM
        3: lieber alternatives RAM
   Bit 14: dontfree
   andere Bits werden ignoriert

Alternatives RAM heiût "alles auûer ST-RAM", d.h. TT-RAM oder per Maddalt()
angemeldetes RAM.
Ist size == 0L, wird ein Pointer ((void *) 1L) geliefert. Dies aus
KompatibilitÑt mit alten Programmen. Neuere TOS- Versionen melden einen
Fehler, liefern also NULL.
Ist size == -1L, wird die Grîûe des grîûten freien Blocks zurÅckgegeben. Im
Fall mode == 2 oder mode == 3 die LÑnge des grîûeren Blocks.

Achtung:  Unter Mag!X ist wegen stÑndiger Kontextwechsel nicht garantiert, daû
          ein Aufruf Malloc(Malloc(-1L)) funktioniert. Abgesehen davon, daû
          man niemals den ganzen Speicher allozieren sollte!

Unter Mag!X werden seit der Version 1.0 alle Speicherallozierungen
mitprotokolliert. Wenn die mit LIMITMEM vorgegebene BeschrÑnkung
Åberschritten wird, wird ein Nullzeiger zurÅckgegeben. Im Fall size == -1
wird das Minimum von freiem Speicher und noch nicht ausgeschîpfter LIMITMEM-
BeschrÑnkung zurÅckgegeben. Ausnahmem sind Aufrufe des Bildschirm-Managers
(SCRENMGR), der die MenÅs kontrolliert. Dadurch wird sichergestellt, daû auch
per LIMITMEM beschrÑnkte Programme keine Probleme mit dem Redraw bei MenÅs
haben.


void *Malloc( ULONG size )
--------------------------

Dieser Aufruf wird auf Mxalloc() mit den Modi 0 bzw. 3 zurÅckgefÅhrt,
abhÑngig von den Konfigurationsbits im Programmdatei-Header. Die
Konfigurationsbits werden z.Zt. in der Basepage abgelegt.


long Mfree( void *memblock )
----------------------------

Wird ein (von Malloc(0) gelieferter) Zeiger 1L Åbergeben, wird E_OK
geliefert. Bei ungerader Adresse oder ungÅltigem Bereich wird EIMBA
geliefert. Ansonsten wird der Block als frei markiert und die
SpeicherbeschrÑnkungsgrenze (->LIMITMEM) wieder erhîht.
Es findet z.Zt. keine öberprÅfung statt, ob der freizugebende Speicherblock
tatsÑchlich dem aufrufenden Prozeû gehîrt. Dies ist besonders fÅr Debugger
notwendig, die Speicherblîcke ihrer Kindprozesse manipulieren. Vielleicht
wird aber auch irgendwann einmal eine öberprÅfung eingebaut.

Achtung: Mag!X 1.x und 2.x reagieren bei ungerader Adresse mit Bomben.
         Mag!X 1.10, 1.11 und 2.00 kînnen bei ungÅltigen Speicheradressen
         auûerhalb des tatsÑchlich vorhandenen Speichers ebenfalls bomben.


long Mshrink( char *memblock, ULONG size )
------------------------------------------

Dem per M(x)alloc() allozierten Speicherblock, der bei Adresse <size>
beginnt, wird eine neue Grîûe zugewiesen. Im Gegensatz zu TOS kann man auch
Speicherblîcke vergrîûern, solange darÅber ein genÅgend groûer freier Block
liegt (ansonsten wird EGSBF zurÅckgegeben). Voraussetzung ist, daû die
TOS-KompatibilitÑt deaktiviert wurde.
Wird -1L als Grîûe Åbergeben, wird die grîûtmîgliche Grîûe des Speicherblocks
zurÅckgegeben.
Wird 0L als Grîûe Åbergeben, wird der Block freigegeben. TOS (zumindest bis
1.4) reagiert darauf, wie kînnte es anders sein, mit einem totalen
Systemabsturz.
Die LIMITMEM-Speicherbegrenzung wird berÅcksichtigt. Es wird aus denselben
GrÅnden wie bei Mfree nicht ÅberprÅft, ob ein Block dem Aufrufer Åberhaupt
gehîrt.
Eine öberprÅfung auf ungÅltige oder ungerade Adressen findet z.Zt. nicht
statt. Normalerweise wird dieser Aufruf auch nur ein einziges Mal, nÑmlich
nach dem Programmstart erledigt. Ich will aber nicht ausschlieûen, noch
einmal eine öberprÅfung einzubauen.



IV Die Prozeûsteuerung
======================


void Pterm0( void )
-------------------

Wird direkt als Pterm(0) ausgefÅhrt.


void Ptermres( ULONG size, UWORD exitcode )
-------------------------------------------

ZunÑchst wird mit Mshrink( act_pd, size ) der Speicher des laufenden
Programms verkleinert, dann wird Pterm( exitcode ) ausgefÅhrt. Dabei wird das
laufende Programm zwar komplett terminiert und verliert seinen Prozeûstatus,
aber alle allozierten Speicherblîcke (insbesondere Basepage und Environment)
bleiben erhalten.


void Pterm( UWORD exitcode )
----------------------------

Das aufrufende Programm wird terminiert, die Kontrolle wird an den
Parentprozeû zurÅckgegeben, dessen Pexec()-Aufruf erhÑlt als RÅckgabewert den
auf ULONG erweiterten <exitcode>, d.h. $ffffffff heiût "Schwerer Fehler beim
AusfÅhren des Pexec-Befehls, das Programm konnte nicht gestartet werden",
$0000ffff dagegen "Programm ist gelaufen und beendete sich mit Pterm(-1) oder
Ptermres(.., -1)". Siehe auch ->AES/form_xerr().

Nebenbei: Aus historischen GrÅnden enthÑlt der Code fÅr Pterm den vom
          Alcyon-Compiler favorisierten Assembler-Befehl "link a6,#0", weil
          dieser von einigen Debuggern vorausgesetzt wird.

Bevor irgendwelche Maûnahmen ergriffen werden, wird Åber Setexc() der
etv_term-Vektor ermittelt und Åber diesen gesprungen. Anschlieûend wird der
Prozeû ordentlich abgerÑumt, einschlieûlich VDI-Workstations, Informierung
aller XFSs Åber xfs_pterm, Schlieûen aller geîffneten Dateien und aktuellen
Pfade und Lîschen der Prozeûdatei in u:\proc\.


long Pexec(UWORD mode, ...)
---------------------------

Erstellt, lÑdt oder startet Prozesse.
- Ein Problem bei Pexec wurde umgangen. Durch die Unterbrechbarkeit der Folge
  Malloc(-1);Malloc();Pexec();Mshrink() konnten, etwa beim Laden der
  Autostart- Applikationen und Accessories, keine Programme gleichzeitig
  geladen werden.

Modus 0 (EXE_LDEX):
     long Pexec(EXE_LDEX, char *name, char *cmdline, char *env)

     Dieser Modus ist kompatibel zu TOS.
     Die Programmdatei mit dem Pfad <name> wird geladen und gestartet. Es
     wird die Kommandozeile <cmdline> und das Environment <env> Åbergeben.
     Ist env == NULL, wird das Environment des Parent vererbt.
     Ist env == -1L, wird kein Environment angelegt, in der Basepage steht
     dann ein Nullzeiger.
     RÅckgabe 0x0000yyyyL, wenn das Programm geladen und gestartet wurde und
     sich mit Pterm(0xyyyy) beendet hat. Konnte das Programm nicht geladen
     oder nicht gestartet werden, wird ein negatives Langwort geliefert.

Modus 3 (EXE_LD):
     PD *Pexec(EXE_LD, char *name, char *cmdline, char *env)

     Dieser Modus ist kompatibel zu TOS.
     Die Programmdatei mit dem Pfad <name> wird geladen. Es
     wird die Kommandozeile <cmdline> und das Environment <env> Åbergeben.
     Ist env == NULL, wird das Environment des Parent vererbt.
     Ist env == -1L, wird kein Environment angelegt, in der Basepage steht
     dann ein Nullzeiger.
     RÅckgabe: Zeiger auf die Basepage des neuen Prozesses oder negativer
     Fehlercode.

Modus 4 (EXE_EX):
     long Pexec(EXE_EX, void *dummy, PD *basepage)

     Dieser Modus ist kompatibel zu TOS.
     Das Programm, dessen Basepage Åbergeben wird, wird gestartet.
     RÅckgabe 0x0000yyyyL, wenn das Programm gestartet wurde und sich mit
     Pterm(0xyyyy) beendet hat. Konnte das Programm nicht gestartet werden,
     wird ein negatives Langwort geliefert.

Modus 5 (EXE_BASE):
     PD *Pexec(EXE_BASE, void *dummy, char *cmdline, char *env)

     Dieser Modus ist kompatibel zu TOS.
     Ein Prozeû wird erzeugt. Es wird die Kommandozeile <cmdline> und das
     Environment <env> Åbergeben.
     Ist env == NULL, wird das Environment des Parent vererbt.
     Ist env == -1L, wird kein Environment angelegt, in der Basepage steht
     dann ein Nullzeiger.
     RÅckgabe: Zeiger auf die Basepage des neuen Prozesses oder negativer
     Fehlercode.

Modus 6 (EXE_EXFR):
     long Pexec(EXE_EX, void *dummy, PD *basepage)

     Dieser Modus ist kompatibel zu TOS 1.4.
     Wie Modus 4, aber Basepage und Environment gehîren dem neuen Prozeû.

Modus 7 (EXE_XBASE):
     PD *Pexec(EXE_BASE, ULONG prgflags, char *cmdline, char *env)

     Dieser Modus ist kompatibel zu TOS > 3.0 (?).
     Wie Modus 5, aber per <prgflags> kînnen die Programmflags festgelegt
     werden, die festlegen, ob das Programm im TT-RAM lÑuft bzw. TT-RAM
     per Malloc() alloziert usw.

Modus 102 (XEXE_TERM):
     long Pexec(EXE_TERM, void *dummy, PD *basepage)

     Der Prozeû wird gelîscht.

Modus 101 (XEXE_INIT):
     long Pexec(EXE_TERM, void *dummy, PD *child, PD *parent)

     Vererbt Pfad- und Dateihandles

Modus 107 (XEXE_XBASE):
     PD *Pexec(EXE_BASE, ULONG prgflags, char *name, char *env)

     wie Modus 7, aber statt einer Kommandozeile wird der Prozeûname
     Åbergeben.

Modus 106 (XEXE_EXFR):
     wird ab Mag!X 2.00 nicht mehr unterstÅtzt.

Modus 108 (XEXE_EXACC):
     wird intern zum Starten eines ACC verwendet.


WORD Pvfork( void )
-------------------

Erzeugt unter MiNT einen neuen Prozeû, der mit dem alten identisch ist. Der
alte wird angehalten, bis der neue ein anderes Programm lÑdt oder sich
beendet.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Pwait( void )
------------------

Ermittelt unter MiNT angehaltene oder beendete Kind-Prozesse.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Pwaitpid( WORD pid, WORD nohang, LONG *rusage )
----------------------------------------------------

MiNT.
Wartet auf Terminierung eines Kindprozesses. Der RÅckgabewert hat die
Process-ID im Hiword und den RÅckgabewert des Kindes im Loword.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pnice( WORD delta )
------------------------

éndert unter MiNT die PrioritÑt des laufenden Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Pusrval( LONG val )
------------------------

Setzt und ermittelt (val == -1) unter MiNT den "user value", ein Langwort, das
Prozesse an ihre Kinder vererben und das vom Kernel nicht verwendet wird.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pdomain( WORD dom )
------------------------

Mit diesem Aufruf kann ein Prozeû das Verhalten einiger Systemaufrufe
beeinflussen. Wird <dom>=1 Åbergeben, wird der MiNT-Modus aktiviert,
ansonsten ist (per Default) <dom>=0, dies entspricht dem TOS-Modus.
In jedem Fall wird der vorherige Wert zurÅckgegeben, wenn man ihn nicht
Ñndern will, muû man <dom>=-1 Åbergeben.
Andere Werte als 0 oder 1 fÅhren unter MagiC zu ERANGE. MagiC unterstÅtzt
Pdomain() seit der Version vom 5.11.95.
Der Wechsel der "Domain" nach MiNT (dom=1) hat folgende Auswirkungen:

In MiNT ergeben sich Unterschiede bei Fread() und Fwrite() auf Terminals,
das Verhalten wird mit speziellen Fcntl()- Aufrufen festgelegt. Weiterhin
kînnen Fsfirst()/Fsnext() auch Dateinamen zurÅckgeben, die nicht der
Form 8+3 in Groûschrift entsprechen.

In MagiC liefern Fsfirst()/Fsnext() immer Dateinamen im Format 8+3. Eine
andere Vorgehensweise ist auch sinnlos, weil "moderne" Programme statt
dieser Åberholten Funktionen immer D(x)readdir() verwenden; ansonsten
lieûen sich auch keine Dateinamen mit mehr als 12 Zeichen verwenden.

Die entsprechenden Terminal-Funktionen sind in MagiC nicht enthalten, so
daû sich hier auch keine Unterschiede zur TOS-Domain ergeben.

Der Aufruf ist aber dennoch wichtig, weil er das Verhalten des
Dateiauswahldialogs beeinfluût, wenn er mit der TOS-KompatibilitÑtsfunktion
fsel(ex)input() aufgerufen wird. Als maximal mîgliche DateinamenlÑnge wird
in der MiNT-Domain 32 angenommen (inkl. EOS). In der TOS-Domain ist die LÑnge
auf 13 beschrÑnkt, und die Verzeichnisse werden im TOS-KompatibilitÑtsmodus
mit 8+3-Dateinamen gelesen (->Dopendir(DOPEN_COMPAT)). Genauer: Wird der
Aufruf fsel(ex)input() von einem Programm ausgefÅhrt, das sich in der
TOS-Domain befindet, wird xfsl_do() mit dem Modus DOSMODE+SHOW8P3 aufgerufen,
ansonsten mit SHOW8P3.

Auf die "modernen" Dateiauswahlfunktionen (xfsl_xx()) hat die Domain
keinen Einfluû, weil hier das Verhalten und die Limits der Dateiauswahl
explizit festgelegt werden kînnen.


WORD Pfork( void )
------------------

Soll eigentlich eine Kopie des aktuellen Prozesses anlegen (d.h. nicht
denselben Kontext, sondern den gleichen, also eine Kopie), was aber in
MiNT noch nicht so funktioniert. Stattdessen funktioniert Pfork z.Zt. wie
Pvfork().
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Pwait3(WORD flag, LONG *rusage)
------------------------------------

Ermittelt unter MiNT den Exit- Status und die CPU- Belastung
eines terminierten oder beendeten Kind- Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


void Prusage(LONG *r)
---------------------

Ermittelt unter MiNT Informationen Åber CPU- und Speicherbelastung des
aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt, zumindest der belegte Speicher unter
r[4] sollte aber in KÅrze eingebaut werden, vielleicht kann man die anderen
Werte auf 0 setzen.


LONG Psetlimit( WORD lim, LONG value )
--------------------------------------

Setzt oder ermittelt unter MiNT das Limit fÅr Speicher und CPU- Belastung fÅr
den aktuellen Prozeû. Unter MiNT stehen folgende Unterfunktionen zur
VerfÅgung:

lim = 1:	Limitiert die Prozessorzeit. Diese Funktion ist in MagiC nicht
		implementiert.

lim = 2:	Limitiert den Gesamtspeicherbedarf eines Prozesses inklusive
		Programmcode. Ist in MagiC nicht implementiert, da die
		Funktion 3 sinnvoller ist.

lim = 3:	Unter MagiC seit dem 17.9.95 implementiert.
		Mit dieser Funktion wird fÅr den aktuellen Prozeû das Limit fÅr
		allozierten Speicher festgelegt. RÅckgabewert ist immer die vorherige
		Einstellung.
		öbergibt man als <value> z.B. den Wert 8000, so kann der Prozeû auûer
		Basepage+Textsegment+Datensegment+BSS-Segment noch 8000 zusÑtzliche
		Bytes allozieren.
		Ist <value> == 0L, wird das Limit auf "unbegrenzt" festgelegt.
		Ist <value> == -1L, wird nur der aktuelle Wert zurÅckgegeben.

		Bei Pexec() wird dieses Limit vererbt. Das gestartete Programm selbst
		(d.h. der Programmcode) kann dabei beliebig groû sein, begrenzt wird
		nur der Heap, d.h. beim Laden der Speicherblock hinter dem BSS-Segment,
		spÑter die Malloc-Aufrufe.
		Ist ein Programm mit dem MagiC-Dienstprogramm LIMITMEM modifiziert
		worden, hat diese Einstellung Vorrang vor dem Speicherlimit des
		aufrufenden Prozesses.
		Psetlimit wird vom erweiterten shel_write()-Modus unterstÅtzt, damit
		kînnen speicherbeschrÑnkte Applikationen auch parallel gestartet
		werden.

UngÅltige Funktionsnummern und solche, die von MagiC nicht unterstÅtzt werden,
liefern EINVFN.


LONG Pmsg( WORD mode, LONG mboxid, struct msg *msgptr )
-------------------------------------------------------

Sendet oder empfÑngt unter MiNT Nachrichten. Der Mechanismus ist unabhÑngig
von den AES-Funktionen appl_read/write.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Prenice( WORD pid, WORD delta )
------------------------------------

éndert unter MiNT die PrioritÑt eines laufenden Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pumask( WORD mode )
------------------------

éndert unter MiNT den Modus (d.h. die Dateirechte), in dem Fcreate() und
Dcreate() Dateien erstellen.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Psemaphore( WORD mode, LONG id, LONG timeout )
---------------------------------------------------

Setzt und erstellt Semaphoren (->MiNT). Der Parameter <timeout> wird nur fÅr
Modus 2 verwendet und gibt die Timeout-Zeit in ms an, ein Wert von -1
bedeutet, daû beliebig lang gewartet wird.
Semaphoren werden bei Terminierung des besitzenden Prozesses automatisch
freigegeben, nicht jedoch gelîscht.

Modus PSEM_CRGET   (0):
     Eine neue Semaphore mit der <id> wird erstellt und dem Prozeû
     zugeordnet. Hierzu muû interner Speicher angefordert werden, deshalb
     sollte der Aufruf sparsam verwendet werden.
     Die Semaphore wird bei Terminierung des Prozesses zwar freigegeben (wie
     mit PSEM_RELEASE), jedoch nicht entfernt (also kein PSEM_DESTROY).
     Der Parameter <timeout> wird ignoriert.
     Fehlercode EACCDN: Semaphore existiert bereits

Modus PSEM_DESTROY (1):
     Die Semaphore <id> wird gelîscht und der reservierte interne Speicher
     wieder freigegeben. PlausibilitÑtsÅberprÅfungen stellen sicher, daû
     keine System-Semaphoren entfernt werden kînnen.
     Das funktioniert nur, wenn vorher ein PSEM_GET bzw. PSEM_CRGET gemacht
     wurde.
     Fehlercode ERANGE: Semaphore existiert nicht
                EACCDN: Semaphore gehîrt mir nicht

Modus PSEM_GET     (2):
     Die Semaphore <id> wird gesetzt, d.h. fÅr den Prozeû reserviert.
     Fehlercode ERANGE: Semaphore existiert nicht (mehr)
                ERROR:  Semaphore gehîrt mir schon
                EACCDN: Timeout

Modus PSEM_RELEASE (3):
     Die Semaphore <id> wird freigegeben.
     Fehlercode ERANGE: Semaphore existiert nicht
                EACCDN: Semaphore gehîrt mir nicht.



V Funktionen fÅr die Prozeû-ID
==============================


WORD Pgetpid( void )
--------------------

Gibt die Prozeû-ID des aktuellen Prozesses zurÅck. Es gibt keinen Fehlerfall,
die Prozeû-ID ist immer gÅltig. Die Prozeû-ID ist der Dateityp, unter dem der
aktuelle Prozeû in u:\proc gefÅhrt wird. D.h. hat der aktuelle Prozeû die ID
5, entspricht die zugehîrige Datei dem Muster "u:\proc\*.005".


LONG Pgetppid( void )
---------------------

Gibt die Prozeû-ID des Parent des aktuellen Prozesses zurÅck. Im Gegensatz zu
MiNT kann der Fehler auftreten, daû der Prozeû keinen Parent hat, dann wird
-1L zurÅckgegeben.


WORD Pgetpgrp( void )
---------------------

Gibt unter MiNT die aktuelle Prozeûgruppennummer zurÅck.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


LONG Psetpgrp( WORD pid, WORD newgrp )
--------------------------------------

Setzt unter MiNT die Prozeûgruppennummer des Prozesses <pid>.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pgetuid( void )
--------------------

Ermittelt unter MiNT die User-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Psetuid( WORD uid)
-----------------------

éndert unter MiNT die User-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pgetgid( void )
--------------------

Ermittelt unter MiNT die Group-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Psetgid( WORD uid)
-----------------------

éndert unter MiNT die Group-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pgeteuid( void )
--------------------

Ermittelt unter MiNT die effektive User-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.


WORD Pgetegid( void )
--------------------

Ermittelt unter MiNT die effektive Group-ID des aktuellen Prozesses.
Wird z.Zt. von Mag!X nicht unterstÅtzt.



VI Signal-Funktionen
====================


WORD Pkill(WORD pid, WORD sig)
------------------------------

Die Funktion sendet das Signal sig an einen oder mehrere Prozesse.
Der Parameter <pid> bedeutet:

	> 0	Prozeû mit der angegebenen pid
	= 0  alle Prozesse der Prozeûgruppe des Aufrufers (inkl.)
	< 0	an alle Prozesse mit der Gruppennummer (-pid).

Das Signal SIGNULL kann dazu verwendet werden, die GÅltigkeit des Parameters
<pid> zu testen; es ist nicht tatsÑchlich ein Signal.

RÅckgabewerte:

	EFILNF: falls pid > 0 und der angegebene Prozeû nicht mehr
             existiert bzw. falls pid < 0 und die angegebene
             Prozeûgruppe keine Mitglieder mehr besitzt.

	EACCDN: falls pid > 0, und der sendende Prozeû keine euid
             von 0 besitzt und auûerdem die UID des empfangenden
             von der des sendenden Prozesses abweicht.

	ERANGE: sig ist kein gÅltiges Signal (z.B. < 0 oder > 30).

In MagiC 4.5 existiert wegen der einfacheren Prozeûsteuerung nur die erste
Version von Pkill, d.h. es kann nur eine pid > 0 angegeben werden. EACCDN
kann bisher nicht geliefert werden, da Prozesse bisher keine UserID kennen.


LONG Psignal(WORD sig, LONG handler)
------------------------------------

Wird unter MagiC zurÅckgefÅhrt auf

	Psigaction(sig, {handler,0L,0}, &oact);
	return(oact.handler);

D.h. im Gegensatz zu Psigaction() werden Extramaske und Flags einfach 
auf Null gesetzt.
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Psigblock( LONG mask )
---------------------------

<mask> gibt als Bitmaske an, welche Signale zusÑtzlich blockiert 
werden (d.h. neumask = altmask OR mask); der alte Wert wird 
zurÅckgegeben. Die nicht maskierbaren Signale SIGKILL, SIGSTOP und 
SIGCONT werden automatisch aus der Signalmaske ausgefiltert.
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Psigsetmask( LONG mask )
-----------------------------

<mask> gibt als Bitmaske an, welche Signale blockiert werden (d.h. 
neumask = mask); der alte Wert wird zurÅckgegeben. Die nicht 
maskierbaren Signale SIGKILL, SIGSTOP und SIGCONT werden automatisch 
aus der Signalmaske ausgefiltert.
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Psigreturn( void )
-----------------------

Siehe ->SIGNALE.TXT.
Wird innerhalb einer Signalbehandlung benutzt, um diese 
abzuschlieûen, um per "longjump" in das Hauptprogramm zurÅckzukehren.
FÅhrt bei MiNT zum Systemabsturz, zumindest wenn in Verbindung mit 
AES verwendet.
In MagiC wird der Thread der aktiven Signalbehandlung zum Main-Thread 
des Prozesses und wird anschlieûend entfernt. Alle anderen 
Signalbehandlungen werden ebenfalls entfernt (bei Verschachtelung). 
Die gesperrten Semaphoren des Main-Thread werden freigegeben. Der 
Supervisor-Stack des Main-Thread wird auf den Wert bei Prozeûstart 
zurÅckgesetzt.
In MiNT ist diese Funktion "void". In MagiC wird EACCDN geliefert, 
falls der Aufrufer keine Signalbehandlungsroutine ist, sonst E_OK.
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Talarm( LONG time )
------------------------

Initiiert in MiNT einen Alarm, der den aktuellen Prozeû in <time> Sekunden
terminiert, wenn das Signal SIGALRM nicht abgefangen wird.
Wird z.Zt. von Mag!X noch nicht unterstÅtzt.


void Pause( void )
------------------

Wie Psigpause(), aber die Signalmaske wird nicht verÑndert. Damit ist 
diese Funktion im Gegensatz zu Psigpause() MT-safe.
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Psigpending( void )
------------------------

Ermittelt die Bitmaske der anliegenden (blockierten) Signale.
Wird von MagiC ab V4.50 unterstÅtzt.


void Psigpause( LONG mask )
---------------------------

Der Prozeû (bzw. in MagiC der Thread) Ñndert die Signalmaske in 
<mask> und legt sich bis zum nÑchsten Signal schlafen. Nach 
Abarbeitung des Signalhandlers wird der Prozeû (in MagiC: alle 
wartenden Threads) wieder aufgeweckt und die Signalmaske restauriert.
Wenn mehrere Threads gleichzeitig Psigpause() machen, kann es 
Probleme geben, weil die Signalmaske prozeûglobal ist (->SIGNALE.TXT).
Wird von MagiC ab V4.50 unterstÅtzt.


LONG Psigaction( WORD sig, struct sigaction *sigact, struct sigaction *oact)
----------------------------------------------------------------------------

Siehe auch ->SIGNALE.TXT.
Die Funktion Ñndert das Signalverhalten fÅr Signal <sig> (wenn 
<sigact> != NULL) und fragt optional das alte Verhalten ab (wenn 
<oact> != NULL).
Eine <sigaction>-Struktur hat folgenden Aufbau:

		typedef struct
		{
		        void    cdecl (*sa_handler)( LONG sig );
		        LONG    sa_mask;
		        WORD    sa_flags;
		} SIGACTION;

<sa_handler> ist entweder 0 (Default-Signal-Behandlung durch das System) oder
1 (Signal ignorieren), sonst die Adresse einer Signalbehandlungsroutine. Diese
wird im User-Modus ausgefÅhrt, bekommt auf dem Stack als LONG die 
Signalnummer. Der Signalhandler wird normalerweise mit dem Ende der 
Prozedur (mit rts) beendet, alternativ kann er mit Psigreturn() und 
anschlieûendem longjmp beendet werden. Im letzten Fall werden ALLE 
laufenden Signalbehandlungen abgebrochen und das Hauptprogramm nicht 
wieder aufgenommen, sondern der Signalhandler wird zum Hauptprogramm.

<sa_mask> enthÑlt die zusÑtzlich (zu dem gerade bearbeiteten 
Signal) wÑhrend der Signalbehandlung zu maskierenden Signale (d.h. 
dann gilt mask = oldmask+(1<<sig)+sa_mask).

<sa_flags> beeinfluût das Verhalten des Signals:

	SA_NOCLDSTOP (1)
		legt in MiNT fest, daû SIGCHLD nur beim Terminieren, nicht beim
		Anhalten eines Kindprozesses ausgelîst wird.


Ein Aufruf von Psigaction hat die Nebenwirkung, das Signal zu 
demaskieren (d.h. freizugeben). Daher kann ein Prozeû beim 
Abarbeiten eines Signals dieses zurÅcksetzen und es sich erneut 
senden.

RÅckgabewerte:

	EACCDN: Signal kann vom Benutzer nicht abgefangen werden.
			(SIGKILL oder SIGSTOP)
	ERANGE: sig ist kein gÅltiges Signal (< 0 oder > 30).

Wird von MagiC ab V4.50 unterstÅtzt.



V Diskverwaltung
================


LONG Dsetdrv( WORD drv )
------------------------

Setzt <drv> als aktuelles Laufwerk des aktuellen Prozesses. Unter MagiC 3
sind Werte zwischen 0 und 25 zulÑssig, unter TOS nur zwischen 0 und 15. Es
wird keinerlei öberprÅfung vorgenommen, ob das Laufwerk Åberhaupt existiert.
ZurÅckgegeben wird der RÅckgabewert des BIOS- Aufrufs Drvmap().


LONG Dgetdrv( void )
--------------------

Liefert das aktuelle Laufwerk des aktuellen Prozesses. MagiC 3 verwaltet
bis zu 26 Laufwerke (A: bis Z:), wÑhrend Ñltere Versionen sowie alle TOS-
Versionen 16 Laufwerke (A: bis P:) verwalten kînnen.


LONG Dfree( DISKINFO *d, WORD drivecode )
-----------------------------------------

Wenn <drivecode> Null ist, wird der freie Platz des Laufwerks geliefert, auf
dem der aktuelle Pfad des aktuellen Laufwerks liegt. Andernfalls der freie
Platz von Laufwerk <drivecode - 1>.
Beispiel: Ist U: das aktuelle Laufwerk und \A\ der aktuelle Pfad auf U:, wird
im Fall <drivecode>==0 der freie Platz von Laufwerk A: berechnet.
<d> soll normalerweise folgende Daten liefern:

     die Anzahl freier Cluster
     die Gesamtzahl von Clustern
     die Grîûe eines Sektors in Bytes
     die Anzahl der Sektoren pro Cluster


LONG Dlock( WORD mode, WORD drv )
---------------------------------

Sperrt ein BIOS-Laufwerk. Der Zugriff auf dieses Laufwerk Åber GEMDOS wird
vollstÑndig verhindert, der BIOS- Aufruf Rwabs() ist nur fÅr den sperrenden
Prozeû erlaubt. Dlock() wird z.B. beim Formatieren oder Kopieren ganzer
Disketten verwendet. Nach der Freigabe des Laufwerks sind alle Caches
ungÅltig gemacht, als wenn ein Diskwechsel stattgefunden hÑtte. <mode> hat
folgende Bedeutung:

     (mode & 1) == 1:    Laufwerk sperren. Existieren geîffnete Dateien auf
                         dem Laufwerk, wird eine Fehlermeldung EACCDN
                         geliefert.
                         Ist das Laufwerk von einem anderen Prozeû ebenfalls
                         per Dlock() gesperrt, wird ELOCKED geliefert. Es sei
                         denn (mode & 2) == 1. In diesem Fall wir die
                         Prozeû-ID des sperrenden Prozesses geliefert.
     (mode & 1) == 0:    Laufwerk wieder freigeben. Ist das Laufwerk nicht
                         oder von einem anderen Prozeû gesperrt, wird eine
                         Fehlermeldung ENSLOCK geliefert. Beim Terminieren des
                         sperrenden Prozesses wird das Laufwerk automatisch
                         wieder freigegeben.
     (mode & 2) == 1:    Liefere ggf. Prozeû-ID, wenn Laufwerk gesperrt.
     (mode & 2) == 0:    Liefere ELOCKED.

Eigentlich existieren also nur die Modi 0 (freigeben), 1 (sperren,
liefere ggf. ELOCKED), 3 (sperren, liefere ggf. sperrende Prozeû-ID).
Ein Sperren und anschlieûendes Freigeben eines Laufwerks simuliert quasi
einen Diskwechsel (es sei denn, das Laufwerk ist in Benutzung).

Vor Sperren des Laufwerks werden, falls ein Dateisystem fÅr das Laufwerk
existiert, die Caches Åber den Vektor xfs_sync zurÅckgeschrieben. Dann stellt
der Kernel Åber xfs_drv_close eine Anfrage, ob das Laufwerk gesperrt werden
kann. Wenn ja, gibt das XFS seine Strukten frei und signalisiert dann dem
Kernel, daû auch er seine Strukturen fÅr das Laufwerk freigeben und die
Sperrung durchfÅhren kann.


LONG Dreadlabel( char *dirpath, char *name, UWORD buflen )
----------------------------------------------------------

Ist seit MiNT 1.12 vorhanden und ist in MagiC 3 implementiert.


LONG Dwritelabel( char *dirpath, char *name)
--------------------------------------------

Ist seit MiNT 1.12 vorhanden und ist in MagiC 3 implementiert.



VI Verzeichnisverwaltung
========================


LONG Dcreate(char *path)
------------------------

Erstellt ein Unterverzeichnis. Der Aufruf wird vom Kernel weitergegeben als
xfs_dcreate mit Erstellmodus (-> Fxattr()) %0100000111101101 (d.h. "directory
file" mit Zugriffsberechtigung RWXRwXRwX). Mit Fchmod() kann der Modus
nachtrÑglich geÑndert werden.
Das XFS sollte keine gleichnamigen Dateien oder Unterverzeichnisse lîschen,
sondern in diesem Fall einen Fehlercode EACCDN liefern. UngÅltige Dateinamen
wie "." oder ".." mÅssen auch vom XFS abgefangen werden.


LONG Ddelete(char *path)
------------------------

Lîscht ein Unterverzeichnis.
Ab MagiC 4.01 kînnen damit auch Symlinks gelîscht werden. In Ñlteren
MagiC-Versioen wurde immer das Verzeichnis gelîscht, auf das der Symlink
zeigte, was Probleme mit Ñlteren Programmen hervorrufen konnte.
Der Kernel von MagiC 4.01 macht die Standardpfade, die eventuell auf dem
gelîschten Verzeichnis lagen, automatisch ungÅltig, weitere Zugriffe auf
diese Standardpfade fÅhren zu EPTHNF, bis durch Dsetpath() ein neuer Pfad
gesetzt wird.
Alte MagiC-Versionen testeten vorher, ob das Verzeichnis ein Standardpfad
ist, und gaben ggf. EACCDN zurÅck.


LONG Frename(char *oldpath, char *newpath)
------------------------------------------

Eine Datei (oder Verzeichnis oder Link oder GerÑt usw.) wird auf demselben
Laufwerk umbenannt oder in der Verzeichnisstruktur verschoben. Da dies Ñhnlich
wie das Erstellen eines Hardlinks ist, wird beim Aufruf des XFS dieselbe
Funktion wie bei Flink benutzt. Es ist Sache des XFS, zu entscheiden, ob
Verzeichnisse umbenannt oder verschoben werden dÅrfen.
Das integrierte DOS-XFS erlaubt kein Verschieben von Verzeichnissen.


LONG Dsetpath( const char *path )
---------------------------------

Im Gegensatz zu UNIX verwaltet GEMDOS fÅr jedes Laufwerk einen eigenen
aktuellen Pfad. Dsetpath() setzt den aktuellen Pfad fÅr dasjenige Laufwerk,
auf dem sich der durch <path> angegebene Pfad befindet. Dies muû nicht
zwangslÑufig derjenige sein, dessen Laufwerkbuchstabe im Pfad angegeben ist,
weil der Pfad Åber einen Symlink auch auf ein anderes Laufwerk zeigen kann.
Bei einem "cross drive link" wird daher, auûer fÅr Laufwerk U:, das aktuelle
Laufwerk umgesetzt, wenn sich der Aufruf von Dsetpath() darauf bezog. Ein
Beispiel:

- Sei f:\cbin ein Symlink auf c:\bin. Das aktuelle Laufwerk sei c:. Der
  Aufruf von Dsetpath("f:\cbin") fÅhrt dazu, daû der aktuelle Pfad von c: in
  "\bin\" geÑndert wird. Ist dagegen das aktuelle Laufwerk f:, wird
  zusÑtzlich noch das aktuelle Laufwerk auf c: gewechselt.
- Ist dagegen das aktuelle Laufwerk u:, ist diese Aktion nicht notwendig,
  weil der aktuelle Pfad einfach von "\f\" in "\c\bin\" geÑndert werden kann.


LONG Dgetpath( char *pathbuf, int drivecode )
---------------------------------------------

Wird unter MagiC 3 als Dgetcwd( pathbuf, drivecode, 128 ) ausgefÅhrt.


LONG Dpathconf( char *path, int mode )
--------------------------------------

Liefert Informationen Åber BeschrÑnkungen des Dateisystems, das zum
angegebenen <path> gehîrt. Die Funktion sollte in MagiC ggf. nach Dopendir()
aufgerufen werden, da Dpathconf() keine Diskwechsel erkennt (wenn der Pfad
noch im Cache ist, wird kein Diskzugriff durchgefÅhrt, und daher kein
Diskwechsel erkannt).

Auzug aus der MiNT-Doku:

 mode = -1:   max. legal value for n in Dpathconf(n)
         0:   internal limit on the number of open files
         1:   max. number of links to a file
         2:   max. length of a full path name
         3:   max. length of an individual file name
         4:   number of bytes that can be written atomically
         5:   information about file name truncation
              0 = File names are never truncated; if the file name in
                  any system call affecting  this  directory  exceeds
                  the  maximum  length (returned by mode 3), then the
                  error value ERANGE is  returned  from  that  system
                  call.

              1 = File names are automatically truncated to the maxi-
                  mum length.

              2 = File names are truncated according  to  DOS  rules,
                  i.e. to a maximum 8 character base name and a maxi-
                  mum 3 character extension.
         6:   0 = case-sensitiv
              1 = nicht case-sensitiv, immer in Groûschrift
              2 = nicht case-sensitiv, aber unbeeinfluût

         7:   Information Åber unterstÅtzte Attribute und Modi
         8:   information Åber gÅltige Felder in XATTR

      If  any  of these items are unlimited, then 0x7fffffffL is
      returned.


Dopendir
Dreaddir
Dxreaddir

- ACHTUNG:
  Dxreaddir eingebaut. Hierzu muûte die Spezifikation des XFS verÑndert
  werden. Der Eintrag xfs_readdir Åbernimmt sowohl Dreaddir als auch
  Dxreaddir, im ersten Fall ist ein Zeiger NULL.

Drewinddir
Dclosedir


LONG Dgetcwd( char *pathbuf, int drivecode, int buflen )
--------------------------------------------------------

Gibt in <pathbuf> den aktuellen Pfad (ohne Laufwerkbuchstabe) fÅr das
angegebene Laufwerk <drivecode> zurÅck. Ist <drivecode> == 0, wird das
aktuelle Laufwerk verwendet, 1 entspricht Laufwerk A:, 2 Laufwerk B: usw.
<buflen> ist die LÑnge des Pfadpuffers, ist der aktuelle Pfad zu lang, wird
ERANGE zurÅckgegeben.



VII Dateinamen-Funktionen
=========================


Fsetdta
Fgetdta


LONG Fcreate(char *path, int attr)
----------------------------------

Diese Funktion dereferenziert symbolische Links, d.h. wenn die Datei bereits
als symbolischer Link existiert, wird die davon referenzierte Datei auf die
LÑnge Null gebracht.

Diese Funktion hat 2 Unterfunktionen:

1.   Ist Bit 3 von <mode> gesetzt, wird ein Diskname erstellt. Dabei wird die
     XFS-Funktion xfs_wlabel aufgerufen. Wird diese Funktion ohne Fehler
     ausgefÅhrt, wird als RÅckgabewert 0x0000fffc zurÅckgegeben. Dies
     entspricht einem Handle fÅr die Datei NUL: bzw. u:\dev\null. Das
     Anwenderprogramm kann dieses Handle schlieûen oder auch nicht.

     Achtung: Diese Unterfunktion wurde in MagiC 3 und MiNT 1.12 durch die
              leistungsfÑhigere Funktion Dwritelabel() ersetzt und ist nur
              noch aus KompatibilitÑtsgrÅnden vorhanden.

2.   Eine Datei mit DOS-Attribut <attr> wird erstellt. Dabei sind die Bits

          FA_RDONLY      (Bit 0)
          FA_HIDDEN      (Bit 1)
          FA_SYSTEM      (Bit 2)
          FA_ARCHIVE     (Bit 5)

     zulÑssig. Die Bits 6 und 7 werden aus KompatibilitÑtsgrÅnden unter
     MagiC 3 ignoriert. Ein gesetztes Bit 4 (FA_SUBDIR) fÅhrt zu Fehlercode
     EBADRQ.
     Wird eine Datei mit FA_RDONLY erstellt, ist sie zwar geîffnet, kann aber
     nicht beschrieben werden.

     Anmerkung: Fcreate() sollte eigentlich in MiNT und MagiC 3 durch
                Fopen() im Modus O_CREAT+O_TRUNC ersetzt werden. Bei dieser
                Funktion wird jedoch immer das Attributbyte 0 angenommen,
                FA_RDONLY muû daher ggf. durch anschlieûenden Aufruf von
                Fchmod() gesetzt werden.
                Die Attribute existieren nur auf DOS-Dateisystemen und werden
                von anderen Dateisystemen ignoriert oder simuliert. Auf dem
                Macintosh-Dateisystem wird nur FA_RDONLY berÅcksichtigt.
                FA_ARCHIVE ist ÅberflÅssig, wenn man eine korrekt gehende
                Systemuhr besitzt und das Datum des letzten Backup bekannt
                ist.


LONG Fopen(char *path, WORD omode)
----------------------------------

Diese Funktion dereferenziert symbolische Links, d.h. wenn die Datei bereits
als symbolischer Link existiert, wird die davon referenzierte Datei geîffnet
bzw., wenn O_TRUNC angegeben wurde, auf die LÑnge Null gebracht.

<omode> der Dateiîffnungsmodus. Unter TOS sind hier nur die Werte 0 bis 2
erlaubt, unter MiNT und MagiC existieren folgende Modi:

	O_RDONLY	(0x00)	Will nur lesen
	O_WRONLY	(0x01)	Will nur schreiben
	O_RDWR	(0x02)	Will lesen und schreiben

Wenn keine weiteren "sharing mode" Flags benutzt werden, entspricht das dem
KompatibilitÑts-Modus, d.h. O_COMPAT (0x00). Dabei erlaubt MagiC das
mehrfache ôffnen zum Lesen, jedoch nur das einfache ôffnen zum Schreiben.
MiNT unterscheidet dagegen zwischen eigenen und fremden Dateien; ein Prozeû
darf hier eine Datei mehrmals îffnen, die fÅr andere Prozesse jedoch dann
gesperrt ist. Die "sharing modes" sind:

	O_COMPAT	(0x00)	TOS-KompatibilitÑt
	O_DENYRW	(0x10)	vor Lesen und Schreiben schÅtzen
	O_DENYW	(0x20)	vor Schreiben schÅtzen
	O_DENYR	(0x30)	vor Lesen schÅtzen
	O_DENYNONE(0x40)	nicht schÅtzen

MiNT "kennt" noch (oder auch nicht):

	O_NOINHERIT(0x80)	/* this is currently ignored by MiNT */
	O_NDELAY	(0x100)	/* don't block for i/o on this file */

MagiC und MiNT unterstÅtzen noch:

	O_CREAT	(0x200)	Datei erstellen, wenn sie nicht existiert
	O_TRUNC	(0x400)	Existierende Datei auf Null-LÑnge setzen
	O_EXCL	(0x800)	Existierende Datei nicht îffnen


LONG Fdelete( char *path )
--------------------------

Die Datei wird gelîscht. Dabei werden keine symbolischen Links dereferenziert,
d.h. es wird der Link gelîscht, nicht die Datei oder der Ordner, auf die der
Link zeigt.


LONG Fattrib( char *path, int setflag, int new_attrib )
-------------------------------------------------------

Hiermit kînnen die DOS-Zugriffsberechtigungen auf Dateien ermittelt und
verÑndert werden. FÅr neuere Anwendungen sind Fxattr() zum Ermitteln der
Attribute und Fchmod() zum VerÑndern der Berechtigungen leistungsfÑhiger,
werden jedoch nicht von allen Dateisystemen unterstÅtzt. So unterstÅtzt das
DOS-XFS zur Zeit nur Fxattr(), nicht Fchmod().
Ist <setflag> == 0, wird das Attribut der Datei oder des Ordners <path>
ermittelt. Dabei werden keine Disknamen (volume labels) gefunden.
Ist <setflag> == 1, wird das Attribut der Datei <path> gemÑû dem neuen
Attribut <new_attrib> modifiziert. Jeder Versuch, damit einen Ordner zu
modifizieren, fÅhrt zu EACCDN.
Modifiziert werden dÅrfen die Attribute FA_READONLY (0x01), FA_HIDDEN (0x02),
FA_SYSTEM (0x04) und FA_ARCHIVE (0x20). EnthÑlt <new_attrib> weitere Flags,
fÅhrt dies zum Fehlercode EACCDN.
Achtung:  éltere Betriebssysteme finden hier keine Ordner, d.h. Zugriff auf
          einen Ordner fÅhrt immer zu EFILNF.


LONG Fsfirst( char *path, int sattr )
-------------------------------------

Diese Funktion erfÅllt zwei unterschiedliche Aufgaben:

1.   Ist Bit 3 von <sattr> gesetzt, ruft der MagiX-Kernel die
     XFS-Funktion xfs_rlabel auf. Das aufrufende Anwenderprogramm kann damit
     leider unter MagiC 3 nicht mehr Datum und Uhrzeit des Disknamens
     ermitteln. Der Kernel setzt alle Felder auf 0. Ein Fsnext() darf dann
     nicht ausgefÅhrt werden.

     Achtung: Die Funktion wurde in MagiC 3 und MiNT 1.12 durch Dreadlabel()
              ersetzt, mit der auf lÑngere Dateinamen gelesen werden kînnen.

2.   Sonst wird wie in TOS nach Dateien gesucht. Ist eine Datei ein Symlink,
     ruft der DOS-Kernel die Funktion Fxattr() auf, um den Symlink zu
     verfolgen. Die von Fxattr() gelieferten Werte werden dann in die DTA
     kopiert.
     Achtung: MagiC 3 ist nicht in der Lage, relative Symlinks wÑhrend des
              Fsfirst/Fsnext - Mechanismus immer korrekt auszuwerten. Es
              bieten sich 3 Auswege an:

              a) Am besten: Dxreaddir() verwenden.
              b) Nur absolute Symlinks verwenden
              c) Das Suchverzeichnis jeweils zum aktuellen machen.

              MiNT behandelt diesen Fall korrekt, jedoch auf Kosten eines
              gewaltigen Aufwands. Das Konzept Fsfirst/next ist grundsÑtzlich
              veraltet, ineffektiv und unsicher und sollte sowohl in MiNT als
              auch in MagiC 3 vermieden werden.


LONG Fsnext( void )
-------------------

In Bezug auf die Auswertung der Symlinks -> Fsfirst().


LONG Frename( const char *oldpath, const char *newpath )
--------------------------------------------------------

(...)


LONG Fxattr( WORD mode, const char *path, XATTR *xa )
-----------------------------------------------------

Ermittelt eine Reihe von Daten fÅr eine Datei oder einen Ordner, dessen Name
bekannt ist. Das Pendant Fcntl mit Modus FSTAT arbeitet Ñquivalent mit einer
geîffneten Datei und erwartet statt des Pfads ein DOS-Dateihandle.
Mit <mode> == 0 werden Symlinks verfolgt, mit <mode> == 1 wird die XATTR-
Struktur des Symlinks selbst ermittelt.
Die XATTR-Struktur im einzelnen:

typedef struct xattr {
     unsigned short mode;

		EnthÑlt den Dateityp und die (UNIX-) Zugriffsrechte. Bei DOS-
		und Mac- Partitionen werden die UNIX-Zugriffsrechte halbwegs sinnvoll
		simuliert: Dateien haben RWXRWXRWX bzw., wenn sie schreibgeschÅtzt
		sind, RwXRwXRwX.
		NÑheres steht in der MiNT-Doku.

     long index;

		EnthÑlt ein Langwort zur eindeutigen Identifizierung einer Datei
		bzw. eines Ordners. Der Index muû innerhalb eines Dateisystems
		eindeutig sein, zusammen mit dem folgenden Feld (dev) ist damit
		eine Datei oder ein Ordner systemglobal vollstÑndig festgelegt.

		Unter UNIX-Ñhnlichen Dateisystemen ist <index> die Nummer des
		Inode.

		Auf Mac-Partitionen wird die "hard file ID" bzw. die "hard dir ID"
		verwendet, die vom MacOS zur VerfÅgung gestellt wird. Das MacOS
		verwendet als Standard-Deskriptoren aber das "FSSpec". FÅr
		Verzeichnisse, d.h. fÅr "Directory IDs", gibt es Funktionen des
		MacOS, um einen FSSpec zu berechnen. Leider lassen sich die "hard
		file IDs" fÅr normale Dateien (d.h. nicht Unterverzeichnisse) nicht
		weiter verwenden, da sie von keiner Funktion des MacOS verarbeitet
		werden.

		Auf DOS-Dateisystemen wird im Fall eines Ordners der Startcluster
		im Motorola-Format verwendet, ansonsten im Hiword der Startcluster
		des Verzeichnisses und im Loword die Position des zugehîrigen
		Verzeichniseintrags, dividiert durch 32.
		Der Startcluster lÑût sich leider bei normalen Dateien nicht verwenden,
		weil leere Dateien den Startcluster 0 haben und so alle leeren
		Dateien einen identischen Index hÑtten. Weiterhin hÑtte sich bei
		Beschreiben einer leeren Datei der Startcluster und damit der
		Index geÑndert.
		Das Verfahren ist Ñhnlich wie das, das Linux und Solaris verwenden.
 		Nachteil ist, daû Dateien beim Verschieben ihren Index Ñndern.

     unsigned short dev;

		Legt das Dateisystem fest. Auf dem Atari sind 0..25 die BIOS-Laufwerke
		A: bis Z:, Laufwerk U: oder andere Dateisysteme verwenden hîhere
		Nummern.
		Auf dem Mac wird die "volume ID" eingesetzt, die vom MacOS vergeben
		wird.

     unsigned short reserved1;

		hier ist Platz fÅr Eric Smiths Lebenslauf.

     unsigned short nlink;

		Anzahl der "hard links", die auf diese Datei verweisen. Dies ist
		nur bei UNIX-Dateisystemen interessant, bei DOS-Dateisystemen und
		Mac-Partitionen steht hier immer eine "1".

     unsigned short uid;

		Die "user ID" der Datei, d.h. der Eigner. Ist nur fÅr Multiuser-
		Systeme interessant, d.h. fÅr UNIX-Partitionen. Mac- und DOS-
		Partitionen haben hier immer eine "0".

     unsigned short gid;

		Die "group ID" der Datei. Ebenfalls nur fÅr Multiuser-
		Systeme interessant, d.h. fÅr UNIX-Partitionen. Mac- und DOS-
		Partitionen haben hier immer eine "0".

     long size;

		Die (logische) DateilÑnge, d.h. die Anzahl der Bytes, die man
		mit Fread() lesen kann.

		Auf DOS-Partitionen wird fÅr Ordner als LÑnge 0 geliefert. Die
		tatsÑchliche LÑnge kann leider aufgrund der EinschrÑnkungen von
		MSDOS nicht ermittelt werden. Die LÑnge des Wurzelverzeichnisses
		kann allerdings ermittelt werden.

		Auf Mac-Partitionen haben Ordner immer die LÑnge 0, die tatsÑchliche
		LÑnge lÑût sich (zumindest unter System 7) nicht ermitteln.

     long blksize;

		Die LÑnge eines physikalischen Blocks der Datei. Auf DOS-
		Partitionen die Clustergrîûe.

	long nblocks;

		Die Anzahl der durch die Datei belegten Blîcke.
		(blksize * nblocks) ist damit die physikalische DateilÑnge.
		Es gelten dieselben EinschrÑnkungen fÅr Ordner wie bei <size>.

     short     mtime, mdate;

		Modifikationsdatum der Datei.

     short     atime, adate;

		Datum des letzten Zugriffs. Ist auf DOS- und Mac- Partitionen
		mit dem Modifikationsdatum identisch.

     short     ctime, cdate;

		Erstelldatum der Datei. Ist auf DOS- Partitionen mit dem
		Modifikationsdatum identisch.

     short     attr;

		Das von Fattrib() gelieferte Byte, d.h. DOS-Zugriffsrechte
		(ReadOnly oder ReadWrite) und DOS-Flags (Hidden,System,Archive,
		Subdir)

     short     reserved2;
     long reserved3[2];

		hier ist Platz fÅr Eric Smiths Lieblingsgedicht.

} XATTR;



Flink
Fsymlink
Freadlink
Fchown
Fchmod


LONG Dcntl( WORD function, char *path, void *param )
----------------------------------------------------

Mit dieser Funktion werden Åblicherweise Spezialfunktionen ausgefÅhrt, 
die abhÑngig vom Åbergebenen Pfad sind. Je nach Dateisystem, das fÅr 
den Åbergebenen Pfad zustÑndig ist, sind unterschiedliche 
Unterfunktionsnummern mîglich, die direkt vom Dateisystemtreiber 
ausgefÅhrt werden.
Weiterhin gibt es eine Reihe von Unterfunktionen, die vom Kernel selbst 
ausgefÅhrt werden, wobei der Pfad ignoriert wird. Hier unterscheiden 
sich MiNT und MagiC deutlich.

Folgende Unterfunktionsnummern sind definiert:

KER_GETINFO (0x0100)

	Diese Funktion existiert nur unter MagiC. <path> und <param> 
	mÅssen auf NULL gesetzt werden. Es wird ein Zeiger auf die MagiC- 
	Kernelstruktur zurÅckgegeben. Sie ist als MX_KERNEL definiert 
	(->MGX_XFS.TXT und MGX_XFS.H) und wird von Dateisystemtreibern 
	oder GerÑtetreibern verwendet.

KER_DOSLIMITS (0x0101)

	Diese Funktion existiert nur unter MagiC. <path> und <param> 
	mÅssen auf NULL gesetzt werden. Es werden Informationen Åber den 
	installierten FAT-Dateisystemtreiber (d.h. den Treiber fÅr das 
	Åbliche TOS- oder MSDOS-Dateisystem) geliefert. Dcntl() liefert 
	einen Zeiger auf einen Zeiger auf die Struktur MX_DOSLIMITS 
	(->MGX_XFS.H). Der Zeiger selbst kann daher auf eine eigene 
	Struktur umgebogen werden, falls ein neuer Treiber installiert 
	wird.
	Diese Unterfunktion wird normalerweise nur von Festplattentreibern 
	(z.B. HDDRIVER) verwendet.

KER_INTMAVAIL (0x0102)
KER_INTGARBC (0x0103)
KER_SETWBACK (0x0300)

	Diese Funktionen existierten vor der Version 4.01 unter MagiC, aber
	wurden auf Sconfig-Aufrufe umgesetzt, um Konflikte mit Treibern zu
	vermeiden, die Probleme mit unbekannten Dcntl-Codes haben.

KER_DRVSTAT (0x0104)

	Diese Funktion existiert nur unter MagiC (ab 9.9.95). <path> 
	wird ignoriert. Vom Kernel werden einfache Informationen Åber ein 
	Laufwerk ermittelt.
	Dazu Åbergibt man in <param> einen Zeiger auf zwei WORDs. Das 
	erste muû eine Null enthalten, in das zweite wird eine 
	Laufwerknummer von 0 (fÅr A:) bis 25 (fÅr Z:) geschrieben.
	Dcntl() liefert folgende RÅckgabewerte:

		EDRIVE	Laufwerknummer ungÅltig (nicht 0..25)
		ELOCKED	Laufwerk z.Zt. gesperrt
		<0		anderer Fehler
		0		Laufwerk z.Zt. nicht gemountet (nicht aktiv)
		>0		Laufwerk gemountet (aktiv)

	Ist auf ein Laufwerk noch nicht zugegriffen worden oder ist ein 
	Laufwerk durch Dlock(), Diskwechsel oder Auswurf eines Mediums 
	freigegeben werden, ist es "unmounted", d.h. ist (nicht mehr) 
	aktiv. Beim ersten Zugriff auf das Laufwerk wird es automatisch 
	wieder "gemountet", z.B. beim ôffnen eines Laufwerkicons in der 
	Shell.

KER_XFSNAME (0x0105)

	Diese Funktion existiert nur unter MagiC (ab 15.6.96). <path>
	ist ein Pfad (keine Datei!). Vom Kernel wird der Name des XFS-
	Treibers ermittelt, der fÅr diesen Pfad zustÑndig ist.
	Dazu Åbergibt man in <param> einen Zeiger auf einen Puffer
	mit Platz fÅr mindestens 9 Bytes (char buf[9]), der Zeiger
	muû auf eine gerade Adresse zeigen.
	Dcntl() liefert einen Wert < 0, wenn das Verzeichnis ungÅltig
	oder ein anderer Fehler aufgetreten ist, ansonsten wird ein
	Wert > 0 zurÅckgegeben, und der Name des Treibers ist in
	buf[] kopiert worden. Z.Zt. gibt es an Namen:

		"DOS_XFS "		Altes DOS-XFS
		"VDOS_XFS"		Neues DOS-XFS (mit VFAT-UnterstÅtzung)
		"MMAC_HFS"		MagicMac-HFS

KER_INSTXFS (0x0200)


	Diese Funktion existiert nur unter MagiC. Durch den Aufruf
		kernel = Dcntl(KER_INSTXFS, NULL, &myxfs);
	wird ein XFS installiert (->MGX_XFS.TXT).

CDROMEJECT (0x4309)

	Diese Funktion existiert unter MagiC und mit EinschrÑnkung 
	auch in MiNT. Sie dient zum Auswurf eines Mediums. <param> muû 
	NULL sein. Unter MiNT wird sie nur vom CDROM-Treiber verwendet. 
	Unter MagiC wird sie komplett vom Kernel unterstÅtzt.

	In <path> Åbergibt man einen Pfad, dessen zugehîriges 
	Speichermedium ausgeworfen werden soll.

	MagiC ermittelt dazu zunÑchst alle Laufwerke, die auf demselben 
	Medium liegen (dafÅr werden die Felder d_driver und d_devcode im 
	DMD verwendet, siehe MGX_XFS.TXT und MGX_XFS.H). Wichtig ist dies 
	fÅr Wechselmedien (z.B. Syquest) mit mehreren Partitionen oder fÅr 
	Macintosh-Volumes mit mehreren MagiC-Laufwerken.

	Alle diese Laufwerke werden freigegeben ("unmounted"). Gibt es 
	dabei einen Fehler, weil z.B. auf einem der Laufwerke noch 
	geîffnete Dateien sind oder weil eines der Laufwerke per Dlock() 
	gesperrt wurde, wird der Auswurf verweigert und EACCDN bzw. 
	ELOCKED zurÅckgegeben.

	Schlieûlich wird der GerÑtetreiber (Eintrag d_driver im DMD) 
	aufgerufen, um das Medium auszuwerfen. UnterstÅtzt wird die 
	Auswurffunktion fÅr Mac-Volumes (auch Disketten) sowie fÅr 
	Laufwerke, die mit einem XHDI-Treiber angesprochen werden (z.B. 
	HDDRIVER). Manche GerÑte (Festplatten) lassen sich nicht 
	auswerfen, sie werden nur ausgeschaltet (geparkt). Disketten 
	lassen sich im Atari nicht auswerfen.

DFS_GETINFO (0x1100)
DFS_INSTDFS (0x1200)

	Diese Funktionen existieren nur in MagiC und dienen zur 
	Installation eines DFS (->MGX_DFS.TXT). Sie werden vom internen 
	DOS-XFS verarbeitet.

PROC_CREATE (0xcc00)

	Diese Funktion existiert nur in MagiC. Sie ist reserviert.

DEV_M_INSTALL (0xcd00)

	Diese Funktion existiert nur in MagiC. Mit
		Dcntl(DEV_M_INSTALL, "u:\\dev\\mydev", &mydriver);
	wird ein GerÑtetreiber installiert (->MGX_UDFS.TXT, MGX_DFS.TXT, 
	MGX_DFS.H).

FUTIME (0x4603)

	Diese Funktion wird vom jeweiligen XFS ausgefÅhrt und ist das 
	Pendant zur gleichnamigen Fcntl()- Funktion. Sie wird von MiNT 
	sowie vom DOS-XFS von MagiC unterstÅtzt. FÅr Macintosh-Volumes 
	wird sie z.Zt. nicht unterstÅtzt.
	Als <param> wird ein Zeiger auf folgende Struktur Åbergeben:

		struct mutimbuf
		     {
		     unsigned int actime;          /* Zugriffszeit */
		     unsigned int acdate;
		     unsigned int modtime;         /* letzte énderung */
		     unsigned int moddate;
		     };

	Die Struktur ist in MAGX.H definiert.

VFAT_CNFDFLN (0x5600)

Diese Funktion existiert nur unter MagiC (ab 2.1.96).
Zur Konfiguration des VFAT-XFS.
Als Pfad muû "u:\" Åbergeben werden. Der Parameter ist ein Bitvektor, der
die Laufwerke festlegt, bei denen lange Dateinamen zugelassen werden.
Die Einstellung wird erst beim Mounten eines Dateisystems aktiv, daher
kînnen bereits gemountete Dateisysteme mit diesem Befehl nicht beeinfluût
werden.
Exakt bedeutet das: Beim Mounten eines Dateisystems bestimmt das VFAT-XFS
aus dem mit VFAT_CNFDFLN festgelegten Bitvektor, ob ein Dateisystem
im "alten" DOS-Modus (mit 8+3-Dateinamen) oder im "neuen" Windows95-Modus
(mit langen Dateinamen) betrieben wird. Der Bitvektor wird beim Booten mit
0L initialisiert, d.h. das Bootlaufwerk wird immer im 8+3-Modus geîffnet.

VFAT_CNFLN (0x5601)

Diese Funktion existiert nur unter MagiC (ab 2.1.96).
Zur Konfiguration eines VFAT-Dateisystems.
Legt fÅr ein gemountetes Laufwerk fest, ob es lange Dateinamen unterstÅtzt
oder nicht. Damit kann man den mit VFAT_CNFDFLN festgelegten Defaultwert
Åberladen. Damit die Umstellung sichtbar wird, sollte eine SH_WDRAW-
Nachricht an die Shell geschickt werden.

DEV_NEWTTY (0xde00)
DEV_NEWBIOS (0xde01)
DEV_INSTALL (0xde02)
FS_INSTALL (0xf001)
FS_MOUNT (0xf002)
FS_UNMOUNT (0xf003)
FS_UNINSTALL (0xf004)

	Diese Funktionen werden nur von MiNT unterstÅtzt und dienen zum 
	Installieren/Deinstallieren von Dateisystemen und -treibern. Wegen 

	der unterschiedlichen Treiberstrukturen verwendet MagiC andere 
	Funktionen (s.o.)



VIII Dateihandle-Funktionen
===========================


Fclose
Fread
Fwrite
Fseek

- Fseek auf Pipes liefert jetzt EACCDN wie in MiNT, damit kînnen Gemini-
  Programme GerÑte und Pipes unterscheiden.

Fdup
Fforce
Fdatime
Flock

wird unterstÅtzt.

Fpipe


LONG Fcntl( WORD handle, LONG arg, WORD cmd )
---------------------------------------------

FÅhrt verschiedene Operationen auf einer geîffneten Datei durch. Je nach
Dateityp werden verschiedene Werte fÅr <cmd> akzeptiert. Einige Funktionen
sind jedoch allgemein und sollten von jedem Dateityp unterstÅtzt werden, dies
ist jedoch nicht gewÑhrleistet. Bei ungÅltigen Kommandos liefert der
Dateitreiber EINVFN.
Folgende Opcodes werden von internen Dateitreibern von MagiC unterstÅtzt:

- FSTAT ($4600)
- FIONREAD ($4601)
  <arg> ist vom Typ (LONG *) und enthÑlt nach dem Aufruf die Anzahl der
  Bytes, die von der Datei gelesen werden kînnen, ohne daû das Programm durch
  das Lesen in den Wartezustand versetzt werden muû. D.h. wenn eine Pipe 1000
  Zeichen enthÑlt, kann man 1000 Zeichen direkt lesen, ohne daû man darauf
  warten muû, daû neue Daten in die Pipe geschrieben werden.
  Bei FAT- Dateien wird die tatsÑchliche LÑnge minus der aktuellen
  Dateizeiger-Position geliefert. Ebenso bei "shared memory". GerÑtedateien
  (devices) liefern eine 1, wenn ein Zeichen anliegt, hierfÅr wird Bconstat()
  verwendet. Bei GerÑten, die einen Einlesepuffer haben, sollte die Zahl der
  im Puffer vorhandenen Zeichen angegeben werden.
  FIONREAD wird von Finstat() verwendet.
- FIONWRITE ($4602)
  <arg> ist vom Typ (LONG *) und enthÑlt nach dem Aufruf die Anzahl der
  Bytes, die auf die Datei geschrieben werden kînnen, ohne daû das Programm
  durch das Schreiben in den Wartezustand versetzt werden muû. D.h. wenn eine
  Pipe 1000 Zeichen enthÑlt, kann man noch 1048 Zeichen direkt schreiben, ohne
  daû man darauf warten muû, daû wieder Daten von der Pipe gelesen werden.
  Bei FAT- Dateien wird 1 geliefert. Bei Dateien mit fester LÑnge, z.B.
  "shared memory", wird die LÑnge minus der Dateizeigerposition geliefert.
  GerÑtedateien (devices) liefern eine 1, wenn Bcostat() ein "OK" liefert.
  Bei GerÑten, die einen Schreibpuffer haben, sollte die Zahl der im Puffer
  noch freien Zeichen angegeben werden.
  FIONWRITE wird von Foutstat() verwendet.
- FUTIME ($4603)
- FTRUNCATE ($4604)
  <arg> ist vom Typ (LONG *) und zeigt auf die neue LÑnge der zu verkÅrzenden
  Datei.
  Wird in MagiC 3 z.Zt. nur vom FAT-DFS unterstÅtzt.
- PBASEADDR ($5002)
- SHMGETBLK ($4d00)
  Wird nur bei "shared memory"- Dateien unterstÅtzt, das sind die Dateien,
  die in u:\shm liegen.
- SHMSETBLK ($4d01)
  Wird nur bei "shared memory"- Dateien unterstÅtzt, das sind die Dateien,
  die in u:\shm liegen. <arg> ist ein Zeiger auf einen per M(x)alloc()
  reservierten Speicherblock, der das "shared memory" darstellt. Der Block
  wird derart markiert, daû er nicht beim Beenden des Prozesses freigegeben
  wird. Die LÑnge wird ermittelt und sowohl fÅr die geîffnete Datei verwendet
  wie in das Verzeichnis eingetragen. UngÅltige Blockadressen fÅhren zu
  Fehlercode EIMBA oder zu einem Bus- oder Adreûfehler.
  Die Implementation sollte MiNT entsprechen.
(...)


LONG Finstat( WORD handle)
--------------------------

Liefert fÅr eine zum Lesen geîffnete Datei <handle> die Anzahl der Zeichen,
die mindestens ohne Warten gelesen werden kînnen. Kann diese Anzahl nicht
exakt angegeben werden, wird 1L geliefert.

Der Kernel versucht zunÑchst, den Aufruf auf Fcntl(FIONREAD) zurÅckzufÅhren.
Wenn diese Subfunktion von dev_ioctl nicht existiert (d.h. der Dateitreiber
liefert EINVFN), wird dev_stat aufgerufen. In diesem Fall kann nur
die Aussage getroffen werden "Zeichen liegt an" (RÅckgabe == 1) bzw. "kein
Zeichen liegt an" (RÅckgabe == 0).
FAT-Dateien und Shared Memory liefern die tatsÑchliche DateilÑnge minus der
aktuellen Position.
Pipes liefern die Anzahl der vorhandenen Bytes im Block.


LONG Foutstat( int handle )
---------------------------

Liefert fÅr eine zum Schreiben geîffnete Datei die Anzahl der Zeichen, die
mindestens ohne Warten geschrieben werden kînnen. Kann diese Anzahl nicht
exakt angegeben werden, wird 1L geliefert.

Der Kernel versucht zunÑchst, den Aufruf auf Fcntl(FIONWRITE)
zurÅckzufÅhren. Wenn diese Subfunktion von dev_ioctl nicht existiert (d.h.
der Dateitreiber liefert EINVFN), wird dev_stat aufgerufen. In diesem Fall
kann nur die Aussage getroffen werden "Zeichen liegt an" (RÅckgabe == 1)
bzw. "kein Zeichen liegt an" (RÅckgabe == 0).
FAT-Dateien liefern 1.
Shared Memory liefert die tatsÑchliche DateilÑnge minus der aktuellen
Position.
Pipes liefern die Anzahl der noch freien Bytes im Block.



Fgetchar
Fputchar
Fselect
Fmidipipe



IX Zeichenorientierte Funktionen
================================


Cconin
Cconout
Cauxin
Cauxout
Cprnout
Crawio
Crawcin
Cnecin
Cconws
Cconrs
Cconis
Cconos
Cprnos
Cauxis
Cauxos
