WDIALOG
=======

Stand: 22.04.96 (V1.05 von Andreas Kromke)

Anmerkung:	HNDL_MESG
			wdlg_set_iconify
			wdlg_set_uniconify

			zur Zeit nur im MagiC Kernel (4.50beta ab 22.4.96)

(c) 1996 by Sven & Wilfried Behne

Intentionen, Konditionen, Ovationen
-----------------------------------

Die Benutzeroberfl„che unter GEM hat sich in den letzten zehn Jahren stark
weiterentwickelt. Aktuelle Programme arbeiten mit Fensterdialogen,
Radiobuttons, Checkboxen und vielem mehr.
Da diese Erweiterungen nicht ins TOS integriert wurden, mssen
Programmierer immer wieder "das Rad neu erfinden": Meist wird zum Programm
eine Bibliothek hinzugelinkt, die nur die AES-Funktionen der ersten
TOS-Versionen voraussetzt. Alle Erweiterungen werden durch den Programmcode
der Bibliothek realisiert.
Leider hat das den Nachteil, da die Programmgr”e "nur" aus Grnden der
Optik stark anw„chst (was im Multitaskingbetrieb genau den Speicher kostet,
den man gerade nicht hat) und die F„higkeiten neuerer OS-Versionen nicht
oder nur unvollst„ndig genutzt werden.

Wir haben daher einen anderen Ansatz mit folgenden Vorgaben gew„hlt:

- Kompakte, residente Erweiterung stellt h„ufig ben”tigte Routinen
  (Fensterdialoge, Listboxen und Zeichensatzauswahl) zur Verfgung.

- Hohe Flexibilit„t der Routinen; d.h. keine statischen Beschr„nkungen in
  der Anzahl der Dialoge oder gleichzeitig offenen Fontselektoren;
  Listboxen, die mehr als nur Text-Objekte verwalten k”nnen,
  Mehrfachselektion, Auto-Scrolling, etc. ... .

- Vorteile und Erweiterungen des OS sollen genutzt werden (3D-Effekte,
  Clipboard in Editfeldern, ...).

- Erweiterte Objekttypen (Gruppenrahmen, Radiobuttons, etc.) werden als
  vorhanden vorausgesetzt, so da das RSC-File kompakt bleibt.

- In „lteren OS-Versionen fehlende Objekttypen sollen durch ein kurze
  Routine automatisch generiert werden (-> ADAPTRSC.C).

- Design der Programmoberfl„che soll zur "Personality" des OS passen (kein
  "Dino-Tuning" mit 3D-Effekten unter TOS 1.0).

Herausgekommen ist WDIALOG. Eine Systemerweiterung von 29 kB Gr”e, die
MagiC 4-kompatible AES-Erweiterungen zur Verfgung stellt.


Installation
------------

WDIALOG.PRG in AUTO-Ordner kopieren und einen Neustart des Systems
durchfhren. Nach g„ngigen Erfahrungen empfiehlt sich eine AUTO-Ordner
Reihenfolge, bei der WDIALOG vor NVDI liegt.


Konditionen
-----------

Die Dokumentation zu WDIALOG und der Archivinhalt von WDIALOG.LZH sind
Public Domain, d.h. es darf frei kopiert und benutzt werden. Das Archiv
darf nur komplett weitergegeben werden!
Es ist erlaubt, die Quellcodes fr die eigenen Anforderungen zu ver„ndern.
Es ist jedoch NICHT erlaubt, diese ver„nderten Dateien in Umlauf zu
bringen. Der entgeldliche Vertrieb ist _untersagt_.

Der Vertrieb von WDIALOG im Zusammenhang mit anderen Software-Produkten ist
erlaubt, sofern dem Kunden dadurch _keine_ zus„tzlichen Kosten entstehen
und der empfohlene Verkaufspreis dieser Software 50 DM nicht bersteigt.

** Ausnahmen bedrfen einer schriftlichen Genehmigung der Autoren!
Zuwiderhandlungen werden strafrechtlich verfolgt. **

Das Copyright verbleibt allein bei den Autoren, Sven & Wilfried Behne

Zu WDIALOG.LZH geh”ren folgende Dateien:

   - DOC_WDLG.TXT
   - WDIALOG.PRG
   - SAMPLE-Ordner mit den Programmen und Quellen zu WDLG_SMP.APP,
     XOBJ_SMP.APP, FNT_SMPL.APP und FNT_SMP2.APP.
   - Snapshots der Beispielprogramme unter TOS 1.04 und MagiC 4 (16
     Farb-IMGs).

Fr Wnsche, Anregungen und Fehlerkorrekturen haben wir natrlich immer ein
offenes Ohr.


Ausschlu der Haftung
=====================

Die Haftung fr unmittelbare und mittelbare Sch„den, Folgesch„den und
Drittsch„den durch die Benutzung der Systemerweiterung WDIALOG sind
ausgeschlossen. Fr die Vollst„ndigkeit und Richtigkeit der gemachten
Angaben wird keinerlei Gew„hr bernommen.

Disclaimer
----------
Die meisten hier erw„hnten Produkte sind in der Regel durch Warenzeichen
geschtzt. Das Fehlen gesonderter Hinweise bedeutet nicht, da diese
Produkte frei von Rechten Dritter sind.



WDIALOG Programmer's Guide
==========================

Stand: 8.12.95 (vorl„ufige Fassung)

Diese Funktionsbeschreibung zu WDIALOG ist ist in die Teile

-  Datentypen und Strukturen
-  Wie erkenne ich WDIALOG?
-  Fensterdialoge
-  Listboxen
-  Zeichensatzauswahl
-  Konvertierung erweiterter Objektetypen

gegliedert.


Datentypen und Strukturen
=========================

ù Benutzte Datentypen

Die Deklarationen und Beschreibungen arbeiten mit den folgenden Datentypen:

BYTE     8 Bit, vorzeichenbehaftet, -128 bis 127
UBYTE    8 Bit, kein Vorzeichen, 0 bis 255
WORD     16 Bit, vorzeichenbehaftet, -32768 bis 32767
UWORD    16 Bit, kein Vorzeichen, 0 bis 65535
LONG     32 Bit, vorzeichenbehaftet, -2147483648 bis 2147483647
ULONG    32 Bit, kein Vorzeichen, 0 bis 4294967295


Wie erkenne ich WDIALOG?
========================

Unterfunktion 7 von appl_getinfo() liefert in den untersten 3 Bit von ap_gout1
zurck, ob die wdlg_xx()/lbox_xx() und fnts_xx()-Funktionen vorhanden sind.

Deklaration: WORD appl_getinfo( WORD ap_gtype, WORD *ap_gout1, WORD *ap_gout2,
                                WORD *ap_gout3, WORD *ap_gout4 );
Aufruf:      ap_greturn = appl_getinfo( 7, &ap_gout1, &ap_gout2, &ap_gout3, &ap_gout4 );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        130                 appl_getinfo
contrl[1]        1                   Eintr„ge in intin
contrl[3]        0                   Eintr„ge in addrin

intin[0]         ap_gtype            Nummer der Unterfunktion (7)

Ausgaben:

contrl[2]        5                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        ap_greturn          0: Fehler 1: alles in Ordnung
intout[1]        ap_gout1            siehe Beschreibung
intout[2]        ap_gout2
intout[3]        ap_gout3
intout[4]        ap_gout4

Bits in ap_gout1:
Bit 0:           wdlg_xx()-Funktionen sind vorhanden (1)
Bit 1:           lbox_xx()-Funktionen sind vorhanden (1)
Bit 2:           fnts_xx()-Funktionen sind vorhanden (1)

Bemerkung:
Die Funktion appl_getinfo() ist nicht in allen AES-Versionen vorhanden. Um festzustellen,
ob sie vorhanden ist, sollten Sie appl_find( "?AGI" ) aufrufen. Wenn appl_find() keinen
Fehler zurckliefert, ist appl_getinfo() vorhanden. Dieses Vorgehen funktioniert auch bei
alten TOS-Versionen, da WDIALOG eine rudiment„re appl_getinfo()-Funktion zur Verfgung
stellt und appl_find() abf„ngt.


Fensterdialoge
==============


ù WINDOW DIALOG - CREATE (AES 160)

Diese Funktion fordert Speicher fr eine Dialog-Strukur an und
initialisiert sie.

Deklaration: DIALOG  *wdlg_create( HNDL_OBJ handle_exit, OBJECT *tree, void *user_data, WORD code, void *data, WORD flags );
Aufruf:      dialog = wdlg_create( handle_exit, tree, user_data, code, data, WDLG_BKGD );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        160                 wdlg_create
contrl[1]        2                   Eintr„ge in intin
contrl[3]        4                   Eintr„ge in addrin

intin[0]         code                wird handle_exit() in <clicks> bergeben
intin[1]         flags

addrin[0]        handle_exit         Zeiger auf die Service-Funktion
addrin[1]        tree                Zeiger auf den Objektbaum
addrin[2]        user_data           Zeiger auf Benutzer-Informationen
addrin[3]        data                wird handle_exit() in <data> bergeben

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       dialog              Zeiger auf die Dialog-Struktur

Beschreibung von <handle_exit>:

<handle_exit> ist der Zeiger auf eine Service-Routine, die u.a. von wdlg_evnt()
aufgerufen wird. <handle_exit> wird aufgerufen, wenn auf ein Exit- oder
Touchexit-Objekt geklickt wurde (in diesem Fall ist <obj> eine positive
Objektnummer) oder wenn ein den Dialog betreffendes Ereignis eingetreten ist
(dann ist <obj> negativ und enth„lt eine entsprechende Funktionsnummer wie
z.B. HNDL_CLSD).

Die Parameter werden ber den Stack bergeben und die Routine darf
Register d0-d2/a0-a2 ver„ndern.

Beispiel fr eine Service-Routine:

   WORD  cdecl handle_exit( DIALOG *dialog, EVNT *events, WORD obj, WORD clicks, void *data );
   {
      if ( obj < 0 )                   /* Ereignis oder Objektnummer? */
      {
                                       /* alle Ereignisse auer HNDL_CLSD */
                                       /* werden bei diesem Beispiel ignoriert */

         if ( obj == HNDL_CLSD )       /* Closer bet„tigt? */
            return( 0 );               /* beenden */


         if ( obj == HNDL_EDIT )
         {
            /* In Fensterdialogen kann es ntzlich sein, Tastenkombinationen
               mit Control in Eingabefeldern zu ignorieren, damit Shortcuts wie
               z.B. Ctrl-U, Ctrl-W oder Ctrl-Q in der Eventschleife des Programms
               abgearbeitet werden k”nnen. In diesem Fall sollte nach HNDL_EDIT
               eine 0 zurckgeliefert werden, damit die Taste nicht von objc_edit()
               bearbeitet wird.
            */
         }
      }
      else                             /* ein Objekt ist angew„hlt worden */
      {
         switch ( obj )                /* Aktionen einleiten (falls n”tig) */
         {
            case ...
              .
              .
              .
            case MY_EXIT_OBJECT: ..... return( 0 );   /* beenden */
         }
      }
      return( 1 );                     /* weitermachen */
   }

   Die Parameter haben folgende Bedeutung:

      dialog:  Zeiger auf eine Dialog-Struktur. Auf die Struktur sollte
               nicht direkt zugegriffen werden. Die wdlg_xx-Funktionen
               sollten benutzt werden!

      events:  Wenn <obj> eine Objektnummer ist (>= 0), dann zeigt
               <events> auf die EVNT-Struktur, die bei wdlg_evnt() bergeben
               wurde. Andernfalls ist <events> grunds„tzlich 0L und kann nicht
               zur Adressierung benutzt werden.

      obj:     >= 0: Objektnummer
               < 0:  Funktionsnummer (siehe unten)

      clicks:  Anzahl der Mausklicks (falls es sich bei <obj>
               um eine Objektnummer handelt)

      data:    der Inhalt h„ngt von <obj> ab

      Bedeutung von <data> abh„ngig von <obj>:

         Falls <obj> eine (positive) Objektnummer ist, wird in <data>
         die Variable <user_data> bergeben (siehe wdlg_create).
         <clicks> enth„lt die Anzahl der Mausklicks auf dieses Objekt.

         HNDL_INIT: <data> ist die bei wdlg_create bergebene Variable.
         -1          Wenn handle_exit() 0 zurckliefert, legt
                     wdlg_create() keine Dialog-Struktur an (Fehler).
                     Die Variable <code> wird in <clicks> bergeben.

         HNDL_OPEN: <data> ist die bei wdlg_open bergebene Variable.
         -5          Die Variable <code> wird in <clicks> bergeben.

         HNDL_CLSD: <data> ist <user_data>. Wenn handle_exit() 0
         -3          zurckliefert, wird der Dialog geschlossen -
                     wdlg_evnt() liefert 0 zurck.
                     <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_MOVE: <data> ist <user_data>. Wenn handle_exit() 0
         -9          zurckliefert, wird der Dialog geschlossen -
                     wdlg_evnt() liefert 0 zurck.
                     <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_TOPW: <data> ist <user_data>. Wenn handle_exit() 0
         -10         zurckliefert, wird der Dialog geschlossen -
                     wdlg_evnt() liefert 0 zurck.
                     <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_UNTP: <data> ist <user_data>. Wenn handle_exit() 0
         -11         zurckliefert, wird der Dialog geschlossen -
                     wdlg_evnt() liefert 0 zurck.
                     <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_EDIT:  <data> zeigt auf ein Wort mit dem Tastencode.
         -6          Wenn handle_exit() 1 zurckliefert, wird der
                     Tastendruck verarbeitet, bei 0 ignoriert.
                     <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_EDDN:  <data> zeigt auf ein Wort mit dem Tastencode.
         -7          <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.

         HNDL_EDCH:  <data> zeigt auf ein Wort mit der Objektnummer
         -8          des neuen Edit-Felds.

	    HNDL_MESG:	<data> ist <user_data>. Wenn handle_exit() 0
         -2          zurckliefert, wird der Dialog geschlossen -
                     wdlg_evnt() liefert 0 zurck.
	                <events> zeigt auf die bei wdlg_evnt() bergebene
                     EVNT-Struktur.
                     HNDL_MESG wird nur dann bergeben, wenn ein
                     Nachrichtencode zwischen 20 und 39 empfangen wurde,
                     der nicht mit den anderen Opcodes bearbeitet wird.
                     Wird z.B. fr die Ikonifizierung ben”tigt.

                     Achtung: Dieser Opcode ist erst ab
                              MagiC 4.5 vom 18.4.96 vorhanden.

      Von diesen Funktionsnummern mu nur auf HNDL_CLSD reagiert werden.
      Alle anderen Ereignisse k”nnen je nach Bedarf beachtet werden.

   Wenn handle_exit mit einer unbekannten Funktionsnummer in <obj> aufgerufen
   wird oder eine der obigen Funktionsnummern ignoriert werden soll, mu 1
   zurckgeliefert werden.


ù WINDOW DIALOG - OPEN (AES 161)

OPEN ”ffnet ein Fenster mit der Titelzeile <title> an der Position <x>,
<y>. Bevor wdlg_open() zum Aufrufer zurckkehrt wird noch die Service-
Routine <handle_exit> (s.o.) mit der Funktionsnummer HNDL_OPEN
aufgerufen: handle_exit( dialog, HNDL_OPEN, code, data );

Deklaration: WORD wdlg_open( DIALOG *dialog, BYTE *title, WORD kind, WORD x, WORD y, WORD code, void *data );
Aufruf:      handle = wdlg_open( dialog, title, NAME + CLOSER + MOVER, x, y, code, data );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        161                 wdlg_open
contrl[1]        4                   Eintr„ge in intin
contrl[3]        3                   Eintr„ge in addrin

intin[0]         kind                Fensterkomponenten (NAME/MOVER/CLOSER)
intin[1]         x                   x-Koordinate des Dialogs oder -1 (zentriert)
intin[2]         y                   y-Koordinate des Dialogs oder -1 (zentriert)
intin[3]         code                wird handle_exit() in <clicks> bergeben

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        title               Zeiger auf den Fensternamen oder 0L
addrin[2]        data                wird handle_exit() in <data> bergeben

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        handle              Handle des Dialog-Fensters (0: Fehler)


ù WINDOW DIALOG - CLOSE (AES 162)

Diese Funktion schliet den Fensterdialog <dialog>.

Deklaration: WORD wdlg_close( DIALOG *dialog );
Aufruf:      wdlg_close( dialog );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        162                 wdlg_close
contrl[1]        0                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù WINDOW DIALOG - DELETE (AES 163)

Diese Funktion gibt den Speicher fr einen Fensterdialog frei.

Deklaration: WORD wdlg_delete( DIALOG *dialog );
Aufruf:      wdlg_delete( dialog );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        163                 wdlg_delete
contrl[1]        0                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù WINDOW DIALOG - GET OBJECT TREE (AES 164, 0)

wdlg_get_tree() liefert die Adresse des Objektbaums und die Gr”e des
Fensters (der Arbeitsfl„che) zurck. Sofern die Dialoggr”e nicht mit
wdlg_set_size() ver„ndert wurde, entspricht die Arbeitsfl„che dem GRECT
des Wurzelobjekts.

Deklaration: WORD wdlg_get_tree( DIALOG *dialog, OBJECT **tree, GRECT *r );
Aufruf:      wdlg_get_tree( dialog, &tree, &r );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        164                 wdlg_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        3                   Eintr„ge in addrin

intin[0]         0                   wdlg_get_tree

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        tree                Zeiger auf Zeiger auf Objektbaum
addrin[2]        rect                Zeiger auf GRECT

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù WINDOW DIALOG - GET EDIT OBJECT (AES 164, 1)

Diese Funktion liefert die Nummer des aktuellen Edit-Objekts. Wenn
das Ergebnis 0 ist, dann ist momentan kein Edit-Objekt aktiv.

Deklaration: WORD wdlg_get_edit( DIALOG *dialog, WORD *cursor );
Aufruf:      edit_obj = wdlg_get_edit( dialog, &cursor );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        164                 wdlg_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         1                   wdlg_get_edit

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        2                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        edit_obj            Nummer des aktuellen Edit-Objekts
                                     (oder 0, wenn keins aktiv ist)
intout[1]        cursor              Index des Zeichens

Bemerkung:
Bei alten WDIALOG-Versionen wird <cursor> nicht zurckgeliefert. Das Binding
in WDIAL_A.S sorgt dafr, da in diesem Fall -1 eingetragen wird.


ù WINDOW DIALOG - GET USERDATA (AES 164, 2)

DIese Funktion liefert die Variable <user_data> zurck, die beim
Aufruf von wdlg_create() bergeben wurde.

Deklaration: void *wdlg_get_udata( DIALOG *dialog );
Aufruf:      user_data = wdlg_get_udata( dialog );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        164                 wdlg_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         2                   wdlg_get_udata

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       user_data           der Zeiger user_data


ù WINDOW DIALOG - GET WINDOW HANDLE (AES 164, 3)

GET WINDOW HANDLE liefert das Handle des Dialog-Fensters.

Deklaration: WORD wdlg_get_handle( DIALOG *dialog );
Aufruf:      handle = wdlg_get_handle( dialog );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        164                 wdlg_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         3                   wdlg_get_handle

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        handle              Fenster-Handle


ù WINDOW DIALOG - SET EDIT OBJECT (AES 165, 0)

SET EDIT OBJECT aktiviert ein Edit-Objekt, d.h. der Cursor wird
im Objekt <obj> gezeichnet und in einem evtl. vorher aktiven Objekt
gel”scht.

Deklaration: WORD wdlg_set_edit( DIALOG *dialog, WORD obj );
Aufruf:      edit_obj = wdlg_set_edit( dialog, new_edit_obj );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        165                 wdlg_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         0                   wdlg_set_edit
intin[1]         obj                 Nummer des neuen Edit-Objekts
                                     (oder 0, wenn keins aktiv sein soll)

addrin[0]        dialog              Zeiger auf die Dialog-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        edit_obj            Nummer des aktuellen Edit-Objekts


ù WINDOW DIALOG - SET TREE (AES 165, 1)

SET TREE stellt einen neuen Objektbaum im Dialog dar. Falls das neue Wurzelobjekt
eine andere Gr”e hat, wird die Fenstergr”e angepat. Der Fensterinhalt wird in
jedem Fall aktualisiert.

Deklaration: WORD wdlg_set_tree( DIALOG *dialog, OBJECT *new_tree );
Aufruf:      wdlg_set_tree( dialog, new_tree );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        165                 wdlg_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         1                   wdlg_set_tree

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        new_tree            Zeiger auf den neuen Objektbaum

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù WINDOW DIALOG - SET SIZE (AES 165, 2)

Mit wdlg_set_size() kann die Gr”e eines Fensterdialogs ver„ndert werden. Das
GRECT <new_size> bestimmt die neue Position und Gr”e der Arbeitsfl„che des
Fensters. SET SIZE „ndert weder Position noch Gr”e des Wurzelobjekts. Soll das
Wurzelobjekt verschoben oder vergr”ert werden, mssen die Objektausmae vor
dem Aufruf von wdlg_set_size() ge„ndert werden.

Deklaration: WORD wdlg_set_size( DIALOG *dialog, GRECT *new_size );
Aufruf:      wdlg_set_size( dialog, new_size );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        165                 wdlg_set
contrl[1]        1                   Eintr„ge in intin
contrl[2]        1                   Eintr„ge in intout
contrl[3]        2                   Eintr„ge in addrin
contrl[4]        0                   Eintr„ge in addrout

intin[0]         2                   wdlg_set_size

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        new_size            Zeiger auf GRECT

Ausgaben:

intout[0]        1

Bemerkung:
Die Buttons mssen sich immer vollst„ndig innerhalb der Arbeitsfl„che des Fensters
befinden, da form_button() nicht die Rechteckliste beachtet.
Der normale Anwendungsfall fr wdlg_set_size() sind vergr”erbare Dialoge, die
ein Sizer-Objekt in der rechten unteren Ecke enthalten.


ù WINDOW DIALOG - ICONIFY (AES 165, 3)

Mit wdlg_set_iconify() kann eine Fensterdialog ikonifiziert werden. Das
GRECT <g> bestimmt die neue Position und Gr”e des Fensters (Auenma). Im
allgemeinen wird man hier msg+4 bergeben, wenn man die Nachricht WM_ICONIFIY
erhalten hat. Genauso kann man jedoch auch ein GRECT {-1,-1,-1,-1} bergeben,
wobei MagiC die Position ermittelt.
ICONIFY „ndert Position und Gr”e des Wurzelobjekts. Da man i.a. fr
ikonifizierte Fenster einen anderen Objektbaum anzeigen m”chte, kann dieser in
<tree> bergeben werden (sonst auf NULL setzen).
šblicherweise besteht ein solcher Objektbaum lediglich aus dem Wurzelobjekt
(G_BOX) und einem Icon (G_(C)ICON). Soll das Icon (oder ein anderes Objekt)
im Fenster zentriert werden, bergibt man die Objektnummer in <obj>,
andernfalls -1. Weiterhin kann ein neuer Fenstertitel angegeben werden. Der
Aufrufer hat dabei aber selbst dafr zu sorgen, bei wdlg_set_uniconify wieder
den ursprnglichen Titel einzusetzen.

Deklaration: WORD wdlg_set_iconify( DIALOG *dialog, GRECT *g,
					char *title, OBJECT *tree, WORD obj );
Aufruf:      wdlg_set_iconify( dialog, g, title, tree, obj );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        165                 wdlg_set
contrl[1]        2                   Eintr„ge in intin
contrl[2]        1                   Eintr„ge in intout
contrl[3]        4                   Eintr„ge in addrin

intin[0]         3                   wdlg_set_iconify
intin[1]         obj                 zu zentrierendes Objekt oder -1

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        g                   Zeiger auf GRECT
addrin[2]        title               neuer Fenstertitel oder NULL
addrin[3]        tree                neuer Fensterbaum oder NULL

Ausgaben:

intout[0]        1


ù WINDOW DIALOG - UNICONIFY (AES 165, 4)

Das Gegenstck zu wdlg_set_iconify(). Das GRECT <g> bestimmt die neue
Position und Gr”e des Fensters (Auenma). Im allgemeinen wird man hier
msg+4 bergeben, wenn man die Nachricht WM_UNICONIFIY erhalten hat.
UNICONIFY „ndert Position und Gr”e des Wurzelobjekts. Da man i.a. fr
ikonifizierte Fenster einen anderen Objektbaum angezeigt hatte, kann der
ursprngliche Baum in <tree> bergeben werden (sonst auf NULL setzen).
Weiterhin kann der ursprngliche Fenstertitel angegeben werden, wenn dieser
mit wdlg_set_iconify ver„ndert worden war.

Deklaration: WORD wdlg_set_uniconify( DIALOG *dialog, GRECT *g,
					char *title, OBJECT *tree );
Aufruf:      wdlg_set_uniconify( dialog, g, title, tree );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        165                 wdlg_set
contrl[1]        1                   Eintr„ge in intin
contrl[2]        1                   Eintr„ge in intout
contrl[3]        4                   Eintr„ge in addrin

intin[0]         4                   wdlg_set_uniconify

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        g                   Zeiger auf GRECT
addrin[2]        title               neuer Fenstertitel oder NULL
addrin[3]        tree                neuer Fensterbaum oder NULL

Ausgaben:

intout[0]        1


ù WINDOW DIALOG - EVENT (AES 166)

Diese Funktion mu im Event-Loop aufgerufen werden. In dem Bitvektor
<mwhich> werden die Ereignis-Bits gel”scht, die sich auf den Fensterdialog
beziehen. Nach wdlg_evnt() kann die EVNT-Struktur von der Applikation zur
Auswertung der fr sie bestimmten Events benutzt werden. Liefert wdlg_evnt()
eine 0 zurck, mu der Fensterdialog geschlossen werden (wdlg_close()
aufrufen).

Deklaration: WORD wdlg_evnt( DIALOG *dialog, EVNT *events );
Aufruf:      cont = wdlg_evnt( dialog, &events );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        166                 wdlg_evnt
contrl[1]        0                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        events              Zeiger auf die EVNT-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        cont                0: Dialog schlieen
                                     1: alles in Ordnung

Beschreibung der EVNT-Struktur:

typedef struct
{
   WORD  mwhich;                     /* Art der Ereignisse */
   WORD  mx;                         /* x-Koordinate des Mauszeigers */
   WORD  my;                         /* y-Koordinate des Mauszeigers */
   WORD  mbutton;                    /* gedrckte Maustaste */
   WORD  kstate;                     /* Status der Sondertasten (kbshift) */
   WORD  key;                        /* Scancode der gedrckten Taste */
   WORD  mclicks;                    /* Anzahl der Mausklicks */
   WORD  reserved[9];                /* reserviert */
   WORD  msg[16];                    /* Message-Buffer */
} EVNT;

Bemerkung:
Das Iconify-Event wird nicht von wdlg_evnt() untersttzt. Wer den Iconifier bei
wdlg_open() als Fensterelement anmeldet mu daher dieses Ereignis auswerten
und selber behandeln. Das gleiche gilt, wenn man den Sizer als Element anmeldet.


ù WINDOW DIALOG - REDRAW (AES 167)

REDRAW funktioniert „hnlich wie objc_draw(). Im Gegensatz dazu wird aber
die Rechteckliste fr das Dialog-Fenster beachtet. M”chte man ein Objekt
innerhalb des Dialogs zeichnen, so sollte man immer wdlg_redraw() und
nicht objc_draw() verwenden. Vor dem Aufruf von wdlg_redraw ist genauso
wie vor und nach objc_draw() der Aufruf von wind_update() n”tig.

Deklaration: void wdlg_redraw( DIALOG *dialog, GRECT *rect, WORD obj, WORD depth );
Aufruf:      wdlg_redraw( dialog, &rect, obj, MAX_DEPTH );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        167                 wdlg_redraw
contrl[1]        2                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         obj                 Nummer des Startobjekts
intin[1]         depth               Anzahl der Ebene/Tiefe

addrin[0]        dialog              Zeiger auf die Dialog-Struktur
addrin[1]        rect                Zeiger auf begrenzendes GRECT

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout




Listboxen
=========



šbersicht der Funktionen:
------------------------

lbox_create()           Listbox anlegen, Speicher anfordern
lbox_update()           AES-Objekte aktualisieren
lbox_do()               Button behandeln
lbox_delete()           Speicher freigeben

lbox_cnt_items();       Anzahl der Listenelemente zurckliefern
lbox_get_tree();        Zeiger auf Objektbaum des Dialogs zurckgeben
lbox_get_visible() bzw.
lbox_get_avis();        Anzahl der sichtbaren Listboxelemente liefern (Slider A)
lbox_get_bvis();        Anzahl der sichtbaren Listboxelemente liefern (Slider B)
lbox_get_udata();       Zeiger auf programmeigene Daten holen
lbox_get_first() bzw.
lbox_get_afirst();      Index des ersten sichtbaren Element zurckgeben (Slider A)
lbox_get_bfirst();      Index des ersten sichtbaren Element zurckgeben (Slider B)
lbox_get_slct_idx();    Index des ersten selektierten Element ermitteln
lbox_get_items();       Zeiger auf das erste Element der Liste zurckgeben
lbox_get_item();        Zeiger auf n-tes Element zurckliefern
lbox_get_slct_item();   Zeiger auf das erste selektierte Element liefern
lbox_get_idx();         Index eines Elements ermitteln
lbox_get_bentries;      Anzahl der Elemente fr Slider B liefern

lbox_set_slider() bzw.
lbox_set_asldr();       Position des Sliders setzen (Slider A)
lbox_set_bsldr();       Position des Sliders setzen (Slider A)
lbox_set_items();       neue Elementliste setzen
lbox_free_items();      Elementliste freigeben
lbox_free_list();       Elementliste freigeben
lbox_set_bentries();    Anzahl der Elemente fr Slider B setzen
lbox_scroll_to() bzw.
lbox_ascroll_to();      Inhalt der Listbox bis zu einem bestimmten Element verschieben (Slider A)
lbox_bscroll_to();      Inhalt der Listbox bis zu einem bestimmten Element verschieben (Slider B)


Aufrufschema fr modalen Dialog:
-------------------------------

wind_update()           Schirm sperren
lbox_create()           Listbox anlegen
form_center()           Dialog zentrieren
form_dial()             Ausschnitt puffern
   .
   .
Schleife:   form_do() <----
               .           |
               .           |
            lbox_do() -----

   .
   .
Ende der Schleife (z.B. OK oder Abbruch bet„tigt)
   .
   .
evtl. lbox_get_slct_item()...
   .
   .
form_dial()             Redraw-Message versenden
wind_update()           Schirm freigeben
lbox_delete()           Speicher fr Listbox freigeben



ù LIST BOX - CREATE (AES 170)

Diese Funktion legt Speicher fr eine Listbox an und initialisiert die
Objekte, indem sie die Routine <set> fr jedes der in <objs> bergebenen
Objekte aufruft. Die Listbox wird jedoch nicht gezeichnet!
Bit 0 der Variable <flags> legt fest, ob es sich um eine horizontale (das
erste Listenelement ist links und das letzte rechts) oder vertikale (das
erste Listenelement ist oben und das letzte unten) Listbox handelt.
Unabh„ngig von dieser Hauptscrollrichtung kann die Listbox noch einen
zweiten Slider haben, wenn die Elemente selber noch gescrollt werden
sollen. Das kann z.B. bei einer vertikalen Listbox mit Textelementen, die
breiter als die Box sind, sinnvoll sein.

Deklaration: LIST_BOX *lbox_create( OBJECT *tree, SLCT_ITEM slct, SET_ITEM set, LBOX_ITEM *items, WORD visible_a, WORD first_a,
                                    WORD *ctrl_objs, WORD *objs, WORD flags, WORD pause_a, void *user_data, DIALOG *dialog,
                                    visible_b, first_b, entries_b, pause_b );
Aufruf:      box = lbox_create( tree, slct_item, set_item, item_list, 10, 0,
                                ctrl_objs, objs, lbox_flags, 20, 0L, 0L, 10, 0, 40, 5 );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        170                 lbox_create
contrl[1]        4 oder 8            Eintr„ge in intin
contrl[3]        8                   Eintr„ge in addrin

intin[0]         visible_a           Anzahl der sichtbaren Eintr„ge (Slider A)
intin[1]         first_a             Index des ersten sichtbaren Eintrags (Slider A)
intin[2]         flags               diverse Flags
intin[3]         pause_a             Verz”gerung beim Scrolling in ms (Slider A)

intin[4]         visible_b           Anzahl der sichtbaren ELemente (Slider B)
intin[5]         first_b             erstes sichtbares Element (Slider B)
intin[6]         entries_b           Anzahl der Elemente (Slider B)
intin[7]         pause_b             Verz”gerung beim Scrolling in ms (Slider B)

addrin[0]        tree                Zeiger auf den Objektbaum des Dialogs
addrin[1]        slct                Zeiger auf Auswahl-Routine
addrin[2]        set                 Zeiger auf Setz-Routine
addrin[3]        items               Zeiger auf verkettete Liste mit LBOX_ITEMs
addrin[4]        ctrl_objs           Zeiger auf ein Feld mit den Objektnummern der
                                     Buttons und Slider (5 Eintr„ge)
addrin[5]        objs                Zeiger auf ein Feld mit den Objektnummer der
                                     Listbox-Eintr„ge (<entries> Eintr„ge)
addrin[6]        user_data           Zeiger fr Applikation
addrin[7]        dialog              Zeiger auf die Fensterdialog-Struktur oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       box                 Zeiger auf die Listbox-Struktur oder 0L


Sowohl <slct> als auch <set> sind Funktionen, deren Parameter auf dem Stack
bergeben werden. Die Funktionen drfen Register d0-d2/a0-a2 ver„ndern.

<slct> ist ein Zeiger auf eine Auswahl-Routine, die immer dann aufgerufen wird,
wenn ein Eintrag selektiert oder deselektiert wurde:

   typedef  void  (cdecl *SLCT_ITEM)( LIST_BOX *box, OBJECT *tree, struct _lbox_item *item,
                                      void *user_data, WORD obj_index, WORD last_state );

   <box>       zeigt auf die Listbox-Struktur
   <tree>      zeigt auf den Objektbaum des Dialogs
   <item>      zeigt auf die LBOX_ITEM-Struktur des ausgew„hlten Eintrags
   <user_data> ist der bei lbox_create() bergebene Zeiger
   <obj_index> ist die Nummer des angew„hlten Objekts. Bei einem Doppelklick ist
               „hnlich wie nach form_do() das oberste Bit gesetzt.
               Wenn <obj_index> 0 ist, heit das, da dem Eintrag kein Objekt
               zugeordnet ist; er ist nicht sichtbar. Normalerweise ist das nur der
               Fall, wenn gescrollt wird und durch Auswahl eines neuen Objekts die
               (mittlerweile nicht mehr sichtbare) Selektion gel”scht werden mu.
   <last_state>   ist der vorhergehende Status des Objekts. <last_state> kann auch
               den gleichen Wert wie <item->selected> haben. In diesem Fall kann die
               Funktion <slct> normalerweise sofort verlassen werden.

   <slct> wird auch dann aufgerufen, wenn die Selektion eines Objekts aufgehoben wird!
   Die Variable <selected> aus der LBOX_ITEM-Struktur enth„lt beim Aufruf von <slct>
   bereits den neuen Status des Objekts.

<set> zeigt auf die Funktion, die den Inhalt eines LBOX_ITEMs in ein Objekt
des Listbox-Dialogs eintragen soll:

   typedef  WORD  (cdecl *SET_ITEM)( LIST_BOX *box, OBJECT *tree, struct _lbox_item *item, WORD obj_index,
                                     void *user_data, GRECT *rect, WORD first );

   <box>       zeigt auf die Listbox-Struktur
   <tree>      zeigt auf den Objektbaum des Dialogs
   <item>      zeigt auf die LBOX_ITEM-Struktur des zu setzenden Eintrags
   <obj_index> ist die Nummer des zu setzenden Objekts
   <user_data> ist der bei lbox_create() bergebene Zeiger
   <rect>      ist der Zeiger auf das GRECT fr das Objekt Redraw oder 0L
   <first>     enth„lt die Nummer des ersten sichtbaren Elements fr Slider B

   Bei einer Listbox, die nur Text-Strings enth„lt, ist <set> typischerweise
   eine Funktion, die ein String, auf den die LBOX_ITEM-Struktur verweist, in
   das Objekt <index> kopiert.

   <rect> ist 0L, wenn ein Redraw der Dialogbox durchgefhrt wird oder wenn
   lbox_update() aufgerufen wurde.

   <rect> ist nicht 0L, wenn der Anwender ein Objekt selektiert oder deselektiert
   hat, und zeigt auf das GRECT fr den Redraw. Der Rckgabewert  von <set> ist
   die Nummer des Startobjekts fr objc_draw()/wdlg_redraw().
   Bei Eintr„gen in der Listbox, die aus mehreren Objekten bestehen, ist es
   manchmal sinnvoll bei Selektion/Deselektion eines Objekts das Redraw-Rechteck
   zu verkleinern oder das Startobjekt zu „ndern, um unn”tige Zeichenoperationen
   und unn”tiges Geflacker zu vermeiden.

   In den meisten F„llen rufen die Listbox-Routinen nach <set> die Funktion
   objc_draw()/wdlg_redraw() auf, um den ge„nderten Inhalt anzuzeigen.

   <first> enth„lt die Nummer des ersten sichtbaren Elements fr Slider B, wenn
   die Listbox 2 Slider hat. Bei einer (vertikalen) Listbox mit Text-Strings und
   zwei Slidern gibt man z.B. beim  Aufruf von lbox_create() die Anzahl der
   sichtbaren Zeichen in <visible_b>, die gesamte Stringl„nge in <entries_b>
   und den Index des ersten sichtbaren Zeichens in <first_b> an. Wird der
   Text horizontal gescrollt, wird <set> fr alle sichtbaren Strings aufgerufen
   und der Bereich neugezeichnet bzw. verschoben.
   Wenn die Listbox nur einen Slider hat, ist <first> immer 0.

<items> zeigt auf das erste Element einer Liste aus LBOX_ITEMs. Die fr
die Elemente verwendete Struktur mu als erstes Element einen Zeiger auf den
Nachfolger enthalten (next) und als zweites ein Wort fr den Zustand (selected):

   typedef struct _lbox_item
   {
      struct _lbox_item *next;   /* Zeiger auf den n„chsten Eintrag in der Liste */
      WORD  selected;            /* gibt an, ob das Objekt selektiert ist */

      WORD  data1;               /* Daten fr das Programm... */
      void  *data2;
      void  *data3;

   } LBOX_ITEM;

   Die Struktur kann aber, wenn bei den Aufrufen entsprechend gecastet wird, durchaus
   wie das folgende Beispiel aussehen:

   typedef struct
   {
      void  *next;
      WORD  selected;

      ... ab hier nach Belieben der Applikation...

   } LB_EXAMPLE;


<ctrl_objs> ist ein Zeiger auf ein Feld mit 5 bzw. 9 Eintr„gen, das die Nummern der
Kontroll-Objekte (Buttons) enth„lt:

   ctrl_objs[0]:  Objektnummer der BOX oder IBOX, die die eigentlichen Listbox-
                  Objekt enth„lt.
   ctrl_objs[1]:  Objektnummer des Buttons fr das Scrolling nach oben bzw. links.
   ctrl_objs[2]:  Objektnummer des Buttons fr das Scrolling nach unten bzw. rechts.
   ctrl_objs[3]:  Objektnummer der Box des Slider-Hintergrunds.
   ctrl_objs[4]:  Objektnummer der Slider-Box.

   Falls die Listbox 2 Slider hat, enhalten ctrl_objs[5-8] die Nummern der Objekte
   von Slider B:

   ctrl_objs[5]:  Objektnummer des Buttons fr das Scrolling nach oben bzw. links.
   ctrl_objs[6]:  Objektnummer des Buttons fr das Scrolling nach unten bzw. rechts.
   ctrl_objs[7]:  Objektnummer der Box des Slider-Hintergrunds.
   ctrl_objs[8]:  Objektnummer der Slider-Box.

   Die Buttons, der Slider und der Slider-Hintergrund sollten TOUCHEXIT-Status haben.
   Wenn die Listbox nur die Buttons und keinen Slider hat, mssen ctrl_objs[3/4 bzw. 7/8]
   -1 enthalten.

<objs> ist ein Feld mit <entries> Eintr„gen, das die Nummern der Listbox-
Objekte enth„lt (die Objekte sind normalerweise Kinder von ctrl_objs[0]).

   objs[0]:             Nummer des ersten Objekts
        .
        .
        .
   objs[entries - 1]:   Nummer des letzten Objekts

   Die Objekt sollten normalerweise TOUCHEXIT-Status haben.


Das Wort <flags> beeinflut das Verhalten der Listbox:

Bit|Zustand|Beschreibung
---|-------|---------------------------------------------------------------------
 0 |   0   | Die Box scrollt horizontal.
   |   1   | Die Box scrollt vertikal.
   |       |
 1 |   0   | kein automatisches Scrolling
   |   1   | Es wird autmatisch gescrollt, sobald bei gedrckter Maustaste der
   |       | Mauszeiger ber das erste oder letzte Element hinausbewegt wird.
   |       |
 2 |   0   | Die Auswahl-Routine wird erst aufgerufen, wenn das automatische
   |       | Scrolling aufgeh”rt hat, d.h. sie wird fr den letzten selektierten
   |       | Eintrag aufgerufen.
   |   1   | Beim automatischen Scrolling wird die Auswahl-Routine beim Scrolling
   |       | fr jeden selektieren Eintrag aufgerufen.
   |       |
 3 |   0   | Bei Bewegung des Sliders wird ein Rahmen verschoben (graf_slidebox),
   |       | die Listbox wird erst nach Loslassen der Maustaste aktualisiert.
   |   1   | Der Slider ist ein Real-Time-Slider.
   |       |
 4 |   0   | Mehrfachselektion innerhalb der Listbox ist m”glich.
   |   1   | Es kann nur ein Element selektiert werden.
   |       |
 5 |   0   | Mehrfachselektion ist ohne Shift-Taste m”glich.
   |   1   | Mehrfachselektion ist nur mit Shift-Taste m”glich.
   |       |
 6 |   0   | Bei Selektion ist der Status immer SELECTED
   |   1   | Bei Selektion wird der Status immer gewechselt
   |       |
 7 |   0   | Listbox hat nur einen Slider
   |   1   | Listbox hat zwei Slider

#define  LBOX_VERT   1        /* Listbox mit vertikalem Slider */
#define  LBOX_AUTO   2        /* Auto-Scrolling */
#define  LBOX_AUTOSLCT  4     /* automatische Darstellung beim Auto-Scrolling */
#define  LBOX_REAL   8        /* Real-Time-Slider */
#define  LBOX_SNGL   16       /* nur ein anw„hlbarer Eintrag */
#define  LBOX_SHFT   32       /* Mehrfachselektionen mit Shift */
#define  LBOX_TOGGLE 64       /* Status eines Eintrags bei Selektion wechseln */
#define  LBOX_2SLDRS 128      /* 2 Slider untersttzen */

Das Flag LBOX_SNGL kann auch mit LBOX_SHFT oder LBOX_TOGGLE kombiniert werden, um
in einer Listbox mit nur einem anw„hlbaren Eintrag auch Deselektion zu erm”glichen.
LBOX_SNGL + LBOX_SHFT bedeutet, da der selektierte Eintrag durch Klick mit gedrckter
Shift-Taste deselektiert werden kann. LBOX_SNGL + LBOX_TOGGLE bewirkt bei einem
Klick auf einen selektierten Eintrag dessen Deselektion.

Der Zeiger <items> kann auch 0L sein, wenn die Listbox noch leer ist und keine
Eintr„ge enth„lt.


ù LIST BOX - UPDATE (AES 171)

UPDATE aktualisiert den Inhalt der Listbox-Objekte, d.h. die Funktion
<set> (s.o.) wird fr jedes der Objekte aufgerufen. Wenn <rect> nicht 0L
ist, wird es als Zeiger auf ein GRECT betrachtet, das fr den Redraw der
Listbox benutzt wird. Andernfalls werden die Objekte nur aktualisiert,
aber nicht gezeichnet.

Deklaration: void lbox_update( LIST_BOX *box, GRECT *rect );
Aufruf:      lbox_update( box, &redraw_rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        171                 lbox_update
contrl[1]        0                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        rect                Zeiger auf das Redraw-GRECT oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - DO (AES 172)

DO reagiert auf die Bet„tigung eines Buttons. Diese Funktion sollte
nach form_do() aufgerufen werden (oder von der Service-Funktion des
Fensterdialogs). Wenn einer der Eintr„ge der Listbox mit einem
Doppelklick ausgew„hlt wurde, liefert lbox_do() -1 zurck. Der Dialog
sollte dann geschlossen, so als w„re der OK-Button bet„tigt worden.

lbox_do() erkennt Doppelklicks am gesetzten obersten Bit der Objektnummer
<obj> (Objektnummer | 0x8000). Bei der zurckgelieferten Objektnummer <slct_obj>
ist das oberste Bit in jedem Fall gel”scht.

Deklaration: WORD lbox_do( LIST_BOX *box, WORD obj );
Aufruf:      slct_obj = lbox_do( box, obj );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        172                 lbox_do
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         obj                 Nummer des ausgew„hlten Objekts

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        slct_obj            Nummer des ausgew„hlten Objekts oder -1,
                                     wenn ein Doppelklick auf einen Eintrag erfolgte


ù LIST BOX - DELETE (AES 173)

DELETE gibt den Speicher fr die Listbox wieder frei.

Deklaration: WORD lbox_delete( LIST_BOX *box );
Aufruf:      lbox_delete( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        173                 lbox_delete
contrl[1]        0                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù LIST BOX - COUNT ITEMS (AES 174, 0)

COUNT ITEMS z„hlt die Elemente der verketteten Liste.

Deklaration: WORD lbox_cnt_items( LIST_BOX *box );
Aufruf:      no = lbox_cnt_items( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         0                   lbox_cnt_items

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        no                  Anzahl der Elemente in der Liste


ù LIST BOX - GET TREE (AES 174, 1)

GET TREE liefert den Zeiger auf den Objektbaum der Dialogbox zurck.

Deklaration: OBJECT  *lbox_get_tree( LIST_BOX *box );
Aufruf:      tree = lbox_get_tree( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         1                   lbox_get_tree

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       tree                Zeiger auf den Objektbaum des Dialogs


ù LIST BOX - GET NUMBER OF VISIBLE ITEMS, SLIDER A (AES 174, 2)

GET SIZE liefert die Anzahl der sichtbaren Eintr„ge zurck.

Deklaration: WORD lbox_get_visible( LIST_BOX *box );
Aufruf:      entries = lbox_get_visble( box ); oder entries = lbox_get_avisb( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         2                   lbox_get_size

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        entries             Anzahl der sichtbaren Eintr„ge


ù LIST BOX - GET USER DATA (AES 174, 3)

...liefert den Zeiger <user_data> zurck.

Deklaration: void *lbox_get_udata( LIST_BOX *box );
Aufruf:      user_data = lbox_get_udata( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         3                   lbox_get_udata

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       user_data


ù LIST BOX - GET FIRST VISIBLE ITEM, SLIDER A (AES 174, 4)

GET FIRST liefert den Index des ersten sichtbaren Elements zurck.

Deklaration: WORD lbox_get_first( LIST_BOX *box );
Aufruf:      first = lbox_get_first( box ); oder first = lbox_get_afirst( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         4                   lbox_get_first

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        first               Index des ersten sichtbaren Eintrags


ù LIST BOX - GET INDEX of SELECTED ITEM (AES 174, 5)

Der Index des ersten selektierten Eintrags wird ermittelt. Ist kein
Eintrag in der Listbox selektiert, wird -1 zurckgegeben.

Deklaration: WORD lbox_get_slct_idx( LIST_BOX *box );
Aufruf:      index = lbox_get_slct_idx( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         5                   lbox_get_slct_idx

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        index               Index des ausgew„hlten Eintrags


ù LIST BOX - GET ITEMS (AES 174, 6)

GET ITEMS gibt einen Zeiger auf die Liste der LBOX_ITEMs zurck.

Deklaration: LBOX_ITEM  *lbox_get_items( LIST_BOX *box );
Aufruf:      items = lbox_get_items( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         6                   lbox_get_items

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       items               Zeiger auf verkettete Liste


ù LIST BOX - GET ITEM (AES 174, 7)

GET ITEM liefert einen Zeiger auf das Element <n> der Liste.

Deklaration: LBOX_ITEM  *lbox_get_item( LIST_BOX *box, WORD n );
Aufruf:      item = lbox_get_item( box, n );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        2                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         7                   lbox_get_item
intin[1]         n                   Index des Elements

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       item                Zeiger auf Element n oder 0L


ù LIST BOX - GET SELECTED ITEM (AES 174, 8)

GET SELECTED ITEM liefert einen Zeiger auf das erste ausgew„hlte
Element der Liste.

Deklaration: LBOX_ITEM *lbox_get_slct_item( LIST_BOX *box );
Aufruf:      item = lbox_get_slct_item( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         8                   lbox_get_slct_item

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       item                Zeiger auf Element n oder 0L


ù LIST BOX - GET ITEM INDEX (AES 174, 9)

Diese Funktion liefert den Index <n> des Elements <item> zurck.
Ist <item> kein Element der Liste, ist der Rckgabewert -1.

Deklaration: WORD lbox_get_idx( LBOX_ITEM *items, LBOX_ITEM *search );
Aufruf:      n = lbox_get_idx( items, search );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         9                   lbox_get_idx

addrin[0]        items               Zeiger auf das erste Element der Liste
addrin[1]        search              Zeiger auf das zu suchende Element

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        n                   Index des Elements


ù LIST BOX - GET NUMBER OF VISIBLE ITEMS, SLIDER B (AES 174, 10)

GET SIZE liefert die Anzahl der sichtbaren Eintr„ge zurck.

Deklaration: WORD lbox_get_bvis( LIST_BOX *box );
Aufruf:      entries = lbox_get_bvis( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         10                  lbox_get_bvis

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        entries             Anzahl der sichtbaren Eintr„ge


ù LIST BOX - GET NUMBER OF ITEMS, SLIDER B (AES 174, 11)

... liefert die Anzahl der Elemente fr Slider B zurck.

Deklaration: WORD lbox_get_bentries( LIST_BOX *box );
Aufruf:      entries = lbox_get_bentries( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         11                  lbox_get_bentrs

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        entries             Anzahl der Elemente


ù LIST BOX - GET FIRST VISIBLE ITEM, SLIDER B (AES 174, 12)

GET FIRST liefert den Index des ersten sichtbaren Elements zurck (Slider B!).

Deklaration: WORD lbox_get_bfirst( LIST_BOX *box );
Aufruf:      first = lbox_get_bfirst( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        174                 lbox_get
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         12                  lbox_get_bfirst

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        first               Index des ersten sichtbaren Eintrags


ù LIST BOX - SET SLIDER A (AES 175, 0)

Diese Funktion positioniert den Slider A und zeichnet ihn innerhalb
des Redraw-Rechtecks <rect>. Der Inhalt der Listbox wird nicht
aktualisiert, d.h. evtl. mu lbox_update() aufgerufen werden. Ist
<rect> 0L, dann wird nur die Position der Slider-Objekte ge„ndert,
aber die Objekte werden nicht gezeichnet.

Deklaration: void lbox_set_slider( LIST_BOX *box, WORD first, GRECT *rect );
Aufruf:      lbox_set_slider( box, first, &rect ); oder lbox_set_asldr( box, first, &rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         0                   lbox_set_slider
intin[1]         first               Index des ersten sichtbaren Eintrags

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        rect                Zeiger auf Redraw-Rechteck oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - SET NEW ITEM LIST (AES 175, 1)

Diese funktion setzt eine neue Liste mit Listbox-Eintr„gen. Die alte
Liste mu vorher mit lbox_free_items() freigegeben werden.

Deklaration: void lbox_set_items( LIST_BOX *box, LBOX_ITEM *items );
Aufruf:      lbox_set_items( box, items );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         1                   lbox_set_items

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        items

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

Der Zeiger <items> kann auch 0L sein, wenn die Listbox leer ist und keine
Eintr„ge enth„lt.


ù LIST BOX - FREE ITEMS (AES 175, 2)

Diese Funktion gibt den Speicher fr die verkettete Liste aus LBOX_ITEMs
zurck. Voraussetzung dafr ist, das fr jedes Element der Liste Speicher mit
Malloc() angefordert wurde.
Wurde fr die LBOX_ITEMs eine eigene Speicherverwaltung benutzt (z.B. die
C-Standard-Funktionen), mu auch eine eigene Funktion zum Freigeben des
Speichers aufgerufen werden.

Deklaration: void lbox_free_items( LIST_BOX *box );
Aufruf:      lbox_free_items( box );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         2                   lbox_free_items

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - FREE ITEM LIST (AES 175, 3)

Diese Funktion arbeitet genauso wie lbox_free_items(). Im Gegensatz dazu
wird lbox_free_list() aber mit dem Zeiger auf das erste LBOX_ITEM der
Liste aufgerufen.

Deklaration: void lbox_free_list( LBOX_ITEM *items );
Aufruf:      lbox_free_list( items );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         3                   lbox_free_list

addrin[0]        items               Zeiger auf verkettete Liste mit LBOX_ITEMs

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - SCROLL TO, SLIDER A (AES 175, 4)

Diese Funktion positioniert den Slider A und aktualisiert den Inhalt
der Listbox. <box_rect> ist das Redraw-Rechteck fr die Listbox
und <slider_rect> ist das Redraw-Rechteck fr den Slider.

SCROLL TO funktioniert prinzipiell wie ein Aufruf von lbox_set_slider()
mit anschlieendem lbox_update(); wenn m”glich wird aber gescrollt, um nur
wenig neu zeichnen zu mssen. Sollte sich die Elementliste der Listbox
ge„ndert haben, darf lbox_scroll_to() daher nicht benutzt werden.

Deklaration: void lbox_scroll_to( LIST_BOX *box, WORD first, GRECT *box_rect, GRECT *slider_rect );
Aufruf:      lbox_scroll_to( box, first, &box_rect, &slider_rect );
        oder lbox_ascroll_to( box, first, &box_rect, &slider_rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        3                   Eintr„ge in addrin

intin[0]         4                   lbox_scroll_to
intin[1]         first               Index des ersten sichtbaren Eintrags

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        box_rect            Zeiger auf Redraw-Rechteck oder 0L
addrin[2]        slider_rect         Zeiger auf Redraw-Rechteck oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - SET SLIDER B (AES 175, 5)

Diese Funktion positioniert den Slider B und zeichnet ihn innerhalb
des Redraw-Rechtecks <rect>. Der Inhalt der Listbox wird nicht
aktualisiert, d.h. evtl. mu lbox_update() aufgerufen werden. Ist
<rect> 0L, dann wird nur die Position der Slider-Objekte ge„ndert,
aber die Objekte werden nicht gezeichnet.

Deklaration: void lbox_set_bsldr( LIST_BOX *box, WORD first, GRECT *rect );
Aufruf:      lbox_set_bsldr( box, first, &rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         5                   lbox_set_bsldr
intin[1]         first               Index des ersten sichtbaren Eintrags

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        rect                Zeiger auf Redraw-Rechteck oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - SET NUMBER OF ENTRIES, SLIDER B (AES 175, 6)

Diese Funktion setzt die Anzahl der Element (der Unterteilungen)
fr Slider B.

Deklaration: void lbox_set_bentries( LIST_BOX *box, WORD entries );
Aufruf:      lbox_set_bentries( box, entries );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         7                   lbox_set_bentries
intin[1]         entries             Anzahl der Elemente

addrin[0]        box                 Zeiger auf die Listbox-Struktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù LIST BOX - SCROLL TO, SLIDER B (AES 175, 7)

Diese Funktion positioniert den Slider B und aktualisiert den Inhalt
der Listbox. <box_rect> ist das Redraw-Rechteck fr die Listbox
und <slider_rect> ist das Redraw-Rechteck fr den Slider.

SCROLL TO funktioniert prinzipiell wie ein Aufruf von lbox_set_bsldr()
mit anschlieendem lbox_update(); wenn m”glich wird aber gescrollt, um nur
wenig neu zeichnen zu mssen. Sollte sich die Elementliste der Listbox
ge„ndert haben, darf lbox_bscroll_to() daher nicht benutzt werden.

Deklaration: void lbox_bscroll_to( LIST_BOX *box, WORD first, GRECT *box_rect, GRECT *slider_rect );
Aufruf:      lbox_bscroll_to( box, first, &box_rect, &slider_rect );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        175                 lbox_set
contrl[1]        2                   Eintr„ge in intin
contrl[3]        3                   Eintr„ge in addrin

intin[0]         7                   lbox_bscroll_to
intin[1]         first               Index des ersten sichtbaren Eintrags

addrin[0]        box                 Zeiger auf die Listbox-Struktur
addrin[1]        box_rect            Zeiger auf Redraw-Rechteck oder 0L
addrin[2]        slider_rect         Zeiger auf Redraw-Rechteck oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout




Zeichensatzauswahl
==================



šbersicht der Funktionen:
------------------------

fnts_create()           Zeichensatzauswahl initialisieren, Speicher anfordern
fnts_open()             Auswahldialog im Fenster ”ffnen
fnts_close()            Fenster schlieen
fnts_delete()           Speicher freigeben

fnts_get_no_styles()    Anzahl der Stile einer Fontfamilie ermitteln
fnts_get_style()        ID des n-ten Stil einer Familie liefern
fnts_get_name()         Namen eines Fonts zurckliefern

fnts_add()              eigene Fonts zur Auswahl hinzufgen (z.B. Signum-Fonts)
fnts_remove()           eigene Fonts aus der Liste entfernen

fnts_evnt()             Events fr Dialog im Fenster behandeln

fnts_do()               modalen Dialog anzeigen



Aufrufschema fr Auswahldialog im Fenster:
-----------------------------------------

Programmstart:             fnts_create()
   .
   .
   .
Aufruf der Fontauswahl:    fnts_open()
   .
   .
   .
Event-Loop:                fnts_evnt()
   .                             .
   .                             .
   ......evtl. fnts_get_no_styles()/fnts_get_style()/... (je nach Status der Checkboxen)
   .                             .
   .                             .
Schlieen der Fontauswahl: fnts_close()
   .
   .
   .
Programmende:              fnts_delete()



Aufrufschema fr modalen Auswahldialog:
---------------------------------------

Programmstart:             fnts_create()
   .
   .
   .
Aufruf der Fontauswahl:    fnts_do()
   .
   .
   ......evtl. fnts_get_no_styles()/fnts_get_style()/... (je nach Status der Checkboxen)
   .
   .
Programmende:              fnts_delete()



Funktionsbeschreibung:
----------------------

ù FONT SELECTOR - CREATE (AES 180)

Diese Funktion initialisiert den Fontselektor. Wenn <no_fonts> 0 ist, wird
vst_load_fonts() mit <vdi_handle> aufgerufen. Andernfalls wird davon ausgegangen,
da <no_fonts> die Anzahl aller ber <vdi_handle> verfgbaren Fonts ist, d.h. die
Anzahl aller Systemfonts (work_out[10] bei v_opnvwk()/vq_extnd()) plus die Anzahl
der nachgeladenen Fonts (Rckgabewert von vst_load_fonts()).

Deklaration: FNT_DIALOG *fnts_create( WORD vdi_handle, WORD no_fonts, WORD font_flags,
                                      WORD dialog_flags, BYTE *sample, BYTE *opt_button );
Aufruf:      fnt_dialog = fnts_create( vdi_handle, 0, 0xf, "The quick brown..." );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        180                 fnts_create
contrl[1]        4                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         vdi_handle          Handle der zu benutzenden Workstation
intin[1]         no_fonts            Anzahl der verfgbaren Fonts oder 0, wenn
                                     vst_load_fonts() aufgerufen werden soll
intin[2]         font_flags          Art der anzuzeigenden Fonts
intin[3]         dialog_flags        Aussehen des Dialogs

addrin[0]        sample              Zeiger auf String fr den Beispieltext
addrin[1]        opt_button          Zeiger auf String fr optionalen Button oder 0L

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        1                   Eintr„ge in addrout

addrout[0]       fnt_dialog          Zeiger auf Verwaltungsstruktur

Beschreibung von <font_flags>:

#define  FNTS_BTMP   1               /* Bitmapfonts anzeigen */
#define  FNTS_OUTL   2               /* Vektorfonts anzeigen */
#define  FNTS_MONO   4               /* „quidistante Fonts anzeigen */
#define  FNTS_PROP   8               /* proportionale Fonts anzeigen */

Beschreibung von <dialog_flags>:

#define  FNTS_3D     1               /* Auswahl im 3D-Look anzeigen */

Bemerkung:
Da diese Funktion je nach Systemkonfiguration durchaus 1 Sekunde (evtl. auch mehr)
ben”tigt, sollte man sie am Programmstart aufrufen und nicht erst direkt vor der
Anzeige der Fontauswahl aufrufen.


*************** Bitte beachten: *****************
Der Fontselektor ver„ndert die Attribute der mit <vdi_handle> bezeichneten Workstation.
Wenn man die bei fnts_create() bergebene Workstation noch fr andere Zwecke benutzen m”chte,
mssen auf jeden Fall die Attribute vorher gesetzt werden, da sie evtl. zwischenzeitlich vom
Fontselektor ge„ndert wurden.


ù FONT SELECTOR - DELETE (AES 181)

Diese Funktion gibt den Speicher fr die Zeichensaztauswahl frei. Ist <vdi_handle>
ungleich 0, wird vst_unload_fonts() aufgerufen.

Deklaration: WORD fnts_delete( FNT_DIALOG *fnt_dialog, WORD vdi_handle );
Aufruf:      fnts_delete( fnt_dialog, vdi_handle );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        181                 fnts_delete
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         vdi_handle          Handle der Workstation oder 0, wenn
                                     vst_unload_fonts() nicht aufgerufen werden soll

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù FONT SELECTOR - OPEN WINDOW (AES 182)

OPEN WINDOW ”ffnet einen Fensterdialog mit dem Fontselektor. Das Handle
des Fensters wird zurckgeliefert, wenn kein Fehler aufgetreten ist. Im
Fehlerfall ist der Rckgabewert 0.

Deklaration: WORD fnts_open( FNT_DIALOG *fnt_dialog, WORD button_flags, WORD x, WORD y, LONG id, LONG pt, LONG ratio );
Aufruf:      whdl = fnts_open( fnt_dialog, 0x3f0f, -1, -1, id, pt, ratio );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        182                 fnts_open
contrl[1]        9                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         button_flags        Flags fr unterstzte Buttons
intin[1]         x                   x-Koordinate des Fensters oder -1 (zentriert)
intin[2]         y                   y-Koordinate des Fensters oder -1 (zentriert)
intin[3/4]       id                  ID des Fonts
intin[5/6]       pt                  H”he in 1/65536 Punkten
intin[7/8]       ratio               Verh„ltnis Breite/H”he in 1/65536

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        whdl                Handle des Fensters oder 0 (Fehler)

Beschreibung von <button_flags>:

#define  FNTS_SNAME     0x01         /* Checkbox fr die Namen selektieren */
#define  FNTS_SSTYLE    0x02         /* Checkbox fr die Stile selektieren */
#define  FNTS_SSIZE     0x04         /* Checkbox fr die H”he selektieren */
#define  FNTS_SRATIO    0x08         /* Checkbox fr das Verh„ltnis Breite/H”he selektieren */

#define  FNTS_CHNAME    0x0100       /* Checkbox fr die Namen anzeigen */
#define  FNTS_CHSTYLE   0x0200       /* Checkbox fr die Stile anzeigen */
#define  FNTS_CHSIZE    0x0400       /* Checkbox fr die H”he anzeigen */
#define  FNTS_CHRATIO   0x0800       /* Checkbox fr das Verh„ltnis Breite/H”he anzeigen */
#define  FNTS_RATIO     0x1000       /* Verh„ltnis Breite/H”he einstellbar */
#define  FNTS_BSET      0x2000       /* Button "setzen" anw„hlbar */
#define  FNTS_BMARK     0x4000       /* Button "markieren" anw„hlbar */



ù FONT SELECTOR - CLOSE WINDOW (AES 183)

CLOSE WINDOW schliet das Fenster der Zeichensatzauswahl.

Deklaration: WORD fnts_close( FNT_DIALOG *fnt_dialog );
Aufruf:      fnts_close( *fnt_dialog );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        183                 fnts_close
contrl[1]        0                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        1


ù FONT SELECTOR - GET NUMBER OF STYLES (AES 184, 0)

Diese Funktion liefert zurck, wie viele Fonts zur gleichen Familie wie
der Font <id> geh”ren, d.h. wieviel Stile die Familie hat. <id> ist die
ID eines Fonts dieser Familie, die z.B. bei fnts_evnt() zurckgeliefert
worden sein kann.

Deklaration: WORD fnts_get_no_styles( FNT_DIALOG *fnt_dialog, LONG id );
Aufruf:      no_fonts = WORD  fnts_get_no_styles( fnt_dialog, id );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        184                 fnts_get
contrl[1]        3                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         0                   fnts_get_no_styles
intin[1/2]       id                  ID eines Fonts der Familie

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        no_fonts            Anzahl der zur Familie geh”renden Stile


ù FONT SELECTOR - GET STYLE ID (AES 184, 1)

GET STYLE ID liefert die ID des <index>-ten Fonts der Familie zurck, zu
der auch der Font <id> geh”rt. <index> mu eine Zahl zwischen 1 und
dem Ergebnis von fnts_get_no_styles() sein.

Deklaration: LONG fnts_get_style( FNT_DIALOG *fnt_dialog, LONG id, WORD index );
Aufruf:      style_id = fnts_get_style( fnt_dialog, id, index );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        184                 fnts_get
contrl[1]        4                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         1                   fnts_get_style
intin[1/2]       id                  ID eines Fonts der Familie
intin[3]         index               Index innerhalb der Familie

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        2                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0/1]      style_id            ID des <index>-ten Fonts der Familie


ù FONT SELECTOR - GET FONT NAME (AES 184, 2)

GET FONT NAME liefert fr den Font <id> den vollst„ndigen Namen, den
Familiennamen und den Stilnamen zurck.

Deklaration: WORD fnts_get_name( FNT_DIALOG *fnt_dialog, LONG id,
                                 BYTE *full_name, BYTE *family_name, BYTE *style_name );
Aufruf:      ret = fnts_get_name( FNT_DIALOG *fnt_dialog, id, &full_name, &family_name, &style_name );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        184                 fnts_get
contrl[1]        3                   Eintr„ge in intin
contrl[3]        4                   Eintr„ge in addrin

intin[0]         2                   fnts_get_name
intin[1/2]       id                  ID des Fonts

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur
addrin[1]        full_name           Zeiger auf vollst„ndigen Namen oder 0L
addrin[2]        family_name         Zeiger auf den Familiennamen oder 0L
addrin[3]        style_name          Zeiger auf den Stilnamen oder 0L

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        ret                 0: Fehler 1: alles in Ordnung


ù FONT SELECTOR - GET FONT INFO (AES 184, 3)

Deklaration: WORD fnts_get_info( FNT_DIALOG *fnt_dialog, LONG id, WORD *mono, WORD *outline );
Aufruf:      index = fnts_get_info( fnt_dialog, id, &mono, &outline );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        184                 fnts_get
contrl[1]        3                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         3                   fnts_get_info
intin[1/2]       id                  ID des Fonts

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        3                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        index               0: Fehler >0: Index fr vqt_name()
intout[1]        mono                Flag fr quidistanz
intout[2]        outline             Flag fr Vektorfont


ù FONT SELECTOR - ADD USER FONTS (AES 185, 0)

Mit ADD USER FONTS kann ein Programm eigene Fonts zu den von der
Zeichensatzauswahl angezeigten Fonts hinzufgen. Die ID dieser Fonts
mu gr”er als 65535 sein. Auerdem mu im Strukturelement <display>
der Zeiger auf eine Anzeigefunktion eingetragen werden.

Deklaration: WORD fnts_add( FNT_DIALOG *fnt_dialog, FNTS_ITEM *user_fonts );
Aufruf:      ret = WORD fnts_add( fnt_dialog, user_fonts );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        185                 fnts_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

intin[0]         0                   fnts_add

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur
addrin[1]        user_fonts          Zeiger auf programmeigene Fonts

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        ret                 0: Fehler 1: alles in Ordnung

Deklaration von FNTS_ITEM:

typedef struct _fnts_item
{
   struct   _fnts_item  *next;       /* Zeiger auf den n„chsten Font oder 0L (Ende der Liste) */
   UTXT_FN  display;                 /* Zeiger auf die Anzeige-Funktion fr applikationseigene Fonts */
   LONG     id;                      /* ID des Fonts, >= 65536 fr applikationseigene Fonts */
   WORD     index;                   /* mu 0 sein, da kein VDI-Font */
   BYTE     mono;                    /* Flag fr „quidistante Fonts */
   BYTE     outline;                 /* Flag fr Vektorfont */
   WORD     npts;                    /* Anzahl der vordefinierten Punkth”hen */
   BYTE     *full_name;              /* Zeiger auf den vollst„ndigen Namen */
   BYTE     *family_name;            /* Zeiger auf den Familiennamen */
   BYTE     *style_name;             /* Zeiger auf den Stilnamen */
   BYTE     *pts;                    /* Zeiger auf Feld mit Punkth”hen */
   LONG     reserved[4];             /* reserviert, mssen 0 sein */
} FNTS_ITEM;

typedef  void  (cdecl *UTXT_FN)( WORD x, WORD y, WORD *clip_rect, LONG id, LONG pt, LONG ratio, BYTE *string );


ù FONT SELECTOR - REMOVE USER FONTS (AES 185, 1)

REMOVE USER FONTS entfernt die mit ADD FONTS angemeldeten Fonts aus der Verkettung.
Sind eigene programmeigene Fonts angemeldet, mu fnts_remove() vor fnts_delete()
aufgerufen werden.

Deklaration: void fnts_remove( FNT_DIALOG *fnt_dialog );
Aufruf:      fnts_remove( fnt_dialog );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        185                 fnts_set
contrl[1]        1                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         1                   fnts_remove

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        0                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout


ù FONT SELECTOR - UPDATE WINDOW (AES 185, 2)

Deklaration: WORD fnts_update( FNT_DIALOG *fnt_dialog, WORD button_flags, LONG id, LONG pt, LONG ratio );
Aufruf:      result = fnts_update( fnt_dialog, 0x3f0f, id, pt, ratio );


Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        185                 fnts_set
contrl[1]        8                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]			  2						 fnts_update
intin[1]         button_flags        Flags fr unterstzte Buttons
intin[2/3]       id                  ID des Fonts
intin[4/5]       pt                  H”he in 1/65536 Punkten
intin[6/7]       ratio               Verh„ltnis Breite/H”he in 1/65536

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        1                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        result

Beschreibung von <result>:

-1: Funktion nicht vorhanden
0:	 Fehler (nicht gengend Speicher), der Fontselektor mu dann mit
	 fnts_close() geschlossen werden.
1:	 alles in Ordnung

Beschreibung von <button_flags>:

#define  FNTS_SNAME     0x01         /* Checkbox fr die Namen selektieren */
#define  FNTS_SSTYLE    0x02         /* Checkbox fr die Stile selektieren */
#define  FNTS_SSIZE     0x04         /* Checkbox fr die H”he selektieren */
#define  FNTS_SRATIO    0x08         /* Checkbox fr das Verh„ltnis Breite/H”he selektieren */

#define  FNTS_CHNAME    0x0100       /* Checkbox fr die Namen anzeigen */
#define  FNTS_CHSTYLE   0x0200       /* Checkbox fr die Stile anzeigen */
#define  FNTS_CHSIZE    0x0400       /* Checkbox fr die H”he anzeigen */
#define  FNTS_CHRATIO   0x0800       /* Checkbox fr das Verh„ltnis Breite/H”he anzeigen */
#define  FNTS_RATIO     0x1000       /* Verh„ltnis Breite/H”he einstellbar */
#define  FNTS_BSET      0x2000       /* Button "setzen" anw„hlbar */
#define  FNTS_BMARK     0x4000       /* Button "markieren" anw„hlbar */

Bemerkung:
In „lteren Versionen von WDIALOG war diese Funktion nicht vorhanden.
Das Binding sorgt dafr, da in diesem Fall -1 in intout[0] zurckgeliefert
wird.


ù FONT SELECTOR - HANDLE EVENT (AES 186)

HANDLE EVENT wertet die bergebene EVNT-Struktur aus und ruft intern
wdlg_evnt() auf. Wenn einer der Exit-Buttons bet„tigt wurde ("Abbruch",
"OK", "setzen", "markieren" oder "Optionen") liefert die Funktion eine 0
zurck und in button wird zurckgeliefert, welche Knopf der Anwender
ausgew„hlt hat.

Deklaration: WORD fnts_evnt( FNT_DIALOG *fnt_dialog, EVNT *events, WORD *button, WORD *check_boxes, LONG *id, LONG *pt, LONG *ratio );
Aufruf:      cont = fnts_evnt( fnt_dialog, &events, &button, &check_boxes, &id, &pt, &ratio );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        186                 fnts_evnt
contrl[1]        0                   Eintr„ge in intin
contrl[3]        2                   Eintr„ge in addrin

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur
addrin[1]        events              Zeiger auf EVNT-Struktur

Ausgaben:

contrl[2]        9                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        cont                0: Exit-Button angew„hlt
                                     1: nichts passsiert
intout[1]        button              angew„hlter Button (oder 0)
intout[2]        check_boxes         Status der Checkboxen
intout[3/4]      id                  ID des ausgew„hlten Fonts
intout[5/6]      pt                  H”he in 1/65536 Punkten
intout[7/8]      ratio               Verh„ltnis Breite/H”he

Beschreibung von <check_boxes>:

#define  FNTS_SNAME     0x01         /* Checkbox fr die Namen selektiert */
#define  FNTS_SSTYLE    0x02         /* Checkbox fr die Stile selektiert */
#define  FNTS_SSIZE     0x04         /* Checkbox fr die H”he selektiert */
#define  FNTS_SRATIO    0x08         /* Checkbox fr das Verh„ltnis Breite/H”he selektiert */


ù FONT SELECTOR - DO (AES 187)

fnts_do() ist das Gegenstck zu fnts_opne()/fnts_evnt()/fnts_close(). Diese
Funktion ”ffnet einen modalen Dialog und kehrt erst zum Aufrufer zurck,
wenn einer der Exit-Buttons bet„tigt wurde ("Abbruch", "OK", "setzen",
"markieren" oder "Optionen").

Deklaration: WORD fnts_do( FNT_DIALOG *fnt_dialog, WORD button_flags,
                           LONG id_in, LONG pt_in, LONG ratio_in,
                           WORD *check_boxes, LONG *id, LONG *pt, LONG *ratio );
Aufruf:      button = fnts_do( fnt_dialog, button_flags, id_in, pt_in, ratio_in,
                               &check_boxes, &id, &pt, &ratio );

Variable         Belegung            Bedeutung
Eingaben:

contrl[0]        187                 fnts_do
contrl[1]        7                   Eintr„ge in intin
contrl[3]        1                   Eintr„ge in addrin

intin[0]         button_flags
intin[1/2]       id_in
intin[3/4]       pt_in
intin[5/6]       ratio_in

addrin[0]        fnt_dialog          Zeiger auf Verwaltungsstruktur

Ausgaben:

contrl[2]        8                   Eintr„ge in intout
contrl[4]        0                   Eintr„ge in addrout

intout[0]        button              angew„hlter Button (oder 0)
intout[1]        check_boxes         Status der Checkboxen
intout[2/3]      id                  ID des ausgew„hlten Fonts
intout[4/5]      pt                  H”he in 1/65536 Punkten
intout[6/7]      ratio               Verh„ltnis Breite/H”he


--------------------------------------------------------------------------
Funktions- und Strukturdefinitionen: WDIAL_G.H, LISTBX_G.H, FNTS_G.H

--------------------------------------------------------------------------
Assembler-Bindings fr Pure C: WDIAL_A.S

--------------------------------------------------------------------------

Konvertierung erweiterter Objekttypen
=====================================

Das Modul ADAPTRSC.C stellt einige ntzliche Funktionen zur Verfgung:

- Es liefert Informationen ber die vorhandenen AES-Funktionen zurck.
- Es pat RSC-Dateien an die (unsch”ne) MultiTOS-Eigenart an, 3D-Objekte
  ber die in der OBJECT-Struktur eingetragenen Ausmae zu vergr”ern.
- Es nimmt (soweit automatisch m”glich) RSC-Anpassungen von 3D nach 2D vor.
- Es generiert, wenn notwendig, automatisch Userdef-Funktionen fr
  erweiterte MagiC 3-Objekte: šberschrift mit Unterstreichung,
  Gruppenrahmen, Radiobutton und Checkbox (mit nachfolgendem String).

Das Modul belegt ca. 2 kB Speicher.

--------------------------------------------------------------------------
Beispiel-Quelltexte: FNT_SMPLC, FNT_SMP2.C, WDLG_SMP.C, XOBJ_SMP.C,
                     ADAPTRSC.C

