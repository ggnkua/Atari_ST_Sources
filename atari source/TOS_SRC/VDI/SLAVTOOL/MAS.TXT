	9Der MAS-68K Makroasssembler auf einen Blick

A	Overview
A.1	 C Interface
A.1.a	  Expressions and Labels
A.1.b	  cdecl and pascal
A.1.c	  Features
A.2	 Calling MAS
A.3	 MAS Options
A.4	 Error Messages
A.4.a	  Command Line Errors
A.4.b	  Assembly Code Errors
A.4.c	  Assembler Errors
A.4.d	  Internal Errors
A.5	 Assembler Listings

B	Elements of Assembly Language
B.1	 Character Set
B.2	 Comments
B.3	 Tokens
B.4	 Register Specification
B.5	 Labels
B.6	 Size Specification
B.7	 Integer Constants
B.8	 Addressing Modes
B.9	 String Constants
B.10	 Position Modifiers
B.11	 Expressions and Operators
B.11.a	  Unary Operators
B.11.b	  Binary Operators
B.12	 Floating Point Expressions
B.12.a	  Floating Point Constants
B.12.b	  Hex FP Constants
B.12.c	  FP Operators
B.13	 Operator Precedence

C	Instruction Set
C.1	 Transfer Instructions
C.2	 Arithmetic Instructions
C.3	 Logical Instructions
C.4	 Bit Instructions
C.5	 Shift and Rotate Instructions
C.6	 Program Structure Instructions
C.7	 Floating Point Instructions

D	Assembler Directives
D.1	 EQU
D.2	 SET
D.3	 =
D.4	 REG
D.5	 DC
D.6	 DCB
D.7	 ASCII
D.8	 ASCIIL
D.9	 ASCIIZ
D.10	 DS
D.11	 ORG
D.12	 *=
D.13	 ALIGN
D.14	 EVEN
D.15	 TEXT
D.16	 DATA
D.17	 COMM
D.18	 BSS
D.19	 OFFSET
D.20	 LCOMM
D.21	 GLOBL
D.22	 XREF
D.23	 XDEF
D.24	 ALINE
D.25	 FLINE
D.26	 MC68000
D.27	 MC68010
D.28	 MC68020
D.29	 MC68030
D.30	 MC68851
D.31	 MC68881
D.32	 SUPER
D.33	 USER
D.34	 INCLUDE
D.35	 PRINT
D.36	 TTL
D.37	 PAGE
D.38	 LIST
D.39	 NOLIST
D.40	 IFCC
D.41	 ELSE
D.42	 ENDIF
D.43	 ENDC
D.44	 END
D.45	 MACRO
D.46	 REPT
D.47	 ENDM
D.48	 EXITM
D.49	 LOCAL

E	Macros
E.1	 Definition
E.2	 Parameters
E.3	 Parameter Substitution
E.4	 Calling
E.5	 Recursion
E.6	 Nesting
E.7	 Redefinition

F	Optimization
F.1	 Expressions
F.2	 Instructions
F.3	 Addressing Modes
F.4	 Branching

G	Definitions

A	Assembler Overview
   Einfhrung in den Assembler und die Assemblerprogrammierung

=================================================================
A.1	C interface
=================================================================
Mit  Assembler  bezeichnet  man  eine  maschinenorientierte  Pro-
grammiersprache. Allgemein wird damit jedoch  auch  ein  Programm
bezeichnet, mit dem ein vorliegender Quelltext  einer  Assembler-
sprache  in  die  Maschinensprache  eines  jeweiligen  Prozessors
bersetzt wird.

Verschiedene Prozessoren besitzen verschiedene S„tze an  Befehlen
die den Befehlsvorrat des jeweiligen Computers  ausmachen. Diesen
Befehlsvorrat  bezeichnet man  als  Assemblersprache.  Assembler-
sprachen unterscheiden sich von den jeweiligen  Maschinensprachen
lediglich  dadurch,  da  anstelle  des  fr  den  Menschen  kaum
verst„ndlichen Bin„rcodes  mnemonische  Abkrzungen  fr Befehle,
Operanden und Adressen verwendet werden.

A.1.a	Expressions and Labels
-----------------------------------------------------------------
Vorteile von Assembler-Programmen  sind  geringer  Speicherplatz-
bedarf und in schnellen Laufzeiten. Ein wesentlicher Nachteil von
in   Assembler  geschriebenen    Programmen   ist   jedoch   ihre
Abh„ngigkeit  von  der zugrundeliegenden Hardware. Die Portierung
von Programmen von System zu  System  ist,  wenn  berhaupt,  nur
m”glich unter der Vorraussetzung, da dem neuen  Zielsystem  eine
„hnliche Hardware zugrundeliegt.

Assembler-Programme werden  haupts„chlich  fr sehr maschinennahe
Aufgaben,  wie  z.B.  Treiber  und Betriebssysteme, erstellt. Die
Einbindung von Assembler-Programmen in Turbo C Programme sind mit
Hilfe   des   MAS-68K  Makroassemblers   leicht    m”glich.   Bei
Einbindungen  ist  vor  allem auf die jeweils gew„hlte Parameter-
schnittstelle zu achten.  Turbo C  bergibt, falls nichts anderes
ber Compiler Optionen  spezifiziert  wurde, Parameter  ber  die
Register d0 - d2  und a0 - a1,  alle weiten Parameter  werden auf
dem Stack bergeben.

A.1.b	cdecl und pascal
-----------------------------------------------------------------
Der Atari ST Serie liegt der MC680x0 Prozessor zugrunde.  Das 'x'
in MC680x0 deutet an, da es sich bei diesem  Prozessor  um  eine
ganze 'Familie handelt. Das heit es gibt verschiedene  Versionen
des MC68000, die sich in  ihrer  Leistungsf„higkeit  zwar  unter-
cheiden, jedoch fr Programme  weitgehend  kompatibel  sind.  Der
MC68000 besitzt nur eine Untermenge des  gesamten  Befehlsvorrats
der auf heutigen MC680x0 Prozessoren vorhanden  ist.   Der  Makro
Assembler MAS-68K kennt jedoch den gesamten Befehlssatz  bis  hin
zum MC68030 und ist so fr zuknftige Entwicklungen gut gerstet.

A.1.c	Der  MAS-68K  Makro  Assembler  bietet  eine  breites  
	Leistungs-spektrum:
-----------------------------------------------------------------
- Untersttzung der Prozessoren MC68000/08, MC68010/12, MC68020
  und MC68030
- Untersttzung der Coprozessoren MC68851 und MC68881/82
- Erzeugung relozierbaren Codes
- Komplexe Ausdrcke
- Fliekomma-Ausdrcke
- Bedingte ( Conditional ) Assemblierung durch Direktiven
- Include-Dateien
- Makros
- Spracherweiterungen
- Codeoptimierung

=================================================================
A.2	Calling MAS
=================================================================
Der Assembler wird  mit  der  folgenden  Befehlszeile aufgerufen:

MAS [Optionen] Quelle[.Ext] ...

Quelle[.Ext] ist der Name der  Quelldatei  mit  einem  optionalen
Suffix .EXT. Wenn kein Suffix angegeben wird,  wird das Suffix .S
angenommen. Die relozierbare Object-Datei wird  normalerweise als
Datei Quelle.O geschrieben.  Andere  Namen  fr die Ausgangsdatei
k”nnen mit dem Schalter -O zugewiesen werden. MAS-68K  akzeptiert
eine Reihe von weiteren Schaltern mit deren Hilfe der Assemblier-
prozess ber die Befehlszeile bzw. ber eine Projektdatei  ge-
steuert werden kann.

=================================================================
A.3	Assembler Options
=================================================================
Schalter    Beschreibung
-----------------------------------------------------------------

-1         Dieser  Schalter  erm”glicht den Gebrauch des  MC68010
           Befehlssatzes.
           In    der Voreinstellung akzeptiert der Assembler  nur
           die MC68000 und MC68010 Opcodes.

-2         Dieser Schalter erm”glicht den  Gebrauch  des  MC68020
           Befehlssatzes und der  erweiterten  Adressierungsarten
           ( Extended Addressing Modes ).

-3         Dieser Schalter erm”glicht  den  Gebrauch  des MC68030
           Befehlssatzes und  der erweiterten  Adressierungsarten
           ( Extended Addressing Modes ).

-5[Id]     Dieser Schalter erm”glicht den  Gebrauch  des  MC68851
           PMMU Befehlssatzes.  Der optionale  Parameter  Id gibt
           die Identit„t ( 0 - 7 ) des Coprozessors an.  Die Vor-
           einstellung ist 0 ( Null ).

-8[Id]     Dieser Schalter erm”glicht den Gebrauch des MC68881/82
           FPU Befehlssatzes. Der optionale Parameter Id gibt die
           Identit„t ( 0 - 7 ) des Coprozessors an.  Die  Vorein-
           stellung ist 1 ( Eins ).

-S         Dieser Schalter erm”glicht den Gebrauch  von  privile-
           gierten Befehlen ( Privileged Instructions ).  In  der
           Voreinstellung werden nur nicht privilegierte  Befehle
           akzeptiert.

-N         Dieser Schalter  deaktiviert  den  Optimierer von MAS.
           In  der  Voreinstellung  arbeitet  der  Assembler  mit
           Optimierung.

-U         Dieser Schalter bestimmt die Behandlung  undefinierter
           Symbole.  Wenn er gesetzt ist, behandelt der Assembler
           alle undefinierten Symbole als externe Referenzen.  In
           der Voreinstellung wird fr jedes undefinierte  Symbol
           eine Fehlermeldung ausgegeben.

-O Object  Der relozierbare Object-Code wird in  eine  Datei  mit
           dem  Namen  Object  geschrieben.   Wenn   kein  Suffix
           angegeben wird,  wird das Suffix .O angenommen. In der
           Voreinstellung schreibt der Assembler den Code in eine
           Datei Quelle.O.

-V         Wenn dieser Schalter gesetzt ist,  gibt  der Assembler
           zus„tzliche Informationen ber  den Assemblierungspro-
           zess aus.

-P         Der Assembler gibt ein Listing aus.  Mit  dem  zus„tz-
           lichen Parameter >Listing  am  Ende  der  Befehlszeile
           k”nnen Sie die Ausgabe in  eine Datei  mit  dem  Namen
           Listing umleiten.

-X         Entspricht -P; das Listing wird mit zus„tzliche Cross-
           Reference-Informationen versehen.

-A         Mit diesem Schalter  wird  vollst„ndiges Macro Tracing
           erm”glicht. Wenn er gesetzt ist, wird jede expandierte
           Makrozeile im  Listing  aufgefhrt.   In  der  Vorein-
           stellung werden nur die Zeilen aufgefhrt,   die  Code
           erzeugen.

-M         Mit     diesem    Schalter  wird  das   Macro  Tracing
           unterdrckt.    Wenn  er  gesetzt ist,   werden  keine
           expandierten Makrozeilen im  Listing  aufgefhrt.  Nur
           der vom Makro erzeugte Code wird gelistet.

-F         Mit diesem Schalter wird das False  Condition  Listing
           deaktiviert. Wenn er gesetzt ist,  werden  alle Zeilen
           innerhalb  eines  If - Else - Endif  Blocks,  die  die
           Bedingung False erfllen, im Listing  unterdrckt.  In
           der Voreinstellung werden alle Zeilen gelistet.

-C         Mit  diesem  Schalter  wird  das  Listen  von Include-
           Dateien deaktiviert. Wenn er gesetzt ist,  werden alle
           Zeilen im Bereich einer Include-Anweisung  im  Listing
           unterdrckt. In  der  Voreinstellung  werden  Include-
           Dateien gelistet.


-----------------------------------------------------------------

Sofern  Optionen  keine weiteren Argumente verlangen, k”nnen auch
mehrere Schalter zusammengefat werden.   Beispielsweise  ist -UP
gleichbedeutend mit -U -P.  Die  Schalter  k”nnen  in  beliebiger
Reihenfolge vor oder nach der Quelldatei  aufgefhrt  werden.  Es
darf lediglich eine Quelldatei angegeben werden.

Wenn der Assembler ohne  oder  mit fehlerhaften Argumenten aufge-
rufen wird, wird eine Hilfstext ausgegeben.

Beispiele:
----------

MAS TEST

Dieser Befehl assembliert TEST.S  und  erzeugt  die  Object-Datei
TEST.O. Der Optimierer ist  aktiviert  und  alle  Fehlermeldungen
werden auf  dem  Bildschirm  ausgegeben.   Es  werden  nur  nicht
privilegierte MC68000 Befehle akzeptiert.

MAS -U -N -O SAMPLE TEST

Dieser Befehl  assembliert  TEST.S  und  erzeugt die Object-Datei
SAMPLE.O. Der Optimierer wird nicht  bentzt,  alle undefinierten
Symbole   werden  als   externe   Referenzen  behandelt und  alle
Fehlermeldungen werden auf dem Bildschirm ausgegeben.  Es  werden
nur nicht privilegierte 68000 Befehle akzeptiert.

MAS -1PM TEST.M68 >TEST.LST

Dieser  Befehl  assembliert  TEST.M68  und  erzeugt  die  Object-
Datei TEST.O. Der Optimierer ist aktiviert,  der (Non-Privileged)
MC68010 Befehlssatz ist gew„hlt und ein Listing ohne  expandierte
Makrozeilen wird erzeugt und in die Datei TEST.LST geschrieben.

MAS -XS -82 FLOAT -O FLOAT2 >FLOAT2.LST

Dieser Befehl assembliert FLOAT.S und  erzeugt  die  Object-Datei
FLOAT2.O.  Der  Optimierer  ist  aktiviert und der ( Privileged )
MC68881/882 Befehlssatz mit dem Coprozessor  68882  ist  gew„hlt.
Ein  Cross-Reference-Listing  wird  erzeugt  und  in  die   Datei
FLOAT2.LST geschrieben.

MAS-68K arbeitet normalerweise mit zwei Durchl„ufen.  W„hrend des
ersten Laufs wird kein  Code  generiert.  Die  Segmentgr”e  wird
definiert, die  Symboltabelle  angelegt  und  alle  Verzweigungs-
befehle werden intern abgespeichert.  Am  Ende  des ersten Durch-
laufs  wird  das  Ausma  der Programmstruktur-Befehle   bestimmt.
Im zweiten Durchlauf  wird  auf  der  Basis  der  im  ersten Lauf
gewonnenen Informationen der Code generiert.  Der  erzeugte  Code
wird  in  die  Object-Datei   geschrieben.   MAS   bentzt  keine
tempor„ren Dateien.

Wenn  der  Optimierer  aktiviert  ist,  wird  unter Umst„nden ein
weiterer  Lauf  zwischen  dem   ersten  und   zweiten   Durchlauf
eingeschoben. Dieser Zwischenlauf kann erforderlich werden, falls
sich die Werte  einiger  Symbole  aufgrund  der  Optimierung  der
Verzweigungen „ndern.

=================================================================
A.4	Assembler Error Messages
=================================================================
Die  Fehlermeldungen  sind  unterteilt   in   vier   verschiedene
Kategorien die in folgenden Abschnitten beschrieben werden:

A.4.a	Command Line Errors
-----------------------------------------------------------------
Fehlermeldungen  nach  Eingabe  der Befehlszeile informieren ber
ungltige oder unvollst„ndige  Argumente.  Die Assemblierung wird
abgebrochen.

*** Invalid Coprocessor Id 'Id'
Der optionale Parameter nach den Schaltern  -5 oder -8  mu  eine
Ziffer im Bereich 0 ( Null ) bis 9 sein.

*** Invalid option 'Option' Missing option character
Auf  ein  Minuszeichen ( - ) in der Befehlszeile mu   ein  gltiger
Schalter ( Buchstabe ) folgen.

*** Missing '-O' argument
Auf den Schalter -O mu immer ein gltiges Argument folgen.

*** Missing source file name
More than one source file name specified
In  der Befehlszeile mu eine Quelldatei angegeben werden. Es ist
nur ein Dateiname zul„ssig.

A.4.b	Assembly Code Errors
-----------------------------------------------------------------
Fehlermeldungen w„hrend der Assemblierung  zeigen Fehler  in  der
Assembler-Quelldatei an. Wenn der Schalter  -P  (oder -X) gesetzt
ist, werden die Fehler im Listing  nach  der  fehlerhaften  Zeile
eingetragen. Die Assemblierung wird nicht abgebrochen.  Wenn  der
Schalter -P (oder -X) nicht gesetzt ist,  werden  Fehlermeldungen
w„hrend der Assemblierung folgendermaen dargestellt:

Quelle_Dateiname, #Zeilennummer: Meldung_Text

*** Addressing mode for MC68020 only
Um die erweiterten Adressierungsarten  des  MC68020  bentzen  zu
k”nnen,  mu der MC68020-Befehlssatz gew„hlt werden.

*** Address register required
Die gew„hlte Adressierungsart  erfordert  ein  Adressregister als
Argument.

*** Argument not allowed
Die angegebene Direktive darf kein Argument haben.

*** Backward assignment to location counter
Die  ORG-Direktive  bzw.  *=  erlauben   nur   vorw„rtsgerichtete
Zuordnungen zum Positionsz„hler ( Location Counter).

*** Code generation in this segment not allowed
Im BSS-Segment bzw. im von einer OFFSET-Direktive angesprochenen
Bereich  darf  kein  Code  erzeugt  werden.  Es  sind  nur Label-
Definitionen und DS-Direktiven zugelassen.

*** Code not aligned
Der  durch die gerade bearbeitete Zeile erzeugte Code mu an eine
Word-Grenze angepat werden. Hier sollte zuvor eine EVEN-Deklara-
tion verwendet werden.

*** Constant too long
Der  Wert  einer numerischen oder String-Konstanten berschreitet
den Speicherbereich eines Longwords.

*** Displacement out of range
Das Displacement einer angegebenen Adressierungsart pat nicht in
ein Byte oder ein Word. Dieser Fehler tritt nicht auf,  wenn  die
erweiterten ( MC68020 ) Adressierungsarten gew„hlt wurden.

*** Division by zero
Es wurde versucht, eine Division durch Null auszufhren.

*** Duplicate global symbols:   Label ...
Dieser  Fehler  kann nur auftreten, wenn das Format der erzeugten
Object-Datei  die  L„nge  von Label-Namen begrenzt. Der Assembler
selbst hat intern keine L„ngenbegrenzung fr  Labels.  Wenn  zwei
unterschiedliche Namen dasselbe Pr„fix haben,  wird  keine  Label
redefined Meldung ausgegeben,  aber  in  der  Object-Datei werden
diese Labels unter gleichen Namen angelegt. Falls  sich nun beide
Namen auf globale oder externe Symbole beziehen, ger„t der Linker
aus dem Tritt.   Daher  werden  unter  dieser  Fehlermeldung alle
Label-Namen aufgefhrt, die dieses Problem hervorrufen wrden.

*** (Warning) Duplicate register in register list
In einer Registerliste wird ein Register  zweimal aufgefhrt. Der
Assembler ignoriert dieses Register.

*** Expression must be defined during pass 1
In  der  gerade  bearbeiteten Zeile ist eine fehlerhafte Forward-
oder Extern-Referenz.

*** Expression too complicated
In einer Befehlsfolge sind zu viele verschachtelte Klammerebenen.
Die  maximal  zul„ssige  Anzahl  der  Klammerebenen h„ngt von der
Gr”e des zur Verfgung stehenden Stacks ab.

*** Immediate data out of range
Die Immediate Daten passen nicht in ein Byte oder ein Word.

*** Index register must be data or address register
*** Index register scale must be 1,2,4 or 8
*** Index register size must be Word or Longword
Der   angegebene   Registertyp   ist   als  Indexregister   nicht
zugelassen.

*** Invalid control character in input line
In  der  gerade bearbeiteten Zeile befindet sich ein Zeichen, das
nicht im ASCII-Zeichensatz enthalten ist.

*** Invalid Conditional directive
Eine ELSE- oder ENDIF-Direktive  auerhalb  des  Bereichs  einer
bedingten IFcc-Direktive wurde gefunden.

*** Invalid digit
In  einer  numerischen  Konstanten  wurde  ein  illegales Zeichen
gefunden.

*** Invalid instruction argument(s)
Die Syntax des Befehls und seine Argumente sind korrekt, aber  es
gibt keinen Opcode fr die vorliegende Kombination von Argumenten
( Adressierungsarten ).

*** Invalid macro directive
Eine  LOCAL-, ENDM- oder  EXITM-Direktive auerhalb des Bereichs
einer Makrodefinition wurde gefunden.

*** Invalid '*/'
Ein '*/' auerhalb eines Kommentars wurde gefunden.

*** Label not allowed for this directive
Vor den  meisten  Direktiven  darf  weder  ein  Label  noch  eine
Labelliste stehen.

*** Label redefined
Ein Label wurde zweimal definiert.

*** Line overflow
Eine Eingabezeile enth„lt mehr als 512 Zeichen.

*** Macro name redefines opcode or directive
Befehle und Direktiven sind als Makronamen nicht zugelassen.

*** Missing argument
Die  angegebene  Direktive verlangt mehr Argumente als  vorhanden
sind.

*** Missing 'endif'
Die bedingten Direktiven sind nicht korrekt verschachtelt.  Diese
Fehlermeldung wird nur am Ende der Quelldatei ausgegeben.

*** Missing 'endm'
Makrodefinitionen sind nicht korrekt verschachtelt. Diese Fehler-
meldung wird nur am Ende der Quelldatei ausgegeben.

*** Missing '(' Missing ')'     Missing '''     Missing '"'
Es fehlt das angegebene Begrenzungszeichen.

*** Missing '*/'
Kommentare sind nicht korrekt verschachtelt. Diese  Fehlermeldung
wird nur am Ende der Quelldatei ausgegeben.

*** Opcode for 68010 only
*** Opcode for 68020 only
*** Opcode for 68030 only
*** Opcode for 68851 only
*** Opcode for 68881 only
Der entsprechende Befehlssatz mu  gew„hlt sein, um den angegebe-
nen Befehl verwenden zu k”nnen.

*** Operand size not allowed
Der Syntax des Befehls und seine Argumente sind korrekt,  aber es
gibt keinen Opcode fr die angegebene Operandengr”e.

*** Phase error
Der Assembler kommt im ersten und im zweiten Durchlauf zu  unter-
chiedlichen Ergebnissen hinsichtlich Segmentgr”en oder dem  Wert
eines Labels. Dieser Fehler wird h„ufig  durch  eine  fehlerhafte
IF1 oder IF2 Direktive verursacht.

*** Privileged instruction
Der privilegierte Befehlssatz mu gew„hlt sein,  um den angegebe-
nen Befehl verwenden zu k”nnen.

*** Relative address out of range
Die Verzweigung  l„t  sich   nicht  in   einem  Byte  oder  Word
darstellen.

*** Relocation error
Im  vorliegenden  Kontext   ist  der   Typ   einer  relozierbaren
Expression  oder  Subexpression  ( absolut, relativ oder extern )
nicht zugelassen.

*** (Warning) Size specification not allowed
Fr den vorliegenden Befehl darf keine  Operandengr”e  angegeben
werden. Die angegebene Gr”e wird vom Assembler ignoriert.

*** Syntax error in argument(s)
Der Befehl- oder die Direktive ist korrekt,  aber  der  Assembler
versteht die Liste der Argumente nicht.

*** Syntax error in expression
Der Ausdruck enth„lt einen Syntaxfehler.

*** Syntax error in input line
Der Assembler kann mit der Eingabezeile nichts anfangen.

*** Syntax error in register list
Die Registerliste enth„lt einen Fehler.

*** (Warning) Tab character in string
In  einem  String  wurde  ein  Tab  ( Hex 09 )  gefunden.  Dieses
Zeichen wird vom Assembler korrekt  interpretiert,  ist  aber  im
Listing der Quelle nicht sichtbar.

*** Undefined symbols:  Label ...
Alle nach der Meldung aufgefhrten Labels werden verwendet,  sind
aber fr diese  Assemblierung  nicht  definiert  oder  als extern
deklariert. Wenn der  Schalter -U  in  der  Befehlszeile  gesetzt
wird, werden diese Labels automatisch als extern  deklariert  und
das Auftreten dieses Fehlers verhindert.

*** Unknown mnemonic
Ein  Bezeichner  wurde gefunden, der weder eine gltige Direktive
noch ein Befehl oder ein Makro-Name ist.

*** Unknown size spezification
Nach einem Punkt wurde ein Bezeichner  gefunden,  der  keine  der
gltigen Gr”en-Spezifikationen darstellt.

*** Value not allowed
Im vorliegenden Kontext ist der Wert eines Ausdrucks  nicht zuge-
lassen.

A.4.c	Assembler Errors
----------------------------------------------------------------
Schwerwiegende  Fehler  sind nicht korrigierbare Fehler  bei z.B.
Datei- Ein- und -Ausgabeoperationen  oder  Speicherberlauf.  Die
Assemblierung wird abgebrochen.  Die  Fehlermeldungen  werden  in
einem der folgenden Formate dargestellt:

Quelle_Dateiname, #Zeilennummer: Meldung_Text   Meldung_Text

*** Cannot close output file
Das  Betriebssystem  meldet  einen  Fehler  beim   Schlieen  der
Ausgangsdatei.    Dieser Fehler sollte normalerweise nicht   auf-
treten.

*** Cannot create output file
Das Betriebssystem  meldet einen Fehler beim Anlegen der Ausgabe-
datei. Das Verzeichnis ist voll, nicht erreichbar oder eine  alte
Datei desselben Namens kann nicht gel”scht werden.

*** Cannot open include file Name
Der Assembler ist nicht in der Lage,  im  Rahmen  einer  INCLUDE-
Direktive die Include-Datei zu ”ffnen.   In  den  meisten  F„llen
existiert die Datei nicht.

*** Cannot open input file name
Die in  der  Befehlszeile   angegebene  Eingabedatei  kann  nicht
ge”ffnet werden. In den meisten F„llen existiert die Datei nicht.

*** Out of memory
Der  Speicher  reicht  nicht zum dynamischen Puffern der Symbole,
Makros und  der  Informationen zur Optimierung der Verzweigungen.
Die Eingabedatei sollte in kleinere Dateien  zerlegt  werden, die
separat zu assemblieren sind. Der Speicherbedarf  des  Assemblers
l„t  sich auch verringern, indem der Optimierer deaktiviert wird
( -N ) oder  indem  Listings  ohne  Cross-Reference-Informationen
erzeugt werden ( Schalter -P anstelle von -X ).

*** Seek error on output file
Das Betriebssystem meldet einen Fehler w„hrend eines Suchvorgangs
in  der  Ausgabedatei.  Dieser  Fehler sollte normalerweise nicht
auftauchen.

*** Sorry, cannot include during macro expansion
Ein Macro Body darf  keine  INCLUDE-Direktive  enthalten.  Dieser
Fehler  wird  w„hrend  der  Abarbeitung   eines   solchen  Makros
angezeigt.

*** Too many nested include files
Es sind mehr als 10 Include-Dateien verschachtelt.  Dieser Fehler
kann   auch   durch  eine  Rekursion  in  einer INCLUDE-Direktive
verursacht werden.

*** Too many nested macro calls ( possibly infinite recursion )
Es sind mehr als 256 Makroaufrufe verschachtelt.  Es  k”nnte auch
eine   fehlerhafte   oder   fehlende  Abbruchbedingung  in  einem
rekursiven Makro vorliegen.

*** Write error on output file
Das Betriebssystem meldet einen Fehler w„hrend des Schreibens  in
die Ausgangsdatei. Die Zieldiskette ist m”glicherweise voll.

A.4.d	Internal Errors
-----------------------------------------------------------------
Interne Fehler sollten niemals auftreten.  Bitte  wenden Sie sich
an  den  Hersteller,  wenn  Sie  eine   derartige   Fehlermeldung
erhalten. Heben Sie die Dateien auf,  mit denen gearbeitet wurde.
Die Ausgabe interner Fehlermeldungen erfolgt grunds„tzlich in der
folgenden Form:

Internal error at module Modul_Name: Meldung_Text

=================================================================
A.5	Assembler Listings
=================================================================
Wenn einer der Schalter -P oder -X gesetzt ist,  erzeugt  MAS-68K
ein Listing, das auf dem Bildschirm ausgegeben wird. Ein  Listing
hat folgendes Format:

Zeilennummer Inc Adresse Code Mac Quelltextzeile

- Zeilennummer ist die fortlaufende Nummer der Zeile im  Listing.

- Inc ist  ein  Punkt ( . ), wenn   gerade   eine  Include-Datei
  bearbeitet wird, ansonsten eine Leerstelle.

- Adresse  ist  die  Startadresse des von der gerade bearbeiteten
  Zeile erzeugten Codes  oder  der  Wert eines Labels, das in der
  gerade bearbeiteten Zeile definiert  wird.  Dieses  Feld bleibt
  leer, wenn von der gerade  bearbeiteten  Zeile  kein  Code oder
  Label erzeugt wird.

- Code listet den Wert aller Codebytes, Words oder Longwords auf,
  die von der gerade bearbeiteten Zeile erzeugt werden.

- Mac ist ein Plus ( + ), wenn die gerade bearbeitete Zeile  sich
  aus einer Makroexpansion ergibt, ansonsten eine Leerstelle.

- Quelltextzeile ist die gerade bearbeitete Zeile selbst.

- Die  Werte  in  den  Feldern  Adresse  und Code werden immer in
  hexadezimaler Form aufgelistet.  Das  auf die hexadezimale Zahl
  folgende Zeichen gibt den Typ des jeweiligen Wertes an:

Zeichen         Type des Wertes
-----------------------------------------------------------------

Leerstelle      Absolut
    '           Textsegment relativ
    `           Datensegment relativ
    "           BSS-Segment relativ
    *           Externe absolute Referenz ( nur Code )
    +           Externe PC relative Referenz ( nur Code )
    !           Optimierter Opcode ( nur Code )
    ~           Registernummer ( nur Adresse )
    &           Gr”e der Common Area ( nur Adresse )


-----------------------------------------------------------------

Das  Listing  endet  mit einer sortierten Symboltabelle. Wenn der
Schalter -X gesetzt ist,  wird  jedes Symbol mit Cross-Reference-
Informationen versehen.  Diese  Informationen  bestehen aus einer
sortierten Zeilennummernliste.  Wenn  auf  eine  Zeilennummer ein
Asterix ( * ) folgt, wird das  Symbol  in dieser Zeile definiert,
andernfalls wird es  in  dieser  Zeile  bentzt.   Bedingt  durch
Include-Dateien und  Makroexpansionen  kann die Zeilennumerierung
des Listings von der Zeilennumerierung der Quelldatei abweichen.

B	Elements of Assembly Language

Grundlegende Sprachelemente des MAS-68K Assemblers

=================================================================
B.1	Character Set
=================================================================
Der Assembler erkennt den folgenden Zeichensatz:

- Die Buchstaben: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                  a b c d e f g h i j k l m n o p q r s t u v w x y z
- Die Zahlen:     0 1 2 3 4 5 6 7 8 9
- Die Zeichen:    ! " # $ % & ' ( ) * + , - . / : ; < = >
                  ? [ \ ] ^ _ ` { | } ~ und den Klammeraffen.

- Die unsichtbaren Zeichen Leerstelle ( $20 ) und Tab ( $09 ).
- Die unsichtbaren Kontrollzeichen Carriage-Return ( $0D )
  und Line-Feed ( $0A ).

Eine Zeile darf maximal 512 Zeichen lang sein.

=================================================================
B.2	Comments
=================================================================
Kommentare k”nnen vom Assembler-Quelltext durch die folgenden 4
Methoden getrennt werden:

1. Alle  Zeichen in einer Zeile ab einem Asterix ( * ) werden als
   Kommentar  behandelt.   Diese Methode ist etwas problematisch:
   Da der Asterix auch als Operator  in  Multiplikationen und als
   Referenz des Positionsz„hlers verwendet wird, ist diese Syntax
   nicht eindeutig.  Der  MAS-Parse r bentzt einige heuristische
   Verfahren,  um  den Asterix semantisch korrekt zu interpretie-
   ren:  Der  Asterix  wird  dann  als Delimiter eines Kommentars
   behandelt, wenn s„mtliche der  folgenden  Bedingungen  erfllt
   sind:

-  Weder eine Zahl noch ein Bezeichner oder String unmittelbar
   vor dem Asterix.
-  Keines der folgenden Zeichen unmittelbar vor dem Asterix:
   ! = < > [ ^ # ' " ,
-  Keines der folgenden Zeichen unmittelbar nach dem Asterix:
   = + -
-  Der Asterix ist nicht eingeklammert ( ... ).

2. Alle Zeichen in einer  Zeile  ab  einem Semikolon ( ; ) werden
   als Kommentar behandelt.

3. Alle  Zeichen  innerhalb  der  in C blichen Kommentarklammern
   ( /*...*/ )  werden  als  Kommentar  behandelt.   Durch  diese
   Eigenschaft   k”nnen  Kommentare  ber  mehrere Zeilen gefhrt
   werden.   Die  Kommentarklammern  drfen  auf  mehreren Ebenen
   verschachtelt sein.   Dadurch  ist  es   m”glich,   Kommentare
   innerhalb    von   "auskommentierten"     Quelltextteilen   zu
   verwenden.

4. Zeilen  mit  einem # als allererstem Zeichen werden ignoriert.
   Diese Eigenschaft erm”glicht den Einsatz von MAS in Verbindung
   mit C-Pr„prozessoren.

Beispiele:
----------

* Dies ist ein Kommentar
        * das ebenfalls
*+ aber dies ist ein Fehler!
; Das ist auch ein Kommentar
        ; und dies ebenfalls
/* Das ist              ein langer              Kommentar       */
/* Das ist ein /* verschachtelter */       langer Kommentar     */
# Dies ist ebenfalls ein Kommentar
    # Aber das ist ein Fehler!

=================================================================
B.3	Tokens
=================================================================
Bezeichner werden verwendet, um Befehle und  Direktiven,  Label-,
Makro-und  Registernamen   und   operationale    Datentypen    zu
spezifizieren. Ein Bezeichner  ist  eine  Folge  von  einem  oder
mehreren Zeichen. Das erste Zeichen  mu  ein  Buchstabe  aus dem
Zeichensatz sein, der vom Assembler erkannt wird.  Als optionale,
weitere Zeichen stehen nach dem ersten Buchstaben alle  durch den
Zeichensatz definierten Zeichen zur Verfgung.

Alle Zeichen eines Bezeichners sind signifikant. Es wird zwischen
Gro- und Kleinschreibung unterschieden.

=================================================================
B.4	Register Specification
=================================================================
Auf die Register des MC68000 kann mit den folgenden  Namen  Bezug
genommen werden:

Name                Register
-----------------------------------------------------------------
d0 D0 r0 R0
d1 D1 r1 R1
d2 D2 r2 R2
d3 D3 r3 R3
d4 D4 r4 R4
d5 D5 r5 R5      Datenregister
d6 D6 r6 R6
d7 D7 r7 R7
-----------------------------------------------------------------
a0 A0 r8 R8
a1 A1 r9 R9
a2 A2 r10 R10
a3 A3 r11 R11    Adressregister
a4 A4 r12 R12
a5 A5 r13 R13
a6 A6 r14 R14
a7 A7 r15 R15 sp SP
-----------------------------------------------------------------
sr      SR      Statusregister
ccr     CCR     Condition Code Register
usp     USP     User Stack Pointer
pc      PC      Program Counter
vbr     VBR     Vector Base Register;              ( MC68010 )
sfc     SFC     Source Function Code Register      ( MC68010 )
dfc     DFC     Destination Function Code Register ( MC68010 )
caar    CAAR    Cache Address Register             ( MC68020 )
cacr    CACR    Cache Control Register             ( MC68020 )
isp     ISP     Interrupt Stack Pointer            ( MC68020 )
msp     MSP     Master Stack Pointer               ( MC68020 )
zpc     ZPC     Zero Program Counter               ( MC68020 )
-----------------------------------------------------------------

FPU.Fliekommaregister
-----------------------------------------------------------------
fp0     FP0
fp1     FP1
fp2     FP2
fp3     FP3
fp4     FP4     Fliekomma-Datenregister ( MC68881 )
fp5     FP5
fp6     FP6
fp7     FP7
-----------------------------------------------------------------
fpcr    FPCR    Fliekomma-Kontrollregister        ( MC68881 )
fpsr    FPSR    Fliekomma-Statusregister          ( MC68881 )
fpiar   FPIAR   Fliekomma-Befehlsadressregister   ( MC68881 )
-----------------------------------------------------------------

PMMU Paged Memory Management Unit Register
-----------------------------------------------------------------
crp     CRP     CPU Root Pointer          ( MC68881, MC68030 )
srp     SRP     Supervisor Root Pointer   ( MC68881, MC68030 )
drp     DRP     DMA Root Pointer                   ( MC68851 )
-----------------------------------------------------------------
tc      TC      Translation Control Reg.  ( MC68881, MC68030 )
psr     PSR     PMMU Statusregister       ( MC68881, MC68030 )
pcsr    PCSR    PMMU Cache Statusregister          ( MC68851 )
-----------------------------------------------------------------
cal     CAL     Current Access Level Register      ( MC68851 )
val     VAL     Validate Access Level Register     ( MC68851 )
ac      AC      Access Control Register            ( MC68851 )
-----------------------------------------------------------------
tt0     TT0     Transparent Translation Register 0 ( MC68030 )
tt1     TT1     Transparent Translation Register 1 ( MC68030 )
-----------------------------------------------------------------
bad0    BAD0
bad1    BAD1
bad2    BAD2
bad3    BAD3    Breakpoint Acknowledge Datenregister
bad4    BAD4    ( MC68851 )
bad5    BAD5
bad6    BAD6
bad7    BAD7
-----------------------------------------------------------------
bac0    BAC0
bac1    BAC1
bac2    BAC2
bac3    BAC3    Breakpoint Acknowledge Control Register
bac4    BAC4    ( MC68851 )
bac5    BAC5
bac6    BAC6
bac7    BAC7
-----------------------------------------------------------------

Bei  den  Registernamen  wird  Gro- und  Kleinschreibung  unter-
schieden, d.h.  Vbr  bezieht  sich  nicht  auf  das  Vector  Base
Register.  Mit  den  Registernamen gleichlautende Labelnamen sind
nicht zul„ssig.

=================================================================
B.5	Labels
=================================================================
Labels sind Bezeichner die w„hrend der Assemblierung als Referenz
fr  bestimmte  Werte  wie  Sprungadressen,  Konstantenwerte oder
externe Symbole bentzt werden.

Labels  sind  im  gesamten Bereich des Quelltextes gltig, in dem
sie enthalten sind.  Bei  den Label-Namen wird zwischen Gro- und
Kleinschreibung unterschieden. Labelnamen  drfen nicht mit einem
Registernamen ( d0,... ),  k”nnen  aber  mit  einem Befehl, einer
Direktive oder einem Makro-Namen bereinstimmen.

Alle Zeichen eines Labels sind signifikant und werden w„hrend der
Assemblierung in der internen Symboltabelle gespeichert. Abh„ngig
von der maximalen  Zeichenanzahl,  die fr das Object-Dateiformat
der Zieldatei  zul„ssig  ist,  mssen  u.U.  Einschr„nkungen  bei
globalen und externen Symbolen vorgenommen werden.

Jeder  Leerzeile,  jedem Befehl  und einigen Direktiven darf eine
Label-Liste  vorangestellt werden.  Eine  Label-Liste besteht aus
einem oder mehreren Label-Namen,  die  jeweils  mit einem Doppel-
punkt abgeschlossen werden. Beachten Sie bitte,  da  MAS-68K  im
Gegensatz zu anderen Assemblern diesen Doppelpunkt  grunds„tzlich
verlangt. Die Liste darf mit Leerstellen oder Tabs beginnen:

Label:[Label:...]

Der aktuelle Wert des  Positionsz„hlers  wird  jedem Label in der
Labelliste zugewiesen. Eine Umdefinierung ( Redefinition ) dieser
Labels ist nicht zul„ssig.  Eine  weitere  Methode,  Labels einen
Wert zuzuweisen, ist die EQU-Direktive  oder  das Gleichheits-
zeichen (=).

=================================================================
B.6	Size Specification
=================================================================
Die  Operationsgr”en-attribute  des  MC68000  k”nnen   mit  den
folgenden Namen spezifiziert werden:

Namen   Typ     Gr”e                           Gr”e in Bits
-----------------------------------------------------------------
.b      .B      Byte                            8 Bit
.w      .W      Word                            16 Bit
.l      .L      Longword                        32 Bit
.s      .S      Single Precision Binary Real    32 Bit
.d      .D      Double Precision Binary Real    64 Bit
.x      .X      Extended Precision Binary Real  96 Bit
.p      .P      Packed Decimal Real             64 Bit
-----------------------------------------------------------------

Achtung:   Im  Gegensatz zu anderen Assemblern ist .s oder .S fr
kurze  Verzweigungen  ( Short Branches, BRA.S )  nicht  zul„ssig.
Daher mu in diesem Fall die Spezifikation fr Byte( .b oder .B )
verwendet werden.  Mit  den  Gr”enattribut-Namen  gleichlautende
Labelnamen sind zul„ssig.

=================================================================
B.7	Integer Constants
=================================================================
Es  stehen  drei  Arten  von  Integer-Konstanten  zur  Verfgung:
numerische  (integer)   Konstanten,  Stringkonstanten   und  der
Positionsz„hler ( Location Counter ).

Numerische Konstanten
---------------------
Numerische   Integer-Konstanten   k”nnen   in   dezimaler,  hexa-
dezimaler,  oktaler  oder  bin„rer  Notation spezifiziert werden.
Das erste ( bzw. die ersten ) Zeichen bestimmt die Notation:

Notation        Erste(s) Zeichen        Weitere Zeichen
-----------------------------------------------------------------
Dezimal         0...9                   0...9
Hexadezimal     $,0x oder 0X            0...9, A...F, a...f
Oktal           Klammeraffe             0...7
Bin„r           %                       0...1

-----------------------------------------------------------------

Innerhalb  numerischer  Konstanten  drfen  zur  Verbesserung der
Lesbarkeit  Unterstrich  ( _ )  und  Dollarzeichen  ( $ ) bentzt
werden.

Unabh„ngig  von  der  gew„hlten  Notation werden alle numerischen
Konstanten in ein Longword ( 32 Bit Wert ) konvertiert.

Beispiele:
----------

Konstante       Wert (Hex)
----------------------------------------------------------------
1347            00000543
1_000_000_000   3B9ACA00
$f37a           0000f37a
0x1234_ABCD     1234ABCD
%0101$1110      0000005E
----------------------------------------------------------------

=================================================================
B.8	Addressing Modes
=================================================================
Die  MC680x0-Mikroprozessorfamilie  untersttzt eine Vielzahl von
Adressierungsarten. Die Syntax wird so akzeptiert, wie sie in den
Motorola User Manuals beschrieben ist. Die folgende Tabelle zeigt
die Syntax fr die unterschiedlichen Adressierungsarten:

Syntax  Modus
-----------------------------------------------------------------
dn                              Datenregister direkt
an                              Adressregister direkt
(an)                            Adressregister indirekt
(an)+                           Adressregister indirekt
                                mit Postincrement
-(an)                           Adressregister indirekt
                                mit Predecrement
(disp,an) od. disp(an)          Adressregister indirekt mit
                                Displacement
(disp,an,xn) od. disp(an,xn)    Adressregister indirekt mit
                                Index und Displacement
([disp,an],disp,xn)             Post-Indexed
([disp,an,xn],disp)             Speicher indirekt Pre-Indexed
(disp,pc) od. disp(pc)          Program Counter relativ mit
                                Displacement
(disp,pc,xn) od. disp(pc,xn)    Program Counter relativ mit
                                Index u. Displacement
([disp,pc],disp,xn)             Program Counter Speicher indirekt
                                Post-Indexed
([disp,pc,xn]disp)              Program Counter Speicher indirekt
                                Pre-Indexed
addr                            Absolute Adresse
#data                           Immediate Data

-----------------------------------------------------------------

Examples:

Beispiele fr Standard-Adressierungsarten
-----------------------------------------------------------------
2
a6
(a0)
(a3)+
-(sp)
100(a2)                         entspricht (100,a2)
5(a3,d2)                        entspricht (5,a3,d2.w*1)
var(pc)                         entspricht (var,pc)
10(pc,a2.l)                     entspricht (10,pc,a2.l*1)
$1fff0000
#1000

-----------------------------------------------------------------

Beispiele fr erweiterte Adressierungsarten
-----------------------------------------------------------------
(1000,a2,d0.l*8)
(d2.l)                  Displacement und Base-Register
                        unterdrckt
(a2,d7*4)               Displacement unterdrckt
([-44,sp],1000,d3.l)
([4,a2,d7.w*4],10)
([4,sp])                ueres displacement und Indexregister
                        unterdrckt
([d2.l],4)              Inneres Displacement und Indexregister
                        unterdrckt
([$1000])               ueres Displacement, Base-Register und
                        Indexregister unterdrckt
(var,pc,d1.w*2)
($400,zpc)              Programmz„hler und Indexregister
                        unterdrckt
([var,pc,a2.l],4)
([var,pc],d2.l)         ueres Displacement unterdrckt
([zpc])                 Beide Displacements, Programmz„hler und
                        Indexregister unterdrckt

-----------------------------------------------------------------

=================================================================
B.9	String Constants
=================================================================
Stringkonstanten  bestehen aus einer Reihe von ASCII-Zeichen, die
in  einfache  ( ' )  oder doppelte ( " ) Anfhrungszeichen einge-
schlossen sind.  Ein  mit  einer  einfachen (doppelten) Anfhrung
beginnender String  endet  an der n„chsten einfachen( doppelten )
Anfhrung.   Strings   drfen   keine   Steuerzeichen  enthalten,
insbesondere  keine  Tabs oder Zeilenschaltungen. Ein String kann
seinen  eigenen  Begrenzer  enthalten,  wenn  das   entsprechende
Zeichen  zweimal  spezifiziert wird ( '' oder "" ). Leere Strings
sind zul„ssig.  Der  Wert,  mit  dem ein String dargestellt wird,
h„ngt von dem Kontext ab, in dem er bentzt wird.  Im allgemeinen
wird fr  jedes  Zeichen  ein  Byte  entsprechend  dem ASCII-Code
dieses Zeichens generiert.

Wenn  ein  String  als  Argument  fr eine  DC-Direktive ( Define
Constant ) dient,  wird fr jedes Byte des  Strings ein Datenbyte
erzeugt. In diesem  Fall  ist  die  maximale  L„nge  des  Strings
gleich der fr eine  Eingabezeile  maximal  zul„ssigen Zeichenan-
zahl.  In  allen  anderen  F„llen  wird der String unabh„ngig von
seiner L„nge in ein  Longword  ( 32 Bit Wert )  konvertiert.   Da
ein Longword nur vier Bytes enthalten kann,  ist  die Stringl„nge
auf  vier  Zeichen  begrenzt.  Wenn  der String  weniger als vier
Zeichen hat, werden von links Nullbytes erg„nzt.

Beispiele:
----------

String  Wert (Hex)      Wert fr DC ( Define Constant )
-----------------------------------------------------------------
""                      00000000        nichts generiert
"0"                     00000030        30
""""                    00000022        22
'"'                     00000022        22
"No"                    00004E6F        4E6F
"Yes"                   00596573        596573
'0123'                  30313233        30313233
"Hello"                 nicht zul.      48656C6C6F
"This is a long string" nicht zul.      54686973206973
                                        2061206C6F6E67
                                        20737472686E67

-----------------------------------------------------------------

=================================================================
B.10	Position Modifiers
=================================================================
Auf  den  aktuellen  Assemblierungs-Positionsz„hler wird mit dem
Asterix ( * ) bezug genommen. Wenn * in einem  Ausdruck  bentzt
wird, repr„sentiert das Zeichen die  Adresse  des  ersten  Bytes
des gegenw„rtigen Statements.  Da der Asterix ( * ) gleichzeitig
auch als Begrenzer  fr  Kommentare  verwendet  wird,  empfiehlt
es sich, das Zeichen in Klammern einzuschlieen,  damit  es  vom
Assembler korrekt interpretiert wird.

Beispiele:
----------

current:   move.l #(*),a0  * entspricht "move.l #current,a0"

Hier_sind_wir equ (*)   * entspricht "hier_sind_wir:"

=================================================================
B.11	Expressions and Operators
=================================================================
Ausdrcke  ( Expressions )  bestehen   aus  Operanden  in   einer
Kombination mit Operatoren, um neue Werte zu erhalten.  Operanden
sind  Konstanten  oder  Labels.  Im Zusammenhang  mit  Ausdrcken
wird eine Syntax „hnlich der Programmiersprache  C  bentzt.  Die
verschiedenen    Operatoren   werden     in    den    Abschnitten
Un„re Operatoren und Bin„re Operatoren eingehend geschildert.

B.11.a	Unary Operators
-----------------------------------------------------------------
Operator        Name            Operation
-----------------------------------------------------------------
+               Identit„t       Operand unver„ndert
-               Negation        Zweierkomplement des Operanden
!               Komplement      Einerkomplement des Operanden

-----------------------------------------------------------------

Fr alle  un„ren  Operatoren  mu  der Operand absolut adressiert
sein. Das Resultat ist ebenfalls absolut.

B.11.b	Binary Operators
-----------------------------------------------------------------
Operator  Name            Operation
-----------------------------------------------------------------
+         Addition        Summe beider Operanden.
-         Subtraktion     Differenz zwischen dem ersten und
                          dem zweiten Operanden.
*         Multiplikation  Produkt beider Operanden.
/         Division        Integerteil des vorzeichenbehaf-
                          teten Quotienten des ersten durch
                          den zweiten Operanden.
%         Remainder       Rest der Integerdivision des
                          ersten durch den zweiten
                          Operanden.
|         OR              Bitweises logisches 'ODER' beider
                          Operanden.
&         AND             Bitweises logisches 'UND' beider
                          Operanden.
^         XOR             Bitweises logisches 'EXLUSIV ODER'
                          beider Operanden.
<<        Shift left      Ergibt den ersten Operanden, wobei
                          alle Bits um die im zweiten
                          Operanden angegebene Anzahl nach
                          links verschoben sind . Rechts wird
                          die entsprechende Zahl mit bin„ren
                          Nullen aufgefllt.
>>        Shift rigth     Ergibt den ersten Operanden, wobei
                          alle Bits um die im zweiten
                          Operanden angegebene Anzahl nach
                          rechts verschoben sinmd. Rechts wird
                          die entsprechende Zahl mit bin„ren
                          Nullen aufgefllt.
=, ==     Gleich          Ergibt $FFFFFFFF, wenn beide
                          Operanden gleich sind, ansonsten
                          $00000000.
!=,<>,#   Ungleich        Ergibt $FFFFFFFF, wenn beide
                          Operanden ungleich sind, ansonsten
                          $00000000.
>=        Gleich-Gr”er   Ergibt $FFFFFFFF, wenn der erste
                          Operand gr”er oder gleich dem
                          zweiten Operanden ist, ansonsten
                          $00000000.
>         Gr”er          Ergibt $FFFFFFFF, wenn der erste
                          Operand gr”er als der zweite ist,
                          ansonsten $00000000.
<=        Kleiner-Gleich  Ergibt $FFFFFFFF, wenn der erste
                          Operand kleiner oder gleich dem
                          zweiten Operanden ist, ansonsten
                          $00000000.
<         Kleiner         Ergibt $FFFFFFFF, wenn der erste
                          Operand kleiner als der zweite ist,
                          ansonsten $00000000.

-----------------------------------------------------------------

Auer  bei  addierenden ( +, - ) und  relationalen ( =, !=, ... )
Operatoren  mssen  alle Operanden absolut sein. Das Resultat ist
ebenfalls absolut.  Fr  den  +  Operator  mu  der  eine Operand
absolut sein, der andere  kann  absolut,  Segment  relative  oder
extern sein. Das Resultat ist dann vom selben Typ wie der  nicht-
absolute Operand.  Fr den - Operator  kann  der  erste ( linke )
Operand absolut,  Segment  relative  oder  extern  und der zweite
( rechte ) absolut sein. Das Resultat ist vom selben  Typ wie der
erste Operand.  Beide  Operanden k”nnen auch Segment relative und
im selben Segment sein. In diesem Fall ist der  Typ des Resultats
absolut,  und  sein  Wert  entspricht  der  Distanz  zwischen den
segment relative Ausdrcken.

Fr die relationalen Operatoren k”nnen beide  Operanden  beliebig
gew„hlt werden,  das  Resultat  ist  immer absolut.  Wenn   beide
Operanden nicht absolut  oder  Segment  relative  und  im  selben
Segment sind, ist das Resultat False ( $00000000 ).   Andernfalls
h„ngt das Resultat von der Bedingung ( Condition ) ab:
Das Resultat ist True ( $FFFFFFFF ), wenn die Bedingung True ist,
sonst False ( $00000000 ). Wenn ein relationaler  Operator  False
zurckgibt, kann es also zwei Ursachen dafr geben:
Entweder k”nnen die Operanden nicht verglichen werden  ( sie sind
ungeordnet ),  oder  das  Resultat  der  Vergleichsoperation  ist
False.  Wenn beide Operanden eines relationalen Operators Strings
sind, drfen die Strings auch mehr als vier Zeichen enthalten. Es
wird ein normaler lexikalischer Vergleich vorgenommen.

Achtung:          Bei der Verwendung des % Operators ist Vorsicht
angebracht: Das %-Zeichen wird  auch  zur  Spezifizierung bin„rer
Konstanten bentzt.   Wenn  das  % - Zeichen  als Modulo-Operator
bentzt wird, darf direkt anschlieend keine  0  ( Null )  oder 1
( Eins ) verwendet werden.

=================================================================
B.12	Floating Point Expresssions
=================================================================
Ausdrcke  die  entweder  in einem Immediate Quelloperanden eines
MC68881-Befehlsstatements  ( ausgenommen FMOVECR )  oder  in  der
Liste der Argumente einer DC-Direktive oder einer Define Constant
Block  (DCB)    Direktive   vorkommen,   werden  automatisch  als
Fliekommaausdrcke behandelt, wenn  Floating  Point als Datentyp
( .s, .d, .x oder .p ) spezifiziert wurde.

B.12.a	Floating Point Constants
-----------------------------------------------------------------
Die  Syntax einer Fliekommakonstanten im freien Format folgt den
Regeln  der  meisten h”heren Programmiersprachen. Die Fliekomma-
konstante  beginnt   mit   dem   Ziffernstring  des Integerteils,
optional gefolgt von dem mit einem Punkt eingeleiteten Nachkomma-
teil ( Fraction ) und dem mit e oder E eingeleiteten Exponential-
teil:

Ziffern[.Ziffern][E[+|-]Ziffern]
Ziffern ist ein String von einer oder mehreren Dezimalziffern.

Beispiele:
----------

1
100
3.14
1.25e-17
9.81e10

B.12.b	Hex FP Constants
----------------------------------------------------------------
Ein Fliekommaausdruck kann  auch mit  einem  Dollarzeichen ( $ )
beginnen, auf das ein  String  hexadezimaler  Ziffern  folgt.  In
diesem Fall  wird  derWert des Ziffernstrings in einen Bytestring
entsprechender Gr”e konvertiert.   Aus   dem   Bytestring   wird
anschlieend direkt der  Code  erzeugt.   Operatoren  sind  nicht
zul„ssig. Durch diese Funktion  k”nnen  spezielle Kodierungen wie
nicht-normalisierte Zahlen,  Infinities,  NANs oder SNANs erzeugt
werden.

B.12.c	Floating Point Operators
-----------------------------------------------------------------
Fliekommaausdrcke   bestehen   normalerweise   aus  Fliekomma-
konstanten in Verbindung mit Operatoren.  Der  Wert des Ausdrucks
wird berechnet und in das Zielformat umgewandelt.

Un„re Operatoren

Fr  alle  Fliekomma-Zielformattypen  ( Single, Double, Extended
Binary  Real  oder  Packed BCD Real ) k”nnen die folgenden un„ren
Operatoren in den Fliekommaausdrcken bentzt werden:

Operator        Name            Operation
-----------------------------------------------------------------
+               Identit„t       Ergibt den Operanden unver„ndert.
-               Negation        Ergibt den negativen Wert seines
                                Operanden.

-----------------------------------------------------------------

Bin„re Operatoren

Wenn  das  Zielformat  eines Fliekommaausdrucks einem der Binary
Real Typen entspricht  ( Single, Double, oder Extended ),  k”nnen
zus„tzlich zu den un„ren Operatoren auch  die  folgenden  bin„ren
Operatoren verwendet werden:

Operator    Name              Operation
-----------------------------------------------------------------
+           Addition          Ergibt die Summe beider Operanden
-           Subtraktion       Ergibt die Differenz zwischen dem
                              ersten und dem zweiten Operanden.
*           Multiplikation    Ergibt das Produkt beider Operanden
/           Division          Ergibt den Quotient des ersten
                              durch den zweiten Operanden.

-----------------------------------------------------------------

Es gilt  dieselbe  Rangfolge von Operatoren  wie bei den Integer-
ausdrcken.   Klammerausdrcke   sind   zul„ssig.  Alle  internen
Berechnungen   werden    mit   erh”hter   Genauigkeit  ( Extended
Precision ) durchgefhrt(Bereich ca. von 8.0E-4933 bis 6.0E4931).
Wenn das Zielformat zu klein  ist,   um  den  Wert  speichern  zu
k”nnen,  wird  bei  Overflow  Unendlich   ( Infinity )  und   bei
Underflow eine Null erzeugt. Die Fliekommaberechnungen  erfolgen
ber  Software,  der  Assemble r  verwendet   keine  Coprozessor-
Fliekomma-Befehle.   Die  Softwareroutinen   verwenden  dieselben
Fehlerbehandlungsmethoden wie der MC68881. Der  Assembler erzeugt
ein  NAN ( Not a Number )   bei  ungltigen Operationen.   Nicht-
normalisierte Zahlen werden niemals generiert.

Wenn das Zielformat eines Fliekommaausdrucks vom  Packed  Decimal
Real Typ ist, drfen nur die un„ren Operatoren +  oder  -  bentzt
werden. Intern werden keine Fliekommaberechnungen durchgefhrt.

=================================================================
B.13	Operator Precedence
=================================================================
Bedingt  durch  die  den  verschiedenen  Integer- und Fliekomma-
operatoren zugeordnete relative Rangfolge  k”nnen  Ausdrcke ohne
verschachtelte  Klammern geschrieben werden.  Die Operatoren  mit
dem h”heren  Rang  werden  zuerst  ausgewertet.   Operatoren  mit
demselben Rang werden von links nach rechts ausgewertet.

Die folgende   Tabelle  stellt  die Rangfolge  der  verschiedenen
Operatoren dar. Alle in einer Zeile aufgefhrten Operatoren haben
denselben Rang.

Operator                                             Rang
-----------------------------------------------------------------
+ (un„r), - (un„r), !, Klammerausdruck ()            hoch
*, /, %, &, ^, ®, ¯
+, -, |
==, !=, >=, >, <=, <                                 niedrig
-----------------------------------------------------------------

Beispiele:
----------

Ausdruck                          quivalenter Ausdruck
-----------------------------------------------------------------
a + b + c                         (a + b) + c
a + b * c                         a + (b * c)
a * b + c                         (a * b) + c
a % b * c ¯ d                     ((a % b) * c) ¯ d
a / !b - c ¯ d                    (a / (!b)) - (c ¯ d)
!a | b > c + d                    ((!a) | b) > (c + d)
-----------------------------------------------------------------

C	Instruction Set

MAS-68K Befehlsbersicht


C.1	Transfer
-----------------------------------------------------------------
EXG     MOVE     PEA
LEA     MOVEA    SWAP
LINK    MOVEC    UNLK
        MOVEM
        MOVEP
        MOVEQ

C.2	Arithmetic
-----------------------------------------------------------------
ADD    CLR    DIVS   NEG    SUBQ   ABCD
ADDA   CMP    DIVU   NEGX   SUBX   NBCD
ADDI   CMPA   EXT    SUB    TST    SBCD
ADDQ   CMPI   MULS   SUBA
ADDX   CMPM   MULU   SUBI

C.3	Logical
-----------------------------------------------------------------
AND    NOT
ANDI   OR
EOR    ORI
EORI

C.4	Bitwise
-----------------------------------------------------------------
BCHG   BFCHG     BFINS
BCLR   BFCLR     BFSET
BSET   BFEXTS    BFTST
BTST   BFEXTU    BKPT
TAS    BFFFO

C.5	Shift and Rotate
-----------------------------------------------------------------
ASL   ROL
ASR   ROR
LSL   ROR
LSR   ROR
      ROXR

C.6	Program Structure
-----------------------------------------------------------------
Bcc   JMP     RTE     TRAP
DBcc  JSR     RTS     TRAPV
BRA   NOP     STOP    TRAPcc
BSR   RESET   Scc
CHK

C.7	Floating Point
-----------------------------------------------------------------
FABS       FINT        FSCALE
FACOS      FINTRZ      FSCC
FADD       FLOGN       FSGLDIV
FASIN      FLOGNP1     FSGLMUL
FATAN      FLOG10      FSIN
FATANH     FLOG2       FSINCOS
FBCC       FMOD        FSINH
FCMP       FMOVE       FSQRT
FCOS       FMOVECR     FSUB
FCOSH      FMOVEM      FTAN
FDBCC      FMUL        FTANH
FDIV       FNEG        FTENTOX
FETOX      FNOP        FTCC
FETOXM1    FREM        FTEST
FGETEXP    FRESTORE    FTWOTOX
FGETMAN    FSAVE

D	Assembler Direktiven

MAS-68K Direktiven

=================================================================
D.1	EQU
=================================================================
EQU    Weist   einem  Label  einen  Wert  zu.  Darf sp„ter nicht
       umdefiniert nicht werden.

Die EQU-Direktive weist dem Label  den  Wert  ines Ausdrucks zu.
Das  Label  kann nicht  redefiniert  werden.  Der  Ausdruck  mu
w„hrend des ersten Laufs vollst„ndig definiert und darf nicht
relativ zu einem externen Symbol sein.

Als  weitere M”glichkeit k”nnen Registernamen (z.B. d0, a2, vbr)
einem  Label  zugewiesen  werden, wobei dieses Label dann in den
folgenden MC68000-Befehlsstatements als Synonym fr das Register
benutzt werden kann.

Beispiele:
----------

cr       EQU $0d
lf       equ $0a
fp       equ a6

=================================================================
D.2	SET
=================================================================
SET    Weist  einem Label einen Wert zu. Darf sp„ter umdefiniert
       werden.

Die SET-Direktive und das Gleichheitszeichen ( = ) sind Synonyme
und entsprechen der  Equate-Direktive  mit  dem Unterschied, da
das   Label   sp„ter  durch   eine   andere  SET-Direktive,  ein
Gleichheitszeichen  oder  eine  REG-Direktive  redefiniert werden
darf. Wenn ein solches mehrfach definiertes Label in einer Zeile
vor der ersten Wertzuweisung bentzt wird,  wird der ihm zuletzt
zugewiesene Wert verwendet.  In diesem Fall darf mit der vorher-
gehenden Zuweisung dem Label  kein  Register  zugewiesen  worden
sein.

Hinweis:   Bei  keiner  der beiden Direktiven darf dem Label ein
Doppelpunkt folgen.  Die EQU- und SET-Direktiven drfen auch mit
dem  ersten  auf  das  mnemonic  folgenden  Zeichen spezifiziert
werden.

Beispiel:
---------

temp     set d0             * d0 als tempor„res Register verwendet
move ttyin,temp             * entspricht "move $1fff000f,d0"
move.b #cr,-4(fp)           * entspricht "move.b #$0d,-4(a6)"
ttybase  = $2fff0000        * Fehler, "ttybase" redefined
temp     = d2               * d2 als tempor„res Register verwendet
clr.l temp                  * entspricht "clr.l d2"

=================================================================
D.3	=
=================================================================
=      Weist einem Label einen Wert zu. Darf sp„ter umdefiniert
       werden. Siehe SET.

=================================================================
D.4	REG
=================================================================
REG    Weist einem Label eine Register Mask zu

Die REG-Direktive berechnet eine Registermaske aus der Register-
liste  und  weist  diesen  Wert  einem  Label  zu.  Wenn nur ein
Minuszeichen  ( - )  spezifiziert  ist,   wird  Label  auf  Null
gesetzt. Ein mit dieser Methode definiertes  Label  darf  sp„ter
durch  ein  Gleichheitszeichen   ( = )  oder  eine  andere  REG-
Direktive redefiniert werden.

Fr  die  Registerliste  wird dieselbe Syntax wie fr die MOVEM-
oder FMOVEM-Befehle bentzt.  Der  berechnete  Wert ist absolut,
die Register korrespondieren mit den folgenden Bitpositionen:

Bit        15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
           -----------------------------------------------
Register   a7 a6 a5 a4 a3 a2 a1 a0 d7 d6 d5 d4 d3 d2 d1 d0

Fr die Fliekommaregister gilt:

Bit         7   6   5   4   3   2   1   0
           -------------------------------
Register   fp7 fp6 fp5 fp4 fp3 fp2 fp1 fp0

Die  REG-Direktive  ist  nur  fr  Daten/Adressregister und  FPU
Fliekommaregister  zugelassen.  In  einer  Registerliste drfen
nicht gleichzeitig  Daten/Adressregister und  Fliekommaregister
spezifiziert werden.

Genauso wie bei EQU und SET darf auch die  REG-Direktive mit dem
ersten  auf  das mnemonic folgenden Zeichen spezifiziert werden.
Die  REG-Direktive  kann verwendet werden, um Registerlisten als
Konstanten  fr  die MOVEM- und FMOVEM-Befehle zu spezifizieren.
Aus diesem Grund wurde die Syntax  fr diese  Befehle erweitert,
so  da  die   Registerliste   auch   als   ein   Immediate Wert
spezifiziert werden kann.

Beispiele:
----------

regs_used  reg d0-d2/a0
movem.l #regs_used,-(sp)

=================================================================
D.5	DC
=================================================================
DC     Erzeugt eine Sequenz konstanter Daten

nicht gleichzeitig  Daten/Adressregister und  Fliekommaregister
Die  DC-Direktive  ( Define Constant )  initialisiert  Teile des
Speichers.   Gr”e-Spezifikation   ist  optional  und  auf  Word
voreingestellt. Der Speicher wird mit  dem  Wert jedes Ausdrucks
in der Argumentliste initialisiert. Der Wert wird jeweils in die
angegebene Gr”e konvertiert.

Wenn  ein  Ausdruck  nur  aus  einem  einzelnen  String besteht,
erzeugt die DC-Direktive unabh„ngig von der angegebene Gr”e ein
Datenbyte fr jedes Zeichen des Strings.  Der String  darf  mehr
als 4 Zeichen haben. Wenn die  angegebene  Gr”e  nicht Byte ist
und die Daten nicht korrekt angepat sind,  werden Nullbytes ans
Ende des Strings angefgt.

Beispiele:
----------

Statement               erzeugter Hexcode
---------------------------------------------------------------

DC.b 1,-1,"a","a"+1     00FF6162
DC   1,-1,"a","a"+1     0001FFFF61000062
DC.l 1,-1,"a","a"+1     00000001FFFFFFFF6100000000000062
DC.s 1.0,-2.0           3F800000C0000000
DC.d 1.0                3FF0000000000000
DC.x 1.0                3FFF00008000000000000000
DC.p -12345678901234567 801400012345678901234567

DC.b "Hello World !"    48656C6C6F20576F726C642021
DC.w "Hello World !"    48656C6C6F20576F726C64202100
DC.l "Hello World !"    48656C6C6F20576F726C642021000000

=================================================================
D.6	DCB
=================================================================
DCB    Erzeugt einen Block konstanter Daten.

und die Daten nicht korrekt angepat sind,  werden Nullbytes ans
Die  DCB-Direktive  ( Define Constant Block) initialisiert einen
Speicherblock mit  einem bestimmten Wert.  Der Ausdruck spezifi-
ziert die Anzahl  der  zu  initialisierenden  Einheiten,  er mu
absolut und gr”er als Null sein und  w„hrend  des  ersten Laufs
definiert werden.   Der  Ausdruck  gibt  den  Wert  jedes  Teils
an.   Gr”e  spezifiziert  optional  die Gr”e einer Einheit und
ist auf Word voreingestellt.

DCB.w 6,-2      FFFEFFFEFFFEFFFEFFFEFFFE
DCB.b 16,'A'    41414141414141414141414141414141

=================================================================
D.7	ASCII
=================================================================
ASCII  Erzeugt eine Sequenz von ASCII-Zeichen.

Beispiel:
---------

ASCII "Hello World !"   48656C6C6F20576F726C642021

Querverweis: DC

=================================================================
D.8	ASCIIL
=================================================================
ASCIIL Erzeugt eine Sequenz von ASCII-Zeichen, der eine
       L„ngenangabe vorangestellt wird.

Beispiel:
---------

ASCIIL "Hello World !"  0D48656C6C6F20576F726C642021

Querverweis: DC

=================================================================
D.9	ASCIIZ
=================================================================
ASCIIZ Erzeugt eine Sequenz von ASCII-Zeichen, die mit Null
       abgeschlossen wird.

Beispiel:
---------

ASCIIZ "Hello World !"  48656C6C6F20576F726C64202100

Querverweis: DC

=================================================================
D.10	DS
=================================================================
DS     Reserviert Speicher,  indem der Positionsz„hler  vorw„rts
       bewegt wird.

Die DS-Direktive ( Define Storage )  reserviert einen Bereich im
Speicher beginnend mit  dem  gegenw„rtigen  Positionsz„hler. Der
Ausdruck spezifiziert die  Zahl  der zu reservierenden Einheiten
und mu absolut, gr”er als oder  gleich  Null  sein und w„hrend
des ersten Laufs definiert werden.  Die  Gr”e einer Einheit ist
optional und ist auf Word voreingestellt.

Wenn das  derzeitige  Segment das Textsegment- oder Datensegment
ist,  wird  der  reservierte Speicherbereich mit Nullen gefllt,
andernfalls wird nur der Positionsz„hler weitergeschaltet.

Beispiele:
----------

Statement       Reservierte Anzahl von Bytes ( dezimal )
----------------------------------------------------------------
DS.b 100        100
DS     2        4
DS.w $10        32
DS.l   1        4
DS.d   5        40

=================================================================
D.11	ORG
=================================================================
ORG    Setzt den Positionsz„hler auf einen bestimmten Wert.

Die  ORG-Direktive  ( Origin )  setzt den derzeitigen Positions-
z„hler auf den Wert eines Ausdrucks.  Der  Ausdruck mu  absolut
oder relativ zum gegenw„rtigen   Segment  sein und  w„hrend  des
ersten  Laufs definiert werden. Rckw„rtsgerichtete  Zuweisungen
sind  nicht zul„ssig.

=================================================================
D.12	*=
=================================================================
*=     Setzt den Positionsz„hler auf einen bestimmten Wert.

Die  Zuweisung  des  Positionsz„hlers  mit  *=  „hnelt  der ORG-
Direktive.   Beachten  Sie  bitte,  da  das  Gleichheitszeichen
unmittelbar nach dem Asterix stehen mu,  andernfalls  wrde die
Zeile als Kommentar gewertet werden.

Diese Direktive ist  nur  aus Kompatibilit„tsgrnden vorgesehen.
Normalerweise  sollte  die  DS-Direktive   bentzt   werden,  um
Speicher zu reservieren.

=================================================================
D.13	ALIGN
=================================================================
ALIGN  Pat den Positionsz„hler an eine bestimmte Grenze an.

Die  ALIGN-Direktive  schaltet den Positionsz„hler weiter bis zu
der in einem optionalen Ausdruck ( Voreinstellung 2 )  angegebe-
nen Grenze.  Der Wert des Ausdruck ist normalerweise 2 ( Word ),
4 ( Longword ), 8 ( Double Longword )  oder  eine  andere Potenz
von 2.  Nach  der  Anpassung sind das Positionsz„hler-Modulo und
der Wert des Ausdrucks Null. Der Ausdruck mu absolut und gr”er
als Null sein und w„hrend des ersten Laufs definiert werden.

=================================================================
D.14	EVEN
=================================================================
EVEN   Pat den Positionsz„hler an eine Word-Grenze an.

Die  EVEN-Direktive  schaltet  den   Positionsz„hler des  gegen-
w„rtigen  Segments  weiter,  falls  dieser  nicht  an eine Word-
renze  angepat  ist.   Diese   Direktive   entspricht  ALIGN  2
oder  ALIGN.  Die  EVEN-Direktive   sollte   jeweils   nach  der
Generierung  von  Byte  data  ( durch DC.b oder DS.b )  spezifi-
ziert werden.

=================================================================
D.15	TEXT
=================================================================
TEXT   Selektiert das Textsegment.

Die TEXT-Direktive w„hlt das  Textsegment  aus.  Dieses  Segment
wird  normalerweise fr ausfhrbaren Maschinencode bentzt. Wenn
ein Ausdruck nicht spezifiziert ist,   wird  das  zu  Beginn der
Assemblierung  voreingestellte   Text-Subsegment  0  ausgew„hlt.
Wenn ein Ausdruck spezifiziert ist,  mu  sein  Wert absolut und
im Bereich 0...3 sein und  auerdem  im  ersten  Lauf  definiert
worden sein.  Das  angegebene  Text-Subsegment  wird  durch  die
Direktive ausgew„hlt.

=================================================================
D.16	DATA
=================================================================
DATA   Selektiert das Datensegment.

Die  DATA-Direktive  w„hlt das Datensegment aus.  Dieses Segment
wird  normalerweise  fr initialisierte Daten bentzt.  Wenn ein
Ausdruck nicht spezifiziert ist,  wird  das  Daten-Subsegment  0
ausgew„hlt. Wenn ein Ausdruck spezifiziert ist,  mu  sein  Wert
absolut und im Bereich 0...3 sein  und  auerdem  im ersten Lauf
definiert worden  sein.  Das  angegebene  Daten-Subsegment  wird
durch die Direktive ausgew„hlt.

=================================================================
D.17	COMM
=================================================================
COMM   Definiert gemeinsamen Speicherbereich.

Die  COMM-Direktive  ( Common )  definiert Namen und Gr”e eines
gemeinsamen Bereichs ( Common Area ), der von einzelnen Programm
Programmodulen   geteilt   wird.   Der  Name  wird  durch  Label
definiert.   Die  Gr”e  wird  in  Bytes  durch  einen  Ausdruck
spezifiziert.  Der Ausdruck mu absolut und gr”er als Null sein
und w„hrend des ersten Laufs definiert werden.  Fr  die weitere
Assemblierung wird das Common Label  wie  eine  externe Referenz
behandelt.  Der Speicherplatz fr gemeinsame Bereiche wird nicht
vom Assembler,  sondern  durch  den  Linker zugewiesen, der alle
gemeinsamen Bereiche  gleichen  Namens an dieselbe Adresse linkt
und ihnen gengend Speicher im BSS-Segment zuweist.

=================================================================
D.18	BSS
=================================================================
BSS    Selektiert das BSS-Segment.

Die BSS-Direktive w„hlt das BSS-Segment ( Block Storage) aus. In
diesem Segment kann kein Code erzeugt werden, es sind nur Label-
definitionen und Speicherzuweisungen  erlaubt.  In  die  Object-
Datei werden nur  die  Gr”eninformationen  und  Symbole  dieses
Segments  geschrieben.  Das  BSS-Segment  darf  nur  fr  nicht-
initialisierte Daten bentzt werden.

=================================================================
D.19	OFFSET
=================================================================
OFFSET Selektiert Segment absolut.

Die  OFFSET-Direktive  w„hlt  ein absolutes Segment aus, das bei
dem Wert eines  Ausdrucks  beginnt  bzw.  bei Null,  falls  kein
Argument  angegeben  wurde.  Diese  Direktive  ist  sinnvoll, um
Labels fr Structure Offsets zu deklarieren.  Das OFFSET-Segment
endet  mit  der  n„chsten  TEXT-,   DATA-   oder   BSS-Direktive
Innerhalb  des absoluten Segments kann kein Code erzeugt werden.
Es  sind  nur Labeldefinitionen und Speicherzuweisungen erlaubt.
Der  Wert  des Ausdrucks mu absolut sein und w„hrend des ersten
Laufs definiert werden.

=================================================================
D.20	LCOMM
=================================================================
LCOMM  Weist Speicherplatz fr eine Variable im BSS-Segment zu.

Die LCOMM-Direktive ist eine schnelle Methode, Speicherplatz fr
Variablen  im BSS-Segment zuzuweisen. Ein Label spezifiziert den
Namen der Variablen,  ein  Ausdruck die Anzahl der zuzuweisenden
Bytes.  Das gegenw„rtige Segment wird nicht gewechselt. Der Wert
des Ausdrucks  mu  absolut und gr”er als Null sein und w„hrend
des  ersten  Laufs  definiert werden.  Wenn die Anzahl der Bytes
gr”er als 1 ist,  wird  die  Variable automatisch an eine Word-
renze angepat.

=================================================================
D.21	GLOBL
=================================================================
GLOBL  Definiert ein Label als global oder extern.

Die GLOBL-Direktive  ( Global )  spezifiziert  ein  oder mehrere
Label  als  Global oder Extern. Wenn ein Label an anderer Stelle
im  gegenw„rtigen   Programm-Modul definiert ist,  wird  es  als
global deklariert  und  ist  von anderen Modulen aus zug„nglich.
Wenn ein Label im gegenw„rtigen Modul nicht definiert ist,  wird
es als Referenz  extern  deklariert  und  mu  in  einem anderen
Module  als  global  deklariert  werden.   Undefinierte  globale
Symbole mssen nicht mit dieser Direktive als extern  deklariert
werden, wenn in der Befehlszeile der  Schalter -U  gesetzt wird.
Die  EXPORT,  IMPORT,  XREF  und  XDEF-Direktiven  sind  nur aus
Kompatibilit„tsgrnden vorgesehen und bewirken dasselbe wie  die
GLOBL-Direktive.

=================================================================
D.22	XREF
=================================================================
XREF   Definiert ein Label als global oder extern.

Siehe GLOBL-Direktive.

=================================================================
D.23	XDEF
=================================================================
XDEF   Definiert ein Label als global oder extern.

Siehe GLOBL-Direktive.

=================================================================
D.24	ALINE
=================================================================
ALINE  Erzeugt Line A Opcode.

Die ALINE-Direktive erzeugt ein Line A Befehlsword,  das mit dem
Wert eines Ausdrucks einer logischen oder-Verknpfung unterzogen
wird.  Der  Wert mu absolut sein und im Bereich zwischen -$0800
und $0FFF liegen.

=================================================================
D.25	FLINE
=================================================================
FLINE  Erzeugt Line F Opcode.

Die FLINE-Direktive erzeugt ein Line F Befehlsword,  das mit dem
Wert eines Ausdrucks einer logischen oder-Verknpfung unterzogen
wird. Der Wert mu absolut sein und im Bereich  zwischen  -$0800
und $0FFF liegen.

Hinweis: Line F Befehle sollten fr Applikationen  nicht bentzt
werden,  da  sie  Bestandteil  der  MC68000-Coprozessor-Schnitt-
stellendefinition sind und  in  zuknftigen  Systemen u.U. nicht
mehr untersttzt werden. Die Line A Befehle sind fr Anwendungen
reserviert und drfen ohne Einschr„nkungen verwendet werden.

=================================================================
D.26	MC68000
=================================================================
MC68000          W„hlt den MC68000/08 Befehlssatz aus.

Die  MC68000-Direktive  selektiert  den   Befehlssatz   fr  die
MC68000 und MC68008 Mikroprozessoren. Vorher angew„hlte Befehls-
s„tze fr andere Prozessoren werden deaktiviert.

Die  MC68nnn-,  SUPER-  und  USER-Direktiven  dienen  dazu,  den
untersttzten Befehlssatz fr den Prozessortyp, den Coprozessor-
typ und/oder die  Coprozessor-Id auszuw„hlen. Als Voreinstellung
wird lediglich  der  Non-Privileged  MC68000 Befehlssatz  akzep-
tiert.

=================================================================
D.27	MC68010
=================================================================
MC68010          W„hlt den MC68010 Befehlssatz aus.

Die MC68010-Direktive selektiert den Befehlssatz fr den MC68010
Mikroprozessor.  Sie  entspricht dem Schalter -1 in der Befehls-
zeile.

Die  MC68nnn-,  SUPER-  und  USER-Direktiven  dienen  dazu,  den
untersttzten Befehlssatz fr den Prozessortyp, den Coprozessor-
typ und/oder die  Coprozessor-Id auszuw„hlen. Als Voreinstellung
wird lediglich  der  Non-Privileged  MC68000 Befehlssatz  akzep-
tiert.

=================================================================
D.28	MC68020
=================================================================
MC68020     W„hlt MC68020 Befehlssatz und Adressierungsmodi aus.

Die  MC68020-Direktive  selektiert  den   Befehlssatz   und  die
erweiterten Adressierungsarten fr den  MC68020  Mikroprozessor.
Sie entspricht dem Schalter -2 in der Befehlszeile.

Die  MC68nnn-,  SUPER-  und  USER-Direktiven  dienen  dazu,  den
untersttzten Befehlssatz fr den Prozessortyp, den Coprozessor-
typ und/oder die  Coprozessor-Id auszuw„hlen. Als Voreinstellung
wird lediglich  der  Non-Privileged  MC68000 Befehlssatz  akzep-
tiert.

=================================================================
D.29	MC68030
=================================================================
MC68030     W„hlt MC68030 Befehlssatz und Adressierungsmodi aus.

Die  MC68030-Direktive  selektiert  den   Befehlssatz   und  die
erweiterten Adressierungsarten fr den  MC68030  Mikroprozessor.
Sie entspricht dem Schalter -3 in der Befehlszeile.

Die  MC68nnn-,  SUPER-  und  USER-Direktiven  dienen  dazu,  den
untersttzten Befehlssatz fr den Prozessortyp, den Coprozessor-
typ und/oder die  Coprozessor-Id auszuw„hlen. Als Voreinstellung
wird lediglich  der  Non-Privileged  MC68000 Befehlssatz  akzep-
tiert.

=================================================================
D.30	MC68851
=================================================================
MC68851  W„hlt den MC68851 Befehlssatz und Coprozessor-Id aus.

Die MC68851-Direktive aktiviert den Befehlssatz fr die  MC68851
Paged Memory Management Unit ( PMMU ).  Der  optionale  Ausdruck
spezifiziert die fr die PMMU-Befehle verwendete Coprozessor-Id.
Voreingestellt  ist   die  Coprozessor-Id  0   ( Null ).   Diese
Direktive  entspricht  dem Schalter -5 in der Befehlszeile.  Ein
Minuszeichen als Argument fr diese  Direktive  deaktiviert  den
PMMU-Befehlssatz.

=================================================================
D.31	MC68881
=================================================================
MC68881 W„hlt den MC68881/82 Befehlssatz und Coprozessor-Id aus.

Die MC688881-Direktive aktiviert den Befehlssatz fr die MC68881
und  MC68882  Floating Point Units ( FPUs ). Ein optionaler Aus-
druck    spezifiziert   die   fr   die  FPU-Befehle  verwendete
Coprozessor-Id. Voreingestellt ist die Coprozessor-Id 1( Eins ).
Diese Direktive entspricht dem Schalter -8 in der  Befehlszeile.
Ein Minuszeichen als Argument fr  diese  Direktive  deaktiviert
den FPU-Befehlssatz.

=================================================================
D.32	SUPER
=================================================================
SUPER       W„hlt den privilegirten Befehlssatz aus.

Die   Super-Direktive   aktiviert   den   privileged-Befehlssatz
( Supervisor Mode )  des  gew„hlten Prozessors/Coprozessors. Sie
entspricht dem Schalter -S in der Befehlszeile.

=================================================================
D.33	USER
=================================================================
USER        W„hlt den nicht-privilegierten Befehlssatz aus.

Die USER-Direktive  deaktiviert  den  privileged-Befehlssatz des
gew„hlten Prozessors/Coprozessors.  Es werden nur non-privileged
Befehle ( User Mode ) akzeptiert.

=================================================================
D.34	INCLUDE
=================================================================
INCLUDE     Eine Datei wird in den Quellcode mit aufgenommen.

gew„hlten Prozessors/Coprozessors.  Es werden nur non-privileged
Die  INCLUDE-Direktive  liest  die Datei mit Namen Dateiname und
bindet sie in  den  Quelltext  ein.  Mehrere  INCLUDE-Direktiven
k”nnen auf bis zu 10 Ebenen verschachtelt werden.  Eine INCLUDE-
Direktive   darf  nicht   Teil  einer Makroexpansion sein,  aber
INCLUDE-Dateien   k”nnen  Makrodefinitionen   und   Makroaufrufe
enthalten.

=================================================================
D.35	PRINT
=================================================================
PRINT       Eine Meldung wird auf den Bildschirm ausgegeben.

Die PRINT-Direktive  gibt  die  angegebene Meldung auf den Bild-
schirm aus.   Wenn  kein  String   spezifiziert   wird,  erfolgt
lediglich eine Zeilenschaltung.   Die   Codeerzeugung  wird  von
dieser Direktive nicht beeinflut.

=================================================================
D.36	TTL
=================================================================
TTL         Definiert den Titel des Listings.

Die TTL-Direktive ( Title ) definiert den Titel,  der im Seiten-
kopf jeder Seite des Listings gedruckt wird.  Wenn die Direktive
in der ersten Zeile  einer  Listingseite spezifiziert ist,  wird
der Titel ab dieser Seite gesetzt,  andernfalls  ab der n„chsten
Seite.   In  einer  Quelldatei  drfen   mehrere  TTL-Direktiven
spezifiziert  werden,   so   da  Untertitel  fr   verschiedene
Programmabschnitte angegeben werden k”nnen.  Eine Variable %f im
Titelstring wird beim Ausdruck durch  den  Namen  der Quelldatei
ersetzt. Der voreingestellte Titel zu  Beginn  des  Listings ist
Source File: %f.

Die  Direktiven  TTL, PAGE, LIST und NOLIST steuern die Listing-
ausgabe.  Sie werden ignoriert,  wenn in der  Befehlszeile nicht
die Schalter -P oder -X gesetzt werden, wenn sie innerhalb eines
False Condition-Blocks auftreten sowie in Include-Dateien,  wenn
in der Befehlszeile -F angegeben wird. Die Codeerzeugung wird in
keinem Fall beeinflut.

=================================================================
D.37	PAGE
=================================================================
PAGE        Bestimmt den Seitenumbruch des Listings.

Die PAGE-Direktive steuert den Seitenumbruch des Listings.  Wenn
kein Ausdruck  spezifiziert wird, erzwingt diese Direktive  eine
Seitenschaltung ( Form Feed ) nach der momentanen Zeile. Ist ein
Ausdruck angegeben, erfolgt keine Seitenschaltung, aber die neue
Seitenl„nge wird auf die in  Ausdruck  spezifizierte  Zeilenzahl
gesetzt. Zu Beginn der Assemblierung ist die  Seitenl„nge auf 59
Zeilen voreingestellt.

Die  Direktiven  TTL, PAGE, LIST und NOLIST steuern die Listing-
ausgabe.  Sie werden ignoriert,  wenn in der  Befehlszeile nicht
die Schalter -P oder -X gesetzt werden, wenn sie innerhalb eines
False Condition-Blocks auftreten sowie in Include-Dateien,  wenn
in der Befehlszeile -F angegeben wird. Die Codeerzeugung wird in
keinem Fall beeinflut.

=================================================================
D.38	LIST
=================================================================
LIST        Schaltet die Generierung des Listings ein.

Die LIST-Direktive  erzeugt die Ausgabe eines Listings  bis  zur
n„chsten NOLIST-Direktive.

Die  Direktiven  TTL, PAGE, LIST und NOLIST steuern die Listing-
ausgabe.  Sie werden ignoriert,  wenn in der  Befehlszeile nicht
die Schalter -P oder -X gesetzt werden, wenn sie innerhalb eines
False Condition-Blocks auftreten sowie in Include-Dateien,  wenn
in der Befehlszeile -F angegeben wird. Die Codeerzeugung wird in
keinem Fall beeinflut.

=================================================================
D.39	NOLIST
=================================================================
NOLIST      Schaltet die Generierung des Listings aus.

Die NOLIST-Direktive unterdrck die Ausgabe des Listings bis zur
n„chsten LIST-Direktive.  Wenn  das  Listing durch NOLIST ausge-
schaltet ist, werden alle PAGE-  und  TTL-Direktiven  ignoriert.

Die  Direktiven  TTL, PAGE, LIST und NOLIST steuern die Listing-
ausgabe.  Sie werden ignoriert,  wenn in der  Befehlszeile nicht
die Schalter -P oder -X gesetzt werden, wenn sie innerhalb eines
False Condition-Blocks auftreten sowie in Include-Dateien,  wenn
in der Befehlszeile -F angegeben wird. Die Codeerzeugung wird in
keinem Fall beeinflut.

=================================================================
D.40	IFCC
=================================================================
IFcc        Markiert den Beginn eines Conditional Blocks.

Die  IFcc-Direktiven  bewerten  die   Bedingung  cc.   Wenn  die
Bedingung True ist, wird die darauffolgende Reihe von Statements
assembliert, bis eine ELSE-, ENDIF-Direktive oder ENDC-Direktive
angetroffen wird.  Andernfalls  wird  die  auf die ( optionale )
ELSE-Direktive folgende  Reihe  von  Statements assembliert, bis
eine ENDIF- oder ENDC-Direktive angetroffen wird.  Die konditio-
nalen  Direktiven  drfen  verschachtelt  werden.  Die  folgende
Tabelle zeigt die Syntax der IFcc-Direktive fr unterschiedliche
Bedingungen cc:

Syntax          Bedingung
----------------------------------------------------------------
IF Ausdruck     Ausdruck != 0
IFF Ausdruck    Ausdruck = 0
IFB Arg         Arg ist blank
IFNB Arg        Arg ist nicht blank
IF1             momentaner_Assemblerlauf = 1
IF2             momentaner_Assemblerlauf = 2
IFEQ Ausdruck   Ausdruck = 0
IFNE Ausdruck   Ausdruck != 0
IFLE Ausdruck   Ausdruck <= 0
IFLT Ausdruck   Ausdruck < 0
IFGE Ausdruck   Ausdruck >= 0
IFGT Ausdruck   Ausdruck > 0

----------------------------------------------------------------

Die  IFEQ-,  IFNE-, IFLE-, IFLT-, IFGE- und IFGT-Direktiven sind
nur aus Kompatibilit„tsgrnden vorgesehen.  Vorzugsweise sollten
die IF- oder IFF-Direktiven zusammen mit relationalen Operatoren
bentzt werden. Die ENDC-Direktive ist ein Synonym fr ENDIF.

=================================================================
D.41	ELSE
=================================================================
den vorgesehen.  Vorzugsweise sollten
die IF- oder IFF-Direktiven zusammen mit relational

=================================================================
D.42	ENDIF
=================================================================
ENDIF       Markiert das Ende eines Conditional Blocks.

Siehe IFCC.

=================================================================
D.43	ENDC
=================================================================
ENDC        Markiert das Ende eines Conditional Blocks.

Siehe IFCC.

=================================================================
D.44	END
=================================================================
END         Markiert das Ende des Assemblertextes.

Die  END-Direktive  markiert  das  Ende  der Assemblierung. Alle
eventuell auf diese Direktive folgenden Zeilen werden ignoriert.
Der Assembler gibt keine Fehlermeldung aus, wenn diese Direktive
fehlt.

=================================================================
D.45	MACRO
=================================================================
MACRO       Anfang einer Named Makrodefinition.

Siehe Makrodefinition.

=================================================================
D.46	REPT
=================================================================
REPT        Anfang einer Repeated Makrodefinition.

Die  REPT-Direktive   ist   eine  platzsparende   Methode,  eine
Statementsequenz  mehrfach  zu  wiederholen. Der Ausdruck spezi-
fiziert die Anzahl der Wiederholungen der  Reihe von Statements.
Er  mu absolut sein und  w„hrend  des  ersten  Laufs  definiert
werden.  Wenn  der  angegebene Wert kleiner als oder gleich Null
ist, wird keine Zeile generiert.  Die  REPT-Direktive  wird  mit
einer ENDM-Direktive beendet.

=================================================================
D.47	ENDM
=================================================================
ENDM        Ende einer Makrodefinition.

Siehe Makrodefinition.

=================================================================
D.48	EXITM
=================================================================
EXITM       Verlassen der gegenw„rtige Makroexpansionsebene.

Die  EXITM-Direktive  kann  innerhalb eines Makrobody auftreten.
Wenn diese Direktive angetroffen wird,  wird  die  Expansion des
gegenw„rtigen  Makros  abgebrochen.   Normalerweise  wird  EXITM
zusammen mit konditionalen Direktiven verwendet.  Innerhalb  des
False-Bereiches einer Bedingung wird EXITM ignoriert.

=================================================================
D.49	LOCAL
=================================================================
LOCAL       Definiert lokale Labels in einem Makro.

Die  LOCAL-Direktive  kann  innerhalb  eines Makrobody auftreten
und  definiert  einen oder mehrere Label-Namen, die singul„r fr
jede Wiederholung des Makros sind.  Wenn  w„hrend  der Expansion
eines Makros einer der angegebenen Namen  in  einer  Zeile ange-
troffen wird, wird er durch  einen  singul„ren  Namen  der  Form
_____nnnn   substituiert.  nnnn  wird  beginnend  mit  0000  als
dezimaler Wert in aufsteigender Folge zugewiesen.

E	Macros

Die Benutzung von Makros im šberblick

=================================================================
E.1	Macro Definition
=================================================================
Syntax  macro Name[.formal0] [formal1[,formal2...]
          Reihe_von_Statements        endm

Die macro-Direktive erm”glicht es, prototypartige  Sequenzen  von
Statements zu speichern und sp„ter  beim  Auftauchen  des  Makro-
namens zu substituieren. An das Makro k”nnen  optional  Argumente
zur Modifizierung der gespeicherten  Sequenzen  bergeben werden.

Die macro-Direktive speichert die  Statementsequenz  intern unter
dem Namen des Bezeichners Name. Die Statementsequenz wird mit der
zugeh”rigen  endm-Direktive   ( end macro )  abgeschlossen.   Die
optionalen Bezeichner *formal* sind die Namen der Formalparameter
des Makros.

Der gespeicherte Makrotext kann  sp„ter  durch  ein  Makroaufruf-
Statement an entsprechender Stelle  in  die  Assemblierung einge-
bunden werden.  Die Syntax  eines Makroaufrufs entspricht der des
Befehlsstatements,  wobei  der  Makroname  anstelle  des Befehls-
mnemonics steht:

[Label:...] Name[.aktuell0] [aktuell1[,aktuell2...]]

Nachdem  ein   Makroaufruf-Statement   angetroffen   wurde,  wird
anschlieend  jede  Zeile  des  Makrotextes in die  Assemblierung
eingebunden.   Wenn  w„hrend  dieses  Vorgangs  irgendein  in der
Makrodefinition  durch   *formal* gesetzter  Bezeichner  in einer
Zeile  des  Makrotextes  gefunden  wird,  wird  dieser Bezeichner
durch  den  korrespondierenden  aktuellen Parameter *aktuell* des
Makroaufrufs substituiert.

Beispiel:
---------

    macro syscall func     * Makroaufruf einer Systemfunktion
        move #func,d0      * Funktionsnummer setzen
        trap #2            * System aufrufen
    endm

Die Zeile

    syscall 4              * Systemfunktion Nummer 4 aufrufen

wird expandiert zu:

    move #4,d0             * Funktionsnummer setzen
    trap #2                * System aufrufen

=================================================================
E.2	Parameters
=================================================================
W„hrend  eines  Makroaufrufs  h„lt sich der Assembler beim Aufbau
der aktuellen Parameter an die folgenden Regeln:

- Der aktuelle0-Parameter beginnt mit dem ersten Zeichen nach dem
  auf den Punkt folgenden Leerzeichen ( Tab oder Leerstelle ) und
  endet beim n„chsten  Leerzeichen.

- Die anderen aktuellen Parameter beginnen mit dem ersten Zeichen
  nach dem auf den vorhergehenden Parameter folgenden Leerzeichen
  (Tab oder Leerstelle) und enden beim n„chsten Komma, Kommentar-
  Delimiter oder einer Zeilenschaltung.

- Leerzeichen nach dem Argument werden abgetrennt.

- Alle   Zeichen  innerhalb  verschachtelter Klammern und Strings
  werden bei der Suche nach dem Delimiter bersprungen.

- Wenn an diesem Punkt das erste Zeichen  eines aktuellen Parame-
  ters ein =, $ oder ein Klammeraffe und das n„chste Zeichen  ein
  ( ist, wird die bei (  beginnende  Zeichenfolge als Ausdruck
  betrachtet und unmittelbar als 32-Bit-Wert bewertet. Dieser Wert
  wird dann in eine die Zahl darstellende ASCII-Ziffernsequenz
  umgewandelt. Die Darstellung h„ngt vom zuvor gelesenen Zeichen ab:

Zeichen       Darstellung
-----------------------------------------------------------------
  =           Dezimal
  $           Hexadezimal
Klammeraffe   Oktal

-----------------------------------------------------------------

Dieser   Ziffernstring   wird   anschlieend   als der endgltige
aktuelle Parameter bernommen.

Beispiel:
---------
macro mac.a b,c,d,e,f
       ...
endm

Der Aufruf

mac . w  "Hallo, dies ist ein Test" ,100(a0 d2.w) , , =(2*5)

erzeugt die folgenden aktuellen Parameter:
a         'w'
b         '"Hallo, dies ist ein Test"
c         '100(a0 d2.w)'
d         ''
e         '10'
f         ''

=================================================================
E.3	Parameter Substitution
=================================================================
Die  folgenden  Regeln  gelten fr die Substitution eines Formal-
parameters durch einen aktuellen Parameter:

- Wenn  mehr  aktuelle  Parameter  als Formalparameter  angegeben
  werden,   werden  die  berz„hligen  Parameter  ignoriert. Wenn
  weniger  aktuelle  Parameter   angegeben  werden,   werden  die
  berz„hligen Formalparameter  durch  einen  Leerstring ersetzt.

- Normalerweise  erfolgt  keine  Parametersubstitution  innerhalb
  von Strings.

- Wenn  unmittelbar  vor  und/oder nach einem Formalparameter ein
  Additionszeichen  ( & )  steht,   werden  ( wird )   diese( s )
  Zeichen  nach  der  Substitution entfernt.  Diese  Funktion ist
  ntzlich   beim  Aneinanderreihen  von  Parametern  an   andere
  Parameter  oder  Bezeichner.    Ein   solcher   Formalparameter
  innerhalb eines Strings wird daher nicht ignoriert.

- Jeder  Parameter  wird  nur  einmal substituiert. Es gibt keine
  Rekursion,  wenn  ein  Formalparameter  einen  anderen  Formal-
  parameter  oder   sich   selbst   substituiert.   Damit  werden
  unendliche Rekursionen vermieden.

- Innerhalb  von  Kommentaren  findet  keine  Substitution statt.
  Kommentare   werden  w„hrend  der  Makroexpansion   vollst„ndig
  unterdrckt,    wenn   der    Kommentar-Delimiter  ( * oder ; )
  zweimal ( ** oder ;; ) angegeben wird.

- Der  optionale  erste  Formalparameter *.formal0* kann fr die
  šbergabe  von Gr”en-Spezifikationen  an den Makrobody bentzt
  werden  und  wird deshalb anders behandelt. Wenn *aktuell0* im
  Makroaufruf   angegeben  ist,   wird  die  normale  Parameter-
  substitution  vorgenommen.   Andernfalls   wird  der   Formal-
  parameter  durch  einen   Leerstring  substituiert.  Wenn  das
  erste  Zeichen  nach  eventuellen  fhrenden  Leerzeichen  ein
  Punkt ( . ) ist,  wird  es  durch  eine   Leerstelle  ersetzt.

Beispiele:
----------
    macro makelabel name,number
    name&number:
    endm

    makro makemessage message
        dc.b "Fehler: &message",$0d,$0a  * Meldung erzeugen
    endm

    macro push.size arg
        move.size arg,-(sp)  ** Dieser Kommentar
                             ** wird nicht expandiert
    endm


Die Zeilen

    makelabel error,10
    makemessage Dies ist ein Fehler
    push.l d0
    push #','

werden expandiert zu:

error10:
    dc.b "Fehler: Dies ist ein Fehler",$0d,$0a  * Meldung erzeugen
    move.l d0,-(sp)
    move #',',-(sp)

=================================================================
E.4	Calling
=================================================================
Makroaufrufe drfen verschachtelt werden. Ein Makrobody kann eine
Zeile  mit  dem  Aufruf  fr ein anderes Makro enthalten, etc. Es
sind bis zu 256 Verschachtelungsebenen erlaubt.

Beispiel:
---------

   macro syscall func     * Systemfunktion func aufrufen
       move #func,d0
       trap #2
   endm

   macro conout char      * Zeichen an Bildschirm ausgeben
       move.b char,d1
       syscall 1
   endm

Die Zeile

    conout (a0)+

expandiert auf der ersten Ebene zu:

    move.b (a0)+,d1
    syscall 1

und schlielich weiter zu:

    move.b (a0)+,d1
    move #1,d0
    trap #2

=================================================================
E.5	Recursion
=================================================================
Ein Makro kann sich  selbst  aufrufen,  oder ein Aufruf von einem
anderen Makro aus kann schlielich  zum  ursprnglich aufrufenden
Makro zurckfhren.  Diese  direkte  oder indirekte Rekursion ist
nur dann  sinnvoll,   wenn  durch  eine  bedingte  Direktive eine
unendliche Rekursion verhindert wird.

Beispiel:
---------

    macro decimal number     * Zahl in Dezimalstring konvertieren
      if (number) < 0
        dc.b "-"             ** Minuszeichen ezeugen...
        decimal -(number)    ** ...und Ziffern zur
                             ** Positivdarstellung
      else
        if (number) > 9
          decimal (number) / 10    ** h”herwertige Ziffern
                                   ** zuerst erzeugen
        endif
         dc.b (number) % 10 + '0'  ** letzte Ziffer erzeugen
      endif
    endm

Die Zeile

    decimal -12

expandiert zu ( nur codeerzeugende Zeilen gelistet ):
    dc.b "-"
    dc.b ((-(-12)) / 10) % 10 +'0'
    dc.b (-(-12)) % 10 +'0'

und hat denselben Effekt wie:

    dc.b "-12"

=================================================================
E.6	Nesting
=================================================================
Eine Makrodefinition darf eine andere Makrodefinition  enthalten.
Nur das  „uere  Makro  wird  durch  solch  eine  Makrodefinition
definiert. Das innere Makro wird w„hrend der ersten Expansion des
„ueren Makros definiert.

Beispiel:
---------

    macro init name
        lcomm name,16*4        * Bereich zum speichern zuweisen

        macro save             * Makro zum Speichern der
                               * Register im res. Bereich
            movem.l d0-q7,name
        endm

        macro restore          * Makro zum zurckschreiben
                               * der Register
            movem.l name,d0-a7
        endm
    endm

Nach dieser Definition steht nur das  Makro  init  zur Verfgung.
Es mu aufgerufen werden,  wenn  die  Makros  save  und   restore
aktiviert werden sollen. Die Zeilen

    init saved_regs            * Bereich "saved_regs" zum
                               * speichern zuweisen
                               *  und "save" und "restore"
                               * aktivieren
    ...

    save                       * Register in "saved_regs"
                               * speichern
    ...

    restore                    * Register von "saved_regs"
                               * zurckschreiben

expandieren zu:

    lcomm saved_regs,16*4      * Bereich zum speichern zuweisen
    macro save                 * Makro zum Speichern der
                               * Register im res. Bereich
        movem.l d0-a7,saved_regs
    endm

    macro restore              * Makro zum zurckschreiben der
                               * Register
        movem.l saved_regs,d0-a7
    endm
    ...
        movem.l d0-a7,saved_regs
    ...
        movem.l saved_regs,d0-a7

=================================================================
E.7	Redefinition
=================================================================
Makros  drfen  nach  der  ersten Definition redefiniert  werden.
Makros k”nnen sich  selbst  redefinieren.  Das ist ntzlich, wenn
eine  Initialisierung  vor  dem  ersten  Gebrauch   eines  Makros
erforderlich ist.  Wenn  ein  Makro  eine  Routine  enth„lt,  die
komplexe Operationen durchfhrt,  mu  diese  Routine nur w„hrend
des ersten Makroaufrufs erzeugt werden und  kann dann in weiteren
Aufrufen einfach angefordert werden.

F	Optimization

Codeoptimierungs-strategien des Assemblers - šbersicht

Der  MAS-68K Assembler stellt einen Codeoptimierer zur Verfgung,
der automatisch  den  Befehlscode optimiert, um Platz einzusparen
und die Ausfhrungszeit zu reduzieren.  Der Optimierer kann durch
den Schalter -N in der Befehlszeile deaktiviert  werden.  Dadurch
wird die Assemblierung beschleunigt,   weil  in  diesem  Fall nur
zwei Assemblerl„ufe  erforderlich  sind  und  einige Berechnungen
bersprungen werden k”nnen.  Wenn  der  Optimierer aktiviert ist,
ben”tigt der  Assembler  unter  Umst„nden bis zu drei Durchl„ufe.
Folgende Optimierungs-strategien werden von MAS-68K benutzt:

=================================================================
F.1	Expresssions
=================================================================
Der Optimierer mu schon w„hrend des ersten Laufs den endgltigen
Wert  aller  Ausdrcke  ( mit  Ausnahme  der  Verzweigungen ) fr
s„mtliche Optimierungen kennen.  Daher  k”nnen  Ausdrcke mit dem
Attribut  simple_absolute  versehen  werden.  Ein simple_absolute
Ausdruck ist entweder:

- Eine numerische oder Stringkonstante,
- ein rckw„rts definiertes Label mit einem einfachen Absolut-
  wert,
- oder ein Ausdruck mit lediglich Simple Absolute Operanden.

Wenn  eine  Optimierung  vom  Bereich  des Wertes eines Ausdrucks
abh„ngt, wird  das simple_absolute Attribut  abgefragt.  Wenn der
Ausdruck simple_absolute ist  und  der  Wert im passenden Bereich
liegt, wird die Optimierung durchgefhrt.  Andernfalls wird keine
Optimierung vorgenommen.

=================================================================
F.2	Instructions
=================================================================
Die  MC680x0  Assemblersprache  untersttzt  mehrere  Kurz-  oder
Schnellbefehle,  mit  denen  die  Programmausfhrung beschleunigt
und  die  Codegr”e  reduziert  werden kann.  Wo  es m”glich ist,
nutzt der Optimierer diese Kurzbefehle automatisch.

=================================================================
F.3	Addressing Modes
=================================================================
Der MC680x0 Befehlssatz stellt fr den absoluten Adressierungs-
modus eine Word- und eine Langform zur Verfgung. Der Assembler
erzeugt die Word-Form, wenn die Adresse Simple Absolute ist und
im Bereich von -$8000 bis $7fff liegt.

Die Adressierungsart Adress Register Indirect with Displacement
(disp(an)) wird zu Address Register indirect ((AN)) konvertiert,
wenn das Displacement Simple Absolute und der Wert null ist.

Die erweiterten  Adressierungsarten fr den MC68020 werden nach
M”glichkeit  in  die  kurzen Modi umgewandelt. Das vollst„ndige
MC68020-Format wird nur erzeugt, wenn

- Speicherindirektion bentzt wird, oder
- das Baseregister unterdrckt wird, oder
- das Displacement Simple Absolute ist und
- Outside Range zwischen -$8000 und $7fff liegt
  ( Indexregister nicht bentzt ).
- Outside Range zwischen -$80 und $7f liegt
  ( Indexregister bentzt ).

Andernfalls wird die Kurzform generiert.

Die Gr”e der Base und des „ueren  Displacements  wird fr die
erweiterten   Adressierungsarten   (  None,  Word  oder  Long )
ebenfalls automatisch bestimmt.

Ein Displacement  wird  nicht  erzeugt,  wenn kein Displacement
spezifiziert oder der Ausdruck  Simple  Absolute  und  der Wert
Null ist. Ein Word-Displacement wird erzeugt, wenn der Ausdruck
Simple Absolute ist und im  Bereich  zwischen  -$8000 und $7fff
liegt.

Andernfalls wird ein Long Displacement erzeugt.

Um die Codeerzeugung fr  die  verschiedenen Adressierungsarten
zu steuern,  kann  jeder  Ausdruck  optional  mit einer nachge-
stellten Gr”en-spezifikation  fr  Byte  ( .b oder .B ),  Word
( .w oder .W ) oder  Longword ( .l oder .L )  versehen  werden.
Wenn eine Gr”e spezifiziert ist, behandelt der Optimierer  den
Ausdruck als einen Simple Absolute  Ausdruck,  dessen  Wert  im
angegebenen Bereich liegt. Andernfalls berprft der Optimierer
den Bereich des Wertes.

=================================================================
F.4	Branching
=================================================================
Fr die BRA-, Bcc- und BSR-Befehle wird die Gr”e abh„ngig  von
der  Entfernung  zwischen  Befehl  und  Sprungziel  automatisch
bestimmt.  Im Gegensatz  zu  allen anderen Optimierungen werden
Verzweigungsbefehle  immer  optimiert,  wenn  es  sich  um eine
vorw„rtsgerichtete Referenz handelt.   Wenn  in dem Befehl eine
Gr”e ( .b, .w oder .l ) ausdrcklich spezifiziert ist oder das
Sprungziel nicht im selben Segment liegt oder es kein einzelnes
Label ist, wird keine Optimierung vorgenommen.

Die BRA- und Bcc-Befehle werden bergangen, wenn das Sprungziel
der n„chstfolgende Befehl ist.

Der  JSR-Befehl  wird  in    den   entsprechenden    BSR-Befehl
konvertiert,  wenn  das  Sprungziel  ein einzelnes Label und im
selben Segment ist.   Der  Assembler optimiert  keine vorw„rts-
gerichteten Verzweigungen, die eine Zuweisung an den Positions-
z„hler  ( ORG oder *= ) oder  eine  ALIGN-Direktive  mit  einem
Parameter ungleich 2 kreuzen.

In groen Quelltexten mit vielen  Verzweigungsbefehlen kann das
Statement  ALIGN 1 nach jeder Subroutine eingefgt  werden,  um
das  Optimieren  der  Verzweigungen  durch  den   Assembler  zu
beschleunigen.

G	Definitions

Erkl„rung der Abkrzungen

ea       Spezifikation einer Adressierungsart ( Effective
         Addresse ).
dn       Datenregister ( Data Register n ).
an       Adressregister ( Address Register n ).
xn       Adress- oder Datenregister n.
data     Adressierungsart die Daten unmittelbar spezifiziert.
         ( Immediate Data ).
label    Sprungmarke.
cr       Kontroll-Register des 680x0 Prozessors.
reglist  Spezifikation einer Registerliste.
offs     Datenregister oder Immediate Data, um  einen  Bitfeld-
         Offset zu spezifizieren.
width    Datenregister oder Immediate Data,  um  eine  Bitfeld-
         Breite zu spezifizieren.
.x       Gr”en-Spezifikationen fr Byte, Word oder Longword.
.a       Gr”en-Spezifikation fr Word oder Longword.
fpn      Fliekomma-Datenregister
fpcr     Fliekomma-Kontrollregister
fdlist   Liste von Fliekomma-Datenregistern
fclist   Liste von Fliekomma-Kontrollregistern
.f       Gr”en-Spezifikation fr Byte, Word, Longword,
         Single Precision Real, Double Precision Real,
         Extended Precision Real oder Packed Decimal Real
cc       Eine der folgenden Bedingungen:
               eq      - equal
               f       - false
               gE      - greater than or equal
               gl      - greater or less than
               glE     - greater, less or equal
               gt      - greater than
               le      - less than or equal
               lt      - less than
               ne      - not equal
               nge     - not ( greater than or equal )
               ngl     - not ( greater or less than )
               ngle    - not ( greater, less or equal )
               ngt     - not greater than
               nle     - not ( less than or equal )
               nlt     - not less than
               oge     - ordered greater than or equal
               ogl     - ordered greater or less than
               ogt     - ordered greater than
               ole     - ordered less than or equal
               olt     - ordered less than
               or      - ordered
               seq     - signaling equal
                sf     - signaling false
               sne     - signaling not equal
                st     - signaling true
                 T     - true
               ueq     - unordered or equal
               uge     - unordered or greater or equal
               ugt     - unordered or greater than
               ule     - unordered or less or equal
               ult     - unordered or less than
               un      - unordered
