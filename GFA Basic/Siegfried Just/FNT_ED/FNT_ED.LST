vers$=" FNT_ED.GFA, V.1/o, 4.April.91, ATARI-ST/TT, v.Pfr.S.Just,6936 Haag,Kirchweg 5 "
'
ON ERROR GOSUB schluss
ON BREAK GOSUB schluss
ON MENU KEY GOSUB m_getkey
ON MENU GOSUB m_deal
'
@init
@main
@schluss
END
'
PROCEDURE m_init
 LOCAL h%,n%,nmax%,mmax%,hx%,d%,i%,dummy%,h$
 '
 scrn_breit_pix%=WORK_OUT(0)
 scrn_hoeh_pix%=WORK_OUT(1)
 scrn_mono!=(WORK_OUT(35)=0)
 scrn_breit_byt%=INT{L~A+2}
 '
 esc$=CHR$(27)
 inv$=esc$+"p"
 norm$=esc$+"q"
 '
m_dat:
 ' MERGE-Punkt
 DATA Desk ,0,  CLS,0,----------------,0, ,0, ,0, ,0, ,0, ,0, ,0, ,0,""
 DATA Datei ,0, Laden,1, Speichern,2,------,0, QUIT,3,""
 DATA Font ,0, WechsleFont,4, Blank,6, System-Font,7, Invers,8, dÅnner,9, fetter,10, rotieren,23,- Horizontal<>,0, spiegeln,0, dehnen,0, stauchen,0,-Vertikal ^v,0, spiegeln,0, dehnen,0, stauchen,0,""
 DATA Buchstabe ,0,-Auch Direkt!,0, Copy->Puffer,15, Paste,16, Kill,17, Invers,18, Tauschen,19, dÅnner,20, fetter,21,- Horizontal<>,0, spiegeln,0, dehnen,0, stauchen,0,- Vertikal ^v,0, spiegeln,0, dehnen,0, stauchen,0,""
 DATA Hilfen ,0, Raster,25,-----,0, Hilfe-Seite,22,""
 DATA ""
 '
 ' Finde DIM-Grenzen
 RESTORE m_dat
 h%=0
 nmax%=0
 mmax%=0
 DO
  READ h$
  EXIT IF h$=""
  READ dummy%
  INC h%
  n%=0
  DO
   READ h$
   EXIT IF h$=""
   READ dummy%
   INC n%
  LOOP
  IF h%=1 THEN
   mmax%=n%
  ELSE
   nmax%=MAX(nmax%,n%)
  ENDIF
 LOOP
 DEC h%
 m.hs%=h%
 m.nmax%=nmax%
 DIM m.titel$(mmax%)
 DIM m.h_titl$(m.hs%+1),m.hx%(m.hs%+1),m.he%(m.hs%+1),m.hc$(m.hs%+1),m.ne%(m.hs%+1),m.ns%(m.hs%+1),m.ns_pix%(m.hs%+1)
 DIM m.n_titl$(m.hs%+1,m.nmax%+1),m.nc$(m.hs%+1,m.nmax%+1),m.nc_p%(m.hs%+1,m.nmax%+1),m.n_geht!(m.hs%+1,m.nmax%+1),m.com_nr%(m.hs%+1,m.nmax%+1)
 ARRAYFILL m.hx%(),0
 ARRAYFILL m.he%(),0
 ARRAYFILL m.ns%(),0
 ARRAYFILL m.ns_pix%(),19
 ARRAYFILL m.ne%(),0
 ARRAYFILL m.nc_p%(),0
 ARRAYFILL m.com_nr%(),0
 ARRAYFILL m.n_geht!(),TRUE
 '
 ' Fuelle Arrays, Finde Grenzen
 RESTORE m_dat
 h%=0
 DO
  READ h$
  EXIT IF h$=""
  READ dummy%
  m.titel$(h%)=h$
  INC h%
 LOOP
 '
 h%=0
 hx%=80 ! Linker Rand eines Menues
 DO
  READ h$
  EXIT IF h$=""
  READ dummy%
  INC h%
  m.h_titl$(h%)=h$
  m.hc$(h%)=LEFT$(h$,1)
  m.hx%(h%)=hx%
  ADD hx%,SHL(ADD(LEN(h$),1),3)
  m.he%(h%)=SUB(hx%,8)
  IF m.he%(h%)>scrn_breit_pix% THEN
   ALERT 1,"MenÅ|zu lang!",1,"WEITER",d%
  ENDIF
  n%=0
  DO
   READ h$
   EXIT IF h$=""
   INC n%
   READ m.com_nr%(h%,n%)
   m.n_titl$(h%,n%)=h$
   m.ne%(h%)=MAX(m.ne%(h%),SHL(ADD(LEN(h$),1),3))
   IF LEFT$(h$,1)="-" THEN
    m.n_geht!(h%,n%)=FALSE
   ELSE
    i%=0
    REPEAT
     INC i%
    UNTIL MID$(h$,i%,1)>"@" OR i%=LEN(h$)
    IF i%<LEN(h$) THEN
     m.nc$(h%,n%)=MID$(h$,i%,1)
     DEC i%
     m.nc_p%(h%,n%)=SHL(i%,3)
    ENDIF
   ENDIF
  LOOP
  ADD m.ne%(h%),m.hx%(h%)
  m.ns%(h%)=n%
  ADD m.ns_pix%(h%),ADD(SHL(n%,4),2)
 LOOP
 '
 MENU m.titel$()
 DEFMOUSE 0
 m.key&=0
 ABSOLUTE m.asc|,V:m.key&+1
 ABSOLUTE m.scan|,V:m.key&
 '
RETURN ! m_init
'
PROCEDURE init
 LOCAL l%,j%,a%
 @m_init
 INLINE fnt1%,4096
 INLINE fnt2%,4096
 INLINE sysfnt%,4096
 fntadr%=fnt1%
 fnt$="SYSTEM.FNT"
 a%={L~A-22}
 FOR l%=0 TO 255
  FOR j%=0 TO 15
   BYTE{fnt2%+SHL(l%,4)+j%}=BYTE{a%+l%+MUL(j%,256)}
  NEXT j%
 NEXT l%
 '
 cltoeol$=esc$+"K"
 cltoeop$=esc$+"J"
 '
 u_raster!=FALSE
 chr%=65 ! A
 scrn%=XBIOS(2)
 DIM cpuf|(15)
 ARRAYFILL cpuf|(),0
 '
 @m_aufbau
RETURN ! init
'
PROCEDURE m_aufbau
 LOCAL i%
 DEFFILL 1,2,7
 PBOX 0,0,scrn_breit_pix%,scrn_hoeh_pix%
 DEFFILL 0,0
 PBOX 0,0,scrn_breit_pix%,17
 IF scrn_breit_byt%=160 THEN
  DEFTEXT ,4,,6
  TEXT 16,8,"Desk"
  tt!=TRUE
 ELSE
  DEFTEXT ,4,,13
  TEXT 16,13,"Desk"
  tt!=FALSE
 ENDIF
 DEFTEXT ,1,,13
 FOR i%=1 TO m.hs%
  TEXT m.hx%(i%),13,m.h_titl$(i%)
  LINE ADD(m.hx%(i%),1),15,ADD(m.hx%(i%),6),15
 NEXT i%
 LINE 0,17,scrn_breit_pix%,17
 LINE 0,18,scrn_breit_pix%,18
 @fnt_anzeige
 ' PRINT AT(80,25);"X";
 PRINT AT(47,3);inv$;
 OUT 5,32,1,32
 PRINT AT(47,20);
 OUT 5,32,2,32
 PRINT AT(37,11);
 OUT 5,32,4,32
 PRINT AT(56,11);
 OUT 5,32,3,32
 PRINT norm$;
 PRINT AT(41,22);" ";inv$;" x ";norm$;" oder x oder 'Buchstabe' ";
 PRINT AT(41,23);" Direkt Åber        -MenÅ    ";
 PRINT AT(41,24);" die Tastatur                ";
 LINE 400,352,408,352
 LINE 464,352,472,352
 DEFTEXT ,4,2700,13
 TEXT 600,22," FNT_ED.GFA v.Pfr.S.Just,Kirchweg 5,6936 Haag "
 DEFTEXT ,1
 TEXT 580,102," P U B L I C - D O M A I N "
 DEFTEXT ,0,,8
 TEXT 564,32," GFABasic 3.5E auf ATARI-TT+TTM194 "
 DEFTEXT ,0,0,13
RETURN ! m_aufbau
'
PROCEDURE fnt_anzeige
 LOCAL x%,y%,c%,i%,j%,z%,adr%,fadr%
 DEFFILL 0,0
 PBOX 14,28,274,384
 x%=3
 y%=SHL(scrn_breit_byt%,5)
 scrn%=XBIOS(2)
 c%=0
 FOR i%=0 TO 15
  adr%=MUL(i%,22)
  IF u_raster! THEN
   DEFLINE 3
   LINE 14,32+adr%,274,32+adr%
   LINE 14,32+adr%+2,274,32+adr%+2
   LINE 14,32+adr%+8,274,32+adr%+8
   LINE 14,32+i%*22+11,274,32+i%*22+11
  ENDIF
  FOR j%=0 TO 15
   c%=SHL(i%,4)
   ADD c%,j%
   adr%=MUL(i%,22)
   SUB adr%,3
   MUL adr%,scrn_breit_byt%
   ADD adr%,scrn%
   ADD adr%,y%
   ADD adr%,ADD(j%,j%)
   ADD adr%,x%
   fadr%=SHL(c%,4)
   ADD fadr%,fntadr%
   FOR z%=0 TO 15
    BYTE{adr%}=BYTE{ADD(fadr%,z%)}
    ADD adr%,scrn_breit_byt%
   NEXT z%
  NEXT j%
 NEXT i%
 DEFLINE 0
 PRINT AT(1,3);inv$;" - ";AT(35,24);" + ";norm$;
 @box_um_char(FALSE)
 @char_anzeige
RETURN ! fnt_anzeige
'
PROCEDURE char_anzeige
 LOCAL i%,j%,w$
 FOR i%=0 TO 15
  w$=BIN$(BYTE{fntadr%+chr%*16+i%},8)
  PRINT AT(40,4+i%);
  FOR j%=1 TO 8
   IF MID$(w$,j%,1)="1" THEN
    PRINT "XX";
   ELSE
    PRINT "  ";
   ENDIF
  NEXT j%
 NEXT i%
 FOR i%=0 TO 15
  j%=SHL(i%,4)
  ADD j%,48
  LINE 312,j%,440,j%
  IF i%=2 OR i%=5 OR i%=13 OR i%=14 THEN
   LINE 312,j%+1,440,j%+1
  ENDIF
 NEXT i%
 FOR i%=0 TO 7
  j%=SHL(i%,4)
  ADD j%,312
  LINE j%,48,j%,304
  IF i%=1 OR i%=7 THEN
   LINE j%+1,48,j%+1,304
  ENDIF
 NEXT i%
RETURN ! char_anzeige
'
PROCEDURE box_um_char(weg!)
 LOCAL x%,y%
 y%=SHR(chr%,4)
 x%=SUB(chr%,SHL(y%,4))
 y%=ADD(28,MUL(y%,22))
 x%=ADD(23,SHL(x%,4))
 IF weg! THEN
  GRAPHMODE 3
 ENDIF
 BOX x%,y%,x%+9,y%+17
 GRAPHMODE 1
RETURN ! box_um_char
'
PROCEDURE char_wahl(mx%,my%)
 @box_um_char(TRUE)
 SUB mx%,24
 DIV mx%,16
 SUB my%,31
 DIV my%,22
 chr%=ADD(SHL(my%,4),mx%)
 chr%=MAX(0,chr%)
 chr%=MIN(chr%,255)
 @char_anzeige
 @box_um_char(FALSE)
RETURN ! char_wahl
'
PROCEDURE bit_change(mx%,my%,mk%)
 LOCAL adr%,w$,j%,i%,c%,fadr%,z%
 SUB mx%,312
 DIV mx%,16
 mx%=SUB(7,mx%)
 SUB my%,48
 DIV my%,16
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 ADD adr%,my%
 IF mk%=1 THEN
  BYTE{adr%}=BSET(BYTE{adr%},mx%)
 ELSE
  BYTE{adr%}=BCLR(BYTE{adr%},mx%)
 ENDIF
 @update_line(my%)
 @update_char
 PAUSE 10
RETURN ! bit_change
'
PROCEDURE update_line(l%)
 LOCAL adr%,i%,j%,z%,w$
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 ADD adr%,l%
 w$=BIN$(BYTE{adr%},8)
 PRINT AT(40,4+l%);
 FOR j%=1 TO 8
  IF MID$(w$,j%,1)="1" THEN
   PRINT "XX";
  ELSE
   PRINT "  ";
  ENDIF
 NEXT j%
 FOR i%=0 TO 7
  j%=SHL(i%,4)
  ADD j%,312
  LINE j%,48+l%*16,j%,48+16+l%*16
  IF i%=1 OR i%=7 THEN
   LINE j%+1,48+l%*16,j%+1,48+16+l%*16
  ENDIF
 NEXT i%
 j%=SHL(l%,4)
 ADD j%,48
 LINE 312,j%,440,j%
 IF l%=2 OR l%=5 OR l%=13 OR l%=14 THEN
  LINE 312,j%+1,440,j%+1
 ENDIF
RETURN ! update_line
'
PROCEDURE update_char
 LOCAL i%,j%,z%,adr%,fadr%
 i%=SHR(chr%,4)
 j%=chr%
 SUB j%,SHL(i%,4)
 adr%=MUL(i%,22)
 SUB adr%,3
 MUL adr%,scrn_breit_byt%
 ADD adr%,scrn%
 ADD adr%,SHL(scrn_breit_byt%,5)
 ADD adr%,ADD(j%,j%)
 ADD adr%,3
 fadr%=SHL(chr%,4)
 ADD fadr%,fntadr%
 FOR z%=0 TO 15
  BYTE{adr%}=BYTE{ADD(fadr%,z%)}
  ADD adr%,scrn_breit_byt%
 NEXT z%
RETURN ! update_char
'
PROCEDURE main
 LOCAL idx%,t$,htitl$,hmen$,ntitl$,nmen$,oldhidx%,dummy%,abbruch!,no%,w%,hopen!,hidx%,nidx%
 '
 hopen!=FALSE
 abbruch!=FALSE
 '
 DO
  m.key&=0
  '
  SHOWM
  REPEAT
   '
   ON MENU
   MOUSE mx%,my%,mk%
   ' PRINT AT(50,1);mx%;"|";my%;" ";
   '
   IF mx%>80 AND mx%<m.he%(m.hs%) THEN
    ' Maus im moeglichen Menuebereich
    IF my%<18 THEN
     ' Maus im Menueleisten-Bereich
     idx%=0
     REPEAT
      INC idx%
     UNTIL (mx%>m.hx%(idx%) AND mx%<m.he%(idx%)) OR idx%>m.hs%
     IF idx%<=m.hs% THEN
      ' Gueltiger Hauptmenue-Index
      IF idx%<>hidx% THEN
       IF hidx%>0 THEN
        PUT m.hx%(hidx%),1,htitl$
        PUT m.hx%(hidx%),19,nmen$
       ENDIF
       hidx%=idx%
       oldhidx%=idx%
       GET m.hx%(hidx%),1,m.he%(hidx%),15,htitl$
       PUT m.hx%(hidx%),1,htitl$,10
       GET m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%),nmen$
       DEFFILL 0,0
       PBOX m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%)
       BOX m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%)
       FOR i%=1 TO m.ns%(hidx%)
        IF m.n_geht!(hidx%,i%) THEN
         DEFTEXT ,0,,13
        ELSE
         DEFTEXT ,2,,13
        ENDIF
        TEXT m.hx%(hidx%)+2,17+i%*16,m.n_titl$(hidx%,i%)
        IF m.n_geht!(hidx%,i%) AND m.nc$(hidx%,i%)<"[" THEN
         LINE m.hx%(hidx%)+3+m.nc_p%(hidx%,i%),19+i%*16,m.hx%(hidx%)+9+m.nc_p%(hidx%,i%),19+i%*16
        ENDIF
       NEXT i%
       hopen!=TRUE
      ENDIF
     ENDIF
    ELSE
     ' Maus im Bereich der Nebenmenues unter der Hauptmenue-Leiste
     IF hopen! THEN
      ' Nebenmenue aufgeklappt, sonst KEINE Aktion!
      IF my%>19 AND my%<m.ns_pix%(hidx%) AND mx%>m.hx%(hidx%) AND mx%<m.ne%(hidx%) THEN
       ' Maus im exakten Nebenmenue-Bereich
       SUB my%,19
       idx%=MIN(m.ns%(hidx%),ADD(SHR(my%,4),1))
       IF idx%<>nidx% THEN
        ' Nur wenn sich der Index geaendert hat!
        IF nidx%>0 THEN
         ' Alten Nebenmenue-Index, sofern schon invertiert, restaurieren
         PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$
        ENDIF
        ' Endlich!
        nidx%=idx%
        IF m.n_geht!(hidx%,nidx%) THEN
         GET m.hx%(hidx%)+2,5+nidx%*16,m.ne%(hidx%)-2,20+nidx%*16,ntitl$
         PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$,10
        ELSE
         nidx%=0
        ENDIF
       ENDIF
      ELSE
       ' Maus ausserhalb des Nebenmenue-Bereiches
       IF nidx%>0 THEN
        PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$
       ENDIF
       nidx%=0
      ENDIF
     ENDIF
    ENDIF
   ELSE
    IF mx%<80 OR mx%>m.ne%(m.hs%) THEN
     ' Maus ausserhalb des rechten Randes
     IF nidx%>0 THEN
      PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$
     ENDIF
     nidx%=0
    ENDIF
    IF mx%<80 AND my%<18 THEN
     ' Maus zeigt auf DESKTOP-Eintrag!
     IF hidx%>0 THEN
      ' Falls Nebenmenue offen und Hauptmenuepunkt invertiert: Zuklappen
      PUT m.hx%(hidx%),1,htitl$
      PUT m.hx%(hidx%),19,nmen$
     ENDIF
     hidx%=0
     hopen!=FALSE
    ENDIF
   ENDIF
  UNTIL m.key&>0 OR mk%>0
  HIDEM
  '
  IF mk%>0 THEN
   IF mx%>24 AND mx%<270 AND my%>31 AND my%<374 THEN
    IF NOT hopen! THEN
     @char_wahl(mx%,my%)
    ENDIF
   ENDIF
   IF mx%>312 AND mx%<440 AND my%>48 AND my%<302 THEN
    IF NOT hopen! THEN
     @bit_change(mx%,my%,mk%)
    ENDIF
   ENDIF
   ' Menuepunkt angeklickt
   IF nidx%>0 THEN
    PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$
   ENDIF
   IF hidx%>0 THEN
    ' Falls Nebenmenue offen und Hauptmenuepunkt invertiert: Zuklappen
    PUT m.hx%(hidx%),1,htitl$
    PUT m.hx%(hidx%),19,nmen$
   ENDIF
   IF hidx%=0 OR nidx%=0 THEN
    hidx%=0
    nidx%=0
   ENDIF
   hopen!=FALSE
  ELSE
   ' Taste betaetigt
   t$=UPPER$(CHR$(m.asc|))
   IF hopen! THEN
    ' Hauptmenue offen, Nebenmenues heruntergeklappt
    ' Finde Nebenmenue-Index
    idx%=0
    REPEAT
     INC idx%
    UNTIL t$=m.nc$(hidx%,idx%) OR idx%>m.ns%(hidx%)
    IF idx%<=m.ns%(hidx%) THEN
     ' Gueltiger Nebenmenue-Index
     IF idx%<>nidx% THEN
      ' Nur wenn sich der Index geaendert hat!
      IF nidx%>0 THEN
       ' Alten Nebenmenue-Index, sofern schon invertiert, restaurieren
       PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$
      ENDIF
      ' Endlich!
      nidx%=idx%
      GET m.hx%(hidx%)+2,5+nidx%*16,m.ne%(hidx%)-2,20+nidx%*16,ntitl$
      PUT m.hx%(hidx%)+2,5+nidx%*16,ntitl$,10
     ENDIF
    ELSE
     ' Buchstabe NICHT ein gueltiger Anfangsbuchstabe: Zuklappen
     PUT m.hx%(hidx%),1,htitl$
     PUT m.hx%(hidx%),19,nmen$
     hidx%=0
     nidx%=0
     hopen!=FALSE
    ENDIF
   ELSE
    @direkt_befehl
    ' Nebenmenue noch nicht heruntergeklappt
    idx%=0
    REPEAT
     INC idx%
    UNTIL t$=m.hc$(idx%) OR idx%>m.hs%
    IF idx%<=m.hs% THEN
     ' Gueltiger Hauptmenue-Index
     IF mx%<80 AND my%<18 THEN
      ' Maus zeigt auf DESKTOP-Eintrag!
      SETMOUSE m.hx%(idx%)+8,my%
     ENDIF
     IF idx%<>hidx% THEN
      IF hidx%>0 THEN
       PUT m.hx%(hidx%),1,htitl$
       PUT m.hx%(hidx%),19,nmen$
      ENDIF
      hidx%=idx%
      oldhidx%=idx%
      GET m.hx%(hidx%),1,m.he%(hidx%),15,htitl$
      PUT m.hx%(hidx%),1,htitl$,10
      GET m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%),nmen$
      DEFFILL 0,0
      PBOX m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%)
      BOX m.hx%(hidx%),19,m.ne%(hidx%),m.ns_pix%(hidx%)
      FOR i%=1 TO m.ns%(hidx%)
       IF m.n_geht!(hidx%,i%) THEN
        DEFTEXT ,0,,13
       ELSE
        DEFTEXT ,2,,13
       ENDIF
       TEXT m.hx%(hidx%)+2,17+i%*16,m.n_titl$(hidx%,i%)
       IF m.n_geht!(hidx%,i%) AND m.nc$(hidx%,i%)<"[" THEN
        LINE m.hx%(hidx%)+3+m.nc_p%(hidx%,i%),19+i%*16,m.hx%(hidx%)+9+m.nc_p%(hidx%,i%),19+i%*16
       ENDIF
      NEXT i%
      hopen!=TRUE
     ENDIF
    ELSE
     ' Buchstabe KEIN gueltiger Hauptmenue-Anfangsbuchstabe
     IF hidx%>0 THEN
      ' Falls Nebenmenue offen und Hauptmenuepunkt invertiert: Zuklappen
      PUT m.hx%(hidx%),1,htitl$
      PUT m.hx%(hidx%),19,nmen$
     ENDIF
     hidx%=0
     nidx%=0
     hopen!=FALSE
    ENDIF
   ENDIF
  ENDIF
  '
  IF hidx%>0 AND nidx%>0 THEN
   PUT m.hx%(hidx%),1,htitl$
   PUT m.hx%(hidx%),19,nmen$
   no%=m.com_nr%(hidx%,nidx%)
   hidx%=0
   nidx%=0
   hopen!=FALSE
   @ausfuehren(no%,mk%)
  ENDIF
  '
  EXIT IF abbruch!
  '
 LOOP
RETURN ! main
'
PROCEDURE laden
 LOCAL v$,in$
 PRINT AT(1,1);cltoeol$;"   Name der 4096-Byte-Datei ? ";
 v$=fnt$
 FILESELECT "*.FNT",v$,in$
 IF in$>"" AND EXIST(in$) THEN
  fnt$=in$
  OPEN "I",#1,fnt$
  BGET #1,fntadr%,4096
  CLOSE #1
 ENDIF
 @m_aufbau
RETURN
'
PROCEDURE speichern
 LOCAL v$,aus$
 PRINT AT(1,1);cltoeol$;"   Abspeichern unter Namen ? ";
 v$=fnt$
 FILESELECT "*.FNT",v$,aus$
 IF aus$>"" THEN
  OPEN "O",#1,aus$
  BPUT #1,fntadr%,4096
  CLOSE #1
 ENDIF
 @m_aufbau
RETURN
'
PROCEDURE hilfe
 LOCAL k%,t%
 IF tt! THEN
  DEFFILL 1,2,7
  PBOX 0,0,scrn_breit_pix%,scrn_hoeh_pix%
 ELSE
 ENDIF
 DEFFILL 0,0
 PBOX 0,0,639,399
 PRINT AT(1,1);inv$;vers$;norm$
 PRINT
 PRINT " *** ";inv$;" WAHL d.BUCHSTABENS ";norm$;" *** mit Mausklick (Links/Rechts) oder '+'/'-' auf dem"
 PRINT "  Nummernblock!"
 PRINT
 PRINT " *** PIXEL ";inv$;" SETZEN ";norm$;" *** mit LINKS-Klick, *** ";inv$;" LôSCHEN ";norm$;" *** mit RECHTS-Klick"
 PRINT
 PRINT " *** MENö *** Da GFABasic 3.5E auf dem ATARI-TT mit TTM194 keine einwandfreie"
 PRINT "  MenÅleiste aufbauen kann, wurde die MenÅsteuerung 'von Hand' programmiert."
 PRINT "  Bis auf den Eintrag 'Desk' funktioniert Alles wie gewohnt - mit Ausnahme"
 PRINT "  der alternativen Tastatursteuerung des MenÅs (Unterstrichene Buchstaben)."
 PRINT "  Zu jeder Funktion kommen Sie damit Åber 2 TastendrÅcke. Das herunterklappen~"
 PRINT "  de MenÅ muû Sie nicht stîren."
 PRINT "  Der 'Desk'-Eintrag ist in Kleinschrift. Hier kommt die normale MenÅ-Steuerung"
 PRINT "  von GFABasic zum Einsatz. Beenden Sie die Anwahl des Eintrags immer korrekt!"
 PRINT "  Sonst kînnten Desk-MenÅ und ein anderes GLEICHZEITIG erscheinen! Der 1.Ein~"
 PRINT "  trag unter 'Desk' baut den Bildschirm von FNT_ED.GFA neu auf."
 PRINT
 PRINT " *** RECHNER ***: ST+SM124 (MONO) und TT+TTM194 (MONO, Hîchst-Auflîsung)"
 PRINT
 PRINT " *** Aktuelle Daten ***"
 PRINT " Zeichensatz-Puffer: ";inv$;
 IF fntadr%=fnt1% THEN
  PRINT "1";
 ELSE
  PRINT "2";
 ENDIF
 PRINT norm$;" Dateiname: '";inv$;fnt$;norm$;"'"
 PRINT " Buchstabe: '";inv$;" ";CHR$(chr%);" ";norm$;"' (";STR$(chr%,3);" $";HEX$(chr%,2);" ";BIN$(chr%,8);")"
 PRINT
 PRINT AT(20,25);inv$;"DrÅcken Sie eine Taste auf der Tastatur oder der Maus ! ";norm$;
 PAUSE 20
 SHOWM
 REPEAT
  k%=MOUSEK
  t%=GEMDOS(6,&HFF)
 UNTIL k%>0 OR t%>0
 HIDEM
 @m_aufbau
RETURN
'
PROCEDURE ausfuehren(num%,click%)
 SELECT num%
 CASE 1 ! COPYRIGHT
  @laden
 CASE 2 ! SPEICHERN
  @speichern
 CASE 3 ! QUIT
  IF click%>0 THEN
   PAUSE 20
  ENDIF
  ALERT 2,"FNT_ED.GFA|Wirklich Verlassen?",1,"JA|Nein",w%
  IF w%=1 THEN
   abbruch!=TRUE
  ENDIF
 CASE 4 ! WechsleFont
  IF fntadr%=fnt1% THEN
   fntadr%=fnt2%
  ELSE
   fntadr%=fnt1%
  ENDIF
  @m_aufbau
 CASE 6 ! BLANK
  FOR i%=fntadr% TO fntadr%+4093 STEP 4
   {i%}=0
  NEXT i%
  @m_aufbau
 CASE 7 ! SYSTEM-Font
  BMOVE sysfnt%,fntadr%,4096
  @m_aufbau
 CASE 8 ! INVERTIEREN
  FOR i%=fntadr% TO fntadr%+4093 STEP 4
   {i%}=NOT {i%}
  NEXT i%
  @m_aufbau
  ' 9 ! VerDöNNEN
  ' 10 ! VerFETTEN
  ' 23 ! ROTIEREN
 CASE 15 ! COPY Char
  @copy_char
 CASE 16 ! PASTE Char
  @paste_char
 CASE 17 ! KILL Char
  @kill_char
 CASE 18 ! INVERT Char
  @invert_char
 CASE 19 ! TAUSCHE Char
  @tausch_char
 CASE 22 ! HILFE
  @hilfe
 CASE 25 ! RASTER
  u_raster!=NOT u_raster!
  @m_aufbau
 DEFAULT
  IF click%>0 THEN
   PAUSE 20
  ENDIF
  ALERT 1,"Funktion "+STR$(no%)+"|Noch nicht|Implementiert!",1,"WEITER",dummy%
 ENDSELECT
RETURN ! ausfuehren
'
PROCEDURE direkt_befehl
 LOCAL x%,y%,k%
 LOCAL adr%,i%,w|
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 ' ALERT 1,"m.scan:"+STR$(m.scan|)+"|m.asc:"+STR$(m.asc|),1,"R",d%
 SELECT m.scan|
 CASE &H4B
  ' Nach links
  FOR i%=0 TO 15
   BYTE{ADD(adr%,i%)}=ROL|(BYTE{ADD(adr%,i%)},1)
   @update_line(i%)
  NEXT i%
  @update_char
 CASE &H4D
  ' Nach rechts
  FOR i%=0 TO 15
   BYTE{ADD(adr%,i%)}=ROR|(BYTE{ADD(adr%,i%)},1)
   @update_line(i%)
  NEXT i%
  @update_char
 CASE &H48
  ' Nach oben
  w|=BYTE{adr%}
  FOR i%=0 TO 14
   BYTE{ADD(adr%,i%)}=BYTE{ADD(adr%,i%)+1}
  NEXT i%
  BYTE{ADD(adr%,15)}=w|
  @char_anzeige
  @update_char
 CASE &H50
  ' Nach unten
  w|=BYTE{ADD(adr%,15)}
  FOR i%=15 TO 1 STEP -1
   BYTE{ADD(adr%,i%)}=BYTE{ADD(adr%,i%)-1}
  NEXT i%
  BYTE{adr%}=w|
  @char_anzeige
  @update_char
 CASE &H4A ! -
  @box_um_char(TRUE)
  DEC chr%
  IF chr%<0 THEN
   chr%=255
  ENDIF
  @char_anzeige
  @box_um_char(FALSE)
 CASE &H4E ! +
  @box_um_char(TRUE)
  INC chr%
  IF chr%>255 THEN
   chr%=0
  ENDIF
  @char_anzeige
  @box_um_char(FALSE)
 CASE 46 ! COPY Char
  @copy_char
 CASE 25 ! PASTE Char
  @paste_char
 CASE 23 ! INVERT Char
  @invert_char
 CASE 20 ! TAUSCHE Char
  @tausch_char
 ENDSELECT
RETURN ! rotate_char
'
PROCEDURE tausch_char
 LOCAL offs%,i%
 offs%=SHL(chr%,4)
 IF fntadr%=fnt1% THEN
  BMOVE ADD(fnt2%,offs%),ADD(fnt1%,offs%),16
 ELSE
  BMOVE ADD(fnt1%,offs%),ADD(fnt2%,offs%),16
 ENDIF
 ADD offs%,fntadr%
 @char_anzeige
 @update_char
RETURN ! tausch_char
'
PROCEDURE invert_char
 LOCAL adr%,i%
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 FOR i%=0 TO 15
  BYTE{adr%}=NOT BYTE{adr%}
  INC adr%
  @update_line(i%)
 NEXT i%
 @update_char
RETURN ! invert_char
'
PROCEDURE kill_char
 LOCAL adr%,i%
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 FOR i%=0 TO 15
  BYTE{adr%}=0
  INC adr%
  @update_line(i%)
 NEXT i%
 @update_char
RETURN ! kill_char
'
PROCEDURE copy_char
 LOCAL adr%,i%
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 FOR i%=0 TO 15
  cpuf|(i%)=BYTE{adr%}
  INC adr%
 NEXT i%
RETURN ! copy_char
'
PROCEDURE paste_char
 LOCAL adr%,i%
 adr%=SHL(chr%,4)
 ADD adr%,fntadr%
 FOR i%=0 TO 15
  BYTE{adr%}=cpuf|(i%)
  INC adr%
  @update_line(i%)
 NEXT i%
 @update_char
RETURN ! paste_char
'
PROCEDURE m_getkey
 m.key&=MENU(14)
RETURN
'
PROCEDURE m_deal
 @m_aufbau
RETURN ! m_deal
'
PROCEDURE schluss
 MENU KILL
 END
RETURN ! abmelden
'
