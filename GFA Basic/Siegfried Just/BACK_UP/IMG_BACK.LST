vers$=" IMG_BACK.GFA, Version 0/o3, 13.Febr.91,  8 Uhr, Pfr.S.Just,Kirchweg 5,6936 Haag, GFABasic 3.5E, ATARI-TT, 1280*960, FastLoad,FastCode,FastMem, *Public Domain* "
'
@init
@partitions_daten
@default_part
@main
@schluss
END
'
> PROCEDURE init
  LOCAL i%
  esc$=CHR$(27)
  inv$=esc$+"p"
  norm$=esc$+"q"
  cltoeop$=esc$+"J"
  cltoeol$=esc$+"K"
  cur_on$=esc$+"e"
  cur_off$=esc$+"f"
  beep$=CHR$(7)
  '
  mode_read&=2
  mode_write&=3
  '
  SPOKE &H444,0 ! Kein Verify!
  '
  DIM bpb&(8),dbpb&(8)
  bpb%=VARPTR(bpb&(0))
  drives&=15
  DIM sect_size_b&(drives&),clust_size_s&(drives&),clust_size_b&(drives&),root_size_s&(drives&),fat_size_s&(drives&),fat2_sect&(drives&),dat_sect&(drives&)
  DIM dat_clust_anz&(drives&),fat_size_bit&(drives&),root_sect&(drives&),part_free%(drives&),part_verbrauch%(drives&),disketten&(drives&)
  '
  bpb_bezs&=12
  DIM bpb_bez$(bpb_bezs&+1)
bpb_bez:
  DATA "SectSizeB","ClustSizeS","ClustSizeB","DirSizeS","FATSizeS","FAT2Sect","DatSect1","DatClustAnz","FATSizeBit","DirSect","ClustFree","ClustFull","Disks"
  RESTORE bpb_bez
  FOR i%=0 TO bpb_bezs&
    READ bpb_bez$(i%)
    bpb_bez$(i%)=LEFT$(bpb_bez$(i%)+"           ",11)
  NEXT i%
  '
  drv_map%=3 ! A: und B:
  drv_map$="AB"
  last_drv%=1 ! B:
  '
  disk_drv%=1 ! B:
  disk_drv$="B"
  part_drv%=2 ! C:
  part_drv$="C"
  '
  ' IMAGE der ersten 18 Sektoren einer 726016-Diskette nach der Formatierung
  INLINE disk_anfang%,9216
  INLINE invert%,16
  soft_format!=TRUE
  ' FAT-Buffer
  DIM fat_bufs|(32767)
  fat_buf%=VARPTR(fat_bufs|(0))
  ' 256K-Kopierbuffer
  DIM kop_bufs|(256*1024-1)
  kop_buf%=VARPTR(kop_bufs|(0))
  '
  ' Copyright
  ' CLS
  PRINT AT(1,1);inv$;vers$;norm$;
  DEFMOUSE 0
  ' Schnell blinkender Cursor
  VOID XBIOS(21,2,-1)
  VOID XBIOS(21,4,20)
RETURN !init
> PROCEDURE partitions_daten
  LOCAL i%,j%,k%,s%
  PRINT
  PRINT " ";inv$;" Ihre Festplatte: ";norm$
  s%=CRSLIN
  drv_map%=BIOS(10)
  j%=1
  FOR k%=0 TO bpb_bezs&
    PRINT AT(1,s%+k%+1);bpb_bez$(k%);":";
  NEXT k%
  FOR i%=2 TO drives&
    IF BTST(drv_map%,i%) THEN
      drv_map$=drv_map$+CHR$(65+i%)
      j%=i%
      BMOVE BIOS(7,i%),bpb%,18
      sect_size_b&(i%)=bpb&(0)
      clust_size_s&(i%)=bpb&(1)
      clust_size_b&(i%)=bpb&(2)
      root_size_s&(i%)=bpb&(3)
      fat_size_s&(i%)=bpb&(4)
      fat2_sect&(i%)=bpb&(5)
      dat_sect&(i%)=bpb&(6)
      dat_clust_anz&(i%)=bpb&(7)
      fat_size_bit&(i%)=bpb&(8)
      root_sect&(i%)=fat2_sect&(i%)+fat_size_s&(i%)
      part_free%(i%)=DFREE(i%+1) DIV clust_size_b&(i%)
      part_verbrauch%(i%)=dat_clust_anz&(i%)-part_free%(i%)-2
      disketten&(i%)=part_verbrauch%(i%) DIV 711
      IF (part_verbrauch%(i%) MOD 711)>0 THEN
        INC disketten&(i%)
      ENDIF
      PRINT AT((i%-2)*7+13,s%);CHR$(i%+65);":\"
      FOR k%=0 TO 8
        PRINT AT((i%-2)*7+13,s%+k%+1);bpb&(k%);
      NEXT k%
      PRINT AT((i%-2)*7+13,s%+10);root_sect&(i%);
      PRINT AT((i%-2)*7+13,s%+11);part_free%(i%);
      PRINT AT((i%-2)*7+13,s%+12);part_verbrauch%(i%);
      PRINT AT((i%-2)*7+13,s%+13);disketten&(i%);
    ENDIF
  NEXT i%
  last_drv%=j%
  PRINT
RETURN ! partitions_daten
> PROCEDURE default_part
  ' BPB der Partition einlesen
  BMOVE BIOS(7,part_drv%),bpb%,18
  ' FAT der Partition einlesen
  IF BIOS(4,mode_read&,L:fat_buf%,fat_size_s&(part_drv%),fat2_sect&(part_drv%),part_drv%)<>0 THEN
    ALERT 3,"Verzeichnis|von Partition "+part_drv$+":\|unleserlich! ",1,"WEITER",dummy%
  ENDIF
RETURN ! default_part
'
> PROCEDURE main
  LOCAL w$,a$
  PRINT
  PRINT cltoeol$
  men_y%=CRSLIN
  PRINT cltoeol$
  PRINT cltoeol$
  DO
    PRINT AT(1,men_y%);cltoeol$;" ";inv$;"L";norm$;"aden VON Disk, ";
    PRINT inv$;"S";norm$;"peichern AUF Disk, ";
    PRINT inv$;"P";norm$;"artition wÑhlen(";part_drv$;"), ";
    PRINT inv$;"D";norm$;"iskettenlaufwerk wÑhlen(";disk_drv$;"), ";
    PRINT inv$;"I";norm$;"nvertieren, ";
    PRINT "E";inv$;"x";norm$;"it ";
    PRINT cur_on$;
    w$=UPPER$(CHR$(EVNT_KEYBD()))
    PRINT cur_off$;cltoeol$
    EXIT IF w$="X"
    SELECT w$
    CASE "I" ! Invertieren
      ~C:invert%(L:XBIOS(2),L:153600 DIV 4)
    CASE "L" ! Laden VON Disk
      @disk_to_hard
    CASE "S" ! Speichern AUF Disk
      @hard_to_disk
    CASE "P" ! Partition waehlen
      PRINT AT(1,men_y%);cltoeol$;" WÑhlen Sie Ihre Partition: ";cur_on$;
      a$=UPPER$(CHR$(EVNT_KEYBD()))
      PRINT cur_off$;cltoeol$
      IF INSTR(drv_map$,a$) THEN
        part_drv$=a$
        part_drv%=ASC(a$)-65
        ' BPB der Partition einlesen
        BMOVE BIOS(7,part_drv%),bpb%,18
        ' FAT der Partition einlesen
        IF BIOS(4,mode_read&,L:fat_buf%,fat_size_s&(part_drv%),fat2_sect&(part_drv%),part_drv%)<>0 THEN
          ALERT 3,"Verzeichnis|von Partition "+part_drv$+":\|unleserlich! ",1,"WEITER",dummy%
        ENDIF
      ELSE
        ALERT 3," Partition "+a$+":\|nicht vorhanden!",1,"WEITER",dummy%
      ENDIF
    CASE "D" ! Diskettenlaufwerk waehlen
      PRINT AT(1,men_y%);cltoeol$;" WÑhlen Sie das Datensicherungslaufwerk A oder B: ";cur_on$;
      a$=UPPER$(CHR$(EVNT_KEYBD()))
      PRINT cur_off$;cltoeol$
      IF a$="A" THEN
        disk_drv$=a$
        disk_drv%=0
      ENDIF
      IF a$="B" THEN
        disk_drv$=a$
        disk_drv%=1
      ENDIF
    CASE "X" ! E-x-it
      ' Niemals
    DEFAULT
      ALERT 3,"Kommando '"+w$+"'|Unbekannt!",1,"WEITER",dummy%
    ENDSELECT
  LOOP
RETURN ! main
'
> PROCEDURE hard_to_disk
  LOCAL gebraucht%,diskette%,t$,d$,cl%,fehler!,dfrei%,info$,w$,header$,fadr%,fwert%,offset%,fkt%,sect%,dat$
  '
  PRINT AT(1,men_y%);cltoeol$;" '726016-Disketten' in ";disk_drv$;": jeweils Lîschen vorher? ['n',...] ";cur_on$;
  IF UPPER$(CHR$(EVNT_KEYBD()))="N" THEN
    soft_format!=FALSE
  ELSE
    soft_format!=TRUE
  ENDIF
  PRINT cur_off$;cltoeol$
  '
  diskette%=0
  t$=TIME$
  d$=DATE$
  cl%=2
  offset%=dat_sect&(part_drv%)
  fkt%=clust_size_s&(part_drv%)
  fadr%=fat_buf%+hd_start%*2
  fwert%=BYTE{fadr%}+256*BYTE{fadr%+1}
  gebraucht%=0
  fehler!=FALSE
  '
  IF NOT fehler! THEN
    DO
      '
      ' Naechste Diskette mit Abbruch-Moeglichkeit
      INC diskette%
      PRINT AT(1,men_y%);cltoeol$;" Legen Sie die Diskette ";inv$;" ";diskette%;" ";norm$;" ein und drÅcken Sie dann eine Taste! ['x' bricht ab!,'i' invertiert] ";cur_on$;
      w$=UPPER$(INPUT$(1))
      PRINT cur_off$;cltoeol$
      IF w$="I" THEN
        ~C:invert%(L:XBIOS(2),L:153600 DIV 4)
      ENDIF
      IF w$="X" THEN
        fehler!=TRUE
      ENDIF
      EXIT IF fehler!
      '
      ' 'Loeschen' der Diskette
      IF soft_format! THEN
        PRINT AT(1,men_y%);cltoeol$;" 'Lîsche' die Diskette ";diskette%
        IF BIOS(4,mode_write&,L:disk_anfang%,18,0,disk_drv%)<>0 THEN
          ALERT 3,"Soft-Formatierung|von "+disk_drv$+"|Fehlgeschlagen",1,"ABBRUCH",dummy%
          fehler!=TRUE
        ENDIF
      ENDIF
      EXIT IF fehler!
      '
      ' INFO-Datei schreiben
      info$=disk_drv$+":\INFO"+STR$(diskette%)+".ASC"
      PRINT AT(1,men_y%);cltoeol$;" Schreibe ";info$
      OPEN "O",#1,info$
      PRINT #1,part_drv$;":\-Partition mit den Daten:"
      FOR i%=0 TO 8
        PRINT #1,bpb&(i%)
      NEXT i%
      PRINT #1,STRING$(25,"-")
      PRINT #1,STR$(diskette%);".Diskette mit 726016 Bytes free"
      PRINT #1,DATE$
      PRINT #1,TIME$
      CLOSE #1
      dfrei%=DFREE(disk_drv%+1)
      '
      ' Auf Diskette 1 die kompletten Verwaltungssektoren schreiben
      IF diskette%=1 THEN
        gebraucht%=dat_sect&(part_drv%)*sect_size_b&(part_drv%)
        IF gebraucht%>dfrei% THEN
          ALERT 3,"Diskspeicherplatz|zu klein!",1,"ABBRUCH",dummy%
          fehler!=TRUE
        ENDIF
        IF BIOS(4,mode_read&,L:kop_buf%,dat_sect&(part_drv%),0,part_drv%)<>0 THEN
          ALERT 3,"Header-Sektoren|von "+disk_drv$+"|unleserlich",1,"ABBRUCH",dummy%
          fehler!=TRUE
        ENDIF
        IF NOT fehler! THEN
          PRINT AT(1,men_y%);cltoeol$;" Schreibe die ersten Sektoren mit Verwaltungsinformationen als ";header$;" auf Diskette! "
          header$=disk_drv$+":\HEADER.DAT"
          OPEN "O",#1,header$
          BPUT #1,kop_buf%,gebraucht%
          CLOSE #1
        ENDIF
      ENDIF
      EXIT IF fehler!
      '
      dfrei%=DFREE(disk_drv%+1)
      dat$=disk_drv$+":\CLUST"+STR$(diskette%)+".DAT"
      gebraucht%=clust_size_b&(part_drv%)
      dfrei%=dfrei% DIV gebraucht%
      PRINT AT(1,men_y%);cltoeol$;" Schreibe die HD-Cluster in Datei ";dat$;" auf Laufwerk ";disk_drv$;" (";dfrei%;" Cluster frei)"
      OPEN "O",#1,dat$
      y%=CRSLIN
      DO
        IF BYTE{fat_buf%+cl%*2}+256*BYTE{fat_buf%+cl%*2+1}<>0 THEN ! Cluster belegt
          sect%=fkt%*(cl%-2)+offset%
          ~BIOS(4,mode_read&,L:kop_buf%,clust_size_s&(part_drv%),sect%,part_drv%)
          PRINT AT(1,men_y%);" Cluster ";cl%;" Sektor ";sect%;" DiskFrei ";dfrei%;cltoeol$;
          BPUT #1,kop_buf%,gebraucht%
          DEC dfrei%
        ENDIF
        INC cl%
        EXIT IF dfrei%<3 ! Noch 3 KB frei
        EXIT IF cl%>dat_clust_anz&(part_drv%)
      LOOP
      CLOSE #1
      PRINT
      EXIT IF cl%>dat_clust_anz&(part_drv%)
      '
    LOOP
  ENDIF
  IF fehler! THEN
    PRINT beep$;
    ALERT 3,"Daten auf|Diskette "+disk_drv$+":|ungÅltig!",1,"WEITER",dummy%
    PRINT beep$;
  ENDIF
RETURN ! hard_to_disk
> PROCEDURE disk_to_hard
  LOCAL diskette%,fehler!,i%,w$,info$,h$,t$,d$,cl%,l%,header$,sectors%,offset%,fadr%,flen%,dat$,gebraucht%,clusters%,y%,cl%,sector%,fkt%
  '
  fehler!=FALSE
  diskette%=0
  offset%=dat_sect&(part_drv%)
  fkt%=clust_size_s&(part_drv%)
  cl%=1
  h$=""
  w$=""
  '
  DO
    '
    INC diskette%
    PRINT AT(1,men_y%);cltoeol$;" Legen Sie die Diskette ";inv$;" ";diskette%;" ";norm$;" ein und drÅcken Sie eine Taste! ['x' bricht ab, 'i' invertiert] ";cur_on$;
    w$=UPPER$(INPUT$(1))
    PRINT cur_off$;cltoeol$
    IF w$="I" THEN
      ~C:invert%(L:XBIOS(2),L:153600 DIV 4)
    ENDIF
    IF w$="X" THEN
      fehler!=TRUE
    ENDIF
    EXIT IF fehler!
    '
    info$=disk_drv$+":\INFO"+STR$(diskette%)+".ASC"
    IF NOT EXIST(info$) THEN
      ALERT 3,"Falsche Diskette?|'"+info$+"'|Fehlt!",1,"ABBRUCH",dummy%
      fehler!=TRUE
    ENDIF
    EXIT IF fehler!
    '
    PRINT AT(1,men_y%);cltoeol$;" öberprÅfe Daten anhand von ";info$
    OPEN "I",#1,info$
    LINE INPUT #1,h$
    h$=LEFT$(h$,1)
    IF h$<>part_drv$ THEN
      ALERT 3,"Falsche Partition!|Disk:"+h$+"|HD:"+part_drv$,1,"ABBRUCH",dummy%
      fehler!=TRUE
    ENDIF
    IF NOT fehler! THEN
      FOR i%=0 TO 8
        LINE INPUT #1,h$
        dbpb&(i%)=VAL(h$)
        IF dbpb&(i%)<>bpb&(i%) THEN
          ALERT 3,bpb_bez$(i%)+"|unterschiedlich!",1,"ABBRUCH",dummy%
          fehler!=TRUE
        ENDIF
      NEXT i%
    ENDIF
    IF NOT fehler! THEN
      LINE INPUT #1,h$
      LINE INPUT #1,h$
      IF VAL(h$)<>diskette% THEN
        ' ALERT 3,"Falsche ZÑhlung|INTERNER Fehler!",1,"ABBRUCH",dummy%
        ' fehler!=TRUE
      ENDIF
    ENDIF
    IF NOT fehler! THEN
      LINE INPUT #1,h$
      IF diskette%=1 THEN
        t$=h$
      ELSE
        IF h$<>t$ THEN
          ' ALERT 3,"Diskette aus|ANDERER|Zeitreihe!",1,"ABBRUCH",dummy%
          ' fehler!=TRUE
        ENDIF
      ENDIF
    ENDIF
    IF NOT fehler! THEN
      LINE INPUT #1,h$
      IF diskette%=1 THEN
        d$=h$
      ELSE
        IF h$<>t$ THEN
          ' ALERT 3,"Diskette aus|ANDERER|Datumsreihe!",1,"ABBRUCH",dummy%
          ' fehler!=TRUE
        ENDIF
      ENDIF
    ENDIF
    h$=""
    CLOSE #1
    EXIT IF fehler!
    '
    '
    IF diskette%=1 THEN
      header$=disk_drv$+":\HEADER.DAT"
      IF EXIST(header$) THEN
        PRINT AT(1,men_y%);cltoeol$;" Lese die Verzeichnis-Daten der ersten Sektoren aus ";header$
        OPEN "I",#1,header$
        l%=LOF(#1)
        BGET #1,kop_buf%,l%
        CLOSE #1
        sectors%=l% DIV sect_size_b&(part_drv%)
        IF sectors%<>offset% THEN
          ALERT 3,"HeaderlÑnge falsch|Disk:"+STR$(sectors%)+"|HD:"+STR$(offset%),1,"ABBRUCH",dummy%
          fehler!=TRUE
        ELSE
          ' GOTO debug
          IF BIOS(4,mode_write&,L:kop_buf%,sectors%,0,part_drv%)<>0 THEN
            ALERT 3,"Verzeichnis|nicht beschreibbar!",1,"ABBRUCH",dummy%
            fehler!=TRUE
          ENDIF
        debug:
        ENDIF
      ELSE
        ALERT 3,header$+"|fehlt!",1,"ABBRUCH",dummy%
        fehler!=TRUE
      ENDIF
    ENDIF
    EXIT IF fehler!
    '
    ' FAT einlesen
    fadr%=kop_buf%+fat2_sect&(part_drv%)*sect_size_b&(part_drv%)
    flen%=fat_size_s&(part_drv%)*sect_size_b&(part_drv%)
    BMOVE fadr%,fat_buf%,flen%
    IF LPEEK(fat_buf%)<>&HF8FFFFFF THEN
      ALERT 3,"FAT in|Unordnung!",1,"ABBRUCH",dummy%
      fehler!=TRUE
    ENDIF
    EXIT IF fehler!
    '
    dat$=disk_drv$+":\CLUST"+STR$(diskette%)+".DAT"
    IF EXIST(dat$) THEN
      OPEN "I",#1,dat$
      l%=LOF(#1)
      gebraucht%=clust_size_b&(part_drv%)
      clusters%=l% DIV gebraucht%
      PRINT AT(1,men_y%);cltoeol$;" Lese ";clusters%;" Cluster aus ";dat$;" ein."
      y%=CRSLIN
      DO
        BGET #1,kop_buf%,gebraucht%
        DEC clusters%
        REPEAT
          INC cl%
        UNTIL BYTE{fat_buf%+cl%*2}+256*BYTE{fat_buf%+cl%*2+1}<>0 ! OR cl%>dat_clust_anz&(part_drv%)
        ' EXIT IF cl%>dat_clust_anz&(part_drv%)
        sector%=offset%+fkt%*(cl%-2)
        PRINT AT(1,men_y%);" Cluster ";cl%;" Sektor ";HEX$(sector%);" Rest-Cluster ";clusters%;" ";
        ' GOTO hallo
        IF BIOS(4,mode_write&,L:kop_buf%,clust_size_s&(part_drv%),sector%,part_drv%)<>0 THEN
          ALERT 3,"Cluster lieû|sich nicht|schreiben!",1,"ABBRUCH",dummy%
          fehler!=TRUE
        ENDIF
      hallo:
        EXIT IF clusters%=0 OR fehler!
      LOOP
      PRINT
      CLOSE #1
    ELSE
      ALERT 3,dat$+"|Nicht gefunden!",1,"ABBRUCH",dummy%
      fehler!=TRUE
    ENDIF
    '
  LOOP
  '
RETURN ! disk_to_hard
'
> PROCEDURE schluss
  SPOKE &H444,1 ! Verify!
RETURN ! schluss
'
