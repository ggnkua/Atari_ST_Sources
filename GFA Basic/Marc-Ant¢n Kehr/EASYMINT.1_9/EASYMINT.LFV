' ----------------------------------------------------------------------------
'
'  EasyMiNT install 1.81b von M.A. Kehr
'
'  29.12.2001, 08:52:44
'
'  (faceVALUE V3.2 PL3á , vom 11.08.00)
'
' ----------------------------------------------------------------------------
'
$m128000                          ! Speicherverbrauch eintragen
compiled!=BYTE{BASEPAGE+256}<>96
' --CMP
IF NOT compiled!
  RESERVE 128000                  ! Speicherverbrauch eintragen
  CHDRIVE "I"                     !***Pfad einstellen (im Interpreter)
  CHDIR "F:\EASYMINT.1_8\"         !***Pfad einstellen (im Interpreter)
ENDIF
' --CMP
'
ON BREAK GOSUB system_restore !This line can be deleted before compiling   !-CMP
ON ERROR GOSUB system_error   !This line can be deleted before compiling   !-CMP
@start_up                     !Code produced using faceVALUE
' ------------------------------------------------------------------------
' Wrinkle-Information / Dokumentation:
'
> PROCEDURE project_settings
  ' WARNING: The contents of this procedure should not be edited!
  ' INFO "GFA-Basic Editor v1.51          "
  ' DATE "05/17/2013"
  ' TIME "10:44:10"
  ' LIB$ "68k       "
  ' LIB# $5
  ' $CMD %00000000000000000000000000000000
  ' $RAM $00000000
  ' FLGS %00010111
  ' _SYM $0
  ' .EXT "prg"
  ' OBJ0 "                                "
  ' OBJ1 "                                "
  ' OBJ2 "                                "
  ' OBJ3 "                                "
  ' OBJ4 "                                "
  ' OBJ5 "                                "
  ' CRSR $00000C8F
  ' BLKS $FFFFFFFF
  ' BLKE $FFFFFFFF
  ' MRK0 $FFFFFFFF
  ' MRK1 $FFFFFFFF
  ' MRK2 $FFFFFFFF
  ' MRK3 $FFFFFFFF
  ' MRK4 $FFFFFFFF
  ' MRK5 $FFFFFFFF
  ' MRK6 $FFFFFFFF
  ' MRK7 $FFFFFFFF
  ' MRK8 $FFFFFFFF
  ' MRK9 $00000988
  ' FIND '00                                                            '
  ' RPLC '00                                                            '
  ' FRH0 '00                                                            '
  ' FRH1 '00                                                            '
  ' FRH2 '00                                                            '
  ' FRH3 '00                                                            '
  ' FRH4 '00                                                            '
  ' FRH5 '00                                                            '
  ' FRH6 '00                                                            '
  ' FRH7 '00                                                            '
  ' FRH8 '00                                                            '
  ' FRH9 '00                                                            '
  ' PST0 '00                                                                                                                                '
  ' PST1 '00                                                                                                                                '
  ' UND0 '00                                                                                                                                '
  ' UND1 '00                                                                                                                                '
  ' CMD$ '00                                                                 '
  ' ENV$ '00                                                                 '
RETURN
> PROCEDURE wrinkles_info
  ' ----------------------------------------------------------------------------
  ' Messagewindow-wrinkle    ½1998 by Holger Herzog
  '                                Vorgartenstr. 9
  '                              D-66424 Homburg
  '
  ' Callable routines:
  '
  ' PROCEDURE messagewin_open(title$,maxlines%,x&,y&,w&,h&,icfyicon&)
  '
  ' Opens a userwindow for displaying messagelines. The string in title$
  ' will be showed in the window title. maxlines% is used for dimming the
  ' scroll-back area. Set the windowsize in x&, y&, w& and h&. If all these
  ' variables are set to (-1), the window will be opened in full size.
  ' icfyicon& can contain the tree number of an iconify-icon for this window.
  ' Otherwise set it to (-1).
  '
  '
  ' PROCEDURE messagewin_print(line$)
  '
  ' Outputs the line line$ in the messagewindow.
  '
  '
  ' PROCEDURE messagewin_close
  '
  ' Closes the messagewindow (if opened).
  '
  ' ---------------------------------------------------------------------------
  ' Textlist-Wrinkle V1.0, ½29.03.1997 Holger Herzog
  '                                    Vorgartenstr. 9
  '                                  D-66424 Homburg
  '
  ' Callable routines:
  '
  ' FUNCTION textlist_win_open(title$,info$,mode&,tool&,tree&,userhandle&,
  '                            x&,y&,w&,h&,iconify&,num%,VAR liste$())
  '
  ' Opens a userwindow for textlist-use. See win_open for information about
  ' title$, info$, tree&, userhandle&, x&, y&, w&, h& and iconify&. See
  ' win_kind_calc for information about mode& and tool&. Fill out the array
  ' liste$() with the textlines to display. num% is the number of lines that
  ' will be shown. If x&, y&, w& and h& are set to (-1), the window will appear
  ' in full screen-size. To suppress the infoline, set info$="". The function
  ' returns the window-handle of the text-window or '0' if error.
  '
  '
  ' PROCEDURE textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,
  '                         VAR list$(),selected!())
  '
  ' Draws a textlist in a userwindow. Normally called in user_window_content
  ' (see also). Most parameters are avaliable in user_window_content anyway:
  '       index&,off_x%,off_y%,cx&,cy&,cw&,ch&
  ' The first num% lines of the array list$() will be drawn in the userwindow
  ' (according to the offsets and the clipping-rectangle). Lines with the
  ' selected!()-flag set will be drawn inverted.
  '
  '
  ' FUNCTION textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,
  '                         selected!(),hash&())
  '
  ' Handles mouseclicks into a textlist-userwindow. This function usually is
  ' called in user_mouse (see also). Like in textlist_draw, most parameters
  ' are availiable anyway:
  '       index&,mx&,my&,mb&,ks&,mc&
  ' num% is the number of lines the textlist have (like in textlist_draw).
  ' Dito selected!(), it may have changed after calling
  ' this function (as this is its main-sentence).
  ' The return-value of textlist_click usually is -1. If the user makes a
  ' doubleclick onto a certain entry, textlist_click will return the value
  ' of the hash&()-array of this entry. If hash&() is negative, the entry will
  ' be not selectable.
  ' If dd! is set to TRUE, a long click with the left mousebutton will lead
  ' to a movebox and the user can drag and drop the entries. After that,
  ' user_textlist_dragdrop will be called where you can do your stuff.
  '
  '
  ' PROCEDURE list_redraw(index&,line&)
  '
  ' Redraws one line (line&) in window index&. Use this if you have changed
  ' the content or the selected!-flag of a certain line for redraw.
  '
  '
  ' PROCEDURE textlist_resize_sliders(index&,num%,VAR liste$())
  '
  ' Call this procedure if you have changed list-texts or fontsize to resize
  ' the window and the sliders. index& is the FV-index of the text-list-
  ' window.
  '
  '
RETURN
'
> PROCEDURE my_init
  INLINE xhdi_call%,134
  '
  '
  DIM newdesk$(300),ttytab$(200),package$(5)
  '
  @init_gemdos_var                                   ! Konstanten belegen und
  '
  em_start_pfad$=@akt_pfad$   ! Pfad aus dem EASYMINT.PRG gestartet wurde
  '
  install_path$="c:\easymint" ! Pfad wo die Tempor„rdateien hinterlegt werden.
  IF @exist(install_path$,16)=-33
    ~@f_mkdir(install_path$)
  ENDIF
  @language_load
  '
  ' Version hier setzen wegen Manipulationsgefahr
  '
  version1$="EasyMiNT"
  version2$="in memoriam Frank"
  version3$="v 1.82b 03/26/13"
  version4$="(faceValue 3.2 RunLib)"
  version5$="Copyright 2001-2013"
  @rsc_set_text(about&,version1&,version1$)
  @rsc_set_text(about&,version2&,version2$)
  @rsc_set_text(about&,version3&,version3$)
  @rsc_set_text(about&,version4&,version4$)
  @rsc_set_text(about&,version5&,version5$)
  '
  mw_x&=5
  mw_y&=5
  mw_b&=620
  mw_h&=400
  '
  IF @exist(install_path$+"\tmp",63)=-33
    ~@f_mkdir(install_path$+"\tmp")
  ENDIF
  '
  mint_version_path$="1-18-0" ! Pfad unter C:\MINT z.B. 1-17-0
  '
RETURN
> PROCEDURE language_load
  LOCAL fiha&
  IF @exist("language.lng",63)=0 OR @exist("LANGUAGE.LNG",63)=0
    '
    CLR dummy&,alert_nr&,alert_inhalt&
    CLR info_nr&,info_inhalt&
    CLR status_nr&,status_inhalt&
    CLR prgstart_nr&,prgstart_inhalt&
    '
    DIM dummy$(1000),alert$(50,3),info$(5,8),status$(50,3),prgstart$(10,3)
    '
    fiha&=@f_open("language.lng")
    '
    dummy$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Statusfenster
    status_win$=@f_input$(fiha&,FALSE)
    '
    REPEAT
      INC dummy&
      dummy$(dummy&)=@f_input$(fiha&,FALSE)
    UNTIL @f_eof(fiha&)
    ~@f_close(fiha&)
    '
    FOR i&=1 TO dummy&
      IF LEFT$(dummy$(i&),7)="# Alert"  ! Alertboxen einlesen
        CLR alert_inhalt&
        INC alert_nr&
        FOR x&=i&+1 TO i&+3
          IF LEFT$(dummy$(x&),1)<>"#"
            INC alert_inhalt&
            alert$(alert_nr&,alert_inhalt&)=dummy$(x&)
          ENDIF
          EXIT IF LEFT$(dummy$(x&),1)="#"
        NEXT x&
      ENDIF
      '
      IF LEFT$(dummy$(i&),6)="# Info"  ! Infoboxen einlesen
        INC info_nr&
        CLR info_inhalt&
        FOR x&=i&+1 TO i&+8
          IF LEFT$(dummy$(x&),1)<>"#"
            INC info_inhalt&
            info$(info_nr&,info_inhalt&)=dummy$(x&)
          ENDIF
          EXIT IF LEFT$(dummy$(x&),1)="#"
        NEXT x&
      ENDIF
      '
      IF LEFT$(dummy$(i&),8)="# Status"  ! Statusmeldungen einlesen
        INC status_nr&
        CLR status_inhalt&
        FOR x&=i&+1 TO i&+2
          IF LEFT$(dummy$(x&),1)<>"#"
            INC status_inhalt&
            status$(status_nr&,status_inhalt&)=dummy$(x&)
          ENDIF
          EXIT IF LEFT$(dummy$(x&),1)="#"
        NEXT x&
      ENDIF
      '
      IF LEFT$(dummy$(i&),10)="# Programm"  ! Programmstartmeldungen einlesen
        INC prgstart_nr&
        CLR prgstart_inhalt&
        FOR x&=i&+1 TO i&+3
          IF LEFT$(dummy$(x&),1)<>"#"
            INC prgstart_inhalt&
            prgstart$(prgstart_nr&,prgstart_inhalt&)=dummy$(x&)
          ENDIF
          EXIT IF LEFT$(dummy$(x&),1)="#"
        NEXT x&
      ENDIF
    NEXT i&
    '
  ELSE
    ALERT 1,"No language.lng",1," Quit ",eing1&
    QUIT
  ENDIF
RETURN
> PROCEDURE file_check
  ' Check EASYMINT.ZIP
  IF @exist(@akt_pfad$+"easymint.zip",63)<>0
    ALERT 1,"EASYMINT.ZIP missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
  ' Check XAAES.ZIP
  IF @exist(@akt_pfad$+"xaaes.zip",63)<>0
    ALERT 1,"XAAES.ZIP missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
  ' Check teradesk.zip
  IF @exist(@akt_pfad$+"teradesk.zip",63)<>0
    ALERT 1,"TERADESK.ZIP missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
  IF @exist(@akt_pfad$+"pakete\basic.tar",63)<>0
    ALERT 1,"basic.tar missing!",1," Quit ",eing%
    exit_program!=TRUE
  ELSE
    IF @exist(@akt_pfad$+"pakete\basic.lst",63)<>0
      ALERT 1,"basic.lst missing!",1," Quit ",eing%
      exit_program!=TRUE
    ENDIF
  ENDIF
  '
  IF @exist(@akt_pfad$+"unzip.ttp",63)<>0
    ' ALERT 1,"unzip.ttp missing!",1," Quit ",eing%
    '  ALERT 1,alert2_1$,1,alert2_2$,eing%
    ALERT 1,alert$(2,1),1,alert$(2,2),eing%
    exit_program!=TRUE
  ENDIF
  '
  IF @exist(@akt_pfad$+"rootfs.tgz",63)<>0
    ALERT 1,"rootfs.tgz missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
RETURN
'
' Erster Teil
'
> PROCEDURE info0                                    ! Installationspakete entpacken
  LOCAL value%,eing&
  @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
  @message(2,info$(1,1),info$(1,2),info$(1,3),info$(1,4),info$(1,5),info$(1,6),info$(1,7))
  info0!=TRUE
RETURN
> PROCEDURE lnx_suchen
  LOCAL i&,lnx_lw&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  FOR i&=ext_c& TO ext_t&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_c&)+2))="LNX" OR UPPER$(@xhdi$((i&-ext_c&)+2))="RAW" OR UPPER$(@xhdi$((i&-ext_c&)+2))="MIX"
        '        PRINT "Laufwerk(c-t): ";CHR$(65+(i&-ext_c&+2))
        ext2_var&=PRED((i&-ext_c&+2)) ! Laufwerk in Popup vorbelegen
        INC lnx_lw&
      ENDIF
    ENDIF
  NEXT i&
  '
  FOR i&=ext_v& TO ext_6&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_v&)+2))="LNX" OR UPPER$(@xhdi$((i&-ext_v&)+2))="RAW" OR UPPER$(@xhdi$((i&-ext_v&)+2))="MIX"
        '        PRINT "Laufwerk(v-6): ";CHR$(65+(i&-ext_c&+2))
        ext2_var&=PRED((i&-ext_c&+2)) !Laufwerk in Popup vorbelegen
        INC lnx_lw&
      ENDIF
    ENDIF
  NEXT i&
  '
  IF lnx_lw&=0          ! Wenn keine LNX oder RAW Programm beenden
    ' Alert 1
    ' ALERT 1,alert1_1$,1,alert1_2$,eing&
    ALERT 1,alert$(1,1),1,alert$(1,2),eing&
    IF eing&=1
      exit_program!=TRUE
    ENDIF
  ELSE
    ' es wurden x lnx partitionen gefunden
    @messagewin_print(status$(1,1)+" "+STR$(lnx_lw&)+" "+status$(1,2))
    @preinst
    info0!=FALSE
  ENDIF
RETURN
> PROCEDURE preinst
  ' Dialogvoreinstellungen
  @rsc_ob_disable(fvt_popu&,lw_u&,TRUE)     !Laufwerk U disablen
  @rsc_ob_disable(fvt_popu&,ext_u&,TRUE)    !   "     "   "
  '
  @comp_choose
  @angemeldete_lw
  @lnx_find
  '
  ' boot$=CHR$(66+lw_c_var&)
  '
  @rsc_setup_tree(preinst&)
  preinst_hdle&=@win_open_dialog(2,preinst&,-1)
RETURN
> PROCEDURE auspacken
  LOCAL dummy&,eing%,eing1&,prg$
  ' Schritt 1/6
  @messagewin_print(status$(29,1)+" 1/6")
  '
  ' Programme werden entpackt, kann dauern
  @messagewin_print(status$(2,1))
  @messagewin_print(status$(2,2))
  '
  IF @exist(em_start_pfad$+"unzip.ttp",63)=0
    ' name1
    LET name$=prgstart$(1,1)
    error%=@start_prg(0,em_start_pfad$+"unzip.ttp","-o "+em_start_pfad$+"easymint.zip -d "+install_path$,"",name$,install_path$+"\tmp\unzip.out",install_path$+"\tmp\unzip.err",TRUE,TRUE,TRUE)
  ELSE
    ' Alert 2
    ' ALERT 1,alert2_1$+" "+em_start_pfad$+alert2_2$,1,alert2_3$,eing1&
    ALERT 1,alert$(2,1)+" "+em_start_pfad$+alert$(2,2),1,alert$(2,3),eing1&
    IF eing1&=1
      exit_program!=TRUE
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE comp_choose                              ! Computer w„hlen
  '  PRINT "Cookie: ";
  '
  IF @get_cookie("_CPU",value%)
    cpu&=value%
  ENDIF
  '
  '  PRINT "CPU: ";cpu&
  '
  IF @get_cookie("_MCH",value%)
    machine&=SWAP(value%)
    IF (machine&=0 OR machine&=1 AND cpu&=0)! ST(e)
      compi_var&=1
    ENDIF
    IF (machine&=0 OR machine&=1 AND cpu&=30)! ST mit 68030
      compi_var&=2
    ENDIF
    IF machine&=2  ! TT
      compi_var&=3
    ENDIF
    IF machine&=3 AND cpu&=30 ! Falcon
      compi_var&=4
    ENDIF
    IF machine&=3 AND cpu&=40 ! Falcon mit AB
      compi_var&=5
    ENDIF
    IF machine&=3 AND cpu&=60 ! Falcon mit ct060
      compi_var&=6
    ENDIF
    IF @get_cookie("MNAM",value%)
      IF CHAR{value%}="Milan"
        compi_var&=7
      ENDIF
    ENDIF
    IF @get_cookie("hade",value%)  ! Hades
      IF cpu&=40          ! mit 68040
        compi_var&=8
      ENDIF
      IF cpu&=60          ! mit 68060
        compi_var&=9
      ENDIF
      '    PRINT "Cookiewert: ";value%
      '    IF value%=&H400E
      '    PRINT "Hades"
      '  ENDIF
    ENDIF
    IF @get_cookie("MTxx",value%)
      IF cpu&=40
        compi_var&=10
      ENDIF
    ENDIF
    IF value%=&H50000 ! ARAnyM Version >= 0.8.5
      compi_var&=11
      ' ELSE              ! ARAnyM Version <0.8.5
      '  IF @get_cookie("__NF",value%)
      '  IF @is_aranym
      '      '      PRINT "This is ARAnyM"
      '  compi_var&=10
      ' ENDIF
      ' ENDIF
    ENDIF
    IF @get_cookie("_CF_",value%)
      compi_var&=12
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE boot_info
  @message(1,info$(2,1),info$(2,2),info$(2,3),info$(2,4),info$(2,5),info$(2,6),info$(2,7))
  boot_info!=TRUE
RETURN
'
> PROCEDURE kernel_copy
  LOCAL eing&,eing1&,datei$,xxxx$
  ' Schritt 2
  @messagewin_print(status$(29,1)+" 2/6")
  '
  '
  mintvers$=UPPER$(mint_version_path$)
  '
  DEFMOUSE 2
  '
  ' bereits vorhandene MINT.CNF umbenennen (in :\ :\MULTITOS)
  IF @exist(boot$+":\MINT.CNF",63)=0
    IF @exist(boot$+":\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MINT.EM")
    ENDIF
    NAME boot$+":\MINT.CNF" AS boot$+":\MINT.EM"
  ENDIF
  IF @exist(boot$+":\MULTITOS\MINT.CNF",63)=0
    IF @exist(boot$+":\MULTITOS\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MULTITOS\MINT.EM")
    ENDIF
    NAME boot$+":\MULTITOS\MINT.CNF" AS boot$+":\MULTITOS\MINT.EM"
  ENDIF
  '
  IF @exist(boot$+":\MINT\"+mintvers$+"\MINT.CNF",63)=0
    IF @exist(boot$+":\MINT\"+mintvers$+"\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MINT\"+mintvers$+"\MINT.EM")
    ENDIF
    NAME boot$+":\MINT\"+mintvers$+"\MINT.CNF" AS boot$+":\MINT\"+mintvers$+"\MINT.EM"
  ENDIF
  '
  IF @exist(boot$+":\auto",16)=-33    ! Wenn nicht vorhanden
    MKDIR boot$+":\auto"
  ENDIF
  '
  ' MINT Ordner nach MINT.OLD umbenennen
  IF @exist(boot$+":\mint",16)=0 !AND @exist(boot$+":\mint.old",16)=-33
    IF @exist(boot$+":\mint.old",16)<>0
      NAME boot$+":\mint" AS boot$+":\mint.old"
    ENDIF
    ' MKDIR boot$+":\mint"
  ENDIF
  IF @exist(boot$+":\mint",16)=-33
    MKDIR boot$+":\mint"
  ENDIF
  '
  IF @exist(boot$+":\mint\"+mint_version_path$,16)=-33
    MKDIR boot$+":\mint\"+mint_version_path$
  ENDIF
  '
  lw_mint$=boot$+":\mint\"
  '
  ' Kopiere MiNT Ordner
  @messagewin_print(status$(3,1))
  '
  @ug_copy1(install_path$+"\mint\mint.ini",lw_mint$+mint_version_path$+"\mint.ini")
  IF compi_var&=1 ! Wenn ST minix Treiber installieren
    @ug_copy1(install_path$+"\mint\minix.xfs",lw_mint$+mint_version_path$+"\minix.xfs")
  ELSE IF compi_var&<>1 ! Sonst ext2
    @ug_copy1(install_path$+"\mint\ext2.xfs",lw_mint$+mint_version_path$+"\ext2.xfs")
  ENDIF
  @ug_copy1(install_path$+"\mint\inet4.xdd",lw_mint$+mint_version_path$+"\inet4.xdd")
  @ug_copy1(install_path$+"\mint\slip.xif",lw_mint$+mint_version_path$+"\slip.xif")
  @ug_copy1(install_path$+"\mint\xconout2.xdd",lw_mint$+mint_version_path$+"\xconout2.xdd")
  @ug_copy1(install_path$+"\mint\lp.xdd",lw_mint$+mint_version_path$+"\lp.xdd")
  @ug_copy1(install_path$+"\mint\nfs.xfs",lw_mint$+mint_version_path$+"\nfs.xfs")
  '
  ' *******************************************************
  ' XaAES installieren und konfigurieren?
  '
  '
  @xaaes_copy
  @teradesk_copy
  '
  ' ******************************************************
  '
  ' Fertig!
  @messagewin_print(status$(4,1))
  '
  lw_auto$=boot$+":\easymint.tmp\"
  '
  ' Kopiere AUTO Ordner
  @messagewin_print(status$(5,1))
  '
  @auto_tmp                   ! Autoordner in richtiger Reihenfolge nach EASYMINT.tmp
  ' Done!
  @messagewin_print(status$(6,1))
  ' Kopiere Kernel und Treiber
  @messagewin_print(status$(6,2))
  '
  kernel_pfad$="\kernel\"
  kernel_name$="mint"
  serial_pfad$=mint_version_path$+"\"
  kernel_pfad$=kernel_pfad$+kernel_name$
  IF compi_var&=1          ! ST
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"000.prg",lw_auto$+kernel_name$+"000.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
  ENDIF
  IF compi_var&=2          ! ST mit 030er
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
  ENDIF
  IF compi_var&=3          ! TT
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
  ENDIF
  IF compi_var&=4          ! Falcon
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
  ENDIF
  IF compi_var&=5          ! Falcon AB
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\68882.prg",lw_mint$+serial_pfad$+"68882.prg")
  ENDIF
  IF compi_var&=6          ! Falcon ct060
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"060.prg",lw_auto$+kernel_name$+"060.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\68882.prg",lw_mint$+serial_pfad$+"68882.prg")
  ENDIF
  IF compi_var&=7          ! Milan
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"mil.prg",lw_auto$+kernel_name$+"mmil.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\uart.xdd",lw_mint$+serial_pfad$+"uart.xdd")
    @ug_copy1(install_path$+"\serial\mfp_mil.xdd",lw_mint$+serial_pfad$+"mfp_mil.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__2m.prg",lw_mint$+"fpu__2m.prg")
  ENDIF
  IF compi_var&=8    ! Hades040
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__3.prg",lw_mint$+"fpu__3.prg")
  ENDIF
  IF compi_var&=9    ! Hades060
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__3.prg",lw_mint$+"fpu__3.prg")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+"mfp.xdd")
  ENDIF
  IF compi_var&=10    ! Medusa T40
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu40v1.prg",lw_mint$+"fpu40v1.prg")
  ENDIF
  IF compi_var&=11          ! Aranym
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"ara.prg",lw_auto$+kernel_name$+"ara.prg")
    ' ARAnyM Treiber kopieren
    @ug_copy1(install_path$+"\mint\aranym.xfs",lw_mint$+mint_version_path$+"\aranym.xfs")
    ' @ug_copy1(install_path$+"\mint\nfosmesa.xdd",lw_mint$+mint_version_path$+"\nfosmesa.xdd")
    @ug_copy1(install_path$+"\mint\nfstderr.xdd",lw_mint$+mint_version_path$+"\nfstderr.xdd")
    @ug_copy1(install_path$+"\mint\nfeth.xif",lw_mint$+mint_version_path$+"\nfeth.xif")
    @ug_copy1(install_path$+"\mint\hostfs.xfs",lw_mint$+mint_version_path$+"\hostfs.xfs")
  ENDIF
  IF compi_var&=12          ! Coldfire/Firebee
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"mintv4e.prg",lw_auto$+kernel_name$+"mintv4e.prg")
    @ug_copy1(install_path$+"\mint\fec.xif",lw_mint$+mint_version_path$+"\fec.xif")
  ENDIF
  '
  ' Fertig!
  @messagewin_print(status$(7,1))
  ' Sortiere AUTO Ordner
  @messagewin_print(status$(7,2))
  '
  @tmp_auto                   ! Autoordner wieder zurck
  ' Fertig!
  @messagewin_print(status$(8,1))
  ' Bearbeite NEWDESK.INF
  @messagewin_print(status$(8,2))
  '
  @newdesk_inf
  ' Fertig!
  @messagewin_print(status$(9,1))
  DEFMOUSE 0
RETURN
> PROCEDURE xaaes_copy
  LOCAL datei$,error%
  '
  DEFMOUSE 2
  '
  '
  xaaes_pfad$=":\mint\"+mint_version_path$+"\xaaes"
  xaaes_zip$=":\mint\"+mint_version_path$+"\"
  '
  IF @exist(boot$+xaaes_pfad$,16)=-33
    ~@f_mkdir(boot$+xaaes_pfad$)
  ENDIF
  @ug_copy1(em_start_pfad$+"xaaes.zip",boot$+xaaes_zip$+"xaaes.zip")
  '
  '
  IF @exist(em_start_pfad$+"unzip.ttp",63)=0
    @ug_copy1(em_start_pfad$+"unzip.ttp",boot$+xaaes_zip$+"unzip.ttp")
    '
    LET name$="Unpacking xaaes.zip..."
    error%=@start_prg(0,boot$+xaaes_zip$+"unzip.ttp","-o "+boot$+xaaes_zip$+"xaaes.zip -d "+boot$+xaaes_pfad$,"",name$,install_path$+"\tmp\xaaes.out",install_path$+"\tmp\xaaes.err",TRUE,TRUE,TRUE)
  ENDIF
  '
  ~@f_kill(boot$+xaaes_zip$+"xaaes.zip")
  ~@f_kill(boot$+xaaes_zip$+"unzip.ttp")
  '
  ' xaaes Modul umbenennen
  '  @ug_copy1(boot$+xaaes_pfad$+"\xaaes.km",boot$+xaaes_pfad$+"\xaaes.kmx")
  ' ~@f_kill(boot$+xaaes_pfad$+"\xaaes.km")
  ' @ug_copy1(boot$+xaaes_pfad$+"\xaaes000.km",boot$+xaaes_pfad$+"\xaaes.km")
  '
  @xaaes_cnf_create(TRUE)
  '
  DEFMOUSE 0
RETURN
> PROCEDURE xaaes_cnf_create(second_stage_flag!)
  LOCAL fiha&,tab$,quote$
  '
  ' XaAES Konfiguration wird erstellt
  @messagewin_print(status$(10,1))
  '
  IF @exist(boot$+":\mint\"+mint_version_path$+"\xaaes\xaaes.cnf",63)=0
    ~@f_kill(boot$+":\mint\"+mint_version_path$+"\xaaes\xaaes.cnf")
  ENDIF
  '
  tab$=CHR$(9)
  quote$=CHR$(34)
  '
  fiha&=@f_create(boot$+":\mint\"+mint_version_path$+"\xaaes\xaaes.cnf")
  ~@f_println(fiha&,"####################################################################",FALSE)
  ~@f_println(fiha&,"# XAAES.CNF created by EasyMiNT ",FALSE)
  ~@f_println(fiha&,"# This is only a rudiment CNF file, just that things come up!",FALSE)
  ~@f_println(fiha&,"# It's highly recommended to have a look at the original CNF file!! ",FALSE)
  ~@f_println(fiha&,"# There are much more options and explanations!",FALSE)
  ~@f_println(fiha&,"# You will find it under "+boot$+":\MINT\"+mint_version_path$+"\XAAES\EXAMPLE.CNF",FALSE)
  ~@f_println(fiha&,"####################################################################",FALSE)
  '
  ~@f_println(fiha&,"# Environment variables",FALSE)
  ~@f_println(fiha&,"setenv ACCPATH"+tab$+tab$+boot$+":\",FALSE)
  ~@f_println(fiha&,"setenv ACCEXT"+tab$+tab$+"ACC,ACX",FALSE)
  ~@f_println(fiha&,"setenv GEMEXT"+tab$+tab$+"PRG,APP,GTP,OVL,SYS",FALSE)
  ~@f_println(fiha&,"setenv TOSEXT"+tab$+tab$+"TOS,TTP",FALSE)
  ~@f_println(fiha&,"setenv TOSRUN"+tab$+tab$+"u:\opt\toswin2\tw-call.app",FALSE)
  ~@f_println(fiha&,"setenv SDL_VIDEODRIVER"+tab$+"gem",FALSE)
  '
  ~@f_println(fiha&,"# naes_cookie (default is no)",FALSE)
  ~@f_println(fiha&,"naes_cookie = yes",FALSE)
  '
  ~@f_println(fiha&,"# use $HOME in shell_find",FALSE)
  ~@f_println(fiha&,"usehome = yes",FALSE)
  '
  ~@f_println(fiha&,"# next_active = <string> (default is window)",FALSE)
  ~@f_println(fiha&,"next_active = client ",FALSE)
  '
  ~@f_println(fiha&,"# app_options = appname,argument1,argument2,...",FALSE)
  ~@f_println(fiha&,"# These are good app_options settings that I (ozk) use atm",FALSE)
  ~@f_println(fiha&,"app_options = default,thinwork=true,winframe_size = 0,xa_nomove = false ",FALSE)
  ~@f_println(fiha&,"app_options = aessys,thinwork=true,winframe_size = 0,xa_nomove = false ",FALSE)
  ~@f_println(fiha&,"app_options = jinnee, naesff = true ",FALSE)
  ~@f_println(fiha&,"app_options = taskbar,inhibit_hide = yes, clwtna = true ",FALSE)
  ~@f_println(fiha&,"app_options = amail, naesff = true",FALSE)
  ~@f_println(fiha&,"app_options = mymail,thinwork=true,winframe_size = 0",FALSE)
  ~@f_println(fiha&,"app_options = highwire,winframe_size = 0",FALSE)
  '
  ~@f_println(fiha&,"# The following will keep the desktop, taskbar and toswin2 running after",FALSE)
  ~@f_println(fiha&,"# a ctrl-alt-a action",FALSE)
  ~@f_println(fiha&,"ctlalta_survivors = "+quote$+"toswin2 "+quote$+", "+quote$+"strngsrv"+quote$+", "+quote$+"_aes_shell_"+quote$+", "+quote$+"taskbar "+quote$,FALSE)
  '
  ~@f_println(fiha&,"clipboard = "+boot$+":\clipbrd\",FALSE)
  ~@f_println(fiha&,"accpath = "+boot$+":\",FALSE)
  ' ~@f_println(fiha&,"launcher = u:\opt\toswin2\tw-call.prg",FALSE)
  '
  ~@f_println(fiha&,"# widgets = <file>",FALSE)
  ~@f_println(fiha&,"# resource = <file>",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"#resource = xa_mono.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\homwdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\styl_wdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\nine-ozk.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\baroqwdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\ronb_wdg.rsc",FALSE)
  ~@f_println(fiha&,"widgets = widgets\magicwdg.rsc",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"cancel = cancel,abbruch,annuler,avbryt,anuluj,afbryd,undo",FALSE)
  '
  ~@f_println(fiha&,"# filters = mask, mask, ...",FALSE)
  ~@f_println(fiha&,"filters = *.*, *.[atpg]*, *.[chs]*, *.l*, *.o*",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# start any other programs with run",FALSE)
  ~@f_println(fiha&,"#run <path>\<application>",FALSE)
  ~@f_println(fiha&,"run u:\opt\toswin2\toswin2.app",FALSE)
  IF second_stage_flag!=TRUE
    ~@f_println(fiha&,"run "+em_start_pfad$+"easymint.prg",FALSE)
  ENDIF
  '
  ~@f_println(fiha&,"# system shell",FALSE)
  ~@f_println(fiha&,"setenv AVSERVER   "+quote$+"DESKTOP "+quote$,FALSE)
  ~@f_println(fiha&,"setenv FONTSELECT "+quote$+"DESKTOP "+quote$,FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"shell = u:\"+boot$+"\mint\"+mint_version_path$+"\teradesk\desktop.prg",FALSE)
  '
  ~@f_close(fiha&)
RETURN
> PROCEDURE teradesk_copy
  LOCAL datei$,old$,new$
  DEFMOUSE 2
  '
  teradesk_pfad$=":\mint\"+mint_version_path$+"\teradesk"
  xaaes_tera_pfad$=":\mint\"+mint_version_path$+"\"
  IF @exist(boot$+teradesk_pfad$,16)=-33
    ~@f_mkdir(boot$+teradesk_pfad$)
  ENDIF
  '
  @ug_copy1(em_start_pfad$+"teradesk.zip",boot$+teradesk_pfad$+"\teradesk.zip")
  '
  '
  IF @exist(em_start_pfad$+"unzip.ttp",63)=0
    @ug_copy1(em_start_pfad$+"unzip.ttp",boot$+teradesk_pfad$+"\unzip.ttp")
    '
    LET name$="Unpacking teradesk.zip..."
    error%=@start_prg(0,boot$+teradesk_pfad$+"\unzip.ttp","-o "+boot$+teradesk_pfad$+"\teradesk.zip -d "+boot$+teradesk_pfad$,"",name$,install_path$+"\tmp\teradesk.out",install_path$+"\tmp\teradesk.err",TRUE,TRUE,TRUE)
    '
    old$=boot$+":\xaaes\tdesk2_3.bin"
    new$=boot$+":\xaaes\teradesk"
    '
    rerror%=@frename(old$,new$)
    '      PRINT "Rename-Error: ";rerror%
    @ug_copy1(boot$+teradesk_pfad$+"\examples\teradesk.inf",boot$+teradesk_pfad$+"\teradesk.inf")
  ENDIF
  ~@f_kill(boot$+teradesk_pfad$+"\teradesk.zip")
  ~@f_kill(boot$+teradesk_pfad$+"\unzip.ttp")
  '
  @teradesk_inf_create
  '
  DEFMOUSE 0
RETURN
> PROCEDURE teradesk_inf_create
  LOCAL fiha&,tab$,quote$
  '
  @td_angemeldete_lw
  '
  IF @exist(boot$+":\mint\"+mint_version_path$+"\teradesk\teradesk.inf",63)=0
    ~@f_kill(boot$+":\mint\"+mint_version_path$+"\teradesk\teradesk.inf")
  ENDIF
  '
  tab$=CHR$(9)
  quote$=CHR$(34)
  '
  fiha&=@f_create(boot$+":\mint\"+mint_version_path$+"\teradesk\teradesk.inf")
  ~@f_println(fiha&,"TeraDesk-inf",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"; Avoid editing this file by hand",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"options=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"infv=0x0382",FALSE)
  ~@f_println(fiha&,tab$+"save=0x0002",FALSE)
  ~@f_println(fiha&,tab$+"dial=0x0001",FALSE)
  ~@f_println(fiha&,tab$+"xpre=0x0020",FALSE)
  ~@f_println(fiha&,tab$+"pref=0x133E",FALSE)
  ~@f_println(fiha&,tab$+"buff=256",FALSE)
  ~@f_println(fiha&,tab$+"maxd=256",FALSE)
  ~@f_println(fiha&,tab$+"plin=80",FALSE)
  ~@f_println(fiha&,tab$+"tabs=8",FALSE)
  ~@f_println(fiha&,tab$+"mode=0",FALSE)
  ~@f_println(fiha&,tab$+"aarr=1",FALSE)
  ~@f_println(fiha&,tab$+"attr=0x0056",FALSE)
  ~@f_println(fiha&,tab$+"flds=0x000F",FALSE)
  ~@f_println(fiha&,tab$+"vidp=0x0003",FALSE)
  ~@f_println(fiha&,tab$+"vres=2",FALSE)
  ~@f_println(fiha&,tab$+"dpat=4",FALSE)
  ~@f_println(fiha&,tab$+"dcol=3",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"shortcuts=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"open=0x024F",FALSE)
  ~@f_println(fiha&,tab$+"show=0x0249",FALSE)
  ~@f_println(fiha&,tab$+"srch=0x0246",FALSE)
  ~@f_println(fiha&,tab$+"prin=0x0250",FALSE)
  ~@f_println(fiha&,tab$+"dele=0x027F",FALSE)
  ~@f_println(fiha&,tab$+"sela=0x0241",FALSE)
  ~@f_println(fiha&,tab$+"quit=0x0251",FALSE)
  ~@f_println(fiha&,tab$+"svop=0x0253",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"filetypes=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.*",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.PRG",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.APP",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.GTP",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.TOS",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.TTP",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.ACC",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.TXT",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ftype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"mask=*.IMG",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  '
  ' Apptypes
  '
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"apptypes=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"ptype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=*.PRG",FALSE)
  ~@f_println(fiha&,tab$+tab$+"flag=0x2001",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ptype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=*.APP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"flag=0x2001",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ptype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=*.GTP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"appt=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+"flag=0x2001",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ptype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=*.TOS",FALSE)
  ~@f_println(fiha&,tab$+tab$+"appt=3",FALSE)
  ~@f_println(fiha&,tab$+tab$+"flag=0x2000",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"ptype=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=*.TTP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"appt=4",FALSE)
  ~@f_println(fiha&,tab$+tab$+"flag=0x2000",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  '
  ' Icontypes
  '
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"icontypes=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"files",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.TXT",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=TEXT@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.GIF",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=IMAGE@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.TIF",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=IMAGE@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.IMG",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=IMAGE@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.LZH",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=PACK@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.ZIP",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=PACK@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.HYP",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=HELP@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.FNT",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=FONT@FILE",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.PRX",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=PRX",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.ACC",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=ACC",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=MAGIC.RAM",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=MAGIC",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ' Folders
  '
  ~@f_println(fiha&,tab$+"folders=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=MINT",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=MINT@FOLDER",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=GEMSYS",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=GEMSYS",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=..",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=UP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"programs=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=*.TTP",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=TOS@APP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"itype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"mask=TOS",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"name=TOS@APP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ' Deskicons
  '
  ~@f_println(fiha&,"deskicons=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"icon=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=FLOPPY",FALSE)
  ~@f_println(fiha&,tab$+tab$+"labl=FLOPPY",FALSE)
  ~@f_println(fiha&,tab$+tab$+"type=1",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"icon=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=FLOPPY",FALSE)
  ~@f_println(fiha&,tab$+tab$+"labl=FLOPPY",FALSE)
  ~@f_println(fiha&,tab$+tab$+"type=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+"driv=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+"xpos=1",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  xpos&=-1
  FOR i&=0 TO 50
    '    @messagewin_print(STR$(td_lw!(i&))+" "+STR$(i&))
    IF td_lw!((i&))=TRUE
      ~@f_println(fiha&,tab$+"icon=",FALSE)
      ~@f_println(fiha&,tab$+"{",FALSE)
      ~@f_println(fiha&,tab$+tab$+"name=HARD@DISC",FALSE)
      ~@f_println(fiha&,tab$+tab$+"labl=HARD@DISC",FALSE)
      ~@f_println(fiha&,tab$+tab$+"type=1",FALSE)
      ~@f_println(fiha&,tab$+tab$+"driv="+STR$(i&+2),FALSE)
      IF xpos&<=5
        INC xpos&
      ELSE
        xpos&=0
      ENDIF
      IF ypos&<4 AND xpos&=0
        INC ypos&
      ENDIF
      '      @messagewin_print(STR$(xpos&)+" "+STR$(ypos&))
      ~@f_println(fiha&,tab$+tab$+"xpos="+STR$(xpos&),FALSE)
      ~@f_println(fiha&,tab$+tab$+"ypos="+STR$(ypos&),FALSE)
      ~@f_println(fiha&,tab$+"}",FALSE)
    ENDIF
  NEXT i&
  '
  ~@f_println(fiha&,tab$+"icon=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=TRASH",FALSE)
  ~@f_println(fiha&,tab$+tab$+"labl=TRASH",FALSE)
  ~@f_println(fiha&,tab$+tab$+"type=2",FALSE)
  ~@f_println(fiha&,tab$+tab$+"xpos=0",FALSE)
  ~@f_println(fiha&,tab$+tab$+"ypos=5",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"icon=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"name=PRINTER",FALSE)
  ~@f_println(fiha&,tab$+tab$+"labl=PRINTER",FALSE)
  ~@f_println(fiha&,tab$+tab$+"type=3",FALSE)
  ~@f_println(fiha&,tab$+tab$+"xpos=0",FALSE)
  ~@f_println(fiha&,tab$+tab$+"ypos=6",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  '
  ' Applications
  '
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"applications=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"app=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"path=D:\QED\QED.APP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"cmdl=%f",FALSE)
  ~@f_println(fiha&,tab$+tab$+"atype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"flag=0x2008",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+tab$+"doctypes=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"dtype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+tab$+"mask=*.TXT",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"app=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"path=F:\INTERNET\CAB28\CAB.APP",FALSE)
  ~@f_println(fiha&,tab$+tab$+"cmdl=%f",FALSE)
  ~@f_println(fiha&,tab$+tab$+"atype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"flag=0x2000",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+tab$+"doctypes=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"dtype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+tab$+"mask=*.HTM",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"dtype=",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+tab$+"mask=HTTP*.*",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  '
  ' Windows
  '
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"windows=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"directories=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"font=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"iden=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"size=10",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"fcol=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=127",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=56",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=32",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=11",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=116",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=27",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=132",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=43",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=43",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=148",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=59",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=164",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=180",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=91",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=196",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=107",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=212",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=123",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=42",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=13",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  ~@f_println(fiha&,tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"views=",FALSE)
  ~@f_println(fiha&,tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+"font=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"iden=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"size=10",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"fcol=1",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=8",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=16",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"ypos=16",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=24",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=32",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=32",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=48",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=40",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=64",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=48",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=80",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=56",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=96",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"pos=",FALSE)
  ~@f_println(fiha&,tab$+tab$+"{",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=64",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"xpos=112",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winw=75",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"winh=22",FALSE)
  ~@f_println(fiha&,tab$+tab$+"}",FALSE)
  '
  ~@f_println(fiha&,tab$+"}",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ' Avstats
  '
  ~@f_println(fiha&,"avstats=",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"end",FALSE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE auto_tmp
  LOCAL suchmaske$,zeit&,attribute&
  '
  attribute&=&X101111                     ! Bit   Finde folgende:
  '                                     x    0    Schreibgeschtzte Datei
  '                                     x    1    Versteckte Datei
  '                                     x    2    Systemdatei
  '                                     x    3    Diskettenname
  '                                          4    Ordner
  '                                     x    5    Datei mit gesetztem Archivbit
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  IF @exist(boot$+":\easymint.tmp",16)=-33
    MKDIR boot$+":\easymint.tmp"
  ENDIF
  '  zeit&=@busy_open(FALSE)
  '
  @move_mint_prg
  '
  '
  ' AUTO Ordner nach EASYMINT.TMP verschieben
  '
  LET dta%=FGETDTA()
  IF @my_fsfirst(boot$+":\auto\*.*",attribute&,TRUE)=0
    REPEAT
      @ug_copy1(boot$+":\auto\"+CHAR{gl_xattr_d_fname%},boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(boot$+":\auto\*.*",attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurcksetzen
  '
  ' Auto Ordner leeren
  LET dta%=FGETDTA()
  suchmaske$=boot$+":\auto\*.*"
  IF @my_fsfirst(suchmaske$,attribute&,TRUE)=0
    REPEAT
      error%=@f_kill(boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(suchmaske$,attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurcksetzen
RETURN
> PROCEDURE tmp_auto
  LOCAL suchmaske$,attribute&
  '
  attribute&=&X101111
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  LET dta%=FGETDTA()
  IF @my_fsfirst(boot$+":\easymint.tmp\*.*",attribute&,TRUE)=0
    REPEAT
      @ug_copy1(boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%},boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(boot$+":\easymint.tmp\*.*",attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurcksetzen
  '
  ' tmp Ordner leeren und l”schen
  LET dta%=FGETDTA()
  suchmaske$=boot$+":\easymint.tmp\*.*"
  IF @my_fsfirst(suchmaske$,attribute&,TRUE)=0
    REPEAT
      error%=@f_kill(boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(suchmaske$,attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)
  '
  error%=@f_rmdir(boot$+":\easymint.tmp")
  '
  '
RETURN
> PROCEDURE move_mint_prg
  LOCAL attribute&
  '
  attribute&=&X101111
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  ' MINT.PRG suchen und verschieben
  '
  IF @exist(boot$+":\auto\mint*.pr*",16)=0
    IF @exist(boot$+":\auto\mintprg.bak",63)=-33
      error%=@f_mkdir(boot$+":\auto\mintprg.bak")
    ENDIF
    '
    LET dta%=FGETDTA()
    IF @my_fsfirst(boot$+":\auto\mint*.pr?",attribute&,TRUE)=0
      REPEAT
        @ug_copy1(boot$+":\auto\"+CHAR{gl_xattr_d_fname%},boot$+":\auto\mintprg.bak\"+CHAR{gl_xattr_d_fname%})
        error%=@f_kill(boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
      UNTIL @my_fsnext(boot$+":\auto\mint*.pr?",attribute&)<>0 !FSNEXT()<0
    ENDIF
    ~FSETDTA(dta%)                          ! DTA zurcksetzen
  ENDIF
RETURN
'
> PROCEDURE newdesk_inf
  LOCAL i&,a&,endof&,fiha&,fiha_1&,zw&
  '
  '
  IF @exist("c:\newdesk.inf",63)=0
    fiha&=@f_open("c:\newdesk.inf")
    REPEAT
      newdesk$(i&)=@f_input$(fiha&,FALSE)
      INC i&
    UNTIL @f_eof(fiha&)
    endof&=(i&-1)
    ~@f_close(fiha&)
    '
    autostart_flag!=FALSE
    '
    app_flag!=FALSE
    prg_flag!=FALSE
    gtp_flag!=FALSE
    ttp_flag!=FALSE
    tos_flag!=FALSE
    '
    FOR i&=0 TO endof&
      IF INSTR(newdesk$(i&),"#Z")<>0
        newdesk$(i&)="#Z 01 "+em_start_pfad$+"easymint.prg@"
        autostart_flag!=TRUE
      ENDIF
      @test_klein(i&,newdesk$(i&))
    NEXT i&
    '
    '
    IF autostart_flag!=FALSE
      FOR i&=0 TO endof&
        IF INSTR(newdesk$(i&),"#d")<>0
          zw&=i&+1
        ENDIF
      NEXT i&
      INC endof&
      FOR i&=endof& DOWNTO zw&
        newdesk$(i&+1)=newdesk$(i&)
      NEXT i&
      newdesk$(zw&)="#Z 01 "+em_start_pfad$+"\easymint.prg@"
    ENDIF
    '
    fiha_1&=@f_create("c:\newdesk.inf")
    FOR a&=0 TO endof&
      ~@f_println(fiha_1&,newdesk$(a&),FALSE)
    NEXT a&
    IF execute$(1)<>""
      ~@f_println(fiha_1&,execute$(1),FALSE)
    ENDIF
    IF execute$(2)<>""
      ~@f_println(fiha_1&,execute$(2),FALSE)
    ENDIF
    IF execute$(3)<>""
      ~@f_println(fiha_1&,execute$(3),FALSE)
    ENDIF
    IF execute$(4)<>""
      ~@f_println(fiha_1&,execute$(4),FALSE)
    ENDIF
    IF execute$(5)<>""
      ~@f_println(fiha_1&,execute$(5),FALSE)
    ENDIF
    ~@f_close(fiha_1&)
  ENDIF
  '
  '  @busy_close
  '  @ext2_info
  @neustart_info
RETURN
> PROCEDURE test_klein(x&,test$)
  '
  ERASE execute$()
  DIM execute$(5)
  '
  IF INSTR(test$,"#G 03 FF 000 *.app@ @ @")<>0
    app_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#G 03 FF 000 *.prg@ @ @")<>0
    prg_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#Y 03 FF 000 *.gtp@ @ @")<>0
    gtp_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#P 03 FF 000 *.ttp@ @ @")<>0
    ttp_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#F 03 04 000 *.tos@ @ @")<>0
    tos_flag!=TRUE
  ENDIF
  '
  IF app_flag!=FALSE
    execute$(1)="#G 03 FF 000 *.app@ @ @"
  ENDIF
  IF prg_flag!=FALSE
    execute$(2)="#G 03 FF 000 *.prg@ @ @"
  ENDIF
  IF gtp_flag!=FALSE
    execute$(3)="#Y 03 FF 000 *.gtp@ @ @"
  ENDIF
  IF ttp_flag!=FALSE
    execute$(4)="#P 03 FF 000 *.ttp@ @ @"
  ENDIF
  IF tos_flag!=FALSE
    execute$(5)="#F 03 04 000 *.tos@ @ @"
  ENDIF
RETURN
> PROCEDURE angemeldete_lw
  LOCAL eing&,eing2&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  ' Laufwerk C-T
  '
  FOR i&=lw_c& TO lw_t&
    IF BTST(drives%,(i&-lw_c&)+2)=TRUE
      @rsc_ob_disable(fvt_popu&,i&,FALSE)
    ENDIF
    IF BTST(drives%,(i&-lw_c&)+2)=FALSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  ' Laufwerk V-Z
  '
  FOR i&=lw_v& TO lw_6&
    IF BTST(drives%,(i&-lw_v&)+21)=TRUE
      @rsc_ob_disable(fvt_popu&,i&,FALSE)
    ENDIF
    IF BTST(drives%,(i&-lw_v&)+21)=FALSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  '
RETURN
> PROCEDURE td_angemeldete_lw
  '
  ERASE td_lw!()
  DIM td_lw!(50)
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  ' Laufwerk C-6
  '
  FOR i&=lw_c& TO lw_6&
    IF BTST(drives%,(i&-lw_c&)+2)=TRUE
      td_lw!((i&-lw_c&))=TRUE
      ' @messagewin_print(STR$(td_lw!(i&-lw_c&))+"   "+STR$(i&-lw_c&))
      ' Laufwerk vorhanden
    ENDIF
    IF BTST(drives%,(i&-lw_c&)+2)=FALSE
      ' Laufwerk nicht vorhanden
      td_lw!((i&-lw_c&))=FALSE
    ENDIF
  NEXT i&
  '
RETURN
> PROCEDURE lnx_find
  LOCAL i&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  '
  FOR i&=ext_c& TO ext_t&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_c&)+2))<>"LNX" AND UPPER$(@xhdi$((i&-ext_c&)+2))<>"RAW" AND UPPER$(@xhdi$((i&-ext_c&)+2))<>"MIX"
        @rsc_ob_disable(fvt_popu&,i&,TRUE)
      ENDIF
    ELSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  FOR i&=ext_v& TO ext_6&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_v&)+2))<>"LNX" AND UPPER$(@xhdi$((i&-ext_v&)+2))<>"RAW" AND UPPER$(@xhdi$((i&-ext_v&)+2))<>"MIX"
        @rsc_ob_disable(fvt_popu&,i&,TRUE)
      ENDIF
    ELSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  ' ext_c_var&=0
  '
  '  @rsc_set_text(kennung&,ke_top1&,chooselw1_1$)
  '  @rsc_set_text(kennung&,ke_top2&,chooselw1_2$)
  '  @rsc_set_text(kennung&,ke_top3&,chooselw1_3$)
  '  @rsc_set_text(kennung&,ke_top4&,chooselw1_4$)
  '  @rsc_setup_tree(kennung&)
  '
  '  kennung_hdle&=@win_open_dialog(2,kennung&,-1)
  '
RETURN
> PROCEDURE neustart_info
  '  ' Wenn XAAES noch nicht vorhanden, entpacken
  '  IF xaaes_var!=FALSE
  '  @messagewin_print("Startpfad: "+em_start_pfad$)
  '  @xaaes_copy
  ' ENDIF
  @message2(info$(4,1),info$(4,2),info$(4,3),info$(4,4),info$(4,5),info$(4,6),info$(4,7))
  neustart_info!=TRUE
  '
RETURN
> PROCEDURE neustart
  LOCAL error%,fiha&
  '
  ' Mini MINT.CNF erzeugen
  login_var&=2
  @mintcnf_create(FALSE)
  '
  ' Boot- und MiNT Laufwerk tempor„r zwischenspeichern
  '
  IF @exist(install_path$+"\tmp",16)=-33
    MKDIR install_path$+"\tmp"
  ENDIF
  '
  fiha&=@f_create(install_path$+"\tmp\position.tmp")
  ~@f_println(fiha&,@lower$(boot$),FALSE)
  ~@f_println(fiha&,lw_fs$,FALSE)
  ~@f_println(fiha&,STR$(compi_var&),FALSE)
  ~@f_println(fiha&,xaaes_version$,FALSE)
  ~@f_close(fiha&)
  '
  exit_program!=TRUE
  @kaltstart
RETURN
'
' Zweiter Teil nach reboot
'
> PROCEDURE make_ext2
  LOCAL rin&,fiha&
  '
  '
  ' Bootlaufwerk und MiNT Laufwerk einlesen
  '
  fiha&=@f_open(install_path$+"\tmp\position.tmp")
  boot$=@f_input$(fiha&,FALSE)
  lw_fs$=@f_input$(fiha&,FALSE)
  compi_var&=VAL(@f_input$(fiha&,FALSE))
  xaaes_version$=@f_input$(fiha&,FALSE)
  ~@f_close(fiha&)
  '
  IF @get_cookie("MiNT",value%)=FALSE
    ' alert4
    ALERT 1,alert$(4,1)+" "+boot$+alert$(4,2),1,alert$(4,3),eing&
    IF eing&=1
      exit_program!=TRUE
    ENDIF
  ELSE
    '
    IF @bereits_installiert=FALSE
      ' alert5 Ext2 installieren JA/NEIN
      ALERT 2,alert$(5,1)+" "+lw_fs$+":/"+alert$(5,2),1,alert$(5,3),rin&
      IF rin&=1
        ' alert6
        ALERT 1,alert$(6,1),2,alert$(6,2),eing&
        IF eing&=1
          ' alert7
          ALERT 2,alert$(7,1),2,alert$(7,2),eing2&
          IF eing2&=1
            ' Schritt 3
            @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
            @messagewin_print(status$(29,1)+" 3/6")
            ' Erzeuge ext2 filesystem
            @messagewin_print(status$(30,1))
            @mw_redraw
            '
            ' Programmstart 2
            IF compi_var&<>1   ! Kein ST
              LET name$=prgstart$(2,1)
              prg$=install_path$+"\mkfs.ttp"
              cmd$="-q "+lw_fs$+":"
              error%=@start_prg(0,prg$,cmd$,"",name$,install_path$+"\tmp\mkfs.out",install_path$+"tmp\mkfs.err",TRUE,TRUE,FALSE)
            ELSE IF compi_var&=1 ! Ein ST
              LET name$=prgstart$(2,1)
              prg$=install_path$+"\minit.ttp"
              cmd$=lw_fs$+":"
              error%=@start_prg(0,prg$,cmd$,"",name$,install_path$+"\tmp\minit.out",install_path$+"tmp\minit.err",TRUE,TRUE,FALSE)
            ENDIF
            IF error%=0
              ' ext2 fs erfolgreich angelegt
              @messagewin_print(status$(11,1))
            ELSE
              ' alert8
              '              ALERT 1,alert8_1$,1,alert8_2$,eing4&
              ALERT 1,alert$(8,1),1,alert$(8,2),eing4&
              IF eing4&=1
                exit_program!=TRUE
              ENDIF
            ENDIF
            @install_base
          ENDIF
          IF eing2&=2
            exit_program!=TRUE
          ENDIF
        ENDIF
        IF eing&=2
          exit_program!=TRUE
        ENDIF
      ENDIF
      IF rin&=2
        @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
        @install_base
      ENDIF
    ELSE IF @bereits_installiert=TRUE
      @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
      @install_base
    ENDIF
  ENDIF
RETURN
> PROCEDURE install_base
  '
  IF ber_inst!=FALSE        ! Wenn noch nichts installiert ist
    lstinst_var!=FALSE
  ELSE IF ber_inst!=TRUE    ! Wenn schon was installiert ist
    ' Alert22    ALERT 1," TAR Pakete oder | RPM per LST | installieren? ",1," TAR | RPM ",eing%
    ' ALERT 2,alert22_1$,1,alert22_2$,eing%
    ALERT 2,alert$(22,1),1,alert$(22,2),eing%
    IF eing%=1
      lstinst_var!=FALSE
    ELSE IF eing%=2
      lstinst_var!=TRUE
      @rpm_pfad_choose
    ENDIF
  ENDIF
  '
  @test_packages("basic.tar","bi.chk",pakete&)
  @test_packages("standard.tar","si.chk",man&)
  @test_packages("net.tar","ni.chk",net&)
  @test_packages("devel.tar","di.chk",devel&)
  @test_packages("libs.tar","li.chk",libs&)
  @test_packages("x11.tar","xi.chk",x11&)
  '
  @rsc_setup_tree(pre&)
  '
  pre_hdle&=@win_open_dialog(2,pre&,-1)
RETURN
> PROCEDURE test_packages(file$,i_file$,objekt&)
  IF lstinst_var!=FALSE
    ' TAR Paket vorhanden aber nicht installiert
    IF @exist(em_start_pfad$+"\pakete\"+file$,63)=0 AND @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,FALSE)
      @rsc_ob_disable(pre&,objekt&,FALSE)
      '
      '
      ' TAR Paket vorhanden und installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)=0 AND @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
      '
      ' TAR Paket nicht vorhanden, aber installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)<>0 AND @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
      '
      ' TAR Paket nicht vorhanden und nicht installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)<>0 AND @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
    ENDIF
  ELSE IF lstinst_var!=TRUE
    ' Paket bereits installiert
    IF @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
    ENDIF
    ' Paket noch nicht installiert
    IF @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,FALSE)
      @rsc_ob_disable(pre&,objekt&,FALSE)
    ENDIF
    '
  ENDIF
RETURN
> PROCEDURE do_check(objekt&)
  SELECT objekt&
  CASE pakete&
    pakete_var!=TRUE
  CASE man&
    man_var!=TRUE
  CASE net&
    net_var!=TRUE
  CASE devel&
    devel_var!=TRUE
  CASE libs&
    libs_var!=TRUE
  CASE x11&
    x11_var!=TRUE
  ENDSELECT
RETURN
> FUNCTION bereits_installiert
  $F%
  LOCAL fiha&,i_p$
  '
  i_p$=install_path$+"\tmp\"
  IF @exist(i_p$+"bi.chk",63)=0 OR @exist(i_p$+"si.chk",63)=0 OR @exist(i_p$+"ni.chk",63)=0 OR @exist(i_p$+"di.chk",63)=0 OR @exist(i_p$+"li.chk",63)=0 OR @exist(i_p$+"xi.chk",63)=0
    ber_inst!=TRUE
  ELSE
    ber_inst!=FALSE
  ENDIF
  RETURN ber_inst!
ENDFUNC
'
> PROCEDURE rpm_pfad_choose
  LOCAL datei$,pfad$,index&
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  IF lstinst_var!=TRUE
    datei$=@fileselector$("rpms?","u:\usr\src\redhat\RPMS\","",TRUE,"")
    pfad$=@extract_pfad$(datei$)
    IF @exist(pfad$,16)=0
      lw_$=@cut_path$(pfad$,TRUE)
      rpm_pfad$=@tos_to_unix_path$(pfad$)+"/"
      rpm_pfad$=@cut_path$(rpm_pfad$,FALSE)
    ELSE
      lstinst_var!=FALSE
    ENDIF
  ELSE IF lstinst_var!=FALSE
    '
  ENDIF
  '
RETURN
> PROCEDURE pre_auswert
  LOCAL eing&,tree%
  '
  '
  tree%=@xrsrc_gaddr(0,tree&)
  '
  IF pakete_var!=TRUE AND BTST(OB_STATE(tree%,pakete&),3)=FALSE
    package$(0)="basic.tar"
  ELSE
    pakete_var!=FALSE
  ENDIF
  IF man_var!=TRUE AND BTST(OB_STATE(tree%,man&),3)=FALSE
    package$(1)="standard.tar"
  ELSE
    man_var!=FALSE
  ENDIF
  IF net_var!=TRUE AND BTST(OB_STATE(tree%,net&),3)=FALSE
    package$(2)="net.tar"
  ELSE
    net_var!=FALSE
  ENDIF
  IF devel_var!=TRUE AND BTST(OB_STATE(tree%,devel&),3)=FALSE
    package$(3)="devel.tar"
  ELSE
    devel_var!=FALSE
  ENDIF
  IF libs_var!=TRUE AND BTST(OB_STATE(tree%,libs&),3)=FALSE
    package$(4)="libs.tar"
  ELSE
    libs_var!=FALSE
  ENDIF
  IF x11_var!=TRUE AND BTST(OB_STATE(tree%,x11&),3)=FALSE
    package$(5)="x11.tar"
  ELSE
    x11_var!=FALSE
  ENDIF
  '
  '
  DEFMOUSE 2
  '
  IF filecheck_var!=TRUE
    '
    ' Kopiere FS Check nach ...
    @messagewin_print(status$(12,1)+" "+boot$+status$(12,2))
    '
    IF @exist(boot$+":\mint\bin",63)=-33
      MKDIR boot$+":\mint\bin"
    ENDIF
    @ug_copy1(install_path$+"\bin\sh",boot$+":\mint\bin\sh")
    @ug_copy1(install_path$+"\bin\fscheck.sh",boot$+":\mint\bin\fscheck.sh")
  ENDIF
  '
  '
  IF mico_var!=TRUE
    ' Kopiere MiCo nach
    @messagewin_print(status$(13,1)+" "+boot$+status$(13,2))
    '
    IF @exist(boot$+":\mint\mico",63)=-33
      MKDIR boot$+":\mint\mico"
    ENDIF
    @ug_copy1(install_path$+"\mico\micodial.prg",boot$+":\mint\mico\micodial.prg")
    @ug_copy1(install_path$+"\mico\micodial.rsc",boot$+":\mint\mico\micodial.rsc")
    @ug_copy1(install_path$+"\mico\micokonf.prg",boot$+":\mint\mico\micokonf.prg")
    @ug_copy1(install_path$+"\mico\micokonf.rsc",boot$+":\mint\mico\micokonf.rsc")
  ENDIF
  IF shutdown_var!=TRUE
    ' Kopiere Shutdown nach
    @messagewin_print(status$(14,1)+" "+boot$+status$(14,2))
    '
    IF @exist(boot$+":\mint\shutdown",63)=-33
      MKDIR boot$+":\mint\shutdown"
    ENDIF
    @ug_copy1(install_path$+"\shutdown\readme",boot$+":\mint\shutdown\readme")
    @ug_copy1(install_path$+"\shutdown\shutdown.app",boot$+":\mint\shutdown\shutdown.app")
    @ug_copy1(install_path$+"\shutdown\shutdown.inf",boot$+":\mint\shutdown\shutdown.inf")
    @ug_copy1(install_path$+"\shutdown\shutdown.rsc",boot$+":\mint\shutdown\shutdown.rsc")
  ENDIF
  '
  DEFMOUSE 0
  '
RETURN
> FUNCTION cut_path$(path$,lwb!)
  '
  ' Laufwerksbuchstabe abschneiden oder zurckgeben
  IF lwb!=TRUE
    c_path$=LEFT$(path$,1)
  ELSE IF lwb!=FALSE
    c_path$=MID$(path$,3)
  ENDIF
  RETURN c_path$
ENDFUNC
> FUNCTION extract_pfad$(datei$)
  '  $F%
  '
  ' Extrahiert einen Pfad
  '
  LOCAL match&
  match&=RINSTR(datei$,"\")
  IF match&>0
    match$=LEFT$(datei$,PRED(match&))
  ELSE
    CLR match$
  ENDIF
  RETURN match$
ENDFUNC
'
> PROCEDURE naes_info
  @message(1,info$(3,1),info$(3,2),info$(3,3),info$(3,4),info$(3,5),info$(3,6),info$(3,7))
  naes_info!=TRUE
RETURN
> PROCEDURE pfade_vorbeleg
  LOCAL handle&,index&,xaaes_folder$
  '
  xaaes_folder$=boot$+":\mint\"+mint_version_path$+"\xaaes"
  '
  IF @exist(xaaes_folder$,16)=0
    @rsc_ob_disable(pfade&,xaaesstrt&,FALSE)
    @rsc_ob_disable(pfade&,xaaespfad&,FALSE)
  ELSE
    @rsc_ob_disable(pfade&,xaaesstrt&,TRUE)
    @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
  ENDIF
  '
  xaaespfad_var$=boot$+":\mint\"+mint_version_path$+"\xaaes\xaloader.prg"
  @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
  '
  @rsc_setup_tree(pfade&)
  '
  pfade_hdle&=@win_open_dialog(2,pfade&,-1)
RETURN
> PROCEDURE pfade_auswert
  LOCAL fiha&,i&,a&,tab$,anfueh$
  '
  IF naescar_var!=TRUE
    ' Kopiere NAESCar nach
    @messagewin_print(status$(16,1)+" "+boot$+status$(16,2))
    IF @exist(boot$+":\mint\naescar",63)=-33
      MKDIR boot$+":\mint\naescar"
    ENDIF
    @ug_copy1(install_path$+"\naescar\naescar.prg",boot$+":\mint\naescar\naescar.prg")
    @ug_copy1(install_path$+"\naescar\naescar.rsc",boot$+":\mint\naescar\naescar.rsc")
    '
    IF @exist(boot$+":\guides",63)=-33
      MKDIR boot$+":\guides"
    ENDIF
    @ug_copy1(install_path$+"\naescar\naescar.hyp",boot$+":\guides\naescar.hyp")
    @ug_copy1(install_path$+"\naescar\naescar.ref",boot$+":\guides\naescar.ref")
  ENDIF
  '
RETURN
'
> PROCEDURE rootfs_install
  LOCAL error%,eing&
  '
  DEFMOUSE 2
  '
  ' schritt 4
  @messagewin_print(status$(29,1)+" 4/6")
  '
  ' Rootfilesystem wird installiert
  @messagewin_print(status$(17,1))
  @ug_copy1(em_start_pfad$+"\rootfs.tgz",lw_fs$+":\rootfs.tgz")
  @ug_copy1(install_path$+"\tar.ttp",lw_fs$+":\tar")
  @ug_copy1(install_path$+"\gzip.ttp",lw_fs$+":\gzip")
  '
  CHDRIVE lw_fs$
  CHDIR "\"
  '
  error%=@fchmod("tar",&O755)
  error%=@fchmod("gzip",&O755)
  '
  DEFMOUSE 0
  '
  ' TODO: Eintragen der Paketgr”žen
  IF package$(0)="basic.tar"
    min_mb%=15000000
  ENDIF
  IF package$(1)="standard.tar"
    min_mb%=min_mb%+55000000
  ENDIF
  IF package$(2)="net.tar"
    min_mb%=min_mb%+32000000
  ENDIF
  IF package$(3)="devel.tar"
    min_mb%=min_mb%+60000000
  ENDIF
  IF package$(4)="libs.tar"
    min_mb%=min_mb%+50000000
  ENDIF
  IF package$(5)="x11.tar"
    min_mb%=min_mb%+50000000
  ENDIF
  '
  '  @messagewin_print("Free on "+lw_fs$+":\ = "+STR$(ROUND(@diskinfo(lw_fs$)/1024000))+" MB  Needed: "+STR$(ROUND((min_mb%)/1024000))+" MB")
  '
  '
  IF @diskinfo(lw_fs$)>min_mb%
    IF @exist(@akt_pfad$+"tar",63)=0
      '
      '
      exec$=@akt_pfad$+"tar"
      cmd$="-xvzf "+@akt_pfad$+"rootfs.tgz"
      env$="UNIXMODE=/brUs" !+CHR$(0)+CHR$(0)
      '
      ' Programmstart 3
      LET name$=prgstart$(3,1)
      error%=@start_prg(0,exec$,cmd$,env$,name$,install_path$+"\tmp\rootfs.out",install_path$+"\tmp\rootfs.err",TRUE,TRUE,FALSE)
      ' error%=@pipe(100,exec$,cmd$,env$,TRUE)
      @setlinks_to_aes
      @create_fstab
      error%=@fchmod("u:\tmp",&O1777)
      '
      IF @exist(lw_fs$+":\tar",63)=0
        error%=@f_kill(lw_fs$+":\tar")
      ENDIF
      IF @exist(lw_fs$+":\gzip",63)=0
        error%=@f_kill(lw_fs$+":\gzip")
      ENDIF
      IF @exist(lw_fs$+":\rootfs.tgz",63)=0
        error%=@f_kill(lw_fs$+":\rootfs.tgz")
      ENDIF
      '
      ' Rootfilesystem erfoglreich angelegt
      @messagewin_print(status$(18,1))
      @mw_redraw
      '
    ELSE
      ' alert 10
      '      ALERT 1,alert10_1$+" "+@akt_pfad$+" "+alert10_2$,1,alert10_3$,eing7&
      ALERT 1,alert$(10,1)+" "+@akt_pfad$+" "+alert$(10,2),1,alert$(10,3),eing7&
      IF eing7&
        exit_program!=TRUE
      ENDIF
    ENDIF
  ELSE
    ' alert 11
    ' ALERT 1,alert11_1$+" "+STR$(ROUND(min_mb%/1024/1024))+" "+alert11_2$,1,alert11_3$,eingg&
    ALERT 1,alert$(11,1)+" "+STR$(ROUND(min_mb%/1024/1024))+" "+alert$(11,2),1,alert$(11,3),eingg&
    exit_program!=TRUE
  ENDIF
  '
RETURN
> PROCEDURE setlinks_to_aes
  '
  LOCAL fiha&
  ' Link setzen von naespfad_var$ auf /usr/bin/n_aes
  IF login_var&=2 OR login_var&=1 AND naespfad_var$<>""
    IF @exist(lw_fs$+":\usr\bin\n_aes",63)=0
      ~@f_kill(lw_fs$+":\usr\bin\n_aes")
    ENDIF
    error%=@f_symlink(naespfad_var$,lw_fs$+":\usr\bin\n_aes")
    '
    @create_aespath(naespfad_var$)
  ENDIF
  '
  ' Link setzen von xaaespfad_var$ auf /usr/bin/xaaes
  IF login_var&=3 OR login_var&=1 AND xaaespfad_var$<>""
    IF @exist(lw_fs$+":\usr\bin\xaaes",63)=0
      ~@f_kill(lw_fs$+":\usr\bin\xaaes")
    ENDIF
    error%=@f_symlink(xaaespfad_var$,lw_fs$+":\usr\bin\xaaes")
    '
    @create_aespath(xaaespfad_var$)
  ENDIF
  '
RETURN
> PROCEDURE create_aespath(aes_pfad$)
  '
  LOCAL a$
  CLR a$
  FOR i&=1 TO LEN(aes_pfad$)
    IF MID$(aes_pfad$,i&,1)<>"\" AND MID$(aes_pfad$,i&,1)<>":"
      a$=a$+MID$(aes_pfad$,i&,1)
    ENDIF
    IF MID$(aes_pfad$,i&,1)="\"
      a$=a$+"/"
    ENDIF
    IF MID$(aes_pfad$,i&,1)=":"
      a$=a$+""
    ENDIF
  NEXT i&
  '
  ' boot/mint/aespath anlegen
  fiha&=@f_create(boot$+":\mint\aespath")
  ~@f_println(fiha&,"/"+@lower$(a$),FALSE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE create_fstab
  LOCAL tab$,fiha&,drives%
  '
  ERASE drive$(),dos!()
  DIM drive$(30),dos!(30)
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  ' Laufwerk C-T
  '
  FOR i&=2 TO 19
    IF BTST(drives%,i&)=TRUE
      IF @xhdi$(i&)<>"-1"
        IF CHAR{(@dcntl(&HF100,CHR$(65+i&)+":\"))+40}="ext2"
          dos!(i&)=FALSE
          drive$(i&)=@lower$(CHR$(65+i&))
        ELSE
          dos!(i&)=TRUE
          drive$(i&)=@lower$(CHR$(65+i&))
        ENDIF
        '        IF UPPER$(@xhdi$(i&))<>"LNX" AND UPPER$(@xhdi$(i&))<>"RAW"
        '        dos!(i&)=TRUE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ELSE
        '        dos!(i&)=FALSE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ENDIF
      ENDIF
    ENDIF
    IF BTST(drives%,i&)=FALSE
      drive$(i&)=""
    ENDIF
  NEXT i&
  '
  ' Laufwerk V-Z
  '
  FOR i&=21 TO 25
    IF BTST(drives%,(i&))=TRUE
      IF @xhdi$(i&)<>"-1"
        IF CHAR{(@dcntl(&HF100,CHR$(65+i&)+":\"))+40}="ext2"
          dos!(i&)=FALSE
          drive$(i&)=@lower$(CHR$(65+i&))
        ELSE
          dos!(i&)=TRUE
          drive$(i&)=@lower$(CHR$(65+i&))
        ENDIF
        '        IF UPPER$(@xhdi$(i&))<>"LNX" AND UPPER$(@xhdi$(i&))<>"RAW"
        '        dos!(i&)=TRUE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ELSE
        '        dos!(i&)=FALSE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ENDIF
      ENDIF
    ENDIF
    IF BTST(drives%,(i&))=FALSE
      drive$(i&)=""
    ENDIF
  NEXT i&
  '
  '
  tab$=CHR$(9)        ! Tabulator
  '
  fiha&=@f_create(lw_fs$+":\etc\fstab")
  FOR i&=2 TO 19
    IF drive$(i&)<>"" AND drive$(i&)<>@lower$(lw_fs$)
      IF dos!(i&)=TRUE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"dos"+tab$+"root"+tab$+"wheel"+tab$+"700",TRUE)
      ENDIF
      IF dos!(i&)=FALSE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+drive$(i&)+tab$+"ext2"+tab$+"-"+tab$+"-"+tab$+"-",TRUE)
      ENDIF
    ENDIF
    IF drive$(i&)=@lower$(lw_fs$)
      ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"ext2"+tab$+"root"+tab$+"wheel"+tab$+"777",TRUE)
    ENDIF
  NEXT i&
  '
  FOR i&=21 TO 25
    IF drive$(i&)<>"" AND drive$(i&)<>@lower$(lw_fs$)
      IF dos!(i&)=TRUE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"dos"+tab$+"root"+tab$+"wheel"+tab$+"700",TRUE)
      ENDIF
      IF dos!(i&)=FALSE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+drive$(i&)+tab$+"ext2"+tab$+"-"+tab$+"-"+tab$+"-",TRUE)
      ENDIF
    ENDIF
    IF drive$(i&)=@lower$(lw_fs$)
      ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"ext2"+tab$+"root"+tab$+"wheel"+tab$+"777",TRUE)
    ENDIF
  NEXT i&
  ~@f_close(fiha&)
RETURN
> PROCEDURE make_ttytab(start_mode&)
  LOCAL tab$,anfue$
  '
  ' /etc/ttytab erzeugen
  '
  tab$=CHR$(9)        ! Tabulator
  anfue$=CHR$(34)     ! Anfhrungszeichen
  '
  fiha&=@f_create(lw_fs$+":\etc\ttytab")                                      !("u:\etc\ttytab")
  ~@f_println(fiha&,"# /etc/ttytab",TRUE)
  ~@f_println(fiha&,"# Prinzipiell l„uft auf der console ein normaler getty",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Es darf nur einer der Eintr„ge aktiv sein!",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  IF login_var&=1       ! Login
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=2       ! N.AES starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=3       ! XaAES starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=4       ! TOS starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# gettys auf den seriellen Schnittstellen",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Modems k”nnen damit nicht ordentlich bedient werden, dafr gibt es",TRUE)
  ~@f_println(fiha&,"# mgetty. gettys werden mit on/off ein- oder ausgeschaltet",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttyS0"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Modem1",TRUE)
  ~@f_println(fiha&,"# ttyS1"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Modem2",TRUE)
  ~@f_println(fiha&,"# ttyS2"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Serial1",TRUE)
  ~@f_println(fiha&,"# ttyS3"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Serial2",TRUE)
  ~@f_println(fiha&,"# ttyS4"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Lan",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Bei MIDI ist es egal welche Baudrate man einstellt, es wird",TRUE)
  ~@f_println(fiha&,"# immer nur die einzig m”gliche genommen.",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttyS5"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Midi",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Beispiel fr den mgetty.",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttySx"+tab$+anfue$+"/usr/sbin/mgetty -x 6 ttySx"+anfue$+tab$+"dialup"+tab$+"on secure",TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE handle_package_tgz
  LOCAL eing&,i&
  '
  ' schritt 5
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  CLR i&,stepshow&
  REPEAT
    IF package$(i&)<>""
      @depack_package(package$(i&))
    ENDIF
    INC i&
  UNTIL i&>=5   ! Anzahl der TAR Pakete
  '
RETURN
> PROCEDURE depack_package(package$)
  LOCAL error%,eing&
  '
  CHDRIVE "u" ! Wichtig sonst werden die TARs nicht gefunden
  '
  '  ALERT 1,"Sollen die rpms in | /usr/src/redhat/RPMS | gespeichert werden?",1," Ja | Nein ",eing&
  '
  ' schritt 6
  INC stepshow&
  @messagewin_print(status$(29,1)+" 5."+STR$(stepshow&)+"/6")
  '
  CLR paket_pfad_unix$
  paket_pfad_unix$=@lower$(@tos_to_unix_path$(em_start_pfad$+"pakete\"))
  '  PRINT paket_pfad_unix$
  '
  IF LEFT$(paket_pfad_unix$,2)="/u"   ! Wenn /u dann /u rauschneiden, da sonst Pfad nicht gefunden wird wenn von /u gestartet (/u/u/x)
    paket_pfad_unix$=MID$(paket_pfad_unix$,3)
  ENDIF
  '
  ' und auspacken
  prg$="/bin/tar"
  cmd$="xvf "+@lower$(paket_pfad_unix$)+package$+" -C /usr/src/redhat/RPMS/m68kmint/"
  '
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0) !+CHR$(0)
  '
  ' ...entpacke...
  @messagewin_print(status$(20,1)+" "+package$+"...")
  LET name$=prgstart$(4,1)+" "+package$+"..."
  error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\package.out",install_path$+"\tmp\package.err",TRUE,TRUE,FALSE)
  IF error%=0
    ' ...erfolgreich entpackt
    @messagewin_print(package$+" "+status$(21,1))
  ENDIF
RETURN
> PROCEDURE install_rpm_auto
  LOCAL x&,x$,v$,redhat$
  '
  '
  DEFMOUSE 2
  '
  CHDRIVE "u"
  ' rpm Datenbank initialisieren
  prg$="/bin/rpm"
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0)+"HOME=/root" !+CHR$(0)
  error%=@start_prg(0,prg$,"--initdb",env$,name$,"","",TRUE,FALSE,FALSE)
  '
  IF lstinst_var!=FALSE
    @setze_pfad_rpm
  ELSE
    ~@dsetdrv(lw_$)
    ~@dsetpath(rpm_pfad$)
  ENDIF
  '
  prg$="/bin/rpm"
  env$="UNIXMODE=/brUs"+CHR$(0)+"HOME=/root" !+CHR$(0)+CHR$(0)
  ' und auspacken
  '
  @install_rpms(prg$,env$)
  '
  DEFMOUSE 0
  '
RETURN
> PROCEDURE install_rpms(prg$,env$)
  LOCAL s_z&,cmd$,i&,basic_max&,standard_max&,net_max&,devel_max&,libs_max&,x11_max&
  '
  ' schritt 7
  @messagewin_print(status$(29,1)+" 6/6")
  @mw_redraw
  '
  basic_max&=@count_packages("basic.lst")
  ' standard_max&=@count_packages("standard.lst")
  net_max&=@count_packages("net.lst")
  devel_max&=@count_packages("devel.lst")
  libs_max&=@count_packages("libs.lst")
  x11_max&=@count_packages("x11.lst")
  '
  ERASE basic$(),standard$(),net$(),devel$(),libs$(),x11$()
  DIM basic$(basic_max&),standard$(standard_max&),net$(net_max&),devel$(devel_max&),libs$(libs_max&),x11$(x11_max&)
  '
  @install_basic_rpms
  ' @install_standard_rpms
  @install_net_rpms
  @install_devel_rpms
  @install_libs_rpms
  @install_x11_rpms
  '
RETURN
> PROCEDURE setze_pfad_rpm !(rp$)
  LOCAL drives%,akt_lw%
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  akt_lw%=GEMDOS(25) ! akt. Laufwerk ermitteln
  ~@dsetdrv("U")
  ~@dsetpath("\usr\src\redhat\RPMS\m68kmint")
RETURN
> FUNCTION tos_to_unix_path$(tos_path$)
  '  $F%
  LOCAL lw$,i%
  '
  CLR unix_path$
  lw$=LEFT$(tos_path$,1)
  '
  FOR i%=3 TO LEN(tos_path$)
    IF MID$(tos_path$,i%,1)="\"
      unix_path$=unix_path$+"/"
    ELSE
      unix_path$=unix_path$+MID$(tos_path$,i%,1)
    ENDIF
  NEXT i%
  '
  unix_path$="/"+lw$+unix_path$
  RETURN unix_path$
ENDFUNC
'
> PROCEDURE install_basic_rpms
  '
  LOCAL fiha&,x&,i&,basic_rpms_max&,pack_counter$
  '
  IF pakete_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\basic.lst",63)=0
      ' Basic Paket wird installiert
      @messagewin_print(STRING$(6,"*")+" "+status$(22,1)+" "+STRING$(6,"*"))
      '
      fiha&=@f_open(em_start_pfad$+"pakete\basic.lst")
      REPEAT
        INC x&
        basic$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      basic_rpms_max&=x&
      FOR i&=1 TO basic_rpms_max&
        cmd$="-i "+basic$(i&)
        '
        ' mw 23=" Installiere" name5$="Installing rpms..."
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        ' Installiere ...
        @messagewin_print(pack_counter$+"/"+STR$(basic_rpms_max&)+": "+status$(23,1)+" "+basic$(i&)+"!")
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\basic.out",install_path$+"\tmp\basic.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw 24= "Fehler aufgetreten"
          @messagewin_print(status$(24,1)+" "+basic$(i&)+"!")
          @print_error(install_path$+"\tmp\basic.err")
        ELSE
          @print_error(install_path$+"\tmp\basic.out")
        ENDIF
        '
        ' noarch Archive nach RPMS/noarch/ verschieben bzw. rpms l”schen falls gewnscht
        @move_noarch(basic$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\bi.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_standard_rpms
  '
  LOCAL fiha&,x&,i&,standard_rpms_max&,pack_counter$,datei$
  '
  IF man_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\standard.lst",63)=0
      ' Standard Paket wird installiert
      @messagewin_print("****** "+status$(25,1)+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\standard.lst")
      REPEAT
        INC x&
        standard$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      standard_rpms_max&=x&
      FOR i&=1 TO standard_rpms_max&
        '
        ' mw23 name5
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(standard_rpms_max&)+": "+status$(23,1)+" "+standard$(i&)+"!")
        '
        cmd$="-i "+standard$(i&)
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\standard.out",install_path$+"\tmp\standard.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' Fehler bei der Installation
          @messagewin_print(status$(24,1)+" "+standard$(i&)+"!")
          @print_error(install_path$+"\tmp\standard.err")
        ELSE
          @print_error(install_path$+"\tmp\standard.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(standard$(i&))
        '
      NEXT i&
      '
      '
      @save_chk(install_path$+"\tmp\si.chk")
      '
      ' timezone ausw„hlen
      '
      ' link von /usr/share/zoneinfo/XXX/XXX auf /etc/localtime
      '
      IF @exist("u:\etc\localtime",63)=0        ! /etc/localtime l”schen
        ~@f_kill("u:\etc\localtime")
      ENDIF
      '
      datei$=@fileselector$("Timezone?","u:\usr\share\zoneinfo\","",FALSE,"")
      '
      IF @exist(datei$,63)=0
        error%=@f_symlink(datei$,"u:\etc\localtime")
      ELSE
        error%=@f_symlink("u:\usr\share\zoneinfo\Europe\Berlin","u:\etc\localtime")
      ENDIF
      '
      @evnt_multi_loop
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_net_rpms
  '
  LOCAL fiha&,x&,i&,net_rpms_max&,pack_counter$
  '
  IF net_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\net.lst",63)=0
      ' Net Paket wird installiert
      @messagewin_print("****** "+status$(26,1)+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\net.lst")
      REPEAT
        INC x&
        net$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      net_rpms_max&=x&
      FOR i&=1 TO net_rpms_max&
        cmd$="-i "+net$(i&)
        '
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(net_rpms_max&)+": "+status$(23,1)+" "+net$(i&)+"!")
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\net.out",install_path$+"\tmp\net.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' Fehler bei der Installation
          @messagewin_print(status$(24,1)+net$(i&)+"!")
          @print_error(install_path$+"\tmp\net.err")
        ELSE
          @print_error(install_path$+"\tmp\net.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(net$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\ni.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_devel_rpms
  '
  LOCAL fiha&,x&,i&,devel_rpms_max&,pack_counter$
  '
  IF devel_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\devel.lst",63)=0
      ' Devel Paket wird installiert
      @messagewin_print("****** "+status$(27,1)+" ******")
      '
      fiha&=@f_open(em_start_pfad$+"pakete\devel.lst")
      REPEAT
        INC x&
        devel$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      devel_rpms_max&=x&
      FOR i&=1 TO devel_rpms_max&
        cmd$="-i "+devel$(i&)
        ' mw23 name5
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(devel_rpms_max&)+": "+status$(23,1)+" "+devel$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\devel.out",install_path$+"\tmp\devel.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' Fehler bei der Installation
          @messagewin_print(status$(24,1)+devel$(i&)+"!")
          @print_error(install_path$+"\tmp\devel.err")
        ELSE
          @print_error(install_path$+"\tmp\devel.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(devel$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\di.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_libs_rpms
  '
  LOCAL fiha&,x&,i&,libs_rpms_max&,pack_counter$
  '
  IF libs_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\libs.lst",63)=0
      ' Library Paket wird installiert
      @messagewin_print("****** "+status$(28,1)+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\libs.lst")
      REPEAT
        INC x&
        libs$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      libs_rpms_max&=x&
      FOR i&=1 TO libs_rpms_max&
        cmd$="-i "+libs$(i&)
        ' mw23
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(libs_rpms_max&)+": "+status$(23,1)+" "+libs$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\libs.out",install_path$+"\tmp\libs.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' Fehler bei der Installation
          @messagewin_print(status$(24,1)+" "+libs$(i&)+"!")
          @print_error(install_path$+"\tmp\libs.err")
        ELSE
          @print_error(install_path$+"\tmp\libs.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(libs$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\li.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_x11_rpms
  '
  LOCAL fiha&,x&,i&,x11_rpms_max&,pack_counter$
  '
  IF x11_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\x11.lst",63)=0
      ' X11 Paket wird installiert
      @messagewin_print("****** "+status$(31,1)+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\x11.lst")
      REPEAT
        INC x&
        x11$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      x11_rpms_max&=x&
      FOR i&=1 TO x11_rpms_max&
        cmd$="-i "+x11$(i&)
        ' mw23
        LET name$=prgstart$(5,1)
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(x11_rpms_max&)+": "+status$(23,1)+" "+x11$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\x11.out",install_path$+"\tmp\x11.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' Fehler bei der Installation
          @messagewin_print(status$(24,1)+" "+x11$(i&)+"!")
          @print_error(install_path$+"\tmp\x11.err")
        ELSE
          @print_error(install_path$+"\tmp\x11.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(x11$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\xi.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
'
> FUNCTION aranym_net$(cmd$)
  LOCAL fiha&,error%
  '
  CHDRIVE "u"
  prg$="/sbin/nfethcfg"
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0)+"HOME=/root" !+CHR$(0)
  '
  error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\nfeth.out",install_path$+"\tmp\nfeth.err",TRUE,TRUE,FALSE)
  IF error%=0
    fiha&=@f_open(install_path$+"\tmp\nfeth.out")
    nfeth$=@f_input$(fiha&,TRUE)
    error%=@f_close(fiha&)
  ENDIF
  '
  RETURN nfeth$
ENDFUNC
'
> PROCEDURE save_chk(chk$)
  LOCAL fiha&
  '
  fiha&=@f_create(chk$)
  error%=@f_println(fiha&,"installiert",FALSE)
  error%=@f_close(fiha&)
RETURN
> FUNCTION count_packages(pack$)
  $F%
  '
  LOCAL fiha&,dummy$,max&
  '
  IF @exist(em_start_pfad$+"pakete\"+pack$,63)=0
    fiha&=@f_open(em_start_pfad$+"pakete\"+pack$)
    REPEAT
      dummy$=@f_input$(fiha&,TRUE)
      INC max&
    UNTIL @f_eof(fiha&)
    ~@f_close(fiha&)
  ENDIF
  RETURN max&
ENDFUNC
> PROCEDURE move_noarch(pack$)
  LOCAL redhat$
  '
  redhat$="u:\usr\src\redhat\RPMS\"
  '
  IF rpmsja_var!=FALSE
    IF RIGHT$(pack$,LEN("m68kmint.rpm"))="m68kmint.rpm"
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
    IF RIGHT$(pack$,LEN("noarch.rpm"))="noarch.rpm"
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
  ELSE IF rpmsja_var!=TRUE
    IF RIGHT$(pack$,LEN("noarch.rpm"))="noarch.rpm"
      @ug_copy1(redhat$+"m68kmint\"+pack$,redhat$+"noarch\"+pack$)
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
  ENDIF
RETURN
> PROCEDURE print_error(errorfile$)
  LOCAL error$,fiha&
  IF @exist(errorfile$,63)=0
    fiha&=@f_open(errorfile$)
    IF @f_lof(fiha&)>0
      REPEAT
        error$=@f_input$(fiha&,TRUE)
        @messagewin_print(error$)
      UNTIL @f_eof(fiha&)=TRUE
      @messagewin_print(" ")
    ENDIF
    error%=@f_close(fiha&)
  ENDIF
RETURN
'
> PROCEDURE mintcnf_create(init!)
  LOCAL eing&,fiha&,tab$,xx$,cache&
  '
  mintcnf_pfad$="\mint\"+mint_version_path$+"\mint.cnf"
  '
  IF @exist(boot$+":"+mintcnf_pfad$,63)=0
    ~@f_kill(boot$+":"+mintcnf_pfad$)
  ENDIF
  '
  tab$=CHR$(9)
  '
  fiha&=@f_create(boot$+":"+mintcnf_pfad$)                                !("u:\etc\ttytab")
  ~@f_println(fiha&,"# MINT.CNF erstellt von EasyMiNT Installer am "+DATE$+" um "+TIME$,FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"SLICES=2",FALSE)
  '  ~@f_println(fiha&,"NEWFATFS=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,V,W,X,Y,Z",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# filesystem cache (kb)",FALSE)
  ~@f_println(fiha&,"# more memory increases the filesystem speed",FALSE)
  IF compi_var&<>1         ! Wenn kein ST
    ' RAM Kalkulieren
    ' PRINT "Gesamtes RAM: ";@ram_calc
    IF @ram_calc<14
      cache&=256
    ENDIF
    IF @ram_calc>=14 AND @ram_calc<20
      cache&=512
    ENDIF
    IF @ram_calc>=20 AND @ram_calc<32
      cache&=1024
    ENDIF
    IF @ram_calc>=32 AND @ram_calc<64
      cache&=2048
    ENDIF
    IF @ram_calc>=64
      cache&=4096
    ENDIF
    '
    ~@f_println(fiha&,"CACHE="+STR$(cache&),FALSE)
  ENDIF
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# enable VFAT (long names) for this drives",FALSE)
  ~@f_println(fiha&,"# (can be changed in runtime by FSetter too)",FALSE)
  ~@f_println(fiha&,"# VFAT=D,E",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# enable write protection for this drives",FALSE)
  ~@f_println(fiha&,"# (can be changed in runtime by FSetter too)",FALSE)
  ~@f_println(fiha&,"# WRITEPROTECT=",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# completly remove drive B:",FALSE)
  ~@f_println(fiha&,"# HIDE_B=Y",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Links zu EasyMiNT",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\bin"+tab$+"u:\bin",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\lib"+tab$+"u:\lib",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\etc"+tab$+"u:\etc",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\home"+tab$+"u:\home",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\usr"+tab$+"u:\usr",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\tmp"+tab$+"u:\tmp",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\var"+tab$+"u:\var",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\sbin"+tab$+"u:\sbin",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\root"+tab$+"u:\root",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\opt"+tab$+"u:\opt",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\mnt"+tab$+"u:\mnt",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\boot"+tab$+"u:\boot",FALSE)
  ~@f_println(fiha&,"echo",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Environment",FALSE)
  ~@f_println(fiha&,"setenv PCONVERT PATH,HOME,SHELL",FALSE)
  ~@f_println(fiha&,"setenv UNIXMODE /brUs",FALSE)
  ~@f_println(fiha&,"setenv PATH u:\bin,u:\usr\bin,u:\usr\sbin,u:\sbin,u:\boot\mint\bin,"+boot$+":\xaaes",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Autostartprogramme",FALSE)
  '
  ' FPU Emulation starten
  IF compi_var&=5       !Falcon 040
    ~@f_println(fiha&,"exec "+boot$+":\mint\68882.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=7       !Milan
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu__2m.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=8 OR compi_var&=9 OR compi_var&=6  !Hades 040/060 Falcon CT60
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu__3.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=10      !Medusa
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu40v1.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  ' Filesystemcheck starten
  IF init!=TRUE
    IF filecheck_var!=TRUE
      ~@f_println(fiha&,"# Filesystemcheck (mandatory)",FALSE)
      ~@f_println(fiha&,"exec u:\"+boot$+"\mint\bin\sh u:\"+boot$+"\mint\bin\fscheck.sh",FALSE)
      ~@f_println(fiha&,"echo",FALSE)
    ENDIF
  ENDIF
  ' fvdi laden, wenn aranym
  IF compi_var&=11 AND login_var&<>1    !ARAnyM
    ~@f_println(fiha&,"# Starting fvdi",FALSE)
    ~@f_println(fiha&,"exec c:\fvdi\fvdi.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  ' AESDIR setzen
  IF naespfad_var$<>""
    xx$=LEFT$(naespfad_var$,LEN(naespfad_var$)-(LEN(naespfad_var$)-RINSTR(naespfad_var$,"\")))
    ~@f_println(fiha&,"setenv AESDIR "+xx$,FALSE)
  ENDIF
  ~@f_println(fiha&,"#",FALSE)
  IF init!=TRUE
    ~@f_println(fiha&,"# Timezone (mandatory)",FALSE)
    ~@f_println(fiha&,"exec"+tab$+"u:\sbin\tzinit -l",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Additional tools",FALSE)
  ~@f_println(fiha&,"# Draconis to MiNT-Net gateway",FALSE)
  ~@f_println(fiha&,"# exec u:\usr\sbin\mgw",FALSE)
  ~@f_println(fiha&,"# echo",FALSE)
  ~@f_println(fiha&,"# Gluestik - STiK/STiNG to MiNT-Net gateway",FALSE)
  ~@f_println(fiha&,"# exec u:\usr\sbin\gluestik",FALSE)
  ~@f_println(fiha&,"# echo",FALSE)
  '
  ~@f_println(fiha&,"cd u:\",FALSE)
  IF init!=TRUE
    ~@f_println(fiha&,"INIT=u:\sbin\init",FALSE)
  ELSE IF init!=FALSE
    '    ~@f_println(fiha&,"GEM=ROM",FALSE)
    ~@f_println(fiha&,"INIT=u:/"+boot$+"/mint/"+mint_version_path$+"/xaaes/xaloader.prg",FALSE)
  ENDIF
  ~@f_println(fiha&,"echo Setup complete, now booting system...",FALSE)
  ~@f_println(fiha&,"echo",FALSE)
  ~@f_close(fiha&)
  '
  '  @endconf_info
RETURN
'
' MiNT-Net konfigurieren
'
> PROCEDURE net_check
  LOCAL eing%
  '
  IF mintnet_flag!=TRUE
    IF nk_flag!=TRUE AND dhcp_flag!=FALSE
      @netzwerk_config
    ELSE IF nk_flag!=TRUE AND dhcp_flag!=TRUE
      @dhcp_config
    ELSE IF nk_flag!=FALSE
      @modem_config
    ENDIF
  ELSE
    @endconf_info
  ENDIF
  '
RETURN
> PROCEDURE net_config
  LOCAL eing1&,eing2&,eing3&
  ' Alert 14
  ' ALERT 1,alert14_1$,1,alert14_2$,eing1& ! Soll MiNTNet konfiguriert werden?
  ALERT 1,alert$(14,1),1,alert$(14,2),eing1&
  IF eing1&=1   !MiNT-Net soll konfiguriert werden
    mintnet_flag!=TRUE
    IF compi_var&<>11 ! Kein ARAnyM
      ' ALERT 1,alert15_1$,2,alert15_2$,eing2& ! Haben Sie eine Netzwerkkarte oder ein Modem?
      ALERT 1,alert$(15,1),2,alert$(15,2),eing2&
      IF eing2&=1
        nk_flag!=TRUE
        ' Alert 23
        '        ALERT 1,alert23_1$,2,alert23_2$,eing3& ! DHCP?
        ALERT 1,alert$(23,1),2,alert$(23,2),eing3&
        IF eing3&=1
          dhcp_flag!=FALSE
        ELSE IF eing3&=2
          dhcp_flag!=TRUE
        ENDIF
      ELSE IF eing2&=2
        nk_flag!=FALSE
      ENDIF
    ELSE IF compi_var&=11 ! Wenn ARAnyM
      nk_flag!=TRUE
      ALERT 1,alert$(23,1),2,alert$(23,2),eing3& ! DHCP?
      IF eing3&=1
        dhcp_flag!=FALSE
      ELSE IF eing3&=2
        dhcp_flag!=TRUE
      ENDIF
    ENDIF
  ELSE IF eing1&=2  !MiNT-Net soll nicht konfiguriert werden
    mintnet_flag!=FALSE
  ENDIF
RETURN
> PROCEDURE netzwerk_config
  IF compi_var&=11      ! Wenn ARAnyM, IP Adressen vorbelegen und disablen
    ipadr$=@ip_fummel$(@aranym_net$("--get-atari-ip"))
    gateway$=@ip_fummel$(@aranym_net$("--get-host-ip"))
    netmask$=@ip_fummel$(@aranym_net$("--get-netmask"))
    kuerzel_var$="eth0"
    ipadr_var$=ipadr$
    netmask_var$=netmask$
    gateway_var$=gateway$
    @rsc_setup_tree(nic&)
    @rsc_ob_disable(nic&,kuerzel&,TRUE)
    @rsc_ob_disable(nic&,netmask&,TRUE)
    @rsc_ob_disable(nic&,gateway&,TRUE)
    @rsc_ob_disable(nic&,ipadr&,TRUE)
  ENDIF
  nic_hdle&=@win_open_dialog(2,nic&,-1)
RETURN
> PROCEDURE modem_config
  ppp_hdle&=@win_open_dialog(2,ppp&,-1)
RETURN
> PROCEDURE nic_driver_copy
  LOCAL datei$
  IF compi_var&<>11 !ARAnyM
    datei$=@fileselector$("NIC Treiber?",boot$+":\*.*","",FALSE,"")
    IF @exist(datei$,63)=0
      @filename(datei$,match$)
      @ug_copy1(datei$,boot$+":\MINT\"+mint_version_path$+"\"+match$)
    ENDIF
  ENDIF
RETURN
> PROCEDURE netconfig_quit
  LOCAL eing%
  IF ber_inst!=FALSE
    @endconf_info
  ELSE
    ' Alert 24 ("Installation beendet")
    ALERT 1,alert$(24,1),1,alert$(24,2),eing%
    exit_program!=TRUE
  ENDIF
RETURN
'
' Netzwerkkarte konfigurieren
'
> PROCEDURE nic_auswert
  LOCAL fiha&,ipadr$,netmask$
  '
  ipadr$=@ip_fummel_back$(ipadr_var$)
  netmask$=@ip_fummel_back$(netmask_var$)
  dns$=@ip_fummel_back$(dns_var$)
  '
  @config.if_create(ipadr$,netmask$)
  @domainname_create
  @hostname_create
  @defaultroute_create
  @resolv.conf_create
  '
RETURN
> PROCEDURE config.if_create(a1$,a2$)
  LOCAL error%,config.if_path$
  '
  config.if_path$="u:\etc\sysconfig\config.if"
  '
  setup_interface$=kuerzel_var$+" "+a1$+" "+@ip_cut$(a1$,"0")+" "+a2$+" "+@ip_cut$(a1$,"255")
  '
  IF @exist(config.if_path$,63)=0
    ~@f_kill(config.if_path$)
  ENDIF
  '
  fiha&=@f_create(config.if_path$)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# [ this file must follow the unix convention - save with no CR !!! ]",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# static interface configuration goes here",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# syntax:",TRUE)
  error%=@f_println(fiha&,"# <interface> <ipaddr> <network> <netmask> <broadaddr>",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# example: ne0 192.168.0.10 192.168.0.0 255.255.255.0 192.168.0.255",TRUE)
  error%=@f_println(fiha&,"#          this setup interface ne0 with IP 192.168.0.10",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  '
  error%=@f_println(fiha&,setup_interface$,TRUE)
  '
  ~@f_close(fiha&)
RETURN
> PROCEDURE domainname_create
  LOCAL fiha&,domainname_path$
  '
  domainname_path$="u:\etc\sysconfig\domainname"
  '
  IF @exist(domainname_path$,63)=0
    ~@f_kill(domainname_path$)
  ENDIF
  '
  fiha&=@f_create(domainname_path$)
  error%=@f_println(fiha&,domaine_var$,TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE hostname_create
  LOCAL fiha&,hostname_path$
  '
  hostname_path$="u:\etc\sysconfig\hostname"
  '
  IF @exist(hostname_path$,63)=0
    ~@f_kill(hostname_path$)
  ENDIF
  '
  fiha&=@f_create(hostname_path$)
  error%=@f_println(fiha&,hn_var$,TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE defaultroute_create
  LOCAL fiha&,defaultroute_path$
  '
  defaultroute_path$="u:\etc\sysconfig\defaultroute"
  '
  IF @exist(defaultroute_path$,63)=0
    ~@f_kill(defaultroute_path$)
  ENDIF
  '
  fiha&=@f_create(defaultroute_path$)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# [ this file must follow the unix convention - save with no CR !!! ]",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# static default gateway configuration goes here",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# syntax:",TRUE)
  error%=@f_println(fiha&,"# <interface> <gateway>",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# example: ne0 192.168.0.200",TRUE)
  error%=@f_println(fiha&,"#          this set the defaultroute over ne0 to IP 192.168.0.200",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,kuerzel_var$+" "+@ip_fummel_back$(gateway_var$),TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE resolv.conf_create
  LOCAL fiha&,resolv_path$
  '
  resolv_path$="u:\etc\resolv.conf"
  '
  IF @exist(resolv_path$,63)=0
    ~@f_kill(resolv_path$)
  ENDIF
  '
  fiha&=@f_create(resolv_path$)
  error%=@f_println(fiha&,"domain "+domaine_var$,TRUE)
  error%=@f_println(fiha&,"nameserver "+@ip_fummel_back$(dns_var$),TRUE)
  ~@f_close(fiha&)
RETURN
'
> PROCEDURE dhcp_config
  LOCAL net_services$
  '
  net_services$="u:\etc\sysconfig\net.services"
  '
  IF @exist(net.services$,63)=0
    ~@f_kill(net_services$)
  ENDIF
  '
  fiha&=@f_create(net_services$)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# [ this file must follow the unix convention - save with no CR !!! ]",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# the default network services that are started on every system boot",TRUE)
  error%=@f_println(fiha&,"# after the network is setted up",TRUE)
  error%=@f_println(fiha&,"# it's interpreted as /etc/rc.d/init.d/<name> start",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  '
  error%=@f_println(fiha&,"dhclient",TRUE)
  '
  ~@f_close(fiha&)
  '
  @nic_driver_copy
  '
RETURN
'
' ppp konfigurieren
'
> PROCEDURE ppp_auswert
  '
  SELECT device_var&
  CASE 1
    device$="/dev/ttyS0"
  CASE 2
    device$="/dev/ttyS1"
  CASE 3
    device$="/dev/ttyS2"
  CASE 4
    device$="/dev/ttyS3"
  CASE 5
    device$="/dev/ttyS4"
  ENDSELECT
  '
  SELECT speed_var&
  CASE 1
    speed$="9600"
  CASE 2
    speed$="19200"
  CASE 3
    speed$="38400"
  CASE 4
    speed$="57600"
  CASE 5
    speed$="76800"
  CASE 6
    speed$="115200"
  CASE 7
    speed$="230400"
  ENDSELECT
  '
  @pap_secrets
  @pppchat
  @peers
  @resolv
  '
RETURN
> PROCEDURE pap_secrets
  LOCAL fiha&,papsecrets_path$
  '
  papsecrets_path$="u:\etc\ppp\pap-secrets"
  '
  IF @exist(papsecrets_path$,63)=0
    ~@f_kill(papsecrets_path$)
  ENDIF
  '
  fiha&=@f_create(papsecrets_path$)
  error%=@f_println(fiha&,user_var$+CHR$(9)+"*"+CHR$(9)+passwd$,TRUE)
  ~@f_close(fiha&)
  '
  ~@fchmod(papsecrets_path$,&O600)
RETURN
> PROCEDURE pppchat
  LOCAL fiha&,pppchat_path$
  '
  pppchat_path$="u:\etc\ppp\pppchat"
  quote$=CHR$(34)
  '
  IF @exist(pppchat_path$,63)=0
    ~@f_kill(pppchat_path$)
  ENDIF
  '
  fiha&=@f_create(pppchat_path$)
  error%=@f_println(fiha&,"TIMEOUT 60",TRUE)
  error%=@f_println(fiha&,"ABORT "+quote$+"NO DIALTONE"+quote$,TRUE)
  error%=@f_println(fiha&,"ABORT "+quote$+"NO CARRIER"+quote$,TRUE)
  error%=@f_println(fiha&,"ABORT BUSY",TRUE)
  error%=@f_println(fiha&,"ABORT ERROR",TRUE)
  error%=@f_println(fiha&,quote$+quote$+" "+atz_var$,TRUE)
  error%=@f_println(fiha&,"OK atdt"+ispnumber_var$,TRUE)
  error%=@f_println(fiha&,"CONNECT",TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE peers
  LOCAL fiha&,peers_path$
  '
  peers_path$="u:\etc\ppp\peers\"+ispname_var$
  '
  IF @exist(peers_path$,63)=0
    ~@f_kill(peers_path$)
  ENDIF
  '
  fiha&=@f_create(peers_path$)
  error%=@f_println(fiha&,device$,TRUE)
  error%=@f_println(fiha&,speed$,TRUE)
  error%=@f_println(fiha&,"crtscts",TRUE)
  error%=@f_println(fiha&,"modem",TRUE)
  error%=@f_println(fiha&,"defaultroute",TRUE)
  error%=@f_println(fiha&,"noauth",TRUE)
  error%=@f_println(fiha&,@ip_fummel_back$(localip_var$)+":"+@ip_fummel_back$(remoteip_var$),TRUE)
  error%=@f_println(fiha&,"user "+user_var$,TRUE)
  error%=@f_println(fiha&,"connect "+quote$+"/usr/sbin/chat -f /etc/ppp/pppchat"+quote$,TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE resolv
  LOCAL fiha&,resolv_path$
  '
  resolv_path$="u:\etc\resolv.conf"
  '
  IF @exist(resolv_path$,63)=0
    ~@f_kill(resolv_path$)
  ENDIF
  '
  fiha&=@f_create(resolv_path$)
  error%=@f_println(fiha&,"domain "+pppdomain_var$,TRUE)
  error%=@f_println(fiha&,"nameserver "+@ip_fummel_back$(nameserver_var$),TRUE)
  ~@f_close(fiha&)
RETURN
'
> FUNCTION ip_cut$(ip$,last$)
  '  $F%
  LOCAL last_p_pos&
  '
  last_p_pos&=LEN(ip$)-RINSTR(ip$,".")
  '
  cut$=LEFT$(ip$,LEN(ip$)-last_p_pos&)
  cut$=cut$+last$
  '
  RETURN cut$
ENDFUNC
> FUNCTION ip_fummel$(fummel$)
  '  $F%
  LOCAL a&,i&,pos1&,pos2&,pos3&,eins$,zwei$,drei$,vier$
  IF fummel$<>""
    DIM punkt_pos&(3)
    FOR i&=1 TO LEN(fummel$)
      IF MID$(fummel$,i&,1)="."
        INC a&
        punkt_pos&(a&)=i&
      ENDIF
    NEXT i&
    pos1&=punkt_pos&(1)
    pos2&=punkt_pos&(2)
    pos3&=punkt_pos&(3)
    ERASE punkt_pos&()
    eins$=SPACE$(3)
    zwei$=SPACE$(3)
    drei$=SPACE$(3)
    vier$=SPACE$(3)
    RSET eins$=LEFT$(fummel$,PRED(pos1&))
    RSET zwei$=MID$(fummel$,SUCC(pos1&),PRED(pos2&-pos1&))
    RSET drei$=MID$(fummel$,SUCC(pos2&),PRED(pos3&-pos2&))
    RSET vier$=RIGHT$(fummel$,LEN(fummel$)-pos3&)
    ret$=eins$+zwei$+drei$+vier$
  ENDIF
  RETURN ret$
ENDFUNC
> FUNCTION ip_fummel_back$(t$)
  '  $F%
  LOCAL eins$,zwei$,drei$,vier$
  eins$=TRIM$(LEFT$(t$,3))
  zwei$=TRIM$(MID$(t$,4,3))
  drei$=TRIM$(MID$(t$,7,3))
  vier$=TRIM$(MID$(t$,10,3))
  bastel_ip$=eins$+"."+zwei$+"."+drei$+"."+vier$
  IF bastel_ip$="..."
    bastel_ip$=""
  ENDIF
  RETURN bastel_ip$
ENDFUNC
'
> FUNCTION invisible_text$(input$,tree&,curspos&,VAR invisible$)
  '  $F%
  LOCAL l$,m$,r$
  '
  LET new_chars&=LEN(input$)-LEN(invisible$)
  LET l$=LEFT$(invisible$,curspos&-MAX(0,new_chars&))
  LET m$=MID$(input$,curspos&-new_chars&+1,MAX(0,new_chars&))
  LET r$=MID$(invisible$,curspos&-new_chars&+1)
  '
  LET invisible$=l$+m$+r$
  '
  RETURN STRING$(LEN(input$),"*")
ENDFUNC
'
> PROCEDURE endconf_info
  '
  @message2(info$(5,1),info$(5,2),info$(5,3),info$(5,4),info$(5,5),info$(5,6),info$(5,7))
  endconf_info!=TRUE
RETURN
> PROCEDURE newdesk_auto_del
  LOCAL i&,a&,x&,zw&,fiha&,fiha1&,endof&
  '
  IF @exist(boot$+":\newdesk.inf",63)=0
    fiha&=@f_open(boot$+":\newdesk.inf")
    REPEAT
      newdesk$(i&)=@f_input$(fiha&,FALSE)
      INC i&
    UNTIL @f_eof(fiha&)=TRUE
    endof&=(i&-1)
    ~@f_close(fiha&)
    '
    FOR i&=0 TO endof&
      IF INSTR(newdesk$(i&),"#Z")<>0
        zw&=i&
      ENDIF
    NEXT i&
    '
    IF zw&<>0
      FOR x&=zw& TO endof&
        newdesk$(x&)=newdesk$(x&+1)
      NEXT x&
      DEC endof&
    ENDIF
    '
    ~@f_kill(boot$+":\newdesk.inf")
    '
    fiha1&=@f_create(boot$+":\newdesk.inf")
    FOR a&=0 TO endof&
      error%=@f_println(fiha1&,newdesk$(a&),FALSE)
    NEXT a&
    ~@f_close(fiha1&)
  ENDIF
  ' ############### TMP\position.tmp l”schen
  '  IF @exist(install_path$+"\tmp\position.tmp",63)=0
  '  ~@f_kill(install_path$+"\tmp\position.tmp")
  ' ENDIF
  '
RETURN
'
> PROCEDURE message(modal&,t1$,t2$,t3$,t4$,t5$,t6$,t7$)
  @rsc_set_text(message&,mes1&,t1$)
  @rsc_set_text(message&,mes2&,t2$)
  @rsc_set_text(message&,mes3&,t3$)
  @rsc_set_text(message&,mes4&,t4$)
  @rsc_set_text(message&,mes5&,t5$)
  @rsc_set_text(message&,mes6&,t6$)
  @rsc_set_text(message&,mes7&,t7$)
  mes_hdle&=@win_open_dialog(modal&,message&,-1)
RETURN
> PROCEDURE message2(t1$,t2$,t3$,t4$,t5$,t6$,t7$)
  @rsc_set_text(message2&,mes1_00&,t1$)
  @rsc_set_text(message2&,mes2_00&,t2$)
  @rsc_set_text(message2&,mes3_00&,t3$)
  @rsc_set_text(message2&,mes4_00&,t4$)
  @rsc_set_text(message2&,mes5_00&,t5$)
  @rsc_set_text(message2&,mes6_00&,t6$)
  @rsc_set_text(message2&,mes7_00&,t7$)
  mes2_hdle&=@win_open_dialog(1,message2&,-1)
RETURN
> FUNCTION xhdi$(bios_dev#)
  '  $F%
  '
  return%=C:xhdi_call%(28,12,bios_dev#,L:V:major#,L:V:minor#,L:V:start_sec%,L:xhdi_bpb%,L:V:blocks%,L:V:partid%)
  IF return%=0
    RETURN CHAR{V:partid%}
  ELSE
    RETURN "-1"
  ENDIF
ENDFUNC
> FUNCTION diskinfo(drv$)
  LOCAL d%,q%,ret&,akt_drv%
  '
  ' aktuelles Laufwerk
  akt_drv%=GEMDOS(25)
  '
  ' Neues akt. Laufwerk setzen
  d%=ASC(UPPER$(drv$))-64
  ~GEMDOS(14,d%)
  '
  dfree$=STRING$(4*4,0)
  q%=V:dfree$
  d%=ASC(UPPER$(drv$))-64
  ret&=GEMDOS(54,L:q%,d%)
  cluster.free#=LONG{q%}
  cluster.total#=LONG{q%+4}
  sector.size#=LONG{q%+8}
  sect.per.clust#=LONG{q%+12}
  cluster.size#=LONG{q%+12}*sector.size#
  '
  size.free#=sector.size#*sect.per.clust#*cluster.free#
  '
  ' Altes akt. Laufwerk zurcksetzen
  ~GEMDOS(14,akt_drv%)
  '
  '
  RETURN size.free#
  '  RETURN {diskinfo%+8}*{diskinfo%+12}*{diskinfo%}
  '
ENDFUNC
'
> FUNCTION dcntl(opcode%,path$)
  $F%
  '
  LOCAL buf$
  path$=path$+CHR$(0)
  '
  buf$=SPACE$(256)
  q%=V:buf$
  '
  error%=GEMDOS(304,opcode%,L:V:path$,L:q%)
  '
  RETURN q%
ENDFUNC
> PROCEDURE open_start_dial(name$)
  @aes_screen_lock
  DEFMOUSE 2
  @rsc_set_text(startprg&,appname&,name$)
  startprg_hdle&=@win_open_dialog(1,startprg&,-1)
  DO
    event&=EVNT_MULTI(&X110000,1,1,1,0,0,0,0,0,0,0,0,0,0,0,100,mx&,my&,mb&,ks&,key&,mc&)
    IF BTST(event&,4)
      @main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
    ENDIF
  LOOP UNTIL BTST(event&,5)
RETURN
> PROCEDURE close_start_dial
  @win_close(startprg_hdle&)
  @mw_redraw
  DEFMOUSE 0
  @aes_clear_buffers
  @aes_screen_unlock
RETURN
> FUNCTION start_prg(mode&,prg$,cmd$,env$,name$,stdout$,stderr$,argv!,redir!,dialog!)
  $F%
  '
  IF dialog!=TRUE
    @open_start_dial(name$)
  ENDIF
  '
  IF argv!=TRUE
    @program_build_cmd_argv(prg$,cmd$,env$)
    prg$=prg$+CHR$(0)
  ELSE
    prg$=prg$+CHR$(0)
    cmd$=CHR$(LEN(cmd$))+cmd$+CHR$(0)
    env$=env$+CHR$(0)
  ENDIF
  '
  IF redir!=TRUE
    fd%=@start_redirect(stdout$,alter_stdout%)
    fd1%=@start_redirect_err(stderr$,alter_stderr%)
  ENDIF
  '
  '
  error%=GEMDOS(75,mode&,L:V:prg$,L:V:cmd$,L:V:env$)        !Pexec
  '
  IF redir!=TRUE
    @stop_redirect(fd%,alter_stdout%)
    @stop_redirect_err(fd1%,alter_stderr%)
  ENDIF
  '
  IF dialog!=TRUE
    @close_start_dial
  ENDIF
  '
  RETURN error%
ENDFUNC
> FUNCTION start_redirect(out$,VAR alter_stdout%)
  $F%
  redir%=GEMDOS(69,W:1) !Fdup() stdout
  alter_stdout%=redir%
  out$=out$+CHR$(0)
  redir%=GEMDOS(60,L:V:out$,W:0) ! Fcreate()
  fd%=redir%
  redir%=GEMDOS(70,W:1,W:fd%)     ! Fforce() stdout
  RETURN fd%
ENDFUNC
> PROCEDURE stop_redirect(fd%,alter_stdout%)
  ~GEMDOS(62,W:fd%)           ! Fclose()
  ~GEMDOS(70,W:1,W:alter_stdout%) ! Fforce()
  ~GEMDOS(62,W:alter_stdout%)     ! Fclose()
RETURN
> FUNCTION start_redirect_err(dev$,VAR alter_stderr%)
  $F%
  redir_err%=GEMDOS(69,W:2) !Fdup()
  alter_stderr%=redir_err%
  dev$=dev$+CHR$(0)
  redir_err%=GEMDOS(60,L:V:dev$,W:0)  ! Fcreate()
  fd1%=redir_err%
  redir_err%=GEMDOS(70,W:2,W:fd1%)     ! Fforce()
  RETURN fd1%
ENDFUNC
> PROCEDURE stop_redirect_err(fd1%,alter_stderr%)
  ~GEMDOS(62,W:fd1%)           ! Fclose()
  ~GEMDOS(70,W:2,W:alter_stderr%) ! Fforce()
  ~GEMDOS(62,W:alter_stderr%)     ! Fclose()
RETURN
> FUNCTION program_build_argv$(prgnam$,cmd$)
  '  $F%
  LOCAL pos&,argv$,null$,nullcount&
  CLR argv$
  CLR null$
  LET nullcount&=1
  LET cmd$=@program_cml_unbuild$(cmd$)
  WHILE LEN(cmd$)>0
    LET pos&=INSTR(cmd$,CHR$(0))
    IF pos&=0
      LET pos&=SUCC(LEN(cmd$))
    ENDIF
    IF pos&=1
      IF null$=""
        LET null$="NULL:"
      ELSE
        LET null$=null$+","
      ENDIF
      LET null$=null$+STR$(nullcount&)
      LET argv$=argv$+" "+CHR$(0)
    ELSE
      LET argv$=argv$+LEFT$(cmd$,PRED(pos&))+CHR$(0)
    ENDIF
    LET cmd$=MID$(cmd$,SUCC(pos&))
    INC nullcount&
  WEND
  RETURN "ARGV="+null$+CHR$(0)+prgnam$+CHR$(0)+argv$+CHR$(0)
ENDFUNC
> PROCEDURE program_build_cmd_argv(prgnam$,VAR cmd$,env$)
  LET cmd$=@program_cml_build$(cmd$)
  LET env$=LEFT$(env$,MAX(0,PRED(LEN(env$))))
  LET env$=env$+@program_build_argv$(prgnam$,cmd$)
  LET cmd$=CHR$(127)+LEFT$(cmd$+STRING$(127,0),127)
RETURN
> FUNCTION lower$(gross$)
  LOCAL i%
  DIM hilf$(100)
  klein$=""
  FOR i%=1 TO LEN(gross$)
    hilf$(i%)=MID$(gross$,i%,1)
    IF ASC(hilf$(i%))>=65 AND ASC(hilf$(i%))<=90
      hilf$(i%)=CHR$(ASC(hilf$(i%))+32)
    ENDIF
    klein$=klein$+hilf$(i%)
  NEXT i%
  ERASE hilf$()
  RETURN klein$
ENDFUNC
> FUNCTION cancel_inst
  $F%
  ' alert 12
  ' ALERT 2,alert12_1$,2,alert12_2$,inp&
  ALERT 2,alert$(12,1),2,alert$(12,2),inp&
  RETURN inp&
ENDFUNC
> PROCEDURE mw_redraw
  IF messagewin_windowhandle_&<>0
    @evnt_multi_loop
    '    @redraw_userwindow(messagewin_windowhandle_&,mw_x&,mw_y&,mw_b&,mw_h&)
  ENDIF
RETURN
> FUNCTION ram_calc
  $F%
  ramtop%=LPEEK(&H5A4)
  phystop%=LPEEK(&H42E)
  '
  IF ramtop%>0
    tt_ram%=ramtop%-(16*1024*1024)
  ELSE
    tt_ram%=0
  ENDIF
  '
  ges_ram%=(phystop%+tt_ram%)/1024/1024
  '
  RETURN ges_ram%
ENDFUNC
' '
'
> FUNCTION f_symlink(a$,b$)
  $F%
  '
  '
  a$=a$+CHR$(0)
  b$=b$+CHR$(0)
  '
  RETURN GEMDOS(302,L:V:a$,L:V:b$)
ENDFUNC
'
> FUNCTION frename(oldname$,newname$)
  $F%
  oldname$=oldname$+CHR$(0)
  newname$=newname$+CHR$(0)
  '
  RETURN GEMDOS(86,0,L:V:oldname$,L:V:newname$)
ENDFUNC
'
> PROCEDURE shutdown
  @messagewin_print("Shutting down system!")
  '  error%=@start_prg(0,"u:\sbin\shutdown","-r","","","",install_path$+"\tmp\shutdown.out",FALSE,TRUE,FALSE)
  '  IF error%=0
  '  @print_error(install_path$+"\tmp\shutdown.out")
  ' ENDIF
  ~GEMDOS(337,L:2)
RETURN
> PROCEDURE kaltstart_virt
  PRINT "Kaltstart"
RETURN
'
> PROCEDURE kaltstart                    ! Coldboot
  '
  VOID GEMDOS(&H20,L:0)
  '
  SLPOKE &H420,0
  SLPOKE &H426,0
  SLPOKE &H43A,0
  '
  a%=LPEEK(&H4F2)+4
  a%=LPEEK(a%)
  '
  CALL a%
  '
RETURN
'
> PROCEDURE ug_copy1(quell_datei$,ziel_datei$)
  LOCAL laenge%,frei%,adresse%,puffer%,wieoft%,rest%
  '
  fiha&=@f_open(quell_datei$)   ! Quelldatei ”ffnen, um die L„nge
  laenge%=@f_lof(fiha&)              ! des Files zu ermitteln,
  ~@f_close(fiha&)                     ! und wieder schliežen.
  frei%=MALLOC(-1)             ! gr”žten freien Speicherblock merken
  '
  IF frei%>laenge%             ! *Wenn m”glich, alles in einem Rutsch*
    adresse%=MALLOC(laenge%)   ! Speicher anfordern und die Quelldatei
    laenge%=@f_bload(quell_datei$,adresse%) ! an die erhaltene Adresse laden.
    fiha3&=@f_bsave(ziel_datei$,adresse%,laenge%) ! Diesen Bereich jetzt abspeichern,
    ~MFREE(adresse%)           ! und den Speicher wieder freigeben.
    '
  ELSE                         ! *ansonsten stckweise kopieren*
    puffer%=MALLOC(frei%)      ! das holen, was noch frei ist
    wieoft%=laenge% DIV frei%  ! Anzahl der Schreib/Lesevorg„nge
    rest%=laenge% MOD frei%    ! eventuellen Rest der Datei merken
    fiha1&=@f_open(quell_datei$)   ! Quelldatei ”ffnen
    fiha2&=@f_create(ziel_datei$)    ! Zieldatei anlegen
    FOR i%=1 TO wieoft%        ! Schleifchen binden
      ~@f_bget(fiha1&,puffer%,frei%)    ! in den Puffer lesen
      ~@f_bput(fiha2&,puffer%,frei%)    ! aus dem Puffer schreiben
    NEXT i%
    IF rest%                   ! *jetzt den wahrscheinlichen Dateirest*
      ~@f_bget(fiha1&,puffer%,rest%)    ! in den Puffer lesen, und
      ~@f_bput(fiha2&,puffer%,rest%)    ! aus dem Puffer schreiben
    ENDIF
    ~@f_close(fiha2&)
    ~@f_close(fiha1&)
    ~MFREE(puffer%)
  ENDIF
RETURN
> FUNCTION f_bput(fh&,a%,l%)
  $F%
  ' BPUT #1,a%,l%
  RETURN GEMDOS(64,fh&,L:l%,L:a%)
ENDFUNC
> FUNCTION f_bget(fh&,a%,l%)
  $F%
  ' BGET #1,a%,l%
  RETURN GEMDOS(63,fh&,L:l%,L:a%)
ENDFUNC
'
' -- Die Unterprogramme -------------------------------------------------------------
'
> FUNCTION my_fsfirst(datei$,attr&,next!)
  $F%
  ' Der Ersatz zu FSFIRST(). Achtung: Der zus„tzliche Parameter (next!) muž
  ' auf TRUE gesetzt werden, wenn anschliežend my_fsnext() aufgerufen wird.
  ' Wird my_fsfirst() nur einmalig aufgerufen (z.B. zur Existenzprfung), so
  ' ist next! auf FALSE zu setzen!
  '
  LOCAL all_names!
  LOCAL match_name!
  LOCAL attrib&
  LOCAL fehler%
  LOCAL bufdatei$
  LOCAL dateiname$
  LOCAL path$
  '
  @chk_dirhandle
  '
  @pfad(datei$,path$)
  '
  IF domain&=1                                  ! Nur wenn wir uns auch in der
    gl_dirhandle%=@dopendir(path$,0)            ! MiNT-Domain befinden ”ffnen.
  ELSE
    gl_dirhandle%=einvfn%                       ! Normales FSFIRST/FSNEXT provozieren
  ENDIF
  '
  '
  IF gl_dirhandle%=einvfn%                      ! (-32) Kein passendes Filesystem
    gl_dirhandle%=0                             ! oder nicht in der MiNT-Domain
    '
    gl_xattr_d_attrib%=ADD(gl_xattrbuf%,&H15)   ! Zum vereinfachten Zugriff auf
    gl_xattr_d_time%=ADD(gl_xattrbuf%,&H16)     ! die DTA (hier werden die Ergebnisse
    gl_xattr_d_date%=ADD(gl_xattrbuf%,&H18)     ! der Funktion eingetragen) werden
    gl_xattr_d_length%=ADD(gl_xattrbuf%,&H1A)   ! einige globale Variablen mit den
    gl_xattr_d_fname%=ADD(gl_xattrbuf%,&H1E)    ! Struktur-Adressen belegt.
    '
    ~FSETDTA(gl_xattrbuf%)                      ! DTA setzen
    '
    RETURN FSFIRST(datei$,attr&)
    '
  ELSE                                          ! In der MiNT-Domain:
    ~GEMDOS(8)
    fehler%=gl_dirhandle%
    IF (SHR(gl_dirhandle%,24) AND &HFF)<>&HFF
      gl_xattr_d_attrib%=ADD(gl_xattrbuf%,&H29) ! Variablen belegen (siehe oben)
      gl_xattr_d_time%=ADD(gl_xattrbuf%,&H1C)
      gl_xattr_d_date%=ADD(gl_xattrbuf%,&H1E)
      gl_xattr_d_length%=ADD(gl_xattrbuf%,&H10)
      gl_xattr_d_fname%=ADD(gl_fnamebuf%,&H4)
      '
      @filename(datei$,dateiname$)              ! Datei extrahieren
      IF dateiname$="*.*" OR dateiname$="*"
        dateiname$="*"
        all_names!=-1
      ENDIF
      CHAR{gl_fnamebuf%}=""                     ! Struktur bereinigen
      '
      fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%) ! Lesen
      '
      WHILE fehler%=0
        bufdatei$=CHAR{gl_xattr_d_fname%}       ! Die gefundene Datei
        IF all_names!                           ! Gesucht wurde *.*
          match_name!=TRUE
        ELSE
          match_name!=@match(UPPER$(bufdatei$),UPPER$(dateiname$))
        ENDIF
        IF match_name!=TRUE                     ! entspricht dem Suchkriterium
          datei$=path$+bufdatei$                ! Kompletter Zugriffspfad
          IF @fxattr(0,datei$,gl_xattrbuf%)=0
            attrib&=INT{PRED(gl_xattr_d_attrib%)}
            IF attrib&=0 AND (attr& AND fa_file&)=fa_file&
              attrib&=fa_file&
            ENDIF
            IF (attrib& AND attr&) OR attr&=0
              IF NOT next!                      ! Dem my_fsfirst() folgt kein
                ~@dclosedir(gl_dirhandle%)      ! my_fsnext(), also Verzeichnis
                CLR gl_dirhandle%               ! wieder schliežen.
              ENDIF
              RETURN 0
            ENDIF
          ENDIF
        ENDIF
        fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)
      WEND
      ~@dclosedir(gl_dirhandle%)
    ENDIF
  ENDIF
  '
  CLR gl_dirhandle%
  RETURN fehler%
  '
ENDFUNC
> FUNCTION my_fsnext(datei$,attr&)
  $F%
  ' Der Ersatz zu FSNEXT().
  '
  LOCAL all_names!
  LOCAL match_name!
  LOCAL attrib&
  LOCAL fehler%
  LOCAL bufdatei$
  LOCAL dateiname$
  LOCAL path$
  '
  IF gl_dirhandle%                              ! Aufruf erfolgte aus MiNT-Domain
    '
    @pfad(datei$,path$)                         ! Pfad extrahieren
    @filename(datei$,dateiname$)                ! Dateiname extrahieren
    IF dateiname$="*.*" OR dateiname$="*"
      dateiname$="*"
      all_names!=TRUE
    ENDIF
    '
    CHAR{gl_fnamebuf%}=""                       ! Struktur bereinigen
    fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)   ! Lesen
    WHILE fehler%=0
      bufdatei$=CHAR{gl_xattr_d_fname%}
      IF all_names!                             ! Gesucht wurde *.*
        match_name!=TRUE
      ELSE
        match_name!=@match(UPPER$(bufdatei$),UPPER$(dateiname$))
      ENDIF
      IF match_name!=TRUE                       ! entspricht dem Suchkriterium
        datei$=path$+bufdatei$                  ! Kompletter Zugriffspfad
        IF @fxattr(0,datei$,gl_xattrbuf%)=0
          attrib&=INT{PRED(gl_xattr_d_attrib%)}
          IF attrib&=0 AND (attr& AND &H27)=&H27
            attrib&=&H27
          ENDIF
          IF (attrib& AND attr&) OR attr&=0
            RETURN 0
          ENDIF
        ENDIF
      ENDIF
      fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)
    WEND
    ~@dclosedir(gl_dirhandle%)
    CLR gl_dirhandle%
    RETURN fehler%
  ELSE IF gl_has_dopendir!
    RETURN enmfil%          ! -49
    '
  ELSE                                          ! Aufruf erfolgte aus TOS-Domain
    RETURN FSNEXT()
  ENDIF
  '
ENDFUNC
'
> FUNCTION fxattr(flag&,fname$,buf%)
  $F%
  '
  fname$=fname$+CHR$(0)
  '
  RETURN GEMDOS(fxattr&,flag&,L:V:fname$,L:buf%)
  '
ENDFUNC
'
> FUNCTION dopendir(dir$,flag&)
  $F%
  '
  LOCAL fehler%
  '
  LET dir$=dir$+CHR$(0)
  '
  fehler%=GEMDOS(dopendir&,L:V:dir$,flag&)
  '
  ' Internes Flag fr dieses eine Verzeichnis:
  gl_has_dopendir!=fehler%<>einvfn%      ! -32
  '
  RETURN fehler%
  '
ENDFUNC
> FUNCTION dclosedir(dirhandle%)
  $F%
  '
  RETURN GEMDOS(dclosedir&,L:dirhandle%)
  '
ENDFUNC
> FUNCTION dreaddir(size&,dirhandle%,buf%)
  $F%
  '
  RETURN GEMDOS(dreaddir&,size&,L:dirhandle%,L:buf%)
  '
ENDFUNC
> FUNCTION fsel_cookie
  $F%
  LOCAL a&,a%
  IF @get_cookie("FSEL",a%)=TRUE
    IF a%
      IF MKL$({a%})="SLCT"                             ! Selectric...
        a&=INT{a%+6}
        IF BTST(a&,0)                                  ! aktiv?...
          IF id_ltmf!                                  ! LTMF leider auch...
            RETURN 1                                   ! ...Box rettet den Hintergrund nicht
          ELSE
            RETURN 2                                   ! ...=2
          ENDIF
        ENDIF
      ELSE                                             ! Jede andere Box...
        RETURN 1                                       ! ...=1
      ENDIF
    ENDIF
  ENDIF
  RETURN 0                                           ! Kein Fsel-Cookie
ENDFUNC
'
' --- Diverses ---------------------------------------------------------------------
'
> PROCEDURE init_gemdos_var
  '
  ' 256 Bytes Puffer fr Dreaddir() und 64 Bytes fr
  ' XATTR/DTA-Struktur ber ein INLINE bereitstellen:
  '
  INLINE gl_fnamebuf%,320
  gl_xattrbuf%=ADD(gl_fnamebuf%,256)
  '
  fa_file&=&H27
  '
  ' Anm.: Konstanten k”nnen vom ergo!pro-Pr„prozessor durch das +SYM-Kommando
  ' vor dem Compilieren berall im Listing durch ihren Wert ersetzt werden.
  ' Durch dieses Verfahren ist das Listing gut lesbar, ohne daž im Compilat
  ' unn”tig Speicherplatz fr sich nie „ndernde Variablen beansprucht wird.
  ' Definierte, aber nicht verwendete Konstanten, werden vom Pr„prozessor
  ' natrlich ebenfalls rechtzeitig aus dem Listing entfernt.
  ' [Ende der Werbung :-]
  '
  ' Die (symbolischen) GEMDOS-Konstanten:
  '
  '     ++SYM
  '
  LET dsetdrv&=14
  LET dgetdrv&=25
  LET super&=32
  LET tgetdate&=42
  LET tgettime&=44
  LET sversion&=48
  LET dfree&=54
  LET dcreate&=57
  LET dsetpath&=59
  LET fcreate&=60
  LET fopen&=61
  ' Fopen()-Modi
  LET readonly&=0
  LET readwrite&=2
  '
  LET fclose&=62
  LET fread&=63
  LET fwrite&=64
  ' Standard-Kan„le
  LET stdprn&=3
  LET fdelete&=65
  LET fseek&=66
  ' Modi
  LET seek_set&=0
  LET seek_cur&=1
  LET seek_end&=2
  LET mxalloc&=68
  ' Modi
  LET mx_stonly&=0
  LET mx_altonly&=1
  LET mx_prefst&=2
  LET mx_prefalt&=3
  ' MTOS-Speicherschutz (OR)
  LET mx_prot_default&=0
  LET mx_prot_private&=&H10
  LET mx_prot_global&=&H20
  LET mx_prot_super&=&H30
  LET mx_prot_readable&=&H40
  LET mx_prot_no_free&=&H4000
  LET dgetpath&=71
  LET pexec&=75
  ' Modi
  LET loadgo&=0
  ' ' Dateiattribute fr Fsfirst()
  LET fa_rdonly&=&H1
  LET fa_hidden&=&H2
  LET fa_system&=&H4
  LET fa_label&=&H8
  LET fa_direc&=&H10
  LET fa_arch&=&H20
  LET fa_attrib&=&H17
  LET fa_file&=&H27
  LET fa_other&=&H18
  LET frename&=86
  LET fdatime&=87
  ' Get/Set
  LET fd_read&=0
  LET fd_write&=1
  LET mfork&=112
  LET pdomain&=281
  '  Domains
  LET dom_tos&=0
  LET dom_mint&=1
  LET dopendir&=296
  LET dreaddir&=297
  LET dclosedir&=299
  LET fxattr&=300
  LET dreadlabel&=338
  '
  e_ok%=0
  einvfn%=-32
  efilnf%=-33
  epthnf%=-34
  enhndl%=-35
  eaccdn%=-36
  eihndl%=-37
  ensmem%=-39
  eimba%=-40
  edrive%=-46
  ensame%=-48
  enmfil%=-49
  elocked%=-58
  enslock%=-59
  erange%=-64
  eintrn%=-65
  eplfmt%=-66
  egsbf%=-67
  ebreak%=-68
  excpt%=-69
  epthov%=-70
  '
  '     ++SYM
  '
RETURN
> PROCEDURE chk_dirhandle
  IF gl_dirhandle%
    ~@dclosedir(gl_dirhandle%)
    CLR gl_dirhandle%
  ENDIF
RETURN
> FUNCTION match(strng$,pattern$)
  $F%
  '
  LOCAL pattern0$
  LOCAL strng0$
  '
  pattern0$=pattern$+CHR$(0)
  strng0$=strng$+CHR$(0)
  '
  RETURN @search(V:strng0$,V:pattern0$)
  '
ENDFUNC
> FUNCTION search(strng%,pattern%)
  $F%
  '
  LOCAL nochmal!
  '
  REPEAT
    CLR nochmal!
    IF BYTE{strng%}=0
      IF BYTE{pattern%}=0
        RETURN -1
      ELSE IF BYTE{pattern%}=42   !"*"
        INC pattern%
        nochmal!=-1
      ENDIF
    ELSE
      IF BYTE{pattern%}=42        !"*"
        RETURN @search(strng%,SUCC(pattern%)) OR @search(SUCC(strng%),pattern%)
      ELSE IF BYTE{pattern%}=BYTE{strng%} OR BYTE{pattern%}=63      !"?"
        INC pattern%
        INC strng%
        nochmal!=-1
      ENDIF
    ENDIF
  UNTIL NOT nochmal!
  RETURN 0
ENDFUNC
> PROCEDURE filename(datei$,VAR match$)
  '
  ' Extrahiert einen Dateinamen
  '
  LOCAL match&
  match&=SUCC(RINSTR(datei$,"\"))
  IF match&>0
    match$=MID$(datei$,match&)
  ELSE
    CLR match$
  ENDIF
RETURN
> PROCEDURE pfad(datei$,VAR match$)
  '
  ' Extrahiert einen Pfad
  '
  LOCAL match&
  match&=RINSTR(datei$,"\")
  IF match&>0
    match$=LEFT$(datei$,match&)
  ELSE
    CLR match$
  ENDIF
RETURN
' ------------------------------------------------------------------------
'
> PROCEDURE user_inline_load
  '
  ' Diese Routine wird einmalig aufgerufen, wenn das Programm gestartet wurde.
  ' Die folgenden Zeilen dienen dem Laden der INLINE-Daten, sofern dies nicht
  ' bereits geschehen ist.
  '
  ' Es ist ebenso m”glich, die INLINE-Daten von Hand zu laden. (s. Handbuch
  ' des GFA-Basic-Editors zum Thema 'INLINE')
  '
  LOCAL file$,fh&,ret%,lof%                     ! -CMP
  INLINE faceval_sys%,2901
  '
  ' Die folgenden Zeilen k”nnen vor dem šbersetzen gel”scht werden.
  '
  ' CMP: ergo!pro-Flag um die Zeilen vor dem šbersetzen automatisch zu l”schen.
  '      Stellen Sie sicher, dass die INLINE-Daten *VOR* dem šbersetzeb in
  '      jedem Falle geladen sind!
  '
  ' --CMP
  IF BYTE{SUCC(faceval_sys%)}=0
    LET file$="fv_sys.inl"+CHR$(0)
    LET ret%=GEMDOS(61,L:V:file$,0)
    IF ret%>0
      LET fh&=ret%
      ret%=GEMDOS(66,L:0,fh&,2)
      LET lof%=ret%
      LET ret%=GEMDOS(66,L:0,fh&,0)
      IF ret%=0
        LET ret%=GEMDOS(63,fh&,L:lof%,L:faceval_sys%)
        IF ret%=lof%
          LET ret%=GEMDOS(62,fh&)
        ENDIF
      ENDIF
    ENDIF
    IF ret%<>0
      ~FORM_ALERT(1,"[3][INLINE wurde nicht |geladen! |Fehler: ]"+STR$(ret%)+"[Abbruch]")
      EDIT
    ELSE
      ~GEMDOS(340,22,L:faceval_sys%,L:lof%) ! cache flush
    ENDIF
  ENDIF
  ' --CMP
  '
RETURN
> PROCEDURE user_var_index
  '
  ' ---------------------------------------------------------------------------
  ' Objektbaum-Namen:
  ' system&                             : Dialog
  ' fvt_asci&                           : Dialog
  ' fvt_alst&                           : Dialog
  ' fvt_work&                           : Dialog
  ' fvt_prog&                           : Dialog
  ' fvt_popu&                           : Dialog
  ' fvt_maus&                           : Dialog
  ' about&                              : Dialog
  ' mainmenu&                           : Men
  ' pre&                                : Dialog
  ' pfade&                              : Dialog
  ' message&                            : Dialog
  ' message2&                           : Dialog
  ' startprg&                           : Dialog
  ' nic&                                : Dialog
  ' ppp&                                : Dialog
  ' preinst&                            : Dialog
  ' ---------------------------------------------------------------------------
  ' Objekt-Namen:
  ' lw_c&                               : Objekt im Baum fvt_popu&
  ' lw_d&                               : Objekt im Baum fvt_popu&
  ' lw_e&                               : Objekt im Baum fvt_popu&
  ' lw_f&                               : Objekt im Baum fvt_popu&
  ' lw_g&                               : Objekt im Baum fvt_popu&
  ' lw_h&                               : Objekt im Baum fvt_popu&
  ' lw_i&                               : Objekt im Baum fvt_popu&
  ' lw_j&                               : Objekt im Baum fvt_popu&
  ' lw_k&                               : Objekt im Baum fvt_popu&
  ' lw_l&                               : Objekt im Baum fvt_popu&
  ' lw_m&                               : Objekt im Baum fvt_popu&
  ' lw_n&                               : Objekt im Baum fvt_popu&
  ' lw_o&                               : Objekt im Baum fvt_popu&
  ' lw_p&                               : Objekt im Baum fvt_popu&
  ' lw_q&                               : Objekt im Baum fvt_popu&
  ' lw_r&                               : Objekt im Baum fvt_popu&
  ' lw_s&                               : Objekt im Baum fvt_popu&
  ' lw_t&                               : Objekt im Baum fvt_popu&
  ' lw_u&                               : Objekt im Baum fvt_popu&
  ' lw_v&                               : Objekt im Baum fvt_popu&
  ' lw_w&                               : Objekt im Baum fvt_popu&
  ' lw_x&                               : Objekt im Baum fvt_popu&
  ' lw_y&                               : Objekt im Baum fvt_popu&
  ' lw_z&                               : Objekt im Baum fvt_popu&
  ' lw_1&                               : Objekt im Baum fvt_popu&
  ' lw_2&                               : Objekt im Baum fvt_popu&
  ' lw_3&                               : Objekt im Baum fvt_popu&
  ' lw_4&                               : Objekt im Baum fvt_popu&
  ' lw_5&                               : Objekt im Baum fvt_popu&
  ' lw_6&                               : Objekt im Baum fvt_popu&
  ' ext_c&                              : Objekt im Baum fvt_popu&
  ' ext_d&                              : Objekt im Baum fvt_popu&
  ' ext_e&                              : Objekt im Baum fvt_popu&
  ' ext_f&                              : Objekt im Baum fvt_popu&
  ' ext_g&                              : Objekt im Baum fvt_popu&
  ' ext_h&                              : Objekt im Baum fvt_popu&
  ' ext_i&                              : Objekt im Baum fvt_popu&
  ' ext_j&                              : Objekt im Baum fvt_popu&
  ' ext_k&                              : Objekt im Baum fvt_popu&
  ' ext_l&                              : Objekt im Baum fvt_popu&
  ' ext_m&                              : Objekt im Baum fvt_popu&
  ' ext_n&                              : Objekt im Baum fvt_popu&
  ' ext_o&                              : Objekt im Baum fvt_popu&
  ' ext_p&                              : Objekt im Baum fvt_popu&
  ' ext_q&                              : Objekt im Baum fvt_popu&
  ' ext_r&                              : Objekt im Baum fvt_popu&
  ' ext_s&                              : Objekt im Baum fvt_popu&
  ' ext_t&                              : Objekt im Baum fvt_popu&
  ' ext_u&                              : Objekt im Baum fvt_popu&
  ' ext_v&                              : Objekt im Baum fvt_popu&
  ' ext_w&                              : Objekt im Baum fvt_popu&
  ' ext_x&                              : Objekt im Baum fvt_popu&
  ' ext_y&                              : Objekt im Baum fvt_popu&
  ' ext_z&                              : Objekt im Baum fvt_popu&
  ' ext_1&                              : Objekt im Baum fvt_popu&
  ' ext_2&                              : Objekt im Baum fvt_popu&
  ' ext_3&                              : Objekt im Baum fvt_popu&
  ' ext_4&                              : Objekt im Baum fvt_popu&
  ' ext_5&                              : Objekt im Baum fvt_popu&
  ' ext_6&                              : Objekt im Baum fvt_popu&
  ' smilemouse&                         : Objekt im Baum fvt_maus&
  ' version1&                           : Objekt im Baum about&
  ' version2&                           : Objekt im Baum about&
  ' version3&                           : Objekt im Baum about&
  ' version4&                           : Objekt im Baum about&
  ' version5&                           : Objekt im Baum about&
  ' aboutok&                            : Objekt im Baum about&
  ' mm_about&                           : Objekt im Baum mainmenu&
  ' mm_quit&                            : Objekt im Baum mainmenu&
  ' pre_info&                           : Objekt im Baum pre&
  ' pakete&                             : Objekt im Baum pre&
  ' man&                                : Objekt im Baum pre&
  ' net&                                : Objekt im Baum pre&
  ' devel&                              : Objekt im Baum pre&
  ' libs&                               : Objekt im Baum pre&
  ' x11&                                : Objekt im Baum pre&
  ' rpmsja&                             : Objekt im Baum pre&
  ' filecheck&                          : Objekt im Baum pre&
  ' shutdown&                           : Objekt im Baum pre&
  ' mico&                               : Objekt im Baum pre&
  ' preabbr&                            : Objekt im Baum pre&
  ' preok&                              : Objekt im Baum pre&
  ' pf_info&                            : Objekt im Baum pfade&
  ' login&                              : Objekt im Baum pfade&
  ' naes_drkt&                          : Objekt im Baum pfade&
  ' xaaesstrt&                          : Objekt im Baum pfade&
  ' plaintos&                           : Objekt im Baum pfade&
  ' naespfad&                           : Objekt im Baum pfade&
  ' naescar&                            : Objekt im Baum pfade&
  ' xaaespfad&                          : Objekt im Baum pfade&
  ' pathabbr&                           : Objekt im Baum pfade&
  ' pathok&                             : Objekt im Baum pfade&
  ' mes1&                               : Objekt im Baum message&
  ' mes2&                               : Objekt im Baum message&
  ' mes3&                               : Objekt im Baum message&
  ' mes4&                               : Objekt im Baum message&
  ' mes5&                               : Objekt im Baum message&
  ' mes6&                               : Objekt im Baum message&
  ' mes7&                               : Objekt im Baum message&
  ' infoabbr&                           : Objekt im Baum message&
  ' mes_ok&                             : Objekt im Baum message&
  ' mes1_00&                            : Objekt im Baum message2&
  ' mes2_00&                            : Objekt im Baum message2&
  ' mes3_00&                            : Objekt im Baum message2&
  ' mes4_00&                            : Objekt im Baum message2&
  ' mes5_00&                            : Objekt im Baum message2&
  ' mes6_00&                            : Objekt im Baum message2&
  ' mes7_00&                            : Objekt im Baum message2&
  ' inf2abbr&                           : Objekt im Baum message2&
  ' mes_ok_00&                          : Objekt im Baum message2&
  ' appname&                            : Objekt im Baum startprg&
  ' nic_info&                           : Objekt im Baum nic&
  ' kuerzel&                            : Objekt im Baum nic&
  ' ipadr&                              : Objekt im Baum nic&
  ' netmask&                            : Objekt im Baum nic&
  ' defaultr&                           : Objekt im Baum nic&
  ' gateway&                            : Objekt im Baum nic&
  ' dns&                                : Objekt im Baum nic&
  ' domain&                             : Objekt im Baum nic&
  ' domaine&                            : Objekt im Baum nic&
  ' hn&                                 : Objekt im Baum nic&
  ' nw_abbr&                            : Objekt im Baum nic&
  ' nw_ok&                              : Objekt im Baum nic&
  ' ispname&                            : Objekt im Baum ppp&
  ' ppp_info&                           : Objekt im Baum ppp&
  ' atz&                                : Objekt im Baum ppp&
  ' timeout&                            : Objekt im Baum ppp&
  ' device&                             : Objekt im Baum ppp&
  ' speed&                              : Objekt im Baum ppp&
  ' ispnumber&                          : Objekt im Baum ppp&
  ' user&                               : Objekt im Baum ppp&
  ' passwd&                             : Objekt im Baum ppp&
  ' nameserver&                         : Objekt im Baum ppp&
  ' pppdomain&                          : Objekt im Baum ppp&
  ' localip&                            : Objekt im Baum ppp&
  ' remoteip&                           : Objekt im Baum ppp&
  ' ppp_abbr&                           : Objekt im Baum ppp&
  ' ppp_ok&                             : Objekt im Baum ppp&
  ' preinfo&                            : Objekt im Baum preinst&
  ' compi&                              : Objekt im Baum preinst&
  ' boot&                               : Objekt im Baum preinst&
  ' ext2&                               : Objekt im Baum preinst&
  ' pabbr&                              : Objekt im Baum preinst&
  ' pok&                                : Objekt im Baum preinst&
  '
  ' ---------------------------------------------------------------------------
  ' Status-Variablen: (Details in der Prozedur user_rsc_var_init)
  '
  ' lw_c_var!                           : anw„hlbar im Baum fvt_popu&
  ' lw_d_var!                           : anw„hlbar im Baum fvt_popu&
  ' lw_e_var!                           : anw„hlbar im Baum fvt_popu&
  ' ext_c_var!                          : anw„hlbar im Baum fvt_popu&
  ' ext_d_var!                          : anw„hlbar im Baum fvt_popu&
  ' ext_e_var!                          : anw„hlbar im Baum fvt_popu&
  ' pakete_var!                         : anw„hlbar im Baum pre&
  ' man_var!                            : anw„hlbar im Baum pre&
  ' net_var!                            : anw„hlbar im Baum pre&
  ' devel_var!                          : anw„hlbar im Baum pre&
  ' libs_var!                           : anw„hlbar im Baum pre&
  ' x11_var!                            : anw„hlbar im Baum pre&
  ' rpmsja_var!                         : anw„hlbar im Baum pre&
  ' filecheck_var!                      : anw„hlbar im Baum pre&
  ' shutdown_var!                       : anw„hlbar im Baum pre&
  ' mico_var!                           : anw„hlbar im Baum pre&
  ' login_var&                          : Radiobutton-Set im Baum pfade&
  ' naespfad_var$                       : editierbarer Text im Baum pfade&
  ' naescar_var!                        : anw„hlbar im Baum pfade&
  ' xaaespfad_var$                      : editierbarer Text im Baum pfade&
  ' kuerzel_var$                        : editierbarer Text im Baum nic&
  ' ipadr_var$                          : editierbarer Text im Baum nic&
  ' netmask_var$                        : editierbarer Text im Baum nic&
  ' gateway_var$                        : editierbarer Text im Baum nic&
  ' dns_var$                            : editierbarer Text im Baum nic&
  ' domaine_var$                        : editierbarer Text im Baum nic&
  ' hn_var$                             : editierbarer Text im Baum nic&
  ' ispname_var$                        : editierbarer Text im Baum ppp&
  ' atz_var$                            : editierbarer Text im Baum ppp&
  ' timeout_var$                        : editierbarer Text im Baum ppp&
  ' device_var&                         : Radio-Popup im Baum ppp&
  ' speed_var&                          : Radio-Popup im Baum ppp&
  ' ispnumber_var$                      : editierbarer Text im Baum ppp&
  ' user_var$                           : editierbarer Text im Baum ppp&
  ' passwd_var$                         : editierbarer Text im Baum ppp&
  ' nameserver_var$                     : editierbarer Text im Baum ppp&
  ' pppdomain_var$                      : editierbarer Text im Baum ppp&
  ' localip_var$                        : editierbarer Text im Baum ppp&
  ' remoteip_var$                       : editierbarer Text im Baum ppp&
  ' compi_var&                          : Radio-Popup im Baum preinst&
  ' boot_var&                           : Radio-Popup im Baum preinst&
  ' ext2_var&                           : Radio-Popup im Baum preinst&
  '
  ' ---------------------------------------------------------------------------
  ' Fenster-Typen:
  '
  '
  ' ---------------------------------------------------------------------------
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' messagewin_userhandle_&       : userhandle of the messagewin-window   !êêFVW:messagewinêê
  ' messagewin_windowhandle_&     : internal (messagewin-wrinkle)         !êêFVW:messagewinêê
  ' messagewin_$()                : internal (messagewin-wrinkle)         !êêFVW:messagewinêê
  ' messagewin_selected_!()       : internal (messagewin-wrinkle)         !êêFVW:messagewinêê
  ' messagewin_maxline_%          : internal (messagewin-wrinkle)         !êêFVW:messagewinêê
  ' messagewin_entries_%          : internal (messagewin-wrinkle)         !êêFVW:messagewinêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
> FUNCTION user_systemcheck
  $F%
  '
  ' This function is called immediately when the program is started,
  ' and only if the requirements in the system procedure 'SYSTEMCHECK'
  ' is met. Remember: The RSC is NOT YET LOADED! If you need to check
  ' anything special (like a cookie) before allowing the program to load
  ' and run, do it here.
  '
  ' To continue, return TRUE
  ' To abort the program, return FALSE
  '
  ' If you abort the program, use an alert to tell the user WHY the program
  ' is aborted.
  '
  ' If you have no need to check anything, just leave this function empty,
  ' except of course for the 'RETURN TRUE' line below.
  '
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  RETURN TRUE
ENDFUNC
> PROCEDURE user_rsc_var_init
  '
  '  Hier mssen alle Status-Variablen korrekt vorbelegt werden.
  '  Ebenso mssen die Arrays fr die Listboxen hier dimensioniert
  '  und initialisiert werden.
  '
  '  Diese Prozedur wird einmal beim Programmstart durchlaufen.
  '  Danach werden die entsprechenden Dialogobjekte nach
  '  den hier get„tigten Einstellungen eingerichtet.
  '
  '  Werden die Befehle DIM, LET und CLR benutzt, um die Werte zu
  '  setzen, so erkennt faceVALUE dies beim Update. Nicht erkannte
  '  Werte werden beim Update wieder eingefgt.
  '
  '    LET xxx_var&=5        => wird erkannt
  '    xxx_var&=5            => wird nicht erkannt
  '
  '  Sollen einige Werte hier explizit NICHT gesetzt werden, so
  '  kann die entsprechende Zeile mit REM auskommentiert werden:
  '
  '    REM LET xxx_var&=5    => wird erkannt
  '    ' LET xxx_var&=5      => wird nicht erkannt
  '
  current_menubar&=mainmenu&      !in diese Variable den Menbaum-Index eintragen
  ' current_menubar&=-1
  '
  ' snap_windows!=TRUE
  quit_alert!=TRUE
  animate_background_alert!=FALSE
  animate_sound_off!=FALSE
  '
  LET st_var&=1                             ! min=1/max=6 - Baum: rechner&
  LET pakete_var!=FALSE                     ! TRUE/FALSE - Baum: pre&
  LET man_var!=FALSE                        ! TRUE/FALSE - Baum: pre&
  LET net_var!=FALSE                        ! TRUE/FALSE - Baum: pre&
  LET devel_var!=FALSE                      ! TRUE/FALSE - Baum: pre&
  LET libs_var!=FALSE                       ! TRUE/FALSE - Baum: pre&
  LET x11_var!=FALSE                        ! TRUE/FALSE - Baum: pre&
  LET filecheck_var!=TRUE                  ! TRUE/FALSE - Baum: pre&
  LET shutdown_var!=FALSE                   ! TRUE/FALSE - Baum: pre&
  LET mico_var!=FALSE                       ! TRUE/FALSE - Baum: pre&
  LET login_var&=1                          ! min=1/max=4 - Baum: pfade&
  LET naespfad_var$=""                      ! max L„nge: 65 - Baum: pfade&
  LET naescar_var!=FALSE                    ! TRUE/FALSE - Baum: pfade&
  LET xaaespfad_var$=""                     ! max L„nge: 65 - Baum: pfade&
  LET lw_c_var&=1                           ! min=1/max=23 - Baum: kennung&
  '
  LET kuerzel_var$="ne0"
  LET netmask_var$="2552552550"
  LET hn_var$="easymint"
  '
  LET ispname_var$="T-Online"
  LET atz_var$="ATZ"
  LET timeout_var$="60"
  LET device_var&=1
  LET speed_var&=4
  LET ispnumber_var$="0191011"
  LET nameserver_var$="194 25  2129"
  LET localip_var$="  0  0  0  0"
  LET pppdomain_var$="t-online.de"
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET compi_var&=1                          ! min=1/max=10 - Baum: rechner&
  LET ipadr_var$=""                         ! max L„nge: 12 - Baum: nic&
  LET gateway_var$=""                       ! max L„nge: 12 - Baum: nic&
  LET domaine_var$=""                       ! max L„nge: 20 - Baum: nic&
  LET user_var$=""                          ! max L„nge: 50 - Baum: ppp&
  LET passwd_var$=""                        ! max L„nge: 30 - Baum: ppp&
  LET remoteip_var$=""                      ! max L„nge: 12 - Baum: ppp&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET xaaes_var!=FALSE                      ! TRUE/FALSE - Baum: preinst&
  LET xaaeszip_var$=""                      ! max L„nge: 65 - Baum: preinst&
  LET teradesk_var!=FALSE                   ! TRUE/FALSE - Baum: preinst&
  LET tdzip_var$=""                         ! max L„nge: 65 - Baum: preinst&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET ext2_var&=1                           ! min=1/max=10 - Baum: preinst&
  LET boot_var&=1                           ! min=1/max=10 - Baum: preinst&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET lw_c_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
  LET lw_d_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
  LET lw_e_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET ext_c_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
  LET ext_d_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
  LET ext_e_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET rpmsja_var!=FALSE                     ! TRUE/FALSE - Baum: pre&
  '  fV-Update 
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  LET dns_var$=""                           ! max L„nge: 12 - Baum: nic&
  '  fV-Update 
  '
  '
  '
  '  fV-Update: 
  ' Die folgenden Variablen sind durch das Update hinzugekommen:
  '  LET mint115_var&=1                        ! min=1/max=2 - Baum: preinst&
  '  fV-Update 
  '
RETURN
> PROCEDURE user_on_open
  '
  ' This procedure is called when the program is run, after the RSC is
  ' loaded and just before the main loop. You can open program windows,
  ' toolboxes etc. here, or  init things for your program like
  ' loading an *.INF or .DAT file.
  '
  ' If run as an accessory, this procedure is called EVERY TIME
  ' THE ACCESSORY IS OPENED. If you need to do anything just ONCE,
  ' like disable menu-entries spesific to PROGRAM execution, set a global
  ' flag here to avoid doing things EVERY time the accessory is opened.
  @my_init
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  '
  '
  '
  '
  '  fV-Update: 
  ' Der folgende Wrinkle-Code ist durch das Update hinzugekommen:
  '  @messagewin_open(" Messagewindow ",50,200,20,400,180,iconify_icon_1&)   !êêFVW:messagewinêê
  '  fV-Update 
  '
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  IF @exist(install_path$+"\tmp\position.tmp",63)<>0
    @file_check
    IF exit_program!=FALSE
      @info0
    ENDIF
  ENDIF
  IF @exist(install_path$+"\tmp\position.tmp",63)=0
    @make_ext2
  ENDIF
  '
  '
  '
RETURN
> PROCEDURE user_rsc_interact(index&,tree&,object&,mc&,sub_me&)
  '
  '  <index&> Index des Fensters in window_array&(index&,x)
  '           Wenn das Objekt aus der Menzeile ist: <index&>=-1
  '   <tree&> Index des Objektbaumes
  ' <object&> Index des selektierten Objektes (ber Mausklick oder Shortcut)
  '     <mc&> Anzahl der Mausklicks (1=normal oder Shortcut / 2=Doppelklick)
  ' <sub_me&> ausgew„hlter Meneintrag in Popup-Mens
  '
  SELECT tree&
    '
    ' ------------------------------------------------------------------------
    '
  CASE about&
    SELECT object&
      '
    CASE aboutok&
      @win_close(about_hdle&)
      @mw_redraw
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE mainmenu&
    SELECT object&
      '
    CASE mm_about&
      about_hdle&=@win_open_dialog(2,about&,-1)
    CASE mm_quit&
      exit_program!=TRUE
      '       '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE pre&
    SELECT object&
      '
    CASE pre_info&
      about_hdle&=@win_open_dialog(2,about&,-1)
    CASE pakete&
    CASE man&
    CASE net&
      IF net_var!=TRUE
        @net_config
      ELSE IF net_var!=FALSE
        mintnet_flag!=FALSE
      ENDIF
    CASE devel&
    CASE libs&
    CASE x11&
    CASE preabbr&
      eing&=@cancel_inst
      '
      IF eing&=1
        @win_close(pre_hdle&)
        exit_program!=TRUE
      ENDIF
    CASE preok&
      @pre_auswert
      @win_close(pre_hdle&)
      @mw_redraw
      IF ber_inst!=FALSE
        IF pakete_var!=0
          ' Alert 9
          ' ALERT 1,alert9_1$,2,alert9_2$,eing&
          ALERT 1,alert$(9,1),2,alert$(9,2),eing&
          IF eing&=1
            @naes_info
          ENDIF
          IF eing&=2
            @install_base
          ENDIF
        ELSE
          @naes_info
        ENDIF
      ELSE IF ber_inst!=TRUE
        IF lstinst_var!=FALSE
          @handle_package_tgz
        ENDIF
        @install_rpm_auto
        @net_check
      ENDIF
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE pfade&
    SELECT object&
      '
    CASE pf_info&
      about_hdle&=@win_open_dialog(2,about&,-1)
      '
    CASE login&
      IF @exist(boot$+":\xaaes\",16)=0
        @rsc_ob_disable(pfade&,naespfad&,FALSE)
        @rsc_ob_draw(index&,naespfad&)
        @rsc_ob_disable(pfade&,naescar&,FALSE)
        @rsc_ob_draw(index&,naescar&)
        @rsc_ob_disable(pfade&,xaaespfad&,FALSE)
        @rsc_ob_draw(index&,xaaespfad&)
      ELSE
        @rsc_ob_disable(pfade&,naespfad&,FALSE)
        @rsc_ob_draw(index&,naespfad&)
        @rsc_ob_disable(pfade&,naescar&,FALSE)
        @rsc_ob_draw(index&,naescar&)
        @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
        @rsc_ob_draw(index&,xaaespfad&)
      ENDIF
    CASE naes_drkt&
      @rsc_ob_disable(pfade&,naespfad&,FALSE)
      @rsc_ob_draw(index&,naespfad&)
      @rsc_ob_disable(pfade&,naescar&,FALSE)
      @rsc_ob_draw(index&,naescar&)
      @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
      @rsc_ob_draw(index&,xaaespfad&)
    CASE xaaesstrt&
      @rsc_ob_disable(pfade&,naespfad&,TRUE)
      @rsc_ob_draw(index&,naespfad&)
      @rsc_ob_disable(pfade&,naescar&,TRUE)
      @rsc_ob_draw(index&,naescar&)
      @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
      @rsc_ob_draw(index&,xaaespfad&)
    CASE plaintos&
      @rsc_ob_disable(pfade&,naespfad&,TRUE)
      @rsc_ob_draw(index&,naespfad&)
      @rsc_ob_disable(pfade&,naescar&,TRUE)
      @rsc_ob_draw(index&,naescar&)
      @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
      @rsc_ob_draw(index&,xaaespfad&)
    CASE naespfad&
      datei$=@fileselector$("NAES.SYS?",boot$+":\*.SYS","",FALSE,"")
      IF @exist(datei$,63)=0
        naespfad_var$=datei$
        @rsc_setup_tree(pfade&)
        @rsc_ob_draw(index&,naespfad&)
      ENDIF
    CASE pathabbr&
      @win_close(pfade_hdle&)
      exit_program!=TRUE
    CASE pathok&
      @pfade_auswert
      @win_close(pfade_hdle&)
      @mw_redraw
      ' In die MiNT Domain schalten
      ~@pdomain(1)
      '
      @rootfs_install
      @handle_package_tgz
      @install_rpm_auto
      @make_ttytab(start_mode&) ! Hier, da sonst von rpm berbgelt
      @xaaes_cnf_create(FALSE) ! EasyMiNT Autostart wieder raus
      @teradesk_inf_create
      @mintcnf_create(TRUE)
      @net_check
      IF dhcp_flag!=TRUE ! Sonst wird easymint nicht beendet
        @netconfig_quit
      ENDIF
      '
      '
      '  fV-Update: 
      ' Die folgenden Objekte sind durch das Update hinzugekommen:
    CASE xaaespfad&
      '  fV-Update 
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE message&
    SELECT object&
      '
    CASE infoabbr&
      eing&=@cancel_inst
      IF eing&=1
        @win_close(mes_hdle&)
        exit_program!=TRUE
        @mw_redraw
      ENDIF
    CASE mes_ok&
      @win_close(mes_hdle&)
      @mw_redraw
      IF info0!=TRUE
        @lnx_suchen
      ENDIF
      '      IF ext2_info!=TRUE
      '      @angemeldete_lw
      '      @lnx_find
      '      ext2_info!=FALSE
      '    ENDIF
      IF boot_info!=TRUE
        @auspacken
        @kernel_copy
        boot_info!=FALSE
      ENDIF
      IF naes_info!=TRUE
        @pfade_vorbeleg
        naes_info!=FALSE
      ENDIF
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE message2&
    SELECT object&
      '
    CASE inf2abbr&
      eing&=@cancel_inst
      IF eing&=1
        @win_close(mes2_hdle&)
        exit_program!=TRUE
        @mw_redraw
      ENDIF
    CASE mes_ok_00&
      @win_close(mes2_hdle&)
      @mw_redraw
      IF neustart_info!=TRUE
        @neustart
        neustart_info!=FALSE
      ENDIF
      IF endconf_info!=TRUE
        @newdesk_auto_del
        exit_program!=TRUE
        ' @kaltstart
        @shutdown
        endconf_info!=FALSE
      ENDIF
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE nic&
    SELECT object&
    CASE nic_info&
      about_hdle&=@win_open_dialog(2,about&,-1)
    CASE kuerzel&
    CASE ipadr&
    CASE netmask&
    CASE dns&
    CASE gateway&
    CASE hn&
    CASE domaine&
    CASE nw_abbr&
      @win_close(nic_hdle&)
    CASE nw_ok&
      @nic_auswert
      '      ALERT 1,alert17_1$+" "+boot$+alert17_2$,1,alert17_3$,eing&
      @nic_driver_copy
      @win_close(nic_hdle&)
      '
      @netconfig_quit
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE ppp&
    SELECT object&
    CASE ispname&
    CASE ppp_info&
      about_hdle&=@win_open_dialog(2,about&,-1)
    CASE atz&
    CASE timeout&
    CASE device&
    CASE speed&
    CASE ispnumber&
    CASE user&
    CASE passwd&
      passwd_var$=@invisible_text$(passwd_var$,tree&,window_array&(index&,3),passwd$)
      @rsc_ob_reset(ppp&,passwd&)
    CASE nameserver&
    CASE localip&
    CASE pppdomain&
    CASE remoteip&
    CASE ppp_abbr&
      @win_close(ppp_hdle&)
    CASE ppp_ok&
      @ppp_auswert
      ' ALERT 1," Internetverbindung aus | der bash mit - | pppd call "+ispname_var$+" | - starten!",1," OK ",eing&
      ' ALERT 1,alert16_1$+" "+ispname_var$+alert16_2$,1,alert16_3$,eing&
      ALERT 1,alert$(16,1)+" "+ispname_var$+alert$(16,2),1,alert$(16,3),eing&
      @win_close(ppp_hdle&)
      '
      @netconfig_quit
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE preinst&
    SELECT object&
    CASE preinfo&
      about_hdle&=@win_open_dialog(2,about&,-1)
    CASE compi&
      '
    CASE ext2&
    CASE boot&
    CASE pabbr&
      eing&=@cancel_inst
      '
      IF eing&=1
        @win_close(preinst_hdle&)
        exit_program!=TRUE
      ENDIF
    CASE pok&
      boot$=CHR$(66+boot_var&)
      lw_fs$=@lower$(CHR$(66+ext2_var&))
      '
      @win_close(preinst_hdle&)
      @boot_info
      '
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  ENDSELECT
RETURN
> PROCEDURE user_rsc_context_help(tree&)
  '
  ' Von hier aus wird der ST-Guide aufgerufen. Bitte die Namen
  ' der entsprechenden Hilfeseiten eintragen:
  '
  SELECT tree&
    ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
    ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
    ' CASE -2 ! Compiler Error "structure error" umgehen
  DEFAULT
    @call_st_guide("easymint.hyp","")
  ENDSELECT
RETURN
> PROCEDURE user_rsc_draw_extra(userhandle&,index&,tree&,tree%,cx&,cy&,cw&,ch&)
  LOCAL x&,y&,w&,h&
  ~GRAF_MOUSE(256,0) !hidem - to avoid "mousedroppings"
  '
  ' This procedure is here if you need to draw anything in the dialog that
  ' cannot be in the RSC-file. The clipping rectangle is already set
  ' for this procedure (walking the rectangle tree) MUST NOT BE ALTERED!!!
  ' Else you may find yourself drawing over other objects, or even windows!
  '
  ' <userhandle&> is the userhandle you gave when opening the window
  '               or -1 if it is a dialog window
  ' <index&> is the index of this window in window_array&(index&,x)
  ' <tree&> is the object tree number of the dialog or toolstrip/bar
  ' <tree%> is the object tree adress of the dialog or toolstrip/bar
  ' <cx&>,<cy&>,<cw&>,<ch&> is the clipping rectangle set
  '
  ' You should limit your drawing/blitting commands to the size and
  ' location of an IBOX/BOX object. The BOX will give you a backround,
  ' the IBOX will not. The location and width/height of the IBOX/BOX
  ' are found by calling:
  '
  ' @rsc_ob_xywh(tree%,object&,x&,y&,w&,h&)
  '
  ' <tree%> is the object tree adress
  ' <object&> is the object number
  ' <x&> is the x-coordinate
  ' <y&> is the y-coordinate
  ' <w&> is the width
  ' <h&> is the height
  '
  ' So you might set up a SELECT/CASE structure that looks
  ' something like this example:
  '
  '   SELECT tree&
  '   CASE dialog_1&
  '     @rsc_ob_xywh(tree%,help2&,x&,y&,w&,h&)
  '     DEFFILL 1,2,5
  '     PBOX x&,y&,PRED(ADD(x&,w&)),PRED(ADD(y&,h&))
  '   CASE toolstrip_h&
  '     @rsc_ob_xywh(tree%,t_clip&,x&,y&,w&,h&)
  '     DEFFILL 1,2,5
  '     PBOX x&,y&,PRED(ADD(x&,w&)),PRED(ADD(y&,h&))
  '   ENDSELECT
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  ~GRAF_MOUSE(257,0) !showm - display pointer again
RETURN
> PROCEDURE user_window_content(index&,userhandle&,off_x%,off_y%,cx&,cy&,cw&,ch&)
  ~GRAF_MOUSE(256,0) !hidem - to avoid "mousedroppings"
  '
  ' This procedure is called when a user window needs to be redrawn.
  ' ALL of the window content should be drawn here. The x & y offsets
  ' will be automatically updated by the system and are ALWAYS current.
  ' DO NOT alter the clipping rectangle, it is set (walking the
  ' rectangle list) BEFORE calling this procedure.
  '
  ' All your coordinates should be relative to the upper left of
  ' the work area of the window, except for blitting wich is relative
  ' to the upper left of the screen. If the window is scrollable/has sliders,
  ' subtract <off_x&> from ALL x-coordinates and <off_y&> from ALL
  ' y-coordinates.
  '
  ' <index&> is the index of this window in window_array&(index&,x)
  ' <userhandle&> is the userhandle you gave when opening the window
  ' <off_x%> is the x offset of the window contents
  ' <off_y%> is the y offset of the window contents
  ' <cx&>,<cy&>,<cw&>,<ch&> is the clipping rectangle set
  '
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  IF userhandle&=messagewin_userhandle_&                                  !êêFVW:messagewinêê
    @textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,messagewin_entries_%,messagewin_$(),messagewin_selected_!())      !êêFVW:messagewinêê
  ENDIF                                                                   !êêFVW:messagewinêê
  ' ---------------------------------------------------------------------------   !êêFVW:textlistêê
  ' Textlist-Wrinkle:     (½1997 by Holger Herzog)                                !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' Draw your textlists here. Just call textlist_draw like it is described in     !êêFVW:textlistêê
  ' wrinkle_info.                                                                 !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' SELECT userhandle&                                                            !êêFVW:textlistêê
  ' CASE xxx                                                                      !êêFVW:textlistêê
  '   @textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,list$(),selected!())       !êêFVW:textlistêê
  ' ENDSELECT                                                                     !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  ~GRAF_MOUSE(257,0) !showm - display pointer again
RETURN
> PROCEDURE user_mouse(handle&,userhandle&,index&,mx&,my&,mc&,mb&,ks&)
  LOCAL x&,y&,w&,h&
  '
  ' If the user clicks in the work area of a userwindow
  ' with the mouse, this procedure is called. The mouse-coordinates
  ' are screen coordinates. There is no reason to check if the mouse is
  ' inside the work area of the window, this procedure would not be called
  ' otherwise.
  '
  ' To get the true work area of this window, you call:
  '
  @win_get_workarea(index&,x&,y&,w&,h&)
  '
  ' <x&>,<y&>,<w&> and <h&> are x,y,width and height for the work area
  ' of the window.
  '
  ' <handle&> is the GEM handle of the window
  ' <userhandle&> is the userhandle you gave when opening the window
  ' <index&> is the index of this window in window_array&(index&,x)
  ' <mx&> is the x-mouseposition
  ' <my&> is the y-mouseposition
  ' <mc&> is the number of clicks (1=normal/2=double clicked)
  ' <mb&> is the mousebutton that was clicked (1=left/2=right)
  ' <ks&> is the keyboard state when the mouse was clicked, thus:
  '     IF AND(ks&,&X11): shift key pressed (either one)
  '     IF BTST(ks&,2)  : control key pressed
  '     IF BTST(ks&,3)  : alternate key pressed
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' ---------------------------------------------------------------------------   !êêFVW:textlistêê
  ' Textlist-Wrinkle:     (½1997 by Holger Herzog)                                !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' Call textlist_click to handle mouseclicks in textlist-userwindows.            !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' LOCAL dd!                                                                     !êêFVW:textlistêê
  ' SELECT userhandle&                                                            !êêFVW:textlistêê
  ' CASE xxx                                                                      !êêFVW:textlistêê
  '  LET dd!=TRUE        ! allow drag&drop                                        !êêFVW:textlistêê
  '  LET selected&=@textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,selected!(),hash&())       !êêFVW:textlistêê
  '  IF selected&=>0                                                              !êêFVW:textlistêê
  '    ' Doubleclick!                                                             !êêFVW:textlistêê
  '  ENDIF                                                                        !êêFVW:textlistêê
  ' ENDSELECT                                                                     !êêFVW:textlistêê
  '                                                                               !êêFVW:textlistêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
> PROCEDURE user_keyb(handle&,userhandle&,index&,ks&,key&)
  '
  '
  ' To help you get going:
  '
  ' scancode         : BYTE(SHR(key&,8))
  ' ascii value      : BYTE(key&)
  ' IF AND(ks&,&X11) : shift key pressed (either one)
  ' IF BTST(ks&,2)   : control key pressed
  ' IF BTST(ks&,3)   : alternate key pressed
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
> FUNCTION user_win_close_ok(index&,userhandle&)
  $F%
  '
  ' User wants to close the userwindow in <index&>
  ' <userhandle&> is the userhandle you gave when opening the window
  ' Return value: TRUE  to close window
  '               FALSE to ignore close call
  '
  ' The code in this function is just an example. If you want to use an
  ' alert, you may (should?:-) want to use a windowed alert...
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  IF userhandle&=messagewin_userhandle_&                          !êêFVW:messagewinêê
    @messagewin_close                                             !êêFVW:messagewinêê
    RETURN TRUE                                                   !êêFVW:messagewinêê
  ENDIF                                                           !êêFVW:messagewinêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
  SELECT FORM_ALERT(1,"[1][Really close? ][ OK |Cancel]")
  CASE 1
    RETURN TRUE
  CASE 2
    RETURN FALSE
  ENDSELECT
  '
ENDFUNC
> PROCEDURE user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
  '
  ' Any message the faceVALUE engine do not understand, goes to this proc.
  ' Here, you are free to implement your own communication protocols, or
  ' to ignore unknown messages completly and leave it empty.
  '
  ' <mx&> and <my&> are the mouse coordinates at the time of the message
  ' <ks&> is the keyboard state at the time of the message
  ' <m0&> to <m7&> are the actual words in the message
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
> FUNCTION user_quit_ok
  $F%
  exit_program!=FALSE
  IF acc!
    RETURN TRUE
  ELSE
    '
    ' User wants to quit
    ' Return value: TRUE  to quit
    '               FALSE to ignore
    '
    ' If you want to use an alert, you may (should?:-) want to use
    ' a windowed alert...
    '
    ' The rest of the code in this function should *NOT* be altered!
    '
    ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
    ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
    '
    RETURN TRUE
    '
  ENDIF
ENDFUNC
> PROCEDURE user_win_close_all
  '
  ' This procedure is called when the WIN_CLOSE_ALL procedure of the FV engine
  ' is called, and before the windows are closed and the window arrays erased.
  '
  ' If you have any resources attatched to each window, you can clean them
  ' up here. (releasing memory etc.)
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  @messagewin_close                                                       !êêFVW:messagewinêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
> PROCEDURE user_on_exit
  '
  ' This procedure is called when you exit the program. If you need to
  ' release memory, restore the original desktop or do other
  ' "cleaning up" tasks, do it here.
  '
  ' If run as an accessory, this procedure is called EVERY TIME
  ' THE ACCESSORY IS CLOSED. (Remember: An accessory is NEVER exited)
  '
  ' êêwsnippetêê  - Wrinkle-Code: (dieses Flag nicht l”schen oder ver„ndern)
  @messagewin_close                                                       !êêFVW:messagewinêê
  ' êêwsnippetêê  - Ende des Wrinkle-Codes: (dieses Flag nicht l”schen oder ver„ndern)
  '
RETURN
'
' ------------------------------------------------------------------------
' WRINKLE-Callback-Routinen: bei Bedarf ausfllen ...
'
> PROCEDURE user_textlist_dragdrop(source&,dest&,dx&,dy&)
  '
  ' written on 25.09.1996 by Holger Herzog
  '
  ' Version 1.1
  '
  ' This procedure is called if the user has moved one or a few entries
  ' of a textlist-window by drag and drop. Be advised that source- and
  ' destinationwindow could be same.
  '
  '     source&                 ==> FV-Index of source-window
  '     dest&                   ==> FV-Index of destination-window
  '     dx&, dy&                ==> position (in pixels) where the user has
  '                                 dopped the entries (realtive to the left
  '                                 upper corner of the destination-window)
  '
  ' Version 1.0         27.09.1996 Holger Herzog
  ' Version 1.1         29.03.1997 Holger Herzog
  '                     Docu now in english :-)
  '
  ' LOCAL source_handle&,source_userhandle&
  ' LOCAL dest_handle&,dest_userhandle&
  ' LOCAL off_x&,off_y&
  '
  ' LET source_handle&=window_array&(source&,0)
  ' LET source_userhandle&=window_array&(source&,8)
  ' LET dest_handle&=window_array&(dest&,0)
  ' LET dest_userhandle&=window_array&(dest&,8)
  ' LET off_x&=window_array&(dest&,10)
  ' LET off_y&=window_array&(dest&,11)
  '
  '
RETURN
'
'
'
' ------------------------------------------------------------------------
' êê_system_êê - SYSTEM: - Nicht ver„ndern! '!call'-Routinen k”nnen aufgerufen werden.
'
> PROCEDURE init
  LOCAL a&
  LET current_menutitle&=-1
  LET top_modal&=-1
  LET rsc_path_name$="EASYMINT.rsc"
  LET max_number_windows&=4         ! +SYM
  LET window_array_size&=25     ! +SYM
  LET windowtree_array_size&=5     ! +SYM
  DIM window_array&(max_number_windows&,window_array_size&)
  DIM window_tree%(max_number_windows&,windowtree_array_size&)
  DIM fvrc_evnt&(12)
  LET fv_aes_timer!=FALSE
  FOR a&=0 TO max_number_windows&
    LET window_array&(a&,21)=-1
  NEXT a&
  LET gdos_minimum&=0          ! +SYM
  LET num_prgdef_objects&=47          ! +SYM
  LET last_tree&=16          ! +SYM
  LET no_rsc_found$="[3][ |RSC-File nicht gefunden! ][ Abbruch ]"
  LET not_accessory$="[3][ |This is not an accessory! ][  OK  ]"
  LET systemcheck_alert$="[3][ |System requirements not met. ][ Abort ]"
  '
  '
  ' ++SYM
  '
  '
  ' ---------------------------------------------------------------------------
  ' Globale RSC-Datei Variablen:
  LET system&=0
  LET fvt_asci&=1
  LET fvt_alst&=2
  LET fvt_work&=3
  LET fvt_prog&=4
  LET fvt_popu&=5
  LET fvt_maus&=6
  LET about&=7
  LET mainmenu&=8
  LET pre&=9
  LET pfade&=10
  LET message&=11
  LET message2&=12
  LET startprg&=13
  LET nic&=14
  LET ppp&=15
  LET preinst&=16
  LET lw_c&=29
  LET lw_d&=30
  LET lw_e&=31
  LET lw_f&=32
  LET lw_g&=33
  LET lw_h&=34
  LET lw_i&=35
  LET lw_j&=36
  LET lw_k&=37
  LET lw_l&=38
  LET lw_m&=39
  LET lw_n&=40
  LET lw_o&=41
  LET lw_p&=42
  LET lw_q&=43
  LET lw_r&=44
  LET lw_s&=45
  LET lw_t&=46
  LET lw_u&=47
  LET lw_v&=48
  LET lw_w&=49
  LET lw_x&=50
  LET lw_y&=51
  LET lw_z&=52
  LET lw_1&=53
  LET lw_2&=54
  LET lw_3&=55
  LET lw_4&=56
  LET lw_5&=57
  LET lw_6&=58
  LET ext_c&=60
  LET ext_d&=61
  LET ext_e&=62
  LET ext_f&=63
  LET ext_g&=64
  LET ext_h&=65
  LET ext_i&=66
  LET ext_j&=67
  LET ext_k&=68
  LET ext_l&=69
  LET ext_m&=70
  LET ext_n&=71
  LET ext_o&=72
  LET ext_p&=73
  LET ext_q&=74
  LET ext_r&=75
  LET ext_s&=76
  LET ext_t&=77
  LET ext_u&=78
  LET ext_v&=79
  LET ext_w&=80
  LET ext_x&=81
  LET ext_y&=82
  LET ext_z&=83
  LET ext_1&=84
  LET ext_2&=85
  LET ext_3&=86
  LET ext_4&=87
  LET ext_5&=88
  LET ext_6&=89
  LET smilemouse&=2
  LET version1&=3
  LET version2&=5
  LET version3&=6
  LET version4&=7
  LET version5&=8
  LET aboutok&=9
  LET mm_about&=7
  LET mm_quit&=16
  LET pre_info&=2
  LET pakete&=4
  LET man&=5
  LET net&=6
  LET devel&=7
  LET libs&=8
  LET x11&=9
  LET rpmsja&=11
  LET filecheck&=13
  LET shutdown&=14
  LET mico&=15
  LET preabbr&=16
  LET preok&=17
  LET pf_info&=2
  LET login&=4
  LET naes_drkt&=5
  LET xaaesstrt&=6
  LET plaintos&=7
  LET naespfad&=10
  LET naescar&=11
  LET xaaespfad&=14
  LET pathabbr&=15
  LET pathok&=16
  LET mes1&=2
  LET mes2&=3
  LET mes3&=4
  LET mes4&=5
  LET mes5&=6
  LET mes6&=7
  LET mes7&=8
  LET infoabbr&=9
  LET mes_ok&=10
  LET mes1_00&=2
  LET mes2_00&=3
  LET mes3_00&=4
  LET mes4_00&=5
  LET mes5_00&=6
  LET mes6_00&=7
  LET mes7_00&=8
  LET inf2abbr&=9
  LET mes_ok_00&=10
  LET appname&=2
  LET nic_info&=2
  LET kuerzel&=4
  LET ipadr&=6
  LET netmask&=8
  LET defaultr&=9
  LET gateway&=10
  LET dns&=12
  LET domain&=13
  LET domaine&=14
  LET hn&=16
  LET nw_abbr&=17
  LET nw_ok&=18
  LET ispname&=3
  LET ppp_info&=4
  LET atz&=6
  LET timeout&=8
  LET device&=10
  LET speed&=13
  LET ispnumber&=16
  LET user&=18
  LET passwd&=20
  LET nameserver&=22
  LET pppdomain&=24
  LET localip&=28
  LET remoteip&=30
  LET ppp_abbr&=31
  LET ppp_ok&=32
  LET preinfo&=2
  LET compi&=4
  LET boot&=7
  LET ext2&=10
  LET pabbr&=12
  LET pok&=13
  '
  ' ++SYM
  '
RETURN
> FUNCTION systemcheck
  $F%
  LOCAL ok!
  ok!=TRUE
  IF ok!=FALSE
    ~FORM_ALERT(1,systemcheck_alert$)
  ELSE
    ok!=@user_systemcheck
  ENDIF
  RETURN ok!
ENDFUNC
> PROCEDURE rsc_setup_tree(tree&)                                   !call
  SELECT tree&
  CASE fvt_popu&
    @rsc_set_selectable(tree&,lw_c&,lw_c_var!)
    @rsc_set_selectable(tree&,lw_d&,lw_d_var!)
    @rsc_set_selectable(tree&,lw_e&,lw_e_var!)
    @rsc_set_selectable(tree&,ext_c&,ext_c_var!)
    @rsc_set_selectable(tree&,ext_d&,ext_d_var!)
    @rsc_set_selectable(tree&,ext_e&,ext_e_var!)
  CASE pre&
    @rsc_set_selectable(tree&,pakete&,pakete_var!)
    @rsc_set_selectable(tree&,man&,man_var!)
    @rsc_set_selectable(tree&,net&,net_var!)
    @rsc_set_selectable(tree&,devel&,devel_var!)
    @rsc_set_selectable(tree&,libs&,libs_var!)
    @rsc_set_selectable(tree&,x11&,x11_var!)
    @rsc_set_selectable(tree&,rpmsja&,rpmsja_var!)
    @rsc_set_selectable(tree&,filecheck&,filecheck_var!)
    @rsc_set_selectable(tree&,shutdown&,shutdown_var!)
    @rsc_set_selectable(tree&,mico&,mico_var!)
  CASE pfade&
    @rsc_set_radio(tree&,login&,login_var&,-1)
    @rsc_set_text(tree&,naespfad&,naespfad_var$)
    @rsc_set_selectable(tree&,naescar&,naescar_var!)
    @rsc_set_text(tree&,xaaespfad&,xaaespfad_var$)
  CASE nic&
    @rsc_set_text(tree&,kuerzel&,kuerzel_var$)
    @rsc_set_text(tree&,ipadr&,ipadr_var$)
    @rsc_set_text(tree&,netmask&,netmask_var$)
    @rsc_set_text(tree&,gateway&,gateway_var$)
    @rsc_set_text(tree&,dns&,dns_var$)
    @rsc_set_text(tree&,domaine&,domaine_var$)
    @rsc_set_text(tree&,hn&,hn_var$)
  CASE ppp&
    @rsc_set_text(tree&,ispname&,ispname_var$)
    @rsc_set_text(tree&,atz&,atz_var$)
    @rsc_set_text(tree&,timeout&,timeout_var$)
    @popup_set_selected(tree&,device&,device_var&,-1)
    @popup_set_selected(tree&,speed&,speed_var&,-1)
    @rsc_set_text(tree&,ispnumber&,ispnumber_var$)
    @rsc_set_text(tree&,user&,user_var$)
    @rsc_set_text(tree&,passwd&,passwd_var$)
    @rsc_set_text(tree&,nameserver&,nameserver_var$)
    @rsc_set_text(tree&,pppdomain&,pppdomain_var$)
    @rsc_set_text(tree&,localip&,localip_var$)
    @rsc_set_text(tree&,remoteip&,remoteip_var$)
  CASE preinst&
    @popup_set_selected(tree&,compi&,compi_var&,-1)
    @popup_set_selected(tree&,boot&,boot_var&,-1)
    @popup_set_selected(tree&,ext2&,ext2_var&,-1)
  ENDSELECT
RETURN
> PROCEDURE rsc_read_tree(tree&,object&)
  SELECT tree&
  CASE fvt_popu&
    SELECT object&
    CASE lw_c&
      LET lw_c_var!=@rsc_get_selectable(tree&,object&)
    CASE lw_d&
      LET lw_d_var!=@rsc_get_selectable(tree&,object&)
    CASE lw_e&
      LET lw_e_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_c&
      LET ext_c_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_d&
      LET ext_d_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_e&
      LET ext_e_var!=@rsc_get_selectable(tree&,object&)
    ENDSELECT
  CASE pre&
    SELECT object&
    CASE pakete&
      LET pakete_var!=@rsc_get_selectable(tree&,object&)
    CASE man&
      LET man_var!=@rsc_get_selectable(tree&,object&)
    CASE net&
      LET net_var!=@rsc_get_selectable(tree&,object&)
    CASE devel&
      LET devel_var!=@rsc_get_selectable(tree&,object&)
    CASE libs&
      LET libs_var!=@rsc_get_selectable(tree&,object&)
    CASE x11&
      LET x11_var!=@rsc_get_selectable(tree&,object&)
    CASE rpmsja&
      LET rpmsja_var!=@rsc_get_selectable(tree&,object&)
    CASE filecheck&
      LET filecheck_var!=@rsc_get_selectable(tree&,object&)
    CASE shutdown&
      LET shutdown_var!=@rsc_get_selectable(tree&,object&)
    CASE mico&
      LET mico_var!=@rsc_get_selectable(tree&,object&)
    ENDSELECT
  CASE pfade&
    SELECT object&
    CASE login&,5,6,7
      LET login_var&=@rsc_get_radio(tree&,object&)
    CASE naespfad&
      LET naespfad_var$=@rsc_get_text$(tree&,object&)
    CASE naescar&
      LET naescar_var!=@rsc_get_selectable(tree&,object&)
    CASE xaaespfad&
      LET xaaespfad_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE nic&
    SELECT object&
    CASE kuerzel&
      LET kuerzel_var$=@rsc_get_text$(tree&,object&)
    CASE ipadr&
      LET ipadr_var$=@rsc_get_text$(tree&,object&)
    CASE netmask&
      LET netmask_var$=@rsc_get_text$(tree&,object&)
    CASE gateway&
      LET gateway_var$=@rsc_get_text$(tree&,object&)
    CASE dns&
      LET dns_var$=@rsc_get_text$(tree&,object&)
    CASE domaine&
      LET domaine_var$=@rsc_get_text$(tree&,object&)
    CASE hn&
      LET hn_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE ppp&
    SELECT object&
    CASE ispname&
      LET ispname_var$=@rsc_get_text$(tree&,object&)
    CASE atz&
      LET atz_var$=@rsc_get_text$(tree&,object&)
    CASE timeout&
      LET timeout_var$=@rsc_get_text$(tree&,object&)
    CASE device&
      LET device_var&=@popup_get_radio(tree&,object&)
    CASE speed&
      LET speed_var&=@popup_get_radio(tree&,object&)
    CASE ispnumber&
      LET ispnumber_var$=@rsc_get_text$(tree&,object&)
    CASE user&
      LET user_var$=@rsc_get_text$(tree&,object&)
    CASE passwd&
      LET passwd_var$=@rsc_get_text$(tree&,object&)
    CASE nameserver&
      LET nameserver_var$=@rsc_get_text$(tree&,object&)
    CASE pppdomain&
      LET pppdomain_var$=@rsc_get_text$(tree&,object&)
    CASE localip&
      LET localip_var$=@rsc_get_text$(tree&,object&)
    CASE remoteip&
      LET remoteip_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE preinst&
    SELECT object&
    CASE compi&
      LET compi_var&=@popup_get_radio(tree&,object&)
    CASE boot&
      LET boot_var&=@popup_get_radio(tree&,object&)
    CASE ext2&
      LET ext2_var&=@popup_get_radio(tree&,object&)
    ENDSELECT
  ENDSELECT
RETURN
> FUNCTION get_rsc
  $F%
  LOCAL ret%
  ~@appl_xgetinfo(2,gout1&,gout2&,gout3&,gout4&)
  IF gout3&=1 AND gout4&=1
    LET ret%=RSRC_LOAD(rsc_path_name$)
    CLR rsc_handle%
  ELSE
    LET ret%=@xrsrc_load(rsc_path_name$)
    LET rsc_handle%=ret%
  ENDIF
  RETURN ret%
ENDFUNC
> PROCEDURE cleanup_after_rsc
  IF rsc_handle%=0
    ~RSRC_FREE()
  ELSE
    ~@xrsrc_free(rsc_handle%)
    CLR rsc_handle%
  ENDIF
RETURN
> FUNCTION xrsrc_gaddr(type&,tree&)                                       !call
  $F%
  LOCAL tree%
  IF rsc_handle%=0
    ~RSRC_GADDR(type&,tree&,tree%)
  ELSE IF NOT (rsc_handle%>=0 AND rsc_handle%<1024)
    ~@xrsrc_xgaddr(rsc_handle%,type&,tree&,tree%)
  ENDIF
  RETURN tree%
ENDFUNC
> FUNCTION win_snap(x&)
  $F%
  IF snap_windows!
    RETURN SUB(x&,MOD(x&,16))
  ENDIF
  RETURN x&
ENDFUNC
> PROCEDURE win_place_tree(handle&)
  LOCAL x&,y&,d&
  LOCAL index&
  ~WIND_GET(handle&,4,x&,y&,d&,d&)
  LET index&=@win_get_index(handle&)
  OB_X(window_tree%(index&,0),0)=SUB(x&,window_array&(index&,15))
  OB_Y(window_tree%(index&,0),0)=y&
RETURN
> PROCEDURE win_close_all                                                 !call
  LOCAL a&,b&
  @user_win_close_all
  IF @win_modal_enq
    @disable_menus(0)
    top_modal&=-1
  ENDIF
  FOR a&=0 TO max_number_windows&
    IF window_array&(a&,0)>0
      ~WIND_CLOSE(window_array&(a&,0))
      ~WIND_DELETE(window_array&(a&,0))
      FOR b&=0 TO window_array_size&
        window_array&(a&,b&)=0
      NEXT b&
      FOR b&=0 TO windowtree_array_size&
        window_tree%(a&,b&)=0
      NEXT b&
      window_array&(a&,21)=-1
    ENDIF
  NEXT a&
RETURN
> PROCEDURE win_close(handle&)                                            !call
  LOCAL index&,type!,a&,prev_top&
  IF handle&>0
    index&=@win_get_index(handle&)
    IF index&<>-1
      IF top_modal&<>-1 AND index&<>top_modal&
        ~GEMDOS(2,7)
      ELSE
        ~WIND_CLOSE(handle&)
        ~WIND_DELETE(handle&)
        IF window_array&(index&,1)=1 OR window_array&(index&,1)=4
          type!=TRUE
          prev_top&=window_array&(index&,6)
        ELSE IF window_array&(index&,1)=0 AND window_array&(index&,24)=0
          type!=TRUE
          prev_top&=window_array&(index&,25)
        ENDIF
        FOR a&=0 TO window_array_size&
          window_array&(index&,a&)=0
        NEXT a&
        window_array&(index&,21)=-1
        FOR a&=0 TO windowtree_array_size&
          window_tree%(index&,a&)=0
        NEXT a&
        IF type!
          IF NOT @win_modal_enq
            @disable_menus(0)
            top_modal&=-1
          ELSE
            top_modal&=prev_top&
            ~WIND_SET(window_array&(top_modal&,0),10,0,0,0,0)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_set_title(index&,title$)                                  !call
  LOCAL adr%
  IF LEN(title$)>78
    title$=LEFT$(title$,78)
  ENDIF
  title$=title$+CHR$(0)
  adr%=window_tree%(index&,1)
  BMOVE V:title$,adr%,LEN(title$)
  ~WIND_SET(window_array&(index&,0),2,CARD(SWAP(adr%)),CARD(adr%),0,0)
RETURN
> FUNCTION win_open_dialog(type&,tree&,icon&)                             !call
  $F%
  RETURN @win_open_dialog2(type&,tree&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open_dialog2(type&,tree&,icon&,ic!)
  $F%
  LOCAL handle&,kind&,x&,y&,w&,h&,index&,tree%,dx&,dy&,dw&,dh&,d&
  LOCAL ob_backgr&
  tree%=@xrsrc_gaddr(0,tree&)
  index&=@find_free_w_array
  IF index&<>-1
    IF @find_handle_from_tree(tree&)=-1
      SELECT type&
      CASE -1
        SELECT BYTE(SHR&(OB_TYPE(tree%,0),8))
        CASE 18 !non modal
          type&=2
          kind&=&X1011
        CASE 19 !prg modal
          type&=1
          kind&=&X1001
        CASE 20 !toolbox
          type&=3
          kind&=&X1001
        DEFAULT !non modal
          type&=2
          kind&=&X1011
        ENDSELECT
      CASE 1,3
        kind&=&X1001
      CASE 2,4
        kind&=&X1011
      CASE 5
        type&=1
        kind&=&X1011
      CASE 6
        type&=3
        kind&=&X1011
      CASE 7
        type&=1
        kind&=0
      CASE 8
        type&=2
        kind&=0
      CASE 9
        type&=3
        kind&=0
      ENDSELECT
      IF icon&<>-1 AND type&<>1 AND type&<>4 AND kind&<>0
        kind&=kind& OR &X100000000000000
      ENDIF
      ob_backgr&=0
      ~WIND_CALC(0,kind&,OB_X(tree%,0),OB_Y(tree%,0),OB_W(tree%,ob_backgr&),OB_H(tree%,ob_backgr&),x&,y&,w&,h&)
      ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
      IF x&<dx& OR y&<dy& OR x&+w&>dx&+dw& OR y&+h&>dy&+dh&
        ~FORM_CENTER(tree%,d&,d&,d&,d&)
        ~WIND_CALC(0,kind&,OB_X(tree%,0),OB_Y(tree%,0),OB_W(tree%,ob_backgr&),OB_H(tree%,ob_backgr&),x&,y&,w&,h&)
        y&=MAX(y&,dy&)
      ENDIF
      handle&=WIND_CREATE(kind&,x&,y&,w&,h&)
      IF handle&>0
        window_array&(index&,0)=handle&
        window_array&(index&,1)=type&
        window_array&(index&,2)=@first_gftext(tree%)
        IF window_array&(index&,2)>0
          window_array&(index&,3)=LEN(CHAR{{OB_SPEC(tree%,window_array&(index&,2))}})
        ELSE
          window_array&(index&,3)=0
        ENDIF
        window_array&(index&,4)=tree&
        window_array&(index&,5)=icon&
        window_array&(index&,6)=-1
        window_array&(index&,7)=kind&
        window_tree%(index&,0)=tree%
        window_tree%(index&,1)=ADD(system_pool%,MUL(index&,160))
        IF OB_TYPE(tree%,1)=28 AND kind&<>0
          OB_FLAGS(tree%,1)=BSET(OB_FLAGS(tree%,1),7)
          @win_set_title(index&,CHAR{OB_SPEC(tree%,1)})
        ELSE
          @win_set_title(index&,CHR$(0))
        ENDIF
        IF icon&<>-1
          tree%=@xrsrc_gaddr(0,icon&)
          window_tree%(index&,2)=tree%
        ELSE
          window_tree%(index&,2)=0
        ENDIF
        x&=@win_snap(x&)
        IF type&=1 AND tree&=fvt_prog&            !***progress snap to 4
          y&=MAX(MUL(DIV(ADD(y&,2),4),4),dy&)
          IF NOT snap_windows!
            x&=MUL(DIV(ADD(x&,2),4),4)
          ENDIF
        ENDIF
        ~WIND_OPEN(handle&,x&,y&,w&,h&)
        IF type&=1 OR type&=4
          @disable_menus(-1)
          IF top_modal&>-1
            window_array&(index&,6)=top_modal&
          ENDIF
          top_modal&=index&
        ENDIF
        RETURN handle&
      ELSE
        ~@alert_standard(1,2,"")
        RETURN 0
      ENDIF
    ELSE
      ~WIND_SET(@find_handle_from_tree(tree&),10,0,0,0,0)
      RETURN @find_handle_from_tree(tree&)
    ENDIF
  ELSE
    ~@alert_standard(1,2,"")
    RETURN 0
  ENDIF
ENDFUNC
> PROCEDURE win_close_dialog(tree&)                                       !call
  @win_close(@find_handle_from_tree(tree&))
RETURN
> FUNCTION win_get_index(handle&)                                         !call
  $F%
  LOCAL a&
  FOR a&=0 TO max_number_windows&
    IF handle&=window_array&(a&,0) AND window_array&(a&,4)<>0
      RETURN a&
    ENDIF
  NEXT a&
  RETURN -1
ENDFUNC
> PROCEDURE win_send_redraw(index&,x&,y&,w&,h&)                           !call
  IF x&=-1 AND y&=-1 AND w&=-1 AND h&=-1 AND window_array&(index&,0)<>0
    ~WIND_GET(window_array&(index&,0),4,x&,y&,w&,h&)
  ENDIF
  IF window_array&(index&,0)=0
    ~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
  ELSE
    @aes_internal_message(20,window_array&(index&,0),x&,y&,w&,h&)
  ENDIF
RETURN
> FUNCTION win_modal_enq                                                  !call
  $F%
  LOCAL a&
  FOR a&=0 TO max_number_windows&
    IF window_array&(a&,1)=1 OR window_array&(a&,1)=4
      RETURN TRUE
    ELSE IF window_array&(a&,1)=0 AND window_array&(a&,24)=0 AND window_array&(a&,0)>0
      RETURN TRUE
    ENDIF
  NEXT a&
  RETURN FALSE
ENDFUNC
> PROCEDURE call_st_guide(filename$,page$)                                !call
  LOCAL cmd$
  IF page$<>""
    cmd$="*:\"+filename$+" "+page$
  ELSE
    cmd$="*:\"+filename$
  ENDIF
  ~@program_start("ST-GUIDE","STGUIDE","",cmd$,cmd$,"","",0)
RETURN
> PROCEDURE v_clsvwk(handle&)                                             !call
  CONTRL(0)=101
  CONTRL(1)=0
  CONTRL(3)=0
  CONTRL(6)=handle&
  VDISYS 101,0,0
RETURN
> FUNCTION get_cookie(cookie$,VAR value%)                                 !call
  $F%
  LOCAL cookie%,cookie!,such%,found%,ret%
  CLR cookie!
  LET such%=CVL(cookie$)
  LET ret%=GEMDOS(340,8,L:such%,L:V:value%)
  IF ret%=-32
    cookie%=BIOS(5,&H5A0\4,L:-1)
    IF cookie%<>0
      DO
        LET found%={cookie%}
        EXIT IF found%=0
        IF found%=such%
          LET cookie!=TRUE
          LET value%={cookie%+4}
          EXIT IF TRUE
        ENDIF
        ADD cookie%,8
      LOOP
    ENDIF
  ELSE
    LET cookie!=(ret%<>-1)
  ENDIF
  RETURN cookie!
ENDFUNC
> FUNCTION alert_standard(default&,index&,insert$)                        !call
  $F%
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,fvt_alst&)
  RETURN FORM_ALERT(default&,@insert_in_string$(CHAR{OB_SPEC(tree%,index&)},insert$))
ENDFUNC
> PROCEDURE rsc_ob_draw(index&,object&)                                   !call
  LOCAL x&,y&,w&,h&,x1&,y1&,w1&,h1&,ob_only!
  LOCAL rx&,ry&,rw&,rh&
  LOCAL dx&,dy&,dw&,dh&
  LET ob_only!=(object&<0)
  LET object&=ABS(object&)
  IF window_array&(index&,21)<>-1 AND (NOT ob_only!)
    @win_send_redraw(index&,-1,-1,-1,-1)
  ELSE
    @rsc_ob_xywh(window_tree%(index&,0),object&,x&,y&,w&,h&)
    IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND @ob_state(window_array&(index&,4),object&,12)
      IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=30
        @rsc_ob_xywh(window_tree%(index&,0),MAX(SUB(object&,2),0),x&,y&,w&,h&)
      ENDIF
    ENDIF
    ~WIND_GET(window_array&(index&,0),4,x1&,y1&,w1&,h1&)
    IF RC_INTERSECT(x1&,y1&,w1&,h1&,x&,y&,w&,h&)
      IF window_array&(index&,1)>0 AND window_array&(index&,2)=object& AND (NOT ob_only!)
        @win_send_redraw(index&,x&,SUB(y&,5),w&,ADD(h&,10))
      ELSE
        @aes_screen_lock_only_screen
        ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
        ~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
        WHILE rw& OR rh&
          IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
            IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
              IF ob_only!
                ~OBJC_DRAW(window_tree%(index&,0),object&,7,rx&,ry&,rw&,rh&)
              ELSE
                ~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
              ENDIF
              CLIP rx&,ry&,rw&,rh& OFFSET 0,0
              @user_rsc_draw_extra(-1,index&,window_array&(index&,4),window_tree%(index&,0),rx&,ry&,rw&,rh&)
              CLIP OFF
            ENDIF
          ENDIF
          ~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
        WEND
        @aes_screen_unlock_only_screen
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION v_opnvwk                                                       !call
  $F%
  LOCAL d&
  CONTRL(0)=100
  CONTRL(1)=0
  CONTRL(3)=11
  CONTRL(6)=GRAF_HANDLE(d&,d&,d&,d&)
  INTIN(0)=1  ! (aktuelle Aufl”sung) XBIOS(4)+2
  FOR d&=1 TO 9
    INTIN(d&)=1
  NEXT d&
  INTIN(10)=2
  VDISYS 100,11,0
  RETURN CONTRL(6)
ENDFUNC
> PROCEDURE rsc_ob_xywh(tree%,object&,VAR x&,y&,w&,h&)                    !call
  LOCAL b&
  ~OBJC_OFFSET(tree%,object&,x&,y&)
  w&=OB_W(tree%,object&)
  h&=OB_H(tree%,object&)
  SELECT BYTE(OB_TYPE(tree%,object&))
  CASE 20,25,27
    b&=SUB(BYTE(SHR(OB_SPEC(tree%,object&),16)),256)
    IF b&<-100
      b&=0
    ENDIF
  CASE 22,30
    b&=WORD{ADD(OB_SPEC(tree%,object&),22)}
  CASE 26
    b&=-1
    IF BTST(OB_FLAGS(tree%,object&),0) AND BTST(OB_FLAGS(tree%,object&),2)
      DEC b&
    ENDIF
    IF BTST(OB_FLAGS(tree%,object&),0) AND BTST(OB_FLAGS(tree%,object&),1) AND BTST(OB_FLAGS(tree%,object&),2)
      DEC b&
    ENDIF
  ENDSELECT
  IF b&<0
    x&=ADD(x&,b&)
    y&=ADD(y&,b&)
    w&=ADD(w&,MUL(-b&,2))
    h&=ADD(h&,MUL(-b&,2))
  ENDIF
RETURN
> PROCEDURE aes_internal_message(m0&,m3&,m4&,m5&,m6&,m7&)                 !call
  @aes_send_message(ap_id&,m0&,m3&,m4&,m5&,m6&,m7&)
RETURN
> FUNCTION vq_extnd(handle&,mode&,parameter&)                             !call
  $F%
  CONTRL(0)=102
  CONTRL(1)=0
  CONTRL(2)=6
  CONTRL(3)=1
  CONTRL(4)=45
  CONTRL(6)=handle&
  INTIN(0)=mode&
  VDISYS
  IF parameter&<45
    RETURN INTOUT(parameter&)
  ELSE
    RETURN PTSOUT(parameter&-45)
  ENDIF
ENDFUNC
> FUNCTION vq_vgdos                                                       !call
  $F%
  LOCAL a%,ret&,vq_vgdos%
  vq_vgdos%=faceval_sys%+2844
  a%=C:vq_vgdos%()
  IF WORD(a%)=-2
    ret&=0
  ELSE IF MKL$(a%)="_FNT"
    ret&=2
  ELSE IF MKL$(a%)="_FSM"
    ret&=3
  ELSE
    ret&=1
  ENDIF
  RETURN ret&
ENDFUNC
> PROCEDURE mouse_wait                                                    !call
  LOCAL mb&,d&
  DO
    ~GRAF_MKSTATE(d&,d&,mb&,d&)
    ~EVNT_TIMER(50)
  LOOP UNTIL mb&=0
RETURN
> PROCEDURE mouse_wait_realtime
  LOCAL mb&,d&,evnt_flags&,time&
  DO
    LET evnt_flags&=&X100000
    LET time&=50
    event&=EVNT_MULTI(evnt_flags&,256+2,3,0,0,0,0,0,0,0,0,0,0,0,0,time&,d&,d&,d&,d&,d&,d&)
    ~GRAF_MKSTATE(d&,d&,mb&,d&)
  LOOP UNTIL mb&=0
RETURN
> FUNCTION rsc_find_menutitle(tree&,object&)                              !call
  $F%
  LOCAL a&,num_tit&,num&,tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF BYTE(OB_TYPE(tree%,object&))=28 AND object&>5
    FOR a&=3 TO object&
      IF BYTE(OB_TYPE(tree%,a&))=20
        INC num_tit&
      ENDIF
    NEXT a&
    IF num_tit&>0
      a&=0
      DO
        INC a&
        IF BYTE(OB_TYPE(tree%,a&))=32
          INC num&
          EXIT IF num&=num_tit&
        ENDIF
      LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
      RETURN a&
    ELSE
      RETURN 0
    ENDIF
  ELSE
    RETURN 0
  ENDIF
ENDFUNC
> FUNCTION vsf_color(handle&,color_index&)
  $F%
  INTIN(0)=color_index&
  CONTRL(0)=25
  CONTRL(1)=0
  CONTRL(3)=1
  CONTRL(6)=handle&
  VDISYS
  RETURN INTOUT(0)
ENDFUNC
> FUNCTION dialog_shortcuts(index&,shift!,ascii|)
  $F%
  LOCAL ob&,regob&
  LET ob&=@dialog_shortcuts_getob(index&,shift!,ascii|,regob&)
  IF ob&=>0
    @my_form_do2(0,index&,ob&,-1)
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
> FUNCTION dialog_shortcuts_getob(index&,shift!,ascii|,VAR regobject&)
  $F%
  LOCAL compare$,pre$,a&,tree%,pos&,adr%,obspec%
  tree%=window_tree%(index&,0)
  tree&=window_array&(index&,4)
  LET regobject&=-1
  a&=0
  IF OB_HEAD(tree%,0)<>-1
    DO
      INC a&
      IF BTST(OB_STATE(tree%,a&),3)=0 AND BTST(OB_FLAGS(tree%,a&),7)=0 AND (BTST(OB_FLAGS(tree%,a&),0) OR BTST(OB_FLAGS(tree%,a&),6))
        IF ascii|=13 AND BTST(OB_FLAGS(tree%,a&),1)
          RETURN a&
        ENDIF
        IF BYTE(OB_TYPE(tree%,a&))=24 AND (BYTE(SHR&(OB_TYPE(tree%,a&),8))=26 OR BYTE(SHR&(OB_TYPE(tree%,a&),8))=28)
          compare$=CHAR{{OB_SPEC(tree%,a&)+4}}
          pre$="["+UPPER$(CHR$(ascii|))
        ELSE IF BYTE(OB_TYPE(tree%,a&))=31 OR BYTE(OB_TYPE(tree%,a&))=33
          compare$=CHAR{{OB_SPEC(tree%,a&)+8}}
          IF shift!
            pre$=""+UPPER$(CHR$(ascii|))
          ELSE
            IF INSTR(compare$,"")
              compare$=""
            ENDIF
            pre$=""+UPPER$(CHR$(ascii|))
          ENDIF
        ELSE IF @ob_flags(tree&,a&,8)
          LET pos&=SHR(OB_STATE(tree%,a&),8) AND &H7F
          obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
          LET adr%=C:obspec%(L:tree%,a&)
          LET compare$=CHAR{adr%}
          IF pos&=>0 AND pos&<LEN(compare$)
            LET compare$=UPPER$(MID$(compare$,pos&+1,1))
            LET pre$=UPPER$(CHR$(ascii|))
          ELSE
            LET pre$="Nix"
            CLR compare$
          ENDIF
        ENDIF
        IF compare$<>""
          IF INSTR(UPPER$(compare$),pre$)
            RETURN a&
          ENDIF
        ENDIF
      ENDIF
    LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
  ENDIF
  RETURN -1
ENDFUNC
> FUNCTION help_object(tree&,tree%)
  $F%
  LOCAL a&
  a&=0
  DO
    INC a&
    IF @ob_flags(tree&,a&,15)
      RETURN TRUE
    ENDIF
  LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
  RETURN FALSE
ENDFUNC
> FUNCTION find_handle_from_tree(tree&)
  $F%
  LOCAL a&
  FOR a&=0 TO max_number_windows&
    IF window_array&(a&,1)>0
      IF tree&=window_array&(a&,4)
        RETURN window_array&(a&,0)
      ENDIF
    ENDIF
  NEXT a&
  RETURN -1
ENDFUNC
> FUNCTION first_gftext(tree%)
  $F%
  LOCAL obj&
  obj&=-1
  REPEAT
    INC obj&
    IF BTST(OB_FLAGS(tree%,obj&),3)
      IF NOT BTST(OB_FLAGS(tree%,obj&),7)
        IF NOT BTST(OB_STATE(tree%,obj&),3)
          RETURN obj&
        ENDIF
      ENDIF
    ENDIF
  UNTIL BTST(OB_FLAGS(tree%,obj&),5)
  RETURN 0
ENDFUNC
> FUNCTION find_free_w_array
  $F%
  LOCAL a&
  FOR a&=0 TO max_number_windows&
    IF window_array&(a&,0)=0 AND window_array&(a&,4)=0
      RETURN a&
    ENDIF
  NEXT a&
  RETURN -1
ENDFUNC
> FUNCTION insert_in_string$(a$,insert$)
  LOCAL parse&
  parse&=INSTR(a$,"@")
  IF parse&<>0
    a$=LEFT$(a$,parse&-1)+insert$+RIGHT$(a$,LEN(a$)-parse&)
  ELSE
    parse&=INSTR(a$,"~")
    IF parse&<>0
      a$=LEFT$(a$,parse&-1)+insert$+RIGHT$(a$,LEN(a$)-parse&)
    ENDIF
  ENDIF
  RETURN a$
ENDFUNC
> FUNCTION pointforward_object(index&,object&)
  $F%
  IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND @ob_flags(window_array&(index&,4),object&,12)
    IF NOT BTST(OB_FLAGS(window_tree%(index&,0),object&),5)
      RETURN TRUE
    ENDIF
  ENDIF
  RETURN FALSE
ENDFUNC
> PROCEDURE install_prg_def_main
  LOCAL wchar&,hchar&,color3d&,font_id&,font_h&,d&
  ~GRAF_HANDLE(wchar&,hchar&,d&,d&)
  {ADD(faceval_sys%,22)}=ADD(GB,24)
  INT{ADD(faceval_sys%,26)}=flydials_handle&
  INT{ADD(faceval_sys%,28)}=wchar&
  INT{ADD(faceval_sys%,30)}=hchar&
  IF INT{{ADD(GB,4)}}>=&H340
    GCONTRL(0)=48
    GCONTRL(1)=4
    GCONTRL(2)=3
    GCONTRL(3)=0
    GCONTRL(4)=0
    GINTIN(0)=0
    GINTIN(1)=5
    GEMSYS
    IF GINTOUT(0)>0
      color3d&=GINTOUT(1)
    ENDIF
  ENDIF
  IF @appl_xgetinfo(0,font_h&,font_id&,d&,d&)
    IF ABS(font_id&)<>1 AND @vq_vgdos<>0               ! Anderer AES-Font...
      V~H=flydials_handle&
      ~VST_LOAD_FONTS(0)                               ! ...Fonts laden
      DEFTEXT ,,,,font_id&
      DEFTEXT ,,,font_h&                               ! ...und einstellen
      V~H=-1
    ENDIF
  ENDIF
  INT{ADD(faceval_sys%,32)}=color3d&>0
  INT{ADD(faceval_sys%,34)}=color3d&
  @install_fv_obdata(0)
  @install_prg_def_objects(0)
RETURN
> PROCEDURE install_prg_def(tree%,ob&,nr&)
  LOCAL c&
  IF nr&=6 AND BYTE(OB_TYPE(tree%,ob&))<>28
    c&=SUCC(-BTST(OB_FLAGS(tree%,ob&),1)-BTST(OB_FLAGS(tree%,ob&),2)-BTST(OB_FLAGS(tree%,ob&),6))
    IF c&>1
      OB_X(tree%,ob&)=OB_X(tree%,ob&)-c&
      OB_Y(tree%,ob&)=OB_Y(tree%,ob&)-c&
      OB_W(tree%,ob&)=OB_W(tree%,ob&)+(c&*2)
      OB_H(tree%,ob&)=SUCC(OB_H(tree%,ob&)+(c&*2))
    ENDIF
  ENDIF
  {prgdef_adress%}=ADD(faceval_sys%,INT{ADD(faceval_sys%,SHL(PRED(nr&),1))})
  {ADD(prgdef_adress%,4)}=OB_SPEC(tree%,ob&)
  OB_SPEC(tree%,ob&)=prgdef_adress%
  OB_TYPE(tree%,ob&)=OR(SHL&(BYTE(OB_TYPE(tree%,ob&)),8),24)
  ADD prgdef_adress%,8
RETURN
> PROCEDURE install_prg_def_objects(add_tree&)
  LOCAL tree%,tree&,b&,d&,hchar&,wchar&,clear_flags!
  LOCAL g_swbutton!,g_popup!,whitebak!,g_shortcut!
  LOCAL gout1&,gout2&,gout3&,gout4&
  LOCAL ib_ytext&,ib_htext&
  ~GRAF_HANDLE(wchar&,hchar&,d&,d&)
  ~@appl_xgetinfo(13,gout1&,gout2&,gout3&,gout4&)
  LET g_swbutton!=BTST(gout4&,0)
  LET g_popup!=BTST(gout4&,1)
  LET whitebak!=BTST(gout4&,2)
  LET g_shortcut!=BTST(gout4&,3)
  FOR tree&=add_tree& TO ADD(last_tree&,add_tree&)
    tree%=@xrsrc_gaddr(0,tree&)
    b&=-1
    REPEAT
      INC b&
      @ob_flags(tree&,b&,8,FALSE)
      LET clear_flags!=TRUE
      IF BYTE(OB_TYPE(tree%,b&))=31 OR BYTE(OB_TYPE(tree%,b&))=33
        LET ib_ytext&=CARD{ADD(OB_SPEC(tree%,b&),28)}
        LET ib_htext&=CARD{ADD(OB_SPEC(tree%,b&),32)}
        OB_H(tree%,b&)=MAX(OB_H(tree%,b&),ADD(ib_ytext&,ib_htext&))
      ENDIF
      IF BYTE(OB_TYPE(tree%,b&))=23
      ELSE IF BYTE(OB_TYPE(tree%,b&))=31
      ELSE
        IF NOT @ob_state(tree&,b&,12)
          @update_prg_def_textob(TRUE,tree%,tree&,b&,whitebak!,clear_flags!)
          IF BYTE(SHR&(OB_TYPE(tree%,b&),8))=22
            IF BYTE(OB_TYPE(tree%,b&))=27
              @ob_flags(tree&,b&,9,TRUE)
              IF (hchar&=8 OR hchar&=16) AND wchar&=8
                @install_prg_def(tree%,b&,7)      !circlebutton
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF clear_flags!
        @clear_flags(tree%,b&)
      ENDIF
    UNTIL BTST(OB_FLAGS(tree%,b&),5)
  NEXT tree&
RETURN
> PROCEDURE update_prg_def_textob(install!,tree%,tree&,b&,whitebak!,VAR clear_flags!)
  IF BYTE(OB_TYPE(tree%,b&))=26 OR BYTE(OB_TYPE(tree%,b&))=28
    SELECT BYTE(SHR&(OB_TYPE(tree%,b&),8))
    CASE 18
      IF whitebak!
        IF (BTST(OB_FLAGS(tree%,b&),4) OR BTST(OB_FLAGS(tree%,b&),0)) AND (NOT BTST(OB_FLAGS(tree%,b&),2))  ! radio/check
          @install_magic_obj(tree&,tree%,b&,-2,TRUE)
          CLR clear_flags!
        ELSE IF BTST(OB_FLAGS(tree%,b&),2) OR BTST(OB_FLAGS(tree%,b&),6)                                    ! exit/touchexit
          @install_magic_obj(tree&,tree%,b&,-2,FALSE)
          CLR clear_flags!
        ENDIF
      ELSE
        IF BTST(OB_FLAGS(tree%,b&),2)
          IF install!
            @install_prg_def(tree%,b&,6)      !shortcut/exit
          ENDIF
          CLR clear_flags!
        ELSE IF BTST(OB_FLAGS(tree%,b&),4)
          IF install!
            @install_prg_def(tree%,b&,1)      !radiobutton/round
          ENDIF
          CLR clear_flags!
        ELSE IF BTST(OB_FLAGS(tree%,b&),0)
          IF install!
            @install_prg_def(tree%,b&,2)      !selectable/checkbox
          ENDIF
          CLR clear_flags!
        ELSE IF BTST(OB_FLAGS(tree%,b&),6)
          IF install!
            @install_prg_def(tree%,b&,6)      !shortcut/touchexit
          ENDIF
          CLR clear_flags!
        ENDIF
      ENDIF
    CASE 19
      IF whitebak!
        @install_magic_obj(tree&,tree%,b&,-1,FALSE)
      ELSE
        IF install!
          @install_prg_def(tree%,b&,4)        !underlined text
        ENDIF
      ENDIF
      CLR clear_flags!
    CASE 20
      IF whitebak!
        @install_magic_obj(tree&,tree%,b&,-3,FALSE)
      ELSE
        IF install!
          @install_prg_def(tree%,b&,3)        !frame
        ENDIF
      ENDIF
      CLR clear_flags!
    CASE 21
      IF install!
        @install_prg_def(tree%,b&,8)        !niceline
      ENDIF
      CLR clear_flags!
    ENDSELECT
  ENDIF
RETURN
> PROCEDURE install_magic_obj(tree&,tree%,ob&,underline&,mac!)
  LOCAL text$,obspec%,pos&,adr%,state|,whitebak!,wchar&,hchar&,a&
  ~GRAF_HANDLE(wchar&,hchar&,a&,a&)
  @clear_flags(tree%,ob&)
  LET whitebak!=TRUE
  IF underline&=-2
    obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
    LET adr%=C:obspec%(L:tree%,ob&)
    LET text$=CHAR{adr%}
    LET pos&=INSTR(text$,"[")
    IF pos&>0
      LET underline&=PRED(pos&)
      CHAR{adr%}=LEFT$(text$,PRED(pos&))+MID$(text$,SUCC(pos&))
    ENDIF
  ENDIF
  SELECT underline&
  CASE -3
    LET state|=BYTE(-2)
  CASE -1
    LET state|=255
    OB_TYPE(tree%,ob&)=(OB_TYPE(tree%,ob&) AND &HFF00) OR 28
  CASE 0 TO
    IF mac!
      LET state|=BYTE(BSET(underline& AND &H7F,7))
    ELSE
      LET state|=BYTE(underline& AND &H7F)
    ENDIF
    @ob_flags(tree&,ob&,8,TRUE)
  DEFAULT
    IF mac!
      LET state|=BYTE(-1)
    ELSE
      LET state|=0
      CLR whitebak!
    ENDIF
  ENDSELECT
  IF whitebak!
    OB_STATE(tree%,ob&)=BSET(OB_STATE(tree%,ob&) OR SHL(state|,8),6)
  ELSE
    OB_STATE(tree%,ob&)=BCLR(OB_STATE(tree%,ob&) OR SHL(state|,8),6)
  ENDIF
RETURN
> PROCEDURE clear_flags(tree%,b&)
  OB_STATE(tree%,b&)=OB_STATE(tree%,b&) AND &HFF
  OB_FLAGS(tree%,b&)=OB_FLAGS(tree%,b&) AND &HFFF
RETURN
> PROCEDURE install_fv_obdata(add_tree&)
  LOCAL tree%,tree&,b&
  DIM fv_obdata_new%(ADD(last_tree&,add_tree&))
  IF add_tree&=>0
    FOR tree&=0 TO PRED(add_tree&)
      LET fv_obdata_new%(tree&)=fv_obdata%(tree&)
    NEXT tree&
  ENDIF
  IF DIM?(fv_obdata%())>add_tree&
    LET fv_obdata$=LEFT$(fv_obdata$,fv_obdata%(add_tree&))
  ELSE IF add_tree&<=0
    CLR fv_obdata$
  ENDIF
  IF last_tree&=>0
    FOR tree&=add_tree& TO ADD(last_tree&,add_tree&)
      LET fv_obdata_new%(tree&)=LEN(fv_obdata$)
      tree%=@xrsrc_gaddr(0,SUB(tree&,add_tree&))
      b&=-1
      REPEAT
        INC b&
        LET fv_obdata$=fv_obdata$+MKI$(WORD(BYTE(SHR&(OB_STATE(tree%,b&),8)) OR (OB_FLAGS(tree%,b&) AND &HF000)))
      UNTIL BTST(OB_FLAGS(tree%,b&),5)
    NEXT tree&
  ENDIF
  SWAP fv_obdata_new%(),fv_obdata%()
  ERASE fv_obdata_new%()
RETURN
> FUNCTION ob_flags(tree&,ob&,flag&)
  $F%
  RETURN BTST(WORD{V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)},flag&)
ENDFUNC
> FUNCTION ob_state(tree&,ob&,flag&)
  $F%
  RETURN BTST(WORD{V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)},SUB(flag&,8))
ENDFUNC
> PROCEDURE ob_flags(tree&,ob&,flag&,value!)
  LOCAL adr%
  LET adr%=V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)
  IF value!
    WORD{adr%}=WORD(BSET(WORD{adr%},flag&))
  ELSE
    WORD{adr%}=WORD(BCLR(WORD{adr%},flag&))
  ENDIF
RETURN
> PROCEDURE ob_state(tree&,ob&,flag&,value!)
  LOCAL adr%
  LET adr%=V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)
  IF value!
    WORD{adr%}=WORD(BSET(WORD{adr%},SUB(flag&,8)))
  ELSE
    WORD{adr%}=WORD(BCLR(WORD{adr%},SUB(flag&,8)))
  ENDIF
RETURN
> FUNCTION menu_register(ap_id&,str_adr%)
  $F%
  GCONTRL(0)=35
  GCONTRL(1)=1
  GCONTRL(2)=1
  GCONTRL(3)=1
  GCONTRL(4)=1
  GINTIN(0)=ap_id&
  ADDRIN(0)=str_adr%
  GEMSYS
  RETURN GINTOUT(0)
ENDFUNC
> FUNCTION malloc_system_memory
  $F%
  LOCAL window_m%,prgdef_m%
  window_m%=MUL(ADD(max_number_windows&,1),160)
  prgdef_m%=MUL(num_prgdef_objects&,8)
  system_pool%=MALLOC(window_m%+prgdef_m%+256)
  IF system_pool%<>0
    prgdef_adress%=system_pool%+window_m%
    st_guide%=prgdef_adress%+prgdef_m%
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
> PROCEDURE my_form_do(mx&,my&,mc&,index&)
  LOCAL object&
  @win_place_tree(window_array&(index&,0))
  object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
  @my_form_do2(mc&,index&,object&,-1)
RETURN
> PROCEDURE pointback_object(tree&,VAR object&)
  DO WHILE object&>0
    object&=PRED(object&)
  LOOP UNTIL NOT @ob_flags(tree&,object&,13)
RETURN
> PROCEDURE keycalc(key&,VAR ascii|,scan|)
  '  $F%
  scan|=BYTE(SHR(key&,8))
  IF BYTE(key&)=0 AND scan|>=120 AND scan|<=129
    ascii|=BYTE{LONG{XBIOS(16,L:-1,L:-1,L:-1)}+SUB(scan|,118)}
  ELSE
    ascii|=BYTE{LONG{XBIOS(16,L:-1,L:-1,L:-1)}+scan|}
  ENDIF
RETURN
> FUNCTION keyascii(key&)
  $F%
  LOCAL asc|,scn|
  @keycalc(key&,asc|,scn|)
  RETURN asc|
ENDFUNC
> PROCEDURE handle_keypress(k_state&,key&)
  LOCAL scan|,handle&,d&,index&,ascii|,shc!
  ~WIND_GET(0,10,handle&,d&,d&,d&)
  index&=@win_get_index(handle&)
  @keycalc(key&,ascii|,scan|)
  IF index&<>-1
    IF window_array&(index&,21)=-1 AND window_array&(index&,23)=0
      IF window_array&(index&,4)>0
        IF scan|=98
          IF @help_object(window_array&(index&,4),window_tree%(index&,0))
            @user_rsc_context_help(window_array&(index&,4))
            shc!=TRUE
          ENDIF
        ENDIF
        IF BTST(window_array&(index&,2),5) AND window_array&(index&,1)=0
          shc!=@menu_shortcuts(window_tree%(index&,0),window_array&(index&,4),k_state&,ascii|,scan|)
        ELSE
          IF scan|=97 AND k_state&=0
            shc!=@closer_object(window_array&(index&,0))
          ENDIF
          IF (BTST(k_state&,3) OR ascii|=13) AND shc!=FALSE
            shc!=@dialog_shortcuts(index&,AND(k_state&,&X11),ascii|)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  IF NOT shc!
    IF NOT no_w_topping!
      shc!=@menu_shortcuts(menubar_adress%,current_menubar&,k_state&,ascii|,scan|)
    ENDIF
  ENDIF
  IF NOT shc!
    IF index&<>-1
      IF window_array&(index&,21)=-1 AND window_array&(index&,23)=0
        IF window_array&(index&,1)>0
          IF scan|=82 AND window_array&(index&,2)>0
            ~@win_open_dialog(4,fvt_asci&,-1)
          ENDIF
          IF (scan|=28 OR scan|=114) OR window_array&(index&,2)>0
            @fgtext_input(k_state&,key&,@win_get_index(handle&))
          ENDIF
        ELSE
          @user_keyb(handle&,window_array&(index&,8),index&,k_state&,key&)
        ENDIF
      ENDIF
    ELSE
      @user_keyb(handle&,0,index&,k_state&,key&)
    ENDIF
  ENDIF
RETURN
> PROCEDURE rsc_window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
  LOCAL d&,dy&,index&
  SELECT m0&
  CASE 20     !redraw
    @rsc_redraw(m3&,m4&,m5&,m6&,m7&)
  CASE 22     !closed
    index&=@win_get_index(m3&)
    IF window_array&(index&,1)=5
      exit_program!=TRUE
    ENDIF
    IF @closer_object(m3&)=FALSE
      @win_close(m3&)
    ENDIF
  CASE 28     !moved
    m4&=@win_snap(m4&)
    IF m3&=progress_handle&
      ~WIND_GET(0,4,d&,dy&,d&,d&)
      m5&=MAX(MUL(DIV(ADD(m5&,2),4),4),dy&)
      IF NOT snap_windows!
        m4&=MUL(DIV(ADD(m4&,2),4),4)
      ENDIF
    ENDIF
    ~WIND_SET(m3&,5,m4&,m5&,m6&,m7&)
    @win_place_tree(m3&)
  CASE 33     !bottomed
    index&=@win_get_index(m3&)
    IF window_array&(index&,1)<>1 AND window_array&(index&,1)<>4
      ~WIND_SET(m3&,25,0,0,0,0)
    ENDIF
  ENDSELECT
RETURN
> PROCEDURE setup_all_trees
  LOCAL a&
  FOR a&=0 TO last_tree&
    @rsc_setup_tree(a&)
  NEXT a&
RETURN
> PROCEDURE rsc_redraw(handle&,x&,y&,w&,h&)
  LOCAL rx&,ry&,rw&,rh&,top_handle&,d&,index&
  LOCAL dx&,dy&,dw&,dh&
  @aes_screen_lock_only_screen
  ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
  ~WIND_GET(0,10,top_handle&,d&,d&,d&)
  ~WIND_GET(handle&,11,rx&,ry&,rw&,rh&)
  index&=@win_get_index(handle&)
  @win_place_tree(handle&)
  IF top_handle&=handle&
    IF window_array&(index&,2)<>0
      ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
    ENDIF
  ENDIF
  WHILE rw& OR rh&
    IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
      IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
        IF window_array&(index&,21)<>-1
          INT{INT{faceval_sys%}+faceval_sys%-2}=1
          ~OBJC_DRAW(window_tree%(index&,2),0,7,rx&,ry&,rw&,rh&)
          INT{INT{faceval_sys%}+faceval_sys%-2}=0
        ELSE
          INT{INT{faceval_sys%}+faceval_sys%-2}=1
          ~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
          INT{INT{faceval_sys%}+faceval_sys%-2}=0
          CLIP rx&,ry&,rw&,rh& OFFSET 0,0
          @user_rsc_draw_extra(window_array&(index&,8),index&,window_array&(index&,4),window_tree%(index&,0),rx&,ry&,rw&,rh&)
          CLIP OFF
        ENDIF
      ENDIF
    ENDIF
    ~WIND_GET(handle&,12,rx&,ry&,rw&,rh&)
  WEND
  IF window_array&(index&,21)=-1
    IF top_handle&=handle&
      IF window_array&(index&,2)<>0
        @cursor_on(index&)
      ENDIF
    ENDIF
  ENDIF
  @aes_screen_unlock_only_screen
RETURN
> PROCEDURE main_loop
  LOCAL event&,mx&,my&,mb&,k_state&,key&,mc&,evnt_flags&
  LOCAL time&
  WHILE NOT (exit_program! OR forced_exit!)
    evnt_flags&=&X10011
    LET time&=-1
    event&=EVNT_MULTI(evnt_flags&,256+2,3,0,fvrc_evnt&(1),fvrc_evnt&(2),fvrc_evnt&(3),fvrc_evnt&(4),fvrc_evnt&(5),fvrc_evnt&(6),fvrc_evnt&(7),fvrc_evnt&(8),fvrc_evnt&(9),fvrc_evnt&(10),0,time&,mx&,my&,mb&,k_state&,key&,mc&)
    IF BTST(event&,0)
      @handle_keypress(k_state&,key&)
    ENDIF
    IF BTST(event&,1)
      @main_loop_mouse(mx&,my&,mb&,k_state&,key&,mc&)
    ENDIF
    IF BTST(event&,4)
      @main_message(mx&,my&,mc&,k_state&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
    ENDIF
    IF exit_program!
      exit_program!=@user_quit_ok
    ENDIF
  WEND
RETURN
> PROCEDURE main_loop_mouse(mx&,my&,mb&,k_state&,key&,mc&)
  LOCAL index&,handle&,d&,object&,winx&,winy&
  index&=@win_get_index(WIND_FIND(mx&,my&))
  IF index&<>-1
    ~WIND_GET(0,10,handle&,d&,d&,d&)
    IF handle&=window_array&(index&,0)
      SELECT window_array&(index&,1)
      CASE 0
        IF BTST(window_array&(index&,2),0)
          object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
          @win_place_tree(handle&)
        ENDIF
        IF BTST(window_array&(index&,2),1) OR BTST(window_array&(index&,2),2)
          IF mb&=1 AND object&>0
            @my_form_do(mx&,my&,mc&,index&)
          ELSE IF object&=0
            @user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
          ENDIF
        ELSE
          @user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
        ENDIF
      CASE 1,2,3
        IF mb&=1 AND mc&
          @my_form_do(mx&,my&,mc&,index&)
        ENDIF
      CASE 4
        IF mb&=1
          @win_ascii_click(handle&,mx&,my&)
        ENDIF
      ENDSELECT
    ELSE
      IF window_array&(index&,1)=0
        @user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
      ELSE
        @my_form_do(mx&,my&,mc&,index&)
      ENDIF
    ENDIF
  ENDIF
RETURN
> PROCEDURE main_message(mx&,my&,mc&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
  LOCAL ob&,flags&,state&,type&,user!,handle&,d&
  LOCAL pos&,index&
  LOCAL x&,y&,w&,h&
  SELECT m0&
  CASE 10
    @menu_selected(m3&,m4&)
  CASE 21     !topped
    IF no_w_topping!
      @fix_editcursor(window_array&(top_modal&,0))
      ~WIND_SET(window_array&(top_modal&,0),10,0,0,0,0)
    ELSE
      LET index&=@win_get_index(m3&)
      IF index&=>0
        IF window_array&(index&,1)=3
          ob&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
          IF ob&=-1
            @fix_editcursor(m3&)
            ~WIND_SET(m3&,10,0,0,0,0)
          ELSE
            ~WIND_GET(0,10,handle&,d&,d&,d&)
            IF @win_get_index(handle&)<>-1
              type&=BYTE(OB_TYPE(window_tree%(@win_get_index(m3&),0),ob&))
              flags&=OB_FLAGS(window_tree%(@win_get_index(m3&),0),ob&)
              IF (BTST(flags&,0) OR BTST(flags&,2) OR BTST(flags&,4) OR BTST(flags&,6)) AND NOT (@ob_state(window_array&(@win_get_index(m3&),4),ob&,12) AND BTST(flags&,6) AND type&=30)
                @my_form_do(mx&,my&,mc&,@win_get_index(m3&))
              ELSE
                @fix_editcursor(m3&)
                ~WIND_SET(m3&,10,0,0,0,0)
              ENDIF
            ELSE
              @fix_editcursor(m3&)
              ~WIND_SET(m3&,10,0,0,0,0)
            ENDIF
          ENDIF
        ELSE IF window_array&(@win_get_index(m3&),1)=0 AND window_array&(@win_get_index(m3&),24)=2
          IF BTST(window_array&(@win_get_index(m3&),2),0)
            ob&=OBJC_FIND(window_tree%(@win_get_index(m3&),0),0,7,mx&,my&)
          ELSE
            ob&=-1
          ENDIF
          IF ob&=-1
            @win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
            IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
              @user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
            ELSE
              ~WIND_SET(m3&,10,0,0,0,0)
            ENDIF
          ELSE
            IF @win_get_index(m3&)<>-1
              type&=BYTE(OB_TYPE(window_tree%(@win_get_index(m3&),0),ob&))
              flags&=OB_FLAGS(window_tree%(@win_get_index(m3&),0),ob&)
              IF (BTST(flags&,0) OR BTST(flags&,2) OR BTST(flags&,4) OR BTST(flags&,6)) AND NOT (@ob_state(window_array&(@win_get_index(m3&),4),ob&,12) AND BTST(flags&,6) AND type&=30)
                @my_form_do(mx&,my&,mc&,@win_get_index(m3&))
              ELSE
                IF BTST(window_array&(@win_get_index(m3&),2),5)
                  @win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
                  IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
                    @user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
                  ELSE
                    ~WIND_SET(m3&,10,0,0,0,0)
                  ENDIF
                ELSE
                  @win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
                  IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
                    @user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
                  ELSE
                    ~WIND_SET(m3&,10,0,0,0,0)
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ELSE
          @fix_editcursor(m3&)
          ~WIND_SET(m3&,10,0,0,0,0)
        ENDIF
      ENDIF
    ENDIF
  CASE 30,31
    LET index&=@win_get_index(m3&)
    IF index&=>0
      @fix_editcursor(m3&)
    ENDIF
  CASE 22360 !wm_shaded
    LET index&=@win_get_index(m3&)
    IF index&=>0
      window_array&(index&,23)=-1
    ENDIF
  CASE 22361 !wm_unshaded
    LET index&=@win_get_index(m3&)
    IF index&=>0
      window_array&(index&,23)=0
    ENDIF
  CASE 50
    forced_exit!=TRUE
  CASE 20,33,22 TO 28
    LET index&=@win_get_index(m3&)
    IF index&=>0
      IF window_array&(index&,1)>0
        @rsc_window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
      ELSE
        @window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
      ENDIF
    ENDIF
  CASE 53
    @handle_keypress(0,m3&)
  CASE &H4710
    @handle_keypress(m3&,m4&)
  CASE &H4709
    @main_loop_mouse(m3&,m4&,m5&,m6&,0,m7&)
  DEFAULT
    @user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
    user!=TRUE
  ENDSELECT
  IF gem_through&>0 AND user!=FALSE
    @user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
  ENDIF
RETURN
> PROCEDURE my_form_do2(mc&,index&,object&,regob&)
  LOCAL root&,a&,ob_spec%,sub&
  LOCAL mx&,my&,d&,cur_edit&,changed!
  LOCAL tree%,done!
  LET changed!=TRUE
  CLR done!
  IF object&>0
    IF window_array&(index&,0)>0
      IF BTST(OB_FLAGS(window_tree%(index&,0),object&),3)
        IF NOT @ob_state(window_array&(index&,4),object&,12)
          IF mc&=2 AND BTST(OB_FLAGS(window_tree%(index&,0),object&),0)
            @aes_screen_lock
            ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
            LET cur_edit&=window_array&(index&,2)
            LET window_array&(index&,2)=-1
            OB_STATE(window_tree%(index&,0),object&)=BSET(OB_STATE(window_tree%(index&,0),object&),0)
            @rsc_ob_draw(index&,object&)
            ~EVNT_TIMER(100)
            OB_STATE(window_tree%(index&,0),object&)=BCLR(OB_STATE(window_tree%(index&,0),object&),0)
            @rsc_ob_draw(index&,object&)
            LET window_array&(index&,2)=cur_edit&
            @cursor_on(index&)
            @aes_screen_unlock
            @user_rsc_interact(index&,window_array&(index&,4),object&,2,-1)
            LET done!=TRUE
          ELSE
            ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
            window_array&(index&,2)=object&
            ~GRAF_MKSTATE(mx&,my&,d&,d&)
            window_array&(index&,3)=@click_set_cursor(index&,mx&,my&,window_array&(index&,3))
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF NOT done!
      ob_spec%=OB_SPEC(window_tree%(index&,0),object&)
      IF NOT BTST(OB_FLAGS(window_tree%(index&,0),object&),7)
        IF NOT BTST(OB_STATE(window_tree%(index&,0),object&),3)
          IF @ob_flags(window_array&(index&,4),object&,13) AND BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
            @pointback_object(window_array&(index&,4),object&)
          ENDIF
          IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND NOT (BTST(OB_FLAGS(window_tree%(index&,0),object&),4) OR BTST(OB_FLAGS(window_tree%(index&,0),object&),0))
            IF @pointforward_object(index&,object&)
              ADD object&,1
              IF @pointforward_object(index&,object&)
                ADD object&,1
              ENDIF
            ENDIF
            IF sub&=0
              sub&=@popup_sub_formdo(index&,object&)
            ENDIF
            IF changed!
              @rsc_read_tree(window_array&(index&,4),object&)
              @user_rsc_interact(index&,window_array&(index&,4),object&,mc&,sub&)
            ENDIF
          ELSE
            IF BTST(OB_FLAGS(window_tree%(index&,0),object&),0)
              IF BTST(OB_FLAGS(window_tree%(index&,0),object&),2)      !exit
                ~@my_form_button(index&,object&,mc&)
                IF BTST(OB_STATE(window_tree%(index&,0),object&),0)
                  LET tree%=window_tree%(index&,0)
                  IF @ob_flags(window_array&(index&,4),object&,15)
                    @user_rsc_context_help(window_array&(index&,4))
                  ELSE
                    @user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
                  ENDIF
                  ~EVNT_TIMER(50)
                  OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),0)
                  IF window_tree%(index&,0)=tree% AND window_array&(index&,0)<>0
                    @rsc_ob_draw(index&,object&)
                  ENDIF
                ENDIF
              ELSE IF BTST(OB_FLAGS(window_tree%(index&,0),object&),4) !radiobutton
                IF BTST(OB_STATE(window_tree%(index&,0),object&),0)=FALSE
                  root&=object&
                  DO
                    root&=OB_NEXT(window_tree%(index&,0),root&)
                  LOOP UNTIL root&<object&
                  a&=OB_HEAD(window_tree%(index&,0),root&)
                  DO
                    IF BTST(OB_FLAGS(window_tree%(index&,0),a&),4) AND BTST(OB_STATE(window_tree%(index&,0),a&),0)
                      OB_STATE(window_tree%(index&,0),a&)=BCLR(OB_STATE(window_tree%(index&,0),a&),0)
                      @rsc_ob_draw(index&,a&)
                    ENDIF
                    a&=OB_NEXT(window_tree%(index&,0),a&)
                  LOOP UNTIL a&=root&
                  OB_STATE(window_tree%(index&,0),object&)=BSET(OB_STATE(window_tree%(index&,0),object&),0)
                  @rsc_ob_draw(index&,object&)
                ENDIF
                @rsc_read_tree(window_array&(index&,4),object&)
                @mouse_wait_realtime
                IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
                  @user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
                ENDIF
              ELSE                                                   !selectable
                IF @my_form_button(index&,object&,mc&)
                  @rsc_read_tree(window_array&(index&,4),object&)
                  IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
                    @user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
> PROCEDURE keypress(key&)                                                !call
  @aes_internal_message(53,key&,0,0,0,0)
RETURN
> FUNCTION my_form_button(index&,object&,mc&)
  $F%
  LOCAL to_select!,changed!
  LOCAL selected_state&,unselected_state&
  LOCAL current_state&,new_state&
  LOCAL mx&,my&,d&
  LOCAL current_ob&
  LOCAL evnt_flags&,time&
  @aes_screen_lock
  LET to_select!=NOT BTST(OB_STATE(window_tree%(index&,0),object&),0)
  LET selected_state&=BSET(OB_STATE(window_tree%(index&,0),object&),0)
  LET unselected_state&=BCLR(OB_STATE(window_tree%(index&,0),object&),0)
  REPEAT
    IF mc&=0
      LET changed!=TRUE
    ELSE
      ~GRAF_MKSTATE(mx&,my&,mc&,d&)
      LET current_ob&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
      IF current_ob&=>0
        IF @ob_flags(window_array&(index&,4),current_ob&,13) AND BTST(OB_FLAGS(window_tree%(index&,0),current_ob&),6)
          @pointback_object(window_array&(index&,4),current_ob&)
        ENDIF
      ENDIF
      LET changed!=(current_ob&=object&)
      LET evnt_flags&=&X100000
      LET time&=20
      event&=EVNT_MULTI(evnt_flags&,256+2,3,0,0,0,0,0,0,0,0,0,0,0,0,time&,d&,d&,d&,d&,d&,d&)
    ENDIF
    IF to_select! EQV changed!
      LET new_state&=selected_state&
    ELSE
      LET new_state&=unselected_state&
    ENDIF
    LET current_state&=OB_STATE(window_tree%(index&,0),object&)
    IF current_state&<>new_state&
      OB_STATE(window_tree%(index&,0),object&)=new_state&
      @rsc_ob_draw(index&,object&)
    ENDIF
  UNTIL mc&=0
  @mouse_wait_realtime
  @aes_screen_unlock
  RETURN changed!
ENDFUNC
> PROCEDURE aes_screen_lock                                               !call
  @aes_screen_lock_only_screen
  @aes_screen_lock_only_mouse
RETURN
> PROCEDURE aes_screen_unlock                                             !call
  @aes_screen_unlock_only_mouse
  @aes_screen_unlock_only_screen
RETURN
> PROCEDURE aes_screen_lock_only_screen                                   !call
  IF fv_aes_lock_num_os&=0
    ~WIND_UPDATE(1)
  ENDIF
  INC fv_aes_lock_num_os&
RETURN
> PROCEDURE aes_screen_unlock_only_screen                                 !call
  DEC fv_aes_lock_num_os&
  IF fv_aes_lock_num_os&=0
    ~WIND_UPDATE(0)
  ENDIF
RETURN
> PROCEDURE aes_screen_lock_only_mouse                                    !call
  IF fv_aes_lock_num_om&=0
    ~WIND_UPDATE(3)
  ENDIF
  INC fv_aes_lock_num_om&
RETURN
> PROCEDURE aes_screen_unlock_only_mouse                                  !call
  DEC fv_aes_lock_num_om&
  IF fv_aes_lock_num_om&=0
    ~WIND_UPDATE(2)
  ENDIF
RETURN
> PROCEDURE aes_send_message(id&,m0&,m3&,m4&,m5&,m6&,m7&)                 !call
  LOCAL message%
  INLINE message%,16
  WORD{message%}=m0&
  WORD{message%+2}=ap_id&
  WORD{message%+4}=0
  WORD{message%+6}=m3&
  WORD{message%+8}=m4&
  WORD{message%+10}=m5&
  WORD{message%+12}=m6&
  WORD{message%+14}=m7&
  ~APPL_WRITE(id&,16,message%)
RETURN
> FUNCTION appl_xgetinfo(gtype&,VAR gout1&,gout2&,gout3&,gout4&)          !call
  $F%
  LOCAL d&,ret%
  IF (INT{{ADD(GB,4)}}=&H399 AND magic_version&>=&H200) OR (INT{{ADD(GB,4)}}>=&H400) OR (APPL_FIND("?AGI")>=0) OR winx_version&>=&H210
    GCONTRL(0)=130
    GCONTRL(1)=1
    GCONTRL(2)=5
    GCONTRL(3)=0
    GCONTRL(4)=0
    GINTIN(0)=gtype&
    GEMSYS
    gout1&=GINTOUT(1)
    gout2&=GINTOUT(2)
    gout3&=GINTOUT(3)
    gout4&=GINTOUT(4)
    LET ret%=GINTOUT(0)
    IF ret%<>0
      RETURN ret%
    ENDIF
  ENDIF
  CLR gout1&
  CLR gout2&
  CLR gout3&
  CLR gout4&
  RETURN 0
ENDFUNC
> FUNCTION aes_send_message_by_name(app_name$,m0&,m3&,m4&,m5&,m6&,m7&)    !call
  $F%
  LOCAL id&
  LET app_name$=app_name$+SPACE$(MAX(0,SUB(8,LEN(app_name$))))
  LET id&=APPL_FIND(app_name$)
  IF id&<>-1
    @aes_send_message(id&,m0&,m3&,m4&,m5&,m6&,m7&)
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
> PROCEDURE do_all_redraws                                                !call
  DO
    EXIT IF NOT BTST(EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),4)
    IF MENU(1)=20 OR MENU(1)=28
      @main_message(0,0,0,0,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
    ELSE
      LET msg$=SPACE$(16)
      BMOVE MENU(-2),V:msg$,16
      LET all_msg$=all_msg$+msg$
    ENDIF
  LOOP
  WHILE LEN(all_msg$)>0
    ~APPL_WRITE(ap_id&,16,V:all_msg$)
    LET all_msg$=MID$(all_msg$,17)
  WEND
RETURN
> PROCEDURE start_up
  LOCAL x&,y&,w&,h&
  LOCAL gout1&,d&
  LOCAL magx_cookie%
  LOCAL fh&,file$,lof%,ret%
  LET mxmask%=@mxmask
  @user_inline_load
  INT{INT{faceval_sys%}+faceval_sys%-2}=0
  ap_id&=APPL_INIT()
  IF ap_id&=-1
    ~APPL_EXIT()
    END
  ENDIF
  magic_version&=0
  IF INT{ADD({ADD(GB,4)},2)}<>1 AND @get_cookie("MagX",magx_cookie%)
    magic_version&=INT{ADD({ADD(magx_cookie%,8)},48)}
  ENDIF
  winx_version&=0
  IF WIND_GET(0,1,d&,d&,d&,d&)=0
    IF WIND_GET(0,22360,winx_version&,d&,d&,d&)=22360
      winx_version&=OR(winx_version&,&HFFF)
    ENDIF
  ENDIF
  @program_init
  acc!=({ADD(BASEPAGE,36)}=0)
  return_value&=1
  @init
  DIM window_array%(max_number_windows&,3)
  ~@menu_register(-1,faceval_sys%+2892)         ! set name for appl_find
  IF acc!
    menu_id&=@menu_register(ap_id&,faceval_sys%+2854)
    DO
      ~EVNT_MESAG(0)
      IF MENU(1)=40
        ~FORM_ALERT(1,not_accessory$)
      ENDIF
    LOOP
  ENDIF
  program_path$=CHR$(65+GEMDOS(25))+":"+DIR$(GEMDOS(25)+1)+"\"
  multitasking!=WORD{{GB+4}+2}<>1
  IF @systemcheck
    IF @get_rsc<>0
      IF @malloc_system_memory
        flydials_handle&=@v_opnvwk
        IF flydials_handle&<>0
          return_value&=0
          ~@vsf_color(flydials_handle&,1)
          V~H=-1
          @install_prg_def_main
          @user_rsc_var_init
          IF multitasking! OR acc!
            LET menu_id&=@menu_register(ap_id&,faceval_sys%+2854)
          ENDIF
          ~@appl_xgetinfo(12,gout1&,d&,d&,d&)
          IF BTST(gout1&,3)
            ~SHEL_WRITE(9,1,0,"","")   ! support AP_TERM
          ENDIF
          IF current_menubar&=>0
            menubar_adress%=@xrsrc_gaddr(0,current_menubar&)
          ELSE
            CLR menubar_adress%
          ENDIF
          @setup_all_trees
          ~GRAF_MOUSE(0,0)
          @aes_screen_lock_only_screen
          IF menubar_adress%<>0
            @menu_snap(current_menubar&)
            ~MENU_BAR(menubar_adress%,1)
          ENDIF
          @aes_screen_unlock_only_screen
          IF NOT compiled!
            ~WIND_GET(0,4,x&,y&,w&,h&)
            ~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
          ENDIF
          @user_on_open
          @main_loop
          @win_close_all
          @aes_screen_lock_only_screen
          ~MENU_BAR(0,0)
          @aes_screen_unlock_only_screen
          @user_on_exit
          IF NOT acc!
            ~WIND_SET(0,14,0,0,0,0)
          ENDIF
          @v_clsvwk(flydials_handle&)
          V~H=-1
        ELSE
          ~@alert_standard(1,3,"")
        ENDIF
        ~MFREE(system_pool%)
      ELSE
        ~@alert_standard(1,1,"")
      ENDIF
      @cleanup_after_rsc
    ELSE
      ~FORM_ALERT(1,no_rsc_found$)
    ENDIF
  ENDIF
  ~APPL_EXIT()
  IF compiled!
    QUIT return_value&
  ELSE
    RESERVE
    EDIT
  ENDIF
RETURN
> FUNCTION mxalloc_global(amount%)                                        !call
  $F%
  IF mxmask%<>0
    RETURN GEMDOS(68,L:amount%,&X100011 AND mxmask%)
  ELSE
    RETURN MALLOC(amount%)
  ENDIF
ENDFUNC
> FUNCTION mxmask
  IF GEMDOS(68,L:-1,0)=-32
    RETURN 0
  ELSE IF GEMDOS(290,-1)=-32
    RETURN 3
  ELSE
    RETURN -1
  ENDIF
ENDFUNC
> PROCEDURE program_init
  LET program_va_init_!=FALSE
  LET program_va_bufadr_%=@mxalloc_global(256)
  IF program_va_bufadr_%<>0
    LET program_va_bufadr2_%=@mxalloc_global(256)
    IF program_va_bufadr2_%<>0
      LET program_va_init_!=TRUE
      LET program_va_bufsize_%=256
    ELSE
      ~MFREE(program_va_bufadr_%)
    ENDIF
  ENDIF
  LET program_avserver_$=@program_getenv$("AVSERVER")
RETURN
> FUNCTION program_va_start(app_name$,cmd$)
  $F%
  LOCAL m3&,m4&,return!,cmdsize%,newbuf%
  CLR return!
  IF program_va_init_!
    LET cmd$=@program_cml_build$(cmd$)
    LET cmdsize%=SUCC(LEN(cmd$))
    IF cmdsize%>program_va_bufsize_%
      LET newbuf%=@mxalloc_global(newsize%)
      IF newbuf%<>0
        ~MFREE(program_va_bufadr_%)
        LET program_va_bufadr_%=newbuf%
        LET program_va_bufsize_%=cmdsize%
      ENDIF
    ENDIF
    IF cmdsize%<=program_va_bufsize_%
      LET m3&=WORD(SHR(program_va_bufadr_%,16))
      LET m4&=WORD(program_va_bufadr_%)
      CHAR{program_va_bufadr_%}=cmd$
      LET return!=@aes_send_message_by_name(app_name$,&H4711,m3&,m4&,0,0,0)
    ENDIF
  ENDIF
  RETURN return!
ENDFUNC
> FUNCTION program_av_startprog(app_fname$,cmd$,userhandle&)
  $F%
  LOCAL m3&,m4&,m5&,m6&,m7&
  LOCAL return!,cmdsize%,newbuf%
  IF multitasking! OR acc!
    IF program_va_init_!
      IF program_avserver_$<>""
        IF LEN(app_fname$)<256
          LET cmd$=@program_cml_build$(cmd$)
          LET cmdsize%=SUCC(LEN(cmd$))
          IF cmdsize%>program_va_bufsize_%
            LET newbuf%=@mxalloc_global(newsize%)
            IF newbuf%<>0
              ~MFREE(program_va_bufadr_%)
              LET program_va_bufadr_%=newbuf%
              LET program_va_bufsize_%=cmdsize%
            ENDIF
          ENDIF
          IF cmdsize%<=program_va_bufsize_%
            LET m3&=WORD(SHR(program_va_bufadr2_%,16))
            LET m4&=WORD(program_va_bufadr2_%)
            LET m5&=WORD(SHR(program_va_bufadr_%,16))
            LET m6&=WORD(program_va_bufadr_%)
            LET m7&=userhandle&
            CHAR{program_va_bufadr2_%}=app_fname$
            CHAR{program_va_bufadr_%}=cmd$
            LET return!=@aes_send_message_by_name(program_avserver_$,&H4722,m3&,m4&,m5&,m6&,m7&)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  RETURN return!
ENDFUNC
> FUNCTION program_getenv$(envname$)                                      !call
  LOCAL adr%,value$,return$
  IF RIGHT$(envname$)<>"="
    LET envname$=envname$+"="
  ENDIF
  LET adr%={ADD(BASEPAGE,44)}
  DO
    LET value$=CHAR{adr%}
    EXIT IF LEFT$(value$,5)="ARGV=" OR value$="ARGV" OR value$=""
    ADD adr%,SUCC(LEN(value$))
    IF LEFT$(value$,LEN(envname$))=envname$
      LET return$=MID$(value$,SUCC(LEN(envname$)))
      EXIT IF TRUE
    ENDIF
  LOOP
  IF return$=""
    ~SHEL_ENVRN(adr%,envname$)
    IF adr%<>0
      LET return$=CHAR{adr%}
    ENDIF
  ENDIF
  RETURN return$
ENDFUNC
> FUNCTION program_start(app_name$,env_name$,app_fname$,single_cmd$,multi_cmd$,env$,def_path$,userhandle&)     !call
  LOCAL app_fname_env$
  LOCAL started!,ret%
  CLR started!
  LET ret%=-1
  IF userhandle&<>-1
    IF env$="" AND def_path$=""
      IF app_name$<>""
        LET started!=@program_va_start(app_name$,multi_cmd$)
      ENDIF
      IF NOT started!
        IF app_fname$<>""
          LET started!=@program_av_startprog(app_fname$,multi_cmd$,userhandle&)
        ENDIF
        IF NOT started!
          IF env_name$<>""
            LET app_fname_env$=@program_getenv$(env_name$)
            IF app_fname_env$<>""
              LET app_fname$=app_fname_env$
              LET started!=@program_av_startprog(app_fname$,multi_cmd$,userhandle&)
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  RETURN 0
ENDFUNC
> FUNCTION program_cml_build$(cml$)
  LOCAL pos&,par$,newcml$
  LET pos&=INSTR(cml$,CHR$(0))
  IF pos&=0
    LET newcml$=cml$
  ELSE
    CLR newcml$
    WHILE pos&>0
      LET par$=LEFT$(cml$,PRED(pos&))
      LET cml$=MID$(cml$,SUCC(pos&))
      IF LEN(par$)=0
        LET par$="' '"
      ELSE IF INSTR(par$," ")>0
        LET pos&=LEN(par$)
        WHILE pos&>0
          IF MID$(par$,pos&,1)="'"
            LET par$=LEFT$(par$,pos&)+MID$(par$,pos&)
          ENDIF
          DEC pos&
        WEND
        LET par$="'"+par$+"'"
      ENDIF
      IF par$<>""
        IF LEN(newcml$)>0
          LET newcml$=newcml$+" "+par$
        ELSE
          LET newcml$=par$
        ENDIF
      ENDIF
      LET pos&=INSTR(cml$,CHR$(0))
    WEND
  ENDIF
  RETURN newcml$
ENDFUNC
> FUNCTION program_cml_unbuild$(cml$)
  LOCAL newcml$,pos&,len&,space!,quote!,char$,par!
  IF INSTR(cml$,CHR$(0))=0
    LET pos&=1
    LET len&=LEN(cml$)
    LET space!=TRUE
    LET par!=FALSE
    WHILE pos&<=len&
      LET char$=MID$(cml$,pos&,1)
      SELECT char$
      CASE " "
        IF quote!
          LET newcml$=newcml$+" "
        ELSE
          IF NOT space!
            LET newcml$=newcml$+CHR$(0)
          ENDIF
          LET space!=TRUE
        ENDIF
      CASE "'"
        IF quote!
          IF MID$(cml$,pos&,2)="''"
            LET newcml$=newcml$+"'"
            INC pos&
          ELSE
            LET quote!=FALSE
            LET space!=TRUE
            LET newcml$=newcml$+CHR$(0)
          ENDIF
        ELSE
          IF space!
            IF MID$(cml$,pos&,3)="' '"
              LET newcml$=newcml$+CHR$(0)
              ADD pos&,2
            ELSE
              LET quote!=TRUE
              CLR space!
            ENDIF
          ELSE
            LET newcml$=newcml$+"'"
          ENDIF
        ENDIF
      DEFAULT
        LET newcml$=newcml$+char$
        LET space!=FALSE
      ENDSELECT
      INC pos&
    WEND
    IF NOT space!
      LET newcml$=newcml$+CHR$(0)
    ENDIF
    RETURN newcml$
  ELSE
    RETURN cml$
  ENDIF
ENDFUNC
> PROCEDURE system_error      !This proc. can be deleted before compiling  !-CMP
  LOCAL d&
  ALERT 1,"Error: "+STR$(ERR)+" |"+MID$(ERR$(ERR),3,INSTR(ERR$(ERR),"Return")-3),1,"  OK  ",d&
  @system_restore
RETURN
> PROCEDURE system_restore    !This proc. can be deleted before compiling  !-CMP
  IF fv_aes_lock_num_om&>0
    ~WIND_UPDATE(2)
  ENDIF
  IF fv_aes_lock_num_os&>0
    ~WIND_UPDATE(0)
  ENDIF
  IF fv_malloced%>0
    ~MFREE(fv_malloced%)
  ENDIF
  @win_close_all
  ~WIND_UPDATE(1)
  ~MENU_BAR(0,0)
  ~WIND_UPDATE(0)
  @user_on_exit
  ~WIND_SET(0,14,0,0,0,0)
  @v_clsvwk(flydials_handle&)
  ~MFREE(system_pool%)
  @cleanup_after_rsc
  IF INT{{ADD(GB,4)}}>=&H320  !AES>3.20
    GCONTRL(0)=109            !wind_new()
    GCONTRL(1)=0
    GCONTRL(2)=0
    GCONTRL(3)=0
    GCONTRL(4)=0
    GEMSYS
  ENDIF
  CLOSE
  ~APPL_EXIT()
  RESERVE
  EDIT
RETURN
> PROCEDURE disable_menus(disable!)
  LOCAL d&
  IF menubar_adress%<>0
    IF disable!<>menu_disabled!
      IF NOT acc!
        IF current_menutitle&<>-1
          ~MENU_TNORMAL(menubar_adress%,current_menutitle&,1)
          current_menutitle&=-1
        ENDIF
        d&=3
        DO
          INC d&
          IF OB_TYPE(menubar_adress%,d&)=32
            IF disable!
              OB_STATE(menubar_adress%,d&)=BSET(OB_STATE(menubar_adress%,d&),3)
            ELSE
              OB_STATE(menubar_adress%,d&)=BCLR(OB_STATE(menubar_adress%,d&),3)
            ENDIF
          ENDIF
        LOOP UNTIL BTST(OB_FLAGS(menubar_adress%,d&),5)
        d&=0
        DO
          IF OB_TYPE(menubar_adress%,d&)=28
            IF disable!
              OB_STATE(menubar_adress%,d&)=BSET(OB_STATE(menubar_adress%,d&),3)
            ELSE
              OB_STATE(menubar_adress%,d&)=BCLR(OB_STATE(menubar_adress%,d&),3)
            ENDIF
            EXIT IF TRUE
          ENDIF
          INC d&
        LOOP UNTIL BTST(OB_FLAGS(menubar_adress%,d&),5)
        @aes_screen_lock_only_screen
        ~MENU_BAR(menubar_adress%,1)
        @aes_screen_unlock_only_screen
      ENDIF
      menu_disabled!=disable!
      no_w_topping!=disable!
    ENDIF
  ENDIF
RETURN
> PROCEDURE menu_snap(tree&)
  LOCAL menu%,box&,menu_desktop&
  LET menu%=@xrsrc_gaddr(0,tree&)
  LET menu_desktop&=OB_TAIL(menu%,0)
  LET box&=OB_HEAD(menu%,menu_desktop&)
  WHILE box&<>menu_desktop& AND box&>0
    OB_X(menu%,box&)=MAX(0,MIN(OB_X(menu%,box&),SUB(OB_W(menu%,menu_desktop&),OB_W(menu%,box&))))
    LET box&=OB_NEXT(menu%,box&)
  WEND
RETURN
> FUNCTION menu_shortcuts(tree%,tree&,k_state&,ascii|,scan|)
  $F%
  LOCAL a&,about!,compare$,shortcut$
  IF AND(k_state&,&X11)
    shortcut$=""
  ENDIF
  IF BTST(k_state&,2)
    shortcut$=shortcut$+"^"
  ENDIF
  IF BTST(k_state&,3)
    shortcut$=shortcut$+""
  ENDIF
  SELECT scan|
  CASE 99 TO 113,74,78
    shortcut$=shortcut$+"["+UPPER$(CHR$(ascii|))+"]"
  CASE 1
    shortcut$=shortcut$+"Esc"
  CASE 14
    shortcut$=shortcut$+"BS"
  CASE 15
    shortcut$=shortcut$+"Tab"
  CASE 59 TO 68
    shortcut$=shortcut$+"F"+STR$(scan|-58)
  CASE 84 TO 93
    shortcut$=shortcut$+"F"+STR$(scan|-73)
    IF LEFT$(shortcut$)=""
      shortcut$=RIGHT$(shortcut$,LEN(shortcut$)-1)
    ENDIF
  CASE 98
    shortcut$=shortcut$+"Help"
  CASE 82
    shortcut$=shortcut$+"Insert"
  CASE 71,119
    shortcut$=shortcut$+"Home"
  CASE 97
    shortcut$=shortcut$+"Undo"
  CASE 57
    shortcut$=shortcut$+"Space"
  DEFAULT
    IF ascii|>32
      IF ascii|=127
        shortcut$=shortcut$+"Del"
      ELSE
        shortcut$=shortcut$+UPPER$(CHR$(ascii|))
      ENDIF
    ENDIF
  ENDSELECT
  about!=FALSE
  a&=2
  DO
    INC a&
    IF OB_TYPE(tree%,a&)=28
      IF BTST(OB_STATE(tree%,a&),3)=0
        compare$=TRIM$(CHAR{OB_SPEC(tree%,a&)})
        IF RINSTR(compare$," ")
          compare$=RIGHT$(compare$,LEN(compare$)-RINSTR(compare$," "))
          IF compare$=shortcut$
            IF BTST(OB_STATE(tree%,@rsc_find_menutitle(tree&,a&)),3)=0
              @user_rsc_interact(-1,tree&,a&,1,0)
              RETURN TRUE
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF NOT about!
        about!=TRUE
        DO
          INC a&
        LOOP UNTIL OB_TYPE(tree%,a&)=20
      ENDIF
    ENDIF
  LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
  RETURN FALSE
ENDFUNC
> PROCEDURE menu_selected(title&,menu_item&)
  LOCAL temp&
  temp&=current_menubar&
  current_menutitle&=title&
  @user_rsc_interact(-1,current_menubar&,menu_item&,1,0)
  IF temp&=current_menubar& AND current_menutitle&=title&
    ~MENU_TNORMAL(menubar_adress%,title&,1)
  ENDIF
  current_menutitle&=-1
RETURN
> FUNCTION win_open(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,user_handle&,x&,y&,w&,h&,icon&) !call
  $F%
  RETURN @win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,0,0,user_handle&,x&,y&,w&,h&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open_scrollpos(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&) !call
  $F%
  RETURN @win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&,ic!)
  $F%
  LOCAL handle&,index&,dx&,dy&,dw&,dh&,tree%,d&,xoff&,wchar&,kind&,usrtype&
  LOCAL mtype&
  index&=@find_free_w_array
  IF index&<>-1
    IF icon&=-1
      kind%=BCLR(kind%,30)
    ENDIF
    IF BTST(kind%,13)      !program modal
      mtype&=0
    ELSE IF BTST(kind%,14) !toolbox type
      mtype&=2
    ELSE                   !non modal
      mtype&=1
    ENDIF
    kind%=BCLR(kind%,13)
    kind%=BCLR(kind%,14)
    kind&=WORD{V:kind%}
    usrtype&=WORD{V:kind%+2}
    ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
    handle&=WIND_CREATE(kind&,dx&,dy&,dw&,dh&)
    IF handle&>0
      window_array&(index&,0)=handle&
      window_array&(index&,1)=0
      window_array&(index&,2)=usrtype&
      window_array&(index&,3)=kind&
      window_array&(index&,4)=tree&
      window_array&(index&,5)=icon&
      window_array%(index&,0)=totw%
      window_array%(index&,1)=toth%
      window_array&(index&,8)=user_handle&
      window_array&(index&,9)=MAX(1,scrlstep_x&)
      window_array&(index&,10)=MAX(1,scrlstep_y&)
      window_array&(index&,25)=-1
      LET window_array%(index&,2)=offx%
      LET window_array%(index&,3)=offy%
      window_array&(index&,12)=0
      window_array&(index&,13)=0
      IF BTST(window_array&(index&,2),0)
        tree%=@xrsrc_gaddr(0,tree&)
        window_tree%(index&,0)=tree%
        IF BTST(window_array&(index&,2),1)        !horisontal toolstrip
          window_array&(index&,13)=OB_H(tree%,1)+1
        ELSE IF BTST(window_array&(index&,2),2)   !vertical toolstrip
          window_array&(index&,12)=OB_W(tree%,1)+1
        ELSE IF BTST(window_array&(index&,2),5)   !menu
          window_array&(index&,13)=OB_H(tree%,2)
          OB_X(tree%,0)=0
          OB_Y(tree%,0)=0
          ~OBJC_OFFSET(tree%,4,xoff&,d&)
          ~GRAF_HANDLE(wchar&,d&,d&,d&)
          window_array&(index&,15)=SUB(xoff&,wchar&)
          d&=3
          DO
            INC d&
          LOOP UNTIL OB_TYPE(tree%,d&)=25
          window_array&(index&,16)=d&
        ENDIF
      ENDIF
      window_tree%(index&,1)=ADD(system_pool%,MUL(index&,160))
      IF icon&<>-1
        tree%=@xrsrc_gaddr(0,icon&)
        window_tree%(index&,2)=tree%
      ELSE
        window_tree%(index&,2)=0
      ENDIF
      @win_set_title(index&,tit$)
      @win_set_infoline(index&,inf$)
      x&=MIN(MAX(dx&,x&),dx&+dw&-dy&)
      y&=MIN(MAX(dy&,y&),dy&+dh&-dy&)
      IF w&<0
        LET w&=dw&
      ENDIF
      IF h&<0
        LET h&=dh&
      ENDIF
      @win_align(index&,x&)
      ~RC_INTERSECT(dx&,dy&,dw&,dh&,x&,y&,w&,h&)
      IF BTST(usrtype&,3) OR BTST(usrtype&,7) OR NOT BTST(kind&,5)
        @win_limit_size(index&,w&,h&)
      ENDIF
      ~WIND_OPEN(handle&,x&,y&,w&,h&)
      @win_set_sliders(index&)
      window_array&(index&,24)=mtype&
      IF mtype&=0
        @disable_menus(-1)
        IF top_modal&>-1
          window_array&(index&,25)=top_modal&
        ENDIF
        top_modal&=index&
      ENDIF
      RETURN handle&
    ELSE
      ~@alert_standard(1,2,"")
      RETURN 0
    ENDIF
  ELSE
    ~@alert_standard(1,2,"")
    RETURN 0
  ENDIF
ENDFUNC
> PROCEDURE win_calc_wh(kind%,tree&,icon&,ww&,wh&,VAR w&,h&)              !call
  LOCAL kind&,tree%,usrtype&,off_x&,off_y&,x&,y&
  IF icon&=-1
    LET kind%=BCLR(kind%,30)
  ENDIF
  LET kind%=BCLR(kind%,13)
  LET kind%=BCLR(kind%,14)
  LET kind&=WORD{V:kind%}
  LET off_x&=0
  LET off_y&=0
  LET usrtype&=WORD{V:kind%+2}
  IF BTST(usrtype&,0)
    LET tree%=@xrsrc_gaddr(0,tree&)
    IF BTST(usrtype&,1)
      LET off_y&=OB_H(tree%,1)+1
    ELSE IF BTST(usrtype&,2)
      LET off_x&=OB_W(tree%,1)+1
    ELSE IF BTST(usrtype&,5)
      LET off_y&=OB_H(tree%,2)
    ENDIF
  ENDIF
  ~WIND_CALC(0,kind&,0,0,ADD(ww&,off_y&),ADD(wh&,off_y&),x&,y&,w&,h&)
RETURN
> PROCEDURE win_get_workarea(index&,VAR x&,y&,w&,h&)                      !call
  ~WIND_GET(window_array&(index&,0),4,x&,y&,w&,h&)
  ADD y&,window_array&(index&,13)
  SUB h&,window_array&(index&,13)
  ADD x&,window_array&(index&,12)
  SUB w&,window_array&(index&,12)
RETURN
> PROCEDURE win_set_infoline(index&,info$)                                !call
  LOCAL adr%
  IF window_array&(index&,1)=0
    IF BTST(window_array&(index&,3),4)
      IF LEN(info$)>78
        info$=LEFT$(info$,78)
      ENDIF
      info$=info$+CHR$(0)
      adr%=window_tree%(index&,1)+80
      BMOVE V:info$,adr%,LEN(info$)
      ~WIND_SET(window_array&(index&,0),3,CARD(SWAP(adr%)),CARD(adr%),0,0)
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_set_sliders(index&)
  LOCAL d&,w&,h&
  IF window_array&(index&,1)=0
    @win_get_workarea(index&,d&,d&,w&,h&)
    IF BTST(window_array&(index&,3),11)
      @win_set_hslider(index&,w&)
    ENDIF
    IF BTST(window_array&(index&,3),8)
      @win_set_vslider(index&,h&)
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_set_vslider(index&,hh%)
  LOCAL size&
  IF BTST(window_array&(index&,3),8)
    IF window_array%(index&,1)>hh%
      LET size&=ROUND(hh%*1000/window_array%(index&,1))
      IF size&<=0
        LET size&=-1
      ELSE
        size&=MIN(size&,1000)
      ENDIF
      ~WIND_SET(window_array&(index&,0),16,size&,0,0,0)
      ~WIND_SET(window_array&(index&,0),9,ROUND(window_array%(index&,3)*1000/SUB(window_array%(index&,1),hh%)),0,0,0)
    ELSE
      LET size&=1000
      ~WIND_SET(window_array&(index&,0),16,size&,0,0,0)
      ~WIND_SET(window_array&(index&,0),9,0,0,0,0)
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_set_hslider(index&,ww%)
  LOCAL size&
  IF BTST(window_array&(index&,3),11)
    IF window_array%(index&,0)>ww%
      ~WIND_SET(window_array&(index&,0),8,ROUND(window_array%(index&,2)*1000/SUB(window_array%(index&,0),ww%)),0,0,0)
      LET size&=ROUND(ww%*1000/window_array%(index&,0))
      IF size&<=0
        LET size&=-1
      ELSE
        size&=MIN(size&,1000)
      ENDIF
    ELSE
      ~WIND_SET(window_array&(index&,0),8,0,0,0,0)
      LET size&=1000
    ENDIF
    ~WIND_SET(window_array&(index&,0),15,size&,0,0,0)
  ENDIF
RETURN
> PROCEDURE win_limit_size(index&,VAR w&,h&)
  LOCAL d&,maxw&,maxh&,dw&,dh&
  IF BTST(window_array&(index&,2),3)
    ~WIND_GET(0,4,d&,d&,dw&,dh&)
    ~WIND_CALC(0,window_array&(index&,3),0,0,MIN(dw&,window_array%(index&,0)+window_array&(index&,12)),MIN(dh&,window_array%(index&,1)+window_array&(index&,13)),d&,d&,maxw&,maxh&)
    w&=MIN(w&,maxw&)
    h&=MIN(h&,maxh&)
  ENDIF
  IF BTST(window_array&(index&,2),7)
    IF window_array&(index&,9)>0
      ~WIND_CALC(1,window_array&(index&,3),0,0,w&,h&,d&,d&,maxw&,maxh&)
      maxw&=MUL(DIV(SUB(maxw&,window_array&(index&,12)),window_array&(index&,9)),window_array&(index&,9))
      maxh&=MUL(DIV(SUB(maxh&,window_array&(index&,13)),window_array&(index&,10)),window_array&(index&,10))
      ~WIND_CALC(0,window_array&(index&,3),0,0,ADD(maxw&,window_array&(index&,12)),ADD(maxh&,window_array&(index&,13)),d&,d&,w&,h&)
    ENDIF
  ENDIF
RETURN
> FUNCTION win_limit_scroll(offset%,step&,limit!)
  $F%
  IF limit!
    RETURN MUL(DIV(ADD(offset%,PRED(step&)),step&),step&)
  ELSE
    RETURN offset%
  ENDIF
ENDFUNC
> PROCEDURE win_align(index&,VAR x&)
  LOCAL xx&,d&
  IF window_array&(index&,21)=-1
    IF BTST(window_array&(index&,2),10)! window work area byte aligned
      ~WIND_CALC(1,window_array&(index&,3),x&,0,100,100,xx&,d&,d&,d&)
      xx&=PRED(MUL(DIV(ADD(ADD(xx&,window_array&(index&,12)),4),8),8))
      IF x&<0
        ADD xx&,1
      ELSE
        IF xx&<0
          ADD xx&,8
        ENDIF
      ENDIF
      ~WIND_CALC(0,window_array&(index&,3),SUB(xx&,window_array&(index&,12)),0,100,100,x&,d&,d&,d&)
    ELSE IF BTST(window_array&(index&,2),11)! window work area word aligned
      ~WIND_CALC(1,window_array&(index&,3),x&,0,100,100,xx&,d&,d&,d&)
      xx&=PRED(MUL(DIV(ADD(ADD(xx&,window_array&(index&,12)),8),16),16))
      IF x&<0
        ADD xx&,1
      ELSE
        IF xx&<0
          ADD xx&,16
        ENDIF
      ENDIF
      ~WIND_CALC(0,window_array&(index&,3),SUB(xx&,window_array&(index&,12)),0,100,100,x&,d&,d&,d&)
    ELSE
      x&=@win_snap(x&)
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_resize(index&,x&,y&,w&,h&)                                !call
  LOCAL wx&,wy&,ww&,wh&
  LOCAL off_x%,off_y%
  IF window_array&(index&,21)=-1
    ~WIND_GET(window_array&(index&,0),5,wx&,wy&,ww&,wh&)
    IF x&<>-1
      LET wx&=x&
    ENDIF
    IF y&<>-1
      LET wy&=y&
    ENDIF
    IF w&<>-1
      LET ww&=w&
    ENDIF
    IF h&<>-1
      LET wh&=h&
    ENDIF
    @win_align(index&,wx&)
    @win_limit_size(index&,ww&,wh&)
    ~WIND_CALC(1,window_array&(index&,3),wx&,wy&,ww&,wh&,x&,y&,w&,h&)
    ADD x&,window_array&(index&,12)
    ADD y&,window_array&(index&,13)
    SUB w&,window_array&(index&,12)
    SUB h&,window_array&(index&,13)
    LET off_x%=MAX(0,MIN(window_array%(index&,2),SUB(window_array%(index&,0),w&)))
    LET off_y%=MAX(0,MIN(window_array%(index&,3),SUB(window_array%(index&,1),h&)))
    @win_set_offset(index&,off_x%,off_y%)
    ~WIND_SET(window_array&(index&,0),5,wx&,wy&,ww&,wh&)
    @win_set_sliders(index&)
    IF BTST(window_array&(index&,2),0)
      @win_place_tree(window_array&(index&,0))
    ENDIF
    IF BTST(window_array&(index&,2),4)
      @win_get_workarea(index&,x&,y&,w&,h&)
      @win_send_redraw(index&,x&,y&,w&,h&)
    ENDIF
  ELSE
    ~WIND_SET(window_array&(index&,0),5,x&,y&,w&,h&)
  ENDIF
RETURN
> PROCEDURE redraw_userwindow(handle&,x&,y&,w&,h&)
  LOCAL rx&,ry&,rw&,rh&,wx&,wy&,ww&,wh&,index&
  LOCAL dx&,dy&,dw&,dh&
  index&=@win_get_index(handle&)
  @aes_screen_lock_only_screen
  ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
  ~WIND_GET(handle&,4,wx&,wy&,ww&,wh&)
  IF BTST(window_array&(index&,2),0)
    @win_place_tree(handle&)
    IF BTST(window_array&(index&,2),5)
      OB_W(window_tree%(index&,0),0)=ww&+window_array&(index&,15)
      OB_W(window_tree%(index&,0),1)=ww&+window_array&(index&,15)
      OB_W(window_tree%(index&,0),window_array&(index&,16))=ww&+window_array&(index&,15)
      IF BTST(window_array&(index&,2),9)
        OB_H(window_tree%(index&,0),window_array&(index&,16))=wh&-window_array&(index&,13)
      ELSE
        OB_H(window_tree%(index&,0),window_array&(index&,16))=1
      ENDIF
    ELSE
      OB_W(window_tree%(index&,0),0)=ww&
      OB_H(window_tree%(index&,0),0)=wh&
    ENDIF
    IF BTST(window_array&(index&,2),1)
      OB_W(window_tree%(index&,0),1)=ww&
    ELSE IF BTST(window_array&(index&,2),2)
      OB_H(window_tree%(index&,0),1)=wh&
    ENDIF
  ENDIF
  ~WIND_GET(handle&,11,rx&,ry&,rw&,rh&)
  WHILE rw& OR rh&
    IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
      IF window_array&(index&,21)<>-1
        ~OBJC_DRAW(window_tree%(index&,2),0,7,rx&,ry&,rw&,rh&)
      ELSE
        IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
          @win_userwin_redraw_rect(index&,rx&,ry&,rw&,rh&)
        ENDIF
      ENDIF
    ENDIF
    ~WIND_GET(handle&,12,rx&,ry&,rw&,rh&)
  WEND
  @aes_screen_unlock_only_screen
RETURN
> PROCEDURE window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
  LOCAL index&,x&,y&,d&,w&,h&,offx%,offy%
  LOCAL xstep&,ystep&
  SELECT m0&
  CASE 20
    @redraw_userwindow(m3&,m4&,m5&,m6&,m7&)
  CASE 22
    index&=@win_get_index(m3&)
    IF @user_win_close_ok(index&,window_array&(index&,8))
      @win_close(m3&)
    ENDIF
  CASE 24
    index&=@win_get_index(m3&)
    @win_get_workarea(index&,d&,d&,w&,h&)
    IF BTST(window_array&(index&,2),6)
      LET xstep&=window_array&(index&,9)
      LET ystep&=window_array&(index&,10)
    ELSE
      LET xstep&=MAX(1,w&\16)
      LET ystep&=MAX(1,h&\16)
    ENDIF
    SELECT m4&
    CASE 0
      @win_set_offset(index&,-1,SUB(window_array%(index&,3),SUB(h&,ystep&)))
    CASE 1
      @win_set_offset(index&,-1,ADD(window_array%(index&,3),SUB(h&,ystep&)))
    CASE 2
      @win_set_offset(index&,-1,SUB(window_array%(index&,3),ystep&))
    CASE 3
      @win_set_offset(index&,-1,ADD(window_array%(index&,3),ystep&))
    CASE 4
      @win_set_offset(index&,SUB(window_array%(index&,2),SUB(w&,xstep&)),-1)
    CASE 5
      @win_set_offset(index&,ADD(window_array%(index&,2),SUB(w&,xstep&)),-1)
    CASE 6
      @win_set_offset(index&,SUB(window_array%(index&,2),xstep&),-1)
    CASE 7
      @win_set_offset(index&,ADD(window_array%(index&,2),xstep&),-1)
    ENDSELECT
  CASE 25
    index&=@win_get_index(m3&)
    ~WIND_GET(m3&,4,x&,y&,w&,h&)
    SUB w&,window_array&(index&,12)
    IF w&<window_array%(index&,0)
      offx%=ROUND(SUB(window_array%(index&,0),w&)*m4&/1000)
    ELSE
      offx%=0
    ENDIF
    IF offx%<>window_array%(index&,2)
      @win_set_offset(index&,offx%,-1)
    ENDIF
  CASE 26
    index&=@win_get_index(m3&)
    ~WIND_GET(m3&,4,x&,y&,w&,h&)
    SUB h&,window_array&(index&,13)
    IF h&<window_array%(index&,1)
      offy%=ROUND(SUB(window_array%(index&,1),h&)*m4&/1000)
    ELSE
      offy%=0
    ENDIF
    IF offy%<>window_array%(index&,3)
      @win_set_offset(index&,-1,offy%)
    ENDIF
  CASE 23
    index&=@win_get_index(m3&)
    ~WIND_GET(0,4,x&,y&,w&,h&)
    d&=x&
    @win_align(index&,x&)
    IF x&>d&
      SUB w&,SUB(x&,d&)
    ENDIF
    @win_limit_size(index&,w&,h&)
    ~WIND_GET(m3&,5,m4&,m5&,m6&,m7&)
    IF x&=m4& AND y&=m5& AND w&=m6& AND h&=m7&
      ~WIND_GET(m3&,6,m4&,m5&,m6&,m7&)
      @win_align(index&,m4&)
      @win_limit_size(index&,m6&,m7&)
      @win_resize(index&,m4&,m5&,m6&,m7&)
    ELSE
      @win_resize(index&,x&,y&,w&,h&)
    ENDIF
  CASE 27
    index&=@win_get_index(m3&)
    @win_limit_size(index&,m6&,m7&)
    @win_resize(index&,m4&,m5&,m6&,m7&)
  CASE 28
    index&=@win_get_index(m3&)
    @win_align(index&,m4&)
    @win_resize(index&,m4&,m5&,m6&,m7&)
  CASE 33
    index&=@win_get_index(m3&)
    IF window_array&(index&,24)>0
      ~WIND_SET(m3&,25,0,0,0,0)
    ENDIF
  ENDSELECT
RETURN
> PROCEDURE win_set_offset(index&,off_x%,off_y%)                          !call
  LOCAL rx&,ry&,rw&,rh&
  LOCAL wx&,wy&,ww&,wh&
  LOCAL off_x_alt%,off_y_alt%
  LOCAL add_x%,add_y%
  LOCAL dx&,dy&,dw&,dh&
  @win_get_workarea(index&,wx&,wy&,ww&,wh&)
  LET off_x_alt%=window_array%(index&,2)
  LET off_y_alt%=window_array%(index&,3)
  IF off_x%=-1
    LET off_x%=off_x_alt%
  ELSE
    IF off_x%=-2
      LET off_x%=MAX(0,SUB(window_array%(index&,0),ww&))
    ELSE
      LET off_x%=MAX(0,MIN(off_x%,SUB(window_array%(index&,0),ww&)))
    ENDIF
    LET off_x%=MAX(0,MIN(off_x%,SUB(window_array%(index&,0),ww&)))
    LET off_x%=@win_limit_scroll(off_x%,window_array&(index&,9),BTST(window_array&(index&,2),6))
  ENDIF
  IF off_y%=-1
    LET off_y%=off_y_alt%
  ELSE
    IF off_y%=-2
      LET off_y%=MAX(0,SUB(window_array%(index&,1),wh&))
    ELSE
      LET off_y%=MAX(0,MIN(off_y%,SUB(window_array%(index&,1),wh&)))
    ENDIF
    LET off_y%=@win_limit_scroll(off_y%,window_array&(index&,10),BTST(window_array&(index&,2),6))
  ENDIF
  LET add_x%=SUB(off_x%,off_x_alt%)
  LET add_y%=SUB(off_y%,off_y_alt%)
  IF add_x%<>0 OR add_y%<>0
    @aes_screen_lock_only_screen
    IF BTST(window_array&(index&,2),8)
      @do_all_redraws
    ENDIF
    LET window_array%(index&,2)=off_x%
    LET window_array%(index&,3)=off_y%
    CLIP OFF
    ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
    ~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
    WHILE rw&<>0 OR rh&<>0
      IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
        IF RC_INTERSECT(wx&,wy&,ww&,wh&,rx&,ry&,rw&,rh&)
          IF BTST(window_array&(index&,2),8)
            @win_move_rect(index&,rx&,ry&,rw&,rh&,add_x%,add_y%)
          ELSE
            @win_userwin_redraw_rect(index&,rx&,ry&,rw&,rh&)
          ENDIF
        ENDIF
      ENDIF
      ~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
    WEND
    @aes_screen_unlock_only_screen
    @win_set_sliders(index&)
  ENDIF
RETURN
> PROCEDURE win_userwin_redraw_rect(index&,x&,y&,w&,h&)
  LOCAL wx&,wy&,ww&,wh&
  IF w&>0 AND h&>0
    IF BTST(window_array&(index&,2),0)
      IF BTST(window_array&(index&,2),5)
        ~OBJC_DRAW(window_tree%(index&,0),1,7,x&,y&,w&,h&)
        OB_TYPE(window_tree%(index&,0),window_array&(index&,16))=20
        OB_SPEC(window_tree%(index&,0),window_array&(index&,16))=&HFF1101
        ~OBJC_DRAW(window_tree%(index&,0),window_array&(index&,16),0,x&,y&,w&,h&)
        OB_TYPE(window_tree%(index&,0),window_array&(index&,16))=25
        OB_SPEC(window_tree%(index&,0),window_array&(index&,16))=0
      ELSE IF BTST(window_array&(index&,2),1) OR BTST(window_array&(index&,2),2)
        IF BTST(window_array&(index&,2),9)
          ~OBJC_DRAW(window_tree%(index&,0),0,7,x&,y&,w&,h&)
        ELSE
          ~OBJC_DRAW(window_tree%(index&,0),1,7,x&,y&,w&,h&)
        ENDIF
      ELSE IF BTST(window_array&(index&,2),9)
        ~OBJC_DRAW(window_tree%(index&,0),0,7,x&,y&,w&,h&)
      ENDIF
    ENDIF
    CLIP x&,y&,w&,h& OFFSET 0,0
    @user_rsc_draw_extra(window_array&(index&,8),index&,window_array&(index&,4),window_tree%(index&,0),x&,y&,w&,h&)
    CLIP OFF
    ~WIND_GET(window_array&(index&,0),4,wx&,wy&,ww&,wh&)
    ADD wx&,window_array&(index&,12)
    ADD wy&,window_array&(index&,13)
    SUB ww&,window_array&(index&,12)
    SUB wh&,window_array&(index&,13)
    IF RC_INTERSECT(wx&,wy&,ww&,wh&,x&,y&,w&,h&)
      CLIP x&,y&,w&,h& OFFSET wx&,wy&
      @user_window_content(index&,window_array&(index&,8),window_array%(index&,2),window_array%(index&,3),x&,y&,w&,h&)
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_move_content(index&,sx%,sy%,dx%,dy%,w%,h%)                !call
  LOCAL rx&,ry&,rw&,rh&
  LOCAL wx&,wy&,ww&,wh&
  LOCAL wx%,wy%,ww%,wh%
  LOCAL add_x%,add_y%
  LOCAL dx&,dy&,dw&,dh&
  LET add_x%=SUB(sx%,dx%)
  LET add_y%=SUB(sy%,dy%)
  IF add_x%<>0 OR add_y%<>0
    @win_get_workarea(index&,wx&,wy&,ww&,wh&)
    LET wx%=SUB(ADD(MIN(sx%,dx%),wx&),window_array%(index&,2))
    LET wy%=SUB(ADD(MIN(sy%,dy%),wy&),window_array%(index&,3))
    LET ww%=ADD(w%,ABS(add_x%))
    LET wh%=ADD(h%,ABS(add_y%))
    IF RC_INTERSECT(wx%,wy%,ww%,wh%,wx&,wy&,ww&,wh&)
      @aes_screen_lock_only_screen
      @do_all_redraws
      CLIP OFF
      ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
      ~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
      WHILE rw&<>0 OR rh&<>0
        IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
          IF RC_INTERSECT(wx&,wy&,ww&,wh&,rx&,ry&,rw&,rh&)
            @win_move_rect(index&,rx&,ry&,rw&,rh&,add_x%,add_y%)
          ENDIF
        ENDIF
        ~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
      WEND
      @aes_screen_unlock_only_screen
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_move_rect(index&,x&,y&,w&,h&,add_x%,add_y%)
  LOCAL sx&,sy&,sw&,sh&
  LOCAL dx%,dy%,dw%,dh%
  LOCAL r1x&,r1y&,r1w&,r1h&
  LOCAL r2x&,r2y&,r2w&,r2h&
  LET dx%=SUB(x&,add_x%)
  LET dy%=SUB(y&,add_y%)
  LET dw%=w&
  LET dh%=h&
  IF RC_INTERSECT(x&,y&,w&,h&,dx%,dy%,dw%,dh%) AND BTST(window_array&(index&,2),8)
    LET sw&=WORD(dw%)
    LET sh&=WORD(dh%)
    IF add_x%>0
      LET sx&=ADD(x&,add_x%)
      LET r1x&=ADD(x&,sw&)
      LET r1y&=y&
      LET r1w&=add_x%
      LET r1h&=h&
      LET r2x&=x&
      LET r2w&=sw&
    ELSE
      LET sx&=x&
      LET r1x&=x&
      LET r1y&=y&
      LET r1w&=SUB(0,add_x%)
      LET r1h&=h&
      LET r2x&=SUB(x&,add_x%)
      LET r2w&=sw&
    ENDIF
    IF add_y%>0
      LET sy&=ADD(y&,add_y%)
      LET r2y&=ADD(y&,sh&)
      LET r2h&=add_y%
    ELSE
      LET sy&=y&
      LET r2y&=y&
      LET r2h&=SUB(0,add_y%)
    ENDIF
    @vdi_bitblt(0,0,0,0,0,0,0,0,0,0,sx&,sy&,sw&,sh&,dx%,dy%,1)
    @win_userwin_redraw_rect(index&,r1x&,r1y&,r1w&,r1h&)
    @win_userwin_redraw_rect(index&,r2x&,r2y&,r2w&,r2h&)
  ELSE
    @win_userwin_redraw_rect(index&,x&,y&,w&,h&)
  ENDIF
RETURN
> PROCEDURE vdi_bitblt(sadr%,sw&,sh&,sf&,sbp&,dadr%,dw&,dh&,df&,dbp&,x&,y&,w&,h&,dx&,dy&,mod&) !call
  LOCAL go%
  IF sadr%=0
    x&=MAX(x&,0)
    y&=MAX(y&,0)
    w&=MIN(w&,SUCC(SUB(WORK_OUT(0),x&)))
    h&=MIN(h&,SUCC(SUB(WORK_OUT(1),y&)))
  ELSE IF dadr%=0
    dx&=MAX(dx&,0)
    dy&=MAX(dy&,0)
    w&=MIN(w&,SUCC(SUB(WORK_OUT(0),dx&)))
    h&=MIN(h&,SUCC(SUB(WORK_OUT(1),dy&)))
  ENDIF
  go%=ADD(faceval_sys%,INT{ADD(faceval_sys%,16)})
  IF w&>0 AND h&>0
    IF sadr%=0 OR dadr%=0
      ~GRAF_MOUSE(256,0)
    ENDIF
    ~C:go%(L:sadr%,sw&,sh&,sf&,sbp&,L:dadr%,dw&,dh&,df&,dbp&,x&,y&,w&,h&,dx&,dy&,mod&)
    IF sadr%=0 OR dadr%=0
      ~GRAF_MOUSE(257,0)
    ENDIF
  ENDIF
RETURN
> PROCEDURE mouse_busy(object&)                                           !call
  LOCAL tree%,next&
  tree%=@xrsrc_gaddr(0,fvt_maus&)
  IF object&>1 AND BYTE(OB_TYPE(tree%,object&))=25
    next&=SUCC(BYTE(SHR&(OB_TYPE(tree%,object&),8)))
    IF OB_NEXT(tree%,ADD(next&,object&))=object&
      OB_TYPE(tree%,object&)=BYTE(OB_TYPE(tree%,object&))
    ELSE
      OB_TYPE(tree%,object&)=OR(SHL&(next&,8),BYTE(OB_TYPE(tree%,object&)))
    ENDIF
    @mouse_form(ADD(next&,object&))
  ENDIF
RETURN
> PROCEDURE aes_clear_buffers                                             !call
  WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
  WEND
  WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
  WEND
RETURN
> PROCEDURE mouse_form(object&)                                           !call
  LOCAL tree%
  IF object&=-1
    ~GRAF_MOUSE(0,0)
  ELSE
    tree%=@xrsrc_gaddr(0,fvt_maus&)
    IF object&>1 AND BYTE(OB_TYPE(tree%,object&))=31
      WORD{{OB_SPEC(tree%,1)}}=BYTE(SHR&(OB_TYPE(tree%,object&),12))
      WORD{ADD({OB_SPEC(tree%,1)},2)}=AND(BYTE(SHR&(OB_TYPE(tree%,object&),8)),&X1111)
      WORD{ADD({OB_SPEC(tree%,1)},4)}=1
      WORD{ADD({OB_SPEC(tree%,1)},6)}=AND(BYTE(SHR&(WORD{ADD(OB_SPEC(tree%,object&),12)},8)),&X1111)
      WORD{ADD({OB_SPEC(tree%,1)},8)}=BYTE(SHR&(WORD{ADD(OB_SPEC(tree%,object&),12)},12))
      BMOVE LONG{OB_SPEC(tree%,object&)},ADD(LONG{OB_SPEC(tree%,1)},10),32
      BMOVE LONG{ADD(OB_SPEC(tree%,object&),4)},ADD(LONG{OB_SPEC(tree%,1)},42),32
      ~GRAF_MOUSE(255,LONG{OB_SPEC(tree%,1)})
    ENDIF
  ENDIF
RETURN
> PROCEDURE progress_open(title$,break!)                                  !call
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,fvt_prog&)
  @rsc_set_text(fvt_prog&,5,title$)
  CHAR{{OB_SPEC(tree%,3)}}="0"
  CHAR{{ADD(4,OB_SPEC(tree%,3))}}="_%"
  OB_STATE(tree%,4)=BCLR(OB_STATE(tree%,4),0)
  OB_X(tree%,3)=0
  @size_busy_progress_dialog(tree%,break!)
  progress_handle&=@win_open_dialog(1,fvt_prog&,-1)
  IF progress_handle&=0
    @aes_screen_lock
    ~GRAF_MOUSE(2,0)
    LET progress_busymouse!=TRUE
  ENDIF
RETURN
> FUNCTION progress_update(value&)                                        !call
  $F%
  '  $F%
  LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,ret!,x&,x2&,y&,index&
  ret!=FALSE
  IF progress_handle&
    index&=@win_get_index(progress_handle&)
    IF index&<>-1
      IF value&<>VAL(CHAR{{OB_SPEC(window_tree%(index&,0),3)}})
        ~OBJC_OFFSET(window_tree%(index&,0),3,x&,y&)
        OB_X(window_tree%(index&,0),3)=INT(((OB_W(window_tree%(index&,0),2)-OB_W(window_tree%(index&,0),3))*value&)/100)
        CHAR{{OB_SPEC(window_tree%(index&,0),3)}}=STR$(value&)
        CHAR{{ADD(OB_SPEC(window_tree%(index&,0),3),4)}}=STRING$(LEN(STR$(value&)),"_")+"%"
        ~OBJC_OFFSET(window_tree%(index&,0),3,x2&,y&)
        busy_progress_redraw(window_tree%(index&,0),index&)
      ENDIF
    ENDIF
    DO
      event&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
      IF BTST(event&,0)
        ret!=@busy_progress_exited_keyb(key&,ks&)
      ENDIF
      IF BTST(event&,1) AND mb&=1
        ret!=@busy_progress_exited_mouse(mx&,my&,mc&)
      ENDIF
      IF BTST(event&,4)
        @main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    LOOP UNTIL BTST(event&,5)
  ENDIF
  RETURN ret!
ENDFUNC
> PROCEDURE progress_close                                                !call
  IF progress_handle&
    @win_close(progress_handle&)
    progress_handle&=0
  ELSE IF progress_busymouse!
    ~GRAF_MOUSE(0,0)
    WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
    WEND
    WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
    WEND
    @aes_screen_unlock
    CLR progress_busymouse!
  ENDIF
RETURN
> PROCEDURE busy_progress_redraw(tree%,index&)
  LOCAL x1&,y1&,w1&,h1&   ! slider background (left)
  LOCAL x2&,y2&,w2&,h2&   ! slider itself
  LOCAL lx&,ly&,lw&,lh&   ! redrawarea (left)
  LOCAL mx&,my&,mw&,mh&   ! redrawarea (slider)
  LOCAL handle&,tree%
  LOCAL dx&,dy&,dw&,dh&
  IF index&<>-1
    @aes_screen_lock_only_screen
    ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
    handle&=window_array&(index&,0)
    @rsc_ob_xywh(window_tree%(index&,0),2,x1&,y1&,w1&,h1&)
    @rsc_ob_xywh(window_tree%(index&,0),3,x2&,y2&,w2&,h2&)
    LET w1&=SUB(x2&,x1&)
    ~WIND_GET(handle&,11,mx&,my&,mw&,mh&)
    WHILE mw& OR mh&
      IF RC_INTERSECT(dx&,dy&,dw&,dh&,mx&,my&,mw&,mh&)
        LET lx&=mx&
        LET ly&=my&
        LET lw&=mw&
        LET lh&=mh&
        IF RC_INTERSECT(x2&,y2&,w2&,h2&,mx&,my&,mw&,mh&)
          ~OBJC_DRAW(window_tree%(index&,0),3,1,mx&,my&,mw&,mh&)
        ENDIF
        IF RC_INTERSECT(x1&,y1&,w1&,h1&,lx&,ly&,lw&,lh&)
          ~OBJC_DRAW(window_tree%(index&,0),2,1,lx&,ly&,lw&,lh&)
        ENDIF
      ENDIF
      ~WIND_GET(handle&,12,mx&,my&,mw&,mh&)
    WEND
    @aes_screen_unlock_only_screen
  ENDIF
RETURN
> PROCEDURE size_busy_progress_dialog(tree%,break!)
  LOCAL wchar&,hchar&,a&
  LOCAL button&
  ~GRAF_HANDLE(wchar&,hchar&,a&,a&)
  LET button&=4
  IF break!
    OB_FLAGS(tree%,button&)=BCLR(OB_FLAGS(tree%,button&),7)
    OB_STATE(tree%,button&)=BCLR(OB_STATE(tree%,button&),3)
    OB_H(tree%,0)=ADD(ADD(OB_Y(tree%,button&),OB_H(tree%,button&)),hchar&)
  ELSE
    OB_FLAGS(tree%,button&)=BSET(OB_FLAGS(tree%,button&),7)
    OB_STATE(tree%,button&)=BSET(OB_STATE(tree%,button&),3)
    OB_H(tree%,0)=OB_Y(tree%,button&)
  ENDIF
RETURN
> FUNCTION busy_progress_exited_mouse(mx&,my&,mc&)
  $F%
  '  $F%
  LOCAL handle&,d&,index&,object&
  IF WIND_FIND(mx&,my&)=progress_handle&
    ~WIND_GET(0,10,handle&,d&,d&,d&)
    IF handle&=progress_handle&
      index&=@win_get_index(handle&)
      IF index&<>-1
        @win_place_tree(window_array&(index&,0))
        object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
        IF object&=4
          IF @my_form_button(index&,object&,mc&)
            RETURN TRUE
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  RETURN FALSE
ENDFUNC
> FUNCTION busy_progress_exited_keyb(key&,ks&)
  $F%
  '  $F%
  LOCAL handle&,d&,index&
  ~WIND_GET(0,10,handle&,d&,d&,d&)
  IF handle&=progress_handle&
    index&=@win_get_index(handle&)
    IF index&<>-1
      IF NOT BTST(OB_FLAGS(window_tree%(index&,0),4),7)
        IF NOT BTST(OB_STATE(window_tree%(index&,0),4),3)
          IF BYTE(SHR(key&,8))=97 AND BTST(OB_FLAGS(window_tree%(index&,0),4),14)
            OB_STATE(window_tree%(index&,0),4)=BSET(OB_STATE(window_tree%(index&,0),4),0)
            @rsc_ob_draw(index&,4)
            RETURN TRUE
          ENDIF
          IF BTST(ks&,3)
            IF BYTE(OB_TYPE(window_tree%(index&,0),4))=24 AND (BYTE(SHR&(OB_TYPE(window_tree%(index&,0),4),8))=26 OR BYTE(SHR&(OB_TYPE(window_tree%(index&,0),4),8))=28)
              IF @dialog_shortcuts_getob(index&,FALSE,@keyascii(key&),d&)
                OB_STATE(window_tree%(index&,0),4)=BSET(OB_STATE(window_tree%(index&,0),4),0)
                @rsc_ob_draw(index&,4)
                RETURN TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  RETURN FALSE
ENDFUNC
> FUNCTION busy_open(break!)                                              !call
  $F%
  LOCAL tree%,index&,time&
  tree%=@xrsrc_gaddr(0,fvt_work&)
  animation_timer%=TIMER
  OB_STATE(tree%,4)=BCLR(OB_STATE(tree%,4),0)
  @size_busy_progress_dialog(tree%,break!)
  progress_handle&=@win_open_dialog(1,fvt_work&,-1)
  IF progress_handle&
  ELSE
    @aes_screen_lock
    ~GRAF_MOUSE(2,0)
    LET progress_busymouse!=TRUE
  ENDIF
  RETURN FALSE
ENDFUNC
> PROCEDURE busy_close                                                    !call
  IF progress_handle&
    @win_close(progress_handle&)
    progress_handle&=0
  ELSE IF progress_busymouse!
    ~GRAF_MOUSE(0,0)
    WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
    WEND
    WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
    WEND
    @aes_screen_unlock
    CLR progress_busymouse!
  ENDIF
RETURN
> FUNCTION busy_update(time&)                                             !call
  $F%
  LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,ret!,index&
  ret!=FALSE
  IF progress_handle&
    DO
      event&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
      IF BTST(event&,0)
        ret!=@busy_progress_exited_keyb(key&,ks&)
      ENDIF
      IF BTST(event&,1)
        ret!=@busy_progress_exited_mouse(mx&,my&,mc&)
      ENDIF
      IF BTST(event&,4)
        @main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
      ENDIF
    LOOP UNTIL BTST(event&,5)
  ENDIF
  RETURN ret!
ENDFUNC
> FUNCTION animate_icon(index&,a_object&)
  $F%
  LOCAL tree&,tree%,x&,y&,w&,h&,last&,num&,handle&,top&,nodraw!,buf$
  LOCAL old_x&,old_y&,old_w&,old_h&,ret&,b%
  handle&=window_array&(index&,0)
  IF index&<>-1
    ~WIND_GET(0,10,top&,x&,x&,x&)
    IF top&=handle& OR animate_background_alert!
      tree&=BYTE(SHR&(OB_TYPE(window_tree%(index&,0),a_object&),8))
      IF tree&
        IF @ob_state(window_array&(index&,4),a_object&,13) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
          IF BTST(OB_STATE(window_tree%(index&,0),a_object&),0)
            OB_STATE(window_tree%(index&,0),a_object&)=BCLR(OB_STATE(window_tree%(index&,0),a_object&),0)
          ELSE
            OB_STATE(window_tree%(index&,0),a_object&)=BSET(OB_STATE(window_tree%(index&,0),a_object&),0)
          ENDIF
        ELSE IF @ob_state(window_array&(index&,4),a_object&,14) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
          IF OB_TYPE(window_array&(index&,4),a_object&)=23
            buf$=SPACE$(16)
            BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+112,V:buf$,16
            BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)},LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+16,112
            BMOVE V:buf$,LONG{OB_SPEC(window_tree%(index&,0),a_object&)},16
          ENDIF
        ELSE IF @ob_state(window_array&(index&,4),a_object&,15) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
          IF OB_TYPE(window_array&(index&,4),a_object&)=23
            buf$=SPACE$(16)
            BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)},V:buf$,16
            BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+16,LONG{OB_SPEC(window_tree%(index&,0),a_object&)},112
            BMOVE V:buf$,LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+112,16
          ENDIF
        ELSE
          tree%=@xrsrc_gaddr(0,tree&)
          last&=VAL(CHAR{OB_SPEC(tree%,1)})
          num&=VAL(CHAR{OB_SPEC(tree%,3)})
          ~OBJC_OFFSET(window_tree%(index&,0),a_object&,old_x&,old_y&)
          SELECT BYTE(OB_TYPE(window_tree%(index&,0),a_object&))
          CASE 23
            old_w&=MUL(WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},8)
            old_h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),6)}
          CASE 24
            old_w&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},22)}
            old_h&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},24)}
          CASE 31,33
            old_w&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),22)}
            old_h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),24)}
          ENDSELECT
          IF BYTE(SHR&(OB_TYPE(tree%,num&),8))<>0 AND BYTE(SHR&(OB_TYPE(tree%,num&),8))>BYTE(SHR&(OB_TYPE(tree%,2),8)) AND BTST(OB_STATE(tree%,num&),3)=TRUE
            IF BYTE(SHR&(OB_TYPE(tree%,2),8))<>0
              nodraw!=TRUE
            ENDIF
            OB_TYPE(tree%,2)=OR(SHL&(SUCC(BYTE(SHR&(OB_TYPE(tree%,2),8))),8),BYTE(OB_TYPE(tree%,2)))
          ELSE
            OB_TYPE(tree%,2)=BYTE(OB_TYPE(tree%,2))
            IF @ob_state(window_array&(index&,4),a_object&,11)=FALSE
              IF BTST(OB_STATE(tree%,1),0)
                IF BTST(OB_STATE(tree%,1),1)
                  DEC num&
                  IF num&<4
                    OB_STATE(tree%,1)=BCLR(OB_STATE(tree%,1),1)
                    num&=5
                  ENDIF
                ELSE
                  INC num&
                  IF num&>last&
                    OB_STATE(tree%,1)=BSET(OB_STATE(tree%,1),1)
                    num&=PRED(last&)
                  ENDIF
                ENDIF
              ELSE
                INC num&
                IF num&>last&
                  IF BTST(OB_STATE(tree%,1),3) AND BTST(OB_STATE(tree%,1),4)=FALSE
                    num&=last&
                    nodraw!=TRUE
                    ret&=-1
                  ELSE
                    num&=4
                  ENDIF
                ENDIF
              ENDIF
            ELSE IF @ob_state(window_array&(index&,4),a_object&,10)
              IF num&=3
                num&=PRED(last&)
              ELSE
                DEC num&
              ENDIF
              IF num&<4
                num&=4
                nodraw!=TRUE
                ret&=-2
              ENDIF
            ENDIF
            buf$=STR$(num&,2)+CHR$(0)
            BMOVE V:buf$,OB_SPEC(tree%,3),3
            OB_TYPE(window_tree%(index&,0),a_object&)=(OB_TYPE(window_tree%(index&,0),a_object&) AND &HFF00) OR BYTE(OB_TYPE(tree%,num&))
            OB_SPEC(window_tree%(index&,0),a_object&)=OB_SPEC(tree%,num&)
            OB_W(window_tree%(index&,0),a_object&)=OB_W(tree%,num&)
            OB_H(window_tree%(index&,0),a_object&)=OB_H(tree%,num&)
            IF BTST(OB_STATE(tree%,1),4) AND nodraw!=FALSE
              IF @ob_state(tree&,1,14)
                IF OB_Y(window_tree%(index&,0),a_object&)<OB_H(window_tree%(index&,0),0)
                  OB_Y(window_tree%(index&,0),a_object&)=ADD(OB_Y(window_tree%(index&,0),a_object&),OB_Y(tree%,1))
                ELSE
                  IF BTST(OB_STATE(tree%,1),3)
                    nodraw!=TRUE
                  ELSE
                    OB_Y(window_tree%(index&,0),a_object&)=-OB_H(tree%,num&)
                  ENDIF
                ENDIF
              ELSE
                IF OB_X(window_tree%(index&,0),a_object&)<OB_W(window_tree%(index&,0),0)
                  OB_X(window_tree%(index&,0),a_object&)=ADD(OB_X(window_tree%(index&,0),a_object&),OB_X(tree%,1))
                ELSE
                  IF BTST(OB_STATE(tree%,1),3)
                    nodraw!=TRUE
                  ELSE
                    OB_X(window_tree%(index&,0),a_object&)=-OB_W(tree%,num&)
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
            IF NOT animate_sound_off!
              IF BYTE(SHR&(OB_TYPE(tree%,num&),8))
                IF @get_cookie("_SND",b%)
                  IF BTST(b%,1)
                    w&=WORD{ADD(OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),4)}
                    h&=WORD{ADD(OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),6)}
                    @dmasound(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},ADD(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},MUL(w&,h&)),BYTE(SHR&(OB_TYPE(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),8)),0)
                    @dmasound(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},ADD(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},MUL(w&,h&)),BYTE(SHR&(OB_TYPE(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),8)),1)
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        IF NOT nodraw!
          ~OBJC_OFFSET(window_tree%(index&,0),a_object&,x&,y&)
          SELECT BYTE(OB_TYPE(window_tree%(index&,0),a_object&))
          CASE 23
            w&=MUL(WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},8)
            h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),6)}
          CASE 24
            w&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},22)}
            h&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},24)}
          CASE 31,33
            w&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),22)}
            h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),24)}
          ENDSELECT
          w&=SUB(MAX(ADD(x&,w&),ADD(old_x&,old_w&)),MIN(x&,old_x&))
          x&=MIN(x&,old_x&)
          h&=SUB(MAX(ADD(y&,h&),ADD(old_y&,old_h&)),MIN(y&,old_y&))
          y&=MIN(y&,old_y&)
          IF window_array&(index&,0)=0
            ~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
          ELSE
            @win_send_redraw(index&,x&,y&,w&,h&)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  RETURN ret&
ENDFUNC
> FUNCTION is_the_icon_animated(index&,reset!,object&,VAR time&)
  $F%
  LOCAL tree&,tree%
  IF index&<>-1
    tree&=BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))
    IF tree&
      IF @ob_state(window_array&(index&,4),object&,13) OR @ob_state(window_array&(index&,4),object&,14) OR @ob_state(window_array&(index&,4),object&,15)
        time&=tree&
        RETURN TRUE
      ELSE
        tree%=@xrsrc_gaddr(0,tree&)
        time&=VAL(CHAR{OB_SPEC(tree%,2)})
        IF reset!
          IF BTST(OB_STATE(tree%,1),4)
            IF @ob_state(tree&,1,14)
              OB_Y(window_tree%(index&,0),object&)=-OB_H(tree%,4)
            ELSE
              OB_X(window_tree%(index&,0),object&)=-OB_W(tree%,4)
            ENDIF
          ENDIF
          CHAR{OB_SPEC(tree%,3)}=STR$(3)+CHR$(0)
        ENDIF
        RETURN TRUE
      ENDIF
    ENDIF
  ENDIF
  RETURN FALSE
ENDFUNC
> PROCEDURE dmasound(st_adr%,end_adr%,rate|,mode|)                        !call
  SDPOKE &HFF8902,BYTE{SUCC(V:st_adr%)}
  SDPOKE &HFF8904,BYTE{ADD(V:st_adr%,2)}
  SDPOKE &HFF8906,BYTE{ADD(V:st_adr%,3)}
  SDPOKE &HFF890E,BYTE{SUCC(V:end_adr%)}
  SDPOKE &HFF8910,BYTE{ADD(V:end_adr%,2)}
  SDPOKE &HFF8912,BYTE{ADD(V:end_adr%,3)}
  SDPOKE &HFF8920,rate|
  SDPOKE &HFF8900,mode|
RETURN
> PROCEDURE animicon_background(do_redraws!)
  IF animicon_endtime%<>0
    IF TIMER>=animicon_endtime%
      ~@animate_icon(animicon_index&,animicon_object&)
      ADD animicon_endtime%,animicon_space%
      IF do_redraws!
        @do_all_redraws
      ENDIF
      IF TIMER>=animicon_endtime%
        LET animicon_endtime%=ADD(TIMER,animicon_space%)
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION closer_object(handle&)
  $F%
  LOCAL a&,index&
  index&=@win_get_index(handle&)
  IF index&<>-1
    a&=0
    DO
      INC a&
      IF @ob_flags(window_array&(index&,4),a&,14)
        IF BTST(OB_FLAGS(window_tree%(index&,0),a&),7)
          @user_rsc_interact(index&,window_array&(index&,4),a&,1,0)
        ELSE
          @my_form_do2(0,index&,a&,-1)
        ENDIF
        RETURN TRUE
      ENDIF
    LOOP UNTIL BTST(OB_FLAGS(window_tree%(index&,0),a&),5)
  ENDIF
  RETURN FALSE
ENDFUNC
> PROCEDURE win_ascii_click(handle&,mx&,my&)
  LOCAL wchar&,hchar&,d&,x&,y&
  ~WIND_GET(handle&,4,x&,y&,d&,d&)
  @mouse_wait_realtime
  @win_close(handle&)
  ~GRAF_HANDLE(wchar&,hchar&,d&,d&)
  ADD x&,DIV(wchar&,2)
  ADD y&,DIV(hchar&,2)
  d&=1
  IF RC_INTERSECT(x&,y&,MUL(MUL(wchar&,2),16),MUL(hchar&,10),mx&,my&,d&,d&)
    d&=ADD(INT(DIV(SUB(mx&,x&),MUL(wchar&,2))),INT(MUL(DIV(SUB(my&,y&),hchar&),16)))
    SELECT d&
    CASE 0
      d&=127
    CASE 32 TO 159
      ADD d&,96
    ENDSELECT
    @keypress(d&)
  ENDIF
RETURN
> PROCEDURE cursor_on(index&)
  LOCAL ob_spec%,a&
  ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
  ob_spec%=ADD({ob_spec%},window_array&(index&,3))
  a&=BYTE{ob_spec%}
  BYTE{ob_spec%}=0
  ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),1,window_array&(index&,3))
  BYTE{ob_spec%}=a&
RETURN
> FUNCTION form_keybd(tree%,curr_obj&,key&,VAR new_obj&,keyout&)
  $F%
  GCONTRL(0)=55
  GCONTRL(1)=3
  GCONTRL(2)=3
  GCONTRL(3)=1
  GCONTRL(4)=0
  ADDRIN(0)=tree%
  GINTIN(0)=curr_obj&
  GINTIN(1)=key&
  GINTIN(2)=curr_obj&
  GEMSYS
  new_obj&=GINTOUT(1)
  keyout&=GINTOUT(2)
  RETURN GINTOUT(0)
ENDFUNC
> PROCEDURE fgtext_input(k_state&,key&,index&)
  LOCAL new_obj&,keyout&,a&,new_pos&,new_obj&,maxlen&,str1$
  LOCAL ob&
  IF index&<>-1
    LET new_obj&=window_array&(index&,2)
    LET a&=1
    CLR keyout&
    str1$=@rsc_get_text$(window_array&(index&,4),window_array&(index&,2))
    IF (k_state& AND &X11)<>0 AND BYTE(SHR(key&,8))=75
      ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
      LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),0)
    ELSE IF (k_state& AND &X11)<>0 AND BYTE(SHR(key&,8))=77
      ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
      LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}}))
    ELSE IF BTST(k_state&,2) AND BYTE(SHR(key&,8))=115
      ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
      LET new_pos&=window_array&(index&,3)
      WHILE new_pos&>0 AND (MID$(str1$,new_pos&,1)=" " OR MID$(str1$,new_pos&,1)="," OR MID$(str1$,new_pos&,1)="@" OR MID$(str1$,new_pos&,1)=";")
        DEC new_pos&
      WEND
      WHILE new_pos&>0 AND (MID$(str1$,new_pos&,1)<>" " AND MID$(str1$,new_pos&,1)<>"," AND MID$(str1$,new_pos&,1)<>"@" AND MID$(str1$,new_pos&,1)<>";")
        DEC new_pos&
      WEND
      LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),new_pos&)
    ELSE IF BTST(k_state&,2) AND BYTE(SHR(key&,8))=116
      ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
      LET maxlen&=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}})
      LET new_pos&=window_array&(index&,3)
      DO
        INC new_pos&
      LOOP WHILE new_pos&<maxlen& AND (MID$(str1$,new_pos&,1)<>" " AND MID$(str1$,new_pos&,1)<>"," AND MID$(str1$,new_pos&,1)<>"@" AND MID$(str1$,new_pos&,1)<>";")
      WHILE new_pos&<maxlen& AND (MID$(str1$,new_pos&,1)=" " OR MID$(str1$,new_pos&,1)="," OR MID$(str1$,new_pos&,1)="@" OR MID$(str1$,new_pos&,1)=";")
        INC new_pos&
      WEND
      LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),PRED(new_pos&))
    ELSE
      LET a&=@form_keybd(window_tree%(index&,0),window_array&(index&,2),key&,new_obj&,keyout&)
    ENDIF
    ob&=window_array&(index&,2)
    IF a&>0
      IF BYTE(SHR(key&,8))<>28 AND BYTE(SHR(key&,8))<>114
        IF new_obj&<>window_array&(index&,2)
          ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
          window_array&(index&,2)=new_obj&
          LET maxlen&=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}})
          LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),MIN(maxlen&,window_array&(index&,3)))
        ENDIF
      ENDIF
      IF keyout&<>0
        ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),keyout&,window_array&(index&,3),2,new_pos&)
        window_array&(index&,3)=new_pos&
      ENDIF
      @rsc_read_tree(window_array&(index&,4),window_array&(index&,2))
      IF @ob_state(window_array&(index&,4),window_array&(index&,2),15)
        IF ob&=window_array&(index&,2) AND @ob_state(window_array&(index&,4),window_array&(index&,2),12)=FALSE
          IF @rsc_get_text$(window_array&(index&,4),window_array&(index&,2))<>str1$
            @user_rsc_interact(index&,window_array&(index&,4),ob&,1,key&)
          ENDIF
        ENDIF
      ENDIF
    ELSE
      OB_STATE(window_tree%(index&,0),new_obj&)=BCLR(OB_STATE(window_tree%(index&,0),new_obj&),0)
      @rsc_ob_draw(index&,new_obj&)
      @user_rsc_interact(index&,window_array&(index&,4),new_obj&,1,0)
    ENDIF
  ENDIF
RETURN
> PROCEDURE fix_editcursor(handle&)
  LOCAL x&,y&,w&,h&,index&
  index&=@win_get_index(handle&)
  IF index&<>-1
    IF window_array&(index&,21)=-1
      IF window_array&(index&,1)>0
        IF window_array&(index&,2)<>0
          @rsc_ob_xywh(window_tree%(index&,0),window_array&(index&,2),x&,y&,w&,h&)
          ~FORM_DIAL(3,0,0,0,0,x&,SUB(y&,5),w&,ADD(h&,10))
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION click_set_cursor(index&,mx&,my&,idx&)
  $F%
  LOCAL x&,a&,i&,ob_spec%,a$,wchar&
  ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
  ~OBJC_OFFSET(window_tree%(index&,0),window_array&(index&,2),x&,a&)
  ~GRAF_HANDLE(wchar&,a&,a&,a&)
  a$=CHAR{{ADD(ob_spec%,4)}}
  SELECT WORD{ADD(ob_spec%,16)}
  CASE 0       !left
    x&=DIV(SUB(mx&,x&),wchar&)
  CASE 1       !right
    x&=DIV(SUB(mx&,SUB(ADD(x&,OB_W(window_tree%(index&,0),window_array&(index&,2))),MUL(wchar&,LEN(a$)))),wchar&)
  CASE 2       !center
    x&=DIV(SUB(mx&,ADD(x&,DIV(OB_W(window_tree%(index&,0),window_array&(index&,2))-MUL(wchar&,LEN(a$)),2))),wchar&)
  ENDSELECT
  x&=MAX(x&,0)
  i&=0
  FOR a&=1 TO x&
    IF MID$(a$,a&,1)="_"
      INC i&
    ENDIF
  NEXT a&
  SUB x&,(x&-i&)
  RETURN @set_cursor(index&,idx&,x&)
ENDFUNC
> FUNCTION set_cursor(index&,idx&,x&)
  $F%
  LOCAL ob_spec%,a&
  ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
  ob_spec%=ADD({ob_spec%},x&)
  a&=BYTE{ob_spec%}
  BYTE{ob_spec%}=0
  ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,idx&,1,idx&)
  BYTE{ob_spec%}=a&
  RETURN idx&
ENDFUNC
> PROCEDURE rsc_set_text(tree&,object&,string$)                           !call
  LOCAL tree%,obspec%,whitebak!,clear_flags!
  LOCAL gout1&,gout2&,gout3&,gout4&
  ~@appl_xgetinfo(13,gout1&,gout2&,gout3&,gout4&)
  LET whitebak!=BTST(gout4&,2)
  tree%=@xrsrc_gaddr(0,tree&)
  obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
  CHAR{C:obspec%(L:tree%,object&)}=string$
  @update_prg_def_textob(FALSE,tree%,tree&,object&,whitebak!,clear_flags!)
RETURN
> FUNCTION rsc_get_text$(tree&,object&)                                   !call
  LOCAL tree%,obspec%
  tree%=@xrsrc_gaddr(0,tree&)
  obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
  RETURN CHAR{C:obspec%(L:tree%,object&)}
ENDFUNC
> PROCEDURE rsc_set_radio(tree&,object&,value&,index&)
  LOCAL tree%,root&,a&,b&,ob1&,ob2&
  tree%=@xrsrc_gaddr(0,tree&)
  IF BTST(OB_FLAGS(tree%,object&),4)
    root&=object&
    DO
      root&=OB_NEXT(tree%,root&)
    LOOP UNTIL root&<object&
    a&=OB_HEAD(tree%,root&)
    b&=1
    DO
      IF BTST(OB_FLAGS(tree%,a&),4)
        IF BTST(OB_STATE(tree%,a&),0)
          OB_STATE(tree%,a&)=BCLR(OB_STATE(tree%,a&),0)
          ob1&=a&
        ENDIF
        IF b&=value&
          OB_STATE(tree%,a&)=BSET(OB_STATE(tree%,a&),0)
          ob2&=a&
        ENDIF
        INC b&
      ENDIF
      a&=OB_NEXT(tree%,a&)
    LOOP UNTIL a&=root&
    IF index&<>-1
      IF ob1&<>0
        @rsc_ob_draw(index&,ob1&)
      ENDIF
      IF ob2&<>0
        @rsc_ob_draw(index&,ob2&)
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION rsc_get_radio(tree&,object&)
  $F%
  LOCAL tree%,root&,a&,b&
  tree%=@xrsrc_gaddr(0,tree&)
  IF BTST(OB_FLAGS(tree%,object&),4)
    root&=object&
    DO
      root&=OB_NEXT(tree%,root&)
    LOOP UNTIL root&<object&
    a&=OB_HEAD(tree%,root&)
    b&=1
    DO
      IF BTST(OB_FLAGS(tree%,a&),4)
        IF BTST(OB_STATE(tree%,a&),0)
          RETURN b&
        ENDIF
        INC b&
      ENDIF
      a&=OB_NEXT(tree%,a&)
    LOOP UNTIL a&=root&
  ENDIF
  RETURN 0
ENDFUNC
> PROCEDURE invert_pointer_string(index&,object&,flag!)
  LOCAL x&,y&,w&,h&,rx&,ry&,rw&,rh&
  IF PRED(object&)>0
    IF @pointforward_object(index&,PRED(object&))
      IF flag!
        OB_STATE(window_tree%(index&,0),PRED(object&))=BSET(OB_STATE(window_tree%(index&,0),PRED(object&)),0)
        OB_H(window_tree%(index&,0),PRED(object&))=OB_H(window_tree%(index&,0),PRED(object&))+4
        OB_W(window_tree%(index&,0),PRED(object&))=SUB(OB_X(window_tree%(index&,0),object&),OB_X(window_tree%(index&,0),PRED(object&)))
      ELSE
        OB_STATE(window_tree%(index&,0),PRED(object&))=BCLR(OB_STATE(window_tree%(index&,0),PRED(object&)),0)
      ENDIF
      @rsc_ob_xywh(window_tree%(index&,0),PRED(object&),x&,y&,w&,h&)
      ~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
      WHILE rw& OR rh&
        IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
          ~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
        ENDIF
        ~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
      WEND
      IF NOT flag!
        OB_H(window_tree%(index&,0),PRED(object&))=OB_H(window_tree%(index&,0),PRED(object&))-4
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION popup(index&,object&,selected&)
  $F%
  LOCAL org_tree%,org_tree&,tree%,pop_me&,x&,y&,dx&,dy&,dw&,dh&,mx&,my&,mb&,ks&
  LOCAL inv_obj&,result&,m!,evnt&,key&,mc&,ascii|,scan|,exit!,bp&,buffer%
  org_tree%=window_tree%(index&,0)
  org_tree&=window_array&(index&,4)
  pop_me&=@popup_find(org_tree%,org_tree&,object&)
  tree%=@xrsrc_gaddr(0,fvt_popu&)
  IF @popup_enq_radio(org_tree%,object&)
    IF BYTE(OB_TYPE(org_tree%,object&))=22
      OB_STATE(tree%,ADD(selected&,pop_me&))=BSET(OB_STATE(tree%,ADD(selected&,pop_me&)),2)
    ENDIF
  ENDIF
  ~OBJC_OFFSET(org_tree%,object&,x&,y&)
  ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
  OB_X(tree%,0)=MIN(MAX(SUB(x&,ADD(OB_X(tree%,pop_me&),OB_X(tree%,ADD(MAX(selected&,1),pop_me&)))),-OB_X(tree%,pop_me&)),SUB(SUB(PRED(ADD(dx&,dw&)),OB_X(tree%,pop_me&)),OB_W(tree%,pop_me&)))
  OB_Y(tree%,0)=MIN(MAX(SUB(y&,ADD(OB_Y(tree%,pop_me&),OB_Y(tree%,ADD(MAX(selected&,1),pop_me&)))),SUB(dy&,OB_Y(tree%,pop_me&))),SUB(SUB(PRED(ADD(dy&,dh&)),OB_H(tree%,pop_me&)),OB_Y(tree%,pop_me&)))
  ~OBJC_OFFSET(tree%,pop_me&,x&,y&)
  @aes_screen_lock
  bp&=@vq_extnd(V~H,1,4)
  buffer%=MALLOC(MUL(MUL(MUL(DIV(ADD(OB_W(tree%,pop_me&),20),16),2),ADD(OB_H(tree%,pop_me&),5)),bp&))
  IF buffer%>0
    IF BYTE(OB_TYPE(org_tree%,object&))=23
      @invert_pointer_string(index&,PRED(object&),-1)
    ELSE
      @invert_pointer_string(index&,object&,-1)
    ENDIF
    fv_malloced%=buffer%
    @vdi_bitblt(0,0,0,0,bp&,buffer%,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,bp&,PRED(x&),PRED(y&),ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,0,1)
    ~OBJC_DRAW(tree%,pop_me&,7,PRED(x&),PRED(y&),ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5))
    ~GRAF_MKSTATE(mx&,my&,mb&,ks&)
    inv_obj&=0
    result&=OBJC_FIND(tree%,pop_me&,7,mx&,my&)
    IF result&=>1 AND result&<>pop_me& AND BTST(OB_STATE(tree%,result&),3)=FALSE
      ~OBJC_OFFSET(tree%,result&,dx&,dy&)
      ~OBJC_CHANGE(tree%,result&,0,dx&,dy&,OB_W(tree%,result&),OB_H(tree%,result&),BSET(OB_STATE(tree%,result&),0),1)
      inv_obj&=result&
    ENDIF
    ~EVNT_TIMER(200)
    ~GRAF_MKSTATE(mx&,my&,mb&,ks&)
    IF mb&=1
      m!=TRUE
    ENDIF
    DO
      IF m!
        ~GRAF_MKSTATE(mx&,my&,mb&,ks&)
      ELSE
        evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
      ENDIF
      IF BTST(evnt&,2) OR m!
        result&=OBJC_FIND(tree%,pop_me&,7,mx&,my&)
        IF result&=pop_me&
          result&=-1
        ENDIF
      ENDIF
      IF BTST(evnt&,0)                                 !keyboard
        ascii|=BYTE(key&)
        scan|=BYTE(SHR(key&,8))
        IF scan|=71
          IF AND(ks&,&X11) !shift
            result&=OB_TAIL(tree%,pop_me&)
          ELSE
            result&=ADD(pop_me&,1)
          ENDIF
        ELSE IF scan|=80
          IF result&<0
            result&=ADD(pop_me&,1)
          ELSE
            IF AND(ks&,&X11) !shift
              result&=OB_TAIL(tree%,pop_me&)
            ELSE
              result&=OB_NEXT(tree%,result&)
              IF result&<=pop_me&
                result&=ADD(pop_me&,1)
              ENDIF
            ENDIF
          ENDIF
        ELSE IF scan|=72
          IF result&<0
            result&=ADD(pop_me&,1)
          ELSE
            IF AND(ks&,&X11) !shift
              result&=ADD(pop_me&,1)
            ELSE
              IF result&>ADD(pop_me&,1)
                DEC result&
              ELSE IF result&=ADD(pop_me&,1)
                result&=OB_TAIL(tree%,pop_me&)
              ENDIF
            ENDIF
          ENDIF
        ELSE IF scan|=97 OR ascii|=27
          result&=-1
          exit!=TRUE
        ELSE IF ascii|=13
          exit!=TRUE
        ENDIF
      ENDIF
      IF result&<>inv_obj&
        IF inv_obj&=>1
          ~OBJC_OFFSET(tree%,inv_obj&,dx&,dy&)
          ~OBJC_CHANGE(tree%,inv_obj&,0,dx&,dy&,OB_W(tree%,inv_obj&),OB_H(tree%,inv_obj&),BCLR(OB_STATE(tree%,inv_obj&),0),1)
        ENDIF
        IF result&=>1
          IF NOT BTST(OB_STATE(tree%,result&),3)
            ~OBJC_OFFSET(tree%,result&,dx&,dy&)
            ~OBJC_CHANGE(tree%,result&,0,dx&,dy&,OB_W(tree%,result&),OB_H(tree%,result&),BSET(OB_STATE(tree%,result&),0),1)
          ENDIF
        ENDIF
        inv_obj&=result&
      ENDIF
      ~EVNT_TIMER(20)
    LOOP UNTIL BTST(evnt&,1) OR (mb&=0 AND m!) OR exit!
    IF @popup_enq_radio(org_tree%,object&)
      IF BYTE(OB_TYPE(org_tree%,object&))=22
        OB_STATE(tree%,ADD(selected&,pop_me&))=BCLR(OB_STATE(tree%,ADD(selected&,pop_me&)),2)
      ENDIF
    ENDIF
    @mouse_wait
    ~OBJC_OFFSET(tree%,pop_me&,x&,y&)
    @vdi_bitblt(buffer%,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,bp&,0,0,0,0,bp&,0,0,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),PRED(x&),PRED(y&),1)
    ~MFREE(buffer%)
    fv_malloced%=0
    IF BYTE(OB_TYPE(org_tree%,object&))=23
      @invert_pointer_string(index&,PRED(object&),0)
    ELSE
      @invert_pointer_string(index&,object&,0)
    ENDIF
    IF result&<>-1
      IF NOT BTST(OB_STATE(tree%,result&),3)
        OB_STATE(tree%,result&)=BCLR(OB_STATE(tree%,result&),0)
        IF @popup_enq_radio(org_tree%,object&)
          IF BYTE(OB_TYPE(org_tree%,object&))=22
            {OB_SPEC(org_tree%,object&)}=OB_SPEC(tree%,result&)
            @rsc_ob_draw(index&,object&)
          ELSE
            OB_SPEC(org_tree%,object&)=OB_SPEC(tree%,result&)
            @rsc_ob_draw(index&,PRED(object&))
          ENDIF
        ENDIF
        LET selected&=SUB(result&,pop_me&)
      ENDIF
    ENDIF
  ENDIF
  @aes_screen_unlock
  RETURN selected&
ENDFUNC
> FUNCTION popup_cycle(index&,object&,selected&)
  $F%
  LOCAL tree2%,a&,num&,pop_me&
  pop_me&=@popup_find(window_tree%(index&,0),window_array&(index&,4),object&)
  tree2%=@xrsrc_gaddr(0,fvt_popu&)
  num&=0
  a&=OB_HEAD(tree2%,pop_me&)
  DO
    INC num&
    a&=OB_NEXT(tree2%,a&)
  LOOP UNTIL a&=pop_me&
  a&=selected&
  DO
    INC a&
    IF a&>num&
      a&=1
    ENDIF
    IF BTST(OB_STATE(tree2%,ADD(pop_me&,a&)),3)=0
      LET selected&=a&
      EXIT IF TRUE
    ENDIF
    EXIT IF a&=selected&
  LOOP
  @popup_set_selected(window_array&(index&,4),object&,selected&,index&)
  ~EVNT_TIMER(100)
  RETURN selected&
ENDFUNC
> FUNCTION popup_find(tree%,tree&,object&)
  $F%
  LOCAL tree2%,a&,pop_me&
  tree2%=@xrsrc_gaddr(0,fvt_popu&)
  a&=0
  pop_me&=0
  DO
    INC pop_me&
    IF BYTE(OB_TYPE(tree2%,pop_me&))=20
      INC a&
    ENDIF
  LOOP UNTIL a&=SUB(BYTE(SHR&(OB_TYPE(tree%,object&),8)),30)
  RETURN pop_me&
ENDFUNC
> FUNCTION popup_get_radio(tree&,object&)
  $F%
  LOCAL tree%,org_tree%,pop_me&,a&
  org_tree%=@xrsrc_gaddr(0,tree&)
  tree%=@xrsrc_gaddr(0,fvt_popu&)
  pop_me&=@popup_find(org_tree%,tree&,object&)
  IF BYTE(OB_TYPE(org_tree%,object&))=22
    DO
      INC a&
      IF OB_SPEC(tree%,a&)={OB_SPEC(org_tree%,object&)}
        RETURN SUB(a&,pop_me&)
      ENDIF
    LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
  ELSE IF BYTE(OB_TYPE(org_tree%,object&))=23
    DO
      INC a&
      IF OB_SPEC(tree%,a&)=OB_SPEC(org_tree%,object&)
        RETURN SUB(a&,pop_me&)
      ENDIF
    LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
  ENDIF
  RETURN 1
ENDFUNC
> PROCEDURE popup_set_selected(tree&,object&,value&,index&)
  LOCAL tree2%,pop_me&,a&,sel&,tree%
  tree%=@xrsrc_gaddr(0,tree&)
  pop_me&=@popup_find(tree%,tree&,object&)
  tree2%=@xrsrc_gaddr(0,fvt_popu&)
  sel&=0
  a&=OB_HEAD(tree2%,pop_me&)
  DO
    INC sel&
    IF sel&=value&
      IF BYTE(OB_TYPE(tree%,object&))=22
        {OB_SPEC(tree%,object&)}=OB_SPEC(tree2%,a&)
        IF index&<>-1
          @rsc_ob_draw(index&,object&)
        ENDIF
      ELSE
        OB_SPEC(tree%,object&)=OB_SPEC(tree2%,a&)
        IF index&<>-1
          @rsc_ob_draw(index&,PRED(object&))
        ENDIF
      ENDIF
      EXIT IF TRUE
    ENDIF
    a&=OB_NEXT(tree2%,a&)
  LOOP UNTIL a&=pop_me&
RETURN
> FUNCTION popup_enq_radio(tree%,object&)
  $F%
  IF NOT BTST(OB_FLAGS(tree%,object&),5)
    IF BYTE(SHR&(OB_TYPE(tree%,SUCC(object&)),8))=27 OR BYTE(OB_TYPE(tree%,SUCC(object&)))=27
      IF OB_NEXT(tree%,SUCC(object&))=object& OR OB_NEXT(tree%,SUCC(object&))=PRED(object&)
        RETURN TRUE
      ENDIF
    ENDIF
  ENDIF
  RETURN FALSE
ENDFUNC
> FUNCTION popup_sub_formdo(index&,VAR object&)
  $F%
  LOCAL sub&
  IF @ob_state(window_array&(index&,4),object&,10)=FALSE
    IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=22 AND BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))>30
      IF OB_HEAD(window_tree%(index&,0),object&)=-1
        sub&=@popup(index&,object&,0)
      ELSE
        ~@popup(index&,object&,@popup_get_radio(window_array&(index&,4),object&))
      ENDIF
    ELSE IF BYTE(SHR&(OB_TYPE(window_tree%(index&,0),PRED(object&)),8))>30 AND @ob_flags(window_array&(index&,4),object&,9)
      IF BYTE(OB_TYPE(window_tree%(index&,0),PRED(object&)))=22
        ~@popup_cycle(index&,PRED(object&),@popup_get_radio(window_array&(index&,4),PRED(object&)))
        DEC object&
      ELSE IF BYTE(OB_TYPE(window_tree%(index&,0),PRED(object&)))=23
        ~@popup_cycle(index&,PRED(object&),@popup_get_radio(window_array&(index&,4),PRED(object&)))
        DEC object&
      ENDIF
    ELSE IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=23 AND BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))>30
      IF OB_NEXT(window_tree%(index&,0),object&)>object&
        ~@popup(index&,object&,@popup_get_radio(window_array&(index&,4),object&))
      ELSE
        sub&=@popup(index&,object&,0)
      ENDIF
    ENDIF
  ENDIF
  RETURN sub&
ENDFUNC
> PROCEDURE rsc_set_selectable(tree&,object&,flag&)
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF flag&
    OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),0)
  ELSE
    OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),0)
  ENDIF
RETURN
> FUNCTION rsc_get_selectable(tree&,object&)
  $F%
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  RETURN BTST(OB_STATE(tree%,object&),0)
ENDFUNC
> FUNCTION rs_read(fname$,VAR rsc%)
  LOCAL size%
  LOCAL ret!
  LOCAL found!
  LOCAL fh&
  LET ret!=FALSE
  LET found!=(SHEL_FIND(fname$)<>0)
  IF found!
    LET fname$=fname$+CHR$(0)
    LET fh&=GEMDOS(61,L:V:fname$,0)
    IF fh&=>0
      LET size%=GEMDOS(66,L:0,fh&,2)
      IF size%>72
        rsc%=MALLOC(size%)
        IF rsc%<>0
          ~GEMDOS(66,L:0,fh&,0)
          IF GEMDOS(63,fh&,L:size%,L:rsc%)=size%
            @rsc_fixup(rsc%,size%)
            ret!=TRUE
          ELSE
            ~MFREE(rsc%)
          ENDIF
        ENDIF
      ENDIF
      ~GEMDOS(62,fh&)
    ENDIF
  ENDIF
  RETURN ret!
ENDFUNC
> PROCEDURE rsc_fixup(rsc%,rs_len%)
  LOCAL vgb_image_adress%
  LOCAL vgb_string_adress%
  LOCAL ob_start_adr%,tree_table%,object&,tree&,free_str_num&,free_img_num&
  LOCAL version&,long!,end&
  LOCAL c_icon%
  LET version&=WORD{rsc%}
  LET long!=(WORD{rsc%} AND &X10)=2
  IF long!
    tree_table%=rsc%+{rsc%+36}
  ELSE
    tree_table%=rsc%+CARD{rsc%+18}
  ENDIF
  IF long!
    LET end&={rsc%+44}-1
  ELSE
    LET end&=CARD{rsc%+22}-1
  ENDIF
  FOR tree&=0 TO end&
    {tree_table%+(4*tree&)}={tree_table%+(4*tree&)}+rsc%
  NEXT tree&
  IF long!
    free_str_num&={rsc%+30*2}-1
  ELSE
    free_str_num&=CARD{rsc%+30}-1
  ENDIF
  IF free_str_num&>-1
    IF long!
      vgb_string_adress%=rsc%+{rsc%+10*2}
    ELSE
      vgb_string_adress%=rsc%+CARD{rsc%+10}
    ENDIF
    FOR object&=0 TO free_str_num&
      {vgb_string_adress%+(4*object&)}={vgb_string_adress%+(4*object&)}+rsc%
    NEXT object&
  ENDIF
  IF long!
    free_img_num&={rsc%+32*2}-1
  ELSE
    free_img_num&=CARD{rsc%+32}-1
  ENDIF
  IF free_img_num&>-1
    IF long!
      vgb_image_adress%=rsc%+{rsc%+16*2}
    ELSE
      vgb_image_adress%=rsc%+CARD{rsc%+16}
    ENDIF
    FOR object&=0 TO free_img_num&
      {vgb_image_adress%+(4*object&)}={vgb_image_adress%+(4*object&)}+rsc%
      {{vgb_image_adress%+(4*object&)}}={{vgb_image_adress%+(4*object&)}}+rsc%
    NEXT object&
  ENDIF
  IF long!
    ob_start_adr%=rsc%+{rsc%+2*2}
  ELSE
    ob_start_adr%=rsc%+CARD{rsc%+2}
  ENDIF
  IF long!
    LET end&={rsc%+20*2}-1
  ELSE
    LET end&=CARD{rsc%+20}-1
  ENDIF
  FOR object&=0 TO end&
    ~RSRC_OBFIX(ob_start_adr%,object&)
    SELECT BYTE(OB_TYPE(ob_start_adr%,object&))
    CASE 21,22,23,26,28,29,30,31,32,34,35,37,38
      OB_SPEC(ob_start_adr%,object&)=OB_SPEC(ob_start_adr%,object&)+rsc%
    ENDSELECT
    SELECT BYTE(OB_TYPE(ob_start_adr%,object&))
    CASE 23,34,35
      {OB_SPEC(ob_start_adr%,object&)}={OB_SPEC(ob_start_adr%,object&)}+rsc%
    CASE 21,22,29,30,31
      {OB_SPEC(ob_start_adr%,object&)}={OB_SPEC(ob_start_adr%,object&)}+rsc%
      {OB_SPEC(ob_start_adr%,object&)+4}={OB_SPEC(ob_start_adr%,object&)+4}+rsc%
      {OB_SPEC(ob_start_adr%,object&)+8}={OB_SPEC(ob_start_adr%,object&)+8}+rsc%
    ENDSELECT
  NEXT object&
  @rs_do_ciconfix(rsc%)
RETURN
> FUNCTION xrsrc_free(rsc%)
  IF rsc%<>0
    ~MFREE(rsc%)
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
> FUNCTION xrsrc_load(name$)
  LOCAL rsc%
  IF @rs_read(name$,rsc%)=0
    LET rsc%=0
  ENDIF
  RETURN rsc%
ENDFUNC
> FUNCTION xrsrc_xgaddr(rsc%,type&,item&,VAR adr%)
  IF rsc%<>0
    adr%=@rs_get_address(rsc%,type&,item&)
  ELSE
    adr%=0
  ENDIF
  RETURN adr%<>0
ENDFUNC
> FUNCTION rs_get_address(rsc%,type&,index%)
  LOCAL the_addr%,long!,version&
  the_addr%=0
  LET version&=WORD{rsc%}
  LET long!=(version& AND &X10)=2
  IF long!
    SELECT type&
    CASE 0
      the_addr%={rsc%+{rsc%+36}+index%*4}
    CASE 1
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+4},24)
    CASE 2
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8},28)
    CASE 3
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12},34)
    CASE 4
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+16},14)
    CASE 5
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+20},4)
    CASE 6
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+28},4)
    CASE 7
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+4}+12,24)
    CASE 8
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8},28)
    CASE 9
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8}+4,28)
    CASE 10
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8}+8,28)
    CASE 11
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12},34)
    CASE 12
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12}+4,34)
    CASE 13
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12}+8,34)
    CASE 14
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+16},14)
    CASE 15
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+20},4)
    CASE 16
      the_addr%=@rs_get_sub(index%,rsc%+{rsc%+32},4)
    ENDSELECT
  ELSE
    SELECT type&
    CASE 0
      the_addr%={rsc%+CARD{rsc%+36\2}+index%*4}
    CASE 1
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+4\2},24)
    CASE 2
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2},28)
    CASE 3
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2},34)
    CASE 4
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+16\2},14)
    CASE 5
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+20\2},4)
    CASE 6
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+28\2},4)
    CASE 7
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+4\2}+12,24)
    CASE 8
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2},28)
    CASE 9
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2}+4,28)
    CASE 10
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2}+8,28)
    CASE 11
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2},34)
    CASE 12
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2}+4,34)
    CASE 13
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2}+8,34)
    CASE 14
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+16\2},14)
    CASE 15
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+20\2},4)
    CASE 16
      the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+32\2},4)
    ENDSELECT
  ENDIF
  RETURN the_addr%
ENDFUNC
> FUNCTION rs_get_sub(index%,offset%,size%)
  RETURN ADD(offset%,MUL(index%,size%))
ENDFUNC
> PROCEDURE rs_do_ciconfix(rsc%)
  LOCAL i&,num&
  LOCAL ciconblk%
  LOCAL p%
  LOCAL iclen%
  LOCAL p2%
  LOCAL cicon%
  LOCAL num_cicon%
  LOCAL i2%
  LOCAL pobject%
  LOCAL ob%
  LOCAL rsxhdr4%
  LOCAL rsxhdr24%
  LOCAL rsxhdr40%
  LOCAL rsxhdr68%
  IF (version& AND &X10)=2
    LET rsxhdr4%={rsc%+4}
    LET rsxhdr24%={rsc%+24}
    LET rsxhdr40%={rsc%+40}
    LET rsxhdr68%={rsc%+68}
  ELSE
    LET rsxhdr4%=CARD{rsc%+4\2}
    LET rsxhdr24%=CARD{rsc%+24\2}
    LET rsxhdr40%=CARD{rsc%+40\2}
    LET rsxhdr68%=CARD{rsc%+68\2}
  ENDIF
  LET cicon_liste%={rsxhdr68%+rsc%+4}+rsc%
  num&=0
  WHILE {cicon_liste%+num&*4}=0
    INC num&
  WEND
  IF {cicon_liste%+num&*4}<>-1
    LET num&=-1
  ELSE
    LET p%=cicon_liste%+(num&+1)*4
    FOR i&=0 TO PRED(num&)
      LET ciconblk%=p%
      {cicon_liste%+i&*4}=ciconblk%
      ADD p%,38
      {ciconblk%+4}=p%
      LET iclen%=((WORD{ciconblk%+22}+15)/16)
      MUL iclen%,2*WORD{ciconblk%+24}
      ADD p%,iclen%
      {ciconblk%}=p%
      ADD p%,iclen%
      LET p2%={ciconblk%+8}
      IF (p2%=0) OR (p2%<rsxhdr24%) OR (p2%>rsxhdr68%)
        {ciconblk%+8}=p%
      ELSE
        {ciconblk%+8}=rsc%+p2%
      ENDIF
      ADD p%,12
      num_cicon%={ciconblk%+34}
      FOR i2%=0 TO PRED(num_cicon%)
        LET cicon%=p%
        ADD p%,22
        ADD p%,iclen%*WORD{cicon%}
        ADD p%,iclen%
        IF {cicon%+10}<>0
          ADD p%,iclen%*WORD{cicon%}
          ADD p%,iclen%
        ENDIF
      NEXT i2%
    NEXT i&
    pobject%=rsc%+rsxhdr4%
    FOR ob%=0 TO PRED(rsxhdr40%)
      IF BYTE(OB_TYPE(pobject%,ob%))=33
        OB_TYPE(pobject%,ob%)=OR(AND(OB_TYPE(pobject%,ob%),&HFF00),31)
        OB_SPEC(pobject%,ob%)={cicon_liste%+OB_SPEC(pobject%,ob%)*4}
      ENDIF
    NEXT ob%
  ENDIF
RETURN
> PROCEDURE win_change_size(index&,new_w%,new_h%,step_x&,step_y&,zero!)   !call
  LOCAL x&,y&,w&,h&                                     !local variables
  @win_get_workarea(index&,x&,y&,w&,h&)                 !get work area of window
  IF new_w%<>-1
    window_array%(index&,0)=new_w%                        !set new width in window array
  ENDIF
  IF new_h%<>-1
    window_array%(index&,1)=new_h%                        !set new height in window array
  ENDIF
  IF step_x&<>-1
    window_array&(index&,9)=step_x&                         !set scroll step in window array
  ENDIF
  IF step_y&<>-1
    window_array&(index&,10)=step_y&                         !set scroll step in window array
  ENDIF
  @win_resize(index&,-1,-1,-1,-1)
  IF zero!
    @win_set_offset(index&,0,0)
  ENDIF
RETURN
> FUNCTION win_kind_create(mode&,tool&,tree&,info!,icfy!,limitsiz!,alw_redr!,offs_scr!,siz_scr!,blit!,backgr!,align&,vdiw!)       !call
  $F%
  LOCAL kind%
  CLR kind%
  SELECT mode&
  CASE 1 ! prg-modal
    LET kind%=BSET(kind%,13)
  CASE 2 ! toolbox
    LET kind%=BSET(kind%,14)
  ENDSELECT
  SELECT tool&
  CASE 1 ! toolstrip
    LET kind%=BSET(kind%,1)
  CASE 2 ! toolbar
    LET kind%=BSET(kind%,2)
  CASE 3 ! windowmenu
    LET kind%=BSET(kind%,5)
  ENDSELECT
  IF tree&=>0
    LET kind%=BSET(kind%,0)
  ENDIF
  IF limitsiz!
    LET kind%=BSET(kind%,3)
  ENDIF
  IF alw_redr!
    LET kind%=BSET(kind%,4)
  ENDIF
  IF offs_scr!
    LET kind%=BSET(kind%,6)
  ENDIF
  IF siz_scr!
    LET kind%=BSET(kind%,7)
  ENDIF
  IF blit!
    LET kind%=BSET(kind%,8)
  ENDIF
  IF backgr!
    LET kind%=BSET(kind%,9)
  ENDIF
  SELECT align&
  CASE 1 ! byte
    LET kind%=BSET(kind%,10)
  CASE 2 ! word
    LET kind%=BSET(kind%,11)
  ENDSELECT
  IF vdiw!
    LET kind%=BSET(kind%,12)
  ENDIF
  LET kind%=BSET(kind%,16)      ! name
  LET kind%=BSET(kind%,17)      ! close
  LET kind%=BSET(kind%,18)      ! full
  LET kind%=BSET(kind%,19)      ! move
  IF info!
    LET kind%=BSET(kind%,20)      ! info
  ENDIF
  LET kind%=BSET(kind%,21)      ! size
  LET kind%=BSET(kind%,22)      ! uparrow
  LET kind%=BSET(kind%,23)      ! dnarrow
  LET kind%=BSET(kind%,24)      ! vslide
  LET kind%=BSET(kind%,25)      ! lfarrow
  LET kind%=BSET(kind%,26)      ! rtarrow
  LET kind%=BSET(kind%,27)      ! hslide
  IF icfy!
    LET kind%=BSET(kind%,30)      ! icfy
  ENDIF
  RETURN kind%
ENDFUNC
> PROCEDURE rsc_ob_disable(tree&,object&,flag!)                           !call
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF flag!
    OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),3)
  ELSE
    OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),3)
  ENDIF
RETURN
> PROCEDURE evnt_multi_loop                                               !call
  LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,time&
  DO
    CLR time&
    LET evnt_flags&=&X110011
    event&=EVNT_MULTI(evnt_flags&,1,1,1,0,0,0,0,0,0,0,0,0,0,0,time&,mx&,my&,mb&,ks&,key&,mc&)
    IF BTST(event&,0)
      @handle_keypress(ks&,key&)
    ENDIF
    IF BTST(event&,1)
      @main_loop_mouse(mx&,my&,mb&,ks&,key&,mc&)
    ENDIF
    IF BTST(event&,4)
      @main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
    ENDIF
  LOOP UNTIL BTST(event&,5)
RETURN
> FUNCTION fileselector$(title$,path$,file$,path_only!,abbruch$)                   !call
  LOCAL error&,button&,aes&
  LOCAL wx&,wy&,ww&,wh&,fx&,fy&,fw&,fh&,h&
  LET aes&=INT{{GB+4}}
  IF (aes&>=&H140 AND aes&<&H200) OR aes&>=&H300 OR @fsel_cookie<>0
    title$=LEFT$(title$,30)+CHR$(0)         ! Titel
    path$=path$+CHR$(0)+SPACE$(400)
    file$=file$+CHR$(0)+SPACE$(150)
    GCONTRL(0)=91
    GCONTRL(1)=0
    GCONTRL(2)=2
    GCONTRL(3)=3
    GCONTRL(4)=0
    ADDRIN(0)=V:path$     ! Pfad
    ADDRIN(1)=V:file$     ! Datei
    ADDRIN(2)=V:title$        ! Titel
    GEMSYS
    path$=CHAR{V:path$}   ! Pfad
    file$=CHAR{V:file$}   ! Dateiname
    LET button&=GINTOUT(1)         ! Abbruch=0, OK=1
    LET error&=GINTOUT(0)     ! Fehlercode
  ELSE
    ~WIND_GET(0,4,wx&,wy&,ww&,wh&)
    LET fw&=324
    IF wh&<350
      LET fh&=156
    ELSE
      LET fh&=308
    ENDIF
    LET fx&=PRED(SUB(ww&,fw&)\2)
    LET fy&=PRED(SUB(wh&,fh&)\2)
    LET title$=" "+LEFT$(title$,30)+" "+CHR$(0)
    LET h&=WIND_CREATE(1,fx&,fy&,fw&,wy&)
    IF h&<>0
      ~WIND_SET(h&,2,WORD(SHR(V:title$,16)),WORD(V:title$),0,0)
      ~WIND_OPEN(h&,fx&,fy&,fw&,wy&)
    ENDIF
    error&=FSEL_INPUT(path$,file$,button&)
    IF h&<>0
      ~WIND_CLOSE(h&)
      ~WIND_DELETE(h&)
    ENDIF
  ENDIF
  IF button&=1 AND error&<>0
    IF path_only!
      RETURN LEFT$(path$,RINSTR(path$,"\"))
    ELSE
      IF file$<>""
        RETURN LEFT$(path$,RINSTR(path$,"\"))+file$
      ELSE
        RETURN ""
      ENDIF
    ENDIF
  ELSE
    RETURN abbruch$
  ENDIF
ENDFUNC
> FUNCTION file_drive$(file$)                                             !call
  RETURN LEFT$(file$,INSTR(file$,":"))
ENDFUNC
> FUNCTION file_path$(file$)                                              !call
  LOCAL doppelpunkt&,backslash&
  LET backslash&=RINSTR(file$,"\")
  IF backslash&
    RETURN LEFT$(file$,backslash&)
  ELSE
    LET doppelpunkt&=INSTR(file$,":")
    RETURN LEFT$(file$,doppelpunkt&)
  ENDIF
ENDFUNC
> FUNCTION file_name$(file$)                                              !call
  LOCAL backslash&,punkt&,doppelpunkt&
  LET backslash&=RINSTR(file$,"\")
  IF backslash&
    LET file$=MID$(file$,SUCC(backslash&))
  ELSE
    LET doppelpunkt&=INSTR(file$,":")
    LET file$=MID$(file$,SUCC(doppelpunkt&))
  ENDIF
  LET punkt&=RINSTR(file$,".")
  IF punkt&
    RETURN LEFT$(file$,PRED(punkt&))
  ELSE
    RETURN file$
  ENDIF
ENDFUNC
> FUNCTION file_ext$(file$)                                               !call
  LOCAL backslash&,punkt&
  LET backslash&=RINSTR(file$,"\")
  LET punkt&=RINSTR(file$,".")
  IF punkt&>backslash&
    RETURN MID$(file$,SUCC(punkt&))
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
> FUNCTION act_drv$                                                       !call
  RETURN CHR$(ADD(GEMDOS(25),65))
ENDFUNC
> FUNCTION act_path$                                                      !call
  RETURN CHR$(ADD(GEMDOS(25),65))+":"+DIR$(GEMDOS(25)+1)+"\"
ENDFUNC
> PROCEDURE rsc_ob_hide(tree&,object&,flag!)                              !call
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF flag!
    OB_FLAGS(tree%,object&)=BSET(OB_FLAGS(tree%,object&),7)
  ELSE
    OB_FLAGS(tree%,object&)=BCLR(OB_FLAGS(tree%,object&),7)
  ENDIF
RETURN
> PROCEDURE win_keyb_scroll(index&,handle&,ks&,key&)                      !call
  LOCAL m4&,scroll!,old_keyb&
  LET old_keyb&=WORD(GEMDOS(340,&HC,L:&H484,L:0))
  IF old_keyb&<0
    LET old_keyb&=PEEK(&H484)
  ENDIF
  IF GEMDOS(340,&HF,L:&H484,L:BCLR(old_keyb&,1))<>-36
    SPOKE &H484,BCLR(old_keyb&,1)
  ENDIF
  CLR scroll!
  SELECT BYTE(SHR(key&,8))
  CASE 71               !clr/home
    IF ks& AND &X11
      @aes_internal_message(25,handle&,1000,0,0,0)
      @aes_internal_message(26,handle&,1000,0,0,0)
    ELSE
      @aes_internal_message(25,handle&,0,0,0,0)
      @aes_internal_message(26,handle&,0,0,0,0)
    ENDIF
  CASE 72               !up arrow
    scroll!=TRUE
    IF ks& AND &X11
      m4&=0
    ELSE
      m4&=2
    ENDIF
  CASE 75               !left arrow
    scroll!=TRUE
    IF ks& AND &X11
      m4&=4
    ELSE
      m4&=6
    ENDIF
  CASE 77               !right arrow
    scroll!=TRUE
    IF ks& AND &X11
      m4&=5
    ELSE
      m4&=7
    ENDIF
  CASE 80               !down arrow
    scroll!=TRUE
    IF ks& AND &X11
      m4&=1
    ELSE
      m4&=3
    ENDIF
  CASE 73               ! page up
    IF ks& AND &X11
      @aes_internal_message(26,handle&,0,0,0,0)
    ELSE
      scroll!=TRUE
      m4&=0
    ENDIF
  CASE 81               ! page down
    IF ks& AND &X11
      @aes_internal_message(26,handle&,1000,0,0,0)
    ELSE
      scroll!=TRUE
      m4&=1
    ENDIF
  ENDSELECT
  IF scroll!
    @aes_internal_message(24,handle&,m4&,0,0,0)
  ENDIF
  IF GEMDOS(340,&HF,L:&H484,L:old_keyb&)<>-36
    SPOKE &H484,old_keyb&
  ENDIF
RETURN
' GEMDOS-Dateifunktionen
> FUNCTION pdomain(wert&)
  $F%
  ' wert=1 ein
  ' wert=0 aus
  ' wert=-1 Status
  RETURN GEMDOS(281,wert&)
ENDFUNC
> FUNCTION f_open(a$)
  $F%
  '
  ' OPEN "I"
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(61,L:V:a$,0)
ENDFUNC
> FUNCTION f_create(a$)
  $F%
  '
  ' OPEN "O"
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(60,L:V:a$,0)
ENDFUNC
> FUNCTION f_update(a$)
  $F%
  '
  ' OPEN "U"
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(61,L:V:a$,2)
ENDFUNC
> FUNCTION f_input$(fh&,unix!)
  '  $F%
  LOCAL a$,neu$
  LOCAL pos1&,pos2&,pos&
  '
  IF unix!=FALSE
    b$=CHR$(13)+CHR$(10)    ! Linefeed 1
    c$=CHR$(10)+CHR$(13)    ! Linefeed 2
  ENDIF
  IF unix!=TRUE
    b$=CHR$(10)     ! Linefeed 3 Unixzeilenden
  ENDIF
  '
  REPEAT
    LET neu$=SPACE$(80)
    LET neu$=LEFT$(neu$,GEMDOS(63,fh&,L:80,L:V:neu$))
    LET a$=a$+neu$
    IF unix!=FALSE
      LET pos1&=INSTR(a$,b$)
      LET pos2&=INSTR(a$,c$)
    ELSE IF unix!=TRUE
      LET pos1&=INSTR(a$,b$)
    ENDIF
    IF pos1&=0
      LET pos&=pos2&
    ELSE IF pos2&=0
      LET pos&=pos1&
    ELSE
      LET pos&=MIN(pos1&,pos2&)
    ENDIF
  UNTIL pos&<>0 OR LEN(neu$)=0
  IF pos&>0
    IF unix!=FALSE
      ~GEMDOS(66,L:SUCC(SUB(pos&,LEN(a$))),fh&,1)
    ELSE IF unix!=TRUE
      ~GEMDOS(66,L:SUCC(SUB(PRED(pos&),LEN(a$))),fh&,1)
    ENDIF
    LET a$=LEFT$(a$,PRED(pos&))
  ENDIF
  RETURN a$
ENDFUNC
> FUNCTION f_println(fh&,a$,unix!)
  $F%
  '
  ' PRINT #1,a$
  '
  IF unix!=FALSE
    a$=a$+CHR$(13)+CHR$(10)
  ELSE IF unix!=TRUE
    a$=a$+CHR$(10)
  ENDIF
  '
  RETURN GEMDOS(64,fh&,L:LEN(a$),L:V:a$)
ENDFUNC
> FUNCTION exist(f$,i|)                    ! i|=16: nur Ordner,
  '                                      ! i|= 8: nur Diskname,
  ' EXIST()                              ! i|=39: alle anderen Namen
  '                                      ! i|=63: alle Namen
  f$=f$+CHR$(0)                          ! Nullbyte anh„ngen
  ~FSETDTA(BASEPAGE+128)
  RETURN GEMDOS(78,L:V:f$,i|)
ENDFUNC
> FUNCTION f_bload(file$,adr%)
  $F%
  LOCAL fh&,lof%,pos%
  '
  ' BLOAD file$,adr%
  '
  file$=file$+CHR$(0)
  '
  ~GRAF_MOUSE(2,0)
  '
  fh&=GEMDOS(61,L:V:file$,0)      ! f_open
  IF fh&>0
    '
    pos%=GEMDOS(66,L:0,fh&,1)     ! LOC(#1)
    lof%=GEMDOS(66,L:0,fh&,2)     ! f_seek(LOF(#1))
    ~GEMDOS(66,L:pos%,fh&,0)      ! f_seek(LOC(#1))
    '
    ~GEMDOS(63,fh&,L:lof%,L:adr%) ! f_read
    ~GEMDOS(62,fh&)               ! f_close
    '
  ENDIF
  '
  ~GRAF_MOUSE(0,0)
  '
  RETURN lof%                     ! L„nge der Datei
ENDFUNC
> FUNCTION f_bsave(file$,adr%,lof%)
  $F%
  LOCAL fh&
  '
  ' BSAVE file$,adr%,lof%
  '
  file$=file$+CHR$(0)
  '
  ~GRAF_MOUSE(2,0)
  '
  fh&=GEMDOS(60,L:V:file$,0)      ! f_create
  IF fh&>0
    '
    ~GEMDOS(64,fh&,L:lof%,L:adr%) ! f_write
    ~GEMDOS(62,fh&)               ! f_close
    '
  ENDIF
  '
  ~GRAF_MOUSE(0,0)
  '
  RETURN fh&
ENDFUNC
> FUNCTION f_lof(fh&)
  $F%
  LOCAL pos%,lof%
  '
  ' LOF(#1)
  '
  pos%=GEMDOS(66,L:0,fh&,1)                       ! LOC(#1)
  lof%=GEMDOS(66,L:0,fh&,2)                       ! SEEK #1,LOF(#1)
  '
  ~GEMDOS(66,L:pos%,fh&,0)                        ! SEEK #1,LOC(#1)
  '
  RETURN lof%
ENDFUNC
> FUNCTION f_eof(fh&)
  $F%
  LOCAL pos%,lof%
  '
  ' EOF(#1)
  '
  pos%=GEMDOS(66,L:0,fh&,1)                       ! LOC(#1)
  lof%=GEMDOS(66,L:0,fh&,2)                       ! SEEK #1,LOF(#1)
  '
  ~GEMDOS(66,L:pos%,fh&,0)                        ! SEEK #1,LOC(#1)
  '
  RETURN pos%>=lof%                               ! EOF(#1)
ENDFUNC
> FUNCTION f_close(fh&)
  $F%
  RETURN GEMDOS(62,fh&)
ENDFUNC
'
> FUNCTION fchmod(a$,mode#)
  $F%
  a$=a$+CHR$(0)
  RETURN GEMDOS(306,L:V:a$,mode#)
ENDFUNC
' GEMDOS-Verzeichnisfunktionen
> FUNCTION akt_drv$
  '
  ' Erstellt am ??.??.???? von Holger Herzog
  '
  ' Version 1.0
  '
  ' Gibt den Buchstaben des aktuellen Laufwerks zurck.
  '
  '    @akt_pfad$()     <== akt. Pfad
  '
  ' Version 1.0         ??.??.???? Holger Herzog
  '
  RETURN CHR$(ADD(GEMDOS(25),65))
ENDFUNC
> FUNCTION akt_pfad$
  '
  ' Erstellt am ??.??.???? von Holger Herzog
  '
  ' Version 1.01
  '
  ' Gibt den aktuellen Zugriffspfad zurck.
  '
  '    @akt_pfad$()     <== akt. Pfad
  '
  ' Version 1.0         ??.??.???? Holger Herzog
  ' Version 1.01        06.09.1996 Holger Herzog
  '                     Aktuelles Laufwerk nicht mehr ber @akt_drv
  '
  RETURN CHR$(ADD(GEMDOS(25),65))+":"+DIR$(0)+"\"
ENDFUNC
> FUNCTION exist_ordner(ordner$)
  $F%
  ' gibt TRUE zurck, falls ein bestimmter Ordner exisiert
  ' Aufrufbeispiel: IF @exist_ordner("C:\WORDPLUS")=TRUE
  ~FSETDTA(BASEPAGE+128)             ! Setzen der Disktransferadresse
  ' Dateisuche mit gesetztem Ordnerbit,
  IF FSFIRST(ordner$+CHR$(0),&X10000)=0
    RETURN TRUE                      ! findet aber auch normale Dateien
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
> FUNCTION dsetdrv(drv$)
  '
  drv%=ASC(drv$)-65
  error%=GEMDOS(14,drv%)
  RETURN error%
ENDFUNC
> FUNCTION dsetpath(path$)
  '
  path$=path$+CHR$(0)
  error%=GEMDOS(59,L:V:path$)
  RETURN error%
ENDFUNC
> FUNCTION f_kill(a$)
  $F%
  '
  ' KILL a$
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(65,L:V:a$)
ENDFUNC
> FUNCTION f_rmdir(a$)
  $F%
  '
  ' RMDIR a$
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(58,L:V:a$)
ENDFUNC
> FUNCTION f_mkdir(a$)
  $F%
  '
  ' MKDIR a$
  '
  a$=a$+CHR$(0)
  '
  RETURN GEMDOS(57,L:V:a$)
ENDFUNC
> PROCEDURE rsc_ob_flags(tree&,object&,number&,flag!)                     !call
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF flag!
    OB_FLAGS(tree%,object&)=BSET(OB_FLAGS(tree%,object&),number&)
  ELSE
    OB_FLAGS(tree%,object&)=BCLR(OB_FLAGS(tree%,object&),number&)
  ENDIF
RETURN
> PROCEDURE rsc_ob_state(tree&,object&,number&,flag!)                     !call
  LOCAL tree%
  tree%=@xrsrc_gaddr(0,tree&)
  IF flag!
    OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),number&)
  ELSE
    OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),number&)
  ENDIF
RETURN
> PROCEDURE set_cursor(index&,object&)                                    !call
  IF BTST(OB_FLAGS(window_tree%(index&,0),object&),3) AND NOT BTST(OB_STATE(window_tree%(index&,0),object&),3)
    ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
    window_array&(index&,2)=object&
    window_array&(index&,3)=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),object&)}})
    @cursor_on(index&)
  ENDIF
RETURN
> PROCEDURE rsc_ob_reset(tree&,ob&)                                       !call
  LOCAL index&
  LOCAL top_handle&,d&
  ~WIND_GET(0,10,top_handle&,d&,d&,d&)
  @rsc_setup_tree(tree&)
  FOR index&=0 TO max_number_windows&
    IF window_array&(index&,0)>0
      IF tree&=window_array&(index&,4)
        @aes_screen_lock_only_screen
        IF top_handle&=window_array&(index&,0) AND window_array&(index&,2)<>0
          ~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
        ENDIF
        @rsc_ob_draw(index&,ob&)
        IF top_handle&=window_array&(index&,0) AND window_array&(index&,2)<>0
          @cursor_on(index&)
        ENDIF
        @aes_screen_unlock_only_screen
      ENDIF
    ENDIF
  NEXT index&
RETURN
> PROCEDURE messagewin_open(title$,maxlines%,x&,y&,w&,h&,icfyicon&)         !call
  '
  ' Version 1.1  03.03.1998  Holger Herzog
  '
  LET messagewin_userhandle_&=-2551   ! +SYM
  '
  IF messagewin_windowhandle_&<>0
    @messagewin_close
  ENDIF
  '
  LET messagewin_maxline_%=PRED(maxlines%)
  DIM messagewin_$(messagewin_maxline_%),messagewin_selected_!(messagewin_maxline_%)
  LET messagewin_entries_%=0
  '
  LET messagewin_windowhandle_&=@textlist_win_open(title$,"",0,0,-1,messagewin_userhandle_&,x&,y&,w&,h&,icfyicon&,messagewin_entries_%,messagewin_$())
  IF messagewin_windowhandle_&=0
    ERASE messagewin_$(),messagewin_selected_!()
  ENDIF
  '
RETURN
> PROCEDURE messagewin_print(line$)                                         !call
  '
  ' Version 1.0  03.03.1998  Holger Herzog
  '
  LOCAL index&
  '
  IF messagewin_windowhandle_&<>0
    '
    LET index&=@win_get_index(messagewin_windowhandle_&)
    '
    IF messagewin_entries_%>messagewin_maxline_%
      DELETE messagewin_$(0)
      @win_move_content(index&,0,window_array&(index&,10),0,0,window_array%(index&,0),SUB(window_array%(index&,1),window_array&(index&,10)))
    ELSE
      INC messagewin_entries_%
    ENDIF
    '
    LET messagewin_$(PRED(messagewin_entries_%))=line$
    @textlist_redraw(index&,PRED(messagewin_entries_%))
    '
    @textlist_resize(index&,messagewin_entries_%,messagewin_$())
    @win_set_offset(index&,-1,-2)
    '
  ENDIF
  '
RETURN
> PROCEDURE messagewin_close                                                !call
  '
  ' Version 1.0  03.03.1998  Holger Herzog
  '
  @win_close(messagewin_windowhandle_&)
  CLR messagewin_windowhandle_&
  ERASE messagewin_$(),messagewin_selected_!()
  '
RETURN
> FUNCTION textlist_win_open(title$,info$,mode&,tool&,tree&,userhandle&,x&,y&,w&,h&,iconify&,num%,VAR list$())       ! call
  $F%
  '
  ' Version 1.0  30.03.1997  Holger Herzog
  ' Version 1.2  17.03.1998  Holger Herzog
  '              32-Bit windowengine
  '
  LOCAL totw%,toth%
  LOCAL scrlstep&
  LOCAL kind%
  LOCAL handle&
  LOCAL info!
  '
  ' *** Fenstergr”že errechnen ***
  '
  LET info!=(info$<>"")
  LET kind%=@win_kind_create(mode&,tool&,tree&,info!,TRUE,FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,1,TRUE)
  '
  IF x&=(-1) AND y&=(-1) AND w&=(-1) AND h&=(-1)
    ~WIND_GET(0,4,x&,y&,w&,h&)                       ! Desktopgr”že ermitteln
  ENDIF
  '
  LET scrlstep&=@textlist_scrlstep_get
  LET totw%=@textlist_totw_get(num%,scrlstep&,list$())
  LET toth%=@textlist_toth_get(num%)
  '
  ' *** Fenster ”ffnen ***
  '
  LET handle&=@win_open(title$,info$,kind%,tree&,totw%,toth%,@textlist_font_width,scrlstep&,userhandle&,x&,y&,w&,h&,iconify&)
  '
  RETURN handle&
  '
ENDFUNC
> PROCEDURE textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,VAR list$(),selected!())
  '
  ' Version 1.1  27.01.1997  Holger Herzog
  ' Version 1.2  29.03.1997  Holger Herzog
  '              some fixes
  ' Version 1.3  17.03.1998 Holger Herzog
  '              32-Bit windowengine
  '
  LOCAL line%,font_h&
  LOCAL xlauf%,xend%,ylauf%,yend%
  LOCAL startline%,endline%
  LOCAL len&,col&,cols&
  LOCAL wx&,wy&,ww&,wh&
  LOCAL x%,y%,w&,h&
  LOCAL text$
  '
  @win_get_workarea(index&,wx&,wy&,ww&,wh&)
  '
  IF RC_INTERSECT(wx&,wy&,ww&,wh&,cx&,cy&,cw&,ch&)
    '
    ' *** Textausrichtung ***
    '
    INTIN(0)=0
    INTIN(1)=5
    CONTRL(0)=39
    CONTRL(1)=0
    CONTRL(3)=2
    CONTRL(6)=V~H
    VDISYS
    '
    LET font_h&=@textlist_font_height
    LET x%=ADD(SUB(cx&,wx&),off_x%)
    LET y%=ADD(SUB(cy&,wy&),off_y%)
    LET w&=cw&
    LET h&=ch&
    LET startline%=y% DIV font_h&
    LET endline%=MIN(PRED(num%),PRED(ADD(y%,h&)) DIV font_h&)
    LET xend%=ADD(wx&,ADD(off_x%,ww&))
    LET yend%=ADD(wy&,ADD(off_y%,wh&))
    '
    GRAPHMODE 1
    BOUNDARY 0
    DEFFILL 0,1
    '
    IF FRE()<4096
      ~FRE(0)
    ENDIF
    '
    LET ylauf%=SUB(MUL(startline%,font_h&),off_y%)
    FOR line%=startline% TO endline%
      LET xlauf%=SUB(0,off_x%)
      LET len&=LEN(list$(line%))
      LET col&=1
      WHILE col&<=len&
        LET cols&=MIN(80,SUCC(SUB(len&,col&)))
        LET text$=MID$(list$(line%),col&,cols&)
        TEXT xlauf%,ylauf%,text$
        ~VQT_EXTENT(text$)
        ADD xlauf%,PTSOUT(2)
        ADD col&,cols&
      WEND
      IF xlauf%<xend%
        PBOX xlauf%,ylauf%,xend%,PRED(ADD(ylauf%,font_h&))
      ENDIF
      IF selected!(line%)
        GRAPHMODE 3
        DEFFILL 1,1
        PBOX 0,ylauf%,xend%,PRED(ADD(ylauf%,font_h&))
        GRAPHMODE 1
        DEFFILL 0,1
      ENDIF
      ADD ylauf%,font_h&
    NEXT line%
    '
    IF ylauf%<yend%
      DEFFILL 0,1
      PBOX 0,ylauf%,xend%,yend%
    ENDIF
    '
  ENDIF
  '
RETURN
> FUNCTION textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,VAR selected!(),hash&())    !call
  $F%
  '
  ' Version 1.0  25.09.1996  Holger Herzog
  ' Version 1.1  29.03.1997  Holger Herzog
  '              new: dd!-flag, some changes
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  LOCAL wx&,wy&,ww&,wh&
  LOCAL mw&,mh&,dummy&
  LOCAL line%,font_h&
  LOCAL ret&,select!,shift!
  LOCAL i%
  LOCAL dx&,dy&,dw&,dh&
  LOCAL sx&,sy&
  LOCAL dest&
  '
  LET ret&=-1                   ! returnvalue
  LET font_h&=@textlist_font_height
  '
  @aes_screen_lock
  '
  IF BTST(mb&,0)
    '
    ' *** leftclick ***
    '
    LET shift!=(AND(ks&,&X11)<>0)     ! shift
    '
    ' *** get window-workarea ***
    '
    LET mw&=1
    LET mh&=1
    @win_get_workarea(index&,wx&,wy&,ww&,wh&)
    '
    ' +++ mouse in window? +++
    '
    IF RC_INTERSECT(wx&,wy&,ww&,wh&,mx&,my&,mw&,mh&)
      '
      LET line%=ADD(window_array%(index&,3),SUB(my&,wy&)) DIV font_h&
      '
      IF line%=>0 AND line%<num%
        '
        ' +++ mouse-pos on a selectable line? +++
        '
        IF hash&(line%)=>0
          '
          LET select!=NOT selected!(line%)
          '
          ' +++ drag&drop? +++
          '
          ~EVNT_MULTI(&X100010,1,1,0,0,0,0,0,0,0,0,0,0,0,0,150)
          ~GRAF_MKSTATE(mx&,my&,mb&,ks&)
          LET dd!=dd! AND BTST(mb&,0)
          '
          IF NOT (shift! OR (dd! AND (NOT select!)))
            '
            ' +++ deselect all +++
            '
            FOR i%=0 TO PRED(num%)
              IF selected!(i%) AND i%<>line%
                LET selected!(i%)=FALSE
                @textlist_redraw(index&,i%)
              ENDIF
            NEXT i%
          ENDIF
          '
          LET select!=select! OR dd!
          '
          IF mc&>1                        ! doubleclick
            LET ret&=hash&(line%)
            LET select!=TRUE
          ELSE
            LET ret&=-1
          ENDIF
          '
          ' +++ (de)select current line if necc. +++
          '
          IF selected!(line%)<>select!
            LET selected!(line%)=select!
            @textlist_redraw(index&,line%)
          ENDIF
          '
          ' *** drag&drop? **
          '
          IF dd!
            '
            ' +++ long click => drag&drop +++
            '
            ~WIND_GET(0,4,dx&,dy&,dw&,dh&)
            ~GRAF_DRAGBOX(MUL(font_h&,6),font_h&,SUB(mx&,MUL(font_h&,3)),SUB(my&,SUB(my&,wy&) MOD font_h&),dx&,dy&,dw&,dh&,sx&,sy&)
            '
            LET dest&=@win_get_index(WIND_FIND(sx&,sy&))
            IF dest&=>0
              @win_get_workarea(dest&,wx&,wy&,ww&,wh&)
              SUB sx&,wx&
              SUB sy&,wy&
              @user_textlist_dragdrop(index&,dest&,sx&,sy&)
            ELSE
              OUT 2,7
            ENDIF
            '
          ENDIF
          '
        ELSE            ! sizebox
          '
          ' not implemented, yet
          '
          OUT 2,7
          '
        ENDIF
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  REPEAT
    ~GRAF_MKSTATE(mx&,my&,mb&,dummy&)
  UNTIL mb&=0
  '
  '
  WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
  WEND
  WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
  WEND
  @aes_screen_unlock
  '
  RETURN ret&
  '
ENDFUNC
> PROCEDURE textlist_redraw(index&,line%)                                 !call
  '
  ' Version 1.0         23.09.1996 Holger Herzog
  ' Version 1.1         29.03.1997 Holger Herzog
  '                     Fix: font_h had to be 16
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  LOCAL wx&,wy&,ww&,wh&
  LOCAL lx&,ly&,lw&,lh&,ly%
  LOCAL font_h&
  '
  @win_get_workarea(index&,wx&,wy&,ww&,wh&)
  LET font_h&=@textlist_font_height
  '
  LET lx&=wx&
  LET ly%=ADD(wy&,SUB(MUL(line%,font_h&),window_array%(index&,3)))
  LET ly&=WORD(ly%)
  LET lw&=ww&
  LET lh&=font_h&
  '
  IF ly%=ly&
    IF RC_INTERSECT(wx&,wy&,ww&,wh&,lx&,ly&,lw&,lh&)
      @redraw_userwindow(window_array&(index&,0),lx&,ly&,lw&,lh&)
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE textlist_resize(index&,num%,VAR list$())              !call
  '
  ' Version 1.0  31.03.1997  Holger Herzog
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  LOCAL totw%,toth%
  LOCAL scrlstep&
  '
  LET scrlstep&=@textlist_scrlstep_get
  LET totw%=@textlist_totw_get(num%,scrlstep&,list$())
  LET toth%=@textlist_toth_get(num%)
  '
  @win_change_size(index&,totw%,toth%,@textlist_font_width,scrlstep&,FALSE)
  '
RETURN
> FUNCTION textlist_totw_get(num%,scrlstep&,VAR list$())
  $F%
  '
  ' Version 1.0  30.03.1997  Holger Herzog
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  LOCAL totw%,line%
  '
  CLR totw%
  '
  FOR line%=0 TO PRED(num%)
    LET totw%=MAX(totw%,@textlist_text_width(list$(line%)))
  NEXT line%
  '
  LET totw%=MUL(SUCC(PRED(totw%) DIV scrlstep&),scrlstep&)
  '
  RETURN totw%
  '
ENDFUNC
> FUNCTION textlist_toth_get(num%)
  $F%
  '
  ' Version 1.0  30.03.1997  Holger Herzog
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  RETURN MUL(num%,@textlist_font_height)
  '
ENDFUNC
> FUNCTION textlist_scrlstep_get
  $F%
  '
  ' Version 1.0  30.03.1997  Holger Herzog
  '
  RETURN @textlist_font_height
  '
ENDFUNC
> FUNCTION textlist_font_width
  $F%
  '
  ' Version 1.0  27.01.1997  Holger Herzog
  ' Version 1.1  31.03.1997  Holger Herzog
  '
  CONTRL(0)=131
  CONTRL(1)=0
  CONTRL(3)=0
  VDISYS
  RETURN PTSOUT(0)
ENDFUNC
> FUNCTION textlist_font_height
  $F%
  '
  ' Version 1.0  27.01.1997  Holger Herzog
  ' Version 1.1  31.03.1997  Holger Herzog
  '
  CONTRL(0)=131
  CONTRL(1)=0
  CONTRL(3)=0
  VDISYS
  RETURN SUCC(ADD(PTSOUT(1),PTSOUT(9)))
ENDFUNC
> FUNCTION textlist_text_width(text$)
  $F%
  '
  ' Version 1.0  27.01.1997  Holger Herzog
  ' Version 1.1  31.03.1997  Holger Herzog
  ' Version 1.2         17.03.1998 Holger Herzog
  '                     32-Bit windowengine
  '
  LOCAL w%,len&,pos&,act&
  CLR w%
  LET pos&=1
  LET len&=LEN(text$)
  '
  WHILE len&>0
    LET act&=MIN(110,len&)
    ~VQT_EXTENT(MID$(text$,pos&,act&))
    ADD w%,PTSOUT(2)
    SUB len&,act&
    ADD pos&,act&
  WEND
  '
  RETURN w%
ENDFUNC
