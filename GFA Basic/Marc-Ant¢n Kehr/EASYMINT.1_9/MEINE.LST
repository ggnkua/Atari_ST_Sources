> PROCEDURE my_init
  INLINE xhdi_call%,134
  '
  '
  DIM newdesk$(300),ttytab$(200),package$(5)
  '
  @init_gemdos_var                                   ! Konstanten belegen und
  '
  em_start_pfad$=@akt_pfad$   ! Pfad aus dem EASYMINT.PRG gestartet wurde
  '
  install_path$="c:\easymint" ! Pfad wo die TemporÑrdateien hinterlegt werden.
  IF @exist(install_path$,16)=-33
    ~@f_mkdir(install_path$)
  ENDIF
  '
  @language_load
  '
  ' Version hier setzen wegen Manipulationsgefahr
  '
  version1$="EasyMiNT"
  version2$="The easy MiNT distribution"
  version3$="v 1.65 07/18/07"
  version4$="(faceValue 3.2 RunLib)"
  version5$="Copyright 2001-2006"
  @rsc_set_text(about&,version1&,version1$)
  @rsc_set_text(about&,version2&,version2$)
  @rsc_set_text(about&,version3&,version3$)
  @rsc_set_text(about&,version4&,version4$)
  @rsc_set_text(about&,version5&,version5$)
  '
  mw_x&=5
  mw_y&=5
  mw_b&=620
  mw_h&=400
  '
  IF @exist(install_path$+"\tmp",63)=-33
    ~@f_mkdir(install_path$+"\tmp")
  ENDIF
  '
RETURN
> PROCEDURE language_load
  LOCAL fiha&
  IF @exist("language.lng",63)=0 OR @exist("LANGUAGE.LNG",63)=0
    fiha&=@f_open("language.lng")
    dummy$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Statusfenster
    status_win$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Versionsinfo
    version1$=@f_input$(fiha&,FALSE)
    version2$=@f_input$(fiha&,FALSE)
    version3$=@f_input$(fiha&,FALSE)
    version4$=@f_input$(fiha&,FALSE)
    version5$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Info0 Box
    info0_1$=@f_input$(fiha&,FALSE)
    info0_2$=@f_input$(fiha&,FALSE)
    info0_3$=@f_input$(fiha&,FALSE)
    info0_4$=@f_input$(fiha&,FALSE)
    info0_5$=@f_input$(fiha&,FALSE)
    info0_6$=@f_input$(fiha&,FALSE)
    info0_7$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert1
    alert1_1$=@f_input$(fiha&,FALSE)
    alert1_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 1
    mw1_1$=@f_input$(fiha&,FALSE)
    mw1_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 2
    mw2_1$=@f_input$(fiha&,FALSE)
    mw2_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' name1
    LET name1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert2
    alert2_1$=@f_input$(fiha&,FALSE)
    alert2_2$=@f_input$(fiha&,FALSE)
    alert2_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' compauswert
    ca_1$=@f_input$(fiha&,FALSE)
    ca_2$=@f_input$(fiha&,FALSE)
    ca_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Boot Info
    bi_1$=@f_input$(fiha&,FALSE)
    bi_2$=@f_input$(fiha&,FALSE)
    bi_3$=@f_input$(fiha&,FALSE)
    bi_4$=@f_input$(fiha&,FALSE)
    bi_5$=@f_input$(fiha&,FALSE)
    bi_6$=@f_input$(fiha&,FALSE)
    bi_7$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 3
    mw3_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 4
    mw4_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 5
    mw5_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 6
    mw6_1$=@f_input$(fiha&,FALSE)
    mw6_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 7
    mw7_1$=@f_input$(fiha&,FALSE)
    mw7_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 8
    mw8_1$=@f_input$(fiha&,FALSE)
    mw8_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 9
    mw9_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 10
    mw10_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Laufwerk wÑhlen 1
    '    chooselw1_1$=@f_input$(fiha&,FALSE)
    '    chooselw1_2$=@f_input$(fiha&,FALSE)
    '    chooselw1_3$=@f_input$(fiha&,FALSE)
    '    chooselw1_4$=@f_input$(fiha&,FALSE)
    '    dummy$=@f_input$(fiha&,FALSE)
    ' Alert3
    alert3_1$=@f_input$(fiha&,FALSE)
    alert3_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Kaltstart Info
    cb_1$=@f_input$(fiha&,FALSE)
    cb_2$=@f_input$(fiha&,FALSE)
    cb_3$=@f_input$(fiha&,FALSE)
    cb_4$=@f_input$(fiha&,FALSE)
    cb_5$=@f_input$(fiha&,FALSE)
    cb_6$=@f_input$(fiha&,FALSE)
    cb_7$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert4
    alert4_1$=@f_input$(fiha&,FALSE)
    alert4_2$=@f_input$(fiha&,FALSE)
    alert4_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert5
    alert5_1$=@f_input$(fiha&,FALSE)
    alert5_2$=@f_input$(fiha&,FALSE)
    alert5_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert6
    alert6_1$=@f_input$(fiha&,FALSE)
    alert6_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert7
    alert7_1$=@f_input$(fiha&,FALSE)
    alert7_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Name2
    LET name2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 11
    mw11_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert8
    alert8_1$=@f_input$(fiha&,FALSE)
    alert8_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 12
    mw12_1$=@f_input$(fiha&,FALSE)
    mw12_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 13
    mw13_1$=@f_input$(fiha&,FALSE)
    mw13_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 14
    mw14_1$=@f_input$(fiha&,FALSE)
    mw14_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 15
    mw15_1$=@f_input$(fiha&,FALSE)
    mw15_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert9
    alert9_1$=@f_input$(fiha&,FALSE)
    alert9_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' NAES Info
    naes_1$=@f_input$(fiha&,FALSE)
    naes_2$=@f_input$(fiha&,FALSE)
    naes_3$=@f_input$(fiha&,FALSE)
    naes_4$=@f_input$(fiha&,FALSE)
    naes_5$=@f_input$(fiha&,FALSE)
    naes_6$=@f_input$(fiha&,FALSE)
    naes_7$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 16
    mw16_1$=@f_input$(fiha&,FALSE)
    mw16_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 17
    mw17_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Name3
    LET name3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 18
    mw18_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert10
    alert10_1$=@f_input$(fiha&,FALSE)
    alert10_2$=@f_input$(fiha&,FALSE)
    alert10_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert11
    alert11_1$=@f_input$(fiha&,FALSE)
    alert11_2$=@f_input$(fiha&,FALSE)
    alert11_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 19
    mw19_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 20
    mw20_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Name4
    LET name4$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 21
    mw21_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 22
    mw22_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Name5
    LET name5$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 23
    mw23_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 24
    mw24_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 25
    mw25_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 26
    mw26_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 27
    mw27_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 28
    mw28_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' NAES Info
    ende_1$=@f_input$(fiha&,FALSE)
    ende_2$=@f_input$(fiha&,FALSE)
    ende_3$=@f_input$(fiha&,FALSE)
    ende_4$=@f_input$(fiha&,FALSE)
    ende_5$=@f_input$(fiha&,FALSE)
    ende_6$=@f_input$(fiha&,FALSE)
    ende_7$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert12
    alert12_1$=@f_input$(fiha&,FALSE)
    alert12_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert13
    alert13_1$=@f_input$(fiha&,FALSE)
    alert13_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    ' messagewin 29
    mw29_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 30
    mw30_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' messagewin 31
    mw31_1$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    ' ab Version 1.4
    ' Alert14
    alert14_1$=@f_input$(fiha&,FALSE)
    alert14_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert15
    alert15_1$=@f_input$(fiha&,FALSE)
    alert15_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    ' Alert16
    alert16_1$=@f_input$(fiha&,FALSE)
    alert16_2$=@f_input$(fiha&,FALSE)
    alert16_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert17_1$=@f_input$(fiha&,FALSE)
    alert17_2$=@f_input$(fiha&,FALSE)
    alert17_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert18_1$=@f_input$(fiha&,FALSE)
    alert18_2$=@f_input$(fiha&,FALSE)
    '  alert18_3$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert19_1$=@f_input$(fiha&,FALSE)
    alert19_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert20_1$=@f_input$(fiha&,FALSE)
    alert20_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert21_1$=@f_input$(fiha&,FALSE)
    alert21_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    alert22_1$=@f_input$(fiha&,FALSE)
    alert22_2$=@f_input$(fiha&,FALSE)
    dummy$=@f_input$(fiha&,FALSE)
    '
    ~@f_close(fiha&)
  ELSE
    ALERT 1,"No language.lng",1," Quit ",eing1&
    QUIT
  ENDIF
RETURN
'
> PROCEDURE file_check
  IF @exist(@akt_pfad$+"easymint.zip",63)<>0
    ALERT 1,"EASYMINT.ZIP missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
  '
  IF @exist(@akt_pfad$+"pakete\basic.tar",63)<>0
    ALERT 1,"basic.tar missing!",1," Quit ",eing%
    exit_program!=TRUE
  ELSE
    IF @exist(@akt_pfad$+"pakete\basic.lst",63)<>0
      ALERT 1,"basic.lst missing!",1," Quit ",eing%
      exit_program!=TRUE
    ENDIF
  ENDIF
  ' @file_loop("standard.tar","standard.lst")
  ' @file_loop("devel.tar","devel.lst")
  ' @file_loop("net.tar","net.lst")
  ' @file_loop("libs.tar","libs.lst")
  ' @file_loop("x11.tar","x11.lst")
  '
  IF @exist(@akt_pfad$+"unzip.ttp",63)<>0
    ALERT 1,"unzip.ttp missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
  '
  IF @exist(@akt_pfad$+"rootfs.tgz",63)<>0
    ALERT 1,"rootfs.tgz missing!",1," Quit ",eing%
    exit_program!=TRUE
  ENDIF
RETURN
> PROCEDURE file_loop(tar$,lst$)
  IF @exist(@akt_pfad$+"pakete\"+tar$,63)=0
    IF @exist(@akt_pfad$+"pakete\"+lst$,63)<>0
      ALERT 1,lst$+" missing!",1," Quit ",eing%
      exit_program!=TRUE
    ENDIF
  ENDIF
RETURN
'
' Erster Teil
'
> PROCEDURE info0                                    ! Installationspakete entpacken
  LOCAL value%,eing&
  @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
  @message(2,info0_1$,info0_2$,info0_3$,info0_4$,info0_5$,info0_6$,info0_7$)
  info0!=TRUE
RETURN
> PROCEDURE lnx_suchen
  LOCAL i&,lnx_lw&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  FOR i&=ext_c& TO ext_t&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_c&)+2))="LNX" OR UPPER$(@xhdi$((i&-ext_c&)+2))="RAW"
        '        PRINT "Laufwerk(c-t): ";CHR$(65+(i&-ext_c&+2))
        ext2_var&=PRED((i&-ext_c&+2)) ! Laufwerk in Popup vorbelegen
        INC lnx_lw&
      ENDIF
    ENDIF
  NEXT i&
  '
  FOR i&=ext_v& TO ext_6&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_v&)+2))="LNX" OR UPPER$(@xhdi$((i&-ext_v&)+2))="RAW"
        '        PRINT "Laufwerk(v-6): ";CHR$(65+(i&-ext_c&+2))
        ext2_var&=PRED((i&-ext_c&+2)) !Laufwerk in Popup vorbelegen
        INC lnx_lw&
      ENDIF
    ENDIF
  NEXT i&
  '
  IF lnx_lw&=0          ! Wenn keine LNX oder RAW Programm beenden
    ' Alert 1
    ALERT 1,alert1_1$,1,alert1_2$,eing&
    IF eing&=1
      exit_program!=TRUE
    ENDIF
  ELSE
    ' MW 1
    @messagewin_print(mw1_1$+" "+STR$(lnx_lw&)+" "+mw1_2$)
    @preinst
    info0!=FALSE
  ENDIF
RETURN
> PROCEDURE preinst
  ' Dialogvoreinstellungen
  @rsc_ob_disable(preinst&,teradesk&,TRUE)  !Teradesk Radiobutton disablen
  @rsc_ob_disable(preinst&,tdzip&,TRUE)     !Teradeskzip Pfad disablen
  @rsc_ob_disable(preinst&,xaaeszip&,TRUE)  !Xaaeszip Pfad disablen
  '
  @rsc_ob_disable(fvt_popu&,lw_u&,TRUE)     !Laufwerk U disablen
  @rsc_ob_disable(fvt_popu&,ext_u&,TRUE)    !   "     "   "
  '
  @comp_choose
  @angemeldete_lw
  @lnx_find
  '
  ' boot$=CHR$(66+lw_c_var&)
  '
  @rsc_setup_tree(preinst&)
  preinst_hdle&=@win_open_dialog(2,preinst&,-1)
RETURN
> PROCEDURE auspacken
  LOCAL dummy&,eing%,eing1&,prg$
  ' Schritt 1
  @messagewin_print(mw29_1$+" 1/6")
  '
  ' mw2
  @messagewin_print(mw2_1$)
  @messagewin_print(mw2_2$)
  '
  IF @exist(em_start_pfad$+"unzip.ttp",63)=0
    ' name1
    LET name$=name1$
    error%=@start_prg(0,em_start_pfad$+"unzip.ttp","-o "+em_start_pfad$+"easymint.zip -d "+install_path$,"",name$,install_path$+"\tmp\unzip.out",install_path$+"\tmp\unzip.err",TRUE,TRUE,TRUE)
  ELSE
    ' Alert 2
    ALERT 1,alert2_1$+" "+em_start_pfad$+alert2_2$,1,alert2_3$,eing1&
    IF eing1&=1
      exit_program!=TRUE
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE comp_choose                              ! Computer wÑhlen
  '  PRINT "Cookie: ";
  '
  IF @get_cookie("_CPU",value%)
    cpu&=value%
  ENDIF
  '
  '  PRINT "CPU: ";cpu&
  '
  IF @get_cookie("_MCH",value%)
    machine&=SWAP(value%)
    IF (machine&=0 OR machine&=1 AND cpu&=0)! ST(e)
      compi_var&=1
    ENDIF
    IF (machine&=0 OR machine&=1 AND cpu&=30)! ST mit 68030
      compi_var&=2
    ENDIF
    IF machine&=2  ! TT
      compi_var&=3
    ENDIF
    IF machine&=3 AND cpu&=30 ! Falcon
      compi_var&=4
    ENDIF
    IF machine&=3 AND cpu&=40 ! Falcon mit AB
      compi_var&=5
    ENDIF
    IF value%=&H50000 ! ARAnyM Version >= 0.8.5
      compi_var&=10
      ' ELSE              ! ARAnyM Version <0.8.5
      '  IF @get_cookie("__NF",value%)
      '  IF @is_aranym
      '      '      PRINT "This is ARAnyM"
      '  compi_var&=10
      ' ENDIF
      ' ENDIF
    ENDIF
    IF @get_cookie("MNAM",value%)
      IF CHAR{value%}="Milan"
        compi_var&=6
      ENDIF
    ENDIF
    IF @get_cookie("hade",value%)  ! Hades
      IF cpu&=40          ! mit 68040
        compi_var&=7
      ENDIF
      IF cpu&=60          ! mit 68060
        compi_var&=8
      ENDIF
      '    PRINT "Cookiewert: ";value%
      '    IF value%=&H400E
      '    PRINT "Hades"
      '  ENDIF
    ENDIF
    IF @get_cookie("MTxx",value%)
      IF cpu&=40
        compi_var&=9
      ENDIF
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE boot_info
  @message(1,bi_1$,bi_2$,bi_3$,bi_4$,bi_5$,bi_6$,bi_7$)
  boot_info!=TRUE
RETURN
> PROCEDURE xaaeszip_choose
  LOCAL datei$,xxxx$
  datei$=@fileselector$("XAAES.ZIP","","",FALSE,"")
  @evnt_multi_loop
  '
  IF @exist(datei$,63)=0
    '
    xxxx$=RIGHT$(datei$,LEN(datei$)-RINSTR(datei$,"\"))
    xaaes_version$=MID$(xxxx$,6,3)
    '
    xaaeszip_path$=datei$
    @rsc_set_txt_redraw(preinst&,xaaeszip&,preinst_hdle&,xaaeszip_path$)
  ELSE
    xaaeszip_path$=""
    '   @rsc_set_txt_redraw(preinst&,xaaeszip&,preinst_hdle&,xaaeszip_path$)
    '
  ENDIF
RETURN
> PROCEDURE tdeskzip_choose
  LOCAL datei$,xxxx$
  datei$=@fileselector$("Teradesk ZIP?","","",FALSE,"")
  @evnt_multi_loop
  '
  IF @exist(datei$,63)=0
    '
    xxxx$=RIGHT$(datei$,LEN(datei$)-RINSTR(datei$,"\"))
    teradesk_version$=MID$(xxxx$,6,3)
    '
    teradeskzip_path$=datei$
    @rsc_set_txt_redraw(preinst&,tdzip&,preinst_hdle&,teradeskzip_path$)
  ELSE
    teradeskzip_path$=""
    '    @rsc_set_txt_redraw(preinst&,tdzip&,preinst_hdle&,teradeskzip_path$)
  ENDIF
RETURN
> PROCEDURE rsc_set_txt_redraw(tree&,objekt&,t_handle&,txt$)
  LOCAL index&
  @rsc_set_text(tree&,objekt&,txt$)
  index&=@win_get_index(t_handle&)
  @rsc_ob_draw(index&,objekt&)
RETURN
> PROCEDURE redraw_object(tree&,objekt&,disable!,t_handle&)
  LOCAL index&
  @rsc_ob_disable(tree&,objekt&,disable!)
  index&=@win_get_index(t_handle&)
  @rsc_ob_draw(index&,objekt&)
RETURN
> PROCEDURE set_dateiname(hdle&,tree&,obj&,flag!)
  @rsc_set_text(tree&,obj&,"")
  @redraw_object(tree&,obj&,flag!,hdle&)
RETURN
> PROCEDURE edit_reset(index&,hdle&,tree&,obj1&,obj2&)
  '
  @rsc_ob_state(tree&,obj1&,0,FALSE)
  teradesk_var!=FALSE
  @rsc_ob_draw(index&,obj1&)
  @redraw_object(tree&,obj2&,TRUE,hdle&)
RETURN
'
> PROCEDURE kernel_copy
  LOCAL eing&,eing1&,datei$,xxxx$
  ' Schritt 2
  @messagewin_print(mw29_1$+" 2/6")
  '
  '
  DEFMOUSE 2
  '
  ' bereits vorhandene MINT.CNF umbenennen (in :\ :\MULTITOS)
  IF @exist(boot$+":\MINT.CNF",63)=0
    IF @exist(boot$+":\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MINT.EM")
    ENDIF
    NAME boot$+":\MINT.CNF" AS boot$+":\MINT.EM"
  ENDIF
  IF @exist(boot$+":\MULTITOS\MINT.CNF",63)=0
    IF @exist(boot$+":\MULTITOS\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MULTITOS\MINT.EM")
    ENDIF
    NAME boot$+":\MULTITOS\MINT.CNF" AS boot$+":\MULTITOS\MINT.EM"
  ENDIF
  '
  IF @exist(boot$+":\MINT\1-16-CUR\MINT.CNF",63)=0
    IF @exist(boot$+":\MINT\1-16-CUR\MINT.EM",63)=0
      error%=@f_kill(boot$+":\MINT\1-16-CUR\MINT.EM")
    ENDIF
    NAME boot$+":\MINT\1-16-CUR\MINT.CNF" AS boot$+":\MINT\1-16-CUR\MINT.EM"
  ENDIF
  '
  IF @exist(boot$+":\auto",16)=-33    ! Wenn nicht vorhanden
    MKDIR boot$+":\auto"
  ENDIF
  '
  ' MINT Ordner nach MINT.OLD umbenennen
  IF @exist(boot$+":\mint",16)=0 !AND @exist(boot$+":\mint.old",16)=-33
    IF @exist(boot$+":\mint.old",16)<>0
      NAME boot$+":\mint" AS boot$+":\mint.old"
    ENDIF
    ' MKDIR boot$+":\mint"
  ENDIF
  IF @exist(boot$+":\mint",16)=-33
    MKDIR boot$+":\mint"
  ENDIF
  '
  IF @exist(boot$+":\mint\1-16-cur",16)=-33
    MKDIR boot$+":\mint\1-16-cur"
  ENDIF
  '
  lw_mint$=boot$+":\mint\"
  '
  ' mw3
  @messagewin_print(mw3_1$)
  '
  @ug_copy1(install_path$+"\mint\mint.ini",lw_mint$+"1-16-cur\mint.ini")
  @ug_copy1(install_path$+"\mint\ext2.xfs",lw_mint$+"1-16-cur\ext2.xfs")
  @ug_copy1(install_path$+"\mint\inet4.xdd",lw_mint$+"1-16-cur\inet4.xdd")
  @ug_copy1(install_path$+"\mint\slip.xif",lw_mint$+"1-16-cur\slip.xif")
  @ug_copy1(install_path$+"\mint\xconout2.xdd",lw_mint$+"1-16-cur\xconout2.xdd")
  @ug_copy1(install_path$+"\mint\lp.xdd",lw_mint$+"1-16-cur\lp.xdd")
  @ug_copy1(install_path$+"\mint\nfs.xfs",lw_mint$+"1-16-cur\nfs.xfs")
  '
  ' *******************************************************
  ' XaAES installieren und konfigurieren?
  '
  IF xaaes_var!=TRUE
    @xaaes_copy
    IF teradesk_var!=TRUE
      @teradesk_copy
    ENDIF
  ENDIF
  '
  ' ******************************************************
  '
  ' mw4
  @messagewin_print(mw4_1$)
  '
  lw_auto$=boot$+":\easymint.tmp\"
  '
  ' mw5
  @messagewin_print(mw5_1$)
  '
  @auto_tmp                   ! Autoordner in richtiger Reihenfolge nach EASYMINT.tmp
  ' mw6
  @messagewin_print(mw6_1$)
  @messagewin_print(mw6_2$)
  '
  kernel_pfad$="\kernel.116\"
  kernel_name$="mint"
  serial_pfad$="1-16-cur\"
  kernel_pfad$=kernel_pfad$+kernel_name$
  IF compi_var&=1          ! ST
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"000.prg",lw_auto$+kernel_name$+"000.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
  ENDIF
  IF compi_var&=2          ! ST mit 030er
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
  ENDIF
  IF compi_var&=3          ! TT
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
  ENDIF
  IF compi_var&=4          ! Falcon
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"030.prg",lw_auto$+kernel_name$+"030.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
  ENDIF
  IF compi_var&=5          ! Falcon AB
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\68882.prg",lw_mint$+serial_pfad$+"68882.prg")
  ENDIF
  IF compi_var&=6          ! Milan
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"mil.prg",lw_auto$+kernel_name$+"mil.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\uart.xdd",lw_mint$+serial_pfad$+"uart.xdd")
    @ug_copy1(install_path$+"\serial\mfp_mil.xdd",lw_mint$+serial_pfad$+"mfp_mil.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__2m.prg",lw_mint$+"fpu__2m.prg")
  ENDIF
  IF compi_var&=7    ! Hades040
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__3.prg",lw_mint$+"fpu__3.prg")
  ENDIF
  IF compi_var&=8    ! Hades060
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu__3.prg",lw_mint$+"fpu__3.prg")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+"mfp.xdd")
  ENDIF
  IF compi_var&=9    ! Medusa T40
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"040.prg",lw_auto$+kernel_name$+"040.prg")
    ' Seriellen Treiber kopieren
    @ug_copy1(install_path$+"\serial\scc.xdd",lw_mint$+serial_pfad$+"scc.xdd")
    @ug_copy1(install_path$+"\serial\mfp.xdd",lw_mint$+serial_pfad$+"mfp.xdd")
    ' FPU Emulator kopieren
    @ug_copy1(install_path$+"\mint\fpu40v1.prg",lw_mint$+"fpu40v1.prg")
  ENDIF
  IF compi_var&=10          ! Aranym
    ' Kernel kopieren
    @ug_copy1(install_path$+kernel_pfad$+"ara.prg",lw_auto$+kernel_name$+"ara.prg")
    ' ARAnyM Treiber kopieren
    @ug_copy1(install_path$+"\mint\aranym.xif",lw_mint$+"1-16-cur\aranym.xif")
    @ug_copy1(install_path$+"\mint\hostfs.xfs",lw_mint$+"1-16-cur\hostfs.xfs")
    @ug_copy1(install_path$+"\mint\makefile.xfs",lw_mint$+"1-16-cur\makefile.xfs")
    @ug_copy1(install_path$+"\mint\nfeth.xif",lw_mint$+"1-16-cur\nfeth.xif")
  ENDIF
  '
  ' mw7
  @messagewin_print(mw7_1$)
  @messagewin_print(mw7_2$)
  '
  @tmp_auto                   ! Autoordner wieder zurÅck
  ' mw8
  @messagewin_print(mw8_1$)
  @messagewin_print(mw8_2$)
  '
  @newdesk_inf
  ' mw9
  @messagewin_print(mw9_1$)
  DEFMOUSE 0
RETURN
> PROCEDURE xaaes_copy
  LOCAL datei$,error%
  '
  DEFMOUSE 2
  '
  IF @exist(xaaeszip_path$,63)=0
    '
    xaaes_pfad$=":\mint\1-16-cur\xaaes"
    xaaes_zip$=":\mint\1-16-cur\"
    '
    IF @exist(boot$+xaaes_pfad$,16)=-33
      ~@f_mkdir(boot$+xaaes_pfad$)
    ENDIF
    @ug_copy1(xaaeszip_path$,boot$+xaaes_zip$+"xaaes.zip")
    '
    '
    IF @exist(em_start_pfad$+"unzip.ttp",63)=0
      @ug_copy1(em_start_pfad$+"unzip.ttp",boot$+xaaes_zip$+"unzip.ttp")
      '
      LET name$="Unpacking xaaes.zip..."
      error%=@start_prg(0,boot$+xaaes_zip$+"unzip.ttp","-o "+boot$+xaaes_zip$+"xaaes.zip -d "+boot$+xaaes_pfad$,"",name$,install_path$+"\tmp\xaaes.out",install_path$+"\tmp\xaaes.err",TRUE,TRUE,TRUE)
    ENDIF
    '
    IF @exist(boot$+":\xaaes"+xaaes_version$,16)=0
      old_name$=boot$+":\xaaes"+xaaes_version$
      new_name$=boot$+":\xaaes"
      error%=@frename(old_name$,new_name$)
      '      PRINT "frename: ";error%
    ENDIF
    '
    '    @ug_copy1(boot$+":\xaaes"+xaaes_version$+"\mint\vmoose.xdd",boot$+":\mint\vmoose.xdd")
    @ug_copy1(boot$+":\xaaes"+"\mint\vmoose.xdd",boot$+":\mint\vmoose.xdd")
    ~@f_kill(boot$+xaaes_zip$+"xaaes.zip")
    ~@f_kill(boot$+xaae_zip$+"unzip.ttp")
    '
    @xaaes_cnf_create_new
    '
  ENDIF
  DEFMOUSE 0
RETURN
> PROCEDURE xaaes_cnf_create
  LOCAL fiha&,tab$,quote$
  '
  ' mw10
  @messagewin_print(mw10_1$)
  '
  tab$=CHR$(9)
  quote$=CHR$(34)
  '
  ' ############## xa_setup.scl ############
  ~@f_kill(boot$+":\xaaes\xa_setup.scl")
  '
  fiha&=@f_create(boot$+":\xaaes\xa_setup.scl")
  ~@f_println(fiha&,"# XaAES Startup Configuration file for xaaes.tos (xa_setup.scl)",FALSE)
  ~@f_println(fiha&,"# Last modified 980704, by Johan Klockars",FALSE)
  ~@f_println(fiha&,"#               010404, by Henk Robbers",FALSE)
  ~@f_println(fiha&,"#               011120, by Henk Robbers",FALSE)
  ~@f_println(fiha&,"#               020402, by Henk Robbers",FALSE)
  ~@f_println(fiha&,"#               020616, by M.A Kehr for EasyMiNT",FALSE)
  ~@f_println(fiha&,"#--------------------------------------------------------------",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"# Since v0.943 this file is called xa_setup.scl",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"# comma is always a infix separators.",FALSE)
  ~@f_println(fiha&,"# white space is always a separator.",FALSE)
  ~@f_println(fiha&,"# '' and "+quote$+quote$+" are string braces",FALSE)
  ~@f_println(fiha&,"# !!! () are no more !!!",FALSE)
  ~@f_println(fiha&,"# any character can be put in a string by catanating",FALSE)
  ~@f_println(fiha&,"# embraced strings, literal strings and #numbers",FALSE)
  '  ~@f_println(fiha&,"string weird = < + '"+quote$+"' + ' ' + "+quote$+"'"+quote$+" (1) + #39 + ' ' + '"+quote$+"' + > ; yields <"+quote$+" '(1)' "+quote$+">",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"options default",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"windows"+tab$+"live,thickframe",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"options ps_contr",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"half_screen"+tab$+"64000",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"options PC,Xcontrol",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"windows"+tab$+"noleft, thinframe, thinwork",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"options aICQ"+STRING$(3,tab$)+"; Hi Joakim :-)",FALSE)
  ~@f_println(fiha&,"{",FALSE)
  ~@f_println(fiha&,tab$+"windows thinwork",FALSE)
  ~@f_println(fiha&,"}",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"# the below are now truly local variables only (not environment!)",FALSE)
  ~@f_println(fiha&,"string root = "+boot$+":\",FALSE)
  ~@f_println(fiha&,"string apps = "+boot$+":\",FALSE)
  ~@f_println(fiha&,"string gsys = root + gemsys\",FALSE)
  ~@f_println(fiha&,"string aes = root + xaaes\",FALSE)
  ~@f_println(fiha&,"string uni  = u:\",FALSE)
  ~@f_println(fiha&,"string widg  = aes + widgets\",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"string tosrun = uni + opt\toswin2\tw-call.prg",FALSE)
  ~@f_println(fiha&,"string olga   = gsys + "+quote$+"olga\olga.app"+quote$,FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"menu"+STRING$(2,tab$)+"leave"+STRING$(3,tab$)+"; leave or push or pull + optional nolocking",FALSE)
  ~@f_println(fiha&,"toppage"+STRING$(2,tab$)+"bold"+STRING$(3,tab$)+"; or faint",FALSE)
  ~@f_println(fiha&,"filters"+STRING$(2,tab$)+"*.*, *.[atpg]*, *.[chs]*, *.l*, *.o*",FALSE)
  ~@f_println(fiha&,"cancel"+STRING$(2,tab$)+"cancel,abbruch,annuler,avbryt,annuluj,afbryd,undo",FALSE)
  ~@f_println(fiha&,"clipboard"+tab$+"root + clipbrd\",FALSE)
  ~@f_println(fiha&,"launcher"+tab$+"uni + opt\toswin2\*.[atpg]*",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"#accpath root",FALSE)
  ~@f_println(fiha&,"accpath"+tab$+@lower$(boot$)+":\",FALSE)
  '
  ~@f_println(fiha&,tab$+"# Optional: specify the names of the resource files",FALSE)
  ~@f_println(fiha&,tab$+"# Widgets in folder widgets",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"if false",FALSE)
  ~@f_println(fiha&,"then",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + adam.rsc"+tab$+tab$+"; modern art icons (Malewicheds :-) of Adam Klobukowski",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + mboxwdg.rsc"+tab$+tab$+"; small mono boxchars (12*12 + (4 for 3D))",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + mbox1214.rsc"+tab$+tab$+"; small mono boxchars (12*14 + (4 for 3D))",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + mboxwidg.rsc"+tab$+tab$+"; large mono boxchars (16*16 + (4 for 3D)) (Easier to make)",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + cboxwdg.rsc"+tab$+tab$+"; small colour boxchars (12*12 + (4 for 3D))",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + cbox1214.rsc"+tab$+tab$+"; small colour boxchars (12*14 + (4 for 3D))",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + cboxwidg.rsc"+tab$+tab$+"; large colour boxchars (16*16 + (4 for 3D)) (Easier to make)",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + gilwidg.rsc"+tab$+tab$+"; nice round widgets of 'forgot his name' resource xa_mono.rsc"+tab$+tab$+"; all colour icons changed to mono icons",FALSE)
  ~@f_println(fiha&,tab$+tab$+tab$+"; all colour icons changed to mono icons",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + monowidg.rsc"+tab$+tab$+"; mono icons (No animation)",FALSE)
  ~@f_println(fiha&,tab$+"widgets widg + monowidg.rsc"+tab$+tab$+"; mono icons (No animation)",FALSE)
  ~@f_println(fiha&,"else",FALSE)
  ~@f_println(fiha&,"# move to here the one of the above you want to use",FALSE)
  ~@f_println(fiha&,"fi",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"# resource"+tab$+"xa_mono.rsc",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"# a demonstration: Try it! Just for fun",FALSE)
  ~@f_println(fiha&,tab$+"# popscroll 6",FALSE)
  '
  ~@f_println(fiha&,"# export certain strings to the environment",FALSE)
  ~@f_println(fiha&,"export"+tab$+"tosrun",FALSE)
  ~@f_println(fiha&,"export"+tab$+"olgamanager olga",FALSE)
  '
  ~@f_close(fiha&)
  '
  ' ################ END of xa_setup.scl
  '
  ' ################ xa_exec.scl
  '
  ~@f_kill(boot$+":\xaaes\xa_exec.scl")
  '
  fiha&=@f_create(boot$+":\xaaes\xa_exec.scl")
  '
  ~@f_println(fiha&,"# XaAES Startup SCL file (xa_exec.scl)",FALSE)
  ~@f_println(fiha&,"# Last modified april 18 2002 by Henk Robbers",FALSE)
  ~@f_println(fiha&,"#               july  16 2002 by M.A Kehr for EasyMiNT",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"#--------------------------------------------------------------",FALSE)
  ~@f_println(fiha&,"# The cnf is split into 2 parts, a static and a executorial",FALSE)
  ~@f_println(fiha&,"# Fixed filenames are now "+quote$+"xa_setup.scl"+quote$+", "+quote$+"xa_debug.scl"+quote$+" and "+quote$+"xa_exec.scl"+quote$,FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"# This is "+quote$+"xa_exec.scl"+quote$+", the executorial one.",FALSE)
  ~@f_println(fiha&,"# Variable names are kept througout the life of XaAES",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"# scl: System Control Language",FALSE)
  ~@f_println(fiha&,"# Nota Bene!!!!",FALSE)
  ~@f_println(fiha&,"# assignment operator: the character sequence ':='",FALSE)
  ~@f_println(fiha&,"# identity operator: the word 'is'",FALSE)
  ~@f_println(fiha&,"# equals operator: the character '='",FALSE)
  ~@f_println(fiha&,"# 'is' is used for defining constants",FALSE)
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"string thingv is thing"+tab$+"; or thing109",FALSE)
  ~@f_println(fiha&,"bool jin is false",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,tab$+"# Open the taskmanager",FALSE)
  ~@f_println(fiha&,"# open the taskmanager",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"run"+tab$+"root + wdial\n_dlg054.app",FALSE)
  ~@f_println(fiha&,"# run"+tab$+"root + wdial\wdialog.prg",FALSE)
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"if jin",FALSE)
  ~@f_println(fiha&,"then",FALSE)
  ~@f_println(fiha&,tab$+"export"+tab$+"avserver "+quote$+"JINNEE  "+quote$,FALSE)
  ~@f_println(fiha&,tab$+"desk"+tab$+"apps + jinnee\jinnee.app",FALSE)
  ~@f_println(fiha&,"else",FALSE)
  ~@f_println(fiha&,tab$+"export"+tab$+"avserver "+quote$+"TERADESK"+quote$,FALSE)
  ~@f_println(fiha&,tab$+"desk"+tab$+boot$+":\xaaes\teradesk\desktop.prg",FALSE)
  '  ~@f_println(fiha&,tab$+"export"+tab$+"avserver "+quote$+"THING   "+quote$,FALSE)
  '  ~@f_println(fiha&,tab$+"desk"+tab$+"apps + thingv + \thing.app",FALSE)
  ~@f_println(fiha&,"fi",FALSE)
  '
  ~@f_println(fiha&,"",FALSE)
  '
  ~@f_println(fiha&,"if false",FALSE)
  ~@f_println(fiha&,"then",FALSE)
  ~@f_println(fiha&,tab$+"desk"+tab$+"uni + c:\gemsys\xaaes\teradesk\desktop.prg",FALSE)
  ~@f_println(fiha&,tab$+"desk"+tab$+"root + ming\Thing.app",FALSE)
  ~@f_println(fiha&,tab$+"desk"+tab$+"root + ease\ease.prg",FALSE)
  ~@f_println(fiha&,tab$+"shell"+tab$+"e:\gemini2\Gemini.app",FALSE)
  ~@f_println(fiha&,tab$+"shell"+tab$+"e:\nodesk\noDesk.ovl",FALSE)
  ~@f_println(fiha&,"fi",FALSE)
  '
  ~@f_println(fiha&,tab$+tab$+"# Do some launches",FALSE)
  ~@f_println(fiha&,"if not true",FALSE)
  ~@f_println(fiha&,"then",FALSE)
  ~@f_println(fiha&,tab$+"run"+tab$+"aes + taskbar\taskbar.prg",FALSE)
  ~@f_println(fiha&,tab$+"run"+tab$+"aes + mltistrp\mltistrp.app",FALSE)
  ~@f_println(fiha&,tab$+"run"+tab$+"root + boxkite.prg",FALSE)
  ~@f_println(fiha&,tab$+"run"+tab$+"root + mint\app\miniwin.app",FALSE)
  ~@f_println(fiha&,"fi",FALSE)
  '
  ~@f_println(fiha&,"",FALSE)
  ~@f_println(fiha&,"run"+tab$+"tosrun",FALSE)
  ~@f_println(fiha&,"run"+tab$+"aes + autogem\*.p*"+tab$+tab$+"; v0.950 run + wildcards",FALSE)
  '
  '
  ~@f_close(fiha&)
RETURN
> PROCEDURE xaaes_cnf_create_new
  LOCAL fiha&,tab$,quote$
  '
  ' mw10
  @messagewin_print(mw10_1$)
  '
  tab$=CHR$(9)
  quote$=CHR$(34)
  '
  fiha&=@f_create(boot$+":\mint\1-16-cur\xaaes\xaaes.cnf")
  ~@f_println(fiha&,"####################################################################",FALSE)
  ~@f_println(fiha&,"# XAAES.CNF created by EasyMiNT ",FALSE)
  ~@f_println(fiha&,"# This is only a rudiment CNF file, just that things come up!",FALSE)
  ~@f_println(fiha&,"# It's highly recommended to have a look at the original CNF file!! ",FALSE)
  ~@f_println(fiha&,"# There are much more options and explanations!",FALSE)
  ~@f_println(fiha&,"# You will find it under "+boot$+":\MINT\1-16-CUR\XAAES\EXAMPLE.CNF",FALSE)
  ~@f_println(fiha&,"####################################################################",FALSE)
  '
  ~@f_println(fiha&,"# Environment variables",FALSE)
  ~@f_println(fiha&,"setenv ACCPATH"+tab$+tab$+boot$+":\",FALSE)
  ~@f_println(fiha&,"setenv ACCEXT"+tab$+tab$+"ACC,ACX",FALSE)
  ~@f_println(fiha&,"setenv GEMEXT"+tab$+tab$+"PRG,APP,GTP,OVL,SYS",FALSE)
  ~@f_println(fiha&,"setenv TOSEXT"+tab$+tab$+"TOS,TTP",FALSE)
  ~@f_println(fiha&,"setenv TOSRUN"+tab$+tab$+"u:\opt\toswin2\tw-call.prg",FALSE)
  ~@f_println(fiha&,"setenv SDL_VIDEODRIVER"+tab$+"gem",FALSE)
  '
  ~@f_println(fiha&,"# naes_cookie (default is no)",FALSE)
  ~@f_println(fiha&,"naes_cookie = yes",FALSE)
  '
  ~@f_println(fiha&,"# use $HOME in shell_find",FALSE)
  ~@f_println(fiha&,"usehome = yes",FALSE)
  '
  ~@f_println(fiha&,"# next_active = <string> (default is window)",FALSE)
  ~@f_println(fiha&,"next_active = client ",FALSE)
  '
  ~@f_println(fiha&,"# app_options = appname,argument1,argument2,...",FALSE)
  ~@f_println(fiha&,"# These are good app_options settings that I (ozk) use atm",FALSE)
  ~@f_println(fiha&,"app_options = default,thinwork=true,winframe_size = 0,xa_nomove = false ",FALSE)
  ~@f_println(fiha&,"app_options = aessys,thinwork=true,winframe_size = 0,xa_nomove = false ",FALSE)
  ~@f_println(fiha&,"app_options = jinnee, naesff = true ",FALSE)
  ~@f_println(fiha&,"app_options = taskbar,inhibit_hide = yes, clwtna = true ",FALSE)
  ~@f_println(fiha&,"app_options = amail, naesff = true",FALSE)
  ~@f_println(fiha&,"app_options = mymail,thinwork=true,winframe_size = 0",FALSE)
  ~@f_println(fiha&,"app_options = highwire,winframe_size = 0",FALSE)
  '
  ~@f_println(fiha&,"# The following will keep the desktop, taskbar and toswin2 running after",FALSE)
  ~@f_println(fiha&,"# a ctrl-alt-a action",FALSE)
  ~@f_println(fiha&,"ctlalta_survivors = "+quote$+"toswin2 "+quote$+", "+quote$+"strngsrv"+quote$+", "+quote$+"_aes_shell_"+quote$+", "+quote$+"taskbar "+quote$,FALSE)
  '
  ~@f_println(fiha&,"clipboard = "+boot$+":\clipbrd\",FALSE)
  ~@f_println(fiha&,"accpath = "+boot$+":\",FALSE)
  ~@f_println(fiha&,"launcher = u:\opt\toswin2\tw-call.prg",FALSE)
  '
  ~@f_println(fiha&,"# widgets = <file>",FALSE)
  ~@f_println(fiha&,"# resource = <file>",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"#resource = xa_mono.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\homwdg.rsc",FALSE)
  ~@f_println(fiha&,"widgets = widgets\styl_wdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\nine-ozk.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\baroqwdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\ronb_wdg.rsc",FALSE)
  ~@f_println(fiha&,"#widgets = widgets\magicwdg.rsc",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"cancel = cancel,abbruch,annuler,avbryt,anuluj,afbryd,undo",FALSE)
  '
  ~@f_println(fiha&,"# filters = mask, mask, ...",FALSE)
  ~@f_println(fiha&,"filters = *.*, *.[atpg]*, *.[chs]*, *.l*, *.o*",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# start any other programs with run",FALSE)
  ~@f_println(fiha&,"#run <path>\<application>",FALSE)
  ~@f_println(fiha&,"run u:\opt\toswin2\toswin2.prg",FALSE)
  '
  ~@f_println(fiha&,"# system shell",FALSE)
  ~@f_println(fiha&,"setenv AVSERVER   "+quote$+"DESKTOP "+quote$,FALSE)
  ~@f_println(fiha&,"setenv FONTSELECT "+quote$+"DESKTOP "+quote$,FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"shell = u:\"+boot$+"\mint\1-16-cur\teradesk\desktop.prg",FALSE)
  '
  ~@f_close(fiha&)
RETURN
> PROCEDURE teradesk_copy
  LOCAL datei$,old$,new$
  DEFMOUSE 2
  '
  teradesk_pfad$=":\mint\1-16-cur\teradesk"
  xaaes_tera_pfad$=":\mint\1-16-cur\"
  IF @exist(boot$+teradesk_pfad$,16)=-33
    ~@f_mkdir(boot$+teradesk_pfad$)
  ENDIF
  IF @exist(teradeskzip_path$,63)=0
    '
    @ug_copy1(teradeskzip_path$,boot$+teradesk_pfad$+"\teradesk.zip")
    '
    '
    IF @exist(em_start_pfad$+"unzip.ttp",63)=0
      @ug_copy1(em_start_pfad$+"unzip.ttp",boot$+teradesk_pfad$+"\unzip.ttp")
      '
      '      IF @exist(boot$+":\xaaes\teradesk",16)=-33
      '      ~@f_mkdir(boot$+":\xaaes\teradesk")
      '    ENDIF
      LET name$="Unpacking teradesk.zip..."
      error%=@start_prg(0,boot$+teradesk_pfad$+"\unzip.ttp","-o "+boot$+teradesk_pfad$+"\teradesk.zip -d "+boot$+teradesk_pfad$,"",name$,install_path$+"\tmp\teradesk.out",install_path$+"\tmp\teradesk.err",TRUE,TRUE,TRUE)
      '
      old$=boot$+":\xaaes\tdesk2_3.bin"
      new$=boot$+":\xaaes\teradesk"
      '
      rerror%=@frename(old$,new$)
      '      PRINT "Rename-Error: ";rerror%
    ENDIF
    ~@f_kill(boot$+teradesk_pfad$+"\teradesk.zip")
    ~@f_kill(boot$+teradesk_pfad$+"\unzip.ttp")
    '
  ENDIF
  DEFMOUSE 0
RETURN
> PROCEDURE auto_tmp
  LOCAL suchmaske$,zeit&,attribute&
  '
  attribute&=&X101111                     ! Bit   Finde folgende:
  '                                     x    0    SchreibgeschÅtzte Datei
  '                                     x    1    Versteckte Datei
  '                                     x    2    Systemdatei
  '                                     x    3    Diskettenname
  '                                          4    Ordner
  '                                     x    5    Datei mit gesetztem Archivbit
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  IF @exist(boot$+":\easymint.tmp",16)=-33
    MKDIR boot$+":\easymint.tmp"
  ENDIF
  '  zeit&=@busy_open(FALSE)
  '
  @move_mint_prg
  '
  '
  ' AUTO Ordner nach EASYMINT.TMP verschieben
  '
  LET dta%=FGETDTA()
  IF @my_fsfirst(boot$+":\auto\*.*",attribute&,TRUE)=0
    REPEAT
      @ug_copy1(boot$+":\auto\"+CHAR{gl_xattr_d_fname%},boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(boot$+":\auto\*.*",attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurÅcksetzen
  '
  ' Auto Ordner leeren
  LET dta%=FGETDTA()
  suchmaske$=boot$+":\auto\*.*"
  IF @my_fsfirst(suchmaske$,attribute&,TRUE)=0
    REPEAT
      error%=@f_kill(boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(suchmaske$,attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurÅcksetzen
RETURN
> PROCEDURE tmp_auto
  LOCAL suchmaske$,attribute&
  '
  attribute&=&X101111
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  LET dta%=FGETDTA()
  IF @my_fsfirst(boot$+":\easymint.tmp\*.*",attribute&,TRUE)=0
    REPEAT
      @ug_copy1(boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%},boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(boot$+":\easymint.tmp\*.*",attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)                          ! DTA zurÅcksetzen
  '
  ' tmp Ordner leeren und lîschen
  LET dta%=FGETDTA()
  suchmaske$=boot$+":\easymint.tmp\*.*"
  IF @my_fsfirst(suchmaske$,attribute&,TRUE)=0
    REPEAT
      error%=@f_kill(boot$+":\easymint.tmp\"+CHAR{gl_xattr_d_fname%})
    UNTIL @my_fsnext(suchmaske$,attribute&)<>0 !FSNEXT()<0
  ENDIF
  ~FSETDTA(dta%)
  '
  error%=@f_rmdir(boot$+":\easymint.tmp")
  '
  '
RETURN
> PROCEDURE move_mint_prg
  LOCAL attribute&
  '
  attribute&=&X101111
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  ' MINT.PRG suchen und verschieben
  '
  IF @exist(boot$+":\auto\mint*.pr*",16)=0
    IF @exist(boot$+":\auto\mintprg.bak",63)=-33
      error%=@f_mkdir(boot$+":\auto\mintprg.bak")
    ENDIF
    '
    LET dta%=FGETDTA()
    IF @my_fsfirst(boot$+":\auto\mint*.pr?",attribute&,TRUE)=0
      REPEAT
        @ug_copy1(boot$+":\auto\"+CHAR{gl_xattr_d_fname%},boot$+":\auto\mintprg.bak\"+CHAR{gl_xattr_d_fname%})
        error%=@f_kill(boot$+":\auto\"+CHAR{gl_xattr_d_fname%})
      UNTIL @my_fsnext(boot$+":\auto\mint*.pr?",attribute&)<>0 !FSNEXT()<0
    ENDIF
    ~FSETDTA(dta%)                          ! DTA zurÅcksetzen
  ENDIF
RETURN
> FUNCTION dateiname_cut$(pfad$)
  $F%
  LOCAL pos1%,len%,dateiname_len%,love$
  love$="Maggi liebt Ulla!"
  pos1%=RINSTR(pfad$,"\")
  len%=LEN(pfad$)
  dateiname_len%=len%-pos1%
  td_version$=RIGHT$(pfad$,dateiname_len%)
  '
  RETURN td_version$
ENDFUNC
'
> PROCEDURE newdesk_inf
  LOCAL i&,a&,endof&,fiha&,fiha_1&,zw&
  '
  '
  IF @exist("c:\newdesk.inf",63)=0
    fiha&=@f_open("c:\newdesk.inf")
    REPEAT
      newdesk$(i&)=@f_input$(fiha&,FALSE)
      INC i&
    UNTIL @f_eof(fiha&)
    endof&=(i&-1)
    ~@f_close(fiha&)
    '
    autostart_flag!=FALSE
    '
    app_flag!=FALSE
    prg_flag!=FALSE
    gtp_flag!=FALSE
    ttp_flag!=FALSE
    tos_flag!=FALSE
    '
    FOR i&=0 TO endof&
      IF INSTR(newdesk$(i&),"#Z")<>0
        newdesk$(i&)="#Z 01 "+em_start_pfad$+"easymint.prg@"
        autostart_flag!=TRUE
      ENDIF
      @test_klein(i&,newdesk$(i&))
    NEXT i&
    '
    '
    IF autostart_flag!=FALSE
      FOR i&=0 TO endof&
        IF INSTR(newdesk$(i&),"#d")<>0
          zw&=i&+1
        ENDIF
      NEXT i&
      INC endof&
      FOR i&=endof& DOWNTO zw&
        newdesk$(i&+1)=newdesk$(i&)
      NEXT i&
      newdesk$(zw&)="#Z 01 "+em_start_pfad$+"\easymint.prg@"
    ENDIF
    '
    fiha_1&=@f_create("c:\newdesk.inf")
    FOR a&=0 TO endof&
      ~@f_println(fiha_1&,newdesk$(a&),FALSE)
    NEXT a&
    IF execute$(1)<>""
      ~@f_println(fiha_1&,execute$(1),FALSE)
    ENDIF
    IF execute$(2)<>""
      ~@f_println(fiha_1&,execute$(2),FALSE)
    ENDIF
    IF execute$(3)<>""
      ~@f_println(fiha_1&,execute$(3),FALSE)
    ENDIF
    IF execute$(4)<>""
      ~@f_println(fiha_1&,execute$(4),FALSE)
    ENDIF
    IF execute$(5)<>""
      ~@f_println(fiha_1&,execute$(5),FALSE)
    ENDIF
    ~@f_close(fiha_1&)
  ENDIF
  '
  '  @busy_close
  '  @ext2_info
  @neustart_info
RETURN
> PROCEDURE test_klein(x&,test$)
  '
  ERASE execute$()
  DIM execute$(5)
  '
  IF INSTR(test$,"#G 03 FF 000 *.app@ @ @")<>0
    app_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#G 03 FF 000 *.prg@ @ @")<>0
    prg_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#Y 03 FF 000 *.gtp@ @ @")<>0
    gtp_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#P 03 FF 000 *.ttp@ @ @")<>0
    ttp_flag!=TRUE
  ENDIF
  IF INSTR(test$,"#F 03 04 000 *.tos@ @ @")<>0
    tos_flag!=TRUE
  ENDIF
  '
  IF app_flag!=FALSE
    execute$(1)="#G 03 FF 000 *.app@ @ @"
  ENDIF
  IF prg_flag!=FALSE
    execute$(2)="#G 03 FF 000 *.prg@ @ @"
  ENDIF
  IF gtp_flag!=FALSE
    execute$(3)="#Y 03 FF 000 *.gtp@ @ @"
  ENDIF
  IF ttp_flag!=FALSE
    execute$(4)="#P 03 FF 000 *.ttp@ @ @"
  ENDIF
  IF tos_flag!=FALSE
    execute$(5)="#F 03 04 000 *.tos@ @ @"
  ENDIF
RETURN
> PROCEDURE angemeldete_lw
  LOCAL eing&,eing2&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  ' Laufwerk C-T
  '
  FOR i&=lw_c& TO lw_t&
    IF BTST(drives%,(i&-lw_c&)+2)=TRUE
      @rsc_ob_disable(fvt_popu&,i&,FALSE)
    ENDIF
    IF BTST(drives%,(i&-lw_c&)+2)=FALSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  ' Laufwerk V-Z
  '
  FOR i&=lw_v& TO lw_6&
    IF BTST(drives%,(i&-lw_v&)+21)=TRUE
      @rsc_ob_disable(fvt_popu&,i&,FALSE)
    ENDIF
    IF BTST(drives%,(i&-lw_v&)+21)=FALSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  '
RETURN
> PROCEDURE lnx_find
  LOCAL i&
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  '
  FOR i&=ext_c& TO ext_t&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_c&)+2))<>"LNX" AND UPPER$(@xhdi$((i&-ext_c&)+2))<>"RAW"
        @rsc_ob_disable(fvt_popu&,i&,TRUE)
      ENDIF
    ELSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  FOR i&=ext_v& TO ext_6&
    IF BTST(drives%,(i&-ext_c&)+2)=TRUE
      IF UPPER$(@xhdi$((i&-ext_v&)+2))<>"LNX" AND UPPER$(@xhdi$((i&-ext_v&)+2))<>"RAW"
        @rsc_ob_disable(fvt_popu&,i&,TRUE)
      ENDIF
    ELSE
      @rsc_ob_disable(fvt_popu&,i&,TRUE)
    ENDIF
  NEXT i&
  '
  ' ext_c_var&=0
  '
  '  @rsc_set_text(kennung&,ke_top1&,chooselw1_1$)
  '  @rsc_set_text(kennung&,ke_top2&,chooselw1_2$)
  '  @rsc_set_text(kennung&,ke_top3&,chooselw1_3$)
  '  @rsc_set_text(kennung&,ke_top4&,chooselw1_4$)
  '  @rsc_setup_tree(kennung&)
  '
  '  kennung_hdle&=@win_open_dialog(2,kennung&,-1)
  '
RETURN
> PROCEDURE kennung_auswert
  LOCAL eing&,eing2&,eing3&,eing4&
  '
  IF lw_c_var&=0
    ' Alert 3
    @win_close(kennung_hdle&)
    @mw_redraw
    '
    ALERT 1,alert3_1$,1,alert3_2$,eing&
    '
    IF eing&=1
      kennung_hdle&=@win_open_dialog(2,kennung&,-1)
    ELSE
      exit_program!=TRUE
    ENDIF
  ELSE
    lw_fs$=@lower$(CHR$(66+lw_c_var&))
    @neustart_info
  ENDIF
RETURN
> PROCEDURE neustart_info
  '  ' Wenn XAAES noch nicht vorhanden, entpacken
  '  IF xaaes_var!=FALSE
  '  @messagewin_print("Startpfad: "+em_start_pfad$)
  ' '    @xaaes_copy
  ' ENDIF
  @message2(cb_1$,cb_2$,cb_3$,cb_4$,cb_5$,cb_6$,cb_7$)
  neustart_info!=TRUE
  '
RETURN
> PROCEDURE neustart
  LOCAL error%,fiha&
  ' ' Wenn XAAES noch nicht vorhanden, entpacken
  ' IF xaaes_var!=FALSE
  ' @messagewin_print(xaaeszip_path$)
  ' @xaaes_copy
  ' ENDIF
  ' Mini MINT.CNF erzeugen
  @mintcnf_create(FALSE)
  '
  ' Boot- und MiNT Laufwerk temporÑr zwischenspeichern
  '
  IF @exist(install_path$+"\tmp",16)=-33
    MKDIR install_path$+"\tmp"
  ENDIF
  '
  fiha&=@f_create(install_path$+"\tmp\position.tmp")
  ~@f_println(fiha&,@lower$(boot$),FALSE)
  ~@f_println(fiha&,lw_fs$,FALSE)
  ~@f_println(fiha&,STR$(compi_var&),FALSE)
  ~@f_println(fiha&,xaaes_version$,FALSE)
  ~@f_close(fiha&)
  '
  exit_program!=TRUE
  @kaltstart
RETURN
'
' Zweiter Teil nach reboot
'
> PROCEDURE make_ext2
  LOCAL rin&,fiha&
  '
  ' Bootlaufwerk und MiNT Laufwerk einlesen
  '
  fiha&=@f_open(install_path$+"\tmp\position.tmp")
  boot$=@f_input$(fiha&,FALSE)
  lw_fs$=@f_input$(fiha&,FALSE)
  compi_var&=VAL(@f_input$(fiha&,FALSE))
  xaaes_version$=@f_input$(fiha&,FALSE)
  ~@f_close(fiha&)
  '
  IF @get_cookie("MiNT",value%)=FALSE
    ' alert4
    ALERT 1,alert4_1$+" "+boot$+alert4_2$,1,alert4_3$,eing&
    IF eing&=1
      exit_program!=TRUE
    ENDIF
  ELSE
    '
    IF @bereits_installiert=FALSE
      ' alert5 Ext2 installieren JA/NEIN
      ALERT 2,alert5_1$+" "+lw_fs$+alert5_2$,1,alert5_3$,rin&
      IF rin&=1
        ' alert6
        ALERT 1,alert6_1$,2,alert6_2$,eing&
        IF eing&=1
          ' alert7
          ALERT 2,alert7_1$,2,alert7_2$,eing2&
          IF eing2&=1
            ' Schritt 3
            @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
            @messagewin_print(mw29_1$+" 3/6")
            @messagewin_print(mw30_1$)
            '
            ' name 2
            LET name$=name2$
            prg$=install_path$+"\mkfs.ttp"
            cmd$="-q "+lw_fs$+":"
            error%=@start_prg(0,prg$,cmd$,"",name$,install_path$+"\tmp\mkfs.out",install_path$+"tmp\mkfs.err",TRUE,TRUE,FALSE)
            IF error%=0
              ' messagewin 11
              @messagewin_print(mw11_1$)
            ELSE
              ' alert8
              ALERT 1,alert8_1$,1,alert8_2$,eing4&
              IF eing4&=1
                exit_program!=TRUE
              ENDIF
            ENDIF
            @install_base
          ENDIF
          IF eing2&=2
            exit_program!=TRUE
          ENDIF
        ENDIF
        IF eing&=2
          exit_program!=TRUE
        ENDIF
      ENDIF
      IF rin&=2
        @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
        @install_base
      ENDIF
    ELSE IF @bereits_installiert=TRUE
      @messagewin_open(status_win$,50,mw_x&,mw_y&,mw_b&,mw_h&,-1)
      @install_base
    ENDIF
  ENDIF
RETURN
> PROCEDURE install_base
  '
  IF ber_inst!=FALSE        ! Wenn noch nichts installiert ist
    lstinst_var!=FALSE
  ELSE IF ber_inst!=TRUE    ! Wenn schon was installiert ist
    ' Alert22    ALERT 1," TAR Pakete oder | RPM per LST | installieren? ",1," TAR | RPM ",eing%
    ALERT 2,alert22_1$,1,alert22_2$,eing%
    IF eing%=1
      lstinst_var!=FALSE
    ELSE IF eing%=2
      lstinst_var!=TRUE
      @rpm_pfad_choose
    ENDIF
  ENDIF
  '
  @test_packages("basic.tar","bi.chk",pakete&)
  @test_packages("standard.tar","si.chk",man&)
  @test_packages("net.tar","ni.chk",net&)
  @test_packages("devel.tar","di.chk",devel&)
  @test_packages("libs.tar","li.chk",libs&)
  @test_packages("x11.tar","xi.chk",x11&)
  '
  @rsc_setup_tree(pre&)
  '
  pre_hdle&=@win_open_dialog(2,pre&,-1)
RETURN
> PROCEDURE test_packages(file$,i_file$,objekt&)
  IF lstinst_var!=FALSE
    ' TAR Paket vorhanden aber nicht installiert
    IF @exist(em_start_pfad$+"\pakete\"+file$,63)=0 AND @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,FALSE)
      @rsc_ob_disable(pre&,objekt&,FALSE)
      '
      '
      ' TAR Paket vorhanden und installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)=0 AND @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
      '
      ' TAR Paket nicht vorhanden, aber installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)<>0 AND @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
      '
      ' TAR Paket nicht vorhanden und nicht installiert
    ELSE IF @exist(em_start_pfad$+"pakete\"+file$,63)<>0 AND @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
    ENDIF
  ELSE IF lstinst_var!=TRUE
    ' Paket bereits installiert
    IF @exist(install_path$+"\tmp\"+i_file$,63)=0
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @rsc_ob_disable(pre&,objekt&,TRUE)
      @do_check(objekt&)
    ENDIF
    ' Paket noch nicht installiert
    IF @exist(install_path$+"\tmp\"+i_file$,63)<>0
      @rsc_ob_disable(pre&,objekt&,FALSE)
      @rsc_ob_disable(pre&,objekt&,FALSE)
    ENDIF
    '
  ENDIF
RETURN
> PROCEDURE do_check(objekt&)
  SELECT objekt&
  CASE pakete&
    pakete_var!=TRUE
  CASE man&
    man_var!=TRUE
  CASE net&
    net_var!=TRUE
  CASE devel&
    devel_var!=TRUE
  CASE libs&
    libs_var!=TRUE
  CASE x11&
    x11_var!=TRUE
  ENDSELECT
RETURN
> FUNCTION bereits_installiert
  $F%
  LOCAL fiha&,i_p$
  '
  i_p$=install_path$+"\tmp\"
  IF @exist(i_p$+"bi.chk",63)=0 OR @exist(i_p$+"si.chk",63)=0 OR @exist(i_p$+"ni.chk",63)=0 OR @exist(i_p$+"di.chk",63)=0 OR @exist(i_p$+"li.chk",63)=0 OR @exist(i_p$+"xi.chk",63)=0
    ber_inst!=TRUE
  ELSE
    ber_inst!=FALSE
  ENDIF
  RETURN ber_inst!
ENDFUNC
'
> PROCEDURE rpm_pfad_choose
  LOCAL datei$,pfad$,index&
  '
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  IF lstinst_var!=TRUE
    datei$=@fileselector$("rpms?","u:\usr\src\redhat\RPMS\","",TRUE,"")
    pfad$=@extract_pfad$(datei$)
    IF @exist(pfad$,16)=0
      lw_$=@cut_path$(pfad$,TRUE)
      rpm_pfad$=@tos_to_unix_path$(pfad$)+"/"
      rpm_pfad$=@cut_path$(rpm_pfad$,FALSE)
    ELSE
      lstinst_var!=FALSE
    ENDIF
  ELSE IF lstinst_var!=FALSE
    '
  ENDIF
  '
RETURN
> PROCEDURE pre_auswert
  LOCAL eing&,tree%
  '
  '
  tree%=@xrsrc_gaddr(0,tree&)
  '
  IF pakete_var!=TRUE AND BTST(OB_STATE(tree%,pakete&),3)=FALSE
    package$(0)="basic.tar"
  ELSE
    pakete_var!=FALSE
  ENDIF
  IF man_var!=TRUE AND BTST(OB_STATE(tree%,man&),3)=FALSE
    package$(1)="standard.tar"
  ELSE
    man_var!=FALSE
  ENDIF
  IF net_var!=TRUE AND BTST(OB_STATE(tree%,net&),3)=FALSE
    package$(2)="net.tar"
  ELSE
    net_var!=FALSE
  ENDIF
  IF devel_var!=TRUE AND BTST(OB_STATE(tree%,devel&),3)=FALSE
    package$(3)="devel.tar"
  ELSE
    devel_var!=FALSE
  ENDIF
  IF libs_var!=TRUE AND BTST(OB_STATE(tree%,libs&),3)=FALSE
    package$(4)="libs.tar"
  ELSE
    libs_var!=FALSE
  ENDIF
  IF x11_var!=TRUE AND BTST(OB_STATE(tree%,x11&),3)=FALSE
    package$(5)="x11.tar"
  ELSE
    x11_var!=FALSE
  ENDIF
  '
  '
  DEFMOUSE 2
  '
  IF filecheck_var!=TRUE
    '
    ' messagewin 12
    @messagewin_print(mw12_1$+" "+boot$+mw12_2$)
    '
    IF @exist(boot$+":\mint\bin",63)=-33
      MKDIR boot$+":\mint\bin"
    ENDIF
    @ug_copy1(install_path$+"\bin\sh",boot$+":\mint\bin\sh")
    @ug_copy1(install_path$+"\bin\fscheck.sh",boot$+":\mint\bin\fscheck.sh")
  ENDIF
  '
  '
  IF mico_var!=TRUE
    ' messagewin 13
    @messagewin_print(mw13_1$+" "+boot$+mw13_2$)
    '
    IF @exist(boot$+":\mint\mico",63)=-33
      MKDIR boot$+":\mint\mico"
    ENDIF
    @ug_copy1(install_path$+"\mico\micodial.prg",boot$+":\mint\mico\micodial.prg")
    @ug_copy1(install_path$+"\mico\micodial.rsc",boot$+":\mint\mico\micodial.rsc")
    @ug_copy1(install_path$+"\mico\micokonf.prg",boot$+":\mint\mico\micokonf.prg")
    @ug_copy1(install_path$+"\mico\micokonf.rsc",boot$+":\mint\mico\micokonf.rsc")
  ENDIF
  IF shutdown_var!=TRUE
    ' messagewin 14
    @messagewin_print(mw14_1$+" "+boot$+mw14_2$)
    '
    IF @exist(boot$+":\mint\shutdown",63)=-33
      MKDIR boot$+":\mint\shutdown"
    ENDIF
    @ug_copy1(install_path$+"\shutdown\readme",boot$+":\mint\shutdown\readme")
    @ug_copy1(install_path$+"\shutdown\shutdown.app",boot$+":\mint\shutdown\shutdown.app")
    @ug_copy1(install_path$+"\shutdown\shutdown.inf",boot$+":\mint\shutdown\shutdown.inf")
    @ug_copy1(install_path$+"\shutdown\shutdown.rsc",boot$+":\mint\shutdown\shutdown.rsc")
  ENDIF
  '
  DEFMOUSE 0
  '
RETURN
> FUNCTION cut_path$(path$,lwb!)
  '
  ' Laufwerksbuchstabe abschneiden oder zurÅckgeben
  IF lwb!=TRUE
    c_path$=LEFT$(path$,1)
  ELSE IF lwb!=FALSE
    c_path$=MID$(path$,3)
  ENDIF
  RETURN c_path$
ENDFUNC
> FUNCTION extract_pfad$(datei$)
  $F%
  '
  ' Extrahiert einen Pfad
  '
  LOCAL match&
  match&=RINSTR(datei$,"\")
  IF match&>0
    match$=LEFT$(datei$,PRED(match&))
  ELSE
    CLR match$
  ENDIF
  RETURN match$
ENDFUNC
'
> PROCEDURE naes_info
  @message(1,naes_1$,naes_2$,naes_3$,naes_4$,naes_5$,naes_6$,naes_7$)
  naes_info!=TRUE
RETURN
> PROCEDURE pfade_vorbeleg
  LOCAL handle&,index&,xaaes_folder$
  '
  xaaes_folder$=boot$+":\mint\1-16-cur\xaaes"
  '
  IF @exist(xaaes_folder$,16)=0
    @rsc_ob_disable(pfade&,xaaesstrt&,FALSE)
    @rsc_ob_disable(pfade&,xaaespfad&,FALSE)
  ELSE
    @rsc_ob_disable(pfade&,xaaesstrt&,TRUE)
    @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
  ENDIF
  '
  xaaespfad_var$=boot$+":\mint\1-16-cur\xaaes\xaloader.prg"
  @rsc_ob_disable(pfade&,xaaespfad&,TRUE)
  '
  @rsc_setup_tree(pfade&)
  '
  pfade_hdle&=@win_open_dialog(2,pfade&,-1)
RETURN
> PROCEDURE pfade_auswert
  LOCAL fiha&,i&,a&,tab$,anfueh$
  '
  IF naescar_var!=TRUE
    ' messagewin 16
    @messagewin_print(mw16_1$+" "+boot$+mw16_2$)
    IF @exist(boot$+":\mint\naescar",63)=-33
      MKDIR boot$+":\mint\naescar"
    ENDIF
    @ug_copy1(install_path$+"\naescar\naescar.prg",boot$+":\mint\naescar\naescar.prg")
    @ug_copy1(install_path$+"\naescar\naescar.rsc",boot$+":\mint\naescar\naescar.rsc")
    '
    IF @exist(boot$+":\guides",63)=-33
      MKDIR boot$+":\guides"
    ENDIF
    @ug_copy1(install_path$+"\naescar\naescar.hyp",boot$+":\guides\naescar.hyp")
    @ug_copy1(install_path$+"\naescar\naescar.ref",boot$+":\guides\naescar.ref")
  ENDIF
  '
RETURN
'
> PROCEDURE rootfs_install
  LOCAL error%,eing&
  '
  DEFMOUSE 2
  '
  ' schritt 4
  @messagewin_print(mw29_1$+" 4/6")
  '
  ' messagewin 17
  @messagewin_print(mw17_1$)
  @ug_copy1(em_start_pfad$+"\rootfs.tgz",lw_fs$+":\rootfs.tgz")
  @ug_copy1(install_path$+"\tar.ttp",lw_fs$+":\tar")
  @ug_copy1(install_path$+"\gzip.ttp",lw_fs$+":\gzip")
  '
  CHDRIVE lw_fs$
  CHDIR "\"
  '
  error%=@fchmod("tar",&O755)
  error%=@fchmod("gzip",&O755)
  '
  DEFMOUSE 0
  '
  ' TODO: Eintragen der Paketgrîûen
  IF package$(0)="basic.tar"
    min_mb%=15000000
  ENDIF
  IF package$(1)="standard.tar"
    min_mb%=min_mb%+55000000
  ENDIF
  IF package$(2)="net.tar"
    min_mb%=min_mb%+32000000
  ENDIF
  IF package$(3)="devel.tar"
    min_mb%=min_mb%+60000000
  ENDIF
  IF package$(4)="libs.tar"
    min_mb%=min_mb%+50000000
  ENDIF
  IF package$(5)="x11.tar"
    min_mb%=min_mb%+50000000
  ENDIF
  '
  '  @messagewin_print("Free on "+lw_fs$+":\ = "+STR$(ROUND(@diskinfo(lw_fs$)/1024000))+" MB  Needed: "+STR$(ROUND((min_mb%)/1024000))+" MB")
  '
  '
  IF @diskinfo(lw_fs$)>min_mb%
    IF @exist(@akt_pfad$+"tar",63)=0
      '
      '
      exec$=@akt_pfad$+"tar"
      cmd$="-xvzf "+@akt_pfad$+"rootfs.tgz"
      env$="UNIXMODE=/brUs" !+CHR$(0)+CHR$(0)
      '
      ' name 3
      LET name$=name3$
      error%=@start_prg(0,exec$,cmd$,env$,name$,install_path$+"\tmp\rootfs.out",install_path$+"\tmp\rootfs.err",TRUE,TRUE,FALSE)
      ' error%=@pipe(100,exec$,cmd$,env$,TRUE)
      @setlinks_to_aes
      @create_fstab
      error%=@fchmod("u:\tmp",&O1777)
      '
      IF @exist(lw_fs$+":\tar",63)=0
        error%=@f_kill(lw_fs$+":\tar")
      ENDIF
      IF @exist(lw_fs$+":\gzip",63)=0
        error%=@f_kill(lw_fs$+":\gzip")
      ENDIF
      IF @exist(lw_fs$+":\rootfs.tgz",63)=0
        error%=@f_kill(lw_fs$+":\rootfs.tgz")
      ENDIF
      '
      ' messagewin 18
      @messagewin_print(mw18_1$)
    ELSE
      ' alert 10
      ALERT 1,alert10_1$+" "+@akt_pfad$+" "+alert10_2$,1,alert10_3$,eing7&
      IF eing7&
        exit_program!=TRUE
      ENDIF
    ENDIF
  ELSE
    ' alert 11
    ALERT 1,alert11_1$+" "+STR$(ROUND(min_mb%/1024/1024))+" "+alert11_2$,1,alert11_3$,eingg&
    exit_program!=TRUE
  ENDIF
  '
RETURN
> PROCEDURE setlinks_to_aes
  '
  LOCAL fiha&
  ' Link setzen von naespfad_var$ auf /usr/bin/n_aes
  IF login_var&=2 OR login_var&=1 AND naespfad_var$<>""
    IF @exist(lw_fs$+":\usr\bin\n_aes",63)=0
      ~@f_kill(lw_fs$+":\usr\bin\n_aes")
    ENDIF
    error%=@f_symlink(naespfad_var$,lw_fs$+":\usr\bin\n_aes")
    '
    @create_aespath(naespfad_var$)
  ENDIF
  '
  ' Link setzen von xaaespfad_var$ auf /usr/bin/xaaes
  IF login_var&=3 OR login_var&=1 AND xaaespfad_var$<>""
    IF @exist(lw_fs$+":\usr\bin\xaaes",63)=0
      ~@f_kill(lw_fs$+":\usr\bin\xaaes")
    ENDIF
    error%=@f_symlink(xaaespfad_var$,lw_fs$+":\usr\bin\xaaes")
    '
    @create_aespath(xaaespfad_var$)
  ENDIF
  '
RETURN
> PROCEDURE create_aespath(aes_pfad$)
  '
  LOCAL a$
  CLR a$
  FOR i&=1 TO LEN(aes_pfad$)
    IF MID$(aes_pfad$,i&,1)<>"\" AND MID$(aes_pfad$,i&,1)<>":"
      a$=a$+MID$(aes_pfad$,i&,1)
    ENDIF
    IF MID$(aes_pfad$,i&,1)="\"
      a$=a$+"/"
    ENDIF
    IF MID$(aes_pfad$,i&,1)=":"
      a$=a$+""
    ENDIF
  NEXT i&
  '
  ' boot/mint/aespath anlegen
  fiha&=@f_create(boot$+":\mint\aespath")
  ~@f_println(fiha&,"/"+@lower$(a$),FALSE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE create_fstab
  LOCAL tab$,fiha&,drives%
  '
  ERASE drive$(),dos!()
  DIM drive$(30),dos!(30)
  '
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  ' Laufwerk C-T
  '
  FOR i&=2 TO 19
    IF BTST(drives%,i&)=TRUE
      IF @xhdi$(i&)<>"-1"
        IF CHAR{(@dcntl(&HF100,CHR$(65+i&)+":\"))+40}="ext2"
          dos!(i&)=FALSE
          drive$(i&)=@lower$(CHR$(65+i&))
        ELSE
          dos!(i&)=TRUE
          drive$(i&)=@lower$(CHR$(65+i&))
        ENDIF
        '        IF UPPER$(@xhdi$(i&))<>"LNX" AND UPPER$(@xhdi$(i&))<>"RAW"
        '        dos!(i&)=TRUE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ELSE
        '        dos!(i&)=FALSE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ENDIF
      ENDIF
    ENDIF
    IF BTST(drives%,i&)=FALSE
      drive$(i&)=""
    ENDIF
  NEXT i&
  '
  ' Laufwerk V-Z
  '
  FOR i&=21 TO 25
    IF BTST(drives%,(i&))=TRUE
      IF @xhdi$(i&)<>"-1"
        IF CHAR{(@dcntl(&HF100,CHR$(65+i&)+":\"))+40}="ext2"
          dos!(i&)=FALSE
          drive$(i&)=@lower$(CHR$(65+i&))
        ELSE
          dos!(i&)=TRUE
          drive$(i&)=@lower$(CHR$(65+i&))
        ENDIF
        '        IF UPPER$(@xhdi$(i&))<>"LNX" AND UPPER$(@xhdi$(i&))<>"RAW"
        '        dos!(i&)=TRUE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ELSE
        '        dos!(i&)=FALSE
        '        drive$(i&)=@lower$(CHR$(65+i&))
        '      ENDIF
      ENDIF
    ENDIF
    IF BTST(drives%,(i&))=FALSE
      drive$(i&)=""
    ENDIF
  NEXT i&
  '
  '
  tab$=CHR$(9)        ! Tabulator
  '
  fiha&=@f_create(lw_fs$+":\etc\fstab")
  FOR i&=2 TO 19
    IF drive$(i&)<>"" AND drive$(i&)<>@lower$(lw_fs$)
      IF dos!(i&)=TRUE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"dos"+tab$+"root"+tab$+"wheel"+tab$+"700",TRUE)
      ENDIF
      IF dos!(i&)=FALSE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+drive$(i&)+tab$+"ext2"+tab$+"-"+tab$+"-"+tab$+"-",TRUE)
      ENDIF
    ENDIF
    IF drive$(i&)=@lower$(lw_fs$)
      ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"ext2"+tab$+"root"+tab$+"wheel"+tab$+"777",TRUE)
    ENDIF
  NEXT i&
  '
  FOR i&=21 TO 25
    IF drive$(i&)<>"" AND drive$(i&)<>@lower$(lw_fs$)
      IF dos!(i&)=TRUE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"dos"+tab$+"root"+tab$+"wheel"+tab$+"700",TRUE)
      ENDIF
      IF dos!(i&)=FALSE
        ~@f_println(fiha&,drive$(i&)+tab$+"/"+drive$(i&)+tab$+"ext2"+tab$+"-"+tab$+"-"+tab$+"-",TRUE)
      ENDIF
    ENDIF
    IF drive$(i&)=@lower$(lw_fs$)
      ~@f_println(fiha&,drive$(i&)+tab$+"/"+tab$+"ext2"+tab$+"root"+tab$+"wheel"+tab$+"777",TRUE)
    ENDIF
  NEXT i&
  ~@f_close(fiha&)
RETURN
> PROCEDURE make_ttytab(start_mode&)
  LOCAL tab$,anfue$
  '
  ' /etc/ttytab erzeugen
  '
  tab$=CHR$(9)        ! Tabulator
  anfue$=CHR$(34)     ! AnfÅhrungszeichen
  '
  fiha&=@f_create(lw_fs$+":\etc\ttytab")                                      !("u:\etc\ttytab")
  ~@f_println(fiha&,"# /etc/ttytab",TRUE)
  ~@f_println(fiha&,"# Prinzipiell lÑuft auf der console ein normaler getty",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Es darf nur einer der EintrÑge aktiv sein!",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  IF login_var&=1       ! Login
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=2       ! N.AES starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=3       ! XaAES starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  IF login_var&=4       ! TOS starten
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/sbin/getty console"+anfue$+tab$+"vt52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/n_aes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"console"+tab$+anfue$+"/usr/bin/execgem"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
    ~@f_println(fiha&,"#console"+tab$+anfue$+"/usr/bin/xaaes"+anfue$+tab$+"tw52"+tab$+"on secure",TRUE)
  ENDIF
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# gettys auf den seriellen Schnittstellen",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Modems kînnen damit nicht ordentlich bedient werden, dafÅr gibt es",TRUE)
  ~@f_println(fiha&,"# mgetty. gettys werden mit on/off ein- oder ausgeschaltet",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttyS0"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Modem1",TRUE)
  ~@f_println(fiha&,"# ttyS1"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Modem2",TRUE)
  ~@f_println(fiha&,"# ttyS2"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Serial1",TRUE)
  ~@f_println(fiha&,"# ttyS3"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Serial2",TRUE)
  ~@f_println(fiha&,"# ttyS4"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Lan",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Bei MIDI ist es egal welche Baudrate man einstellt, es wird",TRUE)
  ~@f_println(fiha&,"# immer nur die einzig mîgliche genommen.",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttyS5"+tab$+anfue$+"/usr/sbin/getty std.19200"+anfue$+tab$+"dialup"+tab$+"off # Midi",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# Beispiel fÅr den mgetty.",TRUE)
  ~@f_println(fiha&,"#",TRUE)
  ~@f_println(fiha&,"# ttySx"+tab$+anfue$+"/usr/sbin/mgetty -x 6 ttySx"+anfue$+tab$+"dialup"+tab$+"on secure",TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE handle_package_tgz
  LOCAL eing&,i&
  '
  ' schritt 5
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  CLR i&,stepshow&
  REPEAT
    IF package$(i&)<>""
      @depack_package(package$(i&))
    ENDIF
    INC i&
  UNTIL i&>=6   ! Anzahl der TAR Pakete
  '
RETURN
> PROCEDURE depack_package(package$)
  LOCAL error%,eing&
  '
  CHDRIVE "u" ! Wichtig sonst werden die TARs nicht gefunden
  '
  '  ALERT 1,"Sollen die rpms in | /usr/src/redhat/RPMS | gespeichert werden?",1," Ja | Nein ",eing&
  '
  ' schritt 6
  INC stepshow&
  @messagewin_print(mw29_1$+" 5."+STR$(stepshow&)+"/6")
  '
  CLR paket_pfad_unix$
  paket_pfad_unix$=@lower$(@tos_to_unix_path$(em_start_pfad$+"pakete\"))
  '  PRINT paket_pfad_unix$
  '
  IF LEFT$(paket_pfad_unix$,2)="/u"   ! Wenn /u dann /u rauschneiden, da sonst Pfad nicht gefunden wird wenn von /u gestartet (/u/u/x)
    paket_pfad_unix$=MID$(paket_pfad_unix$,3)
  ENDIF
  '
  ' und auspacken
  prg$="/bin/tar"
  cmd$="xvf "+@lower$(paket_pfad_unix$)+package$+" -C /usr/src/redhat/RPMS/m68kmint/"
  '
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0) !+CHR$(0)
  '
  ' mw 20="...entpacke..."  name4="Entpacke"
  @messagewin_print(mw20_1$+" "+package$+"...")
  LET name$=name4$+" "+package$+"..."
  error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\package.out",install_path$+"\tmp\package.err",TRUE,TRUE,FALSE)
  IF error%=0
    ' mw 21 = "...erfolgreich entpackt"
    @messagewin_print(package$+" "+mw21_1$)
  ENDIF
RETURN
> PROCEDURE install_rpm_auto
  LOCAL x&,x$,v$,redhat$
  '
  '
  DEFMOUSE 2
  '
  CHDRIVE "u"
  ' rpm Datenbank initialisieren
  prg$="/bin/rpm"
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0)+"HOME=/root" !+CHR$(0)
  error%=@start_prg(0,prg$,"--initdb",env$,name$,"","",TRUE,FALSE,FALSE)
  '
  IF lstinst_var!=FALSE
    @setze_pfad_rpm
  ELSE
    ~@dsetdrv(lw_$)
    ~@dsetpath(rpm_pfad$)
  ENDIF
  '
  prg$="/bin/rpm"
  env$="UNIXMODE=/brUs"+CHR$(0)+"HOME=/root" !+CHR$(0)+CHR$(0)
  ' und auspacken
  '
  @install_rpms(prg$,env$)
  '
  DEFMOUSE 0
  '
RETURN
> PROCEDURE install_rpms(prg$,env$)
  '  $F%
  LOCAL s_z&,cmd$,i&,basic_max&,standard_max&,net_max&,devel_max&,libs_max&,x11_max&
  '
  ' schritt 7
  @messagewin_print(mw29_1$+" 6/6")
  '
  basic_max&=@count_packages("basic.lst")
  standard_max&=@count_packages("standard.lst")
  net_max&=@count_packages("net.lst")
  devel_max&=@count_packages("devel.lst")
  libs_max&=@count_packages("libs.lst")
  x11_max&=@count_packages("x11.lst")
  '
  ERASE basic$(),standard$(),net$(),devel$(),libs$(),x11$()
  DIM basic$(basic_max&),standard$(standard_max&),net$(net_max&),devel$(devel_max&),libs$(libs_max&),x11$(x11_max&)
  '
  @install_basic_rpms
  @install_standard_rpms
  @install_net_rpms
  @install_devel_rpms
  @install_libs_rpms
  @install_x11_rpms
  '
RETURN
> PROCEDURE setze_pfad_rpm !(rp$)
  LOCAL drives%,akt_lw%
  drives%=GEMDOS(14,GEMDOS(25))  ! Angemeldete Laufwerke abfragen
  '
  akt_lw%=GEMDOS(25) ! akt. Laufwerk ermitteln
  ~@dsetdrv("U")
  ~@dsetpath("\usr\src\redhat\RPMS\m68kmint")
RETURN
> FUNCTION tos_to_unix_path$(tos_path$)
  $F%
  LOCAL lw$,i%
  '
  CLR unix_path$
  lw$=LEFT$(tos_path$,1)
  '
  FOR i%=3 TO LEN(tos_path$)
    IF MID$(tos_path$,i%,1)="\"
      unix_path$=unix_path$+"/"
    ELSE
      unix_path$=unix_path$+MID$(tos_path$,i%,1)
    ENDIF
  NEXT i%
  '
  unix_path$="/"+lw$+unix_path$
  RETURN unix_path$
ENDFUNC
'
> PROCEDURE install_basic_rpms
  '
  LOCAL fiha&,x&,i&,basic_rpms_max&,pack_counter$
  '
  IF pakete_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\basic.lst",63)=0
      ' mw 22="Basic Paket wird installiert"
      @messagewin_print(STRING$(6,"*")+" "+mw22_1$+" "+STRING$(6,"*"))
      '
      fiha&=@f_open(em_start_pfad$+"pakete\basic.lst")
      REPEAT
        INC x&
        basic$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      basic_rpms_max&=x&
      FOR i&=1 TO basic_rpms_max&
        cmd$="-i "+basic$(i&)
        '
        ' mw 23=" Installiere" name5$="Installing rpms..."
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(basic_rpms_max&)+": "+mw23_1$+" "+basic$(i&)+"!")
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\basic.out",install_path$+"\tmp\basic.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw 24= "Fehler aufgetreten"
          @messagewin_print(mw24_1$+" "+basic$(i&)+"!")
          @print_error(install_path$+"\tmp\basic.err")
        ELSE
          @print_error(install_path$+"\tmp\basic.out")
        ENDIF
        '
        ' noarch Archive nach RPMS/noarch/ verschieben bzw. rpms lîschen falls gewÅnscht
        @move_noarch(basic$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\bi.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_standard_rpms
  '
  LOCAL fiha&,x&,i&,standard_rpms_max&,pack_counter$,datei$
  '
  IF man_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\standard.lst",63)=0
      ' mw25
      @messagewin_print("****** "+mw25_1$+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\standard.lst")
      REPEAT
        INC x&
        standard$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      standard_rpms_max&=x&
      FOR i&=1 TO standard_rpms_max&
        '
        ' mw23 name5
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(standard_rpms_max&)+": "+mw23_1$+" "+standard$(i&)+"!")
        '
        cmd$="-i "+standard$(i&)
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\standard.out",install_path$+"\tmp\standard.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw24
          @messagewin_print(mw24_1$+" "+standard$(i&)+"!")
          @print_error(install_path$+"\tmp\standard.err")
        ELSE
          @print_error(install_path$+"\tmp\standard.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(standard$(i&))
        '
      NEXT i&
      '
      '
      @save_chk(install_path$+"\tmp\si.chk")
      '
      ' timezone auswÑhlen
      '
      ' link von /usr/share/zoneinfo/XXX/XXX auf /etc/localtime
      '
      IF @exist("u:\etc\localtime",63)=0        ! /etc/localtime lîschen
        ~@f_kill("u:\etc\localtime")
      ENDIF
      '
      datei$=@fileselector$("Timezone?","u:\usr\share\zoneinfo\","",FALSE,"")
      '
      IF @exist(datei$,63)=0
        error%=@f_symlink(datei$,"u:\etc\localtime")
      ELSE
        error%=@f_symlink("u:\usr\share\zoneinfo\Europe\Berlin","u:\etc\localtime")
      ENDIF
      '
      @evnt_multi_loop
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_net_rpms
  '
  LOCAL fiha&,x&,i&,net_rpms_max&,pack_counter$
  '
  IF net_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\net.lst",63)=0
      ' mw26
      @messagewin_print("****** "+mw26_1$+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\net.lst")
      REPEAT
        INC x&
        net$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      net_rpms_max&=x&
      FOR i&=1 TO net_rpms_max&
        cmd$="-i "+net$(i&)
        '
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(net_rpms_max&)+": "+mw23_1$+" "+net$(i&)+"!")
        '
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\net.out",install_path$+"\tmp\net.err",TRUE,TRUE,FALSE)
        IF error%<>0
          '
          @messagewin_print(mw24_1$+net$(i&)+"!")
          @print_error(install_path$+"\tmp\net.err")
        ELSE
          @print_error(install_path$+"\tmp\net.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(net$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\ni.chk")
      '
      '   IF compi_var&=10
      '  ipadr$=@ip_fummel$(@aranym_net$("--get-atari-ip"))
      '  gateway$=@ip_fummel$(@aranym_net$("--get-host-ip"))
      ' netmask$=@ip_fummel$(@aranym_net$("--get-netmask"))
      ' ENDIF
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_devel_rpms
  '
  LOCAL fiha&,x&,i&,devel_rpms_max&,pack_counter$
  '
  IF devel_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\devel.lst",63)=0
      ' mw27
      @messagewin_print("****** "+mw27_1$+" ******")
      '
      fiha&=@f_open(em_start_pfad$+"pakete\devel.lst")
      REPEAT
        INC x&
        devel$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      devel_rpms_max&=x&
      FOR i&=1 TO devel_rpms_max&
        cmd$="-i "+devel$(i&)
        ' mw23 name5
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(devel_rpms_max&)+": "+mw23_1$+" "+devel$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\devel.out",install_path$+"\tmp\devel.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw24
          @messagewin_print(mw24_1$+devel$(i&)+"!")
          @print_error(install_path$+"\tmp\devel.err")
        ELSE
          @print_error(install_path$+"\tmp\devel.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(devel$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\di.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_libs_rpms
  '
  LOCAL fiha&,x&,i&,libs_rpms_max&,pack_counter$
  '
  IF libs_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\libs.lst",63)=0
      ' mw28
      @messagewin_print("****** "+mw28_1$+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\libs.lst")
      REPEAT
        INC x&
        libs$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      libs_rpms_max&=x&
      FOR i&=1 TO libs_rpms_max&
        cmd$="-i "+libs$(i&)
        ' mw23
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(libs_rpms_max&)+": "+mw23_1$+" "+libs$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\libs.out",install_path$+"\tmp\libs.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw24
          @messagewin_print(mw24_1$+" "+libs$(i&)+"!")
          @print_error(install_path$+"\tmp\libs.err")
        ELSE
          @print_error(install_path$+"\tmp\libs.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(libs$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\li.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE install_x11_rpms
  '
  LOCAL fiha&,x&,i&,x11_rpms_max&,pack_counter$
  '
  IF x11_var!=TRUE
    IF @exist(em_start_pfad$+"pakete\x11.lst",63)=0
      ' mw28
      @messagewin_print("****** "+mw31_1$+" ******")
      fiha&=@f_open(em_start_pfad$+"pakete\x11.lst")
      REPEAT
        INC x&
        x11$(x&)=@f_input$(fiha&,TRUE)
      UNTIL @f_eof(fiha&)
      ~@f_close(fiha&)
      x11_rpms_max&=x&
      FOR i&=1 TO x11_rpms_max&
        cmd$="-i "+x11$(i&)
        ' mw23
        LET name$=name5$
        IF i&<10
          pack_counter$="0"+STR$(i&)
        ELSE IF i&>=10
          pack_counter$=STR$(i&)
        ENDIF
        @messagewin_print(pack_counter$+"/"+STR$(x11_rpms_max&)+": "+mw23_1$+" "+x11$(i&)+"!")
        error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\x11.out",install_path$+"\tmp\x11.err",TRUE,TRUE,FALSE)
        IF error%<>0
          ' mw24
          @messagewin_print(mw24_1$+" "+x11$(i&)+"!")
          @print_error(install_path$+"\tmp\x11.err")
        ELSE
          @print_error(install_path$+"\tmp\x11.out")
        ENDIF
        ' noarch Archive nach RPMS/noarch/ verschieben
        @move_noarch(x11$(i&))
        '
      NEXT i&
      '
      @save_chk(install_path$+"\tmp\xi.chk")
      '
    ENDIF
  ENDIF
  '
RETURN
'
> FUNCTION aranym_net$(cmd$)
  LOCAL fiha&,error%
  '
  CHDRIVE "u"
  prg$="/sbin/nfeth-config"
  env$="UNIXMODE=/brUs"+CHR$(0)+"PATH=u:\bin,u:\sbin"+CHR$(0)+"HOME=/root" !+CHR$(0)
  '
  error%=@start_prg(0,prg$,cmd$,env$,name$,install_path$+"\tmp\nfeth.out",install_path$+"\tmp\nfeth.err",TRUE,TRUE,FALSE)
  IF error%=0
    fiha&=@f_open(install_path$+"\tmp\nfeth.out")
    nfeth$=@f_input$(fiha&,TRUE)
    error%=@f_close(fiha&)
  ENDIF
  '
  RETURN nfeth$
ENDFUNC
'
> PROCEDURE save_chk(chk$)
  LOCAL fiha&
  '
  fiha&=@f_create(chk$)
  error%=@f_println(fiha&,"installiert",FALSE)
  error%=@f_close(fiha&)
RETURN
> FUNCTION count_packages(pack$)
  $F%
  '
  LOCAL fiha&,dummy$,max&
  '
  IF @exist(em_start_pfad$+"pakete\"+pack$,63)=0
    fiha&=@f_open(em_start_pfad$+"pakete\"+pack$)
    REPEAT
      dummy$=@f_input$(fiha&,TRUE)
      INC max&
    UNTIL @f_eof(fiha&)
    ~@f_close(fiha&)
  ENDIF
  RETURN max&
ENDFUNC
> PROCEDURE move_noarch(pack$)
  LOCAL redhat$
  '
  redhat$="u:\usr\src\redhat\RPMS\"
  '
  IF rpmsja_var!=FALSE
    IF RIGHT$(pack$,LEN("m68kmint.rpm"))="m68kmint.rpm"
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
    IF RIGHT$(pack$,LEN("noarch.rpm"))="noarch.rpm"
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
  ELSE IF rpmsja_var!=TRUE
    IF RIGHT$(pack$,LEN("noarch.rpm"))="noarch.rpm"
      @ug_copy1(redhat$+"m68kmint\"+pack$,redhat$+"noarch\"+pack$)
      ~@f_kill(redhat$+"m68kmint\"+pack$)
    ENDIF
  ENDIF
RETURN
> PROCEDURE print_error(errorfile$)
  LOCAL error$,fiha&
  IF @exist(errorfile$,63)=0
    fiha&=@f_open(errorfile$)
    IF @f_lof(fiha&)>0
      REPEAT
        error$=@f_input$(fiha&,TRUE)
        @messagewin_print(error$)
      UNTIL @f_eof(fiha&)=TRUE
      @messagewin_print(" ")
    ENDIF
    error%=@f_close(fiha&)
  ENDIF
RETURN
'
> PROCEDURE mintcnf_create(init!)
  LOCAL eing&,fiha&,tab$,xx$,cache&
  '
  mintcnf_pfad$="\mint\1-16-cur\mint.cnf"
  '
  IF @exist(boot$+":"+mintcnf_pfad$,63)=0
    ~@f_kill(boot$+":"+mintcnf_pfad$)
  ENDIF
  '
  tab$=CHR$(9)
  '
  fiha&=@f_create(boot$+":"+mintcnf_pfad$)                                !("u:\etc\ttytab")
  ~@f_println(fiha&,"# MINT.CNF erstellt von EasyMiNT Installer am "+DATE$+" um "+TIME$,FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"SLICES=2",FALSE)
  ~@f_println(fiha&,"NEWFATFS=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,V,W,X,Y,Z",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# filesystem cache (kb)",FALSE)
  ~@f_println(fiha&,"# more memory increases the filesystem speed",FALSE)
  ' RAM Kalkulieren
  ' PRINT "Gesamtes RAM: ";@ram_calc
  IF @ram_calc<14
    cache&=256
  ENDIF
  IF @ram_calc>=14 AND @ram_calc<20
    cache&=512
  ENDIF
  IF @ram_calc>=20 AND @ram_calc<32
    cache&=1024
  ENDIF
  IF @ram_calc>=32 AND @ram_calc<64
    cache&=2048
  ENDIF
  IF @ram_calc>=64
    cache&=4096
  ENDIF
  '
  ~@f_println(fiha&,"CACHE="+STR$(cache&),FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# enable VFAT (long names) for this drives",FALSE)
  ~@f_println(fiha&,"# (can be changed in runtime by FSetter too)",FALSE)
  ~@f_println(fiha&,"# VFAT=D,E",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# enable write protection for this drives",FALSE)
  ~@f_println(fiha&,"# (can be changed in runtime by FSetter too)",FALSE)
  ~@f_println(fiha&,"# WRITEPROTECT=",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# completly remove drive B:",FALSE)
  ~@f_println(fiha&,"# HIDE_B=Y",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Links zu EasyMiNT",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\bin"+tab$+"u:\bin",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\lib"+tab$+"u:\lib",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\etc"+tab$+"u:\etc",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\home"+tab$+"u:\home",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\usr"+tab$+"u:\usr",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\tmp"+tab$+"u:\tmp",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\var"+tab$+"u:\var",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\sbin"+tab$+"u:\sbin",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\root"+tab$+"u:\root",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\opt"+tab$+"u:\opt",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\mnt"+tab$+"u:\mnt",FALSE)
  ~@f_println(fiha&,"sln "+lw_fs$+":\boot"+tab$+"u:\boot",FALSE)
  ~@f_println(fiha&,"echo",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Environment",FALSE)
  ~@f_println(fiha&,"setenv PCONVERT PATH,HOME,SHELL",FALSE)
  ~@f_println(fiha&,"setenv UNIXMODE /brUs",FALSE)
  ~@f_println(fiha&,"setenv PATH u:\bin,u:\usr\bin,u:\usr\sbin,u:\sbin,u:\boot\mint\bin,"+boot$+":\xaaes",FALSE)
  ~@f_println(fiha&,"#",FALSE)
  '
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Autostartprogramme",FALSE)
  '
  ' FPU Emulation starten
  IF compi_var&=5
    ~@f_println(fiha&,"exec "+boot$+":\mint\68882.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=6
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu__2m.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=7 OR compi_var&=8
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu__3.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  IF compi_var&=9
    ~@f_println(fiha&,"exec "+boot$+":\mint\fpu40v1.prg",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  ' Filesystemcheck starten
  IF init!=TRUE
    IF filecheck_var!=TRUE
      ~@f_println(fiha&,"# Filesystemcheck (mandatory)",FALSE)
      ~@f_println(fiha&,"exec u:\"+boot$+"\mint\bin\sh u:\"+boot$+"\mint\bin\fscheck.sh",FALSE)
      ~@f_println(fiha&,"echo",FALSE)
    ENDIF
  ENDIF
  ' AESDIR setzen
  IF naespfad_var$<>""
    xx$=LEFT$(naespfad_var$,LEN(naespfad_var$)-(LEN(naespfad_var$)-RINSTR(naespfad_var$,"\")))
    ~@f_println(fiha&,"setenv AESDIR "+xx$,FALSE)
  ENDIF
  ~@f_println(fiha&,"#",FALSE)
  IF init!=TRUE
    ~@f_println(fiha&,"# Timezone (mandatory)",FALSE)
    ~@f_println(fiha&,"exec"+tab$+"u:\sbin\tzinit -l",FALSE)
    ~@f_println(fiha&,"echo",FALSE)
  ENDIF
  ~@f_println(fiha&,"#",FALSE)
  ~@f_println(fiha&,"# Additional tools",FALSE)
  ~@f_println(fiha&,"# Draconis to MiNT-Net gateway",FALSE)
  ~@f_println(fiha&,"# exec u:\usr\sbin\mgw",FALSE)
  ~@f_println(fiha&,"# echo",FALSE)
  ~@f_println(fiha&,"# Gluestik - STiK/STiNG to MiNT-Net gateway",FALSE)
  ~@f_println(fiha&,"# exec u:\usr\sbin\gluestik",FALSE)
  ~@f_println(fiha&,"# echo",FALSE)
  '
  ~@f_println(fiha&,"cd u:\",FALSE)
  IF init!=TRUE
    ~@f_println(fiha&,"INIT=u:\sbin\init",FALSE)
  ELSE IF init!=FALSE
    ~@f_println(fiha&,"GEM=ROM",FALSE)
  ENDIF
  ~@f_println(fiha&,"echo Setup complete, now booting system...",FALSE)
  ~@f_println(fiha&,"echo",FALSE)
  ~@f_close(fiha&)
  '
  '  @endconf_info
RETURN
'
' MiNT-Net konfigurieren
'
> PROCEDURE net_config
  LOCAL eing1&,eing2&
  '  ALERT 1," Soll MiNT-Net noch | konfiguriert werden? ",1," Ja | Nein ",eing1&
  ALERT 1,alert14_1$,1,alert14_2$,eing1&
  IF eing1&=1
    mintnet_flag!=TRUE
    '    ALERT 1," Haben Sie eine Netz- | werkkarte oder ein Modem? ",1," NK | Modem ",eing2&
    IF compi_var&<>10
      ALERT 1,alert15_1$,2,alert15_2$,eing2&
      IF eing2&=1
        nk_flag!=TRUE
      ELSE IF eing2&=2
        nk_flag!=FALSE
      ENDIF
    ELSE
      nk_flag!=TRUE
    ENDIF
  ELSE
    mintnet_flag!=FALSE
  ENDIF
RETURN
> PROCEDURE netzwerk_config
  IF compi_var&=10      ! Wenn ARAnyM, IP Adressen vorbelegen und disablen
    kuerzel_var$="eth0"
    ipadr_var$=ipadr$
    netmask_var$=netmask$
    gateway_var$=gateway$
    @rsc_setup_tree(nic&)
    @rsc_ob_disable(nic&,kuerzel&,TRUE)
    @rsc_ob_disable(nic&,netmask&,TRUE)
    @rsc_ob_disable(nic&,gateway&,TRUE)
    @rsc_ob_disable(nic&,ipadr&,TRUE)
  ENDIF
  nic_hdle&=@win_open_dialog(2,nic&,-1)
RETURN
> PROCEDURE modem_config
  ppp_hdle&=@win_open_dialog(2,ppp&,-1)
RETURN
> PROCEDURE nic_driver_copy
  LOCAL datei$
  IF compi_var&<>10
    datei$=@fileselector$("NIC Treiber?",boot$+":\*.*","",FALSE,"")
    IF @exist(datei$,63)=0
      @filename(datei$,match$)
      @ug_copy1(datei$,boot$+":\MINT\1-16-CUR\"+match$)
    ENDIF
  ENDIF
RETURN
'
' Netzwerkkarte konfigurieren
'
> PROCEDURE nic_auswert
  LOCAL fiha&,ipadr$,netmask$
  '
  ipadr$=@ip_fummel_back$(ipadr_var$)
  netmask$=@ip_fummel_back$(netmask_var$)
  dns$=@ip_fummel_back$(dns_var$)
  '
  @config.if_create(ipadr$,netmask$)
  @domainname_create
  @hostname_create
  @defaultroute_create
  @resolv.conf_create
  '
RETURN
> PROCEDURE config.if_create(a1$,a2$)
  LOCAL error%,config.if_path$
  '
  config.if_path$="u:\etc\sysconfig\config.if"
  '
  setup_interface$=kuerzel_var$+" "+a1$+" "+@ip_cut$(a1$,"0")+" "+a2$+" "+@ip_cut$(a1$,"255")
  '
  IF @exist(config.if_path$,63)=0
    ~@f_kill(config.if_path$)
  ENDIF
  '
  fiha&=@f_create(config.if_path$)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# [ this file must follow the unix convention - save with no CR !!! ]",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# static interface configuration goes here",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# syntax:",TRUE)
  error%=@f_println(fiha&,"# <interface> <ipaddr> <network> <netmask> <broadaddr>",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# example: ne0 192.168.0.10 192.168.0.0 255.255.255.0 192.168.0.255",TRUE)
  error%=@f_println(fiha&,"#          this setup interface ne0 with IP 192.168.0.10",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  '
  error%=@f_println(fiha&,setup_interface$,TRUE)
  '
  ~@f_close(fiha&)
RETURN
> PROCEDURE domainname_create
  LOCAL fiha&,domainname_path$
  '
  domainname_path$="u:\etc\sysconfig\domainname"
  '
  IF @exist(domainname_path$,63)=0
    ~@f_kill(domainname_path$)
  ENDIF
  '
  fiha&=@f_create(domainname_path$)
  error%=@f_println(fiha&,domaine_var$,TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE hostname_create
  LOCAL fiha&,hostname_path$
  '
  hostname_path$="u:\etc\sysconfig\hostname"
  '
  IF @exist(hostname_path$,63)=0
    ~@f_kill(hostname_path$)
  ENDIF
  '
  fiha&=@f_create(hostname_path$)
  error%=@f_println(fiha&,hn_var$,TRUE)
  ~@f_close(fiha&)
  '
RETURN
> PROCEDURE defaultroute_create
  LOCAL fiha&,defaultroute_path$
  '
  defaultroute_path$="u:\etc\sysconfig\defaultroute"
  '
  IF @exist(defaultroute_path$,63)=0
    ~@f_kill(defaultroute_path$)
  ENDIF
  '
  fiha&=@f_create(defaultroute_path$)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# [ this file must follow the unix convention - save with no CR !!! ]",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# static default gateway configuration goes here",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# syntax:",TRUE)
  error%=@f_println(fiha&,"# <interface> <gateway>",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,"# example: ne0 192.168.0.200",TRUE)
  error%=@f_println(fiha&,"#          this set the defaultroute over ne0 to IP 192.168.0.200",TRUE)
  error%=@f_println(fiha&,"#",TRUE)
  error%=@f_println(fiha&,kuerzel_var$+" "+@ip_fummel_back$(gateway_var$),TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE resolv.conf_create
  LOCAL fiha&,resolv_path$
  '
  resolv_path$="u:\etc\resolv.conf"
  '
  IF @exist(resolv_path$,63)=0
    ~@f_kill(resolv_path$)
  ENDIF
  '
  fiha&=@f_create(resolv_path$)
  error%=@f_println(fiha&,"domain "+domaine_var$,TRUE)
  error%=@f_println(fiha&,"nameserver "+@ip_fummel_back$(dns_var$),TRUE)
  ~@f_close(fiha&)
RETURN
'
' ppp konfigurieren
'
> PROCEDURE ppp_auswert
  '
  SELECT device_var&
  CASE 1
    device$="/dev/ttyS0"
  CASE 2
    device$="/dev/ttyS1"
  CASE 3
    device$="/dev/ttyS2"
  CASE 4
    device$="/dev/ttyS3"
  CASE 5
    device$="/dev/ttyS4"
  ENDSELECT
  '
  SELECT speed_var&
  CASE 1
    speed$="9600"
  CASE 2
    speed$="19200"
  CASE 3
    speed$="38400"
  CASE 4
    speed$="57600"
  CASE 5
    speed$="76800"
  CASE 6
    speed$="115200"
  CASE 7
    speed$="230400"
  ENDSELECT
  '
  @pap_secrets
  @pppchat
  @peers
  @resolv
  '
RETURN
> PROCEDURE pap_secrets
  LOCAL fiha&,papsecrets_path$
  '
  papsecrets_path$="u:\etc\ppp\pap-secrets"
  '
  IF @exist(papsecrets_path$,63)=0
    ~@f_kill(papsecrets_path$)
  ENDIF
  '
  fiha&=@f_create(papsecrets_path$)
  error%=@f_println(fiha&,user_var$+CHR$(9)+"*"+CHR$(9)+passwd$,TRUE)
  ~@f_close(fiha&)
  '
  ~@fchmod(papsecrets_path$,&O600)
RETURN
> PROCEDURE pppchat
  LOCAL fiha&,pppchat_path$
  '
  pppchat_path$="u:\etc\ppp\pppchat"
  quote$=CHR$(34)
  '
  IF @exist(pppchat_path$,63)=0
    ~@f_kill(pppchat_path$)
  ENDIF
  '
  fiha&=@f_create(pppchat_path$)
  error%=@f_println(fiha&,"TIMEOUT 60",TRUE)
  error%=@f_println(fiha&,"ABORT "+quote$+"NO DIALTONE"+quote$,TRUE)
  error%=@f_println(fiha&,"ABORT "+quote$+"NO CARRIER"+quote$,TRUE)
  error%=@f_println(fiha&,"ABORT BUSY",TRUE)
  error%=@f_println(fiha&,"ABORT ERROR",TRUE)
  error%=@f_println(fiha&,quote$+quote$+" "+atz_var$,TRUE)
  error%=@f_println(fiha&,"OK atdt"+ispnumber_var$,TRUE)
  error%=@f_println(fiha&,"CONNECT",TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE peers
  LOCAL fiha&,peers_path$
  '
  peers_path$="u:\etc\ppp\peers\"+ispname_var$
  '
  IF @exist(peers_path$,63)=0
    ~@f_kill(peers_path$)
  ENDIF
  '
  fiha&=@f_create(peers_path$)
  error%=@f_println(fiha&,device$,TRUE)
  error%=@f_println(fiha&,speed$,TRUE)
  error%=@f_println(fiha&,"crtscts",TRUE)
  error%=@f_println(fiha&,"modem",TRUE)
  error%=@f_println(fiha&,"defaultroute",TRUE)
  error%=@f_println(fiha&,"noauth",TRUE)
  error%=@f_println(fiha&,@ip_fummel_back$(localip_var$)+":"+@ip_fummel_back$(remoteip_var$),TRUE)
  error%=@f_println(fiha&,"user "+user_var$,TRUE)
  error%=@f_println(fiha&,"connect "+quote$+"/usr/sbin/chat -f /etc/ppp/pppchat"+quote$,TRUE)
  ~@f_close(fiha&)
RETURN
> PROCEDURE resolv
  LOCAL fiha&,resolv_path$
  '
  resolv_path$="u:\etc\resolv.conf"
  '
  IF @exist(resolv_path$,63)=0
    ~@f_kill(resolv_path$)
  ENDIF
  '
  fiha&=@f_create(resolv_path$)
  error%=@f_println(fiha&,"domain "+pppdomain_var$,TRUE)
  error%=@f_println(fiha&,"nameserver "+@ip_fummel_back$(nameserver_var$),TRUE)
  ~@f_close(fiha&)
RETURN
'
> FUNCTION ip_cut$(ip$,last$)
  $F%
  LOCAL last_p_pos&
  '
  last_p_pos&=LEN(ip$)-RINSTR(ip$,".")
  '
  cut$=LEFT$(ip$,LEN(ip$)-last_p_pos&)
  cut$=cut$+last$
  '
  RETURN cut$
ENDFUNC
> FUNCTION ip_fummel$(fummel$)
  $F%
  LOCAL a&,i&,pos1&,pos2&,pos3&,eins$,zwei$,drei$,vier$
  IF fummel$<>""
    DIM punkt_pos&(3)
    FOR i&=1 TO LEN(fummel$)
      IF MID$(fummel$,i&,1)="."
        INC a&
        punkt_pos&(a&)=i&
      ENDIF
    NEXT i&
    pos1&=punkt_pos&(1)
    pos2&=punkt_pos&(2)
    pos3&=punkt_pos&(3)
    ERASE punkt_pos&()
    eins$=SPACE$(3)
    zwei$=SPACE$(3)
    drei$=SPACE$(3)
    vier$=SPACE$(3)
    RSET eins$=LEFT$(fummel$,PRED(pos1&))
    RSET zwei$=MID$(fummel$,SUCC(pos1&),PRED(pos2&-pos1&))
    RSET drei$=MID$(fummel$,SUCC(pos2&),PRED(pos3&-pos2&))
    RSET vier$=RIGHT$(fummel$,LEN(fummel$)-pos3&)
    ret$=eins$+zwei$+drei$+vier$
  ENDIF
  RETURN ret$
ENDFUNC
> FUNCTION ip_fummel_back$(t$)
  $F%
  LOCAL eins$,zwei$,drei$,vier$
  eins$=TRIM$(LEFT$(t$,3))
  zwei$=TRIM$(MID$(t$,4,3))
  drei$=TRIM$(MID$(t$,7,3))
  vier$=TRIM$(MID$(t$,10,3))
  bastel_ip$=eins$+"."+zwei$+"."+drei$+"."+vier$
  IF bastel_ip$="..."
    bastel_ip$=""
  ENDIF
  RETURN bastel_ip$
ENDFUNC
'
> FUNCTION invisible_text$(input$,tree&,curspos&,VAR invisible$)
  $F%
  LOCAL l$,m$,r$
  '
  LET new_chars&=LEN(input$)-LEN(invisible$)
  LET l$=LEFT$(invisible$,curspos&-MAX(0,new_chars&))
  LET m$=MID$(input$,curspos&-new_chars&+1,MAX(0,new_chars&))
  LET r$=MID$(invisible$,curspos&-new_chars&+1)
  '
  LET invisible$=l$+m$+r$
  '
  RETURN STRING$(LEN(input$),"*")
ENDFUNC
'
> PROCEDURE endconf_info
  '
  @message2(ende_1$,ende_2$,ende_3$,ende_4$,ende_5$,ende_6$,ende_7$)
  endconf_info!=TRUE
RETURN
> PROCEDURE newdesk_auto_del
  LOCAL i&,a&,x&,zw&,fiha&,fiha1&,endof&
  '
  IF @exist(boot$+":\newdesk.inf",63)=0
    fiha&=@f_open(boot$+":\newdesk.inf")
    REPEAT
      newdesk$(i&)=@f_input$(fiha&,FALSE)
      INC i&
    UNTIL @f_eof(fiha&)=TRUE
    endof&=(i&-1)
    ~@f_close(fiha&)
    '
    FOR i&=0 TO endof&
      IF INSTR(newdesk$(i&),"#Z")<>0
        zw&=i&
      ENDIF
    NEXT i&
    '
    IF zw&<>0
      FOR x&=zw& TO endof&
        newdesk$(x&)=newdesk$(x&+1)
      NEXT x&
      DEC endof&
    ENDIF
    '
    ~@f_kill(boot$+":\newdesk.inf")
    '
    fiha1&=@f_create(boot$+":\newdesk.inf")
    FOR a&=0 TO endof&
      error%=@f_println(fiha1&,newdesk$(a&),FALSE)
    NEXT a&
    ~@f_close(fiha1&)
  ENDIF
  ' ############### TMP\position.tmp lîschen
  '  IF @exist(install_path$+"\tmp\position.tmp",63)=0
  '  ~@f_kill(install_path$+"\tmp\position.tmp")
  ' ENDIF
  '
RETURN
'
> PROCEDURE message(modal&,t1$,t2$,t3$,t4$,t5$,t6$,t7$)
  @rsc_set_text(message&,mes1&,t1$)
  @rsc_set_text(message&,mes2&,t2$)
  @rsc_set_text(message&,mes3&,t3$)
  @rsc_set_text(message&,mes4&,t4$)
  @rsc_set_text(message&,mes5&,t5$)
  @rsc_set_text(message&,mes6&,t6$)
  @rsc_set_text(message&,mes7&,t7$)
  mes_hdle&=@win_open_dialog(modal&,message&,-1)
RETURN
> PROCEDURE message2(t1$,t2$,t3$,t4$,t5$,t6$,t7$)
  @rsc_set_text(message2&,mes1_00&,t1$)
  @rsc_set_text(message2&,mes2_00&,t2$)
  @rsc_set_text(message2&,mes3_00&,t3$)
  @rsc_set_text(message2&,mes4_00&,t4$)
  @rsc_set_text(message2&,mes5_00&,t5$)
  @rsc_set_text(message2&,mes6_00&,t6$)
  @rsc_set_text(message2&,mes7_00&,t7$)
  mes2_hdle&=@win_open_dialog(1,message2&,-1)
RETURN
> FUNCTION xhdi$(bios_dev)
  $F%
  '
  return%=C:xhdi_call%(28,12,bios_dev,L:V:major,L:V:minor,L:V:start_sec%,L:xhdi_bpb%,L:V:blocks%,L:V:partid%)
  IF return%=0
    RETURN CHAR{V:partid%}
  ELSE
    RETURN "-1"
  ENDIF
ENDFUNC
> FUNCTION diskinfo(drv$)
  LOCAL d%,q%,ret&,akt_drv%
  '
  ' aktuelles Laufwerk
  akt_drv%=GEMDOS(25)
  '
  ' Neues akt. Laufwerk setzen
  d%=ASC(UPPER$(drv$))-64
  ~GEMDOS(14,d%)
  '
  dfree$=STRING$(4*4,0)
  q%=V:dfree$
  d%=ASC(UPPER$(drv$))-64
  ret&=GEMDOS(54,L:q%,d%)
  cluster.free=LONG{q%}
  cluster.total=LONG{q%+4}
  sector.size=LONG{q%+8}
  sect.per.clust=LONG{q%+12}
  cluster.size=LONG{q%+12}*sector.size
  '
  size.free=sector.size*sect.per.clust*cluster.free
  '
  ' Altes akt. Laufwerk zurÅcksetzen
  ~GEMDOS(14,akt_drv%)
  '
  '
  RETURN size.free
  '  RETURN {diskinfo%+8}*{diskinfo%+12}*{diskinfo%}
  '
ENDFUNC
'
> FUNCTION dcntl(opcode%,path$)
  $F%
  '
  LOCAL buf$
  path$=path$+CHR$(0)
  '
  buf$=SPACE$(256)
  q%=V:buf$
  '
  error%=GEMDOS(304,opcode%,L:V:path$,L:q%)
  '
  RETURN q%
ENDFUNC
> PROCEDURE open_start_dial(name$)
  @aes_screen_lock
  DEFMOUSE 2
  @rsc_set_text(startprg&,appname&,name$)
  startprg_hdle&=@win_open_dialog(1,startprg&,-1)
  DO
    event&=EVNT_MULTI(&X110000,1,1,1,0,0,0,0,0,0,0,0,0,0,0,100,mx&,my&,mb&,ks&,key&,mc&)
    IF BTST(event&,4)
      @main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
    ENDIF
  LOOP UNTIL BTST(event&,5)
RETURN
> PROCEDURE close_start_dial
  @win_close(startprg_hdle&)
  @mw_redraw
  DEFMOUSE 0
  @aes_clear_buffers
  @aes_screen_unlock
RETURN
> FUNCTION start_prg(mode&,prg$,cmd$,env$,name$,stdout$,stderr$,argv!,redir!,dialog!)
  $F%
  '
  IF dialog!=TRUE
    @open_start_dial(name$)
  ENDIF
  '
  IF argv!=TRUE
    @program_build_cmd_argv(prg$,cmd$,env$)
    prg$=prg$+CHR$(0)
  ELSE
    prg$=prg$+CHR$(0)
    cmd$=CHR$(LEN(cmd$))+cmd$+CHR$(0)
    env$=env$+CHR$(0)
  ENDIF
  '
  IF redir!=TRUE
    fd%=@start_redirect(stdout$,alter_stdout%)
    fd1%=@start_redirect_err(stderr$,alter_stderr%)
  ENDIF
  '
  '
  error%=GEMDOS(75,mode&,L:V:prg$,L:V:cmd$,L:V:env$)        !Pexec
  '
  IF redir!=TRUE
    @stop_redirect(fd%,alter_stdout%)
    @stop_redirect_err(fd1%,alter_stderr%)
  ENDIF
  '
  IF dialog!=TRUE
    @close_start_dial
  ENDIF
  '
  RETURN error%
ENDFUNC
> FUNCTION start_redirect(out$,VAR alter_stdout%)
  $F%
  redir%=GEMDOS(69,W:1) !Fdup() stdout
  alter_stdout%=redir%
  out$=out$+CHR$(0)
  redir%=GEMDOS(60,L:V:out$,W:0)  ! Create file Fcreate()
  fd%=redir%
  redir%=GEMDOS(70,W:1,W:fd%)     ! Fforce() stdout
  RETURN fd%
ENDFUNC
> PROCEDURE stop_redirect(fd%,alter_stdout%)
  ~GEMDOS(62,W:fd%)           ! Fclose()
  ~GEMDOS(70,W:1,W:alter_stdout%) ! Fforce()
  ~GEMDOS(62,W:alter_stdout%)     ! Fclose()
RETURN
> FUNCTION start_redirect_err(dev$,VAR alter_stderr%)
  $F%
  redir_err%=GEMDOS(69,W:2) !Fdup()
  alter_stderr%=redir_err%
  dev$=dev$+CHR$(0)
  redir_err%=GEMDOS(60,L:V:dev$,W:0)  ! Create file Fcreate()
  fd1%=redir_err%
  redir_err%=GEMDOS(70,W:2,W:fd1%)     ! Fforce()
  RETURN fd1%
ENDFUNC
> PROCEDURE stop_redirect_err(fd1%,alter_stderr%)
  ~GEMDOS(62,W:fd1%)           ! Fclose()
  ~GEMDOS(70,W:2,W:alter_stderr%) ! Fforce()
  ~GEMDOS(62,W:alter_stderr%)     ! Fclose()
RETURN
> FUNCTION program_build_argv$(prgnam$,cmd$)
  $F%
  LOCAL pos&,argv$,null$,nullcount&
  CLR argv$
  CLR null$
  LET nullcount&=1
  LET cmd$=@program_cml_unbuild$(cmd$)
  WHILE LEN(cmd$)>0
    LET pos&=INSTR(cmd$,CHR$(0))
    IF pos&=0
      LET pos&=SUCC(LEN(cmd$))
    ENDIF
    IF pos&=1
      IF null$=""
        LET null$="NULL:"
      ELSE
        LET null$=null$+","
      ENDIF
      LET null$=null$+STR$(nullcount&)
      LET argv$=argv$+" "+CHR$(0)
    ELSE
      LET argv$=argv$+LEFT$(cmd$,PRED(pos&))+CHR$(0)
    ENDIF
    LET cmd$=MID$(cmd$,SUCC(pos&))
    INC nullcount&
  WEND
  RETURN "ARGV="+null$+CHR$(0)+prgnam$+CHR$(0)+argv$+CHR$(0)
ENDFUNC
> PROCEDURE program_build_cmd_argv(prgnam$,VAR cmd$,env$)
  LET cmd$=@program_cml_build$(cmd$)
  LET env$=LEFT$(env$,MAX(0,PRED(LEN(env$))))
  LET env$=env$+@program_build_argv$(prgnam$,cmd$)
  LET cmd$=CHR$(127)+LEFT$(cmd$+STRING$(127,0),127)
RETURN
> FUNCTION lower$(gross$)
  LOCAL i%
  DIM hilf$(100)
  klein$=""
  FOR i%=1 TO LEN(gross$)
    hilf$(i%)=MID$(gross$,i%,1)
    IF ASC(hilf$(i%))>=65 AND ASC(hilf$(i%))<=90
      hilf$(i%)=CHR$(ASC(hilf$(i%))+32)
    ENDIF
    klein$=klein$+hilf$(i%)
  NEXT i%
  ERASE hilf$()
  RETURN klein$
ENDFUNC
> FUNCTION cancel_inst
  $F%
  ' alert 12
  ALERT 2,alert12_1$,2,alert12_2$,inp&
  RETURN inp&
ENDFUNC
> PROCEDURE mw_redraw
  IF messagewin_windowhandle_&<>0
    @evnt_multi_loop
    '    @redraw_userwindow(messagewin_windowhandle_&,mw_x&,mw_y&,mw_b&,mw_h&)
  ENDIF
RETURN
> FUNCTION ram_calc
  $F%
  ramtop%=LPEEK(&H5A4)
  phystop%=LPEEK(&H42E)
  '
  IF ramtop%>0
    tt_ram%=ramtop%-(16*1024*1024)
  ELSE
    tt_ram%=0
  ENDIF
  '
  ges_ram%=(phystop%+tt_ram%)/1024/1024
  '
  RETURN ges_ram%
ENDFUNC
' '
> PROCEDURE set_popup_text(index&,objekt&,p_text$)
  @rsc_set_text(preinst&,objekt&,p_text$)
  @rsc_ob_draw(index&,objekt&)
RETURN
'
> FUNCTION fpipe(fds%)
  $F%
  '
  RETURN GEMDOS(256,L:fds%)
ENDFUNC
> FUNCTION fforce(std&,nonstd%)
  $F%
  RETURN GEMDOS(70,std&,W:nonstd%)
ENDFUNC
> FUNCTION fcntl(fh&,arg%,cmd&)
  $F%
  '
  RETURN GEMDOS(260,fh&,L:arg%,cmd&)
ENDFUNC
> FUNCTION fread(x&,a%,b%)
  $F%
  ' proc(305)
  RETURN GEMDOS(63,x&,L:a%,L:b%) !a%:LÑnge b%:Adresse
ENDFUNC
> FUNCTION f_symlink(a$,b$)
  $F%
  '
  '
  a$=a$+CHR$(0)
  b$=b$+CHR$(0)
  '
  RETURN GEMDOS(302,L:V:a$,L:V:b$)
ENDFUNC
> FUNCTION pfork
  $F%
  RETURN GEMDOS(283)
ENDFUNC
> FUNCTION pexec(mode&,prg$,cmd$,env$)
  prg$=prg$+CHR$(0)
  cmd$=CHR$(LEN(cmd$))+cmd$+CHR$(0)
  env$=env$+CHR$(0)
  RETURN GEMDOS(75,mode&,L:V:prg$,L:V:cmd$,L:V:env$)        !Pexec
ENDFUNC
> FUNCTION pterm
  $F%
  ~GEMDOS(76,retcode&)
  RETURN retcode&
ENDFUNC
'
> FUNCTION pipe(mode&,prg$,cmd$,env$,argv!)
  $F%
  LOCAL ret%,stdout&,stderr&,pid&,waiting_bytes%,xx$,i&,buffer$,rusage%
  '
  stdout&=1
  stderr&=2
  '
  ERASE fds&()
  DIM fds&(1)
  ret%=@fpipe(V:fds&(0))
  '
  IF ret%=0
    LET pid&=@pfork
    '
    IF pid&=0
      '
      ' child process
      ret%=@fforce(stdout&,fds&(1))           !stdout nach Schreibende pipe
      IF ret%<0
        '        PRINT "Error: ";ret%
      ELSE
        ret%=@fcntl(stdout&,0,1)                !F_GETFD
        ret%=@fcntl(stdout&,AND(ret%,&H1),2)    !F_SETFD
      ENDIF
      '
      ret%=@fforce(stderr&,fds&(1))           ! stderr nach Schreibende pipe
      IF ret%<0
        '       PRINT "Error: ",ret%
      ELSE
        ret%=@fcntl(stderr&,0,1)                !F_GETFD
        ret%=@fcntl(stderr&,AND(ret%,&H1),2)    !F_SETFD
      ENDIF
      '
      IF argv!=TRUE
        @program_build_cmd_argv(prg$,cmd$,env$)
        prg$=prg$+CHR$(0)
      ELSE
        prg$=prg$+CHR$(0)
        cmd$=CHR$(LEN(cmd$))+cmd$+CHR$(0)
        env$=env$+CHR$(0)
        '
      ENDIF
      '
      error&=GEMDOS(75,mode&,L:V:prg$,L:V:cmd$,L:V:env$)        !Pexec
      '
      ret%=@f_close(stdout&)
      ret%=@f_close(stderr&)
      ret%=@f_close(fds&(1))
      '
      QUIT error&
    ELSE
      '
      ' parent process
      '
      WHILE GEMDOS(314,pid&,1,L:V:rusage%)>=0             ! Pwaitpid
        '
        ret%=@fcntl(fds&(0),0,3)              !F_GETFL
        ret%=@fcntl(fds&(0),OR(ret%,&H100),4) !F_SETFL
        '
        '
        '        ret%=GEMDOS(260,fds&(0),L:V:waiting_bytes%,W:&H4601)  !Fcntl()  FIONREAD
        ret%=@fcntl(fds&(0),V:waiting_bytes%,&H4601)      !FIONREAD
        '
        WHILE waiting_bytes%>0
          LET buffer$=SPACE$(waiting_bytes%)
          ~@fread(fds&(0),waiting_bytes%,V:buffer$)                      !Read from stdout of child process
          '          IF INSTR(buffer$,"##")<>0
          '          PRINT "Install"
          '        ELSE
          '          PRINT "No install"
          '        ENDIF
          '          REPEAT
          FOR i&=1 TO waiting_bytes%
            '
            '  INC i&
            zz$=zz$+MID$(buffer$,i&,1)
            '            error&=@fehler_behandlung(zz$)
            '
            ' xx$=MID$(buffer$,i&,1)
            '            @my_messagewin_print(xx$,FALSE)
            @messagewin_print(zz$)
            CLR xx$
            '          UNTIL i&=waiting_bytes%
          NEXT i&
          '        ELSE
          '          zz$=zz$+MID$(buffer$,i&,1)
          '          IF zz$<>CHR$(10)
          '          @messagewin_print(zz$)
          '        ENDIF
          '        ENDIF
          '
          ret%=GEMDOS(260,fds&(0),L:V:waiting_bytes%,W:&H4601)  !Fcntl()  FIONREAD
          '
        WEND
      WEND
      ret%=@f_close(fds&(0))
    ENDIF
  ELSE
    '    PRINT "Mist: ";ret%
  ENDIF
  DEFMOUSE 0
  RETURN error&
ENDFUNC
'
> FUNCTION frename(oldname$,newname$)
  $F%
  oldname$=oldname$+CHR$(0)
  newname$=newname$+CHR$(0)
  '
  RETURN GEMDOS(86,0,L:V:oldname$,L:V:newname$)
ENDFUNC
'
> PROCEDURE shutdown
  @messagewin_print("Shutting down system!")
  '  error%=@start_prg(0,"u:\sbin\shutdown","-r","","","",install_path$+"\tmp\shutdown.out",FALSE,TRUE,FALSE)
  '  IF error%=0
  '  @print_error(install_path$+"\tmp\shutdown.out")
  ' ENDIF
  ~GEMDOS(337,L:2)
RETURN
> PROCEDURE kaltstart_virt
  PRINT "Kaltstart"
RETURN
'
> PROCEDURE kaltstart                    ! Coldboot
  '
  VOID GEMDOS(&H20,L:0)
  '
  SLPOKE &H420,0
  SLPOKE &H426,0
  SLPOKE &H43A,0
  '
  a%=LPEEK(&H4F2)+4
  a%=LPEEK(a%)
  '
  CALL a%
  '
RETURN
> PROCEDURE warmstart                    ! Warmboot
  '
  VOID GEMDOS(&H20,L:0)
  '
  a%=LPEEK(&H4F2)+4
  a%=LPEEK(a%)
  '
  CALL a%
  '
RETURN
'
> PROCEDURE ug_copy1(quell_datei$,ziel_datei$)
  LOCAL laenge%,frei%,adresse%,puffer%,wieoft%,rest%
  '
  fiha&=@f_open(quell_datei$)   ! Quelldatei îffnen, um die LÑnge
  laenge%=@f_lof(fiha&)              ! des Files zu ermitteln,
  ~@f_close(fiha&)                     ! und wieder schlieûen.
  frei%=MALLOC(-1)             ! grîûten freien Speicherblock merken
  '
  IF frei%>laenge%             ! *Wenn mîglich, alles in einem Rutsch*
    adresse%=MALLOC(laenge%)   ! Speicher anfordern und die Quelldatei
    laenge%=@f_bload(quell_datei$,adresse%) ! an die erhaltene Adresse laden.
    fiha3&=@f_bsave(ziel_datei$,adresse%,laenge%) ! Diesen Bereich jetzt abspeichern,
    ~MFREE(adresse%)           ! und den Speicher wieder freigeben.
    '
  ELSE                         ! *ansonsten stÅckweise kopieren*
    puffer%=MALLOC(frei%)      ! das holen, was noch frei ist
    wieoft%=laenge% DIV frei%  ! Anzahl der Schreib/LesevorgÑnge
    rest%=laenge% MOD frei%    ! eventuellen Rest der Datei merken
    fiha1&=@f_open(quell_datei$)   ! Quelldatei îffnen
    fiha2&=@f_create(ziel_datei$)    ! Zieldatei anlegen
    FOR i%=1 TO wieoft%        ! Schleifchen binden
      ~@f_bget(fiha1&,puffer%,frei%)    ! in den Puffer lesen
      ~@f_bput(fiha2&,puffer%,frei%)    ! aus dem Puffer schreiben
    NEXT i%
    IF rest%                   ! *jetzt den wahrscheinlichen Dateirest*
      ~@f_bget(fiha1&,puffer%,rest%)    ! in den Puffer lesen, und
      ~@f_bput(fiha2&,puffer%,rest%)    ! aus dem Puffer schreiben
    ENDIF
    ~@f_close(fiha2&)
    ~@f_close(fiha1&)
    ~MFREE(puffer%)
  ENDIF
RETURN
> FUNCTION f_bput(fh&,a%,l%)
  $F%
  ' BPUT #1,a%,l%
  RETURN GEMDOS(64,fh&,L:l%,L:a%)
ENDFUNC
> FUNCTION f_bget(fh&,a%,l%)
  $F%
  ' BGET #1,a%,l%
  RETURN GEMDOS(63,fh&,L:l%,L:a%)
ENDFUNC
'
'
> PROCEDURE init_langenamen_suche(start_dir$,file_mask$)
  '
  '
  ' (06/99 Ulli Gruszka, basierend auf Routinen von Frank RÅger)
  ' Diese Listing zeigt und erlÑutert einige wesentliche Routinen zum Umgang
  ' mit Verzeichnissen und Dateien unter allen Dateisystemen. Dies geschieht
  ' im Rahmen einer Prozedur zum Lesen und Ausgeben aller Dateien/Ordner eines
  ' Verzeichnisses. Eine weitere Funktion zeigt die Technik zum vollstÑndigen,
  ' rekursiven Lesen bzw. Ausgeben aller Dateien/Ordner eines Verzeichnisses
  ' inklusive der Unterverzeichnisse.
  '
  '                                         XATTR/DTA-Struktur anlegen.
  IF @pdomain(dom_mint&)<>einvfn%         ! In die MiNT-Domain schalten und
    domain&=@pdomain(-1)                  ! dann die nun aktuelle Domain merken.
  ENDIF                                   ! (wird im Fehlerfall 0L = TOS-Domain)
  '
  '  pfad$="c:\"                             ! Das Startverzeichnis (beliebig Ñnderbar)
  '  mask$="*.*"                             ! Die Maske anzuzeigender Dateien (dito)
  '                                         (Wildcards * und ? sind erlaubt)
  attribute&=&X101111                     ! Bit   Finde folgende:
  '                                     x    0    SchreibgeschÅtzte Datei
  '                                     x    1    Versteckte Datei
  '                                     x    2    Systemdatei
  '                                     x    3    Diskettenname
  '                                          4    Ordner
  '                                     x    5    Datei mit gesetztem Archivbit
  '
  dta%=FGETDTA()                          ! Alte DTA zum Restaurieren merken.
  '
  ' Die Vorbereitungen sind erledigt, jetzt kann es losgehen:
  '
  '  ~@alle_verzeichnisse(pfad$,mask$,attribute&) ! Rekursive Verzeichnisausgabe
  '
  ' Sofern nur eine Ebene eines Verzeichnisses ausgegeben werden soll,
  ' muû der obere Funktionsaufruf auskommentiert und der folgende
  ' aktiviert werden. Gegebenenfalls noch Bit Nr. 4 der Attribute
  ' setzen, um die Unterordnernamen ebenfalls ausgeben zu lassen.
  '
  @ein_verzeichnis(start_dir$,file_mask$,attribute&) ! Einfache Verzeichnisausgabe
  '
  ~FSETDTA(dta%)                          ! DTA zurÅcksetzen
  '
  '  EDIT                                    ! Ende der Durchsage.
RETURN
'
' -- Die Verzeichnisroutinen --------------------------------------------------------
'
> FUNCTION alle_verzeichnisse(pfad$,mask$,attribute&)
  $F%
  LOCAL neu_ordner$
  LOCAL neu_pfad$
  '
  ' Diese Funktion wird einmalig mit dem Startpfad, der gewÅnschten Dateimaske
  ' und den gewÅnschten Attributen aufgerufen. Von nun an ruft sich die Funktion
  ' solange selbst auf, bis die unterste Verzeichnisebene erreicht ist.
  ' ZunÑchst werden bei jedem Durchlauf die gesuchten Dateien der jeweiligen
  ' Ebene ausgegeben:
  '
  @ein_verzeichnis(pfad$,mask$,attribute&)
  '
  ' Ab hier werden die Unterverzeichnisse/Ordner der jeweiligen Ebene gesucht:
  '
  IF @my_fsfirst(pfad$+"*.*",&X10000,TRUE)=0    ! Der erste Ordner dieser Ebene.
    '                                            (zu TRUE siehe @my_fsfirst())
    '
    REPEAT
      '
      IF BYTE{gl_xattr_d_attrib%} AND &X10000   ! Ist es ein Ordner?
        neu_ordner$=CHAR{gl_xattr_d_fname%}     ! Ordner-Name holen und damit
        neu_pfad$=pfad$+neu_ordner$+"\"         ! den neuen Pfad bilden.
        '
        IF @alle_verzeichnisse(neu_pfad$,mask$,attribute&)=FALSE  ! Rekursion ...
          RETURN FALSE                          ! Eine Stufe zurÅck bzw. Ende.
        ENDIF
        '                                         Den nÑchsten Ordner nach dem
        ~@my_fsfirst(pfad$+"*.*",&X10000,TRUE)  ! gerade gelesenen suchen, indem
        WHILE neu_ordner$<>CHAR{gl_xattr_d_fname%} ! die Namen verglichen werden,
          ~@my_fsnext(pfad$+"*.*",&X10000)<>0   ! um dort weiterzumachen.
        WEND
      ENDIF
      '                                           Auf der (Åbergeordneten)
    UNTIL @my_fsnext(pfad$+"*.*",&X10000)<>0    ! Ebene weitersuchen.
    '
  ENDIF
  '
  RETURN TRUE
  '
ENDFUNC
> PROCEDURE ein_verzeichnis(pfad$,mask$,attr&)
  LOCAL ex&
  '
  ' Hier werden die passenden Dateien/Ordner einer Ebene gesucht und auf
  ' dem Bildschirm ausgegeben. Der jeweilige Name findet sich nach Aufruf
  ' der Verzeichnisfunktion in der DTA-Struktur. Von dort kann er natÅrlich
  ' auch in ein String-Array, in einen Speicherblock oder in eine Datei
  ' geschrieben werden. Die restlichen Dateiinformationen befinden sich
  ' ebenfalls in der DTA-Struktur.
  '
  IF @my_fsfirst(pfad$+mask$,attr&,TRUE)=0      ! Erste Datei
    '                                             (zu TRUE siehe @my_fsfirst())
    REPEAT
      '
      IF BYTE{gl_xattr_d_attrib%} AND &X10000             ! Ist es ein Ordner?
        PRINT "Ordner: ";pfad$;CHAR{gl_xattr_d_fname%}    ! Namen ausgeben
      ELSE IF BYTE{gl_xattr_d_attrib%} AND attr&          ! Ist es eine Datei?
        PRINT " Datei: ";pfad$;CHAR{gl_xattr_d_fname%}    ! Namen ausgeben
        ' PRINT "        ";{gl_xattr_d_length%};" Byte"   ! DateilÑnge
      ENDIF
      '
      ex&=@my_fsnext(pfad$+mask$,attr&)         ! Weitersuchen bis zum Ende.
      '
    UNTIL ex&<>0                                ! Keine weiteren Dateien.
    '
  ENDIF
  '
RETURN
'
' -- Die Unterprogramme -------------------------------------------------------------
'
> FUNCTION my_fsfirst(datei$,attr&,next!)
  $F%
  ' Der Ersatz zu FSFIRST(). Achtung: Der zusÑtzliche Parameter (next!) muû
  ' auf TRUE gesetzt werden, wenn anschlieûend my_fsnext() aufgerufen wird.
  ' Wird my_fsfirst() nur einmalig aufgerufen (z.B. zur ExistenzprÅfung), so
  ' ist next! auf FALSE zu setzen!
  '
  LOCAL all_names!
  LOCAL match_name!
  LOCAL attrib&
  LOCAL fehler%
  LOCAL bufdatei$
  LOCAL dateiname$
  LOCAL path$
  '
  @chk_dirhandle
  '
  @pfad(datei$,path$)
  '
  IF domain&=1                                  ! Nur wenn wir uns auch in der
    gl_dirhandle%=@dopendir(path$,0)            ! MiNT-Domain befinden îffnen.
  ELSE
    gl_dirhandle%=einvfn%                       ! Normales FSFIRST/FSNEXT provozieren
  ENDIF
  '
  '
  IF gl_dirhandle%=einvfn%                      ! (-32) Kein passendes Filesystem
    gl_dirhandle%=0                             ! oder nicht in der MiNT-Domain
    '
    gl_xattr_d_attrib%=ADD(gl_xattrbuf%,&H15)   ! Zum vereinfachten Zugriff auf
    gl_xattr_d_time%=ADD(gl_xattrbuf%,&H16)     ! die DTA (hier werden die Ergebnisse
    gl_xattr_d_date%=ADD(gl_xattrbuf%,&H18)     ! der Funktion eingetragen) werden
    gl_xattr_d_length%=ADD(gl_xattrbuf%,&H1A)   ! einige globale Variablen mit den
    gl_xattr_d_fname%=ADD(gl_xattrbuf%,&H1E)    ! Struktur-Adressen belegt.
    '
    ~FSETDTA(gl_xattrbuf%)                      ! DTA setzen
    '
    RETURN FSFIRST(datei$,attr&)
    '
  ELSE                                          ! In der MiNT-Domain:
    ~GEMDOS(8)
    fehler%=gl_dirhandle%
    IF (SHR(gl_dirhandle%,24) AND &HFF)<>&HFF
      gl_xattr_d_attrib%=ADD(gl_xattrbuf%,&H29) ! Variablen belegen (siehe oben)
      gl_xattr_d_time%=ADD(gl_xattrbuf%,&H1C)
      gl_xattr_d_date%=ADD(gl_xattrbuf%,&H1E)
      gl_xattr_d_length%=ADD(gl_xattrbuf%,&H10)
      gl_xattr_d_fname%=ADD(gl_fnamebuf%,&H4)
      '
      @filename(datei$,dateiname$)              ! Datei extrahieren
      IF dateiname$="*.*" OR dateiname$="*"
        dateiname$="*"
        all_names!=-1
      ENDIF
      CHAR{gl_fnamebuf%}=""                     ! Struktur bereinigen
      '
      fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%) ! Lesen
      '
      WHILE fehler%=0
        bufdatei$=CHAR{gl_xattr_d_fname%}       ! Die gefundene Datei
        IF all_names!                           ! Gesucht wurde *.*
          match_name!=TRUE
        ELSE
          match_name!=@match(UPPER$(bufdatei$),UPPER$(dateiname$))
        ENDIF
        IF match_name!=TRUE                     ! entspricht dem Suchkriterium
          datei$=path$+bufdatei$                ! Kompletter Zugriffspfad
          IF @fxattr(0,datei$,gl_xattrbuf%)=0
            attrib&=INT{PRED(gl_xattr_d_attrib%)}
            IF attrib&=0 AND (attr& AND fa_file&)=fa_file&
              attrib&=fa_file&
            ENDIF
            IF (attrib& AND attr&) OR attr&=0
              IF NOT next!                      ! Dem my_fsfirst() folgt kein
                ~@dclosedir(gl_dirhandle%)      ! my_fsnext(), also Verzeichnis
                CLR gl_dirhandle%               ! wieder schlieûen.
              ENDIF
              RETURN 0
            ENDIF
          ENDIF
        ENDIF
        fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)
      WEND
      ~@dclosedir(gl_dirhandle%)
    ENDIF
  ENDIF
  '
  CLR gl_dirhandle%
  RETURN fehler%
  '
ENDFUNC
> FUNCTION my_fsnext(datei$,attr&)
  $F%
  ' Der Ersatz zu FSNEXT().
  '
  LOCAL all_names!
  LOCAL match_name!
  LOCAL attrib&
  LOCAL fehler%
  LOCAL bufdatei$
  LOCAL dateiname$
  LOCAL path$
  '
  IF gl_dirhandle%                              ! Aufruf erfolgte aus MiNT-Domain
    '
    @pfad(datei$,path$)                         ! Pfad extrahieren
    @filename(datei$,dateiname$)                ! Dateiname extrahieren
    IF dateiname$="*.*" OR dateiname$="*"
      dateiname$="*"
      all_names!=TRUE
    ENDIF
    '
    CHAR{gl_fnamebuf%}=""                       ! Struktur bereinigen
    fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)   ! Lesen
    WHILE fehler%=0
      bufdatei$=CHAR{gl_xattr_d_fname%}
      IF all_names!                             ! Gesucht wurde *.*
        match_name!=TRUE
      ELSE
        match_name!=@match(UPPER$(bufdatei$),UPPER$(dateiname$))
      ENDIF
      IF match_name!=TRUE                       ! entspricht dem Suchkriterium
        datei$=path$+bufdatei$                  ! Kompletter Zugriffspfad
        IF @fxattr(0,datei$,gl_xattrbuf%)=0
          attrib&=INT{PRED(gl_xattr_d_attrib%)}
          IF attrib&=0 AND (attr& AND &H27)=&H27
            attrib&=&H27
          ENDIF
          IF (attrib& AND attr&) OR attr&=0
            RETURN 0
          ENDIF
        ENDIF
      ENDIF
      fehler%=@dreaddir(255,gl_dirhandle%,gl_fnamebuf%)
    WEND
    ~@dclosedir(gl_dirhandle%)
    CLR gl_dirhandle%
    RETURN fehler%
  ELSE IF gl_has_dopendir!
    RETURN enmfil%          ! -49
    '
  ELSE                                          ! Aufruf erfolgte aus TOS-Domain
    RETURN FSNEXT()
  ENDIF
  '
ENDFUNC
'
> FUNCTION fxattr(flag&,fname$,buf%)
  $F%
  '
  fname$=fname$+CHR$(0)
  '
  RETURN GEMDOS(fxattr&,flag&,L:V:fname$,L:buf%)
  '
ENDFUNC
'
> FUNCTION dopendir(dir$,flag&)
  $F%
  '
  LOCAL fehler%
  '
  LET dir$=dir$+CHR$(0)
  '
  fehler%=GEMDOS(dopendir&,L:V:dir$,flag&)
  '
  ' Internes Flag fÅr dieses eine Verzeichnis:
  gl_has_dopendir!=fehler%<>einvfn%      ! -32
  '
  RETURN fehler%
  '
ENDFUNC
> FUNCTION dclosedir(dirhandle%)
  $F%
  '
  RETURN GEMDOS(dclosedir&,L:dirhandle%)
  '
ENDFUNC
> FUNCTION dreaddir(size&,dirhandle%,buf%)
  $F%
  '
  RETURN GEMDOS(dreaddir&,size&,L:dirhandle%,L:buf%)
  '
ENDFUNC
'
' --- Diverses ---------------------------------------------------------------------
'
> PROCEDURE init_gemdos_var
  '
  ' 256 Bytes Puffer fÅr Dreaddir() und 64 Bytes fÅr
  ' XATTR/DTA-Struktur Åber ein INLINE bereitstellen:
  '
  INLINE gl_fnamebuf%,320
  gl_xattrbuf%=ADD(gl_fnamebuf%,256)
  '
  fa_file&=&H27
  '
  ' Anm.: Konstanten kînnen vom ergo!pro-PrÑprozessor durch das +SYM-Kommando
  ' vor dem Compilieren Åberall im Listing durch ihren Wert ersetzt werden.
  ' Durch dieses Verfahren ist das Listing gut lesbar, ohne daû im Compilat
  ' unnîtig Speicherplatz fÅr sich nie Ñndernde Variablen beansprucht wird.
  ' Definierte, aber nicht verwendete Konstanten, werden vom PrÑprozessor
  ' natÅrlich ebenfalls rechtzeitig aus dem Listing entfernt.
  ' [Ende der Werbung :-]
  '
  ' Die (symbolischen) GEMDOS-Konstanten:
  '
  '     ++SYM
  '
  LET dsetdrv&=14
  LET dgetdrv&=25
  LET super&=32
  LET tgetdate&=42
  LET tgettime&=44
  LET sversion&=48
  LET dfree&=54
  LET dcreate&=57
  LET dsetpath&=59
  LET fcreate&=60
  LET fopen&=61
  ' Fopen()-Modi
  LET readonly&=0
  LET readwrite&=2
  '
  LET fclose&=62
  LET fread&=63
  LET fwrite&=64
  ' Standard-KanÑle
  LET stdprn&=3
  LET fdelete&=65
  LET fseek&=66
  ' Modi
  LET seek_set&=0
  LET seek_cur&=1
  LET seek_end&=2
  LET mxalloc&=68
  ' Modi
  LET mx_stonly&=0
  LET mx_altonly&=1
  LET mx_prefst&=2
  LET mx_prefalt&=3
  ' MTOS-Speicherschutz (OR)
  LET mx_prot_default&=0
  LET mx_prot_private&=&H10
  LET mx_prot_global&=&H20
  LET mx_prot_super&=&H30
  LET mx_prot_readable&=&H40
  LET mx_prot_no_free&=&H4000
  LET dgetpath&=71
  LET pexec&=75
  ' Modi
  LET loadgo&=0
  ' ' Dateiattribute fÅr Fsfirst()
  LET fa_rdonly&=&H1
  LET fa_hidden&=&H2
  LET fa_system&=&H4
  LET fa_label&=&H8
  LET fa_direc&=&H10
  LET fa_arch&=&H20
  LET fa_attrib&=&H17
  LET fa_file&=&H27
  LET fa_other&=&H18
  LET frename&=86
  LET fdatime&=87
  ' Get/Set
  LET fd_read&=0
  LET fd_write&=1
  LET mfork&=112
  LET pdomain&=281
  '  Domains
  LET dom_tos&=0
  LET dom_mint&=1
  LET dopendir&=296
  LET dreaddir&=297
  LET dclosedir&=299
  LET fxattr&=300
  LET dreadlabel&=338
  '
  e_ok%=0
  einvfn%=-32
  efilnf%=-33
  epthnf%=-34
  enhndl%=-35
  eaccdn%=-36
  eihndl%=-37
  ensmem%=-39
  eimba%=-40
  edrive%=-46
  ensame%=-48
  enmfil%=-49
  elocked%=-58
  enslock%=-59
  erange%=-64
  eintrn%=-65
  eplfmt%=-66
  egsbf%=-67
  ebreak%=-68
  excpt%=-69
  epthov%=-70
  '
  '     ++SYM
  '
RETURN
> PROCEDURE chk_dirhandle
  IF gl_dirhandle%
    ~@dclosedir(gl_dirhandle%)
    CLR gl_dirhandle%
  ENDIF
RETURN
> FUNCTION match(strng$,pattern$)
  $F%
  '
  LOCAL pattern0$
  LOCAL strng0$
  '
  pattern0$=pattern$+CHR$(0)
  strng0$=strng$+CHR$(0)
  '
  RETURN @search(V:strng0$,V:pattern0$)
  '
ENDFUNC
> FUNCTION search(strng%,pattern%)
  $F%
  '
  LOCAL nochmal!
  '
  REPEAT
    CLR nochmal!
    IF BYTE{strng%}=0
      IF BYTE{pattern%}=0
        RETURN -1
      ELSE IF BYTE{pattern%}=42   !"*"
        INC pattern%
        nochmal!=-1
      ENDIF
    ELSE
      IF BYTE{pattern%}=42        !"*"
        RETURN @search(strng%,SUCC(pattern%)) OR @search(SUCC(strng%),pattern%)
      ELSE IF BYTE{pattern%}=BYTE{strng%} OR BYTE{pattern%}=63      !"?"
        INC pattern%
        INC strng%
        nochmal!=-1
      ENDIF
    ENDIF
  UNTIL NOT nochmal!
  RETURN 0
ENDFUNC
> PROCEDURE filename(datei$,VAR match$)
  '
  ' Extrahiert einen Dateinamen
  '
  LOCAL match&
  match&=SUCC(RINSTR(datei$,"\"))
  IF match&>0
    match$=MID$(datei$,match&)
  ELSE
    CLR match$
  ENDIF
RETURN
> PROCEDURE pfad(datei$,VAR match$)
  '
  ' Extrahiert einen Pfad
  '
  LOCAL match&
  match&=RINSTR(datei$,"\")
  IF match&>0
    match$=LEFT$(datei$,match&)
  ELSE
    CLR match$
  ENDIF
RETURN
