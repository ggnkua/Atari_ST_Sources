DEFMOUSE 0
SHOWM
'
' FORM_DO.LST - Fehlerbereinigte Version vom 26.7.92
' ------------------------------------------------------------------
' Prototyp aus der ST 11/89
' Erweitert um Radiobuttons/Checkboxen von Sven Spitzmacher, 12.7.92
' Cursor-Down-Bug behoben und TAB eingebaut, Sven Spitzmacher, 18.7.92
' Nochmal den Cursor-Down-Bug behoben, jetzt aber richtig!, Sven S., 26.7.92
' Grafische Unschînheiten beseitigt, Sven S., 26.7.92
' ------------------------------------------------------------------
' Diese Library ist FREEWARE! - Wenn Fehler auftauchen, oder Verbesserungen
' eingebaut worden sind, bitte dem Autor bescheid geben bzw. ihm die
' verbesserte Library schicken. - Wenn die Library aber nur benutzt werden
' soll, aber VerbesserungsvorschlÑge da sind, so werden diese, soweit
' mîglich, eingebaut - Meist innerhalb einer Woche. Wer nen UPDATE-Service
' haben will, soll einfach 20 DM an den Autor schicken - Adresse nicht
' vergessen - die nÑchsten 5 Updates kommen dann kostenlos per Post...
' Es wÑre nett, wenn im entgÅltigen Programm der Name des Autors dieser
' Library auftauchen wÅrde (z.B. in der ABOUT-Box) - dies muss aber nicht
' sein. ===> DIE LIBRARY BITTE IMMER KOMPLETT MIT ALLEN DATEIEN WEITERGEBEN!!
'
' Meine Adresse: Sven Spitzmacher
'                BÅrger 135
'                2850 Bremerhaven
'                Tel.0471-49863  (auch nachts zu erreichen !!)
'
'
' Globale Variablen: dialog_x__&
'                    dialog_y__&
'                    dialog_w__&
'                    dialog_h__&
'                    dialog_rette__$
'
' Die Benutzung der Library ist ganz einfach: einfach den FORM_DO-Aufruf
' der AES gegen den @form_do-Aufruf der Library austauschen - vorher
' noch den Dialog mit 'set_dialog' anpassen und mit 'draw_dialog' statt
' ~OBJC_DRAW() auf den Bildschirm bringen - mit 'undraw' wieder entfernen.
' um die `semi`-Erweiterten Objekt-Typen zu benutzen, einfach die entsprechenden
' erweiterten Bits in OB_FLAGS des jeweiligen Objekts setzen. Dazu auch
' die DEMO-Resource-Datei ansehen. Zum Setzen der Flags ist INTERFACE oder
' ORCS zu empfehlen.
'
' Folgende BITs im OB_FLAG eines Objekts haben `ne Bedeutung:
' 10 = Fly_Ecke
' 11 = Runder Radio-Button, schon selektiert
' 12 = Runder Radio-Button, nicht selektiert
' 13 = Checkbox, schon selektiert
' 14 = Checkbox, nicht selektiert
'
' Falls Du das ganze hier nicht verstanden hast, einfach mal das DEMO
' ansehen, oder: anrufen! Ich stehe gerne mit Rat und Tat zur Seite, falls
' es Probleme gibt..
'
'
'
IF RSRC_LOAD("FORM_DO.RSC")    !Resource einladen
  '
  ' resource set indices for TEST
  '
  LET testbox=0 ! form/dialog
  LET exit=3 ! BUTTON in tree TESTBOX
  LET fly_but=4 ! BOX in tree TESTBOX
  '
  '
  ~RSRC_GADDR(0,testbox,box%)     !Baumaddresse holen
  ~FORM_CENTER(box%)              !Baum zentrieren
  @set_dialog(box%,TRUE)          !Objekte anpassen
  @draw_dialog(box%)              !Dialog malen..
  ~@form_do(box%,0)               !..ausfÅhren..
  @undraw_dialog                  !..und entfernen
  ~RSRC_FREE()                    !Resource freigeben
  END
ELSE    !wenn nicht zu finden
  ~FORM_ALERT(1,"[3][ FORM_DO.RSC NICHT GEFUNDEN!! |  ][ Abbruch ]")    !Fehlermeldung
  END                                                                   !ausgeben
ENDIF
'
'
' ## Die FORM-DO Routine, wie sie der OTTO-Normal-Programmierer benutzt ##
> PROCEDURE set_dialog(tree%,edit_clr!) !Dialog anpassen
  LOCAL x%
  x%=0
  DO
    IF BTST(OB_FLAGS(tree%,x%),11)
      @do_rb_sel(tree%,x%,FALSE)
    ELSE IF BTST(OB_FLAGS(tree%,x%),12)
      @do_rb_unsel(tree%,x%,FALSE)
    ELSE IF BTST(OB_FLAGS(tree%,x%),13)
      @do_xb_sel(tree%,x%,FALSE)
    ELSE IF BTST(OB_FLAGS(tree%,x%),14)
      @do_xb_unsel(tree%,x%,FALSE)
    ELSE IF BTST(OB_FLAGS(tree%,x%),10)
      @make_fly_but(tree%,x%,FALSE)
    ENDIF
    IF OB_TYPE(tree%,x%)=29
      IF edit_clr!
        @clr_edit(tree%,x%)
      ENDIF
    ENDIF
    EXIT IF BTST(OB_FLAGS(tree%,x%),5)
    x%=x%+1
  LOOP
RETURN
> PROCEDURE draw_dialog(tree%)          !Dialog malen
  LOCAL x%,xline&,yline&,wline&,hline&
  '
  ' Objekt-Koordinaten des ROOT-Objekts holen...
  @objc_offset(tree%,0,dialog_x__&,dialog_y__&,dialog_w__&,dialog_h__&)
  ' Hintergrund speichern
  GET dialog_x__&-4,dialog_y__&-4,dialog_x__&+dialog_w__&+8,dialog_y__&+dialog_h__&+8,dialog_rette__$
  ' und ganzen Objektbaum malen
  ~OBJC_DRAW(tree%,0,8,dialog_x__&-4,dialog_y__&-4,dialog_w__&+8,dialog_h__&+8)
RETURN
> FUNCTION form_do(tree%,start_obj&)    !Dialog ausfÅhren
LOCAL but%,raus!,new_x__&,new_y__&,max_x__&,max_y__&,max_w__&,max_h__&
'
raus!=FALSE   !Flag lîschen, sonst ist das Fly'en u.U. nicht mîglich
'
DO
  but%=@form_do__(tree%,start_obj&)   !die `fast` normale form_do aufrufen
  '
  IF BTST(OB_FLAGS(tree%,but%),10) OR but%=-32764     !Wenn Fly-Objekt
    IF dialog_w__&<>0 AND dialog_h__&<>0    !Nur wenn mit 'draw_dialog' gezeichnet, ist das
      '                                       !Verschieben des Dialogs mîglich!
      ~WIND_GET(0,7,max_x__&,max_y__&,max_w__&,max_h__&)      !Bildschirmausmasse
      DEFMOUSE 4
      ~GRAF_DRAGBOX(dialog_w__&,dialog_h__&,dialog_x__&,dialog_y__&,max_x__&+16,max_y__&+16,max_w__&-32,max_h__&-32,new_x__&,new_y__&)   !Rand-Box der AES benutzen
      DEFMOUSE 0
      '
      IF new_x__&<>dialog_x__& OR new_y__&<>dialog_y__&       !Wenn auch verschoben wurde..
        PUT dialog_x__&-4,dialog_y__&-4,dialog_rette__$       !Alten Dialoghintergrund restaurieren
        OB_X(tree%,0)=new_x__&     !Baum-Koordinaten des Dialogs
        OB_Y(tree%,0)=new_y__&     !anpassen
        @draw_dialog(tree%)        !und neuzeichnen
      ENDIF
    ENDIF
  ELSE        !sonst
    raus!=TRUE        !Flag setzen
  ENDIF
  '
LOOP UNTIL raus!      !wenn Flag gesetzt
'
RETURN but%   !Exit-Button zurÅckgeben
ENDFUNC
> PROCEDURE undraw_dialog               !Dialog-Hintergrund restaurieren
IF dialog_w__&<>0 AND dialog_h__&<>0  !Nur wenn mit 'draw_dialog' der Dialog
  '                                   !auf den Bildschirm gebracht wurde
  PUT dialog_x__&-4,dialog_y__&-4,dialog_rette__$ !den Hintergrung restaurieren
  dialog_w__&=0                       !und erkennungs-Flags
  dialog_h__&=0                       !auf '0' setzen.
ENDIF
RETURN
'
' ## Zusatzroutinen, die intern in der FORM-DO-Routine benutzt werden ##
> PROCEDURE clr_edit(tree%,obj%)
IF OB_TYPE(tree%,obj%)=29 OR OB_TYPE(tree%,obj%)=30  !Wenn Objekt = F_TEXT oder F_BOXTEXT
  CHAR{{OB_SPEC(tree%,obj%)}}=""   !Voreingestellten Text lîschen
ENDIF
RETURN
> FUNCTION form_do__(tree%,start_obj&)
' Erweiterte Dialogbox-Routine...
' der Prototyp stammt aus der ST 11/89
' --------------------------------------------------------------
' History:
' 12.7.92 HELP- und UNDO-Buttons rausgeschmissen, dafÅr
'         runde Radio-Buttons und Checkboxen eingebaut.
' 13.7.92 Move-Dial-Eigenschaften eingebaut...
'         dafÅr die eigentliche FORM_DO-Routine (Func FORM_DO)
'         umbenannt und einen FORM_DO-'Aufsatz' geschrieben
' 18.7.92 Fehler beim 'Cursor-Down' entfernt. Der Computer
'         ist beim DrÅcken von 'CURSOR DOWN' wenn die letzte
'         Eingabezeile schon erreicht war abgestÅrzt. Dann
'         noch um 'TAB' erweitert - also Sprung zum nÑchsten
'         Eingabefeld. Dieser Fehler wurde von dem User
'         NEWROMANCER der D-Box gemeldet. Danke!
' 26.7.92 Tja... der Cursor-Down-Bug war wohl doch noch nicht
'         draussen. Jetzt ist er es jedenfalls. Der Fehler
'         ist eigentlich ein kleines Problem gewesen, da er mit
'         der normalen Fehlersuche von normalen Bugs nicht zu
'         finden war. Habe einen öberprÅfungsalgorhytmus eingebaut,
'         der die Funktion der TAB bzw. CURSOR-DOWN-Taste ÅberprÅft.
'         Ausserdem habe ich den Mauszeiger beim Verschieben eines
'         Dialoges zur flachen Hand gemacht - ein Schînheitsfehler.
'         Die Radio-/Check-Buttons werden jetzt auch nicht andauernd
'         neu gezeichnet, wenn man mit gedrÅckter Maustaste auf dem
'         jeweiligen Objekt stehen bleibt.
'
'
' Benutzung: die entsprechenden Bits in OB_FLAGS setzen:
'     11 = Radio-Button, schon selektiert
'     12 = Radio-Button, nicht selektiert
'     13 = Checkbox, schon selektiert
'     14 = Checkbox, nicht selektiert
'
'
LOCAL ed_obj&,nxt_obj&,mes&,pos&,do_dial&,ox&,mpos&,p&,i&,buf|
LOCAL ev_mx&,ev_my&,ev_mb&,ev_ks&,ev_key&,ev_clicks&
'
~WIND_UPDATE(3)
'
IF NOT BTST(OB_FLAGS(tree%,start_obj&),3)
' start_obj& editable
nxt_obj&=@search_ob_flag(tree%,0,3,1)
ELSE
nxt_obj&=start_obj&
ENDIF
ed_obj&=0
do_dial&=TRUE
'
WHILE do_dial&
'
IF ed_obj&<>nxt_obj& AND nxt_obj&<>0
  ed_obj&=nxt_obj&
  nxt_obj&=0
  ~OBJC_EDIT(tree%,ed_obj&,0,0,1,pos&)
ENDIF
'
mes&=EVNT_MULTI(&X11,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,ev_mx&,ev_my&,ev_mb&,ev_ks&,ev_key&,ev_clicks&)
'
IF BTST(mes&,0)
  do_dial&=@process_key(tree%,ed_obj&,ev_ks&,ev_key&,nxt_obj&,ev_key&)
  '
  IF ev_key&
    ~OBJC_EDIT(tree%,ed_obj&,ev_key&,pos&,2,pos&)
  ENDIF
  '
ELSE IF BTST(mes&,1)
  nxt_obj&=OBJC_FIND(tree%,0,8,ev_mx&,ev_my&)
  '
  IF nxt_obj&=-1
    OUT 2,7
    nxt_obj&=0
  ELSE
    IF BTST(OB_FLAGS(tree%,nxt_obj&),3)
      ~OBJC_OFFSET(tree%,nxt_obj&,ox&,dummy&)
      ~GRAF_HANDLE(charw&,dummy&,dummy&,dummy&)
      mlen&=CARD{OB_SPEC(tree%,nxt_obj&)+26}
      SELECT CARD{OB_SPEC(tree%,nxt_obj&)+16}
      CASE 0
        mpos&=TRUNC((ev_mx&-ox&)/charw&+0.5)
      CASE 1
        mpos&=TRUNC((ev_mx&-ox&-(OB_W(tree%,nxt_obj&)-mlen&*charw&)/2)/charw&)
      ENDSELECT
      IF mpos&>0
        CLR p&,i&
        REPEAT
          IF BYTE{{OB_SPEC(tree%,nxt_obj&)+4}+i&}=95
            INC p&
          ENDIF
          INC i&
        UNTIL i&=mpos& OR i&=mlen&
      ELSE
        p&=0
      ENDIF
      ~OBJC_EDIT(tree%,ed_obj&,0,pos&,3,pos&)
      buf|=BYTE{{OB_SPEC(tree%,nxt_obj&)}+p&}
      BYTE{{OB_SPEC(tree%,nxt_obj&)}+p&}=0
      ~OBJC_EDIT(tree%,nxt_obj&,0,pos&,1,pos&)
      BYTE{{OB_SPEC(tree%,nxt_obj&)}+p&}=buf|
      ed_obj&=nxt_obj&
    ELSE IF BTST(OB_FLAGS(tree%,nxt_obj&),11) OR BTST(OB_FLAGS(tree%,nxt_obj&),12)
      @do_rb(tree%,nxt_obj&)                        !Radiobutton ?
      DO
      LOOP UNTIL MOUSEK=0
    ELSE IF BTST(OB_FLAGS(tree%,nxt_obj&),13)       !Eckig/Selektiert ?
      @do_xb_unsel(tree%,nxt_obj&,TRUE)
      DO
      LOOP UNTIL MOUSEK=0
    ELSE IF BTST(OB_FLAGS(tree%,nxt_obj&),14)       !Eckig/Unselktiert ?
      @do_xb_sel(tree%,nxt_obj&,TRUE)
      DO
      LOOP UNTIL MOUSEK=0
    ENDIF
    '        PRINT AT(1,1);nxt_obj&;"     "
    do_dial&=FORM_BUTTON(tree%,nxt_obj&,ev_clicks&,nxt_obj&)
  ENDIF
ENDIF
IF do_dial&=0 OR (nxt_obj&<>0 AND nxt_obj&<>ed_obj&)
  ~OBJC_EDIT(tree%,ed_obj&,0,pos&,3,pos&)
ENDIF
WEND
~WIND_UPDATE(2)
RETURN nxt_obj&
ENDFUNC
> FUNCTION process_key(tree%,obj&,kstate&,ev_key&,VAR nxt_obj&,nxtchar&)
LOCAL key_obj&
'
IF BTST(kstate&,0)
kstate&=BSET(kstate&,1)
ENDIF
kstate&=SHR&(kstate&,1)
'
nxtchar&=0
SELECT ev_key&
CASE &H4D36                                       ! SHIFT + Cursor right
~OBJC_EDIT(tree%,ed_obj&,0,pos&,3,pos&)
~OBJC_EDIT(tree%,ed_obj&,0,pos&,1,pos&)
'
CASE &H4B34                                       ! SHIFT + Cursor left
~OBJC_EDIT(tree%,ed_obj&,0,pos&,3,pos&)
buf|=BYTE{{OB_SPEC(tree%,ed_obj&)}}
BYTE{{OB_SPEC(tree%,ed_obj&)}}=0
~OBJC_EDIT(tree%,ed_obj&,0,pos&,1,pos&)
BYTE{{OB_SPEC(tree%,ed_obj&)}}=buf|
'
CASE &H5000                                       ! Cursor down
nxt_obj&=@do_down_(tree%,obj&)
'
CASE 3849                                         ! Tab
nxt_obj&=@do_down_(tree%,obj&)
'
CASE &H4800                                       ! Cursor up
nxt_obj&=@do_up_(tree%,obj&)
nxt_obj&=@search_ob_flag(tree%,obj&,3,-1)
'
CASE &H1C0D,&H720D                                ! RETURN / ENTER
nxt_obj&=@search_ob_flag(tree%,0,1,1)
IF nxt_obj&
RETURN FORM_BUTTON(tree%,nxt_obj&,1,nxt_obj&)
ELSE
nxt_obj&=@search_ob_flag(tree%,obj&,3,1)
IF nxt_obj&=obj& AND @search_ob_flag(tree%,0,2,1)=0
  RETURN FALSE
ENDIF
ENDIF
'
DEFAULT
key_obj&=@search_key_obj(tree%,kstate&,ev_key&)
IF key_obj&
RETURN FORM_BUTTON(tree%,key_obj&,1,nxt_obj&)
ENDIF
nxt_obj&=obj&
nxtchar&=ev_key&
ENDSELECT
RETURN TRUE
ENDFUNC
> FUNCTION search_key_obj(tree%,kstate&,ev_key&)
LOCAL key|,obj&
key|=SHR&(ev_key&,8)
obj&=0
REPEAT
INC obj&
IF key|=SHR&(OB_STATE(tree%,obj&),8) AND kstate&=SHR&(OB_FLAGS(tree%,obj&),13)
RETURN obj&
ENDIF
UNTIL BTST(OB_FLAGS(tree%,obj&),5)
RETURN 0
ENDFUNC
> FUNCTION search_ob_flag(tree%,startobj&,bitnr|,direktion&)
LOCAL obj&
obj&=startobj&
REPEAT
IF direktion&=-1
obj&=obj&-1
ELSE
obj&=obj&+1
ENDIF
IF BTST(OB_FLAGS(tree%,obj&),bitnr|)
RETURN obj&
ENDIF
UNTIL (obj&=0) OR BTST(OB_FLAGS(tree%,obj&),5)
RETURN startobj&
ENDFUNC
> FUNCTION do_down_(tree%,obj&)
LOCAL rette&,xx%
rette&=nxt_obj&
nxt_obj&=@search_ob_flag(tree%,obj&,3,1)
xx%=0
DO
xx%=xx%+1
LOOP UNTIL BTST(OB_FLAGS(tree%,xx%),5)
IF xx%>=nxt_obj&
RETURN nxt_obj&
ELSE
RETURN rette&
ENDIF
ENDFUNC
> FUNCTION do_up_(tree%,obj&)
nxt_obj&=@search_ob_flag(tree%,obj&,3,-1)
LOCAL rette&,xx%
rette&=nxt_obj&
nxt_obj&=@search_ob_flag(tree%,obj&,3,-1)
xx%=0
DO
xx%=xx%+1
LOOP UNTIL BTST(OB_FLAGS(tree%,xx%),5)
IF xx%>=nxt_obj&
RETURN nxt_obj&
ELSE
RETURN rette&
ENDIF
ENDFUNC
> PROCEDURE objc_offset(objcadr%,objnr|,VAR x&,y&,w&,h&)
~OBJC_OFFSET(objcadr%,objnr|,x&,y&)   !Objektkoordinaten
w&=OB_W(objcadr%,objnr|)              !und zusÑtzlich BREITE und
h&=OB_H(objcadr%,objnr|)              !HôHE des Objekts zurÅckgeben
RETURN
> PROCEDURE do_rb_unsel(tree%,obj%,redraw!)
LOCAL data%,struktur%,x__%,y__%,i_____%,wrt_____%
'
' die folgenden INLINES werden von der Procedure gefÅllt.
' sie mÅssen nicht extra nachgeladen werde (z.B. zum MERGEn der Lib.)
' mit der struktur%-INLINE wird eine BITBLK-Struktur des AES nachgebaut.
' in der data%-INLINE sind die Grafik-Daten fÅr den Button
INLINE data%,32
INLINE struktur%,14
'
LPOKE struktur%+0,data%       !Grafik-Daten
DPOKE struktur%+4,2           !Breite des Images (muss 2 sein!!!)
DPOKE struktur%+6,16          !Hîhe des Images
DPOKE struktur%+8,0           !X-Position
DPOKE struktur%+10,0          !Y-Position
DPOKE struktur%+12,1          !Farbe des Images
'
IF PEEK(adr%+3)<>192  !nur wenn INLINE leer
RESTORE rb_____unsel_____    !DATAs auslesen
FOR i_____%=1 TO 16         !(16 * CARD)=32 BYTE
READ wrt_____%
CARD{data%+((i_____%-1)*2)}=wrt_____%
NEXT i_____%
ENDIF         !sonst direkt weiter...
'
OB_TYPE(tree%,obj%)=23        !Typ = G_IMAGE
OB_SPEC(tree%,obj%)=struktur% !OB_SPEC auf INLINE setzen
OB_FLAGS(tree%,obj%)=BCLR(OB_FLAGS(tree%,obj%),11)    !Erkennungs-Bits
OB_FLAGS(tree%,obj%)=BSET(OB_FLAGS(tree%,obj%),12)    !im OB_FLAG setzen
'
IF redraw!    !Wenn Neuzeichen-Flag = TRUE
~OBJC_OFFSET(tree%,obj%,x__%,y__%)  !Koordianten holen
~OBJC_DRAW(tree%,0,25,x__%,y__%,16,16)      !und neuzeichnen
ENDIF
'
rb_____unsel_____:
DATA 0,960,3120,4104,8196,8196,16386,16386,16386,16386,8196,8196
DATA 4104,3120,960,0
RETURN
> PROCEDURE do_rb_sel(tree%,obj%,redraw!)
LOCAL data%,struktur%,x__%,y__%,i_____%,wrt_____%
'
' die folgenden INLINES werden von der Procedure gefÅllt.
' sie mÅssen nicht extra nachgeladen werde (z.B. zum MERGEn der Lib.)
' mit der struktur%-INLINE wird eine BITBLK-Struktur des AES nachgebaut.
' in der data%-INLINE sind die Grafik-Daten fÅr den Button
INLINE data%,32
INLINE struktur%,14
'
LPOKE struktur%+0,data%       !Grafik-Daten
DPOKE struktur%+4,2           !Breite des Images (muss 2 sein!!!)
DPOKE struktur%+6,16          !Hîhe des Images
DPOKE struktur%+8,0           !X-Position
DPOKE struktur%+10,0          !Y-Position
DPOKE struktur%+12,1          !Farbe des Images
'
IF PEEK(adr%+3)<>192  !nur wenn INLINE leer
RESTORE rb_____sel_____    !DATAs auslesen
FOR i_____%=1 TO 16         !(16 * CARD)=32 BYTE
READ wrt_____%
CARD{data%+((i_____%-1)*2)}=wrt_____%
NEXT i_____%
ENDIF         !sonst direkt weiter...
'
OB_TYPE(tree%,obj%)=23        !Typ = G_IMAGE
OB_SPEC(tree%,obj%)=struktur% !OB_SPEC auf INLINE setzen
OB_FLAGS(tree%,obj%)=BCLR(OB_FLAGS(tree%,obj%),12)    !Erkennungs-Bits
OB_FLAGS(tree%,obj%)=BSET(OB_FLAGS(tree%,obj%),11)    !im OB_FLAG setzen
'
IF redraw!    !Wenn Neuzeichen-Flag = TRUE
~OBJC_OFFSET(tree%,obj%,x__%,y__%)  !Koordinaten holen
~OBJC_DRAW(tree%,0,25,x__%,y__%,16,16)      !und neuzeichnen
ENDIF
'
rb_____sel_____:
DATA 0,960,3120,4104,9156,10212,20466,20466,20466,20466,10212,9156
DATA 4104,3120,960,0
RETURN
> PROCEDURE do_xb_unsel(tree%,obj%,redraw!)
LOCAL data%,struktur%,x__%,y__%,i_____%,wrt_____%
' die folgenden INLINES werden von der Procedure gefÅllt.
' sie mÅssen nicht extra nachgeladen werde (z.B. zum MERGEn der Lib.)
' mit der struktur%-INLINE wird eine BITBLK-Struktur des AES nachgebaut.
' in der data%-INLINE sind die Grafik-Daten fÅr den Button
INLINE data%,32
INLINE struktur%,14
'
LPOKE struktur%+0,data%       !Grafik-Daten
DPOKE struktur%+4,2           !Breite des Images (muss 2 sein!!!)
DPOKE struktur%+6,16          !Hîhe des Images
DPOKE struktur%+8,0           !X-Position
DPOKE struktur%+10,0          !Y-Position
DPOKE struktur%+12,1          !Farbe des Images
'
IF PEEK(adr%+3)<>192  !nur wenn INLINE leer
RESTORE xb_____unsel_____    !DATAs auslesen
FOR i_____%=1 TO 16         !(16 * CARD)=32 BYTE
READ wrt_____%
CARD{data%+((i_____%-1)*2)}=wrt_____%
NEXT i_____%
ENDIF         !sonst direkt weiter...
'
OB_TYPE(tree%,obj%)=23        !Typ = G_IMAGE
OB_SPEC(tree%,obj%)=struktur% !OB_SPEC auf INLINE setzen
OB_FLAGS(tree%,obj%)=BCLR(OB_FLAGS(tree%,obj%),13)    !Erkennungs-Flags setzen
OB_FLAGS(tree%,obj%)=BSET(OB_FLAGS(tree%,obj%),14)    !(im OB_FLAG)
'
IF redraw!    !Neuzeichen-Bit ?
~OBJC_OFFSET(tree%,obj%,x__%,y__%)  !Koordinaten holen
~OBJC_DRAW(tree%,0,25,x__%,y__%,16,16)      !und neuzeichnen
ENDIF
'
xb_____unsel_____:
DATA 0,32766,16386,16386,16386,16386,16386,16386,16386,16386,16386,16386
DATA 16386,16386,32766,0
RETURN
> PROCEDURE do_xb_sel(tree%,obj%,redraw!)
LOCAL data%,struktur%,x__%,y__%,xyz%,i_____%,wrt_____%
'
' die folgenden INLINES werden von der Procedure gefÅllt.
' sie mÅssen nicht extra nachgeladen werde (z.B. zum MERGEn der Lib.)
' mit der struktur%-INLINE wird eine BITBLK-Struktur des AES nachgebaut.
' in der data%-INLINE sind die Grafik-Daten fÅr den Button
INLINE data%,32
INLINE struktur%,14
'
LPOKE struktur%+0,data%       !Grafik-Daten
DPOKE struktur%+4,2           !Breite des Images (muss 2 sein!!!)
DPOKE struktur%+6,16          !Hîhe des Images
DPOKE struktur%+8,0           !X-Position
DPOKE struktur%+10,0          !Y-Position
DPOKE struktur%+12,1          !Farbe des Images
'
IF PEEK(adr%+3)<>192  !nur wenn INLINE leer
RESTORE xb_____sel_____    !DATAs auslesen
FOR i_____%=1 TO 16         !(16 * CARD)=32 BYTE
READ wrt_____%
CARD{data%+((i_____%-1)*2)}=wrt_____%
NEXT i_____%
ENDIF         !sonst direkt weiter...
'
OB_TYPE(tree%,obj%)=23        !Typ = G_IMAGE
OB_SPEC(tree%,obj%)=struktur% !OB_SPEC auf INLINE setzen
OB_FLAGS(tree%,obj%)=BCLR(OB_FLAGS(tree%,obj%),14)    !Erkennungs-Flags setzen
OB_FLAGS(tree%,obj%)=BSET(OB_FLAGS(tree%,obj%),13)    !(im OB_FLAGS)
'
IF redraw!    !Neuzeichen-Flag ?
~OBJC_OFFSET(tree%,obj%,x__%,y__%)  !Objektkoordinaten holen
~OBJC_DRAW(tree%,0,25,x__%,y__%,16,16)      !und neuzeichnen
ENDIF
'
'
xb_____sel_____:
DATA 0,32766,24582,20490,18450,17442,16962,16770,16770,16962,17442,18450
DATA 20490,24582,32766,0
RETURN
> PROCEDURE do_rb(tree%,obj%)
LOCAL x%,tail%
' sel=11/unsel=12
'
tail%=OB_HEAD(tree%,obj%)
'
x%=0
DO
IF BTST(OB_FLAGS(tree%,x%),11) OR BTST(OB_FLAGS(tree%,x%),12)
IF OB_HEAD(tree%,x%)=tail%
IF BTST(OB_FLAGS(tree%,obj%),12)
@do_rb_unsel(tree%,x%,TRUE)
ENDIF
ENDIF
ENDIF
EXIT IF BTST(OB_FLAGS(tree%,x%),5)
x%=x%+1
LOOP
@do_rb_sel(tree%,obj%,TRUE)
RETURN
> PROCEDURE make_fly_but(tree%,obj%,redraw!)
LOCAL data%,struktur%,x__%,y__%,i_____%,wrt_____%
'
' die folgenden INLINES werden von der Procedure gefÅllt.
' sie mÅssen nicht extra nachgeladen werde (z.B. zum MERGEn der Lib.)
' mit der struktur%-INLINE wird eine BITBLK-Struktur des AES nachgebaut.
' in der data%-INLINE sind die Grafik-Daten fÅr den Button
INLINE data%,32
INLINE struktur%,14
'
LPOKE struktur%+0,data%       !Grafik-Daten
DPOKE struktur%+4,2           !Breite des Images (muss 2 sein!!!)
DPOKE struktur%+6,16          !Hîhe des Images
DPOKE struktur%+8,0           !X-Position
DPOKE struktur%+10,0          !Y-Position
DPOKE struktur%+12,1          !Farbe des Images
'
IF PEEK(adr%+3)<>192  !nur wenn INLINE leer
RESTORE fly_____but_____    !DATAs auslesen
FOR i_____%=1 TO 16         !(16 * CARD)=32 BYTE
READ wrt_____%
CARD{data%+((i_____%-1)*2)}=wrt_____%
NEXT i_____%
ENDIF         !sonst direkt weiter...
'
OB_TYPE(tree%,obj%)=23        !Typ = G_IMAGE
OB_SPEC(tree%,obj%)=struktur% !OB_SPEC auf INLINE setzen
OB_FLAGS(tree%,obj%)=BSET(OB_FLAGS(tree%,obj%),10)    !10.Bit in OB_FLAG setzen
OB_STATE(tree%,obj%)=BSET(OB_STATE(tree%,obj%),4)     !Outlined-State setzen
'
IF redraw!    !Wenn Neuzeichen-Flag gesetzt
~OBJC_OFFSET(tree%,obj%,x__%,y__%)  !Objektkoordinaten holen
~OBJC_DRAW(tree%,0,25,x__%,y__%,16,16)      !und neuzeichnen
ENDIF
'
fly_____but_____:
DATA 65535,49153,40961,36865,34817,33793,33281,33025,32897,32833,32801,32785
DATA 32777,32773,32771,65535
RETURN
'
'
' ############# PROGRAMMENDE ##############
'
