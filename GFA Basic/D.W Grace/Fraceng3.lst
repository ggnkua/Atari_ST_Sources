' ==============================================================================
'             FRACTAL ENGINE V3.0 BY D.W.GRACE BSc. & MIKE HARRIS
'                               COPYRIGHT 1993
'                         3.0 VERSION (C) 28/7/1993
' ==============================================================================
'                           VARIABLES/PROGRAM DETAILS
' ==============================================================================
'
' TABLE OF TYPES
'
' 0  = QUADRATIC
' 1  = CONJUGATE
' 2  = SPIDER
' 3  = JELLYFISH
' 4  = CUBIC 1 (Z^3+C)
' 5  = CUBIC 2 (OLD ONE)
' 6  = BARNSLEY
' 7  = SINE
' 8  = COSINE
' 9  = CUBIC NEWTON
' 10 = DEGREE 4
' 11 = POPCORN
' 12 = POINT DLA
' 13 = LINE DLA
' 14 = CLOUD
' 15 = MOUNTAINS
' 16 = LSYSTEM , THIS IS BOLTED ON AND NOT FULLY SUPPORTED
'
' ==============================================================================
'                            CHECK RESOLUTION
' ==============================================================================
'
IF NOT (XBIOS(4)=0)
  wait_no_mouse
  ALERT 3,"Low resolution only",2,"QUIT|CONT",choice|
  '
  IF choice|=1
    QUIT
  ENDIF
  '
ENDIF
'
' ==============================================================================
'                           DECLARE GLOBAL VARIABLES
' ==============================================================================
' *******************  CONSTANTS FOR ST (IN LOW RESOLUTION) ********************
'
screen_adr%=XBIOS(2)
max_pal|=39             ! ultimate palette number
max_col|=15             ! ultimate colour
max_rgb|=15             ! really only 7 for an ST, but 15 for an STE
cdf_len&=118
'
'
' *************************  TYPE DEPENDENT CONSTANTS  *************************
'
max_type|=15            ! ultimate fractal type
max_complex|=10         ! ultimate complex planar fractal
'
'
' *************************  IMAGE ARRAYS/CONSTANTS   **************************
' FOR ARRAYS 0 FOR IMAGE, 1 FOR CURRENT CO-ORDS, 2 FOR STORED CO-ORDS,
' 3 FOR ANIM/TEMP-TYPE, 4 TO 8 FOR JUL DEFAULTS, 9 TO 24 FOR STANDARD DEFAULTS
'
DIM par_mset!(24)    ! Is fractal an Mset?
DIM par_byte|(24,9)  ! (*,0)=type, 1=pal, 2=mode, 3=method, 4=accuracy (0,1 or 2)
'                    ! 5=spread, (SCAPE : different; uses 6, 7, 8)
DIM par_word&(24,3)  ! (*,0)=max_it, 1=scr_width, 2=scr_height, 3=bound (lem)
DIM par_long%(24)    ! =seed for random fractals.
DIM par_real(24,5)   ! (*,0)=x0, 1=y0, 2=dx, 3=Rc, 4=Ic,
'                    ! (SCAPE, SPHERE : 5=fs)
'
' ****************************  INIT MAIN GLOBALS  *****************************
'
CLS
' SGET stored_scr$
SGET scr$
pic_exist!=FALSE        ! IS THERE A FRACTAL PICTURE ?
ani_end_frame!=FALSE    ! NO END FRAME TO START (CHOOSEN FIRST FOR ANIMATION).
ani_zoom!=FALSE         ! WHICH SORT OF ANIM SEQUENCE IS THE CURRENT "END FRAME"
'                       ! TO BE USED FOR? ITS INITIAL VALUE IS IRRELEVANT HERE.
'
' **************************  PALETTE/COLOUR ARRAYS  ***************************
'
DIM col_index|(max_col|)               ! const array hardware colour indexing
DIM inverse_index|(15)
DIM pal_data|(max_pal|,max_col|,2)     ! 3 parts per colour: R, G, B.
'
'
' *********************  FRACTAL TYPE DEPENDENT ARRAYS *************************
'
DIM def_name$(max_type|)        ! DEFAULT FILE NAMES : QUAD etc
DIM type_name$(max_type|+1)     ! QUADRATIC etc
DIM method_name$(5)             ! NORMAL(QUICK), LEM, SPHERE, SCAPE,
'                               ! SMALL NORMAL,SMALL LEM
DIM cloud_meth$(1)              ! CLOUD METHODS : SKY,PLASMA
DIM jul_ptr|(max_complex|)
'
'
' *****************************  BUTTON ARRAYS  ********************************
'
DIM but_loc&(19,1),main_but_name$(19)
DIM type_but_name$(17)
DIM method_but_name$(6)
DIM pal_but_loc&(7,1)
DIM pal_but_name$(7)
DIM edit_but_name$(7)
DIM batch_but_name$(4)
'
'
' *******  USER FILE PATH STRINGS AND "CURRENT" DEFAULTS FOR FILESELECT  *******
'
DIM pic_file_len&(3)                    ! .SML .FUL .PI1 .NEO
'
def_file_name$="FRAC_"
current_path$="\"                       ! THIS IS UPDATED WHEN FSEL IS USED
'
' ***************************  MACHINE CODE ARRAYS  ****************************
'
DIM reg%(16)
DIM adr_off_16&(3),adr_off_32&(5)
'
mach_code$=SPACE$(828)
'
' DEFINE FUNCTIONS :
' BOOLEAN FUNCTION (DETERMINES WHETHER A CD DESCRIBES A FULL OR SMALL IMAGE) :
DEFFN ful_size(par|)=((par_byte|(par|,3)<4) OR (par_byte|(par|,0))>max_complex|)
'
' ==============================================================================
'                       INITIALISE DATA ARRAYS ETC
' ==============================================================================
'
RESTORE array_data
'
' ***************************  CODE/POINTER ARRAYS  ****************************
'
FOR i|=0 TO max_col|
  READ col_index|(i|)
NEXT i|
'
'
FOR n|=0 TO 15
  READ inverse_index|(n|)
NEXT n|
'
'
FOR n|=0 TO 3
  READ adr_off_16&(n|)
NEXT n|
'
'
FOR n|=0 TO 5
  READ adr_off_32&(n|)
NEXT n|
'
'
FOR n|=0 TO 3
  READ pic_file_len&(n|)
NEXT n|
'
'
FOR n|=0 TO max_complex|
  READ jul_ptr|(n|)
NEXT n|
'
'
' **************  TEXT/INPUT OUTPUT STRINGS - EXCEPT BUTTONS STUFF  ************
'
FOR i|=0 TO max_type|
  READ def_name$(i|)
NEXT i|
'
'
FOR i|=0 TO max_type|+1                 ! BOLTED ON TYPE
  READ type_name$(i|)
NEXT i|
'
'
FOR i|=0 TO 5
  READ method_name$(i|)
NEXT i|
'
'
FOR i|=0 TO 1
  READ cloud_meth$(i|)
NEXT i|
'
' *****************************  BUTTON ARRAYS  ********************************
'
FOR button_no|=0 TO 19
  READ main_but_name$(button_no|)
NEXT button_no|
'
FOR button_no|=0 TO max_type|+2         ! Extra buttons : EXIT and CHOOSE
  READ type_but_name$(button_no|)
NEXT button_no|
'
FOR button_no|=0 TO 6
  READ method_but_name$(button_no|)
NEXT button_no|
'
FOR button_no|=0 TO 7
  READ pal_but_name$(button_no|)
NEXT button_no|
'
FOR button_no|=0 TO 7
  READ edit_but_name$(button_no|)
NEXT button_no|
'
FOR button_no|=0 TO 4
  READ batch_but_name$(button_no|)
NEXT button_no|
'
FOR button|=0 TO 19
  READ but_loc&(button|,0)
  READ but_loc&(button|,1)
NEXT button|
'
FOR button|=0 TO 7
  READ pal_but_loc&(button|,0)
  READ pal_but_loc&(button|,1)
NEXT button|
'
' ==============================================================================
'                                  ARRAY DATA
' ==============================================================================
'
array_data:
'
'
' colour_index|() DATA
DATA 0,15,1,2,4,6,3,5,7,8,9,10,12,14,11,13
'
'
' inverse_index|() DATA
DATA 0,2,3,6,4,7,5,8,9,10,11,14,12,15,13,1
'
'
' adr_off_16&() DATA
' QUAD, CONJ, SPID, FISH
DATA 0,46,94,152
'
'
' adr_off_32&() DATA
' QUAD, CONJ, SPID, FISH, CUB1, CUB2
DATA 214,270,328,402,488,568
'
' pic_file_len&() : .FUL, .PI1 (Degas format) and .NEO respectively
DATA 8118,32118,32034,32128
'
' jul_ptr|() :which complex types use which par arrays (3 to 7) for jul defaults
' Only used in select_c procedure - called from julia.
DATA 4,8,4,4,4,4,7,6,6,5,5
'
' def_name$() DATA
DATA "QUAD","CONJ","SPID","FISH","CUB1","CUB2","BARN","SINE","COSN","NEWT"
DATA "DEG4","PCORN","P_DLA","L_DLA","CLOUD","MNTNS"
'
' type_name$() DATA
DATA "QUADRATIC","CONJUGATE","SPIDER","JELLYFISH","CUBIC 1","CUBIC 2","BARNSLEY"
DATA "SINE","COSINE","NEWTON","DEGREE 4","POPCORN"
DATA "POINT DLA","LINE DLA","CLOUDS","MOUNTAINS","L-SYSTEM"
'
'
' method_name$()
DATA "NORMAL ","LEM","SPHERE","SCAPE","SMALL NORMAL","SMALL LEM"
'
'
' cloud_meth$()
DATA "SKY","PLASMA"
'
'
' Main menu buttons
DATA " JULIA ","  ZOOM  ","  DRAW  "," METHOD "
DATA "EDIT CD","COPY CD","LOAD CD","SAVE CD"
DATA "LOAD PIC","SAVE PIC"," BATCH ","  VIEW  "
DATA "STOREPIC","RESTORE","PALETTES","SAVE PAL"
DATA "LSYSTEM","  TYPES  "," INFO ","  QUIT  "
'
' Types menu
DATA "  QUAD  ","  CONJ  ","  SPID  ","  FISH  ","  CUB1  ","  CUB2  "
DATA "  BARN  ","  SINE  ","  COSN  ","  NEWT  ","  DEG4  "
DATA " PCORN "," P_DLA "," L_DLA "," CLOUDS "," MNTNS "," CHOOSE ","  EXIT  "
'
' method_but_name$()
DATA " NORMAL ","  LEM  "," SPHERE "," SCAPE ","SML NRML","SML LEM","  EXIT  "
'
' Palette menu
DATA " PAL - "," PAL + "," MODE - "," MODE + "
DATA " SWIRL ","  HIDE  ","  EDIT  ","  EXIT  "
'
' Edit palette menu
DATA " RED - "," RED + ","GREEN -","GREEN +"
DATA " BLUE - "," BLUE + "," COLOUR ","  EXIT  "
'
' Batch menu
DATA "ZOOMANIM","JULANIM"," POSTER ","CONVERT"," CANCEL "
'
' ****************************  BUTTON LOCATIONS  ******************************
' Main menu
DATA 0,43,63,43,0,59,63,59
DATA 0,75,63,75,0,91,63,91
DATA 0,107,63,107,0,123,63,123
DATA 0,139,63,139,0,155,63,155
DATA 0,171,63,171,0,187,63,187
'
' Palette button locations
DATA 5,27,68,27,5,43,68,43
DATA 5,59,68,59,5,75,68,75
'
' ==============================================================================
'                                    MAIN
' ==============================================================================
'
ON BREAK GOSUB clear_up                 ! SAFE GUARDS
RESERVE ((FRE(0) DIV 256)*256-32256)    ! RESERVE MEMORY FOR LOADING SAVING PICS
'
' ***************************  LOAD IN PALETTE DATA  ***************************
'
PRINT "LOADING DEFAULT DATA ..."
BLOAD "DEFAULTS.FE2\PALETTE.DAT",V:pal_data|(0,0,0)
'
' ***************************  LOAD IN TITLE SCREEN  ***************************
'
adr%=MALLOC(32256)
' BLOAD "DEFAULTS.FE2\TITLE.SCR",adr%
setcols(33,2,0,0,0,0)
BMOVE adr%,screen_adr%,32000
~MFREE(adr%)
'
' ***************************  LOAD IN MACHINE CODE  ***************************
'
BLOAD "DEFAULTS.FE2\FRACENG2.EXE",V:mach_code$
'
' ***************************** INITIALISE DEFAULTS  ***************************
'
init_defaults
copy_params(9,1)                        ! QUADRATIC MSET AS DEFAULT
'
num_buts|=19
exit!=FALSE
'
DEFMOUSE 5
REPEAT
UNTIL MOUSEK
'
CLS
'
' *****************************  MAIN MENU LOOP  ******************************
'
REPEAT
  '
  CLS
  setcols(0,0,0,0,0,0)
  draw_buttons(num_buts|,but_loc&(),main_but_name$())
  show_params
  draw_logo
  check_buttons(num_buts|,but_loc&(),button_selected|)
  '
  SELECT button_selected|
  CASE 0
    julia
    '
  CASE 1
    zoom
    '
  CASE 2
    draw_from_cd(TRUE)
    '
  CASE 3
    method
    '
  CASE 4
    enter_params
    '
  CASE 5
    copy_params(0,1)    ! SEE CO-ORDS PROCEDURES
    '
  CASE 6
    user_load_cdf
    '
  CASE 7
    user_save_cdf
    '
  CASE 8
    user_load_pic
    '
  CASE 9
    user_save_pic
    '
  CASE 10
    batch
    '
  CASE 11
    view
    '
  CASE 12
    store_pic
    '
  CASE 13
    restore_pic
    '
  CASE 14
    IF pic_exist!
      palette
    ENDIF
    '
  CASE 15
    write_pal
    '
  CASE 16
    ALERT 2,"Load and draw|l-system ?",1,"Yes|No",yn|
    '
    IF yn|=1
      lsystem
    ENDIF
    '
  CASE 17
    types
    '
  CASE 18
    '    info
    '
  CASE 19
    ALERT 2,"Are you sure you wish to quit?",2,"YES|NO",yn|
    '
    IF yn|=1
      exit!=TRUE
    ENDIF
    '
  ENDSELECT
  '
UNTIL exit!=TRUE
'
clear_up
'
' ******************************************************************************
'
'  ***   ***   **    ***  *      **   *         **   ***    ***  *   ***    **
' *     *        *  *     ***      *  *        *  *  *  *  *  *      *  *  *  *
' ***   *      ***  *     *      ***  *        ***   *  *   ***  *   *  *  ***
' *     *     *  *  *     *     *  *  *        *     *  *     *  *   *  *  *
' *     *      ***   ***   ***   ***   **       ***  *  *  ***   **  *  *   ***
'
' ******************************************************************************
'
' ==============================================================================
'                               MENU PROCEDURES
' ==============================================================================
'
> PROCEDURE julia
  '
  ' DEPENDING ON WHAT PICTURE THERE IS, IF ANY THE USER EITHER ENTERS C VALUE
  ' OR SELECTS IT VISUALLY FROM A PRE-DRAWN MANDEL (DRAWN WITH LEM OR QUICK)
  '
  LOCAL type|,jul_mode!,enter_c!,full!
  '
  type|=par_byte|(1,0)
  '
  IF pic_exist! AND NOT type|=par_byte|(0,0)
    '
    ALERT 2,"CONFUSION : Picture type does not|match text type.|Use which fractal type ?",1,"Picture|Text",choice|
    '
    IF choice|=1
      type|=par_byte|(0,0)
      '
    ENDIF
    '
  ENDIF
  '
  IF type|<=max_complex|                ! JULS ONLY FOR COMPLEX TYPES
    '
    IF pic_exist!
      '
      full!=@ful_size(0)
      '
      IF par_byte|(0,3)<2 OR NOT full!  ! Method on mset not sphere or scape
        '
        jul_mode!=TRUE
        '
        IF par_mset!(0)
          ALERT 2,"How do you want to enter C|value ?",1,"Visually|Keyboard",choice|
          enter_c!=choice|=2
          '
        ELSE
          jul_query
          '
        ENDIF
        '
      ELSE
        jul_query
        '
      ENDIF
      '
    ELSE
      jul_query
      '
    ENDIF
    '
    ' QUESTIONS FINISHED ******************************************************
    '
    IF jul_mode!
      '
      IF enter_c!
        '
        copy_params(jul_ptr|(type|),1)            ! GET DEFAULTS
        par_byte|(1,0)=type|
        par_byte|(1,3)=par_byte|(0,3)
        show_params
        enter_c
        enter_iters
        auto_precision(1,FALSE)
        '
      ELSE
        select_c
        '
      ENDIF
      '
    ENDIF
    '
  ELSE
    ALERT 3,"No Julia sets for this|fractal type.",1,"Read Doc",choice|
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE zoom
  '
  ' FOR COMPLEX TYPES/POPCORN  : USER SELECTS ZOOM WINDOW AND NEW CO-ORDS
  ' AND PRECISION ARE STORED IN PAR_..(1)
  '
  LOCAL full!
  '
  type|=par_byte|(0,0)
  '
  IF type|<=max_complex|
    '
    full!=@ful_size(0)
    '
    IF par_byte|(0,3)<2 OR NOT full!
      '
      IF pic_exist!
        '
        SPUT scr$
        copy_params(0,1)
        select_pal
        select_zoom
        auto_precision(1,FALSE)
        CLS
        '
      ENDIF
      '
    ELSE
      '
      ALERT 3,"Can't zoom on 3D pictures.|Zoom as usual and then choose|SCAPE or SPHERE !",1,"Try it !",choice|
      '
    ENDIF
    '
  ELSE IF type|=11                      ! POPCORN - CAN ZOOM ON THAT
    '
    IF pic_exist!
      '
      full!=TRUE
      SPUT scr$
      select_pal
      select_zoom
      CLS
      '
    ENDIF
    '
  ELSE
    ALERT 3,"Not a complex fractal type.",1,"Whoops",choice|
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE draw_from_cd(alerts!)
  '
  LOCAL type|,method|,x_step,draw_over!
  '
  ' DRAWS FRACTAL FROM COORDINATE DATA IN PAR_*(1,*).
  ' alerts! IS USED TO ENABLE(TRUE) OR DISABLE THE APPEARACE OF ALERT BOXES.
  ' draw_over! IS USED FOR THE MOUNTAINS TYPE ONLY
  '
  HIDEM
  type|=par_byte|(1,0)
  copy_params(1,0)              ! MATCHES COORDINATES TO PICTURE
  CLS
  '
  IF type|<=max_complex|
    '
    method|=par_byte|(1,3)
    '
    IF method|>3                ! SORT OUT .SML METHODS
      '
      method|=method|-4
      x_max&=159                ! .SML WINDOW SIZE
      y_max&=99
      x_step=par_real(1,2)*2
      '
    ELSE
      '
      x_max&=319                ! .FUL WINDOW SIZE
      y_max&=199
      x_step=par_real(1,2)
      '
    ENDIF
    '
    SELECT method|
    CASE 0                      ! QUICK.
      '
      select_pal
      IF par_byte|(1,4)=2
        quick_fl(type|,par_mset!(1),par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_byte|(1,5),x_max&,y_max&)
      ELSE
        '
        bit_16!=par_byte|(1,4)=0
        quick_as(type|,par_mset!(1),bit_16!,par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_byte|(1,5),x_max&,y_max&)
        '
      ENDIF
      '
    CASE 1                      ! LEM
      '
      select_pal
      IF par_byte|(1,4)=2
        lem_fl(type|,par_mset!(1),par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_byte|(1,5),par_word&(1,1),x_max&,y_max&)
      ELSE
        '
        bit_16!=par_byte|(1,4)=0
        lem_as(type|,par_mset!(1),bit_16!,par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_byte|(1,5),par_word&(1,1),x_max&,y_max&)
        '
      ENDIF
      '
    CASE 2                      ! SPHERE
      '
      IF alerts!
        overlay(draw_over!)
      ENDIF
      '
      select_pal
      IF par_byte|(1,4)=2
        sphere_as(type|,par_mset!(1),bit_16!,par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_word&(1,1),par_word&(1,2),par_word&(1,3),par_real(1,5),par_byte|(1,8))
      ELSE
        '
        bit_16!=par_byte|(1,4)=0
        sphere_as(type|,par_mset!(1),bit_16!,par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_word&(1,1),par_word&(1,2),par_word&(1,3),par_real(1,5),par_byte|(1,8))
        '
      ENDIF
      '
    CASE 3
      '                         ! SCAPE
      IF alerts!
        overlay(draw_over!)
      ENDIF
      '
      select_pal
      3d_cpm_fl(type|,par_mset!(1),par_real(1,0),par_real(1,1),x_step,par_real(1,3),par_real(1,4),par_word&(1,0),par_byte|(1,5),par_byte|(1,6),par_byte|(1,7),par_byte|(1,9),par_real(1,5),par_byte|(1,8),par_byte|(1,4))
      '
    ENDSELECT
    '
    '
  ENDIF
  '
  SELECT type|
  CASE 11
    '
    select_pal
    popcorn(par_real(1,0),par_real(1,1),par_real(1,2),par_byte|(1,4),par_word&(1,0),par_byte|(1,3))
    '
  CASE 12
    '
    select_pal
    ws_dla(par_real(1,1),par_word&(1,0),par_long%(1),par_real(1,0))
    '
  CASE 13
    '
    select_pal
    line_dla(par_word&(1,0),par_long%(1))
    '
  CASE 14
    '
    select_pal
    draw_over!=FALSE
    '
    IF par_byte|(1,3)=0
      '
      cloud_render2(par_real(1,0),par_long%(1)) ! SKY
      '
    ELSE
      '
      cloud_render(par_real(1,0),par_long%(1))  ! PLASMA
      '
    ENDIF
    '
  CASE 15                                       ! MOUNTAINS
    '
    IF alerts!
      overlay(draw_over!)
    ELSE
      draw_over!=FALSE
    ENDIF
    '
    select_pal
    mount_render(par_real(1,0),par_long%(1),par_byte|(1,5),par_real(1,1),par_byte|(1,6),par_byte|(1,3),par_byte|(1,4))
    '
  ENDSELECT
  '
  SHOWM
  pic_exist!=TRUE
  SGET scr$
  '
RETURN
'
'
> PROCEDURE method
  '
  ' USER SELECTS METHOD
  '
  LOCAL selected|
  '
  IF par_byte|(1,0)<=max_complex|       ! WHICH TYPE ?
    '
    erase_buttons
    draw_buttons(6,but_loc&(),method_but_name$())
    check_buttons(6,but_loc&(),selected|)
    '
    IF selected|<6
      par_byte|(1,3)=selected|          ! NEW METHOD
    ENDIF
    '
    SELECT selected|                    ! ASSIGN DEFAULT PARAMS
    CASE 0,4                            ! NORMAL
      '
      par_byte|(1,5)=1                  ! SPREAD
      auto_precision(1,FALSE)
      '
    CASE 1,5                            ! LEM
      '
      par_word&(1,1)=5                  ! BOUND
      par_byte|(1,5)=1                  ! SPEAD
      auto_precision(1,FALSE)
      '
    CASE 2                              ! SPHERE
      '
      IF par_byte|(1,0)<9               ! TYPES : QUAD to COSN ONLY
        '
        par_word&(1,1)=-10              ! LIGHT SOURCE VECTOR
        par_word&(1,2)=-10
        par_word&(1,3)=-30
        par_real(1,5)=0.2               ! SPECULAR
        par_byte|(1,5)=2                ! SHINE
        auto_precision(1,FALSE)
        '
      ELSE
        ALERT 2,"Sphere method unavailable for|Newton or Deg4 types.",1,"OK",choice|
        '
      ENDIF
      '
    CASE 3                              ! SCAPE
      '
      IF par_byte|(1,0)<6               ! TYPES : QUAD to CUBIC2 ONLY
        '
        par_byte|(1,4)=150                ! HEIGHT
        par_byte|(1,5)=40                 ! OFFSET
        par_byte|(1,6)=170                ! EXTENT
        par_byte|(1,7)=40                 ! LIGHT ANGLE
        par_real(1,5)=0.2                 ! SPECULAR
        par_byte|(1,8)=2                  ! SHINE
        par_byte|(1,9)=50                 ! VIEW ANGLE
        '
      ELSE
        ALERT 2,"Scape method unavailable |for this fractal type.     ",1,"OK",choice|
        '
      ENDIF
      '
    ENDSELECT
    '
    IF selected|=2 OR selected|=3       ! ASSIGN DEFAULT PALETTE
      par_byte|(1,1)=31                 ! FIRST 3D PALETTE FOR SPHERE OR
      par_byte|(1,2)=0                  ! SCAPE
      '
    ELSE
      par_byte|(1,1)=0                  ! FIRST PLANAR PALETTE
      par_byte|(1,2)=0
      '
    ENDIF
    '
  ELSE IF par_byte|(1,0)=14     ! CLOUDS METHODS : SKY OR PLASMA
    '
    custom_alert("","  SKY  | PLASMA ",choice|) ! MENU
    copy_params(23,1)
    par_byte|(1,3)=choice|
    par_byte|(1,1)=35                 ! FIRST 3D PALETTE FOR MOUNTAINS
    par_byte|(1,2)=0                  ! SCAPE
    '
  ELSE
    ALERT 3,"Only one method for this|fractal type.",1,"YoDude",choice|
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE enter_params
  '
  LOCAL type|,method|,p_min&
  '
  type|=par_byte|(1,0)
  '
  IF type|>11
    '
    enter_long(24,9,"",7,-1,10000000,V:par_long%(1))     ! SEED
    '
  ENDIF
  '
  IF type|<=max_complex|
    '
    method|=par_byte|(1,3)
    '
    IF method|>3                ! IF .SML METHOD THEN TREAT AS EQUIVALENT .FUL
      method|=method|-4         ! METHOD.
    ENDIF
    '
    enter_coords
    '
    IF NOT par_mset!(1)                                 ! JULIA SET
      enter_c
    ENDIF
    '
    enter_iters
    '
    IF method|=3                        ! SCAPE.
      '
      enter_scape
      '
    ELSE
      '
      IF type|<6
        IF type|<4
          p_min&=-1
        ELSE
          p_min&=0
        ENDIF
        enter_byte(24,17,"",1,p_min&,3,V:par_byte|(1,4))    ! PRECISION
      ELSE
        par_byte|(1,4)=2
      ENDIF
      '
    ENDIF
    '
    IF method|<2                                 ! QUICK OR LEM
      enter_spread
    ENDIF
    '
    IF method|=1
      enter_bound
    ENDIF
    '
    IF method|=2                            ! SPHERE
      enter_sphere
    ENDIF
    '
    '
  ENDIF
  SELECT type|
  CASE 11                                               ! POPCORN
    '
    enter_coords
    enter_popcorn
    '
  CASE 12                                               ! P_DLA
    '
    enter_p_dla
    '
  CASE 13                                               ! L_DLA
    '
    enter_word(23,10,"",4,0,10000,V:par_word&(1,0))              ! SPRD
    '
  CASE 14
    '
    enter_real(24,10,"",4,0,1,V:par_real(1,0))     ! DIMENSION
    '
  CASE 15
    '
    enter_mount
    '
  ENDSELECT
  '
  '
RETURN
'
'
> PROCEDURE user_load_cdf
  '
  ' USER SELECTS/ENTERS A CDF NAME AND IF IT EXISTS,IS LOADED.
  '
  LOCAL file_name$,file_exist!,cancel!,path_fine!
  '
  select_file("CDF",file_name$,file_exist!,cancel!,path_fine!)
  '
  IF file_exist! AND path_fine! AND NOT cancel!
    PRINT "LOADING ";file_name$
    read_cdf(1,file_name$)
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE user_save_cdf
  '
  ' USER SELECTS/ENTERS NAME WHICH CDF IS SAVED BY.
  '
  LOCAL file_name$,file_exist!,cancel!,path_fine!,wrte!,choice|
  '
  get_next("CDF",file_name$)
  select_file("CDF",file_name$,file_exist!,cancel!,path_fine!)
  wrte!=FALSE
  '
  IF path_fine! AND (NOT cancel!)
    auto_ext("CDF",file_name$)
    '
    IF file_exist!
      ALERT 2,file_name$+"|already exists,|overwrite ?",2,"Yes|No",choice|
      wrte!=choice|=1
      '
    ELSE
      '
      wrte!=TRUE
      '
    ENDIF
    '
    IF wrte!
      disk_free(cdf_len&,wrte!)
      '
      IF wrte!
        '
        CLS
        PRINT "SAVING ";file_name$
        write_cdf(1,file_name$)
        '
      ELSE
        ALERT 3,"Not enough disk space.",1,"Oh dear",choice|
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE user_load_pic
  '
  LOCAL file_name$,file_exist!,cancel!,path_fine!,file_format|,choice|
  '
  ALERT 2,"Which picture format ?",2,".SML|.FUL",file_format|
  DEC file_format|
  '
  IF file_format|=0
    select_file("SML",file_name$,file_exist!,cancel!,path_fine!)
  ELSE
    select_file("FUL",file_name$,file_exist!,cancel!,path_fine!)
  ENDIF
  '
  IF path_fine! AND NOT (cancel!)
    '
    IF file_exist!
      '
      CLR scr$
      PRINT "LOADING ";file_name$
      '
      IF file_format|=0                 ! LOAD .SML
        read_sml(file_name$)
        '
      ELSE                              ! LOAD .FUL
        read_ful(file_name$)
        '
      ENDIF
      '
      select_pal
      SGET scr$
      pic_exist!=TRUE
      wait_for_mouse(dum&,dum&)
      '
    ELSE
      '
      ALERT 3,"File does not exist.",1,"Whoops",choice|
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE user_save_pic
  '
  ' USER CHOOSES FILE FORMAT AND SELECTS/ENTERS SAVE NAME FOR PICTURE
  '
  LOCAL file_exist!,file_name$,wrte!,ext$,num_cols|,file_format|
  LOCAL choice|,path_fine!
  '
  IF pic_exist!
    '
    select_pal
    SPUT scr$
    ALERT 2,"Which file format ?",1,"FE 2|.PI1|.NEO",file_format|
    '
    SELECT file_format|
    CASE 1
      '
      IF @ful_size(0)           ! IS THE SCREEN FULL SIZE?
        ext$="FUL"
      ELSE
        file_format|=0
        ext$="SML"
      ENDIF
      '
    CASE 2
      ext$="PI1"
    CASE 3
      ext$="NEO"
    ENDSELECT
    '
    get_next(ext$,file_name$)
    select_file(ext$,file_name$,file_exist!,cancel!,path_fine!)
    wrte!=FALSE
    SPUT scr$
    '
    IF path_fine! AND NOT cancel!
      '
      IF file_exist!
        ALERT 2,file_name$+"|already exists,|overwrite ?",2,"Yes|No",choice|
        wrte!=choice|=1
        '
      ELSE
        '
        wrte!=TRUE
        '
      ENDIF
      '
      IF wrte!
        disk_free(pic_file_len&(file_format|),wrte!)
        '
        IF wrte!
          write_pic(file_format|,file_name$,TRUE,num_cols|)
          '
        ELSE
          ALERT 3,"Not enough disk space.",1,"Oh dear",choice|
          '
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ELSE
    '
    ALERT 3,"No picture to save.",1,"Silly me",choice|
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE batch
  '
  ' SUB MENU OF VARIOUS BATCH OPERATIONS WHICH CAN BE USED TO DRAW
  ' AND SAVE MULTIPLE IMAGES.
  '
  LOCAL selected|,i_folder$,o_folder$,prnt!,wrte!,num_frames&,batch_name$
  '
  erase_buttons
  draw_buttons(4,but_loc&(),batch_but_name$())
  check_buttons(4,but_loc&(),selected|)
  '
  SELECT selected|
  CASE 0,1                              ! ZOOM AND JULIA ANIN BUTTONS RESP
    '
    IF ani_end_frame!                   ! GLOBAL - DETERMINES WHETHER THE LAST
      calc_anim(selected|=0)            ! FRAME HAS BEEN SELECTED. THIS IS
    ELSE                                ! PERFORMED FIRST BY THE USER AND last_
      last_frame(selected|=0)           ! frame IS CALLED THE SECOND TIME THEY
    ENDIF                               ! SELECT OF ONE OF THESE BUTTONS
    '                                   ! calc_anim IS CALLED.
    '
  CASE 2
    poster                              ! TURN CURRENT CD INTO 4, 9 OR 16
    '                                   ! .FUL'S SCREENS.
  CASE 3
    convert                             ! CONVERTS A FOLDER OF CDF'S INTO PICS.
    '
  ENDSELECT
  '
  '
RETURN
'
'
> PROCEDURE view
  '
  ' SHOWS CURRENT PICTURE UNTIL MOUSE PRESSED
  '
  IF pic_exist!
    '
    select_pal
    SPUT scr$
    WHILE MOUSEK=0
    WEND
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE store_pic
  '
  ' STORES CURRENT PICTURE IN MEMORY
  '
  LOCAL choice|
  '
  IF pic_exist!
    '
    SPUT scr$
    select_pal
    ALERT 2,"Store current picture in|memory ?",2,"Yes|Cancel",choice|
    '
    IF choice|=1
      stored_scr$=scr$
      copy_params(0,2)
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE restore_pic
  '
  ' RESTORES PICTURE TO ONE STORED IN MEMORY (IF THERE IS ONE IN MEM)
  '
  LOCAL choice|
  '
  setcols(par_byte|(2,1),par_byte|(2,2),0,0,0,0)
  SPUT stored_scr$
  ALERT 2,"Restore picture to this|one ?      ",2,"Yes|Cancel",choice|
  '
  IF choice|=1
    '
    scr$=stored_scr$
    copy_params(2,0)
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE palette
  '
  ' DISPLAYS PALETTE MENU ; USER SELECTS PALETTE, MODE +/-, EDIT, OR EXIT
  '
  LOCAL x_win&,y_win&,dum&,k|
  LOCAL exit!,clicked|,pal|,mode|,col|
  '
  DIM temp_loc&(7,1)            ! 7 OPTIONS ON PAL MENU
  '
  HIDEM
  SPUT scr$
  GRAPHMODE 3
  x_win&=0
  y_win&=100
  SETMOUSE x_win&,y_win&
  BOX x_win&,y_win&,x_win&+133,y_win&+90
  '
  ' USER SELECTS WINDOW LOCATION :
  '
  REPEAT
    '
    select_pal
    REPEAT
      MOUSE x&,y&,k|
    UNTIL k|>0 OR NOT (x_win&=x& AND y_win&=y&)
    '
    IF x&<320-133 AND y&<200-90
      '
      BOX x_win&,y_win&,x_win&+133,y_win&+90    ! ERASE OLD BOX
      '
      x_win&=x&                                 ! DRAW NEW BOX
      y_win&=y&
      BOX x_win&,y_win&,x_win&+133,y_win&+90
      '
    ELSE
      '
      SETMOUSE x_win&,y_win&
      '
    ENDIF
    '
  UNTIL k|>0
  '
  ' PALETTE MENU
  '
  GRAPHMODE 1
  SHOWM
  col|=0
  exit!=FALSE
  pal|=par_byte|(0,1)
  mode|=par_byte|(0,2)
  draw_pal_win(x_win&,y_win&)
  '
  REPEAT
    '
    palette_text
    check_buttons(7,temp_loc&(),clicked|)
    '
    SELECT clicked|
    CASE 0                                      ! PAL -
      '
      pal_mode_plus(-1,0)
      '
    CASE 1                                      ! PAL +
      '
      pal_mode_plus(1,0)
      '
    CASE 2                                      ! MODE -
      '
      pal_mode_plus(0,-1)
      '
    CASE 3                                      ! MODE +
      '
      pal_mode_plus(0,1)
      '
    CASE 4,12                                   ! SWIRL
      '
      swirl(clicked|=4)                         ! 4 (LEFT BUTTON) FOR SWIRL OUT.
      '
    CASE 5                                      ! HIDE PAL MENU
      SPUT scr$
      wait_no_mouse
      REPEAT
      UNTIL MOUSEK>0
      draw_pal_win(x_win&,y_win&)
      '
    CASE 6
      edit_palette(col|)
      draw_pal_win(x_win&,y_win&)
      '
    CASE 7
      exit!=TRUE
      '
    CASE 8                      ! IF RIGHT BUTTON CLICKED DEC PAL# BY 5
      '
      pal_mode_plus(-5,0)
      '
    CASE 9                      ! IF RIGHT BUTTON CLICKED INC PAL# BY 5
      '
      pal_mode_plus(5,0)
      '
    ENDSELECT
    par_byte|(0,1)=pal|
    par_byte|(0,2)=mode|
    '
  UNTIL exit!=TRUE
  '
  CLS
  ERASE temp_loc&()
  '
RETURN
'
'
> PROCEDURE write_pal
  '
  ' SAVES PALETTE.DAT(A) TO THE DEFAULTS FOLDER.
  '
  LOCAL choice|
  '
  IF EXIST("DEFAULTS.FE2\PALETTE.DAT")
    ALERT 2,"Save entire palette data ?",1,"Yes|No",choice|
    '
    IF choice|=1
      BSAVE "DEFAULTS.FE2\PALETTE.DAT",V:pal_data|(0,0,0),1920
    ENDIF
    '
  ELSE
    ALERT 3,"Cannot find file.|Insert program disk|and try again.",1,"OK",choice|
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE lsystem
  '
  ' LOADS AND DRAWS AN L-SYSTEM.
  ' SYNTAX OF .LSF FILE :
  '  "//"            - COMMENT LINE IGNORED COMPLETELY.
  '  "LSYSTEM()"     - FUNCTION.
  '
  ' SYNTAX OF PARAMTERS :
  ' DEFAULT # OF ITERS, LINE LENGTH (REAL),
  ' TURN ANGLE (DEGREES), START ANGLE, XSTART, YSTART, START STRING,
  ' PRODUTION RULES.
  '
  LOCAL file_name$,file_exist!,cancel!,path_fine!,prg_ok!
  DIM prod_rules$(10),x_stack(99),y_stack(99),angle_stack&(99)
  '
  CLS
  '
  file_name$="TEST.LSD"
  select_file("LSD",file_name$,file_exist!,cancel!,path_fine!)
  '
  IF path_fine! AND file_exist! AND NOT cnacel!
    '
    PRINT "FRACTAL ENGINE V3.0 L-SYSTEM ITERPRETER"
    PRINT "---------------------------------------"
    prg_ok!=TRUE
    PRINT
    PRINT "ASCII FILE : ";file_name$
    PRINT
    HIDEM
    '
    ' *************************** READ ASCII FILE ******************************
    '
    OPEN "I",#1,file_name$
    '
    REPEAT
      lsys_string(field$,eof!)
    UNTIL field$="LSYSTEM" OR eof!
    '
    lsys_string(field$,eof!)
    max_iters|=VAL(field$)
    '
    lsys_string(field$,eof!)
    line_len=VAL(field$)
    '
    lsys_string(field$,eof!)
    turn&=VAL(field$)
    '
    lsys_string(field$,eof!)
    start_angle&=VAL(field$)
    '
    lsys_string(field$,eof!)
    x0=VAL(field$)
    '
    lsys_string(field$,eof!)
    y0=VAL(field$)
    '
    lsys_string(prg$,eof!)
    '
    lsys_string(prod_letters$,eof!)
    num_letters|=LEN(prod_letters$)
    dum$=""
    '
    FOR n|=1 TO num_letters|
      lsys_string(field$,eof!)
      prod_rules$(n|)=field$
    NEXT n|
    '
    CLOSE #1
    '
    ' ***************************  WRITE LOGO STRING ***************************
    '
    PRINT "WRITING LOGO STRING ..."
    '
    FOR iter|=1 TO max_iters|
      '
      PRINT AT(1,7);"Iterations left = ";max_iters|-iter|;"  ";
      temp_prg$=""
      len&=LEN(prg$)
      count&=len&
      prg_end&=len&-1
      '
      FOR pc_count&=0 TO prg_end&
        '
        DEC count&
        PRINT AT(1,8);"Characters left = ";(count&);"  "
        char$=CHR$(PEEK(V:prg$+pc_count&))
        '
        FOR letter|=1 TO num_letters|
          '
          IF char$=MID$(prod_letters$,letter|,1)
            '
            char$=prod_rules$(letter|)
            LET letter|=num_letters|
            '
          ENDIF
          '
        NEXT letter|
        '
        IF LEN(temp_prg$)+LEN(char$)<32767
          temp_prg$=temp_prg$+char$
        ELSE
          SHOWM
          ALERT 3,"ERROR : String too lomg.|Try fewer iterations.",1,"OK",ok|
          pc_count&=prg_end&
          iter|=max_iters|
          prg_ok!=FALSE
          '
        ENDIF
        '
        EXIT IF MOUSEK=2
        '
      NEXT pc_count&
      '
      prg$=temp_prg$
      '
    NEXT iter|
    '
    IF prg_ok!
      '
      ' ******************* INTERPRET LOGO STRING - DRAW LSYSTEM  ****************
      '
      CLS
      stack_ptr%=0
      current_angle&=start_angle&
      len&=LEN(prg$)
      prg_end&=len&-1
      '
      FOR pc_count&=0 TO prg_end&
        '
        char$=CHR$(PEEK(V:prg$+pc_count&))
        '
        SELECT char$
        CASE "F"
          '
          x=x0+COSQ(current_angle&)*line_len
          y=y0-SINQ(current_angle&)*line_len
          COLOR stack_ptr% MOD 14+2
          LINE x0,y0,x,y
          x0=x
          y0=y
          '
        CASE "+"
          current_angle&=(current_angle&-turn&+360) MOD 360
          '
        CASE "-"
          current_angle&=(current_angle&+turn&) MOD 360
          '
        CASE "["
          '
          x_stack(stack_ptr%)=x0
          y_stack(stack_ptr%)=y0
          angle_stack&(stack_ptr%)=current_angle&
          INC stack_ptr%
          '
        CASE "]"
          '
          IF stack_ptr%=0
            PRINT V:prg$-prg_start%
            PRINT "STACK ERROR"
            '
          ELSE
            '
            DEC stack_ptr%
            x0=x_stack(stack_ptr%)
            y0=y_stack(stack_ptr%)
            current_angle&=angle_stack&(stack_ptr%)
            '
          ENDIF
          '
          EXIT IF MOUSEK=2
          '
        ENDSELECT
        '
      NEXT pc_count&
      '
      SHOWM
      pic_exist!=TRUE
      SGET scr$
      par_byte|(1,0)=16
      '
      WHILE MOUSEK=0
      WEND
      '
    ENDIF                       ! IF LOGO PROGRAM OK
    '
  ENDIF                 ! IF FILE READ IN OK
  '
  ERASE prod_rules$(),x_stack(),y_stack(),angle_stack&()
  '
RETURN
'
'
> PROCEDURE types
  '
  ' FRACTAL TYPES MENU - EACH BUTTON IS A FRACTAL TYPE, EXCEPT CHOOSE AND EXIT
  '
  LOCAL but_selected|
  '
  copy_params(1,3)      ! STORE CURRENT CD IN ANIMATION CD
  ani_end_frame!=FALSE  ! ANIMATION END FRAME VOID NOW
  draw_buttons(max_type|+2,but_loc&(),type_but_name$()) ! 2 extras:CHOOSE & EXIT
  '
  REPEAT                ! TYPES MENU LOOP
    '
    show_params
    check_buttons(max_type|+2,but_loc&(),but_selected|)
    '
    IF but_selected|úâ(`:=|ŠPEúâ`.=|ÚPEúà_`"=|ÀPEúÞR`=|ÂPEúÞR`
=|ÈPEúÞøAîNr max_type|
      copy_params(9+but_selected|,1)
      '
    ENDIF
    '
  UNTIL but_selected|>max_type|
  '
  IF but_selected|=max_type|+2
    copy_params(3,1)            ! EXIT CLICKED : RESTORE OLD CD
    '
  ENDIF
  '
  '
RETURN
'
' ==============================================================================
'                                MOUSE STUFF
' ==============================================================================
'
> PROCEDURE get_mouse_wait(VAR mx&,my&,mk|)
  '
  REPEAT
    MOUSE mx&,my&,mk|
  UNTIL NOT mk|=0
  '
  wait_no_mouse
  '
RETURN
'
'
> PROCEDURE wait_for_mouse(VAR mx&,my&)
  '
  LOCAL mk|
  '
  REPEAT
    MOUSE mx&,my&,mk|
  UNTIL mk|>0
  '
RETURN
'
'
> PROCEDURE wait_no_mouse
  '
  REPEAT
  UNTIL MOUSEK=0
  '
RETURN
'
'
> PROCEDURE jul_query
  '
  ' ALERT BOX FOR JULIA SUBROUTINE.
  ALERT 2,"Not an Mandel picture |(QUICK or LEM). Enter|C value.?",1," Yes |Cancel",choice|
  enter_c!=choice|=1
  jul_mode!=enter_c!
  '
RETURN
'
'
> PROCEDURE select_c
  '
  ' USER SELECTS C VALUE FROM A SMALL OR FULL MSET IMAGE
  '
  LOCAL mx&,my&,mk|,y_tops&
  '
  select_pal
  SPUT scr$
  '
  get_mouse_wait(mx&,my&,mk|)
  '
  IF full!
    tweak|=1
    y_tops&=199
  ELSE
    tweak|=2
    y_tops&=99
  ENDIF
  '
  ' CALCULATE C VALUE *********************************************************
  copy_params(jul_ptr|(type|),1)
  par_byte|(1,1)=par_byte|(0,1)                 ! COPY PALETTE FROM IMAGE
  par_byte|(1,2)=par_byte|(0,2)                 ! COPY MODE FROM IMAGE
  par_byte|(1,3)=par_byte|(0,3)
  par_byte|(1,0)=type|
  par_real(1,3)=par_real(0,0)+mx&*par_real(0,2)*tweak|
  par_real(1,4)=par_real(0,1)+(y_tops&-my&)*par_real(0,2)*tweak|
  auto_precision(1,FALSE)
  '
  '
RETURN
'
'
> PROCEDURE select_zoom
  '
  ' USER GRAPHICALLY SELECTS AREA TO ZOM IN ON CURRENT IMAGE.
  ' THE RESULTING CD IS STORED IN par_..(1,*).
  '
  DIM real(319),imag(199)
  '
  LOCAL x&,y&,bsx&,bsy&,y0&,x1&,t_x0&,t_y0&,old_x0&,old_y0&,flag!,key!,i$
  LOCAL x_max&,y_max&,mk|,x_step,yn|,tweak|
  '
  HIDEM
  SETMOUSE 0,0
  GRAPHMODE 3                   ! For drawing zoom box in XOR mode
  '
  x_min=par_real(0,0)           ! Input for zoom is the picture CD (par_..0)
  y_min=par_real(0,1)
  tweak|=2+full!                ! =1 (IF full!), =2 (FOR .SML : DOUBLES x_step)
  x_step=par_real(0,2)*tweak|
  '
  IF full!                      ! Set maximum window screen co-ordinates
    x_max&=319
    y_max&=199
  ELSE
    x_max&=159
    y_max&=99
  ENDIF
  '
  complex_array
  '
  x0&=0                         ! Init top left screen co-ords for zoom box
  y0&=0
  key!=FALSE                    ! has a button been pressed
  bsx&=x_max&                   ! Init zoom box screen dimensions
  bsy&=y_max&
  '
  REPEAT
    '
    x1&=x0&+bsx&                ! Set current bottom right screen co-ord
    y1&=y0&+bsy&                ! of zoom box
    BOX x0&,y0&,x1&,y1&         ! Draw zoom box
    LINE x0&,y0&,x1&,y1&
    LINE x0&,y1&,x1&,y0&
    old_x0&=x0&                 ! Temporary storage
    old_y0&=y0&
    box_flag!=FALSE             ! Redraw box ?
    '
    REPEAT
      '
      MOUSE t_x0&,t_y0&,mk|     ! Temp store for mouse status
      i$=INKEY$
      key!=i$=""
      '
      IF t_x0&<>x0& OR t_y&<>y0&       ! Has mouse moved
        '
        IF t_x0&=>0 AND t_y0&=>0 AND t_x&+bsx&<=x_max& AND t_y0&+bsy&<=y_max&
          '
          x0&=t_x0&                     ! Box can be moved
          y0&=t_y0&
          box_flag!=TRUE
          '
        ELSE
          '
          SETMOUSE x0&,y0&              ! Box cannot be moved
          '
        ENDIF
        '
      ENDIF
      '
      '
      IF mk|=1 AND bsx&>7
        ADD x0&,4               ! Shrink box
        ADD y0&,3
        SETMOUSE x0&,y0&        ! Mousey follow box
        SUB bsx&,8
        SUB bsy&,5
        box_flag!=TRUE
        PAUSE 2
      ENDIF
      '
      IF mk|=2 AND bsx&<x_max&
        '
        IF x0&-4=>0 AND y0&-3=>0 AND x1&+4<=x_max& AND y1&+2<=y_max&
          '
          SUB x0&,4             ! Expand box
          SUB y0&,3
          SETMOUSE x0&,y0&      ! Mousey follow box
          ADD bsx&,8
          ADD bsy&,5
          box_flag!=TRUE
          PAUSE 2
          '
        ENDIF
        '
      ENDIF
      '
    UNTIL box_flag! OR NOT key!
    '
    BOX old_x0&,old_y0&,x1&,y1&         ! Erase old box
    LINE old_x0&,old_y0&,x1&,y1&
    LINE old_x0&,y1&,x1&,old_y0&
    '
  UNTIL NOT key!
  '
  '
  BOX old_x0&,old_y0&,x1&,y1&
  SHOWM
  '
  copy_params(0,1)
  '
  IF i$="o" OR i$="O"
    ' zoom out choosen
    x_step=(x_max&+1)*par_real(0,2)/(bsx&+1)
    par_real(1,0)=real(x0&)-x_step*tweak|*x0&
    par_real(1,1)=imag(y1&)-x_step*tweak|*(y_max&-y1&)
    par_real(1,2)=x_step
    '
  ELSE
    par_real(1,0)=real(x0&)
    par_real(1,1)=imag(y1&)
    par_real(1,2)=(bsx&+1)*x_step/320
    '
  ENDIF
  '
  ' Inherit method
  par_byte|(1,3)=par_byte|(0,3)
  GRAPHMODE 1
  ERASE real(),imag()
  '
  '
RETURN
'
'
> PROCEDURE how_many_cols(VAR num_cols|)
  '
  ' USER ENTERS NUMBER OF COLOURS - USED WHEN SAVING A DEGAS/NEO PICTURE
  '
  ALERT 2,"How many colours ?",3,"4|9|16",num_cols|
  SELECT num_cols|
  CASE 1
    num_cols|=4
  CASE 2
    num_cols|=9
  CASE 3
    num_cols|=16
  ENDSELECT
  '
RETURN
'
' ==============================================================================
'                                KEYBOARD INPUT
' ==============================================================================
'
' EACH OF THESE PROCEDURES INPUTS A STRING AT x&,y& (TEXT POSITION).
' THE MINIMUM AND MAXIMU VALUES ARE ALSO PASSED, TO NUMERICAL ONES.
' ALSO THE ADDRESS OF THE VARTIABLE TO BE UPDATED.
' NUMBER OF CHARACTERS ALLOWED TO BE ENTERED IS PASSED.
'
> PROCEDURE enter_byte(x&,y&,prompt$,num_chars|,i_min&,i_max&,int_adr%)
  '
  LOCAL dum|,dum&,dum$
  '
  dum|=BYTE{int_adr%}
  dum$=STR$(dum|)
  '
  REPEAT
    '
    PRINT AT(x&,y&);SPACE$(num_chars|)
    PRINT AT(x&,y&);prompt$;
    FORM INPUT num_chars| AS dum$
    dum&=VAL(dum$)
    '
  UNTIL dum&>i_min& AND dum&<i_max&
  '
  dum|=dum&
  BYTE{int_adr%}=dum|
  '
  '
RETURN
'
'
> PROCEDURE enter_word(x&,y&,prompt$,num_chars|,i_min&,i_max&,int_adr%)
  '
  LOCAL dum&,dum$
  '
  dum&=INT{int_adr%}
  dum$=STR$(dum&)
  '
  REPEAT
    '
    PRINT AT(x&,y&);SPACE$(num_chars|)
    PRINT AT(x&,y&);prompt$;
    FORM INPUT num_chars| AS dum$
    dum&=VAL(dum$)
    '
  UNTIL dum&>i_min& AND dum&<i_max&
  '
  INT{int_adr%}=dum&
  '
  '
RETURN
'
'
> PROCEDURE enter_long(x&,y&,prompt$,num_chars|,i_min%,i_max%,int_adr%)
  '
  LOCAL dum%,dum$
  '
  dum%=LONG{int_adr%}
  dum$=STR$(dum%)
  '
  REPEAT
    '
    PRINT AT(x&,y&);SPACE$(num_chars|)
    PRINT AT(x&,y&);prompt$;
    FORM INPUT num_chars| AS dum$
    dum%=VAL(dum$)
    '
  UNTIL dum%>i_min% AND dum%<i_max%
  '
  LONG{int_adr%}=dum%
  '
  '
RETURN
'
'
> PROCEDURE enter_real(x&,y&,prompt$,num_chars|,r_min,r_max,real_adr%)
  '
  LOCAL dum,dum$
  '
  dum=FLOAT{real_adr%}
  dum$=STR$(dum)
  '
  REPEAT
    '
    PRINT AT(x&,y&);SPACE$(num_chars|)
    PRINT AT(x&,y&);prompt$;
    FORM INPUT num_chars| AS dum$
    dum=VAL(dum$)
    '
  UNTIL dum>r_min AND dum<r_max
  FLOAT{real_adr%}=dum
  '
  '
RETURN
'
'
' **************************  NON-NUMERICAL ONES  ******************************
'
> PROCEDURE enter_yes_no(x&,y&,default$,VAR yes!)
  '
  ' USER ENTERS "y" (OR "Y") FOR YES OR "n" (OR "N") FOR NO
  ' yes! IS TRUE IF YES WAS ENTERED. INPUT OCCURS AT x&,y&
  '
  LOCAL syntax!
  '
  REPEAT
    '
    enter_string(x&,y&,"",1,default$,yn$)
    syntax!=(yn$="Y" OR yn$="y" OR yn$="N" OR yn$="n")
    '
  UNTIL syntax!
  '
  yes!=(yn$="Y" OR yn$="y")
  '
  '
RETURN
'
'
> PROCEDURE enter_string(x&,y&,prompt$,num_chars|,default$,VAR string$)
  '
  LOCAL dum
  '
  string$=default$
  '
  PRINT AT(x&,y&);SPACE$(num_chars|)
  PRINT AT(x&,y&);prompt$;
  FORM INPUT num_chars| AS string$
  '
  '
RETURN
'
' ==============================================================================
'                               DISK INPUT
' ==============================================================================
'
> PROCEDURE init_defaults
  '
  ' LOADS IN DEFAULT CDF'S FOR EACH FRACTAL TYPE AND THEN SOME FOR THE JULIAS
  '
  LOCAL type|,par|
  '
  type|=0                       ! STANDARD DEFAULTS :
  '
  FOR par|=9 TO max_type|+9
    read_cdf(par|,"DEFAULTS.FE2\"+def_name$(type|)+".CDF")
    INC type|
    '
  NEXT par|
  '
  n|=1                  ! JULIA DEFAULTS :
  '                     ! SOME ARE SHARED BY MORE THAN ONE TYPE (SEE JULIA)
  FOR par|=4 TO 8
    read_cdf(par|,"DEFAULTS.FE2\DEF_JUL"+STR$(n|)+".CDF")
    INC n|
    '
  NEXT par|
  '
  '
RETURN
'
'
> PROCEDURE read_sml(file_name$)
  '
  ' READS A .SML FILE FROM DISK AND STICKS IT ON THE SCREEN, ALSO GETS THE CD
  '
  LOCAL dum&,dum1&,dum2&,dum3|,file_type|,adr%,sml$,version|
  '
  GET 0,0,159,99,sml$
  adr%=MALLOC(8192)
  BLOAD file_name$,adr%
  fe_version(file_name$,version|)
  '
  IF version|=1
    restore_fe1_cd(0,adr%,file_name$)
    BMOVE adr%+50,6+V:sml$,8000
    '
  ELSE
    restore_header(adr%,file_type|,dum1&,dum2&,dum3|)
    restore_cd(0,adr%)                      ! GET CD DATA
    BMOVE adr%+cdf_len&,6+V:sml$,8000             ! GET BIT MAP DATA INTO sml$
    '
  ENDIF
  '
  ~MFREE(adr%)
  CLS
  PUT 0,0,sml$
  '
  '
RETURN
'
'
> PROCEDURE read_ful(file_name$)
  '
  ' READS A .FUL FILE FROM DISK AND STICKS IT ON THE SCREEN, ALSO GETS THE CD
  '
  LOCAL dum&,dum1&,dum2&,dum3|,file_type|,adr%,version|
  '
  adr%=MALLOC(32256)
  BLOAD file_name$,adr%
  fe_version(file_name$,version|)
  '
  IF version|=1
    restore_fe1_cd(0,adr%,file_name$)
    BMOVE adr%+50,screen_adr%,32000
    '
  ELSE
    restore_header(adr%,file_type|,dum1&,dum2&,dum3|)
    restore_cd(0,adr%)                      ! GET CD DATA
    BMOVE adr%+cdf_len&,screen_adr%,32000         ! GET BIT MAP DATA
    '
  ENDIF
  '
  ~MFREE(adr%)
  '
  '
RETURN
'
'
> PROCEDURE read_cdf(par|,file_name$)
  '
  ' READS A CDF INTO par..(par|,*)
  '
  LOCAL adr%,n|,file_type|,dum1&,dum2&,dum3|,version|
  '
  adr%=MALLOC(256)
  BLOAD file_name$,adr%
  fe_version(file_name$,version|)
  '
  IF version|=1
    restore_fe1_cd(par|,adr%,file_name$)
    '
  ELSE
    restore_header(adr%,file_type|,dum1&,dum2&,dum3|)
    restore_cd(par|,adr%)
    '
  ENDIF
  '
  ~MFREE(adr%)
  '
  '
RETURN
'
'
> PROCEDURE lsys_string(VAR field$,eof!)
  '
  ' READS IN A STRING A CHARACTER AT A TIME UNTIL A DELEMINATOR CHARATER IS
  ' FOUND OR THE END OF THE FILE.
  '
  LOCAL char$,delimeter!
  '
  char$=""
  '
  REPEAT
    get_char(char$,eof!)
    lsys_delimeter(char$,delimeter!)
    '
  UNTIL eof! OR NOT delimeter!
  '
  field$=""
  '
  WHILE NOT (delimeter! OR eof!)
    field$=field$+char$
    get_char(char$,eof!)
    lsys_delimeter(char$,delimeter!)
    '
  WEND
  '
RETURN
'
'
> PROCEDURE lsys_delimeter(char$,VAR delimeter!)
  '
  delimeter!=char$="," OR char$="(" OR char$="""" OR char$=")" OR char$="/"
  delimeter!=char$=" " OR ASC(char$)<32 OR delimeter!
  '
RETURN
'
'
> PROCEDURE get_char(VAR char$,eof!)
  '
  eof!=EOF(#1)
  '
  IF NOT eof!
    char$=CHR$(INP(#1))
  ENDIF
  '
RETURN
'
'
> PROCEDURE select_file(ext$,VAR file_name$,file_exist!,cancel!,path_fine!)
  '
  ' USER SELECTS A FILE USING A FILE SELECT BOX
  '
  LOCAL path$
  '
  path$=current_path$+"*."+ext$         ! current_path$ IS GLOBAL
  ~FSEL_INPUT(path$,file_name$,n&)
  CLS
  cancel!=(n&=0)                        ! cancel button oN FSEL' BOX
  '
  IF NOT cancel!
    current_path$=path$
    be_rid_of_ext(current_path$,path_fine!)
    file_name$=current_path$+file_name$
    auto_ext(ext$,file_name$)
    file_exist!=EXIST(file_name$)
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE select_path(for_input!,VAR ok&,path$)
  '
  ' USER SELECTS A DISK DIRECTORY USING FSEL' BOX
  '
  LOCAL file_len|,file_name$,choice|,s$,path_fine!
  '
  IF for_input!          ! IS PATH BEING SELECTED FOR OUTPUT OR INPUT ?
    s$="input"
    '
  ELSE
    s$="output"
    '
  ENDIF
  '
  ALERT 3,"Insert save disk and select|desired "+s$+" path.",1,"OK",choice|
  '
  REPEAT
    '
    ~FSEL_INPUT(path$,file_name$,ok&)
    CLS
    '
    IF ok&=0
      ALERT 3,"No path selected.",1,"Whoops",choice|
      '
    ELSE
      be_rid_of_ext(path$,path_fine!)
      '
    ENDIF
    '
  UNTIL path_fine! OR ok&=0
  '
RETURN
'
'
> PROCEDURE disk_free(file_len%,VAR yep!)
  '
  ' CHECKS TO SEE IF THERE IS ROOM FOR A FILE OF SIZE file_len& ON THE DISK
  ' SETS yep& IF THAT IS THE CASE
  '
  yep!=(DFREE(0)>=file_len%)
  '
RETURN
'
'
> PROCEDURE fe_version(file_name$,VAR version|)
  '
  ' DETERMINES THE VERSION OF FE WHICH PRODUCED THE PICTURE BY THE LENGTH OF
  ' THE CD.
  '
  LOCAL file_len%
  '
  OPEN "I",#1,file_name$
  '
  file_len%=LOF(#1)
  '
  IF file_len% MOD 1000=cdf_len&      ! SUBTRACTS BIT MAP (DIVISIBLE BY 1000)
    version|=2
    '
  ELSE
    version|=1
    '
  ENDIF
  '
  CLOSE #1
  '
RETURN
'
' ==============================================================================
'                               DISK OUTPUT
' ==============================================================================
'
> PROCEDURE write_sml(file_name$)
  '
  ' SAVES A QUARTER SIZE IMAGE (BIT MAP) AND CD IN ONE FILE. IMAGE MUST BE ON
  ' THE SCREEN BEFORE THE .SML IS SAVED.
  '
  LOCAL adr%,sml$
  '
  ' WRITES .SML FILE TO DISK (CD+RAW QUARTER SCREEN DATA)
  '
  CLR scr$
  GET 0,0,159,99,sml$
  PRINT "SAVING ";file_name$
  adr%=MALLOC(8192)
  store_header(1,160,100,4,adr%)
  store_cd(0,adr%)
  BMOVE V:sml$+6,adr%+cdf_len&,pic_file_len&(0)-cdf-len&
  CLR sml$
  BSAVE file_name$,adr%,pic_file_len&(0)
  ~MFREE(adr%)
  SGET scr$
  '
  '
RETURN
'
'
> PROCEDURE write_pic(file_format|,file_name$,alerts!,VAR num_cols|)
  '
  ' CALLS A DIFFERENT SAVE ROUTINE DEPENDING ON file_format|.
  '
  IF file_format|=0
    write_sml(file_name$)
    '
  ELSE IF file_format|=1
    write_ful(file_name$)
    '
  ELSE
    '
    IF alerts!
      how_many_cols(num_cols|)
      '
    ENDIF
    '
    write_art(file_name$,(file_format|=2),num_cols|)
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE write_ful(file_name$)
  '
  ' WRITES IMAGE TO DISK IN .FUL FORMAT (CD+BIT MAP DATA)
  '
  CLR scr$
  adr%=MALLOC(32256)
  store_header(2,320,200,4,adr%)          ! File Type is 2
  store_cd(0,adr%)
  BMOVE screen_adr%,adr%+cdf_len&,pic_file_len&(1)-cdf_len&
  PRINT "SAVING ";file_name$
  BSAVE file_name$,adr%,pic_file_len&(1)
  ~MFREE(adr%)
  SGET scr$
  '
  '
RETURN
'
'
> PROCEDURE write_cdf(par|,file_name$)
  '
  ' WRITES A CDF FROM par_..(par|,*) TO DISK
  '
  LOCAL adr%,n|
  '
  adr%=MALLOC(256)
  store_header(0,0,0,0,adr%)          ! File Type is 0
  store_cd(par|,adr%)
  BSAVE file_name$,adr%,cdf_len&
  '
  ~MFREE(adr%)
  '
  '
RETURN
'
'
> PROCEDURE auto_write_pic(file_name$)
  '
  ' DECIDES WHETHER CURRENT IMAGE IS SMALL OR FULL SIZE AND SAVES IT ACCORDINGLY
  ' HENCE THE FILE NAME IS PASSED WITHOUT THE EXTENSION
  '
  IF @ful_size(0)                       ! CHECKS par_*(0,*) FOR METHOD (SIZE).
    write_ful(file_name$+".FUL")
    '
  ELSE
    write_sml(file_name$+".SML")
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE write_art(file_name$,degas!,num_cols|)
  '
  ' WRITES A PICTURE TO DISK IN DEGAS OR NEOCHROME FORMATS
  ' USER CAN CHANGE NUMBER OF COLOURS
  '
  LOCAL adr%,n|,a&,b&,paste|,liver|,temp_scr_adr%,pal_adr%,len&
  '
  IF num_cols|=4
    liver|=3            ! USED TO REDUCE THE NUMBER OF COLOURS NOT THE NUMBER
    paste|=2            ! OF CATTLE. I'D COME UP WITH SOME BETTER NAMES IF I HAD
  ELSE                  ! THE TIME.
    liver|=9
    paste|=8
  ENDIF
  '
  IF num_cols|<16
    '
    FOR a&=0 TO 319
      '
      FOR b&=0 TO 199
        '
        col|=POINT(a&,b&)
        '
        IF col|>liver|
          PSET a&,b&,col_index|(col| MOD paste|+2)
        ENDIF
        '
      NEXT b&
      '
    NEXT a&
    '
  ENDIF
  '
  adr%=MALLOC(32256)
  DPOKE adr%,0
  '
  IF degas!
    '
    temp_scr_adr%=adr%+34
    pal_adr%=adr%+2
    len&=pic_file_len&(1)
    '
  ELSE
    '
    DPOKE adr%+2,0
    temp_scr_adr%=adr%+128
    pal_adr%=adr%+4
    len&=pic_file_len&(2)
    '
  ENDIF
  '
  store_pal(0,pal_adr%)                   ! SEQUENTIALLY STORES RGB IN MEMORY
  BMOVE screen_adr%,temp_scr_adr%,32000
  BSAVE file_name$,adr%,len&
  ~MFREE(adr%)
  '
  '
RETURN
'
' ==============================================================================
'                               FILE PROCESSING
' ==============================================================================
'
> PROCEDURE get_next(ext$,VAR temp_name$)
  '
  ' GETS NEXT UNUSED (ON DISK) FILE NAME FROM THE ORDERED LIST:
  ' "FRAC_000."+ext$, ..., "FRAC_999."+ext$
  '
  LOCAL n&
  '
  n&=0
  '
  REPEAT
    '
    build_name(ext$,n&,temp_name$)
    INC n&
    unused!=NOT EXIST(root$+temp_name$)
    '
  UNTIL unused! OR n&=1000
  '
  IF NOT unused!
    '
    ALERT 3,"You're not supposed to|have this many files.",1,"FANATIC!",choice|
    temp_name$="MAP"+STR$(RND*100)+"."+ext$
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE build_name(ext$,n&,VAR temp_name$)
  '
  ' BUILDS FILE_NAME$ GIVEN NUMBER n| AND EXTENSION
  '
  LOCAL num$
  '
  IF n&<10
    '
    num$="00"+STR$(n&)
    '
  ELSE IF n&<100
    '
    num$="0"+STR$(n&)
  ELSE
    '
    num$=STR$(n&)
    '
  ENDIF
  '
  temp_name$=def_file_name$+num$+"."+ext$
  '
  '
RETURN
'
'
> PROCEDURE be_rid_of_ext(VAR path$,path_fine!)
  '
  ' REMOVES EXTENSION FROM THE VARIABLE path$
  '
  LOCAL path_len|,n|
  '
  path_len|=LEN(path$)
  n|=path_len|+1
  '
  REPEAT
    DEC n|
  UNTIL n|=0 OR MID$(path$,n|,1)="\"
  '
  path_fine!=n|>0
  path$=LEFT$(path$,n|)
  '
RETURN
'
'
> PROCEDURE auto_ext(ext$,VAR file_name$)
  '
  ' REPLACES EXISTING EXTENTION ON A FILE NAME, OR ADDS ONE IF THERE IS'NT ANY
  '
  LOCAL ext_exist!,n|,string_len|
  '
  string_len|=LEN(file_name$)
  '
  IF ASC(MID$(file_name$,string_len|,1))=0      ! FOR SOME UNKNOWN REASON
    file_name$=LEFT$(file_name$,string_len|-1)  ! THERES OFTEN AN EXTRA USELESS
    DEC string_len|                             ! CHAR AT THE END OF A FILE
  ENDIF                                         ! NAME ?????
  '
  n|=string_len|+1
  ext_exist!=FALSE
  '
  REPEAT                        ! CHECK THAT THERE IS AN EXTENTION
    DEC n|
    ext_exist!=MID$(file_name$,n|,1)="."
    '
  UNTIL ext_exist! OR n|=string_len|-4
  '
  IF ext_exist!
    file_name$=LEFT$(file_name$,n|)+ext$
    '
  ELSE
    file_name$=file_name$+"."+ext$
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE store_header(filetype|,x_res&,y_res&,nplanes|,adr%)
  '
  ' STORES AN FE2 FORMAT FILE HEADER IN MEMORY
  '
  BYTE{adr%}=70
  BYTE{adr%+1}=69
  '
  BYTE{adr%+2}=2
  '
  BYTE{adr%+3}=filetype|
  '
  WORD{adr%+4}=x_res&
  WORD{adr%+6}=y_res&
  BYTE{adr%+8}=nplanes|
  BYTE{adr%+9}=0
  '
RETURN
'
'
> PROCEDURE restore_header(adr%,VAR filetype|,x_res&,y_res&,nplanes|)
  '
  ' restores file header information
  '
  LOCAL error!
  error!=FALSE
  '
  IF BYTE{adr%}p`pa70 OR BYTE{adr%+1}p`pa69
    ' invalid file
    error!=TRUE
  ENDIF
  ' version no
  BYTE{adr%+2}=2
  IF error!=TRUE
    filetype|=255
  ELSE
    filetype|=BYTE{adr%+3}
  ENDIF
  x_res&=WORD{adr%+4}
  y_res&=WORD{adr%+6}
  nplanes|=BYTE{adr%+8}
  ' one spare byte so adr%=10
  '
RETURN
'
'
> PROCEDURE store_cd(par|,adr%)
  '
  ' STORES COORDINATE DATA TO MEMORY FROM PAR_... ARRAYS.
  '
  LOCAL n|,bite|
  '
  FOR n|=0 TO 5
    FLOAT{adr%+10+8*n|}=par_real(par|,n|)
  NEXT n|
  '
  LONG{adr%+58}=par_long%(par|)
  '
  FOR n|=0 TO 3
    WORD{adr%+62+2*n|}=par_word&(par|,n|)
  NEXT n|
  '
  FOR n|=0 TO 9
    BYTE{adr%+70+n|}=par_byte|(par|,n|)
  NEXT n|
  '
  IF par_mset!(par|)
    bite|=1
  ELSE
    bite|=0
  ENDIF
  '
  BYTE{adr%+80}=bite|
  '
  ' extra parameters for future expansion
  '
  ' view_vec(6), fd(8), ia(8), eye_dist(2), eye_vec(6), light_vec(6)
  ' + 1 bonus free on, that's 37 bytes extra
  '
  FOR n|=0 TO 36
    BYTE{adr%+90+n|}=0
  NEXT n|
  '
  ' adr% now 118
RETURN
'
'
> PROCEDURE restore_cd(par|,adr%)
  '
  ' RESTORES COORDINATE DATA TO PAR_... ARRAYS FROM MEMORY.
  '
  LOCAL n|,bite|
  '
  FOR n|=0 TO 5
    par_real(par|,n|)=FLOAT{adr%+10+8*n|}
  NEXT n|
  '
  par_long%(par|)=LONG{adr%+58}
  '
  FOR n|=0 TO 3
    par_word&(par|,n|)=WORD{adr%+62+2*n|}
  NEXT n|
  '
  FOR n|=0 TO 9
    par_byte|(par|,n|)=BYTE{adr%+70+n|}
  NEXT n|
  '
  par_mset!(par|)=BYTE{adr%+80}=1
  '
RETURN
'
'
> PROCEDURE restore_fe1_cd(par|,adr%,file_name$)
  '
  ' RESTORES COORDINATE DATA TO ARRAY FROM AN FE1 MEMORY BLOCK.
  '
  LOCAL n|,fe1_const,short$,type&
  '
  ' RESTORES A CD IN FRACTAL ENGINE V1.0 FORMAT
  '
  fe1_const=50*(1-(1/1.078125))  ! YX SCREEN RATIO IN AN FE1 CD IS 1.07825
  '
  FOR n|=0 TO 4
    par_real(par|,n|)=FLOAT{adr%+8*n|}  ! AS IN FE2: x_min,...,im_c
  NEXT n|
  '
  ' MAKE ADJUSTMENT TO y_min DUE TO YX RATIO OF FE1 CD'S
  par_real(par|,1)=par_real(par|,1)+fe1_const*par_real(par|,2)
  '
  ' MAKE ADJUSTMENT TO x_step
  par_real(par|,2)=par_real(par|,2)/2
  '
  ' COMPUTE TYPE FROM FILE NAME
  short$=RIGHT$(file_name$,12)          ! LESS THE PATH
  type&=-1
  '
  REPEAT
    INC type&
  UNTIL LEFT$(short$,4)=def_name$(type&) OR type&=max_complex|
  '
  IF LEFT$(short$,4)="CUBE"             ! THE NAME OF THIS TYPE HAS BEEN CHANGED
    type&=5                             ! TO CUB2
  ENDIF
  '
  par_byte|(par|,0)=type&               ! type
  '
  ' M OR J ?
  par_mset!(par|)=MID$(short$,6,1)="M"
  '
  par_byte|(par|,3)=1                   ! method = LEM
  par_word&(par|,1)=WORD{adr%+40}       ! bound
  par_word&(par|,0)=WORD{adr%+42}       ! iters
  par_byte|(par|,5)=WORD{adr%+46}       ! spread
  '                                     ! period (AS USED IN FE1 IS IGNORED)
  FOR n|=0 TO 1                         ! pal AND mode
    par_byte|(par|,n|+1)=BYTE{adr%+48+n|}
  NEXT n|
  '
  auto_precision(par|,TRUE)
  '
RETURN
'
'
> PROCEDURE store_pal(par|,pal_adr%)
  '
  ' STORES THE RGB VALUES OF THE PALETTE (par|) IN MEMORY ; AT ADDRESS
  ' pal_adr%. TAKES UP 32 BYTES.
  '
  LOCAL r_source|,g_source|,b_source|,red|,blue|,green|,pal|,mode|,invert!
  '
  pal|=par_byte|(par|,1)
  mode|=par_byte|(par|,2)
  r_source|=mode| MOD 3
  g_source|=(mode| MOD 2+r_source|+1) MOD 3
  b_source|=3-r_source|-g_source|
  invert!=mode|>5
  '
  FOR i|=0 TO 15
    '
    red|=pal_data|(pal|,i|,r_source|)
    blue|=pal_data|(pal|,i|,b_source|)
    green|=pal_data|(pal|,i|,g_source|)
    '
    IF invert! AND i|>1
      '
      red|=15-red|
      green|=15-green|
      blue|=15-blue|
      '
    ENDIF
    '
    DPOKE pal_adr%+2*col_index|(i|),red|*128+green|*8+(blue| DIV 2)
    '
  NEXT i|
  '
  '
RETURN
'
' ==============================================================================
'                               PALETTE PROCEDURES
' ==============================================================================
'
> PROCEDURE swirl(out!)
  '
  ' SWIRLS COLOURS 2 TO 15 EITHER IN OR OUT UNTIL A MOUSE BUTTON IS PRESSED
  '
  LOCAL offset|,mk|
  '
  HIDEM
  SPUT scr$
  '
  mk|=0
  PAUSE 15
  '
  IF out!
    '
    WHILE mk|=0
      '
      FOR offset|=1 TO 14
        '
        setcols(pal|,mode|,0,0,0,offset|)
        ADD mk|,MOUSEK
        PAUSE 5
        '
      NEXT offset|
      '
    WEND
    '
  ELSE
    '
    WHILE mk|=0
      '
      FOR offset|=1 TO 14
        '
        setcols(pal|,mode|,0,0,0,15-offset|)
        ADD mk|,MOUSEK
        PAUSE 5
        '
      NEXT offset|
      '
    WEND
    '
    select_pal                          ! SETS PALETTE BACK TO NORMAL
    '
  ENDIF
  '
  draw_pal_win(x_win&,y_win&)
  SHOWM
  '
  '
RETURN
'
'
> PROCEDURE draw_pal_win(x_win&,y_win&)
  '
  ' DRAWS COLUR STRIP, AND MAKES CALLS TO DRAW THE PAL MENU AND THE PAL TEXT.
  '
  LOCAL c|
  '
  COLOR 1
  BOX x_win&,y_win&,x_win&+133,y_win&+98
  DEFFILL 0
  PBOX x_win&+1,y_win&+1,x_win&+132,y_win&+97
  '
  c|=0
  '
  FOR x&=3 TO 124 STEP 8                        ! DRAW COLOUR STRIP
    '
    DEFFILL c|,1
    PBOX x&+x_win&,y_win&+4,x&+x_win&+6,y_win&+11
    INC c|
    '
  NEXT x&
  '
  ' DRAW MENU
  '
  FOR i|=0 TO 7
    '
    temp_loc&(i|,0)=pal_but_loc&(i|,0)+x_win&
    temp_loc&(i|,1)=pal_but_loc&(i|,1)+y_win&
    '
  NEXT i|
  '
  draw_buttons(7,temp_loc&(),pal_but_name$())
  '
RETURN
'
'
> PROCEDURE edit_palette(VAR col|)
  '
  ' ALLOWS USER TO EDIT THE PALETTE.
  '
  LOCAL exit!,clicked|,mode|,mx&,my&,mk|,rgb_step&
  '
  mode|=0
  exit!=FALSE
  DEFFILL 0
  PBOX x_win&+1,y_win&+12,x_win&+132,y_win&+25
  draw_buttons(7,temp_loc&(),edit_but_name$())
  '
  REPEAT
    '
    edit_pal_text
    check_buttons(7,temp_loc&(),clicked|)
    '
    IF clicked|>7                               ! RIGHT MOUSE BUTTON PRESSED
      '
      clicked|=clicked|-8
      rgb_step&=1
      '
    ELSE
      '
      rgb_step&=2
      '
    ENDIF
    '
    SELECT clicked|
    CASE 0
      setcols(pal|,mode|,col|,0,-rgb_step&,0)
    CASE 1
      setcols(pal|,mode|,col|,0,rgb_step&,0)
    CASE 2
      setcols(pal|,mode|,col|,1,-rgb_step&,0)
    CASE 3
      setcols(pal|,mode|,col|,1,rgb_step&,0)
    CASE 4
      setcols(pal|,mode|,col|,2,-rgb_step&,0)
    CASE 5
      setcols(pal|,mode|,col|,2,rgb_step&,0)
    CASE 6
      '
      COLOR 0
      LINE x_win&+1,y_win&+2,x_win&+132,y_win&+2
      LINE x_win&+1,y_win&+13,x_win&+132,y_win&+13
      PAUSE 10
      '
      REPEAT
        MOUSE mx&,my&,mk&
      UNTIL mk&=1
      '
      col|=POINT(mx&,my&)
      '
    CASE 7
      '
      exit!=TRUE
      '
    ENDSELECT
    '
  UNTIL exit!=TRUE
  '
  '
RETURN
'
'
> PROCEDURE palette_text
  '
  ' DRAWS THE TEXT IN THE PALETTE WINDOW.
  '
  LOCAL i|,j|
  '
  DEFFILL 0
  PBOX x_win&+1,y_win&+12,x_win&+132,y_win&+25
  DEFTEXT 1,1,0,4
  TEXT x_win&+5,y_win&+22,54,"Pal  = "+STR$(par_byte|(0,1))
  TEXT x_win&+68,y_win&+22,54,"Mode = "+STR$(par_byte|(0,2))
  '
  '
RETURN
'
'
> PROCEDURE edit_pal_text
  '
  ' SHOWS CURRENT COLOUR, ITS RGB VALUE AND MARKER.
  '
  LOCAL i|,x_mark&
  '
  DEFFILL col|,1
  PBOX x_win&+3,y_win&+15,x_win&+17,y_win&+22
  DEFTEXT 1,1,0,4
  TEXT x_win&+25,y_win&+22,"="
  '
  ' RGB VALUE
  FOR i|=0 TO 2
    TEXT x_win&+41+i|*8,y_win&+22,HEX$(pal_data|(pal|,col|,i|))
  NEXT i|
  '
  x_mark&=x_win&+col|*8+3
  '
  ' DRAW MARKER TO SHOW WHICH COLOUR IS CURRENTLY SELECTED
  COLOR 1
  LINE x_mark&,y_win&+2,6+x_mark&,y_win&+2
  LINE x_mark&,y_win&+13,6+x_mark&,y_win&+13
  '
  '
RETURN
'
'
> PROCEDURE pal_mode_plus(pal_inc&,mode_inc&)
  '
  ' CHANGES PAL AND MODE VARS BY AMOUNT SPECIFIED WITH MODULO (WRAP AROUND)
  ' AND THEN SETS THE PHYSICAL PALETTE.
  '
  mode|=(mode|+mode_inc&+12) MOD 12
  pal|=(pal|+pal_inc&+max_pal|+1) MOD (max_pal|+1)
  setcols(pal|,mode|,0,0,0,0)
  '
RETURN
'
'
> PROCEDURE select_pal
  '
  ' SETS THE CURRENT PHYSICAL PALETTE GIVEN THE PICTURE CD (PAL/MODE)
  '
  setcols(par_byte|(0,1),par_byte|(0,2),0,0,0,0)
  '
RETURN
'
'
> PROCEDURE setcols(pal|,mode|,col|,prime|,inc_dec&,offset|)
  '
  ' SETS THE RGB VALUES OF THE PHYSICAL PALETTE FROM pal_data().
  ' ALSO USED WHEN SWIRLING PALETTE OR WHEN CHANGING AN INDIVIDUAL COLOUR.
  '
  LOCAL r_source|,g_soure|,b_source|,i|,dum&
  '
  r_source|=mode| MOD 3
  g_source|=(mode| MOD 2+r_source|+1) MOD 3
  b_source|=3-r_source|-g_source|
  dum&=pal_data|(pal|,col|,prime|)+inc_dec&
  '
  IF dum&=>0 AND dum&<16
    '
    pal_data|(pal|,col|,prime|)=dum&
    '
  ENDIF
  '
  invert!=mode|>5
  '
  FOR i|=0 TO 1
    '
    red|=pal_data|(pal|,i|,r_source|)
    blue|=pal_data|(pal|,i|,b_source|)
    green|=pal_data|(pal|,i|,g_source|)
    VSETCOLOR i|,red|,green|,blue|
    '
  NEXT i|
  '
  k|=2
  '
  FOR i|=0 TO 13
    '
    j|=(i|+offset|) MOD 14+2
    red|=pal_data|(pal|,j|,r_source|)
    blue|=pal_data|(pal|,j|,b_source|)
    green|=pal_data|(pal|,j|,g_source|)
    '
    IF invert!
      '
      VSETCOLOR k|,15-red|,15-green|,15-blue|
      '
    ELSE
      '
      VSETCOLOR k|,red|,green|,blue|
      '
    ENDIF
    '
    INC k|
    '
  NEXT i|
  '
  '
RETURN
'
' ==============================================================================
'                          BUTTON/LOGO PROCEDURES
' ==============================================================================
'
> PROCEDURE draw_logo
  '
  ' GUESS !!!
  '
  BOX 0,0,319,37
  DEFTEXT 2,0,0,4
  TEXT 3,12,"     FRACTAL ENGINE V2.2 PROGRAMMED BY DAN GRACE    "
  TEXT 3,20,"USING GFA BASIC V3.0, COMPILER V3.5 AND DEVPAC V2.0."
  TEXT 3,28,"      CO-DESIGNED AND DEVELOPED BY MIKE HARRIS.     "
  '
RETURN
'
'
> PROCEDURE custom_alert(message$,alert_button$,VAR choice|) !kill message stuff
  '
  ' PERFORMS A SIMILAR FUNCTION TO GFA ALERT COMMAND
  ' MESSAGE$ SHOULD BE IN BLOCKS OF 20 CHARACTERS TO JUSTIFY TEXT
  ' ALERT_BUTTON$ SHOULD CONTAIN "|" TO SEPARATE BUTTON NAMES - MAX 4 BUTTONS
  '
  LOCAL i|,string_ptr%,char_ptr%,end_ptr%,num_buts|,dum|,char|,line_count|
  LOCAL num_lines|,length|
  DIM alert_but_name$(3)                ! Maximum of 4 buttons - easy to change
  '
  FOR i|=0 TO 3
    alert_but_name$(i|)=""
  NEXT i|
  '
  string_ptr%=V:alert_button$
  end_ptr%=string_ptr%+LEN(alert_button$)-1
  num_buts|=0
  '
  FOR char_ptr%=string_ptr% TO end_ptr%
    '
    char$=CHR$(PEEK(char_ptr%))
    '
    IF char$="|"
      INC num_buts|
    ELSE
      alert_but_name$(num_buts|)=alert_but_name$(num_buts|)+char$
    ENDIF
    '
  NEXT char_ptr%
  '
  erase_buttons
  draw_buttons(num_buts|,but_loc&(),alert_but_name$())
  DEFTEXT 1,0,0,4
  length|=LEN(message$)
  message$=message$+SPACE$(20-length| MOD 20)
  char|=1
  num_lines|=length| DIV 20
  dum|=((num_buts|+3) DIV 2)*18+51   ! Buttons 18 pixels apart, 1st at text y=51
  '
  FOR line_count|=0 TO num_lines|
    '
    TEXT 0,dum|,123,MID$(message$,char|,20)
    ADD char|,20
    ADD dum|,9
    '
  NEXT line_count|
  '
  check_buttons(num_buts|,but_loc&(),choice|)
  ERASE alert_but_name$()
  '
  '
RETURN
'
'
> PROCEDURE draw_buttons(num_buts|,VAR but_loc&(),button_labels$())
  '
  ' GUESS !!!
  '
  LOCAL loop|,x1&,y1&,x2&,y2&
  '
  DEFFILL 0
  DEFTEXT 2,0,0,4
  COLOR 3
  '
  FOR loop|=0 TO num_buts|
    '
    x1&=but_loc&(loop|,0)
    y1&=but_loc&(loop|,1)
    x2&=x1&+57
    y2&=y1&+10
    PBOX x1&,y1&,x2&,y2&
    BOX x1&,y1&,x2&,y2&
    LINE x2&+1,y1&+1,x2&+1,y2&
    LINE x1&+1,y2&+1,x2&+1,y2&+1
    TEXT x1&+4,y2&-3,50,button_labels$(loop|)
    '
  NEXT loop|
  '
RETURN
'
'
> PROCEDURE check_buttons(num_buts|,VAR but_loc&(),clicked|)
  '
  ' WAITS UNTIL A MENU BUTTON HAS BEEN CLICKED ON
  '
  LOCAL loop|,x1&,y1&,x2&,y2&,mx&,my&,mk|
  loop|=0
  clicked|=255
  wait_no_mouse
  '
  REPEAT
    '
    REPEAT
      MOUSE mx&,my&,mk|
      '
      IF ASC(INKEY$)=6                          ! IF CONTROL F IS PRESSED:
        PRINT AT(1,1);"FREE MEM = ";FRE(0)      ! FOR TEST PURPOSES ONLY
      ENDIF
      '
    UNTIL mk|>0
    '
    FOR loop|=0 TO num_buts|
      '
      x1&=but_loc&(loop|,0)
      y1&=but_loc&(loop|,1)
      x2&=x1&+57
      y2&=y1&+12
      '
      IF mx&>=x1& AND mx&<=x2& AND my&>=y1& AND my&<=y2&
        clicked|=loop|
        flash_button(clicked|)
      ENDIF
      '
    NEXT loop|
    '
  UNTIL NOT clicked|=255
  '
  IF mk|=2
    ADD clicked|,num_buts|+1
  ENDIF
  '
  REPEAT
  UNTIL MOUSEK=0
  '
RETURN
'
'
> PROCEDURE flash_button(button_number|)
  '
  ' GUESS WHAT THIS DOES !  YES - WHEN CLICKED
  '
  LOCAL x1&,y1&,x2&,y2&
  '
  DEFFILL 3
  GRAPHMODE 3
  x1&=but_loc&(button_number|,0)
  y1&=but_loc&(button_number|,1)
  x2&=x1&+57
  y2&=y1&+10
  PBOX x1&,y1&,x2&,y2&
  PAUSE 5
  PBOX x1&,y1&,x2&,y2&
  GRAPHMODE 0
  '
RETURN
'
'
> PROCEDURE erase_buttons
  '
  ' BLANKS THE BUTTONS -Waaaaoooooowwwww !!!
  '
  DEFFILL 0
  PBOX 0,43,124,199
  '
RETURN
'
' ==============================================================================
'                               BATCH PROCEDURES
' ==============================================================================
'
> PROCEDURE batch_info(num_frames!,name!)
  '
  ' DISPLAYS BATCH INFO - CALLED PRIOR TO COMPLETION OF ANY BATCH OPERATION
  '
  DEFFILL 0
  PBOX 126,72,318,198
  PRINT AT(17,11);"BATCH INFO"
  PRINT AT(17,12);"----------"
  '
  PRINT AT(17,14);"DISK OUTPUT ? ";
  '
  IF disk_output!
    PRINT "Y";
  ELSE
    PRINT "N";
  ENDIF
  '
  IF num_frames!
    PRINT AT(17,15);"# OF FRAMES = ";num_frames&
  ENDIF
  '
  IF name!
    PRINT AT(17,16);"BATCH NAME = ";batch_name$
  ENDIF
  '
RETURN
'
'
> PROCEDURE convert
  '
  ' CONVERTS A BATCH OF CDF'S INTO PICTURES
  ' USER SELECTS A FILE IN A FOLDER ; CDF'S IN THAT FOLDER ARE THEN CONVERTED
  '
  LOCAL path_ok&,path$,file_info%,cdf_name$,pic_name$,disk_output!,sure!,d_free!
  LOCAL dum|
  '
  batch_info(FALSE,FALSE)
  enter_yes_no(31,14,"Y",disk_output!)
  path$=current_path$                   ! current_path$ IS GLOBAL
  select_path(TRUE,path_ok&,path$)      ! SELECT INPUT (=>TRUE) PATH WHERE CDF'S
  '                                     ! ARE STORED.
  draw_logo
  show_params
  batch_info(FALSE,FALSE)
  '
  IF path_ok&=1
    '
    batch_sure(sure!)
    '
    IF sure!
      ' SEARCH AND CONVERT CDF'S TO IMAGE FILES OR PRINT IMAGES ***************
      ~FSETDTA(BASEPAGE+128)
      file_info%=FSFIRST(path$+"*.CDF",0)
      d_free!=TRUE
      '
      DO UNTIL file_info% OR NOT d_free!
        '
        cdf_name$=CHAR{BASEPAGE+158}
        read_cdf(1,path$+cdf_name$)
        '
        IF disk_output!
          disk_free(pic_file_len&(-@ful_size(1)),d_free!)       ! CHECK DFREE
          '
          IF d_free!
            batch_single(path$+LEFT$(cdf_name$,LEN(cdf_name$)-4))
          ENDIF
          '
        ELSE
          batch_single("")
          '
        ENDIF
        '
        file_info%=FSNEXT()
        '
      LOOP              ! CONVERSION COMPLETE OR TERMINATED
      '
      IF NOT d_free!
        ALERT 3,"Not enough room on disk.",1," OK ",dum|
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE poster
  '
  ' TURNS CURRENT IMAGE INTO N*N IMAGES. CALLED POSTER SINCE STICKING SEVERAL
  ' PRINTED, ADJACENT, WINDOWS OF THE COMPLEX PLANE NEXT TO EACH OTHER RESULTS
  ' IN A BIGGER IMAGE WHICH I RECKON IS GRAND ENOUGH TO WARRANT THE NAME POSTER.
  '
  LOCAL path_ok&,path$,disk_output!,batch_name$,d_free!,post_ok!
  LOCAL ext$,file_format|,num_cols|
  LOCAL x_min,y_min,x_step,x_scr_step,y_scr_step
  '
  ' CHECK PARAMETERS ARE LEGITAMATE *******************************************
  IF par_byte|(1,0)<max_complex|        ! POSTER ONLY FOR COMPLEX TYPES
    '
    IF par_byte|(1,3)<2                 ! POSTER ONLY FOR NORMAL & LEM
      post_ok!=TRUE
      '
    ELSE
      post_ok!=FALSE
      '
    ENDIF
    '
  ELSE
    post_ok!=FALSE
    '
  ENDIF                                 ! CHECKS ON CD FOR POSTER OVER
  '
  '
  IF post_ok!
    ' USER SUPPLIES POSTER PARAMETERS *****************************************
    '
    batch_info(FALSE,FALSE)
    enter_yes_no(31,14,"Y",disk_output!)
    '
    IF disk_output!
      '
      ' USER SUPPLIES INFO ON OUTPUT FILES *************************************
      path$=current_path$                 ! current_path$ IS GLOBAL
      select_path(FALSE,path_ok&,path$)   ! SELECT OUTPUT PATH WHERE PICS
      '
      ALERT 2,"Which file format ?",1,".FUL|.PI1|.NEO",file_format|
      '
      SELECT file_format|
      CASE 1
        ext$="FUL"
      CASE 2
        ext$="PI1"
      CASE 3
        ext$="NEO"
      ENDSELECT
      '                                   ! ARE TO BE STORED.
      IF file_format|>1
        how_many_cols(num_cols|)
        '
      ENDIF
      '
    ELSE
      path_ok&=1                        ! NO PATH IF OUTPUTTING TO PRINTER
      '
    ENDIF
    '
    IF path_ok&=1
      '
      draw_logo                             ! RESTORE THE SCREEN
      show_params
      batch_info(FALSE,TRUE)
      '
      ALERT 1,"What size poster do you|want to draw (in screens) ?",1,"2x2|3x3|4x4",post_size|
      '
      INC post_size|
      num_frames&=post_size|^2
      '
      IF disk_output!
        disk_free(pic_file_len&(1)*num_frames&,d_free!)     ! CHECK DFREE
        enter_string(30,16,"",5,"",batch_name$)
        path$=path$+batch_name$
        '
      ELSE
        d_free!=TRUE
        '
      ENDIF
      '
      IF d_free!
        '
        batch_info(TRUE,TRUE)
        batch_sure(post_ok!)                    ! USE post_ok! AGAIN
        '
        IF post_ok!
          ' INITIALISE COORDINATES ************************************************
          '
          x_min=par_real(1,0)               ! INITIAL x_min
          y_min=par_real(1,1)               ! INITIAL y_min
          x_step=par_real(1,2)/post_size|   ! x_step ON ENTIRE POSTER
          par_real(1,2)=x_step
          x_scr_step=320*x_step             ! HORIZONTAL SEPARATION OF POSTER SCR'S
          y_scr_step=200*x_step             ! VERTICAL  " " " ".
          auto_precision(1,TRUE)            ! "SAFE" ARITHMETIC USED
          screen_num|=1
          '
          ' DRAW SCREENS TO MAKE UP THE POSTER *********************************
          '
          FOR post_x|=1 TO post_size|
            y_min=par_real(1,1)
            par_real(1,0)=x_min
            '
            FOR post_y|=1 TO post_size|
              '
              par_real(1,1)=y_min
              draw_from_cd(FALSE)
              '
              IF disk_output!
                file_name$=path$+STR$(screen_num|)+"."+ext$
                write_pic(file_format|,file_name$,FALSE,num_cols|)
                '
              ELSE
                '
              ENDIF
              '
              ADD y_min,y_scr_step
              INC screen_num|
              '
            NEXT post_y|
            '
            ADD x_min,x_scr_step
            '
          NEXT post_x|
          '
        ENDIF     ! IF post_ok! (USER "SURE?" ONE)
        '
      ELSE        ! IF NOT d_free! (EG NOT ENOUGH ROOM ON DISK)
        ALERT 3,"Not enough room on disk.",1," OK ",post_size| ! USED AS DUMMY VAR
        '
      ENDIF
      '
    ENDIF
    '
  ELSE          ! IF post_ok! (EG POSTER NOT OK)
    ALERT 3,"Bad CD read FE2 document|and register, please.",1," OK ",yn|
    '
  ENDIF
  '
  '
RETURN
'
'
' ***************************   ANIM PROCEDURES  *******************************
'
> PROCEDURE last_frame(zoom_but!)
  '
  ' WORKS ON THE GLOBAL VARIABLES ani_* : ONCE END CD CHOOSEN BY USER
  ' INPUTS NUMBER OF ITERS AND FOLDER NAME
  '
  LOCAL yn|
  '
  IF par_byte|(1,0)<max_complex|
    '
    ALERT 2,"These co-ordinates for end|frame ?",1,"YES|NO",yn|
    '
    IF yn|=1
      '
      ani_end_frame!=TRUE
      ani_zoom!=zoom_but!     ! INDICATES THAT ZOOMANIM BUTTON WAS CLICKED
      copy_params(1,3)        ! STORE AWAY FOR LATER CALCULATIONS
      '
      ALERT 1,"Now load/enter CD|for start frame.Then|reselect this option !",1,"OK",yn|
      '
    ENDIF
    '
  ELSE
    ALERT 1,"No animation for this|type.",1,"OOPS",yn|
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE calc_anim(zoom!)
  '
  ' CALCULATES AN ANIMATION SEQUENCE - QUITE COMPLICATED
  '
  LOCAL ani_ful!,ani_ok!,batch_name$
  LOCAL type|,method|,re_c,im_c
  LOCAL path$,path_ok&,disk_space%,last_adr%,frame_len&,file_frames&
  LOCAL mem_frames&
  '
  ' CHECKS ANIM USING check_anim. INPUTS NUMBER OF FRAMES AND OUTPUT FOLDER
  ' AND FINALLY CALLS #, IF ALL OK, zoom_anim OR jul_anim TO ACTUALLY DO THE
  ' CALCULATIONS.
  ' THIS PROCEDURE IS COMPLICATED, BUT THEN IT DOES DO SOME GOOD SHIT
  '
  check_anim
  '
  IF ani_ok!            ! PASSES THE CHECKS - LOOKING GOOD
    '
    ALERT 2,"These co-ordinates for|start frame ?",1,"YES|NO",yn|
    '
    IF yn|=1
      '
      batch_info(TRUE,TRUE)
      enter_yes_no(31,14,"Y",disk_output!)
      '
    ENDIF
    '
  ELSE
    ALERT 3,"Bad CD read FE2 document|and register, please.",1," OK ",yn|
    ani_ok!=FALSE
    '
  ENDIF
  '
  IF ani_ok!
    '
    IF disk_output!
      '
      path$=current_path$               ! current_path$ IS GLOBAL
      select_path(FALSE,path_ok&,path$) ! SELECT OUTPUT (=>FALSE) PATH WHERE
      draw_logo                         ! RESTORE THE DISPLAY
      show_params
      batch_info(TRUE,TRUE)
      '                                 ! IMAGES ARE TO BE SAVED TO.
      '
      IF path_ok&=1                     ! INPUT #FRAMES, ANIM NAME
        '
        disk_space%=DFREE(0)
        last_adr%=XBIOS(2)+32768        ! 32K ABOVE THE SCREEN ADDRESS
        ani_ful!=@ful_size(1)
        '
        ' ABS(TRUE)=1, ABS(FALSE)=0
        frame_len&=pic_file_len&(ABS(ani_ful!))
        '
        ' CALCULATE MAX NUMBER OF FRAMES THAT WILL FIT:
        ' (1) ON THE DISK
        ' (2) IN MEMORY (WHEN DISPANIM IS LOADED)
        ' THE SAFEST NUMBER (FROM USERS POINT OF VIEW IS THE MINIMUM OF THESE)
        '
        file_frames&=disk_space% DIV frame_len&
        ' 204288 BYTES ARE USED BY ROM ETC AND DISPANIM
        mem_frames&=(last_adr%-204288) DIV (frame_len&-cdf_len&)
        max_frames&=MIN(mem_frames&,file_frames&)
        '
        ' INPUT ANIMATION NAME ; DETERMINES NAMES OF FRAMES ON DISK
        enter_string(30,16,"",5,"",batch_name$)
        path$=path$+batch_name$
        num_frames&=max_frames&     ! DEFAULT
        enter_word(31,15,"",3,2,max_frames&+1,V:num_frames&)
        batch_sure(ani_ok!)
        '
      ELSE
        ALERT 3,"No path selected|you did not select|a file",1,"OK",yn|
        ani_ok!=FALSE
        '
      ENDIF
      '
    ELSE
      max_frames&=20
      '
    ENDIF
    '
  ENDIF
  '
  IF ani_ok!
    write_anim(path$+".ADF",V:batch_name$)    ! SAVE .ADF: ANIM DATA FILE
    '
    IF ani_zoom!
      zoom_anim
      '
    ELSE
      jul_anim
      '
    ENDIF
    '
    ani_end_frame!=FALSE
    '
  ELSE
    '
    ALERT 2,"Reset end frame ?",1,"Yes|No",yn|
    '
    IF yn|=1
      ani_end_frame!=FALSE
      '
    ENDIF
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE write_anim(file_name$,name_adr%)
  '
  ' WRITES .ANI FILE : WHICH CONTAINS THE ANIMATION NAME AND HENCE THE NAME
  ' OF THE FILES OF THE ANIMATION WHICH IS ALSO THE NAME OF THIS FILE.
  ' ALSO THE NUMBER OF FRAMES AND THE RGB VALUES OF THE 16 COLOUR PALETTE.
  '
  LOCAL adr%
  '
  adr%=MALLOC(256)
  '
  IF @ful_size(1)             ! FALSE=SMALL, TRUE=FULL
    store_header(4,320,200,4,adr%)
  ELSE
    store_header(3,160,100,4,adr%)
  ENDIF
  '
  BMOVE name_adr%,adr%+10,6             ! STORE ANIM NAME (5 BYTES)
  WORD{adr%+16}=num_frames&
  store_pal(1,adr%+18)                   ! STORE PALETTE AS RGB WORDS
  '                                      ! TAKES UP 32 BYTES
  BSAVE file_name$,adr%,50
  ~MFREE(adr%)
  '
  '
RETURN
'
'
> PROCEDURE check_anim
  '
  ' DOES LOTS OF CHECKS TO SEE IF START AND END FRAMES "TALLY" :
  ' FOR ZOOM'S THE CD'S MUST REPRESENT THE SAME FRACTAL AND SAME METHOD.
  ' FOR JUL ANIMS THE CD'S MUST REPRESENT THE SAME TYPE OF JULIA SETS.
  ' NUMBER OF ITERATIONS MAY BE DIFFERENT (FOR EITHER ANIMATION SEQUENCE).
  '
  ani_ok!=FALSE                 ! DEFAULT (THERES SO MANY CHECKS)!
  '
  IF ani_zoom!=zoom!
    '
    ani_ful!=@ful_size(1)       ! GET START FRAME CD
    ani_mset!=par_mset!(1)
    type|=par_byte|(1,0)
    method|=par_byte|(1,3)
    re_c=par_real(1,3)
    im_c=par_real(1,4)
    '
    ' CHECK METHOD, TYPES AND M/J AGREE
    IF par_byte|(3,0)=type| AND par_byte|(3,3)=method| AND ani_mset!=par_mset!(3)
      '
      IF ani_zoom!              ! ZOOMANIM WAS CHOOSEN
        '
        IF NOT par_real(3,2)=par_real(1,2)      ! MUST HAVE DIFFERENT x_step
          '
          IF ani_mset!
            ani_ok!=TRUE
          ELSE IF re_c=par_real(3,3) AND im_c=par_real(3,4)
            ani_ok!=TRUE          ! SAME JULIA SET? USER DOES NOT WANT TO ZOOM
          ELSE                    ! FROM ONE JULIA TO ANOTHER THATS SILLY
            ani_ok!=FALSE
          ENDIF
          '
        ELSE
          ani_ok!=FALSE
        ENDIF
        '
      ELSE                      ! JUL ANIM WAS CHOOSEN
        ani_ok!=TRUE
        '
      ENDIF
      '
    ELSE
      ani_ok!=FALSE
      '
    ENDIF
    '
  ELSE
    ani_ok!=FALSE
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE zoom_anim
  '
  ' COMPUTES THE FRAMES FOR A ZOOM ANIMATION SEQUENCE OF A COMPLEX TYPE
  ' FRACTAL USING ANY METHOD NORMAL, SPHERE ETC.
  ' THESE FRAMES ARE OUTPUTED TO DISK OR TO A PRINTER
  '
  LOCAL xmin1,xstep1,ymin1
  LOCAL zoom_ratio,dx_ratio,dy_ratio,cx0,cy0,cx1,cy1,iters0,iters1
  '
  init_iters
  '
  xmin1=par_real(3,0)
  ymin1=par_real(3,1)
  xstep1=par_real(3,2)
  '
  ' zoom_ratio IS THE RATIO, (FRAME N+1 XSTEP)/(FRAME N XSTEP)
  zoom_ratio=EXP(LOG(xstep1/par_real(1,2))/(num_frames&-1))
  '
  dum=(1-zoom_ratio)/(1-zoom_ratio^(num_frames&-1))
  ' THE FOLLOWING _ratio's ARE THE AMOUNTS TO ADD TO _min's
  dx_ratio=(xmin1-par_real(1,0))*dum
  dy_ratio=(ymin1-par_real(1,1))*dum
  '
  FOR n&=1 TO num_frames&
    '
    auto_precision(1,TRUE)      ! "SAFE" ARITHMETIC USED
    batch_single(path$+STR$(n&)+ani_ext$)
    ADD par_real(1,0),dx_ratio  ! CALC NEW x_min
    ADD par_real(1,1),dy_ratio  ! CALC NEW y_min
    MUL dx_ratio,zoom_ratio
    MUL dy_ratio,zoom_ratio
    MUL par_real(1,2),zoom_ratio
    ADD iters0,iter_step
    par_word&(1,0)=iters0       ! NEW MAX ITERS
    '
  NEXT n&
  '
RETURN
'
'
> PROCEDURE jul_anim
  '
  ' COMPUTES THE FRAMES FOR A JULIA ANIMATION SEQUENCE OF A COMPLEX TYPE
  ' FRACTAL USING ANY METHOD NORMAL, SPHERE ETC.
  ' THESE FRAMES ARE OUTPUTED TO DISK OR TO A PRINTER
  '
  LOCAL cx0,cy0,iters0,iters1,re_c_step,im_c_step
  '
  init_iters
  re_c_step=(par_real(3,3)-re_c)/(num_frames&-1)
  im_c_step=(par_real(3,4)-im_c)/(num_frames&-1)
  '
  FOR n&=1 TO num_frames&
    '
    batch_single(path$+STR$(n&)+ani_ext$)
    ADD par_real(1,3),re_c_step
    ADD par_real(1,4),im_c_step
    ADD iters0,iter_step
    par_word&(1,0)=iters0
    '
  NEXT n&
  '
  '
RETURN
'
'
> PROCEDURE init_iters
  '
  ' INITIALISES ITERS VARIABLES FOR USE IN ZOOMANIM AND JUL_ANIM
  '
  iters0=par_word&(3,0) ! THESE ARE REAL TO ALLOW FOR A SMOOTH TRANSITION
  iters1=par_word&(1,0) ! THEY REPRESENT WHAT IS max_it& IN THE DRAWING ROUTINES
  iter_step=(iters1-iters0)/(num_frames&-1)
  '
  '
RETURN
'
'
> PROCEDURE batch_single(pic_file_name$)
  '
  ' DRAWS AND THEN STORES FRAME ON DISK OR
  ' TO PRINTER USING HARDCOPY (I DO NOT KNOW IF THIS USES A PRINTER DRIVER
  ' I DO NOT KNOW IF HARDCOPY USES A PRINTER DRIVER INSTALLED VIA THE DESKTOP
  ' GFA MANUAL SAYS PRINTER DRIVER IS FOR EPSON 9 PIN COMPATIBLE SO IT PROBABLY
  ' IGNORES ANY OTHER MEMORY RESIDENT PRINTER DRIVERS).
  '
  draw_from_cd(FALSE)           ! NO ALERT BOXES
  '
  IF disk_output!
    auto_write_pic(pic_file_name$)
    '
  ELSE
    HARDCOPY          ! DUMP FRAME TO PRINTER INSTEAD OF TO DISK
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE batch_sure(VAR sure!)
  '
  ' ASKS USER A QUESTION - KEYBOARD INPUT
  '
  PRINT AT(17,17);"ARE YOU SURE ?"
  enter_yes_no(33,17,"Y",sure!)
  '
RETURN
'
' ==============================================================================
'                              CO-ORD PROCEDURES
' ==============================================================================
'
' ********************************  OUTPUT  ************************************
> PROCEDURE show_params
  '
  ' DISPLAYS PARAMETER BOX, VALUES ETC
  LOCAL type|,method|,dum$
  '
  type|=par_byte|(1,0)
  '
  COLOR 3
  BOX 125,43,319,199
  DEFFILL 0
  PBOX 126,44,318,198
  dum$=type_name$(type|)
  PRINT AT(17,7);"TYPE :   ";dum$
  '
  IF type|<=max_complex|
    '
    method|=par_byte|(1,3)
    PRINT AT(17,8);"SET  :   ";
    '
    IF par_mset!(1)
      PRINT "MANDEL"
    ELSE
      PRINT "JULIA"
      PRINT AT(17,14);"RE(C)= ";USING "-##.############",par_real(1,3)
      PRINT AT(17,15);"IM(C)= ";USING "-##.############",par_real(1,4)
    ENDIF
    '
    show_coords                 ! PRINTS x_min, ymin, x_step
    PRINT AT(17,16);"ITERS=";USING "####",par_word&(1,0)
    '
    dum$=method_name$(method|)
    '
    IF method|>3                ! .SML METHOD
      method|=method|-4         ! SMALL IGNORED FROM HERE ON IN THIS PROCEDURE
    ENDIF                       ! EG TREAT AS .FUL (SAME PARAMETERS)
    '
    PRINT AT(17,9);"METHD:   ";dum$
    '
    IF method|=3                       ! SCAPE
      PRINT AT(17,17);"HGHT = ";USING "###",par_byte|(1,4)
      PRINT AT(17,18);"OFFST= ";USING "###",par_byte|(1,5)
      PRINT AT(17,19);"EXTNT= ";USING "###",par_byte|(1,6)
      PRINT AT(17,20);"LIGHT=  ";USING "##",par_byte|(1,7)
      PRINT AT(17,21);"SPCLR=   ";USING "#.##",par_real(1,5)
      PRINT AT(17,22);"SHINE= ";USING "###",par_byte|(1,8)
      PRINT AT(17,23);"VIEW =  ";USING "##",par_byte|(1,9)
    ELSE
      PRINT AT(17,17);"PRCSN=   ";USING "#",par_byte|(1,4)
    ENDIF
    '
    IF method|<3                                ! QUICK OR LEM
      PRINT AT(17,18);"SPRD = ";USING "###",par_byte|(1,5)
    ENDIF
    '
    IF method|=1
      PRINT AT(17,19);"BOUND=";USING "####",par_word&(1,1)   ! LEM METHOD.
    ENDIF
    '
    IF method|=2                            ! SPHERE
      PRINT AT(17,18);"LI   =";USING "-###",par_word&(1,1)
      PRINT AT(17,19);"LJ   =";USING "-###",par_word&(1,2)
      PRINT AT(17,20);"LK   =";USING "-###",par_word&(1,3)
      PRINT AT(17,21);"SPCLR=   ";USING "#.##",par_real(1,5)
      PRINT AT(17,22);"SHINE= ";USING "###",par_byte|(1,5)
    ENDIF
    '
    '
  ENDIF
  SELECT type|
  CASE 11
    '
    show_coords
    PRINT AT(17,14);"GRID =  ";USING "##",par_byte|(1,3)
    PRINT AT(17,15);"SPRD = ";USING "###",par_byte|(1,4)
    PRINT AT(17,16);"ITERS=";USING "####",par_word&(1,0)
    '
  CASE 12
    '
    PRINT AT(17,10);"STICK=   ";USING "#.############",par_real(1,0)
    PRINT AT(17,11);"SYMTR=   ";USING "#.############",par_real(1,1)
    PRINT AT(17,12);"SPRD =   ";USING "####",par_word&(1,0)
    '
  CASE 13
    '
    PRINT AT(17,10);"SPRD =   ";USING "####",par_word&(1,0)
    '
  CASE 14
    '
    PRINT AT(17,8);"METHD:   ";cloud_meth$(par_byte|(1,3))
    PRINT AT(17,10);"DMNSN=   ";USING "#.##",par_real(1,0)
    '
  CASE 15
    '
    PRINT AT(17,10);"DMNSN=   ";USING "#.##",par_real(1,0)
    PRINT AT(17,11);"SPCLR=   ";USING "#.##",par_real(1,1)
    PRINT AT(17,12);"HGHT = ";USING "###",par_byte|(1,3)
    PRINT AT(17,13);"OFFST= ";USING "###",par_byte|(1,4)
    PRINT AT(17,14);"LIGHT=  ";USING "##",par_byte|(1,5)
    PRINT AT(17,15);"SHINE= ";USING "###",par_byte|(1,6)
    '
  ENDSELECT
  '
  IF type|>11
    '
    PRINT AT(17,9);"SEED = ";USING "#######",par_long%(1)
    '
  ENDIF
  '
  PRINT AT(17,24);"PAL  =  ";USING "##",par_byte|(1,1)
  PRINT AT(30,24);"MODE =  ";USING "##",par_byte|(1,2)
  '
RETURN
'
'
> PROCEDURE show_coords
  '
  PRINT AT(17,11);"XMIN = ";USING "-##.############",par_real(1,0)
  PRINT AT(17,12);"YMIN = ";USING "-##.############",par_real(1,1)
  PRINT AT(17,13);"XSTEP=   ";USING "#.########^^^^",par_real(1,2)
  '
RETURN
'
' ****************************  KEYBOARD INPUT  ********************************
'
> PROCEDURE enter_coords
  '
  enter_real(24,11,"",15,-100,100,V:par_real(1,0))  ! XMIN
  enter_real(24,12,"",15,-100,100,V:par_real(1,1))  ! XMIN
  enter_real(24,13,"",15,0,10,V:par_real(1,2))      ! XSTEP
  '
RETURN
'
'
> PROCEDURE enter_c
  '
  ' USER ENTERS C VALUE USED WHEN DRAWING JULIA SETS
  '
  enter_real(24,14,"",15,-10,10,V:par_real(1,3))  ! RE_C
  enter_real(24,15,"",15,-10,10,V:par_real(1,4))  ! IM_C
  '
RETURN
'
'
> PROCEDURE enter_iters
  '
  ' USER ENTERS NUMBER OF ITERS
  '
  enter_word(23,16,"",4,0,10000,V:par_word&(1,0))     ! ITERS
  '
RETURN
'
'
> PROCEDURE enter_spread
  '
  ' USER ENTERS SPREAD FOR QUICK OR LEM METHODS
  '
  enter_byte(24,18,"",3,0,256,V:par_byte|(1,5))     ! SPREAD
  '
RETURN
'
'
> PROCEDURE enter_bound
  '
  ' USER ENTERS BOUND
  '
  enter_word(24,19,"",4,0,10000,V:par_word&(1,1))   ! BOUND
  '
RETURN
'
'
> PROCEDURE enter_scape
  '
  ' USER ENTERS PARAMETERS WHICH ARE EXCLUSIVELY TUNED TO DRAWING 3D LANDSCAPES.
  '
  enter_byte(24,17,"",3,0,256,V:par_byte|(1,4))     ! HEIGHT
  enter_byte(24,18,"",3,-1,256,V:par_byte|(1,5))    ! OFFSET
  enter_byte(24,19,"",3,-1,201,V:par_byte|(1,6))    ! EXTENT
  enter_byte(24,20,"",2,-1,90,V:par_byte|(1,7))     ! LIGHT
  enter_real(24,21,"",4,-0.0001,1.0001,V:par_real(1,5))  ! SPECULAR
  enter_byte(24,22,"",3,0,256,V:par_byte|(1,8))     ! SHINE
  enter_byte(24,23,"",2,-1,91,V:par_byte|(1,9))     ! VIEW
  '
  '
RETURN
'
'
> PROCEDURE enter_sphere
  '
  ' USER ENTERS PARAMETERS WHICH ARE EXCLUSIVELY TUNED TO DRAWING 3D SPHERES.
  '
  enter_word(24,18,"",4,-1000,1000,V:par_word&(1,1))     ! LI
  enter_word(24,19,"",4,-1000,1000,V:par_word&(1,2))     ! LJ
  enter_word(24,20,"",4,-1000,1000,V:par_word&(1,3))     ! LK
  enter_real(24,21,"",4,-0.0001,1.0001,V:par_real(1,5)) ! SPECULAR
  enter_byte(24,22,"",3,0,256,V:par_byte|(1,5))     ! SHINE
  '
RETURN
'
'
> PROCEDURE enter_popcorn
  '
  ' USER ENTERS PARAMETERS WHICH ARE EXCLUSIVELY TUNED TO THE POPCORN TYPE
  '
  REPEAT
    enter_byte(24,14,"",2,0,11,V:par_byte|(1,3))     ! GRID
  UNTIL 160 DIV par_byte|(1,3)=160/par_byte|(1,3)
  '
  enter_byte(24,15,"",3,0,200,V:par_byte|(1,4))       ! SPREAD
  enter_word(23,16,"",4,0,10000,V:par_word&(1,0))     ! ITERS
  '
RETURN
'
'
> PROCEDURE enter_p_dla
  '
  enter_real(24,10,"",15,-1.0E-08,1.00000001,V:par_real(1,0))  ! STICK
  enter_real(24,11,"",15,-1.0E-08,1.00000001,V:par_real(1,1))  ! SYMTR
  enter_word(23,12,"",4,0,10000,V:par_word&(1,0))              ! SPRD
  '
RETURN
'
'
> PROCEDURE enter_mount
  '
  enter_real(24,10,"",4,0,1,V:par_real(1,0))     ! DIMENSION
  enter_real(24,11,"",4,-0.0001,1.0001,V:par_real(1,1))  ! SPEC
  enter_byte(24,12,"",3,0,256,V:par_byte|(1,3))   ! HEIGHT
  enter_byte(24,13,"",3,-1,256,V:par_byte|(1,4))  ! OFFSET
  enter_byte(24,14,"",2,-1,90,V:par_byte|(1,5))   ! LIGHT
  enter_byte(24,15,"",3,0,256,V:par_byte|(1,6))   ! SHINE EXPONENT
  '
RETURN
'
' **************************  PROCESSING CO-ORD DATA  **************************
'
> PROCEDURE copy_params(source|,dest|)
  '
  ' COPIES PARAMETERS FROM SOURCE TO DESTINATION (0=IMAGE, 1=TEMP, 2=ANIM, ETC)
  '
  LOCAL i|
  '
  par_mset!(dest|)=par_mset!(source|)
  par_long%(dest|)=par_long%(source|)
  '
  FOR i|=0 TO 9
    par_byte|(dest|,i|)=par_byte|(source|,i|)
  NEXT i|
  '
  FOR i|=0 TO 3
    par_word&(dest|,i|)=par_word&(source|,i|)
  NEXT i|
  '
  FOR i|=0 TO 5
    par_real(dest|,i|)=par_real(source|,i|)
  NEXT i|
  '
  '
RETURN
'
'
> PROCEDURE auto_precision(par|,safe!)
  '
  ' CALCULATES THE LEAST PRECISION (0,1 OR 2) NEEDED : FROM TYPE AND X_STEP
  ' NOTE PRECISION, STORED IN par_byte|(*,4), DETERMINES THE ARITHMETIC
  ' USED. 16 BIT AND 32 BIT INT MATHS GOES WRONG IF x_step IS TOO SMALL
  ' OR IF x_step IS SUFFICIENTLY IRRATIONAL SO HARD TO ACCURATELY EXPRESS
  ' IN BINARY.
  '
  LOCAL type|,x_step
  '
  type|=par_byte|(par|,0)
  x_step=par_real(par|,2)
  '
  IF NOT @ful_size(par|)        ! FOR .SML'S, THE x_step USED BY DRAW ROUTINES
    x_step=x_step*2             ! IS ACTUALLY TWICE x_step TO KEEP THE CD'S
    '                           ! UNIFORM.
  ENDIF
  '
  IF safe! AND x<0.025           ! THIS OPTION IS USED WHEN COMPUTING ZOOM
    x_step=x_step/4             ! ANIMATIONS. IT MAKES THE PICTURE MORE
    '                           ! ACCURATE BY USING MORE PRECISION EARLIER
  ENDIF                         ! IN THE ZOOM SO SAFER FOR THE USER.
  '
  IF (par_real(par|,3)^2+par_real(par|,4)^2)>4 AND NOT par_mset!(par|)
    par_byte|(par|,4)=2         ! JULIA WITH "BIGGISH" C-VALUE
    '
  ELSE IF x_step>0.025
    par_byte|(par|,4)=2         ! FP IF YOU ZOOM OUT
    '
  ELSE IF type|<4 AND x_step>1/1024
    par_byte|(par|,4)=0         ! 16 BIT : ONLY AVAILABLE FOR FIRST 4 TYPES
    '
  ELSE IF type|<6 AND x_step*(2^23)>1
    par_byte|(par|,4)=1         ! 32 BIT : ONLY AVAILABLE FOR FIRST 6 TYPES
    '
  ELSE
    par_byte|(par|,4)=2         ! OTHERWISE FP ARITHMETIC
    '
  ENDIF
  '
  '
RETURN
'
' ==============================================================================
'                        SPECIAL BONUS PROCEDURES
' ==============================================================================
'
> PROCEDURE clear_up
  '
  ' FREES UP MEMORY USED BY VARIABLES OR MALLOC AND RESERVE COMMANDS THEN ENDS
  ' THE PROGRAM.
  '
  ~MFREE(adr%)
  CLEAR
  RESERVE
  END
  '
RETURN
'
' ==============================================================================
'                       COMPLEX TYPES DRAWING ROUTINES
' ==============================================================================
' *****************  INTEGER ARITHMETIC - COMPLEX ROUTINES  ********************
'
> PROCEDURE quick_as(type|,mandel!,bit_16!,x_min,y_min,x_step,c_re,c_im,max_it&,spread|,x_max&,y_max&)
  '
  ' DRAWS MANDEL/JULIA USING DIVIDE&CONQUER METHOD AND ASSEMBLY ROUTINES.
  '
  LOCAL y_temp&
  '
  as_init
  '
  IF mandel!
    '
    line_start&=0
    line_end&=x_max&
    line_pos&=0
    m_as_line(FALSE)
    '
    line_pos&=y_max&
    m_as_line(FALSE)
    '
    y_temp&=SHR&(y_max&,1)
    line_pos&=y_temp&
    m_as_line(FALSE)
    '
    line_start&=1
    line_end&=y_max&
    line_pos&=0
    m_as_line(TRUE)
    '
    line_pos&=x_max&
    m_as_line(TRUE)
    '
    m_as_section(0,0,x_max&+1,y_temp&+1,TRUE)
    m_as_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
    '
  ELSE
    '
    line_start&=0
    line_end&=x_max&
    line_pos&=0
    j_as_line(FALSE)
    '
    line_pos&=y_max&
    j_as_line(FALSE)
    '
    y_temp&=SHR&(y_max&,1)
    line_pos&=y_temp&
    j_as_line(FALSE)
    '
    line_start&=1
    line_end&=y_max&
    line_pos&=0
    j_as_line(TRUE)
    '
    line_pos&=x_max&
    j_as_line(TRUE)
    '
    j_as_section(0,0,x_max&+1,y_temp&+1,TRUE)
    j_as_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
    '
  ENDIF
  '
  ERASE real%(),imag%()
  '
  '
RETURN
'
'
> PROCEDURE sphere_as(type|,mandel!,bit_16!,x_min,y_min,x_step,c_re,c_im,max_it&,l_i,l_j,l_k,fs,s_e|)
  '
  ' DRAWS FRACTAL PROJECTED (REIMANN STYLE) ONTO A RAYTRACED SPHERE.
  ' USES A STEREOGRAPHIC PROJECTION OF A PLANE ONTO A SPHERE.
  '
  LOCAL centre_x&,centre_y&,rad&,x0&,x1&,y0&,y1&,scale,offset_x,offset_y
  '
  as_init
  select_circle(centre_x&,centre_y&,rad&)
  sphere_init
  '
  FOR sph_x&=x0& TO x1&
    '
    p_i=(sph_x&*scale+offset_x)*x_step+p_i_min       ! TWO TRANSFORMATIONS :
    '
    ' FIRST: CHANGES SMALLER WINDOW TO THAT OF THE SCREEN
    ' THEN CHANGES TO THE 3D SPACE WITHOUT THE CENTRE OFFSET
    '
    FOR sph_y&=y0& TO y1&
      '
      p_j=(sph_y&*scale+offset_y)*x_step+p_j_min     ! SAME TWO TRANS
      '
      IF p_i*p_i+p_j*p_j<rad_sqrd AND sph_x&>-1 AND sph_x&<320 AND sph_y&>-1 AND sph_y&<200
        '
        ' CALCULATE (k CO-ORD - 3RD DIMENSION) AND COMPLEX PLANAR PROJECTION
        '
        p_k=-SQR(rad*rad-p_i*p_i-p_j*p_j)
        temp=rad/(rad-p_k)
        real%=(p_i*temp+re_centre)*mult%
        imag%=(p_j*temp+im_centre)*mult%
        '
        IF mandel!
          '
          reg%(0)=init_x%
          reg%(1)=0
          reg%(4)=0                             ! 16 bit only (x2)
          reg%(5)=0                             ! 16 bit only (y2)
          reg%(7)=max_it&
          reg%(8)=init_x2%                      ! 32 BIT ONLY
          reg%(9)=0                             ! 32 BIT ONLY
          reg%(10)=real%
          reg%(11)=imag%
          '
        ELSE
          '
          temp%=real%
          reg%(0)=temp%
          temp=temp%
          temp_2%=temp*temp/jul_div%                ! x2
          reg%(4)=temp_2%                           ! 16 BIT ONLY
          reg%(8)=temp_2%                           ! 32 BIT ONLY
          temp%=imag%
          reg%(1)=temp%
          temp=temp%
          temp_2%=temp*temp/jul_div%                ! x2
          reg%(5)=temp_2%                           ! 16 BIT ONLY.
          reg%(9)=temp_2%                           ! 32 BIT ONLY.
          reg%(7)=max_it&
          reg%(10)=c_re%
          reg%(11)=c_im%
          '
        ENDIF
        '
        RCALL address%,reg%()
        '
        ' CALCULATE COLOUR OF POINT AND PLOT IT AT (sphere_x&,sphere_y&)
        '
        n_i=p_i                         ! CALCULATE n
        n_j=p_j
        n_k=p_k
        mod_n=SQR(n_i*n_i+n_j*n_j+n_k*n_k)
        c_theta=(n_i*l_i+n_j*l_j+n_k*l_k)/(mod_n*mod_l)
        '
        IF c_theta<0
          '
          intens=0
          '
        ELSE
          '
          two_c_theta=2*c_theta
          r_i=two_c_theta*n_i-l_i
          r_j=two_c_theta*n_j-l_j
          r_k=two_c_theta*n_k-l_k
          mod_r=SQR(r_i*r_i+r_j*r_j+r_k*r_k)
          c_alpha=v_k*r_k/mod_r
          intens=fd*c_theta+fs*c_alpha^s_e|
          '
        ENDIF
        '
        col&=intens*render_spread|
        '
        IF reg%(7)=65535
          '
          IF col&<1
            col&=2
          ELSE IF col&>=render_spread|
            col&=10
          ELSE IF col& MOD 2=1 OR (sph_x&+sph_y&) MOD 2=0
            col&=col& DIV 2+2           ! PURE COLS
          ELSE
            col&=col& DIV 2+1           ! OTHERS
          ENDIF
          '
        ELSE
          '
          IF col&<1
            col&=6
          ELSE IF col&>=render_spread|
            col&=15
          ELSE IF col& MOD 2=1 OR (sph_x&+sph_y&) MOD 2=0
            col&=col& DIV 2+6
          ELSE
            col&=col& DIV 2+5
          ENDIF
          '
        ENDIF
        '
        PSET sph_x&,sph_y&,col_index|(col&)
        '
      ENDIF
      '
      IF MOUSEK=2
        finish(2)
      ENDIF
      '
    NEXT sph_y&
    '
  NEXT sph_x&
  '
  ERASE real%(),imag%()
  '
  '
RETURN
'
'
> PROCEDURE m_as_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTES A BOX OF MSET USING DIVIDE&CONQUER AND ASSEMBLY ROUTINES.
  '
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION
  '
  LOCAL temp_size&    ! MINIMIZED NUM OF LOCAL VARIABLES-AVOIDS STACK OVERFLOW.
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  col|=PTST(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  '
  REPEAT
    mono!=col|=PTST(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=col|=PTST(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        mono!=col|=PTST(box_x&,b0&)
        INC b0&
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        '
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=col|=PTST(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono! AND NOT col|=0
          '
          DEFFILL inverse_index|(col|)
          PBOX box_x&+1,box_y&+1,a1&-1,b1&-1
          '
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    '
    IF width&>8
      '
      IF vert!
        '
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        m_as_line(TRUE)
        m_as_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        m_as_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
        '
      ELSE
        '
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        m_as_line(FALSE)
        m_as_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        m_as_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
        '
      ENDIF
      '
    ELSE
      '
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      '
      REPEAT
        m_as_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE j_as_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTES A BOX OF JSET USING DIVIDE&CONQUER AND ASSEMBLY ROUTINES.
  '
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION
  '
  LOCAL temp_size&
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  col|=PTST(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  REPEAT
    mono!=col|=PTST(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=col|=PTST(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        '
        mono!=col|=PTST(box_x&,b0&)
        INC b0&
        '
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        '
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=col|=PTST(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono! AND NOT col|=0
          DEFFILL inverse_index|(col|)
          PBOX box_x&+1,box_y&+1,a1&-1,b1&-1
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    '
    IF width&>8
      '
      IF vert!
        '
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        j_as_line(TRUE)
        j_as_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        j_as_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
        '
      ELSE
        '
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        j_as_line(FALSE)
        j_as_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        j_as_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
        '
      ENDIF
      '
    ELSE
      '
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      '
      REPEAT
        j_as_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
      '
    ENDIF
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE m_as_line(vert!)
  '
  ' CALCULATES A LINE OF MSET USING ASSEMBLY ROUTINES
  '
  IF vert!
    '
    FOR b&=line_start& TO line_end&
      '
      reg%(0)=init_x%
      reg%(1)=0
      reg%(4)=0                         ! 16 bit only (x2)
      reg%(5)=0                         ! 16 bit only (y2)
      reg%(7)=max_it&
      reg%(8)=init_x2%                  ! 32 BIT ONLY
      reg%(9)=0                         ! 32 BIT ONLY
      reg%(10)=real%(line_pos&)
      reg%(11)=imag%(b&)
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF NOT it%=65535
        it%=(2+max_it&-it%) DIV spread|
        PSET line_pos&,b&,col_index|(it% MOD 14+2)
      ENDIF
      '
    NEXT b&
    '
  ELSE
    '
    FOR a&=line_start& TO line_end&
      '
      reg%(0)=init_x%
      reg%(1)=0
      reg%(4)=0                         ! 16 bit only (x2)
      reg%(5)=0                         ! 16 bit only (y2)
      reg%(7)=max_it&
      reg%(8)=init_x2%                  ! 32 BIT ONLY
      reg%(9)=0                         ! 32 BIT ONLY
      reg%(10)=real%(a&)
      reg%(11)=imag%(line_pos&)
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF NOT it%=65535
        it%=(2+max_it&-it%) DIV spread|
        PSET a&,line_pos&,col_index|(it% MOD 14+2)
      ENDIF
      '
    NEXT a&
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE j_as_line(vert!)
  '
  ' CALCULATES A LINE OF JSET USING ASSEMBLY ROUTINES
  '
  IF vert!
    '
    FOR b&=line_start& TO line_end&
      '
      temp%=real%(line_pos&)
      reg%(0)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%                ! x2
      reg%(4)=temp_2%                           ! 16 BIT ONLY
      reg%(8)=temp_2%                           ! 32 BIT ONLY
      temp%=imag%(b&)
      reg%(1)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%                ! x2
      reg%(5)=temp_2%                           ! 16 BIT ONLY.
      reg%(9)=temp_2%                           ! 32 BIT ONLY.
      reg%(7)=max_it&
      reg%(10)=c_re%
      reg%(11)=c_im%
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF NOT it%=65535
        it%=(2+max_it&-it%) DIV spread|
        PSET line_pos&,b&,col_index|(it% MOD 14+2)
      ENDIF
      '
    NEXT b&
    '
  ELSE
    '
    FOR a&=line_start& TO line_end&
      '
      temp%=real%(a&)
      reg%(0)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%                ! x2
      reg%(4)=temp_2%                   ! 16 BIT ONLY
      reg%(8)=temp_2%                   ! 32 BIT ONLY
      temp%=imag%(line_pos&)
      reg%(1)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%                ! x2
      reg%(5)=temp_2%                   ! 16 BIT ONLY.
      reg%(9)=temp_2%                   ! 32 BIT ONLY.
      reg%(7)=max_it&
      reg%(10)=c_re%
      reg%(11)=c_im%
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF NOT it%=65535
        it%=(2+max_it&-it%) DIV spread|
        PSET a&,line_pos&,col_index|(it% MOD 14+2)
      ENDIF
      '
    NEXT a&
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE lem_as(type|,mandel!,bit_16!,x_min,y_min,x_step,c_re,c_im,max_it&,spread|,bound&,x_max&,y_max&)
  '
  ' DRAWS MANDEL/JULIA USING DIVIDE&CONQUER METHOD, ASSEMBLY ROUTINES
  ' AND LEM (lem_plot).
  '
  LOCAL y_temp&
  '
  DIM iters&(319,199)
  as_init
  '
  IF mandel!
    '
    line_start&=0
    line_end&=x_max&
    line_pos&=0
    lem_m_as_line(FALSE)
    '
    line_pos&=y_max&
    lem_m_as_line(FALSE)
    '
    y_temp&=SHR&(y_max&,1)
    line_pos&=y_temp&
    lem_m_as_line(FALSE)
    '
    line_start&=1
    line_end&=y_max&
    line_pos&=0
    lem_m_as_line(TRUE)
    '
    line_pos&=x_max&
    lem_m_as_line(TRUE)
    '
    lem_m_as_section(0,0,x_max&+1,y_temp&+1,TRUE)
    lem_m_as_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
    '
  ELSE
    line_start&=0
    line_end&=x_max&
    line_pos&=0
    lem_j_as_line(FALSE)
    '
    line_pos&=y_max&
    lem_j_as_line(FALSE)
    '
    y_temp&=SHR&(y_max&,1)
    line_pos&=y_temp&
    lem_j_as_line(FALSE)
    '
    line_start&=1
    line_end&=y_max&
    line_pos&=0
    lem_j_as_line(TRUE)
    '
    line_pos&=x_max&
    lem_j_as_line(TRUE)
    '
    lem_j_as_section(0,0,x_max&+1,y_temp&+1,TRUE)
    lem_j_as_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
    '
  ENDIF
  '
  lem_plot
  ERASE iters&(),real%(),imag%()
  '
  '
RETURN
'
'
> PROCEDURE lem_m_as_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTES A BOX OF J/MSET USING DIVIDE&CONQUER AND ASSEMBLY ROUTINES.
  '
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION
  '
  LOCAL temp_size&    ! MINIMIZED NUM OF LOCAL VARIABLES-AVOIDS STACK OVERFLOW.
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  it&=iters&(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  REPEAT
    mono!=it&=iters&(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=it&=iters&(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        mono!=it&=iters&(box_x&,b0&)
        INC b0&
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=it&=iters&(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono!
          '
          a0&=box_x&+1
          b0&=box_y&+1
          DEC a1&
          DEC b1&
          '
          FOR a&=a0& TO a1&
            FOR b&=b0& TO b1&
              iters&(a&,b&)=it&
            NEXT b&
          NEXT a&
          '
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    '
    IF width&>8
      '
      IF vert!
        '
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        lem_m_as_line(TRUE)
        lem_m_as_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        lem_m_as_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
        '
      ELSE
        '
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        lem_m_as_line(FALSE)
        lem_m_as_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        lem_m_as_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
        '
      ENDIF
      '
    ELSE
      '
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      '
      REPEAT
        lem_m_as_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE lem_j_as_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTE JULIA SET USING ASSEMBLY ROUTINES.
  '
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION
  '
  LOCAL temp_size&
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  it&=iters&(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  REPEAT
    mono!=it&=iters&(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=it&=iters&(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        mono!=it&=iters&(box_x&,b0&)
        INC b0&
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=it&=iters&(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono!
          '
          a0&=box_x&+1
          b0&=box_y&+1
          DEC a1&
          DEC b1&
          '
          FOR a&=a0& TO a1&
            FOR b&=b0& TO b1&
              iters&(a&,b&)=it&
            NEXT b&
          NEXT a&
          '
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    '
    IF width&>8
      '
      IF vert!
        '
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        lem_j_as_line(TRUE)
        lem_j_as_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        lem_j_as_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
        '
      ELSE
        '
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        lem_j_as_line(FALSE)
        lem_j_as_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        lem_j_as_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
        '
      ENDIF
      '
    ELSE
      '
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      '
      REPEAT
        lem_j_as_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
      '
    ENDIF
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE lem_m_as_line(vert!)
  '
  ' CALCULATES A LINE OF MSET USING ASSEMBLY ROUTINES
  '
  IF vert!
    '
    FOR b&=line_start& TO line_end&
      '
      reg%(0)=init_x%
      reg%(1)=0
      reg%(4)=0                         ! 16 bit only (x2)
      reg%(5)=0                         ! 16 bit only (y2)
      reg%(7)=max_it&
      reg%(8)=init_x2%                  ! 32 BIT ONLY
      reg%(9)=0                         ! 32 BIT ONLY
      reg%(10)=real%(line_pos&)
      reg%(11)=imag%(b&)
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF it%=65535
        iters&(line_pos&,b&)=max_it&
      ELSE
        it%=(2+max_it&-it%) DIV spread|
        iters&(line_pos&,b&)=it%
        PSET line_pos&,b&,it%
      ENDIF
      '
    NEXT b&
    '
  ELSE
    '
    FOR a&=line_start& TO line_end&
      '
      reg%(0)=init_x%
      reg%(1)=0
      reg%(4)=0                         ! 16 bit only (x2)
      reg%(5)=0                         ! 16 bit only (y2)
      reg%(7)=max_it&
      reg%(8)=init_x2%                  ! 32 BIT ONLY
      reg%(9)=0                         ! 32 BIT ONLY
      reg%(10)=real%(a&)
      reg%(11)=imag%(line_pos&)
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF it%=65535
        iters&(a&,line_pos&)=max_it&
      ELSE
        it%=(2+max_it&-it%) DIV spread|
        iters&(a&,line_pos&)=it%
        PSET a&,line_pos&,it%
      ENDIF
      '
    NEXT a&
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE lem_j_as_line(vert!)
  '
  ' CALCULATES A LINE OF JSET USING ASSEMBLY ROUTINES
  '
  IF vert!
    '
    FOR b&=line_start& TO line_end&
      '
      temp%=real%(line_pos&)
      reg%(0)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%
      reg%(4)=temp_2%
      reg%(8)=temp_2%
      temp%=imag%(b&)
      reg%(1)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%
      reg%(5)=temp_2%
      reg%(9)=temp_2%
      reg%(7)=max_it&
      reg%(10)=c_re%
      reg%(11)=c_im%
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF it%=65535
        iters&(line_pos&,b&)=max_it&
      ELSE
        it%=(2+max_it&-it%) DIV spread|
        iters&(line_pos&,b&)=it%
        PSET line_pos&,b&,it%
      ENDIF
      '
    NEXT b&
  ELSE
    '
    FOR a&=line_start& TO line_end&
      '
      temp%=real%(a&)
      reg%(0)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%
      reg%(4)=temp_2%
      reg%(8)=temp_2%
      temp%=imag%(line_pos&)
      reg%(1)=temp%
      temp=temp%
      temp_2%=temp*temp/jul_div%
      reg%(5)=temp_2%
      reg%(9)=temp_2%
      reg%(7)=max_it&
      reg%(10)=c_re%
      reg%(11)=c_im%
      RCALL address%,reg%()
      '
      it%=reg%(7)
      IF it%=65535
        iters&(a&,line_pos&)=max_it&
      ELSE
        it%=(2+max_it&-it%) DIV spread|
        iters&(a&,line_pos&)=it%
        PSET a&,line_pos&,it%
      ENDIF
      '
    NEXT a&
    '
  ENDIF
  '
RETURN
'
' ***************  FLOATING POINT ARITHMETIC- COMPLEX ROUTINES  ****************
'
> PROCEDURE select_circle(VAR centre_x&,centre_y&,rad&)
  '
  ' USER SELECTS A CIRCLE IN THE SCREEN
  ' note this procedure is dependent on the x/y ratio of the screen.
  ' - currently set for the st in low rez.
  ' ALSO CIRCLE IN GFA V3.0 FOR THE ST DOES NOT MAKE THE CORRECT USE OF
  ' RADIUS (HAVE TO ADD 8 TO GET A CIRCLE OF THE CORRECT RADIUS ON SCREEN)
  '
  LOCAL x&,y&,max_rad&,t_x&,t_y&,old_x&,old_y&,key!,box_flag!
  LOCAL x_max&,y_max&,mk|,x_step,yn|
  '
  IF alerts!
    '
    SETMOUSE 0,0
    GRAPHMODE 3                   ! For drawing zoom box in XOR mode
    '
    x_max&=319
    y_max&=199
    x&=x_max& DIV 2
    y&=y_max& DIV 2
    SETMOUSE x&,y&
    key!=FALSE
    max_rad&=y_max&
    rad&=max_rad& DIV 2                   ! Init zoom box screen dimensions
    '
    REPEAT
      '
      ELLIPSE x&,y&,rad&,rad&             ! Draw zoom box
      old_x&=x&                           ! Temporary storage
      old_y&=y&
      old_rad&=rad&
      box_flag!=FALSE                     ! Redraw box ?
      '
      REPEAT
        '
        MOUSE t_x&,t_y&,mk|               ! Temp store for mouse status
        key!=INKEY$=""
        '
        IF t_x&<>x& OR t_y&<>y&           ! Has mouse moved
          '
          IF t_x&=>0 AND t_y&=>0 AND t_x&<=x_max& AND t_y&<=y_max&
            '
            x&=t_x&                       ! Circle can be moved
            y&=t_y&
            box_flag!=TRUE
            '
          ELSE
            '
            SETMOUSE x&,y&                ! Circle cannot be moved
            '
          ENDIF
          '
        ENDIF
        '
        '
        IF mk|=1 AND rad&>7
          SETMOUSE x&,y&                  ! Follow circle
          SUB rad&,4
          box_flag!=TRUE
          PAUSE 2
        ENDIF
        '
        IF mk|=2 AND rad&<=max_rad&
          '
          SETMOUSE x&,y&
          ADD rad&,4
          box_flag!=TRUE
          PAUSE 2
          '
        ENDIF
        '
      UNTIL box_flag! OR NOT key!
      '
      ELLIPSE old_x&,old_y&,old_rad&,old_rad&   ! Erase old circ
      '
    UNTIL NOT key!
    '
    GRAPHMODE 1
    '
    centre_x&=x&
    centre_y&=y&
    '
  ELSE
    '
    centre_x&=159
    centre_y&=99
    rad&=99
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE quick_fl(type|,mandel!,x_min,y_min,x_step,c_re,c_im,max_it&,spread|,x_max&,y_max&)
  '
  ' DRAWS M/J USING GFA FLOATING PT ROUTINES.
  '
  LOCAL y_temp&
  y_temp&=SHR&(y_max&,1)
  '
  DIM real(319),imag(199),iters&(319,199)
  '
  complex_array
  '
  float_border
  '
  quick_fl_section(0,0,x_max&+1,y_temp&+1,TRUE)
  quick_fl_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
  ERASE real(),imag(),iters&()
  '
  '
RETURN
'
'
> PROCEDURE quick_fl_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTE A BOX SECTION OF M/J SET USING GFA FLOAT' POINT ARITHMETIC ROUTINES.
  '
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION
  '
  LOCAL temp_size&    ! MINIMIZED NUM OF LOCAL VARIABLES-AVOIDS STACK OVERFLOW.
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  col|=PTST(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  REPEAT
    mono!=col|=PTST(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=col|=PTST(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        mono!=col|=PTST(box_x&,b0&)
        INC b0&
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        '
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=col|=PTST(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono! AND NOT col|=0
          DEFFILL inverse_index|(col|)
          PBOX box_x&+1,box_y&+1,a1&-1,b1&-1
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    '
    IF width&>8
      '
      IF vert!
        '
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        float_line(TRUE)
        quick_fl_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        quick_fl_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
        '
      ELSE
        '
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        float_line(FALSE)
        quick_fl_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        quick_fl_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
        '
      ENDIF
      '
    ELSE
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      '
      REPEAT
        float_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
      '
    ENDIF
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE lem_fl(type|,mandel!,x_min,y_min,x_step,c_re,c_im,max_it&,spread|,bound&,x_max&,y_max&)
  '
  ' COMPUTES M/J USING GFA FLOAT' POINT ARITHMETIC ROUTINES AND THEN PLOTS THE
  ' IMAGE, WITH THE FRACTAL'S BOUNDARY USING THE lem_plot SUBROUTINE.
  '
  LOCAL y_temp&
  y_temp&=SHR&(y_max&,1)
  '
  DIM real(319),imag(199),iters&(319,199)
  complex_array
  '
  float_border
  '
  lem_fl_section(0,0,x_max&+1,y_temp&+1,TRUE)
  lem_fl_section(0,y_temp&,x_max&+1,y_temp&+2,TRUE)
  '
  ERASE real(),imag()
  lem_plot
  ERASE iters&()
  '
  '
RETURN
'
'
> PROCEDURE sphere_fl(type|,mandel!,x_min,y_min,x_step,c_re,c_im,max_it&,l_i,l_j,l_k,fs,s_e|)
  '
  ' DRAWS FRACTAL PROJECTED (REIMANN STYLE) ONTO A RAYTRACED SPHERE.
  '
  LOCAL p|,centre_x&,centre_y&,rad&,x0&,x1&,y0&,y1&,scale,offset_x,offset_y
  '
  p|=PTST(0,0)
  a&=0                  ! SET THESE VARIABLES SO THAT ONLY THE TOP LEFT POINT ON
  b&=0                  ! THE SCREEN IS PLOTTED IN THE CALCULATION PROCEDURE.
  spread|=1             ! NOT USED BUT MUST AVOID DIVISION BY 0.
  '
  select_circle(centre_x&,centre_y&,rad&)
  sphere_init
  '
  FOR sph_x&=x0& TO x1&
    '
    p_i=(sph_x&*scale+offset_x)*x_step+p_i_min       ! TWO TRANSFORMATIONS :
    '
    FOR sph_y&=y0& TO y1&
      '
      p_j=(sph_y&*scale+offset_y)*x_step+p_j_min     ! SAME TWO TRANS
      '
      IF p_i*p_i+p_j*p_j<rad_sqrd AND sph_x&>-1 AND sph_x&<320 AND sph_y&>-1 AND sph_y&<200
        '
        p_k=-SQR(rad*rad-p_i*p_i-p_j*p_j)
        temp=rad/(rad-p_k)
        real(0)=p_i*temp+re_centre
        imag(0)=p_j*temp+im_centre
        '
        SELECT type|
        CASE 0
          quad_point
        CASE 1
          conj_point
        CASE 2
          spid_point
        CASE 3
          fish_point
        CASE 4
          cub1_point
        CASE 5
          cub2_point
        CASE 6
          barn_point
        CASE 7
          sine_point
        CASE 8
          cosn_point
        ENDSELECT
        '
        ' CALCULATE COLOUR OF POINT AND PLOT IT AT (sphere_x&,sphere_y&)
        '
        n_i=p_i                                 ! CALCULATE n
        n_j=p_j
        n_k=p_k
        mod_n=SQR(n_i*n_i+n_j*n_j+n_k*n_k)
        c_theta=(n_i*l_i+n_j*l_j+n_k*l_k)/(mod_n*mod_l)
        '
        IF c_theta<0
          '
          intens=0
          '
        ELSE
          '
          two_c_theta=2*c_theta
          r_i=two_c_theta*n_i-l_i
          r_j=two_c_theta*n_j-l_j
          r_k=two_c_theta*n_k-l_k
          mod_r=SQR(r_i*r_i+r_j*r_j+r_k*r_k)
          c_alpha=v_k*r_k/mod_r
          intens=fd*c_theta+fs*c_alpha^s_e|
          '
        ENDIF
        '
        col&=intens*render_spread|
        '
        IF i&=max_it&
          '
          IF col&<1
            col&=2
          ELSE IF col&>=render_spread|
            col&=10
          ELSE IF col& MOD 2=1 OR (sph_x&+sph_y&) MOD 2=0
            col&=col& DIV 2+2           ! PURE COLS
          ELSE
            col&=col& DIV 2+1           ! OTHERS
          ENDIF
          '
        ELSE
          '
          IF col&<1
            col&=6
          ELSE IF col&>=render_spread|
            col&=15
          ELSE IF col& MOD 2=1 OR (sph_x&+sph_y&) MOD 2=0
            col&=col& DIV 2+6
          ELSE
            col&=col& DIV 2+5
          ENDIF
          '
        ENDIF
        '
        PSET sph_x&,sph_y&,col_index|(col&)
        '
      ENDIF
      '
      IF MOUSEK=2
        finish(2)
      ENDIF
      '
    NEXT sph_y&
    '
  NEXT sph_x&
  '
  PSET 0,0,p|
  '
  '
RETURN
'
'
> PROCEDURE float_border
  '
  ' DRAWS THE BORDER OF M/JSET
  '
  half_pi=PI/2                          ! FOR SINE MSET
  const=x_step*0.02                     ! FOR NEWT AND DEG4
  const2=x_step*2                       ! DITTO
  '
  line_start&=0
  line_end&=x_max&
  line_pos&=0
  float_line(FALSE)
  '
  line_pos&=y_max&
  float_line(FALSE)
  '
  line_pos&=y_temp&
  float_line(FALSE)
  '
  line_start&=1
  line_end&=y_max&
  line_pos&=0
  float_line(TRUE)
  '
  line_pos&=x_max&
  float_line(TRUE)
  '
RETURN
'
'
> PROCEDURE lem_fl_section(box_x&,box_y&,width&,height&,vert!)
  '
  ' COMPUTE A BOX SECTION OF M/J SET USING GFA FLOAT' POINT ARITHMETIC ROUTINES.
  ' box_x,box_y IS THE TOP LEFT HAND COORD OF SECTION.
  '
  LOCAL temp_size&
  '
  IF MOUSEK=2
    finish(1)
  ENDIF
  '
  it&=iters&(box_x&,box_y&)
  a0&=box_x&+1
  a1&=box_x&+width&
  '
  REPEAT
    mono!=it&=iters&(a0&,box_y&)
    INC a0&
  UNTIL a0&=a1& OR NOT mono!
  '
  IF mono!
    '
    a0&=box_x&
    b1&=box_y&+height&-1
    '
    REPEAT
      mono!=it&=iters&(a0&,b1&)
      INC a0&
    UNTIL a0&=a1& OR NOT mono!
    '
    IF mono!
      '
      b0&=box_y&+1
      '
      REPEAT
        mono!=it&=iters&(box_x&,b0&)
        INC b0&
      UNTIL b0&=b1& OR NOT mono!
      '
      IF mono!
        b0&=box_y&+1
        DEC a1&
        '
        REPEAT
          mono!=it&=iters&(a1&,b0&)
          INC b0&
        UNTIL b0&=b1& OR NOT mono!
        '
        IF mono!
          '
          a0&=box_x&+1
          b0&=box_y&+1
          DEC a1&
          DEC b1&
          '
          FOR a&=a0& TO a1&
            FOR b&=b0& TO b1&
              iters&(a&,b&)=it&
            NEXT b&
          NEXT a&
          '
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
  ENDIF
  '
  IF NOT mono!
    IF width&>8
      IF vert!
        line_start&=box_y&+1
        line_end&=box_y&+height&-2
        temp_size&=SHR&(width&,1)
        line_pos&=temp_size&+box_x&
        float_line(TRUE)
        lem_fl_section(box_x&,box_y&,temp_size&+1,height&,FALSE)
        lem_fl_section(temp_size&+box_x&,box_y&,width&-temp_size&,height&,FALSE)
      ELSE
        line_start&=box_x&+1
        line_end&=box_x&+width&-2
        temp_size&=SHR&(height&,1)
        line_pos&=box_y&+temp_size&
        float_line(FALSE)
        lem_fl_section(box_x&,box_y&,width&,temp_size&+1,TRUE)
        lem_fl_section(box_x&,temp_size&+box_y&,width&,height&-temp_size&,TRUE)
      ENDIF
    ELSE
      line_start&=box_x&+1
      line_end&=box_x&+width&-2
      line_pos&=box_y&+1
      b1&=box_y&+height&-1
      REPEAT
        float_line(FALSE)
        INC line_pos&
      UNTIL line_pos&=b1&
    ENDIF
  ENDIF
RETURN
'
'
> PROCEDURE float_line(vert!)
  '
  ' CALCULATES A LINE OF M/JSET USING GFA ROUTINES
  '
  IF vert!
    '
    a&=line_pos&
    '
    SELECT type|
    CASE 0
      FOR b&=line_start& TO line_end&
        quad_point
      NEXT b&
    CASE 1
      FOR b&=line_start& TO line_end&
        conj_point
      NEXT b&
    CASE 2
      FOR b&=line_start& TO line_end&
        spid_point
      NEXT b&
    CASE 3
      FOR b&=line_start& TO line_end&
        fish_point
      NEXT b&
    CASE 4
      FOR b&=line_start& TO line_end&
        cub1_point
      NEXT b&
    CASE 5
      FOR b&=line_start& TO line_end&
        cub2_point
      NEXT b&
    CASE 6
      FOR b&=line_start& TO line_end&
        barn_point
      NEXT b&
    CASE 7
      FOR b&=line_start& TO line_end&
        sine_point
      NEXT b&
    CASE 8
      FOR b&=line_start& TO line_end&
        cosn_point
      NEXT b&
    CASE 9
      FOR b&=line_start& TO line_end&
        newt_point
      NEXT b&
    CASE 10
      FOR b&=line_start& TO line_end&
        deg4_point
      NEXT b&
    ENDSELECT
  ELSE
    '
    b&=line_pos&
    '
    SELECT type|
    CASE 0
      FOR a&=line_start& TO line_end&
        quad_point
      NEXT a&
    CASE 1
      FOR a&=line_start& TO line_end&
        conj_point
      NEXT a&
    CASE 2
      FOR a&=line_start& TO line_end&
        spid_point
      NEXT a&
    CASE 3
      FOR a&=line_start& TO line_end&
        fish_point
      NEXT a&
    CASE 4
      FOR a&=line_start& TO line_end&
        cub1_point
      NEXT a&
    CASE 5
      FOR a&=line_start& TO line_end&
        cub2_point
      NEXT a&
    CASE 6
      FOR a&=line_start& TO line_end&
        barn_point
      NEXT a&
    CASE 7
      FOR a&=line_start& TO line_end&
        sine_point
      NEXT a&
    CASE 8
      FOR a&=line_start& TO line_end&
        cosn_point
      NEXT a&
    CASE 9
      FOR a&=line_start& TO line_end&
        newt_point
      NEXT a&
    CASE 10
      FOR a&=line_start& TO line_end&
        deg4_point
      NEXT a&
    ENDSELECT
    '
  ENDIF
  '
RETURN
'
'
' ******  EACH _point ROUTINE CALCULATES THE COLOUR OF A SINGLE POINT  *********
'
> PROCEDURE quad_point
  '
  init_fl_point
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    y=2*x*y+c_im
    x=x2-y2+c_re
    INC i&
    '
  UNTIL x2+y2>5 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE conj_point
  '
  init_fl_point
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    y=-2*x*y+c_im
    x=x2-y2+c_re
    INC i&
    '
  UNTIL x2+y2>5 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE spid_point
  '
  IF mandel!
    x=0
    y=0
    temp_re=real(a&)
    temp_im=imag(b&)
  ELSE
    temp_re=c_re
    temp_im=c_im
    x=real(a&)
    y=imag(b&)
  ENDIF
  '
  i&=0
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    y=2*x*y+temp_im
    x=x2-y2+temp_re
    temp_re=x+0.5*temp_re
    temp_im=y+0.5*temp_im
    INC i&
    '
  UNTIL x2+y2>4 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE fish_point
  '
  init_fl_point
  temp_re=0
  temp_im=0
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    f=x
    g=y
    y=2*x*y+temp_im+c_im
    x=x2-y2+temp_re+c_re
    temp_re=f
    temp_im=g
    INC i&
    '
  UNTIL x2+y2>4 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cub1_point
  '
  init_fl_point
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    x=x*(x2-3*y2)+c_re
    y=y*(3*x2-y2)+c_im
    INC i&
    '
  UNTIL x2+y2>2 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cub2_point
  '
  IF mandel!
    x=0.5773502691896             ! sqr(1/3)
    y=0
    c_re=real(a&)
    c_im=imag(b&)
  ELSE
    x=real(a&)
    y=imag(b&)
  ENDIF
  '
  i&=0
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    x=x*(x2-3*y2-1)+c_re
    y=y*(3*x2-y2-1)+c_im
    INC i&
    '
  UNTIL x2+y2>2 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE barn_point
  '
  IF mandel!
    x=0
    y=0
    c_re=real(a&)
    c_im=imag(b&)
    q=c_re*c_re+c_im*c_im
    IF q=0
      q=1.0E-10
    ENDIF
  ELSE
    x=real(a&)
    y=imag(b&)
  ENDIF
  '
  i&=0
  '
  REPEAT
    '
    temp=x
    IF x<0
      x=(c_re*x-c_im*y+c_re)/q
      y=(c_re*y+c_im*temp+c_im)/q
    ELSE
      x=(c_re*x+c_im*y-c_re)/q
      y=(c_re*y-c_im*temp+c_im)/q
    ENDIF
    INC i&
    '
  UNTIL x*x+y*y>100 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=i&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
RETURN
'
'
> PROCEDURE sine_point
  '
  IF mandel!
    x=half_pi
    y=0
    c_re=real(a&)
    c_im=imag(b&)
  ELSE
    x=real(a&)
    y=imag(b&)
  ENDIF
  '
  i&=0
  '
  REPEAT
    '
    p=SIN(x)
    q=COS(x)
    r=EXP(y)
    s=1/r
    f=p*(r+s)
    g=q*(r-s)
    x=(f*c_re-g*c_im)/2
    y=(f*c_im+g*c_re)/2
    INC i&
    '
  UNTIL ABS(y)>50 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cosn_point
  '
  init_fl_point
  '
  REPEAT
    '
    p=SIN(x)
    q=COS(x)
    r=EXP(y)
    s=1/r
    f=q*0.5*(r+s)
    g=p*0.5*(s-r)
    x=f*c_re-g*c_im
    y=f*c_im+g*c_re
    INC i&
    '
  UNTIL ABS(y)>50 OR i&=max_it&
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 14+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE newt_point
  '
  IF mandel!
    x=0.3333333333333
    y=0
    c_re=real(a&)
    c_im=imag(b&)
    IF c_re=0
      c_re=1.0E-10
    ENDIF
    wr=c_re*c_re-c_im*c_im
    wi=2*c_re*c_im
  ELSE
    x=real(a&)
    y=imag(b&)
  ENDIF
  '
  i&=0
  '
  REPEAT
    '
    x2=x*x
    y2=y*y
    p=x2*(2*x-1)+y2*(1-6*x)-wr
    q=2*y*(3*x2-y2-x)-wi
    r=3*(x2-y2)-2*x-wr
    s=2*y*(3*x-1)-wi
    f=r*r+s*s
    ox=x
    x=(p*r+q*s)/f
    oy=y
    y=(q*r-p*s)/f
    INC i&
    '
  UNTIL i&=max_it& OR (oy-y)^2+(x-ox)^2<converge
  '
  IF i&=max_it&
    iters&(a&,b&)=max_it&
  ELSE IF (x+c_re)^2+(y+c_im)^2<converge_2
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 4+2)
  ELSE IF (x-c_re)^2+(y-c_im)^2<converge_2
    i&=i& DIV spread|
    iters&(a&,b&)=-i&
    PSET a&,b&,col_index|(i& MOD 5+6)
  ELSE
    i&=i& DIV spread|
    iters&(a&,b&)=i&+10000
    PSET a&,b&,col_index|(i& MOD 5+11)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE deg4_point
  '
  init_fl_point
  '
  REPEAT
    '
    x2=x*x
    y2=y*y
    p=x2-y2+c_re-1
    q=2*x*y+c_im
    r=2*x+c_re-2
    s=2*y+c_im
    f=p*r+q*s
    g=r*q-p*s
    h=(r*r+s*s)
    h=h*h
    ox=x
    oy=y
    x=(f*f-g*g)/h
    y=2*f*g/h
    INC i&
    '
  UNTIL (ox-x)^2+(oy-y)^2<converge OR x2+y2>10 OR i&=max_it&
  '
  IF x2+y2>10
    i&=i& DIV spread|
    iters&(a&,b&)=i&
    PSET a&,b&,col_index|(i& MOD 7+2)
  ELSE IF (x-1)^2+y*y<converge_2
    i&=i& DIV spread|
    iters&(a&,b&)=-i&
    PSET a&,b&,col_index|(i& MOD 7+9)
  ELSE
    iters&(a&,b&)=max_it&
  ENDIF
  '
  '
RETURN
'
' ******************************  SCAPE METHOD  ********************************
'
> PROCEDURE 3d_cpm_fl(type|,mandel!,re_min,im_min,re_step,real_c,imag_c,max_it&,vert_off|,extent|,lambda|,phi|,fs,s_e|,max_height|)
  '
  ' Generalised 3D mountain projection,  ray-tracing and shadows:
  ' screen co-ords -> p (mountain point co-ords)
  '
  ' Ray tracing vectors etc :
  ' n = surface normal
  ' lambda = light source angle with x=0 horizontal
  ' l = light source unit vector away from mountain (described by lambda)
  ' phi = view angle with y=0 horizontal
  ' v = view unit vector (described by phi)
  ' r = reflected light source vector from p
  ' c_theta = cos (angle between n & l)
  ' c_alpha = cos (angle between v & r)
  ' Intens = intensity of p
  ' Fs, Fd = factors determining diffuse and specular components of p
  ' b = shinniness exponent of p
  ' Ia = intensity of ambient light
  ' phi = angle of view measured with horizontal
  ' level = physical height of mountain
  ' max_height = maximum on screen height
  ' offset_k| = vertical offset of image
  ' render_spread = spread factor of colours used in rendering
  ' vert_off = vertical screen offset
  ' extent = number of points (width) on the imaginary axis
  '
  ' _i, _j, _k = postfix components of vectors
  '
  DIM col_height(199)             ! COLUMN OF HEIGHTS
  DIM shd_height(199)             ! COLUMN OF SHADOW HEIGHTS
  '
  RESTORE cpm_data
  FOR n|=0 TO 15
    READ b|,g|,r|
    VSETCOLOR n|,r|,g|,b|
  NEXT n|
  '
cpm_data:
  DATA 5,3,3,0,0,7,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,1,7
  DATA 0,2,7,0,3,7,0,4,7,1,5,7,2,6,7,3,7,7,4,7,7,5,7,7
  '
  ' position of light source
  lambda=lambda|*PI/180
  l_i=-COS(lambda)                ! REVERSED AS VECTOR FROM p TO s
  l_k=SIN(lambda)                 ! j COMPONENT IS 0
  '
  ' view angle and position of view vector
  phi=phi|*PI/180
  v_j=-COS(phi)                   ! i COMPONENT IS 0
  sin_phi=SIN(phi)
  v_k=sin_phi
  '
  fd=1-fs                         ! FACTOR OF DIFFUSE LIGHT.
  render_spread|=21
  max_height=max_height|*0.0125/re_step          ! SCALES HEIGHT WITH ZOOM
  level=COS(phi)*max_height
  offset&=level+vert_off|         ! SHIFT PICTURE DOWN BY THIS MUCH.
  shd_k=TAN(lambda)/max_height    ! AMOUNT POINTS IN SHADOW MUST BE BELOW.
  '
  re_centre=re_min+160*re_step
  im_centre=im_min+100*re_step
  im_step=re_step/sin_phi
  im_min=im_centre-im_step*extent|/2
  n_k=(1+1/sin_phi)/2                 ! k COMPONENT OF SURFACE NORMAL VECTOR.
  n_k2=n_k*n_k
  '
  '
  FOR a&=-1 TO 319                                 ! DRAWING LOOPS
    '
    p_i=re_min+a&*re_step
    old_scr_y&=199
    old_shd&=5
    '
    FOR b&=0 TO extent|
      '
      p_j=im_min+(extent|-b&)*im_step
      '
      SELECT type|
      CASE 0
        '
        cpm_init_fl
        cpm_quad_calc(p_k)
        '
      CASE 1
        '
        cpm_init_fl
        cpm_conj_calc(p_k)
        '
      CASE 2
        '
        i&=0
        '
        IF mandel!
          x=0
          y=0
          temp_re=p_i
          temp_im=p_j
        ELSE
          temp_re=real_c
          temp_im=imag_c
          x=p_i
          y=p_j
        ENDIF
        '
        cpm_spid_calc(p_k)
        '
      CASE 3
        '
        cpm_init_fl
        temp_re=0
        temp_im=0
        cpm_fish_calc(p_k)
        '
      CASE 4
        '
        cpm_init_fl
        cpm_cub1_calc(p_k)
        '
      CASE 5
        '
        i&=0
        '
        IF mandel!
          x=0.5773502691896             ! sqr(1/3)
          y=0
          real_c=p_i
          imag_c=p_j
        ELSE
          x=p_i
          y=p_j
        ENDIF
        '
        cpm_cub2_calc(p_k)
        '
      ENDSELECT
      '
      IF NOT (b&=0 OR a&=-1)
        '
        scr_y&=b&-p_k*level+offset&               ! yCO-ORD OF POINT TO BE PLOTTED
        '
        IF i&=max_it&
          '
          shd_height(b&)=1                        ! UPDATE SHADOW HEIGHT.
          '
          IF scr_y&>-1 AND scr_y&<200
            PSET a&,scr_y&,15
          ENDIF
          '
        ELSE
          intensity
          '
          IF shd_height(b&)-p_k>shd_k             ! DETERMINE IF POINT IS :
            shd_col&=2                            ! IN SHADOW
            SUB shd_height(b&),shd_k              ! UPDATE SHADOW HEIGHT
          ELSE
            shd_col&=5                            ! IN THE LIGHT
            shd_height(b&)=p_k                    ! UPDATE SHADOW HEIGHT
          ENDIF
          '
          intens_colour(intens,shd_col&,a&,scr_y&)        ! PLOT POINT
          '
        ENDIF
        '
        '
        y_gap&=scr_y&-old_scr_y&-1                ! THE NUMBER OF MISSING PIXELS
        IF y_gap&>0
          '
          y_gap_1&=y_gap&+1
          temp_intens=old_intens
          intens_step=(intens-old_intens)/y_gap_1&
          temp_shd=old_shd&
          shd_step=(shd_col&-old_shd&)/y_gap_1&
          '
          FOR temp_b&=old_scr_y&+1 TO scr_y&-1
            '
            ADD temp_intens,intens_step
            ADD temp_shd,shd_step
            temp_shd&=temp_shd
            intens_colour(temp_intens,temp_shd&,a&,temp_b&)
            '
          NEXT temp_b&
          '
        ENDIF
        '
        old_scr_y&=scr_y&
        old_shd&=shd_col&
        old_intens=intens
        '
      ELSE
        '
        shd_height(b&)=p_k
        '
      ENDIF
      '
      col_height(b&)=p_k
      '
      IF MOUSEK=2
        finish(3)
      ENDIF
      '
    NEXT b&
    '
  NEXT a&
  '
  ERASE col_height()
  ERASE shd_height()
  '
  '
RETURN
'
'
' CALC SINGLE POINT ROUTINES:
> PROCEDURE cpm_quad_calc(VAR height)
  '
  REPEAT
    x2=x*x
    y2=y*y
    y=2*x*y+imag_c
    x=x2-y2+real_c
    INC i&
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(2^i&))
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cpm_conj_calc(VAR height)
  '
  REPEAT
    y2=y*y
    x2=x*x
    y=-2*x*y+imag_c
    x=x2-y2+real_c
    INC i&
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(2^i&))
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cpm_spid_calc(VAR height)
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    y=2*x*y+temp_im
    x=x2-y2+temp_re
    temp_re=x+0.5*temp_re
    temp_im=y+0.5*temp_im
    INC i&
    '
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(2^i&))
  ENDIF
  '
RETURN
'
'
> PROCEDURE cpm_fish_calc(VAR height)
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    f=x
    g=y
    y=2*x*y+temp_im+imag_c
    x=x2-y2+temp_re+real_c
    temp_re=f
    temp_im=g
    INC i&
    '
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(2^i&))
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cpm_cub1_calc(VAR height)
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    x3=x2*x
    y3=y2*y
    x=x*(x2-3*y2)+real_c
    y=y*(3*x2-y2)+imag_c
    INC i&
    '
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(3^i&))
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cpm_cub2_calc(VAR height)
  '
  REPEAT
    '
    y2=y*y
    x2=x*x
    x=x*(x2-3*y2-1)+real_c
    y=y*(3*x2-y2-1)+imag_c
    INC i&
    '
  UNTIL (NOT x2+y2<10000) OR i&=max_it&
  '
  IF i&=max_it&
    height=1
  ELSE
    height=1-SQR(0.5*LOG(x2+y2)/(3^i&))
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cpm_init_fl
  '
  ' INITIALISES VARIABLES FOR CPM METHOD.
  '
  i&=0
  '
  IF mandel!
    real_c=p_i
    imag_c=p_j
    x=0
    y=0
  ELSE
    x=p_i
    y=p_j
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE intensity
  '
  ' CALCULATES INTENSITY OF POINT.
  ' SURFACE NORMAL OF POINT IS FOUND BY COMPARING TO POINTS TO LEFT AND ABOVE.
  ' c_... IS THE COSINE OF ANGLE BETWEEN VECTORS : CALCULATED USING THE SCALAR
  ' PRODUCT DIVIDED BY PRODUCT OF LENGTHS.
  '
  n_i=max_height*(col_height(b&)-p_k)   ! col_height(b&) IS HEIGHT TO LEFT
  n_j=max_height*(p_k-col_height(b&-1)) ! AND col_height(b&-1) IS HEIGHT ABOVE.
  mod_n=SQR(n_i*n_i+n_j*n_j+n_k2)        ! =|n|=SQR(n.n)
  c_theta=(n_i*l_i+n_k*l_k)/mod_n        ! =n.l/(|n||l|) AS l_j=0, |l|=1
  '
  IF c_theta<0                          ! POINT FACING AWAY FROM THE LIGHT.
    intens=0
  ELSE
    two_c_theta=2*c_theta
    r_i=two_c_theta*n_i-l_i             ! CALCULATE REFLECTED LIGHT VECTOR.
    r_j=two_c_theta*n_j                 ! l_j=0
    r_k=two_c_theta*n_k-l_k
    mod_r=SQR(r_i*r_i+r_j*r_j+r_k*r_k)          ! =|r|
    c_alpha=(v_j*r_j+v_k*r_k)/mod_r             ! =v.r/(|v||r|) AS v_i=0, |v|=1
    intens=fd*c_theta+fs*c_alpha^s_e|
  ENDIF
  '
RETURN
'
'
> PROCEDURE intens_colour(intens,shd_col&,x&,y&)
  '
  ' DETERMINES COLOUR OF POINT TO BE PLOTTED (AT x&,y&) GIVEN INTENSITY AND
  ' WHETHER POINT IS IN SHADOW OR NOT : shd_col&=2 (SHADOW) OR 5 (LIGHT)
  '
  LOCAL col&
  col&=intens*render_spread|
  '
  IF col&<1
    c&=shd_col&
  ELSE IF col&>20
    c&=10+shd_col&
  ELSE IF col& MOD 2=0 OR (x&+y&) MOD 2=0
    c&=SHR&(col&,1)+shd_col&
  ELSE
    c&=SHR&(col&,1)+shd_col&+1
  ENDIF
  '
  IF y&>-1 AND y&<200
    '
    PSET x&,y&,col_index|(c&)
    '
  ENDIF
  '
  '
RETURN
'
' **********************  GENERAL COMPLEX ROUTINES  ****************************
'
> PROCEDURE sphere_init
  '
  ' NOTE rad& IS THE ON SCREEN RADIUS OF THE SPHERE
  LOCAL t_rad&
  '
  t_rad&=rad&+1
  x0&=centre_x&-t_rad&
  x1&=centre_x&+t_rad&
  y0&=centre_y&-t_rad&
  y1&=centre_y&+t_rad&
  '
  rad=x_step*99                ! Real radius of sphere.
  rad_sqrd=rad*rad
  scale=99/rad&
  offset_x=159-scale*centre_x&
  offset_y=99-scale*centre_y&
  p_i_min=-160*x_step
  p_j_min=-rad
  re_centre=x_min-p_i_min
  im_centre=y_min-p_j_min
  '
  mod_l=SQR(l_i*l_i+l_j*l_j+l_k*l_k)
  v_k=-1                  ! v_i,v_j=0, constant view vector
  fd=1-fs                 ! Contribution from non-shinny component
  ia=0
  render_spread|=20
  '
  '
RETURN
'
'
> PROCEDURE as_init
  '
  ' INITIALIZES VARIABLES FOR USE IN ASSEMBLY CALCULTION ROUTINES.
  '
  ' THESE VARIABLES SHOULD BE SET  : type|,bit_16!,x_min,y_min,x_step,c_re,c_im
  '
  ' THE ONLY DIFFERENCE BETWEEN SETTING UP FOR M AND J IS THE C VALUE AND THE
  ' INITIAL x & x2 FOR CUBIC 2 TYPE WHICH THIS ROUTINE ALWAYS SETS ANYWAY.
  '
  DIM real%(319),imag%(199)
  max_it&=max_it&-3             ! ASSEMBLY ROUTINES DO AN EXTRA 3 ITERS????
  address%=V:mach_code$+28      ! IGNORE FIRST 28 BYTES OF FILE (HEADER??)
  '
  IF bit_16!
    '
    mult%=4096                                  ! 16 BIT FRACTAL TO BE DRAWN
    jul_div%=1                                  ! JULIA ONLY
    address%=address%+adr_off_16&(type|)
    '
  ELSE
    '
    mult%=33554432                              ! 32 BIT FRACTAL TO BE DRAWN
    address%=address%+adr_off_32&(type|)
    jul_div%=mult%
    '
    IF type|=5                                  ! EG CUBIC 2
      '
      init_x%=SQR(1/3)*mult%                    ! MANDEL ONLY
      init_x2%=(1/3)*mult%
      '
    ELSE
      '
      init_x%=0
      init_x2%=0
      '
    ENDIF
    '
  ENDIF
  '
  '
  FOR a&=0 TO x_max&
    '
    real=x_min+a&*x_step
    real%(a&)=real*mult%
    '
  NEXT a&
  '
  FOR b&=0 TO y_max&
    '
    real=y_min+(y_max&-b&)*x_step
    imag%(b&)=real*mult%
    '
  NEXT b&
  '
  c_re%=c_re*mult%                      ! JULIA SET ONLY
  c_im%=c_im*mult%
  '
  '
RETURN
'
'
> PROCEDURE init_fl_point
  '
  ' INITIALISES VARIABLES FOR FLOATING POINT ALGORITHMS.
  '
  i&=0
  '
  IF mandel!
    '
    x=0
    y=0
    c_re=real(a&)
    c_im=imag(b&)
    '
  ELSE
    '
    x=real(a&)
    y=imag(b&)
    '
  ENDIF
  '
RETURN
'
'
> PROCEDURE lem_plot
  '
  ' CALLS _lem_plot ROUTINES DEPENDENT ON FRACTAL TYPE. THIS PART IS
  ' INTERACTIVE PROVIDED alerts!=TRUE.
  '
  choice|=1
  '
  REPEAT
    '
    IF type|<9
      basic_lem_plot
      '
    ELSE IF type|=9
      newt_lem_plot
      '
    ELSE
      deg4_lem_plot
      '
    ENDIF
    '
    '
    IF alerts!
      '
      SHOWM
      WHILE MOUSEK=0
      WEND
      setcols(0,0,0,0,0,0)
      ALERT 2,"Boundary|OK ?",1,"Yes|No",choice|
      '
      IF choice|=2
        enter_word(1,1,"BOUND = ",4,0,10000,V:bound&)
        '
      ENDIF
      '
    ENDIF
    '
    select_pal
    '
  UNTIL choice|=1
  '
  '
RETURN
'
'
> PROCEDURE basic_lem_plot
  '
  ' PLOT'S M/J (BUT NOT DEG4/NEWT FRACTALS), DESCRIBED BY iters&(), WITH A
  ' BOUNDARY USING COLOUR 1.
  '
  ' VARIABLE ABBREVIATIONS ..._i& = ITERS VARIABLE, _x& AND _y& = SCREEN COORDS
  ' up_.., dwn_.., lft_.., rt_.. = OFFSETS FOR SPEED OPTIMIZATION.
  '
  LOCAL x&,y&,lft_x&,rt_x&,up_y&,dwn_y&,i&,temp_i&,up_i&,dwn_i&,rt_i&,lft_i&
  '
  '
  ' PLOT SCREEN EXCEPT FOR LAST ROW AND COLLUMN.
  '
  lft_x&=0
  rt_x&=1
  '
  FOR x&=0 TO x_max&-1
    '
    i&=iters&(x&,0)
    up_i&=i&                    ! REALLY iters&(x&,-1) BUT THAT DOES NOT EXIST.
    dwn_y&=1
    '
    FOR y&=0 TO y_max&-1
      '
      dwn_i&=iters&(x&,dwn_y&)
      '
      IF i&=max_it&
        '
        PSET x&,y&,0
        '
      ELSE
        '
        lft_i&=iters&(lft_x&,y&)
        rt_i&=iters&(rt_x&,y&)
        dif&=MAX(i&-lft_i&,i&-rt_i&,i&-up_i&,i&-dwn_i&)
        '
        IF dif&<bound&
          PSET x&,y&,col_index|(i& MOD 14+2)    ! NOT A BOUNDARY POINT.
        ELSE
          PSET x&,y&,15                         ! A BOUNDARY POINT.
        ENDIF
        '
      ENDIF
      '
      INC dwn_y&
      up_i&=i&
      i&=dwn_i&
      '
    NEXT y&
    '
    INC rt_x&
    lft_x&=x&
    '
  NEXT x&
  '
  '
  ' PLOT LAST COLLUMN.
  '
  dwn_y&=1
  i&=iters&(x_max&,0)
  up_i&=i&                    ! iters&(X_MAX&,-1) DOES NOT EXIST
  lft_x&=x_max&-1
  '
  FOR y&=0 TO y_max&-1
    '
    dwn_i&=iters&(x_max&,dwn_y&)
    '
    IF i&=max_it&
      '
      PSET x_max&,y&,0
      '
    ELSE
      '
      lft_i&=iters&(lft_x&,y&)
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-dwn_i&)
      '
      IF dif&<bound&
        PSET x_max&,y&,col_index|(i& MOD 14+2)
      ELSE
        PSET x_max&,y&,15
      ENDIF
      '
    ENDIF
    '
    INC dwn_y&
    up_i&=i&
    i&=dwn_i&
    '
  NEXT y&
  '
  '
  ' PLOT LAST ROW
  '
  rt_x&=1
  i&=iters&(0,y_max&)
  lft_i&=i&                    ! iters&(-1,y_max&) DOES NOT EXIST
  up_y&=y_max&-1
  '
  FOR x&=0 TO x_max&-1
    '
    rt_i&=iters&(rt_x&,y_max&)
    '
    IF i&=max_it&
      '
      PSET x&,y_max&,0
      '
    ELSE
      '
      up_i&=iters&(x&,up_y&)
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-rt_i&)
      '
      IF dif&<bound&
        PSET x&,y_max&,col_index|(i& MOD 14+2)
      ELSE
        PSET x&,y_max&,15
      ENDIF
      '
    ENDIF
    '
    INC rt_x&
    lft_i&=i&
    i&=rt_i&
    '
  NEXT x&
  '
  '
  ' PLOT BOTTOM RIGHT PIXEL
  '
  i&=iters&(x_max&,y_max&)
  dif&=MAX(i&-iters&(x_max&-1,ymax&),i&-iters&(x_max&,y_max&-1))
  '
  IF dif&<bound&
    PSET x_max&,y_max&,col_index|(i& MOD 14+2)
  ELSE
    PSET x_max&,y_max&,15
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE newt_lem_plot
  '
  ' AS basic_lem_plot EXCEPT THERE ARE 3 EXTERNAL REGIONS WITH THIS TYPE AND
  ' THESE ARE DEALT WITH DIFFERENTLY.
  '
  LOCAL x&,y&,lft_x&,rt_x&,up_y&,dwn_y&,i&,temp_i&,up_i&,dwn_i&,rt_i&,lft_i&
  LOCAL new_temp&
  '
  lft_x&=0
  rt_x&=1
  '
  FOR x&=0 TO x_max&-1
    '
    temp_i&=iters&(x&,0)
    i&=ABS(temp_i&)+(temp_i&>9999)*10000     ! ITERS TRANSFORMATION FOR NEWT
    up_i&=i&
    dwn_y&=1
    '
    FOR y&=0 TO y_max&-1
      '
      new_temp&=iters&(x&,dwn_y&)
      dwn_i&=ABS(new_temp&)+(new_temp&>9999)*10000
      '
      IF i&=max_it&
        '
        PSET x&,y&,0
        '
      ELSE
        '
        lft_i&=iters&(lft_x&,y&)
        lft_i&=ABS(lft_i&)+(lft_i&>9999)*10000
        rt_i&=iters&(rt_x&,y&)
        rt_i&=ABS(rt_i&)+(rt_i&>9999)*10000
        dif&=MAX(i&-lft_i&,i&-rt_i&,i&-up_i&,i&-dwn_i&)
        '
        IF dif&<bound&
          '
          IF temp_i&<0
            PSET x&,y&,col_index|(i& MOD 5+6)
          ELSE IF temp_i&<10000
            PSET x&,y&,col_index|(i& MOD 4+2)
          ELSE
            PSET x&,y&,col_index|(i& MOD 5+11)
          ENDIF
          '
        ELSE
          PSET x&,y&,15
        ENDIF
        '
      ENDIF
      '
      INC dwn_y&
      up_i&=i&
      i&=dwn_i&
      temp_i&=new_temp&
      '
    NEXT y&
    '
    INC rt_x&
    lft_x&=x&
    '
  NEXT x&
  '
  ' PLOT LAST COLLUMN.
  '
  dwn_y&=1
  temp_i&=iters&(x_max&,0)
  i&=ABS(temp_i&)+(temp_i&>9999)*10000
  up_i&=i&
  lft_x&=x_max&-1
  '
  FOR y&=0 TO y_max&-1
    '
    new_temp&=iters&(x_max&,dwn_y&)
    dwn_i&=ABS(new_temp&)+(new_temp&>9999)*10000
    '
    IF i&=max_it&
      '
      PSET x_max&,y&,0
      '
    ELSE
      '
      lft_i&=iters&(lft_x&,y&)
      i&=ABS(lft_i&)+(lft_i&>9999)*10000
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-dwn_i&)
      '
      IF dif&<bound&
        '
        IF temp_i&<0
          PSET x_max&,y&,col_index|(i& MOD 5+6)
        ELSE IF temp_i&<10000
          PSET x_max&,y&,col_index|(i& MOD 4+2)
        ELSE
          PSET x_max&,y&,col_index|(i& MOD 5+11)
        ENDIF
        '
      ELSE
        PSET x_max&,y&,15
      ENDIF
      '
    ENDIF
    '
    INC dwn_y&
    up_i&=i&
    i&=dwn_i&
    temp_i&=new_temp&
    '
  NEXT y&
  '
  ' PLOT LAST ROW
  '
  rt_x&=1
  temp_i&=iters&(0,y_max&)
  i&=ABS(temp_i&)+(temp_i&>9999)*10000
  lft_i&=i&
  up_y&=y_max&-1
  '
  FOR x&=0 TO x_max&-1
    '
    new_temp&=iters&(rt_x&,y_max&)
    rt_i&=ABS(new_temp&)+(new_temp&>9999)*10000
    '
    IF i&=max_it&
      '
      PSET x&,y_max&,0
      '
    ELSE
      '
      up_i&=iters&(x&,up_y&)
      up_i&=ABS(up_i&)+(up_i&>9999)*10000
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-rt_i&)
      '
      IF dif&<bound&
        '
        IF temp_i&<0
          PSET x&,y_max&,col_index|(i& MOD 5+6)
        ELSE IF temp_i&<10000
          PSET x&,y_max&,col_index|(i& MOD 4+2)
        ELSE
          PSET x&,y_max&,col_index|(i& MOD 5+11)
        ENDIF
        '
      ELSE
        PSET x&,y_max&,15
      ENDIF
      '
    ENDIF
    '
    INC rt_x&
    lft_i&=i&
    i&=rt_i&
    temp_i&=new_temp&
    '
  NEXT x&
  '
  ' PLOT BOTTOM RIGHT PIXEL
  ' rt_i& FROM ABOVE LOOP HOLDS THE NUM ITS FOR THIS PIXEL
  '
  i&=rt_i&
  temp_i&=iters&(x_max&,y_max&)
  lft_i&=iters&(x_max&-1,y_max&)
  lft_i&=ABS(lft_i&)+(lft_i&>9999)*10000
  up_i&=iters&(x_max&,y_max&-1)
  up_i&=ABS(up_i&)+(up_i&>9999)*10000
  dif&=MAX(i&-lft_i&,i&-up_i&)
  '
  IF dif&<bound&
    '
    IF temp_i&<0
      PSET x_max&,y_max&,col_index|(i& MOD 5+6)
    ELSE IF temp_i&<10000
      PSET x_max&,y_max&,col_index|(i& MOD 4+2)
    ELSE
      PSET x_max&,y_max&,col_index|(i& MOD 5+11)
    ENDIF
    '
  ELSE
    PSET x_max&,y_max&,15
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE deg4_lem_plot
  '
  LOCAL x&,y&,lft_x&,rt_x&,up_y&,dwn_y&,i&,temp_i&,up_i&,dwn_i&,rt_i&,lft_i&
  '
  ' PLOT SCREEN EXCEPT FOR LAST ROW AND COLLUMN.
  '
  lft_x&=0
  rt_x&=1
  '
  FOR x&=0 TO x_max&-1
    '
    temp_i&=iters&(x&,0)
    i&=ABS(temp_i&)                  ! ITERS TRANSFORMATION FOR DEG4
    up_i&=i&                    ! REALLY iters&(x&,-1) BUT THAT DOES NOT EXIST.
    dwn_y&=1
    '
    FOR y&=0 TO y_max&-1
      '
      new_temp&=iters&(x&,dwn_y&)
      dwn_i&=ABS(new_temp&)
      '
      IF i&=max_it&
        '
        PSET x&,y&,0
        '
      ELSE
        '
        lft_i&=ABS(iters&(lft_x&,y&))
        rt_i&=ABS(iters&(rt_x&,y&))
        dif&=MAX(i&-lft_i&,i&-rt_i&,i&-up_i&,i&-dwn_i&)
        '
        IF dif&<bound&
          '
          IF temp_i&<0
            PSET x&,y&,col_index|(i& MOD 7+9)
          ELSE
            PSET x&,y&,col_index|(i& MOD 7+2)
          ENDIF
          '
        ELSE
          PSET x&,y&,15
        ENDIF
        '
      ENDIF
      '
      INC dwn_y&
      up_i&=i&
      i&=dwn_i&
      temp_i&=new_temp&
      '
    NEXT y&
    '
    INC rt_x&
    INC lft_x&
    '
  NEXT x&
  '
  '
  ' PLOT LAST COLLUMN.
  '
  dwn_y&=1
  temp_i&=iters&(x_max&,0)
  i&=ABS(temp_i&)
  up_i&=i&                    ! iters&(X_MAX&,-1) DOES NOT EXIST
  lft_x&=x_max&-1
  '
  FOR y&=0 TO y_max&-1
    '
    temp_i&=iters&(x_max&,dwn_y&)
    dwn_i&=ABS(new_temp&)+(new_temp&>9999)*10000
    '
    IF i&=max_it&
      '
      PSET x_max&,y&,0
      '
    ELSE
      '
      lft_i&=ABS(iters&(lft_x&,y&))
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-dwn_i&)
      '
      IF dif&<bound&
        '
        IF temp_i&<0
          PSET x_max&,y&,col_index|(i& MOD 7+9)
        ELSE
          PSET x_max&,y&,col_index|(i& MOD 7+2)
        ENDIF
        '
      ELSE
        PSET x_max&,y&,15
      ENDIF
      '
    ENDIF
    '
    INC dwn_y&
    up_i&=i&
    i&=dwn_i&
    temp_i&=new_temp&
    '
  NEXT y&
  '
  '
  ' PLOT LAST ROW
  '
  rt_x&=1
  temp_i&=iters&(0,y_max&)
  i&=ABS(temp_i&)
  lft_i&=i&
  up_y&=y_max&-1
  '
  FOR x&=0 TO x_max&-1
    '
    new_temp&=iters&(rt_x&,y_max&)
    rt_i&=ABS(new_temp&)
    '
    IF i&=max_it&
      '
      PSET x&,y_max&,0
      '
    ELSE
      '
      up_i&=ABS(iters&(x&,up_y&))
      dif&=MAX(i&-lft_i&,i&-up_i&,i&-rt_i&)
      '
      IF dif&<bound&
        '
        IF temp_i&<0
          PSET x&,y_max&,col_index|(i& MOD 7+9)
        ELSE
          PSET x&,y_max&,col_index|(i& MOD 7+2)
        ENDIF
        '
      ELSE
        PSET x&,y_max&,15
      ENDIF
      '
    ENDIF
    '
    INC rt_x&
    lft_i&=i&
    i&=rt_i&
    temp_i&=new_temp&
    '
  NEXT x&
  '
  ' PLOT BOTTOM RIGHT PIXEL
  '
  i&=rt_i&
  temp_i&=iters&(x_max&,y_max&)
  lft_i&=ABS(iters&(x_max&-1,y_max&))
  up_i&=ABS(iters&(x_max&,y_max&-1))
  dif&=MAX(i&-lft_i&,i&-up_i&)
  '
  IF dif&<bound&
    '
    IF temp_i&<0
      PSET x_max&,y_max&,col_index|(i& MOD 7+9)
    ELSE
      PSET x_max&,y_max&,col_index|(i& MOD 7+2)
    ENDIF
    '
  ELSE
    PSET x_max&,y_max&,15
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE complex_array
  '
  ' INITIALISES ARRAY OF X AND Y CO-ORDS FOR USE WITH FLOATING PT ROUTINES.
  '
  FOR a&=0 TO x_max&
    real(a&)=x_min+a&*x_step
  NEXT a&
  '
  FOR b&=0 TO y_max&
    imag(b&)=y_min+(y_max&-b&)*x_step
  NEXT b&
  '
  converge=0.04*x_step          ! USED BY NEWT AND DEG4 IN CONVERGENCE TESTS
  converge_2=2*converge
  '
RETURN
'
' ==============================================================================
'                          OTHER TYPES DRAWING ROUTINES
' ==============================================================================
'
> PROCEDURE popcorn(x_min,y_min,x_step,spread|,max_it&,grid&)
  '
  ' DR PICKOVER POPCORN
  ' SET xs&,ys& = (slow) 1,2,4,5,8 or 10 (fast). GRID DIMENSIONS.
  ' default coords : x_min=-6, y_min=-3.75, x_step=0.0375, max_it&=30
  '                  GRID&=5
  scr=1/x_step
  s&=-3*grid&       ! START PLOTTING OFF THE SCREEN SO IMAGE LOOKS UNIFORM
  s&=0
  '
  FOR a&=s& TO 320-s& STEP grid&       ! DITTO - FOR END OF PLOT.
    '
    FOR b&=s& TO 200-s& STEP grid&
      '
      x=x_min+x_step*a&
      y=y_min+x_step*(199-b&)
      c|=(b& DIV spread|+15) MOD 15+1
      COLOR c|
      '
      FOR n&=1 TO max_it&
        '
        q=x
        x=x-x_step*SIN(y+TAN(3*y))
        y=y-x_step*SIN(q+TAN(3*q))
        PLOT scr*(x-x_min),scr*(y_min-y)+199
        '
        IF MOUSEK=2
          finish(4)
        ENDIF
        '
      NEXT n&
      '
    NEXT b&
    '
  NEXT a&
  '
  '
RETURN
'
'
> PROCEDURE ws_dla(sym,spread&,seed%,stik_prob)
  '
  ' (Almost) Witten-Saunders Diffusion Limited Aggregation
  ' GROWS A MOSS LIKE STRUCTURE FROM THE CENTRE OF THE SCREEN.
  '
  DIM x_off&(3)         ! x OFFSETS - 0=UP, 1=LEFT, 2=RIGHT, 3=DOWN.
  DIM y_off&(3)         ! y OFFSETS - DITTO.
  '
  RESTORE ws_dat
  '
  FOR n|=0 TO 3
    READ x_off&(n|)
    READ y_off&(n|)
  NEXT n|
  '
  FOR n|=0 TO 15
    READ col&
    SETCOLOR n|,col&
  NEXT n|
  '
ws_dat:
  '
  DATA 0,-1,-1,0,1,0,0,1,0,1797,1795,1824,1840,1856,1872,1888
  DATA 1904,1648,1392,1136,1140,1654,1911,1799
  '
  i%=0
  r&=4
  PSET 160,100,15
  RANDOMIZE seed%
  '
  REPEAT
    '
  new_particle:
    '
    theta=RND*360
    temp_x&=r&*COSQ(theta)+160.5
    temp_y&=r&*SINQ(theta)+100.5
  again:
    x&=temp_x&
    y&=temp_y&
    n|=0
    '
  chk_nbr:                              ! CHECK NEIGHBOURING CELLS.
    '
    IF NOT PTST(x&+x_off&(n|),y&+y_off&(n|))=0
      GOTO stick
    ENDIF
    '
    IF n|<3
      '
      INC n|
      GOTO chk_nbr
      '
    ENDIF
    '
    dist&=INT(SQR((x&-160)^2+(y&-100)^2))
    '
    IF dist&>r&+1
      '
      IF RND<sym
        GOTO again
      ELSE
        GOTO new_particle
      ENDIF
      '
    ENDIF
    '
  move:
    '
    m|=RND*4
    x&=x&+x_off&(m|)
    y&=y&+y_off&(m|)
    n|=0
    GOTO chk_nbr
    '
  stick:
    '
    IF RND>stik_prob
      GOTO move
    ENDIF
    '
    PSET x&,y&,(i% DIV spread&) MOD 15+1
    INC i%
    '
    IF dist&=r&
      INC r&
    ENDIF
    '
    IF MOUSEK=2
      finish(5)
    ENDIF
    '
  UNTIL r&=97
  '
  '
  ERASE x_off&()
  ERASE y_off&()
  '
  '
RETURN
'
'
> PROCEDURE line_dla(spread&,seed%)
  '
  ' CRAPY WEEDY FRACTAL
  '
  DIM weed_min|(319)
  '
  ARRAYFILL weed_min|(),200
  '
  y_min|=200
  i%=0
  RANDOMIZE (seed%)
  '
  REPEAT
    '
  new:
    '
    x&=RND*320
    '
    temp_y|=weed_min|(x&)
    '
    IF NOT x&=0
      '
      IF NOT x&=319
        '
        IF weed_min|(x&-1)<temp_y|
          y|=weed_min|(x&-1)
        ELSE IF weed_min|(x&+1)<temp_y|
          y|=weed_min|(x&+1)
        ELSE
          y|=temp_y|-1
        ENDIF
        '
      ELSE
        '
        IF weed_min|(318)<temp_y|
          y|=weed_min|(318)
        ELSE
          y|=temp_y|-1
        ENDIF
        '
      ENDIF
      '
    ELSE
      '
      IF weed_min|(1)<temp_y|
        y|=weed_min|(1)
      ELSE
        y|=temp_y|-1
      ENDIF
      '
    ENDIF
    '
    weed_min|(x&)=y|
    y_min|=MIN(y|,y_min|)
    PSET x&,y|,col_index|((i% DIV spread&) MOD 15+1)
    INC i%
    '
  UNTIL y_min|=0
  '
  ERASE weed_min|()
  '
RETURN
'
'
> PROCEDURE heights(h,seed%)
  '
  ' 2D Midpoint displacement & successive random additions
  ' Si=Sigma,L=Delta
  '
  PRINT "CALCULATING HEIGHT ARRAY."
  PRINT "PLEASE WAIT (NO ABORT OPTION) ..."
  '
  DEFFN f3(l,x0,x1,x2)=(x0+x1+x2)/3+l*g
  DEFFN f4(l,x0,x1,x2,x3)=(x0+x1+x2+x3)/4+l*g
  '
  rand_add!=FALSE
  half_h=0.5*h
  max_recur|=7
  si=27
  n&=2^max_recur|
  '
  DIM x(n&+2,n&+2)              ! x() IS THE ARRAY OF HEIGHTS (OCCURS ALOT)
  '
  RANDOMIZE seed%
  '
  l=si
  @gauss
  x(1,1)=l*g
  @gauss
  x(1,n&+1)=l*g
  @gauss
  x(n&+1,1)=l*g
  @gauss
  x(n&+1,n&+1)=l*g
  d&=n&
  e&=n& DIV 2
  '
  FOR s%=1 TO max_recur|
    '
    '    PRINT AT(1,6);max_recur|-s%    ! GET RID OF THIS
    l=l*(0.5^(half_h))
    '
    n_pl_1&=n&+1                          ! OPTIMIZATION VARIABLES : THESE TWO
    n_e&=n_pl_1&-e&                       ! REMAIN CONSTANT THRO' S% LOOP
    e_pl_1&=e&+1
    two_e1&=e_pl_1&+e&
    x_pl_e&=two_e1&                       ! THESE DON'T : x+e& STARTS AT 2*e&+1
    x_mi_e&=1                             ! x&-e& STARTS AT e&+1-e&=1
    '
    FOR x&=e_pl_1& TO n_e& STEP d&
      y_pl_e&=two_e1&
      y_mi_e&=1
      '
      FOR y&=e_pl_1& TO n_e& STEP d&
        @gauss
        x(x&,y&)=@f4(l,x(x_pl_e&,y_pl_e&),x(x_pl_e&,y_mi_e&),x(x_mi_e&,y_pl_e&),x(x_mi_e&,y_mi_e&))
        ADD y_pl_e&,d&
        ADD y_mi_e&,d&
      NEXT y&
      '
      ADD x_pl_e&,d&
      ADD x_mi_e&,d&
    NEXT x&
    '
    rand_add!=NOT (rand_add!)
    IF rand_add!
      FOR x&=1 TO n_pl_1& STEP d&
        FOR y&=1 TO n_pl_1& STEP d&
          @gauss
          x(x&,y&)=x(x&,y&)+l*g
        NEXT y&
      NEXT x&
    ENDIF
    l=l*(0.5^(half_h))
    '
    x_pl_e&=two_e1&
    x_mi_e&=1
    '
    FOR x&=e&+1 TO n_e& STEP d&
      @gauss
      x(x&,1)=@f3(l,x(x_pl_e&,1),x(x_mi_e&,1),x(x&,e_pl_1&))
      @gauss
      x(x&,n_pl_1&)=@f3(l,x(x_pl_e&,n_pl_1&),x(x_mi_e&,n_pl_1&),x(x&,n_e&))
      @gauss
      x(1,x&)=@f3(l,x(1,x_pl_e&),x(1,x_mi_e&),x(e_pl_1&,x&))
      @gauss
      x(n_pl_1&,x&)=@f3(l,x(n_pl_1&,x_pl_e&),x(n_pl_1&,x_mi_e&),x(n_e&,x&))
      ADD x_pl_e&,d&
      ADD x_mi_e&,d&
    NEXT x&
    '
    IF s%>1
      '
      x_pl_e&=two_e1&
      x_mi_e&=1
      '
      FOR x&=e_pl_1& TO n_e& STEP d&
        FOR y&=d&+1 TO n_e& STEP d&
          @gauss
          x(x&,y&)=@f4(l,x(x&,y&+e&),x(x&,y&-e&),x(x&+e&,y&),x(x&-e&,y&))
        NEXT y&
        ADD x_pl_e&,d&
        ADD x_mi_e&,d&
      NEXT x&
      '
      FOR x&=d&+1 TO n&-e&+1 STEP d&
        FOR y&=e&+1 TO n&-e&+1 STEP d&
          @gauss
          x(x&,y&)=@f4(l,x(x&,y&+e&),x(x&,y&-e&),x(x&+e&,y&),x(x&-e&,y&))
        NEXT y&
      NEXT x&
    ENDIF
    IF rand_add!
      FOR x&=1 TO n_pl_1& STEP d&
        FOR y&=1 TO n_pl_1& STEP d&
          @gauss
          x(x&,y&)=x(x&,y&)+l*g
        NEXT y&
      NEXT x&
      FOR x&=e_pl_1& TO n_e& STEP d&
        FOR y&=e_pl_1& TO n_e& STEP d&
          @gauss
          x(x&,y&)=x(x&,y&)+l*g
        NEXT y&
      NEXT x&
    ENDIF
    d&=d& DIV 2
    e&=e& DIV 2
  NEXT s%
  '
  ' COMPUTE HIGHEST AND LOWEST POINTS
  high=-1000
  low=1000
  FOR x&=1 TO 128
    FOR y&=1 TO 128
      low=MIN(low,x(x&,y&))
      high=MAX(high,x(x&,y&))
    NEXT y&
  NEXT x&
  '
  IF draw_over!
    SPUT scr$
    '
  ELSE
    CLS
    '
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE cloud_render(frac_dim,seed%)
  '
  ' RENDERS A PLASMA CLOUD IN 4 PASSES.
  '
  heights(frac_dim,seed%)
  dum=16/(high-low)                       ! 16 TO ENSURE 15 COLOURS
  '
  ' PLOT EVERY OTHER POINT - CLOUD DOUBLE THE SIZE OF DATA ARRAY
  '
  FOR x&=1 TO 128
    '
    FOR y&=1 TO 100
      '
      c&=(x(x&,y&)-low)*dum
      '
      IF c&<1
        c&=1
      ELSE IF c&>15
        c&=15
      ENDIF
      '
      PSET SHL&(x&,1)+30,SHL&(y&,1)-2,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  '
  ' INTERPOLATE OTHER POINTS
  '
  FOR x&=1 TO 127
    '
    FOR y&=1 TO 100
      '
      c&=((x(x&,y&)+x(x&+1,y&))/2-low)*dum        ! COLOUR BY MEAN HEIGHT
      '
      IF c&<1
        c&=1
      ELSE IF c&>15
        c&=15
      ENDIF
      '
      PSET SHL&(x&,1)+31,SHL&(y&,1)-2,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  '
  '
  FOR x&=1 TO 128
    '
    FOR y&=1 TO 100
      '
      c&=((x(x&,y&)+x(x&,y&+1))/2-low)*dum
      '
      IF c&<1
        COLOR 1
      ELSE IF c&>15
        COLOR 15
      ENDIF
      '
      PSET SHL&(x&,1)+30,SHL&(y&,1)-1,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  '
  '
  FOR x&=1 TO 127
    '
    FOR y&=1 TO 100
      '
      c&=((x(x&,y&)+x(x&+1,y&)+x(x&,y&+1)+x(x&+1,y&+1))/4-low)*dum
      '
      IF c&<1
        COLOR 1
      ELSE IF c&>15
        COLOR 15
      ENDIF
      '
      PSET SHL&(x&,1)+31,SHL&(y&,1)-1,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  ERASE x()
  '
  '
RETURN
'
'
> PROCEDURE cloud_render2(frac_dim,seed%)
  '
  ' RENDERS CLOUDS USING COLOURS 11 TO 15
  ' PLOTTED AT THE TOP OF THE SCREEN - DATA ARRAY INVERTED
  '
  heights(frac_dim,seed%)
  '
  ' PLOT EVERY THIRD POINT - CLOUD PLOTTED TRIPLE THE WIDTH
  '
  FOR x&=1 TO 107
    '
    x_dum&=3*x&-3
    '
    FOR y&=1 TO 64
      '
      IF x(x&,y&)<0
        c&=14
      ELSE
        c&=15
      ENDIF
      '
      PSET x_dum&,y&-1,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  '
  ' INTERPOLATE OTHER POINTS
  '
  FOR x&=1 TO 107
    '
    x_dum&=x&*3-2
    '
    FOR y&=1 TO 64
      '
      IF x(x&,y&)*0.75+x(x&+1,y&)*0.25<0
        c&=14
      ELSE
        c&=15
      ENDIF
      '
      PSET x_dum&,y&-1,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  '
  '
  FOR x&=1 TO 106
    '
    x_dum&=x&*3-1
    '
    FOR y&=1 TO 64
      '
      IF x(x&,y&)*0.25+x(x&+1,y&)*0.75<0
        c&=14
      ELSE
        c&=15
      ENDIF
      '
      PSET x_dum&,y&-1,col_index|(c&)
      '
    NEXT y&
    '
  NEXT x&
  ERASE x()
  '
  '
RETURN
'
'
> PROCEDURE mount_render(frac_dim,seed%,lambda|,fs,s_e|,max_height|,offset|)
  '
  ' RENDERS HEIGHT ARRAY AS A MOUNTAIN, BY STRETCHING HORIZONTALLY BY A FACTOR
  ' OF THREE.
  ' COLOURS USED : 0:BACKGROUND/SEA ; 1:SEA IN SHADOW ; 2 TO 13:MOUNTAIN
  ' LIGHT SOURCE ANGLE IS lambda (0<lambda<PI/2). DIFFUSE LIGHT CONTRIBUTION
  ' IS fd=1-shinniness=1-fs.
  ' VIEW ANGLE IS FIXED.
  '
  heights(frac_dim,seed%)
  '
  ' LIGHT SOURCE VECTOR :
  lambda=lambda|*PI/180
  l_i=-COS(lambda)              ! REVERSED AS VECTOR FROM p TO s.
  l_k=SIN(lambda)               ! j COMPONENT IS 0.
  '
  fd=1-fs
  '
  phi=ASIN(1/3)                 ! VIEW ANGLE.
  v_j=-COS(phi)                 ! i COMPONENT IS 0.
  v_k=1/3                       ! = SIN(phi)
  '
  level=COS(phi)*max_height|
  shd_k=TAN(lambda)/max_height|
  '
  ' DRAW TOP OF SEA
  DEFFILL 12
  PBOX 0,64,319,199             ! 199 MAKES SURE IT GOES ALL THE WAY DOWN
  '
  DIM shd_height(128)
  '
  '
  FOR b&=1 TO 128
    shd_height(b&)=0
  NEXT b&
  '
  '
  FOR a&=1 TO 128
    FOR b&=1 TO 128
      x(a&,b&)=x(a&,b&)/high
    NEXT b&
  NEXT a&
  '
  '
  FOR a&=0 TO 319                                 ! DRAWING LOOPS
    '
    IF MOUSEK=2
      finish(6)
    ENDIF
    '
    old_scr_y&=199
    old_shd&=6
    temp_a&=a& DIV 3+4
    inter_k=0.25*(a& MOD 3)
    one_mi_inter_k=1-inter_k
    '
    FOR b&=2 TO 128
      '
      ' HEIGHT OF CURRENT POINT
      x_c=x(temp_a&,b&)                                 ! CURRENT POINT
      p_k=x_c*one_mi_inter_k+x(temp_a&+1,b&)*inter_k
      '
      IF p_k<0
        '
        scr_y&=b&+offset|                     ! POINT IN THE SEA
        IF shd_height(b&)>shd_k               ! DETERMINE IF POINT IS :
          c&=1                                ! IN SHADOW
        ELSE
          c&=0                                ! IN THE LIGHT
        ENDIF
        SUB shd_height(b&),shd_k              ! UPDATE SHADOW HEIGHT
        '
        IF scr_y&>-1 AND scr_y&<200
          PSET a&,scr_y&,col_index|(c&)
        ENDIF
        '
      ELSE
        '
        ' CALCULATE INTENSITY OF POINT.
        ' SURFACE NORMAL OF POINT IS FOUND BY COMPARING TO POINTS TO LEFT AND
        ' ABOVE. c_... IS THE COSINE OF ANGLE BETWEEN VECTORS : CALCULATED USING
        ' THE SCALAR PRODUCT DIVIDED BY PRODUCT OF LENGTHS.
        '
        ' INTERPOLATE SURFACE NORMAL
        ' NOTE : k COMPONENT OF SURFACE NORMAL VECTOR=(1+1/SIN(phi))/2=2.
        n_i=max_height|*(x(temp_a&-1,b&)*one_mi_inter_k+x_c*inter_k-p_k)
        n_j=max_height|*(p_k-x(temp_a&,b&-1)*one_mi_inter_k-x(temp_a&+1,b&-1)*inter_k)
        mod_n=SQR(n_i*n_i+n_j*n_j+4)            ! =|n|=SQR(n.n).
        c_theta=(n_i*l_i+2*l_k)/mod_n           ! =n.l/(|n||l|) AS l_j=0, |l|=1.
        '
        IF c_theta<0                    ! POINT FACING AWAY FROM THE LIGHT.
          intens=0
        ELSE
          '
          two_c_theta=2*c_theta
          r_i=two_c_theta*n_i-l_i       ! CALCULATE REFLECTED LIGHT VECTOR.
          r_j=two_c_theta*n_j           ! l_j=0.
          r_k=two_c_theta*2-l_k
          mod_r=SQR(r_i*r_i+r_j*r_j+r_k*r_k)    ! =|r|.
          c_alpha=(v_j*r_j+v_k*r_k)/mod_r       ! =v.r/(|v||r|) AS v_i=0, |v|=1.
          intens=fd*c_theta+fs*c_alpha^s_e|
          '
        ENDIF
        '
        IF shd_height(b&)-p_k>shd_k             ! DETERMINE IF POINT IS :
          shd_col&=0                            ! *IN SHADOW,
          SUB shd_height(b&),shd_k              ! UPDATE SHADOW HEIGHT
        ELSE
          shd_col&=4                            ! *IN THE LIGHT.
          shd_height(b&)=p_k
        ENDIF
        '
        scr_y&=b&-p_k*level+offset|
        rmd_intens_col(intens,shd_col&,a&,scr_y&)       ! PLOT POINT.
        '
      ENDIF
      '
      '
      y_gap&=scr_y&-old_scr_y&-1                ! THE NUMBER OF MISSING PIXELS
      IF y_gap&>0
        '
        y_gap_1&=y_gap&+1
        temp_intens=old_intens
        intens_step=(intens-old_intens)/y_gap_1&
        temp_shd=old_shd&
        shd_step=(shd_col&-old_shd&)/y_gap_1&
        '
        FOR temp_b&=old_scr_y&+1 TO scr_y&-1
          '
          ADD temp_intens,intens_step
          ADD temp_shd,shd_step
          temp_shd&=temp_shd
          rmd_intens_col(temp_intens,temp_shd&,a&,temp_b&)
          '
        NEXT temp_b&
        '
      ENDIF
      '
      old_scr_y&=scr_y&
      old_shd&=shd_col&
      old_intens=intens
      '
    NEXT b&
    IF old_scr_y&<199
      COLOR 0
      LINE a&,scr_y&+1,a&,199
    ENDIF
    '
  NEXT a&
  ERASE x(),shd_height()
  '
  '
RETURN
'
'
> PROCEDURE rmd_intens_col(intens,shd_col&,x&,y&)
  '
  ' DETERMINES COLOUR OF POINT TO BE PLOTTED (AT x&,y&) GIVEN INTENSITY AND
  ' WHETHER POINT IS IN SHADOW OR NOT : shd_col&=0 (SHADOW) OR 4 (LIGHT)
  '
  LOCAL col&
  col&=intens*16                                ! render_spread=16
  '
  IF col&<1
    c&=shd_col&
  ELSE IF col&>14                               ! 14 SHADES : 7 COLOURS
    c&=7+shd_col&
  ELSE IF col& MOD 2=0 OR (x&+y&) MOD 2=0
    c&=SHR&(col&,1)+shd_col&
  ELSE
    c&=SHR&(col&,1)+shd_col&+1
  ENDIF
  '
  IF y&>-1 AND y&<200
    PSET x&,y&,col_index|(c&+2)
  ENDIF
  '
  '
RETURN
'
'
> PROCEDURE gauss
  '
  ' RETURNS A RANDOM NUMBER WITH A NORMAL DISTIBUTION
  ' SEE TSOFI : NRAND=4, ARAND=1 (AS 0<RND<1), GAUSSADD=SQR(12)=3.464101515
  ' => GAUSSFAC=2*GAUSSADD/(NRAND*ARAND)=1.732050807569
  s=0
  '
  FOR i%=1 TO 4
    s=s+RND
  NEXT i%
  '
  g=1.732051*s-3.464102
  '
  '
RETURN
'
' ==============================================================================
'                       GENERAL DRAWING RELATED ROUTINES
' ==============================================================================
'
> PROCEDURE finish(routine|)
  '
  ' ASKS USER IF THEY WANT TO STOP DRAWING - CAN BE CALLED FROM ANY
  ' DRAWING ROUTINE. DOES NOTHING IF alerts!=FALSE.
  '
  LOCAL yn|
  '
  IF alerts!
    '
    SHOWM
    ALERT 2,"Finish?|(no resume|option).",2,"Yes|No",yn|
    '
    IF yn|=1
      '
      SELECT routine|
      CASE 1              ! DIVIDE AND CONQUER ROUTINES : LEM/NORMAL
        max_it&=1
        width&=3          ! SET max_it&, width& AND height& NICE AND LOW SO
        height&=3         ! THAT THE REST OF THE FRACTAL IS "DRAWN" QUICKLY.
        '
      CASE 2              ! SPHERE METHODS
        sph_x&=x1&
        sph_y&=y1&        ! SET sph_x& AND sph_y& TO THERE FINAL VALUES
        '
      CASE 3              ! SCAPE
        a&=319
        b&=extent|
        '
      CASE 4              ! POPCORN
        a&=320-s&
        b&=200-s&
        '
      CASE 5              ! POINT DLA
        r&=97
        '
      CASE 6              ! MOUNTAINS
        a&=319
        b&=128
        '
      ENDSELECT
    ELSE
      HIDEM
      '
    ENDIF
  ENDIF
  '
RETURN
'
'
> PROCEDURE overlay(VAR yes!)
  '
  ' REPLACES THE OLD SCREEN IF USER WANTS TO OVERLAY NEW.
  '
  LOCAL choice|
  '
  SHOWM
  ALERT 2,"Overlay (Eg draw over|last screen) ?",1," Yes | No ",choice|
  HIDEM
  yes!=choice|=1
  '
  IF yes!
    '
    SPUT scr$
    '
  ENDIF
  '
  '
RETURN
'
' ******************************************************************************
' *                                                                            *
' *                             END OF FRACENG3.GFA                            *
' *                                                                            *
' *                               PHHEWWWWWW !!!!!                             *
' *                                                                            *
' *                IF YOU HAVE READ THIS FAR I WILL BUY YOU A PINT.            *
' *                                                                            *
' *                         D W Grace BSc Copyright1993                        *
' *                                                                            *
' ******************************************************************************
