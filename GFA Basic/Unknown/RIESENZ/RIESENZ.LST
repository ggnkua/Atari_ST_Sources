Procedure Groesser(Zahl1_g$,Zahl2_g$,Loesung%)
  Local Gross!,Y%
  @Nuller_weg(Zahl1_g$,*Zahl1_g$)
  @Nuller_weg(Zahl2_g$,*Zahl2_g$)
  If Len(Zahl1_g$)>Len(Zahl2_g$)
    Gross!=True
  Else
    If Len(Zahl1_g$)<Len(Zahl2_g$)
      Gross!=False
    Else
      Y%=1
      Do
        Exit If Y%>Len(Zahl1_g$) Or Mid$(Zahl1_g$,Y%,1)<>Mid$(Zahl2_g$,Y%,1)
        Inc Y%
      Loop
      If Y%<=Len(Zahl1_g$)
        If Mid$(Zahl1_g$,Y%,1)>Mid$(Zahl2_g$,Y%,1)
          Gross!=True
        Else
          Gross!=False
        Endif
      Else
        Gross!=False
      Endif
    Endif
  Endif
  *Loesung%=Gross!
Return
Procedure Integer_addition(Zahl1_a$,Zahl2_a$,Loesung%)
  Local Loes$,X%,V1$,V2$,Neg_ergebnis!
  '
  ' Zahlen auf gleiche L„nge bringen:
  '
  V1$=Mid$(Zahl1_a$,1,1)
  V2$=Mid$(Zahl2_a$,1,1)
  If V1$="-"
    Zahl1_a$=Mid$(Zahl1_a$,2)
  Endif
  If V2$="-"
    Zahl2_a$=Mid$(Zahl2_a$,2)
  Endif
  Geloest!=False
  Neg_ergebnis!=False
  If V1$="-" And V2$<>"-"
    @Integer_subtraktion(Zahl2_a$,Zahl1_a$,*Loes$)
    Geloest!=True
  Else
    If V1$<>"-" And V2$="-"
      @Integer_subtraktion(Zahl1_a$,Zahl2_a$,*Loes$)
      Geloest!=True
    Else
      If V1$="-" And V2$="-"
        Neg_ergebnis!=True
      Endif
    Endif
  Endif
  If Geloest!=False
    If Len(Zahl1_a$)>Len(Zahl2_a$)
      Zahl2_a$=String$(Len(Zahl1_a$)-Len(Zahl2_a$),"0")+Zahl2_a$
    Else
      If Len(Zahl2_a$)>Len(Zahl1_a$)
        Zahl1_a$=String$(Len(Zahl2_a$)-Len(Zahl1_a$),"0")+Zahl1_a$
      Endif
    Endif
    Loes$=""
    Rest%=0
    For X%=1 To Len(Zahl1_a$)
      Ziff%=Val(Mid$(Zahl1_a$,Len(Zahl1_a$)-X%+1,1))
      Ziff%=Ziff%+Val(Mid$(Zahl2_a$,Len(Zahl2_a$)-X%+1,1))+Rest%
      Rest%=Int(Ziff%/10)
      Neu_ziffer%=(Ziff%/10-Rest%)*10
      Loes$=Str$(Neu_ziffer%)+Loes$
    Next X%
    If Rest%=1
      Loes$="1"+Loes$
    Endif
    If Neg_ergebnis!
      Loes$="-"+Loes$
    Endif
  Endif
  *Loesung%=Loes$
Return
Procedure Integer_subtraktion(Zahl1_s$,Zahl2_s$,Loesung%)
  Local Loes_s$,X%,Neg_ergebnis!,V1$,V2$,Geloest!
  Neg_ergebnis!=False
  '
  ' Nuller-Weg
  '
  @Nuller_weg(Zahl1_s$,*Zahl1_s$)
  @Nuller_weg(Zahl2_s$,*Zahl2_s$)
  '
  ' Testen auf Subtraktions-Regeln:
  '
  V1$=Mid$(Zahl1_s$,1,1)
  V2$=Mid$(Zahl2_s$,1,1)
  If V1$="-"
    Zahl1_s$=Mid$(Zahl1_s$,2)
  Endif
  If V2$="-"
    Zahl2_s$=Mid$(Zahl2_s$,2)
  Endif
  Geloest!=False
  If Len(Zahl1_s$)=Len(Zahl2_s$)
    Do
      Exit If Mid$(Zahl1_s$,Y%,1)<>Mid$(Zahl2_s$,Y%,1) Or Y%=Len(Zahl1_s$)
      Inc Y%
    Loop
    If Y%<=Len(Zahl1_s$)
      If Val(Mid$(Zahl2_s$,Y%,1))>Val(Mid$(Zahl1_s$,Y%,1))
        Swap Zahl1_s$,Zahl2_s$
        Neg_ergebnis!=True
      Endif
    Endif
  Endif
  If V1$="-" And V2$="-" !Vertauschen
    Swap Zahl1_s$,Zahl2_s$
  Endif
  If V1$="-" And V2$<>"-" ! -x-+y also negative glieder addieren
    @Integer_addition(Zahl1_s$,Zahl2_s$,*Loes_s$)
    Loes_s$="-"+Loes_s$
    Geloest!=True
  Endif
  If V1$<>"" And V2$="-" ! x - -y
    @Integer_addition(Zahl1_s$,Zahl2_s$,*Loes_s$)
    Geloest!=True
  Endif
  '
  ' Zahlen auf gleiche L„nge bringen:
  '
  If Geloest!=False
    If Len(Zahl1_s$)>Len(Zahl2_s$)
      Zahl2_s$=String$(Len(Zahl1_s$)-Len(Zahl2_s$),"0")+Zahl2_s$
    Else
      If Len(Zahl2_s$)>Len(Zahl1_s$)
        Zahl1_s$=String$(Len(Zahl2_s$)-Len(Zahl1_s$),"0")+Zahl1_s$
      Endif
    Endif
    '
    ' eventuell vertauschen:
    '
    If Val(Mid$(Zahl1_s$,1,1))<Val(Mid$(Zahl2_s$,1,1)) !Vertausche
      Swap Zahl1_s$,Zahl2_s$
      Neg_ergebnis!=True
    Endif
    Loes_s$=""
    Rest%=0
    For X%=1 To Len(Zahl1_s$)
      Ziff%=Val(Mid$(Zahl1_s$,Len(Zahl1_s$)-X%+1,1))
      Ziff%=Ziff%-Val(Mid$(Zahl2_s$,Len(Zahl2_s$)-X%+1,1))-Rest%
      If Ziff%<0
        Ziff%=Ziff%+10
        Rest%=1
      Else
        Rest%=0
      Endif
      Loes_s$=Str$(Ziff%)+Loes_s$
    Next X%
    If Neg_ergebnis!
      Loes_s$="-"+Loes_s$
    Endif
  Endif
  *Loesung%=Loes_s$
Return
Procedure Integer_multiplikation(Zahl1_m$,Zahl2_m$,Loesung%)
  Local Loes_m$,X%,Y%,Loes2$,Z1%,Z2%,V1$,V2$,Neg_ergebnis!
  V1$=Mid$(Zahl1_m$,1,1)
  V2$=Mid$(Zahl2_m$,1,1)
  If (V1$="-" And V2$<>"-") Or (V1$<>"-" And V2$="-")
    Neg_ergebnis!=True
  Else
    Neg_ergebnis!=False
  Endif
  If V1$="-"
    Zahl1_m$=Mid$(Zahl1_m$,2)
  Endif
  If V2$="-"
    Zahl2_m$=Mid$(Zahl2_m$,2)
  Endif
  If Len(Zahl1_m$)<Len(Zahl2_m$)
    Swap Zahl1_m$,Zahl2_m$
  Endif
  Loes_m$="0"
  For X%=1 To Len(Zahl2_m$)
    Loes2$=""
    For Y%=1 To Len(Zahl1_m$)
      Z2%=Val(Mid$(Zahl2_m$,Len(Zahl2_m$)-X%+1,1))
      Z1%=Val(Mid$(Zahl1_m$,Len(Zahl1_m$)-Y%+1,1))
      If Z1%>10
        Rest2%=1
        Z1%=Z1%-10
      Else
        Rest2%=0
      Endif
      Loes2$=Str$(((Z1%*Z2%+Rest%)/10-Int((Z1%*Z2%+Rest%)/10))*10)+Loes2$
      Rest%=Int((Z1%*Z2%+Rest%)/10)+Rest2%
    Next Y%
    If X%<>1
      Loes2$=Loes2$+String$(X%-1,"0")
    Endif
    If Rest%<>0
      Loes2$=Str$(Rest%)+Loes2$
    Endif
    @Integer_addition(Loes2$,Loes_m$,*Loes_m$)
  Next X%
  If Neg_ergebnis!
    Loes_m$="-"+Loes_m$
  Endif
  *Loesung%=Loes_m$
Return
Procedure Hoch(Zahl1_h$,Zahl2_h$,Loesung%)
  Local X_h%,Ergebnis$,Neg_ergebnis!
  V1$=Mid$(Zahl1_h$,1,1)
  V2$=Mid$(Zahl2_h$,1,1)
  If V1$="-" And Even(Val(Zahl2_h$))=False
    Neg_ergebnis!=True
  Endif
  If V1$="-"
    Zahl1_h$=Mid$(Zahl1_h$,2)
  Endif
  Ergebnis$=Zahl1_h$
  For X_h%=1 To Val(Zahl2_h$)-1
    @Integer_multiplikation(Ergebnis$,Zahl1_h$,*Ergebnis$)
  Next X_h%
  If Neg_ergebnis!
    Ergebnis$="-"+Ergebnis$
  Endif
  *Loesung%=Ergebnis$
Return
Procedure Integer_division(Zahl1_d$,Zahl2_d$,Loesung%)
  Local Loes_d$,X%,Y%,Loes2$,Z1%,Z2%,V1$,V2$,Neg_ergebnis!,Anz%,Y$
  V1$=Mid$(Zahl1_d$,1,1)
  V2$=Mid$(Zahl2_d$,1,1)
  If (V1$="-" And V2$<>"-") Or (V1$<>"-" And V2$="-")
    Neg_ergebnis!=True
  Else
    Neg_ergebnis!=False
  Endif
  If V1$="-"
    Zahl1_d$=Mid$(Zahl1_d$,2)
  Endif
  If V2$="-"
    Zahl2_d$=Mid$(Zahl2_d$,2)
  Endif
  Loes_d$=""
  Rest%=0
  Last%=1
  Z$=""
  For X%=1 To Len(Zahl1_d$)
    Z$=Z$+Mid$(Zahl1_d$,X%,1)
    Anz%=0
    Inc Aufr%
    Y$=Z$
    Do
      @Integer_subtraktion(Y$,Zahl2_d$,*Y$)
      Exit If Mid$(Y$,1,1)="-"
      Inc Anz%
    Loop
    Loes_d$=Loes_d$+Str$(Anz%)
    If Anz%<>0
      Last%=X%
      @Integer_addition(Y$,Zahl2_d$,*Rest$)
      @Nuller_weg(Rest$,*Rest$)
      Z$=Rest$
    Endif
  Next X%
  If Neg_ergebnis!
    Loes_d$="-"+Loes_d$
  Endif
  *Loesung%=Loes_d$
Return
Procedure Gehts_auf(Zahl1_d$,Zahl2_d$,Loesung%)
  Local Loes_d$,X%,Y%,Loes2$,Z1%,Z2%,V1$,V2$,Neg_ergebnis!,Anz%,Y$
  V1$=Mid$(Zahl1_d$,1,1)
  V2$=Mid$(Zahl2_d$,1,1)
  If (V1$="-" And V2$<>"-") Or (V1$<>"-" And V2$="-")
    Neg_ergebnis!=True
  Else
    Neg_ergebnis!=False
  Endif
  If V1$="-"
    Zahl1_d$=Mid$(Zahl1_d$,2)
  Endif
  If V2$="-"
    Zahl2_d$=Mid$(Zahl2_d$,2)
  Endif
  Loes_d$=""
  Rest%=0
  Last%=1
  Z$=""
  For X%=1 To Len(Zahl1_d$)
    Z$=Z$+Mid$(Zahl1_d$,X%-Last%+1,1)
    Anz%=0
    Inc Aufr%
    Y$=Z$
    Do
      @Integer_subtraktion(Y$,Zahl2_d$,*Y$)
      Exit If Mid$(Y$,1,1)="-"
      Inc Anz%
    Loop
    Loes_d$=Loes_d$+Str$(Anz%)
    If Anz%<>0
      Last%=X%
      @Integer_addition(Y$,Zahl2_d$,*Rest$)
      Z$=Rest$
    Endif
  Next X%
  If Neg_ergebnis!
    Loes_d$="-"+Loes_d$
  Endif
  @Integer_multiplikation(Loes_d$,Zahl2_d$,*Rest$)
  If Rest$=Zahl1_d$
    Gehts!=True
  Else
    Gehts!=False
  Endif
  *Loesung%=Gehts!
Return
Procedure Nuller_weg(A$,A%)
  Do
    Exit If Mid$(A$,1,1)<>"0" Or A$=""
    A$=Mid$(A$,2)
  Loop
  If A$=""
    A$="0"
  Endif
  *A%=A$
Return
Procedure Wurzel(A$,Stw$,Loesung%)
  Local T$,T2$,T!
  T$=Stw$
  Do
    @Integer_addition(T$,"1",*T$)
    @Integer_multiplikation(T$,T$,*T2$)
    @Groesser(T2$,A$,*T!)
    Exit If T!
  Loop
  *Loesung%=T$
Return
