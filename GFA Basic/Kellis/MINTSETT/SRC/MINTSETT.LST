' MiNTsetter coded by kellis.
' GFA basic 3.6E TT
' under MiNT and Naes. 1998
' kellis@leading.net
' http://users.leading.net/~kellis/
$m40960
' CLIP OFF    ! to display text x,y,text$
version$="3.9"                        ! set MiNTsetter version
deskacc&=({ADD(BASEPAGE,36)}=0)       ! check if ran as ACC
compiled!=BYTE{BASEPAGE+256}<>96      ! check if ran from editor, or compiled
IF NOT compiled!
  RESERVE 1024*40                     ! reserve memory for under interpretor!
ENDIF
IF NOT @cookie_find("MiNT")>0
  ALERT 1,"MiNT is not |installed. |Please, reboot now. ",1,"OK",ok|
  END
ENDIF
IF @ssystem(-1,0,0)<>0                ! kernal too old?
  ALERT 1,"Your MiNT kernal is |too old. |Please, upgrade it.",1,"OK",ok|
  END
ENDIF
ap_id&=APPL_INIT()
IF ap_id&=-1                          ! problem, EXIT.
  ~APPL_EXIT()
  END
ENDIF
IF deskacc&                           ! ran as ACC
  @init
  me_id&=@menu_register(ap_id&,"  MiNT Setter")
  DO
    event&=EVNT_MULTI(mu_mesag&+mu_timer&,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000,d&,d&,d&,d&,d&,d&)
    IF event& AND mu_timer& AND no_alert&=0 AND alert&=1
      @mutimer
      count&=@fread(pipe_fd&,(max_str_len&+1),albuf%)
      IF count&>0
        ~FORM_ALERT(1,CHAR{albuf%})
      ENDIF
    ENDIF
    IF event& AND mu_mesag&
      IF MENU(5)=me_id& AND MENU(1)=40
        ~SCRP_READ(clipboard_path$)
        clip$=clipboard_path$+"scrap.txt"
        @init2
        @evnt_multi_loop
        ~WIND_GET(handle&,5,dummyx&,dummyy&,dummyw&,dummyh&)
        ~WIND_CLOSE(handle&)
        ~WIND_CLOSE(handle2&)
        ~FORM_DIAL(fmd_shrink&,((dummyx&+dummyw&)/2),((dummyy&+dummyh&)/2),0,0,dummyx&,dummyy&,dummyw&,dummyh&)
      ENDIF
    ENDIF
  LOOP
ELSE                                 ! ran as PRG
  @init
  @init2
  IF VAL(@aes$)>=4
    ~@menu_register(ap_id&,"  MiNT Setter")  ! put the name in the task menu.
  ENDIF
  REPEAT
    @evnt_multi_loop
  UNTIL exit
  ~WIND_GET(handle&,5,dummyx&,dummyy&,dummyw&,dummyh&)
  ~WIND_CLOSE(handle&)
  ~WIND_CLOSE(handle2&)
  ~WIND_DELETE(handle&)
  ~FORM_DIAL(fmd_shrink&,((dummyx&+dummyw&)/2),((dummyy&+dummyh&)/2),0,0,dummyx&,dummyy&,dummyw&,dummyh&)
  IF alert&=1
    ~@fclose(pipe_fd&)
  ENDIF
  ~RSRC_FREE()
  ~APPL_EXIT()
  IF NOT compiled!
    RESERVE                          ! use this one if ran from the interpretor
  ENDIF
  EDIT
ENDIF
'
> PROCEDURE credit                   ! INFO
  ALERT 0,"MiNT Setter version "+version$+" | Kellis @ YesCREW 1999 |      *FREEWARE*",1,"OK",ok|
RETURN
> PROCEDURE evnt_multi_loop          ! main loop
  LOCAL mx&,my&,mb&,ks&,key&,mc&
  mc&=2
  DO
    event&=EVNT_MULTI(mu_button&+mu_mesag&+mu_keybd&+mu_timer&,256+2,3,0,0,0,0,0,0,0,0,0,0,0,0,1000,mx&,my&,mb&,ks&,key&,mc&)
    IF event& AND mu_timer& AND alert&=1
      @mutimer
    ENDIF
    IF event& AND mu_button&                     ! if mouse clicked
      @mubutton
    ENDIF
    IF event& AND mu_keybd&
      @mukey
    ENDIF
    IF event& AND mu_mesag&
      @analize_mesag
    ENDIF
  LOOP UNTIL exit=1
RETURN
' ----------------------
> PROCEDURE analize_mesag            ! check the GEM messages sent by the aes
  SELECT MENU(1)
  CASE wm_redraw&
    @rsc_redraw(MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
  CASE wm_topped&
    @topit
  CASE wm_moved&
    ~WIND_SET(MENU(4),5,MENU(5),MENU(6),MENU(7),MENU(8))
    @win_place_tree(MENU(4))
  CASE wm_bottom&
    ~WIND_SET(MENU(4),wf_bottom&,MENU(5),MENU(6),MENU(7),MENU(8))
  CASE wm_closed&,ac_close&,41
    lock_more&=0
    IF MENU(4)=handle&
      @r_mint
      exit=1
    ELSE
      ~WIND_CLOSE(MENU(4))
    ENDIF
  CASE wm_fulled&
    IF full|=0
      full|=1
      ~WIND_GET(MENU(4),5,tmpx&,tmpy&,tmpw&,tmph&)
      ~WIND_SET(MENU(4),5,tmpx&,tmpy&,tmpw&,0)
    ELSE
      full|=0
      ~WIND_GET(MENU(4),5,tmpx&,tmpy&,d&,d&)
      ~WIND_SET(MENU(4),5,tmpx&,tmpy&,tmpw&,tmph&)
    ENDIF
  CASE ap_term&
    exit=1
  ENDSELECT
RETURN
> PROCEDURE mutimer                    ! every X ms it will execute this routine
  count&=@fread(pipe_fd&,(max_str_len&+1),albuf%)
  IF count&>0
    alertlog$=""
    ~FORM_ALERT(1,CHAR{albuf%})
    IF @exist("U:\tmp\alert.log")=FALSE
      OPEN "O",#1,"U:\tmp\alert.log"
    ELSE
      OPEN "A",#1,"U:\tmp\alert.log"
    ENDIF
    alertlog$=CHAR{albuf%}
    PRINT #1,MID$(alertlog$,5,LEN(alertlog$)-13)+CHR$(0)
    CLOSE #1
  ENDIF
RETURN
> PROCEDURE mubutton                   ! mouse button has been clicked
  my_ob&=OBJC_FIND(tree%,0,2,mx&,my&)
  my_ob_fat&=OBJC_FIND(tree3%,0,4,mx&,my&)
  my_ob_user&=OBJC_FIND(w_user%,0,3,mx&,my&)
  my_ob_k&=OBJC_FIND(sysc%,0,2,mx&,my&)
  my_ob_cache&=OBJC_FIND(w_cache%,0,2,mx&,my&)
  '
  IF mb&=left_button&
    IF WIND_FIND(mx&,my&)<>handle&        ! on which window was it clicked on?
      IF tree2%=tree3%
        @treat_vfat
      ELSE IF tree2%=w_user%
        @treat_user
      ELSE IF tree2%=w_cache%
        @treat_cpu_cache
      ELSE IF tree2%=sysc% AND (debug_level&>-1 OR debug_device&>-1)
        IF my_ob_k&=klevel&          ! if click on kernal debug level
          ~OBJC_OFFSET(tree2%,klevel&,mx&,my&)
          IF level2&>-2 AND debug_level&<>level2&
            @switch_obj(pop_lev%,level2&+1,normal&)
          ENDIF
          level2&=debug_level&
          debug_level&=@form_popup(pop_lev%,mx&+1,my&+21)-1
          IF debug_level&>-2
            @switch_obj(pop_lev%,debug_level&+1,checked&)
            debug_level&=@ssystem(debuglevel&,debug_level&,0)
            debug_level&=@ssystem(debuglevel&,-1,0)
            CHAR{{OB_SPEC(tree2%,klevel&)}}=STR$(debug_level&)
            @win_redraw_objc(handle2&,tree2%,klevel&)
          ELSE
            debug_level&=level2&
          ENDIF
        ELSE IF my_ob_k&=kdev&      ! if click on kernal debug device
          ~OBJC_OFFSET(tree2%,kdev&,mx&,my&)
          IF debug2&>-2 AND debug_device&<>debug2&
            @switch_obj(pop_dev%,debug2&+1,normal&)           ! reset
          ENDIF
          debug2&=debug_device&
          debug_device&=@form_popup(pop_dev%,mx&+1,my&+21)-1
          IF debug_device&>-2
            @switch_obj(pop_dev%,debug_device&+1,checked&)    ! mark
            debug_device&=@ssystem(debugdevice&,debug_device&,0)    !!!!
            debug_device&=@ssystem(debugdevice&,-1,0)
            CHAR{{OB_SPEC(tree2%,kdev&)}}=@device$(debug_device&)
            @win_redraw_objc(handle2&,tree2%,kdev&)
          ELSE
            debug_device&=debug2&
          ENDIF
        ENDIF
      ELSE
      ENDIF
    ELSE IF WIND_FIND(mx&,my&)=handle&          !  was it main-window? yes.
      '
      IF timeslice&>-1
        IF my_ob&=tsplus&                  ! Time-Slice icon
          IF timeslice&<20 AND timeslice&>-1
            INC timeslice&
            @timeslice
          ENDIF
        ELSE IF my_ob&=tsminus&
          IF timeslice&>0
            DEC timeslice&
            @timeslice
          ENDIF
        ENDIF
      ENDIF
      '
      IF security&>-1
        IF my_ob&=sl& AND VAL(@aes$)>3.2   ! popup security
          ~OBJC_OFFSET(tree%,sl&,mx&,my&)
          sl_tmp&=@form_popup(pop2%,mx&+1,my&+21)
          IF sl_tmp&>-1
            security&=sl_tmp&-1
            @security
          ENDIF
        ENDIF
        IF my_ob&=slplus&                  ! security icon
          IF security&<2 AND security&>=0
            INC security&
            @security
          ENDIF
        ELSE IF my_ob&=slminus&
          IF security&>0
            DEC security&
            @security
          ENDIF
        ENDIF
      ENDIF
      '
      IF (my_ob&=icon_alert& OR my_ob&=12) AND no_alert&=0
        ~EVNT_BUTTON(1,1,0)
        IF alert&=0
          @redraw_obj(tree%,icon_alert&,selected&)
          alert&=1
          @do_pipe
        ELSE
          @redraw_obj(tree%,icon_alert&,normal&)
          alert&=0
          ~@fclose(pipe_fd&)
        ENDIF
      ENDIF
      IF my_ob&=ok&
        IF @texit(tree%)=0
          @endit
        ENDIF
      ENDIF
      IF my_ob&=icon&
        IF @texit(tree%)=0
          @credit
        ENDIF
      ENDIF
      IF my_ob&=ffl& OR my_ob&=11
        ~EVNT_BUTTON(1,1,0)
        IF @ssystem(forcefastload&,-1,0)=0
          ~@ssystem(forcefastload&,1,0)
          @redraw_obj(tree%,ffl&,selected&)
        ELSE
          ~@ssystem(forcefastload&,0,0)
          @redraw_obj(tree%,ffl&,normal&)
        ENDIF
      ENDIF
      IF (my_ob&=ts& AND timeslice&<0) OR (my_ob&=sl& AND security&<0)
        ALERT 1,"NS: Operation NOT Supported. ",1,"OK",ok|
      ENDIF
      IF my_ob&=avstring& AND av_notloaded|=1
        ALERT 1,"The AVSERVER you have set |is not running. ",1,"OK",ok|
      ENDIF
      '
      IF my_ob&=icon_inetd& OR my_ob&=13
        ~EVNT_BUTTON(1,1,0)
        @suspend_inetd
      ENDIF
      IF my_ob&=load_button&
        IF mc&=1
          IF @texit(tree%)=0
            @uptime
            @win_redraw_objc(handle&,tree%,update_val&)
            @win_redraw_objc(handle&,tree%,hours_val&)
            @win_redraw_objc(handle&,tree%,days_val&)
            @users
            @display_user
          ENDIF
        ELSE
          @clip_average
        ENDIF
      ENDIF
      IF my_ob&=clip&
        IF @texit(tree%)=0
          @dumpclip
        ENDIF
      ENDIF
      IF my_ob&=user_icon& AND nouser|=1
        ALERT 1,"/etc/utmp file not found. | No user option available. ",1,"OK",ok|
      ENDIF
      '
      IF (my_ob&=more& OR my_ob&=w_vfat& OR my_ob&=user_icon&) AND lock_more&=1
        ~WIND_SET(handle2&,wf_top&,ap_id&,FALSE,FALSE,FALSE)
      ENDIF
      IF my_ob&=more& AND lock_more&<>1
        IF @texit(tree%)=0
          lock_more&=1
          tree2%=sysc%
          @morewin
        ENDIF
      ENDIF
      IF my_ob&=cpu_icon& AND lock_more&<>1
        IF @texit(tree%)=0
          @redraw_obj(tree%,cpu_icon&,selected&)
          tree2%=w_cache%
          lock_more&=1
          @morewin9
          @redraw_obj(tree%,cpu_icon&,normal&)
        ENDIF
      ENDIF
      IF my_ob&=w_vfat& AND lock_more&<>1
        IF @texit(tree%)=0
          lock_more&=1
          tree2%=tree3%
          @morewin2
        ENDIF
      ENDIF
      IF my_ob&=cookie_icon&
        IF @texit(tree%)=0
          @redraw_obj(tree%,clip&,selected&)
          @dumpcookie
          @redraw_obj(tree%,clip&,normal&)
        ENDIF
      ENDIF
      IF my_ob&=user_icon& AND lock_more&<>1
        IF @texit(tree%)=0
          tree2%=w_user%
          lock_more&=1
          @morewin3
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
> FUNCTION texit(t%)
$F%
LOCAL a&
IF t%=tree%
  m&=my_ob&
ELSE IF t%=tree3%
  m&=my_ob_fat&
ELSE IF t%=w_user%
  m&=my_ob_user&
ELSE IF t%=w_cache%
  m&=my_ob_cache&
ENDIF
a&=FORM_BUTTON(t%,m&,1,d&)
IF a&=0
  @redraw_obj(t%,m&,normal&)
ENDIF
RETURN a&
ENDFUNC
> PROCEDURE mukey                      ! a key has been pressed
LOCAL h&
SELECT key&
CASE cntrl_w&
  ~WIND_GET(0,10,h&,d&,d&,d&)
  IF h&=handle&
    ~WIND_SET(handle2&,wf_top&,ap_id&,FALSE,FALSE,FALSE)
  ELSE
    ~WIND_SET(handle&,wf_top&,ap_id&,FALSE,FALSE,FALSE)
  ENDIF
ENDSELECT
IF lock_more&=1
  SELECT key&
  CASE key_return&,key_enter&,cntrl_u&
    ~WIND_CLOSE(handle2&)
    lock_more&=0
  ENDSELECT
ELSE
  SELECT key&
  CASE key_undo&,cntrl_q&,cntrl_u&
    exit=1
  CASE key_return&,key_enter&
    @endit
  CASE cntrl_i&,key_help&
    @credit
  CASE cntrl_c&
    @redraw_obj(tree%,clip&,selected&)
    @dumpclip
    @redraw_obj(tree%,clip&,normal&)
  CASE key_tab&
    IF lock_more&<>1
      lock_more&=1
      tree2%=sysc%
      @morewin
    ENDIF
  CASE shift_larrow&
    IF timeslice&>0
      DEC timeslice&
      @timeslice
    ENDIF
  CASE shift_rarrow&
    IF timeslice&<20 AND timeslice&>-1
      INC timeslice&
      @timeslice
    ENDIF
  CASE key_rarrow&
    IF security&<2 AND security&>=0
      INC security&
      @security
    ENDIF
  CASE key_larrow&
    IF security&>0
      DEC security&
      @security
    ENDIF
  ENDSELECT
ENDIF
RETURN
' -----------------------
> PROCEDURE suspend_inetd              ! kill -17 or kill -19 (PID)
IF @fattrib("u:\proc\inetd."+STR$(pid&),0,2)=&H24   ! if stopped
  IF @pkill(pid&,sigcont&)=0
    @redraw_obj(tree%,icon_inetd&,normal&)
  ENDIF
ELSE
  IF @pkill(pid&,sigstop&)=0
    @redraw_obj(tree%,icon_inetd&,selected&)
  ENDIF
ENDIF
RETURN
'
> PROCEDURE treat_vfat
IF my_ob_fat&=drplus& AND dr&<drivelen&-1
  REPEAT
    INC dr&
    IF dr&=drivelen&
      dr&=dr&-1
    ENDIF
  UNTIL BTST(drivemap%,dr&)=-1
  IF dr&<>20
    @switch_icon
  ENDIF
ENDIF
IF my_ob_fat&=fatdrive& AND VAL(@aes$)>3.2
  @redraw_obj(pop%,dr&+1,selected&)
  ~OBJC_OFFSET(tree2%,fatdrive&,mx&,my&)
  result&=(@form_popup(pop%,mx&+1,my&+26))-1
  @redraw_obj(pop%,dr&+1,normal&)
  IF result&>=0 AND result&<>20
    dr&=result&
    @switch_icon
  ENDIF
ENDIF
IF my_ob_fat&=drminus& AND dr&>0
  REPEAT
    DEC dr&
  UNTIL BTST(drivemap%,dr&)=-1
  @switch_icon
ENDIF
IF my_ob_fat&=icon_vfat& OR my_ob_fat&=6
  ~EVNT_BUTTON(1,1,0)
  IF @dcntl(fatfs_cntr_vfat&,@makeu$(dr&),-1)=0
    ~@dcntl(fatfs_cntr_vfat&,@makeu$(dr&),1)
  ELSE
    ~@dcntl(fatfs_cntr_vfat&,@makeu$(dr&),0)
  ENDIF
  @redraw_obj(tree2%,icon_vfat&,@dcntl(fatfs_cntr_vfat&,@makeu$(dr&),-1))
  IF av_notloaded|=0
    @c_drive(dr&)
  ENDIF
ENDIF
IF my_ob_fat&=icon_wb& OR my_ob_fat&=8
  ~EVNT_BUTTON(1,1,0)
  IF @dcntl(fatfs_cntr_cache&,@makeu$(dr&),-1)=0
    ~@dcntl(fatfs_cntr_cache&,@makeu$(dr&),1)
  ELSE
    ~@dcntl(fatfs_cntr_cache&,@makeu$(dr&),0)
  ENDIF
  @redraw_obj(tree2%,icon_wb&,@dcntl(fatfs_cntr_cache&,@makeu$(dr&),-1))
ENDIF
IF my_ob_fat&=vfat_ok&
  IF @texit(tree2%)=0
    ~@ssystem(s_blockcache&,cache_val&,0)
    ~WIND_CLOSE(handle2&)
    lock_more&=0
  ENDIF
ENDIF
IF my_ob_fat&=20 AND cache_val&>-1
  ~OBJC_OFFSET(tree2%,20,x&,d&)
  cache_val&=INT((mx&-x&)/OB_W(tree2%,20)*100)+1
  CHAR{{OB_SPEC(tree2%,cache&)}}=STR$(cache_val&,3)
  OB_X(tree2%,21)=mx&-x&
  @redraw_obj(tree2%,19,normal&)
  @win_redraw_objc(handle2&,tree2%,cache&)
ENDIF
IF my_ob_fat&=fs_time&
  IF @ssystem(sync_time&,-1,0)>-1
    ~OBJC_OFFSET(tree2%,fs_time&,mx&,my&)
    sync&=@form_popup(popsync%,mx&+1,my&+21)
    IF sync&>-1
      INC sync&
      IF @ssystem(sync_time&,sync&,0)>-1
        CHAR{{OB_SPEC(tree2%,fs_time&)}}=STR$(@ssystem(sync_time&,-1,0),2)
        @win_redraw_objc(handle2&,tree2%,fs_time&)
      ELSE
        @redraw_obj(tree2%,fs_time&,disabled&)
      ENDIF
    ENDIF
  ELSE
    ALERT 1,"NS: Your MiNT version does |Not Support this option to|be set on the fly. ",1,"OK",ok|
  ENDIF
ENDIF
RETURN
> PROCEDURE treat_user
IF my_ob_user&=user_plus& AND b&<many_user&-1
  INC b&
  @display_user
ENDIF
IF my_ob_user&=user_minus& AND b&>0
  DEC b&
  @display_user
ENDIF
IF my_ob_user&=user_ok&
  IF @texit(w_user%)=0
    ~WIND_CLOSE(handle2&)
    lock_more&=0
  ENDIF
ENDIF
RETURN
PROCEDURE treat_cpu_cache
IF my_ob_cache&>=i_cache&          ! check if we click on a button
  ccw%=@ssystem(s_ctrlcache&,-1,0)       ! get current cache setting
  '
  IF my_ob_cache&=i_cache&
    IF ccw% AND &H1
      ~@ssystem(s_ctrlcache&,0,&H1)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H1,&H1)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  '
  IF my_ob_cache&=d_cache&
    IF ccw% AND &H2
      ~@ssystem(s_ctrlcache&,0,&H2)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H2,&H2)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  '
  IF my_ob_cache&=b_cache&
    IF ccw% AND &H4
      ~@ssystem(s_ctrlcache&,0,&H4)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H4,&H4)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  '
  IF my_ob_cache&=w_buffer&
    IF ccw% AND &H8000
      ~@ssystem(s_ctrlcache&,0,&H8000)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H8000,&H8000)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=i_burst&
    IF ccw% AND &H20
      ~@ssystem(s_ctrlcache&,0,&H20)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H20,&H20)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=d_burst&
    IF ccw% AND &H40
      ~@ssystem(s_ctrlcache&,0,&H40)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H40,&H40)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=i_fmode&
    IF ccw% AND &H100
      ~@ssystem(s_ctrlcache&,0,&H100)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H100,&H100)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=d_fmode&
    IF ccw% AND &H400
      ~@ssystem(s_ctrlcache&,0,&H400)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H400,&H400)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=i_readwrite&
    IF ccw% AND &H200
      ~@ssystem(s_ctrlcache&,0,&H200)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H200,&H200)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=d_walloc&
    IF ccw% AND &H80
      ~@ssystem(s_ctrlcache&,0,&H80)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H80,&H80)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
  IF my_ob_cache&=d_ralloc&
    IF ccw% AND &H800
      ~@ssystem(s_ctrlcache&,0,&H800)
      @redraw_obj(w_cache%,my_ob_cache&,normal&)
    ELSE
      ~@ssystem(s_ctrlcache&,&H800,&H800)
      @redraw_obj(w_cache%,my_ob_cache&,selected&)
    ENDIF
  ENDIF
ENDIF
RETURN
> FUNCTION dreadlabel$(dr&,len&)
$F%
LOCAL path$,er&
path$=@makeu$(dr&)+CHR$(0)
er&=GEMDOS(&H152,L:V:path$,L:label%,len&)
IF er&=0
label$=CHAR{label%}
ELSE
IF dr&<2
  label$="FLOPPY DISK "
ELSE
  label$="HARD DISK   "
ENDIF
ENDIF
RETURN label$
ENDFUNC
> PROCEDURE display_user
IF ASC(LEFT$(host$(b&),1))<33
host$(b&)="localhost       "
ENDIF
CHAR{{OB_SPEC(w_user%,user_val&)}}=nam$(b&)
CHAR{{OB_SPEC(w_user%,term_val&)}}=line$(b&)
CHAR{{OB_SPEC(w_user%,host_val&)}}=host$(b&)
@win_redraw_objc(handle2&,w_user%,user_val&)
@win_redraw_objc(handle2&,w_user%,term_val&)
@win_redraw_objc(handle2&,w_user%,host_val&)
CHAR{{OB_SPEC(tree%,user_number_val&)}}=STR$(connected_user&,3)
@win_redraw_objc(handle&,tree%,user_number_val&)
RETURN
> PROCEDURE switch_icon
CHAR{{OB_SPEC(tree2%,label_val&)}}=@dreadlabel$(dr&,13)
@win_redraw_objc(handle2&,tree2%,label_val&)
IF dr&<>20
CHAR{{OB_SPEC(tree2%,fatdrive&)}}=CHR$(65+dr&)
@redraw_obj(tree2%,icon_vfat&,@dcntl(fatfs_cntr_vfat&,@makeu$(dr&),-1))
@redraw_obj(tree2%,icon_wb&,@dcntl(fatfs_cntr_cache&,@makeu$(dr&),-1))
@win_redraw_objc(handle2&,tree2%,fatdrive&)
IF dr&>1
  @redraw_obj(tree2%,icon_floppy&,selected&)
ELSE
  @redraw_obj(tree2%,icon_floppy&,normal&)
ENDIF
ENDIF
RETURN
> PROCEDURE c_drive(dr&)               ! change drive to AVSERVER
IF av_notloaded|=0
msg&(0)=72
msg&(1)=ap_id&
msg&(3)=dr&
msg&(2)=msg&(4)=msg&(5)=msg&(6)=msg&(7)=0
~APPL_WRITE(av_id&,16,V:msg&(0))
ENDIF
RETURN
> PROCEDURE endit
'  ~EVNT_BUTTON(1,1,0)
' ~OBJC_CHANGE(tree%,ok&,0,OB_X(tree%,ok&),OB_Y(tree%,ok&),OB_W(tree%,ok&),OB_H(tree%,ok&),selected&,no_draw&)
' @win_redraw_objc(handle&,tree%,ok&)
IF timeslice&>0
~@ssystem(tslice&,timeslice&,0)
ENDIF
IF security&=>0
~@ssystem(sys_slevel&,security&,0)
ENDIF
' ~OBJC_CHANGE(tree%,ok&,0,OB_X(tree%,ok&),OB_Y(tree%,ok&),OB_W(tree%,ok&),OB_H(tree%,ok&),normal&,no_draw&)
' @win_redraw_objc(handle&,tree%,ok&)
exit=1
RETURN
'
> PROCEDURE init                       ! startup code, initialize everything, runs once.
~SCRP_READ(clipboard_path$)
clip$=clipboard_path$+"scrap.txt"
INLINE label%,256
value$=SPACE$(1024)               ! for Ssystem() strings
LET max_str_len&=1024
DIM cookies$(1000)
DIM msg&(7)
DIM average%(2)
DIM albuf|(max_str_len&+1)
' for users
DIM line$(100)
DIM nam$(100)
DIM host$(100)
DIM time%(100)
'
INLINE dta%,128
INLINE mdata%,12
INLINE menu%,12
albuf%=V:albuf|(0)
'
obj&=0
exit=0
tmp_clip$=""
@rsc_define
@include
~WIND_GET(desk&,wf_workxywh&,dsk_x&,dsk_y&,dsk_w&,dsk_h&)            ! get the coordinates   d for desktop
~WIND_CALC(0,name&,dsk_x&,dsk_y&,dsk_w&,dsk_h&,newx&,newy&,neww&,newh&)
~GRAF_MOUSE(arrow&,0)                                       ! reset mouse pointer
IF NOT compiled!
~FORM_DIAL(3,0,0,0,0,dsk_x&,dsk_y&,dsk_w&,dsk_h&)    ! this one cls the screen when NOT compiled
program_path$="g:\minta\"
ELSE
program_path$=CHR$(65+GEMDOS(25))+":"+DIR$(0)+"\"      ! get dynamical path ONCE compiled
ENDIF
success|=RSRC_LOAD(program_path$+"mintsett.rsc")
IF success|<>1                                         ! rsc loaded correctly?
ALERT 1,"File mintsett.rsc not found. ",1,"OK",ok|
EDIT
ENDIF
~RSRC_GADDR(0,0,tree%)
~RSRC_GADDR(0,1,sysc%)
~RSRC_GADDR(0,2,tree3%)
~RSRC_GADDR(0,3,pop%)
~RSRC_GADDR(0,4,w_user%)
~RSRC_GADDR(0,5,pop2%)
~RSRC_GADDR(0,6,popsync%)
~RSRC_GADDR(0,pop_lev&,pop_lev%)
~RSRC_GADDR(0,pop_dev&,pop_dev%)
~RSRC_GADDR(0,w_cache&,w_cache%)
tree2%=sysc%
@r_mint
IF alert$="YES" OR alert$="yes"
LET alert&=1
ELSE
LET alert&=0
ENDIF
IF alert&=1
@do_pipe
ENDIF
xres&=WORK_OUT(0)
yres&=WORK_OUT(1)
tx&=OB_X(tree%,0)
ty&=OB_Y(tree%,0)
tw&=OB_W(tree%,0)
th&=OB_H(tree%,0)
' second tree, ssysconf()
tx2&=OB_X(sysc%,0)
ty2&=OB_Y(sysc%,0)
tw2&=OB_W(sysc%,0)
th2&=OB_H(sysc%,0)
' third tree, VFAT
tx3&=OB_X(tree3%,0)
ty3&=OB_Y(tree3%,0)
tw3&=OB_W(tree3%,0)
th3&=OB_H(tree3%,0)
' 5th tree, user window
tx5&=OB_X(w_user%,0)
ty5&=OB_Y(w_user%,0)
tw5&=OB_W(w_user%,0)
th5&=OB_H(w_user%,0)
' 9th tree, cpu cache window
tx9&=OB_X(w_cache%,0)
ty9&=OB_Y(w_cache%,0)
tw9&=OB_W(w_cache%,0)
th9&=OB_H(w_cache%,0)
IF VAL(@aes$)<4.1
handle&=WIND_CREATE(name&+move&+close&,0,0,dsk_w&,dsk_h&)         ! creation of the window for our rsc &X0 because NO GEM widgets
ELSE
handle&=WIND_CREATE(name&+move&+close&+fuller&,0,0,dsk_w&,dsk_h&)         ! creation of the window for our rsc &X0 because NO GEM widgets
ENDIF
handle2&=WIND_CREATE(name&+move&+close&,0,0,dsk_w&,dsk_h&)
title$="MiNT Setter V"+version$+CHR$(0)                          ! title of the window
drivemap%=BIOS(&HA)
drivelen&=LEN(BIN$(drivemap%))
FOR dr&=0 TO 25
IF BTST(drivemap%,dr&)=0
  OB_STATE(pop%,dr&+1)=disabled&
ENDIF
NEXT dr&
OB_FLAGS(pop%,26)=OB_FLAGS(pop%,26)+lastob&
dr&=0
IF VAL(mintval$)<1.15
~OBJC_DELETE(tree%,ffl&)
~OBJC_DELETE(tree%,w_vfat&)
~OBJC_DELETE(tree%,36)
~OBJC_DELETE(tree%,54)
~OBJC_DELETE(tree%,11)
ENDIF
IF VAL(@aes$)<3.4   ! was <3.4
OB_TYPE(tree%,icon&)=g_icon&
OB_TYPE(tree%,tsplus&)=g_icon&
OB_TYPE(tree%,tsminus&)=g_icon&
OB_TYPE(tree%,slplus&)=g_icon&
OB_TYPE(tree%,slminus&)=g_icon&
OB_TYPE(tree%,more&)=g_icon&
OB_TYPE(tree%,ffl&)=g_icon&
OB_TYPE(tree%,w_vfat&)=g_icon&
OB_TYPE(tree%,icon_alert&)=g_icon&
OB_TYPE(tree3%,drplus&)=g_icon&
OB_TYPE(tree3%,drminus&)=g_icon&
OB_TYPE(tree3%,icon_vfat&)=g_icon&
OB_TYPE(tree3%,icon_wb&)=g_icon&
OB_TYPE(tree3%,icon_floppy&)=g_icon&
OB_TYPE(tree%,cookie_icon&)=g_icon&
OB_TYPE(tree%,icon_inetd&)=g_icon&
OB_TYPE(tree%,user_icon&)=g_icon&
OB_TYPE(w_user%,user_plus&)=g_icon&
OB_TYPE(w_user%,user_minus&)=g_icon&
ENDIF
ccm%=@ssystem(s_ctrlcache&,0,-1)
IF (ccm% AND &H1)=FALSE
OB_FLAGS(w_cache%,i_cache&)=OB_FLAGS(w_cache%,i_cache&)-hidetree&
ENDIF
IF (ccm% AND &H2)=FALSE
OB_FLAGS(w_cache%,d_cache&)=OB_FLAGS(w_cache%,d_cache&)-hidetree&
ENDIF
IF (ccm% AND &H4)=FALSE
OB_FLAGS(w_cache%,b_cache&)=OB_FLAGS(w_cache%,b_cache&)-hidetree&
ENDIF
IF (ccm% AND &H8000)=FALSE
OB_FLAGS(w_cache%,w_buffer&)=OB_FLAGS(w_cache%,w_buffer&)-hidetree&
ENDIF
IF (ccm% AND &H20)=FALSE
OB_FLAGS(w_cache%,i_burst&)=OB_FLAGS(w_cache%,i_burst&)-hidetree&
ENDIF
IF (ccm% AND &H40)=FALSE
OB_FLAGS(w_cache%,d_burst&)=OB_FLAGS(w_cache%,d_burst&)-hidetree&
ENDIF
IF (ccm% AND &H100)=FALSE
OB_FLAGS(w_cache%,i_fmode&)=OB_FLAGS(w_cache%,i_fmode&)-hidetree&
ENDIF
IF (ccm% AND &H400)=FALSE
OB_FLAGS(w_cache%,d_fmode&)=OB_FLAGS(w_cache%,d_fmode&)-hidetree&
ENDIF
IF (ccm% AND &H200)=FALSE
OB_FLAGS(w_cache%,i_readwrite&)=OB_FLAGS(w_cache%,i_readwrite&)-hidetree&
ENDIF
IF (ccm% AND &H80)=FALSE
OB_FLAGS(w_cache%,d_walloc&)=OB_FLAGS(w_cache%,d_walloc&)-hidetree&
ENDIF
IF (ccm% AND &H800)=FALSE
OB_FLAGS(w_cache%,d_ralloc&)=OB_FLAGS(w_cache%,d_ralloc&)-hidetree&
ENDIF
RETURN
> PROCEDURE init2                      ! init everytime the main window is opened, or called as acc
dr&=ASC(UPPER$(@boot$))-65
full|=0
exit=0
lock_more&=0
olddta%=FGETDTA()
~FSETDTA(dta%)
stat&=FSFIRST("u:\proc\inetd.*",&H100)
DO WHILE stat&=0
pid&=VAL(MID$(CHAR{dta%+30},RINSTR(CHAR{dta%+30},".")+1))
stat&=FSNEXT()
LOOP
IF pid&=0                    ! is inetd running?
OB_FLAGS(tree%,icon_inetd&)=hidetree&
OB_FLAGS(tree%,13)=hidetree&
ELSE
OB_FLAGS(tree%,icon_inetd&)=normal&
OB_FLAGS(tree%,13)=normal&
IF @fattrib("u:\proc\inetd."+STR$(pid&),0,2)=&H24
  @redraw_obj(tree%,icon_inetd&,selected&)
ELSE
  @redraw_obj(tree%,icon_inetd&,normal&)
ENDIF
ENDIF
~FSETDTA(olddta%)
~FORM_DIAL(fmd_grow&,(dsk_w&/2),(dsk_h&/2),0,0,(dsk_w&-tw&)/2,(dsk_h&-th&)/2,tw&+(neww&-dsk_w&),th&+(newh&-dsk_h&))
~WIND_OPEN(handle&,(dsk_w&-tw&)/2,(dsk_h&-th&)/2,tw&+(neww&-dsk_w&),th&+(newh&-dsk_h&))                  ! open the window previously created (line above)
av_id&=APPL_FIND(prog$+STRING$(8-(LEN(prog$))," "))
IF av_id&<=TRUE               ! is AV-server loaded?
~OBJC_CHANGE(tree%,avstring&,0,OB_X(tree%,avstring&),OB_Y(tree%,avstring&),OB_W(tree%,avstring&),OB_H(tree%,avstring&),disabled&,no_draw&)
av_notloaded|=1
ELSE
~OBJC_CHANGE(tree%,avstring&,0,OB_X(tree%,avstring&),OB_Y(tree%,avstring&),OB_W(tree%,avstring&),OB_H(tree%,avstring&),normal&,no_draw&)
av_notloaded|=0
ENDIF
@redraw_text(ts&,timeslice&)
@redraw_text(sl&,security&)
fload&=@ssystem(forcefastload&,-1,0)
IF no_alert&=1
@redraw_obj(tree%,icon_alert&,disabled&)
@redraw_obj(tree%,12,disabled&)
ELSE
IF alert&=1
  @redraw_obj(tree%,icon_alert&,selected&)
ELSE
  @redraw_obj(tree%,icon_alert&,normal&)
ENDIF
ENDIF
IF fload&=1
@redraw_obj(tree%,ffl&,selected&)
ENDIF
' set window title
w%=V:title$
~WIND_SET(handle&,2,CARD(SWAP(w%)),CARD(w%),0,0)
~WIND_SET(handle2&,2,CARD(SWAP(w%)),CARD(w%),0,0)
RETURN
> FUNCTION cookie_find(id$)            ! find a cookie, and return tag if found
LOCAL c_ptr%,cname%,c_val%
c_ptr%=LPEEK(&H5A0)           ! start of list (cookie-jar)
IF OR(c_ptr%=0,ODD(c_ptr%))
RETURN 0                    ! error: cookiejar does not exist
ELSE
REPEAT
cname%=LPEEK(c_ptr%)
c_val%=LPEEK(c_ptr%+4)
EXIT IF cname%=0          ! end of list
ADD c_ptr%,8
UNTIL MKL$(cname%)=id$      ! cookie found
IF cname%
RETURN c_val%             ! return its value
ENDIF
RETURN -1                   ! jar exists; cookie not fount
ENDIF
ENDFUNC
> FUNCTION form_popup(tr%,xp&,yp&)     ! naes and magic popup
IF @menu_popup(tr%,xp&,yp&,mdata%)=1
return&=WORD{mdata%+6}
ELSE
return&=-1
ENDIF
RETURN return&
ENDFUNC
> FUNCTION menu_popup(tr%,xpos&,ypos&,mdata%)
$F%
LONG{menu%}=tr%
WORD{menu%+4}=0
WORD{menu%+6}=1
WORD{menu%+8}=0
WORD{menu%+10}=0
'
GCONTRL(0)=36
GCONTRL(1)=2
GCONTRL(2)=1
GCONTRL(3)=2
GCONTRL(4)=0
GINTIN(0)=xpos&
GINTIN(1)=ypos&
ADDRIN(0)=menu%
ADDRIN(1)=mdata%
GEMSYS
RETURN GINTOUT(0)
ENDFUNC
> FUNCTION menu_register(id&,t$)       ! menu_register() new version, not buggy like the gfa original
$F%
LOCAL sa%
INLINE sa%,32
CHAR{sa%}=MID$(t$,1,30)+CHR$(0)
GCONTRL(FALSE)=35
GINTIN(FALSE)=id&
GCONTRL(1)=1
GCONTRL(2)=1
GCONTRL(3)=1
GCONTRL(4)=FALSE
ADDRIN(FALSE)=sa%
GEMSYS
RETURN GINTOUT(FALSE)
ENDFUNC
> FUNCTION aes$                        ! returns the AES version
$F%
LOCAL a&,a$
a&=DPEEK(LPEEK(GB+4))
a$=HEX$(BYTE{V:a&})+"."+HEX$(BYTE{V:a&+1},2)
RETURN a$
ENDFUNC
> PROCEDURE redraw_text(object&,value&)
IF value&<0
CHAR{{OB_SPEC(tree%,object&)}}="NS"
ELSE
IF value&=<9
CHAR{{OB_SPEC(tree%,object&)}}=STR$(value&)+CHR$(32)
ELSE
CHAR{{OB_SPEC(tree%,object&)}}=STR$(value&)
ENDIF
ENDIF
RETURN
> PROCEDURE r_mint                     ! fetches all main initial settings from running system
@users
@uptime
naes%=@cookie_find("nAES")
IF naes%>0
naesvers$=HEX$(WORD{naes%})
naesvers$=LEFT$(naesvers$,1)+"."+MID$(naesvers$,2,1)+"."+RIGHT$(naesvers$,1)
naesflg&=DPEEK(naes%+6)
naesflg$=BIN$(naesflg&,2)
ENDIF
gemdosval$=HEX$(BYTE(@sversion))+"."+HEX$(SHR&(@sversion,8))
tosversval$=HEX$(AND(@ssystem(tosheader&,0,0),&X1111111111111111))
tosversval$=LEFT$(tosversval$,1)+"."+RIGHT$(tosversval$,2)
IF (AND(@ssystem(osversion&,0,0),&X11111111))=0     ! if 0> official, all rest is beta/alpha
CHAR{{OB_SPEC(tree%,beta&)}}="OFFICIAL"
ELSE
IF (AND(@ssystem(osversion&,0,0),&X11111111))=97
CHAR{{OB_SPEC(tree%,beta&)}}=" ALPHA  "
ELSE
CHAR{{OB_SPEC(tree%,beta&)}}="  BETA  "
ENDIF
ENDIF
mintval$=STR$(AND(SHR(@ssystem(osversion&,0,0),24),&X11111111))+"."+STR$(AND(SHR(@ssystem(osversion&,0,0),16),&X11111111))
mintval$=mintval$+"."+STR$(AND(SHR(@ssystem(osversion&,0,0),8),&X11111111))
IF LEN(mintval$)<7
FOR i&=LEN(mintval$) TO 6
mintval$=mintval$+CHR$(32)
NEXT i&
ENDIF
mintmonth$=STR$(AND(SHR(@ssystem(os_build_date&,0,0),16),&X11111111))
SELECT VAL(mintmonth$)
CASE 1
mintmonth$="Jan"
CASE 2
mintmonth$="Feb"
CASE 3
mintmonth$="Mar"
CASE 4
mintmonth$="Apr"
CASE 5
mintmonth$="May"
CASE 6
mintmonth$="Jun"
CASE 7
mintmonth$="Jul"
CASE 8
mintmonth$="Aug"
CASE 9
mintmonth$="Sep"
CASE 10
mintmonth$="Oct"
CASE 11
mintmonth$="Nov"
CASE 12
mintmonth$="Dec"
ENDSELECT
mintday$=STR$(AND(SHR(@ssystem(os_build_date&,0,0),24),&X11111111))
IF VAL(mintday$)=<9
mintday$="0"+mintday$
ENDIF
mintyear$=STR$(AND(@ssystem(os_build_date&,0,0),&X1111111111111111))
mintdate$=mintday$+" "+mintmonth$+" "+mintyear$
timeslice&=@ssystem(tslice&,-1,0)
security&=@ssystem(sys_slevel&,-1,0)
feat%=@ssystem(features&,0,0)
IF AND(SHR((feat%),1),&X1)=1
vm$="ON "
ELSE
vm$="OFF"
ENDIF
CHAR{{OB_SPEC(tree%,vm&)}}=vm$
IF AND(feat%,&X1)=1
mp$="ON "
ELSE
mp$="OFF"
ENDIF
CHAR{{OB_SPEC(tree%,mp&)}}=mp$
~SHEL_ENVRN(a%,"AVSERVER")
IF a%>0
prog$=CHAR{a%+1}
ELSE
prog$="Not set"
ENDIF
CHAR{{OB_SPEC(tree%,av&)}}=prog$
~SHEL_ENVRN(a%,"HOSTNAME")
IF a%>0
hostname$=CHAR{a%+1}
ELSE
hostname$="Unknown"
ENDIF
~SHEL_ENVRN(a%,"USER")
IF a%>0
user$=CHAR{a%+1}
ELSE
user$="Not set"
ENDIF
~SHEL_ENVRN(a%,"ALERT")
IF a%>0
alert$=CHAR{a%+1}
ENDIF
CHAR{{OB_SPEC(tree%,user&)}}=user$
~SHEL_ENVRN(a%,"UNIXMODE")
IF a%>0
unixmode$=CHAR{a%+1}
ELSE
unixmode$="Not set"
ENDIF
CHAR{{OB_SPEC(tree%,unix&)}}=unixmode$
~SHEL_ENVRN(a%,"HOME")
IF a%>0
home$=CHAR{a%+1}
ELSE
home$="Undefined"
ENDIF
IF SCRP_READ(clipboard_path$)<>0
clip$=clipboard_path$+"scrap.txt"
ELSE
clip$=@boot$+":\clipbrd\scrap.txt"
ENDIF
debug_device&=@ssystem(debugdevice&,-1,0)
debug_level&=@ssystem(debuglevel&,-1,0)
IF debug_device&<0 OR debug_level&<0
@switch_obj(sysc%,kdev&,disabled&+selected&)
@switch_obj(sysc%,klevel&,disabled&+selected&)
ELSE
@switch_obj(pop_lev%,debug_level&+1,checked&)
@switch_obj(pop_dev%,debug_device&+1,checked&)    ! mark
ENDIF
aesvers$=LEFT$(@aes$,1)+"."+RIGHT$(@aes$,2)
CHAR{{OB_SPEC(tree%,gemdosvers&)}}=gemdosval$
CHAR{{OB_SPEC(tree%,tosvers&)}}=tosversval$
CHAR{{OB_SPEC(tree%,mintvers&)}}=mintval$
CHAR{{OB_SPEC(tree%,mintdate&)}}=mintdate$
CHAR{{OB_SPEC(tree%,aesversion&)}}=aesvers$
IF (@sysconf(0))=&H7FFFFFFF
CHAR{{OB_SPEC(sysc%,memarea&)}}="Unlimited"
ELSE
CHAR{{OB_SPEC(sysc%,memarea&)}}=STR$(@sysconf(0))
ENDIF
IF (@sysconf(1))=&H7FFFFFFF
CHAR{{OB_SPEC(sysc%,pex&)}}="Unlimited"
ELSE
CHAR{{OB_SPEC(sysc%,pex&)}}=STR$(@sysconf(1))
ENDIF
IF (@sysconf(3))=&H7FFFFFFF
CHAR{{OB_SPEC(sysc%,grpid&)}}="Unlimited"
ELSE
CHAR{{OB_SPEC(sysc%,grpid&)}}=STR$(@sysconf(3))
ENDIF
IF (@sysconf(4))=&H7FFFFFFF
CHAR{{OB_SPEC(sysc%,ppuser&)}}="Unlimited"
ELSE
CHAR{{OB_SPEC(sysc%,ppuser&)}}=STR$(@sysconf(4))
ENDIF
IF (@sysconf(2))=&H7FFFFFFF
CHAR{{OB_SPEC(sysc%,pproc&)}}="Unlimited"
ELSE
CHAR{{OB_SPEC(sysc%,pproc&)}}=STR$(@sysconf(2))
ENDIF
cpu$=STR$(AND(@ssystem(compile_type&,0,0),&X1111111111111111))
IF cpu$="0"
cpu$="00"
ENDIF
CHAR{{OB_SPEC(tree%,optimized&)}}="680"+cpu$
CHAR{{OB_SPEC(tree%,user_number_val&)}}=STR$(connected_user&,3)
IF @ssystem(sync_time&,-1,0)<0
sync&=-36
CHAR{{OB_SPEC(tree3%,fs_time&)}}="NS"
ELSE
CHAR{{OB_SPEC(tree3%,fs_time&)}}=STR$(@ssystem(sync_time&,-1,0),2)
ENDIF
IF @ssystem(900,V:value$,1024)>-1
kname$=CHAR{V:value$}             ! kernel name
ELSE
kname$="Call not supported"
ENDIF
IF @ssystem(910,V:value$,1024)>-1
cname$=CHAR{V:value$}           ! compiler name
ELSE
cname$="Call not supported"
ENDIF
IF @ssystem(911,V:value$,1024)>-1
cversion$=CHAR{V:value$}          ! compiler version
ELSE
cversion$="Call not supported"
ENDIF
IF @ssystem(912,V:value$,1024)>-1
cdefine$=CHAR{V:value$}           ! compiler definitions
ELSE
cdefine$="Call not supported"
ENDIF
IF @ssystem(913,V:value$,1024)>-1
coptim$=CHAR{V:value$}
ELSE
coptim$="Call not supported"
ENDIF
RETURN
> PROCEDURE uptime
~GEMDOS(&H13F,L:VARPTR(uptime%),L:VARPTR(average%(0)))
uptime%=uptime%/60
updays%=uptime%/1440
uptime%=uptime%-updays%*1440
uphours%=uptime%/60
uptime%=uptime%-uphours%*60
IF uphours%<10
uphour$="0"+STR$(uphours%)
ELSE
uphour$=STR$(uphours%)
ENDIF
IF uptime%<10
uptime$="0"+STR$(uptime%)
ELSE
uptime$=STR$(uptime%)
ENDIF
CHAR{{OB_SPEC(tree%,hours_val&)}}=uphour$+uptime$
CHAR{{OB_SPEC(tree%,days_val&)}}=STR$(updays%,3)
average1$=STR$(ROUND(average%(0)/2048,2),4)
average2$=STR$(ROUND(average%(1)/2048,2),4)
average3$=STR$(ROUND(average%(2)/2048,2),4)
average$=average1$+average2$+average3$
CHAR{{OB_SPEC(tree%,update_val&)}}=average$
RETURN
> PROCEDURE display_cache
ccw%=@ssystem(s_ctrlcache&,-1,0)
IF (ccw% AND &H1)
@switch_obj(w_cache%,i_cache&,selected&)
ELSE
@switch_obj(w_cache%,i_cache&,normal&)
ENDIF
IF (ccw% AND &H2)
@switch_obj(w_cache%,d_cache&,selected&)
ELSE
@switch_obj(w_cache%,d_cache&,normal&)
ENDIF
IF (ccw% AND &H4)
@switch_obj(w_cache%,b_cache&,selected&)
ELSE
@switch_obj(w_cache%,b_cache&,normal&)
ENDIF
IF (ccw% AND &H8000)
@switch_obj(w_cache%,w_buffer&,selected&)
ELSE
@switch_obj(w_cache%,w_buffer&,normal&)
ENDIF
IF (ccw% AND &H20)
@switch_obj(w_cache%,i_burst&,selected&)
ELSE
@switch_obj(w_cache%,i_burst&,normal&)
ENDIF
IF (ccw% AND &H40)
@switch_obj(w_cache%,d_burst&,selected&)
ELSE
@switch_obj(w_cache%,d_burst&,normal&)
ENDIF
IF (ccw% AND &H100)
@switch_obj(w_cache%,i_fmode&,selected&)
ELSE
@switch_obj(w_cache%,i_fmode&,normal&)
ENDIF
IF (ccw% AND &H400)
@switch_obj(w_cache%,d_fmode&,selected&)
ELSE
@switch_obj(w_cache%,d_fmode&,normal&)
ENDIF
IF (ccw% AND &H200)
@switch_obj(w_cache%,i_readwrite&,selected&)
ELSE
@switch_obj(w_cache%,i_readwrite&,normal&)
ENDIF
IF (ccw% AND &H80)
@switch_obj(w_cache%,d_walloc&,selected&)
ELSE
@switch_obj(w_cache%,d_walloc&,normal&)
ENDIF
IF (ccw% AND &H800)
@switch_obj(w_cache%,d_ralloc&,selected&)
ELSE
@switch_obj(w_cache%,d_ralloc&,normal&)
ENDIF
RETURN
> PROCEDURE caches
IF @ssystem(s_ctrlcache&,-1,-1)<0               ! is this call supported by kernel?
PRINT #1,"CPU cache report:"
PRINT #1,"NOT available, Reason: Ssystem(S_CTRLCACHE) not implemented in kernel"
ELSE
ccw%=@ssystem(s_ctrlcache&,-1,0)
ccm%=@ssystem(s_ctrlcache&,0,-1)
IF ccm%=0
PRINT #1,"CPU cache report:"
PRINT #1,"No cache control available."
ELSE
PRINT #1,"CPU cache report:"
IF (ccm% AND &H1)
IF (ccw% AND &H1)
PRINT #1,"Instruction cache: present, enabled."
ELSE
PRINT #1,"Instruction cache: present, disabled."
ENDIF
ELSE
PRINT #1,"Instruction cache: not available."
ENDIF
IF (ccm% AND &H2)
IF (ccw% AND &H2)
PRINT #1,"Data cache: present, enabled."
ELSE
PRINT #1,"Data cache: present, disabled."
ENDIF
ELSE
PRINT #1,"Data cache: not available."
ENDIF
'
IF (ccm% AND &H4)
IF (ccw% AND &H4)
PRINT #1,"Branch cache: present, enabled."
ELSE
PRINT #1,"Branch cache: present, disabled."
ENDIF
ELSE
PRINT #1,"Branch cache: not available."
ENDIF
IF (ccm% AND &H8000)
IF (ccw% AND &H8000)
PRINT #1,"Write buffer: available, enabled."
ELSE
PRINT #1,"Write buffer: available, disabled."
ENDIF
ELSE
PRINT #1,"Write buffer: not available."
ENDIF
IF (ccm% AND &H20)
IF (ccw% AND &H20)
PRINT #1,"Instruction burst: available, enabled."
ELSE
PRINT #1,"Instruction burst: available, disabled."
ENDIF
ELSE
PRINT #1,"Instruction burst: not available."
ENDIF
IF (ccm% AND &H40)
IF (ccw% AND &H40)
PRINT #1,"Data burst: available, enabled."
ELSE
PRINT #1,"Data burst: available, disabled."
ENDIF
ELSE
PRINT #1,"Data burst: not available."
ENDIF
IF (ccm% AND &H100)
IF (ccw% AND &H100)
PRINT #1,"Instruction full mode: available, enabled."
ELSE
PRINT #1,"Instruction full mode: available, disabled."
ENDIF
ELSE
PRINT #1,"Instruction full mode: not available."
ENDIF
IF (ccm% AND &H400)
IF (ccw% AND &H400)
PRINT #1,"Data full mode: available, enabled."
ELSE
PRINT #1,"Data full mode: available, disabled."
ENDIF
ELSE
PRINT #1,"Data full mode: not available."
ENDIF
IF (ccm% AND &H200)
IF (ccw% AND &H200)
PRINT #1,"Instruction read/write: available, enabled."
ELSE
PRINT #1,"Instruction read/write: available, disabled."
ENDIF
ELSE
PRINT #1,"Instruction read/write: not available."
ENDIF
IF (ccm% AND &H80)
IF (ccw% AND &H80)
PRINT #1,"Data write allocate: available, enabled."
ELSE
PRINT #1,"Data write allocate: available, disabled."
ENDIF
ELSE
PRINT #1,"Data write allocate: not available."
ENDIF
IF (ccm% AND &H800)
IF (ccw% AND &H800)
PRINT #1,"Data read/write allocate: available, enabled."
ELSE
PRINT #1,"Data read/write allocate: available, disabled."
ENDIF
ELSE
PRINT #1,"Data read/write allocate: not available."
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION boot$                       ! returns the boot drive, most likely "C"
$F%
LOCAL a&
a&=DPEEK(&H446)
RETURN CHR$(65+a&)
ENDFUNC
> PROCEDURE clip_average
LOCAL ho&,mi&,tim$,pm$
@uptime
@users
ho&=AND(SHR(@tget_time,11),&X11111)
mi&=AND(SHR(@tget_time,5),&X111111)
IF ho&>12
ho&=ho&-12
pm$="pm"
ELSE
pm$="am"
ENDIF
IF mi&>9
tim$=STR$(ho&)+":"+STR$(mi&)+pm$
ELSE
tim$=STR$(ho&)+":0"+STR$(mi&)+pm$
ENDIF
hand_clip&=@f_create(clip$)
IF hand_clip&>0
IF updays%=0
~@f_println(hand_clip&," "+tim$+"  up "+STR$(VAL(uphour$))+":"+uptime$+",  "+STR$(connected_user&)+" user,  load average: "+average1$+", "+average2$+", "+average3$)
ELSE
~@f_println(hand_clip&," "+tim$+"  up "+STR$(updays%)+" days "+STR$(VAL(uphour$))+":"+uptime$+",  "+STR$(connected_user&)+" user,  load average: "+average1$+", "+average2$+", "+average3$)
ENDIF
~@f_close(hand_clip&)
ENDIF
@c_drive(ASC(UPPER$(LEFT$(clip$,1)))-65)
RETURN
> PROCEDURE dumpclip
~GRAF_MOUSE(busy_bee&,0)
OPEN "O",#1,clip$
PRINT #1,"####  MiNT setter V"+version$+" Dump  ####"
PRINT #1,"For: "+user$;"@"+hostname$
PRINT #1,""
PRINT #1,"TOS version: "+tosversval$
PRINT #1,"GEMDOS version (in ROM): "+gemdosval$
PRINT #1,"AES version: "+aesvers$
IF naes%>0
PRINT #1,"N_AES detected, version: "+naesvers$
IF BTST(naesflg&,0)<>0
PRINT #1,"                030-version,"
ELSE
PRINT #1,"                ST-version,"
ENDIF
IF BTST(naesflg&,1)<>0
PRINT #1,"                DEBUG."
ELSE
PRINT #1,"                USER."
ENDIF
ENDIF
PRINT #1,"MiNT version: "+mintval$
PRINT #1,"MiNT date: "+mintdate$
PRINT #1,"MiNT optimized for: 680"+cpu$
PRINT #1,"Kernel name: "+kname$
PRINT #1,"Compiler name: "+cname$
PRINT #1,"Compiler version: "+cversion$
PRINT #1,"Compiler definitions: "+cdefine$
PRINT #1,"Compiler flags: "+coptim$
PRINT #1,""
IF timeslice&>-1
PRINT #1,"Timeslice: ";timeslice&
ELSE
PRINT #1,"Timeslice: Not Set"
ENDIF
PRINT #1,"Security:  ";security&
sync&=@ssystem(sync_time&,-1,0)
IF sync&<0
PRINT #1,"Filesystem Sync-Time: Not Set"
ELSE
PRINT #1,"Filesystem Sync-Time: ";sync&
ENDIF
PRINT #1,"Memory protection: "+mp$
PRINT #1,"Virtual RAM:       "+vm$
IF av_notloaded|=1
PRINT #1,"AVSERVER: "+prog$+" and NOT running."
ELSE
PRINT #1,"AVSERVER: "+prog$+" and running."
ENDIF
PRINT #1,"UNIXMODE: "+unixmode$
PRINT #1,"USER:     "+user$
PRINT #1,"HOME directory: "+home$
PRINT #1,""
PRINT #1,"Sysconf():"
PRINT #1,"max number of memory regions per process: ";
IF @sysconf(0)=&H7FFFFFFF
PRINT #1,"unlimited"
ELSE
PRINT #1,@sysconf(0)
ENDIF
PRINT #1,"max length of Pexec() command line string: ";
IF @sysconf(1)=&H7FFFFFFF
PRINT #1,"unlimited"
ELSE
PRINT #1,@sysconf(1)
ENDIF
PRINT #1,"max number of open files per process: ";
IF @sysconf(2)=&H7FFFFFFF
PRINT #1,"unlimited"
ELSE
PRINT #1,@sysconf(2)
ENDIF
PRINT #1,"number of supplementary group id's: ";
IF @sysconf(3)=&H7FFFFFFF
PRINT #1,"unlimited"
ELSE
PRINT #1,@sysconf(3)
ENDIF
PRINT #1,"max number of processes per user: ";
IF @sysconf(4)=&H7FFFFFFF
PRINT #1,"unlimited"
ELSE
PRINT #1,@sysconf(4)
ENDIF
PRINT #1,""
IF debug_level&<0 OR debug_device&<0
PRINT #1,"Kernal debug (level) and (device) not implemented in ssystem() yet."
ELSE
PRINT #1,"Kernal debug level: ";debug_level&
PRINT #1,"Kernal debug device: ";@device$(debug_device&)
ENDIF
IF @exist(@boot$+":\mint.cnf")=TRUE
PRINT #1,"MiNT kernal loads with "+@boot$+":\mint.cnf"
ENDIF
IF @exist(@boot$+":\mint\mint.cnf")=TRUE
PRINT #1,"MiNT kernal loads with "+@boot$+":\mint\mint.cnf"
ENDIF
IF @exist(@boot$+":\multitos\mint.cnf")=TRUE
PRINT #1,"MiNT kernal loads with "+@boot$+":\multitos\mint.cnf"
ENDIF
PRINT #1,"GEM CLIPBOARD PATH (scrp_read()): "+clipboard_path$
PRINT #1,""
@caches
PRINT #1,""
PRINT #1,"############ EOF ############"
CLOSE #1
~GRAF_MOUSE(arrow&,0)
@c_drive(ASC(UPPER$(LEFT$(clip$,1)))-65)
RETURN
> PROCEDURE users
IF nouser|=0
text$=""
b&=0
many_user&=0
connected_user&=0
IF @exist("u:\etc\utmp")=TRUE
OPEN "I",#1,"u:\etc\utmp"     ! parse the utmp file to fetch users data
FOR b&=1 TO LOF(#1)
bt|=INP(#1)
IF bt|<32
bt|=32
ENDIF
text$=text$+CHR$(bt|)
NEXT b&
many_user&=(b&-1)/36
CLOSE #1
'
FOR b&=0 TO many_user&-1
nam$(connected_user&)=MID$(text$,b&*36+9,8)
IF LEFT$(nam$(connected_user&),1)>CHR$(32)
line$(connected_user&)=MID$(text$,b&*36+1,8)
host$(connected_user&)=MID$(text$,b&*36+17,16)
INC connected_user&
ENDIF
NEXT b&
b&=0
many_user&=connected_user&
ELSE
nouser|=1
@switch_obj(tree%,user_icon&,disabled&)
@switch_obj(tree%,user_number_val&,disabled&)
ENDIF
ENDIF
RETURN
> PROCEDURE dumpcookie
cookie_number&=0
cookies$(0)=""
IF @exist(program_path$+"cookie.dat")=TRUE
OPEN "I",#2,program_path$+"cookie.dat"
~GRAF_MOUSE(busy_bee&,0)
FOR b&=1 TO LOF(#2)
bt|=INP(#2)
IF bt|=10
INC cookie_number&
cookies$(cookie_number&)=""
ELSE
cookies$(cookie_number&)=cookies$(cookie_number&)+CHR$(bt|)
ENDIF
NEXT b&
CLOSE #2
~GRAF_MOUSE(arrow&,0)
ENDIF
~GRAF_MOUSE(busy_bee&,0)
OPEN "O",#1,clip$
PRINT #1,"####  MiNT setter V"+version$+" Cookie Dump  ####"
count&=0
tag_id%=0
PRINT #1,"Hex Val  :  ID  : Description"
PRINT #1,""
DO UNTIL tag_id%=-1
found|=0
count&=count&+1
tag_id%=@ssystem(getcookie&,count&,0)
IF tag_id%>0
FOR n&=0 TO cookie_number&
IF INSTR(CHAR{V:tag_id%},LEFT$(cookies$(n&),4))
found|=1
PRINT #1,HEX$(@ssystem(getcookie&,tag_id%,0),8)+" : "+cookies$(n&)
ENDIF
NEXT n&
IF found|=0
PRINT #1,HEX$(@ssystem(getcookie&,tag_id%,0),8)+" : "+CHAR{V:tag_id%}
ENDIF
ENDIF
LOOP
PRINT #1,""
PRINT #1,"################## EOF #################"
CLOSE #1
~GRAF_MOUSE(arrow&,0)
@c_drive(ASC(UPPER$(LEFT$(clip$,1)))-65)
RETURN
> FUNCTION exist(p$) !v0.02
$F%
LOCAL r!,e&,sdta%
INLINE dta%,64
p$=p$+CHR$(FALSE)
sdta%=GEMDOS(47) !get old dta
~GEMDOS(26,L:dta%) !set new dta
e&=GEMDOS(78,L:V:p$,W:FALSE)
~GEMDOS(26,L:sdta%) !reset old dta
IF e&=FALSE
r!=TRUE
ELSE
r!=FALSE
ENDIF
RETURN r!
ENDFUNC
> PROCEDURE rsc_define                ! just setting the object names to numbers, easier to handle
REM Indice du ressource pour MINTSETT
'
LET main&=0 ! Formulaire/Dialogue
LET ffl&=2 ! USERDEF dans l'arbre MAIN
LET icon_alert&=3 ! USERDEF dans l'arbre MAIN
LET icon_inetd&=4 ! USERDEF dans l'arbre MAIN
LET icon&=8 ! USERDEF dans l'arbre MAIN
LET beta&=9 ! FTEXT dans l'arbre MAIN
LET days_val&=16 ! FTEXT dans l'arbre MAIN
LET mintdate&=19 ! FTEXT dans l'arbre MAIN
LET hours_val&=20 ! FTEXT dans l'arbre MAIN
LET mintvers&=21 ! FTEXT dans l'arbre MAIN
LET load_button&=22 ! BUTTON dans l'arbre MAIN
LET optimized&=24 ! FTEXT dans l'arbre MAIN
LET tosvers&=25 ! FTEXT dans l'arbre MAIN
LET gemdosvers&=26 ! FTEXT dans l'arbre MAIN
LET aesversion&=27 ! FTEXT dans l'arbre MAIN
LET more&=28 ! USERDEF dans l'arbre MAIN
LET w_vfat&=29 ! USERDEF dans l'arbre MAIN
LET cookie_icon&=30 ! USERDEF dans l'arbre MAIN
LET clip&=31 ! USERDEF dans l'arbre MAIN
LET user_icon&=32 ! USERDEF dans l'arbre MAIN
LET user_number_val&=33 ! FTEXT dans l'arbre MAIN
LET avstring&=38 ! STRING dans l'arbre MAIN
LET update_val&=42 ! FTEXT dans l'arbre MAIN
LET av&=43 ! FTEXT dans l'arbre MAIN
LET unix&=44 ! FTEXT dans l'arbre MAIN
LET user&=45 ! FTEXT dans l'arbre MAIN
LET ok&=46 ! BUTTON dans l'arbre MAIN
LET tsminus&=47 ! USERDEF dans l'arbre MAIN
LET slminus&=48 ! USERDEF dans l'arbre MAIN
LET mp&=49 ! FTEXT dans l'arbre MAIN
LET vm&=50 ! FTEXT dans l'arbre MAIN
LET ts&=51 ! TEXT dans l'arbre MAIN
LET sl&=52 ! TEXT dans l'arbre MAIN
LET tsplus&=53 ! USERDEF dans l'arbre MAIN
LET slplus&=54 ! USERDEF dans l'arbre MAIN
LET cpu_icon&=55 ! USERDEF dans l'arbre MAIN
'
LET sysc&=1 ! Formulaire/Dialogue
LET memarea&=2 ! FTEXT dans l'arbre SYSC
LET pex&=8 ! FTEXT dans l'arbre SYSC
LET grpid&=9 ! FTEXT dans l'arbre SYSC
LET ppuser&=10 ! FTEXT dans l'arbre SYSC
LET pproc&=11 ! FTEXT dans l'arbre SYSC
LET klevel&=13 ! FTEXT dans l'arbre SYSC
LET kdev&=15 ! FTEXT dans l'arbre SYSC
'
LET vfat&=2 ! Formulaire/Dialogue
LET fatdrive&=2 ! TEXT dans l'arbre VFAT
LET drplus&=3 ! USERDEF dans l'arbre VFAT
LET drminus&=4 ! USERDEF dans l'arbre VFAT
LET icon_vfat&=7 ! USERDEF dans l'arbre VFAT
LET icon_wb&=9 ! USERDEF dans l'arbre VFAT
LET vfat_ok&=10 ! BUTTON dans l'arbre VFAT
LET icon_floppy&=11 ! USERDEF dans l'arbre VFAT
LET label_val&=12 ! FTEXT dans l'arbre VFAT
LET fs_time&=15 ! FTEXT dans l'arbre VFAT
LET cache&=18 ! FTEXT dans l'arbre VFAT
LET pointer_cache&=21 ! USERDEF dans l'arbre VFAT
'
LET popup&=3 ! Formulaire/Dialogue
'
LET w_user&=4 ! Formulaire/Dialogue
LET user_val&=2 ! TEXT dans l'arbre W_USER
LET user_plus&=3 ! USERDEF dans l'arbre W_USER
LET user_minus&=4 ! USERDEF dans l'arbre W_USER
LET user_ok&=6 ! BUTTON dans l'arbre W_USER
LET term_val&=7 ! TEXT dans l'arbre W_USER
LET host_val&=8 ! TEXT dans l'arbre W_USER
'
LET popup2&=5 ! Formulaire/Dialogue
'
LET pop_sync&=6 ! Formulaire/Dialogue
'
LET pop_lev&=7 ! Formulaire/Dialogue
'
LET pop_dev&=8 ! Formulaire/Dialogue
'
LET w_cache&=9 ! Formulaire/Dialogue
LET i_cache&=13 ! USERDEF dans l'arbre W_CACHE
LET d_cache&=14 ! USERDEF dans l'arbre W_CACHE
LET b_cache&=15 ! USERDEF dans l'arbre W_CACHE
LET w_buffer&=16 ! USERDEF dans l'arbre W_CACHE
LET i_burst&=17 ! USERDEF dans l'arbre W_CACHE
LET d_burst&=18 ! USERDEF dans l'arbre W_CACHE
LET i_fmode&=19 ! USERDEF dans l'arbre W_CACHE
LET d_fmode&=20 ! USERDEF dans l'arbre W_CACHE
LET i_readwrite&=21 ! USERDEF dans l'arbre W_CACHE
LET d_walloc&=22 ! USERDEF dans l'arbre W_CACHE
LET d_ralloc&=23 ! USERDEF dans l'arbre W_CACHE
'
RETURN
'
> PROCEDURE include                     ! includes for lib
@aes.h
' @vdi.h
' @bios.h
' @xbios.h
@gemdos.h
@system.h
' @xcontrol.h
RETURN
> PROCEDURE aes.h
LET aes_largefont&=0
LET aes_smallfont&=1
LET aes_system&=2
LET aes_language&=3
LET aes_environ1&=4
LET aes_environ2&=5
LET aes_environ3&=6
LET aes_osextensions&=7
LET aes_mouse&=8
LET aes_menu&=9
LET aes_shelwrite&=10
LET aes_window&=11
LET aes_message&=12
LET aes_object&=13
LET aes_form&=14
LET system_font&=0
LET outline_font&=1
LET aeslang_english&=0
LET aeslang_german&=1
LET aeslang_french&=2
LET aeslang_spanish&=4
LET aeslang_italian&=5
LET aeslang_swedish&=6
LET has_wftop&=&H1
LET has_wfnewdesk&=&H2
LET has_wfcolor&=&H4
LET has_wfdcolor&=&H8
LET has_wfowner&=&H10
LET has_wfbevent&=&H20
LET has_wfbottom&=&H40
LET has_wficonify&=&H80
LET has_wfuniconify&=&H100
LET has_iconifier&=&H1
LET has_bottomer&=&H2
LET has_shiftclick&=&H4
LET has_hotclosebox&=&H8
LET has_wmnewtop&=&H1
LET has_wmuntopped&=&H2
LET has_wmontop&=&H4
LET has_apterm&=&H8
LET has_reschange&=&H10
LET has_chexit&=&H20
LET has_wmbottom&=&H40
LET has_wmiconify&=&H80
LET has_wmuniconify&=&H100
LET has_wmalliconify&=&H200
LET apr_nowait&=-1
LET app_first&=0
LET app_next&=1
LET app_system&=0
LET app_application&=1
LET app_accessory&=2
LET appevnt_timer&=0
LET appevnt_button&=1
LET appevnt_mouse&=2
LET appevnt_keyboard&=3
LET left_button&=&H1
LET right_button&=&H2
LET middle_button&=&H4
LET edc_inquire&=0
LET edc_set&=1
LET mu_keybd&=&H1
LET mu_button&=&H2
LET mu_m1&=&H4
LET mu_m2&=&H8
LET mu_mesag&=&H10
LET mu_timer&=&H20
LET mn_selected&=10
LET wm_redraw&=20
LET wm_topped&=21
LET wm_closed&=22
LET wm_fulled&=23
LET wm_arrowed&=24
LET wm_hslid&=25
LET wm_vslid&=26
LET wm_sized&=27
LET wm_moved&=28
LET wm_untopped&=30
LET wm_ontop&=31
LET wm_bottom&=33
LET wm_iconify&=34
LET wm_uniconify&=35
LET wm_alliconify&=36
LET wm_toolbar&=37
LET ac_open&=40
LET ac_close&=41
LET ap_term&=50
LET ap_tfail&=51
LET ap_reschg&=57
LET shut_completed&=60
LET resch_failed&=61
LET ap_dragdrop&=63
LET sh_wdraw&=72
LET all_drives&=-1
LET ch_exit&=90
LET ct_update&=50
LET ct_move&=51
LET ct_newtop&=52
LET ct_key&=53
LET wa_uppage&=0
LET wa_dnpage&=1
LET wa_upline&=2
LET wa_dnline&=3
LET wa_lfpage&=4
LET wa_rtpage&=5
LET wa_lfline&=6
LET wa_rtline&=7
LET mo_enter&=0
LET mo_leave&=1
LET fmd_start&=0
LET fmd_grow&=1
LET fmd_shrink&=2
LET fmd_finish&=3
LET ferr_filenotfound&=2
LET ferr_pathnotfound&=3
LET ferr_nohandles&=4
LET ferr_accessdenied&=5
LET ferr_lowmem&=8
LET ferr_badenviron&=10
LET ferr_badformat&=11
LET ferr_baddrive&=15
LET ferr_deletedir&=16
LET ferr_nofile&=18
LET fsel_ok&=1
LET fsel_cancel&=0
LET arrow&=0
LET text_crsr&=1
LET busy_bee&=2
LET point_hand&=3
LET flat_hand&=4
LET thin_cross&=5
LET thick_cross&=6
LET outln_cross&=7
LET user_def&=255
LET m_off&=256
LET m_on&=257
LET m_save&=258
LET m_last&=259
LET m_restore&=260
LET m_force%=&H8000
LET vertical&=0
LET horizontal&=1
LET scroll_yes&=1
LET scroll_no&=0
LET scroll_listbox&=-1
LET me_inquire&=0
LET me_attach&=1
LET me_remove&=2
LET menu_remove&=0
LET menu_install&=1
LET menu_inquire&=-1
LET enable&=1
LET disable&=0
LET check&=1
LET uncheck&=0
LET highlight&=0
LET unhighlight&=1
LET mis_setalign&=1
LET mis_getalign&=0
LET reg_newname&=-1
LET mn_inquire&=0
LET mn_change&=1
LET root&=0
LET max_depth&=8
LET ip_hollow&=0
LET ip_1patt&=1
LET ip_2patt&=2
LET ip_3patt&=3
LET ip_4patt&=4
LET ip_5patt&=5
LET ip_6patt&=6
LET ip_solid&=7
LET gdos_prop&=0
LET gdos_mono&=1
LET gdos_bitm&=2
LET ibm&=3
LET small&=5
LET g_box&=20
LET g_text&=21
LET g_boxtext&=22
LET g_image&=23
LET g_progdef&=24
LET g_userdef&=24
LET g_ibox&=25
LET g_button&=26
LET g_boxchar&=27
LET g_string&=28
LET g_ftext&=29
LET g_fboxtext&=30
LET g_icon&=31
LET g_title&=32
LET g_cicon&=33
LET none&=&H0
LET selectable&=&H1
LET default&=&H2
LET exit&=&H4
LET editable&=&H8
LET rbutton&=&H10
LET lastob&=&H20
LET touchexit&=&H40
LET hidetree&=&H80
LET indirect&=&H100
LET fl3dind&=&H200
LET fl3dbak&=&H400
LET fl3dact&=&H600
LET submnu&=&H800
LET normal&=&H0
LET selected&=&H1
LET crossed&=&H2
LET checked&=&H4
LET disabled&=&H8
LET outlined&=&H10
LET shadowed&=&H20
LET special&=&H40
LET white&=0
LET black&=1
LET red&=2
LET green&=3
LET blue&=4
LET cyan&=5
LET yellow&=6
LET magenta&=7
LET lwhite&=8
LET lblack&=9
LET lred&=10
LET lgreen&=11
LET lblue&=12
LET lcyan&=13
LET lyellow&=14
LET lmagenta&=15
LET te_left&=0
LET te_right&=1
LET te_cntr&=2
LET no_draw&=0
LET redraw&=1
LET ed_start&=0
LET ed_init&=1
LET ed_char&=2
LET ed_end&=3
LET oo_last&=-1
LET oo_first&=0
LET sv_inquire&=0
LET sv_set&=1
LET lk3dind&=1
LET lk3dact&=2
LET indbutcol&=3
LET actbutcol&=4
LET backgrcol&=5
LET ad3dval&=6
LET ad3dvalue&=6
LET r_tree&=0
LET r_object&=1
LET r_tedinfo&=2
LET r_iconblk&=3
LET r_bitblk&=4
LET r_string&=5
LET r_imagedata&=6
LET r_obspec&=7
LET r_teptext&=8
LET r_teptmplt&=9
LET r_tepvalid&=10
LET r_ibpmask&=11
LET r_ibpdata&=12
LET r_ibptext&=13
LET r_bipdata&=14
LET r_frstr&=15
LET r_frimg&=16
LET shell_bufsiz&=-1
LET swm_launch&=0
LET swm_launchnow&=1
LET swm_launchacc&=3
LET swm_shutdown&=4
LET swm_rezchange&=5
LET swm_broadcast&=7
LET swm_environ&=8
LET swm_newmsg&=9
LET swm_aesmsg&=10
LET sw_psetlimit&=&H100
LET sw_prenice&=&H200
LET sw_defdir&=&H400
LET sw_environ&=&H800
LET cl_normal&=0
LET cl_argv&=1
LET sd_abort&=0
LET sd_partial&=1
LET sd_complete&=2
LET environ_size&=0
LET environ_change&=1
LET environ_copy&=2
LET nm_apterm&=&H1
LET name&=&H1
LET close&=&H2
LET closer&=&H2
LET full&=&H4
LET fuller&=&H4
LET move&=&H8
LET mover&=&H8
LET info&=&H10
LET size&=&H20
LET sizer&=&H20
LET uparrow&=&H40
LET dnarrow&=&H80
LET vslide&=&H100
LET lfarrow&=&H200
LET rtarrow&=&H400
LET hslide&=&H800
LET smaller&=&H4000
LET desk&=0
LET wf_kind&=1
LET wf_name&=2
LET wf_info&=3
LET wf_wxywh&=4
LET wf_workxywh&=4
LET wf_cxywh&=5
LET wf_currxywh&=5
LET wf_pxywh&=6
LET wf_prevxywh&=6
LET wf_fxywh&=7
LET wf_fullxywh&=7
LET wf_hslide&=8
LET wf_vslide&=9
LET wf_top&=10
LET wf_firstxywh&=11
LET wf_nextxywh&=12
LET wf_ignore&=13
LET wf_newdesk&=14
LET wf_hslsize&=15
LET wf_hslsiz&=15
LET wf_vslsize&=16
LET wf_vslsiz&=16
LET wf_screen&=17
LET wf_color&=18
LET wf_dcolor&=19
LET wf_owner&=20
LET wf_bevent&=24
LET wf_bottom&=25
LET wf_iconify&=26
LET wf_uniconify&=27
LET wf_toolbar&=30
LET wf_ftoolbar&=31
LET wf_ntoolbar&=32
LET w_box&=0
LET w_title&=1
LET w_closer&=2
LET w_name&=3
LET w_fuller&=4
LET w_info&=5
LET w_data&=6
LET w_work&=7
LET w_sizer&=8
LET w_vbar&=9
LET w_uparrow&=10
LET w_dnarrow&=11
LET w_vslide&=12
LET w_velev&=13
LET w_hbar&=14
LET w_lfarrow&=15
LET w_rtarrow&=16
LET w_hslide&=17
LET w_helev&=18
LET w_smaller&=19
LET b_untoppable&=&H1
LET end_update&=0
LET beg_update&=1
LET end_mctrl&=2
LET beg_mctrl&=3
LET no_block&=&H100
LET wc_border&=0
LET wc_work&=1
LET dd_ok&=0
LET dd_nak&=1
LET dd_ext&=2
LET dd_len&=3
LET dd_trash&=4
LET dd_printer&=5
LET dd_clipboard&=6
LET dd_timeout&=4000
LET dd_numexts&=8
LET dd_extsize&=32
LET nil&=-1
LET obnil&=-1
LET obroot&=0
LET obmaxlen&=81
LET obmaxdepth&=8
LET obnone&=&H0
LET obselectable&=&H1
LET obdefault&=&H2
LET obexit&=&H4
LET obeditable&=&H8
LET obradio&=&H10
LET oblastob&=&H20
LET obtouchexit&=&H40
LET obhidetree&=&H80
LET obindirect&=&H100
LET obfl3dind&=&H200
LET obfl3dbak&=&H400
LET obfl3dact&=&H600
LET obfl3dmask&=&H600
LET obfl3dnone&=&H0
LET obsubmenu&=&H800
LET obnormal&=&H0
LET obselected&=&H1
LET obcrossed&=&H2
LET obchecked&=&H4
LET obdisabled&=&H8
LET oboutlined&=&H10
LET obshadowed&=&H20
LET tegdosprop&=0
LET tegdosmono&=1
LET tegdosbitm&=2
LET tesystemfont&=3
LET tesmallfont&=5
LET modereplace&=1
LET modetransparent&=0
RETURN
> PROCEDURE vdi.h
LET bez_polyline&=&H0
LET bez_bezier&=&H1
LET bez_nodraw&=&H2
LET scaling_fractional&=0
LET scaling_integer&=1
LET image_left&=0
LET image_top&=0
LET image_center&=1
LET image_right&=2
LET image_bottom&=2
LET other_color&=-1
LET nojustify&=0
LET justify&=1
LET default_plotter&=11
LET default_printer&=21
LET metafile_driver&=31
LET memory_driver&=61
LET reset_mouse&=0
LET nest_mouse&=1
LET slm_ok&=&H0
LET slm_onery&=&H2
LET slm_notoner&=&H3
LET slm_nopaper&=&H5
LET color_requested&=0
LET color_actual&=1
LET vq_base&=0
LET vq_extended&=1
LET gdos_none&=&HFFFFFFFE
LET gdos_fsm%=&H5F46534D
LET gdos_fnt%=&H5F464E54
LET locator&=0
LET valuator&=1
LET choice&=2
LET string&=3
LET request_mode&=1
LET sample_mode&=2
LET cache_char&=0
LET cache_misc&=1
LET dev_missing&=0
LET dev_installed&=1
LET outline_font&=1
LET bitmap_font&=0
LET vdi_device&=0
LET vdi_standard&=1
LET all_white&=0
LET s_and_d&=1
LET s_and_notd&=2
LET s_only&=3
LET nots_and_d&=4
LET d_only&=5
LET s_xor_d&=6
LET s_or_d&=7
LET not_sord&=8
LET not_sxord&=9
LET not_d&=10
LET s_or_notd&=11
LET not_s&=12
LET nots_or_d&=13
LET not_sandd&=14
LET all_black&=15
LET clip_on&=1
LET clip_off&=0
LET fis_hollow&=0
LET fis_solid&=1
LET fis_pattern&=2
LET fis_hatch&=3
LET fis_user&=4
LET dots&=3
LET grid&=6
LET bricks&=9
LET weave&=16
LET solid&=1
LET ldashed&=2
LET longdash&=2
LET dotted&=3
LET dot&=3
LET dashdot&=4
LET dashed&=5
LET dash&=5
LET dashdotdot&=6
LET dash2dot&=6
LET userline&=7
LET square&=0
LET arrowed&=1
LET round&=2
LET mrkr_dot&=1
LET mrkr_plus&=2
LET mrkr_asterisk&=3
LET mrkr_box&=4
LET mrkr_cross&=5
LET mrkr_diamond&=6
LET thickened&=&H1
LET light&=&H2
LET skewed&=&H4
LET underlined&=&H8
LET outline&=&H10
LET shadow&=&H20
LET md_replace&=1
LET md_trans&=2
LET md_xor&=3
LET md_erase&=4
LET perimeter_on&=1
LET perimeter_off&=0
LET map_atari&=1
LET map_bitstream&=0
LET app_error&=0
LET screen_error&=1
LET pair_off&=0
LET pair_on&=1
LET tracking_none&=0
LET tracking_normal&=1
LET tracking_tight&=2
LET tracking_verytight&=3
LET scratch_both&=0
LET scratch_bitmap&=1
LET scratch_none&=2
RETURN
> PROCEDURE bios.h
LET error&=-1
LET edrvnr&=-2
LET euncmd&=-3
LET e_crc&=-4
LET ebadrq&=-5
LET e_seek&=-6
LET emedia&=-7
LET esecnf&=-8
LET epaper&=-9
LET ewritf&=-10
LET ereadf&=-11
LET ewrpro&=-13
LET e_chng&=-14
LET eundev&=-15
LET ebadsf&=-16
LET eother&=-17
LET gem_magic%=&H87654321
LET usa&=0
LET germany&=1
LET france&=2
LET uk&=3
LET spain&=4
LET italy&=5
LET sweden&=6
LET fswitzerland&=7
LET gswitzerland&=8
LET turkey&=9
LET finland&=10
LET norway&=11
LET denmark&=12
LET saudiarabia&=13
LET holland&=14
LET czechoslovakia&=15
LET hungary&=16
LET all_countries&=127
LET last_cookie&=0
LET cpu_cookie%=CVL("_CPU")
LET video_cookie%=CVL("_VDO")
LET fpu_cookie%=CVL("_FPU")
LET floppy_cookie%=CVL("_FDC")
LET sound_cookie%=CVL("_SND")
LET machine_cookie%=CVL("_MCH")
LET switch_cookie%=CVL("_SWI")
LET fastram_cookie%=CVL("_FRB")
LET flock_cookie%=CVL("_FLK")
LET network_cookie%=CVL("_NET")
LET datetime_cookie%=CVL("_IDT")
LET keyboard_cookie%=CVL("_AKP")
LET gdos_cookie%=CVL("FSMC")
LET mint_cookie%=CVL("MiNT")
LET cpu_68000&=&H0
LET cpu_68010&=&HA
LET cpu_68020&=&H14
LET cpu_68030&=&H1E
LET cpu_68040&=&H28
LET video_st&=&H0
LET video_ste%=&H10000
LET video_tt%=&H20000
LET video_falcon%=&H30000
LET fpu_none&=0
LET fpu_sfp&=1
LET fpu_6888x&=2
LET fpu_6888xwsfp&=3
LET fpu_68881&=4
LET fpu_68881wsfp&=5
LET fpu_68882&=6
LET fpu_68882wsfp&=7
LET fpu_68040&=8
LET fpu_68040wsfp&=9
LET floppy_atari%=&H415443
LET floppy_dsdd&=0
LET floppy_dshd&=1
LET floppy_dsed&=2
LET sound_psg&=&H1
LET sound_dmastereo&=&H2
LET sound_dmarecord&=&H4
LET sound_xbios&=&H4
LET sound_codec&=&H8
LET sound_dsp&=&H10
LET machine_st&=&H0
LET machine_ste%=&H10000
LET machine_stbook%=&H10008
LET machine_megaste%=&H1000F
LET machine_tt%=&H20000
LET machine_falcon%=&H30000
LET date_mmddyy&=0
LET date_ddmmyy&=1
LET date_yymmdd&=2
LET date_yyddmm&=3
LET time_12hour&=0
LET time_24hour&=1
LET dev_printer&=0
LET dev_prn&=0
LET dev_modem&=1
LET dev_aux&=1
LET dev_con&=2
LET dev_console&=2
LET dev_midi&=3
LET dev_ikbd&=4
LET dev_raw&=5
LET dev_ttmodem1&=6
LET dev_ttmodem2&=7
LET dev_ttserial1&=8
LET dev_ttserial2&=9
LET dev_falconmodem&=7
LET dev_falconlan&=8
LET k_rshift&=&H1
LET k_lshift&=&H2
LET k_ctrl&=&H4
LET k_alt&=&H8
LET k_capslock&=&H10
LET k_clrhome&=&H20
LET k_insert&=&H40
LET med_nochange&=0
LET med_unknown&=1
LET med_change&=2
LET rw_read&=&H0
LET rw_write&=&H1
LET rw_usemediach&=&H0
LET rw_ignoremediach&=&H2
LET rw_retries&=&H0
LET rw_noretries&=&H4
LET rw_translate&=&H0
LET rw_notranslate&=&H8
LET vec_buserror&=&H2
LET vec_addresserror&=&H3
LET vec_illegalinstruction&=&H4
LET vec_dividebyzero&=&H5
LET vec_chkinstruction&=&H6
LET vec_trapxinstruction&=&H7
LET vec_privilegeviolation&=&H8
LET vec_traceexception&=&H9
LET vec_linea&=&HA
LET vec_linef&=&HB
LET vec_protocolviolation&=&HD
LET vec_formaterror&=&HE
LET vec_unintializedinterrupt&=&HF
LET vec_spuriousinterrupt&=&H18
LET vec_av1&=&H19
LET vec_av2&=&H1A
LET vec_av3&=&H1B
LET vec_av4&=&H1C
LET vec_av5&=&H1D
LET vec_av6&=&H1E
LET vec_av7&=&H1F
LET vec_trap0&=&H20
LET vec_trap1&=&H21
LET vec_gemdos&=&H21
LET vec_trap2&=&H22
LET vec_gem&=&H22
LET vec_trap3&=&H23
LET vec_trap4&=&H24
LET vec_trap5&=&H25
LET vec_trap6&=&H26
LET vec_trap7&=&H27
LET vec_trap8&=&H28
LET vec_trap9&=&H29
LET vec_trap10&=&H2A
LET vec_trap11&=&H2B
LET vec_trap12&=&H2C
LET vec_trap13&=&H2D
LET vec_bios&=&H2D
LET vec_trap14&=&H2E
LET vec_xbios&=&H2E
LET vec_trap15&=&H2F
LET vec_fpbsuc&=&H30
LET vec_fpinexactresult&=&H31
LET vec_fpdividebyzero&=&H32
LET vec_fpunderflow&=&H33
LET vec_fpoperanderror&=&H34
LET vec_fpoverflow&=&H35
LET vec_fpsignalingnan&=&H36
LET vec_mmuconfigerror&=&H37
LET vec_mmuillegalop&=&H38
LET vec_mmuaccessviolation&=&H39
LET vec_stmfp0&=&H40
LET vec_stmfp1&=&H41
LET vec_stmfp2&=&H42
LET vec_stmfp3&=&H43
LET vec_stmfptimerd&=&H44
LET vec_stmfptimerc&=&H45
LET vec_stmfp4&=&H46
LET vec_stmfp5&=&H47
LET vec_stmfptimerb&=&H48
LET vec_stmfptransmiterror&=&H49
LET vec_stmfptransmitbuffer&=&H4A
LET vec_stmfprecieveerror&=&H4B
LET vec_stmfprecievebuffer&=&H4C
LET vec_stmfptimera&=&H4D
LET vec_stmfp6&=&H4E
LET vec_stmfp7&=&H4F
LET vec_ttmfp0&=&H50
LET vec_ttmfp1&=&H51
LET vec_ttmfp2&=&H52
LET vec_ttmfp3&=&H53
LET vec_ttmfptimerd&=&H54
LET vec_ttmfptimerc&=&H55
LET vec_ttmfp4&=&H56
LET vec_ttmfp5&=&H57
LET vec_ttmfptimerb&=&H58
LET vec_ttmfptransmiterror&=&H59
LET vec_ttmfptransmitbuffer&=&H5A
LET vec_ttmfprecieveerror&=&H5B
LET vec_ttmfprecievebuffer&=&H5C
LET vec_ttmfptimera&=&H5D
LET vec_ttmfp6&=&H5E
LET vec_ttmfp7&=&H5F
LET vec_sccbtransmitbuffer&=&H60
LET vec_sccbexternalstatus&=&H62
LET vec_sccbreceivechar&=&H64
LET vec_sccbreceivecondition&=&H66
LET vec_sccatransmitbuffer&=&H68
LET vec_sccaexternalstatus&=&H6A
LET vec_sccareceivechar&=&H6C
LET vec_sccareceivecondition&=&H6E
LET vec_timer&=&H100
LET vec_criticalerror&=&H101
LET vec_terminate&=&H102
RETURN
> PROCEDURE xbios.h
LET bmap_check&=0
LET bmap_inquire&=-1
LET bmap_maptab&=-2
LET blit_soft&=&H0
LET blit_hard&=&H1
LET blit_inquire&=-1
LET play_enable&=&H1
LET play_repeat&=&H2
LET record_enable&=&H4
LET record_repeat&=&H8
LET curs_hide&=0
LET curs_show&=1
LET curs_blink&=2
LET curs_noblink&=3
LET curs_setrate&=4
LET curs_getrate&=5
LET db_nullstring%=&HF000
LET db_command%=&HF100
LET adc&=3
LET extinp&=2
LET dspxmit&=1
LET dmaplay&=0
LET dac&=&H8
LET extout&=&H4
LET dsprecv&=&H2
LET dmarec&=&H1
LET clk_25m&=0
LET clk_ext&=1
LET clk_32m&=2
LET no_shake&=1
LET handshake&=0
LET clk_compat&=0
LET clk50k&=1
LET clk33k&=2
LET clk25k&=3
LET clk20k&=4
LET clk16k&=5
LET clk12k&=7
LET clk10k&=9
LET clk8k&=11
LET act_clk50k%=49170
LET act_clk33k%=33880
LET act_clk25k&=24585
LET act_clk20k&=20770
LET act_clk16k&=16490
LET act_clk12k&=12292
LET act_clk10k&=9834
LET act_clk8k&=8195
LET ds_inquire&=-1
LET hf_clear&=0
LET hf_set&=1
LET hf_inquire&=-1
LET icr_rxdf&=&H1
LET icr_txde&=&H2
LET icr_trdy&=&H4
LET icr_hf2&=&H8
LET icr_hf3&=&H10
LET icr_dma&=&H40
LET icr_hreq&=&H80
LET block_long&=0
LET block_word&=1
LET block_ubyte&=2
LET rts_off&=&H1
LET rtr_off&=&H2
LET dspsend_nothing&=&H0
LET dspsend_zero%=&HFF000000
LET dsp_enable&=1
LET dsp_tristate&=0
LET es_smear%=&H8000
LET es_gray&=&H1000
LET es_mode&=&H700
LET tt_low&=&H700
LET tt_high&=&H600
LET tt_med&=&H300
LET st_high&=&H200
LET st_med&=&H100
LET st_low&=&H0
LET es_bank&=&HF
LET bank_0&=&H0
LET bank_1&=&H1
LET bank_2&=&H2
LET bank_3&=&H3
LET bank_4&=&H4
LET bank_5&=&H5
LET bank_6&=&H6
LET bank_7&=&H7
LET bank_8&=&H8
LET bank_9&=&H9
LET bank_10&=&HA
LET bank_11&=&HB
LET bank_12&=&HC
LET bank_13&=&HD
LET bank_14&=&HE
LET bank_15&=&HF
LET esg_inquire&=-1
LET esg_color&=0
LET esg_gray&=1
LET esm_normal&=0
LET esm_smear&=1
LET esm_inquire&=-1
LET flop_drivea&=0
LET flop_driveb&=1
LET flop_side0&=0
LET flop_side1&=1
LET flop_noskew&=1
LET flop_skew&=-1
LET flop_magic%=&H87654321
LET flop_virgin%=&HE5E5
LET frate_inquire&=-1
LET frate_seek6&=0
LET frate_seek12&=1
LET frate_seek2&=2
LET frate_seek3&=3
LET psg_apitchlow&=0
LET psg_apitchhigh&=1
LET psg_bpitchlow&=2
LET psg_bpitchhigh&=3
LET psg_cpitchlow&=4
LET psg_cpitchhigh&=5
LET psg_whitenoisepitch&=6
LET psg_mode&=7
LET psg_avolume&=8
LET psg_bvolume&=9
LET psg_cvolume&=10
LET psg_freqlow&=11
LET psg_freqhigh&=12
LET psg_envelope&=13
LET psg_porta&=14
LET psg_portb&=15
LET psg_set&=&H80
LET psg_enablea&=&H1
LET psg_enableb&=&H2
LET psg_enablec&=&H4
LET psg_noisea&=&H8
LET psg_noiseb&=&H10
LET psg_noisec&=&H20
LET psg_portainput&=&H0
LET psg_portaoutput&=&H40
LET psg_portbinput&=&H0
LET psg_portboutput&=&H80
LET gpio_inquire&=0
LET gpio_read&=1
LET gpio_write&=2
LET gpio_pin1output&=&H0
LET gpio_pin1input&=&H1
LET gpio_pin2output&=&H0
LET gpio_pin2input&=&H2
LET gpio_pin3output&=&H0
LET gpio_pin3input&=&H4
LET im_disable&=1
LET im_relative&=2
LET im_absolute&=3
LET im_keycode&=4
LET io_serial&=0
LET io_keyboard&=1
LET io_midi&=2
LET kb_inquire&=-1
LET sndnotlocked&=-128
LET sndlocked&=-129
LET mfp_parallel&=0
LET mfp_dcd&=1
LET mfp_cts&=2
LET mfp_bitblt&=3
LET mfp_timerd&=4
LET mfp_baudrate&=4
LET mfp_timerc&=5
LET mfp_200hz&=5
LET mfp_ikbd&=6
LET mfp_disk&=7
LET mfp_timerb&=8
LET mfp_hblank&=8
LET mfp_transmiterror&=9
LET mfp_transmitbufferempty&=10
LET mfp_receiveerror&=11
LET mfp_receivebufferfull&=12
LET mfp_timera&=13
LET mfp_dmasound&=13
LET mfp_ringindicator&=14
LET mfp_monodetect&=15
LET nvm_read&=0
LET nvm_write&=1
LET nvm_reset&=2
LET gi_floppyside&=&H1
LET gi_floppya&=&H2
LET gi_floppyb&=&H4
LET gi_rts&=&H8
LET gi_dtr&=&H10
LET gi_strobe&=&H20
LET gi_gpo&=&H40
LET gi_reserved&=&H80
LET serial_nochange&=-1
LET serial_random%=&H1000000
LET disk_nochange&=-1
LET disk_sssd&=0
LET disk_dssd&=1
LET disk_ssdd&=2
LET disk_dsdd&=3
LET disk_dshd&=4
LET disk_dsed&=5
LET execute_nochange&=-1
LET execute_no&=0
LET execute_yes&=1
LET baud_19200&=0
LET baud_9600&=1
LET baud_4800&=2
LET baud_3600&=3
LET baud_2400&=4
LET baud_2000&=5
LET baud_1800&=6
LET baud_1200&=7
LET baud_600&=8
LET baud_300&=9
LET baud_200&=10
LET baud_150&=11
LET baud_134&=12
LET baud_110&=13
LET baud_75&=14
LET baud_50&=15
LET rs_lastbaud&=-2
LET rs_inquire&=-1
LET flow_none&=0
LET flow_soft&=1
LET flow_hard&=2
LET flow_both&=3
LET rs_oddparity&=&H2
LET rs_evenparity&=&H0
LET rs_parityenable&=&H4
LET rs_paritydisable&=&H0
LET rs_8bits&=&H0
LET rs_7bits&=&H20
LET rs_6bits&=&H40
LET rs_5bits&=&H60
LET rs_clk16&=&H80
LET rs_recvenable&=&H1
LET rs_recvdisable&=&H0
LET rs_syncstrip&=&H2
LET rs_matchbusy&=&H4
LET rs_brkdetect&=&H8
LET rs_frameerr&=&H10
LET rs_parityerr&=&H20
LET rs_overrunerr&=&H40
LET rs_buffull&=&H80
LET play&=0
LET record&=1
LET col_inquire&=-1
LET int_timera&=0
LET int_i7&=1
LET int_disable&=0
LET int_play&=1
LET int_record&=2
LET int_both&=3
LET mode_stereo8&=0
LET mode_stereo16&=1
LET mode_mono8&=2
LET prt_inquire&=-1
LET prt_dotmatrix&=&H0
LET prt_daisy&=&H1
LET prt_mono&=&H0
LET prt_color&=&H2
LET prt_atari&=&H0
LET prt_epson&=&H4
LET prt_draft&=&H0
LET prt_final&=&H8
LET prt_parallel&=&H0
LET prt_serial&=&H10
LET prt_continuous&=&H0
LET prt_singlesheet&=&H20
LET scr_nochange&=-1
LET snd_reset&=1
LET snd_clipleft&=&H8
LET snd_clipright&=&H10
LET snd_error&=&HF
LET snd_ok&=0
LET snd_badcontrol&=1
LET snd_badsync&=2
LET snd_badclock&=3
LET inquire&=-1
LET ltatten&=0
LET rtatten&=1
LET ltgain&=2
LET rtgain&=3
LET adderin&=4
LET adcinput&=5
LET setprescale&=6
LET addr_adc&=&H1
LET addr_matrix&=&H2
LET left_mic&=&H0
LET left_psg&=&H1
LET right_mic&=&H0
LET right_psg&=&H1
LET cclk_50k&=3
LET cclk_25k&=2
LET cclk_12k&=1
LET cclk_6k&=0
LET mon_mono&=0
LET mon_color&=1
LET mon_vga&=2
LET mon_tv&=3
LET overlay_on&=1
LET overlay_off&=0
LET bps1&=&H0
LET bps2&=&H1
LET bps4&=&H2
LET bps8&=&H3
LET bps16&=&H4
LET bps32&=&H5
LET col80&=&H8
LET col40&=&H0
LET vga&=&H10
LET tv&=&H0
LET pal&=&H20
LET ntsc&=&H0
LET overscan&=&H40
LET stmodes&=&H80
LET vertflag&=&H100
LET vm_inquire&=-1
LET scr_modecode&=3
LET vclk_external&=&H1
LET vclk_extvsync&=&H2
LET vclk_exthsync&=&H4
LET xb_timera&=0
LET xb_timerb&=1
LET xb_timerc&=2
LET xb_timerd&=3
RETURN
> PROCEDURE gemdos.h
LET e_ok&=0
LET einvfn&=-32
LET efilnf&=-33
LET epthnf&=-34
LET enhndl&=-35
LET eaccdn&=-36
LET eihndl&=-37
LET ensmem&=-39
LET eimba&=-40
LET edrive&=-46
LET exdev&=-48
LET elocked&=-58
LET enslock&=-59
LET erange&=-64
LET eintrn&=-65
LET eplfmt&=-66
LET enoexec&=-66
LET egsbf&=-67
LET enametoolong&=-64
LET eloop&=-80
LET emount&=-200
LET signull&=0
LET sighup&=1
LET sigint&=2
LET sigquit&=3
LET sigill&=4
LET sigtrap&=5
LET sigabrt&=6
LET sigpriv&=7
LET sigfpe&=8
LET sigkill&=9
LET sigbus&=10
LET sigsegv&=11
LET sigsys&=12
LET sigpipe&=13
LET sigalrm&=14
LET sigterm&=15
LET sigurg&=16
LET sigstop&=17
LET sigtstp&=18
LET sigcont&=19
LET sigchld&=20
LET sigttin&=21
LET sigttou&=22
LET sigio&=23
LET sigxcpu&=24
LET sigxfsz&=25
LET sigvtalrm&=26
LET sigprof&=27
LET sigwinch&=28
LET sigusr1&=29
LET sigusr2&=30
LET pf_fastload&=&H1
LET pf_ttramload&=&H2
LET pf_ttrammem&=&H4
LET pf_private&=&H0
LET pf_global&=&H10
LET pf_supervisor&=&H20
LET pf_readable&=&H30
LET gsh_conin&=0
LET gsh_conout&=1
LET gsh_aux&=2
LET gsh_prn&=3
LET gsh_bioscon&=-1
LET gsh_biosaux&=-2
LET gsh_biosprn&=-3
LET gsh_biosmidiin&=-4
LET gsh_biosmidiout&=-5
LET mint_eof%=&HFF1A
LET dev_ready&=-1
LET dev_busy&=0
LET default_drive&=0
LET drv_lock&=1
LET drv_unlock&=0
LET mode_normal&=0
LET mode_compat&=1
LET fa_readonly&=&H1
LET fa_hidden&=&H2
LET fa_system&=&H4
LET fa_volume&=&H8
LET fa_dir&=&H10
LET fa_archive&=&H20
LET fa_run&=&H0
LET fa_ready&=&H1
LET fa_tsr&=&H2
LET fa_waiting&=&H20
LET fa_iowait&=&H21
LET fa_exited&=&H22
LET fa_stopped&=&H24
LET fa_unidirectional&=&H1
LET fa_nokill&=&H2
LET fa_tty&=&H4
LET tty_cooked&=&H1
LET tty_echo&=&H2
LET flk_lock&=0
LET flk_unlock&=1
LET s_read&=&H0
LET s_write&=&H1
LET s_readwrite&=&H2
LET s_compat&=&H0
LET s_denyreadwrite&=&H10
LET s_denywrite&=&H20
LET s_denyread&=&H30
LET s_denynone&=&H40
LET s_noinherit&=&H80
LET seek_set&=0
LET seek_cur&=1
LET seek_end&=2
LET mx_stram&=&H0
LET mx_ttram&=&H1
LET mx_prefstram&=&H2
LET mx_prefttram&=&H3
LET mx_header&=&H8
LET mx_private&=&H18
LET mx_global&=&H28
LET mx_supervisor&=&H38
LET mx_readable&=&H48
LET domain_tos&=0
LET domain_mint&=1
LET pe_loadgo&=0
LET pe_load&=3
LET pe_go&=4
LET pe_basepage&=5
LET pe_gothenfree&=6
LET pe_cloadgo&=100
LET pe_cgo&=104
LET pe_noshare&=106
LET pe_replace&=200
LET msg_read&=0
LET msg_write&=1
LET msg_readwrite&=2
LET msg_nowait%=&H8000
LET pru_kerneltime&=0
LET pru_processtime&=1
LET pru_childkerneltime&=2
LET pru_childprocesstime&=3
LET pru_memory&=4
LET sem_create&=0
LET sem_destroy&=1
LET sem_lock&=2
LET sem_unlock&=3
LET lim_maxtime&=1
LET lim_maxmem&=2
LET lim_maxmalloc&=3
LET sa_nocldstop&=1
LET term_ok&=0
LET term_error&=1
LET term_badparams&=2
LET term_crash&=-1
LET term_ctrlc&=-32
LET pw_noblock&=&H1
LET pw_stopped&=&H2
LET pwp_allchildren&=-1
LET pwp_samegroup&=0
LET sys_maxinq&=-1
LET sys_maxregions&=0
LET sys_maxcommand&=1
LET sys_maxfiles&=2
LET sys_maxids&=3
LET sys_maxprocs&=4
LET unlimited%=&H7FFFFFFF
LET name_max&=32
LET path_max&=128
LET tos_search&=&H1
LET s_ifmt%=&X1111000000000000
LET s_ifchr&=&X10000000000000
LET s_ifdir&=&X100000000000000
LET s_ifreg%=&X1000000000000000
LET s_ififo%=&X1010000000000000
LET s_imem%=&X1100000000000000
LET s_iflnk%=&X1110000000000000
LET s_isuid&=&X100000000000
LET s_isgid&=&X10000000000
LET s_isvtx&=&X1000000000
LET s_irusr&=&X100000000
LET s_iwusr&=&X10000000
LET s_ixusr&=&X1000000
LET s_irgrp&=&X100000
LET s_iwgrp&=&X10000
LET s_ixgrp&=&X1000
LET s_iroth&=&X100
LET s_iwoth&=&X10
LET s_ixoth&=&X1
LET default_dirmode&=&X111111111
LET default_mode&=&X110110110
LET f_rdlck&=&H0
LET f_wrlck&=&H1
LET f_unlck&=3
LET fs_knoparse&=&H1
LET fs_casesensitive&=&H2
LET fs_noxbit&=&H4
LET fs_longpath&=&H8
LET o_rwmode&=&H3
LET o_rdonly&=&H0
LET o_wronly&=&H1
LET o_rdwr&=&H2
LET o_exec&=&H3
LET o_append&=&H8
LET o_shmode&=&H70
LET o_compat&=&H0
LET o_denyrw&=&H10
LET o_denyw&=&H20
LET o_denyr&=&H30
LET o_denynone&=&H40
LET o_noinherit&=&H80
LET o_ndelay&=&H100
LET o_creat&=&H200
LET o_trunc&=&H400
LET o_excl&=&H800
LET o_user&=&HFFF
LET o_global&=&H1000
LET o_tty&=&H2000
LET o_head&=&H4000
LET o_lock%=&H8000
LET dp_iopen&=0
LET dp_maxlinks&=1
LET dp_pathmax&=2
LET dp_namemax&=3
LET dp_atomic&=4
LET dp_trunc&=5
LET dp_case&=6
LET dp_maxreq&=6
LET dp_notrunc&=0
LET dp_autotrunc&=1
LET dp_dostrunc&=2
LET dp_casesens&=0
LET dp_caseconv&=1
LET dp_caseinsens&=2
LET minteof%=&HFF1A
LET raw&=0
LET cooked&=&H1
LET noecho&=0
LET echo&=&H2
LET escseq&=&H4
LET f_dupfd&=0
LET f_getfd&=1
LET f_setfd&=2
LET f_getfl&=3
LET f_setfl&=4
LET f_getlk&=5
LET f_setlk&=6
LET f_setlkw&=7
LET fd_cloexec&=1
LET t_crmod&=&H1
LET t_cbreak&=&H2
LET t_echo&=&H4
LET t_raw&=&H10
LET t_tos&=&H80
LET t_tostop&=&H100
LET t_xkey&=&H200
LET ts_esc&=&HFF
LET ts_cooked%=&H8000
LET dev_install%=&HDE02
LET dev_newbios%=&HDE01
LET dev_newtty%=&HDE00
LET fs_install%=&HF001
LET fs_mount%=&HF002
LET fs_unmount%=&HF003
LET fs_uninstall%=&HF004
LET osname&=0
LET osxname&=1
LET osversion&=2
LET tosheader&=3
LET os_build_date&=4
LET os_build_time&=5
LET compile_type&=6
LET features&=7
LET getcookie&=8
LET setcookie&=9
LET get_lval&=10
LET get_wval&=11
LET get_bval&=12
LET set_lval&=13
LET set_wval&=14
LET set_bval&=15
LET sys_slevel&=16
LET run_level&=17
LET tslice&=18
LET forcefastload&=19
LET sync_time&=20
LET s_blockcache&=21
LET s_ctrlcache&=23
LET feat_mp&=1
LET feat_vm&=2
LET gcjarsize&=0
LET fatfs_cntr_vfat_all&=&H5600
LET fatfs_cntr_vfat&=&H5601
LET fatfs_cntr_slnk&=&H5602
LET fatfs_cntr_cache&=&H5665
LET debuglevel&=1000
LET debugdevice&=1001
RETURN
> PROCEDURE system.h
LET key_backspace&=&HE08
LET key_delete&=&H537F
LET shift_delete&=&H532E
LET key_enter&=&H720D
LET key_escape&=&H11B
LET key_home&=&H4700
LET shift_home&=&H4737
LET cntrl_home&=&H7700
LET key_insert&=&H5200
LET shift_insert&=&H5230
LET key_return&=&H1C0D
LET cntrl_return&=&H1C0A
LET key_tab&=&HF09
LET key_undo&=&H6100
LET key_help&=&H6200
LET key_larrow&=&H4B00
LET key_rarrow&=&H4D00
LET key_uarrow&=&H4800
LET key_darrow&=&H5000
LET shift_larrow&=&H4B34
LET cntrl_larrow&=&H7300
LET shift_rarrow&=&H4D36
LET cntrl_rarrow&=&H7400
LET shift_uarrow&=&H4838
LET shift_darrow&=&H5032
LET key_ampersand&=&H826
LET key_asterisk&=&H92A
LET key_at&=&H340
LET key_caret&=&H75E
LET key_colon&=&H273A
LET key_comma&=&H332C
LET key_dollar&=&H524
LET key_equals&=&HD3D
LET alt_equals%=&H8300
LET key_exclamation&=&H221
LET key_minus&=&HC2D
LET alt_minus%=&H8200
LET cntrl_minus&=&HC1F
LET key_percent&=&H625
LET key_period&=&H342E
LET key_plus&=&HD2B
LET key_pounds&=&H423
LET key_question&=&H353F
LET key_quotation&=&H2822
LET key_semicolon&=&H273B
LET key_space&=&H3920
LET key_tilde&=&H297E
LET key_uline&=&HC5F
LET key_vline&=&H2B7C
LET key_l_angle&=&H333C
LET key_r_angle&=&H343E
LET key_l_bracket&=&H1A7B
LET key_r_bracket&=&H1B7D
LET key_l_paren&=&HA28
LET key_r_paren&=&HB29
LET key_slash&=&H352F
LET key_backslash&=&H2B5C
LET cntrl_backslash&=&H2B1C
LET key_l_square&=&H1A5B
LET cntrl_l_square&=&H1A1B
LET key_r_square&=&H1B5D
LET cntrl_r_square&=&H1B1D
LET key_0&=&HB30
LET key_1&=&H231
LET key_2&=&H332
LET key_3&=&H433
LET key_4&=&H534
LET key_5&=&H635
LET key_6&=&H736
LET key_7&=&H837
LET key_8&=&H938
LET key_9&=&HA39
LET keypad_minus&=&H4A2B
LET keypad_plus&=&H4E2B
LET key_a&=&H1E41
LET key_b&=&H3042
LET key_c&=&H2E43
LET key_d&=&H2044
LET key_e&=&H1245
LET key_f&=&H2146
LET key_g&=&H2247
LET key_h&=&H2348
LET key_i&=&H1749
LET key_j&=&H244A
LET key_k&=&H254B
LET key_l&=&H264C
LET key_m&=&H324D
LET key_n&=&H314E
LET key_o&=&H184F
LET key_p&=&H1950
LET key_q&=&H1051
LET key_r&=&H1352
LET key_s&=&H1F53
LET key_t&=&H1454
LET key_u&=&H1655
LET key_v&=&H2F56
LET key_w&=&H1157
LET key_x&=&H2D58
LET key_y&=&H1559
LET key_z&=&H2C5A
LET key_a.&=&H1E61
LET key_b.&=&H3062
LET key_c.&=&H2E63
LET key_d.&=&H2064
LET key_e.&=&H1265
LET key_f.&=&H2166
LET key_g.&=&H2267
LET key_h.&=&H2368
LET key_i.&=&H1769
LET key_j.&=&H246A
LET key_k.&=&H256B
LET key_l.&=&H266C
LET key_m.&=&H326D
LET key_n.&=&H316E
LET key_o.&=&H186F
LET key_p.&=&H1970
LET key_q.&=&H1071
LET key_r.&=&H1372
LET key_s.&=&H1F73
LET key_t.&=&H1474
LET key_u.&=&H1675
LET key_v.&=&H2F76
LET key_w.&=&H1177
LET key_x.&=&H2D78
LET key_y.&=&H1579
LET key_z.&=&H2C7A
LET cntrl_2&=&H300
LET cntrl_6&=&H71E
LET cntrl_a&=&H1E01
LET cntrl_b&=&H3002
LET cntrl_c&=&H2E03
LET cntrl_d&=&H2004
LET cntrl_e&=&H1205
LET cntrl_f&=&H2106
LET cntrl_g&=&H2207
LET cntrl_h&=&H2308
LET cntrl_i&=&H1709
LET cntrl_j&=&H240A
LET cntrl_k&=&H250B
LET cntrl_l&=&H260C
LET cntrl_m&=&H320D
LET cntrl_n&=&H310E
LET cntrl_o&=&H180F
LET cntrl_p&=&H1910
LET cntrl_q&=&H1011
LET cntrl_r&=&H1312
LET cntrl_s&=&H1F13
LET cntrl_t&=&H1414
LET cntrl_u&=&H1615
LET cntrl_v&=&H2F16
LET cntrl_w&=&H1117
LET cntrl_x&=&H2D18
LET cntrl_y&=&H1519
LET cntrl_z&=&H2C1A
LET alt_0%=&H8100
LET alt_1&=&H7800
LET alt_2&=&H7900
LET alt_3&=&H7A00
LET alt_4&=&H7B00
LET alt_5&=&H7C00
LET alt_6&=&H7D00
LET alt_7&=&H7E00
LET alt_8&=&H7F00
LET alt_9%=&H8000
LET alt_a&=&H1E00
LET alt_b&=&H3000
LET alt_c&=&H2E00
LET alt_d&=&H2000
LET alt_e&=&H1200
LET alt_f&=&H2100
LET alt_g&=&H2200
LET alt_h&=&H2300
LET alt_i&=&H1700
LET alt_j&=&H2400
LET alt_k&=&H2500
LET alt_l&=&H2600
LET alt_m&=&H3200
LET alt_n&=&H3100
LET alt_o&=&H1800
LET alt_p&=&H1900
LET alt_q&=&H1000
LET alt_r&=&H1300
LET alt_s&=&H1F00
LET alt_t&=&H1400
LET alt_u&=&H1600
LET alt_v&=&H2F00
LET alt_w&=&H1100
LET alt_x&=&H2D00
LET alt_y&=&H1500
LET alt_z&=&H2C00
LET fkey_1&=&H3B00
LET fkey_2&=&H3C00
LET fkey_3&=&H3D00
LET fkey_4&=&H3E00
LET fkey_5&=&H3F00
LET fkey_6&=&H4000
LET fkey_7&=&H4100
LET fkey_8&=&H4200
LET fkey_9&=&H4300
LET fkey_10&=&H4400
LET shift_f1&=&H5400
LET shift_f2&=&H5500
LET shift_f3&=&H5600
LET shift_f4&=&H5700
LET shift_f5&=&H5800
LET shift_f6&=&H5900
LET shift_f7&=&H5A00
LET shift_f8&=&H5B00
LET shift_f9&=&H5C00
LET shift_f10&=&H5D00
LET proc_lives_magic%=&H12345678
LET memvalid_magic%=&H752019F3
LET resvalid_magic%=&H31415926
LET memval2_magic%=&H237698AA
RETURN
> PROCEDURE xcontrol.h
LET save_defaults&=0
LET mem_err&=1
LET file_err&=2
LET file_not_found&=3
LET mfsave&=1
LET mfrestore&=0
LET cpxmagic&=100
LET cpx_resident&=4
LET cpx_bootinit&=2
LET cpx_setonly&=1
RETURN
'
> PROCEDURE morewin         ! basic info
~WIND_OPEN(handle2&,(dsk_w&-tw2&)/2,(dsk_h&-th2&)/2,tw2&+(neww&-dsk_w&),th2&+(newh&-dsk_h&))                  ! open the window previously created (line above)
IF debug_level&<0 OR debug_device&<0
ELSE
CHAR{{OB_SPEC(tree2%,klevel&)}}=STR$(debug_level&)
CHAR{{OB_SPEC(tree2%,kdev&)}}=@device$(debug_device&)
ENDIF
RETURN
> PROCEDURE morewin2        ! vfat window
CHAR{{OB_SPEC(tree2%,label_val&)}}=@dreadlabel$(dr&,13)
CHAR{{OB_SPEC(tree2%,fatdrive&)}}=CHR$(65+dr&)
cache_val&=@ssystem(21,-1,0)
IF cache_val&>-1
OB_X(tree2%,21)=(cache_val&-1)/100*OB_W(tree2%,20)
CHAR{{OB_SPEC(tree2%,cache&)}}=STR$(cache_val&,3)
ELSE
@redraw_obj(tree2%,cache&,disabled&)
ENDIF
~WIND_OPEN(handle2&,(dsk_w&-tw3&)/2,(dsk_h&-th3&)/2,tw3&+(neww&-dsk_w&),th3&+(newh&-dsk_h&))                  ! open the window previously created (line above)
@switch_icon
RETURN
> PROCEDURE morewin3        ! user window
@users
@display_user
~WIND_OPEN(handle2&,(dsk_w&-tw5&)/2,(dsk_h&-th5&)/2,tw5&+(neww&-dsk_w&),th5&+(newh&-dsk_h&))                  ! open the window previously created (line above)
RETURN
> PROCEDURE morewin9        ! cpu cache window
@display_cache
~WIND_OPEN(handle2&,(dsk_w&-tw9&)/2,(dsk_h&-th9&)/2,tw9&+(neww&-dsk_w&),th9&+(newh&-dsk_h&))
RETURN
> PROCEDURE rsc_redraw(hand&,x&,y&,w&,h&)    ! main GEM redraw routine
LOCAL rx&,ry&,rw&,rh&,top_handle&,d&,index&
~WIND_UPDATE(beg_update&)
~WIND_GET(0,wf_top&,top_handle&,d&,d&,d&)
~WIND_GET(hand&,wf_firstxywh&,rx&,ry&,rw&,rh&)
@win_place_tree(hand&)
WHILE rw& OR rh&
IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
IF hand&=handle&
~OBJC_DRAW(tree%,0,4,rx&,ry&,rw&,rh&)
ELSE IF hand&=handle2&
~OBJC_DRAW(tree2%,0,4,rx&,ry&,rw&,rh&)
ENDIF
ENDIF
~WIND_GET(hand&,wf_nextxywh&,rx&,ry&,rw&,rh&)
WEND
~WIND_UPDATE(end_update&)
RETURN
> PROCEDURE win_place_tree(hand&)
LOCAL x&,y&,d&
~WIND_GET(hand&,wf_workxywh&,x&,y&,d&,d&)
IF hand&=handle&
OB_X(tree%,0)=x&+1
OB_Y(tree%,0)=y&+1
ELSE IF hand&=handle2&
OB_X(tree2%,0)=x&+1
OB_Y(tree2%,0)=y&+1
ENDIF
RETURN
> PROCEDURE timeslice
@redraw_text(ts&,timeslice&)
@win_redraw_objc(handle&,tree%,ts&)
RETURN
> PROCEDURE security
@redraw_text(sl&,security&)
@win_redraw_objc(handle&,tree%,sl&)
RETURN
> FUNCTION tget_time
RETURN GEMDOS(&H2C)
ENDFUNC
> PROCEDURE topit                 ! top GEM window
~WIND_SET(MENU(4),wf_top&,ap_id&,FALSE,FALSE,FALSE)
RETURN
> FUNCTION device$(a&)
$F%
LOCAL a$
IF a&=0
a$="printer"
ELSE IF a&=1
a$="aux/modem"
ELSE IF a&=2
a$="console"
ELSE IF a&=3
a$="midi"
ELSE IF a&=4
a$="keyboard"
ELSE IF a&=5
a$="raw"
ELSE
a$=STR$(a&)
ENDIF
RETURN a$
ENDFUNC
> FUNCTION makeu$(dr&)            ! transform from device x into a string
$F%
RETURN "u:\"+CHR$(65+dr&)
ENDFUNC
'    coded by lp for UNiC
> PROCEDURE win_redraw_objc(wh&,ta%,ob&)
' wh&  handle of window object is in
' ta%  tree address of form object is in
' ob&  object number we wish to redraw clipped
LOCAL x&,y& !define some temps
~OBJC_OFFSET(ta%,ob&,x&,y&) !get screen x,y of our object
' -2,+4 below is required because objc_offset() does't include object borders
' thus we increase the box location by 2 pixels in all for directions
@rsc_redraw(wh&,x&-2,y&-2,OB_W(ta%,ob&)+4,OB_H(ta%,ob&)+4) !draw it clipped!
RETURN
> PROCEDURE redraw_obj(ta%,ob&,state&)
' ta%= tree, ob& is object to redraw, state& is what status should the object been drawn
~OBJC_CHANGE(ta%,ob&,0,OB_X(ta%,ob&),OB_Y(ta%,ob&),OB_W(ta%,ob&),OB_H(ta%,ob&),state&,no_draw&)
IF ta%=tree%
@win_redraw_objc(handle&,ta%,ob&)
ELSE
@win_redraw_objc(handle2&,ta%,ob&)
ENDIF
RETURN
> PROCEDURE switch_obj(ta%,ob&,state&)
~OBJC_CHANGE(ta%,ob&,0,OB_X(ta%,ob&),OB_Y(ta%,ob&),OB_W(ta%,ob&),OB_H(ta%,ob&),state&,no_draw&)
RETURN
'    eof
' ******* GEMDOS and MiNT calls libs here ********
> FUNCTION ssystem(mode,arg1%,arg2%)    ! MiNT new call (1.15)
$F%
RETURN GEMDOS(&H154,mode,L:arg1%,L:arg2%)
ENDFUNC
> FUNCTION sversion                     ! obtain the current GEMDOS version (&)
$F%
RETURN GEMDOS(&H30)
ENDFUNC
> FUNCTION pkill(pid&,sig&)
$F%
RETURN GEMDOS(&H111,pid&,sig&)
ENDFUNC
> FUNCTION sysconf(n&)           ! obtain system configuration from MiNT(%)
$F%
RETURN GEMDOS(&H122,n&)
ENDFUNC
> FUNCTION fcreate(path$,attr&)  ! create a file (%)
$F%
path$=path$+CHR$(0)
RETURN GEMDOS(&H3C,L:V:path$,attr&)
ENDFUNC
> FUNCTION fopen(file$,mode%)    ! open a file (%)
$F%
LOCAL adr%
file$=file$+CHR$(0)
adr%=V:file$
RETURN GEMDOS(&H3D,L:adr%,W:mode%)
ENDFUNC
> FUNCTION fclose(handle&)       ! close a file (&)
$F%
RETURN GEMDOS(&H3E,W:handle&)
ENDFUNC
> FUNCTION fread(handle&,len%,adr%)     ! read binary data from file (%)
$F%
RETURN GEMDOS(&H3F,W:handle&,L:len%,L:adr%)
ENDFUNC
> FUNCTION fwrite(handle&,len%,adr%)    ! write binary data to file (%)
$F%
RETURN GEMDOS(&H40,W:handle&,L:len%,L:adr%)
ENDFUNC
> FUNCTION fdelete(path$)               ! delete a file (&)
$F%
path$=path$+CHR$(0)
RETURN GEMDOS(&H41,L:V:path$)
ENDFUNC
> FUNCTION fseek(offset%,handle&,mode&) ! move a file pointer (%)
$F%
RETURN GEMDOS(&H42,L:offset%,handle&,mode&)
ENDFUNC
> FUNCTION fattrib(path$,flag&,attrib&) ! get or set the attributes of a file (&)
$F%
path$=path$+CHR$(0)
RETURN GEMDOS(&H43,L:V:path$,flag&,attrib&)
ENDFUNC
> FUNCTION fcntl(f&,arg%,cmd&)          ! (%)
$F%
RETURN GEMDOS(&H104,W:f&,L:arg%,cmd&)
ENDFUNC
> FUNCTION dcntl(cmd&,path$,arg%)
$F%
path$=path$+CHR$(0)
error%=GEMDOS(&H130,W:cmd&,L:V:path$,L:arg%)
IF error%<0
error%=disabled&
ENDIF
RETURN error%
ENDFUNC
> PROCEDURE do_pipe
pipe_fd&=@fopen("U:\PIPE\ALERT",o_rdwr&+o_creat&+o_trunc&+o_ndelay&+o_denynone&)
IF pipe_fd&<0
ALERT 1,"Not able to create pipe. ",1,"OK",ok|
no_alert&=1
ELSE IF pipe_fd&>=32
~@fclose(pipe_fd&)
ALERT 1,"Out of range. ",1,"OK",ok|
no_alert&=1
ENDIF
IF no_alert&=0
~@fcntl(pipe_fd&,0,f_setfd&)  ! to avoid GEM bus error
ENDIF
RETURN
' ********* EOF *********
> FUNCTION instr(a$,b$,i&)
$F%
LOCAL a&
a&=INSTR(a$,b$,i&)
IF a&<i&
a&=FALSE
ENDIF
RETURN a&
ENDFUNC
> FUNCTION f_close(fh&)
$F%
RETURN GEMDOS(62,fh&)
ENDFUNC
> FUNCTION f_rename(a$,b$)
$F%
'
' RENAME a$ AS b$
'
a$=a$+CHR$(0)
b$=b$+CHR$(0)
'
RETURN GEMDOS(86,0,L:V:a$,L:V:b$)
ENDFUNC
> FUNCTION f_kill(a$)
$F%
'
' KILL a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(65,L:V:a$)
ENDFUNC
> FUNCTION f_rmdir(a$)
$F%
'
' RMDIR a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(58,L:V:a$)
ENDFUNC
> FUNCTION f_mkdir(a$)
$F%
'
' MKDIR a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(57,L:V:a$)
ENDFUNC
> FUNCTION dsetpath(a$)
$F%
a$=a$+CHR$(0)
RETURN GEMDOS(59,L:V:a$)
ENDFUNC
> FUNCTION f_create(a$)
$F%
'
' OPEN "O"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(60,L:V:a$,0)
ENDFUNC
> FUNCTION f_open(a$)
$F%
'
' OPEN "I"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(61,L:V:a$,0)
ENDFUNC
> FUNCTION f_update(a$)
$F%
'
' OPEN "U"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(61,L:V:a$,2)
ENDFUNC
> FUNCTION f_append(a$)
$F%
LOCAL fh&,a%
'
' OPEN "A"
'
a$=a$+CHR$(0)
'
fh&=GEMDOS(61,L:V:a$,2)               ! OPEN "U"
'
IF fh&=-33                            ! Existiert nicht...
fh&=GEMDOS(60,L:V:a$,0)             ! OPEN "O"
ENDIF
'
IF fh&>0
a%=GEMDOS(66,L:0,fh&,2)             ! SEEK #1,lof%
IF a%<0
RETURN a%                         ! Error beim Seeken
ENDIF
ENDIF
'
RETURN fh&
ENDFUNC
> FUNCTION f_lof(fh&)
$F%
LOCAL pos%,lof%
'
' LOF(#1)
'
pos%=GEMDOS(66,L:0,fh&,1)                             ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)                             ! SEEK #1,LOF(#1)
'
~GEMDOS(66,L:pos%,fh&,0)                              ! SEEK #1,LOC(#1)
'
RETURN lof%
ENDFUNC
> FUNCTION f_eof(fh&)
$F%
LOCAL pos%,lof%
'
' EOF(#1)
'
pos%=GEMDOS(66,L:0,fh&,1)                             ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)                             ! SEEK #1,LOF(#1)
'
~GEMDOS(66,L:pos%,fh&,0)                              ! SEEK #1,LOC(#1)
'
RETURN pos%>=lof%                                     ! EOF(#1)
ENDFUNC
> FUNCTION f_println(fh&,a$)
$F%
a$=a$+CHR$(0)
RETURN GEMDOS(64,fh&,L:LEN(a$),L:V:a$)
ENDFUNC
> FUNCTION f_input$(fh&)
LOCAL a|,e%,a$,b$
'
' LINE INPUT #1,a$
'
b$=CHR$(10)                ! Linefeed
'
WHILE RIGHT$(a$,1)<>b$
e%=GEMDOS(63,fh&,L:1,L:V:a|)      ! INP #1,a|
'
EXIT IF e%<>1                     ! EOF(#1)
'
a$=a$+CHR$(a|)
WEND
'
IF RIGHT$(a$,1)=b$
a$=LEFT$(a$,SUB(LEN(a$),1))       ! LF abhngen
ENDIF
'
RETURN a$
ENDFUNC
> FUNCTION f_bload(file$,adr%)
$F%
LOCAL fh&,lof%,pos%
'
' BLOAD file$,adr%
'
file$=file$+CHR$(0)
'
~GRAF_MOUSE(2,0)
'
fh&=GEMDOS(61,L:V:file$,0)      ! f_open
IF fh&>0
'
pos%=GEMDOS(66,L:0,fh&,1)     ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)     ! f_seek(LOF(#1))
~GEMDOS(66,L:pos%,fh&,0)      ! f_seek(LOC(#1))
'
~GEMDOS(63,fh&,L:lof%,L:adr%) ! f_read
~GEMDOS(62,fh&)               ! f_close
'
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN lof%                     ! Lnge der Datei
ENDFUNC
> FUNCTION fforce(std&,nonstd&)
$F%
RETURN GEMDOS(&H46,std&,nonstd&)
ENDFUNC
