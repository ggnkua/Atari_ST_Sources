DESERT DRAIN   68000 Disassembler fr Atari ST 
Version 1.3  (Aug 1991 - M„rz 1992) 
 
erstellt mit GFA-Basic 3.0 und TurboAss 1.5 
 
von  Volker Hemsen 
     Gremskampstr.3 
     2427 Malente 
     Blz. 21352240 KRSPK Eutin 
     Kto. 0103047130 
 
Desert Drain 1.3 ist Public Domain, d.h. das Programm und seine 
Zusatzdateien drfen und sollen beliebig oft kopiert und weiter- 
gegeben werden. Jeglicher kommerzieller Vertrieb, auer auf 
Basis von PD-Vertrieben, ist untersagt. 
 
Dies ist die letzte PD-Version von Desert Drain! Alle weiteren 
werden als Shareware vertrieben. Die Sharware-Gebhr betr„gt 
25,- DM (in bar/V-Scheck). Hierfr erhaltet Ihr eine registrierte 
Version (>=1.4) und ein sp„teres Update frei Haus. Alle 
weiteren Updates kosten je 10,- DM. Da Ihr natrlich nicht sie 
Katze im Sack kaufen sollt, hier ein paar Erweiterungen der 
Version 1.40 :
 
- Der Editor wurde nochmals berarbeitet und ist nun etwas  
  schneller. 
- Die Benutzeroberfl„che ist durch erweiterte Dialogboxen noch 
  freundlicher geworden. 
- Eine Symboltabelle kann nun ver„ndert, erweitert, 
  abgespeichert und neu eingebunden werden. 
- Das Einsetzen der Symbole geht nun wesentlich schneller. 
- Fr jede Quelle kann eine Parameterdatei unter beliebigem Pfad 
  abgespeichert werden. 
- Nach einfacher Vorarbeit durch den Bediener ist es m”glich, 
  da auch AES- und VDI-Traps erkannt werden. 
- Das bisherige Benennen der OS-Traps l„uft etwas flexibler ab. 
- Desert Drain 1.4 ist ca. 130kB lang. Also nichts fr groe 
  Geister mit kleinen Speichern. 
u.n.v.a.m. 
 
 
Nun aber ein paar Worte zu meinem Programm: 
 
Zu Desert Drain ('wster Abflu' - kein Kommentar) geh”ren 
folgende Dateien: 
     - DS_DRAIN.PRG      Programmdatei (incl. 16kB RSC-Datei, 
                                        siehe ST-Computer 9/91) 
     - DS_HILFE.TXT      Hifstext mit Symbolnamen 
     - OPCODE.TXT        Textdatei mit Opcodes und Hintergrund- 
                         informationen fr Disassembler 
     - READ_130.TXT      dieser Text 
     - DATE_130.TXT      kurzes Update-Info zur Version 1.2 
     - FEHLER.TXT        einige Fehlerbeschreibungen und 
                         deren L”sung 
     - und noch einiges mehr... 
 
Das Programm l„uft in jeder Aufl”sung mit mindestens 640 Pixel 
Bildbreite (mittlere und hohe ST-Aufl”sung). Testen konnte ich 
es unter TOS 1.02 und 2.05. Bei Verwendung von Quick ST2-Demo 
gab es leichte Probleme mit 'crossed'-Buttons (???). Mit Turbo 
ST l„uft es einwandfrei. Der freie Speicher sollte nicht kleiner 
als 512 kB sein, aber je mehr desto besser. 
 
Zur folgenden Programmbeschreibung ein kleiner Tip von mir: 
Ladet doch diesen Text mit 'Hilfe laden' oder 'ASCII laden' 
(kein Spartabulator!) ein und schaut euch alles 'vor Ort' an. 
Dann wird es auch nicht so langweilig und Ihr behaltet den šber- 
blick. 
 
 
kurzes Inhaltsverzeichnis: 
 
       1. Quelle laden 
       2. Optionen 
       3. Disassembler 
       4. Editor 
       5. Editor-Optionen 
       6. System-Info 
       7. Hilfsdatei 
       8. Wie arbeite ich mit Desert Drain? 
 
 
 
1. Quelle laden 
 
1.1. Programmdatei laden 
In der Fileselectbox kann man eine Programmdatei (PRG,TOS,APP, 
TTP,ACC) ausw„hlen. Es werden folgende Segmente erkannt und 
geladen: 
     - Programmheader 
          - Segmentl„ngen 
          - Fast-Load-Bit 
          - Headerbits fr den TT 
     - TEXT-Segment 
     - DATA-Segment 
     - Symboltabelle 
     - Reloziertabelle 
Es sollte sich unbedingt um eine Programmdatei mit dem 
entsprechenden Header handeln, andernfalls drohen nette kleine 
Abstrze. Wenn es eine gleichnamige Datei mit der Extension 
"DBT" gibt, wird diese mitgeladen - aber dazu sp„ter mehr. 
 
1.2. Programmteil laden 
Arbeitet wie 'Programmdatei laden' (zumindest hoffe ich es - 
war schwieriger als es aussieht), nur das man sich hier einen 
Teil (Text und/oder Data) aussuchen und ein Programm so zerlegen 
kann. Das BSS wird immer bersetzt. Ihr solltet hierbei bedenken, 
da das sp„tere Zusammenfgen so gut wie unm”glich ist, da 
immer nur die Label gestetzt werden k”nnen, zu denen im selben 
Programmteil verzweigt wird. 
 
1.3. Routine laden 
Die selektierte Datei wird vollst„ndig als TEXT geladen. Sinn- 
voll ist dies z.B. bei GFA-Inline-Assembler und sonstigen in 
Hochsprachen eingebauten Unterprogrammen ohne Header, Symbol- 
und Reloziertabelle. Das Disassemblieren von Objektdateien im DR- 
Format ist bisher noch nicht m”glich. 
 
1.4. RAM/ROM laden 
Hier k”nnen die Adressen von Speicherbereichen aus dem RAM oder 
ROM eingestellt werden. Sie werden als TEXT-Segment weiter- 
verwendet. Adressen von Betriebssystemroutinen erh„lt man bei 
SYS-Info. 
 
1.5. Resource laden 
Hiermit kann man RSC-Dateien als Data laden. Beim Disassem- 
blieren werden s„mtliche Adressen durch Label ersetzt, sowie die 
Headereintr„ge fr Segmentanf„nge und -l„ngen variabel einge- 
richtet. Dies dient dazu sie im Assembler zu erweitern oder in 
Assembler/Pascal-Programme einzubinden. 
 
1.6 Data laden 
Es k”nnte ja mal das Problem entstehen, da man ein Bild oder 
eine ASCII- Datei als Data einem Assemblerprogramm beifgen 
m”chte. 
 
 
 
 
2. Disassembler-Optionen 
Alle Einstellungen in der Dialogbox 'Optionen' sollten grund- 
s„tzlich vor dem Disassemblieren vorgenommen werden!!! 
 
2.1. ASCII 
Hier lassen sich mit zwei Buttons drei Formate ausw„hlen, die 
die Tabulatorpositionen im sp„teren ASCII-Code bestimmen. 
     - Norm:   Leerzeichen zwischen linkem Rand und Befehl 
               (kein Button selektiert) 
     - Spar:   Keine Leerzeichen zwischen linkem Rand und  
               Befehl, es sei denn es steht ein Label am  
               Zeilenanfang. (nur Spar-Button) 
     - Hyper.: Zwischen Label, Befehl, Operanden und Remark 
               nur ein Leerzeichen  (Hyperspar-Button) 
Alle drei Formen k”nnen von TurboAss gelesen werden. Wenn man 
den Assemblercode mit einem normalen Editor weiterverarbeiten 
m”chte, eignet sich nur das Normformat. Beim Laden einer ASCII- 
Datei wird angenommen, da sie durchschnittlich mindestens 20 
Zeichen pro Zeile lang ist. 
 
2.2. Tabulator 
Hier lassen sich die Tabulatoren fr Befehl, Operanden und 
Remark festlegen. 
 
2.3. Symbole einsetzen 
Mit dieser Option kann man eine Symboltabelle verschm„hen. Beim 
Neuladen wird sie nicht mitgeladen. Da Symbole nur maximal 8 
Zeichen lang sein drfen, Hochsprachen-Compiler und Assembler 
jedoch l„ngere Label (z.B. Prozedur- und Funktionsnamen) 
erlauben, welch Glck, kann es vorkommen da sich Symbole 
gleichen, und ein sp„teres Weiterverarbeiten schwierig wird. 
 
2.4. Kommentar 
Bei Traps und Systemvariablen wird ein Remark angefgt. siehe 
Editor, Disassembler und Hilfsdatei 
Leider rufen die Hochsprachen-Systeme die AES- und VDI- 
Funktionen auf v”llig verschiedene Art und Weise auf, und 
verzweigen dabei auch noch sehr h„ufig, so da ein Einfgen der 
Symbolnamen sehr schwierig ist. M”glich w„re ein Nacharbeiten 
durch den Anwender. Dieser mte durch Tastendruck dem Dis- 
assembler die Zeilen mit den entsprechenden Parametern zeigen. 
 
2.5. Label in HEX 
Die Label (Sprungadressen) werden als Hexadezimal oder Dezimal- 
Zahlen geschrieben. z.B. T_100 in Hex entspricht T_256 in Dez 
 
2.6. Text: Konstanten in HEX 
Stellt die Zahlendarstellung fr Konstanten aus dem TEXT- 
Segment ein. 
 
2.7. Data 
Hier kann mit drei Buttons und einem EDIT-Feld die 
Disassemblierung des DATA-Segments gesteuert werden. Es besteht 
die M”glichkeit es als Strings (Zahlen von 0..31 als Zahl) 
und/oder als Zahl in HEX oder DEZ auszugeben. Zus„tzlich kann 
angegeben werden wie lang eine Zeile werden darf. 
 
2.8. BSS: mit Bereichsgr”e 
Im aktivierten Zustand wird die L„nge des Bereichs als Remark 
eingefgt. 
 
 
 
 
3. Disassember 
 
3.1. Speicher-Einteilung 
In der Dialogbox wird festgelegt, wie das String-Array (Ziel) 
dimensioniert werden soll. Auerdem wird die Array-Ausnutzung 
und der freie und maximale Speicherplatz (ab Initialisierung) 
aufgefhrt. Die Gesamtl„nge der Zeilen entspricht der L„nge der 
sp„teren ASCII-Datei (incl. LF/CR). Diese Optionen dienen zum 
Finden der maximalen Speicherausnutzung bei l„ngeren Quellen 
oder kleineren Rechnern. 
 
3.2. Label 
Label, die nicht in der Symboltabelle enthalten sind, werden 
selbst benannt: 'T_' steht fr 'zeigt ins Textsegment', 'D_' fr 
Data, 'B_' fr BSS und 'A_' fr Auerhalb. Danach folgt eine 
Zahl mit der Offset-Adresse ab Programmanfang (Dateianfang+$1C). 
Wenn die Adresse negativ ist und keine negative Systemvariable 
zutrifft, wird am Programmanfang ein Label gesetzt und ab hier 
entsprechend adressiert. (z.B. erster Befehl eines GFA-Basic- 
Compilates) 
 
3.3. Opcodes 
S„mtliche im Programm verwendete Opcodes und Mnemoniks sind in 
der Datei OPCODE.TXT aufgefhrt. 
 
3.4. DC.W 
Unbekannte Opcodes werden als DefineConstant.Word ausgegeben. 
Am Ende der Zeile steht der Wert als ASCII. 
 
3.5. XBRA 
XBRA-Kennungen werden erkannt und als 'dc.l'... entschlsselt. 
 
3.6. Kommentare 
Wenn eine wortlange effektive Adresse einer Systemvariable aus 
der Hilfsdatei gleicht, wird deren Name als Remark angefgt. 
Traps mit den Nummern #1 (gemdos), #13 (bios) und #14 (xbios) 
k”nnen nur erkannt werden, wenn die Funktionsnummer eine Zeile 
zuvor mit 'move.w/.l #XX,?(sp)' oder 'pea' auf den Stack gelegt 
wird. Bei Trap #2 mu hier 'move.? #XX,D0' stehen, damit 
zwischen aes, vdi und gdos unterschieden werden kann. 
 
3.7. DATA 
Datas werden als 'dc.b' geschrieben. Ob String, Hex oder Dez 
und wie lang jede Zeile sein darf wird bei Optionen eingestellt. 
XBRA-Kennungen werden an den 4 Buchstaben 'XBRA' erkannt. Eine 
Verwechslung mit Strings ist also ohne weiteres m”glich. 
 
3.8. BSS 
Das Block-Storage-Segment wird je nach L„nge mit den Direktiven 
'ds.b', '.w' oder '.l' aufgefllt. Das Beifgen der Bereichs- 
gr”e soll die šbersichtlichkeit erh”hen. 
 
3.9. TurboAss 
Alle Befehle, Direktiven usw. wurden auf den TurboAss von ä- 
Soft abgestimmt. Sollte irgendetwas nicht klappen, bitte ich um 
Nachricht. Ich helfe gern. Sollte ich demn„chst an vollst„ndige 
Opcode-Listen fr 68000, 020, 030, 040, 881, 882 Prozessoren 
herankommen, werde ich den Disassembler erweitern. 
 
3.10. Databereiche im Textsegment 
Es kommt immer wieder vor, das Datas wie z.B. Strings sich nicht 
im Data- sondern im Textsegment befinden. Um sp„ter berhaupt  
noch etwas mit dem disassemblierten Code anfangen zu k”nnen (siehe  
Kapitel 8), mu man diese Bereiche herausfischen und die Quelle  
erneut disassemblieren. 
Dazu gibt man jeweils die Anfangs- und Endadresse des Bereiches 
an, wobei das letzte, als Data zu bersetzende, Byte in der um 1 
verminderten Endadresse steht. Beim Anlegen der Bl”cke ist zu 
beachten, da sie sich nicht berschneiden. 
In der Dialogbox 'Data im Text' werden die Bl”cke aufgelistet. 
Hier gibt es folgende Buttons: 
- Eintrag 
   - aktivieren : zum aktivieren des aktuellen Eintrags 
   - l”schen : l”scht den aktuellen Eintrag 
- Feld 
   - aktivieren : das ganze Verfahren aktivieren 
   - l”schen : alle Eintr„ge l”schen 
Bei Maximum kann man angeben, wie lang das Feld sein soll. Die 
aktuelle L„nge stellt sich nur neu ein, wenn man alle Eintr„ge 
abspeichert und neul„dt, oder das ganze Feld l”scht. Die Bl”cke 
werden nach Verlassen der Dialogbox und beim Start des 
Disassemblierens neu sortiert. 
 
 
 
4. Editor 
Der Name ist zwar etwas bertrieben, aber dennoch ist er recht 
hilfreich. Einen Curser habe ich aus Bequemlichkeit weggelassen. 
Wenn eine Zeile direkt angesprochen werden soll, mu sie an 
erster Stelle der Seite stehen. 
 
4.1. Scrolling 
Das Bewegen des Textes erfolgt ber den rechten Slider oder die 
Cursertasten, evtl. in Verbindung mit Shift. Mit ClrHome gelangt 
man zum Anfang, mit Shift Clr Home zum Ende des Textes. 
 
4.2. 8er/16er Text 
Mit Tab oder ber Editor-Optionen schaltet man zwischen den 
zwei Texth”hen hin und her. 
 
4.3. Hilfe und Remark suchen 
Mit 'H' gelangt man in den Hilfstext und kann dort bl„ttern. 
Mit Help oder Return sucht man aus dem Editor heraus im Hilfs- 
text nach dem Symbol, das als erstes Remark ab Seitenanfang 
steht. Hier erh„lt man dann n„here Infos ber Trap's und System- 
variablen. 
 
4.4. Text suchen 
Durch Drcken der Taste F erh„lt man die M”glichkeit einen Text 
(z.B. Label) zu suchen. Mit Control F kann die Suche wiederholt 
werden. (Editor+Hilfe) 
 
4.5. Symbol ersetzen 
Ersetzt s„mtliche zutreffenden Symbole. (nur Editor) 
 
4.6. Goto Symbol 
Wenn sich in der obersten Zeile ein Symbol mit 'T_', 'D_' oder 
'B_' befindet, wird hiernach im brigen Text gesucht und die 
entsprechende Stelle angesprungen. Mit anderen Labelnamen geht 
dies leider noch nicht. (nur Editor) 
 
4.7. Goto next Symbol 
Arbeitet „hnlich wie 'Goto Symbol', nur da hier erst der 
n„chste Verzweigbefehl (jmp, jsr, bxx.s, bxx) gesucht wird. 
 
4.8. Remark „ndern 
Erm”glicht es Kommentare zu „ndern und anzufgen. 
 
 
 
 
5. Editor-Optionen 
Im Gegensatz zu den Disassembler-Optionen k”nnen diese auch 
sp„ter noch ge„ndert werden. Sie betreffen nur die Benutzerober- 
fl„che. 
 
5.1. Turbo-Fenster 
Da die VDI-Textausgabe (V_GTEXT) bei achtfachen X-Werten 
wesentlich schneller arbeitet (welch Wunder), kann man hier die 
Fensterpositionierung einschr„nken. D.h. Fenster k”nnen nur noch 
an Stellen mit X=8*DIV(X,8)-1 gesetzt werden (wie im Desktop). 
 
5.2. Zeilenadressen 
Der Disassembler 'merkt' sich bei welcher Offset-Adresse der 
Opcode jeder Zeile stand. Mit der Option 'mit Zeilenadressen' 
oder den Cursertasten 'links' und 'rechts' werden diese einge- 
blendet. Zus„tzlich kann eingestellt werden ob diese in HEX- 
oder DEZ-Zahlenformat ausgegeben werden sollen. Das geht natr- 
lich nur, wenn eine Quelle geladen wurde! 
 
5.3. Sprungbefehle 
Um den Code bersichtlicher zu gestalten, werden einige Sprung- 
befehle farbig bzw. bold, fett und kursiv gekennzeichnet. Dieses 
l„t sich jedoch auch abstellen (erh”ht die Scrollgeschwindig- 
keit). 
 
5.4. Move-, Grow- und Shrinkboxen 
Wenn sie st”ren, dann schalten wir sie eben ab. 
 
 
 
 
6. System-Info 
Hier erf„hrt man die Inhalte von Systemvariablen und einigen 
wichtigen Vektoren. 
 
6.0 Die Funktion 
Die Dialogbox enth„lt neben diversen Buttons ein Eingabefeld, 
zwei Ausgabefelder und einen Pfeilbutton. Das Eingabefeld sollte 
die entsprechenden Eingaben enthalten (was sonst). In der linken 
Ausgabe steht der zurckgegebene Wert als Zahl (HEX oder DEZ) 
und in der rechten als String. Der Pfeilbutton dient dazu den 
Inhalt des linken Ausgabefeldes in das Eingabefeld zu kopieren. 
Im Eingabefeld sind folgende Symbole erlaubt: Ziffern von 0 bis 
F, $ fr Hexadezimalzahl, + fr addiere und - fr negativ oder 
subtrahiere. 
 
6.1. GET ... 
Nichts anderes als peek, dpeek (2 Byte) und lpeek (4 Byte). 
 
6.2. CPU-Vektor 
Erwartet Werte von 0 bis 263 und gibt die Vektoradressen zurck. 
Intern wird setexec [bios(5)] benutzt. Diese Vektoradressen 
entsprechen den Systemvariablen: 
 
Beispiele:    
    bios(5)   Systemvariable 
       33          $84          Vektor auf GEMDOS - Routinen 
       34          $88                     VDI/AES 
       45          $B4                     BIOS 
       46          $B8                     XBIOS 
     $100         $400          System-Timer-Interrupt 
     $101         $404          Critical Error Handler 
 
 
6.3. KBD-Vektor 
Erwartet Werte von 0 bis 8 und gibt die Adressen verschiedener 
Routinen zurck, die die vom Tastaturprozessor kommenden Daten 
verarbeiten. Es wird kbdvbase [xbios(34)] benutzt. 
     0 : midi_ein 
     1 : tast_ueberlauf 
     2 : midi_ueberlauf 
     3 : ikbd_status 
     4 : maus 
     5 : timer 
     6 : joystick 
     7 : midi_sys 
     8 : ikbd_sys 
 
6.4. _sysbase 
Holt die Basisadresse des TOS. 
 
6.5. linea 
Gibt je nach Eingabe eine Basisadresse zurck. (intern: nach 
dem Befehl linea #0 ğ $A000 werden die Adressregister A0-A2 
verschieden belegt.) 
 Eingabe     Ausgabe 
   0      Basisadresse der LINE-A Variablen 
   1      Zeiger auf Tabelle mit Zeigern auf die Systemzeichens„tze 
          (Wird hier wohl kaum jemand ben”tigen!) 
   2      Zeiger auf eine Tabelle mit den Anfangsadressen der  
          Line-A-Routinen („hnlich wie der Inhalt des Line-A-Vektors) 
 
 
 
7. Hilfstext 
Alle Remarks kommen aus der Hilfstext-Datei 'DS_HILFE.TXT', die 
bei Programmstart oder mit 'Hilfe laden' aus dem Men neugeladen 
werden kann. Ein L”schen der Hilfe erh”ht den freien Speicher. 
Sie ist eine 'stinknormale' ASCII-Datei deren Zeilenenden mit 
LF/CR begrenzt werden. Geladen wird sie mit der GFA-Basic- 
Funktion 'recall'. Mit Texteditoren wie z.B. 'TEMPUS' kann sie 
ohne Probleme erweitert werden. Hierbei sind folgende Normen zu 
beachten: 
 
- Die ersten drei Zeichen sind eine Zahl und bestimmem die 
  Zeilenl„nge der Datei. Wenn diese Zahl nicht vorhanden ist, 
  wird eine ASCII-Datei mit 30 Bytes pro Zeile geladen und 
  nicht ausgewertet. 
- Remarks mssen mit ';' anfangen. 
- Es werden folgende Segmente an entsprechenden W”rtern erkannt: 
   - gemdos:       GEMDOS ?/? 
   - bios:         BIOS ?/? 
   - xbios:        XBIOS ?/? 
   - Line-A:       LINEA ?/? 
   - Systemvariablen:   SYSVAR ?/- 
  Der erste Zahlenwert enth„lt die Anzahl der Eintr„ge. Der 
  zweite den h”chsten Parameterwert (entf„llt bei SYSVAR). 
- Die Parameterwerte der entsprechenden Funktionen mssen nach 
  dem folgenden Schema eingebaut werden: 
   - gemdos(DEZ) 
   - bios(DEZ) 
   - xbios(DEZ) 
   - linea #DEZ 
   - $HEX   (nur wortlange Variablen) 
 
Wenn Ihr dies beachtet, kann gar nichts schiefgehen. 
 
 
 
 
 
8. Was kann Desert Drain ? 
   Wie arbeite ich mit Desert Drain ? 
 
Dieser Disassembler kann (meiner Meinung nach) schon eine ganze 
Menge. Trotzdem gibt es einiges, was noch verbessert oder 
eingebaut werden mte. Leider waren in Version 1.1 so viele 
Fehler, da kaum jemand das Programm vernnftig nutzen konnte. 
(Und mit 'Nutzen' meine ich nicht unbedingt das Knacken eines 
Kopierschutzes.) 
 
Doch nun zur Sache - Was kann ein Disassembler? Als erstes 
solltet Ihr euch klar machen, da ein Disassembler in einem 
Quellcode nur Bits und Bytes erkennt, und nicht wei, ob es sich 
hierbei um einen Opcode oder ein Data handelt. Hier mu der 
Mensch Ihm helfen, denn nur er kann zu 100% erkennen um was es 
sich handelt. Also meckert nicht gleich los wenn Desert Drain 
einige Label nicht setzt, ober nach dem Optimieren im Assembler 
(z.B. TurboAss) das Programm nicht mehr l„uft. 
 
Aber wie k”nnt Ihr im helfen? Nach dem Disassemblieren solltet 
Ihr euch den Code im Editor ansehen und s„mtliche Bereiche, die 
nach vermeindlichen Datas aussehen, als zus„tzliche Databereiche 
vermerken. Aber Vorsicht! Nicht alles was Desert Drain als 
'dc.w' bersetzt ist ein vermeindliches Data. Manchmal zeigt 
eine Adresse zum Beispiel auf eine Konstante, die zu einem 
Opcode geh”rt, oder ein Programm untersttzt fortgeschrittene 
Mikroprozessoren deren Opcode Desert Drain noch nicht ent- 
schlsseln kann. So enth„lt zum Beispiel AHDI einige 'move D0, 
CACR' (ab MC68010). 
 
Wo liegt denn nun eigentlich das Problem? Stellt euch vor der 
Disassembler erkennt in einem Datenbereich einen Opcode mit 
Label und entschlsselt ihn. Hier ein real existierendes 
Beispiel aus einem Turbo-C Compilat: 
              Opcode:             $6566 
              Mnemonik:    PC:    bcs.s PC+$66 
              ASCII:              'ef' 
Vom Inhalt her ist hier nichts einzuwenden. Bit bleibt Bit. Nun 
stellt Euch aber vor Ihr optimiert den Assemblercode und 
verschiebt einige Label... 
 
Warum setzt Desert Drain einige Label nicht, die ins Text- 
Segment zeigen? Hier gibt es mehrere M”glichkeiten. Wenn das 
Label bzw. die angesprochene Adresse ungerade ist, kann sie nur 
auf ein Data z.B. einen String zeigen, und den erkennt der Dis- 
assembler nicht automatisch. Hier mt Ihr 'per Hand' nach- 
arbeiten. Wenn das Label gerade ist, w„re es m”glich, da es 
nicht direkt auf einen Opcode sondern auf dessen Konstante oder 
Sprunglabel zeigt. Warum? Wei ich nicht, aber so etwas kommt vor. 
 
 
So da war's dann auch schon. 
 
                              Tsch. Euer Volker 
 
