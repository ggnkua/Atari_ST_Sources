$m 64000
acc!=({ADD(BASEPAGE,36)}=0)
IF FRE()<64000
  ~FORM_ALERT(1,"[1][| Insuffisant or fragmented | memory. |][ Quit ]")
  QUIT 0
ELSE
  ON ERROR GOSUB leave
  init1
  @load_info
  init2
  main
ENDIF
'
> PROCEDURE leave
  close_all_win
  mxfree(m_adr%)
  mxfree(raster_image%)
  IF long_photo%=0
    mxfree(buf_photo%)
  ENDIF
  ~RSRC_FREE()
  v_clsvwk
  ~APPL_EXIT()
  QUIT 0
RETURN
'
> PROCEDURE init1
  ~GRAF_MOUSE(0,0)
  ap_id&=APPL_INIT()
  '
  vdi_handle&=@v_opnvwk
  '
  IF ap_id&<0
    leave
  ENDIF
  '
  IF acc!=TRUE AND ap_id&>0
    ~MENU_REGISTER(ap_id&,"  Rage Screen Saver")
  ENDIF
  '
  IF VAL(HEX$(INT{{ADD(GB,4)}}))>=399
    naes!=TRUE
  ELSE
    naes!=FALSE
  ENDIF
  '
  magic!=@test_cookie("MagX",dummy%)
  mint!=@test_cookie("MiNT",dummy%) OR @test_cookie("Gnva",dummy%)
  IF magic! OR mint!
    multi!=TRUE
  ELSE
    multi!=FALSE
  ENDIF
  '
  ~WIND_UPDATE(1)
  ~WIND_UPDATE(3)
  '
  ~WIND_GET(0,4,screenx&,screeny&,screenl&,screenh&)
  '
  @declare_1
  @declare_2
  IF mint!=FALSE
    RESERVE 16000
  ENDIF
  @declare_3
  '
  ~RSRC_FREE()
  IF @s_exist(chemin$+ragecalm_rsc$)=TRUE
    IF RSRC_LOAD(chemin$+ragecalm_rsc$)=0
      ~FORM_ALERT(1,"[1][RAGECALM.RSC couldn't be| loaded as a RSC file.][ Quit ]")
      leave
    ELSE
      FOR i&=0 TO nb_tree&
        ~RSRC_GADDR(0,i&,adtree%(i&))
      NEXT i&
      OB_H(adtree%(0),0)=OB_H(adtree%(1),1)
      OB_W(adtree%(0),0)=OB_W(adtree%(2),0)
      FOR i&=0 TO nb_tree&
        ~FORM_CENTER(adtree%(i&),xd&(i&),yd&(i&),dummy&,dummy&)
        IF i&=0
          hd&(0)=OB_H(adtree%(0),1)
        ELSE
          hd&(i&)=OB_H(adtree%(i&),0)
          wd&(i&)=OB_W(adtree%(i&),0)
        ENDIF
      NEXT i&
    ENDIF
  ELSE
    ~FORM_ALERT(1,"[1][|RAGECALM.RSC not found.|Put it beside RAGECALM.A?? ][ Ok ]")
    leave
  ENDIF
  '
  OB_SPEC(adtree%(0),1)=OB_SPEC(adtree%(0),1) OR &X111111110000000000000000
  OB_TYPE(adtree%(0),0)=20
  menu_titre_deb&=3
  menu_titre_fin&=OB_TAIL(adtree%(0),2)
  menu_box_deb&=OB_HEAD(adtree%(0),OB_TAIL(adtree%(0),0))
  menu_box_fin&=OB_TAIL(adtree%(0),OB_TAIL(adtree%(0),0))
  '
  IF OB_TYPE(adtree%(1),0)=20 AND (nb_plan&<3 OR magic!=FALSE)
    OB_SPEC(adtree%(1),0)=OB_SPEC(adtree%(1),0) AND &X1111111111111111
    OB_SPEC(adtree%(4),0)=OB_SPEC(adtree%(4),0) AND &X1111111111111111
  ENDIF
  '
  IF NOT magic!
    FOR i&=12 TO 18
      obj_disable(1,i&)
    NEXT i&
  ENDIF
  '
  get_env_home
  IF LEN(home$)>0 AND home$<>c0$
    preferences_path$=home$+ragecalm_inf$
  ELSE
    preferences_path$=chemin$+ragecalm_inf$
  ENDIF
  scrap_read
  IF LEN(scrap_text_file$)<7
    OB_FLAGS(adtree%(3),OB_TAIL(adtree%(3),0))=BSET(OB_FLAGS(adtree%(3),OB_TAIL(adtree%(3),0)),7)
  ENDIF
  '
RETURN
> PROCEDURE declare_1
  lect%=GEMDOS(25)
  chemin$=CHR$(ADD(lect%,65))+":"+DIR$(SUCC(lect%))+"\"
  c0$=CHR$(0)
  '
  ragecalm_rsc$="RAGECALM.RSC"+c0$
  ragecalm_inf$="RAGECALM.INF"+c0$
  preferences_path$=SPACE$(256)
  '
  fi_path$=SPACE$(256)
  fi_name$=SPACE$(256)
  '
  nb_tree&=5
  '
  DIM adtree%(nb_tree&),xd&(nb_tree&),yd&(nb_tree&),wd&(nb_tree&),hd&(nb_tree&)
  DIM hand_win&(nb_tree&),wx&(nb_tree&),wy&(nb_tree&),ww&(nb_tree&),wh&(nb_tree&)
  '
  preferences_text_size&=64
  DIM preferences_text$(preferences_text_size&)
  FOR i&=0 TO preferences_text_size&
    preferences_text$(i&)=SPACE$(128)
  NEXT i&
  '
  DIM boolean$(1)
  boolean$(0)="FALSE"
  boolean$(1)="TRUE"
  '
  DIM win!(nb_tree&),cp_win&(nb_tree&),aff!(nb_tree&)
  FOR i&=0 TO nb_tree&
    win!(i&)=FALSE
    aff!(i&)=FALSE
    cp_win&(i&)=&X1011
  NEXT i&
  '
  IF naes!=TRUE
    cp_win&(0)=BSET(cp_win&(0),14)
  ENDIF
  '
RETURN
> PROCEDURE declare_2
  '
  device_okay!=FALSE
  device_framebuffer_base%=0
  device_register_base%=0
  '
  cur_timer%=0
  cur_pos_x&=0
  cur_pos_y&=0
  cur_but_k&=0
  cur_key_c&=0
  '
  old_timer%=0
  old_pos_x&=0
  old_pos_y&=0
  '
  inactivity_delay&=7
  no_blanking_zone&=1
  mach64_sleeping!=FALSE
  '
  animation_delay&=5
  animation_pathfile$=""
  animation_name$=""
  mach64_animation!=FALSE
  '
RETURN
> PROCEDURE declare_3
  '
  m_adr%=MALLOC(32)
  IF m_adr%<1
    leave
  ELSE
    ABSOLUTE m_type&,m_adr%
    ABSOLUTE m_ap_id&,ADD(m_adr%,2)
    ABSOLUTE m_nothing&,ADD(m_adr%,4)
    ABSOLUTE m_titre&,ADD(m_adr%,6)
    ABSOLUTE m_fenetre&,ADD(m_adr%,6)
    ABSOLUTE m_entree&,ADD(m_adr%,8)
    ABSOLUTE m_x&,ADD(m_adr%,8)
    ABSOLUTE m_y&,ADD(m_adr%,10)
    ABSOLUTE m_l&,ADD(m_adr%,12)
    ABSOLUTE m_h&,ADD(m_adr%,14)
    '
    m_buf%=ADD(m_adr%,16)
  ENDIF
  '
  buf_photo%=0
  '
  INT{ADD(CONTRL,12)}=vdi_handle&
  INT{INTIN}=1
  VDISYS 102,1,0
  nb_plan&=INT{ADD(INTOUT,8)}
  '
  raster_image%=MALLOC(64)
  IF raster_image%
    '
    ~WIND_GET(0,17)
    buf_photo%={ADD(GINTOUT,2)}
    long_photo%={ADD(GINTOUT,6)}
    IF long_photo%<MUL(9000,nb_plan&) OR nb_plan&>8
      buf_photo%=MALLOC(MUL(9000,nb_plan&))
      long_photo%=0
    ENDIF
    '
    pscrmfdb%=raster_image%
    pdesmfdb%=ADD(pscrmfdb%,20)
    pxyarray%=ADD(pdesmfdb%,20)
    '
    make_zero_mfdb(pscrmfdb%)
    make_zero_mfdb(pdesmfdb%)
    '
    LONG{pdesmfdb%}=buf_photo%
    INT{ADD(pdesmfdb%,4)}=288
    INT{ADD(pdesmfdb%,6)}=300
    INT{ADD(pdesmfdb%,8)}=18
    INT{ADD(pdesmfdb%,12)}=nb_plan&
    '
  ENDIF
  '
RETURN
> PROCEDURE init2
  LOCAL pci_func_error%,ati_handle%,pci_map_ptr%
  LOCAL device_name$,chip_name$,foundry_name$,bus$,dac_name$
  LOCAL config_chip_id_value%,chip_type%,chip_class%,chip_rev%
  LOCAL chip_version%,chip_foundry%,chip_revision%
  LOCAL config_stat0_value%,mem_cntl_value%
  '
  set_inactivity_delay(inactivity_delay&)
  set_no_blanking_zone(no_blanking_zone&)
  set_animation_delay(animation_delay&)
  set_animation_name(info_pathfile$)
  '
  FOR i&=2 TO 20 STEP 2
    CHAR{OB_SPEC(adtree%(3),i&)}=""
  NEXT i&
  '
  pci_bios_error%=@pci_bios_init
  IF pci_bios_error%=&H0
    '
    idx&=0
    DO
      ati_handle%=@pci_find_pci_device(&HFFFF,idx&) ! scanning PCI cards
      IF ati_handle%>=0
        ~@pci_read_config_longword(ati_handle%,&H0,device_vendor%) ! reading device+vendor
      ENDIF
      INC idx&
    LOOP UNTIL ati_handle%<0 OR (device_vendor% AND &HFFFF)=&H1002 ! error or ATI vendor found
    '
    IF ati_handle%<0
      CHAR{OB_SPEC(adtree%(3),2)}=LEFT$(CHAR{OB_SPEC(adtree%(5),4)},36)
    ELSE
      CHAR{OB_SPEC(adtree%(3),2)}=LEFT$("ATI Technologies",36)
      '
      device_okay!=TRUE
      device_name$=""
      SELECT SHR(device_vendor% AND &HFFFF0000,16) ! selecting device
      CASE &H4758
        device_name$="Mach64GX (ATI888GX00)"
      CASE &H4358
        device_name$="Mach64CX (ATI888CX00)"
      CASE &H4354
        device_name$="Mach64CT (ATI264CT)"
      CASE &H4554
        device_name$="Mach64ET (ATI264ET)"
      CASE &H5654
        device_name$="Mach64VT3 (ATI264VT)"
      CASE &H5655
        device_name$="Mach64VTB (ATI264VTB)"
      CASE &H5656
        device_name$="Mach64VT4 (ATI264VT4)"
      CASE &H4752
        device_name$="3D Rage (XL)"
      CASE &H4754
        device_name$="3D Rage (GT)"
      CASE &H4755
        device_name$="3D Rage II/II+ (GTB)"
      CASE &H4756
        device_name$="3D Rage IIc (PCI)"
      CASE &H4757,&H475A
        device_name$="3D Rage IIc (AGP)"
      CASE &H4C54
        device_name$="3D Rage LT"
      CASE &H4C47
        device_name$="3D Rage LT-G"
      CASE &H4742
        device_name$="3D Rage Pro (BGA, AGP, 1x & 2x)"
      CASE &H4744
        device_name$="3D Rage Pro (BGA, AGP, 1x only)"
      CASE &H4749
        device_name$="3D Rage Pro (BGA, PCI33 only)"
      CASE &H4750
        device_name$="3D Rage Pro (PQFP, PCI33, full 3D)"
      CASE &H4751
        device_name$="3D Rage Pro (PQFP, PCI33, limited 3D)"
      CASE &H4C42
        device_name$="3D Rage LT Pro (AGP)"
      CASE &H4C44,&H4C49,&H4C50
        device_name$="3D Rage LT Pro (PCI)"
      CASE &H4C4D
        device_name$="3D Rage Mobility (PCI)"
      CASE &H4C4E
        device_name$="3D Rage Mobility (AGP)"
      DEFAULT
        device_name$="Unknown ($"+HEX$(SHR(device_vendor% AND &HFFFF0000,16))+")"
        device_okay!=FALSE
      ENDSELECT
      CHAR{OB_SPEC(adtree%(3),4)}=LEFT$(device_name$,36)
      '
      IF device_okay!
        '
        ' searching the MEM adresses of the PCI card (CBA1, CBA2 ... CB6)
        '
        reg|=&H10
        FOR i&=1 TO 6
          ~@pci_read_config_longword(ati_handle%,reg|,base%)
          IF BTST(base%,0)
            base%=base% AND &HFFFFFFFC ! is i/O space
          ELSE
            base%=base% AND &HFFFFFFF0 ! is MEM space
            '
            IF device_framebuffer_base%=0 ! assumes first MEM space is framebuffer
              device_framebuffer_base%=base%
            ELSE
              device_register_base%=base% ! assumes second MEM space is register
            ENDIF
            '
          ENDIF
          ADD reg|,4
          EXIT IF device_register_base%>0
        NEXT i&
        '
        ~FRE(0)
        '
        ' converting PCI base adresses to TOS adresses
        ' 1) attempt to remap
        ' 2) if not, detect the machine, a convert manually
        ' (from test.c source of Johan Klockars)
        '
        pci_map_ptr%=MALLOC(16) ! 2 LONGs (1 LONG = address, 1 LONG : length)
        '
        IF (@pci_bus_to_virt(ati_handle%,device_register_base%,pci_map_ptr%) AND &HFFFFFFF0)<>&HFFFFFFF0 ! if function supported
          device_register_base%=LONG{pci_map_ptr%}+1024
          ~@pci_bus_to_virt(ati_handle%,device_framebuffer_base%,pci_map_ptr%)
          device_framebuffer_base%=LONG{pci_map_ptr%}
        ELSE
          host_id%=@pci_get_machine_id
          SELECT SHR(host_id% AND &HFF000000,24)
          CASE 0 ! Medusa/Hades
            device_register_base%=device_register_base%+1024
          CASE 1 ! Milan
            device_register_base%=device_register_base%+&H40000000+1024
            device_framebuffer_base%=device_framebuffer_base%+&H40000000
          CASE 2 ! PAK/Panther2
            device_register_base%=device_register_base%+1024
          DEFAULT ! Falcon/Eclipse ?
            device_register_base%=device_register_base%+&HF0000000+1024
            device_framebuffer_base%=device_framebuffer_base%+&HE0000000
          ENDSELECT
        ENDIF
        mxfree(pci_map_ptr%)
        '
        ' reading chip informations
        '
        config_chip_id_value%=@ati_rd_32(&HE0) ! read at CONFIG_CHIP_ID register
        '
        chip_type%=config_chip_id_value% AND &HFFFF
        chip_class%=SHR(config_chip_id_value% AND &HFF0000,16)
        chip_rev%=SHR(config_chip_id_value% AND &HFF000000,24)
        chip_version%=SHR(config_chip_id_value% AND &H7000000,24) ! Mach264xT
        chip_foundry%=SHR(config_chip_id_value% AND &H38000000,27) ! Mach264xT
        chip_revision%=SHR(config_chip_id_value% AND &HC0000000,30) ! Mach264xT
        '
        chip_name$=""
        SELECT chip_type%
        CASE &HD7,&H4758
          SELECT chip_rev%
          CASE &H0
            chip_name$="88800GXC"
          CASE &H1
            chip_name$="88800GXD"
          CASE &H2
            chip_name$="88800GXE"
          CASE &H3
            chip_name$="88800GXF"
          DEFAULT
            chip_name$="88800GX"
          ENDSELECT
        CASE &H57,&H4358
          chip_name$="88800CX"
        CASE &H53,&H4354
          chip_name$="264CT"
        CASE &H93,&H4554
          chip_name$="264ET"
        CASE &H2B3,&H5654
          chip_name$="264VT"
          IF chip_version%<>0
            chip_name$="264VTB"
          ENDIF
        CASE &H2B4,&H5655
          chip_name$="264VT3"
        CASE &H315,&H5656
          chip_name$="264VT4"
        CASE &HD3,&H4754
          IF chip_version%=0
            chip_name$="264GT"
          ELSE
            chip_name$="264GTB"
          ENDIF
        CASE &HD4,&H4755
          chip_name$="264GTDVD"
        CASE &HD5,&H4756,&HD6,&HD9,&H4757,&H475A
          chip_name$="264GT2C"
        CASE &HCE,&HCF,&HD0,&H4749,&H4750,&H4751,&HC7,&HC9,&H4742,&H4744
          chip_name$="264GTPRO"
        CASE &H166,&H4C47
          chip_name$="264LT"
        CASE &H168,&H16F,&H4C49,&H4C50,&H161,&H163,&H4C42,&H4C44
          chip_name$="264LTPRO"
        CASE &H4752
          chip_name$="264XL"
        CASE &H4C4D,&H4C4E
          chip_name$="MOBILITY"
        DEFAULT
          chip_name$="Not recognized"
        ENDSELECT
        IF INSTR(chip_name$,"Not recognized")=0
          CHAR{OB_SPEC(adtree%(3),6)}=LEFT$(chip_name$,36)
          CHAR{OB_SPEC(adtree%(3),8)}=LEFT$("$"+STR$(chip_class%),36)
          IF INSTR(chip_name$,"88800")=0
            chip_rev%=chip_revision%
            '
            foundry_name$=""
            SELECT chip_foundry%
            CASE 0
              foundry_name$="SGS-Thomson"
            CASE 1
              foundry_name$="NEC"
            CASE 2
              foundry_name$="KCS (?)"
            CASE 3
              foundry_name$="UMC (United Microelectronics Corp)"
            CASE 4
              foundry_name$="TSMC (Taiwan Semiconductor Manufacturing Company)"
            CASE 5
              foundry_name$="Unknown"
            CASE 6
              foundry_name$="Unknown"
            CASE 7
              foundry_name$="UMCA (UMC Alternate)"
            ENDSELECT
            CHAR{OB_SPEC(adtree%(3),14)}=LEFT$(foundry_name$,36)
            '
          ENDIF
          CHAR{OB_SPEC(adtree%(3),10)}=LEFT$("$"+STR$(chip_rev%),36)
          CHAR{OB_SPEC(adtree%(3),12)}=LEFT$("$"+STR$(chip_version%),36)
        ENDIF
        '
        config_stat0_value%=@ati_rd_32(&HE4) ! read at CONFIG_STAT0 register
        '
        ' reading bus informations
        '
        bus$=""
        IF INSTR(chip_name$,"88800")=1
          SELECT (config_stat0_value% AND &H7)
          CASE 0
            bus$="ISA"
          CASE 1
            bus$="EISA"
          CASE 6
            bus$="VLB"
          CASE 7
            bus$="PCI"
          DEFAULT
            bus$="?"
          ENDSELECT
        ENDIF
        CHAR{OB_SPEC(adtree%(3),16)}=LEFT$(bus$,36)
        '
        ' reading RAM informations
        '
        mem_cntl_value%=@ati_rd_32(&HB0) ! read at MEM_CNTL register
        '
        ram_type$=""
        IF INSTR(chip_name$,"88800")=1
          SELECT SHR(config_stat0_value% AND &H38,3)
          CASE 0
            ram_type$="DRAMx4"
          CASE 1
            ram_type$="VRAMx16"
          CASE 2
            ram_type$="VRAMx16ssr"
          CASE 3
            ram_type$="DRAMx16"
          CASE 4
            ram_type$="GraphicsDRAMx16"
          CASE 5
            ram_type$="EnhancedVRAMx16"
          CASE 6
            ram_type$="EnhancedVRAMx16ssr"
          ENDSELECT
        ELSE
          SELECT (config_stat0_value% AND &H7)
          CASE 0
            ram_type$="Disabled"
          CASE 1
            ram_type$="DRAM"
          CASE 2
            ram_type$="EDO"
          CASE 3
            ram_type$="PSEUDO_EDO"
          CASE 4
            ram_type$="SDRAM (1:1)"
          CASE 5
            ram_type$="SGRAM (1:1)"
          CASE 6
            ram_type$="SGRAM (2:1) 32 bits"
          ENDSELECT
        ENDIF
        ram_amount$=""
        IF INSTR(chip_name$,"88800")>0 OR chip_name$="264CT" OR chip_name$="264ET" OR chip_name$="264VT" OR chip_name$="264GT"
          SELECT (mem_cntl_value% AND &H7)
          CASE 0
            ram_amount$="512 Ko"
          CASE 1
            ram_amount$="1 Mo"
          CASE 2
            ram_amount$="2 Mo"
          CASE 3
            ram_amount$="4 Mo"
          CASE 4
            ram_amount$="6 Mo"
          CASE 5
            ram_amount$="8 Mo"
          ENDSELECT
        ELSE
          SELECT (mem_cntl_value% AND &HF)
          CASE 3
            ram_amount$="2 Mo"
          CASE 7
            ram_amount$="4 Mo"
          CASE 9
            ram_amount$="6 Mo"
          CASE 11
            ram_amount$="8 Mo"
          ENDSELECT
        ENDIF
        CHAR{OB_SPEC(adtree%(3),18)}=LEFT$(ram_amount$+" ["+ram_type$+"]",36)
        '
        ' reading DAC informations
        '
        dac_name$=""
        IF INSTR(chip_name$,"88800")=1
          SELECT SHR(config_stat0_value% AND &HE00,9)
          CASE &H0
            dac_name$="Internal"
          CASE &H1
            dac_name$="IBMRGB514"
          CASE &H2
            dac_name$="ATI68875"
          CASE &H72
            dac_name$="TVP3026_A"
          CASE &H3
            dac_name$="BT476"
          CASE &H4
            dac_name$="BT481"
          CASE &H14
            dac_name$="ATT20C491"
          CASE &H24
            dac_name$="SC15026"
          CASE &H34
            dac_name$="MU9C1880"
          CASE &H44
            dac_name$="IMSG174"
          CASE &H5
            dac_name$="ATI68860_B"
          CASE &H15
            dac_name$="ATI68860_C"
          CASE &H75
            dac_name$="TVP3026_B"
          CASE &H6
            dac_name$="STG1700"
          CASE &H16
            dac_name$="ATT498"
          CASE &H7
            dac_name$="STG1702"
          CASE &H17
            dac_name$="SC15021"
          CASE &H27
            dac_name$="ATT21C498"
          CASE &H37
            dac_name$="STG1703"
          CASE &H47
            dac_name$="CH8398"
          CASE &H57
            dac_name$="ATT20C408"
          DEFAULT
            dac_name$="Unknown"
          ENDSELECT
        ENDIF
        CHAR{OB_SPEC(adtree%(3),20)}=LEFT$(dac_name$,36)
        '
      ENDIF
    ENDIF
  ELSE
    ~MENU_IENABLE(adtree%(0),11,0)
  ENDIF
  '
  FOR i&=1 TO 19 STEP 2
    IF CHAR{OB_SPEC(adtree%(3),SUCC(i&))}=""
      CHAR{OB_SPEC(adtree%(3),i&)}=""
    ENDIF
  NEXT i&
  '
  IF acc!=TRUE
    ~MENU_IENABLE(adtree%(0),15,0)
  ENDIF
  '
  ~WIND_UPDATE(2)
  ~WIND_UPDATE(0)
  IF multi!=FALSE
    ~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
  ENDIF
  IF acc!=FALSE
    win(0)
  ENDIF
  '
RETURN
'
> PROCEDURE get_env_home
  '
  home$=c0$
  dummy$="HOME="+c0$
  '
  f_buf%=MALLOC(512)
  IF f_buf%>0
    INT{ADD(GCONTRL,2)}=0
    INT{ADD(GCONTRL,4)}=1
    INT{ADD(GCONTRL,6)}=2
    INT{ADD(GCONTRL,8)}=0
    '
    LONG{ADDRIN}=f_buf%
    LONG{ADD(ADDRIN,4)}=V:dummy$
    '
    GEMSYS 125
    '
    IF LONG{f_buf%}>0
      home$=CHAR{{f_buf%}}
      IF RIGHT$(home$)<>"\"
        home$=home$+"\"
      ENDIF
    ENDIF
    mxfree(f_buf%)
  ENDIF
  '
RETURN
> PROCEDURE scrap_read
  '
  f_buf%=MALLOC(256)
  IF f_buf%>0
    '
    GCONTRL(0)=80
    GCONTRL(1)=0
    GCONTRL(2)=1
    GCONTRL(3)=1
    GCONTRL(4)=0
    '
    ADDRIN(0)=f_buf%
    '
    GEMSYS
    '
    dummy%=GINTOUT(0)
    IF dummy%
      scrap_text_file$=CHAR{f_buf%}
    ENDIF
    scrap_text_file$=LEFT$(scrap_text_file$,RINSTR(scrap_text_file$,"\"))
    IF LEN(scrap_text_file$)<4
      dummy%=0
    ENDIF
    '
    IF dummy%=0
      IF BTST(BIOS(10),2)
        result%=FSFIRST("C:\CLIPBRD"+c0$,16)
      ELSE
        result%=-33
      ENDIF
    ENDIF
    '
    IF dummy%
      scrap_text_file$=scrap_text_file$+"SCRAP.TXT"+c0$
    ELSE
      IF result%=0
        scrap_text_file$="C:\CLIPBRD\SCRAP.TXT"+c0$
      ELSE
        scrap_text_file$=chemin$+"SCRAP.TXT"+c0$
      ENDIF
    ENDIF
    '
    mxfree(f_buf%)
  ENDIF
  '
RETURN
'
> PROCEDURE main
  DO
    evnt&=@ev_multi(&X110011,258,3,0,250,mo_x&,mo_y&,mo_k&,m_touche&,m_clavier&,mo_c&)
    IF BTST(evnt&,0)=TRUE
      gere_keyboard
      mo_c&=0
      mo_k&=0
      IF mach64_sleeping!
        old_timer%=TIMER
        set_mach64_blank(FALSE)
      ENDIF
    ENDIF
    IF BTST(evnt&,1)=TRUE
      IF mo_c&=1 AND mo_k&=1
        clic_win&=WIND_FIND(mo_x&,mo_y&)
        delai
        IF clic_win&=hand_win&(0) AND win!(0)=TRUE AND icon!=FALSE
          gere_main
        ENDIF
      ENDIF
      IF mach64_sleeping!
        old_timer%=TIMER
        set_mach64_blank(FALSE)
      ENDIF
    ENDIF
    IF BTST(evnt&,4)=TRUE
      SELECT m_type&
      CASE 20
        redraw
      CASE 21
        win_topped
      CASE 22
        win_closed
      CASE 28
        win_moved
      CASE 29,31
        win_top
      CASE 34
        iconify
      CASE 35
        uniconify
      CASE 40
        win(0)
      CASE 41
        aff!(0)=FALSE
        aff!(1)=FALSE
      CASE 50
        shut_down
      CASE 63
      CASE 18193
        win(0)
      CASE 22360
        FOR i&=0 TO 1
          IF m_fenetre&=hand_win&(i&) AND win!(i&)=TRUE
            aff!(i&)=FALSE
          ENDIF
        NEXT i&
      CASE 22361
        FOR i&=0 TO 1
          IF m_fenetre&=hand_win&(i&) AND win!(i&)=TRUE
            aff!(i&)=TRUE
          ENDIF
        NEXT i&
      ENDSELECT
    ENDIF
    IF BTST(evnt&,5)
      test_inactivity
    ENDIF
  LOOP
RETURN
'
> PROCEDURE win(dial&)
  IF win!(dial&)=TRUE
    force_top(dial&)
  ELSE
    create_win(dial&)
  ENDIF
RETURN
> PROCEDURE create_win(dial&)
  hand_win&(dial&)=@window_create(cp_win&(dial&))
  IF hand_win&(dial&)>0
    win!(dial&)=TRUE
    IF dial&=0
      ~FORM_CENTER(adtree%(1),xd&(1),yd&(1),dummy&,dummy&)
      ~WIND_SET(hand_win&(0),2,CARD(SWAP(OB_SPEC(adtree%(5),1))),CARD(OB_SPEC(adtree%(5),1)),0,0)
    ELSE
      ~FORM_CENTER(adtree%(dial&),xd&(dial&),yd&(dial&),dummy&,dummy&)
    ENDIF
    IF dial&=0
      ~WIND_CALC(0,cp_win&(dial&),xd&(1),yd&(1),wd&(1),ADD(hd&(0),SUCC(hd&(1))),wx&(dial&),wy&(dial&),ww&(dial&),wh&(dial&))
    ELSE
      ~WIND_CALC(0,cp_win&(dial&),xd&(dial&),yd&(dial&),wd&(dial&),hd&(dial&),wx&(dial&),wy&(dial&),ww&(dial&),wh&(dial&))
    ENDIF
    wx&(dial&)=MAX(SUCC(screenx&),wx&(dial&))
    wy&(dial&)=MAX(SUCC(screeny&),wy&(dial&))
    move_win(dial&,wx&(dial&),wy&(dial&),ww&(dial&),wh&(dial&))
    ~WIND_SET(hand_win&(dial&),24,&X1,0,0,0)
    IF WIND_OPEN(hand_win&(dial&),wx&(dial&),wy&(dial&),ww&(dial&),wh&(dial&))=0
      win!(dial&)=FALSE
      IF dial&=1
        icon!=FALSE
      ENDIF
    ENDIF
  ELSE
    no_more_win
  ENDIF
  aff!(dial&)=win!(dial&)
RETURN
> PROCEDURE no_more_win
  ~@alerte(1,4)
  win!(dial&)=FALSE
RETURN
> PROCEDURE close_win(dial&)
  IF win!(dial&)=TRUE
    ~WIND_CLOSE(hand_win&(dial&))
    ~WIND_DELETE(hand_win&(dial&))
    win!(dial&)=FALSE
    aff!(dial&)=FALSE
    IF dial&=1
      icon!=FALSE
    ENDIF
  ENDIF
RETURN
> PROCEDURE move_win(dial&,x0&,y0&,l0&,h0&)
  IF win!(dial&)=TRUE AND icon!=FALSE
    ~WIND_CALC(1,cp_win&(dial&),x0&,y0&,l0&,h0&,xd&(dial&),yd&(dial&),dummy&,dummy&)
    OB_X(adtree%(dial&),0)=xd&(dial&)
    OB_Y(adtree%(dial&),0)=yd&(dial&)
    IF dial&=0
      OB_X(adtree%(1),0)=xd&(0)
      OB_Y(adtree%(1),0)=ADD(yd&(0),SUCC(hd&(0)))
    ENDIF
  ENDIF
  IF dial&=4
    ~WIND_CALC(1,&X1001,m_x&,m_y&,m_l&,m_h&,xd&(4),yd&(4),wd&(4),hd&(4))
    OB_X(adtree%(4),0)=xd&(4)
    OB_Y(adtree%(4),0)=yd&(4)
    OB_W(adtree%(4),0)=wd&(4)
    OB_H(adtree%(4),0)=hd&(4)
    OB_X(adtree%(4),1)=MAX(0,(OB_W(adtree%(4),0)-OB_W(adtree%(4),1))/2)
    OB_Y(adtree%(4),1)=MAX(0,(OB_H(adtree%(4),0)-OB_H(adtree%(4),1))/2)
  ENDIF
RETURN
> PROCEDURE noir_blanc(arbre&,fils&,nb_etat&)
  IF BTST(OB_FLAGS(adtree%(arbre&),fils&),9)=0
    black_white(arbre&,fils&,OB_STATE(adtree%(arbre&),fils&))
  ENDIF
  black_white(arbre&,fils&,nb_etat&)
RETURN
> PROCEDURE black_white(arbre&,fils&,etat&)
  SELECT etat&
  CASE 0
    obj_deselect(arbre&,fils&)
  CASE 1
    obj_select(arbre&,fils&)
  ENDSELECT
  SELECT arbre&
  CASE 0,3,6
    xf&=screenx&
    yf&=screeny&
    lf&=screenl&
    hf&=screenh&
    rx&=xf&
    ry&=yf&
    rl&=lf&
    rh&=hf&
  CASE 1
    ~WIND_GET(hand_win&(0),4,xf&,yf&,lf&,hf&)
    ~WIND_GET(hand_win&(0),11,rx&,ry&,rl&,rh&)
  ENDSELECT
  IF (win!(0)=TRUE AND aff!(0)=TRUE AND icon!=FALSE)
    control
    WHILE rl&<>0 AND rh&<>0
      IF RC_INTERSECT(xf&,yf&,lf&,hf&,rx&,ry&,rl&,rh&)
        ~OBJC_DRAW(adtree%(arbre&),fils&,3,rx&,ry&,rl&,rh&)
      ENDIF
      IF arbre&=1
        ~WIND_GET(hand_win&(0),12,rx&,ry&,rl&,rh&)
      ELSE
        ~WIND_GET(hand_win&(arbre&),12,rx&,ry&,rl&,rh&)
      ENDIF
    WEND
    uncontrol
  ENDIF
RETURN
'
> PROCEDURE force_top(bar&)
  ~WIND_GET(0,10,top_win&,dummy&,dummy&,dummy&)
  IF top_win&<>hand_win&(bar&) AND win!(bar&)=TRUE
    FOR i&=0 TO 12 STEP 4
      LONG{ADD(m_buf%,i&)}=0
    NEXT i&
    INT{m_buf%}=21
    INT{ADD(m_buf%,2)}=ap_id&
    INT{ADD(m_buf%,6)}=hand_win&(bar&)
    ~APPL_WRITE(ap_id&,16,m_buf%)
  ENDIF
RETURN
> PROCEDURE force_update(bar&,xr&,yr&,lr&,hr&)
  IF win!(bar&)
    INT{m_buf%}=20
    INT{ADD(m_buf%,2)}=ap_id&
    INT{ADD(m_buf%,4)}=0
    INT{ADD(m_buf%,6)}=hand_win&(bar&)
    INT{ADD(m_buf%,8)}=xr&
    INT{ADD(m_buf%,10)}=yr&
    INT{ADD(m_buf%,12)}=lr&
    INT{ADD(m_buf%,14)}=hr&
    ~APPL_WRITE(ap_id&,16,m_buf%)
  ENDIF
RETURN
'
> PROCEDURE shut_down
  ~APPL_EXIT()
  QUIT
RETURN
> PROCEDURE win_closed
  IF m_fenetre&=hand_win&(0) AND win!(0)=TRUE
    IF acc!
      close_win(0)
    ELSE
      @leave
    ENDIF
  ENDIF
RETURN
> PROCEDURE win_moved
  m_x&=MAX(SUCC(screenx&),m_x&)
  m_y&=MAX(SUCC(screeny&),m_y&)
  ~WIND_SET(m_fenetre&,5,m_x&,m_y&,m_l&,m_h&)
  FOR i&=0 TO 3
    IF m_fenetre&=hand_win&(i&) AND win!(i&)=TRUE
      IF icon!=TRUE AND i&=1
        move_win(5,m_x&,m_y&,m_l&,m_h&)
      ELSE
        move_win(i&,m_x&,m_y&,m_l&,m_h&)
      ENDIF
    ENDIF
  NEXT i&
RETURN
> PROCEDURE win_topped
  IF m_fenetre&=hand_win&(0) AND win!(0)=TRUE
    ~WIND_SET(hand_win&(0),10,0,0,0,0)
  ENDIF
RETURN
> PROCEDURE win_top
RETURN
> PROCEDURE redraw
  '
  control
  ~WIND_GET(m_fenetre&,11,rx&,ry&,rl&,rh&)
  WHILE rl&<>0 AND rh&<>0
    IF RC_INTERSECT(m_x&,m_y&,m_l&,m_h&,rx&,ry&,rl&,rh&)
      IF m_fenetre&=hand_win&(0) AND win!(0)=TRUE
        IF icon!=FALSE
          ~OBJC_DRAW(adtree%(0),1,3,rx&,ry&,rl&,rh&)
          ~OBJC_DRAW(adtree%(1),0,3,rx&,ry&,rl&,rh&)
        ELSE
          ~OBJC_DRAW(adtree%(4),0,0,rx&,ry&,rl&,rh&)
          ~OBJC_DRAW(adtree%(4),1,0,rx&,ry&,rl&,rh&)
        ENDIF
      ENDIF
    ENDIF
    ~WIND_GET(m_fenetre&,12,rx&,ry&,rl&,rh&)
  WEND
  uncontrol
  '
RETURN
> PROCEDURE iconify
  IF naes!=TRUE
    IF m_fenetre&=hand_win&(0) AND win!(0)=TRUE
      icon!=TRUE
      ~WIND_SET(m_fenetre&,26,m_x&,m_y&,m_l&,m_h&)
      ~WIND_GET(m_fenetre&,5,m_x&,m_y&,m_l&,m_h&)
      move_win(4,m_x&,m_y&,m_l&,m_h&)
    ENDIF
  ENDIF
RETURN
> PROCEDURE uniconify
  IF m_fenetre&=hand_win&(0) AND win!(0)=TRUE AND naes!=TRUE
    ~WIND_SET(m_fenetre&,27,m_x&,m_y&,m_l&,m_h&)
    icon!=FALSE
  ENDIF
RETURN
'
> PROCEDURE gere_main
  SELECT OBJC_FIND(adtree%(0),0,5,mo_x&,mo_y&)
  CASE menu_titre_deb& TO menu_titre_fin&
    gere_menu
  DEFAULT
    gere_pannel
  ENDSELECT
RETURN
> PROCEDURE gere_menu
  menu_tit&=0
  DO
    result&=OBJC_FIND(adtree%(0),2,menu_titre_fin&,mo_x&,mo_y&)
    IF result&>=menu_titre_deb& AND result&=<menu_titre_fin&
      menu_tit&=result&
      noir_blanc(0,menu_tit&,1)
      gere_shell_menu(menu_tit&)
      noir_blanc(0,menu_tit&,0)
    ELSE
      menu_tit&=0
      result&=0
    ENDIF
  LOOP UNTIL menu_tit&=0 OR old_result&<>0
  delai
  flush_clic
  SELECT old_result&
  CASE 7
    @infos
  CASE 9
    @inquire_video_card
  CASE 11
    @test_blanking
  CASE 13
    @save_info
  CASE 15
    @quit
  ENDSELECT
RETURN
> PROCEDURE gere_shell_menu(menu_tit&)
  old_menu_tit&=menu_tit&
  j&=PRED(menu_titre_deb&)
  FOR i&=menu_box_deb& TO menu_box_fin&
    IF OB_TYPE(adtree%(0),i&)=20
      INC j&
      IF j&=menu_tit&
        menu_deb&=i&
      ENDIF
    ENDIF
  NEXT i&
  menu_fin&=OB_TAIL(adtree%(0),menu_deb&)
  control
  get_photo(0,menu_deb&)
  v_show_c
  old_result&=0
  DO
    IF NOT magic!
      evnt&=@ev_multi(&X100010,258,3,0,30,mo_x&,mo_y&,mo_k&,dummy&,dummy&,mo_c&)
    ELSE
      evnt&=@ev_multi(&X10,2,0,1,30,mo_x&,mo_y&,mo_k&,dummy&,dummy&,mo_c&)
    ENDIF
    menu_result&=OBJC_FIND(adtree%(0),menu_deb&,menu_fin&,mo_x&,mo_y&)
    menu_tit&=OBJC_FIND(adtree%(0),2,menu_titre_fin&,mo_x&,mo_y&)
    IF menu_tit&<>old_menu_tit&
      SELECT menu_tit&
      CASE 3 TO menu_titre_fin&
        mo_c&=1
        mo_k&=1
      ENDSELECT
    ENDIF
    IF BTST(OB_STATE(adtree%(0),menu_result&),3)
      menu_result&=0
    ENDIF
    IF old_result&<>menu_result&
      IF menu_result&>menu_deb& AND menu_result&=<menu_fin&
        IF old_result&>menu_titre_fin&
          noir_blanc(0,old_result&,0)
        ENDIF
        old_result&=menu_result&
        noir_blanc(0,old_result&,1)
      ELSE
        IF old_result&>menu_titre_fin&
          noir_blanc(0,old_result&,0)
        ENDIF
        old_result&=0
      ENDIF
    ENDIF
  LOOP UNTIL mo_c&=1 AND (mo_k&=1 OR mo_k&=2)
  put_photo(0)
  uncontrol
  IF old_result&>menu_titre_fin&
    OB_STATE(adtree%(0),old_result&)=0
  ENDIF
RETURN
> PROCEDURE gere_pannel
  ihm_obj&=OBJC_FIND(adtree%(1),0,3,mo_x&,mo_y&)
  SELECT ihm_obj&
  CASE 2
    black_white(1,2,1)
    set_inactivity_delay(PRED(inactivity_delay&))
    set_animation_delay(animation_delay&)
    black_white(1,2,0)
  CASE 4
    black_white(1,4,1)
    set_inactivity_delay(SUCC(inactivity_delay&))
    set_animation_delay(animation_delay&)
    black_white(1,4,0)
  CASE 8 TO 11
    set_no_blanking_zone(SUB(ihm_obj&,7))
  CASE 13
    black_white(1,13,1)
    set_animation_delay(PRED(animation_delay&))
    black_white(1,13,0)
  CASE 15
    black_white(1,15,1)
    set_animation_delay(SUCC(animation_delay&))
    black_white(1,15,0)
  CASE 18
    black_white(1,18,1)
    dummy$=@fileselector$(6,chemin$+"*.PRG"+c0$,c0$)
    IF dummy$<>c0$
      set_animation_name(dummy$)
    ENDIF
    black_white(1,18,0)
  DEFAULT
    win(0)
  ENDSELECT
RETURN
> PROCEDURE gere_keyboard
  IF m_touche&=4
    SELECT BYTE(m_clavier&)
    CASE 9
      @infos
    CASE 19
      @save_info
    CASE 6
      @inquire_video_card
    CASE 20
      @test_blanking
    CASE 17
      @quit
    ENDSELECT
  ENDIF
RETURN
'
> PROCEDURE infos
  '
  @form_display(2)
  DO
    form_result&=FORM_DO(adtree%(2),0)
  LOOP UNTIL form_result&=9
  @obj_deselect(2,9)
  @form_clear(2)
  '
RETURN
> PROCEDURE quit
  IF acc!=FALSE
    @leave
  ENDIF
RETURN
'
> PROCEDURE inquire_video_card
  IF pci_bios_error%=&HFFFFF001
    ~@alerte(1,2)
  ELSE IF pci_bios_error%=&HFFFFF000
    ~@alerte(1,3)
  ELSE
    '
    @form_display(3)
    DO
      form_result&=FORM_DO(adtree%(3),0)
    LOOP UNTIL form_result&>0
    @obj_deselect(3,form_result&)
    @form_clear(3)
    '
    IF form_result&=OB_TAIL(adtree%(3),0)
      @save_info_card
    ENDIF
    '
  ENDIF
RETURN
> PROCEDURE save_info_card
  IF device_okay!
    '
    mem_pos%=@mem_init
    '
    mem_pos%=@mem_put_line("Inquire PCI video card by Rage Screen Saver",mem_pos%)
    mem_pos%=@mem_put_line("",mem_pos%)
    '
    FOR i&=2 TO 20 STEP 2
      IF LEN(CHAR{OB_SPEC(adtree%(3),i&)})>0
        mem_pos%=@mem_put_line(CHAR{OB_SPEC(adtree%(3),PRED(i&))}+" "+CHAR{OB_SPEC(adtree%(3),i&)},mem_pos%)
      ENDIF
    NEXT i&
    '
    ~GRAF_MOUSE(2,0)
    IF mem_pos%>0
      IF @s_exist(scrap_text_file$)
        ~GEMDOS(65,L:V:scrap_text_file$)
      ENDIF
      '
      file_handle&=GEMDOS(60,L:V:scrap_text_file$,W:0)
      IF file_handle&>0
        ~GEMDOS(64,W:file_handle&,L:SUB(mem_pos%,text_mem%),L:text_mem%)<>SUB(mem_pos%,text_mem%)
        ~GEMDOS(62,W:file_handle&)
      ENDIF
    ENDIF
    ~GRAF_MOUSE(0,0)
    '
    ~@mem_close
    '
  ENDIF
RETURN
> PROCEDURE test_blanking
  IF device_okay!
    IF @alerte(2,5)=1
      flush_clic
      IF mach64_sleeping!=FALSE
        set_mach64_blank(TRUE)
      ENDIF
      ~EVNT_TIMER(7000)
      ~GRAF_MKSTATE(cur_pos_x&,cur_pos_y&,cur_but_k&,cur_key_c&)
      old_pos_x&=cur_pos_x&
      old_pos_y&=cur_pos_y&
    ENDIF
  ENDIF
RETURN
> PROCEDURE set_mach64_blank(flag!)
  LOCAL crtc_gen_cntl%
  '
  IF device_okay!
    IF flag!
      IF mach64_sleeping!=FALSE
        IF magic!
          animation_id&=APPL_FIND(animation_app$)
          IF animation_id&>0
            screen_manager(1,animation_id&)
            v_show_c
          ENDIF
        ENDIF
        '
        crtc_gen_cntl%=@ati_rd_32(&H1C)       ! read CRTC_GEN_CNTL register
        crtc_gen_cntl%=BSET(crtc_gen_cntl%,2) ! set bit CRTC_HSYNC_DIS(able)
        crtc_gen_cntl%=BSET(crtc_gen_cntl%,3) ! set bit CRTC_VSYNC_DIS(able)
        crtc_gen_cntl%=BSET(crtc_gen_cntl%,6) ! set bit CRTC_DISPLAY_DIS(able)
        @ati_wr_32(&H1C,crtc_gen_cntl%)       ! write at CRTC_GEN_CNTL register
        mach64_sleeping!=TRUE
      ENDIF
    ELSE
      IF mach64_sleeping!=TRUE
        crtc_gen_cntl%=@ati_rd_32(&H1C)       ! read at CRTC_GEN_CNTL register
        crtc_gen_cntl%=BCLR(crtc_gen_cntl%,2) ! clear bit CRTC_HSYNC_DIS(able)
        crtc_gen_cntl%=BCLR(crtc_gen_cntl%,3) ! clear bit CRTC_VSYNC_DIS(able)
        crtc_gen_cntl%=BCLR(crtc_gen_cntl%,6) ! clear bit CRTC_DISPLAY_DIS(able)
        @ati_wr_32(&H1C,crtc_gen_cntl%)       ! write at CRTC_GEN_CNTL
        mach64_sleeping!=FALSE
      ENDIF
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE launch_animation(flag!)
  '
  IF magic!
    IF flag!
      IF mach64_animation!=FALSE AND animation_pathfile$<>c0$
        IF @s_exist(animation_pathfile$)
          num_drive&=SUB(ASC(animation_pathfile$),65)
          ~GEMDOS(14,W:num_drive&)
          CHDIR LEFT$(animation_pathfile$,RINSTR(animation_pathfile$,"\"))+c0$
          shl_write(1,1,100,c0$,animation_pathfile$)
          num_drive&=SUB(ASC(chemin$),65)
          ~GEMDOS(14,W:num_drive&)
          CHDIR LEFT$(chemin$,RINSTR(chemin$,"\"))+c0$
          mach64_animation!=TRUE
        ENDIF
      ENDIF
    ELSE
      IF mach64_animation!=TRUE
        animation_id&=APPL_FIND(animation_app$)
        IF animation_id&>0
          screen_manager(1,animation_id&)
          v_show_c
        ENDIF
        mach64_animation!=FALSE
      ENDIF
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE test_inactivity
  LOCAL delay%
  '
  ~GRAF_MKSTATE(cur_pos_x&,cur_pos_y&,cur_but_k&,cur_key_c&)
  IF cur_pos_x&=old_pos_x& AND cur_pos_y&=old_pos_y& AND cur_but_k&=0 AND cur_key_c&=0
    mouse_used!=FALSE
  ELSE IF cur_but_k&<>0 OR cur_key_c&<>0 OR old_pos_x&<>cur_pos_x& OR old_pos_y&<>cur_pos_y&
    mouse_used!=TRUE
    old_pos_x&=cur_pos_x&
    old_pos_y&=cur_pos_y&
  ENDIF
  '
  keyboard_used!=FALSE
  '
  IF @is_in_none_blanking_zone(cur_pos_x&,cur_pos_y&)
    old_timer%=TIMER
  ELSE IF mouse_used!=FALSE AND keyboard_used!=FALSE
    cur_timer%=TIMER
    delay%=((SUB(cur_timer%,old_timer%)/200)/60)
    IF delay%>=inactivity_delay&
      IF mach64_sleeping!=FALSE
        set_mach64_blank(TRUE)
      ENDIF
    ELSE IF delay%>=animation_delay&
      IF mach64_animation!=FALSE
        launch_animation(TRUE)
      ENDIF
    ENDIF
  ELSE IF mouse_used!=TRUE OR keyboard_used!=TRUE
    old_timer%=TIMER
    IF mach64_sleeping!=TRUE
      set_mach64_blank(FALSE)
    ELSE IF mach64_animation!=TRUE
      launch_animation(FALSE)
    ENDIF
  ENDIF
RETURN
'
> FUNCTION ati_rd_8(ati_reg%)
$F|
LOCAL old_stack%,value|
'
' pci_stack%=GEMDOS(32,L:0)
value|=BYTE{ADD(device_register_base%,ati_reg%)}
' ~GEMDOS(32,L:pci_stack%)
'
RETURN value|
ENDFUNC
> FUNCTION ati_rd_16(ati_reg%)
$F&
LOCAL old_stack%,value&
'
' pci_stack%=GEMDOS(32,L:0)
value&=INT{ADD(device_register_base%,ati_reg%)}
' ~GEMDOS(32,L:pci_stack%)
'
RETURN value&
ENDFUNC
> FUNCTION ati_rd_32(ati_reg%)
$F%
LOCAL old_stack%,value%
'
' pci_stack%=GEMDOS(32,L:0)
value%=LONG{ADD(device_register_base%,ati_reg%)}
' ~GEMDOS(32,L:pci_stack%)
'
RETURN value%
ENDFUNC
> PROCEDURE ati_wr_8(ati_reg%,value|)
' LOCAL old_stack%
'
' pci_stack%=GEMDOS(32,L:0)
BYTE{ADD(device_register_base%,ati_reg%)}=value|
' ~GEMDOS(32,L:pci_stack%)
RETURN
> PROCEDURE ati_wr_16(ati_reg%,value&)
' LOCAL old_stack%
'
' pci_stack%=GEMDOS(32,L:0)
INT{ADD(device_register_base%,ati_reg%)}=value&
' ~GEMDOS(32,L:pci_stack%)
RETURN
> PROCEDURE ati_wr_32(ati_reg%,value%)
' LOCAL old_stack%
'
' pci_stack%=GEMDOS(32,L:0)
LONG{ADD(device_register_base%,ati_reg%)}=value%
' ~GEMDOS(32,L:pci_stack%)
RETURN
'
> PROCEDURE save_info
'
mem_pos%=@mem_init
'
mem_pos%=@mem_put_property("RAGECALM_INF","1.1",mem_pos%)
mem_pos%=@mem_put_property("#","",mem_pos%)
mem_pos%=@mem_put_property("#","DO NOT MODIFY THESE VALUES! USE FVDICMD",mem_pos%)
mem_pos%=@mem_put_property("#","",mem_pos%)
'
mem_pos%=@mem_put_property("INACTIVITY_DELAY",STR$(inactivity_delay&),mem_pos%)
mem_pos%=@mem_put_property("NO_BLANKING_ZONE",STR$(no_blanking_zone&),mem_pos%)
mem_pos%=@mem_put_property("ANIMATION_DELAY",STR$(animation_delay&),mem_pos%)
mem_pos%=@mem_put_property("ANIMATION_NAME",@remove_c0$(animation_pathfile$),mem_pos%)
'
~GRAF_MOUSE(2,0)
IF mem_pos%>0
IF @s_exist(preferences_path$)
~GEMDOS(65,L:V:preferences_path$)
ENDIF
'
file_handle&=GEMDOS(60,L:V:preferences_path$,W:0)
IF file_handle&>0
~GEMDOS(64,W:file_handle&,L:SUB(mem_pos%,text_mem%),L:text_mem%)<>SUB(mem_pos%,text_mem%)
~GEMDOS(62,W:file_handle&)
ENDIF
ENDIF
~GRAF_MOUSE(0,0)
'
~@mem_close
'
RETURN
> PROCEDURE load_info
LOCAL command_i&,command_txt$,sep_pos&
'
new_preferences_text
IF @s_exist(preferences_path$)=TRUE
'
OPEN "i",#4,preferences_path$
RECALL #4,preferences_text$(),-1,nb_line%
CLOSE #4
'
IF LEFT$(preferences_text$(0),12)="RAGECALM_INF"
'
inactivity_delay&=MAX(5,MIN(VAL(@find$("INACTIVITY_DELAY")),45))
no_blanking_zone&=MAX(1,MIN(VAL(@find$("NO_BLANKING_ZONE")),4))
animation_delay&=MAX(4,MIN(MIN(VAL(@find$("ANIMATION_DELAY")),PRED(inactivity_delay&)),44))
info_pathfile$=@find$("ANIMATION_NAME")+c0$
'
ENDIF
new_preferences_text
ENDIF
RETURN
> PROCEDURE set_inactivity_delay(value&)
inactivity_delay&=MAX(5,MIN(value&,45))
CHAR{{OB_SPEC(adtree%(1),3)}}=STR$(inactivity_delay&)
black_white(1,3,0)
RETURN
> PROCEDURE set_no_blanking_zone(zone&)
no_blanking_zone&=MAX(1,MIN(zone&,4))
SELECT zone&
CASE 1
obj_select(1,8)
obj_deselect(1,9)
obj_deselect(1,10)
obj_deselect(1,11)
CASE 2
obj_deselect(1,8)
obj_select(1,9)
obj_deselect(1,10)
obj_deselect(1,11)
CASE 3
obj_deselect(1,8)
obj_deselect(1,9)
obj_select(1,10)
obj_deselect(1,11)
CASE 4
obj_deselect(1,8)
obj_deselect(1,9)
obj_deselect(1,10)
obj_select(1,11)
ENDSELECT
IF nb_plan&>1 AND magic!=TRUE
black_white(1,7,1)
ELSE
black_white(1,7,0)
ENDIF
RETURN
> FUNCTION is_in_none_blanking_zone(cur_x&,cur_y&)
$F!
'
SELECT no_blanking_zone&
CASE 1
IF cur_x&<10 AND cur_y&<10
RETURN TRUE
ENDIF
CASE 2
IF cur_x&>SUB(ADD(screenx&,screenl&),10) AND cur_y&<10
RETURN TRUE
ENDIF
CASE 3
IF cur_x&<10 AND cur_y&>SUB(ADD(screeny&,screenh&),10)
RETURN TRUE
ENDIF
CASE 4
IF cur_x&>SUB(ADD(screenx&,screenl&),10) AND cur_y&>SUB(ADD(screeny&,screenh&),10)
RETURN TRUE
ENDIF
ENDSELECT
'
RETURN FALSE
ENDFUNC
> PROCEDURE set_animation_delay(value&)
animation_delay&=MAX(4,MIN(MIN(value&,PRED(inactivity_delay&)),44))
CHAR{{OB_SPEC(adtree%(1),14)}}=STR$(animation_delay&)
black_white(1,14,0)
RETURN
> PROCEDURE set_animation_name(name$)
IF name$=c0$
animation_pathfile$=c0$
ELSE IF LEN(name$)>2
animation_pathfile$=name$
animation_name$=@remove_c0$(MID$(name$,SUCC(RINSTR(name$,"\"))))
CHAR{{OB_SPEC(adtree%(1),18)}}=RIGHT$(animation_name$,13)
animation_app$=UPPER$(LEFT$(animation_name$,PRED(INSTR(animation_name$,"."))))
IF LEN(animation_app$)<8
animation_app$=animation_app$+SPACE$(SUB(8,LEN(animation_app$)))
ENDIF
ENDIF
RETURN
'
> FUNCTION find$(find_key$)
LOCAL find_len&,find_i&,find_exit!,find_end&
'
~FRE()
~FRE(0)
'
find_value$=""
find_exit!=FALSE
find_key$=find_key$+"="
find_len&=LEN(find_key$)
find_end&=MIN(preferences_text_size&,SUCC(nb_line%))
IF find_ptr&>PRED(find_end&)
find_cursor&=0
ENDIF
old_find_cursor&=find_cursor&
'
FOR find_i&=find_cursor& TO find_end&
IF LEFT$(preferences_text$(find_i&),find_len&)=find_key$
find_value$=MID$(preferences_text$(find_i&),SUCC(find_len&))
find_exit!=TRUE
ENDIF
EXIT IF find_exit!
NEXT find_i&
'
IF NOT find_exit!
find_cursor&=0
IF old_find_cursor&>PRED(find_end&)
FOR find_i&=0 TO old_find_cursor&
IF LEFT$(preferences_text$(find_i&),find_len&)=find_key$
find_value$=MID$(preferences_text$(find_i&),SUCC(find_len&))
find_exit!=TRUE
old_find_cursor&=find_i&
ENDIF
EXIT IF find_exit!
NEXT find_i&
find_cursor&=old_find_cursor&
ENDIF
ENDIF
'
RETURN find_value$
ENDFUNC
> PROCEDURE new_preferences_text
FOR i&=0 TO preferences_text_size&
preferences_text$(i&)=""
NEXT i&
find_ptr&=0
~FRE()
~FRE(0)
RETURN
> FUNCTION mem_init
~@mem_close
text_len%=16000
text_mem%=MALLOC(text_len%)
IF text_mem%<0
~@alerte(1,16)
text_mem%=0
ENDIF
RETURN text_mem%
ENDFUNC
> FUNCTION mem_close
IF text_mem%>0
~MFREE(text_mem%)
text_mem%=0
text_len%=0
ENDIF
RETURN TRUE
ENDFUNC
> FUNCTION mem_put_line(str$,ptr%)
LOCAL len_str%
'
str$=str$+CHR$(13)+CHR$(10)
len_str%=LEN(str$)
IF @mem_add(ptr%,len_str%,ptr%)
IF ptr%>0
CHAR{ptr%}=str$
ADD ptr%,len_str%
ENDIF
ENDIF
str$=""
'
RETURN ptr%
ENDFUNC
> FUNCTION mem_put_property(str1$,str2$,ptr%)
LOCAL len_str%
'
str$=str1$+"="+str2$+CHR$(13)+CHR$(10)
'
len_str%=LEN(str$)
IF @mem_add(ptr%,len_str%,ptr%)
IF ptr%>0
CHAR{ptr%}=str$
ADD ptr%,len_str%
ENDIF
ENDIF
str$=""
'
RETURN ptr%
ENDFUNC
> FUNCTION mem_add(old_pos%,add%,VAR new_pos%)
'
IF old_pos%=0
RETURN FALSE
ENDIF
'
IF ADD(SUB(old_pos%,text_mem%),add%)>text_len%
new_text_len%=SHL(SHR(ADD(ADD(text_len%,MAX(ADD(add%,16),16000)),32),4),4)
new_text_mem%=MALLOC(new_text_len%)
IF new_text_mem%>0
BMOVE text_mem%,new_text_mem%,text_len%
~MFREE(text_mem%)
new_pos%=ADD(old_pos%,SUB(new_text_mem%,text_mem%))
text_mem%=new_text_mem%
text_len%=new_text_len%
RETURN TRUE
ELSE
okay!=FALSE
~@alerte(1,16)
new_pos%=0
RETURN FALSE
ENDIF
ENDIF
new_pos%=old_pos%
RETURN TRUE
ENDFUNC
'
> PROCEDURE close_all_win
FOR i&=0 TO 0
close_win(i&)
NEXT i&
RETURN
> PROCEDURE control
~WIND_UPDATE(1)
~WIND_UPDATE(3)
v_hide_c
RETURN
> PROCEDURE uncontrol
~WIND_UPDATE(2)
~WIND_UPDATE(0)
v_show_c
RETURN
> PROCEDURE form_display(dial&)
~WIND_UPDATE(1)
~WIND_UPDATE(3)
~FORM_CENTER(adtree%(dial&),xd&(dial&),yd&(dial&),wd&(dial&),hd&(dial&))
DEC xd&(dial&)
DEC yd&(dial&)
ADD wd&(dial&),8
ADD hd&(dial&),8
~FORM_DIAL(0,0,0,0,0,xd&(dial&),yd&(dial&),wd&(dial&),hd&(dial&))
~OBJC_DRAW(adtree%(dial&),0,3,screenx&,screeny&,screenl&,screenh&)
RETURN
> PROCEDURE form_clear(dial&)
~WIND_UPDATE(0)
~WIND_UPDATE(2)
~FORM_DIAL(3,0,0,0,0,xd&(dial&),yd&(dial&),wd&(dial&),hd&(dial&))
RETURN
> PROCEDURE delai
~EVNT_TIMER(75)
RETURN
> PROCEDURE flush_clic
LOCAL flush_state&
'
WHILE flush_state&>0
~GRAF_MKSTATE(dammy&,dammy&,flush_state&,dammy&)
WEND
mo_k&=0
mo_c&=0
'
RETURN
> PROCEDURE screen_manager(manage_function&,manage_id&)
INT{m_buf%}=101
INT{ADD(m_buf%,2)}=ap_id&
INT{ADD(m_buf%,4)}=0
INT{ADD(m_buf%,6)}=0
INT{ADD(m_buf%,8)}=CVI("MA")
INT{ADD(m_buf%,10)}=CVI("GX")
INT{ADD(m_buf%,12)}=manage_function&
INT{ADD(m_buf%,14)}=manage_id&
~APPL_WRITE(1,16,m_buf%)
RETURN
'
> FUNCTION window_create(cp_win_recu&)
$F&
'
GCONTRL(0)=100
GCONTRL(1)=5
GCONTRL(2)=1
GCONTRL(3)=0
GCONTRL(4)=0
'
GINTIN(0)=cp_win_recu&
GINTIN(1)=30
GINTIN(2)=30
GINTIN(3)=30
GINTIN(4)=30
'
GEMSYS
'
RETURN GINTOUT(0)
ENDFUNC
> FUNCTION test_cookie(cookie_name$,VAR cookie_valeur%)
$F!
LOCAL read_cook%,nom_cook%,cookie%
'
nom_cook%=CVL(cookie_name$)
cookie%=LPEEK(&H5A0)
cookie_valeur%=0
'
IF cookie%<>0
REPEAT
read_cook%=LPEEK(cookie%)
cookie_valeur%=LPEEK(cookie%+4)
ADD cookie%,8
UNTIL read_cook%=0 OR read_cook%=nom_cook%
IF read_cook%=nom_cook%
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION ev_multi(em_flags&,em_cl&,em_ma&,em_st&,em_ct%,VAR em_mx&,em_my&,em_mk&,em_kbd&,em_key&,em_click&)
$F&
'
INT{ADD(GCONTRL,2)}=16
INT{ADD(GCONTRL,4)}=7
INT{ADD(GCONTRL,6)}=1
INT{ADD(GCONTRL,8)}=0
'
INT{GINTIN}=em_flags&
INT{ADD(GINTIN,2)}=em_cl&
INT{ADD(GINTIN,4)}=em_ma&
INT{ADD(GINTIN,6)}=em_st&
INT{ADD(GINTIN,8)}=0
INT{ADD(GINTIN,10)}=0
INT{ADD(GINTIN,12)}=0
INT{ADD(GINTIN,14)}=0
INT{ADD(GINTIN,16)}=0
INT{ADD(GINTIN,18)}=0
INT{ADD(GINTIN,20)}=0
INT{ADD(GINTIN,22)}=0
INT{ADD(GINTIN,24)}=0
INT{ADD(GINTIN,26)}=0
INT{ADD(GINTIN,28)}=WORD(em_ct%)
INT{ADD(GINTIN,30)}=WORD(SWAP(em_ct%))
'
LONG{ADDRIN}=m_adr%
'
GEMSYS 25
'
em_mx&=INT{ADD(GINTOUT,2)}
em_my&=INT{ADD(GINTOUT,4)}
em_mk&=INT{ADD(GINTOUT,6)}
em_kbd&=INT{ADD(GINTOUT,8)}
em_key&=INT{ADD(GINTOUT,10)}
em_click&=INT{ADD(GINTOUT,12)}
'
RETURN INT{GINTOUT}
ENDFUNC
> FUNCTION s_exist(exist_name$)
$F!
exist_name$=exist_name$+c0$
LOCAL existe&
IF LEN(exist_name$)=0 OR LEFT$(exist_name$)=c0$
RETURN FALSE
ELSE
existe&=GEMDOS(61,L:V:exist_name$,W:0)
IF existe&>0
~GEMDOS(62,W:existe&)
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDIF
ENDFUNC
> FUNCTION remove_c0$(remove_str$)
IF RIGHT$(remove_str$)=c0$
RETURN LEFT$(remove_str$,MAX(0,PRED(LEN(remove_str$))))
ELSE
RETURN remove_str$
ENDIF
ENDFUNC
> FUNCTION alerte(al_type&,alerte&)
$F&
RETURN FORM_ALERT(al_type&,CHAR{OB_SPEC(adtree%(5),alerte&)})
ENDFUNC
> FUNCTION fileselector$(type_msg&,path$,name$)
LOCAL path1$,name1$,choix_file&,retour_file&
LET path1$=path$
LET name1$=name$
retour_file&=@fi_input(type_msg&,path1$,name1$,choix_file&)
IF name1$=c0$ OR name1$=""
choix_file&=0
ENDIF
IF retour_file&=0 OR choix_file&=0
RETURN c0$
ELSE
RETURN LEFT$(path1$,RINSTR(path1$,"\"))+name1$
ENDIF
ENDFUNC
> FUNCTION fi_input(type_msg&,VAR fi_path$,fi_name$,fi_choix&)
$F&
'
~FRE()
~FRE(0)
'
IF GEMDOS(48)<&H1500
type_msg&=0
ENDIF
'
IF type_msg&>0
GCONTRL(0)=91
ELSE
GCONTRL(0)=90
ENDIF
GCONTRL(1)=0
GCONTRL(2)=2
IF type_msg&>0
GCONTRL(3)=3
ELSE
GCONTRL(3)=2
ENDIF
GCONTRL(4)=0
'
fi_path$=fi_path$+SPACE$(300)
fi_name$=fi_name$+SPACE$(100)
'
ADDRIN(0)=V:fi_path$
ADDRIN(1)=V:fi_name$
IF type_msg&>0
ADDRIN(2)=OB_SPEC(adtree%(5),type_msg&)
ENDIF
'
GEMSYS
'
fi_path$=CHAR{V:fi_path$}+c0$
fi_name$=CHAR{V:fi_name$}+c0$
fi_choix&=GINTOUT(1)
'
RETURN GINTOUT(0)
ENDFUNC
> PROCEDURE shl_write(mode&,wisgr&,wiscr&,cmd$,tail$)
'
GCONTRL(0)=121
GCONTRL(1)=3
GCONTRL(2)=1
GCONTRL(3)=2
GCONTRL(4)=0
'
GINTIN(0)=mode&
GINTIN(1)=wisgr&
GINTIN(2)=wiscr&
'
ADDRIN(0)=V:tail$
ADDRIN(1)=V:cmd$
'
GEMSYS
'
RETURN
> PROCEDURE obj_select(arbre&,fils&)
OB_STATE(adtree%(arbre&),fils&)=BSET(OB_STATE(adtree%(arbre&),fils&),0)
RETURN
> PROCEDURE obj_deselect(arbre&,fils&)
OB_STATE(adtree%(arbre&),fils&)=BCLR(OB_STATE(adtree%(arbre&),fils&),0)
RETURN
> FUNCTION tst_selected(arbre&,fils&)
$F!
RETURN BTST(OB_STATE(adtree%(arbre&),fils&),0)
ENDFUNC
> PROCEDURE obj_disable(arbre&,fils&)
OB_STATE(adtree%(arbre&),fils&)=BSET(OB_STATE(adtree%(arbre&),fils&),3)
RETURN
'
> FUNCTION v_opnvwk
$F&
'
INT{ADD(CONTRL,2)}=0
INT{ADD(CONTRL,6)}=11
INT{ADD(CONTRL,12)}=@graf_handle
'
INT{INTIN}=1           ! Num‚ro ID du p‚riph‚rique physique (‚cran)
INT{ADD(INTIN,2)}=1    ! Type de ligne
INT{ADD(INTIN,4)}=1    ! Index de couleur Polyline
INT{ADD(INTIN,6)}=1    ! Type de marqueur
INT{ADD(INTIN,8)}=1    ! Index de couleur Polymarker
INT{ADD(INTIN,10)}=1   ! Fonte de caractŠres
INT{ADD(INTIN,12)}=1   ! Index couleur texte
INT{ADD(INTIN,14)}=1   ! Fill interior Style
INT{ADD(INTIN,16)}=1   ! Fill style index
INT{ADD(INTIN,18)}=1   ! Fill index couleur
INT{ADD(INTIN,20)}=2   ! Flag coordonn‚es NDC ou RC
'
VDISYS 100
'
RETURN INT{ADD(CONTRL,12)}
'
ENDFUNC
> PROCEDURE v_clsvwk
INT{ADD(CONTRL,12)}=vdi_handle&
VDISYS 101,0,0
RETURN
> FUNCTION graf_handle
$F&
'
INT{ADD(GCONTRL,2)}=0
INT{ADD(GCONTRL,4)}=5
LONG{ADD(GCONTRL,6)}=0
'
GEMSYS 77
'
RETURN INT{GINTOUT}
ENDFUNC
> PROCEDURE v_hide_c
INT{ADD(CONTRL,12)}=vdi_handle&
VDISYS 123,0,0
RETURN
> PROCEDURE v_show_c
INT{ADD(CONTRL,12)}=vdi_handle&
INT{INTIN}=1
VDISYS 122,1,0
RETURN
> PROCEDURE get_photo(abr&,menu_box&)
IF buf_photo%
~OBJC_OFFSET(adtree%(abr&),menu_box&,x9&,y9&)
SUB x9&,3
SUB y9&,3
l9&=ADD(OB_W(adtree%(abr&),menu_box&),9)
h9&=ADD(OB_H(adtree%(abr&),menu_box&),9)
IF ADD(x9&,l9&)>ADD(screenx&,screenl&)
l9&=SUB(ADD(screenx&,screenl&),x9&)
ENDIF
IF ADD(y9&,h9&)>ADD(screeny&,screenh&)
h9&=SUB(ADD(screeny&,screenh&),y9&)
ENDIF
'
make_xyarray(x9&,y9&,ADD(x9&,l9&),ADD(y9&,h9&),1,1,l9&,h9&)
'
vro_cpyfm(pscrmfdb%,pdesmfdb%)
'
ENDIF
black_white(abr&,menu_box&,0)
RETURN
> PROCEDURE put_photo(abr&)
IF buf_photo%
'
make_xyarray(1,1,l9&,h9&,x9&,y9&,ADD(x9&,PRED(l9&)),ADD(y9&,PRED(h9&)))
'
vro_cpyfm(pdesmfdb%,pscrmfdb%)
'
ELSE
~FORM_DIAL(3,0,0,0,0,screenx&,screeny&,screenl&,screenh&)
ENDIF
RETURN
> PROCEDURE blitter(x1&,l1&,y1&,y2&,h1&)
'
dummy&=MIN(ADD(x1&,PRED(l1&)),ADD(screenx&,PRED(screenl&)))
'
make_xyarray(x1&,y1&,dummy&,ADD(y1&,PRED(h1&)),x1&,y2&,dummy&,ADD(y2&,PRED(h1&)))
'
vro_cpyfm(pscrmfdb%,pscrmfdb%)
'
RETURN
> PROCEDURE make_zero_mfdb(pmfdb%)
LONG{pmfdb%}=0
LONG{ADD(pmfdb%,4)}=0
LONG{ADD(pmfdb%,8)}=0
LONG{ADD(pmfdb%,12)}=0
LONG{ADD(pmfdb%,16)}=0
RETURN
> PROCEDURE make_xyarray(xq0&,yq0&,xq1&,yq1&,xz0&,yz0&,xz1&,yz1&)
WORD{pxyarray%}=xq0&
WORD{ADD(pxyarray%,2)}=yq0&
WORD{ADD(pxyarray%,4)}=xq1&
WORD{ADD(pxyarray%,6)}=yq1&
WORD{ADD(pxyarray%,8)}=xz0&
WORD{ADD(pxyarray%,10)}=yz0&
WORD{ADD(pxyarray%,12)}=xz1&
WORD{ADD(pxyarray%,14)}=yz1&
RETURN
> PROCEDURE vro_cpyfm(pscr_mfdb%,pdes_mfdb%)
'
v_hide_c
'
INT{ADD(CONTRL,12)}=vdi_handle&
LONG{ADD(CONTRL,14)}=pscr_mfdb%
LONG{ADD(CONTRL,18)}=pdes_mfdb%
INT{INTIN}=3
BMOVE pxyarray%,PTSIN,16
'
VDISYS 109,1,4
'
v_show_c
'
RETURN
'
> PROCEDURE mxfree(mx_adr%)
IF mx_adr%>0
~MFREE(mx_adr%)
ENDIF
RETURN
'
> FUNCTION pci_bios_init
LOCAL pci_cookie_value%,pci_version&
'
DIM pci_rcall%(16)
pci_enabled!=FALSE
'
IF @test_cookie("_PCI",pci_cookie_value%)
pci_version&=INT{ADD(pci_cookie_value%,4)}
IF @test_cookie("XPCI",dummy%)
pci_version&=2
ENDIF
SELECT pci_version&
CASE 0
RETURN &HFFFFF001
CASE 1
'
pci_enabled_1!=TRUE
'
pci_find_pci_device%=LONG{ADD(pci_cookie_value%,8)}
pci_read_config_longword%=LONG{ADD(pci_cookie_value%,24)}
pci_get_machine_id%=LONG{ADD(pci_cookie_value%,156)}
pci_bus_to_virt%=LONG{ADD(pci_cookie_value%,168)}
'
RETURN &H0
CASE 2
'
pci_enabled_2!=TRUE
'
RETURN &H0
DEFAULT
RETURN &HFFFFF000
ENDSELECT
ENDIF
RETURN &HFFFFF001
ENDFUNC
> FUNCTION pci_find_pci_device(pci_id%,pci_index&)
$F%
LOCAL old_stack%,pci_value%
'
IF pci_enabled_2!
'
pci_value%=XBIOS(300,L:pci_id%,W:pci_index&)
'
ELSE IF pci_enabled_1!
old_stack%=GEMDOS(32,L:0)
'
pci_rcall%(0)=pci_id%
pci_rcall%(1)=pci_index&
RCALL pci_find_pci_device%,pci_rcall%()
pci_value%=pci_rcall%(0)
'
~GEMDOS(32,L:old_stack%)
ENDIF
'
RETURN pci_value%
ENDFUNC
> FUNCTION pci_read_config_longword(pci_handle%,pci_reg|,VAR pci_longword%)
$F%
LOCAL old_stack%,pci_value%
'
IF pci_enabled_2!
'
pci_value%=XBIOS(304,L:pci_handle%,W:pci_reg|,L:V:pci_longword%)
'
ELSE IF pci_enabled_1!
old_stack%=GEMDOS(32,L:0)
'
pci_rcall%(0)=pci_handle%
pci_rcall%(1)=pci_reg|
pci_rcall%(8)=V:pci_longword%
RCALL pci_read_config_longword%,pci_rcall%()
pci_value%=pci_rcall%(0)
'
~GEMDOS(32,L:old_stack%)
ENDIF
'
RETURN pci_value%
ENDFUNC
> FUNCTION pci_get_machine_id
$F%
LOCAL old_stack%,pci_value%
'
IF pci_enabled_2!
'
pci_value%=XBIOS(337)
'
ELSE IF pci_enabled_1!
old_stack%=GEMDOS(32,L:0)
'
RCALL pci_get_machine_id%,pci_rcall%()
pci_value%=pci_rcall%(0)
'
~GEMDOS(32,L:old_stack%)
ENDIF
'
RETURN pci_value%
ENDFUNC
> FUNCTION pci_bus_to_virt(pci_handle%,pci_adr%,pci_ptr%)
$F%
LOCAL old_stack%,pci_value%
'
IF pci_enabled_2!
'
pci_value%=XBIOS(340,L:pci_handle%,L:pci_adr%,L:pci_ptr%)
'
ELSE IF pci_enabled_1!
old_stack%=GEMDOS(32,L:0)
'
pci_rcall%(0)=pci_handle%
pci_rcall%(1)=pci_adr%
pci_rcall%(8)=pci_ptr%
RCALL pci_bus_to_virt%,pci_rcall%()
pci_value%=pci_rcall%(0)
'
~GEMDOS(32,L:old_stack%)
ENDIF
'
RETURN pci_value%
ENDFUNC
