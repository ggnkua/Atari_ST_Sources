$M 256000 $S> $F< $P< $%0 $*% $O3 $A2 $E$
'
REM #KEY ColdFire v4e|Classic 68K
REM #IFK 0
REM #BRK MA
REM #EIK 1 ! ColdFire v4e
REM #LIB ColdFire
REM #EXT prx
REM #EIK 2 ! Classic 68K
REM #LIB 68000
REM #EXT prg
REM #FIK
'
IF FATAL
  ~FORM_ALERT(1,"[1][ This version is not suited | for this CPU. Please get | the correct archive. ][ Ok ]")
  @leave
ENDIF
IF ERR=8
  ~FORM_ALERT(1,"[1][ Insuffisant or fragmented | memory ][ Ok ]")
  @leave
ELSE
  init1
  init2
  main
ENDIF
'
> PROCEDURE leave
  @rnd_exit
  @restore_colors
  @close_win
  @gxalloc_main_exit(1)
  @mxfree(palette_save%)
  @mxfree(palette_work%)
  FOR i&=1 TO img_nb_slots&
    IF LONG{img_mfdb%(i&)}>0
      @mxfree(LONG{img_mfdb%(i&)})
    ENDIF
  NEXT i&
  @mxfree(mfdb_structure%)
  IF ressource!
    ~MENU_BAR(ressource_menu%,0)
    ~RSRC_FREE()
  ENDIF
  QUIT
RETURN
'
> PROCEDURE init1
  '
  IF A~I<0 ! appl_init() failed?
    @leave
  ENDIF
  '
  IF _B<8
    ~FORM_ALERT(1,"[1][ Need at least 256 colors ][ Quit ]")
    @leave
  ENDIF
  '
  mx_mask%=@mx_mask
  mxalloc!=(_GEMDOS>=&H19)
  '
  magic!=GETCOOKIE(CVL("MagX"))
  mint!=(_MINT<>0) ! GETCOOKIE(CVL("MiNT"))
  '
  IF magic! OR mint!
    naes!=TRUE
  ELSE IF _AES>=&H399
    naes!=TRUE
  ELSE
    naes!=FALSE
  ENDIF
  '
  multi!=MULTITASK?
  '
  @gxalloc_main_init(1)
  '
  @declare
  @declare_effect
  IF mint!=FALSE
    RESERVE 32000
  ENDIF
  @allocate
  '
  ~RSRC_FREE()
  IF EXIST(ressource_file$)
    IF RSRC_LOAD(ressource_file$)<>0
      ~RSRC_GADDR(0,0,ressource_menu%)
      ressource!=TRUE
    ENDIF
  ENDIF
  '
RETURN
> PROCEDURE declare
  general_path$=CURDIR$
  '
  application_path$=general_path$+"GHOSTS.DAT\"
  '
  ressource_file$=general_path$+"GHOSTS.RSC"
  ressource!=FALSE
  ressource_menu%=0
  '
  ghosts_tile_px&=32
  ghost_new_type|=0
  '
  ghosts_nb_slots&=200
  '
  DIM ghosts_cx&(ghosts_nb_slots&),ghosts_cy&(ghosts_nb_slots&) ! current position
  DIM ghosts_nx&(ghosts_nb_slots&),ghosts_ny&(ghosts_nb_slots&) ! next position
  DIM ghosts_dx&(ghosts_nb_slots&,32),ghosts_dy&(ghosts_nb_slots&,32) ! position
  DIM ghosts_mov&(ghosts_nb_slots&)
  DIM ghosts_dir|(ghosts_nb_slots&) ! direction: 0=north, 1=east, 2=south, 3=west, 4=appearing/disappearing
  DIM ghosts_sta|(ghosts_nb_slots&) ! status: 0=complete, 1->22=mostly plain->nearly invisible
  DIM ghosts_act|(ghosts_nb_slots&) ! action: 0=inactive, 1=active, 2=appearing, 3=disappearing
  DIM ghosts_typ|(ghosts_nb_slots&) ! 0=angry blinky 1=calm blinky, 2=pinky, 3=inky, 4=clyde, 5=sue, 6=funky, 7=spunky
  DIM ghosts_ani|(ghosts_nb_slots&) ! animation (0->5)
  DIM ghosts_lif&(ghosts_nb_slots&) ! lifetime
  DIM ghosts_ord&(ghosts_nb_slots&),ghosts_ory&(ghosts_nb_slots&) ! display order
  '
  DIM ghosts_spd&(8) ! speed (relative to ghosts_typ|)
  '
  ghosts_spd&(0)=4
  ghosts_spd&(1)=3
  ghosts_spd&(2)=2
  ghosts_spd&(3)=2
  ghosts_spd&(4)=2
  ghosts_spd&(5)=3
  ghosts_spd&(6)=1
  ghosts_spd&(7)=1
  '
  DIM ghosts_spr&(8,5)
  '
  ghosts_spr&(0,0)=652
  ghosts_spr&(0,1)=580
  ghosts_spr&(0,2)=604
  ghosts_spr&(0,3)=628
  ghosts_spr&(0,4)=664
  '
  ghosts_spr&(1,0)=640
  ghosts_spr&(1,1)=568
  ghosts_spr&(1,2)=592
  ghosts_spr&(1,3)=616
  ghosts_spr&(1,4)=664
  '
  ghosts_spr&(2,0)=46
  ghosts_spr&(2,1)=10
  ghosts_spr&(2,2)=22
  ghosts_spr&(2,3)=34
  ghosts_spr&(2,4)=58
  '
  ghosts_spr&(3,0)=512
  ghosts_spr&(3,1)=470
  ghosts_spr&(3,2)=482
  ghosts_spr&(3,3)=500
  ghosts_spr&(3,4)=524
  '
  ghosts_spr&(4,0)=138
  ghosts_spr&(4,1)=102
  ghosts_spr&(4,2)=114
  ghosts_spr&(4,3)=126
  ghosts_spr&(4,4)=150
  '
  ghosts_spr&(5,0)=230
  ghosts_spr&(5,1)=194
  ghosts_spr&(5,2)=206
  ghosts_spr&(5,3)=218
  ghosts_spr&(5,4)=242
  '
  ghosts_spr&(6,0)=322
  ghosts_spr&(6,1)=286
  ghosts_spr&(6,2)=298
  ghosts_spr&(6,3)=310
  ghosts_spr&(6,4)=334
  '
  ghosts_spr&(7,0)=414
  ghosts_spr&(7,1)=378
  ghosts_spr&(7,2)=390
  ghosts_spr&(7,3)=402
  ghosts_spr&(7,4)=426
  '
  preferences_file$=general_path$+"VDI_FX.INF"
  '
  DIM boolean$(2)
  boolean$(0)="FALSE"
  boolean$(1)="TRUE"
  '
  hand_win&=0
  xd&=0
  yd&=0
  wd&=0
  hd&=0
  wx&=_DX
  wy&=_DY
  wl&=_DW
  wh&=_DH
  win!=FALSE
  aff!=FALSE
  '
  bitplane_number&=_B
  '
  ' number of slots for images pool
  img_nb_slots&=720
  '
  ' MFDB and coord of the images
  DIM img_mfdb%(img_nb_slots&)
  DIM img_x&(img_nb_slots&),img_y&(img_nb_slots&)
  DIM img_w&(img_nb_slots&),img_h&(img_nb_slots&)
  '
  ' pointer to loaded DGX file (group of DGI) or DGI file if not existing
  dgx_adr%=0
  dgx_buffer_len%=100000
  old_dgx_filename$=""
  '
  ' pixel<->palette index in 16 and 256 color mode
  DIM pixorg_col|(256)
  '
  ' bit organization for true color mode
  DIM bitorg_r|(16),bitorg_g|(16),bitorg_b|(16)
  ' number of red, green, blue for a pixel
  nb_bit_r|=0
  nb_bit_g|=0
  nb_bit_b|=0
  '
  ' 32bit value for palette mode to TC mode transformation
  DIM color(255)
  '
  ' transcodage table for pixel value<->color of the palette
  DIM trans_pal|(255)
  trans_pal|(0)=0
  trans_pal|(1)=2
  trans_pal|(2)=3
  trans_pal|(3)=6
  trans_pal|(4)=4
  trans_pal|(5)=7
  trans_pal|(6)=5
  trans_pal|(7)=8
  trans_pal|(8)=9
  trans_pal|(9)=10
  trans_pal|(10)=11
  trans_pal|(11)=14
  trans_pal|(12)=12
  trans_pal|(13)=15
  trans_pal|(14)=13
  trans_pal|(15)=255
  FOR i&=16 TO 254
    trans_pal|(i&)=i&
  NEXT i&
  trans_pal|(255)=1
  '
RETURN
> PROCEDURE allocate
  '
  palette_save%=@mxalloc(1536,3)
  palette_work%=@mxalloc(1536,3)
  '
  ' pxy array and MFDB strutures
  mfdb_structure%=@mxalloc(SHL(SHR(ADD(MUL(20,SUCC(img_nb_slots&)),31),4),4),3)
  IF mfdb_structure%>0
    FOR i&=0 TO img_nb_slots&
      img_mfdb%(i&)=ADD(ADD(mfdb_structure%,16),MUL(i&,20))
      '
      LONG{img_mfdb%(i&)}=0
      LONG{ADD(img_mfdb%(i&),4)}=0
      LONG{ADD(img_mfdb%(i&),8)}=0
      LONG{ADD(img_mfdb%(i&),12)}=0
      LONG{ADD(img_mfdb%(i&),16)}=0
    NEXT i&
  ELSE
    leave
  ENDIF
  '
  scr_mfdb%=img_mfdb%(0)
  off_mfdb%=img_mfdb%(1)
  del_mfdb%=img_mfdb%(9)
  '
  ~VQ_EXTND(1)
  '
  bitplane_number&=INTOUT(4)
  '
  ' screen structure
  IF GETCOOKIE(CVL("EdDI"))
    '
    DIM work_out&(272)
    '
    ~VQ_SCRNINFO(V:work_out&(0))
    '
    workstation_format&=work_out&(0)
    '
    bitplane_number&=work_out&(2)
    IF bitplane_number&=15
      bitplane_number&=16
      mode_32k!=TRUE
    ELSE
      mode_32k!=FALSE
    ENDIF
    '
    SELECT work_out&(1) ! clut_mode&
    CASE 1 ! palette mode: get pixel index<->palette color
      FOR i&=16 TO 271
        pixorg_col|(SUB(i&,16))=BYTE(work_out&(i&))
      NEXT i&
    CASE 2 ! true color mode: get RGB structure for the pixel
      nb_bit_r|=BYTE(work_out&(8))
      nb_bit_g|=BYTE(work_out&(9))
      nb_bit_b|=BYTE(work_out&(10))
      FOR i&=1 TO nb_bit_r|
        bitorg_r|(i&)=BYTE(SUB(bitplane_number&,work_out&(ADD(15,i&))))
      NEXT i&
      FOR i&=1 TO nb_bit_g|
        bitorg_g|(i&)=BYTE(SUB(bitplane_number&,work_out&(ADD(31,i&))))
      NEXT i&
      FOR i&=1 TO nb_bit_b|
        bitorg_b|(i&)=BYTE(SUB(bitplane_number&,work_out&(ADD(47,i&))))
      NEXT i&
    ENDSELECT
  ENDIF
  '
  IF bitplane_number&=8
    raster_mask_mode&=2
    raster_mask_color_0&=0
    raster_mask_color_1&=1
    '
    raster_sprite_mode&=7
  ELSE
    raster_mask_mode&=2
    raster_mask_color_0&=0
    raster_mask_color_1&=1
    '
    raster_sprite_mode&=1
  ENDIF
  '
RETURN
> PROCEDURE init2
  '
  ~VSF_INTERIOR(1)
  ~VSF_STYLE(0)
  ~VSF_COLOR(1)
  ~VSF_PERIMETER(0)
  '
  IF ressource!
    ~MENU_IENABLE(ressource_menu%,3,0)
    ~MENU_BAR(ressource_menu%,1)
  ENDIF
  IF multi!=FALSE
    ~FORM_DIAL(3,0,0,0,0,_DX,_DY,_DW,_DH)
  ENDIF
  '
RETURN
'
> PROCEDURE declare_effect
  LOCAL pref_len%
  '
  IF EXIST(preferences_file$)
    '
    mem_pos%=0
    '
    file_handle&=FOPEN(preferences_file$,0)
    IF file_handle&>0
      '
      pref_len%=FSEEK(0,file_handle&,2)
      ~FSEEK(0,file_handle&,0)
      '
      IF pref_len%>0
        mem_pos%=@mem_init(pref_len%)
        '
        IF mem_pos%>0
          IF FREAD(file_handle&,pref_len%,mem_pos%)<>pref_len%
            mem_pos%=@mem_close
          ENDIF
        ENDIF
      ENDIF
      ~FCLOSE(file_handle&)
    ENDIF
    '
    IF mem_pos%>0
      '
      mem_start_ptr%=mem_pos%
      mem_end_ptr%=ADD(mem_pos%,pref_len%)
      DO
        IF BYTE{mem_start_ptr%}=13 OR BYTE{mem_start_ptr%}=10
          BYTE{mem_start_ptr%}=0
        ENDIF
        INC mem_start_ptr%
      LOOP UNTIL mem_start_ptr%>mem_end_ptr%
      mem_start_ptr%=mem_pos%
      '
      ghosts_delay&=MAX(0,MIN(VAL(@mem_find$("GHOSTS_DELAY")),200))
      ghosts_num&=MAX(7,MIN(VAL(@mem_find$("GHOSTS_NUMBER")),ghosts_nb_slots&))
      '
    ENDIF
    '
    ~@mem_close
    '
  ELSE
    '
    ghosts_delay&=1
    ghosts_num&=7
    '
  ENDIF
RETURN
'
> FUNCTION mem_init(mem_wished_len%)
  $F%
  ~@mem_close
  mem_len%=MAX(16000,SHL(SHR(ADD(mem_wished_len%,31),4),4))
  mem_start_adr%=@mxalloc(mem_len%,3)
  IF mem_start_adr%<0
    ' alert ?
    mem_start_adr%=0
  ENDIF
  RETURN mem_start_adr%
ENDFUNC
> FUNCTION mem_close
  $F%
  IF mem_start_adr%>0
    @mxfree(mem_start_adr%)
    mem_start_adr%=0
    mem_len%=0
  ENDIF
  RETURN 0
ENDFUNC
> FUNCTION mem_find$(mem_key$)
  LOCAL mem_find_line$,mem_find_ptr%
  IF mem_start_ptr%>0 AND mem_end_ptr%>mem_start_ptr%
    mem_find_ptr%=mem_start_ptr%
    DO
      mem_find_line$=CHAR{mem_find_ptr%}
      ADD mem_find_ptr%,SUCC(LEN(mem_find_line$))
      '
      IF INSTR(mem_find_line$,mem_key$+"=")=1
        mem_str$=MID$(mem_find_line$,ADD(LEN(mem_key$),2))
        mem_pos&=INSTR(mem_str$,"#")
        IF mem_pos&>0
          RETURN TRIM$(LEFT$(mem_str$,PRED(mem_pos&)))
        ENDIF
        RETURN TRIM$(mem_str$)
      ENDIF
      '
    LOOP UNTIL mem_find_ptr%>=mem_end_ptr%
  ENDIF
  RETURN ""
ENDFUNC
> FUNCTION mem_get_flag(find_str$,default_flag!)
  $F%
  '
  IF @mem_find$(find_str$)=boolean$(ABS(NOT default_flag!))
    RETURN NOT default_flag!
  ELSE
    RETURN default_flag!
  ENDIF
ENDFUNC
'
> PROCEDURE load_images
  LOCAL catalog_filename$,catalog_adr%,catalog_ptr%,catalog_handle&,catalog_len%
  '
  IF EXIST(application_path$+"BLINKY.DGX")=FALSE
    ~FORM_ALERT(1,"[1][ Need GHOSTS.DAT\*.DGX files ][ Quit ]")
    @leave
  ENDIF
  '
  ~@gxalloc_init(1)
  '
  catalog_filename$=application_path$+"SPRITES.IDX"+c0$
  '
  ~FRE(0)
  '
  catalog_handle&=GEMDOS(61,L:V:catalog_filename$,W:0)
  IF catalog_handle&>0
    '
    mouse_busy
    '
    catalog_len%=GEMDOS(66,L:0,W:catalog_handle&,W:2)
    ~GEMDOS(66,L:0,W:catalog_handle&,W:0)
    catalog_adr%=@mxalloc(ADD(catalog_len%,16),3)
    IF catalog_adr%>0
      IF GEMDOS(63,W:catalog_handle&,L:catalog_len%,L:catalog_adr%)=catalog_len%
        '
        DIV catalog_len%,56
        DEC catalog_len%
        '
        catalog_ptr%=catalog_adr%
        catalog_i&=0
        DO
          img_id&=INT{catalog_ptr%}
          '
          IF img_id&>0 AND img_id&<SUCC(img_nb_slots&)
            '
            img_x&(img_id&)=INT{ADD(catalog_ptr%,2)}
            img_y&(img_id&)=INT{ADD(catalog_ptr%,4)}
            img_w&(img_id&)=INT{ADD(catalog_ptr%,6)}
            img_h&(img_id&)=INT{ADD(catalog_ptr%,8)}
            '
            img_x&(9)=MAX(img_x&(9),img_x&(img_id&))
            img_y&(9)=MAX(img_y&(9),img_y&(img_id&))
            img_w&(9)=MAX(img_w&(9),img_w&(img_id&))
            img_h&(9)=MAX(img_h&(9),img_h&(img_id&))
            '
            img_mask!=(INT{ADD(catalog_ptr%,10)}=1)
            '
            img_name$=CHAR{ADD(catalog_ptr%,12)}
            '
            IF LEFT$(img_name$)="@"
              BMOVE img_mfdb%(VAL(MID$(img_name$,2))),img_mfdb%(img_id&),20
            ELSE IF LEN(img_name$)>0
              ~@load_image(img_id&,img_name$,img_mask!)
            ENDIF
          ENDIF
          '
          ADD catalog_ptr%,56
          INC catalog_i&
        LOOP UNTIL catalog_i&>catalog_len%
        '
        @gxalloc_shrink(1,1024)
        '
      ELSE
        leave
      ENDIF
      @mxfree(catalog_adr%)
    ELSE
      leave
    ENDIF
    ~GEMDOS(62,W:catalog_handle&)
    '
    mouse_free
  ELSE
    leave
  ENDIF
  '
  @mxfree(dgx_adr%)
  dgx_adr%=0
  dgx_filename_old$=""
  '
RETURN
> FUNCTION load_image(pimg_id&,pimg_name$,pimg_mask!)
  $F%
  LOCAL file_adr%,mfdb_adr%,dummy_adr%,dummy_size%
  ~FRE(0)
  '
  good!=FALSE
  '
  pimg_name$=application_path$+pimg_name$+".DGI"
  '
  file_adr%=@load_dgx(pimg_name$)
  IF file_adr%>0
    IF (INT{ADD(file_adr%,12)}=8 OR INT{ADD(file_adr%,12)}=1) AND MKL$(LONG{file_adr%})="_DGI"
      LONG{file_adr%}=ADD(file_adr%,20)
      '
      IF pimg_mask!
        '
        dummy_size%=MUL(MUL(INT{ADD(file_adr%,6)},INT{ADD(file_adr%,8)}),2)
        '
        mfdb_adr%=img_mfdb%(pimg_id&)
        LONG{mfdb_adr%}=@gxalloc(1,ADD(dummy_size%,16))
        INT{ADD(mfdb_adr%,4)}=INT{ADD(file_adr%,4)}
        INT{ADD(mfdb_adr%,6)}=INT{ADD(file_adr%,6)}
        INT{ADD(mfdb_adr%,8)}=INT{ADD(file_adr%,8)}
        INT{ADD(mfdb_adr%,10)}=0
        INT{ADD(mfdb_adr%,12)}=1
        INT{ADD(mfdb_adr%,14)}=0
        INT{ADD(mfdb_adr%,16)}=0
        INT{ADD(mfdb_adr%,18)}=0
        '
        BMOVE ADD(file_adr%,20),LONG{mfdb_adr%},dummy_size%
        good!=TRUE
        '
      ELSE
        '
        mfdb_adr%=img_mfdb%(pimg_id&)
        LONG{mfdb_adr%}=@gxalloc(1,ADD(MUL(MUL(INT{ADD(file_adr%,6)},INT{ADD(file_adr%,8)}),SHL&(bitplane_number&,1)),16))
        INT{ADD(mfdb_adr%,4)}=INT{ADD(file_adr%,4)}
        INT{ADD(mfdb_adr%,6)}=INT{ADD(file_adr%,6)}
        INT{ADD(mfdb_adr%,8)}=INT{ADD(file_adr%,8)}
        INT{ADD(mfdb_adr%,10)}=0
        IF mode_32k!
          INT{ADD(mfdb_adr%,12)}=15
        ELSE
          INT{ADD(mfdb_adr%,12)}=bitplane_number&
        ENDIF
        INT{ADD(mfdb_adr%,14)}=0
        INT{ADD(mfdb_adr%,16)}=0
        INT{ADD(mfdb_adr%,18)}=0
        '
        SELECT bitplane_number&
        CASE 8
          ~VR_TRNFM(file_adr%,mfdb_adr%)
          good!=TRUE
        CASE 15,16
          dummy_size%=SHL&(MUL(INT{ADD(file_adr%,6)},INT{ADD(file_adr%,8)}),1)
          ADD file_adr%,20
          dummy_cale%=SUB(ADD(file_adr%,dummy_size%),2)
          ktrans%=LONG{mfdb_adr%}
          FOR itrans%=file_adr% TO dummy_cale% STEP 2
            '
            trns_0&=INT{itrans%}
            trns_1&=INT{ADD(itrans%,dummy_size%)}
            trns_2&=INT{ADD(itrans%,MUL(dummy_size%,2))}
            trns_3&=INT{ADD(itrans%,MUL(dummy_size%,3))}
            trns_4&=INT{ADD(itrans%,MUL(dummy_size%,4))}
            trns_5&=INT{ADD(itrans%,MUL(dummy_size%,5))}
            trns_6&=INT{ADD(itrans%,MUL(dummy_size%,6))}
            trns_7&=INT{ADD(itrans%,MUL(dummy_size%,7))}
            '
            FOR jtrans&=1 TO 16
              '
              trns_8&=SHR&(trns_0&,15)
              ADD trns_8&,SHL&(SHR&(trns_1&,15),1)
              ADD trns_8&,SHL&(SHR&(trns_2&,15),2)
              ADD trns_8&,SHL&(SHR&(trns_3&,15),3)
              ADD trns_8&,SHL&(SHR&(trns_4&,15),4)
              ADD trns_8&,SHL&(SHR&(trns_5&,15),5)
              ADD trns_8&,SHL&(SHR&(trns_6&,15),6)
              ADD trns_8&,SHL&(SHR&(trns_7&,15),7)
              '
              trns_0&=SHL&(trns_0&,1)
              trns_1&=SHL&(trns_1&,1)
              trns_2&=SHL&(trns_2&,1)
              trns_3&=SHL&(trns_3&,1)
              trns_4&=SHL&(trns_4&,1)
              trns_5&=SHL&(trns_5&,1)
              trns_6&=SHL&(trns_6&,1)
              trns_7&=SHL&(trns_7&,1)
              '
              INT{ktrans%}=CARD(color(trans_pal|(trns_8&)))
              ADD ktrans%,2
              '
            NEXT jtrans&
          NEXT itrans%
          SUB file_adr%,20
          good!=TRUE
        CASE 24
          dummy_size%=SHL&(MUL(INT{ADD(file_adr%,6)},INT{ADD(file_adr%,8)}),1)
          ADD file_adr%,20
          dummy_cale%=SUB(ADD(file_adr%,dummy_size%),2)
          ktrans%=LONG{mfdb_adr%}
          FOR itrans%=file_adr% TO dummy_cale% STEP 2
            '
            trns_0&=INT{itrans%}
            trns_1&=INT{ADD(itrans%,dummy_size%)}
            trns_2&=INT{ADD(itrans%,MUL(dummy_size%,2))}
            trns_3&=INT{ADD(itrans%,MUL(dummy_size%,3))}
            trns_4&=INT{ADD(itrans%,MUL(dummy_size%,4))}
            trns_5&=INT{ADD(itrans%,MUL(dummy_size%,5))}
            trns_6&=INT{ADD(itrans%,MUL(dummy_size%,6))}
            trns_7&=INT{ADD(itrans%,MUL(dummy_size%,7))}
            '
            FOR jtrans&=1 TO 16
              '
              trns_8&=SHR&(trns_0&,15)
              ADD trns_8&,SHL&(SHR&(trns_1&,15),1)
              ADD trns_8&,SHL&(SHR&(trns_2&,15),2)
              ADD trns_8&,SHL&(SHR&(trns_3&,15),3)
              ADD trns_8&,SHL&(SHR&(trns_4&,15),4)
              ADD trns_8&,SHL&(SHR&(trns_5&,15),5)
              ADD trns_8&,SHL&(SHR&(trns_6&,15),6)
              ADD trns_8&,SHL&(SHR&(trns_7&,15),7)
              '
              trns_0&=SHL&(trns_0&,1)
              trns_1&=SHL&(trns_1&,1)
              trns_2&=SHL&(trns_2&,1)
              trns_3&=SHL&(trns_3&,1)
              trns_4&=SHL&(trns_4&,1)
              trns_5&=SHL&(trns_5&,1)
              trns_6&=SHL&(trns_6&,1)
              trns_7&=SHL&(trns_7&,1)
              '
              dummy%=color(trans_pal|(trns_8&))
              BYTE{ktrans%}=BYTE(SHR(dummy%,15))
              INC ktrans%
              BYTE{ktrans%}=BYTE(SHR(dummy%,7))
              INC ktrans%
              BYTE{ktrans%}=BYTE(dummy%)
              INC ktrans%
              '
            NEXT jtrans&
          NEXT itrans%
          SUB file_adr%,20
          good!=TRUE
        CASE 32
          dummy_size%=SHL&(MUL(INT{ADD(file_adr%,6)},INT{ADD(file_adr%,8)}),1)
          ADD file_adr%,20
          dummy_cale%=SUB(ADD(file_adr%,dummy_size%),2)
          ktrans%=LONG{mfdb_adr%}
          FOR itrans%=file_adr% TO dummy_cale% STEP 2
            '
            trns_0&=INT{itrans%}
            trns_1&=INT{ADD(itrans%,dummy_size%)}
            trns_2&=INT{ADD(itrans%,MUL(dummy_size%,2))}
            trns_3&=INT{ADD(itrans%,MUL(dummy_size%,3))}
            trns_4&=INT{ADD(itrans%,MUL(dummy_size%,4))}
            trns_5&=INT{ADD(itrans%,MUL(dummy_size%,5))}
            trns_6&=INT{ADD(itrans%,MUL(dummy_size%,6))}
            trns_7&=INT{ADD(itrans%,MUL(dummy_size%,7))}
            '
            FOR jtrans&=1 TO 16
              '
              trns_8&=SHR&(trns_0&,15)
              ADD trns_8&,SHL&(SHR&(trns_1&,15),1)
              ADD trns_8&,SHL&(SHR&(trns_2&,15),2)
              ADD trns_8&,SHL&(SHR&(trns_3&,15),3)
              ADD trns_8&,SHL&(SHR&(trns_4&,15),4)
              ADD trns_8&,SHL&(SHR&(trns_5&,15),5)
              ADD trns_8&,SHL&(SHR&(trns_6&,15),6)
              ADD trns_8&,SHL&(SHR&(trns_7&,15),7)
              '
              trns_0&=SHL&(trns_0&,1)
              trns_1&=SHL&(trns_1&,1)
              trns_2&=SHL&(trns_2&,1)
              trns_3&=SHL&(trns_3&,1)
              trns_4&=SHL&(trns_4&,1)
              trns_5&=SHL&(trns_5&,1)
              trns_6&=SHL&(trns_6&,1)
              trns_7&=SHL&(trns_7&,1)
              '
              LONG{ktrans%}=color(trans_pal|(trns_8&))
              ADD ktrans%,4
              '
            NEXT jtrans&
          NEXT itrans%
          SUB file_adr%,20
          good!=TRUE
        ENDSELECT
      ENDIF
    ENDIF
  ENDIF
  '
  RETURN good!
ENDFUNC
> FUNCTION load_dgx(pdgx_name$)
  $F%
  LOCAL dgx_handle&,dgx_len%,dgx_filename$,dgx_pos&
  ~FRE(0)
  dgx_ptr%=0
  '
  dgx_pos&=RINSTR(pdgx_name$,"\")
  dgx_filename$=LEFT$(pdgx_name$,PRED(dgx_pos&))+".DGX"
  dgi_filename$=MID$(pdgx_name$,SUCC(dgx_pos&))
  dgi_filename$=LEFT$(dgi_filename$,PRED(INSTR(dgi_filename$,".")))
  IF LEN(dgi_filename$)<8
    dgi_filename$=dgi_filename$+SPACE$(MAX(SUB(8,LEN(dgi_filename$))))
  ENDIF
  '
  IF EXIST(dgx_filename$)
    IF dgx_filename$=old_dgx_filename$
      dgx_ptr%=@search_into_dgx(dgi_filename$)
    ENDIF
    '
    IF dgx_ptr%=0
      '
      dgx_handle&=FOPEN(dgx_filename$,0)
      IF dgx_handle&>0
        dgx_len%=FSEEK(0,dgx_handle&,2)
        ~FSEEK(0,dgx_handle&,0)
        IF dgx_buffer_len%<SHL(SHR(ADD(dgx_len%,32),4),4)
          @mxfree(dgx_adr%)
          dgx_adr%=0
          dgx_buffer_len%=SHL(SHR(ADD(dgx_len%,32),4),4)
        ENDIF
        IF dgx_adr%<1
          dgx_adr%=@mxalloc(dgx_buffer_len%,3)
        ENDIF
        IF dgx_adr%>0
          ~FREAD(dgx_handle&,dgx_len%,dgx_adr%)
          '
          old_dgx_filename$=dgx_filename$
          dgx_ptr%=@search_into_dgx(dgi_filename$)
          '
        ENDIF
        ~FCLOSE(dgx_handle&)
      ENDIF
      '
    ENDIF
  ELSE
    '
    @mxfree(dgx_adr%)
    dgx_adr%=0
    '
    dgx_handle&=FOPEN(pdgx_name$,0)
    IF dgx_handle&>0
      dgx_len%=FSEEK(0,dgx_handle&,2)
      ~FSEEK(0,dgx_handle&,0)
      IF dgx_buffer_len%<SHL(SHR(ADD(dgx_len%,32),4),4)
        @mxfree(dgx_adr%)
        dgx_adr%=0
        dgx_buffer_len%=SHL(SHR(ADD(dgx_len%,32),4),4)
      ENDIF
      IF dgx_adr%<1
        dgx_adr%=@mxalloc(dgx_buffer_len%,3)
      ENDIF
      IF dgx_adr%>0
        ~FREAD(dgx_handle&,dgx_len%,dgx_adr%)
        '
        dgx_ptr%=dgx_adr%
        '
      ENDIF
      ~FCLOSE(dgx_handle&)
    ENDIF
  ENDIF
  '
  RETURN dgx_ptr%
ENDFUNC
> FUNCTION search_into_dgx(pdgi_name$)
  $F%
  LOCAL sdgx_ptr%,sdgx_name$,sdgx_len&,sdgx_cpt&
  sdgx_adr%=0
  sdgx_cpt&=0
  '
  IF dgx_adr%>0
    IF MKL$(LONG{dgx_adr%})="_DGX"
      sdgx_len&=INT{ADD(dgx_adr%,4)}
      IF sdgx_len&>0
        sdgx_ptr%=ADD(dgx_adr%,6)
        DO
          sdgx_name$=MKL$(LONG{sdgx_ptr%})+MKL$(LONG{ADD(sdgx_ptr%,4)})
          IF sdgx_name$=pdgi_name$
            sdgx_adr%=ADD(dgx_adr%,LONG{ADD(sdgx_ptr%,8)})
            sdgx_cpt&=sdgx_len&
          ENDIF
          INC sdgx_cpt&
          ADD sdgx_ptr%,12
        LOOP UNTIL sdgx_cpt&>=sdgx_len&
      ENDIF
    ENDIF
  ENDIF
  '
  RETURN sdgx_adr%
ENDFUNC
> PROCEDURE load_palette
  LOCAL filename_palette$,file_handle&
  '
  filename_palette$=application_path$+"COLORS.P08"+c0$
  '
  IF EXIST(filename_palette$) AND (palette_work%>0)
    file_handle&=FOPEN(filename_palette$,0)
    IF file_handle&>0
      ~FSEEK(12,file_handle&,0)
      IF FREAD(file_handle&,1536,palette_work%)=1536
        '
        IF _B>8
          FOR itrans&=0 TO 255
            r&=INT{ADD(palette_work%,MUL(itrans&,6))}
            g&=INT{ADD(ADD(palette_work%,2),MUL(itrans&,6))}
            b&=INT{ADD(ADD(palette_work%,4),MUL(itrans&,6))}
            r|=BYTE((r&/1000)*255)
            g|=BYTE((g&/1000)*255)
            b|=BYTE((b&/1000)*255)
            LET color(itrans&)=@trns_pix(r|,g|,b|)
          NEXT itrans&
        ENDIF
      ENDIF
      ~FCLOSE(file_handle&)
    ENDIF
  ELSE
    ~FORM_ALERT(1,"[1][ Need COLORS.P08 file ][ Quit ]")
    leave
  ENDIF
  '
RETURN
'
> PROCEDURE main
  @set_values1
  @create_win
  @v_hide_c
  @clear_win
  @set_values2
  exit!=FALSE
  DO
    @draw_win
  LOOP UNTIL exit!
  @v_show_c
  @leave
RETURN
'
> PROCEDURE create_win
  hand_win&=WIND_CREATE(&X0,30,30,30,30)
  IF hand_win&>0
    wx&=_DX
    wy&=_DY
    wl&=_DW
    wh&=_DH
    win!=TRUE
    IF WIND_OPEN(hand_win&,wx&,wy&,wl&,wh&)=0
      ~FORM_ALERT(1,"[1][ Can't open window ][ Quit ]")
      @leave
    ELSE
      ~WIND_GET(hand_win&,4,xd&,yd&,wd&,hd&)
    ENDIF
  ELSE
    ~FORM_ALERT(1,"[1][ No window available ][ Quit ]")
    @leave
  ENDIF
  aff!=win!
RETURN
> PROCEDURE set_values1
  '
  @rnd_init
  @save_colors
  @load_palette
  @load_images
  @set_colors
  '
RETURN
> PROCEDURE set_values2
  '
  ' screen
  '
  img_x&(0)=xd&
  img_y&(0)=yd&
  img_w&(0)=wd&
  img_h&(0)=hd&
  '
  ' offscreen
  '
  img_x&(1)=0
  img_y&(1)=0
  img_w&(1)=wd&
  img_h&(1)=hd&
  '
  LONG{off_mfdb%}=@mxalloc(ADD(MUL(MUL(img_h&(1),SHR&(ADD(img_w&(1),15),4)),SHL&(bitplane_number&,1)),16),3)
  IF LONG{off_mfdb%}>0
    INT{ADD(off_mfdb%,4)}=img_w&(1)
    INT{ADD(off_mfdb%,6)}=img_h&(1)
    INT{ADD(off_mfdb%,8)}=SHR&(ADD(img_w&(1),15),4)
    INT{ADD(off_mfdb%,10)}=0
    IF mode_32k!
      INT{ADD(off_mfdb%,12)}=15
    ELSE
      INT{ADD(off_mfdb%,12)}=bitplane_number&
    ENDIF
    INT{ADD(off_mfdb%,14)}=0
    INT{ADD(off_mfdb%,16)}=0
    INT{ADD(off_mfdb%,18)}=0
    '
    @offscreen_make
  ELSE
    leave
  ENDIF
  '
  ' ghosts eraser
  '
  LONG{del_mfdb%}=@mxalloc(ADD(MUL(MUL(img_h&(9),SHR&(ADD(img_w&(9),15),4)),SHL&(bitplane_number&,1)),16),3)
  IF LONG{del_mfdb%}>0
    INT{ADD(del_mfdb%,4)}=img_w&(9)
    INT{ADD(del_mfdb%,6)}=img_h&(9)
    INT{ADD(del_mfdb%,8)}=SHR&(ADD(img_w&(9),15),4)
    INT{ADD(del_mfdb%,10)}=0
    IF mode_32k!
      INT{ADD(del_mfdb%,12)}=15
    ELSE
      INT{ADD(del_mfdb%,12)}=bitplane_number&
    ENDIF
    INT{ADD(del_mfdb%,14)}=0
    INT{ADD(del_mfdb%,16)}=0
    INT{ADD(del_mfdb%,18)}=0
    '
    @sprite_gum_make
  ELSE
    leave
  ENDIF
  '
  @ghosts_ini
  '
RETURN
> PROCEDURE close_win
  IF win!
    ~WIND_CLOSE(hand_win&)
    ~WIND_DELETE(hand_win&)
    win!=FALSE
    aff!=FALSE
  ENDIF
RETURN
> PROCEDURE clear_win
  ~VSF_COLOR(1)
  ~VS_CLIP(1,xd&,yd&,ADD(xd&,PRED(wd&)),ADD(yd&,PRED(hd&)))
  ~V_BAR(xd&,yd&,ADD(xd&,PRED(wd&)),ADD(yd&,PRED(hd&)))
  ~VS_CLIP(0,xd&,yd&,ADD(xd&,PRED(wd&)),ADD(yd&,PRED(hd&)))
RETURN
> PROCEDURE draw_win
  '
  @ghosts_add
  @ghosts_move
  @ghosts_animate
  @ghosts_display
  '
  @screen_display
  '
  @ghosts_gum
  '
  IF ghosts_delay&>0
    ~EVNT_TIMER(ghosts_delay&)
  ENDIF
  '
  ~GRAF_MKSTATE(gm_x&,gm_y&,gm_s&,gk_s&)
  IF BCONSTAT(2) OR gm_s&>0 OR gk_s&>0
    exit!=TRUE
  ENDIF
  '
RETURN
'
> PROCEDURE ghosts_ini
  FOR g&=0 TO PRED(ghosts_num&)
    ghosts_act|(g&)=0
  NEXT g&
  ghost_new_type|=0
RETURN
> PROCEDURE ghosts_add
  FOR g&=0 TO PRED(ghosts_num&)
    IF ghosts_act|(g&)=0
      '
      ghosts_cx&(g&)=MAX(ghosts_tile_px&,MIN(@rnd_get(img_w&(1)),SUB(img_w&(1),ghosts_tile_px&)))
      ghosts_cy&(g&)=MAX(MUL(ghosts_tile_px&,2),MIN(@rnd_get(img_h&(1)),SUB(img_h&(1),ghosts_tile_px&)))
      '
      ghosts_dir|(g&)=MAX(0,MIN(@rnd_get(4),3))
      '
      ghosts_nx&(g&)=ghosts_cx&(g&)
      ghosts_ny&(g&)=ghosts_cy&(g&)
      ghosts_mov&(g&)=0
      ghosts_dx&(g&,0)=0
      ghosts_dy&(g&,0)=0
      '
      ghosts_typ|(g&)=ghost_new_type|
      ghosts_act|(g&)=2
      ghosts_sta|(g&)=22
      ghosts_lif&(g&)=MAX(10,@rnd_get(50))
      '
      ghosts_ani|(g&)=MAX(0,MIN(@rnd_get(6),5))
      '
      INC ghost_new_type|
      IF ghost_new_type|>7
        ghost_new_type|=MAX(0,MIN(@rnd_get(2),1))
      ENDIF
    ENDIF
  NEXT g&
RETURN
> PROCEDURE ghosts_move
  '
  FOR g&=0 TO PRED(ghosts_num&)
    IF ghosts_act|(g&)=1
      IF ghosts_mov&(g&)<1
        '
        DEC ghosts_lif&(g&)
        IF ghosts_lif&(g&)<1
          ghosts_act|(g&)=3
        ENDIF
        '
        ghosts_cx&(g&)=ghosts_nx&(g&)
        ghosts_cy&(g&)=ghosts_ny&(g&)
        '
        IF ghosts_act|(g&)=1
          '
          @ghosts_new_dir(g&)
          '
          ghosts_mov&(g&)=MIN(ghosts_tile_px&/MAX(1,ghosts_spd&(ghosts_typ|(g&))),32)
          '
          SELECT ghosts_dir|(g&)
          CASE 0
            FOR i&=0 TO ghosts_mov&(g&)
              ghosts_dx&(g&,i&)=0
              ghosts_dy&(g&,i&)=-(ghosts_tile_px&*(SUB(ghosts_mov&(g&),i&))/ghosts_mov&(g&))
            NEXT i&
          CASE 1
            FOR i&=0 TO ghosts_mov&(g&)
              ghosts_dx&(g&,i&)=(ghosts_tile_px&*(SUB(ghosts_mov&(g&),i&))/ghosts_mov&(g&))
              ghosts_dy&(g&,i&)=0
            NEXT i&
          CASE 2
            FOR i&=0 TO ghosts_mov&(g&)
              ghosts_dx&(g&,i&)=0
              ghosts_dy&(g&,i&)=(ghosts_tile_px&*(SUB(ghosts_mov&(g&),i&))/ghosts_mov&(g&))
            NEXT i&
          CASE 3
            FOR i&=0 TO ghosts_mov&(g&)
              ghosts_dx&(g&,i&)=-(ghosts_tile_px&*(SUB(ghosts_mov&(g&),i&))/ghosts_mov&(g&))
              ghosts_dy&(g&,i&)=0
            NEXT i&
          ENDSELECT
        ENDIF
      ELSE
        '
        DEC ghosts_mov&(g&)
        '
      ENDIF
    ENDIF
  NEXT g&
  '
RETURN
> PROCEDURE ghosts_new_dir(g_n&)
  LOCAL ghost_new_dir|
  '
  ghost_new_dir|=ghosts_dir|(g_n&)
  '
  SELECT ghosts_dir|(g_n&)
  CASE 0
    IF ghosts_cy&(g_n&)<MUL(ghosts_tile_px&,2) OR @rnd_get(10)>7
      DO
        ghost_new_dir|=MAX(0,MIN(@rnd_get(3),3))
      LOOP UNTIL ghost_new_dir|<>0
    ENDIF
  CASE 1
    IF ghosts_cx&(g_n&)>SUB(img_w&(1),ghosts_tile_px&) OR @rnd_get(10)>7
      DO
        ghost_new_dir|=MAX(0,MIN(@rnd_get(3),3))
      LOOP UNTIL ghost_new_dir|<>1
    ENDIF
  CASE 2
    IF ghosts_cy&(g_n&)>SUB(img_h&(1),ghosts_tile_px&) OR @rnd_get(10)>7
      DO
        ghost_new_dir|=MAX(0,MIN(@rnd_get(3),3))
      LOOP UNTIL ghost_new_dir|<>2
    ENDIF
  CASE 3
    IF ghosts_cx&(g_n&)<ghosts_tile_px& OR @rnd_get(10)>7
      DO
        ghost_new_dir|=MAX(0,MIN(@rnd_get(3),3))
      LOOP UNTIL ghost_new_dir|<>3
    ENDIF
  ENDSELECT
  '
  ghosts_dir|(g_n&)=ghost_new_dir|
  '
  SELECT ghosts_dir|(g_n&)
  CASE 0
    IF ghosts_cy&(g_n&)<-ghosts_tile_px&
      ADD ghosts_cy&(g_n&),ADD(img_h&(1),ghosts_tile_px&)
    ENDIF
  CASE 1
    IF ghosts_cx&(g_n&)>ADD(img_w&(1),ghosts_tile_px&)
      SUB ghosts_cx&(g_n&),ADD(img_w&(1),ghosts_tile_px&)
    ENDIF
  CASE 2
    IF ghosts_cy&(g_n&)>ADD(img_h&(1),ghosts_tile_px&)
      SUB ghosts_cy&(g_n&),ADD(img_h&(1),ghosts_tile_px&)
    ENDIF
  CASE 3
    IF ghosts_cx&(g_n&)<-ghosts_tile_px&
      ADD ghosts_cx&(g_n&),ADD(img_w&(1),ghosts_tile_px&)
    ENDIF
  ENDSELECT
  '
  SELECT ghosts_dir|(g_n&)
  CASE 0
    ghosts_nx&(g_n&)=ghosts_cx&(g_n&)
    ghosts_ny&(g_n&)=SUB(ghosts_cy&(g_n&),ghosts_tile_px&)
  CASE 1
    ghosts_nx&(g_n&)=ADD(ghosts_cx&(g_n&),ghosts_tile_px&)
    ghosts_ny&(g_n&)=ghosts_cy&(g_n&)
  CASE 2
    ghosts_nx&(g_n&)=ghosts_cx&(g_n&)
    ghosts_ny&(g_n&)=ADD(ghosts_cy&(g_n&),ghosts_tile_px&)
  CASE 3
    ghosts_nx&(g_n&)=SUB(ghosts_cx&(g_n&),ghosts_tile_px&)
    ghosts_ny&(g_n&)=ghosts_cy&(g_n&)
  ENDSELECT
  '
RETURN
> PROCEDURE ghosts_animate
  LOCAL ghost_new_act|
  '
  FOR g&=0 TO PRED(ghosts_num&)
    ghost_new_act|=ghosts_act|(g&)
    '
    SELECT ghosts_act|(g&)
    CASE 1 ! moving
      INC ghosts_ani|(g&)
      IF ghosts_ani|(g&)>5
        ghosts_ani|(g&)=0
      ENDIF
    CASE 2 ! appearing
      DEC ghosts_sta|(g&)
      IF ghosts_sta|(g&)=0
        ghost_new_act|=1
        '
        ghosts_nx&(g&)=ghosts_cx&(g&)
        ghosts_ny&(g&)=ghosts_cy&(g&)
        ghosts_mov&(g&)=0
        ghosts_dx&(g&,0)=0
        ghosts_dy&(g&,0)=0
      ENDIF
    CASE 3 ! disappearing
      INC ghosts_sta|(g&)
      IF ghosts_sta|(g&)>22
        ghost_new_act|=0
        '
        ghosts_nx&(g&)=ghosts_cx&(g&)
        ghosts_ny&(g&)=ghosts_cy&(g&)
        ghosts_mov&(g&)=0
        ghosts_dx&(g&,0)=0
        ghosts_dy&(g&,0)=0
      ENDIF
    ENDSELECT
    '
    ghosts_act|(g&)=ghost_new_act|
  NEXT g&
RETURN
> PROCEDURE ghosts_display
  LOCAL ghost_spr&
  '
  IF @ghosts_sort_for_display
    FOR g&=0 TO ghosts_ord_n&
      h&=ghosts_ord&(g&)
      IF h&>=0
        IF ghosts_act|(h&)>0
          ghost_spr&=0
          '
          SELECT ghosts_act|(h&)
          CASE 1
            ghost_spr&=ADD(ghosts_spr&(ghosts_typ|(h&),ghosts_dir|(h&)),MUL(ghosts_ani|(h&),2))
          CASE 2,3
            ghost_spr&=ADD(ghosts_spr&(ghosts_typ|(h&),4),MUL(PRED(ghosts_sta|(h&)),2))
          ENDSELECT
          '
          @sprite_put(ghost_spr&,ADD(ghosts_cx&(h&),ghosts_dx&(h&,ghosts_mov&(h&))),ADD(ghosts_cy&(h&),ghosts_dy&(h&,ghosts_mov&(h&))))
        ENDIF
      ENDIF
    NEXT g&
  ENDIF
  '
RETURN
> PROCEDURE ghosts_gum
  FOR g&=0 TO PRED(ghosts_num&)
    IF ghosts_act|(g&)>0
      @sprite_gum(ADD(ghosts_cx&(g&),ghosts_dx&(g&,ghosts_mov&(g&))),ADD(ghosts_cy&(g&),ghosts_dy&(g&,ghosts_mov&(g&))))
    ENDIF
  NEXT g&
RETURN
> FUNCTION ghosts_sort_for_display
  $F%
  LOCAL ghost_ord&
  '
  ghosts_ord_n&=0
  '
  FOR g&=0 TO PRED(ghosts_num&)
    ghosts_ord&(g&)=-1
    ghosts_ory&(g&)=-1
  NEXT g&
  '
  FOR g&=0 TO PRED(ghosts_num&)
    IF ghosts_act|(g&)>0
      IF g&=0
        INSERT ghosts_ord&(g&)=g&
        INSERT ghosts_ory&(g&)=ghosts_cy&(g&)
      ELSE
        ghost_ord&=@ghosts_sort_by_ordinate(ghosts_cy&(g&))
        INSERT ghosts_ord&(ghost_ord&)=g&
        INSERT ghosts_ory&(ghost_ord&)=ghosts_cy&(g&)
      ENDIF
      INC ghosts_ord_n&
    ENDIF
  NEXT g&
  '
  RETURN (ghosts_ord_n&>0)
ENDFUNC
> FUNCTION ghosts_sort_by_ordinate(ghost_ord_y&)
  $F%
  LOCAL ghost_ins&,ghost_end!
  '
  IF ghosts_ord_n&=0
    RETURN 0
  ENDIF
  '
  ghost_ins&=0
  ghost_end!=FALSE
  '
  WHILE ghost_ins&<ghosts_ord_n& AND ghost_end!=FALSE
    IF ghosts_ory&(ghost_ins&)<ghost_ord_y&
      INC ghost_ins&
    ELSE
      ghost_end!=TRUE
    ENDIF
  WEND
  '
  RETURN MAX(0,MIN(ghost_ins&,ghosts_ord_n&))
ENDFUNC
'
> PROCEDURE restore_colors
  LOCAL tmp_c&,tmp_d&,col_r&,col_g&,col_b&
  '
  IF palette_save%>0 AND _B=8
    FOR tmp_c&=0 TO 255
      tmp_d&=MUL(tmp_c&,6)
      col_r&=INT{ADD(palette_save%,tmp_d&)}
      col_g&=INT{ADD(palette_save%,ADD(tmp_d&,2))}
      col_b&=INT{ADD(palette_save%,ADD(tmp_d&,4))}
      ~VS_COLOR(tmp_c&,col_r&,col_g&,col_b&)
    NEXT tmp_c&
  ENDIF
RETURN
> PROCEDURE save_colors
  LOCAL tmp_c&,tmp_d&,col_r&,col_g&,col_b&
  '
  IF palette_save%>0 AND _B=8
    FOR tmp_c&=0 TO 255
      ~VQ_COLOR(tmp_c&,0,col_r&,col_g&,col_b&)
      tmp_d&=MUL(tmp_c&,6)
      INT{ADD(palette_save%,tmp_d&)}=col_r&
      INT{ADD(palette_save%,ADD(tmp_d&,2))}=col_g&
      INT{ADD(palette_save%,ADD(tmp_d&,4))}=col_b&
    NEXT tmp_c&
  ENDIF
RETURN
> PROCEDURE set_colors
  LOCAL tmp_c&,tmp_d&,col_r&,col_g&,col_b&
  '
  IF palette_work%>0 AND _B=8
    FOR tmp_c&=0 TO 255
      tmp_d&=MUL(tmp_c&,6)
      col_r&=INT{ADD(palette_work%,tmp_d&)}
      col_g&=INT{ADD(palette_work%,ADD(tmp_d&,2))}
      col_b&=INT{ADD(palette_work%,ADD(tmp_d&,4))}
      ~VS_COLOR(tmp_c&,col_r&,col_g&,col_b&)
    NEXT tmp_c&
  ENDIF
RETURN
'
> PROCEDURE mouse_busy
  ~GRAF_MOUSE(2,0)
RETURN
> PROCEDURE mouse_free
  ~GRAF_MOUSE(0,0)
RETURN
'
> PROCEDURE sprite_put(pspr_id&,pimg_x&,pimg_y&)
  LOCAL opx&,opy&,opdx&,opdy&,opw&,oph&
  '
  IF pspr_id&>0
    '
    opx&=SUB(pimg_x&,img_x&(pspr_id&))
    opy&=SUB(pimg_y&,img_y&(pspr_id&))
    opdx&=0
    opdy&=0
    opw&=img_w&(pspr_id&)
    oph&=img_h&(pspr_id&)
    '
    IF opx&<0
      ADD opw&,opx&
      opdx&=ABS(opx&)
      opx&=0
    ENDIF
    IF ADD(opx&,opw&)>img_w&(1)
      opw&=SUB(img_w&(1),opx&)
    ELSE IF ADD(opx&,opw&)<0
      opw&=0
    ENDIF
    IF opy&<0
      ADD oph&,opy&
      opdy&=ABS(opy&)
      opy&=0
    ENDIF
    IF ADD(opy&,oph&)>img_h&(1)
      oph&=SUB(img_h&(1),opy&)
    ELSE IF ADD(opy&,oph&)<0
      oph&=0
    ENDIF
    '
    opw&=MIN(opw&,img_w&(1))
    oph&=MIN(oph&,img_h&(1))
    '
    IF opw&>0 AND oph&>0
      '
      SET.SXYWH opdx&,opdy&,opw&,oph&
      SET.DXYWH opx&,opy&,opw&,oph&
      '
      ~VRT_CPYFM(raster_mask_mode&,img_mfdb%(SUCC(pspr_id&)),off_mfdb%,raster_mask_color_0&,raster_mask_color_1&)
      ~VRO_CPYFM(raster_sprite_mode&,img_mfdb%(pspr_id&),off_mfdb%)
    ENDIF
  ENDIF
RETURN
> PROCEDURE sprite_gum(pimg_x&,pimg_y&)
  LOCAL opx&,opy&,opdx&,opdy&,opw&,oph&
  '
  opx&=SUB(pimg_x&,img_x&(9))
  opy&=SUB(pimg_y&,img_y&(9))
  opdx&=0
  opdy&=0
  opw&=img_w&(9)
  oph&=img_h&(9)
  '
  IF opx&<0
    ADD opw&,opx&
    opdx&=ABS(opx&)
    opx&=0
  ENDIF
  IF ADD(opx&,opw&)>img_w&(1)
    opw&=SUB(img_w&(1),opx&)
  ELSE IF ADD(opx&,opw&)<0
    opw&=0
  ENDIF
  IF opy&<0
    ADD oph&,opy&
    opdy&=ABS(opy&)
    opy&=0
  ENDIF
  IF ADD(opy&,oph&)>img_h&(1)
    oph&=SUB(img_h&(1),opy&)
  ELSE IF ADD(opy&,oph&)<0
    oph&=0
  ENDIF
  '
  opw&=MIN(opw&,img_w&(1))
  oph&=MIN(oph&,img_h&(1))
  '
  IF opw&>0 AND oph&>0
    '
    SET.SXYWH opdx&,opdy&,opw&,oph&
    SET.DXYWH opx&,opy&,opw&,oph&
    '
    ~VRO_CPYFM(3,del_mfdb%,off_mfdb%)
  ENDIF
RETURN
> PROCEDURE screen_display
  SET.SXYWH 0,0,img_w&(1),img_h&(1)
  SET.DXYWH img_x&(0),img_y&(0),img_w&(1),img_h&(1)
  ~VRO_CPYFM(3,off_mfdb%,scr_mfdb%)
RETURN
> PROCEDURE offscreen_make
  SET.SXYWH img_x&(0),img_y&(0),img_w&(1),img_h&(1)
  SET.DXYWH 0,0,img_w&(1),img_h&(1)
  ~VRO_CPYFM(3,scr_mfdb%,off_mfdb%)
RETURN
> PROCEDURE sprite_gum_make
  SET.SXYWH img_x&(0),img_y&(0),img_w&(9),img_h&(9)
  SET.DXYWH 0,0,img_w&(9),img_h&(9)
  ~VRO_CPYFM(3,scr_mfdb%,del_mfdb%)
RETURN
> FUNCTION trns_pix(trns_r|,trns_g|,trns_b|)
  $F%
  LOCAL trns_r$,trns_g$,trns_b$,trns_dummy$
  ~FRE()
  ~FRE(0)
  '
  trns_dummy$=STRING$(bitplane_number&,"0")
  '
  trns_r$=LEFT$(BIN$(trns_r|,8),nb_bit_r|)
  FOR trns_i|=1 TO nb_bit_r|
    MID$(trns_dummy$,bitorg_r|(trns_i|))=MID$(trns_r$,SUB(SUCC(nb_bit_r|),trns_i|),1)
  NEXT trns_i|
  '
  trns_g$=LEFT$(BIN$(trns_g|,8),nb_bit_g|)
  FOR trns_i|=1 TO nb_bit_g|
    MID$(trns_dummy$,bitorg_g|(trns_i|))=MID$(trns_g$,SUB(SUCC(nb_bit_g|),trns_i|),1)
  NEXT trns_i|
  '
  trns_b$=LEFT$(BIN$(trns_b|,8),nb_bit_b|)
  FOR trns_i|=1 TO nb_bit_b|
    MID$(trns_dummy$,bitorg_b|(trns_i|))=MID$(trns_b$,SUB(SUCC(nb_bit_b|),trns_i|),1)
  NEXT trns_i|
  '
  RETURN VAL("&X"+trns_dummy$)
ENDFUNC
'
> PROCEDURE rnd_init
  LOCAL rnd_ptr%,rnd_end%
  '
  @mxfree(rnd_mem%)
  '
  rnd_mem%=MAX(0,@mxalloc(256,3))
  IF rnd_mem%>0
    '
    rnd_ptr%=rnd_mem%
    rnd_end%=ADD(rnd_mem%,256)
    WHILE rnd_ptr%<rnd_end%
      BYTE{rnd_ptr%}=MAX(0,MIN(RAND(256) AND &HFF,255))
      INC rnd_ptr%
    WEND
    '
    rnd_deb|=0
  ENDIF
RETURN
> PROCEDURE rnd_exit
  @mxfree(rnd_mem%)
RETURN
> FUNCTION rnd_get(rnd_max&)
  $F%
  LOCAL rnd_val|
  '
  IF rnd_mem%>0
    INC rnd_deb|
    IF rnd_deb|>255
      rnd_deb|=0
    ENDIF
    rnd_val|=BYTE{ADD(rnd_mem%,rnd_deb|)}
    rnd_val|=BYTE{ADD(rnd_mem%,rnd_val|)}
    rnd_val|=BYTE{ADD(rnd_mem%,rnd_val|)}
  ELSE
    rnd_val|=MAX(0,MIN(RAND(256) AND &HFF,255))
  ENDIF
  '
  RETURN SHR(MUL(rnd_max&,rnd_val|),8)
ENDFUNC
'
> PROCEDURE v_hide_c
  IF naes!
    GHIDEM
  ELSE
    ~V_HIDE_C()
  ENDIF
RETURN
> PROCEDURE v_show_c
  IF naes!
    GSHOWM
  ELSE
    ~V_SHOW_C()
  ENDIF
RETURN
'
> FUNCTION mx_mask
  $F%
  IF MXALLOC(-1,0)=-32
    RETURN 0
  ELSE IF SYSCONF(-1)=-32
    RETURN 3
  ELSE
    RETURN -1
  ENDIF
ENDFUNC
> FUNCTION mxalloc(mxlen%,mxmode&)
  $F%
  IF mxalloc!
    RETURN MXALLOC(mxlen%,mxmode&)
  ENDIF
  RETURN MALLOC(mxlen%)
ENDFUNC
> PROCEDURE mxfree(mx_adr%)
  IF mx_adr%>0
    ~MFREE(mx_adr%)
  ENDIF
RETURN
'
> PROCEDURE gxalloc_main_init(gx_n&)
  LOCAL gx_i&
  '
  gxblk_max&=128
  '
  DIM gxblk%(gx_n&,PRED(gxblk_max&))
  DIM gxblk_count&(gx_n&),gxblk_mode&(gx_n&)
  DIM last_gxadr%(gx_n&),last_gxlen%(gx_n&)
  DIM gxalloc!(gx_n&),gxblk_size%(gx_n&),gxblk_len%(gx_n&,PRED(gxblk_max&))
  '
  FOR gx_i&=0 TO gx_n&
    gxblk_size%(gx_i&)=16000
    gxblk_mode&(gx_i&)=0
  NEXT gx_i&
  '
RETURN
> PROCEDURE gxalloc_main_exit(gx_n&)
  LOCAL gx_i&
  '
  FOR gx_i&=0 TO gx_n&
    ~@gxalloc_exit(gx_i&)
  NEXT gx_i&
  '
  ERASE gxblk%()
  ERASE gxblk_count&()
  ERASE last_gxadr%(),last_gxlen%()
  ERASE gxalloc!(),gxblk_size%(),gxblk_len%()
  ERASE garbage%()
  ERASE garbage%(),garbage_maxline&(),garbage_nbline&()
  '
RETURN
> FUNCTION gxalloc_init(gx_n&)
  $F%
  LOCAL ig&
  ~FRE(0)
  '
  IF NOT gxalloc!(gx_n&)
    FOR ig&=0 TO PRED(gxblk_max&)
      gxblk%(gx_n&,ig&)=0
    NEXT ig&
    '
    SELECT gx_n&
    CASE 1 ! gfx
      gxblk_size%(1)=24000*_B
      gxblk_mode&(1)=3 ! TT-RAM preferred
    CASE 2 ! sounds
      ' gxblk_size%(2)=256000
      ' IF mint!
      ' gxblk_mode&(2)=32 ! ST-RAM only and global mode access ! Raj (20121103)
      ' ELSE
      ' gxblk_mode&(2)=0 ! ST-RAM only
      ' ENDIF
    CASE 3 ! datas
      ' gxblk_size%(3)=16000
      ' gxblk_mode&(3)=3 ! TT-RAM preferred
    ENDSELECT
    '
    gxblk_count&(gx_n&)=0
    last_gxadr%(gx_n&)=0
    last_gxlen%(gx_n&)=0
    '
    gxblk%(gx_n&,0)=@mxalloc(ADD(gxblk_size%(gx_n&),32),gxblk_mode&(gx_n&))
    IF gxblk%(gx_n&,0)>0
      last_gxadr%(gx_n&)=gxblk%(gx_n&,0)
      last_gxlen%(gx_n&)=gxblk_size%(gx_n&)
      gxalloc!(gx_n&)=TRUE
      RETURN 0
    ENDIF
    RETURN gxblk%(gx_n&,0)
  ENDIF
  RETURN -1
ENDFUNC
> FUNCTION gxalloc_exit(gx_n&)
  $F%
  LOCAL ig&,free%
  '
  IF gx_n&=1
    job_list_adr%=0
    console_header_adr%=0
    console_nb_line&=0
  ENDIF
  '
  IF gxalloc!(gx_n&)
    gxalloc!(gx_n&)=FALSE
    FOR ig&=0 TO gxblk_count&(gx_n&)
      IF gxblk%(gx_n&,ig&)>0
        @mxfree(gxblk%(gx_n&,ig&))
        free%=0
        gxblk_len%(gx_n&,ig&)=0
        gxblk%(gx_n&,ig&)=0
        IF free%<>0
          ~FORM_ALERT(1,"[1][ gxalloc: can't free memory block ][ Ok ]")
        ENDIF
      ENDIF
    NEXT ig&
    RETURN 0
  ENDIF
  RETURN -1
ENDFUNC
> FUNCTION gxalloc(gx_n&,wanted_size%)
  $F%
  '
  wanted_size%=ADD(wanted_size%,3) AND -4
  wanted_size%=MAX(4,wanted_size%)
  '
  IF wanted_size%>0
    IF wanted_size%=<gxblk_size%(gx_n&)
      IF SUB(last_gxlen%(gx_n&),wanted_size%)<0
        @gxalloc_shrink(gx_n&,last_gxlen%(gx_n&))
        temp_adr%=@gxalloc_new(gx_n&)
        IF temp_adr%=0
          new_gxadr%=last_gxadr%(gx_n&)
          ADD last_gxadr%(gx_n&),wanted_size%
          SUB last_gxlen%(gx_n&),wanted_size%
          RETURN new_gxadr%
        ENDIF
        RETURN temp_adr%
      ELSE
        new_gxadr%=last_gxadr%(gx_n&)
        ADD last_gxadr%(gx_n&),wanted_size%
        SUB last_gxlen%(gx_n&),wanted_size%
        RETURN new_gxadr%
      ENDIF
    ENDIF
  ENDIF
  ~FORM_ALERT(1,"[1][ gxalloc: negative or oversize| length for a memory block ][ Ok ]")
  RETURN -70
ENDFUNC
> FUNCTION gxalloc_new(gx_n&)
  $F%
  INC gxblk_count&(gx_n&)
  IF gxblk_count&(gx_n&)<gxblk_max&
    gxblk%(gx_n&,gxblk_count&(gx_n&))=@mxalloc(ADD(gxblk_size%(gx_n&),32),gxblk_mode&(gx_n&))
    IF gxblk%(gx_n&,gxblk_count&(gx_n&))>0
      last_gxadr%(gx_n&)=gxblk%(gx_n&,gxblk_count&(gx_n&))
      last_gxlen%(gx_n&)=gxblk_size%(gx_n&)
      RETURN 0
    ELSE
      ~FORM_ALERT(1,"[1][ gxalloc: can't allocate a memory block ][ Ok ]")
    ENDIF
    DEC gxblk_count&(gx_n&)
    RETURN gxblk%(gx_n&,SUCC(gxblk_count&(gx_n&)))
  ENDIF
  ~FORM_ALERT(1,"[1][| gxalloc: all available blocks are allocated ][ Ok ]")
  RETURN -74
ENDFUNC
> PROCEDURE gxalloc_shrink(gx_n&,free_size%)
  IF free_size%>4
    gxblk_len%(gx_n&,gxblk_count&(gx_n&))=SUB(gxblk_size%(gx_n&),SUB(free_size%,4))
    last_gxlen%(gx_n&)=0
    ~GEMDOS(74,W:0,L:gxblk%(gx_n&,gxblk_count&(gx_n&)),L:gxblk_len%(gx_n&,gxblk_count&(gx_n&)))
  ENDIF
RETURN
> FUNCTION gxalloc_get_total(gx_n&)
  $F%
  LOCAL gx_amount%,gx_j&
  '
  gx_amount%=0
  FOR gx_j&=0 TO gxblk_count&(gx_n&)
    IF gxblk_len%(gx_n&,gx_j&)=0
      ADD gx_amount%,gxblk_size%(gx_n&)
    ELSE
      ADD gx_amount%,gxblk_len%(gx_n&,gx_j&)
    ENDIF
  NEXT gx_j&
  '
  RETURN gx_amount%
ENDFUNC
