@database "CRESUS"
@options "+g -i -s +z -t2 -d12"
@author "Pierre TONTHAT"
@$VER: 1.2I
@subject "Cr‚sus documentation"

@node "cresus_start"
@title "Cr‚sus documentation"

@image CRESUS.IMG 1











          @{"Presentation" LINK "cresus_presentation"}
          @{"Legal" LINK "cresus_legal"}

          @{"Installation and requirements " LINK "cresus_install"}
          @{"Preferences" LINK "cresus_preferences"}
          @{"Keyboard shortcuts" LINK "cresus_key_shortcuts"}

        @{0U}Tutorial :@{0}
          @{"Database creation" LINK "cresus_creation"}
          @{"Utils" LINK "cresus_utils"}
          @{"Backup" LINK "cresus_backup"}

          @{"Limitations" LINK "cresus_bogues"}
          @{"History" LINK "cresus_versions"}

          @{"Greetings" LINK "cresus_merci"}

          @{"Dev-doc" LINK "cresus_dev"}



@endnode

@node "cresus_presentation"
@title "Cr‚sus documentation"
@{0U}                                                           Presentation@{0}

    Cr‚sus is a bank accounts manager. It can help you to follow
    your money transactions, and to be less spendthrift. You can
    create several accounts, in one or more banks, with several
    account holders and in the correct currency.

    This program features for your convenience:
    ú a modern interface, with vector fonts
    ú colourization of types, categories and amounts
    ú use of a second currency for currency exchanges and money conversions
    ú automatic transactions (jobs)
    ú a calendar (double-click on date fields)
    ú etc
@image RENAISSA.IMG 50

    This program is provided by Renaissance, was
    coded with GFA Basic by Rajah Lone, with the
    help of Daroou.

@endnode


@node "cresus_legal"
@title "Cr‚sus documentation"
@{0U}                                                                  Legal@{0}

    Cr‚sus is freeware.
    
    It is strongly advised to make frequent backups, and to always check
    Cr‚sus' datas against your bank(s) datas'.

    As always, we deny any responsibility concerning any errors, bugs
    or limitations of the program on your personal data, and on
    your computer. We try hard to seek out errors and to correct them.

@endnode
   
@node "cresus_install"
@title "Cr‚sus documentation"
@{0U}                                          Installation and requirements@{0}

    @{0U}Required:@{0}

    ú 2 MB RAM or more (TT-RAM is used if present)
    ú a hard disk is strongly advised
    ú NVDI or other modern VDI is advised

    @{0U}Installation:@{0}

    > If you already use Cr‚sus then replace only the PRG and RSC files. Add
      the BUB and HYP files in the same path.
      In Cr‚sus, set the path and filename for the ST-Guide and save
      the options (there was a bad variable name in the old config file).

    Otherwise:

    > Unpack the archive to the location of your choice.

    > Copy the CRES_ICN.RSC in the GOODIES folder to your desktop to use
      as the program icon and then delete the GOODIES folder and its contents.

    > Please set or verify that the environment variable $HOME is present
      in your system. For example, in MAGX.INF:

      #_ENV HOME=C:\GEMSYS\HOME

    > Launch Cr‚sus, go to Options and set the paths, fonts, display,
      miscellaneous settings ... and save them.

      You can see one of the example accounts, with the password "atari".

      You can remove the example accounts by deleting the entries in the
      different tables in this order: accounts, types, holders and banks.
      It is advised to keep the currencies table.

      To make Cr‚sus run faster first quit Cr‚sus, and then delete all the
      files in the ACCOUNTS folder. Then delete all the files, except for the
      CURRENCY.CDB, from the SHARED folder.

    > Relaunch Cr‚sus, and customize it to your needs.

      Create in this order: currency (if deleted), bank(s), holder(s),
      account(s), and types. You can then add transactions after this.

    > To use help bubbles and/or documentation under Cr‚sus, you may have
      to install ST-Guide and/or BubbleGEM. These programs need environment
      variables, such as in MAGX.INF:

      #_ENV BUBBLEGEM=C:\GEMSYS\BUBBLE\BUBBLE.APP
      #_ENV STGUIDE=C:\ST-GUIDE.ACX

    > To archive, the program needs a GEM library called DEFLATE.LDG,
      and the LDGM cookie to find it.

      Download DEFLATE.ZIP and put the files in:

      C:\AUTO\LDG.PRG (or your AUTO folder)
      C:\GEMSYS\LDG\DEFLATE.LDG (or your LDG folder)

@endnode

@node "cresus_preferences"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    ú @{"Paths" LINK "cresus_pref_path"}
    ú @{"Date and hour" LINK "cresus_pref_clock"}
    ú @{"Fonts" LINK "cresus_pref_font"}
    ú @{"Display" LINK "cresus_pref_display"}
    ú @{"Misc" LINK "cresus_pref_misc"}

@endnode

@node "cresus_pref_path"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    @{0U}Hypertext@{0}
      Path and filename of Cr‚sus' ST-Guide documentation.

    @{0U}Shared files@{0}
      The path leads to the SHARED folder, where are located
      JOB.CDB, CURRENCY.CDB, BANK.CDB, ACCOUNT.CDB,
      PEOPLE.CDB, STREAM.CDB, BUDGET.CDB, etc.

    @{0U}Accounts files@{0}
      The path leads to the ACCOUNTS folder, where are located
      the accounts files *.CDB.

    @{0U}Backup folder@{0}
      With the menu (File -> Backup) or the shortcut Control+B, the most
      important files (*.CDB) are zipped by a utility located in the
      HELPERS folder.
      *.ZIP files corresponding to the backups will be put in this
      folder.

    @{0U}Filters group files@{0}
      The path leads to the FILTERS folder, where are located
      the accounts files *.CDF.

@endnode

@node "cresus_pref_clock"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    @{0U}Today is...@{0}
      Today's date is suggested by default when adding a new transaction.
      You can set it there if it is wrong.

      A double click in every date field opens a calendar.

    @{0U}Set at every launch:@{0}
      If your computer does not keep the time when off, you can
      tell Cr‚sus to ask for and set the date and time at every launch.

@endnode

@node "cresus_pref_font"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    You can use vector fonts (NVDI required) or monospaced fonts
    (minimum GDOS needed) instead of the system font.

    You can set the height of the font which will be used in all
    the Cr‚sus tables.

@endnode

@node "cresus_pref_display"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    The dialog is divided into several parts which concern the general
    display, and the display of the table fields in the windows.

    Please note, for the transactions table, that the 'reverse order'
    (last transactions are on top) is active only after the next launch of
    the program. This option needs a good computer (entire memory
    blocks are moved).

@endnode

@node "cresus_pref_misc"
@title "Cr‚sus documentation"
@{0U}                                                            Preferences@{0}

    Here are listed some options that modify the behavior of the
    program.

    @{0U}Open the last edited account at launch@{0}
      The account you were manipulating last will be automatically
      opened at the next program launch.

    @{0U}Don't close window when adding transactions@{0}
      Permits the adding of several transactions one after the other.

    @{0U}Save configuration when quitting@{0}
      All options, window positions and settings will be automatically
      saved when Cr‚sus is exited.

    @{0U}Print with GDOS or compatible method@{0} (ie NVDI)
      The program will use quality printing instead of sending characters
      direclty to the printer (GEMDOS mode).
      The paper format can be A4 (european) or Letter (american).

    @{0U}Alert if remaining memory becomes rare@{0}
      The program will survey the remaining RAM amount and will display
      an alert if this free RAM is not enough to work securely

@endnode

@node "cresus_key_shortcuts"
@title "Cr‚sus documentation"
@{0U}                                                      Keybord shortcuts@{0}

  @{0U}Everywhere@{0}

    Control+I: program information / operations modifications if selected
    Control+Q: quit
    Control+U: close the top window

    if an edit window is not on top:

    Control+S: save the alterations
    Control+B: backup the database
    Control+J: jobs window
    Control+F: transaction search window

    Help: open the ST-Guide documentation

    F1: currencies table
    F2: banks table
    F3: holders table
    F4: accounts table
    F5: types table
    F6: categories table
    F7: transactions table

  @{0U}In a table window@{0}

    Control+W: toggles window size
    Insert: add a record
    Control+Del: delete the selected record
    ClrHome: go to the first record
    Shift+ClrHome: go to the last record
    Arrow up or down: scroll record per record
    Shift+arrow up or down: scroll page per page

  @{0U}In the transaction editor window@{0}

    Control+Return: add or modify the transaction
    Control+P: swap the checked flag true or false
    Control+(F1 to F10): select the type (1st to 10th in the types table)
    Shift+Control+(F1 to F10): select the target account (1st to 10th)
    Alternate+(F1 to F10): select the category (F1 for nothing, 1st to 9th)
    Shift+Alernate+(F1 to F10): select the next categories (10th to 19th)

@endnode

@node "cresus_creation"
@title "Cr‚sus documentation"
@{0U}                                                      Database creation@{0}

    A Cr‚sus databse is a set of tables, corresponding to *.CDB files.

    In the "Tables" menu:
    - the currencies
    - the banks
    - the holders
    - the accounts
    - the types of transactions
    - the categories
    - the transactions

    There's a hierarchy between the tables. The items of one table can
    be created only if at least one item in a parent table exists.
    Therefore, you must create in order : one or more currencies, one
    or more banks, the holders, the accounts, the types and categories,
    and after this, you will be able to add/modify transactions.

    Every table corresponds to a window. Click the '+' button to add
    a new item. Click the '?' button to modify or delete or see more
    informations of an item. The items can be sorted in the table :
    if on top, the item will be found quickly. A correct and witty
    ordering can speed up the display of the transactions table.

    @{0U}1) The currencies@{0}

      The first created currency must be the reference. The next currencies
      should be declared with a conversion rate, related to the reference.

      Si the currency has not a fix conversion rate, click on the 'float'
      button. The conversion rate will be asked/confirmed when opening
      a transaction table that uses this currency.

      The reference currency must be created;

    @{0U}2) The banks@{0}

      Please indicate the informations corresponding to the bank.
      At least one bank must be created.

    @{0U}3) The holders@{0}

      Indicate the people that will hold one or more accounts.
      At lest one holder must be created.

    @{0U}4) The accounts@{0}

      You must have created at least one currency, one bank et one holder
      to create a bank account.

      It is possible to have an account with double currencies, one main
      and one second: you can set the amount of a transaction with the
      first or the second currency. All will be computed with the conversion
      rate.

      Option: an alert can be display if the balance of the account is lesser
      than a critical value.

      A filename is needed: a file containing all the transactions of this
      account will be managed and stored in the ACCOUNTS folder, instead of
      the SHARED one.

    @{0U}5) The types of transactions@{0}

      Indicate of debt (negativate in the account) or credit (positivate
      in the account).
      The color is used in the transactions table display, to get more
      convenient the reading.

      If the type is a check emission, the programm will show a special
      field for the check number, and will automaticaly present the new
      number if a new check is made.

      If the type is an acount to account transfer, the program will give
      the possibility to indicate the target account, to write
      automaticaly the inverse transaction.
      Please select also the new type after the transfer
      (ie debtor movement -> creditor movement)

      @{0B}Carefull:@{0} the transactions from account to account are
      after totaly independant. Modifying the one does not modify
      automaticaly the other.

    @{0U}6) The categories@{0}

      This item is used to group the transactions for statistics and/or
      graphics in the future.
      The color is used in the transactions display window.

    @{0U}7) The transactions@{0}

      The date, type and amount are needed to insert a new transaction.
      The category and notes are not needed but advised.

      The checking corresponds to the fact the real bank has registered
      the transaction. Checking transactions makes closer the both
      balances.

      The transaction table permits some more manipulations than in the
      others tables:
      - multiple selection (with shift key)
      - multiple checking or un-checking
      - delete without opening the transaction details window
      - if multiple selection, the transaction details window show '' and
      '' buttons to swap between the selected transactions.
      - the balance display
      - the transactions table load and automatic save, when choosing the
      account.

@endnode

@node "cresus_utils"
@title "Cr‚sus documentation"
@{0U}                                                                  Utils@{0}

    @{0U}1) Filters@{0}

      Some filters can be created and modified, deleted, enabled and
      disabled.
      To activate the filtering, click on the '' button. The transactions
      that do not correspond to the criterias will be displayed in light
      writing. The balance of the none-rejected transactions will be
      showed in the bottom of the filters window.

      You can, as exemple, obtain the total amount of the transactions for
      a studied category, between some dates...

      Tip: select all the transactions, when the filtering is active, select
      only the none-rejected transactions.

      Carefull: you cannot add/modify the filters when the filtering is
      active.

      The whole set of filters can be saved in a file, and reloaded after.

    @{0U}2) Jobs@{0}

      The automatic transactions are created in the jobs, with some options
      such as manual confirmation before writing, desactivation or
      delete after writing, the repetition...

      Tip: the creation of a new job is made with the features of the job
      that was selected before.

    @{0U}3) Search@{0}

      The search is done on the transactions of the opened account, with
      the criterias you have indicated. The found transaction will be
      selected. The next found transaction does not deselect the old one.

@endnode

@node "cresus_backup"
@title "Cr‚sus documentation"
@{0U}                                                              Archivage@{0}

    The program uses for now GEM dynamic library called DEFLATE.LDG
    with the LDG system. The 'LDGM' must be present in the cookie jar.
    DEFLATE.LDG must be in the current LDG folder.

    You must have committed (ie saved to files) the modifications.

    The backup file is a *.ZIP file with day-date in its name.

@endnode

@node "cresus_bogues"
@title "Cr‚sus documentation"
@{0U}                                                   Bugs and limitations@{0}

  ú Deflate Error when archiving if not enough memory. Needs about
    800KB free. If not enough you should zip the files manually in
    the folders ACCOUNTS, SHARED and FILTERS

  Please report any bugs you may find to ptonthat@club-internet.fr

@endnode

@node "cresus_versions"
@title "Cr‚sus documentation"
@{0U}                                                                History@{0}

  ú @{0U}1.2I@{0}
   - fix: missing array index when allocating large block of memory.

  ú @{0U}1.2H@{0}
   - fix: total amounts were not updated at start if automatic operations
         were written at start.
   - add: manual reorder items in the automatic jobs list.
   - fix: automatic selection on new automatic job.
   - fix: some buttons reshaped.
   - fix: validate/save from every window.
   - add: operation action pop-up opened near mouse if right click.
   - fix: total amounts in second currency are not displayed in operations list
          toolbar if display option masks the second currency column.
   - fix: operation details were not updated if operations are (un)checked via
          the pop-up on the operations list.
   - fix: while loading operations list, amounts in second currency are
          calculated to fix sums errors.

  ú @{0U}1.2G@{0}
   - fix: Control+Numeric Pad triggered some actions such as program Quit.
   - fix: Shows Free TT-RAM+ST-RAM in info window instead of ST-RAM.
   - fix: amount in account, in operations table were not redrawn sometimes.
   - fix: errors if CRESUS.RSC not found.

  ú @{0U}1.2F@{0}
    - fix: in operation table, '?' button moved inside '~' pop-up as 'Modify'.
    - fix: if an operation (or more) is selected, then Control+I opens the
           modification window. If not, still the program informations.

  ú @{0U}1.2E@{0}
    - fix: possible crash at start, when reading the preferences file.
    - fix: hide/show the mouse cursor with AES functions instead of VDI.

  ú @{0U}1.2D@{0}
    - fix: uses preferentialy Ssystem to look into the cookie jar.
    - chg: DEFLATE.LDG is moved out of the archive, please fetch
           this library from its own release.

  ú @{0U}1.2C@{0}
    - fix: display in iconified window under MyAES.
    - fix: Return works in date+time change dialog.
    - fix: cosmetic changes in RSC file for XaAES.

  ú @{0U}1.2B@{0}
    - can work with for the new 1.2.7 version of DEFLATE.LDG
    - RSC graphic modifications for XaAES.

  ú @{0U}1.2@{0}
    - compiled with Lonny Pursell's GFA Library, with 68000 and ColdFire targets.
    - windows arrows component are fixed under XaAES.
    - rewrite of load functions for preferences file and clipboard TXT file.
    - smarter application name for taskbars.

 ú @{0U}1.1B@{0}
    + was shareware, now freeware. For unregistered users, the freeze dialog at start
      is now discarded.
    - fix: launch of BubbleGEM wasn't loaded at start, and may have crashed under MiNT.
    - fix: crash under MiNT after calling the ST-Guide documentation.
    - fix: commit for operations tables, saving was correctly done but one table did not
      have its status 'saved', so the program asked uselessly one more commit when leaving.

  ú @{0U}1.1@{0}
    - fix data corruption in transactions types table
      (desynchronization between STREAM.CDB and STREAM2.CDB when
      creating or deleting a type or ordering the types list)
    - fix possible crash when inserting new type of transaction
    + $F% instead of $F&: speed enhanced, visible on ST and Falcon
    + archiving using DEFLATE.LDG and MEM.LDG instead of .TTP helpers
      - no more long pathnames problems
      - no more crash of ZIPJR.TTP on 060 CPU
      - filters are also saved
      - use InfoZIP unzip or KK Commander instead of STZIP
      - needs 800KB free RAM (if not, deflate error)
      - to install this, the LDG and other files are in the GOODIES folder

  ú @{0U}1.0C@{0}
    - fixed crash under MiNT environment in Memory Protected mode.

  ú @{0U}1.0B@{0}
    - fixes:
      - some small files with bizarre names where wronly created
        into the ACCOUNTS folder. Corrected, but if you find ones,
        delete them.
      - for type of transaction with transfer: indicate the inverse
        type via the new pop-up selector (ie if debtor transfer,
        declare its corresponding creditor transfer). The display
        and names will be more correct (wording and "<- FROM ACCOUNT"
        in the notes).
      - if an account was edited and modified, the amounts were
        reset to 0. This won't happen any longer, but do keep in
        mind these amounts are only indicative, and truly set when
        a transaction table was loaded.

  ú @{0U}1.0@{0} (crau04 party release)
    - bugfix: crash at start if NVDI or compatible GDOS was missing.
    + archiving: ZIP.TTP is managed instead of ZIPJR.TTP (060 incompatible)
    + free RAM displayed, it's possible to show an alert if its amount
      is critical.
    + balances if filtering activated (at the window bottom)
    + the filters set can be saved and reloaded (indicate the path folder
      containing the *.CDF files).
    + in the transaction editing window,  and  buttons to go to the
      previous/next transaction (was already there when selecting
      several transactions in the same time).
    + adds in this documentation

  ú @{0U}b‚ta8@{0}
    - bugfixes:
      - display error on balance amounts (cents in 'n.100')
      - when confirming an automatic transaction, the changes
        (date, checking, amount) affects only the one displayed,
        not the next transactions.
     (Thanks to Strider)
      - BubbleGEM font height is no more set.
    + transactions filtering (tip: "Select all" selects only
      the only remaining transactions)
    + transactions printing (see "Misc")
      - GDOS or compatible (default) or GEMDOS
      - A4 (default) or US-letter
      - to printer or clipboard (metafile *.GEM or *.TXT)
    + transactions export, to text file with TAB for
      field separator, and CR+LR for lineends.

  ú @{0U}b‚ta7@{0}
    - bugfixes :
      - crashes at launch if automatic transaction (2 bugs:
        deleting a job after its use, confirmation dialogue
        for a transaction that is not a transfer)
      - windows sliders managment: no more wild selection,
        nor opening of editing windows
      - transaction deleting via the "~" popup: say 'no'
        correctly avoid deleting now
    - minor changes:
      - the birthday is no more necessary
      - ":" instead of "h" for hours in English date format
      - flags correction for non private memory allocation
    ('Merci' to Olivier and Derryck)

  ú @{0U}b‚ta6@{0}
    - bugfixes:
      - crash after transactions general saving
      - crash (random) when transaction editor window is opened in add mode
      - display error in date fields if full
      - bad backup filename (date problem)
      - jobs were not correctly saved in the backup
      - category display problem in jobs for transactions
    + quicker vertical scrolling
    + help bubbles (BubbleGEM protocol)
    + keyboard shortcuts
    + ST-Guide documentation
    + if a transaction job is already selected, adding a new job
      transaction will create one using the same details
    + the last transactions are displayed on opening the account

  ú @{0U}b‚ta5@{0}
    - bugfixes:
       - cents amount approximation.
       - bad display if date transaction was modified.
       - etc.
    + left space in popups.
    + English translation fixes and help by Derryck CROKER
    + TT-RAM used if present.
    + editable fields for date can use the format for display.
    + date reverse order display for transactions (needs relaunch of the
      program).
    + possible automatic save of the configuration when quitting.
    + if transaction is a transfer account, the amount is written in the
      target account (careful, writes are not linked, so deletion of a
      transaction does NOT delete the one in the target account).
    + popup menu in transaction window: quick delete, check or uncheck
      enabled correlated to the (multi) selection of transactions.
      + transaction search functionality (on the opened account)
    + jobs: automatic transactions

    'Merci' to Olivier VANONI, Cyril 'Bibou' LEFEBVRE,
               Jean-Marc STOCKLAUSEN, Derryck CROKER

  ú @{0U}b‚ta4@{0}
    + backup calling (use of STZIP)
    + desk icons
    - changes to the account editor
    - bugfixes :
      - hour not valid (thanks Jean-Marc and cicile)
      - $HOME with MiNT exf2 (hello STrider)
      - columns left move at pref saving (thanks Pascal RICARD)
      - etc

  ú @{0U}b‚ta3@{0}
    + register formular, with hashed key
    + hashed password for accounts
    + new display and misc options
    + multiple selection of operations (Mouse+Shift)
    + editing window opens with double-click on a record
    + record selection faster redraw
    - bugfixes (thanks to Jean-Marc STOCKLAUSEN, Dominique AUSSANT)

  ú @{0U}b‚ta2@{0}
    * first public version

@endnode


@node "cresus_merci"
@title "Cr‚sus documentation"
@{0U}                                                       Megagreetings to@{0}

  to Claude ATTARD,
     who taught me to code in GEM in his articles

  to Daroou / Renaissance aka Jean-Marc STOCKLAUSEN
     an old friend, met during the Dungeon GEM adventure ;)

  thanks to Derryck CROKER, Olivier VANONI, Cyril 'Bibou' LEFEBVRE,
            Strider/mjjprod, Cooper/Paradize, cicile+fabounio/TripleA,
            Jace/STK, Rix, AmigaLyon dudes and people on ircnet
            #atari.fr and #atariscne

@endnode

@node "cresus_dev"
@title "Cr‚sus dev-documentation"

@image ANALYSE.IMG 2


                                   @{"*" LINK "cresus_structure_type"}               @{"*" LINK "cresus_structure_category"}
      @{"*" LINK "cresus_structure_currency"}



      @{"*" LINK "cresus_structure_bank"}                       @{"*" LINK "cresus_structure_account"}

                                                 @{"*" LINK "cresus_structure_transaction"}

      @{"*" LINK "cresus_structure_holder"}



  -> @{"Jobs" LINK "cresus_structure_job"}
  -> @{"Date" LINK "cresus_structure_date"}

@endnode

@node "cresus_structure_currency"
@title "Cr‚sus dev-documentation"

  Table: currencies
  Structure length: 52 bytes
  File: SHARED\CURRENCY.CDB
  Code: @{"*" LINK "cresus_structure_currency_code"}

  @{0U}Offset   Code          Name                         Field@{0}
  +0       INO_CUR       Internal number              INT -> 2 bytes (1 -> 32000)
  +2       CLIB_CUR      Currency name                CHAR -> 32 bytes max + nullbyte
  +36      CCOD_CUR      Code                         CHAR -> 3 bytes max + nullbyte
  +40      CCHR_CUR      Symbol                       CHAR -> 1 byte max + nullbyte
  +42      LREF_CUR      Reference flag               BYTE -> 1 = TRUE, 0 = FALSE
  +43      LVAR_CUR      Floating flag (to reference) BYTE -> 1 = TRUE, 0 = FALSE
  +44      FCONVERT_CUR  Rate exchande (to reference) FLOAT -> 8 bytes

@endnode

@node "cresus_structure_currency_code"
@title "Cr‚sus dev-documentation"

PROCEDURE cur_set_number(cur_ptr%,number&)
  INT{cur_ptr%}=number&
RETURN
FUNCTION cur_get_number(cur_ptr%)
  $F&
  RETURN INT{cur_ptr%}
ENDFUNC
PROCEDURE cur_set_wording(cur_ptr%,wording$)
  CHAR{ADD(cur_ptr%,2)}=TRIM$(LEFT$(wording$,32))
RETURN
FUNCTION cur_get_wording$(cur_ptr%)
  IF cur_ptr%>0
    RETURN CHAR{ADD(cur_ptr%,2)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE cur_set_code(cur_ptr%,code$)
  CHAR{ADD(cur_ptr%,36)}=UPPER$(TRIM$(LEFT$(code$,3)))
RETURN
FUNCTION cur_get_code$(cur_ptr%)
  IF cur_ptr%>0
    RETURN CHAR{ADD(cur_ptr%,36)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE cur_set_symbol(cur_ptr%,symbol$)
  CHAR{ADD(cur_ptr%,40)}=LEFT$(symbol$)
RETURN
FUNCTION cur_get_symbol$(cur_ptr%)
  RETURN CHAR{ADD(cur_ptr%,40)}
ENDFUNC
PROCEDURE cur_set_reference(cur_ptr%,reference!)
  IF reference!
    BYTE{ADD(cur_ptr%,42)}=1
  ELSE
    BYTE{ADD(cur_ptr%,42)}=0
  ENDIF
RETURN
FUNCTION cur_is_reference(cur_ptr%)
  $F!
  IF BYTE{ADD(cur_ptr%,42)}
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE cur_set_conversion(cur_ptr%,conversion)
  FLOAT{ADD(cur_ptr%,44)}=conversion
RETURN
FUNCTION cur_get_conversion(cur_ptr%)
  $F#
  RETURN FLOAT{ADD(cur_ptr%,44)}
ENDFUNC
PROCEDURE cur_set_floating(cur_ptr%,floating!)
  IF floating!
    BYTE{ADD(cur_ptr%,43)}=1
  ELSE
    BYTE{ADD(cur_ptr%,43)}=0
  ENDIF
RETURN
FUNCTION cur_is_floating(cur_ptr%)
  $F!
  IF BYTE{ADD(cur_ptr%,43)}
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC

@endnode

@node "cresus_structure_bank"
@title "Cr‚sus dev-documentation"

  Table: banks
  Structure length: 338 bytes
  File: SHARED\BANK.CDB
  Code: @{"*" LINK "cresus_structure_bank_code"}

  @{0U}Offset   Code          Name              Field@{0}
  +0       INO_BNK       Internal number   INT -> 2 bytes (1 -> 32000)
  +2       CLIB_BNK      Name              CHAR -> 32 bytes max + nullbyte
  +36      CCOD_BNK      Code              CHAR -> 8 bytes max + nullbyte
  +46      COFF_BNK      Office            CHAR -> 32 bytes max + nullbyte
  +80      CADR_BNK      Street            CHAR -> 32 bytes max + nullbyte
  +114     CCODPOST_BNK  Zip code          CHAR -> 16 bytes max + nullbyte
  +132     CVILLE_BNK    City              CHAR -> 32 bytes max + nullbyte
  +166     CPAYS_BNK     Country           CHAR -> 16 bytes max + nullbyte
  +184     CHTTP_BNK     Website           CHAR -> 48 bytes max + nullbyte
  +234     CMAIL_BNK     Email             CHAR -> 48 bytes max + nullbyte
  +284     CTEL1_BNK     Phone number 1    CHAR -> 16 bytes max + nullbyte
  +302     CTEL2_BNK     Phone number 2    CHAR -> 16 bytes max + nullbyte
  +320     CFAX_BNK      Telecopy          CHAR -> 16 bytes max + nullbyte

@endnode

@node "cresus_structure_bank_code"
@title "Cr‚sus dev-documentation"

PROCEDURE bnk_set_number(bnk_ptr%,number&)
  INT{bnk_ptr%}=number&
RETURN
FUNCTION bnk_get_number(bnk_ptr%)
  $F&
  RETURN INT{bnk_ptr%}
ENDFUNC
PROCEDURE bnk_set_wording(bnk_ptr%,wording$)
  CHAR{ADD(bnk_ptr%,2)}=TRIM$(LEFT$(wording$,32))
RETURN
FUNCTION bnk_get_wording$(bnk_ptr%)
  IF bnk_ptr%>0
    RETURN CHAR{ADD(bnk_ptr%,2)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE bnk_set_code(bnk_ptr%,code$)
  CHAR{ADD(bnk_ptr%,36)}=UPPER$(TRIM$(LEFT$(code$,8)))
RETURN
FUNCTION bnk_get_code$(bnk_ptr%)
  IF bnk_ptr%>0
    RETURN CHAR{ADD(bnk_ptr%,36)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE bnk_set_agency(bnk_ptr%,agency$)
  CHAR{ADD(bnk_ptr%,46)}=TRIM$(LEFT$(agency$,32))
RETURN
FUNCTION bnk_get_agency$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,46)}
ENDFUNC
PROCEDURE bnk_set_address(bnk_ptr%,address$)
  CHAR{ADD(bnk_ptr%,80)}=TRIM$(LEFT$(address$,32))
RETURN
FUNCTION bnk_get_address$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,80)}
ENDFUNC
PROCEDURE bnk_set_postnumber(bnk_ptr%,postnumber$)
  CHAR{ADD(bnk_ptr%,114)}=TRIM$(LEFT$(postnumber$,16))
RETURN
FUNCTION bnk_get_postnumber$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,114)}
ENDFUNC
PROCEDURE bnk_set_town(bnk_ptr%,town$)
  CHAR{ADD(bnk_ptr%,132)}=TRIM$(LEFT$(town$,32))
RETURN
FUNCTION bnk_get_town$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,132)}
ENDFUNC
PROCEDURE bnk_set_country(bnk_ptr%,country$)
  CHAR{ADD(bnk_ptr%,166)}=TRIM$(LEFT$(country$,16))
RETURN
FUNCTION bnk_get_country$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,166)}
ENDFUNC
PROCEDURE bnk_set_website(bnk_ptr%,website$)
  CHAR{ADD(bnk_ptr%,184)}=TRIM$(LEFT$(website$,48))
RETURN
FUNCTION bnk_get_website$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,184)}
ENDFUNC
PROCEDURE bnk_set_email(bnk_ptr%,email$)
  CHAR{ADD(bnk_ptr%,234)}=TRIM$(LEFT$(email$,48))
RETURN
FUNCTION bnk_get_email$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,234)}
ENDFUNC
PROCEDURE bnk_set_telephone1(bnk_ptr%,telephone$)
  CHAR{ADD(bnk_ptr%,284)}=TRIM$(LEFT$(telephone$,16))
RETURN
FUNCTION bnk_get_telephone1$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,284)}
ENDFUNC
PROCEDURE bnk_set_telephone2(bnk_ptr%,telephone$)
  CHAR{ADD(bnk_ptr%,302)}=TRIM$(LEFT$(telephone$,16))
RETURN
FUNCTION bnk_get_telephone2$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,302)}
ENDFUNC
PROCEDURE bnk_set_faximile(bnk_ptr%,faximile$)
  CHAR{ADD(bnk_ptr%,320)}=TRIM$(LEFT$(faximile$,16))
RETURN
FUNCTION bnk_get_faximile$(bnk_ptr%)
  RETURN CHAR{ADD(bnk_ptr%,320)}
ENDFUNC

@endnode

@node "cresus_structure_holder"
@title "Cr‚sus dev-documentation"

  Table: holders
  Structure length: 250 bytes
  File: SHARED\PEOPLE.CDB
  Code: @{"*" LINK "cresus_structure_holder_code"}

  @{0U}Offset   Code          Name             Field@{0}
  +0       INO_MAN       Internal number  INT -> 2 bytes (1 -> 32000)
  +2       INO_CIV       Title            INT -> 2 bytes (= internal codes)
  +4       CNOM_MAN      Name             CHAR -> 32 bytes max + nullbyte
  +38      CPRENOM_MAN   First name       CHAR -> 16 bytes max + nullbyte
  +56      CNAI_MAN      Birthday         DATE -> 4 bytes (@{"Cr‚sus date format" LINK "cresus_structure_date"})
  +60      CADR_MAN      Street           CHAR -> 32 bytes max + nullbyte
  +94      CCODPOST_MAN  Zip code         CHAR -> 16 bytes max + nullbyte
  +112     CVILLE_MAN    City             CHAR -> 32 bytes max + nullbyte
  +146     CPAYS_MAN     Country          CHAR -> 16 bytes max + nullbyte
  +164     CTEL1_MAN     Phone number 1   CHAR -> 16 bytes max + nullbyte
  +182     CTEL2_MAN     Phone number 2   CHAR -> 16 bytes max + nullbyte
  +200     CMAIL_MAN     Email            CHAR -> 48 bytes max + nullbyte

@endnode

@node "cresus_structure_holder_code"
@title "Cr‚sus dev-documentation"

PROCEDURE man_set_number(man_ptr%,number&)
  INT{man_ptr%}=number&
RETURN
FUNCTION man_get_number(man_ptr%)
  $F&
  RETURN INT{man_ptr%}
ENDFUNC
PROCEDURE man_set_civility(man_ptr%,civility&)
  INT{ADD(man_ptr%,2)}=civility&
RETURN
FUNCTION man_get_civility(man_ptr%)
  $F&
  RETURN INT{ADD(man_ptr%,2)}
ENDFUNC
PROCEDURE man_set_lastname(man_ptr%,lastname$)
  CHAR{ADD(man_ptr%,4)}=TRIM$(LEFT$(lastname$,32))
RETURN
FUNCTION man_get_lastname$(man_ptr%)
  IF man_ptr%>0
    RETURN CHAR{ADD(man_ptr%,4)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE man_set_firstname(man_ptr%,firstname$)
  CHAR{ADD(man_ptr%,38)}=TRIM$(LEFT$(firstname$,16))
RETURN
FUNCTION man_get_firstname$(man_ptr%)
  IF man_ptr%>0
    RETURN CHAR{ADD(man_ptr%,38)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE man_set_birthday(man_ptr%,birthday%)
  LONG{ADD(man_ptr%,56)}=birthday%
RETURN
FUNCTION man_get_birthday(man_ptr%)
  $F&
  RETURN LONG{ADD(man_ptr%,56)}
ENDFUNC
PROCEDURE man_set_address(man_ptr%,address$)
  CHAR{ADD(man_ptr%,60)}=TRIM$(LEFT$(address$,32))
RETURN
FUNCTION man_get_address$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,60)}
ENDFUNC
PROCEDURE man_set_postnumber(man_ptr%,postnumber$)
  CHAR{ADD(man_ptr%,94)}=TRIM$(LEFT$(postnumber$,16))
RETURN
FUNCTION man_get_postnumber$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,94)}
ENDFUNC
PROCEDURE man_set_town(man_ptr%,town$)
  CHAR{ADD(man_ptr%,112)}=TRIM$(LEFT$(town$,32))
RETURN
FUNCTION man_get_town$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,112)}
ENDFUNC
PROCEDURE man_set_country(man_ptr%,country$)
  CHAR{ADD(man_ptr%,146)}=TRIM$(LEFT$(country$,16))
RETURN
FUNCTION man_get_country$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,146)}
ENDFUNC
PROCEDURE man_set_telephone1(man_ptr%,telephone$)
  CHAR{ADD(man_ptr%,164)}=TRIM$(LEFT$(telephone$,16))
RETURN
FUNCTION man_get_telephone1$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,164)}
ENDFUNC
PROCEDURE man_set_telephone2(man_ptr%,telephone$)
  CHAR{ADD(man_ptr%,182)}=TRIM$(LEFT$(telephone$,16))
RETURN
FUNCTION man_get_telephone2$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,182)}
ENDFUNC
PROCEDURE man_set_email(man_ptr%,email$)
  CHAR{ADD(man_ptr%,200)}=TRIM$(LEFT$(email$,48))
RETURN
FUNCTION man_get_email$(man_ptr%)
  RETURN CHAR{ADD(man_ptr%,200)}
ENDFUNC

@endnode

@node "cresus_structure_account"
@title "Cr‚sus dev-documentation"

  Table: accounts
  Structure length: 144 bytes
  File: SHARED\ACCOUNT.CDB
  Code: @{"*" LINK "cresus_structure_account_code"}

  @{0U}Offset   Code          Name                  Field@{0}
  +0       INO_CPT       Internal number       INT -> 2 bytes (1 -> 32000)
  +2       CCOD_CPT      Code                  CHAR -> 8 bytes max + nullbyte
  +12      CLIB_CPT      Name                  CHAR -> 32 bytes max + nullbyte
  +46      CFIC_CPT      Filename              CHAR -> 8 bytes max (major case) + nullbyte
  +56      CPASS_CPT     Password (hashed)     CHAR -> 16 bytes max + nullbyte
  +74      INO_BNK       Bank                  INT -> 2 bytes -> to banks table (not null)
  +76      CID_CPT       Account number        CHAR -> 24 bytes + nullbyte
  +102     INO_MAN1      Holder 1              INT -> 2 bytes -> to holders table (not null)
  +104     INO_MAN2      Holder 2              INT -> 2 bytes -> to holders table (may be null)
  +106     INO_CUR1      Main currency         INT -> 2 bytes -> to currencies table (not null)
  +108     INO_CUR2      Seconde currency      INT -> 2 bytes -> to currencies table (may be null)
  +110     LCRITIQ1_CPT  Minimum Balance alert BYTE -> 1 = TRUE, 0 = FALSE
  +111     LCRITIQ2_CPT  Minimum Balance alert BYTE -> 1 = TRUE, 0 = FALSE (deprecated)
  +112     FCRITIQ1_CPT  Amount for alert      FLOAT -> 8 bytes
  +120     FCRITIQ2_CPT  Amount for alert      FLOAT -> 8 bytes (deprecated)
  +128     FAMOUNT1_CPT  Balance for main cur  FLOAT -> 8 bytes
  +136     FAMOUNT2_CPT  Balance for 2nd cur   FLOAT -> 8 bytes (deprecated)

@endnode

@node "cresus_structure_account_code"
@title "Cr‚sus dev-documentation"

PROCEDURE cpt_set_number(cpt_ptr%,number&)
  INT{cpt_ptr%}=number&
RETURN
FUNCTION cpt_get_number(cpt_ptr%)
  $F&
  RETURN INT{cpt_ptr%}
ENDFUNC
PROCEDURE cpt_set_code(cpt_ptr%,code$)
  CHAR{ADD(cpt_ptr%,2)}=UPPER$(TRIM$(LEFT$(code$,8)))
RETURN
FUNCTION cpt_get_code$(cpt_ptr%)
  RETURN CHAR{ADD(cpt_ptr%,2)}
ENDFUNC
PROCEDURE cpt_set_wording(cpt_ptr%,wording$)
  CHAR{ADD(cpt_ptr%,12)}=TRIM$(LEFT$(wording$,32))
RETURN
FUNCTION cpt_get_wording$(cpt_ptr%)
  IF cpt_ptr%>0
    RETURN CHAR{ADD(cpt_ptr%,12)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE cpt_set_filename(cpt_ptr%,filename$)
  CHAR{ADD(cpt_ptr%,46)}=UPPER$(TRIM$(LEFT$(filename$,8)))
RETURN
FUNCTION cpt_get_filename$(cpt_ptr%)
  RETURN CHAR{ADD(cpt_ptr%,46)}
ENDFUNC
PROCEDURE cpt_set_password(cpt_ptr%,password$)
  IF cpt_password_changed!
    password$=@hash_password$(TRIM$(LEFT$(password$,16)))
  ENDIF
  CHAR{ADD(cpt_ptr%,56)}=password$
RETURN
FUNCTION cpt_is_same_passwords(pass_str1$,hash_str2$)
  $F!
  IF @hash_password$(pass_str1$)=hash_str2$
    RETURN TRUE
  ELSE IF pass_str1$=hash_str2$
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
FUNCTION cpt_get_password$(cpt_ptr%)
  RETURN CHAR{ADD(cpt_ptr%,56)}
ENDFUNC
FUNCTION cpt_is_password_hashed(cpt_ptr%)
  $F!
  IF BYTE{ADD(cpt_ptr%,56)}=0
    RETURN FALSE
  ELSE IF BYTE{ADD(cpt_ptr%,56)}<16
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
FUNCTION cpt_get_password_len(cpt_ptr%)
  $F&
  IF @cpt_is_password_hashed(cpt_ptr%)
    RETURN BYTE{ADD(cpt_ptr%,56)}
  ELSE
    RETURN LEN(CHAR{ADD(cpt_ptr%,56)})
  ENDIF
ENDFUNC
PROCEDURE cpt_set_bank(cpt_ptr%,number&)
  INT{ADD(cpt_ptr%,74)}=number&
RETURN
FUNCTION cpt_get_bank(cpt_ptr%)
  $F&
  RETURN INT{ADD(cpt_ptr%,74)}
ENDFUNC
PROCEDURE cpt_set_id(cpt_ptr%,id$)
  CHAR{ADD(cpt_ptr%,76)}=TRIM$(LEFT$(id$,24))
RETURN
FUNCTION cpt_get_id$(cpt_ptr%)
  RETURN CHAR{ADD(cpt_ptr%,76)}
ENDFUNC
PROCEDURE cpt_set_holder1(cpt_ptr%,number&)
  INT{ADD(cpt_ptr%,102)}=number&
RETURN
FUNCTION cpt_get_holder1(cpt_ptr%)
  $F&
  RETURN INT{ADD(cpt_ptr%,102)}
ENDFUNC
PROCEDURE cpt_set_holder2(cpt_ptr%,number&)
  INT{ADD(cpt_ptr%,104)}=number&
RETURN
FUNCTION cpt_get_holder2(cpt_ptr%)
  $F&
  RETURN INT{ADD(cpt_ptr%,104)}
ENDFUNC
PROCEDURE cpt_set_currency1(cpt_ptr%,number&)
  INT{ADD(cpt_ptr%,106)}=number&
RETURN
FUNCTION cpt_get_currency1(cpt_ptr%)
  $F&
  RETURN INT{ADD(cpt_ptr%,106)}
ENDFUNC
PROCEDURE cpt_set_currency2(cpt_ptr%,number&)
  INT{ADD(cpt_ptr%,108)}=number&
RETURN
FUNCTION cpt_get_currency2(cpt_ptr%)
  $F&
  RETURN INT{ADD(cpt_ptr%,108)}
ENDFUNC
PROCEDURE cpt_set_critical_flag1(cpt_ptr%,critical!)
  IF critical!
    BYTE{ADD(cpt_ptr%,110)}=1
  ELSE
    BYTE{ADD(cpt_ptr%,110)}=0
  ENDIF
RETURN
FUNCTION cpt_get_critical_flag1(cpt_ptr%)
  $F!
  IF BYTE{ADD(cpt_ptr%,110)}=1
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE cpt_set_critical_flag2(cpt_ptr%,critical!)
  IF critical!
    BYTE{ADD(cpt_ptr%,111)}=1
  ELSE
    BYTE{ADD(cpt_ptr%,111)}=0
  ENDIF
RETURN
FUNCTION cpt_get_critical_flag2(cpt_ptr%)
  $F!
  IF BYTE{ADD(cpt_ptr%,111)}=1
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE cpt_set_critical_amount1(cpt_ptr%,amount)
  FLOAT{ADD(cpt_ptr%,112)}=amount
RETURN
FUNCTION cpt_get_critical_amount1(cpt_ptr%)
  $F#
  RETURN FLOAT{ADD(cpt_ptr%,112)}
ENDFUNC
PROCEDURE cpt_set_critical_amount2(cpt_ptr%,amount)
  FLOAT{ADD(cpt_ptr%,120)}=amount
RETURN
FUNCTION cpt_get_critical_amount2(cpt_ptr%)
  $F#
  RETURN FLOAT{ADD(cpt_ptr%,120)}
ENDFUNC
PROCEDURE cpt_set_amount1(cpt_ptr%,amount)
  FLOAT{ADD(cpt_ptr%,128)}=amount
RETURN
FUNCTION cpt_get_amount1(cpt_ptr%)
  $F#
  RETURN FLOAT{ADD(cpt_ptr%,128)}
ENDFUNC
PROCEDURE cpt_set_amount2(cpt_ptr%,amount)
  FLOAT{ADD(cpt_ptr%,136)}=amount
RETURN
FUNCTION cpt_get_amount2(cpt_ptr%)
  $F#
  RETURN FLOAT{ADD(cpt_ptr%,136)}
ENDFUNC

@endnode

@node "cresus_structure_type"
@title "Cr‚sus dev-documentation"

  Table: types (of transactions)
  Structure length: 50 bytes
  File: SHARED\STREAM.CDB
  Code: @{"*" LINK "cresus_structure_type_code"}

  @{0U}Offset   Code          Name              Field@{0}
  +0       INO_MOV       Internal number   INT -> 2 bytes (1 -> 32000)
  +2       CLIB_MOV      Name              CHAR -> 32 bytes max + nullbyte
  +36      CCOD_MOV      Code              CHAR -> 8 bytes max + nullbyte
  +46      ICOL_MOV      Color             BYTE -> 0 -> 16 (VDI index)
  +47      LDEB_MOV      Debt flag         BYTE -> 0 = debtor, 1 = creditor
  +48      LCECHK_MOV    Check flag        BYTE -> 0 = no, 1 = with check
  +49      LVIR_MOV      Transfert flag    BYTE -> 0 = no, 1 = transfer to other account (debt)

  Table: types (of transactions)
  Structure length: 32 bytes
  File: SHARED\STREAM2.CDB

  @{0U}Offset   Code          Name              Field@{0}
  +0       INO_NEW_MOV   Internal number   INT -> 2 bytes (1 -> 32000)
                         (if type=account transfer, then it will be the target type)

@endnode

@node "cresus_structure_type_code"
@title "Cr‚sus dev-documentation"

PROCEDURE mov_set_number(mov_ptr%,number&)
  INT{mov_ptr%}=number&
RETURN
FUNCTION mov_get_number(mov_ptr%)
  $F&
  RETURN INT{mov_ptr%}
ENDFUNC
PROCEDURE mov_set_wording(mov_ptr%,wording$)
  CHAR{ADD(mov_ptr%,2)}=TRIM$(LEFT$(wording$,32))
RETURN
FUNCTION mov_get_wording$(mov_ptr%)
  IF mov_ptr%>0
    RETURN CHAR{ADD(mov_ptr%,2)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE mov_set_code(mov_ptr%,code$)
  CHAR{ADD(mov_ptr%,36)}=UPPER$(TRIM$(LEFT$(code$,8)))
RETURN
FUNCTION mov_get_code$(mov_ptr%)
  RETURN CHAR{ADD(mov_ptr%,36)}
ENDFUNC
PROCEDURE mov_set_color(mov_ptr%,color|)
  BYTE{ADD(mov_ptr%,46)}=MAX(0,MIN(color|,15))
RETURN
FUNCTION mov_get_color(mov_ptr%)
  $F|
  RETURN MAX(0,MIN(BYTE{ADD(mov_ptr%,46)},15))
ENDFUNC
PROCEDURE mov_set_debt(mov_ptr%,debt!)
  IF debt!
    BYTE{ADD(mov_ptr%,47)}=1
  ELSE
    BYTE{ADD(mov_ptr%,47)}=0
  ENDIF
RETURN
FUNCTION mov_is_debt(mov_ptr%)
  $F!
  IF mov_ptr%>0
    IF BYTE{ADD(mov_ptr%,47)}>0
      RETURN TRUE
    ELSE
      RETURN FALSE
    ENDIF
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE mov_set_with_check(mov_ptr%,check!)
  IF check!
    BYTE{ADD(mov_ptr%,48)}=1
  ELSE
    BYTE{ADD(mov_ptr%,48)}=0
  ENDIF
RETURN
FUNCTION mov_is_with_check(mov_ptr%)
  $F!
  IF mov_ptr%>0
    IF BYTE{ADD(mov_ptr%,48)}
      RETURN TRUE
    ELSE
      RETURN FALSE
    ENDIF
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE mov_set_transfer(mov_ptr%,transfer!)
  IF transfer!
    BYTE{ADD(mov_ptr%,49)}=1
  ELSE
    BYTE{ADD(mov_ptr%,49)}=0
  ENDIF
RETURN
FUNCTION mov_is_transfer(mov_ptr%)
  $F!
  IF mov_ptr%>0
    IF BYTE{ADD(mov_ptr%,49)}
      RETURN TRUE
    ELSE
      RETURN FALSE
    ENDIF
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC

@endnode

@node "cresus_structure_category"
@title "Cr‚sus dev-documentation"

  Table: categories
  Structure length: 48 bytes
  File: SHARED\BUDGET.CDB
  Code: @{"*" LINK "cresus_structure_category_code"}

  @{0U}Offset   Code          Name              Field@{0}
  +0       INO_BUD       Internal number   INT -> 2 bytes (1 -> 32000)
  +2       CLIB_BUD      Name              CHAR -> 32 bytes max + nullbyte
  +36      CCOD_BUD      Code              CHAR -> 8 bytes max + nullbyte
  +46      ICOL_BUD      Color             BYTE -> 0 -> 16 (VDI index)

@endnode

@node "cresus_structure_category_code"
@title "Cr‚sus dev-documentation"

PROCEDURE bud_set_number(bud_ptr%,number&)
  INT{bud_ptr%}=number&
RETURN
FUNCTION bud_get_number(bud_ptr%)
  $F&
  RETURN INT{bud_ptr%}
ENDFUNC
PROCEDURE bud_set_wording(bud_ptr%,wording$)
  CHAR{ADD(bud_ptr%,2)}=TRIM$(LEFT$(wording$,32))
RETURN
FUNCTION bud_get_wording$(bud_ptr%)
  IF bud_ptr%>0
    RETURN CHAR{ADD(bud_ptr%,2)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE bud_set_code(bud_ptr%,code$)
  CHAR{ADD(bud_ptr%,36)}=UPPER$(TRIM$(LEFT$(code$,8)))
RETURN
FUNCTION bud_get_code$(bud_ptr%)
  RETURN CHAR{ADD(bud_ptr%,36)}
ENDFUNC
PROCEDURE bud_set_color(bud_ptr%,color|)
  BYTE{ADD(bud_ptr%,46)}=MAX(0,MIN(color|,15))
RETURN
FUNCTION bud_get_color(bud_ptr%)
  $F|
  RETURN MAX(0,MIN(BYTE{ADD(bud_ptr%,46)},15))
ENDFUNC

@endnode

@node "cresus_structure_transaction"
@title "Cr‚sus dev-documentation"

  Table: transactions
  Structure length: 162 bytes
  File: ACCOUNTS\*.CDB
  Code: @{"*" LINK "cresus_structure_transaction_code"}

  @{0U}Offset   Code          Name                  Field@{0}
  +0       INO_OPE       Internal number       INT -> 2 bytes (1 -> 32000, unused)
  +2       INO_CPT       Account               INT -> 2 bytes -> to accounts table (not null)
  +4       DCRE_OPE      Record creation       DATE -> 4 bytes (@{"Cr‚sus date format" LINK "cresus_structure_date"})
  +8       DMOD_OPE      Record modification   DATE -> 4 bytes (@{"Cr‚sus date format" LINK "cresus_structure_date"})
  +12      DOPE_OPE      Date of transaction   DATE -> 4 bytes (@{"Cr‚sus date format" LINK "cresus_structure_date"})
  +16      INO_MOV       Type of transaction   INT -> 2 bytes -> to types tables (not null)
  +18      CCHEQ_OPE     Check number          CHAR -> 16 bytes max + nullbyte
  +36      INO_CPT_VIR   Transfer to account   INT -> 2 bytes -> to accounts table (may be null)
  +38      FAMOUNT1_OPE  Amount in main curren FLOAT -> 8 bytes
  +46      FAMOUNT2_OPE  Amount in 2nd currenc FLOAT -> 8 bytes
  +54      INO_BUD       Category              INT -> 2 bytes -> to categories table (may be null)
  +56      CNOTE1_OPE    Notes 1               CHAR -> 50 bytes max + nullbyte
  +108     CNOTE2_OPE    Notes 2               CHAR -> 50 bytes max + nullbyte
  +160     LPOINTE_OPE   Checked flag          BYTE -> 1 = TRUE, 0 = FALSE
  +161     LFLAGS_OPE    Misc flags            BYTE (not yet used)

@endnode

@node "cresus_structure_transaction_code"
@title "Cr‚sus dev-documentation"

PROCEDURE ope_set_number(ope_ptr%,number&)
  INT{ope_ptr%}=number&
RETURN
FUNCTION ope_get_number(ope_ptr%)
  $F&
  RETURN INT{ope_ptr%}
ENDFUNC
PROCEDURE ope_set_account(ope_ptr%,number&)
  INT{ADD(ope_ptr%,2)}=number&
RETURN
FUNCTION ope_get_account(ope_ptr%)
  $F&
  RETURN INT{ADD(ope_ptr%,2)}
ENDFUNC
PROCEDURE ope_set_date_creation(ope_ptr%,date%)
  LONG{ADD(ope_ptr%,4)}=date%
RETURN
FUNCTION ope_get_date_creation(ope_ptr%)
  $F%
  RETURN LONG{ADD(ope_ptr%,4)}
ENDFUNC
PROCEDURE ope_set_date_modification(ope_ptr%,date%)
  LONG{ADD(ope_ptr%,8)}=date%
RETURN
FUNCTION ope_get_date_modification(ope_ptr%)
  $F%
  RETURN LONG{ADD(ope_ptr%,8)}
ENDFUNC
PROCEDURE ope_set_date_operation(ope_ptr%,date%)
  LONG{ADD(ope_ptr%,12)}=date%
RETURN
FUNCTION ope_get_date_operation(ope_ptr%)
  $F%
  RETURN LONG{ADD(ope_ptr%,12)}
ENDFUNC
PROCEDURE ope_set_stream(ope_ptr%,number&)
  INT{ADD(ope_ptr%,16)}=number&
RETURN
FUNCTION ope_get_stream(ope_ptr%)
  $F&
  RETURN INT{ADD(ope_ptr%,16)}
ENDFUNC
PROCEDURE ope_set_check_number(ope_ptr%,number$)
  CHAR{ADD(ope_ptr%,18)}=LEFT$(number$,16)
RETURN
FUNCTION ope_get_check_number$(ope_ptr%)
  RETURN CHAR{ADD(ope_ptr%,18)}
ENDFUNC
PROCEDURE ope_set_transfer_account(ope_ptr%,number&)
  INT{ADD(ope_ptr%,36)}=number&
RETURN
FUNCTION ope_get_transfer_account(ope_ptr%)
  $F&
  RETURN INT{ADD(ope_ptr%,36)}
ENDFUNC
PROCEDURE ope_set_amount1(ope_ptr%,amount)
  FLOAT{ADD(ope_ptr%,38)}=amount
RETURN
FUNCTION ope_get_amount1(ope_ptr%)
  $F#
  RETURN FLOAT{ADD(ope_ptr%,38)}
ENDFUNC
PROCEDURE ope_set_amount2(ope_ptr%,amount)
  FLOAT{ADD(ope_ptr%,46)}=amount
RETURN
FUNCTION ope_get_amount2(ope_ptr%)
  $F#
  RETURN FLOAT{ADD(ope_ptr%,46)}
ENDFUNC
PROCEDURE ope_set_budget(ope_ptr%,number&)
  INT{ADD(ope_ptr%,54)}=number&
RETURN
FUNCTION ope_get_budget(ope_ptr%)
  $F&
  RETURN INT{ADD(ope_ptr%,54)}
ENDFUNC
PROCEDURE ope_set_note1(ope_ptr%,note$)
  CHAR{ADD(ope_ptr%,56)}=TRIM$(LEFT$(note$,50))
RETURN
FUNCTION ope_get_note1$(ope_ptr%)
  RETURN CHAR{ADD(ope_ptr%,56)}
ENDFUNC
PROCEDURE ope_set_note2(ope_ptr%,note$)
  CHAR{ADD(ope_ptr%,108)}=TRIM$(LEFT$(note$,50))
RETURN
FUNCTION ope_get_note2$(ope_ptr%)
  RETURN CHAR{ADD(ope_ptr%,108)}
ENDFUNC
PROCEDURE ope_set_verified(ope_ptr%,verified!)
  IF verified!
    BYTE{ADD(ope_ptr%,160)}=1
  ELSE
    BYTE{ADD(ope_ptr%,160)}=0
  ENDIF
RETURN
FUNCTION ope_is_verified(ope_ptr%)
  $F!
  IF BYTE{ADD(ope_ptr%,160)}
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE ope_set_flags(ope_ptr%,flags|)
  BYTE{ADD(ope_ptr%,161)}=flags|
RETURN
FUNCTION ope_get_flags(ope_ptr%)
  $F|
  RETURN BYTE{ADD(ope_ptr%,161)}
ENDFUNC

@endnode

@node "cresus_structure_job"
@title "Cr‚sus dev-documentation"

  Table: jobs
  Structure length: 256 bytes (42 bytes for header, 214 for embeded structure)
  File: SHARED\JOB.CDB
  Code: @{"*" LINK "cresus_structure_job_code"}

  @{0U}Offset   Code          Name                  Field@{0}
  +0       INO_JOB       Internal number       INT -> 2 bytes (1 -> 32000)
  +2       CNOM_JOB      Name                  CHAR -> 30 bytes max + nullbyte
  +34      LACTIF_JOB    Activated flag        BYTE -> 1 = TRUE, 0 = FALSE
  +35      LCONFIRM_JOB  Confirmation dialog   BYTE -> 1 = TRUE, 0 = FALSE
  +36      IREPET_JOB    Repetition            INT -> 2 bytes (= internal codes)
  +38      IFIN_JOB      Behavior after exec   INT -> 2 bytes (0 = inactivate, 1 = delete)
  +40      ITYPE_JOB     Type of structure     INT -> 2 bytes (1 = transaction)
  +42      -> Embedded Structure

@endnode

@node "cresus_structure_job_code"
@title "Cr‚sus dev-documentation"

PROCEDURE job_set_number(job_ptr%,number&)
  INT{job_ptr%}=number&
RETURN
FUNCTION job_get_number(job_ptr%)
  $F&
  RETURN INT{job_ptr%}
ENDFUNC
PROCEDURE job_set_wording(job_ptr%,wording$)
  CHAR{ADD(job_ptr%,2)}=TRIM$(LEFT$(wording$,30))
RETURN
FUNCTION job_get_wording$(job_ptr%)
  IF job_ptr%>0
    RETURN CHAR{ADD(job_ptr%,2)}
  ELSE
    RETURN ""
  ENDIF
ENDFUNC
PROCEDURE job_set_active(job_ptr%,activated!)
  IF activated!
    BYTE{ADD(job_ptr%,34)}=1
  ELSE
    BYTE{ADD(job_ptr%,34)}=0
  ENDIF
RETURN
FUNCTION job_is_active(job_ptr%)
  $F!
  IF BYTE{ADD(job_ptr%,34)}
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE job_set_need_confirmation(job_ptr%,confirm!)
  IF confirm!
    BYTE{ADD(job_ptr%,35)}=1
  ELSE
    BYTE{ADD(job_ptr%,35)}=0
  ENDIF
RETURN
FUNCTION job_is_confirmation_needed(job_ptr%)
  $F!
  IF BYTE{ADD(job_ptr%,35)}
    RETURN TRUE
  ELSE
    RETURN FALSE
  ENDIF
ENDFUNC
PROCEDURE job_set_repetition(job_ptr%,number&)
  INT{ADD(job_ptr%,36)}=number&
RETURN
FUNCTION job_get_repetition(job_ptr%)
  $F&
  RETURN INT{ADD(job_ptr%,36)}
ENDFUNC
PROCEDURE job_set_end(job_ptr%,number&)
  INT{ADD(job_ptr%,38)}=number&
RETURN
FUNCTION job_get_end(job_ptr%)
  $F&
  RETURN INT{ADD(job_ptr%,38)}
ENDFUNC
PROCEDURE job_set_type(job_ptr%,number&)
  INT{ADD(job_ptr%,40)}=number&
RETURN
FUNCTION job_get_type(job_ptr%)
  $F&
  RETURN INT{ADD(job_ptr%,40)}
ENDFUNC
FUNCTION job_get_pointer(job_ptr%)
  $F%
  RETURN ADD(job_ptr%,42)
ENDFUNC

@endnode

@node "cresus_structure_date"
@title "Cr‚sus dev-documentation"

  Date: 1 long = 4 bytes, bit fields
  Code: @{"*" LINK "cresus_structure_date_code"}

  Field: yyyyyyyyyyyyyyMMMMdddddHHHHHmmmmmm

@endnode

@node "cresus_structure_date_code"
@title "Cr‚sus dev-documentation"

year$=STR$(SHR(timestamp%,20) AND &X11111111111111)
IF LEN(year$)<4
  year$=STRING$(SUB(4,LEN(year$)),"0")+year$
ENDIF

month$=STR$(SHR(timestamp%,16) AND &X1111)
IF LEN(month$)<2
  month$=STRING$(SUB(2,LEN(month$)),"0")+month$
ENDIF

day$=STR$(SHR(timestamp%,11) AND &X11111)
IF LEN(day$)<2
  day$=STRING$(SUB(2,LEN(day$)),"0")+day$
ENDIF

hour$=STR$(SHR(timestamp%,6) AND &X11111)
IF LEN(hour$)<4
  hour$=STRING$(SUB(2,LEN(hour$)),"0")+hour$
ENDIF

minute$=STR$(timestamp% AND &X111111)
IF LEN(minute$)<2
  minute$=STRING$(SUB(2,LEN(minute$)),"0")+minute$
ENDIF

@endnode
