' Name:  RCL
' von :  H. Pape   DK2ZA   Gauûstraûe 20    90459 NÅrnberg    Tel.: 0911/449184
'
'
dimensionieren_u_initialisieren
'
fehlereinsprung:
'
ON ERROR GOSUB fehlerbehandlung
'
'
'
' Es folgt die Hauptschleife des Programms:
'
DO
  '
  IF eingabe&=1
    dialogbox1
  ELSE
    dialogbox2
  ENDIF
  '
  EXIT IF prog_ende&=TRUE
  '
  IF zeige_grafik&=TRUE
    grafik_zeigen
  ENDIF
  '
  IF zeichne_kurve&=TRUE
    kurve_zeichnen
  ENDIF
  '
LOOP
'
'
'
' Nun die Unterprogramme:
'
PROCEDURE dimensionieren_u_initialisieren
  '
  LOCAL n&,k&
  '
  '
  OPTION BASE 0               ! Indizes beginnen mit 0
  MAT BASE 0                  ! auch bei Matrizen
  '
  GRAPHMODE 1                 ! ersetzen
  DEFLINE 1                   ! durchgezogen
  COLOR 1                     ! schwarz
  '
  CLIP 0,0 TO 639,399         ! nicht Åber den Bildrand zeichnen
  '
  '
  ' Hier werden globale Konstanten dimensioniert und vorbelegt:
  '
  '
  anzahl_bef&=20              ! Es gibt 20 Befehle
  '
  DIM befehl$(anzahl_bef&)    ! Liste mit den Namen der Befehle
  '
  FOR n&=0 TO anzahl_bef&     ! Die Namen der Befehle lesen
    READ befehl$(n&)
  NEXT n&
  '
  DATA "     ","R    ","C    ","L    ","ser  "
  DATA "par  ","dup  ","sto  ","rcl  ","/    "
  DATA "*    ","drop ","swap ","over ","rot  "
  DATA "inv  ","+    ","-    ","cstk ","~~~~~"
  DATA "conj "
  '
  '
  DIM box&(29)                ! Zu jedem der 30 Items in Dialogbox 1
  '                             steht hier die Nummer der Rasterzeile
  FOR n&=0 TO 29              ! der obersten Linie des umgebenden
    READ box&(n&)             ! Kastens ( Breite ist bei allen gleich )
  NEXT n&
  '
  '     0  1   2   3   4   5   6   7   8   9  10  11  12  13  14
  DATA 56,56,105,105,105,137,137,169,169,169,169,169,201,201,249
  '     15  16  17  18  19  20  21  22  23  24  25  26  27  28  29
  DATA 249,249,297,297,297,297,297,329,329,329,329,361,361,361,361
  '
  '
  DIM n_item&(29,6)           ! n_item&() enthÑlt zu jedem Item
  '                             von Dialogbox 1 die
  FOR n&=0 TO 29              ! Cursorposition (x,y) und die Nummer
    FOR k&=0 TO 6             ! des Items, welches nach BetÑtigung
      READ n_item&(n&,k&)     ! der Pfeiltasten bzw. der Return-
    NEXT k&                   ! Taste als nÑchstes zur Eingabe
  NEXT n&                     ! angeboten wird
  '
  '  x, y, Pfeilrichtung links, rechts, rauf, runter, Return
  '
  ' item1&=0                                   f_min
  DATA 11,5,0,1,0,2,1
  ' item1&=1                                   f_max
  DATA 52,5,0,1,1,3,2
  ' item1&=2                                   maximaler Betrag bzw. SWR
  DATA 27,8,2,3,0,5,5
  ' item1&=3                                   nicht automatisch festlegen
  DATA 69,8,2,4,1,6,5
  ' item1&=4                                   automatisch festlegen
  DATA 76,8,3,4,1,6,5
  ' item1&=5                                   maximale DÑmpfung
  DATA 27,10,5,6,2,7,6
  ' item1&=6                                   Wellenwiderstand
  DATA 67,10,5,6,3,9,7
  ' item1&=7                                   Betrag /
  DATA 3,12,7,8,5,12,9
  ' item1&=8                                          / SWR
  DATA 12,12,7,9,5,12,9
  ' item1&=9                                   Betrag / SWR darstellen nein
  DATA 40,12,8,10,6,12,12
  ' item1&=10                                  Betrag / SWR darstellen lin
  DATA 49,12,9,11,6,12,12
  ' item1&=11                                  Betrag / SWR darstellen log
  DATA 57,12,10,11,6,12,12
  ' item1&=12                                  Phasenwinkel darstellen nein
  DATA 40,14,12,13,9,14,14
  ' item1&=13                                  Phasenwinkel darstellen ja
  DATA 49,14,12,13,9,14,14
  ' item1&=14                                  Schrittweite
  DATA 31,17,14,15,12,17,15
  ' item1&=15                                  Frequenzachsenteilung lin
  DATA 69,17,14,16,12,17,17
  ' item1&=16                                  Frequenzachsenteilung log
  DATA 75,17,15,16,12,17,17
  ' item1&=17                                  Befehlsfolge laden
  DATA 25,20,17,18,14,22,22
  ' item1&=18                                  Befehlsfolge anhÑngen
  DATA 34,20,17,19,14,23,14
  ' item1&=19                                  Befehlsfolge speichern
  DATA 46,20,18,20,14,24,23
  ' item1&=20                                  Befehlsfolge drucken
  DATA 59,20,19,21,14,25,14
  ' item1&=21                                  Befehlsfolge lîschen
  DATA 71,20,20,21,14,25,14
  ' item1&=22                                  Bauteile laden
  DATA 25,22,22,23,17,26,14
  ' item1&=23                                  Bauteile speichern
  DATA 34,22,22,24,18,27,14
  ' item1&=24                                  Bauteile drucken
  DATA 47,22,23,25,19,28,14
  ' item1&=25                                  Bauteile lîschen
  DATA 59,22,24,25,20,29,14
  ' item1&=26                                  Grafik laden
  DATA 25,24,26,27,22,26,14
  ' item1&=27                                  Grafik speichern
  DATA 34,24,26,28,23,27,14
  ' item1&=28                                  Grafik drucken
  DATA 47,24,27,29,24,28,14
  ' item1&=29                                  Grafik lîschen
  DATA 59,24,28,29,25,29,14
  '
  '
  DIM li_ob&(3)               ! Diese Liste enthÑlt fÅr Dialogbox 2
  '                             ( Befehle und Bauteilwerte )
  FOR n&=0 TO 3               ! die x-Werte des ersten Zeichens der
    READ li_ob&(n&)           ! jeweiligen Befehls- bzw. Wertespalte
  NEXT n&
  '
  DATA 4,23,43,63
  '
  '
  ' Diese Festlegungen sollen das Listing besser lesbar machen:
  '
  nein&=0
  lin&=1
  log&=2
  weiss&=0
  schwarz&=1
  '
  '
  ' Hier stehen die bei INP(2) von der jeweiligen Taste gelieferten Nummern:
  '
  backspace&=8
  return&=13
  esc&=27
  leertaste&=32
  jk&=106                     ! Taste j ( klein )
  jg&=74                      ! Taste J ( groû )
  delete&=127
  eins&=49
  zwei&=50
  drei&=51
  f1&=187
  f2&=188
  f3&=189
  f4&=190
  f5&=191
  f7&=193
  f10&=196
  clrhome&=199
  auf&=200
  ab&=208
  links&=203
  rechts&=205
  insert&=210
  undo&=225
  help&=226
  control_clrhome&=247
  '
  '
  ' Hier werden globale Variable dimensioniert und vorbelegt:
  '
  '
  DIM r(99),c(99),l(99)       ! Speicher fÅr Bauteilwerte R, C, L
  DIM bauteil(99)             ! Zwischenspeicher zur Bearbeitung
  DIM sp_r(99),sp_i(99)       ! sto - rcl - Speicher fÅr komplexe Zahlen
  '                             sp_r(): Realteil,  sp_i(): ImaginÑrteil
  DIM st_r(99),st_i(99)       ! Rechenstapel fÅr komplexe Zahlen
  DIM befehl&(999)            ! Befehlsfolge. Jedes 16 Bit Wort dieser
  '                             Liste enthÑlt einen der eingegebenen
  '                             Befehle evtl. mit der dazugehîrigen
  '                             Speicher- oder Bauteilnummer
  DIM betr_swr(639)           ! Wenn der Maximalwert von Betrag / SWR
  '                             automatisch bestimmt werden soll, werden
  '                             die berechneten Werte Werte zuerst hier
  '                             gespeichert
  DIM anzahl&(255)            ! Wenn ein Bild komprimiert gespeichert wird,
  '                             brauchen wir diese Liste, um das seltenste
  '                             Byte zu finden
  DIM oberst&(3)              ! Nummern der Befehle bzw. der Bauteile in den
  '                             obersten Zeilen der 4 Spalten von Dialogbox 2
  DIM zeile&(3)               ! Cursorzeile in der jeweiligen Spalte
  '
  DIM linie(9)                ! legt bei logarithmischer Teilung der
  FOR n&=0 TO 9               ! Frequenzachse fest, welche Teilungslinien
    READ linie(n&)            ! gezeichnet werden sollen. Hier:
  NEXT n&                     ! ... 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1 2
  '                               3 4 5 6 7 8 9 10 20 30 40 50 60 70 80 ...
  DATA -1,1.5,-2,-3,-4,-5,-6,-7,-8,-9
  '
  ' Es folgen Bitmuster fÅr die verschiedenen Arten von Teilungslinien
  '
  DIM strich%(7)
  strich%(0)=&X11111111111111110000000000000001   !  Eingabe als
  strich%(1)=&X11111111111111110011001100110100   ! = -%1100110011001100
  strich%(2)=&X11111111111111110000111100010000
  strich%(3)=&X11111111111111110000000100000000
  strich%(4)=&X11111111111111110000000000010000
  strich%(5)=&X11111111111111110000011100001000
  strich%(6)=&X11111111111111111111100011111001
  strich%(7)=&X11111111111111110011111101000000
  '
  linienstilf&=0              ! Linienstil fÅr Frequenzteilung
  linienstild&=0              ! Linienstil fÅr DÑmpfungslinien
  '
  eingabe&=1                  ! Dialogbox 1: Allgemeine Eingaben
  '                             Dialogbox 2: Befehle und Bauteile eingeben
  '
  antw&=0                     ! Antwortvariable bei Alarmboxen
  '
  streifen$=""                ! String als Zwischenspeicher beim Scrollen
  '                             der Spalten in Dialogbox 2
  item2&=0                    ! beim nÑchsten Aufruf der Eingaberoutine fÅr
  '                             Befehle und Werte (Dialogbox 2) wird der
  '                             Cursor auf die Spalte item2& gesetzt (0..3)
  item1&=17                   ! beim nÑchsten Aufruf der Eingaberoutine
  '                             fÅr allgemeine Eingaben (Dialogbox 1) wird
  '                             der Cursor auf dieses item1& gesetzt
  '
  nullpkt_neu&=FALSE          ! Flag, falls 1 wurde der Koordinatenursprung
  '                             ( bei Darstellung mit F5 ) verschoben
  x0&=0                       ! Koordinatenursprung
  y0lin&=0                    ! fÅr "anschauen" ( Taste F5 )
  y0log&=0
  '
  f_min=0                     ! Frequenzuntergrenze
  f_max=10000000              ! Frequenzobergrenze
  f_achse&=lin&               ! Teilung der Frequenzachse
  frequenzlinien&=FALSE       ! Frequenzteilung nicht zeichnen ( bei log )
  betr_swr_max=2              ! am oberen Bildrand
  betr_swr_auto&=FALSE        ! kann man in Dialogbox 1 Ñndern
  daempf_max=60               ! DÑmpfung am unteren Bildrand bei
  '                             logarithmischer Darstellung in dB
  daempfungslinien&=FALSE     ! dB - Linien nicht zeichnen ( bei log )
  wellenwiderstand=50         ! fÅr SWR- Berechnung
  schrittweite&=4             ! 640/4=160 Berechnungen, dazwischen linear
  befehlz&=0                  ! zeigt auf aktuellen Befehl in Befehlsfolge
  betrag_darst&=TRUE          ! kann man in Dialogbox 1 Ñndern
  '                             wenn FALSE, wird das SWR dargestellt
  betr_swr_darst&=lin&        ! dito
  phase_darst&=FALSE          ! dito
  prog_ende&=FALSE            ! wird mit Esc auf TRUE gesetzt
  zeige_grafik&=FALSE         ! wird mit F5 auf TRUE gesetzt
  zeichne_kurve&=FALSE        ! wird mit F10 auf TRUE gesetzt
  kurve$=STRING$(32000,0)     ! in kurve$ wird der Bildschirm mit der
  '                             Kurve aber ohne Gitter aufgehoben
  bild$=STRING$(32000,0)      ! in bild$ wird der Bildschirm mit Kurve
  '                             und Gitter aufgehoben (fÅr F5)
  dialogbox2_neu&=TRUE        ! wird FALSE gesetzt, nachdem die betreffende
  dialogbox1_neu&=TRUE        ! Dialogbox gezeichnet und als Bild
  '                             gespeichert ist
  dialogbox2$=STRING$(32000,0)       ! EnthÑlt den Bildschirm fÅr Dialogbox 2
  '                                    (Befehls- und Werteeingabe)
  dialogbox1$=STRING$(32000,0)       ! EnthÑlt den Bildschirm fÅr Dialogbox 1
  '                                    (Åbrige Eingaben)
  '
  '
  ' Hier folgen die Vorgaben fÅr Pfade und Dateinamen:
  '
  pfad$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"
  dnam$="TEST"
  datei$=""
  '
RETURN
'
PROCEDURE dialogbox1
  '
  LOCAL w,taste&,k&,n&,raus&,e&
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  IF dialogbox1_neu&=TRUE
    '
    CLS
    PRINT
    PRINT " andere Eingaben: F1   anschauen: F5";
    PRINT "   zeichnen: F10   Hilfe: Help    Ende: Esc"
    PRINT
    PRINT
    PRINT "  f min = ";FN wert$(f_min,12,0);"Hz";
    PRINT TAB(43);"f max = ";FN wert$(f_max,12,0);"Hz"
    PRINT
    PRINT
    PRINT "  Betrag / SWR   max.   = ";
    betr_swr_drucken(betr_swr_max)
    PRINT TAB(43);"automatisch einstellen:  nein / ja"
    PRINT
    PRINT "  DÑmpfung       max.   =  ";daempf_max;" dB";
    PRINT TAB(43);"Wellenwiderstand   =   ";
    PRINT STR$(wellenwiderstand,7,2);" Ohm"
    PRINT
    PRINT "  Betrag / SWR    darstellen:          nein  /  lin  /  log"
    PRINT
    PRINT "  Phasenwinkel    darstellen:          nein  /  ja"
    PRINT
    PRINT
    PRINT "  Schrittweite ( 1 ... 9 )  = ";schrittweite&;
    PRINT "        Teilung der Frequenzachse    lin / log"
    PRINT
    PRINT
    PRINT "  Befehlsfolge  ";
    PRINT "        laden  / anhÑngen  / speichern /  drucken  /  lîschen"
    PRINT
    PRINT "  Bauteile      ";
    PRINT "        laden  / speichern /  drucken  /  lîschen"
    PRINT
    PRINT "  Grafik        ";
    PRINT "        laden  / speichern /  drucken  /  lîschen  ( oder F3 )"
    '
    RESTORE tabelle
    '
    FOR n&=0 TO 8
      READ k&
      BOX 5,k&,634,k&+32
    NEXT n&
    '
  tabelle:
    DATA 56,105,137,169,201,249,297,329,361
    '
    SGET dialogbox1$                        ! Bildschirm aufheben
    dialogbox1_neu&=FALSE
    '
  ELSE
    SPUT dialogbox1$
    PRINT AT(n_item&(2,0),n_item&(2,1));
    betr_swr_drucken(betr_swr_max)
  ENDIF
  '
  raus&=FALSE
  '
  DO
    '
    IF betr_swr_auto&=FALSE                 ! Unterstreichungen
      COLOR schwarz&
      BOX 541,130,578,131
      COLOR weiss&
      BOX 599,130,617,131
    ELSE
      COLOR schwarz&
      BOX 599,130,617,131
      COLOR weiss&
      BOX 541,130,578,131
    ENDIF
    '
    IF betrag_darst&=TRUE
      COLOR schwarz&
      BOX 13,194,64,195
      COLOR weiss&
      BOX 86,194,112,195
    ELSE
      COLOR schwarz&
      BOX 86,194,112,195
      COLOR weiss&
      BOX 13,194,64,195
    ENDIF
    '
    IF betr_swr_darst&=nein&
      COLOR schwarz&
      BOX 310,194,345,195
      COLOR weiss&
      BOX 382,194,410,195
      BOX 447,194,473,195
    ELSE IF betr_swr_darst&=lin&
      COLOR schwarz&
      BOX 382,194,410,195
      COLOR weiss&
      BOX 310,194,345,195
      BOX 447,194,473,195
    ELSE
      COLOR schwarz&
      BOX 447,194,473,195
      COLOR weiss&
      BOX 382,194,410,195
      BOX 310,194,345,195
    ENDIF
    '
    IF phase_darst&=FALSE
      COLOR schwarz&
      BOX 310,226,345,227
      COLOR weiss&
      BOX 382,226,402,227
    ELSE
      COLOR schwarz&
      BOX 382,226,402,227
      COLOR weiss&
      BOX 310,226,345,227
    ENDIF
    '
    IF f_achse&=lin&
      COLOR schwarz&
      BOX 543,274,569,275
      COLOR weiss&
      BOX 591,274,617,275
    ELSE
      COLOR schwarz&
      BOX 591,274,617,275
      COLOR weiss&
      BOX 543,274,569,275
    ENDIF
    '
    n&=box&(item1&)+1
    COLOR schwarz&
    BOX 6,n&,633,n&+30
    BOX 7,n&+1,632,n&+29
    '
    LOCATE n_item&(item1&,0),n_item&(item1&,1)
    taste_holen(taste&)
    '
    SELECT taste&
      '
    CASE links&
      item1&=n_item&(item1&,2)
    CASE rechts&
      item1&=n_item&(item1&,3)
    CASE auf&
      item1&=n_item&(item1&,4)
    CASE ab&
      item1&=n_item&(item1&,5)
    CASE return&
      '
      SELECT item1&
        '
      CASE 3
        betr_swr_auto&=FALSE
      CASE 4
        betr_swr_auto&=TRUE
      CASE 7
        betrag_darst&=TRUE
      CASE 8
        betrag_darst&=FALSE
      CASE 9
        betr_swr_darst&=nein&
      CASE 10
        betr_swr_darst&=lin&
      CASE 11
        betr_swr_darst&=log&
      CASE 12
        phase_darst&=FALSE
      CASE 13
        phase_darst&=TRUE
      CASE 15
        f_achse&=lin&
      CASE 16
        f_achse&=log&
      CASE 17
        befehle_laden
        raus&=TRUE
      CASE 18
        befehle_anhaengen
        raus&=TRUE
      CASE 19
        befehle_speichern
      CASE 20
        befehle_drucken
      CASE 21
        befehle_loeschen
      CASE 22
        bauteile_laden
        raus&=TRUE
      CASE 23
        bauteile_speichern
      CASE 24
        bauteile_drucken
      CASE 25
        bauteile_loeschen
      CASE 26
        grafik_laden
        raus&=TRUE
      CASE 27
        grafik_speichern
        SPUT dialogbox1$
      CASE 28
        grafik_drucken
      CASE 29
        grafik_loeschen
      ENDSELECT
      item1&=n_item&(item1&,6)
      '
    CASE f1&
      raus&=TRUE
      eingabe&=2
      '
    CASE f3&
      grafik_loeschen
      '
    CASE f5&
      zeige_grafik&=TRUE
      raus&=TRUE
      '
    CASE f10&
      raus&=TRUE
      zeichne_kurve&=TRUE
      '
    CASE help&
      help_bearbeitung
      '
    CASE esc&
      alarmbox("| Programm beenden ? |||       j / n|")
      IF antw&=jk& OR antw&=jg&
        prog_ende&=TRUE
        raus&=TRUE
      ENDIF
      '
    CASE 44,46,48 TO 57              ! Punkt, Komma oder Ziffern 0 ... 9 ?
      FOR k&=0 TO 20
        KEYPRESS delete&
      NEXT k&
      IF taste&=44 OR taste&=46      ! Punkt oder Komma ?
        KEYPRESS 48                  ! dann eine 0 voransetzen
      ENDIF
      KEYPRESS taste&
      '
      SELECT item1&
      CASE 0
        e$="                    "
        FORM INPUT 20 AS e$
        e$=TRIM$(e$)
        f_min=FN wert(e$)
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));
        PRINT FN wert$(f_min,12,0);"Hz     "
      CASE 1
        e$="                    "
        FORM INPUT 20 AS e$
        e$=TRIM$(e$)
        f_max=FN wert(e$)
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));
        PRINT FN wert$(f_max,12,0);"Hz     "
      CASE 2
        e$="          "
        FORM INPUT 10 AS e$
        betr_swr_max=FN wert(e$)
        IF betr_swr_max=0
          betr_swr_max=2
          PRINT CHR$(7);
        ENDIF
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));
        betr_swr_drucken(betr_swr_max)
        betr_swr_auto&=FALSE
      CASE 5
        e$=" "
        FORM INPUT 3 AS e$
        daempf_max=ABS(VAL(e$))
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));STR$(daempf_max,3);
      CASE 6
        e$="      "
        FORM INPUT 6 AS e$
        w=FN wert(e$)
        IF w<9999 AND w>0.01
          wellenwiderstand=w
        ELSE
          PRINT CHR$(7);
        ENDIF
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));
        PRINT STR$(wellenwiderstand,7,2);
      CASE 14
        IF taste&>48 AND taste&<58
          schrittweite&=taste&-48
        ENDIF
        PRINT AT(n_item&(item1&,0),n_item&(item1&,1));schrittweite&
      ENDSELECT
      '
      REPEAT                         ! sonst Gefahr einer Endlosschleife
      UNTIL INKEY$=""                ! bei Eingabe von Delete etc.
      '
      item1&=n_item&(item1&,6)
      '
    ENDSELECT
    '
    IF n&<>box&(item1&)+1 OR raus&=TRUE
      COLOR weiss&
      BOX 6,n&,633,n&+30
      BOX 7,n&+1,632,n&+29
    ENDIF
    '
    SGET dialogbox1$
    EXIT IF raus&=TRUE
    '
  LOOP
  '
RETURN
'
PROCEDURE dialogbox2
  '
  LOCAL a$,e$,element%,raus&,einf&,itemalt&,listenlaenge&,flag&
  LOCAL li&,zeile&,taste&,n&
  '
  GRAPHMODE 1                                      ! normal
  COLOR schwarz&
  '
  IF dialogbox2_neu&=TRUE                          ! Dialogbox 2 aufbauen
    '
    CLS
    PRINT
    PRINT " andere Eingaben: F1   anschauen: F5";
    PRINT "   zeichnen: F10   Hilfe: Help    Ende: Esc"
    a$="       Befehle          R in Ohm            C in Far"
    TEXT 10,71,a$+"ad         L in Henry"
    PRINT CHR$(esc&);"f";                          ! Cursor aus
    '
    schreibe_spalte(0)
    '
    MAT CPY bauteil()=r()
    schreibe_spalte(1)
    '
    MAT CPY bauteil()=c()
    schreibe_spalte(2)
    '
    MAT CPY bauteil()=l()
    schreibe_spalte(3)
    '
    COLOR schwarz&
    BOX 5,50,635,76
    BOX 5,76,635,339
    DRAW 159,51 TO 159,338
    DRAW 316,51 TO 316,338
    DRAW 473,51 TO 473,338
    '
    PRINT AT(3,23);"Steuertasten:       Pfeile,  Insert,  Delete,  ";
    PRINT "Backspace,  Clr Home,  Return"
    a$="Eine ganze Bauteilspalte lîschen :    Control/Clr Home"
    TEXT 80,387,a$
    '
    dialogbox2_neu&=FALSE
    SGET dialogbox2$                        ! Dialogbox 2 speichern
    '
  ELSE
    SPUT dialogbox2$                        ! schneller als Neuaufbau
  ENDIF
  '
  raus&=FALSE
  flag&=FALSE
  einf&=FALSE
  '
  DO
    '
    itemalt&=item2&
    '
    COLOR schwarz&
    '
    LET listenlaenge&=99             ! 0..99 Bauteile, aber 0..999 Befehle
    IF item2&=0
      BOX 6,77,158,338               ! fette Umrandung
      BOX 7,78,157,337
      LET listenlaenge&=999
    ELSE IF item2&=1
      BOX 160,77,315,338
      BOX 161,78,314,337
      MAT CPY bauteil()=r()          ! kopieren zur Bearbeitung
    ELSE IF item2&=2
      BOX 317,77,472,338
      BOX 318,78,471,337
      MAT CPY bauteil()=c()
    ELSE IF item2&=3
      BOX 474,77,634,338
      BOX 475,78,633,337
      MAT CPY bauteil()=l()
    ENDIF
    '
    li&=li_ob&(item2&)*8-8           ! linke obere Ecke der Spalte (x-Wert)
    '
    FOR zeile&=0 TO 15               ! die aktuelle Spalte neu schreiben
      schreibe_befehl_oder_wert(item2&,zeile&)
    NEXT zeile&
    '
    REPEAT
      '
      ' in dieser Schleife geht es nur in einer der vier Spalten
      ' rauf und runter
      '
      ' nun plazieren wir den Cursor in der aktuellen Spalte item2&
      ' auf zeile&(item2&) :
      '
      LOCATE li_ob&(item2&)+5,zeile&(item2&)+6
      '
      IF flag&=FALSE
        taste_holen(taste&)
      ELSE
        taste&=insert&
      ENDIF
      '
      IF taste&=auf&                               ! Pfeil nach oben ?
        DEC zeile&(item2&)                         ! Cursor nach oben
        IF zeile&(item2&)<0                        ! mit Anschlag
          zeile&(item2&)=0
          DEC oberst&(item2&)                      ! Spalte nach unten
          IF oberst&(item2&)<0
            oberst&(item2&)=0
          ELSE
            GET li&,80,li&+128,319,streifen$
            PUT li&,96,streifen$
            schreibe_befehl_oder_wert(item2&,0)
          ENDIF
        ENDIF
      ENDIF
      '
      element%=befehl&(oberst&(0)+zeile&(0))       ! 16 Bit
      IF item2&>0
        element%=1
      ENDIF
      '
      IF (taste&=ab& OR taste&=return&) AND (element%>0)
        INC zeile&(item2&)
        IF zeile&(item2&)>15
          zeile&(item2&)=15
          INC oberst&(item2&)
          IF oberst&(item2&)>listenlaenge&-15
            oberst&(item2&)=listenlaenge&-15       ! Spalte nach oben
          ELSE
            GET li&,96,li&+128,336,streifen$
            PUT li&,80,streifen$
            schreibe_befehl_oder_wert(item2&,15)
          ENDIF
        ENDIF
      ENDIF
      '
      flag&=FALSE
      IF taste&=ab& AND einf&=TRUE
        flag&=TRUE
      ENDIF
      '
    UNTIL taste&<>auf& AND taste&<>ab& AND taste&<>return&
    '
    SELECT taste&
      '
    CASE clrhome&
      oberst&(item2&)=0                     ! ganz nach oben
      zeile&(item2&)=0
      '
    CASE control_clrhome&
      oberst&(item2&)=0                     ! ganze Bauteilspalte lîschen
      zeile&(item2&)=0
      IF item2&=1
        ARRAYFILL r(),0
      ELSE IF item2&=2
        ARRAYFILL c(),0
      ELSE IF item2&=3
        ARRAYFILL l(),0
      ENDIF
      '
    CASE links&                             ! eine Spalte nach links
      DEC item2&
      IF item2&<0
        item2&=0
      ENDIF
      '
    CASE rechts&                            ! eine Spalte nach rechts
      INC item2&
      IF item2&>3
        item2&=3
      ENDIF
      '
    CASE delete&
      IF item2&=0
        DELETE befehl&(oberst&(item2&)+zeile&(item2&))    ! ganzen Befehl
      ELSE                                                ! lîschen
        bauteil(oberst&(item2&)+zeile&(item2&))=0         ! ganzes Bauteil
        aenderungen_merken                                ! lîschen
      ENDIF
      '
    CASE insert&
      IF item2&=0
        IF befehl&(999)=0
          einf&=TRUE
          INSERT befehl&(oberst&(0)+zeile&(0))=0          ! Befehl einfÅgen
          KEYPRESS leertaste&
        ELSE
          alarmbox("|  Kein Platz mehr !  |||       Taste !|")
          einf&=FALSE
          flag&=FALSE
        ENDIF
      ENDIF
      '
    CASE f1&                                       ! zu Dialogbox 1
      raus&=TRUE
      eingabe&=1
      '
    CASE f3&
      grafik_loeschen
      '
    CASE f10&                                      ! Ende der Eingabe
      zeichne_kurve&=TRUE
      raus&=TRUE
      '
    CASE esc&
      alarmbox("| Programm beenden ? |||       j / n|")
      IF antw&=jk& OR antw&=jg&
        prog_ende&=TRUE
        raus&=TRUE
      ENDIF
      '
    CASE f5&
      zeige_grafik&=TRUE
      raus&=TRUE
      '
    CASE help&
      help_bearbeitung
      '
    CASE 32,42 TO 57,65 TO 90,97 TO 122,126
      '
      IF item2&=0 AND taste&<>44 AND taste&<>46
        FOR n&=0 TO 6                ! Alten Befehl lîschen
          KEYPRESS delete&
        NEXT n&
        KEYPRESS taste&              ! Tastendruck darf nicht verloren gehen
        IF einf&=TRUE
          KEYPRESS backspace&
        ENDIF
        PRINT "          "           ! Åberschreibt alten Eintrag
        LOCATE li_ob&(item2&)+5,zeile&(item2&)+6
        FORM INPUT 8,e$
        e$=TRIM$(e$)                 ! vorne und hinten Blanks weg
        befehlein(e$)
      ENDIF
      '
      IF item2&>0
        FOR n&=0 TO 13               ! Alten Wert lîschen
          KEYPRESS delete&
        NEXT n&
        IF taste&=44 OR taste&=46    ! Punkt oder Komma ?
          KEYPRESS 48                ! dann eine 0 voransetzen
        ENDIF
        KEYPRESS taste&              ! Tastendruck darf nicht verloren gehen
        PRINT "           "          ! Åberschreibt alten Eintrag
        LOCATE li_ob&(item2&)+5,zeile&(item2&)+6
        FORM INPUT 10,e$
        e$=TRIM$(e$)                 ! vorne und hinten Blanks weg
        bauteilein(e$)
      ENDIF
      '
    ENDSELECT
    '
    IF item2&<>itemalt& OR raus&=TRUE       ! Umrahmung entfernen
      COLOR weiss&
      IF itemalt&=0
        BOX 6,77,158,338                    ! fette Umrandung
        BOX 7,78,157,337
      ELSE IF itemalt&=1
        BOX 160,77,315,338
        BOX 161,78,314,337
      ELSE IF itemalt&=2
        BOX 317,77,472,338
        BOX 318,78,471,337
      ELSE
        BOX 474,77,634,338
        BOX 475,78,633,337
      ENDIF
    ENDIF
    '
    SGET dialogbox2$                 ! mit énderungen speichern
    '
    EXIT IF raus&=TRUE
    '
  LOOP
  '
RETURN
'
PROCEDURE schreibe_spalte(spalte&)
  '
  LOCAL zeile&
  '
  FOR zeile&=0 TO 15
    schreibe_befehl_oder_wert(spalte&,zeile&)
  NEXT zeile&
  '
RETURN
'
PROCEDURE schreibe_befehl_oder_wert(spalte&,zeile&)
  '
  LOCAL element%,nummer&,ausgabe$
  '
  nummer&=oberst&(spalte&)+zeile&
  ausgabe$=STR$(nummer&,3)+"  "
  IF spalte&=0                                     ! es ist ein Befehl
    element%=befehl&(nummer&)
    ausgabe$=ausgabe$+befehl$(element% AND 255)
    IF element%>255                                ! eine Adresse ist dabei
      ausgabe$=ausgabe$+STR$((element% AND 65280)/256-1,3)
    ELSE
      ausgabe$=ausgabe$+"    "
    ENDIF
  ELSE                                             ! es ist ein Bauteilwert
    ausgabe$=ausgabe$+FN wert$(bauteil(nummer&),8,0)
  ENDIF
  PRINT AT(li_ob&(spalte&),zeile&+6);ausgabe$;
  '
RETURN
'
PROCEDURE befehlein(e$)
  '
  LOCAL befehl$,befehl&,blank_pos&,fehler&,nummer&,n&
  '
  IF e$=""                                         ! nur alles gelîscht ?
    DELETE befehl&(oberst&(item2&)+zeile&(item2&)) ! ganzen Befehl lîschen
    einf&=FALSE
  ELSE
    IF e$="s" OR e$="S"                            ! zur Vereinfachung
      e$="ser"                                     ! der Eingabe
    ENDIF
    IF e$="p" OR e$="P"
      e$="par"
    ENDIF
    IF LEFT$(e$)="~"
      e$="~~~~~"
    ENDIF
    blank_pos&=INSTR(e$," ")
    nummer&=0                 ! Nummer des Bauteils oder des Speicherplatzes
    IF blank_pos&>0                         ! Wurde eine Nummer eingegeben ?
      nummer&=VAL(MID$(e$,blank_pos&))+1    ! Nummern > 0 !
      e$=LEFT$(e$,blank_pos&-1)             ! in e$ ist jetzt der Befehl
    ENDIF
    befehl$="     "                         ! nun wird der eingegebene Befehl
    LSET befehl$=e$                         ! in der Liste der Befehle gesucht
    befehl&=0
    FOR n&=1 TO anzahl_bef&
      IF UPPER$(befehl$)=UPPER$(befehl$(n&))
        befehl&=n&                          ! Befehlsnummer
      ENDIF
    NEXT n&
    '
    fehler&=FALSE
    '
    IF befehl&=0 OR nummer&>100             ! unbekannter Befehl
      fehler&=TRUE                          ! oder zu groûe Registernummer
    ENDIF
    '
    ' auf die Befehle Nr. 1 2 3 7 und 8 muû eine Nummer folgen:
    IF nummer&=0 AND INSTR("12378",STR$(befehl&))>0
      fehler&=TRUE
    ENDIF
    '
    ' auf die Åbrigen Befehle darf keine Nummer folgen:
    IF nummer&>0 AND NOT INSTR("12378",STR$(befehl&))>0
      fehler&=TRUE
    ENDIF
    '
    IF fehler&=FALSE
      befehl&(oberst&(item2&)+zeile&(item2&))=befehl&+256*nummer&
      KEYPRESS ab&                          ! Cursor runter
    ELSE
      PRINT CHR$(7);                        ! Ping !
      IF einf&=TRUE
        KEYPRESS leertaste&
      ENDIF
    ENDIF
    '
  ENDIF
  '
RETURN
'
PROCEDURE bauteilein(e$)
  '
  IF e$=""                                         ! nur alles gelîscht ?
    DELETE bauteil(oberst&(item2&)+zeile&(item2&)) ! ganzes Bauteil lîschen
  ELSE
    bauteil(oberst&(item2&)+zeile&(item2&))=FN wert(e$)
    KEYPRESS ab&                                   ! Pfeil runter
  ENDIF
  aenderungen_merken
  '
RETURN
'
PROCEDURE aenderungen_merken
  '
  IF item2&=1
    MAT CPY r()=bauteil()
  ELSE IF item2&=2
    MAT CPY c()=bauteil()
  ELSE IF item2&=3
    MAT CPY l()=bauteil()
  ENDIF
  '
RETURN
'
PROCEDURE kurve_zeichnen
  '
  LOCAL a$,p,q,r,s,f,y,omega,re,im,exp_fakt,daempf,zeile%,st_z&,befehl&
  LOCAL x&,x_alt&,y_alt,p_x_alt&,p_y_alt,addr&,fehler&,n&
  '
  zeichne_kurve&=FALSE
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  ' Zuerst wird ÅberprÅft, ob ein offensichtlicher Fehler vorliegt
  '
  fehler&=FALSE
  '
  IF befehl&(0)=0
    fehler&=TRUE
    alarmbox("| ohne Befehle geht's nicht |||          Taste !|")
  ENDIF
  '
  IF f_max<=f_min
    fehler&=TRUE
    a$="| f max   muû grîûer sein als   f min  ! |||               Taste !|"
    alarmbox(a$)
  ENDIF
  '
  IF f_min=0 AND f_achse&=log&
    fehler&=TRUE
    a$="| Bei logarithmischer Teilung | der Frequenzachse ||"
    a$=a$+" darf  f min  nicht 0 sein ! |||           Taste !|"
    alarmbox(a$)
  ENDIF
  '
  IF fehler&=FALSE
    '
    befehlz&=0                       ! Hier wird ÅberprÅft, ob irgendwelche
    n&=0
    '
    WHILE befehl&(befehlz&)>0        ! der verwendeten Bauteile den Wert 0
      '
      zeile%=befehl&(befehlz&)       ! besitzen
      INC befehlz&
      befehl&=(zeile% AND 255)       ! der Befehlscode steht im rechten Byte
      '                                des 16-Bit-Wortes
      addr&=(zeile% AND 65280)/256-1 ! evtl. vorhandene Bauteil- oder
      '                                Speichernummer
      '
      SELECT befehl&
        '
      CASE 1
        '
        ' R
        '
        IF r(addr&)=0
          INC n&
        ENDIF
        '
      CASE 2
        '
        ' C
        '
        IF c(addr&)=0
          INC n&
        ENDIF
        '
      CASE 3
        '
        ' L
        '
        IF l(addr&)=0
          INC n&
        ENDIF
        '
      ENDSELECT
      '
    WEND
    '
    IF n&>0
      fehler&=TRUE
      a$="|                      Warnung !||"
      IF n&=1
        a$=a$+" Ein in der Schaltung verwendetes Bauteil hat den Wert 0 ! "
      ELSE
        a$=a$+" Einige in der Schaltung verwendete Bau"
        a$=a$+"teile haben den Wert 0 ! "
      ENDIF
      a$=a$+"|||               Return :   die Sache geht in Ordnung"
      a$=a$+"||         andere Taste :   abbrechen|"
      alarmbox(a$)
      IF antw&=return&
        fehler&=FALSE
      ENDIF
    ENDIF
    '
  ENDIF
  '
  IF betr_swr_darst&=nein& AND phase_darst&=FALSE AND betr_swr_auto&=FALSE
    fehler&=TRUE
    a$="| Es wurden Einstellungen gewÑhlt, bei denen nichts zu tun ist ! |||"
    a$=a$+"                         Taste !|"
    alarmbox(a$)
  ENDIF
  '
  ' öberprÅfung auf offensichtliche Fehler beendet, Rechnungen beginnen
  '
  IF fehler&=FALSE            ! natÅrlich nur, wenn kein Fehler erkannt wurde
    '
    ARRAYFILL betr_swr(),0    ! Liste der Betragswerte lîschen
    '
    SPUT kurve$               ! Es wird Åber die vorhandene Grafik gezeichnet
    '                           beim erstenmal ist kurve$ natÅrlich leer
    IF f_achse&=log&
      exp_fakt=LOG(f_max/f_min)/639         ! spart weiter unten Rechenzeit
    ENDIF
    '
    FOR x&=0 TO 639 STEP schrittweite&             ! Beginn der Hauptschleife
      '                                              zur Kurvenberechnung
      EXIT IF INP?(2)=TRUE OR fehler&=TRUE         ! Abbruch mit bel. Taste
      '
      IF f_achse&=lin&
        f=f_min+x&*(f_max-f_min)/640
        IF f<f_max/1000              ! Verhindert Division durch 0 bei f=0
          f=f_max/1000
        ENDIF
      ELSE
        f=f_min*EXP(x&*exp_fakt)     ! log. Teilung der Frequenzachse
      ENDIF
      '
      omega=2*PI*f
      st_z&=-1                       ! Stapelzeiger auf letzten belegten Platz
      '                                es ist allerdings keiner belegt
      befehlz&=0                     ! Befehlszeiger auf den ersten Befehl
      '
      ' In der folgenden WHILE- Schleife wird die Befehlsfolge fÅr eine
      ' bestimmte Frequenz f einmal abgearbeitet
      '
      WHILE befehl&(befehlz&)>0             ! 0: Ende der Befehlsfolge
        '
        zeile%=befehl&(befehlz&)
        befehl&=(zeile% AND 255)            ! der Befehlscode steht im rechten
        '                                     Byte des 16-Bit-Wortes
        addr&=(zeile% AND 65280)/256-1      ! evtl. vorhandene Bauteil- oder
        '                                     Speichernummer
        '
        SELECT befehl&
          '
        CASE 1
          '
          ' R
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=r(addr&)
          st_i(st_z&)=0
          '
        CASE 2
          '
          ' C
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=0
          st_i(st_z&)=-1/(omega*c(addr&))
          '
        CASE 3
          '
          ' L
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=0
          st_i(st_z&)=omega*l(addr&)
          '
        CASE 4,16
          '
          ' + ser
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          DEC st_z&
          st_r(st_z&)=st_r(st_z&)+st_r(st_z&+1)
          st_i(st_z&)=st_i(st_z&)+st_i(st_z&+1)
          '
        CASE 5
          '
          ' par
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          p=st_r(st_z&)+st_r(st_z&-1)
          q=st_i(st_z&)+st_i(st_z&-1)
          r=st_r(st_z&)*st_r(st_z&-1)-st_i(st_z&)*st_i(st_z&-1)
          s=st_r(st_z&)*st_i(st_z&-1)+st_i(st_z&)*st_r(st_z&-1)
          DEC st_z&
          st_r(st_z&)=(r*p+s*q)/(p*p+q*q)
          st_i(st_z&)=(s*p-r*q)/(p*p+q*q)
          '
        CASE 6
          '
          ' dup
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          test_stack(1)
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=st_r(st_z&-1)
          st_i(st_z&)=st_i(st_z&-1)
          '
        CASE 7
          '
          ' sto
          '
          test_stack(1)
          EXIT IF fehler&=TRUE
          sp_r(addr&)=st_r(st_z&)
          sp_i(addr&)=st_i(st_z&)
          '
        CASE 8
          '
          ' rcl
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=sp_r(addr&)
          st_i(st_z&)=sp_i(addr&)
          '
        CASE 9
          '
          ' /
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          DEC st_z&
          p=st_r(st_z&)*st_r(st_z&+1)+st_i(st_z&)*st_i(st_z&+1)
          q=st_i(st_z&)*st_r(st_z&+1)-st_r(st_z&)*st_i(st_z&+1)
          r=st_r(st_z&+1)^2+st_i(st_z&+1)^2
          st_r(st_z&)=p/r
          st_i(st_z&)=q/r
          '
        CASE 10
          '
          ' *
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          DEC st_z&
          p=st_r(st_z&)
          q=st_i(st_z&)
          r=st_r(st_z&+1)
          s=st_i(st_z&+1)
          st_r(st_z&)=p*r-q*s
          st_i(st_z&)=q*r+p*s
          '
        CASE 11
          '
          ' drop
          '
          test_stack(1)
          EXIT IF fehler&=TRUE
          DEC st_z&
          '
        CASE 12
          '
          ' swap
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          SWAP st_r(st_z&),st_r(st_z&-1)
          SWAP st_i(st_z&),st_i(st_z&-1)
          '
        CASE 13
          '
          ' over
          '
          test_stack_voll
          EXIT IF fehler&=TRUE
          test_stack(2)
          EXIT IF fehler&=TRUE
          INC st_z&
          st_r(st_z&)=st_r(st_z&-2)
          st_i(st_z&)=st_i(st_z&-2)
          '
        CASE 14
          '
          ' rot
          '
          test_stack(3)
          EXIT IF fehler&=TRUE
          SWAP st_r(st_z&),st_r(st_z&-2)
          SWAP st_i(st_z&),st_i(st_z&-2)
          SWAP st_r(st_z&-1),st_r(st_z&-2)
          SWAP st_i(st_z&-1),st_i(st_z&-2)
          '
        CASE 15
          '
          ' inv
          '
          test_stack(1)
          EXIT IF fehler&=TRUE
          p=st_r(st_z&)
          q=st_i(st_z&)
          st_r(st_z&)=p/(p*p+q*q)
          st_i(st_z&)=-q/(p*p+q*q)
          '
        CASE 17
          '
          ' -
          '
          test_stack(2)
          EXIT IF fehler&=TRUE
          DEC st_z&
          st_r(st_z&)=st_r(st_z&)-st_r(st_z&+1)
          st_i(st_z&)=st_i(st_z&)-st_i(st_z&+1)
          '
        CASE 18
          '
          ' cstk = lîsche ganzen Stapel
          '
          st_z&=-1
          '
        CASE 20
          '
          ' conj = bilde konjugiert komplexe Zahl
          '
          test_stack(1)
          EXIT IF fehler&=TRUE
          st_i(st_z&)=-st_i(st_z&)
          '
        ENDSELECT
        '
        INC befehlz&                                      ! nÑchster Befehl
        '
      WEND
      '
      ' bei einem der obigen test_ ... Unterprogramme kînnte fehler& = TRUE
      ' gesetzt worden sein, deshalb:
      '
      IF fehler&=FALSE
        '
        ' das Ergebnis befindet sich jetzt in st_r(st_z&), st_i(st_z&)
        '
        re=st_r(st_z&)                      ! Realteil des Ergebnisses
        im=st_i(st_z&)                      ! ImaginÑrteil des Ergebnisses
        '
        IF betrag_darst&=TRUE
          y=SQR(re^2+im^2)
        ELSE                                ! StehwellenverhÑltnis berechnen
          y=SQR(((re-wellenwiderstand)^2+im^2)/((re+wellenwiderstand)^2+im^2))
          IF ABS(1-y)<0.00001
            y=0.99999
          ENDIF
          y=(1+y)/(1-y)
        ENDIF
        betr_swr(x&)=y                      ! berechneten Wert speichern
        '
        IF betr_swr_auto&=FALSE AND betr_swr_darst&<>nein&
          ' dann mÅssen wir den gerade berechneten Wert
          ' gleich in die Grafik einzeichnen
          '
          y=y/betr_swr_max
          IF betr_swr_darst&=lin&
            y=400-400*y
          ELSE
            IF y>0
              y=-8000*LOG10(y)/daempf_max
            ELSE
              y=400
            ENDIF
          ENDIF
          '
          IF y<0
            y=0
          ENDIF
          IF y>399
            y=399
          ENDIF
          '
          IF x&=0             ! damit die erste kleine Strecke links
            x_alt&=x&         ! auf der richtigen Hîhe beginnt
            y_alt=y
          ENDIF
          '
          DRAW x_alt&,y_alt TO x&,y         ! kleine Strecke
          x_alt&=x&
          y_alt=y
          '
        ENDIF
        '
        IF betr_swr_auto&=TRUE AND phase_darst&=FALSE
          ' in diesem Fall ist wÑhrend der Berechnung nichts zu zeichnen
          '
          PRINT AT(30,12);"Bitte warten .. ";STR$(640-x&,3)
        ENDIF
        '
        IF phase_darst&=TRUE
          ' dann kînnen wir jedenfalls wÑhrend der Berechnung
          ' schon den Phasenverlauf zeichnen
          '
          p=st_r(st_z&)
          q=st_i(st_z&)
          IF p>0
            y=ATN(q/p)
          ENDIF
          IF p<0 AND q>0
            y=PI+ATN(q/p)
          ENDIF
          IF p<0 AND q<0
            y=ATN(q/p)-PI
          ENDIF
          IF p=0
            y=SGN(q)*PI/2
          ENDIF
          y=200-200*y/PI
          IF x&=0 THEN
            p_x_alt&=x&
            p_y_alt=y
          ENDIF
          DRAW p_x_alt&,p_y_alt TO x&,y
          p_x_alt&=x&
          p_y_alt=y
          '
        ENDIF
        '
      ENDIF
      '
    NEXT x&
    '
    ' Die Berechnungen sind beendet
    '
    IF fehler&=FALSE
      '
      IF betr_swr_auto&=TRUE
        '
        betr_swr_max=0                             ! grîûten Betrag suchen
        FOR x&=0 TO 639 STEP schrittweite&
          IF betr_swr_max<betr_swr(x&)
            betr_swr_max=betr_swr(x&)
          ENDIF
        NEXT x&
        '
        IF betr_swr_max=0
          '
          e$="| Hier stimmt wohl etwas nicht !|||"
          e$=e$+" Der Maximalwert aller BetrÑge / SWRs ist Null||||"
          e$=e$+" Das Programm wird mit dem EingabemenÅ fortgesetzt ||"
          e$=e$+" Befehle und Bauteilwerte sind noch vorhanden  (?)|||"
          e$=e$+"                   Taste !|"
          alarmbox(e$)
          '
          betr_swr_max=2
          '
          zeige_grafik&=FALSE
          zeichne_kurve&=FALSE
          dialogbox2_neu&=TRUE
          dialogbox1_neu&=TRUE
          '
          fehler&=TRUE
          '
        ENDIF
        '
        IF phase_darst&=FALSE
          SPUT kurve$
        ENDIF
        '
        IF fehler&=FALSE
          '
          IF betr_swr_darst&<>nein&
            FOR x&=0 TO 639 STEP schrittweite&
              y=betr_swr(x&)/betr_swr_max
              IF betr_swr_darst&=lin&
                y=400-400*y
              ELSE
                IF y>0
                  y=-8000*LOG10(y)/daempf_max
                ELSE
                  y=400
                ENDIF
              ENDIF
              '
              IF y<0
                y=0
              ENDIF
              IF y>399
                y=399
              ENDIF
              '
              IF x&=0
                x_alt&=x&
                y_alt=y
              ENDIF
              DRAW x_alt&,y_alt TO x&,y
              x_alt&=x&
              y_alt=y
            NEXT x&
          ENDIF
          '
        ENDIF
        '
      ENDIF
      '
      IF phase_darst&=TRUE
        DRAW 0,200 TO 639,200
        DEFLINE 5
        DRAW 0,100 TO 639,100
        DRAW 0,300 TO 639,300
        DEFLINE 1
      ENDIF
      '
      SGET bild$       ! damit die folgenden Angaben nicht in kurve$ stehen
      '
      ' Bild fertig
      '
      IF phase_darst&=TRUE
        TEXT 600,95,"+90"
        TEXT 616,195,"0"
        TEXT 600,295,"-90"
      ENDIF
      '
      IF betr_swr_darst&=lin& AND betr_swr_auto&=FALSE
        PRINT AT(2,2);
        betr_swr_drucken(betr_swr_max)
      ENDIF
      '
      IF betr_swr_darst&=log&
        a$=STR$(-daempf_max)+" dB"
        PRINT AT(40,24);TRIM$(a$)
      ENDIF
      '
      IF betr_swr_darst&<>nein& OR phase_darst&=TRUE
        '
        a$=FN wert$(f_min,12,0)+"Hz"
        PRINT AT(2,24);TRIM$(a$)
        '
        a$=FN wert$(f_max,12,0)+"Hz"
        PRINT AT(62,24);TRIM$(a$)
        '
        ~INP(2)
        REPEAT
          a$="| neue Kurve(n) Åberne"
          a$=a$+"hmen: Return ||                verwerfen: Undo |"
          alarmbox(a$)
        UNTIL antw&=return& OR antw&=undo&
        '
        IF antw&=return&
          kurve$=bild$
        ENDIF
        '
      ENDIF
      '
    ENDIF
    '
    item1&=14
    '
  ENDIF
  '
RETURN
'
PROCEDURE befehle_laden
  '
  LOCAL kopf$,anz&,n&
  '
  FILESELECT #"Befehlsfolge laden",pfad$+"*.BEF",dnam$+".BEF",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    IF EXIST(datei$)
      OPEN "I",#1,datei$
      anz&=LOF(#1)-4
      IF anz&>=0
        kopf$=""
        FOR n&=1 TO 4
          kopf$=kopf$+CHR$(INP(#1))
        NEXT n&
        IF kopf$="BEFE"
          ARRAYFILL befehl&(),0
          BGET #1,VARPTR(befehl&(0)),anz&
          oberst&(0)=0
          zeile&(0)=0
          item2&=0
          neu_pfad_u_vorgabe
          dialogbox1_neu&=TRUE
        ELSE
          alarmbox("| Keine RCL-Befehlsdatei ! |||         Taste !|")
        ENDIF
      ELSE
        alarmbox("| Keine RCL-Befehlsdatei ! |||         Taste !|")
      ENDIF
      CLOSE #1
    ELSE
      alarmbox("| Datei existiert nicht ! |||         Taste !|")
    ENDIF
  ENDIF
  '
RETURN
'
PROCEDURE befehle_anhaengen
  '
  LOCAL a$,kopf$,n&,anz&,anz2&
  '
  FILESELECT #"Befehlsfolge anhÑngen",pfad$+"*.BEF",dnam$+".BEF",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    IF EXIST(datei$)
      anz&=0
      WHILE befehl&(anz&)<>0
        INC anz&
      WEND
      OPEN "I",#1,datei$
      IF LOF(#1)>=4
        anz2&=(LOF(#1)-4)/2
        kopf$=""
        FOR n&=1 TO 4
          kopf$=kopf$+CHR$(INP(#1))
        NEXT n&
        IF kopf$="BEFE"
          IF anz&+anz2&<1000
            BGET #1,VARPTR(befehl&(0))+2*anz&,anz2&*2
            dialogbox1_neu&=TRUE
          ELSE
            a$="|      Platz reicht nicht !|| zusammen mehr als 999 Bef"
            a$=a$+"ehle |||           Taste !|"
            alarmbox(a$)
          ENDIF
        ELSE
          alarmbox("| Keine RCL-Befehlsdatei ! |||         Taste !|")
        ENDIF
      ELSE
        alarmbox("| Keine RCL-Befehlsdatei ! |||         Taste !|")
      ENDIF
      CLOSE #1
      item2&=0
      neu_pfad_u_vorgabe
    ELSE
      alarmbox("| Datei existiert nicht ! |||         Taste !|")
    ENDIF
  ENDIF
  '
RETURN
'
PROCEDURE befehle_speichern
  '
  LOCAL anz&
  '
  FILESELECT #"Befehlsfolge speichern",pfad$+"*.BEF",dnam$+".BEF",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    IF INSTR(datei$,".")=0
      datei$=datei$+".BEF"
    ENDIF
    anz&=0
    WHILE befehl&(anz&)<>0
      INC anz&
    WEND
    OPEN "O",#1,datei$
    OUT #1,66,69,70,69                      ! B E F E  als Dateikennung
    BPUT #1,VARPTR(befehl&(0)),2*anz&
    CLOSE #1
    neu_pfad_u_vorgabe
  ENDIF
  '
RETURN
'
PROCEDURE befehle_drucken
  '
  LOCAL a$,wort%,n&,zeile&,spalte&
  '
  n&=0                               ! Befehle zÑhlen
  DO
    wort%=befehl&(n&)
    EXIT IF wort%=0
    INC n&
  LOOP
  '
  IF n&=0
    '
    a$="|Es sind keine Befehle vorhanden|||           Taste !|"
    alarmbox(a$)
    '
  ELSE
    '
    IF GEMDOS(17)=TRUE
      drucker_initialisieren
      LPRINT
      LPRINT
      LPRINT "Befehlsfolge zu  ";dnam$
      LPRINT
      '
      DEC n&
      spaltenlaenge&=n&/4
      '
      FOR zeile&=0 TO spaltenlaenge&
        '
        FOR spalte&=0 TO 3
          '
          a$=STR$(zeile&+(spaltenlaenge&+1)*spalte&,3)+"   "
          wort%=befehl&(zeile&+(spaltenlaenge&+1)*spalte&)
          a$=a$+befehl$(wort% AND 255)
          IF wort%>255                             ! eine Adresse ist dabei
            a$=a$+STR$((wort% AND 65280)/256-1,3)
          ELSE
            a$=a$+"   "
          ENDIF
          IF wort%<>0
            LPRINT a$;
          ENDIF
          IF spalte&<3
            LPRINT "      ";
          ENDIF
          '
        NEXT spalte&
        LPRINT
        '
      NEXT zeile&
      '
    ELSE
      alarmbox("| Drucker nicht bereit ! |||        Taste !|")
    ENDIF
    '
  ENDIF
  '
RETURN
'
PROCEDURE befehle_loeschen
  '
  alarmbox("| Befehle lîschen ? |||       j / n|")
  IF antw&=jk& OR antw&=jg&
    ARRAYFILL befehl&(),0
    oberst&(0)=0
    zeile&(0)=0
  ENDIF
  '
RETURN
'
PROCEDURE bauteile_laden
  '
  LOCAL kopf$,r,c,l,n&
  '
  FILESELECT #"Bauteile laden",pfad$+"*.BAU",dnam$+".BAU",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    IF EXIST(datei$)
      ARRAYFILL r(),0
      ARRAYFILL c(),0
      ARRAYFILL l(),0
      OPEN "I",#1,datei$
      IF LOF(#1)>=4
        kopf$=""
        FOR n&=1 TO 4
          kopf$=kopf$+CHR$(INP(#1))
        NEXT n&
        IF kopf$="BAUT"
          BGET #1,VARPTR(f_min),8
          BGET #1,VARPTR(f_max),8
          BGET #1,VARPTR(betr_swr_max),8
          BGET #1,VARPTR(daempf_max),8
          BGET #1,VARPTR(wellenwiderstand),8
          BGET #1,VARPTR(betrag_darst&),2
          BGET #1,VARPTR(betr_swr_darst&),2
          BGET #1,VARPTR(phase_darst&),2
          BGET #1,VARPTR(schrittweite&),2
          BGET #1,VARPTR(f_achse&),2
          BGET #1,VARPTR(r),8
          BGET #1,VARPTR(c),8
          BGET #1,VARPTR(l),8
          BGET #1,VARPTR(r(0)),(r+1)*8
          BGET #1,VARPTR(c(0)),(c+1)*8
          BGET #1,VARPTR(l(0)),(l+1)*8
          dialogbox2_neu&=TRUE
          dialogbox1_neu&=TRUE
          betr_swr_auto&=FALSE
        ELSE
          alarmbox("| Keine RCL-Bauteiledatei ! |||         Taste !|")
        ENDIF
      ELSE
        alarmbox("| Keine RCL-Bauteiledatei ! |||         Taste !|")
      ENDIF
      CLOSE #1
      neu_pfad_u_vorgabe
    ELSE
      alarmbox("| Datei existiert nicht ! |||         Taste !|")
    ENDIF
  ENDIF
  '
RETURN
'
PROCEDURE bauteile_speichern
  '
  LOCAL r,c,l
  '
  FILESELECT #"Bauteile speichern",pfad$+"*.BAU",dnam$+".BAU",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    '
    IF INSTR(datei$,".")=0
      datei$=datei$+".BAU"
    ENDIF
    '
    r=99
    DO
      EXIT IF r(r)>0 OR r=0
      DEC r
    LOOP
    '
    c=99
    DO
      EXIT IF c(c)>0 OR c=0
      DEC c
    LOOP
    '
    l=99
    DO
      EXIT IF l(l)>0 OR l=0
      DEC l
    LOOP
    '
    OPEN "O",#1,datei$
    OUT #1,66,65,85,84                      ! B A U T  als Dateikennung
    BPUT #1,VARPTR(f_min),8
    BPUT #1,VARPTR(f_max),8
    BPUT #1,VARPTR(betr_swr_max),8
    BPUT #1,VARPTR(daempf_max),8
    BPUT #1,VARPTR(wellenwiderstand),8
    BPUT #1,VARPTR(betrag_darst&),2
    BPUT #1,VARPTR(betr_swr_darst&),2
    BPUT #1,VARPTR(phase_darst&),2
    BPUT #1,VARPTR(schrittweite&),2
    BPUT #1,VARPTR(f_achse&),2
    BPUT #1,VARPTR(r),8
    BPUT #1,VARPTR(c),8
    BPUT #1,VARPTR(l),8
    BPUT #1,VARPTR(r(0)),(r+1)*8
    BPUT #1,VARPTR(c(0)),(c+1)*8
    BPUT #1,VARPTR(l(0)),(l+1)*8
    CLOSE #1
    neu_pfad_u_vorgabe
  ENDIF
  '
RETURN
'
PROCEDURE bauteile_drucken
  '
  LOCAL a$,n&,k&
  '
  n&=99                                     ! Zeilenzahl bestimmen
  WHILE r(n&)=0 AND c(n&)=0 AND l(n&)=0
    DEC n&
    EXIT IF n&=-1
  WEND
  '
  IF n&<0
    '
    a$="|Es sind keine Bauteile vorhanden|||           Taste !|"
    alarmbox(a$)
    '
  ELSE
    '
    IF GEMDOS(17)=TRUE
      drucker_initialisieren
      LPRINT
      LPRINT
      LPRINT " Bauteile zu  ";dnam$
      LPRINT
      LPRINT "     Nummer           R                    C                    L"
      LPRINT
      FOR k&=0 TO n&
        LPRINT "      ";STR$(k&,2);"     ";FN wert$(r(k&),10,0);"        ";
        LPRINT FN wert$(c(k&),10,0);"        ";FN wert$(l(k&),10,0)
      NEXT k&
    ELSE
      alarmbox("| Drucker nicht bereit ! |||        Taste !|")
    ENDIF
    '
  ENDIF
  '
RETURN
'
PROCEDURE bauteile_loeschen
  '
  alarmbox("| Bauteile lîschen ? |||       j / n|")
  IF antw&=jk& OR antw&=jg&
    ARRAYFILL r(),0
    ARRAYFILL c(),0
    ARRAYFILL l(),0
    oberst&(1)=0
    oberst&(2)=0
    oberst&(3)=0
    zeile&(1)=0
    zeile&(2)=0
    zeile&(3)=0
    dialogbox2_neu&=TRUE
  ENDIF
  '
RETURN
'
PROCEDURE grafik_laden
  '
  LOCAL kopf$,dateilaenge%,bildzeiger%,bildende%
  LOCAL kurvezeiger%,schirmzeiger%,byte&,byteanzahl&,signal&,n&
  '
  FILESELECT #"Grafik laden",pfad$+"*.P??",dnam$+".PAK",datei$
  '
  IF datei$<>"" AND RIGHT$(datei$)<>"\"
    '
    IF EXIST(datei$)
      '
      OPEN "I",#1,datei$
      dateilaenge%=LOF(#1)
      '
      IF dateilaenge%=32000
        BGET #1,VARPTR(kurve$),32000
        SPUT kurve$
        DELAY 1
        dialogbox1_neu&=TRUE
      ELSE IF dateilaenge%>58
        kopf$=""
        FOR n&=1 TO 4
          kopf$=kopf$+CHR$(INP(#1))
        NEXT n&
        IF kopf$="DKZA"
          BGET #1,VARPTR(f_min),8
          BGET #1,VARPTR(f_max),8
          BGET #1,VARPTR(betr_swr_max),8
          BGET #1,VARPTR(daempf_max),8
          BGET #1,VARPTR(wellenwiderstand),8
          BGET #1,VARPTR(betrag_darst&),2
          BGET #1,VARPTR(betr_swr_darst&),2
          BGET #1,VARPTR(phase_darst&),2
          BGET #1,VARPTR(schrittweite&),2
          BGET #1,VARPTR(f_achse&),2
          BGET #1,VARPTR(signal&),2
          dateilaenge%=dateilaenge%-56
          '
          BGET #1,VARPTR(bild$),dateilaenge%
          '
          ' Jetzt wird das Bild in bild$ dekomprimiert nach kurve$
          '
          bildzeiger%=VARPTR(bild$)
          bildende%=bildzeiger%+dateilaenge%-1
          kurvezeiger%=VARPTR(kurve$)
          schirmzeiger%=XBIOS(2)
          CLS
          '
          REPEAT
            '
            byte&=PEEK(bildzeiger%)
            POKE kurvezeiger%,byte&
            INC kurvezeiger%
            POKE schirmzeiger%,byte&
            INC schirmzeiger%
            INC bildzeiger%
            '
            IF byte&=signal&
              byteanzahl&=PEEK(bildzeiger%)
              INC bildzeiger%
              IF byteanzahl&>0
                byte&=PEEK(bildzeiger%-3)
                DEC kurvezeiger%
                DEC schirmzeiger%
                FOR n&=1 TO byteanzahl&+2
                  POKE kurvezeiger%,byte&
                  INC kurvezeiger%
                  POKE schirmzeiger%,byte&
                  INC schirmzeiger%
                NEXT n&
              ENDIF
            ENDIF
            '
          UNTIL bildzeiger%>bildende%
          '
          dialogbox1_neu&=TRUE
        ELSE
          alarmbox("| Kein RCL-Bild ! |||     Taste !|")
        ENDIF
      ELSE
        alarmbox("| Falsche DateilÑnge ! |||       Taste !|")
      ENDIF
      CLOSE #1
      neu_pfad_u_vorgabe
    ELSE
      alarmbox("| Datei existiert nicht ! |||        Taste !|")
    ENDIF
  ENDIF
  '
RETURN
'
PROCEDURE grafik_speichern
  '
  LOCAL a$,dateilaenge%,bildzeiger%,bildanfang%,bildende%
  LOCAL byte&,seltenstes_byte&,aagb&,min&,n&
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  a$="|                          Grafik speichern|"
  a$=a$+"                         ==================||"
  a$=a$+"Auswahl                                  "
  a$=a$+"                            Taste|"
  a$=a$+"-------                                   "
  a$=a$+"                           -----||"
  a$=a$+"Die erzeugte Grafik wird ungepackt als Datei der LÑnge|"
  a$=a$+"32000 Bytes gespeichert, die von jedem Zeichenprogramm|"
  a$=a$+"und von RCL gelesen werden kann. ( Dateiname:  xxxxxxxx.PIC )"
  a$=a$+" .....    1|||"
  a$=a$+"Die erzeugte Grafik wird als gepackte Datei ( zusammen mit|"
  a$=a$+"allen Parametern von Dialogbox 1 ) gespeichert, die nur von|"
  a$=a$+"RCL wieder gelesen werden kann.  Beim Lesen werden die|"
  a$=a$+"Parameter wieder eingestellt.    ( Dateiname:  xxxxxxxx.PAK )"
  a$=a$+" .....    2||||"
  a$=a$+"abbrechen ............."
  a$=a$+"............................................  Undo |"
  alarmbox(a$)
  '
  IF antw&=eins&
    '
    FILESELECT #"Grafik speichern",pfad$+"*.PIC",dnam$+".PIC",datei$
    '
    IF datei$<>"" AND RIGHT$(datei$)<>"\"
      IF INSTR(datei$,".")=0
        datei$=datei$+".PIC"
      ENDIF
      SPUT kurve$
      teilungslinien_zeichnen
      BSAVE datei$,XBIOS(2),32000
      neu_pfad_u_vorgabe
    ENDIF
    '
    dialogbox1_neu&=TRUE
  ENDIF
  '
  IF antw&=zwei&
    '
    FILESELECT #"Grafik speichern",pfad$+"*.PAK",dnam$+".PAK",datei$
    '
    IF datei$<>"" AND RIGHT$(datei$)<>"\"
      '
      IF INSTR(datei$,".")=0
        datei$=datei$+".PAK"
      ENDIF
      '
      OPEN "O",#1,datei$
      '
      OUT #1,68,75,90,65                    ! D K Z A  als Dateikennung
      BPUT #1,VARPTR(f_min),8               ! Es folgen 50 Bytes Parameter
      BPUT #1,VARPTR(f_max),8
      BPUT #1,VARPTR(betr_swr_max),8
      BPUT #1,VARPTR(daempf_max),8
      BPUT #1,VARPTR(wellenwiderstand),8
      BPUT #1,VARPTR(betrag_darst&),2
      BPUT #1,VARPTR(betr_swr_darst&),2
      BPUT #1,VARPTR(phase_darst&),2
      BPUT #1,VARPTR(schrittweite&),2
      BPUT #1,VARPTR(f_achse&),2
      '
      ' Es wird eine einfache LauflÑngenkomprimierung verwendet
      '
      SPUT kurve$
      teilungslinien_zeichnen               ! Bild auf Bildschirm
      '
      ' Zuerst wird das seltenste Byte bestimmt. In der komprimierten Datei
      ' bedeutet es:  Das nach mir folgende Byte gibt an, wie oft das vor
      ' mir stehende Byte noch wiederholt werden soll.
      ' Falls das Signalbyte selbst im Bild vorkommt, wird es an die
      ' komprimierte Datei weitergegeben, gefolgt von einem Nullbyte.
      '
      bildanfang%=XBIOS(2)
      bildende%=bildanfang%+31999           ! letztes Bildschirmbyte
      '
      ' HÑufigkeit der einzelnen Bytes feststellen:
      '
      ARRAYFILL anzahl&(),0
      FOR bildzeiger%=bildanfang% TO bildende%
        byte&=PEEK(bildzeiger%)
        INC anzahl&(byte&)
      NEXT bildzeiger%
      '
      ' Nun das seltenste bestimmen:
      '
      min&=anzahl&(0)
      seltenstes_byte&=0
      '
      FOR byte&=1 TO 255
        IF anzahl&(byte&)<min&
          min&=anzahl&(byte&)
          seltenstes_byte&=byte&
        ENDIF
      NEXT byte&
      '
      BPUT #1,VARPTR(seltenstes_byte&),2
      dateilaenge%=56
      '
      bildzeiger%=bildanfang%               ! erstes Bildschirmbyte
      '
      REPEAT
        '
        byte&=PEEK(bildzeiger%)
        OUT #1,byte&
        INC bildzeiger%
        INC dateilaenge%
        '
        IF byte&=seltenstes_byte&
          OUT #1,0
          INC dateilaenge%
        ELSE
          '
          ' Anzahl aufeinanderfolgender gleicher Bytes (aagb&) bestimmen:
          '
          aagb&=0
          WHILE PEEK(bildzeiger%)=byte& AND aagb&<256 AND bildzeiger%<=bildende%
            INC aagb&
            INC bildzeiger%
          WEND
          '
          ' aagb& ist jetzt die Anzahl der Bytes, die auch gleich byte& sind
          ' meistens zeigt hier bildzeiger% auf ein anderes Byte als byte&
          '
          IF aagb&<3
            FOR n&=1 TO aagb&
              OUT #1,byte&
              INC dateilaenge%
            NEXT n&
          ELSE
            OUT #1,seltenstes_byte&
            INC dateilaenge%
            OUT #1,aagb&-2
            INC dateilaenge%
          ENDIF
        ENDIF
        '
      UNTIL bildzeiger%>bildende%
      '
      IF dateilaenge%=32000   ! gepackte Datei darf nicht 32000 lang sein
        OUT #1,0
      ENDIF
      '
      CLOSE #1
      neu_pfad_u_vorgabe
      dialogbox1_neu&=TRUE
      '
    ENDIF
    '
  ENDIF
  '
RETURN
'
PROCEDURE grafik_drucken
  '
  LOCAL graphmod$,datenanz$,vorschub$,lwort%,druckzeile&,n&,x&,punkt&,y&
  LOCAL zwopunkt&,e&,dreipunkt&,i&,abbrechen&
  LOCAL byte1|,byte2|,byte3|
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  SGET dialogbox1$
  '
  a$="|                           Grafik drucken|"
  a$=a$+"                          ================||"
  a$=a$+"  NEC P 6, EPSON LQ 570 oder zu die"
  a$=a$+"sen kompatible 24-Nadel-Drucker|||"
  a$=a$+"  Auswahl               "
  a$=a$+"                                     Taste|"
  a$=a$+"  -------                                                    --"
  a$=a$+"---  |||"
  a$=a$+"  Format   9 cm  x   5,6 cm ......... ( 2 m"
  a$=a$+"in 20 s) ........   1  ||"
  a$=a$+"  Format  18 cm  x  11,2 cm ......... ( 4 m"
  a$=a$+"in ) ............   2  ||"
  a$=a$+"  Format  27 cm  x  16,8 cm ......... ( 6 m"
  a$=a$+"in 30 s ) .......   3  ||||"
  a$=a$+"  oder abbrechen ( auch wÑ"
  a$=a$+"hrend des Druckens ) .............  Undo  ||"
  alarmbox(a$)
  '
  IF antw&=eins& OR antw&=zwei& OR antw&=drei&
    '
    IF GEMDOS(17)=TRUE
      '
      SPUT kurve$
      teilungslinien_zeichnen
      BOX 0,0,639,399
      '
      graphmod$=CHR$(esc&)+"*"+CHR$(39)
      vorschub$=CHR$(esc&)+"J"+CHR$(24)+CHR$(13)
      '
      IF antw&=eins&                 ! Ein Bildschirmpunkt -> ein Druckerpunkt
        '
        datenanz$=CHR$(178)+CHR$(2)
        '
        LPRINT
        FOR druckzeile&=0 TO 15
          '
          abbrechen&=FALSE
          IF INP?(2)
            i&=INP(2)
            REPEAT                                 ! Nachlaufen verhindern
            UNTIL INKEY$=""
            IF i&=undo&
              alarmbox("| Druck abbrechen ? |||       j / n|")
              IF antw&=jk& OR antw&=jg&
                abbrechen&=TRUE
              ENDIF
              EXIT IF abbrechen&=TRUE
            ENDIF
          ENDIF
          '
          LPRINT graphmod$;datenanz$;
          '
          FOR n&=0 TO 49
            LPRINT CHR$(0);CHR$(0);CHR$(0);
          NEXT n&
          '
          FOR x&=0 TO 639
            '
            lwort%=0
            FOR punkt&=0 TO 23
              y&=ADD(MUL(24,druckzeile&),punkt&)
              IF PTST(x&,y&)
                lwort%=BSET(lwort%,SUB(23,punkt&))
              ENDIF
            NEXT punkt&
            '
            byte3|=BYTE(lwort%)
            byte2|=DIV(CARD(lwort%),256)
            lwort%=SWAP(lwort%)
            byte1|=BYTE(lwort%)
            '
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            '
          NEXT x&
          '
          LPRINT vorschub$;
          '
        NEXT druckzeile&
        '
        ' Jetzt kommen die letzten 16 Rasterzeilen:
        '
        IF abbrechen&=FALSE
          '
          LPRINT graphmod$;datenanz$;
          '
          FOR n&=0 TO 49
            LPRINT CHR$(0);CHR$(0);CHR$(0);
          NEXT n&
          '
          FOR x&=0 TO 639
            '
            lwort%=0
            FOR punkt&=0 TO 15
              y&=ADD(384,punkt&)
              IF PTST(x&,y&)
                lwort%=BSET(lwort%,SUB(15,punkt&))
              ENDIF
            NEXT punkt&
            '
            LPRINT CHR$(DIV(CARD(lwort%),256));CHR$(BYTE(lwort%));CHR$(0);
            '
          NEXT x&
          '
        ENDIF
        '
      ENDIF
      '
      IF antw&=zwei&                 ! Ein Bildschirmpunkt -> 4 Druckerpunkte
        '
        datenanz$=CHR$(50)+CHR$(5)
        '
        LPRINT
        FOR druckzeile&=0 TO 32
          '
          abbrechen&=FALSE
          IF INP?(2)
            i&=INP(2)
            REPEAT                                 ! Nachlaufen verhindern
            UNTIL INKEY$=""
            IF i&=undo&
              alarmbox("| Druck abbrechen ? |||       j / n|")
              IF antw&=jk& OR antw&=jg&
                abbrechen&=TRUE
              ENDIF
              EXIT IF abbrechen&=TRUE
            ENDIF
          ENDIF
          '
          LPRINT graphmod$;datenanz$;
          '
          FOR n&=0 TO 49
            LPRINT CHR$(0);CHR$(0);CHR$(0);
          NEXT n&
          '
          FOR x&=0 TO 639
            '
            lwort%=0
            FOR punkt&=0 TO 11
              y&=ADD(MUL(12,druckzeile&),punkt&)
              zwopunkt&=ADD(punkt&,punkt&)
              IF PTST(x&,y&)
                lwort%=BSET(lwort%,SUB(23,zwopunkt&))
                lwort%=BSET(lwort%,SUB(22,zwopunkt&))
              ENDIF
            NEXT punkt&
            '
            byte3|=BYTE(lwort%)
            byte2|=DIV(CARD(lwort%),256)
            lwort%=SWAP(lwort%)
            byte1|=BYTE(lwort%)
            '
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            '
          NEXT x&
          '
          LPRINT vorschub$;
          '
        NEXT druckzeile&
        '
        ' Jetzt kommen die letzten 4 Rasterzeilen:
        '
        IF abbrechen&=FALSE
          '
          LPRINT graphmod$;datenanz$;
          '
          FOR n&=0 TO 49
            LPRINT CHR$(0);CHR$(0);CHR$(0);
          NEXT n&
          '
          FOR x&=0 TO 639
            '
            byte1|=0
            FOR punkt&=0 TO 3
              y&=ADD(396,punkt&)
              zwopunkt&=ADD(punkt&,punkt&)
              IF PTST(x&,y&)
                byte1|=BSET(byte1|,SUB(7,zwopunkt&))
                byte1|=BSET(byte1|,SUB(6,zwopunkt&))
              ENDIF
            NEXT punkt&
            '
            LPRINT CHR$(byte1|);CHR$(0);CHR$(0);
            LPRINT CHR$(byte1|);CHR$(0);CHR$(0);
            '
          NEXT x&
          '
        ENDIF
        '
      ENDIF
      '
      IF antw&=drei&                 ! Ein Bildschirmpunkt -> 9 Druckerpunkte
        '
        datenanz$=CHR$(help&)+CHR$(4)
        '
        LPRINT
        FOR druckzeile&=0 TO 79
          '
          abbrechen&=FALSE
          IF INP?(2)
            i&=INP(2)
            REPEAT                                 ! Nachlaufen verhindern
            UNTIL INKEY$=""
            IF i&=undo&
              alarmbox("| Druck abbrechen ? |||       j / n|")
              IF antw&=jk& OR antw&=jg&
                abbrechen&=TRUE
              ENDIF
              EXIT IF abbrechen&=TRUE
            ENDIF
          ENDIF
          '
          LPRINT graphmod$;datenanz$;
          '
          FOR n&=0 TO 49
            LPRINT CHR$(0);CHR$(0);CHR$(0);
          NEXT n&
          '
          FOR x&=0 TO 399
            '
            lwort%=0
            FOR punkt&=0 TO 7
              y&=ADD(MUL(8,druckzeile&),punkt&)
              dreipunkt&=ADD(ADD(punkt&,punkt&),punkt&)
              IF PTST(y&,SUB(399,x&))
                lwort%=BSET(lwort%,SUB(23,dreipunkt&))
                lwort%=BSET(lwort%,SUB(22,dreipunkt&))
                lwort%=BSET(lwort%,SUB(21,dreipunkt&))
              ENDIF
            NEXT punkt&
            '
            byte3|=BYTE(lwort%)
            byte2|=DIV(CARD(lwort%),256)
            lwort%=SWAP(lwort%)
            byte1|=BYTE(lwort%)
            '
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            LPRINT CHR$(byte1|);CHR$(byte2|);CHR$(byte3|);
            '
          NEXT x&
          '
          LPRINT vorschub$;
          '
        NEXT druckzeile&
        '
      ENDIF
      '
      LPRINT
      '
    ELSE
      alarmbox("| Drucker nicht bereit ! |||        Taste !|")
    ENDIF
    '
  ENDIF
  '
  SPUT dialogbox1$
  '
RETURN
'
PROCEDURE grafik_loeschen
  '
  alarmbox("| Grafik lîschen ? |||      j / n|")
  IF antw&=jk& OR antw&=jg&
    kurve$=STRING$(32000,0)
  ENDIF
  '
RETURN
'
PROCEDURE grafik_zeigen
  '
  ' Hierher gelangt man mit der Taste F5
  '
  LOCAL a$,ausschnitt_oben$,ausschnitt_unten$
  LOCAL f_nullp,f,f1,f2,exp_fakt,e&,x&,y&,x_alt&,y_alt&
  LOCAL lage&,x0&,x1&,y1&
  '
  zeige_grafik&=FALSE
  '
  IF f_min=0 AND f_achse&=log&
    '
    a$="| Bei logarithmischer Teilung | der Frequenzachse ||"
    a$=a$+" darf  f min  nicht 0 sein ! |||           Taste !|"
    alarmbox(a$)
    '
  ELSE
    '
    SPUT kurve$
    teilungslinien_zeichnen
    SGET bild$
    '
    y0log&=0
    y0lin&=0
    nullpkt_neu&=FALSE
    '
    GRAPHMODE 3
    '
    x_alt&=100
    y_alt&=250
    DRAW x_alt&,0 TO x_alt&,399
    DRAW 0,y_alt& TO 639,y_alt&
    HIDEM
    '
    lage&=25                                ! Zeile fÅr Frequenz bzw. Betrag
    '
    f_nullp=0                               ! wird mit rechter Maustaste
    '                                         geÑndert
    IF f_achse&=log&
      exp_fakt=LOG(f_max/f_min)/639         ! spart weiter unten Rechenzeit
    ENDIF
    '
    REPEAT
      '
      GRAPHMODE 3
      '
      x&=MOUSEX
      y&=MOUSEY
      '
      IF x&<>x_alt&                         ! Fadenkreuz zeichnen
        DRAW x_alt&,0 TO x_alt&,399
        DRAW x&,0 TO x&,399
        x_alt&=x&
      ENDIF
      '
      IF y&<>y_alt&
        DRAW 0,y_alt& TO 639,y_alt&
        DRAW 0,y& TO 639,y&
        y_alt&=y&
      ENDIF
      '
      IF y&<24                             ! Zeile mit Betrag und Frequenz
        IF lage&=1                         ! evtl. aus dem Weg nehmen
          SPUT bild$
          DRAW 0,y& TO 639,y&
          DRAW x&,0 TO x&,399
        ENDIF
        lage&=25
      ENDIF
      '
      IF y&>376
        IF lage&=25
          SPUT bild$
          DRAW 0,y& TO 639,y&
          DRAW x&,0 TO x&,399
        ENDIF
        lage&=1
      ENDIF
      '
      IF f_achse&=lin&                                    ! Frequenz zur
        f=x&*(f_max-f_min)/639+f_min-f_nullp              ! Cursorstellung
      ELSE                                                ! berechnen
        f=f_min*EXP(x&*exp_fakt)-f_nullp
      ENDIF
      '
      PRINT AT(62,lage&);FN wert$(f,12,1);"Hz";
      '
      IF betr_swr_darst&=lin&                             ! Betrag zur
        betr_swr=(399-y&-y0lin&)*betr_swr_max/399         ! Cursorstellung
        PRINT AT(2,lage&);"Betrag/SWR: ";                 ! berechnen
        betr_swr_drucken(betr_swr)
      ENDIF
      '
      IF betr_swr_darst&=log&                             ! DÑmpfung zur
        daempf=(y&-y0log&)*daempf_max/399                 ! Cursorstellung
        PRINT AT(2,lage&);USING "-###.## dB",-daempf;     ! berechnen
      ENDIF
      '
      IF phase_darst&=TRUE                                       ! dito
        PRINT AT(38,lage&);USING "-###.# Grad",9*(200-y&)/10;    ! Phase
      ENDIF
      '
      IF MOUSEK=1                                  ! linke Maustaste
        REPEAT                                     ! Warten, bis wieder
        UNTIL MOUSEK=0                             ! losgelassen
        x1&=MOUSEX
        y1&=MOUSEY
        SPUT kurve$
        DRAW x1&-5,y1& TO x1&+5,y1&                ! Kreuzchen zeichnen
        DRAW x1&,y1&-5 TO x1&,y1&+5
        DRAW x1&,y1&
        SGET kurve$
        SPUT bild$
        DRAW x1&-5,y1& TO x1&+5,y1&
        DRAW x1&,y1&-5 TO x1&,y1&+5
        DRAW x1&,y1&
        SGET bild$
        GRAPHMODE 3
        DRAW 0,y& TO 639,y&                        ! neues Fadenkreuz
        DRAW x&,0 TO x&,399
      ENDIF
      '
      IF MOUSEK=2                                  ! rechte Maustaste
        REPEAT
        UNTIL MOUSEK=0
        IF nullpkt_neu&=FALSE
          x0&=MOUSEX
          IF f_achse&=lin&
            f_nullp=x0&*(f_max-f_min)/639+f_min
          ELSE
            f_nullp=f_min*EXP(x0&*exp_fakt)
          ENDIF
          y0log&=MOUSEY
          y0lin&=399-y0log&
          nullpkt_neu&=TRUE
        ELSE
          f_nullp=0
          y0log&=0
          y0lin&=0
          nullpkt_neu&=FALSE
        ENDIF
      ENDIF
      '
      e&=0
      IF INP?(2)                            ! Taste gedrÅckt ?
        e&=INP(2)                           ! Taste holen
        REPEAT                              ! Nachlaufen verhindern
        UNTIL INKEY$=""
        '
        IF e&=help&
          a$="|Linke Maustaste  :  Markierungen setzen/lîschen||"
          a$=a$+"Rechte Maustaste :  Koordinatennullpunkt setzen/rÅcksetzen|||"
          a$=a$+"F2               :  Teilungs"
          a$=a$+"linien Betrag    ein / aus|"
          a$=a$+"                    ( nur bei logarithmischer Darstellung )||"
          a$=a$+"F4               :  Teilungs"
          a$=a$+"linien Frequenz  ein / aus|"
          a$=a$+"                    ( nur bei logarithmischer Darstellung )|||"
          a$=a$+"F5               :  zurÅck zum MenÅ||"
          a$=a$+"F7               :  Frequenzintervall von dem ( evtl. mit der "
          a$=a$+"rechten|"
          a$=a$+"                    Maustaste gesetzten ) Koordinatennullpunkt "
          a$=a$+"bis zur|"
          a$=a$+"                    Cursorposition als  f min  und  f max  "
          a$=a$+"Åbernehmen,|"
          a$=a$+"                    dann zurÅck zum MenÅ|||"
          a$=a$+"                            Taste !|"
          alarmbox(a$)
          GRAPHMODE 3
        ENDIF
        '
        IF e&=(f2& AND betr_swr_darst&=log&) OR (e&=f4& AND f_achse&=log&)
          GRAPHMODE 1
          COLOR 1
          IF e&=f2&
            IF daempfungslinien&=TRUE
              daempfungslinien&=FALSE
            ELSE
              daempfungslinien&=TRUE
              '
              SPUT kurve$
              GET 8,360,631,392,ausschnitt_unten$
              DEFFILL 0,1
              PBOX 8,360,631,392
              BOX 8,360,631,392
              BOX 9,361,630,391
              BOX 12,364,627,388
              PRINT AT(4,24);"Linienstil wechseln:  F10";
              PRINT AT(61,24);"Wenn fertig:  F2"
              '
              GET 0,0,639,355,ausschnitt_oben$
              '
              DO
                '
                PUT 0,0,ausschnitt_oben$
                '
                DEFLINE strich%(linienstild&)
                '
                IF daempf_max>3
                  IF 1200/daempf_max<360
                    DRAW 0,1200/daempf_max TO 639,1200/daempf_max
                  ENDIF
                ENDIF
                IF daempf_max>6
                  IF 2400/daempf_max<360
                    DRAW 0,2400/daempf_max TO 639,2400/daempf_max
                  ENDIF
                ENDIF
                FOR daempf=10 TO daempf_max STEP 10
                  IF 400*daempf/daempf_max<360
                    DRAW 0,400*daempf/daempf_max TO 639,400*daempf/daempf_max
                  ENDIF
                NEXT daempf
                '
                PRINT AT(35,24);"Linienstil jetzt ";linienstild&
                REPEAT
                  n&=INP(2)
                  REPEAT
                  UNTIL INKEY$=""
                UNTIL n&=f2& OR n&=f10&
                '
                EXIT IF n&=f2&
                '
                IF n&=f10&
                  linienstild&=linienstild&+1
                  IF linienstild&>7
                    linienstild&=0
                  ENDIF
                ELSE
                  n&=n&-48
                  linie(n&)=-linie(n&)
                ENDIF
                '
              LOOP
              '
              PUT 0,0,ausschnitt_oben$
              PUT 8,360,ausschnitt_unten$
              '
            ENDIF
            '
          ELSE
            '
            IF frequenzlinien&=TRUE
              frequenzlinien&=FALSE
            ELSE
              frequenzlinien&=TRUE
              '
              SPUT kurve$
              GET 8,245,631,392,ausschnitt_unten$
              DEFFILL 0,1
              PBOX 8,245,631,392
              BOX 8,245,631,392
              BOX 9,246,630,391
              BOX 12,249,627,388
              PRINT AT(4,17);"Bei welchen Frequenzen sol";
              PRINT "len Linien gezeichnet werden ?"
              PRINT AT(4,18);"DrÅcken Sie die entsprechende Zifferntaste !"
              PRINT AT(4,20);"Bei           1 *   1,5     2     3     4     5";
              PRINT "     6     7     8     9"
              PRINT AT(4,22);"Taste:               1      2     3     4     5";
              PRINT "     6     7     8     9"
              PRINT AT(4,24);"Linienstil wechseln:  F10";
              PRINT AT(61,24);"Wenn fertig:  F4"
              '
              GET 0,0,639,229,ausschnitt_oben$
              '
              h=639/LOG(f_max/f_min)
              '
              DO
                '
                FOR n&=1 TO 9
                  IF linie(n&)<0
                    PRINT AT(22+6*n&,20);"*";
                  ELSE
                    PRINT AT(22+6*n&,20);" ";
                  ENDIF
                NEXT n&
                '
                PUT 0,0,ausschnitt_oben$
                '
                DEFLINE strich%(linienstilf&)
                n&=0
                fa=10^INT(LOG10(f_min))
                fx=fa
                DO
                  EXIT IF fx>f_max
                  IF fx>=f_min
                    xx=h*LOG(fx/f_min)
                    DRAW xx,0 TO xx,229
                  ENDIF
                  INC n&
                  IF n&>9
                    n&=0
                    fa=10*fa
                  ENDIF
                  IF linie(n&)<0
                    fx=-fa*linie(n&)
                  ENDIF
                LOOP
                '
                PRINT AT(35,24);"Linienstil jetzt ";linienstilf&
                REPEAT
                  n&=INP(2)
                  REPEAT
                  UNTIL INKEY$=""
                UNTIL n&=f4& OR n&=f10& OR (n&>48 AND n&<58)
                '
                EXIT IF n&=f4&
                '
                IF n&=f10&
                  linienstilf&=linienstilf&+1
                  IF linienstilf&>7
                    linienstilf&=0
                  ENDIF
                ELSE
                  n&=n&-48
                  linie(n&)=-linie(n&)
                ENDIF
                '
              LOOP
              '
              PUT 0,0,ausschnitt_oben$
              PUT 8,245,ausschnitt_unten$
              '
            ENDIF
            '
          ENDIF
          SPUT kurve$
          teilungslinien_zeichnen
          SGET bild$
          GRAPHMODE 3
          DRAW x_alt&,0 TO x_alt&,399
          DRAW 0,y_alt& TO 639,y_alt&
        ENDIF
        '
        IF e&=f7&
          f1=f_nullp
          f2=f1+f
          IF f1<>f2
            IF f2<f1
              SWAP f1,f2
            ENDIF
            IF nullpkt_neu&=TRUE
              f_min=f1
            ENDIF
            f_max=f2
            dialogbox1_neu&=TRUE
          ELSE
            a$="| f min  =  f max  ist nicht sinn"
            a$=a$+"voll ! |||              Taste !|"
            alarmbox(a$)
            GRAPHMODE 3
          ENDIF
        ENDIF
        '
      ENDIF
      '
    UNTIL e&=f7& OR e&=f5&
    '
  ENDIF
  '
RETURN
'
PROCEDURE betr_swr_drucken(b_s)
  '
  IF ABS(b_s)>=10000 OR (ABS(b_s)<0.00001 AND ABS(b_s)>b_s_max/400)
    PRINT USING "-###.##^^^^",b_s;
  ELSE IF ABS(b_s)>=1
    PRINT USING "-#####.####",b_s;
  ELSE
    PRINT USING "-#.########",b_s;
  ENDIF
  '
RETURN
'
PROCEDURE alarmbox(e$)
  '
  LOCAL ausschnitt$
  LOCAL maxlang&,zeilenzahl&,wo&,p&,erste_zeile&,zeilenanfang&,zeile&
  LOCAL x_min&,x_max&,y_min&,y_max&
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  maxlang&=0
  zeilenzahl&=1
  '
  IF INSTR(e$,"|")=0
    maxlang&=LEN(e$)
  ELSE
    wo&=1
    DO
      p&=INSTR(e$,"|",wo&)
      EXIT IF p&=0
      INC zeilenzahl&
      IF maxlang&<p&-wo&
        maxlang&=p&-wo&
      ENDIF
      wo&=p&+1
    LOOP
  ENDIF
  '
  erste_zeile&=13-INT(zeilenzahl&/2)
  zeilenanfang&=41-INT(maxlang&/2)
  x_min&=(zeilenanfang&-1)*8-20
  x_max&=x_min&+8*maxlang&+38
  y_min&=(erste_zeile&-1)*16-11
  y_max&=y_min&+16*zeilenzahl&+21
  '
  GET x_min&,y_min&,x_max&,y_max&,ausschnitt$
  DEFFILL 0,1
  PBOX x_min&,y_min&,x_max&,y_max&
  BOX x_min&,y_min&,x_max&,y_max&
  BOX x_min&+1,y_min&+1,x_max&-1,y_max&-1
  BOX x_min&+4,y_min&+4,x_max&-4,y_max&-4
  '
  FOR zeile&=0 TO zeilenzahl&-2
    p&=INSTR(e$,"|")
    PRINT AT(zeilenanfang&,erste_zeile&+zeile&);LEFT$(e$,p&-1);
    e$=MID$(e$,p&+1)
  NEXT zeile&
  PRINT AT(zeilenanfang&,erste_zeile&+zeile&);e$;
  '
  antw&=INP(2)
  REPEAT
  UNTIL INKEY$=""
  PUT x_min&,y_min&,ausschnitt$
  '
RETURN
'
PROCEDURE taste_holen(VAR e&)
  '
  PRINT CHR$(esc&);"e";                     ! Cursor darstellen
  e&=INP(2)                                 ! Tastatur abfragen
  REPEAT                                    ! Nachlaufen verhindern
  UNTIL INKEY$=""
  PRINT CHR$(esc&);"f";                     ! Cursor ausschalten
  '
RETURN
'
PROCEDURE fehlerbehandlung
  '
  LOCAL e$
  '
  e$="| Es ist ein Fehler aufgetreten !|||"
  e$=e$+" Nummer der Befehlszeile :   "+STR$(befehlz&-1)+"||||"
  e$=e$+" Die GFA-Basic Fehlermeldung lautet :|||"
  e$=e$+"  "+ERR$(ERR)+"|||"
  e$=e$+" Das Programm wird mit dem EingabemenÅ fortgesetzt ||"
  e$=e$+" Befehle und Bauteilwerte sind noch vorhanden  (?)|||"
  e$=e$+"                   Taste !|"
  alarmbox(e$)
  '
  zeige_grafik&=FALSE
  zeichne_kurve&=FALSE
  dialogbox2_neu&=TRUE
  dialogbox1_neu&=TRUE
  CLOSE
  '
  RESUME fehlereinsprung
  '
RETURN
'
PROCEDURE help_bearbeitung
  '
  LOCAL a$
  '
  IF (eingabe&=1 AND (item1&=0 OR item1&=1)) OR (eingabe&=2 AND item2&>0)
    a$="|  So gibt man Frequenzen und Bauteilwerte ein:||"
    a$=a$+"  als ganze Zahl,   z.B.:     470         3         0|"
    a$=a$+"  als Dezimalzahl   z.B.:       6,8        .123     0.0001|"
    a$=a$+"  mit Zehnerpotenz  z.B.:       8,2e7   400E-3      0.12e+12  ||"
    a$=a$+"  mit den ZusÑtzen    f,  p,  n,  u,  m,  k,  M,  G,  T||"
    a$=a$+"  diese stehen fÅr die Faktoren:||"
    a$=a$+"  f=10^(-15)   p=10^(-12)   n=10^(-9)   u=10^(-6)   m=10^(-3)|"
    a$=a$+"  k=10^3       M=10^6       G=10^9      T=10^12||"
    a$=a$+"  Beispiele:   6,8p     1200 u     0,003G     12e+3 n|||"
    a$=a$+"                            Taste !|"
  ELSE IF eingabe&=2 AND item2&=0
    a$="Mîgliche Befehle:||R 34  C 0  L 87     bringt den komplexen"
    a$=a$+" Widerstand des jeweiligen|                    Bauteiles"
    a$=a$+" auf den Stapel|sto 22              kopiert den obersten"
    a$=a$+" Stapeleintrag nach Speicher 22|rcl 8               holt"
    a$=a$+" eine Kopie aus Speicher 8 auf den Stapel|ser oder +  "
    a$=a$+"        addiert die beiden obersten komplexen WiderstÑnde|"
    a$=a$+" -                  subtrahiert sie ( den ober"
    a$=a$+"sten von dem darunter )|"
    a$=a$+" *                  bildet ihr komplexes Produkt|"
    a$=a$+" /                  komplexer Quotient"
    a$=a$+" ( zweiter durch obersten )|"
    a$=a$+"par                 schaltet sie parallel|"
    a$=a$+"inv                 komplexer"
    a$=a$+" Kehrwert des obersten Eintrages |conj                bildet"
    a$=a$+" den konjugiert komplexen Wert|drop                entfernt"
    a$=a$+" den obersten Stapeleintrag|dup                 dupliziert"
    a$=a$+" den obersten Stapeleintrag|swap                vertauscht die"
    a$=a$+" beiden obersten StapeleintrÑge|over                legt"
    a$=a$+" den zweiten Stapeleintrag nochmal obendrauf|rot        "
    a$=a$+"         vertauscht die drei obersten EintrÑge zyklisch|"
    a$=a$+"cstk                lîscht den ganzen Rechenstapel|~   "
    a$=a$+"                dient nur zum Trennen von Befehlsgruppen"
    a$=a$+" (entspr. REM)||                              Taste !|"
  ELSE IF eingabe&=1 AND item1&>1 AND item1&<5
    a$="|Gewîhnlich mîchte man, daû der hîchste Punkt der dargestellten"
    a$=a$+" Kurve|gerade den oberen Bildrand erreicht.||Falls"
    a$=a$+" der Maximalwert von Betrag bzw. SWR vorher bekannt ist, kann er|"
    a$=a$+"eingegeben werden.||Andernfalls stellt man 'automatisch' ein und"
    a$=a$+" das Programm schreibt die|berechneten Werte zunÑchst in eine"
    a$=a$+" Liste, sucht darin den Maximalwert|und zeichnet dann erst"
    a$=a$+" die Kurve.|||                            Taste !|"
  ELSE IF eingabe&=1 AND item1&=5
    a$="|Der obere Bildrand entspricht 0 dB DÑmpfung.||Die Strecke bis zum"
    a$=a$+" unteren Bildrand teilt"
    a$=a$+" das Programm dB-linear.||Die Teilungslinien ( nach F5 F2 )"
    a$=a$+" liegen bei DÑmpfungen von||       3 dB,   6 dB,   10 dB,   20 dB,"
    a$=a$+"   30 dB   u.s.w. ||Als maximale DÑmpfung sollte man ein"
    a$=a$+" Vielfaches von 10 angeben.|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND item1&=6
    a$="|FÅr die Berechnung des StehwellenverhÑltnisses ( SWR ) kann man|"
    a$=a$+"hier den Wellenwiderstand des verwendeten Kabels eingeben.||"
    a$=a$+"Standardwert ist 50 Ohm.||"
    a$=a$+"( Siehe auch Hilfe zum Punkt 'SWR darstellen' )|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND item1&=7
    a$="|Nachdem die Befehlsfolge fÅr eine bestimmte Frequenz abgearbeitet|"
    a$=a$+"wurde, ist das Ergebnis all dieser Rechnungen eine komplexe"
    a$=a$+" Zahl.|||Falls ein Zweipol untersucht wird, ist sie dessen"
    a$=a$+" Impedanz.|Ihr Betrag||     SQR( Realteil^2 + ImaginÑrteil^2 )"
    a$=a$+"   ( = Scheinwiderstand )||wird dargestellt.|||Falls ein"
    a$=a$+" Spannungsteiler untersucht wird, ist sie dessen Ausgangs-|spannung"
    a$=a$+" bei einer Eingangsspannung von 1V. |Der Betrag dieser Span"
    a$=a$+"nung ( s.o. ) wird dargestellt.|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND item1&=8
    a$="|Die Darstellung des SWR ist nur sinnvoll, wenn ein Zweipol|"
    a$=a$+"untersucht wird !|||Dieser bildet den Abschluû eines Kabels"
    a$=a$+" mit dem vorgegebenen|Wellenwiderstand.||Falls die"
    a$=a$+" Zweipolimpedanz nicht reell und gleich dem"
    a$=a$+" Wellen-|widerstand des Kabels ist, bilden sich"
    a$=a$+" stehende Wellen, d.h.|an verschiedenen Stellen des Kabels"
    a$=a$+" miût man unterschiedliche|Wechselspannungen.|||"
    a$=a$+"Das SWR ist das VerhÑltnis des grîûten dieser Werte zum|"
    a$=a$+"kleinsten.  Deshalb ist es immer grîûer oder gleich 1.||"
    a$=a$+"Ein SWR = 1 bedeutet perfekte Anpassung ohne stehende Wellen.|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND (item1&=12 OR item1&=13)
    a$="|Nachdem die Befehlsfolge fÅr eine bestimmte Frequenz abgearbeitet|"
    a$=a$+"wurde, ist das Ergebnis all dieser Rechnungen eine komplexe"
    a$=a$+" Zahl.|||Falls ein Zweipol untersucht wird, ist sie dessen"
    a$=a$+" Impedanz.|Ihr Phasenwinkel  ATN( ImaginÑrteil / Realteil ) "
    a$=a$+" wird dargestellt.|||Falls ein Spannungsteiler"
    a$=a$+" untersucht wird, ist sie dessen Ausgangs-|spannung bei einer"
    a$=a$+" Eingangsspannung von 1V. |Die Phasenverschiebung der Ausgangsspan"
    a$=a$+"nung gegen die Eingangsspannung|wird dargestellt.|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND item1&=14
    a$="|Bei Schrittweite 1 wird die Kurve fÅr alle 640 Spalten|"
    a$=a$+"des Bildschirms berechnet.||"
    a$=a$+"|Bei Schrittweite n nur fÅr jede n-te, dazwischen wird"
    a$=a$+"|linear interpoliert.|||"
    a$=a$+"Also:|"
    a$=a$+"|Kleine Schrittweite   -         genauer Kurvenverlauf"
    a$=a$+"|                                aber lange Rechenzeit|"
    a$=a$+"|Groûe Schrittweite    -         nur grober Kurvenverlauf"
    a$=a$+"|                                dafÅr kurze Rechenzeit|||"
    a$=a$+"                         Taste !|"
  ELSE IF eingabe&=1 AND item1&=16
    a$="|           Die Frequenzachse wird logarithmisch geteilt|||"
    a$=a$+"Wenn z.B.   f min = 10 Hz   und   f max = 100 MHz   ist, dann "
    a$=a$+"belegt|jede der sieben Dekaden||10 Hz .. 100 Hz, 100 Hz .. 1 kHz,"
    a$=a$+" 1 kHz .. 10 kHz, 10 kHz .. 100 kHz,||100 kHz .. 1 MHz,"
    a$=a$+" 1 MHz .. 10 MHz, 10 MHz .. 100 MHz||einen gleich langen"
    a$=a$+" Abschnitt auf der Frequenzachse.|||"
    a$=a$+"Nachdem man  F5  gedrÅckt hat, um das Bild zu betrachten, "
    a$=a$+"lÑût sich|mit  F4  ein vertikales Gitter Åber das Diagramm "
    a$=a$+"legen, dessen Linien|sich bei folgenden Frequenzen befinden:||"
    a$=a$+"... 0,05   0,1   0,2   0,5   1   2   5   10   20"
    a$=a$+"   50   100   200 ...|||"
    a$=a$+"                             Taste !|"
  ELSE
    a$="| Zu diesem Punkt sollte keine Hilfe nîtig sein ! |||"
    a$=a$+"                    Taste !|"
  ENDIF
  alarmbox(a$)
  '
RETURN
'
PROCEDURE neu_pfad_u_vorgabe
  '
  pfad$=LEFT$(datei$,RINSTR(datei$,"\"))
  dnam$=MID$(datei$,RINSTR(datei$,"\")+1)
  IF INSTR(dnam$,".")
    dnam$=LEFT$(dnam$,RINSTR(dnam$,".")-1)
  ENDIF
  '
RETURN
'
PROCEDURE drucker_initialisieren
  '
  LPRINT CHR$(27);"R";CHR$(0);       ! Amerikanischer Zeichensatz
  LPRINT CHR$(27);"N";CHR$(6);       ! öberspringe Perforation. 6 Zeilen
  LPRINT CHR$(27);"M";               ! 12 Zeichen pro Zoll
  LPRINT CHR$(27);"x";CHR$(1);       ! Letter Quality
  LPRINT CHR$(27);"l";CHR$(17);      ! Linker Rand 12 Zeichen = 1 Zoll
  '
RETURN
'
PROCEDURE test_stack_voll
  '
  LOCAL e$
  '
  IF st_z&>98
    '
    e$="| Es ist ein Fehler aufgetreten !|||"
    e$=e$+" Nummer der Befehlszeile :   "+STR$(befehlz&)+"||||"
    e$=e$+" Art des Fehlers :|||"
    e$=e$+"            Stapel ist voll|||"
    e$=e$+" Das Programm wird mit dem EingabemenÅ fortgesetzt ||"
    e$=e$+" Befehle und Bauteilwerte sind noch vorhanden  (?)|||"
    e$=e$+"                   Taste !|"
    alarmbox(e$)
    '
    zeige_grafik&=FALSE
    zeichne_kurve&=FALSE
    dialogbox2_neu&=TRUE
    dialogbox1_neu&=TRUE
    '
    fehler&=TRUE
    '
  ENDIF
  '
RETURN
'
PROCEDURE test_stack(n&)
  '
  LOCAL e$
  '
  IF st_z&<n&-1
    '
    e$="| Es ist ein Fehler aufgetreten !|||"
    e$=e$+" Nummer der Befehlszeile :   "+STR$(befehlz&)+"||||"
    e$=e$+" Art des Fehlers :|||"
    e$=e$+"     Nicht genÅgend Operanden !||"
    e$=e$+"     Die Operation erfordert mindestens "
    e$=e$+STR$(n&)+" Zahl"
    IF n&>1
      e$=e$+"en"
    ENDIF
    e$=e$+" auf dem Stapel  |||"
    e$=e$+" Das Programm wird mit dem EingabemenÅ fortgesetzt ||"
    e$=e$+" Befehle und Bauteilwerte sind noch vorhanden  (?)|||"
    e$=e$+"                   Taste !|"
    alarmbox(e$)
    '
    zeige_grafik&=FALSE
    zeichne_kurve&=FALSE
    dialogbox2_neu&=TRUE
    dialogbox1_neu&=TRUE
    '
    fehler&=TRUE
    '
  ENDIF
  '
RETURN
'
PROCEDURE teilungslinien_zeichnen
  '
  LOCAL fx,xx,fa,h,n&
  '
  GRAPHMODE 1
  COLOR schwarz&
  '
  IF frequenzlinien&=TRUE AND f_achse&=log&
    '
    h=639/LOG(f_max/f_min)
    fa=10^INT(LOG10(f_min))
    fx=fa
    n&=0
    DEFLINE strich%(linienstilf&)
    DO
      EXIT IF fx>f_max
      IF fx>=f_min
        xx=h*LOG(fx/f_min)
        DRAW xx,0 TO xx,399
      ENDIF
      INC n&
      IF n&>9
        n&=0
        fa=10*fa
      ENDIF
      IF linie(n&)<0
        fx=-fa*linie(n&)
      ENDIF
    LOOP
    '
  ENDIF
  '
  IF daempfungslinien&=TRUE AND betr_swr_darst&=log&
    DEFLINE strich%(linienstild&)
    IF daempf_max>3
      DRAW 0,1200/daempf_max TO 639,1200/daempf_max
    ENDIF
    IF daempf_max>6
      DRAW 0,2400/daempf_max TO 639,2400/daempf_max
    ENDIF
    FOR daempf=10 TO daempf_max STEP 10
      DRAW 0,400*daempf/daempf_max TO 639,400*daempf/daempf_max
    NEXT daempf
  ENDIF
  '
  DEFLINE 1
  '
RETURN
'
FUNCTION wert$(x,l&,flag&)
  '
  LOCAL f$
  '
  f$=" "
  IF ABS(x)>=1000
    x=x/1000
    f$="k"
  ENDIF
  IF ABS(x)>=1000
    x=x/1000
    f$="M"
  ENDIF
  IF ABS(x)>=1000
    x=x/1000
    f$="G"
  ENDIF
  IF ABS(x)>=1000
    x=x/1000
    f$="T"
  ENDIF
  IF ABS(x)<1
    x=x*1000
    f$="m"
  ENDIF
  IF ABS(x)<1
    x=x*1000
    f$="u"
  ENDIF
  IF ABS(x)<1
    x=x*1000
    f$="n"
  ENDIF
  IF ABS(x)<1
    x=x*1000
    f$="p"
  ENDIF
  IF ABS(x)<1
    x=x*1000
    f$="f"
  ENDIF
  IF ABS(x)=0
    f$=" "
  ENDIF
  '
  IF flag&=1
    f$=STR$(x,l&,4)+"  "+f$
  ELSE
    f$=STR$(x,l&)+"  "+f$
  ENDIF
  '
  RETURN f$
  '
ENDFUNC
'
FUNCTION wert(x$)
  '
  LOCAL hilf
  '
  hilf=INSTR(x$,",")
  IF hilf
    x$=LEFT$(x$,hilf-1)+"."+MID$(x$,hilf+1)
  ENDIF
  hilf=ABS(VAL(x$))
  IF INSTR(x$,"f")
    hilf=hilf*1.0E-15
  ELSE IF INSTR(x$,"p")
    hilf=hilf*1.0E-12
  ELSE IF INSTR(x$,"n")
    hilf=hilf*1.0E-09
  ELSE IF INSTR(x$,"u")
    hilf=hilf*1.0E-06
  ELSE IF INSTR(x$,"m")
    hilf=hilf*0.001
  ELSE IF INSTR(x$,"k")
    hilf=hilf*1000
  ELSE IF INSTR(x$,"M")
    hilf=hilf*1000000
  ELSE IF INSTR(x$,"G")
    hilf=hilf*1000000000
  ELSE IF INSTR(x$,"T")
    hilf=hilf*1000000000000
  ENDIF
  RETURN hilf
  '
ENDFUNC
