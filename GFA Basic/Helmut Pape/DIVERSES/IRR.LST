' Name :   IRR
'
' Von  :   Helmut Pape     Gauûstraûe 20     90459 Nuernberg     0911/449184
'
' ----------------------------------------------------------------------------
'
' Zweck:   Zeichnet jedesmal einen anderen Irrgarten, bei dem es von
'          jedem Punkt zu jedem anderen Punkt genau einen Weg gibt.
'          Man kann also Start und Ziel beliebig waehlen.
'
'          Programmende    :   Esc oder Undo druecken
'          Neuer Irrgarten :   beliebige andere Taste druecken
'
'
' Algorithmus:
'
' Wir beginnen mit einem Gitter von  zh * zv  quadratischen Zellen.
' Jede enthaelt die Zahl 0, zum Zeichen, daû sie noch nicht betreten wurde.
'
' Die Startzelle bestimmen wir per Zufall und geben ihr die Nummer 1.
' Dann waehlen wir aus den noch nicht betretenen Nachbarzellen ebenfalls
' mit Hilfe des Zufalls eine aus, geben ihr die Nummer 2 und loeschen
' die Wand zwischen Zelle 1 und 2.
'
' Genauso wird nun von Zelle 2 aus eine freie Nachbarzelle gesucht, d.h.
' eine, deren Inhalt die Zahl 0 ist.  Von dieser Zelle Nr. 3 geht es
' dann in gleicher Weise weiter.  Immer, wenn mehrere freie Nachbarzellen
' vorhanden sind, wird eine davon mittels Zufallszahl ausgewaehlt.
' Auf diese Weise entsteht ein Weg, der sich nirgends kreuzt, da jede
' bereits angeschlossene Zelle ihre Nummer enthaelt und diese nicht 0 ist.
'
' Nach einiger Zeit werden wir von unserer jetzigen Zelle aus
' ( welche z.B. die Nummer 367 tragen moege ) keine freie Nachbarzelle
' mehr finden.  Dann wird diese ( Zelle 367 ) mit einer  -1  belegt,
' was "betreten verboten !" bedeutet.  Wir gehen auf unserer eigenen Spur
' einen Schritt zurueck nach Zelle 366 und versuchen es dort nochmal.
' Wenn diese auch keine freie Nachbarzelle hat, schreiben wir ebenfalls
' eine -1 hinein und gehen noch einen Schritt zurueck ( nach 365 ) u.s.w.
'
' So werden schlieûlich alle Zellen des Gitters betreten und miteinander
' verbunden.
'
' Der Irrgarten ist fertig, wenn auf der Suche nach freien Zellen
' die noch eine 0 enthalten, die Zelle Nummer 1 wieder betreten wird.
'
' ----------------------------------------------------------------------------
DIM m&(320,200)               ! Die Matrix m&() enthÑlt die Zellenbelegungen
'
DO
  '
  CLS
  PRINT
  PRINT TAB(35);"Irrgarten"
  PRINT TAB(34);"==========="
  PRINT AT(9,10);"oder nur    Return    um das Programm zu beenden"
  PRINT AT(9,16);"Wenn der Irrgarten fertig ist:"
  PRINT AT(18,18);"s  tippen um ihn zu speichern"
  PRINT AT(18,20);"oder eine beliebige Taste fÅr einen neuen"
  PRINT AT(9,8);
  INPUT "Wegbreite in Bildpunkten   ( 1 ... 100 )     ";w$
  EXIT IF w$=""
  w=INT(ABS(VAL(w$)))
  IF w<1
    w=1
  ENDIF
  IF w>100
    w=100
  ENDIF
  h=640
  v=400
  zh=INT((h-5)/(w+1))
  zv=INT((v-5)/(w+1))
  ih=zh*(w+1)+1
  iv=zv*(w+1)+1
  x0=INT((h-ih)/2)
  y0=INT((v-iv)/2)
  '
  '
  FOR x=0 TO zh               ! Alle Zellen sind zunÑchst frei,
    FOR y=0 TO zv             ! enthalten also die Zahl 0.
      m&(x,y)=0
    NEXT y
  NEXT x
  '                         --------------------------------------------------
  CLS                         ! Bildschirm lîschen
  COLOR 1                     ! normal zeichnen
  BOX x0-1,y0-1,x0+ih,y0+iv   ! Damit die Umrandung etwas dicker wird.
  FOR y=y0 TO y0+iv STEP w+1  ! Es wird ein Gitter von zh * zv
    DRAW x0,y TO x0+ih,y      ! Quadraten gezeichnet.
  NEXT y
  FOR x=x0 TO x0+ih STEP w+1  ! Jedem Quadrat entspricht eine der inneren
    DRAW x,y0 TO x,y0+iv      ! Zellen der Matrix m&(), d.h. solche mit
  NEXT x                      ! Koordinaten  ( 1 ... 79, 1 ... 49 ).
  '                         --------------------------------------------------
  FOR x=0 TO zh+1             ! Um die inneren Zellen wird ein Rand von
    m&(x,0)=-1                ! Zellen gelegt, deren Betreten verboten ist.
    m&(x,zv+1)=-1             ! Das vereinfacht die Programmierung.
  NEXT x
  FOR y=1 TO zv
    m&(0,y)=-1
    m&(zh+1,y)=-1
  NEXT y
  '                         --------------------------------------------------
  COLOR 0                     ! Von jetzt an wird nur noch gelîscht.
  x=RANDOM(zh)+1              ! Per Zufall bestimmen wir das AnfangskÑstchen.
  y=RANDOM(zv)+1
  m&(x,y)=1                   ! Es bekommt die Nummer 1.
  n=1                         ! Die aktuelle Nummer ist immer auch in n.
  '
  ' --------------------------------------------------------------------------
  '
  REPEAT                      ! Hier beginnt die Hauptschleife des Programms.
    f=0                       ! Zuerst werden die freien Nachbarzellen gezÑhlt.
    IF m&(x+1,y)=0
      f=f+1
    ENDIF
    IF m&(x-1,y)=0
      f=f+1
    ENDIF
    IF m&(x,y+1)=0
      f=f+1
    ENDIF
    IF m&(x,y-1)=0
      f=f+1
    ENDIF                     ! Das Ergebnis steht jetzt in f.
    '                       --------------------------------------------------
    IF f=0                    ! Keine Nachbarzelle frei.
      m&(x,y)=-1              ! Hier ist jetzt Betreten verboten !
      n=n-1                   ! Nummer der vorigen Zelle bestimmen.
      IF m&(x+1,y)=n          ! Vorige Zelle suchen.
        x=x+1
      ENDIF
      IF m&(x-1,y)=n
        x=x-1
      ENDIF
      IF m&(x,y+1)=n
        y=y+1
      ENDIF
      IF m&(x,y-1)=n
        y=y-1
      ENDIF                   ! x, y  sind ihre Koordinaten.
      '                     --------------------------------------------------
    ELSE                      ! Es gibt f freie Nachbarzellen.
      x1=x                    ! Jetzige Koordinaten merken.
      y1=y
      z=RANDOM(f)             ! Um eine der freien Nachbarzellen auszuwÑhlen,
      '                         wird eine Zufallszahl z mit 0 <= z < f bestimmt.
      x=x+1                   ! Die rechte Nachbarzelle.
      IF m&(x,y)=0            ! War sie frei ?
        z=z-1                 ! Wenn z=0 war, wird diese gewÑhlt.
      ENDIF
      '
      IF z>=0                 ! Falls aber z noch nicht -1 ist,
        x=x-2                 ! Blick auf die linke Nachbarzelle.
        IF m&(x,y)=0          ! Frei ?
          z=z-1               ! Wenn z=0 war, wird diese gewÑhlt.
        ENDIF
      ENDIF
      '
      IF z>=0                 ! Ist z noch nicht -1 ?
        x=x+1                 ! Schauen wir uns die Nachbarzelle oben an.
        y=y+1
        IF m&(x,y)=0          ! Frei ?
          z=z-1               ! Wenn z=0 war, wird diese gewÑhlt.
        ENDIF
      ENDIF
      '
      IF z>=0                 ! Letzte Moeglichkeit:
        y=y-2                 ! Die untere Nachbarzelle
      ENDIF                   ! Nun sind x, y die Koordinaten der neuen Zelle.
      n=n+1                   ! Ihre Nummer wird gebildet
      m&(x,y)=n               ! und hineingeschrieben.
      '                     --------------------------------------------------
      IF x=x1                 ! Die Wand zwischen den Zellen (x1,y1) und (x,y)
        IF y<y1 THEN          ! muû nun gelîscht werden.
          y1=y
        ENDIF
        y1=(y1)*(w+1)+y0      ! Zellen uebereinander
        x1=(x1-1)*(w+1)+x0
        DRAW x1+1,y1 TO x1+w,y1
      ELSE
        IF x<x1 THEN
          x1=x
        ENDIF
        x1=(x1)*(w+1)+x0      ! Zellen nebeneinander
        y1=(y1-1)*(w+1)+y0
        DRAW x1,y1+1 TO x1,y1+w
      ENDIF
      '                     --------------------------------------------------
    ENDIF                     ! Ende des Falles  f > 0
    '                       --------------------------------------------------
  UNTIL n=1                   ! Ende der Hauptschleife.
  '
  ' --------------------------------------------------------------------------
  '
  PRINT CHR$(7)
  '                           ! Einen neuen Irrgarten erhÑlt man durch Druck
  e=INP(2)                    ! auf eine beliebige Taste mit Ausnahme von
  '
  IF e=83 OR e=115
    '
    a$="Irrgarten speichern"
    pfad$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\*.*"
    FILESELECT #a$,pfad$,"",file$
    BSAVE file$,XBIOS(2),32000
    '
  ENDIF
  '
LOOP
