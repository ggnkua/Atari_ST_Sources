'    Text-Editor    27.04.1990
$S&,S>,I+,F<,P>
'
INLINE madeby%,150
INLINE preview%,116
INLINE qvdi%,290
INLINE qwrt%,272
INLINE trim_r%,30
INLINE qlin%,88
INLINE qbox%,60
screen%=XBIOS(3)
'
LONG{qvdi%+282}={L~A-22}
LONG{qvdi%+286}=screen%
'
LONG{qlin%+84}=screen%
LONG{qbox%+56}=screen%
'
ON BREAK CONT
ON ERROR GOSUB fehler
'
@current_path(select$)
@current_path(store_select$)
@current_path(b_select$)
'
DIM find$(1),tab|(30),store_tab|(30)
DIM f_line%(999),jump%(1),rectblock$(24),help$(100)
'
@help_loader
'
FOR i%=0 TO 9
  tab|(i%)=i%*8
  store_tab|(i%)=i%*8
NEXT i%
'
dual!=TRUE
filewrite!=TRUE
left_space%=1
store_left_space%=1
form_len|=62
r_mode%=3
@text_array_init
'
'         die 2000 ist ein gesch„tzter Sicherheitsabstand im Speicher
max%=MIN((FRE(0)-2000)\90,20000)  ! Begrenzt auf 20000 Zeilen
max1%=max%/2                      ! halbe Zeilenanzahl fr zwei Texte
max2%=max1%-13                    ! 13 Zeilen Sicherheitsabstand
'                                   max2%=maximale nutzbare Zeilenanzahl
DIM txt$(max1%),store$(max1%)     ! Zeile Null bleibt frei
'
KEYPAD 2
'
@anwendung
'
DEFMOUSE 0
LOCATE x%,y%
OUT 2,27,113   ! Schwarz auf Weiž
OUT 2,27,119   ! automatischer šberlauf aus
OUT 2,27,101   ! Cursor ein
~XBIOS(21,3)   ! Cursor blinkt nicht
'
DO
  in%=GEMDOS(6,&HFF)
  IF in%
    LONG{XBIOS(14,1)+6}=0  ! Tastaturpuffer leeren
    '
    asc|=BYTE(in%)
    scan&=BCLR(CARD(SWAP(in%)),12)
    '
    IF asc|>31
      @write(ADD(y%,off%))
    ELSE IF scan&
      @steer
    ENDIF
  ENDIF
  ON MOUSEK GOSUB maus,summe
LOOP
'
PROCEDURE write(o%)
  OUT 2,27,102   ! Cursor aus
  @trim_right
  @save_line
  IF asc|=127
    @delete_char
  ELSE
    @set_line
    IF x%<80
      @insert_char
      INC x%
    ELSE
      IF LEN(txt$(o%))<80
        @insert_char
      ENDIF
    ENDIF
  ENDIF
  LOCATE x%,y%
  OUT 2,27,101   ! Cursor ein
RETURN
'
PROCEDURE steer
  OUT 2,27,102
  SELECT scan&
  CASE &HE                    !Backspace
    @backspace(ADD(y%,off%))
  CASE &HF                    !Tab
    @tab
  CASE &H10F,&H20F            !sh Tab
    @space_tab
    '  CASE &H81C                  !alt Return, halbe Zeilen in Custom
    '  @write_linepart(over|,ADD(y%,off%),CHR$(171),x%)
    '  CONT
  CASE &H1C                   !Return
    @scroll_up
    x%=left_space%
  CASE &H3B                   !F1
    @load_text
    ' CASE &H154,&H254            !sh F1 Custom
  CASE &H3C                   !F2 Kleinedi
    @load_block(ADD(y%,off%))
  CASE &H3D                   !F3
    @print(FALSE)
  CASE &H40,&H521,&H621       !F6,sh F
    @find_one_input(TRUE)
  CASE &H44                   !F10
    @edit_end
  CASE &H47                   !Clr Home
    x%=left_space%
    y%=1
    @text_to_screen(off%)
  CASE &H48                   !Cursor Up
    @scroll_down
  CASE &H4B                   !Cursor Left
    IF x%>1
      DEC x%
    ENDIF
  CASE &H4D                   !Cursor Right
    IF x%<80
      INC x%
    ENDIF
  CASE &H50                   !Cursor Down
    @scroll_up
  CASE &H52                   !Insert
    IF over|=1
      @write_linepart(0,ADD(y%,off%)," ",x%)
      DEC x%
    ELSE
      @insert_line(ADD(y%,off%))
    ENDIF
    '  CASE &H3C                   !F2 Custom
  CASE &H154,&H254             !sh F1 Kleinedi
    @save_text(FALSE)
  CASE &H155,&H255             !sh F2
    IF blockmark!=TRUE
      @save_block(FALSE)
    ELSE
      @no_block
    ENDIF
  CASE &H156,&H256             !sh F3
    IF blockmark!=TRUE
      @print(TRUE)
    ELSE
      @no_block
    ENDIF
  CASE &H159,&H259,&H512,&H612 !sh F6, sh E
    @replace_one_input
  CASE &H15D,&H25D             !sh F10
    @switch_single_dual
  CASE &H61                    !Undo
    @undo
  CASE &H62                    !Help
    @help
  CASE &H412                   !^E
    IF wordfind!=TRUE AND x%=f_pos%
      @replace(f_line%)
    ELSE
      @find(find$(0),gross!,TRUE)
    ENDIF
  CASE &H413                   !^R
    @switch_on("Rechteckblock",rectblock|)
  CASE &H414                   !^T
    @tab_set
  CASE &H415,&H41D             ! ^Z, der zweite Wert ist bei Numlock
    @trim_right_1(ADD(y%,off%))
    @set_x_y_off(left_space%,MIN(max2%,SUCC(line%)))
    @text_to_screen(off%)
  CASE &H416                   !^U
    @undelete(ADD(y%,off%))
  CASE &H417                   !^I
    @info
  CASE &H418                   !^O
    @switch_on("šberschreibmodus",over|)
  CASE &H419                   !^P
    IF store_blockmark!=TRUE
      @store_block_paste(ADD(y%,off%))
    ELSE
      @no_block
    ENDIF
  CASE &H41B                   !^+
    @connect_lines(ADD(y%,off%))
  CASE &H41E                   !^A
    @switch_on("Autoformat",format|)
  CASE &H41F                   !^S
    @preview
  CASE &H420                   !^D
    IF blockmark!=TRUE
      @block_delete
    ELSE
      @no_block
    ENDIF
  CASE &H421                   !^F
    @find(find$(0),gross!,TRUE)
  CASE &H423                   !^H
    IF blockmark!=TRUE
      @clear_block
      @text_to_screen(off%)
    ELSE
      @no_block
    ENDIF
  CASE &H424                   !^J
    jump%(j%)=ADD(y%,off%)
    j%=ABS(EVEN(j%))
    @set_x_y_off(left_space%,jump%(j%))
    @text_to_screen(off%)
  CASE &H425                   !^K
    @mark_blockend
  CASE &H426                   !^L
    @goto_line
  CASE &H42B                   !^~
    @crack_lines(x%,ADD(y%,off%))
  CASE &H42E                   !^C
    IF blockmark!=TRUE
      @block_copy(ADD(y%,off%))
    ELSE
      @no_block
    ENDIF
  CASE &H430                   !^B
    @mark_blockstart
  CASE &H431                   !^N
    @clear_text
  CASE &H432                   !^M
    IF blockmark!=TRUE
      @block_move(ADD(y%,off%))
    ELSE
      @no_block
    ENDIF
  CASE &H435                   !^-
    @find(find$(0),gross!,FALSE)
  CASE &H535,&H635             !sh^-
    @find_one_input(FALSE)
  CASE &H448                   !^Cursor Up
    @scroll_down_fast
  CASE &H450                   !^Cursor Down
    @scroll_up_fast
  CASE &H452                   !^Insert
    @insert_line(ADD(y%,off%))
  CASE &H453                   !^Delete
    @delete_line(ADD(y%,off%))
  CASE &H473                   !^Cursor Left
    x%=left_space%
  CASE &H474                   !^Cursor Right
    @trim_right_1(ADD(y%,off%))
    x%=MAX(left_space%,MIN(80,LEN(txt$(ADD(y%,off%)))+1))
  CASE &H477                   !^Clr Home
    x%=left_space%
    y%=1
    CLR off%
    @text_to_screen(off%)
  CASE &H811                   !alt W
    @tabs_to_spaces
  CASE &H812                   !alt E
    @replace_all_input
  CASE &H813                   !alt R
    @rechter_rand
  CASE &H913,&HA13             !sh alt R
    @border_set(FALSE,ADD(y%,off%))
  CASE &H814                   !alt T
    @write_linepart(over|,ADD(y%,off%),TIME$,x%)
  CASE &H815                   !alt Z
    @zentri(ADD(y%,off%))
  CASE &H816                   !alt U
    @change_text
  CASE &H81E                   !alt A
    @sonderzeichen
  CASE &H81F                   !alt S
    @seiten_len
  CASE &H820                   !alt D
    @write_linepart(over|,ADD(y%,off%),DATE$,x%)
  CASE &H821                   !alt F
    IF blockmark!=TRUE
      IF blocklen%<201
        @text_format(left_space%,right_space%,blockstart%,blockend%)
      ELSE
        @block_overflow
      ENDIF
    ELSE
      @no_block
    ENDIF
  CASE &H822                   !alt G
    @set_x_y_off(short_mark_x%,short_mark_y%)
    @text_to_screen(off%)
  CASE &H823                   !alt H
    @result_mode(r_mode%)
  CASE &H825                   !alt K
    IF blockmark!=TRUE
      @set_x_y_off(left_space%,blockend%)
      @text_to_screen(off%)
    ELSE
      @no_block
    ENDIF
  CASE &H826                   !alt L
    @linker_rand
  CASE &H926,&HA26             !sh alt L
    @border_set(TRUE,ADD(y%,off%))
  CASE &H82D                   !alt X
    short_mark_x%=x%
    short_mark_y%=ADD(y%,off%)
  CASE &H830                   !alt B
    IF blockmark!=TRUE
      @set_x_y_off(left_space%,blockstart%)
      @text_to_screen(off%)
    ELSE
      @no_block
    ENDIF
  CASE &H83B                   !alt F1
    @save_text(TRUE)
  CASE &H83C                   !alt F2
    IF blockmark!=TRUE
      @save_block(TRUE)
    ELSE
      @no_block
    ENDIF
  CASE &H881                   !alt 0
    @set_x_y_off(left_space%,undo_line%)
    @text_to_screen(off%)
  CASE &H882                   !alt ?
    IF current_text!=TRUE
      @show_find_lines(all_off%)
    ELSE
      @find_all(find$(0),gross!)
    ENDIF
  CASE &H840,&H982,&HA82       !alt F6, sh alt ?
    @find_all_input
  CASE &HE32                   !sh^alt M
    @messagebox(CHAR{madeby%})
    ~INP(2)
    @text_to_screen(off%)
  ENDSELECT
  LOCATE x%,y%
  OUT 2,27,101   ! Cursor ein
RETURN
'
PROCEDURE summe
  LOCAL r%,result,result$
  HIDEM
  @park
  IF first!=FALSE
    first!=TRUE
    rx1%=x%
    ry1%=y%+off%
  ELSE
    first!=FALSE
    rx2%=x%
    ry2%=y%+off%
    '
    IF rx1%>rx2%
      SWAP rx1%,rx2%
    ENDIF
    IF ry1%>ry2%
      SWAP ry1%,ry2%
    ENDIF
    OUT 2,27,102
    IF ry2%>ry1%
      FOR r%=ry1% TO ry2% STEP 1
        result=result+VAL(MID$(txt$(r%),rx1%,rx2%-rx1%))
      NEXT r%
      @result_to_digit(result,r_mode%,result$)
      @write_linepart(over|,ry2%,result$,rx1%)
    ELSE
      @rechnen(MID$(txt$(ry1%),rx1%,rx2%-rx1%),result)
      @result_to_digit(result,r_mode%,result$)
      @write_linepart(over|,ry1%,result$,x%)
    ENDIF
    LOCATE x%,y%
    OUT 2,27,101
  ENDIF
  SHOWM
RETURN
'
PROCEDURE park
  WHILE MOUSEK
  WEND
RETURN
'
PROCEDURE rechnen(in$,VAR out)
  @spaces(in$)
  @replace_to_dez("&X",in$)
  @replace_to_dez("&O",in$)
  @replace_to_dez("&H",in$)
  @replace_to_dez("$",in$)
  @sign(in$)
  @replace_percent(in$)
  @replace_divs(in$)
  @replace_muls(in$)
  @chain_add(in$,out)
RETURN
'
PROCEDURE spaces(VAR in$)
  LOCAL pos%
  in$=TRIM$(in$)
  WHILE INSTR(in$," ")>0
    pos%=INSTR(in$," ")
    in$=LEFT$(in$,MAX(0,pos%-1))+MID$(in$,pos%+1)
  WEND
RETURN
'
PROCEDURE sign(VAR in$)
  IF LEFT$(in$)<>"-"
    IF LEFT$(in$)<>"+"
      in$="+"+in$
    ENDIF
  ENDIF
RETURN
'
PROCEDURE replace_to_dez(id$,VAR in$)
  LOCAL dez$,dig$
  WHILE INSTR(UPPER$(in$),id$)>0
    pos%=INSTR(UPPER$(in$),id$)
    dig$=MID$(in$,pos%,VAL?(MID$(in$,pos%)))
    dez$=STR$(VAL(dig$))
    in$=LEFT$(in$,MAX(0,pos%-1))+dez$+MID$(in$,pos%+LEN(dig$))
  WEND
RETURN
'
PROCEDURE replace_percent(VAR in$)
  WHILE INSTR(in$,"%")>0
    pos%=INSTR(in$,"%")
    in$=LEFT$(in$,MAX(0,pos%-1))+":100"+MID$(in$,pos%+1)
  WEND
RETURN
'
PROCEDURE replace_divs(VAR in$)
  LOCAL var1,var2,pos%,rpos%,erg$
  WHILE INSTR(in$,":")
    pos%=INSTR(in$,":")
    var2=VAL(MID$(in$,1+pos%))
    IF var2<>0
      rpos%=1+pos%+VAL?(MID$(in$,1+pos%))
      @get_var1(in$,pos%,var1)
      var1=var1/var2
      erg$=STR$(var1)
      @sign(erg$)
      in$=LEFT$(in$,pos%-1)+erg$+MID$(in$,rpos%)
    ELSE
      @messagebox("Division durch Null!  Taste...")
      ~INP(2)
      @text_to_screen(off%)
    ENDIF
    EXIT IF var2=0
  WEND
RETURN
'
PROCEDURE replace_muls(VAR in$)
  LOCAL var1,var2,pos%,rpos%,erg$
  WHILE INSTR(in$,"*")
    pos%=INSTR(in$,"*")
    var2=VAL(MID$(in$,1+pos%))
    rpos%=1+pos%+VAL?(MID$(in$,1+pos%))
    @get_var1(in$,pos%,var1)
    var1=var1*var2
    erg$=STR$(var1)
    @sign(erg$)
    in$=LEFT$(in$,pos%-1)+erg$+MID$(in$,rpos%)
  WEND
RETURN
'
PROCEDURE get_var1(in$,VAR pos%,var1)
  REPEAT
    DEC pos%
  UNTIL VAL?(MID$(in$,pos%,1))=0
  IF MID$(in$,pos%,1)<>"+" AND MID$(in$,pos%,1)<>"-"
    INC pos%
  ENDIF
  var1=VAL(MID$(in$,pos%))
RETURN
'
PROCEDURE chain_add(in$,VAR out)
  WHILE VAL?(in$)>0
    ADD out,VAL(in$)
    in$=MID$(in$,VAL?(in$)+1)
  WEND
RETURN
'
PROCEDURE result_to_digit(in,mode%,VAR out$)
  SELECT mode%
  CASE 1
    out$="&X"+BIN$(in)
  CASE 2
    out$="&O"+OCT$(in)
  CASE 3
    out$=STR$(in)
  CASE 4
    out$="&H"+HEX$(in)
  CASE 5
    out$="$"+HEX$(in)
  ENDSELECT
RETURN
'
PROCEDURE current_path(VAR path$)
  path$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)+"\"
RETURN
'
PROCEDURE text_array_init
  text_num%=1
  store_text_num%=2
  x%=left_space%
  store_x%=left_space%
  y%=1
  store_y%=1
  find_y%=1
  line_number%=1
  short_mark_x%=1
  short_mark_y%=1
  store_mark_x%=1
  store_mark_y%=1
  ext$=".TXT"
  file$="NO_NAME.TXT"
  store_ext$=".TXT"
  store_file$="NO_NAME.TXT"
  b_ext$=".TXT"
  b_file$="NO_NAME.TXT"
RETURN
'
PROCEDURE fehler_text_save
  ON ERROR GOSUB fehler
  CLS
  IF ERR=37
    @messagebox("Diskette voll!")
  ELSE IF ERR<>0
    @messagebox("Fehlernummer : "+STR$(ERR))
  ENDIF
  PRINT AT(8,6);"Der Text wurde nicht gesichert!  Taste...";
  ~INP(2)
  RESUME text_save_out
RETURN
'
PROCEDURE fehler_bakfile
  ON ERROR GOSUB fehler
  filewrite!=FALSE
  RESUME bakfile_out
RETURN
'
PROCEDURE fehler_text_load
  ON ERROR GOSUB fehler
  RESUME text_load_out
RETURN
'
PROCEDURE fehler
  ON ERROR GOSUB fehler
  RESUME NEXT
RETURN
'
PROCEDURE overflow
  @messagebox("Der Textspeicher ist zu klein!  Taste...")
  ~INP(2)
RETURN
'
PROCEDURE write_linepart(over|,o%,linepart$,VAR x%)
  IF x%<81
    @create_linepart(over|,x%,o%,linepart$)
    ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:SUB(o%,off%))
    ADD x%,LEN(linepart$)
  ENDIF
RETURN
'
PROCEDURE create_linepart(over|,x%,o%,linepart$)
  @set_line
  @save_line
  txt$(o%)=txt$(o%)+SPACE$(80)
  IF over|
    MID$(txt$(o%),x%)=linepart$
  ELSE
    txt$(o%)=LEFT$(txt$(o%),x%-1)+linepart$+MID$(txt$(o%),x%)
  ENDIF
  @trim_right
RETURN
'
PROCEDURE set_line
  line%=MIN(max2%,MAX(line%,o%))
RETURN
'
PROCEDURE save_line
  change!=TRUE
  CLR line_delete!,current_text!
  IF undo_line%<>o% OR undo!=TRUE
    CLR undo!
    undo_line%=o%
    undo_line$=txt$(undo_line%)
  ENDIF
RETURN
'
PROCEDURE sub_keys(VAR key%)
  SELECT BSET(INP(2),5)
  CASE 231 ! home
    key%=1
  CASE 232 ! up
    key%=2
  CASE 240 ! down
    key%=3
  CASE 162 ! ~?
    key%=4
  DEFAULT
    CLR key%
  ENDSELECT
  LONG{XBIOS(14,1)+6}=0
RETURN
'
PROCEDURE set_x_y_off(xin%,yin%)
  IF yin%>0
    x%=xin%
    y%=MIN(yin%,13)
    off%=MAX(SUB(yin%,13),0)
  ENDIF
RETURN
'
PROCEDURE help
  LOCAL key%
  @help_to_screen(help_off%,help$())
  REPEAT
    @sub_keys(key%)
    ON key% GOSUB help_home,help_up,help_down
  UNTIL key%=0 OR key%=4
  @text_to_screen(off%)
RETURN
'
PROCEDURE help_home
  IF help_off%>0
    CLR help_off%
    @help_to_screen(0,help$())
  ENDIF
RETURN
'
PROCEDURE help_up
  IF help_off%>0
    DEC help_off%
    @top_line(help_off%,help$())
  ENDIF
RETURN
'
PROCEDURE help_down
  IF help_off%<help_cnt%-25
    INC help_off%
    @bottom_line(ADD(24,help_off%),help$())
  ENDIF
RETURN
'
PROCEDURE show_find_lines(o%)
  LOCAL key%
  @find_to_screen(o%)
  LOCATE 1,find_y%
  OUT 2,27,101
  REPEAT
    @sub_keys(key%)
    OUT 2,27,102
    ON key% GOSUB find_home,find_up,find_down,jump_to_text
    OUT 2,27,101
  UNTIL key%=0
  all_off%=o%
  OUT 2,27,102
  @text_to_screen(off%)
RETURN
'
PROCEDURE find_home
  find_y%=1
  IF o%>0
    CLR o%
    @find_to_screen(o%)
  ENDIF
  LOCATE 1,find_y%
RETURN
'
PROCEDURE find_up
  IF find_y%>1
    DEC find_y%
  ELSE
    IF o%>0
      DEC o%
      @top_line(f_line%(o%),txt$())
    ENDIF
  ENDIF
  LOCATE 1,find_y%
RETURN
'
PROCEDURE find_down
  IF find_y%<25
    INC find_y%
  ELSE
    IF o%<all%-25
      INC o%
      @bottom_line(f_line%(24+o%),txt$())
    ENDIF
  ENDIF
  LOCATE 1,find_y%
RETURN
'
PROCEDURE jump_to_text
  CLR key%
  @set_x_y_off(left_space%,f_line%(o%+find_y%-1))
RETURN
'
PROCEDURE top_line(o%,VAR ar$())
  BMOVE screen%,screen%+1280,30720
  ~C:qvdi%(L:V:ar$(o%),W:LEN(ar$(o%)),W:1)
RETURN
'
PROCEDURE bottom_line(o%,VAR ar$())
  BMOVE screen%+1280,screen%,30720
  ~C:qvdi%(L:V:ar$(o%),W:LEN(ar$(o%)),W:25)
RETURN
'
PROCEDURE screen_dn
  @top_line(off%,txt$())
  ~C:qlin%(W:off%,W:form_len|,W:1)
  IF blockmark!=TRUE
    ~C:qbox%(W:off%,W:blockstart%,W:blockend%,W:1)
  ENDIF
  DEC off%
RETURN
'
PROCEDURE screen_up
  INC off%
  bot%=ADD(25,off%)
  @bottom_line(bot%,txt$())
  ~C:qlin%(W:bot%,W:form_len|,W:25)
  IF blockmark!=TRUE
    ~C:qbox%(W:bot%,W:blockstart%,W:blockend%,W:25)
  ENDIF
RETURN
'
PROCEDURE help_to_screen(o%,VAR array$())
  FOR cnt%=0 TO 24
    ~C:qvdi%(L:V:array$(cnt%+o%),W:LEN(array$(cnt%+o%)),W:cnt%+1)
  NEXT cnt%
RETURN
'
PROCEDURE find_to_screen(o%)
  CLR i%
  REPEAT
    INC i%
    ~C:qvdi%(L:V:txt$(f_line%(o%)),W:LEN(txt$(f_line%(o%))),W:i%)
    INC o%
  UNTIL i%>25
RETURN
'
PROCEDURE text_to_screen(o%)
  FOR cnt%=1 TO 25
    INC o%
    ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:cnt%)
    ~C:qlin%(W:o%,W:form_len|,W:cnt%)
    ~C:qbox%(W:o%,W:blockstart%,W:blockend%,W:cnt%)
  NEXT cnt%
RETURN
'
PROCEDURE clear_block
  CLR firstmark!,blockmark!,blockstart%,blockend%,blocklen%
RETURN
'
PROCEDURE mark_blockstart
  blockstart%=ADD(y%,off%)
  IF firstmark!=TRUE
    IF blockend%>blockstart%
      blockmark!=TRUE
      blocklen%=blockend%-blockstart%
    ENDIF
    @text_to_screen(off%)
  ELSE
    firstmark!=TRUE
  ENDIF
RETURN
'
PROCEDURE mark_blockend
  blockend%=ADD(y%,off%)
  IF firstmark!=TRUE
    IF blockend%>blockstart%
      blockmark!=TRUE
      blocklen%=blockend%-blockstart%
    ENDIF
    @text_to_screen(off%)
  ELSE
    firstmark!=TRUE
  ENDIF
RETURN
'
PROCEDURE block_delete
  @messagebox("Block l”schen?  Y/N")
  IF BSET(INP(2),5)=121
    change!=TRUE
    CLR current_text!
    @set_x_y_off(left_space%,blockstart%)
    REPEAT
      SWAP txt$(blockstart%),txt$(blockend%)
      INC blockstart%
      IF blockend%<line%
        INC blockend%
      ELSE
        txt$(blockend%)=""
      ENDIF
    UNTIL blockstart%>line%
    SUB line%,blocklen%
    @clear_block
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE block_copy(o%)
  LOCAL l%,m%
  IF ADD(line%,blocklen%)<max2%
    IF o%<=blockstart% OR o%>=blockend%
      @create_blockspace(o%,blocklen%)
      FOR l%=0 TO PRED(blocklen%)
        txt$(o%+l%)=txt$(blockstart%+l%)
      NEXT l%
      ADD line%,blocklen%
    ELSE
      @cursor_in_block
    ENDIF
  ELSE
    @overflow
  ENDIF
  set_x_y_off(left_space%,o%)
  @text_to_screen(off%)
RETURN
'
PROCEDURE block_move(o%)
  LOCAL cnt%
  DIM block_txt$(blocklen%-1)
  IF o%<blockstart% OR o%>=blockend%
    change!=TRUE
    CLR current_text!
    '
    FOR cnt%=0 TO blocklen%-1
      SWAP block_txt$(cnt%),txt$(ADD(cnt%,blockstart%))
    NEXT cnt%
    '
    IF o%<blockstart%
      FOR cnt%=blockstart%-1 DOWNTO o%
        SWAP txt$(cnt%),txt$(ADD(cnt%,blocklen%))
      NEXT cnt%
    ENDIF
    '
    IF o%>=blockend%
      SUB o%,blocklen%
      FOR cnt%=blockstart% TO o%-1
        SWAP txt$(cnt%),txt$(ADD(cnt%,blocklen%))
      NEXT cnt%
    ENDIF
    '
    FOR cnt%=0 TO blocklen%-1
      SWAP block_txt$(cnt%),txt$(ADD(cnt%,o%))
    NEXT cnt%
    '
    @clear_block
  ELSE
    @cursor_in_block
  ENDIF
  ERASE block_txt$()
  set_x_y_off(left_space%,o%)
  @text_to_screen(off%)
RETURN
'
PROCEDURE create_blockspace(o%,len%)
  LOCAL l%,m%
  change!=TRUE
  CLR current_text!
  line%=MAX(line%,PRED(o%))
  l%=line%
  m%=ADD(line%,len%)
  WHILE o%<=l%
    SWAP txt$(l%),txt$(m%)
    DEC l%
    DEC m%
  WEND
  IF blockmark!
    IF o%<=blockstart%
      ADD blockstart%,len%
    ENDIF
    IF o%<blockend%
      ADD blockend%,len%
    ENDIF
    blocklen%=blockend%-blockstart%
  ENDIF
RETURN
'
PROCEDURE store_block_paste(o%)
  LOCAL n%
  IF ADD(line%,store_blocklen%)<max2%
    @create_blockspace(o%,store_blocklen%)
    FOR n%=0 TO PRED(store_blocklen%)
      txt$(o%+n%)=store$(store_blockstart%+n%)
    NEXT n%
    ADD line%,store_blocklen%
  ELSE
    @overflow
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE print(block!)
  IF BIOS(8,0)=0
    @messagebox("Der Drucker ist nicht bereit!  Taste...")
    ~INP(2)
  ELSE
    IF block!=TRUE
      @messagebox("Block drucken:")
    ELSE
      @messagebox("Text drucken:")
    ENDIF
    PRINT AT(8,6);"B'riefqualit„t? L'istingqualit„t? P'roportional? A'bbruch?";
    SELECT BSET(INP(2),5)
    CASE 108  ! L
      @print_out_text(block!,0,0)
    CASE 98  ! B
      @print_out_text(block!,1,0)
    CASE 112 ! P
      @print_out_text(block!,1,1)
    ENDSELECT
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE print_out_text(block!,qual!,prop!)
  LOCAL cnt|,char|,charset|,a%,e%,txt$
  '
  '     Init  amerik  IBM      Skip  Draft/LQ     Prop  E/A
  OUT 0,27,64,27,82,0,27,116,1,27,79,27,120,qual!,27,112,prop!
  IF prop!=TRUE
    OUT 0,27,108,6,27,81,75 !Linker Rand und rechter Rand
  ELSE
    OUT 0,27,108,0,27,81,0
  ENDIF
  @print_cut
  IF block!=TRUE
    a%=blockstart%
    e%=PRED(blockend%)
  ELSE
    a%=1
    e%=line%
  ENDIF
  REPEAT
    txt$=LEFT$(txt$(a%),80)
    IF prop!=TRUE AND LEN(txt$)>70
      OUT 0,27,97,3
    ELSE
      OUT 0,27,97,0
    ENDIF
    WHILE LEN(txt$)
      char|=ASC(LEFT$(txt$))
      SELECT char|
      CASE 158
        IF charset|=2
          OUT 0,126
        ELSE IF charset|=0
          charset|=2
          OUT 0,27,82,2,126
        ENDIF
      CASE 221
        IF charset|=0
          OUT 0,21
        ELSE IF charset|=2
          charset|=0
          OUT 0,27,82,0,21
        ENDIF
      DEFAULT
        IF charset|=0
          OUT 0,char|
        ELSE IF charset|=2
          charset|=0
          OUT 0,27,82,0,char|
        ENDIF
      ENDSELECT
      txt$=MID$(txt$,2)
    WEND
    '
    INC cnt|
    IF cnt|<form_len|
      OUT 0,13,10 !CR+LF
    ELSE
      CLR cnt|
      OUT 0,12
    ENDIF
    '
    IF (GEMDOS(6,&HFF) AND &HFF)=27
      @messagebox("Druckausgabe abbrechen?  Y/N")
      IF BSET(INP(2),5)=121
        a%=e%
      ELSE
        @print_cut
      ENDIF
    ENDIF
    '
    INC a%
  UNTIL a%>e%
  IF block!=FALSE   !Seitenvorschub am Ende
    OUT 0,12
  ENDIF
RETURN
'
PROCEDURE print_cut
  @messagebox("Abbruch mit Esc")
RETURN
'
PROCEDURE find_all_input
  @find_word_input("Suchen und alles anzeigen:")
  @capitals
  @find_all(find$(0),gross!)
RETURN
'
PROCEDURE find_one_input(direct!)
  IF direct!=TRUE
    @find_word_input("Suchen +")
  ELSE
    @find_word_input("Suchen -")
  ENDIF
  @capitals
  @find(find$(0),gross!,direct!)
RETURN
'
PROCEDURE find_word_input(mess$)
  @messagebox(mess$)
  PRINT AT(8,6);"Suchbegriff?";
  LOCATE 8,8
  FORM INPUT 64 AS find$(0)
RETURN
'
PROCEDURE replace_all_input
  @find_word_input("Suchen und alles ersetzen:")
  @replace_word_input("Ersetzen durch?")
  @messagebox("Ersetzen ab Cursorposition ohne Nachfrage?  Y/N")
  IF BSET(INP(2),5)=121
    @replace_all(ADD(y%,off%),find$(0),find$(1),txt$())
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE replace_one_input
  @find_word_input("Suchen und ersetzen:")
  @replace_word_input("Ersetzen durch?")
  @capitals
  @find(find$(0),gross!,TRUE)
RETURN
'
PROCEDURE replace_word_input(mess$)
  PRINT AT(8,10);mess$;
  LOCATE 8,12
  FORM INPUT 64 AS find$(1)
RETURN
'
PROCEDURE capitals
  @messagebox("Grož / Kleinschreibung beachten?  Y/N")
  IF BSET(INP(2),5)=121
    gross!=TRUE
  ELSE
    gross!=FALSE
  ENDIF
RETURN
'
PROCEDURE find(f_$,caps!,ahead!)
  f_line%=ADD(y%,off%)
  IF ahead!=TRUE
    IF MID$(txt$(f_line%),x%)=f_$
      INC f_line%
    ENDIF
    IF caps!=TRUE
      REPEAT
        f_pos%=INSTR(txt$(f_line%),f_$,f_pos%+1)
        INC f_line%
      UNTIL f_pos% OR f_line%>line%
    ELSE
      f_$=UPPER$(f_$)
      REPEAT
        f_pos%=INSTR(UPPER$(txt$(f_line%)),f_$,f_pos%+1)
        INC f_line%
      UNTIL f_pos% OR f_line%>line%
    ENDIF
    DEC f_line%
  ELSE
    IF MID$(txt$(f_line%),x%)=f_$
      DEC f_line%
    ENDIF
    IF caps!=TRUE
      REPEAT
        f_pos%=INSTR(txt$(f_line%),f_$,f_pos%+1)
        DEC f_line%
      UNTIL f_pos% OR f_line%<1
    ELSE
      f_$=UPPER$(f_$)
      REPEAT
        f_pos%=INSTR(UPPER$(txt$(f_line%)),f_$,f_pos%+1)
        DEC f_line%
      UNTIL f_pos% OR f_line%<1
    ENDIF
    INC f_line%
  ENDIF
  IF f_pos%
    @set_x_y_off(f_pos%,f_line%)
  ELSE
    @not_found
  ENDIF
  wordfind!=TRUE
  @text_to_screen(off%)
RETURN
'
PROCEDURE find_all(f_$,caps!)
  find_y%=1
  CLR all%,all_off%
  current_text!=TRUE
  ARRAYFILL f_line%(),0
  IF caps!=TRUE
    FOR i%=1 TO line%
      IF INSTR(txt$(i%),f_$)
        f_line%(all%)=i%
        INC all%
      ENDIF
      EXIT IF all%>999
    NEXT i%
  ELSE
    f_$=UPPER$(f_$)
    FOR i%=1 TO line%
      IF INSTR(UPPER$(txt$(i%)),f_$)
        f_line%(all%)=i%
        INC all%
      ENDIF
      EXIT IF all%>999
    NEXT i%
  ENDIF
  IF all%>0
    @show_find_lines(0)
  ELSE
    @not_found
    @text_to_screen(off%)
  ENDIF
RETURN
'
PROCEDURE not_found
  @messagebox("Der Suchbegriff wurde nicht gefunden!  Taste...")
  ~INP(2)
RETURN
'
PROCEDURE replace(o%)
  IF f_pos%
    @save_line
    txt$(o%)=LEFT$(txt$(o%),f_pos%-1)+find$(1)+MID$(txt$(o%),f_pos%+LEN(find$(0)))
    ADD f_pos%,LEN(find$(1))
  ENDIF
  CLR wordfind!
  x%=f_pos%
  @text_to_screen(off%)
RETURN
'
PROCEDURE replace_all(o%,f1$,f2$,VAR ar$())
  LOCAL c%,f%
  DEFMOUSE 2
  REPEAT
    CLR f%
    WHILE INSTR(ar$(o%),f1$,f%)
      INC c%
      f%=INSTR(ar$(o%),f1$,f%)
      ar$(o%)=LEFT$(ar$(o%),f%-1)+f2$+MID$(ar$(o%),f%+LEN(f1$))
      ADD f%,LEN(f2$)
    WEND
    INC o%
  UNTIL o%>line%
  DEFMOUSE 0
  IF c%=0
    @not_found
  ELSE
    change!=TRUE
    CLR current_text!
    @messagebox(STR$(c%)+" Textstellen wurden ersetzt.  Taste...")
    ~INP(2)
  ENDIF
RETURN
'
PROCEDURE info
  @messagebox("")
  PRINT AT(8,4);"Text :"'text_num%''file$'CHR$(-change!*42);
  PRINT AT(8,5);"Cursor in Spalte"'x%'"und in Zeile"'y%+off%'"von"'line%;
  PRINT AT(8,7);"Auf Seite :"'1+(y%+off%-1)\form_len|'"von"'1+line%\form_len|
  PRINT AT(8,8);"Freie Zeilen :"'max2%-line%;
  PRINT AT(8,9);"Freie Druckseiten :"'max2%\form_len|-line%\form_len|;
  PRINT AT(8,11);"Taste...";
  ~INP(2)
  @text_to_screen(off%)
RETURN
'
PROCEDURE scroll_up
  @trim_right_1(ADD(y%,off%))
  IF ADD(y%,off%)<max2%
    IF y%<25
      INC y%
    ELSE
      @screen_up
    ENDIF
  ELSE
    @overflow
    @text_to_screen(off%)
  ENDIF
RETURN
'
PROCEDURE scroll_up_fast
  off%=MIN(ADD(off%,24),MAX(0,MIN(SUB(max2%,13),SUB(line%,12))))
  y%=MIN(SUB(MIN(SUCC(line%),max2%),off%),25)
  @text_to_screen(off%)
  x%=left_space%
RETURN
'
PROCEDURE scroll_down
  @trim_right_1(ADD(y%,off%))
  IF ADD(y%,off%)>1
    IF y%>1
      DEC y%
    ELSE
      @screen_dn
    ENDIF
  ENDIF
RETURN
'
PROCEDURE scroll_down_fast
  off%=MAX(SUB(off%,24),0)
  @text_to_screen(off%)
  x%=left_space%
  y%=1
RETURN
'
PROCEDURE cursor_in_block
  @messagebox("Der Cursor steht im Block!  Taste...")
  ~INP(2)
RETURN
'
PROCEDURE no_block
  @messagebox("Es ist kein Block markiert!  Taste...")
  @clear_block
  ~INP(2)
  @text_to_screen(off%)
RETURN
'
PROCEDURE block_overflow
  @messagebox("Der Block ist zu grož, max. 200 Zeilen!  Taste...")
  ~INP(2)
  @text_to_screen(off%)
RETURN
'
PROCEDURE goto_line
  LOCAL line_number$
  line_number$=STR$(line_number%)
  @messagebox(" Zeilennummer ")
  FORM INPUT 5 AS line_number$
  line_number%=MAX(VAL(line_number$),1)
  IF line_number%<=line%
    @set_x_y_off(left_space%,line_number%)
  ELSE
    @messagebox("Dieser Text hat nur "+STR$(line%)+" Zeilen!  Taste...")
    ~INP(2)
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE file_intro(mess$,ext$,VAR sel$)
  @messagebox(mess$)
  IF add!=TRUE
    PRINT AT(8,6);"> ADD-Mode <";
  ENDIF
  sel$=LEFT$(sel$,RINSTR(sel$,"\"))+"*"+ext$
RETURN
'
PROCEDURE file_exit
  HIDEM
  @text_to_screen(off%)
  SHOWM
RETURN
'
PROCEDURE save_text(add!)
  LOCAL but%
  @file_intro("Text sichern",ext$,select$)
  ~FSEL_INPUT(select$,file$,but%)
  IF but%=1 AND file$<>""
    @create_ext(".TXT",select$,file$,ext$)
    @look_exist_dat(add!,select$,".TXB")
    IF filewrite!=TRUE
      @messagebox("Text "+STR$(text_num%)+" wird als "+file$+" gesichert...")
      WHILE txt$(line%)=""
        DEC line%
      WEND
      DELETE txt$(0)
      @save(add!,select$,line%,change!,txt$())
      INSERT txt$(0)=""
    ENDIF
  ENDIF
  @file_exit
RETURN
'
PROCEDURE save_block(add!)
  LOCAL but%,i%,j%,ok!
  @file_intro("Block sichern",b_ext$,b_select$)
  ~FSEL_INPUT(b_select$,b_file$,but%)
  IF but%=1 AND b_file$<>""
    @create_ext(".TXT",b_select$,b_file$,b_ext$)
    @look_exist_dat(add!,b_select$,".TXB")
    IF filewrite!=TRUE
      @messagebox("Block wird als "+b_file$+" gesichert...")
      DIM merge_txt$(blocklen%-1)
      j%=blockstart%
      FOR i%=0 TO blocklen%-1
        SWAP merge_txt$(i%),txt$(j%)
        INC j%
      NEXT i%
      @save(add!,b_select$,blocklen%,ok!,merge_txt$())
      j%=blockstart%
      FOR i%=0 TO blocklen%-1
        SWAP merge_txt$(i%),txt$(j%)
        INC j%
      NEXT i%
    ENDIF
  ENDIF
  ERASE merge_txt$()
  @file_exit
RETURN
'
PROCEDURE look_exist_dat(add!,sel$,ext$)
  filewrite!=TRUE
  IF add!=FALSE AND EXIST(sel$)
    @messagebox("Datei existiert bereits. šberschreiben?  Y/N")
    IF BSET(INP(2),5)=121
      @create_bakfile(sel$,ext$)
    ELSE
      filewrite!=FALSE
    ENDIF
  ENDIF
RETURN
'
PROCEDURE create_bakfile(sel$,ext$)
  LOCAL bakfile$
  ON ERROR GOSUB fehler_bakfile
  IF EXIST(sel$)
    IF RINSTR(RIGHT$(sel$,4),".")
      bakfile$=LEFT$(sel$,MAX(0,RINSTR(sel$,".")-1))
    ELSE
      bakfile$=sel$
    ENDIF
    bakfile$=bakfile$+ext$
    $U
    IF EXIST(bakfile$)
      KILL bakfile$
    ENDIF
    NAME sel$ AS bakfile$
    $U
  ENDIF
  bakfile_out:
RETURN
'
PROCEDURE create_ext(def$,VAR sel$,nam$,ext$)
  sel$=LEFT$(sel$,RINSTR(sel$,"\"))
  IF RINSTR(RIGHT$(nam$,4),".")
    ext$=MID$(nam$,RINSTR(nam$,"."))
    nam$=LEFT$(nam$,RINSTR(nam$,".")-1)
  ENDIF
  IF ext$="" OR ext$="."
    ext$=def$
  ENDIF
  nam$=nam$+ext$
  sel$=sel$+nam$
RETURN
'
PROCEDURE help_loader
  LOCAL pos%,a$,b$
  ~SHEL_READ(a$,b$)
  b$="KLEINEDI.HLP"
  pos%=RINSTR(a$,"\")
  IF MID$(a$,SUCC(pos%))="KLEINEDI.PRG"
    b$=LEFT$(a$,pos%)+b$
  ENDIF
  @load(b$,-1,help$(),help_cnt%)
RETURN
'
PROCEDURE anwendung
  LOCAL nam$
  nam$=CHAR{BASEPAGE+129}
  pos%=INSTR(nam$,CHR$(13))
  IF pos%>0
    file$=LEFT$(nam$,PRED(pos%))
    @new_ext(file$,select$,ext$)
    @load(select$,max2%,txt$(),line%)
    INSERT txt$(0)=""
    @file_exit
  ELSE
    @load_text
  ENDIF
RETURN
'
PROCEDURE load_text
  LOCAL but%
  @file_intro("Text laden",ext$,select$)
  ~FSEL_INPUT(select$,file$,but%)
  IF but%=1
    @new_ext(file$,select$,ext$)
    IF EXIST(select$)
      @clear_block
      CLR change!,off%,line%,undo_line%
      ERASE txt$()
      DIM txt$(max1%)
      x%=left_space%
      y%=1
      @load(select$,max2%,txt$(),line%)
      INSERT txt$(0)=""
    ENDIF
  ENDIF
  @file_exit
RETURN
'
PROCEDURE load_block(o%)
  LOCAL but%,n%,merge_line%
  @file_intro("Block laden",b_ext$,b_select$)
  '
  ~FSEL_INPUT(b_select$,b_file$,but%)
  IF but%=1
    @new_ext(b_file$,b_select$,b_ext$)
    '
    IF EXIST(b_select$)
      merge_line%=PRED(SUB(max2%,MAX(line%,o%)))
      IF merge_line%>0
        DIM merge_txt$(merge_line%)
        @load(b_select$,-1,merge_txt$(),merge_line%)
        @create_blockspace(o%,merge_line%)
        '
        FOR n%=0 TO PRED(merge_line%)
          SWAP merge_txt$(n%),txt$(o%)
          INC o%
        NEXT n%
        ADD line%,merge_line%
      ELSE
        @overflow
      ENDIF
    ENDIF
  ENDIF
  ERASE merge_txt$()
  @file_exit
RETURN
'
PROCEDURE new_ext(nam$,VAR sel$,ext$)
  CLR current_text!
  sel$=LEFT$(sel$,RINSTR(sel$,"\"))+nam$
  IF RINSTR(RIGHT$(sel$,4),".")
    ext$=MID$(sel$,RINSTR(sel$,"."))
  ELSE
    ext$=ext$
  ENDIF
RETURN
'
PROCEDURE save(add!,name$,anz%,VAR ok!,array$())
  DEFMOUSE 2
  LET name$=UPPER$(name$)+CHR$(0)
  ON ERROR GOSUB fehler_text_save
  $U
  IF add!=TRUE AND EXIST(name$)
    OPEN "a",#1,name$
  ELSE
    OPEN "o",#1,name$
  ENDIF
  STORE #1,array$(),anz%
  CLR ok!
  $U
  text_save_out:
  CLOSE #1
  DEFMOUSE 0
RETURN
'
PROCEDURE load(name$,maxi%,VAR array$(),anz%)
  DEFMOUSE 2
  ON ERROR GOSUB fehler_text_load
  $U
  OPEN "i",#1,name$
  IF overflow$=name$
    SEEK #1,loc%
  ENDIF
  RECALL #1,array$(),maxi%,anz%
  IF EOF(#1)=FALSE
    loc%=LOC(#1)
    overflow$=name$
    @overflow
  ELSE
    CLR loc%,overflow$
  ENDIF
  $U
  text_load_out:
  CLOSE #1
  DEFMOUSE 0
RETURN
'
PROCEDURE tabs_to_spaces
  LOCAL i%,pos%
  FOR i%=1 TO line%
    WHILE INSTR(txt$(i%),CHR$(9))
      change!=TRUE
      pos%=INSTR(txt$(i%),CHR$(9))
      txt$(i%)=LEFT$(txt$(i%),pos%-1)+SPACE$(8-(pos% MOD 8))+MID$(txt$(i%),pos%+1)
    WEND
  NEXT i%
  @text_to_screen(off%)
RETURN
'
PROCEDURE sonderzeichen
  @messagebox("Sonderzeichen (ASCII-Code):")
  FORM INPUT 3 AS asc$
  asc|=VAL(asc$)
  IF asc|>0
    @create_linepart(over|,x%,ADD(y%,off%),CHR$(asc|))
    INC x%
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE backspace(o%)
  IF x%>1
    @save_line
    DEC x%
    @delete_char
  ENDIF
RETURN
'
PROCEDURE insert_char
  txt$=CHR$(asc|)+MID$(txt$(o%),x%+over|)
  txt$(o%)=LEFT$(txt$(o%),PRED(x%))+txt$
  ~C:qwrt%(L:screen%,L:V:txt$,W:LEN(txt$),W:x%,W:y%)
  IF format|=1
    IF asc|=32
      @format_1
      @format_2
    ENDIF
  ENDIF
RETURN
'
PROCEDURE delete_char
  txt$(o%)=LEFT$(txt$(o%),x%-1)+MID$(txt$(o%),x%+1)
  ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:y%)
RETURN
'
PROCEDURE tab
  LOCAL n%
  IF x%<80
    REPEAT
      INC n%
    UNTIL tab|(n%)>x% OR n%>29
    IF tab|(n%)>x%
      step%=tab|(n%)-x%
    ENDIF
    ADD x%,step%
  ENDIF
RETURN
'
PROCEDURE space_tab
  LOCAL n%
  IF x%<80
    REPEAT
      INC n%
    UNTIL tab|(n%)>x% OR n%>29
    IF tab|(n%)>x%
      step%=tab|(n%)-x%
      @write_linepart(0,ADD(y%,off%),SPACE$(step%),x%)
    ENDIF
  ENDIF
RETURN
'
PROCEDURE tab_set
  LOCAL n%
  tab|(0)=x%
  QSORT tab|()
  FOR n%=0 TO 29
    IF tab|(n%)=tab|(n%+1)
      tab|(n%)=0
      tab|(n%+1)=0
    ENDIF
  NEXT n%
  QSORT tab|()
RETURN
'
PROCEDURE clear_text
  @messagebox("Text L”schen?  Y/N")
  IF BSET(INP(2),5)=121
    ERASE txt$()
    DIM txt$(max1%)
    x%=left_space%
    y%=1
    @clear_block
    CLR change!,line%,off%,loc%,overflow$
    file$="NO_NAME.TXT"
    ext$=".TXT"
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE undo
  IF line_delete!=TRUE
    @undelete(ADD(y%,off%))
    CLR line_delete!
  ELSE IF undo_line%=ADD(y%,off%)
    undo!=TRUE
    SWAP txt$(ADD(y%,off%)),undo_line$
    ~C:qvdi%(L:V:txt$(ADD(y%,off%)),W:LEN(txt$(ADD(y%,off%))),W:y%)
    x%=left_space%
  ENDIF
RETURN
'
PROCEDURE undelete(o%)
  IF line%<max2%
    OUT 2,27,76
    @inc_blockmarks
    INSERT txt$(o%)=delete_line$
    ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:y%)
  ELSE
    @overflow
    @text_to_screen(off%)
  ENDIF
  x%=left_space%
RETURN
'
PROCEDURE change_text
  IF dual!=TRUE
    CLR current_text!
    SWAP store_line_delete!,line_delete!
    SWAP store_change!,change!
    SWAP store_undo_line%,undo_line%
    SWAP store_delete_line$,delete_line$
    SWAP store_undo_line$,undo_line$
    SWAP store_text_num%,text_num%
    SWAP store_line%,line%
    SWAP store_off%,off%
    SWAP store_x%,x%
    SWAP store_y%,y%
    SWAP store_left_space%,left_space%
    SWAP store_right_space%,right_space%
    SWAP store_mark_x%,short_mark_x%
    SWAP store_mark_y%,short_mark_y%
    SWAP store_blockmark!,blockmark!
    SWAP store_firstmark!,firstmark!
    SWAP store_blockstart%,blockstart%
    SWAP store_blockend%,blockend%
    SWAP store_blocklen%,blocklen%
    SWAP store_tab|(),tab|()
    SWAP store$(),txt$()
    SWAP store_ext$,ext$
    SWAP store_file$,file$
    SWAP store_select$,select$
  ELSE
    @messagebox("Umschalten ist nicht m”glich, nur ein Text.  Taste...")
    ~INP(2)
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE format_1
  LOCAL newlen%,buf$
  IF LEN(txt$(o%))>80-right_space%
    space%=RINSTR(txt$(o%)," ",82-right_space%)
    IF space%>0
      format!=TRUE
      CLR undo_line%
      buf$=MID$(txt$(o%),space%)
      buf$=SPACE$(PRED(left_space%))+TRIM$(buf$)
      txt$(o%)=LEFT$(txt$(o%),PRED(space%))
      IF txt$(SUCC(o%))=""
        INSERT txt$(SUCC(o%))=buf$
        @inc_blockmarks
      ELSE
        txt$(SUCC(o%))=buf$+" "+TRIM$(txt$(SUCC(o%)))
      ENDIF
    ENDIF
    INC o%
    @format_1
  ENDIF
RETURN
'
PROCEDURE format_2
  IF format!=TRUE
    IF LEN(TRIM$(MID$(txt$(ADD(y%,off%)),x%)))=0
      newlen%=LEN(txt$(ADD(y%,off%)))
      IF PRED(x%)>newlen%
        SUB x%,newlen%
        ADD x%,left_space%
        DEC x%
      ELSE
        x%=left_space%
      ENDIF
      @set_x_y_off(x%,SUCC(ADD(y%,off%)))
      @create_linepart(0,x%,ADD(y%,off%),CHR$(32))
      DEC x%
    ENDIF
    @text_to_screen(off%)
    CLR current_text!,format!
  ENDIF
RETURN
'
PROCEDURE text_format(left%,right%,start%,VAR end%)
  LOCAL puffer$,count%,fill%,max_len%,pos%
  @set_x_y_off(left%,start%)
  DEC left%
  change!=TRUE
  CLR current_text!
  max_len%=82-left%-right%
  '
  count%=start%
  WHILE count%<end%
    puffer$=puffer$+TRIM$(txt$(count%))+" "
    txt$(count%)=""
    INC count%
  WEND
  '
  count%=start%
  '
  WHILE LEN(puffer$)
    pos%=INSTR(puffer$," ")
    IF count%=end%
      INSERT txt$(end%)=""
      INC end%
      INC line%
    ENDIF
    IF pos%>=max_len%
      txt$(count%)=LEFT$(puffer$,pos%)
      fill%=80
      SUB fill%,LEN(txt$(count%))
      fill%=MAX(fill%,0)
      DIV fill%,2
      txt$(count%)=SPACE$(fill%)+txt$(count%)
    ELSE
      pos%=RINSTR(puffer$," ",max_len%)
      IF pos%
        txt$(count%)=LEFT$(puffer$,pos%)
        txt$(count%)=SPACE$(left%)+TRIM$(txt$(count%))
      ENDIF
    ENDIF
    '
    INC pos%
    INC count%
    puffer$=MID$(puffer$,pos%)
  WEND
  '
  IF count%<end%
    @remove_blockspace(count%,end%)
    line%=SUB(ADD(line%,count%),end%)
    end%=count%
  ENDIF
  '
  text_to_screen(off%)
RETURN
'
PROCEDURE remove_blockspace(a%,e%)
  WHILE a%<line%
    SWAP txt$(a%),txt$(e%)
    INC a%
    INC e%
  WEND
RETURN
'
PROCEDURE result_mode(VAR r_mode%)
  @messagebox("Welches Zahlensystem fr das Rechenergebnis?")
  PRINT AT(8,6);"B'in  O'kt  D'ez  H'ex  $'Hex";
  SELECT BSET(INP(2),5)
  CASE 98
    r_mode%=1
  CASE 111
    r_mode%=2
  CASE 100
    r_mode%=3
  CASE 104
    r_mode%=4
  CASE 36,52
    r_mode%=5
  ENDSELECT
  @text_to_screen(off%)
RETURN
'
PROCEDURE trim_right  ! schneidet rechte Leerzeichen ab
  txt$(o%)=LEFT$(txt$(o%),C:trim_r%(L:LEN(txt$(o%)),L:V:txt$(o%)))
  IF x%>LEN(txt$(o%))
    txt$(o%)=txt$(o%)+SPACE$(PRED(x%-LEN(txt$(o%))))
  ENDIF
RETURN
'
PROCEDURE trim_right_1(o%)  ! schneidet rechte Leerzeichen ab
  txt$(o%)=LEFT$(txt$(o%),C:trim_r%(L:LEN(txt$(o%)),L:V:txt$(o%)))
RETURN
'
PROCEDURE switch_on(mess$,VAR on|)
  IF on|=0
    @messagebox(mess$+" ein?  Y/N")
    IF BSET(INP(2),5)=121
      on|=1
    ENDIF
  ELSE IF on|=1
    @messagebox(mess$+" aus?  Y/N")
    IF BSET(INP(2),5)=121
      on|=0
    ENDIF
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE delete_line(o%)
  IF o%<=line%
    x%=left_space%
    @dec_blockmarks
    delete_line$=txt$(o%)
    line_delete!=TRUE
    DELETE txt$(o%)
    OUT 2,27,77
    bot%=ADD(25,off%)
    ~C:qvdi%(L:V:txt$(bot%),W:LEN(txt$(bot%)),W:25)
    LONG{XBIOS(14,1)+6}=0
  ENDIF
RETURN
'
PROCEDURE insert_line(o%)
  IF line%<max2%
    x%=left_space%
    @inc_blockmarks
    @trim_right_1(o%)
    OUT 2,27,76
    INSERT txt$(o%)=""
  ELSE
    @overflow
    @text_to_screen(off%)
  ENDIF
RETURN
'
PROCEDURE connect_lines(o%)
  IF line%>1
    @trim_right
    txt$(o%)=txt$(o%)+TRIM$(txt$(SUCC(o%)))
    DELETE txt$(SUCC(o%))
    @dec_blockmarks
    @text_to_screen(off%)
  ENDIF
RETURN
'
PROCEDURE crack_lines(s%,o%)
  IF line%<max2%
    @inc_blockmarks
    INSERT txt$(SUCC(o%))=SPACE$(PRED(left_space%))+TRIM$(MID$(txt$(o%),s%))
    txt$(o%)=LEFT$(txt$(o%),PRED(s%))
  ELSE
    @overflow
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE dec_blockmarks
  change!=TRUE
  CLR current_text!
  IF blockmark!
    IF o%<blockstart%
      DEC blockstart%
    ENDIF
    IF o%<blockend%
      DEC blockend%
    ENDIF
    IF blockstart%=blockend%
      @clear_block
    ENDIF
    blocklen%=blockend%-blockstart%
  ENDIF
  line%=MAX(0,PRED(line%))
RETURN
'
PROCEDURE inc_blockmarks
  change!=TRUE
  CLR current_text!
  IF blockmark!
    IF o%<=blockstart%
      INC blockstart%
    ENDIF
    IF o%<blockend%
      INC blockend%
    ENDIF
    blocklen%=blockend%-blockstart%
  ENDIF
  line%=MAX(o%,SUCC(line%))
RETURN
'
PROCEDURE maus
  LOCAL x1%,y1%,border%,t%
  DEFLINE &X11111111111111111010101010101011,1,2,2
  GRAPHMODE 3
  HIDEM
  IF BIOS(11,-1) AND 4
    IF rectblock|=1
      @put_rectblock
    ELSE
      @put_flexblock
    ENDIF
    OUT 2,27,102
    @text_to_screen(off%)
    LOCATE x%,y%
    OUT 2,27,101
    @park
  ELSE
    border%=SUB(max2%,13)
    x1%=MOUSEX
    y1%=MOUSEY
    x%=SHR(x1%,3)
    INC x%
    y%=SHR(y1%,4)
    y%=MIN(SUCC(y%),SUB(max2%,off%))
    OUT 2,27,102
    IF y1%<16
      WHILE MOUSEK=1 AND off%
        @screen_dn
      WEND
    ELSE IF y1%>384
      WHILE MOUSEK=1 AND off%<border%
        @screen_up
      WEND
    ENDIF
    LOCATE x%,y%
    OUT 2,27,101
    t%=TIMER
    WHILE x1%=MOUSEX AND y1%=MOUSEY
      EXIT IF MOUSEK=0
      IF TIMER-t%>80
        OUT 2,27,102
        IF rectblock|=0
          @mark_flexblock
        ELSE
          @mark_rectblock
        ENDIF
        @text_to_screen(off%)
        LOCATE x%,y%
        OUT 2,27,101
      ENDIF
    WEND
  ENDIF
  SHOWM
RETURN
'
PROCEDURE mark_flexblock
  LOCAL c&,x1&,y1&,x2&,y2&
  x1&=SUB(SHL(x%,3),8)
  y1&=SHL(y%,4)
  DEC y1&
  WHILE MOUSEK=1
    y2&=MAX(y1&,ADD(16,SHL(SHR(MOUSEY,4),4)))
    DEC y2&
    IF y1&=y2&
      x2&=MAX(x1&,ADD(8,SHL(SHR(MOUSEX,3),3)))
      LINE x1&,y1&,x2&,y1&
      @parking
      LINE x1&,y1&,x2&,y1&
    ELSE IF y2&>y1&
      x2&=SHL(SHR(MOUSEX,3),3)
      @marklines
      @parking
      @marklines
    ENDIF
  WEND
RETURN
'
PROCEDURE marklines
  LINE x1&,y1&,639,y1&
  c&=ADD(y1&,16)
  WHILE c&<y2&
    LINE 0,c&,639,c&
    ADD c&,16
  WEND
  LINE 0,y2&,x2&,y2&
RETURN
'
PROCEDURE parking
  LOCAL x&,y&
  x&=MOUSEX
  y&=MOUSEY
  WHILE MOUSEX=x& AND MOUSEY=y&
    IF MOUSEK=0
      x&=SHR(x2&,3)
      y&=SHR(y2&,4)
      INC y&
      @get_flexblock
    ENDIF
  WEND
RETURN
'
PROCEDURE get_flexblock
  LOCAL o%,del!
  @mausblock_message
  IF BSET(INP(2),5)=121
    change!=del!
    o%=ADD(y%,off%)
    IF y%=y&
      INC x&
      block$=MID$(txt$(o%),x%,SUB(x&,x%))
      IF del!=TRUE
        txt$(o%)=LEFT$(txt$(o%),PRED(x%))+MID$(txt$(o%),x&)
      ENDIF
    ELSE
      DEC y&
      block$=TRIM$(MID$(txt$(o%),x%))+" "
      IF del!=TRUE
        txt$(o%)=LEFT$(txt$(o%),PRED(x%))
      ENDIF
      INC o%
      WHILE y&>y%
        block$=block$+TRIM$(txt$(o%))+" "
        IF del!=TRUE
          DELETE txt$(o%)
        ELSE
          INC o%
        ENDIF
        DEC y&
      WEND
      block$=block$+TRIM$(LEFT$(txt$(o%),x&))+" "
      IF del!=TRUE
        txt$(o%)=MID$(txt$(o%),SUCC(x&))
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE put_flexblock
  LOCAL o%
  @putbox(8,16)
  IF line%<max2%
    o%=ADD(y%,off%)
    @create_linepart(over|,x%,o%,block$)
    @format_1
  ELSE
    @overflow
  ENDIF
RETURN
'
PROCEDURE mark_rectblock
  LOCAL n%,del!
  mx1%=SHL(SHR(MOUSEX,3),3)
  my1%=SHL(SHR(MOUSEY,4),4)
  WHILE MOUSEK=1
    mx2%=MAX(mx1%,SHL(SHR(MOUSEX,3),3))
    my2%=MAX(my1%,SHL(SHR(MOUSEY,4),4))
    ADD mx2%,7
    ADD my2%,15
    BOX mx1%,my1%,mx2%,my2%
    PAUSE 1
    BOX mx1%,my1%,mx2%,my2%
  WEND
  @mausblock_message
  IF BSET(INP(2),5)=121
    mbx1%=SHR(mx1%,3)
    INC mbx1%
    mby1%=SHR(my1%,4)
    INC mby1%
    mbx2%=SHR(mx2%,3)
    INC mbx2%
    mby2%=SHR(my2%,4)
    INC mby2%
    '
    change!=del!
    CLR rectline%
    ERASE rectblock$()
    DIM rectblock$(24)
    FOR n%=mby1% TO mby2%
      rectblock$(rectline%)=MID$(txt$(n%+off%),mbx1%,SUCC(mbx2%-mbx1%))
      IF del!=TRUE
        txt$(n%+off%)=LEFT$(txt$(n%+off%),PRED(mbx1%))+MID$(txt$(n%+off%),SUCC(mbx2%))
      ENDIF
      INC rectline%
    NEXT n%
    mx3%=SUB(mx2%,mx1%)
    my3%=SUB(my2%,my1%)
  ENDIF
RETURN
'
PROCEDURE put_rectblock
  LOCAL n%
  @putbox(mx3%,my3%)
  WHILE n%<rectline%
    EXIT IF ADD(y%,off%)>max2%
    @create_linepart(over|,x%,ADD(y%,off%),rectblock$(n%))
    INC n%
    IF y%<25
      INC y%
    ELSE
      INC off%
    ENDIF
  WEND
RETURN
'
PROCEDURE mausblock_message
  IF BIOS(11,-1)=8
    del!=TRUE
    @messagebox("Mausblock ausschneiden?  Y/N")
  ELSE
    @messagebox("Mausblock bernehmen?  Y/N")
  ENDIF
RETURN
'
PROCEDURE putbox(adx%,ady%)
  WHILE MOUSEK=1
    mx1%=SHL(SHR(MOUSEX,3),3)
    my1%=SHL(SHR(MOUSEY,4),4)
    mx2%=ADD(mx1%,adx%)
    my2%=ADD(my1%,ady%)
    BOX mx1%,my1%,mx2%,my2%
    PAUSE 1
    BOX mx1%,my1%,mx2%,my2%
  WEND
  x%=ADD(1,SHR(mx1%,3))
  y%=ADD(1,SHR(my1%,4))
RETURN
'
PROCEDURE zentri(o%)
  LOCAL fill%
  fill%=80
  txt$(o%)=TRIM$(txt$(o%))
  SUB fill%,LEN(txt$(o%))
  DIV fill%,2
  txt$(o%)=SPACE$(fill%)+txt$(o%)
  ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:y%)
  @scroll_up
RETURN
'
PROCEDURE border_set(left!,o%)
  txt$(o%)=TRIM$(txt$(o%))
  IF LEN(txt$(o%))
    IF left!=TRUE
      txt$(o%)=SPACE$(SUB(left_space%,1))+txt$(o%)
    ELSE
      txt$(o%)=SPACE$(80-right_space%-LEN(txt$(o%)))+txt$(o%)
    ENDIF
  ENDIF
  ~C:qvdi%(L:V:txt$(o%),W:LEN(txt$(o%)),W:y%)
  @scroll_up
RETURN
'
PROCEDURE linker_rand
  @messagebox("linker Rand?")
  LOCATE 24,4
  left_space$=STR$(left_space%-1)
  FORM INPUT 2 AS left_space$
  left_space%=VAL(left_space$)+1
  left_space%=MAX(1,MIN(36,left_space%))
  x%=left_space%
  @text_to_screen(off%)
RETURN
'
PROCEDURE rechter_rand
  @messagebox("rechter Rand?")
  LOCATE 25,4
  right_space$=STR$(right_space%)
  FORM INPUT 2 AS right_space$
  right_space%=VAL(right_space$)
  right_space%=MAX(0,MIN(35,right_space%))
  @text_to_screen(off%)
RETURN
'
PROCEDURE seiten_len
  @messagebox("Seitenl„nge?")
  LOCATE 24,4
  form_len$=STR$(form_len|)
  FORM INPUT 2 AS form_len$
  form_len|=VAL(form_len$)
  form_len|=MAX(1,MIN(66,form_len|))
  @text_to_screen(off%)
RETURN
'
PROCEDURE switch_single_dual
  IF dual!=TRUE
    @messagebox("Umschalten auf einen Text?  Y/N")
  ELSE
    @messagebox("Umschalten auf zwei Texte?  Y/N")
  ENDIF
  PRINT AT(8,6);"VORSICHT! Textspeicher wird dabei gel”scht!";
  IF BSET(INP(2),5)=121
    CLR all%,all_off%,current_text!,undo!
    CLR loc%,overflow$
    CLR store_line%,line%
    CLR store_off%,off%,bot%  ! bot% ist nur fr das ADD(25,off%) gut
    CLR store_blockmark!,blockmark!
    CLR store_firstmark!,firstmark!
    CLR store_blockstart%,blockstart%
    CLR store_blockend%,blockend%
    CLR store_blocklen%,blocklen%
    CLR store_undo_line%,undo_line%
    CLR line_delete!,undo_line$,delete_line$
    CLR store_line_delete!,store_undo_line$,store_delete_line$
    CLR store_change!,change!,wordfind!    !...change! soll Žnderungen melden
    ERASE txt$(),store$()
    @text_array_init
    IF dual!=TRUE
      max1%=max%
      DIM txt$(max1%)
      max2%=max1%-13
      dual!=FALSE
    ELSE
      max1%=max%/2
      DIM txt$(max1%),store$(max1%)
      max2%=max1%-13
      dual!=TRUE
    ENDIF
  ENDIF
  @text_to_screen(off%)
RETURN
'
PROCEDURE preview
  LOCAL c&,p&,y&,s%
  OUT 2,27,101
  DEFLINE 1,1,0,0
  DEFFILL 1,0
  GRAPHMODE 1
  BOUNDARY 1
  PBOX 382,11,624,372       ! = 12 Inch, oben und unten je 1 Inch frei
  p&=MUL(form_len|,PRED(ADD(y%,off%))\form_len|)
  y&=SUB(ADD(y%,off%),p&)
  MUL y&,5
  ADD y&,34
  s%=screen%+3248
  FOR c&=SUCC(p&) TO ADD(p&,form_len|)
    '
    ~C:preview%(L:V:txt$(c&),L:s%,W:LEN(txt$(c&)))
    ADD s%,400
    '
  NEXT c&
  BOX ADD(380,MUL(3,x%)),y&,ADD(382,MUL(3,x%)),ADD(y&,4)
  ~INP(2)
  OUT 2,27,102
  @text_to_screen(off%)
RETURN
'
PROCEDURE messagebox(mess$)
  BOUNDARY 0
  GRAPHMODE 2
  DEFFILL 1,2,4
  PBOX 48,200,623,216
  PBOX 608,48,623,216
  BOUNDARY 1
  GRAPHMODE 1
  DEFFILL 1,0
  PBOX 32,32,607,200
  PRINT AT(8,4);mess$;
RETURN
'
PROCEDURE edit_end
  @messagebox("Text-Editor verlassen?  Y/N")
  IF change!=TRUE OR store_change!=TRUE
    PRINT AT(8,6);"Texte werden als SCRAP_1.TXT bzw. SCRAP_2.TXT gesichert!";
  ENDIF
  IF BSET(INP(2),5)=121
    IF change!=TRUE
      select$=LEFT$(select$,RINSTR(select$,"\"))+"SCRAP_1.TXT"
      DELETE txt$(0)
      @save(FALSE,select$,line%,change!,txt$())
    ENDIF
    IF store_change!=TRUE
      store_select$=LEFT$(store_select$,RINSTR(store_select$,"\"))+"SCRAP_2.TXT"
      DELETE store$(0)
      @save(FALSE,store_select$,store_line%,store_change!,store$())
    ENDIF
    EDIT
  ENDIF
  @text_to_screen(off%)
RETURN
'
