$E$ B+ N+ C+ U- I-
version$="v0.012"               ! DAA, IN r,(C)
@msx                            ! LD R,A <-- Wat is R??   LD A,R
$P>
> PROCEDURE msx                           ! Main-Menu, init & go Z80
  LOCAL file$,dummy&
  '
  @init
  '
  IF NOT exit!
    '
    DO
      DO
        CLR dummy!
        '
        ALERT 0,"Set-Up, start or more? ",2," Set-Up | Start | More ",dummy&
        '
        $S& S<
        SELECT dummy&
        CASE 1
          '
          @set_up
          dummy!=TRUE
          '
        CASE 2                ! Start
          '
          IF started!
            @reset_msx
          ELSE
            started!=TRUE
          ENDIF
          '
        CASE 3                ! Other
          '
          DO
            ALERT 0,"Exit, Disassem. or |previous menu? ",3," Exit | Diss. | Prev. ",dummy&
            SELECT dummy&
            CASE 1
              @end
            CASE 2
              CLS
              INPUT "Start: ";start%
              INPUT "End: ";end%
              IF end%<start%
                SWAP end%,start%
              ENDIF
              file$=@fileselect$("Select file to write to")
              IF file$<>""
                HIDEM
                path$=LEFT$(file$,RINSTR(file$,"\"))
                IF EXIST(file$)
                  OPEN "A",#1,file$
                ELSE
                  OPEN "O",#1,file$
                ENDIF
                DO
                  ADD start%,@disassem(start%,1)
                LOOP UNTIL start%=>end%
                CLOSE #1
              ENDIF
            CASE 3
              dummy!=TRUE
            DEFAULT
              error_exit&=err_internal_error&
            ENDSELECT
          LOOP UNTIL dummy!
        DEFAULT
          error_exit&=err_internal_error&
        ENDSELECT
        $S% S>
        '
      LOOP WHILE dummy!
      '
      HIDEM
      '
      CLS
      COLOR 1
      lowest_y_line&=WORK_OUT(1)
      ARRAYFILL cpu_usage&(),lowest_y_line&
      BOX 320,0,327,lowest_y_line&
      '
      program_counter%=ram_start%
      '
      ALERT 2,"Debugging?",0," Yes | No ",dummy&
      emul_mode!=dummy&=1
      '
      start_emulation_time%=TIMER
      start_tijd%=start_emulation_time%
      DO
        CLR exit!
        HIDEM
        '
        IF emul_mode!
          @do_z80.d
        ELSE
          @do_z80
        ENDIF
        '
        $S& S<
        SELECT error_exit&
        CASE err_return_to_main_menu&
          '
          exit!=TRUE
          '
        CASE err_no_error&
          '
          ALERT 2,"INTERNAL ERROR! -> No error! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_not_enough_main_ram&
          '
          ALERT 3,"Not enough memory! ",1," Exit ",dummy&
          exit!=TRUE
          '
        CASE err_not_enough_video_ram&
          '
          ALERT 3,"Not enoug memory! [2] ",1," Exit ",dummy&
          exit!=TRUE
          '
        CASE err_unknown_error&
          '
          ALERT 2,"Error: unknown MSX-hardware! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_mem_pointer_error&
          '
          ALERT 2,"Memory-pointer overflow! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_wrong_mem_page&
          '
          ALERT 2,"Unknown memory-page selected! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_z80_instruction&
          '
          ALERT 2,"Unknown Z80-instruction! |Exit? ",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_internal_error&
          '
          ALERT 2,"Unknown internal error! |Exit? ",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_vdp_register&
          '
          ALERT 2,"Unknown VDP-Register accessed!|Exit? ",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_vdp_status_reg&
          '
          ALERT 2,"Unknown VDP status-|register accessed! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_fm_pac_reg&
          '
          ALERT 2,"Unknown FM-Pac |register accessed! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_no_mem_mapper&
          '
          ALERT 2,"No memory-mapper while|accessing it! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_vdp_mode&
          '
          ALERT 2,"Unknown VDP-mode! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_no_bios&
          '
          ALERT 2,"Can't find BIOS-Dump(s)! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_romload_error&
          '
          ALERT 3,"No memory reserved for BIOS! ",0," Exit ",dummy&
          exit!=TRUE
          '
        CASE err_unknown_vdp_l.operation&
          '
          ALERT 2,"Unknown logical operation |for VDP-command! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_unknown_vdp_command&
          '
          ALERT 2,"Unknown VDP-Command! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_vdp_illegal_mode&
          '
          ALERT 2,"Illegal VDP-mode while |executing VDP-Command! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        CASE err_no_extra_vdp_mem&
          '
          ALERT 2,"No extra VDP-memory while |trying to access! |Exit?",0," Yes | No ",dummy&
          exit!=dummy&=1
          '
        DEFAULT
          '
          ALERT 3,"Unknown error! ["+STR$(error_exit&)+"] ",1," Exit ",dummy&
          exit!=TRUE
          '
        ENDSELECT
        $S% S>
        '
        CLR error_exit&
      LOOP UNTIL exit!
      '
      PRINT AT(1,max_row&);"Took: ";DIV(SUB(TIMER,start_tijd%),200);" seconds.";
      '
    LOOP
    '
  ENDIF
  '
  @end
  '
RETURN
> PROCEDURE set_up                        ! Edit Configuration
  LOCAL dummy&,file$,dummy$
  '
  DO
    '
    ALERT 0,"Load file, |change configuration or |return to main-menu? ",0," Load | Config | Back ",dummy&
    '
    $S& S<
    SELECT dummy&
    CASE 1
      '
      DO
        '
        file$=@fileselect$("Select file to load")
        HIDEM
        '
        IF EXIST(file$)
          path$=LEFT$(file$,RINSTR(file$,"\"))
          '
          @load_bsave(file$,TRUE)
          '
        ELSE IF file$=""
          '
          ALERT 0,"Start, retry or exit? ",1," Start | Retry | Exit ",dummy&
          HIDEM
          $S& S<
          SELECT dummy&
          CASE 1            ! Start
            EXIT IF TRUE
          CASE 2            ! Retry
            '
          CASE 3            ! Exit
            @end
          DEFAULT
            error_exit&=err_internal_error&
          ENDSELECT
          '
        ENDIF
        '
      LOOP
      '
    CASE 2
      '
      DO
        CLS
        PRINT "01] Fast Scr.0: ";@onf$(fast_screen_0!)
        PRINT "02] Fast Scr.1: ";@onf$(fast_screen_1!)
        PRINT "03] NoRam-exit: ";@onf$(NOT unused_random!)
        PRINT "04] Unoff. z80: ";@onf$(unofficial_z80_commands!)
        PRINT "05] Z80-bugs..: ";@onf$(known_bugs!)
        PRINT "06] Debug.....: ";@onf$(debug!)
        PRINT "07] S.Step....: ";@onf$(single_step!)
        PRINT "08] Status....: ";@onf$(show_emulator_status!)
        PRINT "09] Dis.Point.: p";HEX$(diss_pointer%,4);"q"
        PRINT "10] Key.Debug.: ";@onf$(keyboard_debug!)
        PRINT "11] Show Speed: ";@onf$(relative_speed_calculation!)
        PRINT "12] Real Vsync: ";@onf$(vsync!)
        PRINT "13] Int. 38H..: ";@onf$(int_0x38!)
        PRINT "14] Real 50Hz.: ";@onf$(real_nmi!)
        PRINT "15] Always VSc: ";@onf$(always_vsync!)
        PRINT "16] Int. Level: p";interrupt_level&;"q"
        PRINT "17] 2nd Slots.: ";@onf$(secundairy_slots!)
        PRINT "18] Colors....: ";@onf$(colors!)
        PRINT "19] Keybuf-Len: p";SUCC(max_bufkeys&);"q"
        PRINT "20] SMP data-r: ";@onf$(emulate_data_recorder!)
        PRINT "21] Mem.Mapper: ";@onf$(mem_mapper!)
        PRINT "22] ROM-Patch.: ";@onf$(msx_rom_patches!)
        PRINT "23] SCC-Emul..: ";@onf$(konami_scc!)
        '
        PRINT AT(30,1);"24] FM-Pac....: ";@onf$(fm_pac!);       ! ----> slot!!!!!
        PRINT AT(30,2);"25] Patches...: ";@onf$(patches!);
        PRINT AT(30,3);"26] SCC-Slot..: p";konami_scc_slot&;",";konami_scc_sslot&;"q";
        PRINT AT(30,4);"27] Rl. 250kHz: ";@onf$(real_250khz!);
        PRINT AT(30,5);"28] Load BIOS.: ";@onf$(load_bios!);
        PRINT AT(30,6);"29] Load DskRM: ";@onf$(load_diskrom!);
        PRINT AT(30,7);"30] Mapper Slt: p";memory_mapper&;",";memory_smapper&;"q";
        PRINT AT(30,8);"31] Bios Slot.: p";msx_bios_slot&;",";msx_bios_2nd_slot&;"q";
        PRINT AT(30,9);"32] DiskRSlot.: p";diskrom_slot&;",";diskrom_sslot&;"q";
        PRINT AT(30,10);"33] Kanji ROM.: ";@onf$(kanji_rom!);
        PRINT AT(30,11);"34] RS232C....: ";@onf$(rs232c!);
        PRINT AT(30,12);"35] Printer...: ";@onf$(printer!);
        PRINT AT(30,13);"36] Joystick..: ";@onf$(joystick!);
        PRINT AT(30,14);"37] Music Mod.: ";@onf$(mmod!);
        PRINT AT(30,15);"38] Fast BMOVE: ";@onf$(fbmove!);
        PRINT AT(30,16);"39] Fast Scr.8: ";@onf$(fast_screen_8!);
        PRINT AT(30,17);"40] Disk Drive: ";@onf$(disk_drive!);
        PRINT AT(30,18);"41] VRAM Size.: ";HEX$(video_mem_length%,5);
        PRINT AT(30,19);"42] PSG.......: ";@onf$(emul_psg!);
        PRINT AT(30,20);"43] LPen/Mouse: ";@onf$(light.pen_mouse!);
        PRINT AT(30,21);"44] Exit Port.: p";exit_port&;"q";
        PRINT AT(30,22);"45] CPU Usage.: ";@onf$(cpu_usage!);
        PRINT AT(30,23);"46] Mem. Conf.";
        '
        PRINT AT(60,1);"47] MSX-Type..: p";msx_type&;"q";
        PRINT AT(60,2);"48] H.DrvEmul.: ";@onf$(highlevel_drive!);
        PRINT AT(60,3);"49] PRN 2 File: ";@onf$(redirect_printer!);
        PRINT AT(60,4);"50] SCC+......: ";@onf$(scc_plus!);
        PRINT AT(60,5);"51] VRam=Ram..: ";@onf$(video_in_page!);
        PRINT AT(60,6);"52] Device....: ";@onf$(device_emul!);  ! ----> slot!!!!
        PRINT AT(60,7);"53] ROM-Prot..: ";@onf$(NOT no_rom_prot.!);
        PRINT AT(60,8);"54] MSXPRNemul: ";@onf$(msx_2_epson!);
        PRINT AT(60,9);"55] MSX-Audio.: ";@onf$(msx_audio!);    ! ----> slot!!!!
        PRINT AT(60,10);"56] True Color: ";@onf$(truecolor!);
        PRINT AT(60,11);"57] Real Color: ";@onf$(pal.real!);
        '
        PRINT AT(1,max_row&);"99] Done";AT(40,max_row&);"Change what: ";
        DO
          dummy$=INPUT$(1)
        LOOP UNTIL INSTR("0123456789",dummy$)
        PRINT dummy$;
        DO
          dummy$=LEFT$(dummy$)+INPUT$(1)
          SELECT RIGHT$(dummy$)
          CASE 8
            CLR dummy$
          CASE 13
            dummy$=LEFT$(dummy$)
            EXIT IF TRUE
          ENDSELECT
        LOOP UNTIL INSTR("0123456789",RIGHT$(dummy$))
        IF LEN(dummy$)>1
          PRINT RIGHT$(dummy$);
        ENDIF
        '
        SELECT VAL(dummy$)
        CASE 1
          fast_screen_0!=NOT fast_screen_0!
          @set_res
        CASE 2
          fast_screen_1!=NOT fast_screen_1!
          @set_res
        CASE 3
          unused_random!=NOT unused_random!
        CASE 4
          unofficial_z80_commands!=NOT unofficial_z80_commands!
        CASE 5
          known_bugs!=NOT known_bugs!
        CASE 6
          debug!=NOT debug!
        CASE 7
          single_step!=NOT single_step!
        CASE 8
          show_emulator_status!=NOT show_emulator_status!
        CASE 9
          PRINT AT(17,9);
          FORM INPUT 4,dummy$
          diss_pointer%=VAL("&H"+dummy$)
        CASE 10
          keyboard_debug!=NOT keyboard_debug!
        CASE 11
          relative_speed_calculation!=NOT relative_speed_calculation!
        CASE 12
          LET vsync!=NOT vsync!
        CASE 13
          int_0x38!=NOT int_0x38!
        CASE 14
          real_nmi!=NOT real_nmi!
        CASE 15
          always_vsync!=NOT always_vsync!
        CASE 16
          PRINT AT(17,16);
          interrupt_level&=MOD(VAL(INPUT$(1)),3)
        CASE 17
          secundairy_slots!=NOT secundairy_slots!
        CASE 18
          LET colors!=NOT colors!
          @set_res
        CASE 19
          PRINT AT(17,19);
          FORM INPUT 3,dummy$
          max_bufkeys&=MAX(1,PRED(VAL(dummy$)))
        CASE 20
          emulate_data_recorder!=NOT emulate_data_recorder!
        CASE 21
          mem_mapper!=NOT mem_mapper!
        CASE 22
          msx_rom_patches!=NOT msx_rom_patches!
        CASE 23
          konami_scc!=NOT konami_scc!
        CASE 24
          fm_pac!=NOT fm_pac!
          ERASE fmpac_ram%()
          IF fm_pac!
            DIM fmpac_ram%(8192\4)
            @init_fmpac_ram
          ENDIF
        CASE 25
          patches!=NOT patches!
          IF patches!
            @init_look_up
          ELSE
            ARRAYFILL not_patched!(),TRUE
          ENDIF
        CASE 26
          @get_p.s_slot(46,3,konami_scc_slot&,konami_scc_sslot&)
        CASE 27
          real_250khz!=NOT real_250khz!
        CASE 28
          LET load_bios!=NOT load_bios!
        CASE 29
          LET load_diskrom!=NOT load_diskrom!
        CASE 30
          @get_p.s_slot(46,7,memory_mapper&,memory_smapper&)
        CASE 31
          @get_p.s_slot(46,8,msx_bios_slot&,msx_bios_2nd_slot&)
        CASE 32
          @get_p.s_slot(46,9,diskrom_slot&,diskrom_sslot&)
        CASE 33
          kanji_rom!=NOT kanji_rom!
        CASE 34
          rs232c!=NOT rs232c!
        CASE 35
          LET printer!=NOT printer!
        CASE 36
          joystick!=NOT joystick!
        CASE 37
          mmod!=NOT mmod!
        CASE 38
          fbmove!=NOT fbmove!
        CASE 39
          fast_screen_8!=NOT fast_screen_8!
        CASE 40
          disk_drive!=NOT disk_drive!
        CASE 41
          PRINT AT(46,18);
          dummy$=HEX$(video_mem_length%)
          FORM INPUT 5 AS dummy$
          video_mem_length%=MIN(131072,MAX(16384,VAL("&H"+dummy$)))
          ~MFREE(msx_video_ram%)
          msx_video_ram%=MALLOC(video_mem_length%)
          IF msx_video_ram%=0
            error_exit&=err_not_enough_video_ram&
            ALERT 3,"Error while allocating memory! ",1," Exit ",dummy&
          ELSE
            video_mem_end%=PRED(video_mem_length%)
          ENDIF
        CASE 42
          emul_psg!=NOT emul_psg!
        CASE 43
          light.pen_mouse!=NOT light.pen_mouse!
        CASE 44
          PRINT AT(46,21);
          exit_port&=VAL(INPUT$(1))
        CASE 45
          cpu_usage!=NOT cpu_usage!
        CASE 46
          @do_memory_configuration
        CASE 47
          PRINT AT(76,1);
          msx_type&=MIN(2,MAX(1,VAL(INPUT$(1))))
        CASE 48
          highlevel_drive!=NOT highlevel_drive!
        CASE 49
          redirect_printer!=NOT redirect_printer!
        CASE 50
          scc_plus!=NOT scc_plus!
        CASE 51
          video_in_page!=NOT video_in_page!
        CASE 52
          device_emul!=NOT device_emul!
        CASE 53
          no_rom_prot.!=NOT no_rom_prot.!
        CASE 54
          msx_2_epson!=NOT msx_2_epson!
        CASE 55
          msx_audio!=NOT msx_audio!
        CASE 56
          truecolor!=NOT truecolor!
        CASE 57
          pal.real!=NOT pal.real!
        CASE 58 TO 98
        CASE 99
          EXIT IF TRUE
        DEFAULT
          error_exit&=err_internal_error&
        ENDSELECT
      LOOP
      '
    CASE 3
      '
      EXIT IF TRUE
      '
    DEFAULT
      error_exit&=err_internal_error&
    ENDSELECT
    $S% S>
    '
  LOOP
  '
RETURN
> PROCEDURE get_p.s_slot(x&,y&,VAR slot&,sslot&)! Ask Slot/2nd Slot
  LOCAL dummy$
  '
  PRINT AT(x&,y&);
  '
  dummy$=STR$(memory_mapper&,1)
  FORM INPUT 1 AS dummy$
  '
  slot&=VAL(dummy$)
  '
  IF sslot!(slot&)
    '
    PRINT AT(ADD(x&,2),y&);
    '
    dummy$=STR$(memory_smapper&,1)
    FORM INPUT 1 AS dummy$
    '
    sslot&=VAL(dummy$)
    '
  ELSE
    '
    CLR sslot&
    '
  ENDIF
  '
RETURN
> PROCEDURE do_memory_configuration       ! Memory SetUp
  '
  ~MFREE(msx_memory_base%)
  '
  DO
    CLS
    dummy%=MALLOC(-1)
    PRINT "Memory free: ";dummy%;" = ";SHR(dummy%,10);"Kb = ";SHR(dummy%,14);" pages."
    '
    PRINT "  Slot: ";
    FOR lus&=0 TO 3
      IF sslot!(lus&)
        PRINT "p";lus&;SPACE$(16);"q";
      ELSE
        PRINT lus&;SPACE$(16);
      ENDIF
    NEXT lus&
    PRINT
    PRINT "2-slot: ";
    FOR lus&=0 TO 3
      FOR lus2&=0 TO 3
        PRINT lus2&;
        IF mem_map&(lus&,lus2&)
          PRINT "p";HEX$(mem_map&(lus&,lus2&),2);"q ";
        ELSE
          PRINT SPACE$(3);
        ENDIF
      NEXT lus2&
      PRINT " ";
    NEXT lus&
    PRINT
    '
    CLR cnt&
    IF mem_mapper!                      ! Memory Mapper            x * 16Kb
      FOR slot&=0 TO 3
        FOR sslot&=0 TO ABS(3*sslot!(slot&))
          ADD cnt&,mem_map&(slot&,sslot&)
        NEXT sslot&
      NEXT slot&
    ENDIF
    '
    IF emulate_sony_8255_cartridge!     ! Sony 8255 Data Cartridge 4 * 16Kb
      ADD cnt&,4
    ENDIF
    '
    FOR page&=3 DOWNTO 0
      PRINT "Page ";page&;": ";
      FOR slot&=0 TO 3
        FOR sslot&=0 TO 3
          '
          $S& S<
          SELECT page&(page&,slot&,sslot&)
          CASE mem_rom&
            PRINT "ROM";
            INC cnt&
          CASE mem_ram&
            PRINT "RAM";
            INC cnt&
          CASE mem_map&
            PRINT "MAP";
          CASE mem_unused&
            PRINT "---";
          CASE mem_fm_pac&
            PRINT "FMP";
          DEFAULT
            PRINT " ?!";
            INC cnt&
          ENDSELECT
          $S% S>
          '
          $S& S<
          SELECT slot&
          CASE msx_bios_slot&
            IF load_bios! AND sslot&=msx_bios_2nd_slot& AND page&<2
              PRINT "p4q";
            ELSE
              PRINT " ";
            ENDIF
          CASE diskrom_slot&
            IF load_diskrom! AND sslot&=diskrom_sslot& AND page&=1
              PRINT "p5q";
            ELSE
              PRINT " ";
            ENDIF
          CASE konami_scc_slot&
            IF konami_scc! AND sslot&=konami_scc_sslot& AND page&=2
              PRINT "p1q";
            ELSE
              PRINT " ";
            ENDIF
          DEFAULT
            PRINT " ";
          ENDSELECT
          $S% S>
          '
        NEXT sslot&
        PRINT "|";
      NEXT slot&
      PRINT
    NEXT page&
    '
    PRINT "1 = Konami SCC (";konami_scc_slot&;",0)   2 = FM-Pac (";fm_pac_slot&;",0)"
    PRINT "4 = MSX-Bios (";msx_bios_slot&;",";msx_bios_2nd_slot&;")     5 = DiskROM (";diskrom_slot&;",";diskrom_sslot&;")"
    PRINT
    PRINT "# Pages used: ";cnt&
    PRINT
    CLR dummy$
    PRINT "1] Edit page-setup"
    IF konami_scc!
      dummy$="2"
      PRINT "2] Select pKonami SCCq Slot"
    ENDIF
    IF mem_mapper!
      PRINT "4] Select pMemory Mapper(s)q"
      dummy$=dummy$+"4"
    ENDIF
    IF fm_pac!
      dummy$=dummy$+"5"
      PRINT "5] Slect pFM-Pacq Slot"
    ENDIF
    PRINT "6] Load BIOS...: ";@onf$(load_bios!)
    PRINT "7] Load DiskROM: ";@onf$(load_diskrom!)
    PRINT "8] Toggle 2nd Slots"
    PRINT "9] Toggle Sony 8255 Data Cartridge (";@onf$(emulate_sony_8255_cartridge!);")"
    PRINT "0] Done"
    '
    DO
      choice$=INPUT$(1)
    LOOP UNTIL INSTR("167890"+dummy$,choice$)
    '
    $S& S<
    SELECT choice$
    CASE "0"                            ! Done
      '
      dummy%=MALLOC(-1)
      '
      IF dummy%<SHL(cnt&,14)
        '
        ALERT 3,"Not enough memory! |Release at least "+STR$(SUB(cnt&,SHR(dummy%,14)))+" pages. ",1," Ok ",dummy&
        '
      ELSE
        '
        EXIT IF TRUE
        '
      ENDIF
      '
    CASE "1"                            ! Edit Page
      '
      INPUT "Slot: ";slot&
      IF sslot!(slot&)
        INPUT "2nd Slot: ";sslot&
      ENDIF
      '
      INPUT "Page: ";page&
      PRINT "1] ROM"
      PRINT "2] RAM"
      PRINT "3] Unused"
      PRINT "0] Cancel"
      DO
        choice$=INPUT$(1)
      LOOP UNTIL INSTR("1230",choice$)
      SELECT choice$
      CASE "1"
        page&(page&,slot&,sslot&)=mem_rom&
      CASE "2"
        page&(page&,slot&,sslot&)=mem_ram&
      CASE "3"
        page&(page&,slot&,sslot&)=mem_unused&
        '        CASE "0"
        ' cancel.
      ENDSELECT
      '
    CASE "2"                            ! SCC Slot
      '
      INPUT "SCC-Slot: ";konami_scc_slot&
      '
    CASE "4"                            ! Memory-Mapper
      '
      PRINT "Slot: ";
      dummy&=MIN(3,MAX(0,VAL(INPUT$(1))))
      '
      IF sslot!(dummy&)
        PRINT
        PRINT "Sslot: ";
        dummy2&=MIN(3,MAX(0,VAL(INPUT$(1))))
      ELSE
        CLR dummy2&
      ENDIF
      '
      PRINT
      INPUT "Pages: ";mem_map&(dummy&,dummy2&)
      mem_map&(dummy&,dummy2&)=ABS(mem_map&(dummy&,dummy2&))
      IF mem_map&(dummy&,dummy2&)>255
        mem_map&(dummy&,dummy2&)=255
      ENDIF
      '
    CASE "5"                            ! FM-Pac Slot
      '
      INPUT "FM-Pac Slot: ";fm_pac_slot&
      '
    CASE "6"                            ! Load BIOS
      '
      LET load_bios!=NOT load_bios!
      '
    CASE "7"                            ! Load DISKROM
      '
      LET load_diskrom!=NOT load_diskrom!
      '
    CASE "8"                            ! 2nd Slot Toggle
      '
      INPUT "Toggle Slot: ";slot&
      IF AND(slot&=>0,slot&<=3)
        sslot!(slot&)=NOT sslot!(slot&)
      ENDIF
      '
    CASE 9                              ! Sony 8255 Data Cartridge
      '
      emulate_sony_8255_cartridge!=NOT emulate_sony_8255_cartridge!
      '
    ENDSELECT
    $S% S>
    '
  LOOP
  '
  @init_main_memory_map
  '
RETURN
> FUNCTION onf$(on_off!)                  ! FALSE: OFF, TRUE: ON
'
IF on_off!
  '
  RETURN "pOn q"
  '
ELSE
  '
  RETURN "pOffq"
  '
ENDIF
'
ENDFUNC
> PROCEDURE any_key                       ! Wait for any key
LOCAL dummy%
'
dummy%=TIMER
DO
LOOP UNTIL OR(OR(SUB(TIMER,dummy%)>2000,INP?(2)),MOUSEK)
HIDEM
DO WHILE INP?(2)
  ~INP(2)
  VSYNC
LOOP
'
RETURN
> PROCEDURE copyright_message             ! Copyright Message
LOCAL lus&,lus2&,cnt%,dummy%,x&,y&
'
VSYNC
HIDEM
VSYNC
CLS
'
PRINT AT(1,max_row&);
DIM msg$(9)
msg$(0)="MSX-Emulator"
msg$(1)="(C) 1994 by F.J.J. van Heusden [NL]"
msg$(2)="Send all your donations (financial or so) to:"
msg$(3)="F. van Heusden"
msg$(4)="Tournooiveld 11"
msg$(5)="4841 VM  Prinsenbeek"
msg$(6)="The Netherlands"
msg$(7)="Contact me via FidoNet at: 2:285/750.2"
msg$(8)="or UUCP: Folkert.van.Heusden@p2.f750.n285.z2@fidonet.org"
msg$(9)="Many thanks to all people of the dutch FidoNet area 'MSX.028'. Especially Roderik Muit, Ben Doedens, Albert Siersema, Udo van den Heuvel, Paul Koning, Pierre Gielen, Jeroen Wessels, Richard Blaak, Martijn Dekker, Mari van den Broek and Robert"
msg$(9)=SPACE$(79)+msg$(9)+SPACE$(1)
'
@center(msg$(0)+" "+version$)
FOR lus&=1 TO 8
  @center(msg$(lus&))
NEXT lus&
FOR lus&=1 TO 12
  VSYNC
  PRINT
NEXT lus&
'
CLR cnt%
FOR lus&=1 TO 9
  '
  FOR lus2&=1 TO LEN(msg$(lus&))
    ADD cnt%,MUL(ASC(MID$(msg$(lus&),lus2&,1)),lus&)
  NEXT lus2&
  '
  FOR lus2&=0 TO 3
    cnt%=XOR(cnt%,MUL(lus&,2^SHL(lus2&,3)))
  NEXT lus2&
  '
NEXT lus&
hack_cnt&=WORD(XOR(SHR(cnt%,16),AND(cnt%,32767)))
hacked!=hack_cnt&<>12572
'
dummy&=1                      ! Show some nice scroll-text
dummy%=TIMER
LET dir!=TRUE
x&=CRSCOL
y&=CRSLIN
@center("Press any key to continue...")
DO
  dummy$=MID$(msg$(9),dummy&,max_col&)
  VSYNC
  PRINT AT(1,1);dummy$;
  IF dir!
    IF dummy&<LEN(msg$(9))
      INC dummy&
    ELSE
      CLR dir!
    ENDIF
  ELSE IF dummy&>1
    DEC dummy&
  ELSE
    LET dir!=TRUE
  ENDIF
LOOP UNTIL OR(OR(MOUSEK,INP?(2)),SUB(TIMER,dummy%)>960000)
PRINT AT(1,y&);"K";AT(x&,y&);
'
VSYNC
FOR lus&=1 TO ADD(max_row&,ABS(MUL(500,hacked!)))
  PRINT
  IF lus&=10
    VSYNC
  ENDIF
NEXT lus&
VSYNC
CLS
'
DO WHILE INP?(2)
  ~INP(2)
LOOP
'
ERASE msg$()
'
RETURN
> PROCEDURE dedicated_to...                       ! Greetings etcetera
LOCAL m&,s&,cnt%,lus&,lus2&,a$,b$,a&,b&
'
HIDEM
CLS
'
ERASE msg$()
DIM msg$(4)
msg$(0)="öûìéâÑÐüÖÓÓÑ®è·‹ÏÂëÀ²ïÊÒ°ÿò±³¹ÑÀ½ö„€÷ô€äÞŒÓ™ãîÚìé§£ÇÛéìøÕªØÁø÷þ¤¾ï®£‹¿œ“ö¡ÚÌéÌ"
msg$(1)="äìô­ÅÐ¼ù‚ßÒäçåÂÏÖ÷Ž½øÜÐûüÂªâ¾ßúýò€²¬ÀèÉÇÕŽîüÜô»éòÀÞŸÿìãÆâÖ„Öûf÷·¬íÁ¸’„óáÝÍêÍþ"
msg$(2)="áî«Î€ÖÓÆÄÉ¦³ô™…ÄÃ¤éœéôýå¶ñúÒóÚýŠÈæêÏà–ÁÃ…éûÅ¸¤À¦Üœ‘áø¢×ñŒÆµë–Žó£ì¥ÆéÚØ¦£ÜÊëÎÿé"
msg$(3)="¿å„¾žŒ‘™©¤ç–”š¬Œö«šûò¥û´ýž±‚€ÎË´¢ƒ¦—–Î­®—µ¥¶ ’Ø¯¯£‹¥Ý‚²³ÐÛ‚¢ï¤ÁèÙÙ©¢ßËìÏüèñ"
msg$(4)="–ÉÃþÎÈžÈøà³Ä—ÞýÙ°øšÏ·óéµù¨ÐþÔÄÿÊ·£„§”€™Ï®¯´¦·¿“žÙ¨® ŠªÜ³´ÑØƒÝî§ÀïØÚ¨­ÞÈíÈýëð¨"
'
m&=5
s&=7
FOR lus&=0 TO 4
  '
  FOR lus2&=1 TO 79
    s&=MOD(MUL(s&,m&),79)
    MID$(msg$(lus&),lus2&,1)=CHR$(XOR(ASC(MID$(msg$(lus&),lus2&,1)),BSET(XOR(lus2&,s&),7)))
  NEXT lus2&
  '
  FOR lus2&=1 TO 79
    ADD cnt%,MUL(ASC(MID$(msg$(lus&),lus2&,1)),XOR(lus2&,cnt%))
    DO WHILE cnt%>&HFFFF
      cnt%=ADD(SHR(cnt%,16),AND(cnt%,65535))
    LOOP
  NEXT lus2&
  '
  PRINT msg$(lus&)
  '
NEXT lus&
'
hacked!=OR(hacked!,cnt%<>36347)
'
DO
LOOP UNTIL INP(2)=13
'
ERASE msg$()
'
RETURN
> PROCEDURE dedicated_to_and_greetings    ! Called by 'out()'
LOCAL dummy1%,dummy2%,dummy$,tijd%,dummy!
'
dummy1%=ADD(RANDOM(9990),4)
dummy2%=ADD(RANDOM(9990),4)
PRINT "What is ";dummy1%;"x";dummy2%;"?"
dummy$=STR$(dummy1%*dummy2%)
tijd%=TIMER
CLR dummy!
DO UNTIL INP?(2)
  dummy!=SUB(TIMER,tijd%)>400
LOOP UNTIL dummy!
IF NOT dummy!
  IF INPUT$(1)=LEFT$(dummy$)
    PRINT LEFT$(dummy$);
    FORM INPUT PRED(LEN(dummy$)),dummy2$
    IF MID$(dummy$,2)=dummy2$
      CLR dummy!
    ENDIF
  ENDIF
  IF NOT dummy!
    @dedicated_to...
  ENDIF
ENDIF
IF dummy!
  PRINT "Wrong!"
  PRINT
  PRINT "Press any key to exit..."
  @any_key
  END
ENDIF
'
RETURN
> PROCEDURE center(string$)               ! Center string on screen
'
VSYNC
HTAB SUB(SHR(max_col&,1),SHR(LEN(string$),1))
PRINT string$
'
RETURN
> PROCEDURE end                           ! Exit Emulator
'
ON BREAK CONT                 ! probleempjes voorkomen
'
CLOSE                         ! Close ALL files (#50, #51, #58, #80, #81)
'
IF emulate_rp5c01!
  PRINT AT(42,max_row&);"Writing RP5C01.DAT...K";
  BSAVE "RP5C01.DAT",V:rp5c01|(0),256 ! KlokChip-Info wegschrijven
ENDIF
IF fm_pac!
  PRINT AT(42,max_row&);"Writing FM_PAC.RAM...K";
  BSAVE "FM_PAC.RAM",V:fmpac_ram%(0),8192
ENDIF
IF OR(fm_pac!,emulate_rp5c01!)
  PRINT AT(42,max_row&);"K";
ENDIF
'
~MFREE(msx_video_ram%)
~MFREE(msx_memory_base%)
~MFREE(kanji_rom%)
PRINT
PRINT " p";SPACE$(78);"qK"
PRINT " p Press any key to exit...";SPACE$(53);"qK"
PRINT " p";SPACE$(78);"qK"
@any_key
ON BREAK
SHOWM
END
'
RETURN
'
> PROCEDURE init                          ! Main Initialisising
'
ON ERROR GOSUB error
ON BREAK GOSUB end
PRINT "Ewq";
HIDEM
SPOKE &H484,&X110              ! Disable Key-Click, MSX-Basic will do the job!
'
path$=CHR$(ADD(GEMDOS(25),65))+":"+DIR$(0)+"\"
default$=""
select$="*.*"
'
~GRAF_HANDLE(dummy1&,dummy2&,dummy&,dummy&)
max_col&=SUCC(WORK_OUT(0))/dummy1&
max_row&=SUCC(WORK_OUT(1))/dummy2&
'
MODE 0                ! #,###.## 16.05.1988
KEYPAD 46             ! NumLockSwitch/CTRLKeyp.=cursor/ALTKeyp.=ascinv./keydefmetaltaan
'
@copyright_message
'
' De diverse fouten die zich kunnen voordoen:
'
err_return_to_main_menu&=-1   ! Return to Main Menu
err_no_error&=0               ! No Error
err_not_enough_main_ram&=1    ! Not Enough main RAM
err_not_enough_video_ram&=2   ! Not Enough video RAM
err_unknown_error&=3          ! Addressing Unknown HARDWARE
err_mem_pointer_error&=4      ! Error while reading memory ( > $FFFF )
err_wrong_mem_page&=5         ! Wrong memory page selected
err_unknown_z80_instruction&=6! Unknwon Z80-opcode
err_flag_upd._type_err.&=7    ! Wrong update-type while updating flag-register
err_internal_error&=8         ! Impossible selections (MMOD-emulation)
err_unknown_fm_pac_reg&=9     ! Unknown FM-Pac register
'  err_unknown_vdp_register&=10  ! Unknown VDP-register adressed
'  err_unknown_vdp_status_reg&=11! Unknown VDP status-register read
err_no_mem_mapper&=12         ! The Memory-mapper is adressed while there isn't a memory-mapper
err_unknown_vdp_mode&=13      ! Unknown VDP mode
err_no_bios&=14               ! Can't find system-files
err_romload_error&=15         ! No memory reserved for bios-page
err_unknown_vdp_l.operation&=16! Unknown Logical point-operation
err_unknown_vdp_command&=17   ! Unknown VDP-command
err_vdp_illegal_mode&=18      ! Doing command in wrong VDP-mode
err_no_extra_vdp_mem&=19      ! No xtra VDP-Memory
error_exit&=err_no_error&!no_error
'
' MSX-Types:
'
msx_1&=1                      ! MSX-1
msx_2&=2                      ! MSX-2
msx_2plus&=3                  ! MSX-2+
msx_type&=msx_1&
'
' Memory-Page Types:
'
mem_unused&=0                 ! Unused page
mem_ram&=1                    ! RAM
mem_rom&=2                    ! ROM
mem_map&=3                    ! Memory-Mapper <----- NIET GEBRUIKEN!!
mem_fm_pac&=4                 ! FM-Pac RAM
'
msx_bios_slot&=0              ! Where we can find the BIOS (we should :-])
msx_bios_2nd_slot&=0
'
diskrom_slot&=3               ! Where we should place the DiskROM
diskrom_sslot&=3
'
cartridge_1&=1                ! Cartridge-port 1: Slot 1 [Page0...3, 2ndSlot 0...3]
cartridge_2&=2                ! Cartridge-port 2: Slot 2 [idem]
'
exit_port&=0                  ! Writing to this port will let the emulator exit to the main-menu
dedicate_port&=&H35           ! Greetings etc.
'
clock_freq%=3579545           ! Clock-frequentie van main-clock
screen_refresh&=50            ! Scherm wordt 50x/sec ververst, tevens # NMI's/sec
cycles_per_frame%=clock_freq%/screen_refresh&! Cycles per screen-BuildUp
psg_freq_adjust=(clock_freq%/2)/(2000000)! To adjust frequency
'                                ^^^^^^^ ST's PSG is on 2MHz
'
DIM i8253_counter&(2)         ! i-8253 counter registers
i8253_frequency%=1843200      ! Frequency of i-8253 crystal
'
ppi_mode&=250                 ! Default PPI-mode
'
ram_start%=0                  ! The main-system starts at 0x000
stack_pointer%=0              ! Initial StackPointer
'
video_read_pointer%=0         ! Read-Pointer in VRAM
video_write_pointer%=0        ! Write-Pointer in VRAM
video_mode&=3                 ! We start in SCREEN 1 (!!!!!)
msx_vdp_mode&=0
'
none_emul&=0                  ! NOTHING SPECIAL EMULATED
vdp_emul&=1                   ! VDP-Emulation
scc_emul&=2                   ! SCC-Emulation
mmod_emul&=3                  ! MUSIC_MODULE-Emulation
keyboard_emul&=4              ! KEYBOARD-Emulation
drive.l_emul&=5               ! DRIVE-Emulation [low]
drive.h_emul&=6               ! DRIVE-Emulation [High]
fmpac_emul&=7                 ! FM-PAC-Emulation
'
unused_random!=TRUE           ! Reading unused RAM returns random stuff
unofficial_z80_commands!=TRUE ! Do unofficial Z80-instructions?
known_bugs!=TRUE              ! Emulate bugs in Z80-instructions
debug!=FALSE                  ! Show disassembled Z80-instructions (current working on)
single_step!=FALSE            ! Wait after each command
show_emulator_status!=TRUE    ! Show Emulator Status every NMI
keyboard_debug!=FALSE         ! Don't debug keyboard-thingy
diss_pointer%=-1              ! Where we have to start dis-assembling
relative_speed_calculation!=TRUE! Show emulation-speed
LET vsync!=FALSE              ! We don't want to keep Video-Sync
int_0x38!=TRUE                ! Emulate 50Hz/60Hz-interupt
real_nmi!=FALSE               ! Adjust    " -cycles
always_vsync!=TRUE            ! Say always "VSYNC!" when reading 0x99
interrupt_level&=1            ! IM 1
secundairy_slots!=TRUE        ! So we need to handle 0xFFFF
fast_screen_0!=TRUE           ! Use PRINT instead of pixel-routine
fast_screen_1!=TRUE           ! Use PRINT & COLOR instead of pixel-routine
fast_screen_8!=TRUE           ! pset x,y,data
large_msx.2_vram!=FALSE       ! No 128Kb vram when doing msx-2
SELECT msx_type&              ! VRAM-Size
CASE msx_1&
  video_mem_length%=16384     ! Max. MSX-1
CASE msx_2&
  IF large_msx.2_vram!
    video_mem_length%=131072
  ELSE
    video_mem_length%=65536   ! Min. MSX-2
  ENDIF
ENDSELECT
ADD video_mem_length%,hacked!
LET colors!=FALSE             ! Emulate colors (color only! (:-]))
LET pal.real!=FALSE           ! Gebruik de ingestelde rgb waarde, niet de werkelijke
LET truecolor!=FALSE          ! Truecolor display?
max_bufkeys&=255              ! We'll remember 256 keys
emulate_data_recorder!=FALSE  ! Do NOT emulate datarecorder via sampler
kb_dummy&=-1                  ! keyboard-buffer stuff
LET load_bios!=TRUE           ! We need that BIOS
' ********************************************************************************
'  LET load_diskrom!=TRUE        ! /diskrom/                                  **
'  disk_drive!=TRUE              ! Emulate Disk-Drive                         **
'  highlevel_drive!=TRUE         ! Highlevel diskdrive emulation              **
'
emulate_rp5c01!=TRUE          ! Emulate Clock-Chip
'  console_bitplanes&=1          ! # bitplanes on emulating computer
'  bytes_per_row&=80             ! # bytes per line
turbo.r!=TRUE                 ! Try to emulate as much as possible of the Turbo-R
emulate_sony_8255_cartridge!=FALSE! Sony Data Cartridge 8255
'  kanji_rom!=TRUE               ! Emulate KANJI-ROM :-) :-/ :-?
rs232c!=TRUE                  ! RS-232C emulation
LET printer!=TRUE             ! Use Printer (otherwhise: dev\NULL)
joystick!=TRUE                ! Use Joystick (problems with mouse?)
mmod!=TRUE                    ! Philips Music Module
fbmove!=TRUE                  ! Fast BMOVE-instruction for LDIR
emul_psg!=TRUE                ! Emulate PSG
extra_vdp_mem!=FALSE          ! xtra vdp-ram voor digitaliseren etc.
light.pen_mouse!=TRUE         ! Emulate Light-Pen & Mouse
cpu_usage!=FALSE              ! Show CPU-Usage
mem_mapper!=TRUE              ! Memory-Mapper
real_250khz!=TRUE             ! Real 250kHz-counter?
redirect_printer!=TRUE        ! Redirect printer-output to file
scc_plus!=TRUE                ! SCC+
video_in_page!=TRUE           ! Put video-RAM in a Page (!!!!!)
video_slot&=1                 ! [1|3]
video_sslot&=3
no_rom_prot.!=FALSE           ! We _DO_ want ROM-Protection!
msx_audio!=TRUE               ! Yeah, well, yeah. MSX-Audio.
msx.audio_0xffca&=&H23        ! Init. address
device_emul!=TRUE             ! Emulate Device-handling cartridge
device_slot&=cartridge_1&
device_sslot&=0
device_io&=&H20               ! I/O-port for device-emulation
'
' *** Resolutions ***
'
screen_0a&=1
screen_0b&=2
screen_1&=3
screen_2&=4
screen_3&=5
screen_4&=6
screen_5&=7
screen_6&=8
screen_7&=9
screen_8&=10
'
' *** Memory Config. ***
'
DIM sslot!(3)
sslot!(0)=TRUE        ! Slot 0: 2nd Slots!  [vdp-ram]
sslot!(1)=FALSE       ! Slot 1: No 2nd Slots
sslot!(2)=FALSE       ! Slot 2: No 2nd Slots
sslot!(3)=TRUE        ! Slot 3: 2nd Slots!
'
DIM page&(3,3,3)      ! 3 Pages / 3 Slots / 3 2ndSlots TYPE
DIM page%(3,3,3)      !                                OFFSET IN RAM-BUFFER
DIM cpageo%(3),ram!(3)
ARRAYFILL page&(),0
ARRAYFILL page%(),0
ARRAYFILL cpageo%(),0
'
page&(0,0,0)=mem_rom& ! Slot 0: 32Kb ROM
page&(1,0,0)=mem_rom&
'
IF load_diskrom!      ! Allocate memory for DiskROM if needed
  page&(1,diskrom_slot&,diskrom_sslot&)=mem_rom&
  IF diskrom_sslot&<>0        ! Wel d'r ff 'n sub-slot slot van maken natuurlijk!
    sslot!(diskrom_slot&)=TRUE        ! (en niet perongeluk op false ofzo :-])
  ENDIF
ENDIF
'
DIM slot_sel&(3)      ! Selected Slots
ARRAYFILL slot_sel&(),0
slot_sel&(0)=0       ! BIOS
slot_sel&(1)=0       ! BASIC
slot_sel&(2)=0       ! ---
slot_sel&(3)=0       ! ---
'
DIM slot2sel&(3,3)   ! Selected 2nd Slots
ARRAYFILL slot2sel&(),0
slot2sel&(0,0)=0
slot2sel&(1,0)=0
slot2sel&(2,0)=0
slot2sel&(3,0)=0
'
DIM mem_map&(3,3)             ! Memory Mapper in Slot X, Sslot Y (meteen ook aant. Pages)
mem_map&(3,2)=4     ! mem-mapper op [3,2] van 4 pagina's (128Kb)
'
' *** Cartridges etc. ***
'
msx_rom_patches!=TRUE         ! To be able to use ST hard- & software
konami_scc!=TRUE              ! Konami-SCC
konami_scc_slot&=1            ! ... Slot with Konami SCC
konami_scc_midi_channel&=0    ! ... First MIDI-channel to use is 0
IF konami_scc!                ! ... To be able to return things when its read
  DIM konami_scc_volume|(4),konami_scc_wave|(4,31),konami_scc_freq%(4)
ENDIF
fm_pac!=TRUE                  ! FM-Pac
fm_pac_slot&=2                ! ... Slot with FM-Pac
IF fm_pac!
  page&(1,fm_pac_slot&,0)=mem_fm_pac&
ENDIF
'
patches!=konami_scc! OR msx_rom_patches! OR fm_pac! OR secundairy_slots!
drive_dummy!=AND(AND(disk_drive!,msx_rom_patches!),highlevel_drive!)
'
DIM keybuf|(max_bufkeys&),keysk|(max_bufkeys&)! Keyboard-buffers
DIM dr_emul|(31)              ! Buffer voor data-recorder emulatie
DIM freq&(2)                  ! frequency-tables for PSG-Emulation
DIM parity|(255)              ! Look-Up tabel voor parity-berekening
DIM or|(63),and|(63)          ! Look-Up tabellen voor OR & AND-berekening
DIM inc!(3,255)               ! Look-Up tabel voor INCrease functies
DIM not_patched!(65543)       ! 1 extra byte (=8 mem.-bytes) for safety
DIM jr&(255)                  ! JR [xx,] look-up
DIM cpu_usage&(320)           ! For CPU-Usage Graphic
DIM drive_buf|(511)           ! 512bytes buffer voor drive-access
IF fm_pac!
  DIM fmpac_freq&(8)          ! 8 9-bits variables for FM-Pac frequencys
  DIM fmpac_oct|(8)           ! Octaaf-nummer (FM-Pac)
  DIM fmpac_chbits!(8,1)      ! channel-configs for FM-Pac
ENDIF
IF colors!                    ! Get color-map (if used)
  console_colors&=WORK_OUT(39)-1! # kleuren
  DIM pal|(console_colors&,2)
  FOR lus&=console_colors& DOWNTO 0
    '
    CONTRL(0)=26              ! VQ_COLOR
    CONTRL(3)=2               ! 2 in INTIN
    CONTRL(4)=4               ! 4 in INTOUT
    CONTRL(6)=V~H             ! VDI-Handle
    '
    INTIN(0)=lus&             ! Kleur Index
    IF pal.real!
      INTIN(1)=1              ! feitelijke kleur
    ELSE
      INTIN(1)=0              ! ingestelde kleur
    ENDIF
    '
    VDISYS                    ! Call OS
    '
    pal|(lus&,0)=DIV(MUL(INTOUT(1),255),1000) ! Red
    pal|(lus&,1)=DIV(MUL(INTOUT(2),255),1000) ! Green
    pal|(lus&,2)=DIV(MUL(INTOUT(3),255),1000) ! Blue
    '
  NEXT lus&
ENDIF
IF device_emul!               ! program
  DIM device_emul|(31)
  RESTORE device_emul
device_emul:
  DATA 41,42,16,40,00,00,18,40,00,00,00,00,00,00,00,00,00,00,00,00,c9,00,d3,--,c9,*
  CLR dummy&
  DO
    READ dummy$
    EXIT IF dummy$="*"
    IF dummy$="--"
      device_emul|(dummy&)=BYTE(device_io&)
    ELSE
      device_emul|(dummy&)=VAL("&H"+dummy$)
    ENDIF
    INC dummy&
  LOOP UNTIL dummy&=31
ENDIF
'
' ***** Sub-Init Routines *****
'
@init_rp5c01
@init_fmpac_ram
@init_look_up
dummy&=WORD(OR(OR(OR(TT?,FRE(0)),FRE()),STE?))
RESERVE 49152
@init_video_memory_map
@init_kanji_rom
@init_main_memory_map
@set_res
'
RETURN
> PROCEDURE init_main_memory_map          ! Init Main RAM
LOCAL slot&,page&,offset%,used_pages&,sslot&,max_ram_pages&
'
CLR used_pages&
IF mem_mapper!
  FOR slot&=0 TO 3
    FOR sslot&=0 TO 3
      '
      ADD used_pages&,mem_map&(slot&,sslot&)
      '
    NEXT sslot&
  NEXT slot&
ENDIF
'
FOR sslot&=0 TO 3
  FOR slot&=0 TO 3
    FOR page&=0 TO 3
      IF OR(AND(sslot&>0,sslot!(slot&)),sslot&=0)
        IF page&(page&,slot&,sslot&)<>mem_unused&
          IF page&(page&,slot&,sslot&)<>mem_map&! Niet nodig, maar om bugs te voorkomen
            INC used_pages&
          ENDIF
        ENDIF
      ENDIF
    NEXT page&
  NEXT slot&
NEXT sslot&
'
' ***** MALLOC Main-Memory *****
'
max_ram_pages&=MIN(32767,MALLOC(-1)/16384)       ! 16Kb per page
IF max_ram_pages&<used_pages&+ABS(emulate_sony_8255_cartridge!)*4
  '
  CLR msx_memory_base%
  '
ELSE
  '
  PRINT AT(42,max_row&);"Allocating memory...K";
  msx_memory_base%=MALLOC(used_pages&*16384+ABS(emulate_sony_8255_cartridge!)*65536+hacked!)
  '
ENDIF
'
IF msx_memory_base%=0
  '
  ALERT 0,"Not enough memory! ",1," Quit ",dummy&
  HIDEM
  error_exit&=err_not_enough_main_ram&
  '
ELSE
  '
  offset%=msx_memory_base%
  '
  ' ***** Show the Program where to find its memory *****
  '
  FOR sslot&=0 TO 3
    FOR slot&=0 TO 3
      FOR page&=0 TO 3
        IF OR(AND(sslot&>0,sslot!(slot&)),sslot&=0)
          IF page&(page&,slot&,sslot&)<>mem_unused&
            IF page&(page&,slot&,sslot&)<>mem_map&! Niet nodig, maar om bugs te voorkomen
              page%(page&,slot&,sslot&)=offset%
              ADD offset%,16384
            ENDIF
          ENDIF
        ENDIF
      NEXT page&
    NEXT slot&
  NEXT sslot&
  '
  ' ***** Show the program where to find the MemoryMapper-Memory *****
  '
  IF mem_mapper!
    '
    ERASE mem_map%(),mmap&()
    DIM mem_map%(3,3),mmap&(3)
    '
    FOR slot&=0 TO 3
      FOR sslot&=0 TO 3
        IF mem_map&(slot&,sslot&)>0
          '
          mem_map%(slot&,sslot&)=offset%
          ADD offset%,mem_map&(slot&,sslot&)*16384
          '
          FOR page&=0 TO 3
            page&(page&,slot&,sslot&)=mem_map&
          NEXT page&
          '
        ENDIF
      NEXT sslot&
    NEXT slot&
    FOR lus&=0 TO 3
      mmap&(lus&)=lus&
    NEXT lus&
    '
    IF video_in_page!
      '
      vdp_pages&=total_vdp_mem%/16384                         ! #pages
      mem_map&(video_slot&,video_sslot&)=vdp_pages&
      mem_map%(video_slot&,video_sslot&)=msx_video_ram%       ! RAM-Pointer
      FOR page&=0 TO MIN(PRED(vdp_pages&),3)                  ! Note as Mapper
        page&(page&,video_slot&,video_sslot&)=mem_map&
      NEXT page&
      '
    ENDIF
    '
    @update_memory_mapper_pointers
    '
  ENDIF
  '
  ' ***** Sony Data-Cartridge (8255) *****
  '
  IF emulate_sony_8255_cartridge!
    '
    sony_8255_data_cartridge_mem%=offset%
    ADD offset%,65536
    '
  ENDIF
  '
  IF load_bios!                             ! ***** Load BIOS *****
    IF EXIST("MSX1ROMA.BIN")
      IF page%(0,msx_bios_slot&,msx_bios_2nd_slot&)
        PRINT AT(42,max_row&);"Loading bios, part 1...K";
        OPEN "I",#1,"msx1roma.bin"
        RELSEEK #1,7
        BGET #1,page%(0,msx_bios_slot&,msx_bios_2nd_slot&),16384
        CLOSE #1
      ELSE
        error_exit&=err_romload_error&
      ENDIF
    ELSE
      error_exit&=err_no_bios&
    ENDIF
    IF EXIST("MSX1ROMB.BIN")
      IF page%(1,msx_bios_slot&,msx_bios_2nd_slot&)
        PRINT AT(42,max_row&);"Loading bios, part 2...K";
        OPEN "I",#1,"msx1romb.bin"
        RELSEEK #1,7
        BGET #1,page%(1,msx_bios_slot&,msx_bios_2nd_slot&),16384
        CLOSE #1
      ELSE
        error_exit&=err_romload_error&
      ENDIF
    ELSE
      error_exit&=err_no_bios&
    ENDIF
  ENDIF
  '
  IF load_diskrom!
    IF EXIST("DISKROM.BIN")
      IF page%(1,diskrom_slot&,diskrom_sslot&)
        PRINT AT(42,max_row&);"Loading diskrom...K";
        OPEN "I",#1,"diskrom.bin"
        RELSEEK #1,7
        BGET #1,page%(1,diskrom_slot&,diskrom_sslot&),16384
        CLOSE #1
      ELSE
        error_exit&=err_romload_error&
      ENDIF
    ELSE
      error_exit&=err_no_bios&
    ENDIF
  ENDIF
  PRINT AT(42,max_row&);"K";
  '
ENDIF
'
IF device_emul!                               ! Device-emulation Cartridge :-)
  page&(1,device_slot&,device_sslot&)=mem_rom&
  page%(1,device_slot&,device_sslot&)=V:device_emul|(0)
ENDIF
'
@update_global_memory_pointers
'
RETURN
$P<
> PROCEDURE update_global_memory_pointers ! Update memory-pointers
'
FOR ugmp_page&=3 DOWNTO 0
  '
  ' Calc. pointers to pages:
  IF AND(sslot!(slot_sel&(ugmp_page&)),secundairy_slots!)
    cpageo%(ugmp_page&)=page%(ugmp_page&,slot_sel&(ugmp_page&),slot2sel&(ugmp_page&,slot_sel&(ugmp_page&)))
  ELSE
    cpageo%(ugmp_page&)=page%(ugmp_page&,slot_sel&(ugmp_page&),0)
  ENDIF
  '
  ' Make fast look-up table for RAM-Check:
  ugmp_dummy&=page&(ugmp_page&,slot_sel&(ugmp_page&),slot2sel&(ugmp_page&,slot_sel&(ugmp_page&)))
  ram!(ugmp_page&)=BYTE(OR(OR(ugmp_dummy&=mem_ram&,ugmp_dummy&=mem_map&),AND(ugmp_dummy&=mem_rom&,no_rom_prot.!)))
  '
  ' Extra RAM-available check:
  IF cpageo%(ugmp_page&)=0            ! valid pointer?
    ram!(ugmp_page&)=FALSE                    ! NO!
  ENDIF
  '
NEXT ugmp_page&
'
RETURN
> PROCEDURE update_memory_mapper_pointers ! Update Memory-Mapper pointers in page%()-list
'
IF mem_mapper!
  '
  FOR ummp_sslot&=ABS(3*secundairy_slots!) DOWNTO 0
    FOR ummp_slot&=3 DOWNTO 0
      '
      IF mem_map&(ummp_slot&,ummp_sslot&)
        '
        FOR ummp_page&=3 DOWNTO 0
          '
          IF mmap&(ummp_page&)<mem_map&(ummp_slot&,ummp_sslot&)
            page%(ummp_page&,ummp_slot&,ummp_sslot&)=ADD(mem_map%(ummp_slot&,ummp_sslot&),SHL(mmap&(ummp_page&),14))
          ELSE
            page%(ummp_page&,ummp_slot&,ummp_sslot&)=mem_map%(ummp_slot&,ummp_sslot&)  ! not valid
          ENDIF
          '
        NEXT ummp_page&
        '
      ENDIF
      '
    NEXT ummp_slot&
  NEXT ummp_sslot&
  '
ENDIF
'
@update_global_memory_pointers
'
RETURN
> PROCEDURE init_video_memory_map         ! Init Video RAM
'
video_mem_end%=PRED(video_mem_length%)
'
IF extra_vdp_mem!
  total_vdp_mem%=video_mem_length%+2^16
ELSE
  total_vdp_mem%=video_mem_length%
ENDIF
'
msx_video_ram%=MALLOC(total_vdp_mem%)
IF msx_video_ram%=0
  '
  error_exit&=err_not_enough_video_ram&
  '
ELSE
  '
  DIM vdp_data|(255),charset|(767,7),charcolors|(31,1),vdpregs|(255)
  '
  vdp_data!=TRUE      ! firs byte to get: data!
  '
  IF extra_vdp_mem!
    msx._video._ram.%=msx_video_ram%+video_mem_length%
  ENDIF
  '
ENDIF
'
RETURN
> PROCEDURE init_look_up                  ! Init LOOK-UP tables
'
' ***** Parity *****
'
FOR lus&=255 DOWNTO 0
  '
  CLR cnt&
  FOR lus2&=7 DOWNTO 0
    ADD cnt&,BTST(lus&,lus2&)
  NEXT lus2&
  '
  parity|(lus&)=BYTE(EVEN(cnt&))
  '
NEXT lus&
'
' ***** OR *****
'
FOR lus&=0 TO 63
  or|(lus&)=2^SHR(lus&,3)
NEXT lus&
'
' ***** AND *****
'
FOR lus&=0 TO 63
  and|(lus&)=XOR(or|(lus&),255)
NEXT lus&
'
' ***** Jump Relative *****
'
FOR lus&=0 TO 255
  IF lus&>127
    jr&(lus&)=-SUB(255,lus&)
  ELSE
    jr&(lus&)=SUCC(lus&)
  ENDIF
NEXT lus&
'
' ***** INC *****
'
FOR lus&=0 TO 254
  '    inc!(0,lus&)=FALSE         ! Zero
  inc!(1,lus&)=lus&>127      ! Sign
  inc!(2,lus&)=AND(lus&,15)=0! Half/C (van 15 naar 0 gesprongen)
  inc!(3,lus&)=lus&=128      ! Par/Ov (van 127 naar 128 gesprongen)
NEXT lus&
inc!(0,lus&)=TRUE
inc!(1,lus&)=FALSE
inc!(2,lus&)=TRUE
inc!(3,lus&)=TRUE
'
' ***** Look-up table with patches *****
'
IF patches!
  '
  ARRAYFILL not_patched!(),TRUE
  '
  RESTORE patches
patches:
  ' Adressen uit jump-tabel:
  DATA &H56,&Hc0,&He1,&He4,&He7,&Hea,&Hed,&Hf0,&H156,&H17d
  ' JMP adr:
  DATA &H17d,&H815,&H1113,&H1a63,&H1abc,&H19e9,&H19f1,&H1a19,&H19dd,&H468
  ' Disk-ROM:
  DATA &H4010,&H401c,&H4029,&H46c5,&H4755
  ' FM-Pac:
  DATA &H7ff6,&H5ffe,&H5fff
  ' Konami SCC(+):
  DATA &h8000,-2,&H8800,&H888f,&H9000,-2,&H9800,&H988f
  ' MSX-Audio:
  DATA &Hffca
  ' 2nd slot sel.:
  DATA &HFFFF
  DATA -1
  '
  DO
    '
    READ adres%
    '
    $S& S>
    SELECT adres%
    CASE -1                   ! End of list
      EXIT IF TRUE
    CASE -2                   ! Area
      '
      READ start_adres%
      READ eind_adres%
      '
      FOR lus%=start_adres% TO eind_adres%
        not_patched!(lus%)=FALSE
      NEXT lus%
      '
    DEFAULT                   ! Single Address
      '
      not_patched!(adres%)=FALSE
      '
    ENDSELECT
    $S% S>
    '
  LOOP
  '
ENDIF
'
not_patched!(65535)=NOT secundairy_slots!! $FFFF altijd in de gaten houden! [IVM pc++]
'
RETURN
> PROCEDURE init_rp5c01                   ! Klok Chip
'
DIM rp5c01|(255)
'
IF EXIST("RP5C01.DAT") AND emulate_rp5c01!
  OPEN "I",#1,"RP5C01.DAT"
  IF LOF(#1)=>256
    BGET #1,V:rp5c01|(0),256
  ENDIF
  CLOSE #1
ENDIF
'
RETURN
> PROCEDURE init_kanji_rom                ! Init Kanji-ROM
'
IF kanji_rom!
  '
  IF EXIST("KANJIROM.BIN")
    '
    kanji_rom%=MALLOC(4096)           ! Allocate memory for KANJI-ROM
    IF kanji_rom%=0                   ! Couldn't
      '
      CLR kanji_rom!
      ALERT 0,"Can't allocate memory for |Kanji-ROM! |Kanji-ROM disabled. ",1," Ok ",dummy&
      '
    ELSE
      '
      OPEN "I",#1,"KANJIROM.BIN"
      '
      IF LOF(#1)<>4096
        '
        CLR kanji_rom!
        ALERT 0,"KANJIROM.BIN-file is damaged! |Kanji-ROM disabled. ",1," Ok ",dummy&
        '
      ELSE
        BGET #1,kanji_rom%,4096
      ENDIF
      '
      CLOSE #1
      '
    ENDIF
    '
  ELSE
    '
    CLR kanji_rom!
    ALERT 0,"Can't find KANJIROM.BIN! |Kanji-ROM disabled. ",1," Ok ",dummy&
    '
  ENDIF
  '
ENDIF
'
RETURN
> PROCEDURE init_fmpac_ram                ! Init FMPac-RAM
'
IF fm_pac!
  '
  DIM fmpac_ram%(8192\4)      ! RAM for FM-Pac (8Kb)
  '
  IF EXIST("FM_PAC.RAM")
    OPEN "I",#1,"FM_PAC.RAM"
    BGET #1,V:fmpac_ram%(0),8192
    CLOSE #1
  ENDIF
  '
ENDIF
'
RETURN
> PROCEDURE reset_msx                     ! Reset MSX :-)
'
OUT 2,7               ! Reset PSG
'
CLR reg_a&,reg_b&,reg_c&,reg_d&,reg_e&,reg_ix%,reg_iy%,reg_i&,reg_r&,emul&
CLR reg_a_&,reg_b_&,reg_c_&,reg_d_&,reg_e_&,program_counter%,stack_pointer%
CLR cycle_cnt%,interrupts!,old_interrupts!,keybuf_cnt&,kb_dummy!,rp5c01_adr&
CLR video_read_pointer%,video_write_pointer%,sony_8255%,sony_8255_write!
CLR sony_8255_adr.l!,reg_f_&,fmpac_ram!,fmpac_0x5ffe&,fmpac_0x5fff&
CLR fmpac_0x7ff6&
@reg_f(0)
'
ARRAYFILL vdp_data|(),0
ARRAYFILL charset|(),0
ARRAYFILL charcolors|(),0
ARRAYFILL slot_sel&(),0
ARRAYFILL slot2sel&(),0
ARRAYFILL mmap&(),0
ARRAYFILL konami_scc_volume|(),0
ARRAYFILL konami_scc_freq%(),0
FOR dummy&=0 TO 4
  konami_scc_wave$(dummy&)=""
NEXT dummy&
ARRAYFILL keybuf|(),0
ARRAYFILL keysk|(),0
ARRAYFILL dr_emul|(),0
ARRAYFILL freq&(),0
ARRAYFILL vdp_data|(),0
'
' Reset MIDI:
OUT 3,&HF7    ! END  [System Exclusive Information]
OUT 3,&HFC    ! STOP [Real Time Information]
FOR dummy&=0 TO 15
  OUT 3,BYTE(ADD(&H80,dummy&)),0,0    ! NOTE OFF
  OUT 3,BYTE(ADD(&HB0,dummy&)),&H7C   ! OMNI MODE OFF
  OUT 3,BYTE(ADD(&HB0,dummy&)),&H7B,0 ! ALL NOTES OFF
NEXT dummy&
OUT 3,&HFF    ! System Reset
'
@update_global_memory_pointers
@update_memory_mapper_pointers
'
vdp_data!=TRUE
'
RETURN
$P>
'
> FUNCTION fileselect$(string$)           ! Ask for file
LOCAL file$,dummy&
'
FILESELECT #string$,path$+select$,default$,file$
IF EXIST(file$)
dummy&=RINSTR(file$,"\")
path$=LEFT$(file$,dummy&)
default$=MID$(file$,SUCC(dummy&))
dummy&=INSTR(default$,".")
IF dummy&
  select$="*"+MID$(default$,dummy&)
ELSE
  select$="*.*"
ENDIF
ENDIF
'
RETURN file$
'
ENDFUNC
> PROCEDURE load_bsave(file$,ask!)        ! Loads a BSAVEd program in memory
LOCAL dummy&,start%,length%,exec%
'
OPEN "I",#1,file$
'
IF EOF(#1)                    ! Lege file?
'
ALERT 0,"Empty file! ",1," Cancel ",dummy&
HIDEM
'
ELSE IF INP(#1)=&HFE          ! BSAVEd?
'
start%=ADD(INP(#1),SHL(INP(#1),8))
length%=ADD(INP(#1),SHL(INP(#1),8))-start%+1
exec%=ADD(INP(#1),SHL(INP(#1),8))
'
PRINT AT(42,max_row&);"Start: ";HEX$(start%,4);", End: ";HEX$(ADD(start%,length%),4);", Exec: ";HEX$(exec%,4);"K";
'
' load in buffers
DO WHILE length%
  '
  dummy%=@page.mem_left(start%,length%)
  BGET #1,ADD(cpageo%(SHR(start%,14)),AND(start%,&H3FFF)),dummy%
  ADD start%,dummy%
  SUB length%,dummy%
  '
LOOP
'
IF ask!
  '
  ALERT 0,"Execute this dump? ",0," Yes | No | Exit ",dummy&
  HIDEM
  $S& S<
  SELECT dummy&
  CASE 1                      ! Execute
    ram_start%=exec%
  CASE 2                      ! Don't execute
    ' do nothing :-)
  CASE 3
    @end
  DEFAULT
    error_exit&=err_internal_error&
  ENDSELECT
  $S% S>
  '
ELSE
  '
  ram_start%=exec%
  '
ENDIF
'
ELSE
'
ALERT 0,"Not a BSAVEd file! ",1," Cancel ",dummy&
HIDEM
'
ENDIF
'
CLOSE #1
'
RETURN
'
> PROCEDURE add_key_to_buffer(char&)      ! Add key to internal buffer
'
IF keybuf_cnt&<=max_bufkeys&
keybuf|(keybuf_cnt&)=BYTE(char&)
keysk|(keybuf_cnt&)=BYTE(BIOS(11,W:-1))
INC keybuf_cnt&
ELSE
SETCOLOR 0,0
SETCOLOR 0,1
ENDIF
'
RETURN
$P<
> PROCEDURE error                         ! Error
'
ON ERROR
'
CLS
PRINT "p ***** ERROR! ***** q"
PRINT
PRINT "Number: ";ERR;"  Fatal-flag: ";FATAL!
PRINT "Last occured internal error: ";error_exit&
PRINT
'
@emulator_status
'
PRINT "Press any key..."
@any_key
'
IF FATAL!
'
ALERT 3,"Fatal error! |Program will exit. ",1," Exit ",dummy&
HIDEM
'
ELSE
'
ALERT 2,"Continue or exit? ",0,"Continue| Exit ",dummy&
HIDEM
'
$S& S<
SELECT dummy&
CASE 1              ! Continue with next instruction
  '
  RESUME NEXT
  '
CASE 2
  '
  END
  '
DEFAULT
  error_exit&=err_internal_error&
ENDSELECT
$S% S>
'
ENDIF
'
ON ERROR GOSUB error
'
RETURN
> PROCEDURE do_z80.d                      ! Do Z80-emulation [DEBUG-VERSION]
'
DO
'
IF single_step!
  @debug
ENDIF
'
command&=@get_byte_pc    ! Get Z80-Instruction
'
ON SUCC(SHR(command&,3)) GOSUB g_00,g_08,g_10,g_18,g_20,g_28,g_30,g_38,g_40,g_48,g_50,g_58,g_60,g_68,g_70,g_78,g_80,g_88,g_90,g_98,g_a0,g_a8,g_b0,g_b8,g_c0,g_c8,g_d0,g_d8,g_e0,g_e8,g_f0,g_f8
'
IF cycle_cnt%=>cycles_per_frame%
  @interrupt
ENDIF
'
LOOP UNTIL error_exit&
'
RETURN
> PROCEDURE check_emulation_keys          ! F6-F10
'
DO
'
$S& S< U+ I+
cek_dummy&=INP(2)
SELECT cek_dummy&
CASE 192                  !  F6: Emulator Status
  @emulator_status
CASE 193                  !  F7: Exit?
  '
  ALERT 0,"Exit emulation? ",0," Yes | No ",cek_choice&
  HIDEM
  IF cek_choice&=1
    error_exit&=err_return_to_main_menu&
  ENDIF
  '
CASE 194                  !  F8: Configuration-menu
  '
  @set_up
  '
CASE 195                  !  F9: LOAD
  '
  file$=@fileselect$("Select file to load")
  IF EXIST(file$)
    path$=LEFT$(file$,RINSTR(file$,"\"))
    '
    @load_bsave(file$,FALSE)
    '
  ENDIF
  '
CASE 196                  ! F10: Reset MSX
  '
  ALERT 0,"Reset MSX? ",0," Yes | No ",cek_dummy&
  HIDEM
  '
  IF cek_dummy&=1
    @reset_msx
  ENDIF
  '
  KEYPRESS &H420000   ! Press F8 = Configuration-menu
  '
DEFAULT               ! Add key to MSX-buffer
  '
  @add_key_to_buffer(cek_dummy&)
  '
ENDSELECT
$S% S> U- I-
'
LOOP WHILE INP?(2)
'
RETURN
> PROCEDURE emulator_status               ! Emulator Status
'
PRINT AT(42,1);"A: ";HEX$(reg_a&,2);"-";HEX$(reg_a_&,2);" F: ";HEX$(@reg_f,2);"-";HEX$(reg_f_&,2);
PRINT AT(42,2);"B: ";HEX$(reg_b&,2);"-";HEX$(reg_b_&,2);" C: ";HEX$(reg_c&,2);"-";HEX$(reg_c_&,2);
PRINT AT(42,3);"D: ";HEX$(reg_d&,2);"-";HEX$(reg_d_&,2);" E: ";HEX$(reg_e&,2);"-";HEX$(reg_e_&,2);
PRINT AT(42,4);"H: ";HEX$(reg_h&,2);"-";HEX$(reg_h_&,2);" L: ";HEX$(reg_l&,2);"-";HEX$(reg_l_&,2);
PRINT AT(42,5);"IX: ";HEX$(reg_ix%,4);" IY: ";HEX$(reg_iy%,4);
PRINT AT(42,6);"PC: ";HEX$(program_counter%,4);" SP: ";HEX$(stack_pointer%,4);
PRINT AT(42,7);"Flags: ";BIN$(@reg_f,8);
PRINT AT(42,8);" I: ";HEX$(reg_i&,2);"   R: ";HEX$(reg_r&,2);
PRINT AT(42,9);"Co: ";HEX$(command&,2);" Int: ";
IF interrupts!
PRINT "On ";
ELSE
PRINT "Off";
ENDIF
IF ram_ch!
FOR es_lus&=0 TO 3
  PRINT AT(42,ADD(10,es_lus&));slot_sel&(es_lus&);":";slot2sel&(es_lus&,slot_sel&(es_lus&));"=";
  '
  $S& S<
  SELECT page&(es_lus&,slot_sel&(es_lus&),slot2sel&(es_lus&,slot_sel&(es_lus&)))
  CASE mem_ram&       ! RAM
    PRINT "RAM";
  CASE mem_rom&       ! ROM
    PRINT "ROM";
  CASE mem_unused&    ! Unused
    PRINT "---";
  CASE mem_map&       ! Memory Mapper <----- NIET GEBRUIKEN!!!!!
    PRINT "MAP";
  DEFAULT             ! ?!?!
    PRINT "?!?";
  ENDSELECT
  $S% S>
  '
NEXT es_lus&
CLR ram_ch!
ENDIF
PRINT AT(50,10);"----VDP----";
PRINT AT(50,11);"Read:  ";HEX$(video_read_pointer%,4);
PRINT AT(50,12);"Write: ";HEX$(video_write_pointer%,4);
PRINT AT(50,13);"Mode:  ";video_mode&;
PRINT AT(42,14);"Rel.Speed: ";AT(59,14);"%";
PRINT AT(42,15);"Special: ";
$S& S<
SELECT emul&
CASE none_emul&
CASE vdp_emul&
PRINT "VDP ";
CASE scc_emul&
PRINT "SCC+";
CASE mmod_emul&
PRINT "MMOD";
CASE keyboard_emul&
PRINT "KEYB";
CASE drive.l_emul&
PRINT "DRVL";
CASE drive.h_emul&
PRINT "DRVH";
CASE fmpac_emul&
PRINT "FM-P";
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
$S% S>
PRINT AT(42,16);"Keys: ";keybuf_cnt&;" #";DIV(SUB(TIMER,start_tijd%),200);"s";
PRINT AT(42,17);"MMap:";
IF mem_mapper!
FOR es_lus&=0 TO 3
  PRINT " ";HEX$(mmap&(es_lus&),2);
NEXT es_lus&
PRINT
ELSE
PRINT " No Mapper"
ENDIF
emul&=none_emul&
IF file_open!
PRINT AT(42,18);"R";HEX$(LOC(#50),4);" W";HEX$(LOC(#51),4);
ELSE
PRINT AT(42,18);SPACE$(11);
ENDIF
IF AND(redirect_printer!,printerfile_open!)
PRINT AT(42,19);"P";HEX$(LOC(#58),4);
ELSE
PRINT AT(42,19);SPACE$(5);
ENDIF
'
RETURN
> PROCEDURE debug                         ! Main debugging routine
'
$U+ I+
IF diss_pointer%=0
'
@check_emulation_keys
'
ELSE IF program_counter%=diss_pointer%
'
CLR diss_pointer%
debug!=TRUE
'
ENDIF
'
IF debug!
'
~@disassem(program_counter%,-1)
'
ENDIF
'
IF cpu_usage!
'
dummy2&=ADD(cpu_usage_x&,330)
'
GRAPHMODE 3
LINE dummy2&,lowest_y_line&,dummy2&,cpu_usage&(cpu_usage_x&)
'
cpu_usage&(cpu_usage_x&)=SUB(lowest_y_line&,MIN(100,SHL(SUB(cycle_cnt%,last_cycle_cnt%),1)))
last_cycle_cnt%=cycle_cnt%
'
LINE dummy2&,lowest_y_line&,dummy2&,cpu_usage&(cpu_usage_x&)
GRAPHMODE 1
'
INC cpu_usage_x&
IF cpu_usage_x&>300
  CLR cpu_usage_x&
ENDIF
'
ENDIF
$U- I-
'
RETURN
> PROCEDURE interrupt                     ! Do several _very_ important things.
'
IF vsync!
IF cycle_cnt%=cycles_per_frame%     ! niet echt nodig, maar voor echt snelle emulatie :-)
  VSYNC
ENDIF
ENDIF
'
IF relative_speed_calculation!        ! Show emulation-speed relative to MSX-1
dummy%=SUB(TIMER,start_emulation_time%)
relative_speed=400/CFLOAT(dummy%)
PRINT AT(53,14);STR$(relative_speed,6,2);
IF real_nmi!
  cycles_per_frame%=CFLOAT(clock_freq%/screen_refresh&)*(4/CFLOAT(dummy%))
ENDIF
ENDIF
'
IF show_emulator_status!              ! Show registers etc.
$U+ I+
@emulator_status
$U- I-
ENDIF
'
IF INP?(2)                            ! Check keys
$U+ I+
@check_emulation_keys
$U- I-
ENDIF
'
hacked!=hack_cnt&<>12572
'
IF hacked!
SETCOLOR 0,program_counter%
ELSE
SUB cycle_cnt%,cycles_per_frame%      ! Re-init cycle-counter
start_emulation_time%=TIMER
ENDIF
'
IF int_0x38!                          ! Do MSX-Interrupts
IF AND(interrupts!,interrupt_level&=1)
  @rst(&H38)
ENDIF
ENDIF
'
RETURN
'
' *** Emulate Z80 ***
'
> PROCEDURE do_z80                        ! Do Z80-emulation
'
DO
command&=@get_byte_pc    ! Get Z80-Instruction
'
ON SUCC(SHR(command&,3)) GOSUB g_00,g_08,g_10,g_18,g_20,g_28,g_30,g_38,g_40,g_48,g_50,g_58,g_60,g_68,g_70,g_78,g_80,g_88,g_90,g_98,g_a0,g_a8,g_b0,g_b8,g_c0,g_c8,g_d0,g_d8,g_e0,g_e8,g_f0,g_f8
'
IF cycle_cnt%=>cycles_per_frame%
  @interrupt
ENDIF
'
LOOP UNTIL error_exit&
'
RETURN
> PROCEDURE g_00 !                      0x00 ... 0x07
'
$S& S>
SELECT command&
CASE &H0                            ! NOP [No Operant]
'
ADD cycle_cnt%,4+1
'
CASE &H1                            ! LD BC,nnnn
'
dummy%=@get_word_pc
'
reg_b&=SHR(dummy%,8)
reg_c&=BYTE(dummy%)
'
ADD cycle_cnt%,10+1
'
CASE &H2                            ! LD (BC),A
'
@put_byte(ADD(SHL(reg_b&,8),reg_c&),reg_a&)
'
ADD cycle_cnt%,7+1
'
CASE &H3                            ! INC BC
'
@inc_double(reg_b&,reg_c&)
'
ADD cycle_cnt%,6+1
'
CASE &H4                            ! INC B
'
@inc(reg_b&)
'
ADD cycle_cnt%,4+1
'
CASE &H5                            ! DEC B
'
@dec(reg_b&)
'
ADD cycle_cnt%,4+1
'
CASE &H6                            ! LD B,n
'
reg_b&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H7                            ! RLCA
'
reg_a&=ROL|(reg_a&,1)
flag_carry!=AND(reg_a&,1)
'
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_08 !                      0x08 ... 0x0F!
'
$S& S>
SELECT command&
CASE &H8                            ! EX AF,AF'
'
SWAP reg_a&,reg_a_&
dummy&=@reg_f
@reg_f(reg_f_&)
reg_f_&=dummy&
'
ADD cycle_cnt%,4+1
'
CASE &H9                            ! ADD HL,BC
'
@add_hl(reg_b&,reg_c&)
'
ADD cycle_cnt%,11+1
'
CASE &HA                            ! LD A,(BC)
'
reg_a&=@get_byte(ADD(SHL(reg_b&,8),reg_c&))
'
ADD cycle_cnt%,7+1
'
CASE &HB                            ! DEC BC
'
@dec_double(reg_b&,reg_c&)
'
ADD cycle_cnt%,6+1
'
CASE &HC                            ! INC C
'
@inc(reg_c&)
'
ADD cycle_cnt%,4+1
'
CASE &HD                            ! DEC C
'
@dec(reg_c&)
'
ADD cycle_cnt%,4+1
'
CASE &HE                            ! LD C,n
'
reg_c&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &HF                            ! RRCA
'
flag_carry!=AND(reg_a&,1)
reg_a&=ROR|(reg_a&,1)
'
CLR flag_half.c!,flag_neg!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_10 !                      0x10 ... 0x17
'
$S& S>
SELECT command&
CASE &H10                           ! DJNZ e
'
reg_b&=BYTE(PRED(reg_b&))
'
IF reg_b&
  '
  program_counter%=CARD(ADD(program_counter%,jr&(@get_byte(program_counter%))))
  '
  ADD cycle_cnt%,13+1
ELSE
  '
  INC program_counter%          ! Skip jmp cnt
  '
  ADD cycle_cnt%,8+1
ENDIF
'
CASE &H11                           ! LD DE,nnnn
'
dummy%=@get_word_pc
'
reg_d&=SHR(dummy%,8)
reg_e&=BYTE(dummy%)
'
ADD cycle_cnt%,10+1
'
CASE &H12                           ! LD (DE),A
'
@put_byte(ADD(SHL(reg_d&,8),reg_e&),reg_a&)
'
ADD cycle_cnt%,7+1
'
CASE &H13                           ! INC DE
'
@inc_double(reg_d&,reg_e&)
'
ADD cycle_cnt%,6+1
'
CASE &H14                           ! INC D
'
@inc(reg_d&)
'
ADD cycle_cnt%,4+1
'
CASE &H15                           ! DEC D
'
@dec(reg_d&)
'
ADD cycle_cnt%,4+1
'
CASE &H16                           ! LD D,n
'
reg_d&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H17                           ! RLA
'
dummy!=reg_a&>127
reg_a&=ADD(SHL|(reg_a&,1),ABS(flag_carry!))
flag_carry!=dummy!
'
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_18 !                      0x18 ... 0x1F!
'
$S& S>
SELECT command&
CASE &H18                           ! JR e
'
ADD program_counter%,jr&(@get_byte(program_counter%))
'
ADD cycle_cnt%,12+1
'
CASE &H19                           ! ADD HL,DE
'
@add_hl(reg_d&,reg_e&)
'
ADD cycle_cnt%,11+1
'
CASE &H1A                           ! LD A,(DE)
'
reg_a&=@get_byte(ADD(SHL(reg_d&,8),reg_e&))
'
ADD cycle_cnt%,7+1
'
CASE &H1B                           ! DEC DE
'
@dec_double(reg_d&,reg_e&)
'
ADD cycle_cnt%,6+1
'
CASE &H1C                           ! INC E
'
@inc(reg_e&)
'
ADD cycle_cnt%,4+1
'
CASE &H1D                           ! DEC E
'
@dec(reg_e&)
'
ADD cycle_cnt%,4+1
'
CASE &H1E                           ! LD E,n
'
reg_e&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H1F                           ! RRA
'
dummy!=flag_carry!
flag_carry!=AND(reg_a&,1)
reg_a&=SHR(reg_a&,1)
ADD reg_a&,AND(dummy!,128)
'
CLR flag_half.c!,flag_neg!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_20 !                      0x20 ... 0x27
'
$S& S>
SELECT command&
CASE &H20                           ! JR NZ,e
'
@jr(NOT flag_zero!)
'
CASE &H21                           ! LD HL,nnnn
'
dummy%=@get_word_pc
reg_h&=SHR(dummy%,8)
reg_l&=BYTE(dummy%)
'
ADD cycle_cnt%,16
'
CASE &H22                           ! LD (nnnn),HL
'
@put_word(@get_word_pc,ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,16
'
CASE &H23                           ! INC HL
'
@inc_double(reg_h&,reg_l&)
'
ADD cycle_cnt%,6+1
'
CASE &H24                           ! INC H
'
@inc(reg_h&)
'
ADD cycle_cnt%,4+1
'
CASE &H25                           ! DEC H
'
@dec(reg_h&)
'
ADD cycle_cnt%,4+1
'
CASE &H26                           ! LD H,n
'
reg_h&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H27                           ! DAA      <---
'
@daa
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_28 !                      0x28 ... 0x2F!
'
$S& S>
SELECT command&
CASE &H28                           ! JR Z,e
'
@jr(flag_zero!)
'
CASE &H29                           ! ADD HL,HL
'
@add_hl(reg_h&,reg_l&)
'
ADD cycle_cnt%,11+1
'
CASE &H2A                           ! LD HL,(nnnn)
'
dummy%=@get_word(@get_word_pc)
reg_h&=SHR(dummy%,8)
reg_l&=BYTE(dummy%)
'
ADD cycle_cnt%,16
'
CASE &H2B                           ! DEC HL
'
@dec_double(reg_h&,reg_l&)
'
ADD cycle_cnt%,6+1
'
CASE &H2C                           ! INC L
'
@inc(reg_l&)
'
ADD cycle_cnt%,4+1
'
CASE &H2D                           ! DEC L
'
@dec(reg_l&)
'
ADD cycle_cnt%,4+1
'
CASE &H2E                           ! LD L,n
'
reg_l&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H2F                           ! CPL
'
reg_a&=XOR(reg_a&,255)
'
flag_neg!=TRUE
flag_half.c!=TRUE
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_30 !                      0x30 ... 0x37
'
$S& S>
SELECT command&
CASE &H30                           ! JR NC,e
'
@jr(NOT flag_carry!)
'
CASE &H31                           ! LD SP,nnnn
'
stack_pointer%=@get_word_pc
'
ADD cycle_cnt%,10+1
'
CASE &H32                           ! LD (nnnn),A
'
@put_byte(@get_word_pc,reg_a&)
'
ADD cycle_cnt%,13+1
'
CASE &H33                           ! INC SP
'
INC stack_pointer%
'
ADD cycle_cnt%,6+1
'
CASE &H34                           ! INC (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@inc(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,6+1
'
CASE &H35                           ! DEC (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@dec(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,11+1
'
CASE &H36                           ! LD (HL),n
'
@put_byte(ADD(SHL(reg_h&,8),reg_l&),@get_byte_pc)
'
ADD cycle_cnt%,10+1
'
CASE &H37                           ! SCF
'
flag_carry!=TRUE
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_38 !                      0x38 ... 0x3F!
'
$S& S>
SELECT command&
CASE &H38                           ! JR C,e
'
@jr(flag_carry!)
'
CASE &H39                           ! ADD HL,SP
'
@add_hl(SHR(stack_pointer%,8),BYTE(stack_pointer%))
'
ADD cycle_cnt%,11+1
'
CASE &H3A                           ! LD A,(nnnn)
'
reg_a&=@get_byte(@get_word_pc)
'
ADD cycle_cnt%,13+1
'
CASE &H3B                           ! DEC SP
'
DEC stack_pointer%
'
ADD cycle_cnt%,6+1
'
CASE &H3C                           ! INC A
'
@inc(reg_a&)
'
ADD cycle_cnt%,4+1
'
CASE &H3D                           ! DEC A
'
@dec(reg_a&)
'
ADD cycle_cnt%,4+1
'
CASE &H3E                           ! LD A,n
'
reg_a&=@get_byte_pc
'
ADD cycle_cnt%,7+1
'
CASE &H3F                           ! CCF
'
flag_half.c!=flag_carry!
flag_carry!=NOT flag_carry!
'
ADD cycle_cnt%,4+1
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_40 !                      0x40 ... 0x47     LD B,x
'
$S& S>
SELECT command&
'  CASE &H40                           ! LD B,B
'
'    reg_b&=reg_b&
'
CASE &H41                           ! LD B,C
'
reg_b&=reg_c&
'
CASE &H42                           ! LD B,D
'
reg_b&=reg_d&
'
CASE &H43                           ! LD B,E
'
reg_b&=reg_e&
'
CASE &H44                           ! LD B,H
'
reg_b&=reg_h&
'
CASE &H45                           ! LD B,L
'
reg_b&=reg_l&
'
CASE &H46                           ! LD B,(HL)
'
reg_b&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H47                           ! LD B,A
'
reg_b&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_48 !                      0x48 ... 0x4F!    LD C,x
'
$S& S>
SELECT command&
CASE &H48                           ! LD C,B
'
reg_c&=reg_b&
'
'  CASE &H49                           ! LD C,C
'
'        reg_c&=reg_c&
'
CASE &H4A                           ! LD C,D
'
reg_c&=reg_d&
'
CASE &H4B                           ! LD C,E
'
reg_c&=reg_e&
'
CASE &H4C                           ! LD C,H
'
reg_c&=reg_h&
'
CASE &H4D                           ! LD C,L
'
reg_c&=reg_l&
'
CASE &H4E                           ! LD C,(HL)
'
reg_c&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H4F                           ! LD C,A
'
reg_c&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_50 !                      0x50 ... 0x57     LD D,x
'
$S& S>
SELECT command&
CASE &H50                           ! LD D,B
'
reg_d&=reg_b&
'
CASE &H51                           ! LD D,C
'
reg_d&=reg_c&
'
'  CASE &H52                           ! LD D,D
'
'        reg_d&=reg_d&
'
CASE &H53                           ! LD D,E
'
reg_d&=reg_e&
'
CASE &H54                           ! LD D,H
'
reg_d&=reg_h&
'
CASE &H55                           ! LD D,L
'
reg_d&=reg_l&
'
CASE &H56                           ! LD D,(HL)
'
reg_d&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H57                           ! LD D,A
'
reg_d&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_58 !                      0x58 ... 0x5F!    LD E,x
'
$S& S>
SELECT command&
CASE &H58                           ! LD E,B
'
reg_e&=reg_b&
'
CASE &H59                           ! LD E,C
'
reg_e&=reg_c&
'
CASE &H5A                           ! LD E,D
'
reg_e&=reg_d&
'
'  CASE &H5B                           ! LD E,E
'
'        reg_e&=reg_e&
'
CASE &H5C                           ! LD E,H
'
reg_e&=reg_h&
'
CASE &H5D                           ! LD E,L
'
reg_e&=reg_l&
'
CASE &H5E                           ! LD E,(HL)
'
reg_e&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H5F                           ! LD E,A
'
reg_e&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_60 !                      0x60 ... 0x67     LD H,x
'
$S& S>
SELECT command&
CASE &H60                           ! LD H,B
'
reg_h&=reg_b&
'
CASE &H61                           ! LD H,C
'
reg_h&=reg_c&
'
CASE &H62                           ! LD H,D
'
reg_h&=reg_d&
'
CASE &H63                           ! LD H,E
'
reg_h&=reg_e&
'
'  CASE &H64                           ! LD H,H
'
'        reg_h&=reg_h&
'
CASE &H65                           ! LD H,L
'
reg_h&=reg_l&
'
CASE &H66                           ! LD H,(HL)
'
reg_h&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H67                           ! LD H,A
'
reg_h&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_68 !                      0x68 ... 0x6F!    LD L,x
'
$S& S>
SELECT command&
CASE &H68                           ! LD L,B
'
reg_l&=reg_b&
'
CASE &H69                           ! LD L,C
'
reg_l&=reg_c&
'
CASE &H6A                           ! LD L,D
'
reg_l&=reg_d&
'
CASE &H6B                           ! LD L,E
'
reg_l&=reg_e&
'
CASE &H6C                           ! LD L,H
'
reg_l&=reg_h&
'
'  CASE &H6D                           ! LD L,L
'
'        reg_l&=reg_l&
'
CASE &H6E                           ! LD L,(HL)
'
reg_l&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
CASE &H6F                           ! LD L,A
'
reg_l&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_70 !                      0x70 ... 0x77     LD (HL),x & HALT
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
'
$S& S>
SELECT command&
CASE &H70                           ! LD (HL),B
'
@put_byte(dummy%,reg_b&)
'
CASE &H71                           ! LD (HL),C
'
@put_byte(dummy%,reg_c&)
'
CASE &H72                           ! LD (HL),D
'
@put_byte(dummy%,reg_d&)
'
CASE &H73                           ! LD (HL),E
'
@put_byte(dummy%,reg_e&)
'
CASE &H74                           ! LD (HL),H
'
@put_byte(dummy%,reg_h&)
'
CASE &H75                           ! LD (HL),L
'
@put_byte(dummy%,reg_l&)
'
CASE &H76                           ! HALT
'
PRINT AT(42,max_row&);"pHALTqK";
'
SUB cycle_cnt%,3         ! + 7+1 = 4+1
'
IF real_halt!
  '
  DO UNTIL cycle_cnt%=>cycles_per_frame%
    ADD cycle_cnt%,4+1
  LOOP
  '
ENDIF
'
PRINT AT(42,max_row&);"K";
'
CASE &H77                           ! LD (HL),A
'
@put_byte(dummy%,reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,7+1
'
RETURN
> PROCEDURE g_78 !                      0x78 ... 0x7F!    LD A,x
'
$S& S>
SELECT command&
CASE &H78                           ! LD A,B
'
reg_a&=reg_b&
'
CASE &H79                           ! LD A,C
'
reg_a&=reg_c&
'
CASE &H7A                           ! LD A,D
'
reg_a&=reg_d&
'
CASE &H7B                           ! LD A,E
'
reg_a&=reg_e&
'
CASE &H7C                           ! LD A,H
'
reg_a&=reg_h&
'
CASE &H7D                           ! LD A,L
'
reg_a&=reg_l&
'
CASE &H7E                           ! LD A,(HL)
'
reg_a&=@get_byte(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,3
'
'  CASE &H7F                           ! LD A,A
'
'        reg_a&=reg_a&
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_80 !                      0x80 ... 0x87     ADD A,x
'
$S& S>
SELECT command&
CASE &H80                           ! ADD A,B
'
@add(reg_b&)
'
CASE &H81                           ! ADD A,C
'
@add(reg_c&)
'
CASE &H82                           ! ADD A,D
'
@add(reg_d&)
'
CASE &H83                           ! ADD A,E
'
@add(reg_e&)
'
CASE &H84                           ! ADD A,H
'
@add(reg_h&)
'
CASE &H85                           ! ADD A,L
'
@add(reg_l&)
'
CASE &H86                           ! ADD A,(HL)
'
@add(@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &H87                           ! ADD A,A
'
@add(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_88 !                      0x88 ... 0x8F!    ADC A,x
'
$S& S>
SELECT command&
CASE &H88                           ! ADC A,B
'
@adc(reg_b&)
'
CASE &H89                           ! ADC A,C
'
@adc(reg_c&)
'
CASE &H8A                           ! ADC A,D
'
@adc(reg_d&)
'
CASE &H8B                           ! ADC A,E
'
@adc(reg_e&)
'
CASE &H8C                           ! ADC A,H
'
@adc(reg_h&)
'
CASE &H8D                           ! ADC A,L
'
@adc(reg_l&)
'
CASE &H8E                           ! ADC A,(HL)
'
@adc(@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &H8F                           ! ADC A,A
'
@adc(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_90 !                      0x90 ... 0x97     SUB x
'
$S& S>
SELECT command&
CASE &H90                           ! SUB B
'
@sub(reg_b&)
'
CASE &H91                           ! SUB C
'
@sub(reg_c&)
'
CASE &H92                           ! SUB D
'
@sub(reg_d&)
'
CASE &H93                           ! SUB E
'
@sub(reg_e&)
'
CASE &H94                           ! SUB H
'
@sub(reg_h&)
'
CASE &H95                           ! SUB L
'
@sub(reg_l&)
'
CASE &H96                           ! SUB (HL)
'
@sub(@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &H97                           ! SUB A
'
@sub(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_98 !                      0x98 ... 0x9F!    SBC x
'
$S& S>
SELECT command&
CASE &H98                           ! SBC B
'
@sbc(reg_b&)
'
CASE &H99                           ! SBC C
'
@sbc(reg_c&)
'
CASE &H9A                           ! SBC D
'
@sbc(reg_d&)
'
CASE &H9B                           ! SBC E
'
@sbc(reg_e&)
'
CASE &H9C                           ! SBC H
'
@sbc(reg_h&)
'
CASE &H9D                           ! SBC L
'
@sbc(reg_l&)
'
CASE &H9E                           ! SBC (HL)
'
@sbc(@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &H9F                           ! SBC A
'
@sbc(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_a0 !                      0xA0 ... 0xA7     AND x
'
$S& S>
SELECT command&
CASE &HA0                           ! AND B
'
reg_a&=AND(reg_a&,reg_b&)
'
CASE &HA1                           ! AND C
'
reg_a&=AND(reg_a&,reg_c&)
'
CASE &HA2                           ! AND D
'
reg_a&=AND(reg_a&,reg_d&)
'
CASE &HA3                           ! AND E
'
reg_a&=AND(reg_a&,reg_e&)
'
CASE &HA4                           ! AND H
'
reg_a&=AND(reg_a&,reg_h&)
'
CASE &HA5                           ! AND L
'
reg_a&=AND(reg_a&,reg_l&)
'
CASE &HA6                           ! AND (HL)
'
reg_a&=AND(reg_a&,@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
'  CASE &HA7                           ! AND A
'
'    reg_a&=AND(reg_a&,reg_a&)
'
ENDSELECT
$S% S>
'
CLR flag_carry!,flag_neg!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
flag_half.c!=TRUE
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_a8 !                      0xa8 ... 0xaF!    XOR x
'
$S& S>
SELECT command&
CASE &HA8                           ! XOR B
'
reg_a&=XOR(reg_a&,reg_b&)
'
CASE &HA9                           ! XOR C
'
reg_a&=XOR(reg_a&,reg_c&)
'
CASE &HAA                           ! XOR D
'
reg_a&=XOR(reg_a&,reg_d&)
'
CASE &HAB                           ! XOR E
'
reg_a&=XOR(reg_a&,reg_e&)
'
CASE &HAC                           ! XOR H
'
reg_a&=XOR(reg_a&,reg_h&)
'
CASE &HAD                           ! XOR L
'
reg_a&=XOR(reg_a&,reg_l&)
'
CASE &HAE                           ! XOR (HL)
'
reg_a&=XOR(reg_a&,@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &HAF                           ! XOR A
'
'    reg_a&=XOR(reg_a&,reg_a&)
CLR reg_a&
'
ENDSELECT
$S% S>
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_b0 !                      0xB0 ... 0xB7     OR x
'
$S& S>
SELECT command&
CASE &HB0                           ! OR B
'
reg_a&=OR(reg_a&,reg_b&)
'
CASE &HB1                           ! OR C
'
reg_a&=OR(reg_a&,reg_c&)
'
CASE &HB2                           ! OR D
'
reg_a&=OR(reg_a&,reg_d&)
'
CASE &HB3                           ! OR E
'
reg_a&=OR(reg_a&,reg_e&)
'
CASE &HB4                           ! OR H
'
reg_a&=OR(reg_a&,reg_h&)
'
CASE &HB5                           ! OR L
'
reg_a&=OR(reg_a&,reg_l&)
'
CASE &HB6                           ! OR (HL)
'
reg_a&=OR(reg_a&,@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
'  CASE &HB7                           ! OR A
'
'        reg_a&=OR(reg_a&,reg_a&)
'
ENDSELECT
$S% S>
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_b8 !                      0xb8 ... 0xbF!    CP x
'
$S& S>
SELECT command&
CASE &HB8                           ! CP B
'
@cp(reg_b&)
'
CASE &HB9                           ! CP C
'
@cp(reg_c&)
'
CASE &HBA                           ! CP D
'
@cp(reg_d&)
'
CASE &HBB                           ! CP E
'
@cp(reg_e&)
'
CASE &HBC                           ! CP H
'
@cp(reg_h&)
'
CASE &HBD                           ! CP L
'
@cp(reg_l&)
'
CASE &HBE                           ! CP (HL)
'
@cp(@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
'
ADD cycle_cnt%,3
'
CASE &HBF                           ! CP A
'
@cp(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,4+1
'
RETURN
> PROCEDURE g_c0 !                      0xC0 ... 0xC7
'
$S& S>
SELECT command&
CASE &HC0                           ! RET NZ
'
@ret(NOT flag_zero!)
'
CASE &HC1                           ! POP BC
'
dummy%=@get_word_sp
reg_b&=SHR(dummy%,8)
reg_c&=BYTE(dummy%)
'
ADD cycle_cnt%,10+1
'
CASE &HC2                           ! JP NZ,nnnn
'
@jp(NOT flag_zero!)
'
CASE &HC3                           ! JP nnnn
'
program_counter%=@get_word(program_counter%)
'
ADD cycle_cnt%,10+1
'
CASE &HC4                           ! CALL NZ,nnnn
'
@call(NOT flag_zero!)
'
CASE &HC5                           ! PUSH BC
'
@put_word_sp(ADD(SHL(reg_b&,8),reg_c&))
'
ADD cycle_cnt%,11+1
'
CASE &HC6                           ! ADD A,n
'
@add(@get_byte_pc)
'
ADD cycle_cnt%,7+1
'
CASE &HC7                           ! RST 00H
'
@rst(&H0)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_c8 !                      0xc8 ... 0xcF!
'
$S& S>
SELECT command&
CASE &HC8                           ! RET Z
'
@ret(flag_zero!)
'
CASE &HC9                           ! RET
'
program_counter%=@get_word_sp
'
ADD cycle_cnt%,10+1
'
CASE &HCA                           ! JP Z,nnnn
'
@jp(flag_zero!)
'
CASE &HCB                           ! ---> Sub Commands <---
'
sub_command&=@get_byte_pc
'
IF sub_command&<&H40
  '
  ON SUCC(SHR(sub_command&,3)) GOSUB subc_0xcb.rlc,subc_0xcb.rrc,subc_0xcb.rl,subc_0xcb.rr,subc_0xcb.sla,subc_0xcb.sra,subc_0xcb.sll,subc_0xcb.srl
  '
ELSE
  '
  $S> $S&
  SELECT sub_command&
  CASE &H40 TO &H7F             ! BIT x,y
    @chk_bits
  CASE &H80 TO &HBF             ! RES x,y
    @res_bits
  CASE &HC0 TO &HFF             ! SET x,y
    @set_bits
  ENDSELECT
  '
ENDIF
'
CASE &HCC                           ! CALL Z,nnnn
'
@call(flag_zero!)
'
CASE &HCD                           ! CALL nnnn
'
dummy%=@get_word_pc
'
IF not_patched!(dummy%)                     ! Geen Patch?
  '
  @put_word_sp(program_counter%)
  program_counter%=dummy%
  '
ELSE IF NOT @check_jump_patches(dummy%)     ! Misschien wel Patch?
  '
  @put_word_sp(program_counter%)
  program_counter%=dummy%
  '
ENDIF
'
ADD cycle_cnt%,17+1
'
CASE &HCE                           ! ADC A,n
'
@adc(@get_byte_pc)
'
ADD cycle_cnt%,4+1
'
CASE &HCF                           ! RST 08H
'
@rst(&H8)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_d0 !                      0xD0 ... 0xD7
'
$S& S>
SELECT command&
CASE &HD0                           ! RET NC
'
@ret(NOT flag_carry!)
'
CASE &HD1                           ! POP DE
'
dummy%=@get_word_sp
reg_d&=SHR(dummy%,8)
reg_e&=BYTE(dummy%)
'
ADD cycle_cnt%,10+1
'
CASE &HD2                           ! JP NC,nnnn
'
@jp(NOT flag_carry!)
'
CASE &HD3                           ! OUT n,A
'
@out(@get_byte_pc,reg_a&)
'
ADD cycle_cnt%,11+1
'
CASE &HD4                           ! CALL NC,nnnn
'
@call(NOT flag_carry!)
'
CASE &HD5                           ! PUSH DE
'
@put_word_sp(ADD(SHL(reg_d&,8),reg_e&))
'
ADD cycle_cnt%,11+1
'
CASE &HD6                           ! SUB n
'
@sub(@get_byte_pc)
'
ADD cycle_cnt%,7+1
'
CASE &HD7                           ! RST 10H
'
@rst(&H10)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_d8 !                      0xd8 ... 0xdF!
'
$S& S>
SELECT command&
CASE &HD8                           ! RET C
'
@ret(flag_carry!)
'
CASE &HD9                           ! EXX
'
SWAP reg_b&,reg_b_&
SWAP reg_c&,reg_c_&
SWAP reg_d&,reg_d_&
SWAP reg_e&,reg_e_&
SWAP reg_h&,reg_h_&
SWAP reg_l&,reg_l_&
'
ADD cycle_cnt%,4+1
'
CASE &HDA                           ! JP C,nnnn
'
@jp(flag_carry!)
'
CASE &HDB                           ! IN A,(n)
'
reg_a&=@inp(@get_byte_pc)
'
ADD cycle_cnt%,11+1
'
CASE &HDC                           ! CALL C,nnnn
'
@call(flag_carry!)
'
CASE &HDD                           ! ---> Sub Commands <--- [IX]
'
@subc_0xdd.fd(reg_ix%)
'
CASE &HDE                           ! SBC n
'
@sbc(@get_byte_pc)
'
ADD cycle_cnt%,7+1
'
CASE &HDF                           ! RST 18H
'
@rst(&H18)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_e0 !                      0xE0 ... 0xE7
'
$S& S>
SELECT command&
CASE &HE0                           ! RET PO
'
@ret(NOT flag_par.ov!)
'
CASE &HE1                           ! POP HL
'
dummy%=@get_word_sp
reg_h&=SHR(dummy%,8)
reg_l&=BYTE(dummy%)
'
ADD cycle_cnt%,10+1
'
CASE &HE2                           ! JP PO,nnnn
'
@jp(NOT flag_par.ov!)
'
CASE &HE3                           ! EX (SP),HL
'
dummy%=@get_word(stack_pointer%)
@put_word(stack_pointer%,ADD(SHL(reg_h&,8),reg_l&))
reg_h&=SHR(dummy%,8)
reg_l&=BYTE(dummy%)
'
ADD cycle_cnt%,19+1
'
CASE &HE4                           ! CALL PO,nnnn
'
@call(NOT flag_par.ov!)
'
CASE &HE5                           ! PUSH HL
'
@put_word_sp(ADD(SHL(reg_h&,8),reg_l&))
'
ADD cycle_cnt%,11+1
'
CASE &HE6                           ! AND n
'
reg_a&=AND(reg_a&,@get_byte_pc)
'
CLR flag_carry!,flag_neg!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
flag_half.c!=TRUE
'
ADD cycle_cnt%,7+1
'
CASE &HE7                           ! RST 20H
'
@rst(&H20)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_e8 !                      0xe8 ... 0xeF!
'
$S& S>
SELECT command&
CASE &HE8                           ! RET PE
'
@ret(flag_par.ov!)
'
CASE &HE9                           ! JP (HL)
'
program_counter%=ADD(SHL(reg_h&,8),reg_l&)
'
ADD cycle_cnt%,4+1
'
CASE &HEA                           ! JP PE,nnnn
'
@jp(flag_par.ov!)
'
CASE &HEB                           ! EX DE,HL
'
SWAP reg_d&,reg_h&
SWAP reg_e&,reg_l&
'
ADD cycle_cnt%,4+1
'
CASE &HEC                           ! CALL PE,nnnn
'
@call(flag_par.ov!)
'
CASE &HED                           ! ---> Sub Commands <---
'
sub_command&=@get_byte_pc
'
ON SUCC(SHR(sub_command&,4)) GOSUB sn,sn,sn,sn,s_0100,s_0101,s_0110,s_0111,s_1000,sn,s_1010,s_1011,sn,sn,sn,sn
'
CASE &HEE                           ! XOR n
'
reg_a&=XOR(reg_a&,@get_byte_pc)
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
ADD cycle_cnt%,7+1
'
CASE &HEF                           ! RST 28H
'
@rst(&H28)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_f0 !                      0xF0 ... 0xF7
'
$S& S>
SELECT command&
CASE &HF0                           ! RET P
'
@ret(NOT flag_sign!)
'
CASE &HF1                           ! POP AF
'
dummy%=@get_word_sp
reg_a&=SHR(dummy%,8)
@reg_f(BYTE(dummy%))
'
ADD cycle_cnt%,10+1
'
CASE &HF2                           ! JP P,nnnn
'
@jp(NOT flag_sign!)
'
CASE &HF3                           ! DI [Disable Interrupts]
'
CLR interrupts!
'
ADD cycle_cnt%,4+1
'
CASE &HF4                           ! CALL P,nnnn
'
@call(NOT flag_sign!)
'
CASE &HF5                           ! PUSH AF
'
@put_word_sp(ADD(SHL(reg_a&,8),@reg_f))
'
ADD cycle_cnt%,11+1
'
CASE &HF6                           ! OR n
'
reg_a&=OR(reg_a&,@get_byte_pc)
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
ADD cycle_cnt%,7+1
'
CASE &HF7                           ! RST 30H
'
@rst(&H30)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE g_f8 !                      0xf8 ... 0xfF!
'
$S& S>
SELECT command&
CASE &HF8                           ! RET M
'
@ret(flag_sign!)
'
CASE &HF9                           ! LD SP,HL
'
stack_pointer%=ADD(SHL(reg_h&,8),reg_l&)
'
ADD cycle_cnt%,6+1
'
CASE &HFA                           ! JP M,nnnn
'
@jp(flag_sign!)
'
CASE &HFB                           ! EI [Enable Interrupts]
'
interrupts!=TRUE
'
ADD cycle_cnt%,4+1
'
CASE &HFC                           ! CALL M,nnnn
'
@call(flag_sign!)
'
CASE &HFD                           ! ---> Sub Commands <--- [IY]
'
@subc_0xdd.fd(reg_iy%)
'
CASE &HFE                           ! CP n
'
@cp(@get_byte_pc)
'
ADD cycle_cnt%,7+1
'
CASE &HFF                           ! RST 38H
'
@rst(&H38)
'
ENDSELECT
$S% S>
'
RETURN
'
' *** Read/Write of Memory ***
'
$P>
> FUNCTION get_byte_pc                    ! Get BYTE from memory, PC++
$F%
'
gbp_dummy%=cpageo%(SHR(program_counter%,14))
IF gbp_dummy%
'
get_byte_dummy&=BYTE{ADD(gbp_dummy%,AND(program_counter%,&H3FFF))}
'
ELSE
'
get_byte_dummy&=@get_byte(program_counter%)
'
ENDIF
'
program_counter%=CARD(SUCC(program_counter%))
'
RETURN get_byte_dummy&
'
ENDFUNC
> FUNCTION get_byte(adres%)               ! Get BYTE from memory
$F%
'
gb_dummy%=cpageo%(SHR(adres%,14))
'
IF not_patched!(adres%)
'
IF gb_dummy%
RETURN BYTE{ADD(gb_dummy%,AND(adres%,&H3FFF))}
ENDIF
'
ELSE                          ! check 4 patches
'
get_byte_dummy&=@check_read_patches(adres%)
IF get_byte_dummy&>-1
'
RETURN get_byte_dummy&
'
ELSE IF gb_dummy%
'
RETURN BYTE{ADD(gb_dummy%,AND(adres%,&H3FFF))}
'
ENDIF
'
ENDIF
'
IF @r.fm_pac(adres%,get_byte_dummy&)
RETURN get_byte_dummy&
ENDIF
'
IF unused_random!
RETURN RANDOM(256)
ELSE
error_exit&=err_wrong_mem_page&
ENDIF
'
RETURN 121                    ! weetikveel...
'
ENDFUNC
> PROCEDURE put_byte(adres%,byte&)        ! Put BYTE in memory
$F%
'
put_byte_page&=SHR(adres%,14)
put_byte_dummy%=AND(adres%,&H3FFF)
'
IF AND(not_patched!(adres%),ram!(put_byte_page&))
'
BYTE{ADD(cpageo%(put_byte_page&),put_byte_dummy%)}=byte&
'
ELSE
'
IF NOT @check_write_patches(adres%,byte&)
IF ram!(put_byte_page&)
BYTE{ADD(cpageo%(put_byte_page&),put_byte_dummy%)}=byte&
ELSE
@w.fm_pac(adres%,byte&)
ENDIF
ENDIF
'
ENDIF
'
RETURN
> FUNCTION get_word_pc                    ! Get WORD from memory, PC++
$F%
'
gw_adres%=AND(program_counter%,&H3FFF)
'
IF gw_adres%<&H3FFF
'
gwp_pointer%=cpageo%(SHR(program_counter%,14))
IF gwp_pointer%
'
program_counter%=CARD(ADD(program_counter%,2))
ADD gwp_pointer%,gw_adres%
RETURN ADD(BYTE{gwp_pointer%},SHL(BYTE{SUCC(gwp_pointer%)},8))
'
ENDIF
'
ENDIF
'
' Read at end of page/No RAM: can't use optimized routine;
'
word%=@get_byte_pc
RETURN ADD(word%,SHL(@get_byte_pc,8))
'
ENDFUNC
> FUNCTION get_word(adres%)               ! Get WORD from memory
$F%
'
gw_dummy%=AND(adres%,&H3FFF)
'
IF AND(AND(not_patched!(adres%),not_patched!(SUCC(adres%))),gw_dummy%<&H3FFF)
'
gw_pointer%=cpageo%(SHR(adres%,14))
IF gw_pointer%
'
ADD gw_pointer%,gw_dummy%
RETURN ADD(BYTE{gw_pointer%},SHL(BYTE{SUCC(gw_pointer%)},8))
'
ENDIF
'
ENDIF
'
' Read at end of page/no RAM: can't use optimized routine:
'
RETURN ADD(@get_byte(adres%),SHL(@get_byte(CARD(SUCC(adres%))),8))
'
ENDFUNC
> FUNCTION get_word_sp                    ! Get WORD from stack, SP++
$F%
'
gw_adres%=AND(stack_pointer%,&H3FFF)
'
IF gw_adres%<&H3FFF
'
gwp_pointer%=cpageo%(SHR(stack_pointer%,14))
IF gwp_pointer%
'
stack_pointer%=CARD(ADD(stack_pointer%,2))
ADD gwp_pointer%,gw_adres%
RETURN ADD(BYTE{gwp_pointer%},SHL(BYTE{SUCC(gwp_pointer%)},8))
'
ENDIF
'
ENDIF
'
word%=ADD(@get_byte(stack_pointer%),SHL(@get_byte(CARD(SUCC(stack_pointer%))),8))
stack_pointer%=CARD(ADD(stack_pointer%,2))
RETURN word%
'
ENDFUNC
> PROCEDURE put_word(adres%,word%)        ! Put WORD in memory
'
pw_dummy%=AND(adres%,&H3FFF)
pw_page&=SHR(adres%,14)
'
IF AND(AND(AND(pw_dummy%<&H3FFF,not_patched!(adres%)),not_patched!(SUCC(adres%))),ram!(pw_page&))
'
pw_pointer%=ADD(cpageo%(pw_page&),pw_dummy%)
BYTE{pw_pointer%}=BYTE(word%)
BYTE{SUCC(pw_pointer%)}=SHR(word%,8)
'
ELSE
'
@put_byte(adres%,BYTE(word%))
@put_byte(CARD(SUCC(adres%)),SHR(word%,8))
'
ENDIF
'
RETURN
> PROCEDURE put_word_sp(word%)            ! Put WORD on stack, --SP
'
stack_pointer%=CARD(SUB(stack_pointer%,2))
'
pw_dummy%=AND(stack_pointer%,&H3FFF)
'
IF pw_dummy%<&H3FFF
'
pw_page&=SHR(stack_pointer%,14)
IF ram!(pw_page&)
pw_pointer%=ADD(cpageo%(pw_page&),pw_dummy%)
BYTE{pw_pointer%}=BYTE(word%)
BYTE{SUCC(pw_pointer%)}=SHR(word%,8)
ELSE
@put_word(stack_pointer%,word%)
ENDIF
'
ELSE
'
@put_word(stack_pointer%,word%)
'
ENDIF
'
RETURN
'
' ***** Sub-Codes *****
'
$P<
> PROCEDURE subc_0xcb.rlc                     ! SubCommand: 0xCB -> RLC
'
$S& S>
SELECT sub_command&
CASE &H0                              ! RLC B
'
@rlc(reg_b&)
'
CASE &H1                              ! RLC C
'
@rlc(reg_c&)
'
CASE &H2                              ! RLC D
'
@rlc(reg_d&)
'
CASE &H3                              ! RLC E
'
@rlc(reg_e&)
'
CASE &H4                              ! RLC H
'
@rlc(reg_h&)
'
CASE &H5                              ! RLC L
'
@rlc(reg_l&)
'
CASE &H6                              ! RLC (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@rlc(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H7                              ! RLC A
'
@rlc(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.rrc                     ! SubCommand: 0xCB -> RRC
'
$S& S>
SELECT sub_command&
CASE &H8                              ! RRC B
'
@rrc(reg_b&)
'
CASE &H9                              ! RRC C
'
@rrc(reg_c&)
'
CASE &HA                              ! RRC D
'
@rrc(reg_d&)
'
CASE &HB                              ! RRC E
'
@rrc(reg_e&)
'
CASE &HC                              ! RRC H
'
@rrc(reg_h&)
'
CASE &HD                              ! RRC L
'
@rrc(reg_l&)
'
CASE &HE                              ! RRC (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@rrc(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &HF                              ! RRC A
'
@rrc(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.rl                      ! SubCommand: 0xCB -> RL
'
$S& S>
SELECT sub_command&
CASE &H10                             ! RL B
'
@rl(reg_b&)
'
CASE &H11                             ! RL C
'
@rl(reg_c&)
'
CASE &H12                             ! RL D
'
@rl(reg_d&)
'
CASE &H13                             ! RL E
'
@rl(reg_e&)
'
CASE &H14                             ! RL H
'
@rl(reg_h&)
'
CASE &H15                             ! RL L
'
@rl(reg_l&)
'
CASE &H16                             ! RL (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@rl(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H17                             ! RL A
'
@rl(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.rr                      ! SubCommand: 0xCB -> RR
'
$S& S>
SELECT sub_command&
CASE &H18                             ! RR B
'
@rr(reg_b&)
'
CASE &H19                             ! RR C
'
@rr(reg_c&)
'
CASE &H1A                             ! RR D
'
@rr(reg_d&)
'
CASE &H1B                             ! RR E
'
@rr(reg_e&)
'
CASE &H1C                             ! RR H
'
@rr(reg_h&)
'
CASE &H1D                             ! RR L
'
@rr(reg_l&)
'
CASE &H1E                             ! RR (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@rr(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H1F                             ! RR A
'
@rr(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.sla                     ! SubCommand: 0xCB -> SLA
'
$S& S>
SELECT sub_command&
CASE &H20                             ! SLA B
'
@sla(reg_b&)
'
CASE &H21                             ! SLA C
'
@sla(reg_c&)
'
CASE &H22                             ! SLA D
'
@sla(reg_d&)
'
CASE &H23                             ! SLA E
'
@sla(reg_e&)
'
CASE &H24                             ! SLA H
'
@sla(reg_h&)
'
CASE &H25                             ! SLA L
'
@sla(reg_l&)
'
CASE &H26                             ! SLA (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@sla(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H27                             ! SLA A
'
@sla(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.sra                     ! SubCommand: 0xCB -> SRA
'
$S& S>
SELECT sub_command&
CASE &H28                             ! SRA B
'
@sra(reg_b&)
'
CASE &H29                             ! SRA C
'
@sra(reg_c&)
'
CASE &H2A                             ! SRA D
'
@sra(reg_d&)
'
CASE &H2B                             ! SRA E
'
@sra(reg_e&)
'
CASE &H2C                             ! SRA H
'
@sra(reg_h&)
'
CASE &H2D                             ! SRA L
'
@sra(reg_l&)
'
CASE &H2E                             ! SRA (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@sra(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H2F                             ! SRA A
'
@sra(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE subc_0xcb.sll                     ! SubCommand: 0xCB -> SLL **
'
IF unofficial_z80_commands!
'
$S& S>
SELECT sub_command&
CASE &H30                             ! SLL B
'
@sll(reg_b&)
'
CASE &H31                             ! SLL C
'
@sll(reg_c&)
'
CASE &H32                             ! SLL D
'
@sll(reg_d&)
'
CASE &H33                             ! SLL E
'
@sll(reg_e&)
'
CASE &H34                             ! SLL H
'
@sll(reg_h&)
'
CASE &H35                             ! SLL L
'
@sll(reg_l&)
'
CASE &H36                             ! SLL (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@sll(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H37                             ! SLL A
'
@sll(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
ELSE
'
@unknown_instruction(&HCB,sub_command&,-1)
'
ENDIF
'
RETURN
> PROCEDURE subc_0xcb.srl                     ! SubCommand: 0xCB -> SRL
'
$S& S>
SELECT sub_command&
CASE &H38                             ! SRL B
'
@srl(reg_b&)
'
CASE &H39                             ! SRL C
'
@srl(reg_c&)
'
CASE &H3A                             ! SRL D
'
@srl(reg_d&)
'
CASE &H3B                             ! SRL E
'
@srl(reg_e&)
'
CASE &H3C                             ! SRL H
'
@srl(reg_h&)
'
CASE &H3D                             ! SRL L
'
@srl(reg_l&)
'
CASE &H3E                             ! SRL (HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
dummy&=@get_byte(dummy%)
@srl(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,7
'
CASE &H3F                             ! SRL A
'
@srl(reg_a&)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
' 0xED-subgroep:
> PROCEDURE sn ! <None>
'
@unknown_instruction(&HED,sub_command&,-1)
'
RETURN
> PROCEDURE s_0100 !          0x40 ... 0x4f
'
$S& S>
SELECT sub_command&
CASE &H40                             ! IN B,(C)           !   ???
'
reg_b&=@inp(reg_c&)
'
flag_zero!=reg_b&=0
flag_par.ov!=parity|(reg_b&)
flag_sign!=reg_b&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H41                             ! OUT (C),B
'
@out(reg_c&,reg_b&)
'
ADD cycle_cnt%,12+1
'
CASE &H42                             ! SBC HL,BC
'
@sbc_16b(reg_b&,reg_c&)
'
CASE &H43                             ! LD (nnnn),BC
'
@put_word(@get_word_pc,ADD(SHL(reg_b&,8),reg_c&))
'
ADD cycle_cnt%,20+1
'
CASE &H44                             ! NEG --
'
flag_carry!=reg_a&=0
flag_par.ov!=reg_a&=&H80
'
dummy&=reg_a&
reg_a&=BYTE(-reg_a&)
'
flag_sign!=reg_a&>127
flag_zero!=reg_a&=0
flag_neg!=TRUE
flag_half.c!=AND(reg_a&,15)>AND(dummy&,15)
'
ADD cycle_cnt%,8+1
'
CASE &H45                             ! RETN
'
program_counter%=@get_word_sp
interrupts!=old_interrupts!
'
ADD cycle_cnt%,14+1
'
CASE &H46                             ! IM 0
'
CLR interrupt_level&,interrupts!
'
ADD cycle_cnt%,8+1
'
CASE &H47                             ! LD I,A
'
reg_i&=reg_a&
'
ADD cycle_cnt%,9
'
CASE &H48                             ! IN C,(C)
'
reg_c&=@inp(reg_c&)
'
flag_zero!=reg_c&=0
flag_par.ov!=parity|(reg_c&)
flag_sign!=reg_c&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H49                             ! OUT (C),C
'
@out(reg_c&,reg_c&)
'
ADD cycle_cnt%,12+1
'
CASE &H4A                             ! ADC HL,BC
'
@adc_hl(reg_b&,reg_c&)
'
CASE &H4B                             ! LD BC,(nnnn)
'
dummy%=@get_word(@get_word_pc)
reg_b&=SHR(dummy%,8)
reg_c&=BYTE(dummy%)
'
ADD cycle_cnt%,20+1
'
CASE &H4D                             ! RETI
'
program_counter%=@get_word_sp
'
ADD cycle_cnt%,14+1
'
CASE &H4F                             ! LD R,A
'
reg_r&=reg_a&
'
ADD cycle_cnt%,9
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE s_0101 !          0x50 ... 0x5f
'
$S& S>
SELECT sub_command&
CASE &H50                             ! IN D,(C)
'
reg_d&=@inp(reg_c&)
'
flag_zero!=reg_d&=0
flag_par.ov!=parity|(reg_d&)
flag_sign!=reg_d&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H51                             ! OUT (C),D
'
@out(reg_c&,reg_d&)
'
ADD cycle_cnt%,12+1
'
CASE &H52                             ! SBC HL,DE
'
@sbc_16b(reg_d&,reg_e&)
'
CASE &H53                             ! LD (nnnn),DE
'
@put_word(@get_word_pc,ADD(SHL(reg_d&,8),reg_e&))
'
ADD cycle_cnt%,20+1
'
CASE &H56                             ! IM 1
'
interrupt_level&=1
'
ADD cycle_cnt%,8+1
'
CASE &H57                             ! LD A,I
'
reg_a&=reg_i&
'
flag_zero!=reg_a&=0
flag_par.ov!=interrupts!
flag_sign!=reg_a&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,9
'
CASE &H58                             ! IN E,(C)
'
reg_e&=@inp(reg_c&)
'
flag_zero!=reg_e&=0
flag_par.ov!=parity|(reg_e&)
flag_sign!=reg_e&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H59                             ! OUT (C),E
'
@out(reg_c&,reg_e&)
'
ADD cycle_cnt%,12+1
'
CASE &H5A                             ! ADC HL,DE
'
@adc_hl(reg_d&,reg_e&)
'
CASE &H5B                             ! LD DE,(nnnn)
'
dummy%=@get_word(@get_word_pc)
reg_d&=SHR(dummy%,8)
reg_e&=BYTE(dummy%)
'
ADD cycle_cnt%,20+1
'
CASE &H5E                             ! IM 2
'
interrupt_level&=2
'
ADD cycle_cnt%,8+1
'
CASE &H5F                             ! LD A,R
'
'    reg_a&=reg_r&
reg_a&=BYTE(cycle_cnt%)
'
flag_zero!=reg_a&=0
flag_par.ov!=interrupts!
flag_sign!=reg_a&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,9
'
CASE &H4C,&H54,&H5C,&H64,&H6C,&H74,&H7C
'
IF unofficial_z80_commands!
'
dummy&=reg_a&
CLR reg_a&
@sub(dummy&)
'
ELSE
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDIF
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE s_0110 !          0x60 ... 0x6f
'
$S& S>
SELECT sub_command&
CASE &H60                             ! IN H,(C)
'
reg_h&=@inp(reg_c&)
'
flag_zero!=reg_h&=0
flag_par.ov!=parity|(reg_h&)
flag_sign!=reg_h&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H61                             ! OUT (C),H
'
@out(reg_c&,reg_h&)
'
ADD cycle_cnt%,12+1
'
CASE &H62                             ! SBC HL,HL
'
@sbc_16b(reg_h&,reg_l&)
'
CASE &H67                             ! RRD
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
'
dummy&=reg_a&
dummy2&=@get_byte(dummy%)
'
reg_a&=AND(reg_a&,&X11110000)
ADD reg_a&,AND(dummy2&,&X1111)
@put_byte(dummy%,ADD(SHR(dummy2&,4),SHL|(dummy&,4)))
'
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,18
'
CASE &H68                             ! IN L,(C)
'
reg_l&=@inp(reg_c&)
'
flag_zero!=reg_l&=0
flag_par.ov!=parity|(reg_l&)
flag_sign!=reg_l&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H69                             ! OUT (C),L
'
@out(reg_c&,reg_l&)
'
ADD cycle_cnt%,12+1
'
CASE &H6A                             ! ADC HL,HL
'
@adc_hl(reg_h&,reg_l&)
'
CASE &H6F                             ! RLD
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
'
dummy&=reg_a&
dummy2&=@get_byte(dummy%)
'
reg_a&=AND(reg_a&,&X11110000)
ADD reg_a&,SHR(dummy2&,4)
@put_byte(dummy%,ADD(SHL|(dummy2&,4),AND(dummy&,&X1111)))
'
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,18
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE s_0111 !          0x70 ... 0x7f
'
$S& S>
SELECT sub_command&
CASE &H70                             ! IN (HL),(C)
'
dummy&=@inp(reg_c&)
'
flag_zero!=dummy&=0
flag_par.ov!=parity|(dummy&)
flag_sign!=dummy&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,15+1
'
CASE &H71                             ! OUT (C),(HL)   **
'
IF unofficial_z80_commands!
'
IF known_bugs!
@out(reg_c&,0)
ELSE
@out(reg_c&,@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
ENDIF
'
ELSE
'
@unknown_instruction(&HED,&H71,-1)
'
ENDIF
'
ADD cycle_cnt%,15+1
'
CASE &H72                             ! SBC HL,SP
'
@sbc_16b(SHR(stack_pointer%,8),BYTE(stack_pointer%))
'
CASE &H73                             ! LD (nnnn),SP
'
@put_word(@get_word_pc,stack_pointer%)
'
ADD cycle_cnt%,20+1
'
CASE &H78                             ! IN A,(C)
'
reg_a&=@inp(reg_c&)
'
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
CLR flag_neg!,flag_half.c!
'
ADD cycle_cnt%,12+1
'
CASE &H79                             ! OUT (C),A
'
@out(reg_c&,reg_a&)
'
ADD cycle_cnt%,12+1
'
CASE &H7A                             ! ADC HL,SP
'
@adc_hl(SHR(stack_pointer%,8),BYTE(stack_pointer%))
'
CASE &H7B                             ! LD SP,(nnnn)
'
stack_pointer%=@get_word(@get_word_pc)
'
ADD cycle_cnt%,20+1
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE s_1000 !          0x80 ... 0x8f
'
$S& S>
SELECT sub_command&
CASE &H8B                             ! OTDR
'
IF reg_b&=0
reg_b&=256
ENDIF
'
ADD cycle_cnt%,SUB(MUL(reg_b&,21),5)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
DO
'
@out(reg_c&,@get_byte(dummy%))            ! OUT (C),(HL)
DEC dummy%                                ! DEC HL
DEC reg_b&                                ! DEC B
'
LOOP WHILE reg_b&
@to_double_reg(dummy%,reg_h&,reg_l&)
'
flag_zero!=TRUE
flag_neg!=TRUE
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE s_1010 !          0xa0 ... 0xaf
'
$S& S>
SELECT sub_command&
CASE &HA0                             ! LDI
'
@put_byte(ADD(SHL(reg_d&,8),reg_e&),@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
@inc_double(reg_d&,reg_e&)                        ! (DE++) <- (HL++)
@inc_double(reg_h&,reg_l&)
@dec_double(reg_b&,reg_c&)                        ! BC--
'
CLR flag_half.c!,flag_neg!
flag_par.ov!=OR(reg_b&,reg_c&)
'
CASE &HA2                             ! INI
'
@put_byte(ADD(SHL(reg_h&,8),reg_l&),@inp(reg_c&)) ! IN (HL++),(C)
@inc_double(reg_h&,reg_l&)
reg_b&=BYTE(PRED(reg_b&))                         ! B--
'
flag_zero!=(reg_b&=0)
flag_neg!=TRUE
'
CASE &HA3                             ! OUTI
'
@out(reg_c&,@get_byte(ADD(SHL(reg_h&,8),reg_l&))) ! OUT (C),(HL++)
@inc_double(reg_h&,reg_l&)
reg_b&=BYTE(PRED(reg_b&))
'
flag_neg!=TRUE
flag_zero!=(reg_b&=0)
'
CASE &HA8                             ! LDD
'
@put_byte(ADD(SHL(reg_d&,8),reg_e&),@get_byte(ADD(SHL(reg_h&,8),reg_l&)))
@dec_double(reg_d&,reg_e&)                        ! (DE--) <- (HL--)
@dec_double(reg_h&,reg_l&)
@dec_double(reg_b&,reg_c&)                        ! BC--
'
CLR flag_half.c!,flag_neg!
flag_par.ov!=OR(reg_b&,reg_c&)
'
CASE &HAA                             ! IND
'
@put_byte(ADD(SHL(reg_h&,8),reg_l&),@inp(reg_c&)) ! IN (HL--),(C)
@dec_double(reg_h&,reg_l&)
reg_b&=BYTE(PRED(reg_b&))                         ! B--
'
flag_zero!=(reg_b&=0)
flag_neg!=TRUE
'
CASE &HAB                             ! OUTD
'
@out(reg_c&,@get_byte(ADD(SHL(reg_h&,8),reg_l&))) ! OUT (C),(HL--)
@dec_double(reg_h&,reg_l&)
reg_b&=BYTE(PRED(reg_b&))                         ! B--
'
flag_zero!=(reg_b&=0)
flag_neg!=TRUE
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,16+1
'
RETURN
> PROCEDURE s_1011 !          0xb0 ... 0xbf
'
$S& S>
SELECT sub_command&
CASE &HB0                             ! LDIR               [ Block Move ]
'
pointer1%=ADD(SHL(reg_h&,8),reg_l&)
pointer2%=ADD(SHL(reg_d&,8),reg_e&)
aant%=ADD(SHL(reg_b&,8),reg_c&)
'
IF aant%=0
aant%=65536
ENDIF
'
ADD cycle_cnt%,SUB(MUL(aant%,21+1),5)
'
IF AND(ABS(SUB(pointer1%,pointer2%))>aant%,fbmove!)    ! not overlapping
'
@fast_bmove(pointer1%,pointer2%,aant%)
'
ELSE
'
DO                                                ! Byte voor byte :-/
@put_byte(pointer2%,@get_byte(pointer1%))
pointer1%=CARD(SUCC(pointer1%))
pointer2%=CARD(SUCC(pointer2%))
DEC aant%
LOOP WHILE aant%
'
ENDIF
'
CLR reg_b&,reg_c&                           ! Update BC [0]
@to_double_reg(pointer1%,reg_d&,reg_e&)     ! Update DE
@to_double_reg(pointer2%,reg_h&,reg_l&)     ! Update HL
'
CLR flag_par.ov!,flag_neg!,flag_half.c!     ! Update Flags
'
CASE &HB1                             ! CPIR
'
aant%=ADD(SHL(reg_b&,8),reg_c&)
IF aant%=0
aant%=65536
ENDIF
pointer%=ADD(SHL(reg_h&,8),reg_l&)
'
ADD cycle_cnt%,SUB(MUL(aant%,21),5)         !????????????????????
'
CLR flag_zero!
dummy!=flag_carry!
'
DO UNTIL flag_zero!
'
@cp(@get_byte(pointer%))
DEC aant%
pointer%=CARD(SUCC(pointer%))
'
LOOP WHILE aant%
'
flag_par.ov!=aant%<>0
flag_neg!=TRUE
flag_carry!=dummy!
'
CASE &HB2                             ! INIR
'
IF reg_b&=0
reg_b&=256
ENDIF
'
ADD cycle_cnt%,SUB(MUL(reg_b&,21),5)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
DO
'
@put_byte(dummy%,@inp(reg_c&))            ! IN (HL++),(C)
INC dummy%
DEC reg_b&                                ! DEC B
'
LOOP WHILE reg_b&
@to_double_reg(dummy%,reg_h&,reg_l&)
'
flag_zero!=TRUE
flag_neg!=TRUE
'
CASE &HB3                             ! OTIR
'
IF reg_b&=0
reg_b&=256
ENDIF
'
ADD cycle_cnt%,SUB(MUL(reg_b&,21),5)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
DO
'
@out(reg_c&,@get_byte(dummy%))            ! OUT (C),(HL++)
INC dummy%
INC reg_b&                                ! INC B
'
LOOP WHILE reg_b&
@to_double_reg(dummy%,reg_h&,reg_l&)
'
flag_zero!=TRUE
flag_neg!=TRUE
'
CASE &HB8                             ! LDDR                [ Block Move ]
'
pointer1%=ADD(SHL(reg_d&,8),reg_e&)
pointer2%=ADD(SHL(reg_h&,8),reg_l&)
aant%=ADD(SHL(reg_b&,8),reg_c&)
'
IF aant%=0
aant%=65536
ENDIF
'
ADD cycle_cnt%,SUB(MUL(aant%,21),5)
'
DO
'
@put_byte(pointer1%,@get_byte(pointer2%))
'
pointer1%=CARD(PRED(pointer1%))
pointer2%=CARD(PRED(pointer2%))
DEC aant%
'
LOOP WHILE aant%
'
CLR reg_b&,reg_c&                           ! Update BC [0]
@to_double_reg(pointer1%,reg_d&,reg_e&)     ! Update DE
@to_double_reg(pointer2%,reg_h&,reg_l&)     ! Update HL
'
CLR flag_half.c!,flag_par.ov!,flag_neg!
'
CASE &HB9                             ! CPDR
'
aant%=ADD(SHL(reg_b&,8),reg_c&)
IF aant%=0
aant%=65536
ENDIF
pointer%=ADD(SHL(reg_h&,8),reg_l&)
'
ADD cycle_cnt%,SUB(MUL(aant%,21),5)         !????????????????????
'
CLR flag_zero!
dummy!=flag_carry!
'
DO UNTIL flag_zero!
'
@cp(@get_byte(pointer%))
DEC aant%
pointer%=CARD(PRED(pointer%))
'
LOOP WHILE aant%
'
flag_par.ov!=aant%!<>0
flag_neg!=TRUE
flag_carry!=dummy!
'
CASE &HBA                             ! INDR
'
IF reg_b&=0
reg_b&=256
ENDIF
'
ADD cycle_cnt%,SUB(MUL(reg_b&,21),5)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
DO
'
@put_byte(dummy%,@inp(reg_c&))                    ! IN (HL--),(C)
DEC dummy%
DEC reg_b&                                        ! DEC B
'
LOOP WHILE reg_b&
@to_double_reg(dummy%,reg_h&,reg_l&)
'
flag_zero!=TRUE
flag_neg!=TRUE
'
DEFAULT
'
@unknown_instruction(&HED,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
$P>
> PROCEDURE subc_0xdd.fd(VAR b16_reg%)        ! SubCommand: 0xDD/0xFD I[X|Y]-Stuff
'
sub_command&=@get_byte_pc
'
$S& S>
SELECT sub_command&
CASE &H9                          ! ADD I[X|Y],BC
'
@add_16b(reg_b&,reg_c&,b16_reg%)
'
ADD cycle_cnt%,15+1
'
CASE &H19                         ! ADD I[X|Y],DE
'
@add_16b(reg_d&,reg_e&,b16_reg%)
'
ADD cycle_cnt%,15+1
'
CASE &H21                         ! LD I[X|Y],nnnn
'
b16_reg%=@get_word_pc
'
ADD cycle_cnt%,14+1
'
CASE &H22                         ! LD (nnnn),I[X|Y]
'
@put_word(@get_word_pc,b16_reg%)
'
ADD cycle_cnt%,20+1
'
CASE &H23                         ! INC I[X|Y]
'
b16_reg%=CARD(SUCC(b16_reg%))
'
ADD cycle_cnt%,10+1
'
CASE &H29                         ! ADD I[X|Y],I[X|Y]
'
b16_reg%=CARD(SHL(b16_reg%,1))
'
ADD cycle_cnt%,15+1
'
CASE &H2A                         ! LD I[X|Y],(nnnn)
'
b16_reg%=@get_word(@get_word_pc)
'
ADD cycle_cnt%,20+1
'
CASE &H2B                         ! DEC I[X|Y]
'
b16_reg%=CARD(PRED(b16_reg%))
'
ADD cycle_cnt%,10+1
'
CASE &H34                         ! INC (I[X|Y]+d)
'
dummy%=CARD(ADD(b16_reg%,@get_byte_pc))
dummy&=@get_byte(dummy%)
@inc(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,23+1
'
CASE &H35                         ! DEC (I[X|Y]+d)
'
dummy%=CARD(ADD(b16_reg%,@get_byte_pc))
dummy&=@get_byte(dummy%)
@dec(dummy&)
@put_byte(dummy%,dummy&)
'
ADD cycle_cnt%,23+1
'
CASE &H36                         ! LD (I[X|Y]+d),n
'
dummy%=CARD(ADD(b16_reg%,@get_byte_pc))
@put_byte(dummy%,@get_byte_pc)
'
ADD cycle_cnt%,19+1
'
CASE &H39                         ! ADD I[X|Y],SP
'
b16_reg%=CARD(ADD(b16_reg%,stack_pointer%))
'
ADD cycle_cnt%,15+1
'
CASE &H46 TO &H77
'
dummy%=CARD(ADD(b16_reg%,@get_byte_pc))
'
SELECT sub_command&
CASE &H46                         ! LD B,(I[X|Y]+d)
'
reg_b&=@get_byte(dummy%)
'
CASE &H4E                         ! LD C,(I[X|Y]+d)
'
reg_c&=@get_byte(dummy%)
'
CASE &H56                         ! LD D,(I[X|Y]+d)
'
reg_d&=@get_byte(dummy%)
'
CASE &H5E                         ! LD E,(I[X|Y]+d)
'
reg_e&=@get_byte(dummy%)
'
CASE &H66                         ! LD H,(I[X|Y]+d)
'
reg_h&=@get_byte(dummy%)
'
CASE &H6E                         ! LD L,(I[X|Y]+d)
'
reg_l&=@get_byte(dummy%)
'
CASE &H70                         ! LD (I[X|Y]+d),B
'
@put_byte(dummy%,reg_b&)
'
CASE &H71                         ! LD (I[X|Y]+d),C
'
@put_byte(dummy%,reg_c&)
'
CASE &H72                         ! LD (I[X|Y]+d),D
'
@put_byte(dummy%,reg_d&)
'
CASE &H73                         ! LD (I[X|Y]+d),E
'
@put_byte(dummy%,reg_e&)
'
CASE &H74                         ! LD (I[X|Y]+d),H
'
@put_byte(dummy%,reg_h&)
'
CASE &H75                         ! LD (I[X|Y]+d),L
'
@put_byte(dummy%,reg_l&)
'
CASE &H77                         ! LD (I[X|Y]+d),A
'
@put_byte(dummy%,reg_a&)
'
DEFAULT
'
@unknown_instruction(command&,sub_command&,-1)
'
ENDSELECT
'
ADD cycle_cnt%,19+1
'
CASE &H78 TO &HCA
'
dummy&=@get_byte(CARD(ADD(b16_reg%,@get_byte_pc)))
'
SELECT sub_command&
CASE &H7E                         ! LD A,(I[X|Y]+d)
'
reg_a&=dummy&
'
CASE &H86                         ! ADD A,(I[X|Y]+d)
'
@add(dummy&)
'
CASE &H8E                         ! ADC A,(I[X|Y]+d)
'
@adc(dummy&)
'
CASE &H96                         ! SUB (I[X|Y]+d)
'
@sub(dummy&)
'
CASE &H9E                         ! SBC (I[X|Y]+d)
'
@sbc(dummy&)
'
CASE &HA6                         ! AND (I[X|Y]+d)
'
reg_a&=AND(reg_a&,dummy&)
'
CLR flag_carry!,flag_neg!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
flag_half.c!=TRUE
'
CASE &HAE                         ! XOR (I[X|Y]+d)
'
reg_a&=XOR(reg_a&,dummy&)
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
CASE &HB6                         ! OR (I[X|Y]+d)
'
reg_a&=OR(reg_a&,dummy&)
'
CLR flag_carry!,flag_neg!,flag_half.c!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
'
CASE &HBE                         ! CP (I[X|Y]+d)
'
@cp(dummy&)
'
DEFAULT
'
@unknown_instruction(command&,sub_command&,-1)
'
ENDSELECT
'
ADD cycle_cnt%,19+1
'
CASE &HCB                         ! ---> Sub Sub Command <---
'
@ssubc_dd.fd_0xcb(b16_reg%)
'
CASE &HE1                         ! POP I[X|Y]
'
b16_reg%=@get_word_sp
'
ADD cycle_cnt%,14+1
'
CASE &HE3                         ! EX (SP),I[X|Y]
'
dummy%=@get_word(stack_pointer%)
@put_word(stack_pointer%,b16_reg%)
b16_reg%=dummy%
'
ADD cycle_cnt%,23+1
'
CASE &HE5                         ! PUSH I[X|Y]
'
@put_word_sp(b16_reg%)
'
ADD cycle_cnt%,15+1
'
CASE &HE9                         ! JP (I[X|Y])
'
program_counter%=b16_reg%                            !@get_word(b16_reg%)
'
ADD cycle_cnt%,8+1
'
CASE &HF9                         ! LD SP,I[X|Y]
'
stack_pointer%=b16_reg%
'
ADD cycle_cnt%,10+1
'
DEFAULT
'
IF unofficial_z80_commands!
'
@unofficial_0xdd.fd(b16_reg%)
'
ELSE
'
@unknown_instruction(command&,sub_command&,-1)
'
ENDIF
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ssubc_dd.fd_0xcb(b16_reg%)        ! SubSubCommand: [D|F]D0xCB I[X|Y]
'
dummy%=CARD(ADD(b16_reg%,@get_byte_pc))
dummy&=@get_byte(dummy%)
ssub_command&=@get_byte_pc
'
$s& s>
SELECT ssub_command&
CASE &H46,&H4E,&H56,&H5E,&H66,&H6E,&H76,&H7E
'
CLR flag_neg!
flag_half.c!=TRUE
'
flag_zero!=NOT BTST(dummy&,AND(SHR(dummy&,3),&X111))
'
ADD cycle_cnt%,20+1
'
CASE &H86,&H8E,&H96,&H9E,&HA6,&HAE,&HB6,&HBE
'
@put_byte(dummy%,BCLR(dummy&,AND(SHR(dummy&,3),&X111)))
'
ADD cycle_cnt%,23+1
'
CASE &HC6,&HCE,&HD6,&HDE,&HE6,&HEE,&HF6,&HFE
'
@put_byte(dummy%,BSET(dummy&,AND(SHR(dummy&,3),&X111)))
'
ADD cycle_cnt%,23+1
'
DEFAULT
'
ADD cycle_cnt%,23+1
'
$S& S>
SELECT ssub_command&
CASE &H6                              ! RLC (I[X|Y]+d)
'
@rlc(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &HE                              ! RRC (I[X|Y]+d)
'
@rrc(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &H16                             ! RL (I[X|Y]+d)
'
@rl(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &H1E                             ! RR (I[X|Y]+d)
'
@rr(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &H26                             ! SLA (I[X|Y]+d)
'
@sla(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &H2E                             ! SRA (I[X|Y]+d)
'
@sra(dummy&)
@put_byte(dummy%,dummy&)
'
CASE &H3E                             ! SRL (I[X|Y]+d)
'
@srl(dummy&)
@put_byte(dummy%,dummy&)
'
DEFAULT                             ! Unknown Instruction
'
@unknown_instruction(command&,&HCB,ssub_command&)
'
ENDSELECT
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE unofficial_0xdd.fd(VAR b16_reg%)  ! Unofficial SubCommands: 0xDD/0xFD
'
ADD cycle_cnt%,4+1
'
$S& S>
SELECT sub_command&
CASE &H24                     ! INC I[X|Y]h
'
dummy&=SHR(b16_reg%,8)
@inc(dummy&)
b16_reg%=ADD(BYTE(b16_reg%),SHL(dummy&,8))
'
CASE &H26                     ! LD I[X|Y]h,n
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(@get_byte_pc,8))
'
ADD cycle_cnt%,3
'
CASE &H2C                     ! INC I[X|Y]l
'
dummy&=BYTE(b16_reg%)
@inc(dummy&)
b16_reg%=ADD(AND(b16_reg%,&HFF00),dummy&)
'
CASE &H2E                     ! LD I[X|Y]l,n
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),@get_byte_pc)
'
ADD cycle_cnt%,3
'
CASE &H44                     ! LD B,I[X|Y]h
'
reg_b&=SHR(b16_reg%,8)
'
CASE &H45                     ! LD B,I[X|Y]l
'
reg_b&=BYTE(b16_reg%)
'
CASE &H4C                     ! LD C,I[X|Y]h
'
reg_c&=SHR(b16_reg%,8)
'
CASE &H4D                     ! LD C,I[X|Y]l
'
reg_c&=BYTE(b16_reg%)
'
CASE &H54                     ! LD D,I[X|Y]h
'
reg_d&=SHR(b16_reg%,8)
'
CASE &H55                     ! LD D,I[X|Y]l
'
reg_d&=BYTE(b16_reg%)
'
CASE &H5C                     ! LD E,I[X|Y]h
'
reg_e&=SHR(b16_reg%,8)
'
CASE &H5D                     ! LD E,I[X|Y]l
'
reg_c&=BYTE(b16_reg%)
'
CASE &H60                     ! LD I[X|Y]h,B
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(reg_b&,8))
'
CASE &H61                     ! LD I[X|Y]h,C
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(reg_c&,8))
'
CASE &H62                     ! LD I[X|Y]h,D
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(reg_d&,8))
'
CASE &H63                     ! LD I[X|Y]h,E
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(reg_e&,8))
'
CASE &H64                     ! LD I[X|Y]h,I[X|Y]h
'
' Do nothing...
'
CASE &H65                     ! LD I[X|Y]h,I[X|Y]l
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(BYTE(b16_reg%),8))
'
CASE &H67                     ! LD I[X|Y]h,a
'
b16_reg%=ADD(BYTE(b16_reg%),SHL(reg_a&,8))
'
CASE &H68                     ! LD I[X|Y]l,B
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),reg_b&)
'
CASE &H69                     ! LD I[X|Y]l,C
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),reg_c&)
'
CASE &H6A                     ! LD I[X|Y]l,D
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),reg_d&)
'
CASE &H6B                     ! LD I[X|Y]l,E
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),reg_e&)
'
CASE &H6C                     ! LD I[X|Y]l,I[X|Y]h
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),SHR(b16_reg%,8))
'
CASE &H6D                     ! LD I[X|Y]l,I[X|Y]l
'
' Do nothing...
'
CASE &H6F                     ! LD I[X|Y]l,a
'
b16_reg%=ADD(AND(b16_reg%,&HFF00),reg_a&)
'
CASE &H7C                     ! LD A,I[X|Y]h
'
reg_a&=SHR(b16_reg%,8)
'
ADD cycle_cnt%,4+1
'
CASE &H7D                     ! LD A,I[X|Y]l
'
reg_a&=BYTE(b16_reg%)
'
ADD cycle_cnt%,4+1
'
CASE &H84                     ! ADD A,I[X|Y]h
'
@add(SHR(b16_reg%,8))
'
CASE &H85                     ! ADD A,I[X|Y]l
'
@add(BYTE(b16_reg%))
'
CASE &H8C                     ! ADC A,I[X|Y]h
'
@adc(SHR(b16_reg%,8))
'
CASE &H8D                     ! ADC A,I[X|Y]l
'
@adc(BYTE(b16_reg%))
'
CASE &H94                     ! SUB I[X|Y]h
'
@sub(SHR(b16_reg%,8))
'
CASE &H95                     ! SUB I[X|Y]l
'
@sub(BYTE(b16_reg%))
'
CASE &H9C                     ! SBC I[X|Y]h
'
@sbc(SHR(b16_reg%,8))
'
CASE &H9D                     ! SBC I[X|Y]l
'
@sbc(BYTE(b16_reg%))
'
CASE &HA4,&HA5,&HAC,&HAD,&HB4,&HB5
'
SELECT sub_command&
CASE &HA4                     ! AND I[X|Y]h
'
reg_a&=AND(reg_a&,SHR(b16_reg%,8))
'
CASE &HA5                     ! AND I[X|Y]l
'
reg_a&=AND(reg_a&,BYTE(b16_reg%))
'
CASE &HAC                     ! XOR I[X|Y]h
'
reg_a&=XOR(reg_a&,SHR(b16_reg%,8))
'
CASE &HAD                     ! XOR I[X|Y]l
'
reg_a&=XOR(reg_a&,BYTE(b16_reg%))
'
CASE &HB4                     ! OR I[X|Y]h
'
reg_a&=OR(reg_a&,SHR(b16_reg%,8))
'
CASE &HB5                     ! OR I[X|Y]l
'
reg_a&=OR(reg_a&,BYTE(b16_reg%))
'
ENDSELECT
'
CLR flag_carry!,flag_neg!
flag_zero!=reg_a&=0
flag_par.ov!=parity|(reg_a&)
flag_sign!=reg_a&>127
flag_half.c!=TRUE
'
CASE &HBC                     ! CP I[X|Y]h
'
@cp(SHR(b16_reg%,8))
'
CASE &HBD                     ! CP I[X|Y]l
'
@cp(BYTE(b16_reg%))
'
DEFAULT
'
@unknown_instruction(command&,sub_command&,-1)
'
ENDSELECT
$S% S>
'
RETURN
'
> PROCEDURE unknown_instruction(c1&,c2&,c3&)! Unknown Command
'
error_exit&=err_unknown_z80_instruction&
'
@emulator_status
'
PRINT AT(42,max_row&);"pUnknown Instruction: ";HEX$(command&,2);
'
IF c3&>-1
'
PRINT " ";HEX$(sub_command&,2)+" "+HEX$(ssub_command&,2);
'
ELSE IF c2&>-1
'
PRINT " ";HEX$(sub_command&,2);
'
ENDIF
'
PRINT "q";
'
RETURN
'
' *** Support Routines for emulation ***
'
> FUNCTION reg_f                          ! Get Reg_F&
$F%
'
reg_f&=AND(flag_sign!,128)
ADD reg_f&,AND(flag_zero!,64)
ADD reg_f&,AND(flag_half.c!,16)
ADD reg_f&,AND(flag_par.ov!,4)
ADD reg_f&,AND(flag_neg!,2)
'
RETURN ADD(reg_f&,ABS(flag_carry!))
'
ENDFUNC
> PROCEDURE reg_f(dummy&)                 ! Set Reg_F&
'
flag_sign!=dummy&>127
flag_zero!=AND(dummy&,64)
flag_half.c!=AND(dummy&,16)
flag_par.ov!=AND(dummy&,4)
flag_neg!=AND(dummy&,2)
flag_carry!=AND(dummy&,1)
'
RETURN
> PROCEDURE rst(adres%)                   ! RST $xx
'
IF not_patched!(adres%)
'
old_interrupts!=interrupts!
CLR interrupts!
@put_word_sp(program_counter%)
program_counter%=adres%
'
ELSE IF NOT @check_jump_patches(adres%)
'
old_interrupts!=interrupts!
CLR interrupts!
@put_word_sp(program_counter%)
program_counter%=adres%
'
ENDIF
'
ADD cycle_cnt%,11+1
'
RETURN
> PROCEDURE cp(reg&)                      ! CP r/n
'
dummy&=SUB(reg_a&,reg&)
IF dummy&<0
'
flag_par.ov!=(dummy&<-128)  ! was: =>
flag_sign!=NOT flag_par.ov!
flag_carry!=TRUE
CLR flag_zero!              ! Kan nooit 0 worden bij <0
'
ELSE
'
CLR flag_carry!,flag_par.ov!
flag_zero!=dummy&=0
flag_sign!=dummy&>127
'
ENDIF
'
flag_neg!=TRUE
flag_half.c!=AND(reg_a&,15)<AND(reg&,15)
'
RETURN
> PROCEDURE jr(voorwaarde!)               ! Jump Relative
'
IF voorwaarde!
'
program_counter%=CARD(ADD(program_counter%,jr&(@get_byte(program_counter%))))
'
ADD cycle_cnt%,12+1
'
ELSE
'
INC program_counter%
'
ADD cycle_cnt%,7+1
'
ENDIF
'
RETURN
> PROCEDURE jp(voorwaarde!)               ! JUMP
'
IF voorwaarde!
'
program_counter%=@get_word(program_counter%)
'
ELSE
'
ADD program_counter%,2
'
ENDIF
'
ADD cycle_cnt%,10+1
'
RETURN
> PROCEDURE call(voorwaarde!)             ! CALL
'
IF voorwaarde!
'
dummy%=@get_word_pc
'
IF not_patched!(dummy%)
'
@put_word_sp(program_counter%)
program_counter%=dummy%
'
ELSE IF NOT @check_jump_patches(dummy%)
'
@put_word_sp(program_counter%)
program_counter%=dummy%
'
ENDIF
'
ADD cycle_cnt%,17+1
'
ELSE
'
ADD program_counter%,2
'
ADD cycle_cnt%,10+1
'
ENDIF
'
RETURN
> PROCEDURE ret(voorwaarde!)              ! RET
'
IF voorwaarde!
'
program_counter%=@get_word_sp
'
ADD cycle_cnt%,11+1
'
ELSE
'
ADD cycle_cnt%,5+1
'
ENDIF
'
RETURN
> PROCEDURE inc(VAR reg&)                 ! ++x
'
CLR flag_neg!
flag_zero!=inc!(0,reg&)
flag_sign!=inc!(1,reg&)
flag_half.c!=inc!(2,lus&)
flag_par.ov!=inc!(3,lus&)
'
reg&=BYTE(SUCC(reg&))
'
RETURN
> PROCEDURE dec(VAR reg&)                 ! --x
'
IF reg&
'
DEC reg&
flag_par.ov!=reg&=127
flag_sign!=reg&>127
flag_half.c!=AND(reg&,15)=15        ! van 0 naar 15 gesprongen
flag_zero!=reg&=0
'
ELSE
'
reg&=255
flag_par.ov!=TRUE
flag_sign!=TRUE
flag_half.c!=TRUE
CLR flag_zero!
'
ENDIF
flag_neg!=TRUE
'
RETURN
> PROCEDURE add(reg&)                     ! ADD A,r
'
dummy&=reg_a&
ADD reg_a&,reg&
IF reg_a&>255
'
flag_par.ov!=reg_a&>383             ! was: <384
flag_sign!=flag_par.ov!             ! (reg_a-=256)>127
SUB reg_a&,256
flag_carry!=TRUE
'
ELSE
'
flag_sign!=reg_a&>127
CLR flag_carry!
flag_par.ov!=AND(flag_sign!,dummy&<128)
'
ENDIF
'
flag_zero!=reg_a&=0
'
CLR flag_neg!
flag_half.c!=AND(reg_a&,15)<AND(dummy&,15)
'
RETURN
> PROCEDURE adc(reg&)                     ! ADC A,r
'
dummy&=reg_a&
SUB reg_a&,flag_carry!
ADD reg_a&,reg&
IF reg_a&>255
'
flag_par.ov!=reg_a&>383             ! was: <384
flag_sign!=flag_par.ov!             ! (reg_a-=256)>127
SUB reg_a&,256
flag_carry!=TRUE
'
ELSE
'
flag_sign!=reg_a&>127
CLR flag_carry!
flag_par.ov!=AND(flag_sign!,dummy&<128)
'
ENDIF
'
flag_zero!=reg_a&=0
'
CLR flag_neg!
flag_half.c!=AND(reg_a&,15)<AND(dummy&,15)
'
RETURN
> PROCEDURE dec_double(VAR reg_1&,reg_2&) ! DEC BC/DE/HL
'
IF reg_2&
'
DEC reg_2&
'
ELSE
'
reg_2&=255
reg_1&=BYTE(PRED(reg_1&))
'
ENDIF
'
RETURN
> PROCEDURE inc_double(VAR reg_1&,reg_2&) ! INC BC/DE/HL
'
IF reg_2&<>255
'
INC reg_2&
'
ELSE
'
CLR reg_2&
reg_1&=BYTE(SUCC(reg_1&))
'
ENDIF
'
RETURN
> PROCEDURE add_hl(reg_1&,reg_2&)         ! ADD HL,rr
'
CLR flag_neg!,flag_carry!
'
ADD reg_l&,reg_2&
IF reg_l&>255
SUB reg_l&,256
INC reg_1&
ENDIF
'
dummy&=reg_h&
ADD reg_h&,reg_1&
IF reg_h&>255
SUB reg_h&,256
flag_carry!=TRUE
ENDIF
'
flag_half.c!=AND(reg_h&,15)<AND(dummy&,15)
'
RETURN
> PROCEDURE add_16b(reg_1&,reg_2&,VAR b16_reg%)! ADD I[X|Y],rr
'
CLR flag_carry!,flag_neg!
'
dummy%=b16_reg%
dummy2%=ADD(SHL(reg_1&,8),reg_2&)
'
ADD b16_reg%,dummy2%
'
IF b16_reg%>&HFFFF
SUB b16_reg%,&H10000
flag_carry!=TRUE
ENDIF
'
flag_half.c!=AND(dummy%,2047)>AND(b16_reg%,2047)
'
RETURN
> PROCEDURE adc_hl(reg_1&,reg_2&)         ! ADC HL,rr
'
ADD reg_l&,reg_2&             ! ADD L,rL
SUB reg_l&,flag_carry!
IF reg_l&>255
SUB reg_l&,256
INC reg_1&
ENDIF
'
dummy&=reg_h&
ADD reg_h&,reg_1&             ! ADD H,rH
IF reg_h&>255
'
flag_par.ov!=reg_h&>383
flag_sign!=flag_par.ov!
SUB reg_h&,256
flag_carry!=TRUE
'
ELSE
'
flag_sign!=reg_h&>127
CLR flag_carry!
flag_par.ov!=AND(flag_sign!,dummy&<128)
'
ENDIF
'
flag_zero!=reg_h&=0
'
CLR flag_neg!
flag_half.c!=AND(reg_h&,15)<AND(dummy&,15)
'
ADD cycle_cnt%,15+1
'
RETURN
> PROCEDURE sub(reg&)                     ! SUB a...l
'
dummy&=reg_a&
SUB reg_a&,reg&
IF reg_a&<0
'
flag_par.ov!=(reg_a&<-128)         ! was: =>-128
flag_sign!=NOT flag_par.ov!
ADD reg_a&,256
flag_carry!=TRUE
CLR flag_zero!              ! Kan nooit 0 worden bij <0
'
ELSE
'
CLR flag_carry!
flag_sign!=reg_a&>127
flag_par.ov!=AND(NOT flag_sign!,dummy&>127) ! was: and(flag_sign!,dummy&<128)
flag_zero!=reg_a&=0
'
ENDIF
'
flag_half.c!=AND(dummy&,15)<AND(reg_a&,15)
flag_neg!=TRUE
'
RETURN
> PROCEDURE sbc(reg&)                     ! SBC a...l
'
dummy&=reg_a&
ADD reg_a&,flag_carry!
SUB reg_a&,reg&
IF reg_a&<0
'
flag_par.ov!=(reg_a&<-128)          ! was: =>-128
flag_sign!=NOT flag_par.ov!
ADD reg_a&,256
flag_carry!=TRUE
'
ELSE
'
CLR flag_carry!
flag_sign!=reg_a&>127
flag_par.ov!=AND(NOT flag_sign!,dummy&>127) ! was: and(flag_sign!,dummy&<128)
'
ENDIF
'
flag_zero!=reg_a&=0   ! want 255+carry=1 =256, 0-256=-256 + 256 =0!!!!!
'
flag_neg!=TRUE
flag_half.c!=AND(reg_a&,15)>AND(dummy&,15)
'
RETURN
> PROCEDURE sbc_16b(reg_1&,reg_2&)        ! SBC HL,BC/DE/HL/SP
'
SUB reg_l&,reg_2&                    ! Low Byte aftrekken
ADD reg_l&,flag_carry!
'
IF reg_l&<0                   ! Resultaat < 0?
ADD reg_l&,256              ! +256
INC reg_1&                  ! en HighByteSub++
ENDIF
'
SUB reg_h&,reg_1&             ! High Byte aftrekken
'
dummy&=reg_h&
IF reg_h&<0                   ! Resultaat < 0?
'
ADD reg_h&,256              ! +256
flag_carry!=TRUE            ! underflow markeren
flag_par.ov!=(reg_a&<-128)                          ! was: =>-128
flag_sign!=reg_h&>127
'
ELSE
'
CLR flag_carry!
flag_sign!=reg_h&>127
flag_par.ov!=AND(NOT flag_sign!,dummy&>127) ! was: and(flag_sign!,dummy&<128)
'
ENDIF
'
flag_zero!=reg_h&=0 ! AND(...,reg_l&=0) ??????????????????????????????????
'
flag_half.c!=AND(dummy&,15)<AND(reg_h&,15)
flag_neg!=TRUE
'
ADD cycle_cnt%,15+1
'
RETURN
> PROCEDURE sla(VAR reg&)                 ! SLA a/b/c/d/e/h/l
'
flag_carry!=reg&>127               ! Bit 7 -> Carry
reg&=SHL|(reg&,1)          ! << 1
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE sll(VAR reg&)                 ! SLL a/b/c/d/e/h/l **
'
flag_carry!=reg&>127
reg&=SUCC(SHL|(reg&,1))
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE sra(VAR reg&)                 ! SRA a/b/c/d/e/h/l
'
flag_carry!=AND(reg&,1)           ! (Re-)Set CARRY == bit 0
reg&=ADD(SHR(reg&,1),AND(reg&,128))
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE srl(VAR reg&)                 ! SLR a/b/c/d/e/h/l
'
flag_carry!=AND(reg&,1)           ! Bit 0 -> Carry
reg&=SHR(reg&,1)                  ! >> 1
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE rl(VAR reg&)                  ! RL a/b/c/d/e/h/l
'
dummy!=reg&>127
reg&=ADD(SHL|(reg&,1),ABS(flag_carry!))
flag_carry!=dummy!
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE rlc(VAR reg&)                 ! RLC a/b/c/d/e/h/l
'
reg&=ROL|(reg&,1)
flag_carry!=AND(reg&,1)
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE rr(VAR reg&)                  ! RR a/b/c/d/e/h/l
'
dummy!=flag_carry!
flag_carry!=AND(reg&,1)
reg&=ADD(SHR(reg&,1),AND(dummy!,128))
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE rrc(VAR reg&)                 ! RRC a/b/c/d/e/h/l
'
flag_carry!=AND(reg&,1)
reg&=ROR|(reg&,1)
'
flag_zero!=reg&=0
flag_par.ov!=parity|(reg&)
flag_sign!=reg&>127
CLR flag_neg!,flag_half.c!
'
RETURN
> PROCEDURE to_double_reg(word%,VAR reg_1&,reg_2&)! B+C/D+E/H+L -> BC/DE/HL
'
reg_1&=SHR(word%,8)
reg_2&=BYTE(word%)
'
RETURN
$P<
> PROCEDURE set_bits                      ! SET x,y
'
SUB sub_command&,&HC0
'
$S& S>
SELECT AND(sub_command&,7)
CASE &H0                             ! SET x,B
'
reg_b&=OR(reg_b&,or|(sub_command&))
'
CASE &H1                             ! SET x,C
'
reg_c&=OR(reg_c&,or|(sub_command&))
'
CASE &H2                             ! SET x,D
'
reg_d&=OR(reg_d&,or|(sub_command&))
'
CASE &H3                             ! SET x,E
'
reg_e&=OR(reg_e&,or|(sub_command&))
'
CASE &H4                             ! SET x,H
'
reg_h&=OR(reg_h&,or|(sub_command&))
'
CASE &H5                             ! SET x,L
'
reg_l&=OR(reg_l&,or|(sub_command&))
'
CASE &H6                             ! SET x,(HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
@put_byte(dummy%,OR(@get_byte(dummy%),or|(sub_command&)))
'
ADD cycle_cnt%,7
'
CASE &H7                             ! SET x,A
'
reg_a&=OR(reg_a&,or|(sub_command&))
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE res_bits                      ! RES x,y
'
SUB sub_command&,&H80
'
$S& S>
SELECT AND(sub_command&,7)
CASE &H0                             ! RES x,B
'
reg_b&=AND(reg_b&,and|(sub_command&))
'
CASE &H1                             ! RES x,C
'
reg_c&=AND(reg_c&,and|(sub_command&))
'
CASE &H2                             ! RES x,D
'
reg_d&=AND(reg_d&,and|(sub_command&))
'
CASE &H3                             ! RES x,E
'
reg_e&=AND(reg_e&,and|(sub_command&))
'
CASE &H4                             ! RES x,H
'
reg_h&=AND(reg_h&,and|(sub_command&))
'
CASE &H5                             ! RES x,L
'
reg_l&=AND(reg_l&,and|(sub_command&))
'
CASE &H6                             ! RES x,(HL)
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
@put_byte(dummy%,AND(@get_byte(dummy%),and|(sub_command&)))
'
ADD cycle_cnt%,7
'
CASE &H7                             ! RES x,A
'
reg_a&=AND(reg_a&,and|(sub_command&))
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
'
RETURN
> PROCEDURE chk_bits                      ! BIT x,y
'
SUB sub_command&,&H40
'
$S& S>
SELECT AND(sub_command&,7)
CASE &H0                             ! BIT x,B
'
flag_zero!=NOT BTST(reg_b&,SHR(sub_command&,3))
'
CASE &H1                             ! BIT x,C
'
flag_zero!=NOT BTST(reg_c&,SHR(sub_command&,3))
'
CASE &H2                             ! BIT x,D
'
flag_zero!=NOT BTST(reg_d&,SHR(sub_command&,3))
'
CASE &H3                             ! BIT x,E
'
flag_zero!=NOT BTST(reg_e&,SHR(sub_command&,3))
'
CASE &H4                             ! BIT x,H
'
flag_zero!=NOT BTST(reg_h&,SHR(sub_command&,3))
'
CASE &H5                             ! BIT x,L
'
flag_zero!=NOT BTST(reg_l&,SHR(sub_command&,3))
'
CASE &H6                             ! BIT x,(HL)
'
flag_zero!=NOT BTST(@get_byte(ADD(SHL(reg_h&,8),reg_l&)),SHR(sub_command&,3))
'
ADD cycle_cnt%,4
'
CASE &H7                             ! BIT x,A
'
flag_zero!=NOT BTST(reg_a&,SHR(sub_command&,3))
'
ENDSELECT
$S% S>
'
ADD cycle_cnt%,8+1
CLR flag_neg!
flag_half.c!=TRUE
'
RETURN
> PROCEDURE daa                           ! DAA
'
reg_1&=SHR(reg_a&,4)
reg_2&=AND(reg_a&,&X1111)
'
CLR dummy2&
'
IF NOT flag_neg!
'
IF OR(reg_2&>9,flag_half.c!)     ! Pas onderste nibble aan
dummy2&=&H6
ENDIF
'
IF OR(reg_1&>9,flag_carry!)      ! Pas bovenste nibble aan
ADD dummy2&,&H60
ENDIF
'
ELSE          ! flag neg?
'
IF AND(reg_2&=>6,flag_half.c!)
dummy2&=&HA
ENDIF
'
IF flag_carry!
'
IF flag_half.c!
ADD dummy2&,&HA0
ELSE
ADD dummy2&,&H90
ENDIF
'
ELSE
'
IF AND(reg_1&=<8,flag_half.c!)
ADD dummy2&,&HF0
ENDIF
'
ENDIF       ! flag carry
'
ENDIF         ! flag neg
'
@add(dummy2&)
'
flag_par.ov!=parity|(reg_a&)
'
ADD cycle_cnt%,4+1
'
RETURN
$P>
> FUNCTION page.mem_left(adres%,aant%)    ! # bytes in deze page
$F%
'
RETURN MIN(aant%,SUB(&H4000,AND(adres%,&H3FFF)))
'
ENDFUNC
> PROCEDURE fast_bmove(VAR pointer1%,pointer2%,aant%)! Move Block
LOCAL page1&,page2&,dummy%
'
DO WHILE aant%
'
page1&=SHR(pointer1%,14)
page2&=SHR(pointer2%,14)
dummy%=MIN(@page.mem_left(pointer1%,aant%),@page.mem_left(pointer2%,aant%))
'
IF cpageo%(page1&)
IF cpageo%(page2&)
'
BMOVE ADD(cpageo%(page1&),AND(pointer1%,&H3FFF)),ADD(cpageo%(page2&),AND(pointer2%,&H3FFF)),dummy%
'
ENDIF
ENDIF
'
pointer1%=CARD(ADD(pointer1%,dummy%))
pointer2%=CARD(ADD(pointer2%,dummy%))
SUB aant%,dummy%
'
LOOP
'
RETURN
'
' *** I/O-ports emulation ***
'
> PROCEDURE out(port&,data&)              ! Write to Hardware
'
$S& S>
SELECT port&
CASE &H7C,&H7D                ! FM-Pac
'
@fm_pac_o
'
CASE &H80 TO &H87             ! RS-232
'
@rs232_o
'
CASE &H90,&H91                ! LPT
'
@lpt_o
'
CASE &H98 TO &H9B,&H88 TO &H8B! VDP Ports
'
@vdp_o
'
CASE &HA0,&HA1
'
@psg_o
'
CASE &HA7                     ! Turbo-R: Bit 1=Pause LED, Bit 7=Turbo LED
'
IF turbo.r!
'
turbo.r_pause_led!=BTST(data&,1)
turbo.r_turbo_led!=BTST(data&,7)
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
CASE &HA8 TO &HAB             ! 8255 (PPI)
'
@ppi_o
'
CASE &HB0 TO &HB2           ! Sony 8255 Data-Cartridge
'
@sony_8255_o
'
CASE &HB4,&HB5                ! RP-5C01 (battery backuped clock-chip
'
@rp5c01_o
'
CASE &HC0,&HC1                ! Philips MSX Music Module
'
@mmod_o
'
CASE &HD0 TO &HD7             ! DiskDrive-Controller
'
@ddrive_o
'
CASE &HD8,&HD9                ! Kanji-ROM
'
@kanji_o
'
CASE &HE6,&HE7                ! 250kHz [0xE6=LSB] 16 bits counter, TurboR
'
@turbo.r_250khz_o
'
CASE &HF7                     ! Audio/Video Control
'
' BIT 4 - AV Control    L - TV
' BIT 5 - Ym Control    L - TV
' BIT 6 - Ys Control    L - Super
' BIT 7 - Video Select  L - Super
'
CASE &HFC TO &HFF             ! Memory-Mapper Page Select
'
@memmap_o
'
CASE device_io&               ! Device Emulation Cartridge :-)
'
@device_o
'
CASE exit_port&               ! --------------------> ST-STUFF <--------------
'
@exit_port
'
CASE dedicate_port&           ! Dedicated to & Greetings :-)
'
@dedicated_to_and_greetings
'
DEFAULT
'
' Unknown HARDWARE!
'
error_exit&=err_unknown_hardware&
'
ENDSELECT
$S% S>
'
RETURN
$P<
> PROCEDURE vdp_o                         ! Emulate VDP  [Write]
'
emul&=vdp_emul&
'
$S& S>
SELECT port&
CASE &H98,&H88                        ! Video RAM Data
'
BYTE{ADD(msx_video_ram%,video_write_pointer%)}=data&
'
ON video_mode& GOSUB ws_0a,ws_0b,ws_1,ws_2,ws_3,ws_2,ws_5,ws_6,ws_7,ws_8
'                                                  ^ Screen 4 == Screen 2
video_write_pointer%=AND(SUCC(video_write_pointer%),video_mem_end%)
'
CASE &H99,&H89                        ! Command & Status Register
'
IF vdp_data!                ! Data Send, keep it
CLR vdp_data!,vdp_data_cnt&
vdp_data|(0)=BYTE(data&)
vdp_data_pointer&=1
ELSE
IF data&<128              ! Change Adres?
IF AND(data&,64) ! Write-Address
video_write_pointer%=ADD(vdp_data|(0),SHL(AND(data&,63),8))
ELSE             ! Read-Address
video_read_pointer%=ADD(vdp_data|(0),SHL(AND(data&,63),8))
ENDIF
ELSE                      ! Change Register.
@do_vdp_register(AND(data&,63))
ENDIF
vdp_data!=TRUE
ENDIF
'
CASE &H9A,&H8A
'
IF vdp_pal_2nd!
IF colors!
SETCOLOR vdp_p_reg&,AND(SHR(vdp_pal_1&,4),&X111),AND(data&,&X111),AND(vdp_pal_1&,&X111)
CLR vdp_pal_2nd!
ENDIF
ELSE
vdp_pal_1&=data&
vdp_pal_2nd!=TRUE
ENDIF
'
CASE &H9B,&H8B                        ! Indirect Acces Register
'
IF vdp_data_cnt&    ! We already know its register number, we need data!
'
vdp_data!=TRUE
vdp_data|(vdp_data_pointer&)=BYTE(data&)
INC vdp_data_pointer&
DEC vdp_data_cnt&
'
ELSE
'
vdp_data_cnt&=1 ! **Reg.Num.**
'
ENDIF
'
IF vdp_data_cnt&=0
@do_vdp_register(vdp_reg&)
vdp_data!=TRUE
ENDIF
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN
$P>
> PROCEDURE do_vdp_register(vdp_reg&)     ! Do something usefull with data dropped in via $99
'
vdpregs|(vdp_reg&)=vdp_data|(0)       ! to speed some things up
'
$S& S>
SELECT vdp_reg&
CASE 0
'
dummy&=msx_vdp_mode&
IF msx_type&=msx_2&
msx_vdp_mode&=ADD(AND(msx_vdp_mode&,&X11),AND(SHL(vdp_data|(0),1),&X11100))
ELSE
msx_vdp_mode&=ADD(AND(msx_vdp_mode&,&X11),AND(SHL(vdp_data|(0),1),&X100))
ENDIF
IF dummy&<>msx_vdp_mode&
@set_res
ENDIF
'
CASE 1
'
dummy2&=msx_vdp_mode&
'
magnified_sprite!=AND(vdp_data|(0),1)
size_sprite!=AND(vdp_data|(0),2)
dummy&=AND(SHR(vdp_data|(0),3),&X11)
msx_vdp_mode&=ADD(ADD(AND(msx_vdp_mode&,&X11100),SHR(dummy&,1)),SHL(AND(dummy&,1),1))
vdp_interrupt!=AND(vdp_data|(0),32)
blank_screen!=NOT BTST(vdp_data|(0),6)
' IF BTST(vdp_data|(0),1)
'   video_mem_end%=16383
' ELSE
'   video_mem_end%=4095
' ENDIF
'
IF dummy2&<>msx_vdp_mode&
@set_res
ENDIF
'
CASE 2                        ! pattern name table
'
vdp_pattern_name_tabel%=AND(vdp_data|(0),15)*&H400
'
CASE 3                        ! Color table
'
vdp_color_tabel%=vdp_data|(0)*&H40
vdp_color_tabel_end%=vdp_color_tabel%+123!----------------------------------
'
IF video_mode&=screen_2&
'
' Do something with bit 5 & 6
'
ENDIF
'
CASE 4                        ! Pattern-generator table
'
vdp_pattern_generator_tabel%=AND(vdp_data|(0),7)*&H800
vdp_pattern_generator_end_tabel%=vdp_pattern_generator_tabel%+123!----------
'
IF video_mode&=screen_2&
'
' Do something with bit 0 & 1
'
ENDIF
'                           ! Sprite-pattern table
CASE 5
'
vdp_sprite_pattern_generator_tabel%=AND(vdp_data|(0),127)*&H80!-------------
vdp_sprite_pattern_generator_tabel_end%=vdp_sprite_pattern_generator_tabel%+123
'
CASE 7                        ! Back/Fore-ground color
'
vdp_foreground_color&=SHR(vdp_data|(0),4)
vdp_background_color&=AND(vdp_data|(0),15)
IF colors!
COLOR vdp_foreground_color&
INT{SUB(L~A,38)}=vdp_background_color&
ENDIF
'
CASE 8                        ! Light Pen etc.
'
CLR light_pen!,mouse!
'
IF AND(vdp_data|(0),64)
light_pen!=TRUE
ELSE IF AND(vdp_data|(0),128)
mouse!=TRUE
ENDIF
'
CASE 15
'
vdp_status_reg&=AND(vdp_data|(0),15)
'
CASE 16
'
vdp_p_reg&=AND(vdp_data|(0),15)
'
CASE 34                       ! Command-Register
'
x&=WORD(ADD(vdpregs|(36),SHL(AND(vdpregs|(37),&X1),8)))   ! X
y&=WORD(ADD(vdpregs|(38),SHL(AND(vdpregs|(39),&X11),8)))  ! Y
dx&=WORD(ADD(vdpregs|(40),SHL(AND(vdpregs|(41),&X1),8)))  ! DX
dy&=WORD(ADD(vdpregs|(42),SHL(AND(vdpregs|(43),&X1),8)))  ! DY
'
c&=WORD(vdpregs|(44))                                     ! Color
'
op&=AND(vdp_data|(0),15)                                  ! Logical operation
'
mem_sel!=AND(vdpregs|(45),32)                             ! Memory Select
'
IF AND(vdpregs|(45),1)                                    ! X/Y-Direction
SWAP dx&,dy&
ENDIF
IF AND(vdpregs|(45),2)                                    ! X-Direction
dx&=-dx&
ENDIF
IF AND(vdpregs|(45),4)                                    ! Y-Direction
dy&=-dy&
ENDIF
'
IF OR(AND(mem_sel!,extra_vdp_mem!),NOT mem_sel!)
'
SELECT SHR(vdp_data|(0),4)
CASE &X101                ! PSET  0101
'
@pset
'
CASE &X110                ! SRCH  0110
'
'
CASE &X111                ! LINE  1111
'
@line(x&,y&,dx&,dy&,c&,op&)
'
ENDSELECT       ! Command
'
ELSE
'
error_exit&=err_no_extra_vdp_mem&
'
ENDIF                       ! xtra vdp-mem selection valid check
'
DEFAULT
'
error_exit&=err_unknown_vdp_register&
'
ENDSELECT
$S% S>
'
CLR vdp_data_pointer&
'
RETURN
$P<
> PROCEDURE ws_0a                         ! SCREEN 0, 40 Kolommen
'
$S& S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=MOD(vdp_dummy%,40)
ws_y&=DIV(vdp_dummy%,40)
'
IF fast_screen_0!
'
PRINT AT(SUCC(ws_x&),SUCC(ws_y&));
OUT 5,BYTE(data&)
'
ELSE
'
vdp_dummy%=ADD(XBIOS(2),MUL(ws_y&,640))
'                                  ^^^ 8 lines van 80 bytes
ADD vdp_dummy%,ws_x&
'
FOR ws_dummy&=0 TO 7
BYTE{vdp_dummy%}=charset|(data&,ws_dummy&)
ADD vdp_dummy%,80
NEXT ws_dummy&
'
ENDIF
'
CASE vdp_pattern_generator_tabel% TO vdp_pattern_generator_end_tabel%
'
ws_dummy&=SUB(video_write_pointer%,vdp_pattern_generator_tabel%)
'
charset|(SHR(ws_dummy&,3),AND(ws_dummy&,7))=BYTE(data&)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_0b                         ! SCREEN 0, 80 Kolommen
'
' I.v.m. MSX-2:
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=MOD(vdp_dummy%,80)
ws_y&=DIV(vdp_dummy%,80)
'
IF fast_screen_0!
'
PRINT AT(SUCC(ws_x&),SUCC(ws_y&));
OUT 5,BYTE(data&)
'
ELSE
'
vdp_dummy%=ADD(XBIOS(2),MUL(ws_y&,640))
'                                 ^^^ 8 lines van 80 bytes
ADD vdp_dummy%,ws_x&
'
FOR ws_dummy&=0 TO 7
BYTE{vdp_dummy%}=charset|(data&,ws_dummy&)
ADD vdp_dummy%,80
NEXT ws_dummy&
'
ENDIF
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_1                          ! SCREEN 1, 32x24x16   [16]
'
$S& S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=AND(vdp_dummy%,31)
ws_y&=SHR(vdp_dummy%,5)
'
IF fast_screen_1!
'
IF colors!
ws_dummy&=SHR(data&,3)
COLOR charcolors|(ws_dummy&,1)            ! Set voorgrondkleur
INT{SUB(L~A,38)}=charcolors|(ws_dummy&,0) ! Set achtergrondkleur
ENDIF
'
PRINT AT(SUCC(ws_x&),SUCC(ws_y&));
OUT 5,BYTE(data&)
'
ELSE
'
vdp_dummy%=ADD(XBIOS(2),MUL(ws_y&,640))
'                                 ^^^ 8 lines van 80 bytes
ADD vdp_dummy%,ws_x&
'
FOR ws_dummy&=0 TO 7
BYTE{vdp_dummy%}=charset|(data&,ws_dummy&)
ADD vdp_dummy%,80
NEXT ws_dummy&
'
ENDIF
'
CASE vdp_pattern_generator_tabel% TO vdp_pattern_generator_end_tabel%
'
ws_dummy&=SUB(video_write_pointer%,vdp_pattern_generator_tabel%)
'
charset|(SHR(ws_dummy&,3),AND(ws_dummy&,7))=BYTE(data&)
'
CASE vdp_palette_tabel% TO vdp_palette_tabel_end%
'
ws_dummy2&=SHR(SUB(video_write_pointer%,vdp_palette_tabel%),3)
'
charcolors|(ws_dummy2&,0)=AND(data&,15) ! Background
charcolors|(ws_dummy2&,1)=SHR(data&,4)  ! Color
'
IF AND(NOT fast_screen_1!,colors!)     ! Werkt nog niet bij fastscreen1
'
vdp_dummy2%=video_write_pointer%      ! Keep old pointer & update screen
ws_dummy2&=SHL(ws_dummy2&,3)
'
FOR video_write_pointer%=vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
IF AND(BYTE{ADD(msx_video_ram%,video_write_pointer%)},&X11111000)=ws_dummy2&
'
@ws_1
'
ENDIF
NEXT video_write_pointer%
'
video_write_pointer%=vdp_dummy2%
'
ENDIF
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_2                          ! SCREEN 2, 256x192x16 [16]
'
$S& S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=AND(vdp_dummy%,31)
ws_y&=SHR(vdp_dummy%,5)
'
vdp_dummy2%=ADD(XBIOS(2),MUL(ws_y&,640))
'                                 ^^^ 8 lines van 80 bytes
ADD vdp_dummy2%,ws_x&
'
IF colors!
'
' Do something with those colors
'
ELSE
'
FOR ws_dummy&=0 TO 7
BYTE{vdp_dummy2%}=charset|(data&,ws_dummy&)
ADD vdp_dummy2%,80
NEXT ws_dummy&
'
ENDIF
'
CASE vdp_pattern_generator_tabel% TO vdp_pattern_generator_end_tabel%
'
ws_dummy&=SUB(video_write_pointer%,vdp_pattern_generator_tabel%)
ws_dummy2&=SHR(ws_dummy&,3)
ws_dummy&=AND(ws_dummy&,7)
'
charset|(ws_dummy2&,ws_dummy&)=BYTE(data&)
'
ws_dummy&=MUL(ws_dummy&,80)
'
vdp_dummy2%=msx_video_ram%
FOR vdp_dummy%=vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
IF BYTE{vdp_dummy2%}=ws_dummy2&
vdp_dummy3%=XBIOS(2)
ADD vdp_dummy3%,MUL(SHR(vdp_dummy%,5),640)
ADD vdp_dummy3%,AND(vdp_dummy%,31)
BYTE{ADD(vdp_dummy3%,ws_dummy&)}=data&
ENDIF
'
INC vdp_dummy2%
'
NEXT vdp_dummy%
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_3                          ! SCREEN 3,            [16]
'
RETURN
' PROCEDURE ws_4                          ! SCREEN 4, 256x192x16 [16] = Screen 2
' Y: 192 of 212:
> PROCEDURE ws_5                          ! SCREEN 5, 256xYx16   [512]
'
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=SHL(AND(vdp_dummy%,127),1)
ws_y&=SHR(vdp_dummy%,7)
'
PSET ws_x&,ws_y&,SHR(data&,4)
PSET SUCC(ws_x&),ws_y&,AND(data&,15)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_6                          ! SCREEN 6, 512xYx4    [512]
'
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=SHL(AND(vdp_dummy%,127),2)
ws_y&=SHR(vdp_dummy%,7)
'
PSET ws_x&,ws_y&,SHR(data&,6)
INC ws_x&
PSET ws_x&,ws_y&,AND(SHR(data&,4),&X11)
INC ws_x&
PSET ws_x&,ws_y&,AND(SHR(data&,2),&X11)
INC ws_x&
PSET ws_x&,ws_y&,AND(data&,&X11)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_7                          ! SCREEN 7, 512xYx16   [512]
'
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=SHL(AND(vdp_dummy%,255),1)
ws_y&=SHR(vdp_dummy%,8)
'
PSET ws_x&,ws_y&,SHR(data&,4)
PSET SUCC(ws_x&),ws_y&,AND(data&,15)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_8                          ! SCREEN 8, 256xYx256  [256]
'
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=AND(vdp_dummy%,255)
ws_y&=SHR(vdp_dummy%,8)
'
IF fast_screen_8!
'
PSET ws_x&,ws_y&,data&
'
' ELSE IF colors!
'
'   pset ws_x&,ws_y&,c256_look.up|(data&)
'
ELSE
'
ws_x&=SHL(ws_x&,1)
PSET ws_x&,ws_y&,SHR(data&,7)
PSET SUCC(ws_x&),ws_y&,AND(SHR(data&,3),1)
'
ENDIF
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE ws_12                         ! SCREEN 12, 256x212x19268
'
$S% S>
SELECT video_write_pointer%
CASE vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
'
vdp_dummy%=SUB(video_write_pointer%,vdp_pattern_name_tabel%)
'
ws_x&=AND(video_write_pointer%,&X11111100)
ws_y&=SHR(vdp_dummy%,8)
'
vdp_dummy2%=ADD(msx_video_ram%,AND(video_write_pointer%,&H1FFFC))
y1&=BYTE{ADD(vdp_dummy2%,0)}        ! Y pixel 1 [in c: vdp_dummy2%++]
y2&=BYTE{ADD(vdp_dummy2%,1)}        ! Y pixel 2
y3&=BYTE{ADD(vdp_dummy2%,2)}        ! Y pixel 3
y4&=BYTE{ADD(vdp_dummy2%,3)}        ! Y pixel 4
'
k&=ADD(AND(y1&,&X111),SHL(AND(y2&,&X111),3))! K
IF k&>32
SUB k&,64
ENDIF
'
j&=ADD(AND(y3&,&X111),SHL(AND(y4&,&X111),3))! J
IF j&>32
SUB j&,64
ENDIF
'
blauw_dummy=(CFLOAT(j&)/2)+(CFLOAT(k&)/4)! => - (j/2) - (k/4)
'
@t_pset(ADD(ws_x&,0),ws_y&,@l8b(@g_5b.8b(ADD(y1&,j&))),@l8b(@g_5b.8b(ADD(y1&,k&))),@l8b(@g_5b.8b(CINT((5/4)*CFLOAT(y1&)-blauw_dummy))))
@t_pset(ADD(ws_x&,1),ws_y&,@l8b(@g_5b.8b(ADD(y2&,j&))),@l8b(@g_5b.8b(ADD(y2&,k&))),@l8b(@g_5b.8b(CINT((5/4)*CFLOAT(y2&)-blauw_dummy))))
@t_pset(ADD(ws_x&,2),ws_y&,@l8b(@g_5b.8b(ADD(y3&,j&))),@l8b(@g_5b.8b(ADD(y3&,k&))),@l8b(@g_5b.8b(CINT((5/4)*CFLOAT(y3&)-blauw_dummy))))
@t_pset(ADD(ws_x&,3),ws_y&,@l8b(@g_5b.8b(ADD(y4&,j&))),@l8b(@g_5b.8b(ADD(y4&,k&))),@l8b(@g_5b.8b(CINT((5/4)*CFLOAT(y4&)-blauw_dummy))))
'
ENDSELECT
'
RETURN
$P>
> FUNCTION g_5b.8b(value&)                ! Grow 5bit to 8bit
$F%
'
RETURN DIV(MUL(value&,255),31)
'
ENDFUNC
> FUNCTION l8b(value&)                    ! Limit to 8-bits value
$F%
'
RETURN MAX(0,MIN(255,value&))
'
ENDFUNC
$P<
'
> PROCEDURE exit_port                     ! Emulator Functions
$U+ I+
'
ep_dummy%=TIMER
'
$S& S>
SELECT data&
CASE 253        ! Reset MSX :-)
'
ALERT 0,"Reset MSX? ",1," Yes | No ",ep_choice&
HIDEM
IF ep_choice&=1
RUN
ENDIF
'
CASE 254        ! Exit
'
ALERT 0,"Exit emulator? ",1," Yes | No ",ep_choice&
HIDEM
IF ep_choice&=1
END
ENDIF
'
CASE 255        ! Force Error
'
ALERT 0,"Force error? ",1," Yes | No ",ep_choice&
HIDEM
IF ep_choice&=1
@error
ENDIF
'
DEFAULT
'
ENDSELECT
$S% S>
'
ADD start_emulation_time%,SUB(TIMER,ep_dummy%)
'
$U- I-
RETURN
> PROCEDURE psg_o                         ! PSG          [Write]
'
IF emul_psg!
'
$S& S>
SELECT port&
CASE &HA0                     ! PSG Address Latch
'
psg_port&=data&
'
CASE &HA1                     ! PSG Data Write
'
psg_channel&=SHR(psg_port&,1)
SELECT psg_port&                    ! Adjust frequency (if needed)
CASE 0,2,4
freq&(psg_channel&)=ADD(AND(freq&(psg_channel&),&HFF00),data&)
LET data&=BYTE(CFLOAT(freq&(psg_channel&))*psg_freq_adjust)
CASE 1,3,5
freq&(psg_channel&)=ADD(BYTE(freq&(psg_channel&)),SHL(AND(data&,15),8))
LET data&=AND(SHR(CFLOAT(freq&(psg_channel&))*psg_freq_adjust,8),15)
CASE 7
LET data&=ADD(AND(XBIOS(28,W:-1,W:7),192),AND(data&,&H63))
CASE 15
j3!=BTST(data&,6)
kana_led!=NOT BTST(data&,7)
ENDSELECT
'
IF OR(psg_port&<=13,hacked!)        ! If the hacker f*cks things up, then I'll do it to!
~XBIOS(28,W:data&,W:BSET(psg_port&,7))
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE ppi_o                         ! 8255 (PPI)   [Write]
'
$S& S>
SELECT port&
CASE &HA8                     ! 8255 (PPI) Port A
'
slot_sel&(0)=AND(data&,&X11)        ! 0x0000 - 0x3FFFF
slot_sel&(1)=AND(SHR(data&,2),&X11) ! 0x4000 - 0x7FFFF
slot_sel&(2)=AND(SHR(data&,4),&X11) ! 0x8000 - 0xBFFFF
slot_sel&(3)=AND(SHR(data&,6),&X11) ! 0xC000 - 0xFFFFF
'
ram_ch!=TRUE
'
@update_global_memory_pointers
'
CASE &HA9                     ! PPI Poort B
'
ppi_b&=data&
'
CASE &HAA                     ! PPI Poort C
'
ppi_c&=data&
'
keyboard_row&=AND(data&,15)
relais!=NOT BTST(data&,4)   ! 0=ON, 1=OFF
cassette_output!=AND(data&,32)
caps_led!=AND(data&,64)
key_click!=data&>127
'
CASE &HAB                     ! PPI Mode
'
IF data&>127    ! Set PPI-Mode
ppi_mode&=data&
ELSE                ! Set 1 PPI-C-Port bit
dummy!=AND(data&,1)
dummy&=AND(SHR(data&,1),&X111)
SELECT dummy&
CASE 0 TO 3
IF dummy!
keyboard_row&=BSET(keyboard_row&,dummy&)
ELSE
keyboard_row&=BCLR(keyboard_row&,dummy&)
ENDIF
CASE 4
relais!=NOT dummy!
CASE 5
cassette_output!=dummy!
CASE 6
caps_led!=dummy!
CASE 7
key_click!=dummy!
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
ENDIF
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE lpt_o                         ! LPT          [Write]
'
IF printer!
'
$S& S>
SELECT port&
CASE &H90                     ! Strobe Output
'
' Bit 0
'
CASE &H91                     ! Print Data
'
IF msx_2_epson!
'
' Convert MSX-codes to Epson FX-80 codes
'
ENDIF
'
IF redirect_printer!
'
IF NOT printerfile_open!
IF EXIST("PRINTER.OUT")
OPEN "A",#58,"PRINTER.OUT"
ELSE
OPEN "O",#58,"PRINTER.OUT"
ENDIF
LET printerfile_open!=TRUE
ENDIF
'
OUT #58,BYTE(data&)
'
ELSE
LPRINT CHR$(data&);
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE mmod_o                        ! Emulate MMOD [Write]
'
IF mmod!
'
emul&=mmod_emul&
'
$S& S>
SELECT port&
CASE &HC0                     ! Register
'
mmod_reg&=data&
'
CASE &HC1                     ! Data
'
SELECT mmod_reg&
CASE 0                           ! ACIA-CONTROL
'
' 7: recv-interupt, 6, RTS (niet aangesl.), 5 send-end inter.
' 4: 0=7b, 1=8b, 3/2 7b: 00=even2, 01=odd2, 10=even1, 11=odd1
'                    8b: 00=none2, 01=none1, 10=even1, 11=odd1
' 10=snelh. 00=500Kbit/sec, 01=31.25Kbit/sec, 10=7.8125kbit/sec, 11=reset
'
SPOKE &HFFFC04,data&! Dezelfde ACIA :-)
'
CASE 1                           ! ACIA DATAREGISTER
'
SPOKE &HFFFC06,data&
'
DEFAULT
'
' can't :-(
'
ENDSELECT
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE turbo.r_250khz_o              ! Turbo-R+ 250kHz Counter [Write]
'
IF turbo.r!
'
' Well, ehrm, do nothing?
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE rs232_o                       ! RS-232C      [Write]
'
IF rs232c!
'
$S& S>
SELECT port&
CASE &H80                     ! RS-232C Data Port
'
OUT 1,BYTE(data&)
'
CASE &H84,&H85,&H86           ! i-8253 Counter 0/1/2 Register
'
dummy&=SUB(port&,&H84)
'
i8253_counter&(0)=data&
'
SELECT dummy&
CASE 0              ! Rx Baud Rate Clock
'
' verwerk [data&] en set baudrate
'
CASE 1              ! Tx Baud Rate Clock
CASE 2              ! Used by application (Interrupt generated optionally)
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE sony_8255_o                   ! Sony 8255    [Write]
'
IF emulate_sony_8255_cartridge!
'
$S& S>
SELECT port&
CASE &HB0                     ! Sony 8255 Cartridge, A0-A7
'
sony_8255%=ADD(AND(sony_8255%,&HFF00),data&)
'
CASE &HB1                     !                      A8-A10, A13-A15, R/W-Control
'
sony_8255%=AND(sony_8255%,&H18FF)   ! Mask OFF bit A8-A10 & A13-A5
ADD sony_8255%,SHL(AND(data&,&X111),8)
ADD sony_8255%,SHL(AND(data&,&X111000),10)
'
sony_8255_adr.l!=NOT BTST(data&,6)  ! Control
sony_8255_write!=data&<128          ! R/W
'
CASE &HB2                     ! A11-A12 / D0-D7
'
IF sony_8255_write!
'
IF sony_8255_adr.l!
'
sony_8255%=AND(sony_8255%,&HE7FF)+SHL(AND(data&,&X11),11)
'
ELSE
'
BYTE{ADD(sony_8255_data_cartridge_mem%,sony_8255%)}=data&
'
ENDIF
'
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE rp5c01_o                      ! RP5C01       [Write]
'
IF emulate_rp5c01!
'
$S& S>
SELECT port&
CASE &HB4                     ! RP-5C01: Adres-Register
'
rp5c01_adr&=data&
'
CASE &HB5                     ! RP-5C01: Data Write
'
rp5c01|(rp5c01_adr&)=BYTE(data&)
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE kanji_o                       ! Kanji-ROM    [Write]
'
IF kanji_rom!
'
$S& S>
SELECT port&
CASE &HD8                     ! Kanji-ROM, A5-A0 [least sign.]
'
kanji_rom_adr%=ADD(AND(kanji_rom_adr%,&X1111100000),AND(data&,&X11111))
'
CASE &HD9                     !            A5-A0 [most sign.]
'
kanji_rom_adr%=ADD(AND(kanji_rom_adr%,&X11111),SHL(AND(data&,&X11111),5))
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE memmap_o                      ! Memory-Mapper[Write]
'
IF mem_mapper!
'
mmap&(SUB(port&,&HFC))=MIN(data&,memory_mapper_pages&)
'
@update_memory_mapper_pointers
'
ELSE
'
error_exit&=err_no_mem_mapper&
'
ENDIF
'
RETURN
> PROCEDURE device_o                      ! Device Cartr.[Write]
'
IF device_emul!
'
$S& S<
SELECT reg_a&
CASE &HFF                 ! Geef drive-nr. bij drive-letter
CLR flag_carry!
'
dummy&=@get_byte(&HFD89)-65
IF dummy&=<3              ! =< D:?
reg_a&=dummy&
ELSE
flag_carry!=TRUE
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
$P>
> PROCEDURE ddrive_o                      ! DiskDrive    [Write]
LOCAL dummy&
'
emul&=drive.l_emul&
'
IF AND(disk_drive!,NOT highlevel_drive!)
'
IF drive_debug!
dummy&=port&-&HD0
PRINT AT(1+dummy&*8,max_row&);"D";dummy&;": ";HEX$(data&,2);",";
ENDIF
'
$S& S>
SELECT port&
CASE &HD0                           ! Command Register
'
CLR drive_error!
'
SELECT SHR(data&,5)
CASE &X0
'
drive_motor!=BTST(data&,3)
drive_verify!=BTST(data&,2)
drive_s.rate&=AND(data&,&X11)
'
IF BTST(data&,4)        ! Seek 1
'
' Seek naar 'drive_track&'
'
ELSE                    ! Restore 0
'
drive_track&=0
'
ENDIF
'
CASE &X1                  ! Step
CASE &X10                 ! Step-IN
'
IF drive_track&<82
INC drive_track&
ELSE
drive_error!=TRUE
ENDIF
'
CASE &X11                 ! Step-OUT
'
IF drive_track&
DEC drive_track&
ELSE
drive_error!=TRUE
ENDIF
'
CASE &X100                ! Read Sector
CASE &X101                ! Write Sector
CASE &X110                ! Read Address 0 | Force Interrupt 1
CASE &X111                ! Read Track 0 | Write Track 1
ENDSELECT
'
CASE &HD1
'
reg_0xd1&=data&
'
CASE &HD2
'
reg_0xd2&=data&
'
CASE &HD3
'
reg_0xd3&=data&
'
CASE &HD4
'
reg_0xd4&=data&
'
CASE &HD5                           ! Track Register?
'
drive_track&=data&
'
CASE &HD6
'
reg_0xd6&=data&
'
CASE &HD7
'
reg_0xd7&=data&
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN
> PROCEDURE fm_pac_o                      ! FM-Pac       [Write]
LOCAL dummy&
'
emul&=fmpac_emul&
'
IF fm_pac!
'
$S& S>
SELECT port&
CASE &H7C                   ! Register-Select
'
fm_pac_reg&=data&
'
CASE &H7D                   ! Data-Write
'
SELECT fm_pac_reg&
CASE &HF
'
fmpac_snd_off!=BTST(data&,3)
fmpac_smp!=BTST(data&,0)
'
CASE &H10 TO &H18         ! Frequency, low-byte
'
dummy&=SUB(fm_pac_reg&,&H10)
fmpac_freq&(dummy&)=ADD(AND(fmpac_freq&(dummy&),&HFF00),data&)
'
CASE &H20 TO &H28         ! Frequency, high-byte
'
dummy&=SUB(fm_pac_reg&,&H20)
fmpac_freq&(dummy&)=ADD(AND(fmpac_freq&(dummy&),&HFF),SHL(AND(data&,1),8))
fmpac_oct|(dummy&)=AND(SHR(data&,1),&X111)
fmpac_chbits!(dummy&,0)=BTST(data&,4)   ! op 0 voor nieuwe toon
fmpac_chbits!(dummy&,1)=BTST(data&,5)   ! 1: fade bij 4=0, 0: meteen uit bij 4=0
'
DEFAULT
'
error_exit&=err_unknown_fm_pac_reg&
'
ENDSELECT
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
ENDIF
'
RETURN
> PROCEDURE w.fm_pac(adres%,byte&)        ! FM-Pac       [Write2]
'
IF fmpac_ram!
'
emul&=fmpac_emul&
'
IF AND(adres%=>&H4000,adres%<=&H5FFF)
'
BYTE{ADD(V:fmpac_ram%(0),SUB(adres%,&H4000))}=byte&
'
ENDIF
'
ENDIF
'
RETURN
'
> FUNCTION inp(port&)                     ! Read from HardWare
$F%
'
$S& S>
SELECT port&
CASE &H80 TO &H87             ! RS-232C
'
RETURN @rs232_i
'
CASE &H90                     ! Busy State
'
RETURN @lpt_i
'
CASE &H98 TO &H9B,&H88 TO &H8B! VDP
'
RETURN @vdp_i
'
CASE &HA2                     ! PSG Port Data Read
'
RETURN @psg_i
'
CASE &HA8                     ! 8255 (PPI) Port A
'
' Address slot select signal
'
RETURN ADD(ADD(ADD(slot_sel&(0),SHL(slot_sel&(1),2)),SHL(slot_sel&(2),4)),SHL(slot_sel&(3),6))
'
CASE &HA9                     ! PPI Port B
'
'  IF BTST(ppi_c&,1)
'    RETURN ppi_b&
'  ELSE
RETURN @keyboard_i
'  ENDIF
'
CASE &HAA                     ! PPI Port C
'
IF BTST(ppi_c&,0)
RETURN ppi_c&
ELSE
RETURN 255
ENDIF
'
CASE &HAB                     ! PPI Mode Register
'
RETURN ppi_mode&
'
CASE &HB0 TO &HB2             ! Sony Data Cartridge (8255)
'
RETURN @sony.dc_i
'
CASE &HB4                     ! RP-5C01: Adres-Register
'
IF emulate_rp5c01!
RETURN rp5c01_adr&
ELSE
error_exit&=err_unknown_hardware&
ENDIF
'
CASE &HB5                     ! RP-5C01: Data Write
'
IF emulate_rp5c01!
RETURN rp5c01|(rp5c01_adr&)
ELSE
error_exit&=err_unknown_hardware&
ENDIF
'
CASE &HC0,&HC1                ! Philips Music Module
'
IF mmod!
RETURN @mmod_i
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
CASE &HD0 TO &HD7             ! Disk-Drive Controller
'
RETURN @ddrive_i
'
CASE &HD9                     ! Kanji ROM
'
IF kanji_rom!
RETURN BYTE{ADD(kanji_rom%,kanji_rom_adr%)}
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
CASE &HE6,&HE7                ! Turbo-R 250kHz 16bit++ (:-])
'
IF turbo.r!
'
IF port&=&HE6
RETURN BYTE(@turbo.r_250khz_i)
ELSE!IF port&=&HE7
RETURN BYTE(SHR(@turbo.r_250khz_i,8))
ENDIF
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
CASE &HFC TO &HFF             ! Memory-Mapper page select
'
RETURN @memmap_i
'
DEFAULT
'
' Unknown HARDWARE!
'
error_exit&=err_unknown_hardware&
'
ENDSELECT
$S% S>
'
RETURN inp_data&          ! just in case...
'
ENDFUNC
> FUNCTION vdp_i                          ! Emulate VDP      [Read]
$F%
'
$S& S>
SELECT port&
CASE &H98,&H88                ! Video RAM Data
'
vdp_dummy&=BYTE{ADD(msx_video_ram%,video_read_pointer%)}
'
video_read_pointer%=AND(SUCC(video_read_pointer%),video_mem_end%)
'
CASE &H99,&H89                ! Command & Status Register
'
SELECT vdp_status_reg&
CASE 0
'
IF always_vsync!
vdp_dummy&=128
ELSE
CLR vdp_dummy&                         ! Vsync :-)
IF PEEK(&HFF8201)=PEEK(&HFF8205)
IF PEEK(&HFF8203)=PEEK(&HFF8207)
IF PEEK(&H8209)=0
vdp_dummy&=128
ENDIF
ENDIF
ENDIF
ENDIF
'
' bit 6: 5 sprites/line
' bit 5: 2 sprites raken elkaar
' bit 0...4: nummer v/d 5e sprite
'
CASE 1
'
IF AND(mouse!,light.pen_mouse!)
'
SELECT MOUSEK
CASE 3
vdp_dummy&=128+64
CASE 2
vdp_dummy&=128
CASE 1
vdp_dummy&=64
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
'
ELSE IF AND(light_pen!,light.pen_mouse!)
'
SELECT MOUSEK
CASE 3                  ! switch & light
vdp_dummy&=128+64
CASE 2                  ! light detected
vdp_dummy&=64
CASE 1                  ! switch pressed
vdp_dummy&=128
ENDSELECT
'
ENDIF
'
IF vdp_h.scan_int!!<---------------
vdp_dummy&=BSET(vdp_dummy&,0)
ENDIF
'
CASE 2
'
vdp_dummy&=128         ! Always ready to get data
ADD vdp_dummy&,64+32   ! h-sync/v-sync
IF vdp_bd!        ! Boundary color found (ofzoiets)
ADD vdp_dummy&,16
ENDIF
ADD vdp_dummy&,8+4     ! 11
' +2  -> first/second field?
' +1  -> command execution
'
CASE 3 TO 6
'
IF light.pen_mouse!
'
SELECT vdp_status_reg&
CASE 3              ! LightPen/Mouse X (B7...B0)
'
vdp_dummy&=BYTE(MOUSEX)
'
CASE 4              ! LightPen/Mouse X (B8)
'
vdp_dummy&=OR(AND(SHR(MOUSEX,8),1),254)
'
CASE 5              ! LightPen/Mouse Y (B7...B0)
'
vdp_dummy&=BYTE(MOUSEY)
'
CASE 6              ! LightPen/Mouse Y (B8)
'
vdp_dummy&=OR(AND(SHR(MOUSEY,8),1),254)
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
CASE 8              ! vdp-color search thingy (b7...b0)
'
vdp_dummy&=BYTE(vdp_bd&)
'
CASE 9              ! vdp-color search thingy (b8)
'
vdp_dummy&=OR(AND(SHR(vdp_bd&,8),1),254)
'
DEFAULT
'
error_exit&=err_unknown_vdp_status_reg&
'
ENDSELECT
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN vdp_dummy&
'
ENDFUNC
> FUNCTION keyboard_i                     ! Emulate Keyboard [Read]
$F%
LOCAL data&
'
emul&=keyboard_emul&
'
IF keybuf_cnt&                                ! Delete Buffer if Needed
IF kb_dummy!
DELETE keybuf|(0)
DELETE keysk|(0)
DEC keybuf_cnt&
CLR kb_dummy!
ENDIF
ENDIF
'
CLR data&
IF keybuf_cnt&
'
IF debug!
IF keyboard_debug!
DEFNUM 3
PRINT AT(30,ADD(15,keyboard_row&));keyboard_row&;" ";keybuf|(0);" ";keysk|(0);" ";
OUT 5,keybuf|(0)
ENDIF
ENDIF
'
$S& S>
SELECT keybuf|(0)
CASE "0" TO "7","&","^","%","$","#","@","!",")"
IF keyboard_row&=0
SELECT keybuf|(0)
CASE "7","&"
LET data&=128
CASE "6","^"
LET data&=64
CASE "5","%"
LET data&=32
CASE "4","$"
LET data&=16
CASE "3","#"
LET data&=8
CASE "2","@"
LET data&=4
CASE "1","!"
LET data&=2
CASE "0",")"
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE ";","]","[","\","=","-","9","8",":","}","{","|","+","_","(","*"
IF keyboard_row&=1
SELECT keybuf|(0)
CASE ";",":"
LET data&=128
CASE "]","}"
LET data&=64
CASE "[","{"
LET data&=32
CASE "\","|"
LET data&=16
CASE "=","+"
LET data&=8
CASE "-","_"
LET data&=4
CASE "9","("
LET data&=2
CASE "8","*"
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE "B","A","œ","/",".",",","`","'","b","a","ÿ","?",">","<",34,"~"
IF keyboard_row&=2
SELECT keybuf|(0)
CASE "B","b",2
LET data&=128
CASE "A","a",1
LET data&=64
CASE "œ","ÿ"
LET data&=32
CASE "/","?"
LET data&=16
CASE ".",">"
LET data&=8
CASE ",","<"
LET data&=4
CASE "`",34                     ! ' of "
LET data&=2
CASE "'","~"
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE "C" TO "J","c" TO "j",3 TO 7,10
IF keyboard_row&=3
SELECT keybuf|(0)
CASE "J","j",10
LET data&=128
CASE "I","i"
LET data&=64
CASE "H","h"
LET data&=32
CASE "G","g",7
LET data&=16
CASE "F","f",6
LET data&=8
CASE "E","e",5
LET data&=4
CASE "D","d",4
LET data&=2
CASE "C","c",3
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE "K" TO "R","k" TO "r",11,12,14 TO 18
IF keyboard_row&=4
SELECT keybuf|(0)
CASE "R","r",18
LET data&=128
CASE "Q","q",17
LET data&=64
CASE "P","p",16
LET data&=32
CASE "O","o",15
LET data&=16
CASE "N","n",14
LET data&=8
CASE "M","m"
LET data&=4
CASE "L","l",12
LET data&=2
CASE "K","k",11
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE "S" TO "Z","s" TO "z",19 TO 26
IF keyboard_row&=5
SELECT keybuf|(0)
CASE "Z","z",26
LET data&=128
CASE "Y","y",25
LET data&=64
CASE "X","x",24
LET data&=32
CASE "W","w",23
LET data&=16
CASE "V","v",22
LET data&=8
CASE "U","u",21
LET data&=4
CASE "T","t",20
LET data&=2
CASE "S","s",19
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE 187 TO 189
IF keyboard_row&=6
LET data&=2^SUB(keybuf|(0),182)
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE 190,191,8,255,9,27,226,13
IF keyboard_row&=7
SELECT keybuf|(0)
CASE 13                 ! CR
LET data&=128
CASE 226                ! SEL  [help]
LET data&=64
CASE 8                  ! BS
LET data&=32
CASE 225                ! STOP [undo]
LET data&=16
CASE 9                  ! TAB
LET data&=8
CASE 27                 ! ESC
LET data&=4
CASE 191                ! F5
LET data&=2
CASE 190                ! F4
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE 200,203,205,208,127,210,199,32
IF keyboard_row&=8
SELECT keybuf|(0)
CASE 205                ! Right
LET data&=128
CASE 208                ! Down
LET data&=64
CASE 200                ! Up
LET data&=32
CASE 203                ! Left
LET data&=16
CASE 127                ! Del
LET data&=8
CASE 210                ! Ins
LET data&=4
CASE 199                ! Home
LET data&=2
CASE 32                 ! Space
LET data&=1
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
kb_dummy!=keysk|(0)=0
keybuf|(0)=0
ENDIF
CASE 0
kb_dummy!=keysk|(0)=0             ! bugje voorkomen
DEFAULT                     ! Onbekende toets
kb_dummy!=TRUE
keybuf|(0)=0
keysk|(0)=0
ENDSELECT
$S% S>
'
IF keyboard_row&=6
LET data&=@switch_keys(keysk|(0),data&)
keysk|(0)=0
kb_dummy!=keybuf|(0)=0
ENDIF
'
ELSE
'
LET data&=@switch_keys(BYTE(BIOS(11,W:-1)),data&)
'
IF AND(hacked!,RND<0.05)                    ! Program is hacked!
LET data&=XOR(data&,RANDOM(256))
ENDIF
'
ENDIF                         ! cnt?
'
RETURN XOR(BYTE(data&),255)
'
ENDFUNC
> FUNCTION switch_keys(chk&,data&)        ! Shift, Code, Graph, etc.
$F%
'
IF keyboard_row&=6
IF AND(chk&,2)       ! Linker (!!) Shift = Shift (!!)
LET data&=OR(data&,1)
ENDIF
'
IF AND(chk&,4)       ! Ctrl
LET data&=OR(data&,2)
ENDIF
'
IF AND(chk&,8)       ! Graph (ALT)
LET data&=OR(data&,4)
ENDIF
'
IF AND(chk&,16)      ! Cap(-slock)
LET data&=OR(data&,8)
ENDIF
'
IF AND(chk&,1)       ! Rechter (!!) Shift = Code (!!)
LET data&=OR(data&,16)
ENDIF
'
IF debug!
PRINT AT(42,22);BIN$(data&,8);
ENDIF
ENDIF
'
RETURN data&
'
ENDFUNC
> FUNCTION psg_i                          ! PSG              [Read]
$F%
'
IF emul_psg!
'
SELECT psg_port&
CASE 0 TO 13
RETURN XBIOS(28,W:-1,W:psg_port&)
CASE 14
'
IF joystick!
STICK 1
IF j3!
j&=STICK(0)
fire&=STRIG(0)
ELSE
j&=STICK(1)
fire&=STRIG(1)
ENDIF
STICK 0
'
LET inp_data&=XOR(255,@joy(j&,fire&))
ENDIF
'
CASE 15
'
' iets met kana-leds enzo.
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN 0
'
ENDFUNC
> FUNCTION joy(j&,fire&)                  ! Emulate Joystick [Read]
$F%
'
IF OR(OR(j&=5,j&=1),j&=9)                ! Up/Down
joy_dummy&=1
ELSE IF OR(OR(j&=6,j&=2),j&=10)
joy_dummy&=2
ELSE
CLR joy_dummy&
ENDIF
'
IF OR(OR(j&=5,j&=4),j&=6)                ! Left/Right
joy_dummy&=OR(joy_dummy&,4)
ELSE IF OR(OR(j&=9,j&=8),j&=10)
joy_dummy&=OR(joy_dummy&,8)
ENDIF
'
IF fire&
joy_dummy&=OR(joy_dummy&,16)
ENDIF
'
RETURN joy_dummy&
'
ENDFUNC
> FUNCTION mmod_i                         ! Emulate MMOD     [Read]
$F%
LOCAL data&
'
emul&=mmod_emul&
'
$S& S>
SELECT port&
CASE &HC0                     ! Register
'
' Can't read this port!
'
byte&=mmod_reg&     ! Mja :-/
'
CASE &HC1                     ! Data
'
SELECT mmod_reg&
CASE 4              ! Status Register
'
byte&=PEEK(&HFFFC04)
'
CASE 5              ! Ontvangen Data
'
byte&=PEEK(&HFFFC06)
'
DEFAULT
'
' Can't handle
'
ENDSELECT
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN byte&
'
ENDFUNC
> FUNCTION ddrive_i                       ! DiskDrive        [Read]
$F%
LOCAL data&,dummy&
'
emul&=drive.l_emul&
'
IF disk_drive!
'
IF drive_debug!
dummy&=port&-&HD0
PRINT AT(1+dummy&*8,max_row&);"pD";dummy&;"q";
ENDIF
'
$S& S>
SELECT port&
CASE &HD0                                     ! Status Register?
'
CLR data&
IF drive_motor!     ! Motor Aan?
LET data&=127
ENDIF
' 32
IF drive_error!
ADD data&,63      ! Write Protect
ADD data&,16      ! Record not found
ADD data&,8       ! CRC-Fout
ENDIF
' 4/2
drive_busy!=NOT drive_busy!! Fouten voorkomen
IF drive_busy!      ! Drive busy
ADD data&,1
ENDIF
'
RETURN data&
'
CASE &HD1
'
RETURN reg_0xd1&
'
CASE &HD2
'
RETURN reg_0xd2&
'
CASE &HD3
'
RETURN reg_0xd3&
'
CASE &HD4
'
RETURN 0 ! reg_0xd4&
'
CASE &HD5                                     ! Drive Track?
'
RETURN drive_track&
'
CASE &HD6
'
RETURN reg_0xd6&
'
CASE &HD7
'
RETURN reg_0xd7&
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN -1
'
ENDFUNC
> FUNCTION turbo.r_250khz_i               ! Turbo-R+ 250kHz  [Read]
$F%
'
IF real_250khz!
'
RETURN MOD(MUL(TIMER,1250),250000)              ! nauwkeuriger!
'
ELSE
'
RETURN CFLOAT(cycle_cnt%)*CFLOAT(250000/CFLOAT(clock_freq%))
'
ENDIF
'
ENDFUNC
> FUNCTION rs232_i                        ! RS232C           [Read]
$F%
'
IF rs232c!
'
$S& S>
SELECT port&
CASE &H80                     ! RS-232C Data Port
'
IF INP?(1)
last_rs232c_data&=INP(1)
ENDIF
'
RETURN last_rs232c_data&
'
CASE &H82                     ! RS-232C Status Sense Port for CTS, Timer/Counter 2, RI and CD
'
inp_dummy&=PEEK(&HFFFA01)
'
IF AND(inp_dummy&,4)         !CTS
LET inp_data&=BSET(inp_data&,7)
ENDIF
'
IF AND(inp_dummy&,64)        !RI
LET inp_data&=BSET(inp_data&,1)
ENDIF
'
IF AND(inp_dummy&,2)         !CD
RETURN BSET(inp_data&,0)
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN -1
'
ENDFUNC
> FUNCTION memmap_i                       ! Memory Mapper    [Read]
$F%
'
IF mem_mapper!
'
RETURN mmap&(SUB(port&,&HFC))
'
ELSE
'
error_exit&=err_no_mem_mapper&
'
ENDIF
'
RETURN -1
'
ENDFUNC
> FUNCTION lpt_i                          ! Printer          [Read]
$F%
'
IF printer!
IF redirect_printer!
RETURN 0              !     ready
ELSE
IF BIOS(8,0)=0! Can't send
RETURN &X10         ! NOT ready
ELSE
RETURN &X0          !     ready
ENDIF
ENDIF
ELSE
'
error_exit&=err_unknown_hardware&
RETURN 0
'
ENDIF
'
ENDFUNC
> FUNCTION sony.dc_i                      ! Sony Data Cartr. [Read]
$F%
'
IF emulate_sony_8255_cartridge!
'
$S& S>
SELECT port&
CASE &HB0                     ! Sony 8255, A0-A7
'
RETURN BYTE(sony_8255%)
'
CASE &HB1                     !            A8-A10, A13-A15, Control, R/W
'
LET inp_data&=AND(SHR(sony_8255%,8),&X111)
ADD inp_data&,AND(SHR(sony_8255%,13),&X111)
ADD inp_data&,AND(NOT sony_8255_adr.l!,64)
RETURN ADD(inp_data&,AND(NOT sony_8255_write!,127))
'
CASE &HB2                     !            A11-A12 / D0-D7
'
IF sony_8255_adr.l!
'
RETURN AND(SHR(sony_8255%,11),&X11)
'
ELSE
'
RETURN BYTE{ADD(sony_8255_data_cartridge_mem%,sony_8255%)}
'
ENDIF
'
ENDSELECT
$S% S>
'
ELSE
'
error_exit&=err_unknown_hardware&
'
ENDIF
'
RETURN -1
'
ENDFUNC
> FUNCTION r.fm_pac(adres%,VAR byte&)     ! FM-Pac       [Read]
$F%
'
IF fmpac_ram!
'
emul&=fmpac_emul&
'
IF AND(AND(adres%=>&H4000,adres%<=&H5FFF),slot_sel&(1)=fm_pac_slot&)
'
byte&=BYTE{ADD(V:fmpac_ram%(0),SUB(adres%,&H4000))}
RETURN TRUE
'
ENDIF
'
ENDIF
'
RETURN FALSE
'
ENDFUNC
'
' *** ROM-Patches, emulation of special cartridges, etc. ***
'
' #Check 4 patches:
> FUNCTION check_read_patches(adres%)     ! Check 4 Patches               [Read]
$F%
'
$S& S>
SELECT adres%
CASE &H5FFE,&H5FFF,&H7FF6             ! FM-Pac
'
IF AND(slot_sel&(1)=fm_pac_slot&,fm_pac!)
RETURN @r.emulate_fm_pac(adres%)
ENDIF
'
CASE &H8000,&H8800 TO &H888F,&H9000,&H9800 TO &H988F ! SCC(+)
'
IF AND(slot_sel&(2)=konami_scc_slot&,konami_scc!)
RETURN @r.emulate_konami_scc(adres%)
ENDIF
'
CASE &HFFCA                           ! MSX-Audio
'
IF msx_audio!
RETURN msx.audio_0xffca&
ENDIF
'
CASE &HFFFF                           ! 2nd slot-select
'
IF patches!        ! Deze kan ook gechecked worden met uigeschakelde patches
'
slot&=slot_sel&(3)
RETURN XOR(255,ADD(ADD(ADD(SHL(slot2sel&(3,slot&),6),SHL(slot2sel&(2,slot&),4)),SHL(slot2sel&(1,slot&),2)),slot2sel&(0,slot&)))
'
ENDIF
'
ENDSELECT
$S% S>
'
IF AND(hacked!,RND<0.1)
RETURN PRED(RANDOM(2))
ENDIF
'
RETURN -1
'
ENDFUNC
> FUNCTION check_write_patches(adres%,data&)! Check 4 Patches            [Write]
$F%
'
$S& S>
SELECT adres%
CASE &H5FFE,&H5FFF,&H7FF6
'
IF AND(slot_sel&(1)=fm_pac_slot&,fm_pac!)
'
@w.emulate_fm_pac(adres%,data&)
'
RETURN TRUE
'
ENDIF
'
CASE &H8000,&H8800 TO &H888F,&H9000,&H9800 TO &H988F
'
IF AND(slot_sel&(2)=konami_scc_slot&,konami_scc!)
'
@w.emulate_konami_scc(adres%,data&)
'
RETURN TRUE
'
ENDIF
'
CASE &HFFCA
'
IF msx_audio!
'
msx.audio_0xffca&=data&
'
RETURN TRUE
'
ENDIF
'
CASE &HFFFF                           ! 2nd slot-select
'
slot&=slot_sel&(3)
'
slot2sel&(0,slot&)=AND(data&,&X11)
slot2sel&(1,slot&)=AND(SHR(data&,2),&X11)
slot2sel&(2,slot&)=AND(SHR(data&,4),&X11)
slot2sel&(3,slot&)=SHR(data&,6)
'
ram_ch!=TRUE
'
@update_global_memory_pointers
'
RETURN TRUE
'
ENDSELECT
$S% S>
'
RETURN FALSE
'
ENDFUNC
> FUNCTION check_jump_patches(adres%)     ! Check 4 Patches               [Jump]
$F%
'
$S& S>
SELECT adres%
CASE &H56,&HC0,&HE1,&HE4,&HE7,&HEA,&HED,&HF0,&H156,&H17D
'
CONT        ! gewoon doorgaan :-)
CASE &H17D,&H815,&H1113,&H1A63,&H1ABC,&H19E9,&H19F1,&H1A19,&H19DD,&H468
'
dummy&=slot_sel&(0)
IF AND(AND(dummy&=msx_bios_slot&,msx_rom_patches!),slot2sel&(0,dummy&)=msx_bios_2nd_slot&)
'
@msx_rom_patches(adres%)
'
RETURN TRUE
'
ENDIF
'
CASE &H4010,&H401C,&H4029,&H46C5,&H4755
'
dummy&=slot_sel&(1)
IF AND(AND(dummy&=diskrom_slot&,slot2sel&(1,dummy&)=diskrom_sslot&),drive_dummy!)
'
@diskrom_patches(adres%)
'
RETURN TRUE
'
ENDIF
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN FALSE
'
ENDFUNC
' #Do ROM-patches:
> PROCEDURE msx_rom_patches(adres%)       ! Patches to use ST Soft- & Hardware
LOCAL file$
'
emul&=rom_emul&
'
$S% S>
SELECT adres%
CASE &H56,&H815              ! FILVRM
'
dummy%=ADD(SHL(reg_h&,8),reg_l&)
'
LET data&=reg_a&           ! voor de on...gosub ws_x
'
FOR video_write_pointer%=dummy% TO PRED(ADD(ADD(dummy%,SHL(reg_b&,8)),reg_c&))
'
BYTE{ADD(msx_video_ram%,video_write_pointer%)}=reg_a&
ON video_mode& GOSUB ws_0a,ws_0b,ws_1,ws_2,ws_3,ws_2,ws_5,ws_6,ws_7,ws_8
'
NEXT video_write_pointer%
'
CASE &HC0,&H17D,&H1113       ! BEEP
'
OUT 2,7                             ! ping :-)
'
CASE &HE1,&H1A63             ! TAPION
'
CLR flag_carry!
dummy!=TRUE
IF file_open!
ALERT 0,"Continue from same file? ",1," Yes | No | Abort ",dummy&
SELECT dummy&
CASE 1
CLR dummy!
CASE 2
CLR dr_emul&
CLOSE #50
CLOSE #51
CASE 3
CLR dr_emul&,dummy!
flag_carry!=TRUE
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
ENDIF
'
IF dummy!
'
file$=@fileselect$("Select file to open")
IF EXIST(file$)
'
path$=LEFT$(file$,RINSTR(file$,"\"))
OPEN "I",#50,file$
file_open!=TRUE
'
IF INP(#50)=&HFE
'
ALERT 0,"This seems to be a diskfile. |Emulate data-recorder? ",1," Yes | No ",dummy&
IF dummy&=2
'
RELSEEK #50,-1
'
ELSE
'
ARRAYFILL dr_emul|(),32
FOR dummy&=0 TO 9
dr_emul|(dummy&)=&HD0
NEXT dummy&
dummy$=MID$(file$,SUCC(RINSTR(file$,"\")))
FOR dummy&=1 TO MIN(LEN(dummy$),6)
dr_emul|(ADD(dummy&,9))=ASC(MID$(dummy$,dummy&,1))
NEXT dummy&
dr_emul&=16   ! 16 bytes left in emulation-buffer
'
ENDIF
'
ELSE
RELSEEK #50,-1
ENDIF
'
ELSE
'
flag_carry!=TRUE
'
ENDIF
'
ENDIF
'
CASE &HE4,&H1ABC            ! TAPIN
'
IF OR(EOF(#50),NOT file_open!)
'
flag_carry!=TRUE
'
ELSE
'
CLR flag_carry!
'
reg_a&=INP(#50)
'
ENDIF
'
CASE &HE7,&H19E9             ! TAPIOF
'
IF file_open!
'
ALERT 0,"Close file? ",0," Yes | No ",dummy&
IF dummy&=1
'
CLOSE #50
CLOSE #51
CLR file_open!,dr_emul&
'
ENDIF
ENDIF
'
CLR flag_carry!
'
CASE &HEA,&H19F1             ! TAPOON
'
CLR flag_carry!
'
file$=@fileselect$("Select file to write")
IF EXIST(file$)
'
ALERT 0,"Overwrite, append or abort? ",1+ABS(tapoon_dummy!)," Overwr. | Append | Abort ",dummy&
HIDEM
IF dummy&=3
CLR file$,tapoon_dummy!
ELSE
tapoon_dummy!=NOT tapoon_dummy!
ENDIF
'
ELSE
CLR dummy&
ENDIF
'
IF LEN(file$)
path$=LEFT$(file$,RINSTR(file$,"\"))
'
IF file_open!
CLOSE #50
CLOSE #51
ENDIF
'
IF OR(dummy&=1,EXIST(file$)=0)
OPEN "O",#51,file$
ELSE
OPEN "A",#51,file$
ENDIF
file_open!=TRUE
'
ELSE
'
flag_carry!=TRUE
'
ENDIF
'
CASE &HED,&H1A19                     ! TAPOUT
'
IF file_open!
'
OUT #51,BYTE(reg_a&)
'
CLR flag_carry!
'
ELSE
'
flag_carry!=TRUE
'
ENDIF
'
CASE &HF0,&H19DD                     ! TAPOOF
'
IF file_open!
'
CLOSE #50
CLOSE #51
'
CLR flag_carry!
'
ELSE
'
flag_carry!=TRUE
'
ENDIF
'
CASE &H156,&H468                    ! KILBUF
'
IF NOT hacked!
'
CLR keybuf_cnt&,kb_dummy!
ARRAYFILL keybuf|(),0
ARRAYFILL keysk|(),0
DO WHILE INP?(2)
~INP(2)
LOOP
'
ENDIF
'
DEFAULT
error_exit&=err_internal_error&
ENDSELECT
$S% S>
'
RETURN
' #Do DDrive-Patches:
> PROCEDURE diskrom_patches(adres%)       ! Patches to use Disk-Drive
LOCAL sector&,dummy%,dummy&,dummy2&,adres%,drive&
'
emul&=drive.l_emul&
'
IF adres%=&H4010
drive&=MIN(1,reg_a&)                ! Alleen A & B!!
IF flag_carry!
adres%=&H4755             ! Write
ELSE
adres%=&H46C5             ! Read
ENDIF
CLR reg_a&          ! Geen fout opgetreden
ELSE
CLR drive&          ! Zal wel drive A zijn.
ENDIF
'
$S% S>
SELECT adres%
CASE &H401C                          ! Format Disk
'
' HL=Buffer, BC=Lengte (minimaal 0x1C00), D=Drive-nr., A=sides (1/2)
'
ALERT 0,"Format your disk :-) ",1," Ok ",dummy&
'
CASE &H4029
'
' Als (get_byte(&Hf1c1) != 0), gaat 't op sommige computers mis en krijg je
' 'n disk-offline error bij de volgende actie.
'
CASE &H46C5                          ! Read  Sector(s), HL=DMA, DE=Sector, B=#
'
sector&=AND(ADD(SHL(reg_d&,8),reg_e&),32767)
adres%=ADD(SHL(reg_h&,8),reg_l&)
'
DO WHILE b&
'
~BIOS(4,W:0,L:V:drive_buf|(0),W:1,W:sector&,W:drive&)! Lees sector van disk
INC sector&
DEC b&
'
dummy&=512
dummy%=V:drive_buf|(0)
DO
dummy2&=@page.mem_left(adres%,512)
BMOVE dummy%,adres%,dummy2&
ADD adres%,dummy2&
ADD dummy%,dummy2&
SUB dummy&,dummy2&
LOOP WHILE dummy&
'
LOOP
'
CASE &H4755                   ! Write Sector(s), HL=DMA, DE=Sector, B=#
'
sector&=AND(ADD(SHL(reg_d&,8),reg_e&),32767)
adres%=ADD(SHL(reg_h&,8),reg_l&)
'
DO WHILE b&
'
dummy&=512
dummy%=V:drive_buf|(0)
DO
dummy2&=@page.mem_left(adres%,512)
BMOVE adres%,dummy%,dummy2&
ADD adres%,dummy2&
ADD dummy%,dummy2&
SUB dummy&,dummy2&
LOOP WHILE dummy&
'
~BIOS(4,W:1,L:V:drive_buf|(0),W:1,W:sector&,W:drive&)! Schrijf sector naar disk
INC sector&
DEC b&
'
LOOP
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
'
RETURN
' #Do SCC-emulation:
> FUNCTION r.emulate_konami_scc(adres%)   ! Emulate Konami SCC-Chip       [Read]
$F%
LOCAL freq,dummy&,dummy%
'
emul&=scc_emul&
'
IF adres%=>&H9000
SUB adres%,&H1000
ENDIF
'
$S& S>
SELECT adres%
CASE &H8000                   ! On/Off :-)
'
RETURN &H3F
'
CASE &H8800 TO &H889F         ! Wave-Pattern
'
dummy%=SUB(adres%,&H8800)
'
RETURN konami_scc_wave|(SHR(dummy%,5),AND(dummy%,31))
'
CASE &H8880 TO &H8889         ! Frequenties
'
dummy&=SHR(SUB(adres%,&H8880),1) !Channel Nr.
'
IF AND(adres%,1)
'
RETURN SHR(konami_scc_freq%(dummy&),8)
'
ELSE
'
RETURN BYTE(konami_scc_freq%(dummy&))
'
ENDIF
'
CASE &H888A TO &H888E         ! Volume
'
RETURN konami_scc_volume|(ADD(SUB(adres%,&H888A),konami_scc_midi_channel&))
'
CASE &H888F                   ! Channel-Select
'
RETURN konami_scc_channels&
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN FALSE
'
ENDFUNC
> PROCEDURE w.emulate_konami_scc(adres%,data&)! Emulate Konami SCC-Chip  [Write]
LOCAL freq,dummy&,dummy%
'
emul&=scc_emul&
'
IF adres%=>&H9000
SUB adres%,&H1000
ENDIF
'
$S& S>
SELECT adres%
CASE &H8000                   ! On/Off :-)
'
' 3f? ofzo? geen id.
'
CASE &H8800 TO &H889F         ! Wave-Pattern
'
dummy%=SUB(adres%,&H8800)
'
konami_scc_wave|(SHR(dummy%,5),AND(dummy%,31))=data&
'
CASE &H8880 TO &H8889         ! Frequenties
'
dummy&=SHR(SUB(adres%,&H8880),1) !Channel Nr.
'
IF AND(adres%,1)        ! MSB
'
konami_scc_freq%(dummy&)=ADD(BYTE(konami_scc_freq%(dummy&)),SHL(data&,8))
'
freq=CFLOAT(111760)/CFLOAT(konami_scc_freq%(dummy&))
' Speel toon af (NU PAS!)
' if scc_plus!
' doe gewoon 't 5e kanaal met eigen wave
' else
' channel 5 = channel 4 [wave]
' endif
'
ELSE                     ! LSB
'
konami_scc_freq%(dummy&)=ADD(AND(konami_scc_freq%(dummy&),&HFF00),data&)
'
ENDIF
'
CASE &H888A TO &H888E         ! Volume
'
dummy&=ADD(SUB(adres%,&H888A),konami_scc_midi_channel&)
'
LET data&=AND(data&,15)
konami_scc_volume|(dummy&)=data&
IF data&
' set volume
ELSE
OUT 3,BYTE(dummy&),0,0                                        ! Note OFF
ENDIF
'
CASE &H888F                   ! Channel-Select
'
konami_scc_channels&=data&
'
FOR dummy&=0 TO 4   ! Check if any channels must switched off
'
IF BTST(konami_scc_channels&,dummy&)
OUT 3,BYTE(ADD(dummy&,konami_scc_midi_channel&)),0,0          ! NOTE OFF
ENDIF
'
NEXT dummy&
'
DEFAULT
'
error_exit&=err_internal_error&
'
ENDSELECT
$S% S>
'
RETURN
' #Do FM-Pac-emulation:
> FUNCTION r.emulate_fm_pac(adres%)       ! Emulate FM-Pac
$F%
'
$S& S>
SELECT adres%
CASE &H5FFE
RETURN fmpac_0x5ffe&
CASE &H5FFF
RETURN fmpac_0x5fff&
CASE &H7FF6
RETURN fmpac_0x7ff6&
ENDSELECT
$S% S>
'
RETURN -1
'
ENDFUNC
> PROCEDURE w.emulate_fm_pac(adres%,data&)! Emulate FM-Pac
'
IF fm_pac_ram!
'
IF AND(AND(adres%=>&H4000,adres%<&H5FFF),slot_sel&(1)=fm_pac_slot&)
'
$S& S>
SELECT adres%
CASE &H5FFE
fmpac_0x5ffe&=data&
CASE &H5FFF
fmpac_0x5fff&=data&
CASE &H7FF6
fmpac_0x7ff6&=data&
ENDSELECT
$S% S>
'
fmpac_ram!=AND(AND(fmpac_0x5ffe&=&H4D,fmpac_0x5fff&=&H69),fmpac_0x7ff6&<=&H1)
'
ENDIF
'
ENDIF
'
RETURN
' Add key to keyboard-buffer:
'
' ***** VDP-Commands: *****
'
$P<
> PROCEDURE pset                          ! Set Point
'
SELECT video_mode&
CASE screen_0a&,screen_0b&,screen_1&      ! Do Nothing
'
error_exit&=err_vdp_illegal_mode&
'
CASE screen_2&,screen_3&,screen_4&        ! Not implemented yet
'
CASE screen_5&
'
@pset5(x&,y&,c&,op&)
'
CASE screen_6&
'
@pset6(x&,y&,c&,op&)
'
CASE screen_7&
'
@pset7(x&,y&,c&,op&)
'
CASE screen_8&
'
@pset8(x&,y&,c&,op&)
'
DEFAULT
'
error_exit&=err_unknown_vdp_mode&
'
ENDSELECT     ! VDP-Mode
'
RETURN
$P>
> PROCEDURE pset5(x&,y&,c&,op&)
'
pset_dummy%=ADD(SHL(y&,7),x&)              ! 2pixels/byte
ADD pset_dummy%,vdp_pattern_name_tabel%
IF mem_sel!
ADD pset_dummy%,msx._video._ram.%
ELSE
ADD pset_dummy%,msx_video_ram%
ENDIF
'
dummy&=BYTE{pset_dummy%}
dummy!=AND(x&,1)
IF dummy!
old&=AND(dummy&,15)
ELSE
old&=SHR(dummy&,4)
ENDIF
'
IF op&=>&X1000                ! Txx(x)
IF c&
op&=AND(op&,&X111)
ENDIF
ENDIF
'
$S& S>
SELECT op&
CASE &X0                      ! IMP  0000 DC=SC
old&=c&
CASE &X1                      ! AND  0001 DC=SC*DC
old&=AND(old&,c&)
CASE &X10                     ! OR   0010 DC=_SC_+DC
old&=OR(old&,c&)
CASE &X11                     ! EOR  0011 DC=_SC_*DC+SC*ÿDCÿ
old&=XOR(old&,c&)
CASE &X100                    ! NOT  0100 DC=ÿSCÿ
old&=BYTE(NOT c&)
CASE &X101 TO &X111           ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
CASE &X1101 TO &X1111         ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
'  DEFAULT
'    Txx(x): SC=0
ENDSELECT
$S% S<
'
IF dummy!
BYTE{pset_dummy%}=ADD(AND(dummy&,&X11110000),old&)
ELSE
BYTE{pset_dummy%}=ADD(AND(dummy&,&X1111),SHL(old&,4))
ENDIF
PSET x&,y&,old&
'
RETURN
> PROCEDURE pset6(x&,y&,c&,op&)
'
pset_dummy%=ADD(SHL(y&,7),x&)              ! 4pixels/byte
ADD pset_dummy%,vdp_pattern_name_tabel%
IF mem_sel!
ADD pset_dummy%,msx._video._ram.%
ELSE
ADD pset_dummy%,msx_video_ram%
ENDIF
'
IF op&=>&X1000                ! Txx(x)
IF c&
op&=AND(op&,&X111)
ENDIF
ENDIF
'
$S& S>
SELECT op&
CASE &X0                      ! IMP  0000 DC=SC
old&=c&
CASE &X1                      ! AND  0001 DC=SC*DC
old&=AND(old&,c&)
CASE &X10                     ! OR   0010 DC=_SC_+DC
old&=OR(old&,c&)
CASE &X11                     ! EOR  0011 DC=_SC_*DC+SC*ÿDCÿ
old&=XOR(old&,c&)
CASE &X100                    ! NOT  0100 DC=ÿSCÿ
old&=BYTE(NOT c&)
CASE &X101 TO &X111           ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
CASE &X1101 TO &X1111         ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
'  DEFAULT
'    Txx(x): SC=0
ENDSELECT
$S% S<
'
PSET x&,y&,old&
'
RETURN
> PROCEDURE pset7(x&,y&,c&,op&)
'
pset_dummy%=ADD(SHL(y&,8),x&)              ! 2pixels/byte
ADD pset_dummy%,vdp_pattern_name_tabel%
IF mem_sel!
ADD pset_dummy%,msx._video._ram.%
ELSE
ADD pset_dummy%,msx_video_ram%
ENDIF
'
dummy&=BYTE{pset_dummy%}
dummy!=AND(x&,1)
IF dummy!
old&=AND(dummy&,15)
ELSE
old&=SHR(dummy&,4)
ENDIF
'
IF op&=>&X1000                ! Txx(x)
IF c&
op&=AND(op&,&X111)
ENDIF
ENDIF
'
$S& S>
SELECT op&
CASE &X0                      ! IMP  0000 DC=SC
old&=c&
CASE &X1                      ! AND  0001 DC=SC*DC
old&=AND(old&,c&)
CASE &X10                     ! OR   0010 DC=_SC_+DC
old&=OR(old&,c&)
CASE &X11                     ! EOR  0011 DC=_SC_*DC+SC*ÿDCÿ
old&=XOR(old&,c&)
CASE &X100                    ! NOT  0100 DC=ÿSCÿ
old&=BYTE(NOT c&)
CASE &X101 TO &X111           ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
CASE &X1101 TO &X1111         ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
'  DEFAULT
'    Txx(x): SC=0
ENDSELECT
$S% S<
'
IF dummy!
BYTE{pset_dummy%}=ADD(AND(dummy&,&X11110000),old&)
ELSE
BYTE{pset_dummy%}=ADD(AND(dummy&,&X1111),SHL(old&,4))
ENDIF
PSET x&,y&,old&
'
RETURN
> PROCEDURE pset8(x&,y&,c&,op&)
'
pset_dummy%=ADD(SHL(y&,8),x&)              ! 1pixel/byte
ADD pset_dummy%,vdp_pattern_name_tabel%
IF mem_sel!
ADD pset_dummy%,msx._video._ram.%
ELSE
ADD pset_dummy%,msx_video_ram%
ENDIF
'
old&=BYTE{pset_dummy%}
'
IF op&=>&X1000                ! Txx(x)
IF c&
op&=AND(op&,&X111)
ENDIF
ENDIF
'
$S& S>
SELECT op&
CASE &X0                      ! IMP  0000 DC=SC
old&=c&
CASE &X1                      ! AND  0001 DC=SC*DC
old&=AND(old&,c&)
CASE &X10                     ! OR   0010 DC=_SC_+DC
old&=OR(old&,c&)
CASE &X11                     ! EOR  0011 DC=_SC_*DC+SC*ÿDCÿ
old&=XOR(old&,c&)
CASE &X100                    ! NOT  0100 DC=ÿSCÿ
old&=BYTE(NOT c&)
CASE &X101 TO &X111           ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
CASE &X1101 TO &X1111         ! -> Unknown <-
error_exit&=err_unknown_vdp_l.operation&
'  DEFAULT
'    Txx(x): SC=0
ENDSELECT
$S% S<
'
BYTE{pset_dummy%}=old&
PSET x&,y&,old&
'
RETURN
> PROCEDURE t_pset(x&,y&,r&,g&,b&)         ! 24 bit
LOCAL lus&,diff%,index&,cdiff%,ws_x&,ws_y&
'
IF colors!
'
IF truecolor!                       ! True Color mode: just set point
'
' pset x,y [r,g,b]
'
ELSE                                ! Palet-mode: Search best matching color
'
diff%=2^31-1
CLR index&
FOR lus&=255 DOWNTO 0
'
cdiff%=ADD(ADD(SUB(r&,pal|(lus&,0))^2,SUB(g&,pal|(lus&,1))^2),SUB(b&,pal|(lus&,2))^2)
IF cdiff%<diff%
diff%=cdiff%
index&=lus&
EXIT IF cdiff%=0
ENDIF
'
NEXT lus&
'
PSET x&,y&,index&
'
ENDIF
'
ELSE
'
ws_x&=SHL(x&,1)                     ! Nieuwe X (x2)
ws_y&=DIV(MUL(y&,399),211)          ! Nieuwe Y (x399/211)
'
PSET ADD(ws_x&,0),ADD(ws_y&,0),SHR(r&,7)                        ! x+0,y+0 = R
PSET ADD(ws_x&,1),ADD(ws_y&,0),SHR(g&,7)                        ! x+1,y+0 = G
PSET ADD(ws_x&,0),ADD(ws_y&,1),SHR(b&,7)                        ! x+0,y+1 = B
PSET ADD(ws_x&,1),ADD(ws_y&,1),SHR(DIV(ADD(ADD(r&,g&),b&),3),7) ! x+1,y+1 = gray
'
ENDIF
'
RETURN
> PROCEDURE line(x1&,y1&,dx&,dy&,c&,op&)   ! Line
'
x2&=ADD(x1&,dx&)              ! Calculate dest. point
y2&=ADD(y1&,dy&)
'
IF x1&>x2&                    ! Swap x & y if needed
SWAP x1&,x2&
ENDIF
IF y1&>y2&                    !
SWAP y1&,y2&
ENDIF
'
incr1&=SHL(dy&,1)
incr2&=SHL(SUB(dy&,dx&),1)
'
d&=SUB(incr1&,dx&)
'
DO
'
$S& S>
SELECT video_mode&
CASE screen_0a&,screen_0b&,screen_1&
'
error_exit&=err_vdp_illegal_mode&
'
CASE screen_2&,screen_3&,screen_4&
'
' not implemented yet
'
CASE screen_5&
'
@pset5(x&,y&,c&,op&)
'
CASE screen_6&
'
@pset6(x&,y&,c&,op&)
'
CASE screen_7&
'
@pset7(x&,y&,c&,op&)
'
CASE screen_8&
'
@pset8(x&,y&,c&,op&)
'
DEFAULT
'
error_exit&=err_unknown_vdp_mode&
'
ENDSELECT
$S% S>
'
INC x1&
'
IF d&<0
'
ADD d&,incr1&
'
ELSE
'
INC y1&
ADD d&,incr2&
'
ENDIF
'
LOOP WHILE x1&<x2&
'
RETURN
> PROCEDURE search_color(x&,y&,d!,c&,mode!)! Search Point
'
' get adress
'
CLR dummy!,vdp_bd!
$S& S>
SELECT video_mode&
CASE screen_0a&,screen_0b&,screen_1&
error_exit&=err_vdp_illegal_mode&
CASE screen_2&,screen_4&,screen_5&,screen_8&
max&=256
CASE screen_3&
max&=64
CASE screen_6&,screen_7&
max&=512
ENDSELECT
$S% S>
'
IF mode!                                      ! ** Do While Same **
'
DO WHILE @ptst(x&,y&)=c&
'
IF d!
INC x&
dummy!=(x&=max&)
ELSE
DEC x&
dummy!=(x&=-1)
ENDIF
'
LOOP UNTIL dummy!
'
IF NOT dummy!
vdp_bd!=@ptst(x&,y&)<>c&
ENDIF
'
ELSE                                          ! ** Do While Diff **
'
DO WHILE @ptst(x&,y&)<>c&
'
IF d!
INC x&
dummy!=(x&=max&)
ELSE
DEC x&
dummy!=(x&=-1)
ENDIF
'
LOOP UNTIL dummy!
'
IF NOT dummy!
vdp_bd!=@ptst(x&,y&)=c&
ENDIF
'
ENDIF
'
IF NOT dummy!
vdp_bd&=x&
ENDIF
'
RETURN
> FUNCTION ptst(x&,y&)
'
' met adres enzo
'
SELECT video_mode&
ENDSELECT
'
ENDFUNC
$P<
> PROCEDURE set_res                       ! Switch screen to new MSX-Res
'
DEFFILL 0                     ! CLS :-)
COLOR 0
PBOX 0,0,319,399
COLOR 1
'
$S& S<
SELECT msx_vdp_mode&      ! m5 m4 m3 m2 m1
CASE &X1                  ! 0  0  0  0  1             SCREEN 0, 40 kolommen
'
video_mode&=screen_0a&
'
vdp_pattern_name_tabel%=&H0
vdp_pattern_name_tabel_end%=vdp_pattern_name_tabel%+40*24-1
vdp_palette_tabel%=&H400
vdp_palette_tabel_end%=vdp_palette_tabel%+16*2-1
IF fast_screen_0!
vdp_pattern_generator_tabel%=-1
vdp_pattern_generator_end_tabel%=-1
ELSE
vdp_pattern_generator_tabel%=&H800
vdp_pattern_generator_end_tabel%=vdp_pattern_generator_tabel%+256*8-1
ENDIF
'
CASE &X1001                 ! 0  1  0  0  1             SCREEN 0, 80 kolommen
'
CLS
video_mode&=screen_0b&
'
CASE &X0                    ! 0  0  0  0  0             SCREEN 1
'
video_mode&=screen_1&
'
vdp_pattern_name_tabel%=&H1800
vdp_pattern_name_tabel_end%=vdp_pattern_name_tabel%+32*24-1
vdp_palette_tabel%=&H800
vdp_palette_tabel_end%=vdp_palette_tabel%+16*2-1
IF fast_screen_1!
vdp_pattern_generator_tabel%=-1
vdp_pattern_generator_end_tabel%=-1
ELSE
vdp_pattern_generator_tabel%=&H0
vdp_pattern_generator_end_tabel%=vdp_pattern_generator_tabel%+256*8-1
ENDIF
'
CASE &X100,&X1000           ! 0  01 10 0  0           SCREEN 2 / SCREEN 4
'
video_mode&=screen_2&
'
vdp_pattern_name_tabel%=&H1800
vdp_pattern_name_tabel_end%=vdp_pattern_name_tabel%+32*24-1
vdp_palette_tabel%=&H800
vdp_palette_tabel_end%=vdp_palette_tabel%+16*2-1
vdp_pattern_generator_tabel%=&H0
vdp_pattern_generator_end_tabel%=vdp_pattern_generator_tabel%+256*8-1
vdp_color_table%=&H2000
vdp_color_table_end%=vdp_color_table%+1024*6-1
'
FOR vdp_dummy%=vdp_pattern_name_tabel% TO vdp_pattern_name_tabel_end%
BYTE{ADD(msx_video_ram%,vdp_dummy%)}=BYTE(vdp_dummy%)
NEXT vdp_dummy%
'
CASE &X10                   ! 0  0  0  1  0           SCREEN 3
'
video_mode&=screen_3&
'
'                         ! 0  1  0  0  0   -->     SCREEN 4  zie: SCREEN 2
'
CASE &X1100                 ! 0  1  1  0  0           SCREEN 5
'
video_mode&=screen_5&
'
vdp_pattern_name_tabel%=&H0
vdp_pattern_name_tabel_end%=&H6A00-1
'
CASE &X10000                ! 1  0  0  0  0           SCREEN 6
'
CLS
video_mode&=screen_6&
'
'
CASE &X10100                ! 1  0  1  0  0           SCREEN 7
'
CLS
video_mode&=screen_7&
'
'
CASE &X11100                ! 1  1  1  0  0           SCREEN 8
'
video_mode&=screen_8&
'
vdp_pattern_name_tabel%=&H0
vdp_pattern_name_tabel_end%=vdp_pattern_name_tabel%+256*212-1
'
DEFAULT
'
error_exit&=err_unknown_vdp_mode&
'
ENDSELECT
$S% S>
'
PRINT AT(1,max_row&);BIN$(msx_vdp_mode&,5),video_mode&;"K";
'
IF colors!
IF video_mode&=screen_8&
'
FOR dummy2&=0 TO 255
'
SETCOLOR dummy2&,SHR(dummy2&,5),AND(SHR(dummy2&,2),&X111),AND(dummy2&,&X11)
'
NEXT dummy2&
'
ELSE
'
SETCOLOR 0,0,0,0!      <- Used for digitizing
SETCOLOR 1,0,0,0
SETCOLOR 2,1,6,1
SETCOLOR 3,3,7,3
SETCOLOR 4,1,1,7
SETCOLOR 5,2,3,7
SETCOLOR 6,5,1,1
SETCOLOR 7,2,6,7
SETCOLOR 8,7,1,1
SETCOLOR 9,7,3,3
SETCOLOR 10,6,6,1
SETCOLOR 11,6,6,4
SETCOLOR 12,1,4,1
SETCOLOR 13,6,2,5
SETCOLOR 14,5,5,5
SETCOLOR 15,7,7,7
'
ENDIF
ENDIF
'
@redraw_msx_screen
'
RETURN
> PROCEDURE redraw_msx_screen             ! Updates screen
'
RETURN
'
' *** Disassembler ***
'
$P>
> FUNCTION disassem(pointer%,file&)       ! Show command worked on
$F%
LOCAL command&,word%,dummy$,scnd_byte&,command_length&,dummy&,dummy2&
'
command&=@get_byte(pointer%)
word%=@get_word(SUCC(pointer%))
scnd_byte&=@get_byte(SUCC(pointer%))
'
command_length&=1
'
$S& S<
SELECT command&
CASE &H0                            ! NOP [No Operant]
dummy$="NOP"
CASE &H1                            ! LD BC,nnnn
dummy$="LD BC,"+HEX$(word%,4)
ADD command_length&,2
CASE &H2                            ! LD (BC),A
dummy$="LD (BC),A"
CASE &H3                            ! INC BC
dummy$="INC BC"
CASE &H4                            ! INC B
dummy$="INC B"
CASE &H5                            ! DEC B
dummy$="DEC B"
CASE &H6                            ! LD B,n
dummy$="LD B,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H7                            ! RLC A
dummy$="RLCA"
CASE &H8                            ! EX AF,AF'
dummy$="EX AF,AF'"
CASE &H9                            ! ADD HL,BC
dummy$="ADD HL,BC"
CASE &HA                            ! LD A,(BC)
dummy$="LD A,(BC)"
CASE &HB                            ! DEC BC
dummy$="DEC BC"
CASE &HC                            ! INC C
dummy$="INC C"
CASE &HD                            ! DEC C
dummy$="DEC C"
CASE &HE                            ! LD C,n
dummy$="LD C,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &HF                            ! RRCA
dummy$="RRCA"
CASE &H10                           ! DJNZ e
dummy$="+DJNZ "+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H11                           ! LD DE,nnnn
dummy$="LD DE,"+HEX$(word%,4)
ADD command_length&,2
CASE &H12                           ! LD (DE),A
dummy$="LD (DE),A"
CASE &H13                           ! INC DE
dummy$="INC DE"
CASE &H14                           ! INC D
dummy$="INC D"
CASE &H15                           ! DEC D
dummy$="DEC D"
CASE &H16                           ! LD D,n
dummy$="LD D,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H17                           ! RLA
dummy$="RLA"
CASE &H18                           ! JR e
dummy$="JR "+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H19                           ! ADD HL,DE
dummy$="ADD HL,DE"
CASE &H1A                           ! LD A,(DE)
dummy$="LD A,(DE)"
CASE &H1B                           ! DEC DE
dummy$="DEC DE"
CASE &H1C                           ! INC E
dummy$="INC E"
CASE &H1D                           ! DEC E
dummy$="DEC E"
CASE &H1E                           ! LD E,n
dummy$="LD E,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H1F                           ! RRA
dummy$="RRA"
CASE &H20                           ! JR NZ,e
dummy$="JR NZ,"+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H21                           ! LD HL,nnnn
dummy$="LD HL,"+HEX$(word%,4)
ADD command_length&,2
CASE &H22                           ! LD (nnnn),HL
dummy$="LD ("+HEX$(word%,4)+"),HL"
ADD command_length&,2
CASE &H23                           ! INC HL
dummy$="INC HL"
CASE &H24                           ! INC H
dummy$="INC H"
CASE &H25                           ! DEC H
dummy$="DEC H"
CASE &H26                           ! LD H,n
dummy$="LD H,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H27                           ! DAA
dummy$="DAA"
CASE &H28                           ! JR Z,e
dummy$="JR Z,"+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H29                           ! ADD HL,HL
dummy$="ADD HL,HL"
CASE &H2A                           ! LD HL,(nnnn)
dummy$="LD HL,("+HEX$(word%,4)+")"
ADD command_length&,2
CASE &H2B                           ! DEC HL
dummy$="DEC HL"
CASE &H2C                           ! INC L
dummy$="INC L"
CASE &H2D                           ! DEC L
dummy$="DEC L"
CASE &H2E                           ! LD L,n
dummy$="LD L,"+HEX$(scnd_byte&)
INC command_length&
CASE &H2F                           ! CPL
dummy$="CPL"
CASE &H30                           ! JR NC,e
dummy$="JR NC,"+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H31                           ! LD SP,nnnn
dummy$="LD SP,"+HEX$(word%,4)
ADD command_length&,2
CASE &H32                           ! LD (nnnn),A
dummy$="LD ("+HEX$(word%,4)+"),A"
ADD command_length&,2
CASE &H33                           ! INC SP
dummy$="INC SP"
CASE &H34                           ! INC (HL)
dummy$="INC (HL)"
CASE &H35                           ! DEC (HL)
dummy$="DEC (HL)"
CASE &H36                           ! LD (HL),n
dummy$="LD (HL),"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H37                           ! SCF
dummy$="SCF"
CASE &H38                           ! JR C,e
dummy$="JR C,"+@jr$(pointer%,scnd_byte&)
INC command_length&
CASE &H39                           ! ADD HL,SP
dummy$="ADD HL,SP"
CASE &H3A                           ! LD A,(nnnn)
dummy$="LD A,("+HEX$(word%,4)+")"
ADD command_length&,2
CASE &H3B                           ! DEC SP
dummy$="DEC SP"
CASE &H3C                           ! INC A
dummy$="INC A"
CASE &H3D                           ! DEC A
dummy$="DEC A"
CASE &H3E                           ! LD A,n
dummy$="LD A,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &H3F                           ! CCF
dummy$="CCF"
CASE &H40 TO &H7F
'
SELECT SHR(SUB(command&,&H40),3)
CASE 0
dummy$="LD B,"
CASE 1
dummy$="LD C,"
CASE 2
dummy$="LD D,"
CASE 3
dummy$="LD E,"
CASE 4
dummy$="LD H,"
CASE 5
dummy$="LD L,"
CASE 6
dummy$="LD (HL),"
CASE 7
dummy$="LD A,"
ENDSELECT
'
IF command&=&H76
dummy$="HALT"
ELSE
dummy$=dummy$+@reg$(command&)
ENDIF
'
CASE &H80 TO &HBF
'
SELECT command&
CASE &H80 TO &H87
dummy$="ADD A,"
CASE &H88 TO &H8F
dummy$="ADC A,"
CASE &H90 TO &H97
dummy$="SUB "
CASE &H98 TO &H9F
dummy$="SBC "
CASE &HA0 TO &HA7
dummy$="AND "
CASE &HA8 TO &HAF
dummy$="XOR "
CASE &HB0 TO &HB7
dummy$="OR "
CASE &HB8 TO &HBF
dummy$="CP "
ENDSELECT
'
dummy$=dummy$+@reg$(command&)
'
CASE &HC0                           ! RET NZ
dummy$="RET NZ"
CASE &HC1                           ! POP BC
dummy$="POP BC"
CASE &HC2                           ! JP NZ,nnnn
dummy$="JP NZ,"+HEX$(word%,4)
ADD command_length&,2
CASE &HC3                           ! JP nnnn
dummy$="JP "+HEX$(word%,4)
ADD command_length&,2
CASE &HC5                           ! PUSH BC
dummy$="PUSH BC"
CASE &HC6                           ! ADD A,n
dummy$="ADD A,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &HC7                           ! RST 00H
dummy$="RST 00H"
CASE &HC8                           ! RET Z
dummy$="RET Z"
CASE &HC9                           ! RET
dummy$="RET"
CASE &HCA                           ! JP Z,nnnn
dummy$="JP Z,"+HEX$(word%,4)
ADD command_length&,2
CASE &HCB
@diss_cb
CASE &HCC                           ! CALL Z,nnnn
dummy$="CALL Z,"+HEX$(word%,4)
ADD command_length&,2
CASE &HCD                           ! CALL nnnn
dummy$="CALL "+HEX$(word%,4)
ADD command_length&,2
CASE &HCE                           ! ADC A,n
dummy$="ADC A,"+HEX$(scnd_byte&,2)
INC command_length&
CASE &HCF                           ! RST 08H
dummy$="RST 08H"
CASE &HD0                           ! RET NC
dummy$="RET NC"
CASE &HD1                           ! POP DE
dummy$="POP DE"
CASE &HD2                           ! JP NC,nnnn
dummy$="JP NC,"+HEX$(word%,4)
ADD command_length&,2
CASE &HD3                           ! OUT n,A
dummy$="OUT ("+HEX$(scnd_byte&,2)+"),A"
INC command_length&
CASE &HD4                           ! CALL NC,nnnn
dummy$="CALL NC,"+HEX$(word%,4)
ADD command_length&,2
CASE &HD5                           ! PUSH DE
dummy$="PUSH DE"
CASE &HD6                           ! SUB n
dummy$="SUB "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HD7                           ! RST 10H
dummy$="RST 10H"
CASE &HD8                           ! RET C
dummy$="RET C"
CASE &HD9                           ! EXX
dummy$="EXX"
CASE &HDA                           ! JP C,nnnn
dummy$="JP C,"+HEX$(word%,4)
ADD command_length&,2
CASE &HDB                           ! IN A,(n)
dummy$="IN A,("+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &HDD
@diss_dd_fd("IX")
CASE &HDE                           ! SBC n
dummy$="SBC "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HDF                           ! RST 18H
dummy$="RST 18H"
CASE &HE0                           ! RET PO
dummy$="RET PO"
CASE &HE1                           ! POP HL
dummy$="POP HL"
CASE &HE2                           ! JP PO,nnnn
dummy$="JP PO,"+HEX$(word%,4)
ADD command_length&,2
CASE &HE3                           ! EX (SP),HL
dummy$="EX (SP),HL"
CASE &HE4                           ! CALL PO,nnnn
dummy$="CALL PO,"+HEX$(word%,4)
ADD command_length&,2
CASE &HE5                           ! PUSH HL
dummy$="PUSH HL"
CASE &HE6                           ! AND n
dummy$="AND "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HE7                           ! RST 20H
dummy$="RST 20H"
CASE &HE9                           ! JP (HL)
dummy$="JP (HL)"
CASE &HEA                           ! JP PE,nnnn
dummy$="JP PE,"+HEX$(word%,4)
ADD command_length&,2
CASE &HEB                           ! EX DE,HL
dummy$="EX DE,HL"
CASE &HED
@diss_ed
CASE &HEE                           ! XOR n
dummy$="XOR "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HEF                           ! RST 28H
dummy$="RST 28H"
CASE &HF0                           ! RET P
dummy$="RET P"
CASE &HF1                           ! POP AF
dummy$="POP AF"
CASE &HF2                           ! JP P,nnnn
dummy$="JP P,"+HEX$(word%,4)
ADD command_length&,2
CASE &HF3                           ! DI [Disable Interrupts]
dummy$="DI"
CASE &HF4                           ! CALL P,nnnn
dummy$="CALL P,"+HEX$(word%,4)
ADD command_length&,2
CASE &HF5                           ! PUSH AF
dummy$="PUSH AF"
CASE &HF6                           ! OR n
dummy$="OR "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HF7                           ! RST 30H
dummy$="RST 30H"
CASE &HF8                           ! RET M
dummy$="RET M"
CASE &HF9                           ! LD SP,HL
dummy$="LD SP,HL"
CASE &HFA                           ! JP M,nnnn
dummy$="JP M,"+HEX$(word%,4)
ADD command_length&,2
CASE &HFB                           ! EI [Enable Interrupts]
dummy$="EI"
CASE &HFC                           ! CALL M,nnnn
dummy$="CALL M,"+HEX$(word%,4)
ADD command_length&,2
CASE &HFD
@diss_dd_fd("IY")
CASE &HFE                           ! CP n
dummy$="CP "+HEX$(scnd_byte&,2)
INC command_length&
CASE &HFF                           ! RST 38H
dummy$="RST 38H"
DEFAULT
dummy$="-Unknown--> "+HEX$(command&,2)
ENDSELECT
$S% S>
'
IF file&=-1
INC disassem_cnt&
IF disassem_cnt&=25
disassem_cnt&=1
ENDIF
PRINT AT(62,disassem_cnt&);HEX$(pointer%,4);" ";dummy$;" [";command_length&;"]";AT(62,SUCC(disassem_cnt&));"K";
ELSE
IF EVEN(pointer%)
PRINT AT(1,max_row&);HEX$(pointer%,4);
ENDIF
PRINT #file&,HEX$(pointer%,4);" ";dummy$;" ";
FOR lus&=0 TO PRED(command_length&)
PRINT #file&," ";HEX$(@get_byte(ADD(pointer%,lus&)),2);
NEXT lus&
PRINT #file&
ENDIF
'
RETURN command_length&
'
ENDFUNC
> PROCEDURE diss_dd_fd(reg$)
'
INC command_length&
sub_command&=scnd_byte&
word%=@get_word(ADD(pointer%,2))
scnd_byte&=@get_byte(ADD(pointer%,2))
'
$S& S<
SELECT sub_command&
CASE &H9                          ! ADD I[X|Y],BC
dummy$="ADD "+reg$+",BC"
CASE &H19                         ! ADD I[X|Y],DE
dummy$="ADD "+reg$+",DE"
CASE &H21                         ! LD I[X|Y],nnnn
dummy$="LD "+reg$+","+HEX$(word%,4)
ADD command_length&,2
CASE &H22                         ! LD (nnnn),I[X|Y]
dummy$="LD ("+HEX$(word%,4)+"),"+reg$
ADD command_length&,2
CASE &H23                         ! INC I[X|Y]
dummy$="INC "+reg$
CASE &H29                         ! ADD I[X|Y],I[X|Y]
dummy$="ADD "+reg$+","+reg$
CASE &H2A                         ! LD I[X|Y],(nnnn)
dummy$="LD "+reg$+",("+HEX$(word%,4)+")"
ADD command_length&,2
CASE &H2B                         ! DEC I[X|Y]
dummy$="DEC "+reg$
CASE &H34                         ! INC (I[X|Y]+d)
dummy$="INC ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H35                         ! DEC (I[X|Y]+d)
dummy$="DEC ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H36                         ! LD (I[X|Y]+d),n
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),"+HEX$(@get_byte(ADD(pointer%,3)),2)
ADD command_length&,2
CASE &H39                         ! ADD I[X|Y],SP
dummy$="ADD "+reg$+",SP"
CASE &H46                         ! LD B,(I[X|Y]+d)
dummy$="LD B,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H4E                         ! LD C,(I[X|Y]+d)
dummy$="LD C,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H56                         ! LD D,(I[X|Y]+d)
dummy$="LD D,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H5E                         ! LD E,(I[X|Y]+d)
dummy$="LD E,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H66                         ! LD H,(I[X|Y]+d)
dummy$="LD H,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H6E                         ! LD L,(I[X|Y]+d)
dummy$="LD L,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H70                         ! LD (I[X|Y]+d),B
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),B"
INC command_length&
CASE &H71                         ! LD (I[X|Y]+d),C
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),C"
INC command_length&
CASE &H72                         ! LD (I[X|Y]+d),D
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),D"
INC command_length&
CASE &H73                         ! LD (I[X|Y]+d),E
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),E"
INC command_length&
CASE &H74                         ! LD (I[X|Y]+d),H
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),H"
INC command_length&
CASE &H75                         ! LD (I[X|Y]+d),L
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),L"
INC command_length&
CASE &H77                         ! LD (I[X|Y]+d),A
dummy$="LD ("+reg$+"+"+HEX$(scnd_byte&,2)+"),A"
INC command_length&
CASE &H7C                         ! LD A,I[X|Y]h          **
dummy$="@LD A,"+reg$+"h"
CASE &H7D                         ! LD A,I[X|Y]l          **
dummy$="@LD A,"+reg$+"l"
CASE &H7E                         ! LD A,(I[X|Y]+d)
dummy$="LD A,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H86                         ! ADD A,(I[X|Y]+d)
dummy$="ADD A,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H8E                         ! ADC A,(I[X|Y]+d)
dummy$="ADC A,("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H96                         ! SUB (I[X|Y]+d)
dummy$="SUB ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &H9E                         ! SBC (I[X|Y]+d)
dummy$="SBC ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &HA6                         ! AND (I[X|Y]+d)
dummy$="AND ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &HAE                         ! XOR (I[X|Y]+d)
dummy$="XOR ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &HB6                         ! OR (I[X|Y]+d)
dummy$="OR ("+reg$+"+"+HEX$(scnd_byte&,2)+")"
INC command_length&
CASE &HCB
@diss_dd_fd.cb(reg$)
CASE &HE1                         ! POP I[X|Y]
dummy$="POP "+reg$
CASE &HE3                         ! EX (SP),I[X|Y]
dummy$="EX (SP),"+reg$
CASE &HE5                         ! PUSH I[X|Y]
dummy$="PUSH "+reg$
CASE &HE9                         ! JP (I[X|Y])
dummy$="JP ("+reg$+")"
CASE &HF9                         ! LD SP,I[X|Y]
dummy$="LD SP,"+reg$
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE diss_dd_fd.cb(reg$)
'
ADD command_length&,2
'
dummy$="("+reg$+"+"+HEX$(@get_byte(ADD(pointer%,3)),2)+")"
'
$S& S<
SELECT scnd_byte&
CASE &H6                      ! RLC (I[X|Y]+d)
dummy$="RLC "+dummy$
CASE &H16                     ! RL (I[X|Y]+d)
dummy$="RL "+dummy$
CASE &H26                     ! SLA (I[X|Y]+d)
dummy$="SLA "+dummy$
CASE &H2E                     ! SRA (I[X|Y]+d)
dummy$="SRA "+dummy$
CASE &H3E                     ! SRL (I[X|Y]+d)
dummy$="SRL "+dummy$
'
CASE &H46 TO &H7E
'
dummy$="BIT "+STR$(SHR(SUB(scnd_byte&,&H40),3))+","+dummy$
'
CASE &H86 TO &HBE
'
dummy$="RES "+STR$(SHR(SUB(scnd_byte&,&H40),3))+","+dummy$
'
CASE &HC6 TO &HFE
'
dummy$="SET "+STR$(SHR(SUB(scnd_byte&,&H40),3))+","+dummy$
'
ENDSELECT
$S% S>
'
RETURN
> FUNCTION jr$(pointer%,data&)            ! ...jr
'
IF data&>127
RETURN HEX$(pointer%+2-(256-data&),4)
ELSE
RETURN HEX$(pointer%+2+data&,4)
ENDIF
'
ENDFUNC
> FUNCTION reg$(byte&)
'
$S& S<
SELECT AND(byte&,7)
CASE 0 TO 3   ! B, C, D & E
'
RETURN CHR$(ADD(66,AND(byte&,7)))
'
CASE 4
'
RETURN "H"
'
CASE 5
'
RETURN "L"
'
CASE 6
'
RETURN "(HL)"
'
CASE 7
'
RETURN "A"
'
ENDSELECT
$S% S>
'
ENDFUNC
$P<
> PROCEDURE diss_cb
'
INC command_length&
'
$S& S<
SELECT scnd_byte&
CASE 0 TO &H3F
'
SELECT scnd_byte&
CASE &H0 TO &H7
dummy$="RLC "
CASE &H8 TO &HF
dummy$="RRC "
CASE &H10 TO &H17
dummy$="RL "
CASE &H18 TO &H1F
dummy$="RR "
CASE &H20 TO &H27
dummy$="SLA "
CASE &H28 TO &H2F
dummy$="SRA "
CASE &H30 TO &H37
dummy$="SLL "
CASE &H38 TO &H3F
dummy$="SRL "
ENDSELECT
'
dummy$=dummy$+@reg$(scnd_byte&)
'
CASE &H40 TO &HFF                     ! BIT x,
'
SELECT scnd_byte&
CASE &H40 TO &H7F
dummy&=SUB(scnd_byte&,&H40)
dummy$="BIT "
CASE &H80 TO &HBF
dummy&=SUB(scnd_byte&,&H80)
dummy$="RES "
CASE &HC0 TO &HFF
dummy&=SUB(scnd_byte&,&HC0)
dummy$="SET "
ENDSELECT
'
dummy$=dummy$+STR$(SHR(dummy&,3))+","+@reg$(dummy&)
'
ENDSELECT
$S% S>
'
RETURN
> PROCEDURE diss_ed
'
INC command_length&
sub_command&=scnd_byte&
word%=@get_word(ADD(pointer%,2))
scnd_byte&=@get_byte(ADD(pointer%,2))
'
$S& S<
SELECT sub_command&
CASE &H40                             ! IN B,(C)
dummy$="IN B,(C)"
CASE &H41                             ! OUT (C),B
dummy$="OUT (C),B"
CASE &H42                             ! SBC HL,BC
dummy$="SBC HL,BC"
CASE &H43                             ! LD (nnnn),BC
dummy$="LD ("+HEX$(word%,4)+"),BC"
ADD command_length&,2
CASE &H44                             ! NEG
dummy$="NEG"
CASE &H45                             ! RETN
dummy$="RETN"
CASE &H46                             ! IM 0
dummy$="IM 0"
CASE &H47                             ! LD I,A
dummy$="LD I,A"
CASE &H48                             ! IN C,(C)
dummy$="IN C,(C)"
CASE &H49                             ! OUT (C),C
dummy$="OUT (C),C"
CASE &H4A                             ! ADC HL,BC
dummy$="ADC HL,BC"
CASE &H4B                             ! LD BC,(nnnn)
dummy$="LD BC,("+HEX$(word%,4)+")"
ADD command_length&,2
CASE &H4D                             ! RETI
dummy$="RETI"
CASE &H4F                             ! LD R,A
dummy$="LD R,A"
CASE &H50                             ! IN D,(C)
dummy$="IN D,(C)"
CASE &H51                             ! OUT (C),D
dummy$="OUT (C),D"
CASE &H52                             ! SBC HL,DE
dummy$="SBC HL,DE"
CASE &H53                             ! LD (nnnn),DE
dummy$="LD ("+HEX$(word%,4)+"),DE"
ADD command_length&,2
CASE &H56                             ! IM 1
dummy$="IM 1"
CASE &H57                             ! LD A,I
dummy$="LD A,I"
CASE &H58                             ! IN E,(C)
dummy$="IN E,(C)"
CASE &H59                             ! OUT (C),E
dummy$="OUT (C),E"
CASE &H5A                             ! ADC HL,DE
dummy$="ADC HL,DE"
CASE &H5B                             ! LD DE,(nnnn)
dummy$="LD DE,("+HEX$(word%,4)+")"
ADD command_length&,2
CASE &H5E                             ! IM 2
dummy$="IM 2"
CASE &H5F                             ! LD A,R
dummy$="LD A,R"
CASE &H60                             ! IN H,(C)
dummy$="IN H,(C)"
CASE &H61                             ! OUT (C),H
dummy$="OUT (C),H"
CASE &H62                             ! SBC HL,HL
dummy$="SBC HL,HL"
CASE &H67                             ! RRD
dummy$="RRD"
CASE &H68                             ! IN L,(C)
dummy$="IN L,(C)"
CASE &H69                             ! OUT (C),L
dummy$="OUT (C),L"
CASE &H6A                             ! ADC HL,HL
dummy$="ADC HL,HL"
CASE &H6F                             ! RLD
dummy$="RLD"
CASE &H70                             ! IN (HL),(C)    **
dummy$="@IN (HL),(C)"
CASE &H71                             ! OUT (C),(HL)   **
dummy$="@OUT (C),(HL)"
CASE &H72                             ! SBC HL,SP
dummy$="SBC HL,SP"
CASE &H73                             ! LD (nnnn),SP
dummy$="LD ("+HEX$(word%,4)+"),SP"
ADD command_length&,2
CASE &H78                             ! IN A,(C)
dummy$="IN A,(C)"
CASE &H79                             ! OUT (C),A
dummy$="OUT (C),A"
CASE &H7A                             ! ADC HL,SP
dummy$="ADC HL,SP"
CASE &H7B                             ! LD SP,(nnnn)
dummy$="LD SP,("+HEX$(word%)+")"
ADD command_length&,2
CASE &H8B                             ! OTDR
dummy$="OTDR"
CASE &HA2                             ! INI
dummy$="INI"
CASE &HA3                             ! OUTI
dummy$="OUTI"
CASE &HAA                             ! IND
dummy$="IND"
CASE &HAB                             ! OUTD
dummy$="OUTD"
CASE &HB0                             ! LDIR               [ Block Move ]
dummy$="LDIR"
CASE &HB2                             ! INIR
dummy$="INIR"
CASE &HB3                             ! OTIR
dummy$="OUTI"
CASE &HB8                             ! LDDR                [ Block Move ]
dummy$="LDDR"
CASE &HBA                             ! INDR
dummy$="INDR"
ENDSELECT
$S% S>
'
RETURN
