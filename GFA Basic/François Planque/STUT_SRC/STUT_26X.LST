' *****************************************************************************
'
' STUT ONE version 2.6X
' Logiciel Serveur Minitel RTC Monovoie pour ATARI ST/TT
' Copyright (c)1989-1993 by Fran‡ois PLANQUE
'
'  Fran‡ois PLANQUE
'  10, Rue Saint-Louis
'  78760 Jouars-Pontchartrain
'  FRANCE
'   Ne t‚l‚phonnez pas, je suis raremement … la maison, vous d‚rangeriez
'   d'autres personnes qui ne s'int‚ressent pas beaucoup … l'informatique
'   et qui ne pourraient pas vous ˆtre d'une grande utilit‚.
'  Serveur Minitel (L… vous pouvez appeller!) (1)-34.89.29.45
'  Internet: E-Mail: planque@worldnet.net
'               WWW: http://www.univ-compiegne.fr/~planque/fplanque.htm
'
' *****************************************************************************
'
' Si ce logiciel (et en particulier son code source!) vous est utile...
'    ...vos chŠques d'encouragements (mˆme symboliques) sont les bienvenus! :-)
'
' *****************************************************************************
'
' Les conditions d'utilisation et de distribution de la version 2.6X et
' en particulier du code source sont soumises … des conditions sp‚ciales
' ‚nonc‚es ci-dessous et dans la "GNU General Public License". Ces conditions
' diffŠrent des autres versions de STUT ONE.
'
' STUT ONE 2.6X n'est __PAS__ un SHAREWARE.
' STUT ONE 2.6X n'est __PAS__ un FREEWARE.
' STUT ONE 2.6X n'est __PAS__ un DOMAINE PUBLIC.
' STUT ONE 2.6X n'est pas non plus, un programme commercial.
'
' En particulier STUT ONE 2.6X ou TOUTE MODIFICATION OU EVOLUTION de ce
' programme NE PEUT ETRE DIFFUSE SANS LE CODE SOURCE CORRESPONDANT ou sans
' fournir … l'utilisateur un moyen d'acc‚der au code source. De mˆme, les
' termes de la LICENSE et le NOM DE L'AUTEUR (Fran‡ois PLANQUE) DOIVENT
' ETRE CLAIREMENT LISIBLES.
'
' *****************************************************************************
'
' Ce logiciel peut ˆtre utilis‚ librement; vous pouvez le redistribuer et/ou
' le modifier sous les termes de la License Generale Publique de GNU ("GNU
' General Public License") telle qu'elle est publi‚e par la Free Software
' Foundation; soit en appliquant la version 2 de la License, soit (si vous
' pr‚ferrez, toute version ult‚rieure.
'
' Ce programme est distribu‚ avec l'espoir d'ˆtre utile, mais SANS AUCUNE
' GARANTIE; sans mˆme la garantie implicite d'ˆtre COMMERCIALISABLE ou
' d'ˆtre APPROPRIE A UNE UTILISATION PARTICULIERE. R‚f‚rrez vous … la
' "GNU General Public License" pour plus de d‚tails.
'
' Vous devriez avoir re‡u une copie de la "GNU General Public License" avec
' ce programme (fichier LICENSE.TXT); si ce n'est pas le cas, ‚crivez … la
'  Free Software Foundation, Inc
'  675 Mass Ave
'  Cambridge, MA 02139, USA
'
' *****************************************************************************
'
' Ce programme n'est pas toujours programm‚ trŠs proprement, mais je dois dire
' … ma d‚charge que j'‚tais trŠs jeune (1989) quand je l'ai commenc‚ et qu'il
' s'agit l… de mon premier programme de grande taille :-)
' EN TOUT CAS, si quelque chose vous semble suspect et mal ‚crit, c'est
' probablement le cas et vous gagnerez surement … le re-‚crire.
' Ceci n'est pas cens‚ ˆtre un modŠle de programmation, mais une base pour les
' personnes d‚sirant ‚tudier le fonctionnement d'un serveur t‚l‚matique.
'
' *****************************************************************************
'
' Initialisation:
'
DEFMOUSE 2                      ! Abeille
inter!=-1                       ! Mettre … 0 pour compiler, laisser … -1 en interpret‚
erreurs!=-1                     ! -1: tente de r‚cup‚rer les erreurs, 0: laisse planter
version$="2.6x"
vc$="26X"
stut$="STUT_"+vc$+"."           ! Base des noms de fichier.
default_date%=19950726          ! Date de r‚f‚rence pour demande auto
neder_ver$=CHR$(3)+CHR$(0)      ! utilise protocole NEDER version 3.0
IF inter!                       ! Si on tourne sous interpreteur
  CHDRIVE "H"                     ! On change de lecteur
  CHDIR "H:\STUT_2.6\"            ! A MODIFIER POUR QUE CA CORRESPONDE A CHEZ VOUS
ENDIF
path$=CHR$(65+GEMDOS(&H19))+":"+DIR$(0)+"\" ! Path courant au lancement
'
test_rez                        ! R‚solution
present_520_1040                ! Pr‚sentation
init_rs_520_1040                ! Init port s‚rie
'
ch_rsrc_520_1040                ! Chargement du fichier RSC
'
ouvre_def
init_var_global                 ! Init variables globales
init_pages                      ! Pages Vdt,Arbo,Rub,Aff
init_edit_520_1040              ! Variables pour Edition
init_cnx_520_1040               ! Gestion des connexions
init_supp                       ! Variables suppl‚mentaires
ferme_def
'
charge_conf                     ! Charge config
'
init_rs_2                       ! Port s‚rie (2)
~FORM_DIAL(3,0,0,0,0,200,72*rez|+rm|*16,239,57*rez|-9*rm|) ! Efface pr‚sentation
'
' Gestion principale:
'
~MENU_BAR(menu.adr%,1)          ! Affiche menu
'
auto_exec                       ! Ex‚cutions automatiques
'
DEFMOUSE 0
menu_p_520_1040                 ! Gestion menu ppal
'
' Fin:
'
rs_out(rs_out.adr%,256)         ! Tampon de sortie … 256 octets
OUT 1,&H1B,&H5B,&H3F,&H7B       ! Sortie du mode t‚l‚informatique ( au cas ou )
OUT 1,27,57,127                 ! Reset
OUT 1,27,59,97,88,83            ! Inst Pri => Ecr
OUT 1,27,59,97,90,81            ! Inst Clav => Mod
OUT 1,27,59,97,91,81            ! Inst Clav => pri
OUT 1,27,59,97,88,82            ! Inst Mod => Ecr
OUT 1,27,59,105,89,65           ! Clavier etendu
OUT 1,&H1B,&H3A,&H6B,&H64       ! Prise … 1200 Bauds
CLOSE                           ! Ferme tous les fichiers
~MFREE(screen.zone%)            ! LibŠre zone de travail
~RSRC_FREE()                    ! Efface les rsrc en m‚m
RESERVE                         ! Restore m‚moire r‚serv‚e
ON ERROR                        ! Plus de traitement d'erreur
PAUSE 5
~XBIOS(15,7,0,174,-1,-1,-1)     ! RS … 1200 Bauds
EDIT
'
'
' ****************************
' *** Proc‚dures g‚n‚rales ***
' ****************************
> PROCEDURE accent_80(c_a|)
  '
  ' Transforme car sp‚ciaux ST en equ approximatifs au format mixte:
  '
  SELECT c_a|
  CASE 129,150,151                   ! ,–,—
    l1$="u"
  CASE 130,136,137,138,180           ! ‚,ˆ,‰,Š,´
    l1$="e"
  CASE 131,132,133                   ! ƒ,„,…
    l1$="a"
  CASE 135                           ! ‡
    l1$="c"
  CASE 139,140                       ! ‹,Œ
    l1$="i"
  CASE 147,148,221,248               ! “,”,Ý,ø
    l1$="o"
  CASE 156                           ! œ
    l1$="L"
  CASE 158,225                       ! ž,á
    l1$="B"
  CASE 171,172,246                   ! «,¬,ö
    l1$="/"
  CASE 181                           ! µ
    l1$="E"
  CASE 241                           ! ñ
    l1$="~"
  DEFAULT
    l1$="?"
  ENDSELECT
RETURN
> PROCEDURE aes_draw
  ~FORM_CENTER(adr%,x%,y%,w%,h%)
  DEC x%
  DEC y%
  ADD w%,4
  ADD h%,4
  ~FORM_DIAL(0,0,0,0,0,x%,y%,w%,h%)
  ~OBJC_DRAW(adr%,0,7,x%,y%,w%,h%)
RETURN
> PROCEDURE aes_erase
  ~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,0,0)
  ~FORM_DIAL(3,0,0,0,0,x%,y%,w%,h%)
RETURN
> PROCEDURE aff_charsauve
  '
  ' Aff boite de charge/sauve
  '
  set_string(5,"")
  set_string(6,"")
  set_string(10,"")
  set_string(11,"")
  ~FORM_CENTER(fichiers.adr%,x%,y%,w%,h%)
  DEC x%
  DEC y%
  ADD w%,4
  ADD h%,4
  ~FORM_DIAL(0,160,100,0,0,x%,y%,w%,h%)
  ~OBJC_DRAW(fichiers.adr%,0,7,x%,y%,w%,h%) ! Dessine la boite
RETURN
> PROCEDURE aff_page_1(p.page&,interrupt!)
  '
  ' Affichage en 1 bloc
  '
  IF p.page&=>0            ! Si page fond existe
    ptr&=1
    PRINT AT(13,14);"Affichage de la page vid‚otex.      ";
    affiche_vdt(p.page&)
  ENDIF
RETURN
> PROCEDURE affiche_rsc
  '
  ' Gere une boite de dialogue:
  '
  aes_draw
  DEFMOUSE 0
  b%=FORM_DO(adr%,0)
  aes_erase
RETURN
> PROCEDURE affiche_lignes(p.first&)
  '
  ' aff lignes jusqu'… la fin de la fenetre:
  '
  FOR l1&=p.first& TO g7&+19         ! R‚affiche texte
    l1|=-(l1&=>g10& AND l1&<=g11&)        ! Csr dans bloc ou pas
    PRINT AT(p.x_car&,l1&-g7&+5);normal.f$(l1|);editor$(l1&);
  NEXT l1&
  PRINT normal.f$(0);
RETURN
> PROCEDURE affiche_texte
  '
  ' REDRAW text de l'‚diteur GEM:
  '
  pos_asc                               ! Position de ascenseur
  '
  HIDEM
  l.screen.adr%=XBIOS(3)                ! Ecran logique
  '
  ~XBIOS(5,L:screen.adr%,L:-1,L:-1)     ! On va dessiner l'‚cran entier
  no_ligne
  set_insert(l.insert|)
  PBOX l.l_g&,31*rez|,l.r_g&,192*rez|+rm|       ! Efface fenetre
  affiche_lignes(g7&)
  IF l.cursor!                          ! S'il y a un curseur
    affiche_curseur                       ! 520_1040
  ENDIF
  '
  ~XBIOS(5,L:l.screen.adr%,L:-1,L:-1)   ! On va faire le REDRAW
  ~WIND_UPDATE(1)                       ! Bloque liste de rectangles
  ~WIND_UPDATE(3)                       ! Controle souris
  ~WIND_GET(handle%,11,x%,y%,w%,h%)     ! 1er rectangle
  WHILE w%>0 OR h%>0
    RC_COPY screen.adr%,x%,y%,w%,h% TO l.screen.adr%,x%,y%
    ~WIND_GET(handle%,12,x%,y%,w%,h%)
  WEND
  ~WIND_UPDATE(2)                       ! Rend ctrl souris
  ~WIND_UPDATE(0)                       ! LibŠre liste de rectangles
  SHOWM
RETURN
> PROCEDURE affiche_vdt(page&)
  LOCAL page$,page_lg&,sequence&
  '
  ' Affiche page vdt:
  '
  page$=page_vdt$(page&)
  page_lg&=LEN(page$)           ! Long page
  IF ptr&=1                     ! Si d‚but affichage
    pause%=TRUE
  ENDIF
  REPEAT                        ! Aff code/code
    '
    l1|=ASC(MID$(page$,ptr&,1))
    IF page_v&=last_v&
      IF l1|>127
        code_accent(l1|)
        PRINT #99;l1$;
      ELSE
        OUT 1,l1|
      ENDIF
    ELSE
      SELECT l1|
      CASE 17                       ! CSR ON
        OUT 1,17
        csr!=TRUE
      CASE 18
        sequence&=1                   ! Suit: 1 caractŠre ins‚parable
        OUT 1,18
      CASE 20                       ! CSR OFF
        OUT 1,20
        csr!=FALSE
      CASE 25
        sequence&=1                   ! Suit: 1 caractŠre ins‚parable
        OUT 1,25
      CASE 27
        sequence&=3                   ! Suivent: 1 … 3 caractŠres ins‚parables
        OUT 1,27
      CASE 31                         ! Suivent: 2 caractŠres ins‚parables
        sequence&=2
        OUT 1,31
      CASE 0 TO 127                 ! Si code <= … 127
        OUT 1,l1|
      CASE 134                      ! *TPAPER x
        IF ptr&<page_lg&              ! Si c'est pas le dernier code
          INC ptr&                      ! Code suivant
          l1|=ASC(MID$(page$,ptr&,1))     ! Extraction code
          tpaper
        ENDIF
      CASE 148                      ! *PAUSE x
        IF pause%=TRUE                ! D‚but de pause
          pause%=TIMER+(ASC(MID$(page$,SUCC(ptr&),1))-65)*100 ! Timer de sortie
        ENDIF
        IF TIMER<pause%               ! En attente
          DEC ptr&
        ELSE                          ! Tps ‚coul‚
          INC ptr&
          pause%=TRUE
        ENDIF
      DEFAULT                       ! Autres codes
        vdt_special
      ENDSELECT
    ENDIF
    '
    INC ptr&
    '
    IF sequence&=FALSE
      IF ASC(MID$(page$,ptr&,1))<>18
        EXIT IF INP(TRUE) AND interrupt! AND vdt_test!=FALSE
        IF INP(-2)                    ! Si clavier ST
          IF vdt_test!                  ! Si on est en mode test de page
            ~INP(2)
            EXIT IF TRUE
          ENDIF
          ' -- 520_1040 -------------------
          l1$=INKEY$
          l1|=ASC(l1$)
          IF l1|=FALSE                  ! Si touche de fnct
            l2|=ASC(RIGHT$(l1$))
            function_keys                 ! Touches g‚n‚rales
            IF l2!=FALSE AND clav!        ! Si pas reconnue et emul clavier
              key_trans$=key_trans$+CHR$(0)+CHR$(l2|)
              EXIT IF interrupt!            ! Interruption d'aff
            ENDIF
          ELSE IF clav! OR l1|=2 OR l1|=4 OR l1|=19   ! Si touche pour ‚mulateur
            key_trans$=key_trans$+CHR$(l1|)
            EXIT IF interrupt!            ! Interruption d'aff
          ELSE
            kbd_l0_break                  ! Gest touches g‚n‚rales
          ENDIF
          ' -------------------------------
        ENDIF
      ENDIF
    ENDIF
    DEC sequence&
    IF sequence&=TRUE
      sequence&=FALSE
    ENDIF
  UNTIL ptr&>page_lg&
  IF ptr&=SUCC(page_lg&)          ! Si tout est affich‚
    ptr&=TRUE                     ! Fin affichage
  ENDIF
RETURN
> PROCEDURE aiguil_loc
  '
  ' Aiguillages minitel local:
  '
  OUT 1,&H1B,&H5B,&H3F,&H7B     ! Sortie mode t‚l‚informatique
  OUT 1,27,57,127               ! Reset
  OUT 1,27,59,96,88,81          ! Stp Clavier => Ecran
  OUT 1,27,59,96,88,82          ! Stp Mod => Ecr
  OUT 1,27,59,96,90,81          ! Stp Clav => Mod
  OUT 1,27,59,97,88,83          ! Inst Pri => Ecr
  OUT 1,27,58,105,69            ! Min
  OUT 1,27,59,105,89,65         ! Clavier etendu
  OUT 1,27,59,97,91,81          ! Inst Clav => pri
RETURN
> FUNCTION ascii(keycode&)
l1%=XBIOS(16,L:-1,L:-1,L:-1)    ! Table des codes
RETURN BYTE{{l1%+4}+@scan(keycode&)} ! Code ASCII ds table Shift
ENDFUNC
> PROCEDURE attente_cnx
'
' Ret modem, envoi port, att cnx:
'
OUT 1,27,57,111               ! Retournement modem
l1%=TIMER
l2|=FALSE
REPEAT
  IF INP(TRUE)
    l2|=INP(1)
  ENDIF
UNTIL l2|=80 OR TIMER-l1%>200 ! Attend aquit
WHILE MOUSEK                  ! Attend relachement bout souris
WEND
OUT 1,27,57,104               ! Envoi porteuse
l1%=TIMER
DO
  IF INP(TRUE)                  ! Si code en entr‚e
    l1|=INP(1)
    IF l1|=19                     ! Si d‚but de [CONNEXION]
      PAUSE 5                     ! Attente code suivant
      IF INP?(1)                  ! Code en entr‚e
        l1|=INP(1)
        IF l1|=83                   ! Si on a recu cette fin
          OUT 1,27,59,97,88,83        ! Installe prise => ‚cran
          OUT 1,31,64,65,24,12        ! Efface ecran minitel
          loc(1,0)
          PRINT #99;"Logiciel Serveur STUT ONE ";version$
          envoi_chaine("Communication ‚tablie.")
          connecte!=TRUE              ! Il y a un connect‚
          ~MENU_ICHECK(menu.adr%,connecte|,1) ! Check Connect‚
          m_iena(0,MKI$(porteu|)+MKI$(m_loc|)+MKI$(m_off|)) !520_1040
          m_iena(1,MKI$(deco|))
          EXIT IF TRUE
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  IF TIMER-l1%=>4000            ! Si pas de connexion au bout de 20 s
    OUT 1,27,57,103             ! Deconnexion
    OUT 1,27,57,87,27,57,88     ! LibŠre la ligne (M2)
    EXIT IF TRUE
  ENDIF
LOOP
RETURN
> PROCEDURE auto_exec
'
' R‚glage de l'heure si demand‚:
'
LOCAL no_load!
'
IF BTST(BIOS(11,W:TRUE),3)      ! Si la touche Alternate est active
  OUT 2,7
  no_load!=TRUE                   ! On ne chargera pas
ENDIF
IF auto_setdate%<>TRUE
  l1$=DATE$
  l2$=TIME$
  l1%=VAL(RIGHT$(l1$,4)+MID$(l1$,4,2)+LEFT$(l1$,2))
  IF l1%<auto_setdate% OR auto_setdate%=-2
    DEFMOUSE 0
    regler_heure
    DEFMOUSE 2
  ENDIF
ENDIF
'
' Charge et lance serv si demand‚
'
IF BTST(auto_charge|,0) AND no_load!=FALSE ! Si le bit de chargement est mis et pas encore annul‚
  IF BTST(BIOS(11,W:TRUE),3)      ! Si la touche Alternate est active
    OUT 2,7
  ELSE
    charge_serv
    ' -- 520_1040 ------------------
    IF BTST(auto_charge|,1)         ! Si bit lancement mis
      IF serveur!
        normal
      ELSE
        ALERT 3,"Le serveur n'ayant pas|‚t‚ charg‚, il ne peut|ˆtre lanc‚...",1,"   OK   ",void
      ENDIF
    ENDIF
    ' ------------------------------
  ENDIF
ENDIF
RETURN
'
> PROCEDURE balstate
'
' Affich infos sur la BAL cnt:
'
IF topline|(1)=0
  loc(2,0)
ELSE
  loc(8,0)
ENDIF
font_restore
OUT 1,27,66
IF info_bal|=0
  IF LEN(pseudo$)
    PRINT #99;"Vous n'avez pas de BAL.";
  ELSE
    envoi_chaine("Vous n'ˆtes pas identifi‚.")
  ENDIF
ELSE IF info_bal|=1
  PRINT #99;"Vous n'avez plus de BAL.";
ELSE IF nb_balmsg|=FALSE
  PRINT #99;"Votre BAL est vide.";
ELSE IF nb_balmsg|=1
  PRINT #99;"Vous avez 1 message en BAL.";
ELSE
  PRINT #99;"Vous avez ";STR$(nb_balmsg|);" messages en BAL.";
ENDIF
OUT 1,10
RETURN
'
> PROCEDURE call_value(VAR m.value&)
LINE INPUT #1,l1$
INPUT #1,m.value&
DEC m.value&
RETURN
> PROCEDURE can
'
' Bourrage ligne:
'
IF mixt!
  OUT 1,27,91,75
ELSE
  OUT 1,24
ENDIF
RETURN
> PROCEDURE charge_conf
'
' Charg conf si ‚xist:
'
titre(stut$+"CNF")
g1$=path$+stut$+"CNF"
IF EXIST(g1$)                 ! Si le fichier config existe
  chargement_conf
ELSE
  auto_setdate%=default_date%
ENDIF
RETURN
> PROCEDURE charge_conf2
'
' Charge conf aprŠs coup!
'
titre("Chargement d'une configuration")
cur_dir               ! Directory courant\ ==> g1$
f_titre$="CHOIX DE LA CONF"
g1$=FN file$(1,g1$+"*.CNF","",l1$)
IF LEN(g1$)
  chargement_conf
ENDIF
~MENU_BAR(menu.adr%,1)                ! Active menu
RETURN
> PROCEDURE chargement_conf
OPEN "I",#1,g1$
RECALL #1,chemin$(),4,void
RECALL #1,ligne$(),4,l1%
CLOSE #1
m1&=BIOS(10)                  ! Test lects pr‚sents
FOR l1&=0 TO 3                ! Control si lects peuvent etre utilis‚s
  IF BTST(m1&,ASC(chemin$(l1&))-65)=FALSE
    chemin$(l1&)="A:\"
  ENDIF
NEXT l1&
inout_path$=chemin$(0)        ! Path pour Import/Export de pages = path systŠme
PRINT #99
envoi_chaine("Sys: ")
PRINT #99;chemin$(0)
envoi_chaine("R/A: ")
PRINT #99;chemin$(1)
envoi_chaine("Bal: ")
PRINT #99;chemin$(2)
envoi_chaine("Srv: ")
PRINT #99;chemin$(3)
adr%=menu.adr%
auto_charge|=VAL(LEFT$(ligne$(0))) ! Chargement auto ?
auto_setdate%=VAL(LEFT$(ligne$(1),8)) ! Demande date ?
enr&=VAL(ligne$(2))             ! Enregistrement cnxs
~MENU_ICHECK(menu.adr%,enregistr|,enr&) ! Indique Enregistrement
IF l1%=>4                       ! Si on asauv‚ la vitesse
  l1|=VAL(ligne$(3))
  IF l1|<>vitesse|                ! SI vitesse diff‚rente
    vitesse|=l1|
    vit_set
    PAUSE 10
    l1$=INPAUX$
  ENDIF
ENDIF
RETURN
> PROCEDURE charge_pages(fichier$,VAR nbp&,nom$(),info|(),page$(),nbn&,alpha$())
LOCAL l.direct!
'
' Charge pages VDT/ABR
'
IF LEN(fichier$)=FALSE
  l.direct!=TRUE
  l1!=TRUE
ELSE
  set_string(6,"Test de pr‚sence")
  l1!=EXIST(m1$+fichier$)
ENDIF
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
IF l1!
  err_resume&=2
  REPEAT
    err_choix&=FALSE
    IF l.direct!=FALSE
      OPEN "I",#1,m1$+fichier$
    ENDIF
    nbp&=INP(#1)*256+INP(#1)      ! Nb pages
    IF INP(#1)<>255               ! Si format incorrect
      OUT 2,7
      nbp&=FALSE
    ENDIF
    IF l.direct&=FALSE
      set_string(6,char$)
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
    ENDIF
    IF nbp&
      nbn&=nbp&
      FOR m1&=PRED(nbp&) DOWNTO 0   ! Parcourt les pages
        l1$=""
        DO
          l1|=INP(#1)
          EXIT IF l1|=0
          l1$=l1$+CHR$(l1|)
        LOOP
        nom$(m1&)=l1$                   ! Nom page
        alpha$(m1&)=l1$+" "             ! Pour la liste
        set_string(11,l1$)
        set_vlstring(10,SUCC(m1&),4)
        ~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
        l1&=INP(#1)*256+INP(#1)         ! Longueur page
        page$(m1&)=SPACE$(l1&)
        BGET #1,V:page$(m1&),l1&        ! Charge la page
        IF INP(#1)<>255                 ! Si format incorrect
          OUT 2,7
          EXIT IF TRUE
        ENDIF
      NEXT m1&
    ENDIF
  err_2:
    IF l.direct!=FALSE
      CLOSE #1
    ENDIF
  UNTIL err_choix&<>2
  err_resume&=FALSE
ELSE IF fichier$="ARBO.STU"
  ALERT 1,"ATTENTION! Le fichier|arborescence (ARBO.STU)|n'a pas ‚t‚ trouv‚!|Est-ce voulu ?",1,"  VU!  ",void
ENDIF
fin_cs_type                           ! Fin de l'op‚ration
IF nbn&
  QSORT alpha$() WITH sort|(),nbn&
ENDIF
RETURN
> PROCEDURE ch_rsrc_520_1040
'
' Chargement du fichier RSC:
'
l1$=stut$+"RSC"                   ! 520_1040
titre(l1$)
~RSRC_FREE()
RESERVE FRE(0)-65000-2048
REPEAT
  l1|=RSRC_LOAD(path$+l1$)        ! Essai de chargement
  IF l1|=0                        ! Si on n'a pas pu charger
    DEFMOUSE 0
    ALERT 3,"|Le fichier: "+l1$+"|ne peut ˆtre charg‚.",1,"RETRY|STOP",l1|
    INC l1|
  ENDIF
UNTIL l1|<>2
IF l1|=3
  RESERVE
  EDIT
ENDIF
IF erreurs!
  ON ERROR GOSUB erreur         ! Routine de traitement des erreurs.
ENDIF
'
' Fixe adresses & pos de certains objets:
'
~RSRC_GADDR(0,0,menu.adr%)      ! Menu principal
infos_menu|=13                  ! Infos/copyright
c_serv|=22                      ! Chargement du serv
create_new|=23                  ! Cr‚ation nouveau serveur
maj|=24                         ! Mise … jour           520_1040
init|=25                        ! Init du serv
select_f|=27                    ! Selecteur de fichiers
prg_ext|=28                     ! Appel prg ext
fin|=30                         ! Quitter serveur
chemins|=32                     ! Chemins d'accŠs
params|=33                      ! ParamŠtres
par_load|=34                    ! Chargement config
par_save|=35                    ! Sauvegarde config
dispo|=37                       ! Espaces dispo
heure|=39                       ! Reglage heure
connecte|=41                    ! Connect‚
menu_vit|=42                    ! 300 Bds
' --MAKE_ONE---------------------
edit_vdt|=47                    ! Editer une page VDT
test_vdt|=48                    ! Tester une page VDT
copy_vdt|=50                    ! Copier page
effa_vdt|=51                    ! Effacer page
import_vdt|=53                  ! Import page
export_vdt|=54                  ! Export page
edit_arbo|=56                   ! Editer une page arbo
copy_arbo|=58                   ! Copier page
supp_arbo|=59                   ! Supp une page arbo
import_arbo|=61                 ! Import page
export_arbo|=62                 ! Export page
edit_rub|=64                    ! Param rub
supp_rub|=65                    ! Supp une rub
edit_aff|=67                    ! Param affiche
supp_aff|=68                    ! Eff aff
bals|=70                        ! BALs
edit_base|=73                   ! Param base
supp_base|=74                   ! Supp une base
'
edit_alt|=77                    ! Editer une page alternative
effa_alt|=78                    ! Supprimer une page alt
startstop|=80                   ! START/STOP
mot_cle|=81                     ! Mots clef
msgs_sys|=82                    ! Messages systŠme
infos_tel|=84                   ! Guides t‚l
para_mod|=86                    ! Param module
' --USE_ONE--------------------
filtrer|=71                     ! Filtrer les BAL
voir_base|=75                   ! Consulter une base
m_loc|=88                       ! Mode local
m_off|=89                       ! Mode Off-Line
m_norm|=90                      ! Mode normal
enregistr|=92                   ! Enregistrement des cnxs
voir_enr|=93                    ! Voir l'enregistr
' ------------------------------
porteu|=95                      ! Porteuse
deco|=96                        ! D‚co
marche|=98                      ! Marche Minitel
veille|=99                      ! Veille Minitel
'
'
ent_edit$=MKI$(init|)
ent_edit$=ent_edit$+MKI$(edit_vdt|)+MKI$(test_vdt|)+MKI$(copy_vdt|)+MKI$(effa_vdt|)+MKI$(export_vdt|)+MKI$(edit_arbo|)+MKI$(copy_arbo|)+MKI$(supp_arbo|)+MKI$(export_arbo|)+MKI$(edit_rub|)+MKI$(supp_rub|)+MKI$(edit_aff|)
ent_edit$=ent_edit$+MKI$(supp_aff|)+MKI$(edit_base|)+MKI$(supp_base|)+MKI$(voir_base|)+MKI$(edit_alt|)+MKI$(effa_alt|)+MKI$(mot_cle|)+MKI$(bals|)+MKI$(filtrer|)+MKI$(startstop|)+MKI$(msgs_sys|)
ent_edit$=ent_edit$+MKI$(m_norm|)
'
~RSRC_GADDR(0,1,cr.adr%)        ! Infos copyright
~RSRC_GADDR(0,2,timeset.adr%)   ! R‚glage heure
~RSRC_GADDR(0,3,chemins.adr%)   ! Chemins d'accŠs
~RSRC_GADDR(0,4,fichiers.adr%)  ! Traitement de fichiers
~RSRC_GADDR(0,5,select.adr%)    ! S‚lecteur de pages
select_valid%=LPEEK(OB_SPEC(select.adr%,26)+8)
~RSRC_GADDR(0,6,espaces.adr%)   ! Espaces dispos
~RSRC_GADDR(0,7,defarbo.adr%)   ! Definition d'une page arbo
~RSRC_GADDR(0,8,pararub.adr%)   ! Param d'une rub
~RSRC_GADDR(0,9,parabal.adr%)  ! Param des bals
~RSRC_GADDR(0,10,infos_tel.adr%) ! Ed des infos sur les fichiers tel
~RSRC_GADDR(0,11,break.adr%)    ! Valid d'une demande de break
~RSRC_GADDR(0,12,params.adr%)   ! Params g‚n‚raux
~RSRC_GADDR(0,13,paraff.adr%)   ! Param affiche
~RSRC_GADDR(0,14,edit_menu.adr%)! Menu ‚diteur
~RSRC_GADDR(0,15,enregistr.adr%)! Params enregistr
' Edition des pages ABR
~RSRC_GADDR(0,16,module.adr%)   ! Page MODULE
~RSRC_GADDR(0,17,clef.adr%)     ! Page MENU
~RSRC_GADDR(0,18,image.adr%)    ! Page IMAGE,START,TABL_CNX
~RSRC_GADDR(0,19,telechar.adr%) ! Page TELECHAR
~RSRC_GADDR(0,20,tel_inv.adr%)  ! PAGE TEL_INV
~RSRC_GADDR(0,21,dialogue.adr%) ! Page DIALOGUE
~RSRC_GADDR(0,22,stop.adr%)     ! Page STOP
~RSRC_GADDR(0,23,ecrilir.adr%)  ! Pages ecriture/lecture message
'
~RSRC_GADDR(0,24,startstop.adr%) ! Params Pages START&STOP
'
~RSRC_GADDR(0,25,acces.adr%)    ! Page ACCES
~RSRC_GADDR(0,26,liste.adr%)    ! Page BALS_ANN,LIST_ENV,LIST_REC
~RSRC_GADDR(0,27,pseudo.adr%)   ! Page PSEUDO/CREE_BAL
~RSRC_GADDR(0,28,journal.adr%)  ! Page JOURNAL
'
~RSRC_GADDR(0,29,menu_voir.adr%) ! Menu visu page
'
~RSRC_GADDR(0,30,affiche.adr%)  ! Page AFFICHE
~RSRC_GADDR(0,31,fiche.adr%)    ! Page FICHE_ID
'
~RSRC_GADDR(0,32,msgsys.adr%)   ! Messages systŠme
~RSRC_GADDR(0,33,pagemem.adr%)  ! M‚moires de page
~RSRC_GADDR(0,34,altern.adr%)   ! Pages alternatives!
~RSRC_GADDR(0,35,create_new.adr%) ! Cr‚ation d'un nouveau serv!
'
~RSRC_GADDR(0,36,editfiche.adr%) ! Edition d'une fiche
'
~RSRC_GADDR(0,37,para_base.adr%) ! Param‚trage d'une base de donn‚es
'
~RSRC_GADDR(0,38,transit.adr%)  ! Page TRANSIT
'
~RSRC_GADDR(0,39,filtrer.adr%)  ! Filtrage des BALS
RETURN
> PROCEDURE charge_divers(p.direct!)
file2touch("DIVERS.STU",char$)            ! Indique Nom fichier … charger
err_resume&=8
REPEAT
  err_choix&=FALSE
  IF p.direct!=FALSE
    OPEN "I",#1,m1$+"DIVERS.STU"
  ENDIF
  INPUT #1,bal_nb_pagemsg|
  INPUT #1,bal_nb_lignepage|
  INPUT #1,bal_titre!
  INPUT #1,rep_nbl|
  INPUT #1,start_page$
  INPUT #1,stop_page$
  INPUT #1,error_page$
  RECALL #1,off_vdt$(),10,l1%
  INPUT #1,off_vdt_mode|
  WHILE NOT EOF(#1)
    l1|=INP(#1)
    EXIT IF l1|=ASC("$")
    IF l1|=ASC("+")       ! A partir de version 2.4! (compatible 2.3)
      INPUT #1,sysop_page$
      INPUT #1,sysop_maxlong&
    ELSE IF l1|=ASC("-")      ! A partir de v2.6
      INPUT #1;date_filtre$
      INPUT #1;levels_filtre$
    ENDIF
  WEND
err_8:
  IF p.direct!=FALSE
    CLOSE #1
  ENDIF
UNTIL err_choix&<>2
err_resume&=FALSE
RETURN
> PROCEDURE charge_messages(p.direct!)
' Charge messages systŠme:
file2touch("MSGS_SYS.STU",char$)     ! Indique Nom fichier … charger
err_resume&=10
REPEAT
  err_choix&=FALSE
  IF p.direct!=FALSE
    OPEN "I",#1,m1$+"MSGS_SYS.STU"
  ENDIF
  INPUT #1,nb_msgsys&                   ! Nombre de msgs sys
  RECALL #1,msgsys$(),nb_msgsys&,void   ! Chargement des messages systŠme
err_10:
  IF p.direct!=FALSE
    CLOSE #1
  ENDIF
UNTIL err_choix&<>2
err_resume&=FALSE
RETURN
> PROCEDURE charge_serv
LOCAL l.folder&
'
' Chargement du serv:
'
DEFMOUSE 2
adr%=fichiers.adr%
l1$=char$+" du serveur"
titre(l1$)
set_edit(1,l1$)
aff_charsauve
real_load&=TRUE               ! Par d‚faut
'
control_folder(0,"systŠme",chemin$(0))
IF l.folder&=TRUE
  m1$=chemin$(0)                ! Path … utiliser
  '
  ' Pages vdt:
  '
  set_string(5,"Pages vid‚otex")
  charge_pages("VIDEOTEX.STU",nbp_vdt&,nom_vdt$(),info_vdt|(),page_vdt$(),nbn_vdt&,alpha_vdt$())
  '
  ' Pages arborescence:
  '
  set_string(5,"Pages arborescence")
  charge_pages("ARBO.STU",nbp_arbo&,nom_arbo$(),info_arbo|(),page_arbo$(),nbn_arbo&,alpha_arbo$())
  '
  ' Pages alternatives:
  '
  set_string(5,"Pages alternatives")
  charge_pages("ALTERN.STU",nbp_alt&,nom_alt$(),info_alt|(),page_alt$(),nbn_alt&,alpha_alt$())
  '
  ' Mots clef:
  '
  set_string(5,"Mots clef")
  set_string(6,"Test de pr‚sence")
  ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
  l1!=EXIST(m1$+"MOTS_CLE.STU")
  IF l1!
    file2touch("MOTS_CLE.STU",char$)            ! Indique Nom fichier … charger
    err_resume&=7
    REPEAT
      err_choix&=FALSE
      OPEN "I",#1,m1$+"MOTS_CLE.STU"
      INPUT #1,nb_mots&                     ! Nombre de mots clef
      RECALL #1,mot$(),nb_mots&,void        ! Chargement des mots clef
      RECALL #1,page$(),nb_mots&,void       ! Chargement des pages arbo correspond
    err_7:
      CLOSE #1
    UNTIL err_choix&<>2
    err_resume&=FALSE
  ENDIF
  fin_cs_type                           ! Fin de l'op‚ration
  '
  ' Messages systŠme:
  '
  set_string(5,"Messages systŠme")
  set_string(6,"Test de pr‚sence")
  ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
  l1!=EXIST(m1$+"MSGS_SYS.STU")
  IF l1!
    charge_messages(0)
  ELSE
    ALERT 1,"ATTENTION! Le fichier|de messages systŠme|(MSGS_SYS.STU) n'a pas ‚t‚|trouv‚! Est-ce voulu ?",1,"  VU!  ",void
  ENDIF
  fin_cs_type                           ! Fin de l'op‚ration
  '
  ' Parametres divers:
  '
  set_string(5,"ParamŠtres divers")
  set_string(6,"Test de pr‚sence")
  ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Affiche
  l2!=EXIST(m1$+"DIVERS.STU")
  IF l2!
    charge_divers(0)
  ENDIF
  fin_cs_type                           ! Fin de l'op‚ration
ELSE
  real_load&=FALSE
ENDIF
'
IF l.folder&                  ! Si pas abandon
  control_folder(0,"rubs/affs",chemin$(1))
  IF l.folder&=TRUE
    m1$=chemin$(1)
    '
    ' Rubriques:
    '
    set_string(5,"Rubriques")
    ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
    directory(m1$,"*.RUB",TRUE,FALSE)      ! Directory
    IF nb_files%
      set_string(6,"Tri")
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      DELETE file$(0)                       ! On supprime le 1er nom (vide)
      QSORT file$() WITH sort|(),nb_files%  ! Tri alpha des fichiers
      DEC nb_files%                         ! On ajuste la valeur
      IF nb_files%>nb_rub_max&              ! S'il y a plus de 40 rubriques
        nb_files%=nb_rub_max&
      ENDIF
      set_string(6,char$)
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      FOR m1&=0 TO nb_files%                ! On va charger les rubriques
        l1$=file$(m1&)                        ! Nom de la rubrique
        set_string(11,l1$)
        ~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%) ! Aff nom
        OPEN "I",#1,m1$+l1$
        INPUT #1,param_rub|(m1&,0)            ! Nb msgs max
        INPUT #1,param_rub|(m1&,1)            ! Nb pages par msg
        INPUT #1,param_rub|(m1&,2)            ! Nb lignes par page
        INPUT #1,param_rub|(m1&,3)            ! Indicateur titre/tri
        INPUT #1,param_rub|(m1&,4)            ! Nombre de msgs existants
        l2|=param_rub|(m1&,4)
        IF l2|
          RECALL #1,ligne$(),l2|,void           ! Charge msgs
          CLOSE #1
          FOR l1|=0 TO PRED(l2|)
            msg_rub$(m1&,l1|)=ligne$(l1|)       ! Stocke msgs
          NEXT l1|
        ELSE
          CLOSE #1
        ENDIF
        l1$=LEFT$(l1$,LEN(l1$)-4)             ! Extrait nom
        nom_rub$(m1&)=l1$                     ! Nom rub
        alpha_rub$(m1&)=l1$+" "               ! Pour la liste
        set_vlstring(10,nb_files%-m1&,4)
      NEXT m1&
      nb_rub&=m1&
      nbn_rub&=m1&
    ENDIF
    fin_cs_type                           ! Fin de l'op‚ration
    '
    ' Affiches:
    '
    set_string(5,"Affiches")
    set_string(6,"Test de pr‚sence")
    ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
    directory(m1$,"*.AFF",TRUE,FALSE)     ! Directory
    IF nb_files%
      set_string(6,"Tri")
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      DELETE file$(0)                       ! On supprime le 1er nom (vide)
      QSORT file$() WITH sort|(),nb_files%  ! Tri alpha des fichiers
      DEC nb_files%                         ! On ajuste la valeur
      IF nb_files%>nb_aff_max&              ! S'il y a trop d'aff
        nb_files%=nb_aff_max&
      ENDIF
      set_string(6,char$)
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      FOR m1&=0 TO nb_files%                ! On va charger les aff
        l1$=file$(m1&)                        ! Nom de l'aff
        set_string(11,l1$)
        ~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%) ! Aff nom
        OPEN "I",#1,m1$+l1$
        INPUT #1,param_aff|(m1&,0)            ! Nbl max
        INPUT #1,param_aff|(m1&,1)            ! 40/80 col
        INPUT #1,param_aff|(m1&,2)            ! Nbl existantes
        l2|=param_aff|(m1&,2)
        IF l2|
          RECALL #1,ligne$(),l2|,void           ! Charge lignes
          CLOSE #1
          FOR l1|=0 TO PRED(l2|)
            ligne_aff$(m1&,l1|)=ligne$(l1|)       ! Stocke lignes
          NEXT l1|
        ELSE
          CLOSE #1
        ENDIF
        l1$=LEFT$(l1$,LEN(l1$)-4)             ! Extrait nom
        nom_aff$(m1&)=l1$                     ! Nom aff
        alpha_aff$(m1&)=l1$+" "               ! Pour la liste
        set_vlstring(10,nb_files%-m1&,4)
      NEXT m1&
      nb_aff&=m1&
      nbn_aff&=m1&
    ENDIF
    fin_cs_type                           ! Fin de l'op‚ration
    '
    ' Bases:
    '
    set_string(5,"Bases de donn‚es")
    set_string(6,"Test de pr‚sence")
    ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
    directory(m1$,"*.DBD",TRUE,FALSE)     ! Directory
    IF nb_files%
      set_string(6,"Tri")
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      DELETE file$(0)                       ! On supprime le 1er nom (vide)
      QSORT file$() WITH sort|(),nb_files%  ! Tri alpha des fichiers
      DEC nb_files%                         ! On ajuste la valeur
      IF nb_files%>nb_base_max&             ! S'il y a trop de bases
        nb_files%=nb_base_max&
      ENDIF
      set_string(6,char$)
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Aff op‚rat
      FOR m1&=0 TO nb_files%                ! On va charger les bases
        l1$=file$(m1&)                        ! Nom de la base
        set_string(11,l1$)
        ~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%) ! Aff nom
        OPEN "I",#1,m1$+l1$
        '
        INPUT #1;l1&
        l3&=l1&
        IF l1&>3                      ! 3 Params g‚n‚raux
          l1&=3
        ENDIF
        DEC l1&
        FOR l2&=0 TO l1&                ! Params g‚n‚raux
          INPUT #1;base_param%(m1&,l2&)
        NEXT l2&
        RECALL #1,file$(),l3&-l1&-1,l1% ! Charge surplus
        '
        INPUT #1;l1&               ! Nb fiches
        '          l3&=l1&                    ! On s'en fout du surplus
        IF l1&>25                  ! 25 Fiches
          l1&=25
        ENDIF
        DEC l1&
        '
        INPUT #1,l7&               ! Nb noms
        INPUT #1,l4&
        l6&=l4&
        IF l4&>3                    ! 3 paramŠtres
          l4&=3
        ENDIF
        DEC l4&
        '
        FOR l2&=0 TO l1&              ! Parcourt fiches
          INPUT #1;fiches_nom$(m1&,l2&)   ! Charge nom
          RECALL #1,file$(),PRED(l7&),l1% ! Charge surplus
          FOR l5&=0 TO l4&            ! Parcourt params
            INPUT #1;fiches_param&(m1&,l2&,l5&)
          NEXT l5&
          RECALL #1,file$(),l6&-l4&-1,l1%
        NEXT l2&
        '
        CLOSE #1
        l1$=LEFT$(l1$,LEN(l1$)-4)             ! Extrait nom
        nom_base$(m1&)=l1$                    ! Nom aff
        alpha_base$(m1&)=l1$+" "              ! Pour la liste
        set_vlstring(10,nb_files%-m1&,4)
      NEXT m1&
      nb_base&=m1&
      nbn_base&=m1&
    ENDIF
    fin_cs_type                           ! Fin de l'op‚ration
  ELSE
    real_load&=FALSE
  ENDIF
  '
  IF l.folder&                  ! Si pas abandon
    control_folder(0,"bals",chemin$(2))
    IF l.folder&=TRUE
      m1$=chemin$(2)
      '
      ' Liste des BALS:
      '
      set_string(5,"Liste des Bals")
      set_string(6,"Test de pr‚sence")
      ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
      l1!=EXIST(m1$+"BALS.LST")
      IF l1!
        file2touch("BALS.LST",char$)         ! Indique Nom fichier … charger
        OPEN "I",#1,m1$+"BALS.LST"
        INPUT #1,nb_pseudos&                  ! NB bals
        ' -- 520_1040 -----------------------
        RECALL #1,pseudo$(),nb_pseudos&,void  ! Chargement pseudos
        RECALL #1,code$(),nb_pseudos&,void    ! Chargement des codes correspondants
        INPUT #1,nb_nums&                     ! Nb de num‚ros
        RECALL #1,file$(),nb_nums&,void       ! Chargement et pr‚-stockage des num
        ' -----------------------------------
        CLOSE #1
        ' -- 520_1040 -----------------------
        FOR l1&=0 TO PRED(nb_nums&)
          bal_no%(l1&)=VAL(file$(l1&))          ! Stockage d‚finitif des num‚ros
        NEXT l1&
        ' -----------------------------------
      ENDIF
      fin_cs_type                           ! Fin de l'op‚ration
    ELSE
      real_load&=FALSE
    ENDIF
    '
    ' -- 520_1040 -----------------------
    IF l.folder&                  ! Si pas abandon
      control_folder(0,"serveur",chemin$(3))
      IF l.folder&=TRUE
        m1$=chemin$(3)
        '
        ' Tableau des connexions:
        '
        set_string(5,"Tableau des CNXs")
        set_string(6,"Test de pr‚sence")
        ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
        l1!=EXIST(m1$+"TABLEAU.CNX")
        IF l1!
          file2touch("TABLEAU.CNX",char$)         ! Indique Nom fichier … charger
          OPEN "I",#1,m1$+"TABLEAU.CNX"
          INPUT #1,nb_appels%                   ! Chargement du nb d'appels
          INPUT #1,d_totale%                    ! Chargement de la dur‚e totale
          RECALL #1,connecte$(),20,void         ! Chargement du tableau des cnxs
          CLOSE #1
        ENDIF
        fin_cs_type                           ! Fin de l'op‚ration
      ELSE
        real_load&=FALSE
      ENDIF
      ' -----------------------------------
      '
      ' Fin chargement
      '
      IF real_load&=FALSE
        ALERT 2,"Voulez-vous utiliser|la partie de serveur|ayant pu ˆtre charg‚e?",1,"Essayer|Annuler",l1&
      ENDIF
      IF l1&=1 OR real_load&
        set_loaded                            ! Fixe les nlles poss menu
      ELSE
        init_totale                           ! efface ce qui a ‚t‚ charg‚
      ENDIF
    ENDIF
  ENDIF                               ! 520_1040
ENDIF
FOR l1&=0 TO nb_file_max&             ! Efface le tableau file$
  file$(l1&)=""
NEXT l1&
FOR l1|=0 TO 39                       ! Efface le tableau ligne$
  ligne$(l1|)=""
NEXT l1|
IF l.folder&=FALSE                    ! Si abandon
  init_totale
ELSE
  fram
ENDIF
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%)
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)                ! Activation menu
RETURN
> PROCEDURE chemins
'
' Fixe les chemins d'accŠs au serveur
'
titre("Chemins d'accŠs aux fichiers serveur")
chemins_noyau:
DATA 3,4,5,6,0,0,1,2,3,0,0,0,0,0,0,7,8,9,10,0
'
adr%=chemins.adr%
FOR l1&=0 TO 3
  parametre$(l1&)=chemin$(l1&)
  set_edit(7+l1&,parametre$(l1&))
NEXT l1&
'
RESTORE chemins_noyau
editarbo_noyau(50,11,1000)
'
IF b%=11
  FOR l1&=0 TO 3
    chemin$(l1&)=parametre$(l1&)
  NEXT l1&
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE clock
'
' Aff pendule:
'
IF l0|=FALSE
  IF csr!
    OUT 1,20
  ENDIF
  loc(2,0)
  font_restore
  l2$=TIME$
  clock%=TIMER+12000-VAL(RIGHT$(l2$,2))*200
  PRINT #99;CHR$(27);"]";LEFT$(l2$,2);CHR$(27);"H:";CHR$(27);"I";MID$(l2$,4,2);
  OUT 1,27,94,10
  IF csr!
    OUT 1,17
  ENDIF
ENDIF
RETURN
> PROCEDURE cls_2nd
'
' Efface le 2Šme ecran:
'
l.x_g&=p.x_car&*8-8
l.l_g&=l.x_g&-4
l.w_g&=p.w_car&*8+16
l.r_g&=PRED(l.l_g&+l.w_g&)    ! Right border
l.x_no&=l.r_g&-40             ! No de ligne
l.x_ins&=l.x_no&-8            ! Insert
l.screen.adr%=XBIOS(3)
'
~XBIOS(5,L:screen.adr%,L:-1,L:-1)
CLS
l1&=30*rez|+rm|
LINE l.l_g&,l1&,l.r_g&,l1&
TEXT l.x_g&,28*rez|+2*rm|,w_info$
~XBIOS(5,L:l.screen.adr%,L:-1,L:-1)
RETURN
> PROCEDURE code_accent(c_a|)
'
' Transforme car >127 en car vdt:
'
SELECT c_a|
CASE 129                           ! 
  l1$=CHR$(25)+CHR$(72)+CHR$(117)
CASE 130                           ! ‚
  l1$=CHR$(25)+CHR$(66)+CHR$(101)
CASE 131                           ! ƒ
  l1$=CHR$(25)+CHR$(67)+CHR$(97)
CASE 132                           ! „
  l1$=CHR$(25)+CHR$(72)+CHR$(97)
CASE 133                           ! …
  l1$=CHR$(25)+CHR$(65)+CHR$(97)
CASE 135                           ! ‡
  l1$=CHR$(25)+CHR$(75)+CHR$(99)
CASE 136                           ! ˆ
  l1$=CHR$(25)+CHR$(67)+CHR$(101)
CASE 137                           ! ‰
  l1$=CHR$(25)+CHR$(72)+CHR$(101)
CASE 138                           ! Š
  l1$=CHR$(25)+CHR$(65)+CHR$(101)
CASE 139                           ! ‹
  l1$=CHR$(25)+CHR$(72)+CHR$(105)
CASE 140                           ! Œ
  l1$=CHR$(25)+CHR$(67)+CHR$(105)
CASE 147                           ! “
  l1$=CHR$(25)+CHR$(67)+CHR$(111)
CASE 148                           ! ”
  l1$=CHR$(25)+CHR$(72)+CHR$(111)
CASE 150                           ! –
  l1$=CHR$(25)+CHR$(67)+CHR$(117)
CASE 151                           ! —
  l1$=CHR$(25)+CHR$(65)+CHR$(117)
CASE 156                           ! œ
  l1$=CHR$(25)+CHR$(35)
CASE 158,225                       ! ž,á
  l1$=CHR$(25)+CHR$(123)
CASE 171                           ! «
  l1$=CHR$(25)+CHR$(61)
CASE 172                           ! ¬
  l1$=CHR$(25)+CHR$(60)
CASE 180                           ! ´
  l1$=CHR$(25)+CHR$(122)
CASE 181                           ! µ
  l1$=CHR$(25)+CHR$(106)
CASE 221                           ! Ý
  l1$=CHR$(25)+CHR$(39)
CASE 241                           ! ñ
  l1$=CHR$(25)+CHR$(49)
CASE 246                           ! ö
  l1$=CHR$(25)+CHR$(56)
CASE 248                           ! ø
  l1$=CHR$(25)+CHR$(48)
DEFAULT
  l1$="?"
ENDSELECT
RETURN
> PROCEDURE connecte
'
' Cnx/deco logique:
'
DEFMOUSE 2
IF connecte!                          ! Si on est cnt
  titre("D‚connexion logique")
  CLR connecte!                         ! On signale qu'on n'est plus cnt
ELSE                                  ! Si on est d‚co
  titre("Connexion logique")
  connecte!=TRUE                        ! On signale qu'on est cnt
  veille_off                            ! Sort du mode veille
ENDIF
~MENU_ICHECK(menu.adr%,connecte|,-connecte!) ! Check Cnt ?
m_iena(1+connecte!,MKI$(porteu|))
m_iena(-connecte!,MKI$(deco|))
IF serveur!                           ! Si le serv est charg‚...
  m_iena(1+connecte!,MKI$(m_loc|)+MKI$(m_off|))  ! 520_1040
ENDIF
PAUSE 30
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)                ! Active menu
RETURN
> PROCEDURE control_folder(mode&,nom$,rep$)
LOCAL l.rep$,l.rep2$,l.nom$
'
' Contr“le pr‚sence dossier
'
set_string(5,"Dossier "+nom$)
set_string(6,"Test de pr‚sence")
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
'
l.rep2$=LEFT$(rep$,PRED(LEN(rep$)))
l1|=RINSTR(l.rep2$,"\")
IF l1|
  l.rep$=LEFT$(l.rep2$,l1|)
  l.nom$=MID$(l.rep2$,SUCC(l1|))
ENDIF
search_folder:
directory(l.rep$,"*.*",FALSE,FALSE)   ! Directory
IF nb_paths&
  FOR l1&=1 TO nb_paths&                ! On cherche le dossier
    EXIT IF path$(l1&)=rep$
  NEXT l1&
ELSE
  l1&=1
ENDIF
IF l1&=SUCC(nb_paths&) AND LEN(l.nom$)  ! Si dossier n'exist pas
  IF mode&=FALSE
    ALERT 2,"Le dossier: "+l.nom$+" n'existe|pas ou ne figure dans le|r‚pertoire indiqu‚ dans le|champ: "+nom$+".",1,"Retry|Suivant|Abandon",l1|
    IF l1|=2                              ! Suivant
      l.folder&=-2
    ELSE IF l1|=3                         ! Abandon
      l.folder&=FALSE
    ELSE                                  ! Retry
      GOTO search_folder
    ENDIF
  ELSE
    l.folder&=FALSE
  ENDIF
ELSE
  l.folder&=TRUE
ENDIF
RETURN
> PROCEDURE ctrl_pagemem(VAR p.cour$)
'
' Pour compatibilit‚ STUT 2.34 => 2.40
'
IF LEN(parametre$(46))=FALSE  ! Si page de version 2.34
  parametre$(46)="2.40"         ! Format ‚tendu pour version 2.40
  l1&=VAL(parametre$(40))
  FOR l2&=0 TO 9                ! Parcourt les PM
    IF BTST(l1&,l2&)              ! Si PM valid‚e
      parametre$(50+l2&)=p.cour$    ! Nom de la page arbo courante
    ENDIF
  NEXT l2&
ENDIF
RETURN
> PROCEDURE ctrl_msgsys
IF LEN(parametre$(60))=FALSE  ! Si page de version 2.34
  parametre$(60)="2.40"         ! Format ‚tendu pour version 2.40
  FOR l1&=0 TO PRED(nb_msg_arbo&(fnct|))
    parametre$(61+l1&)=no_msg$(msg_arbo&(fnct|,l1&))   ! Fixe nom du message
  NEXT l1&
ENDIF
RETURN
> PROCEDURE cur_dir
g1$=CHR$(65+GEMDOS(25))+":"+DIR$(0)+"\"
RETURN
'
> PROCEDURE deco
'
' Deconnexion:
'
titre("D‚connexion physique")         ! Aff titre
DEFMOUSE 2
@deconnexion
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)                ! Active menu
RETURN
> PROCEDURE decode_accent(a|,b|)
'
' D‚code car sp‚ciaux du minitel:
'
l1|=1                         ! A priori on peut d‚coder
SELECT a|                     ! En fonction du type de caractŠre
CASE 35
  l1$="œ"
CASE 39
  l1$="Ý"
CASE 48
  l1$="ø"
CASE 49
  l1$="ñ"
CASE 56
  l1$="ö"
CASE 60
  l1$="¬"
CASE 61
  l1$="«"
CASE 65                       ! Accent grave
  SELECT b|
  CASE 97
    INC l1|
    l1$="…"
  CASE 101
    INC l1|
    l1$="Š"
  CASE 117
    INC l1|
    l1$="—"
  DEFAULT
    CLR l1|                     ! D‚codage impossible
  ENDSELECT
CASE 66                       ! Accent aigu
  SELECT b|
  CASE 101
    INC l1|
    l1$="‚"
  DEFAULT
    CLR l1|                     ! D‚codage impossible
  ENDSELECT
CASE 67                       ! Accent circonflexe
  SELECT b|
  CASE 97
    INC l1|
    l1$="ƒ"
  CASE 101
    INC l1|
    l1$="ˆ"
  CASE 105
    INC l1|
    l1$="Œ"
  CASE 111
    INC l1|
    l1$="“"
  CASE 117
    INC l1|
    l1$="–"
  DEFAULT
    CLR l1|                     ! D‚codage impossible
  ENDSELECT
CASE 72                       ! Trema
  SELECT b|
  CASE 97
    INC l1|
    l1$="„"
  CASE 101
    INC l1|
    l1$="‰"
  CASE 105
    INC l1|
    l1$="‹"
  CASE 111
    INC l1|
    l1$="”"
  CASE 117
    INC l1|
    l1$=""
  DEFAULT
    CLR l1|                     ! D‚codage impossible
  ENDSELECT
CASE 75                       ! C‚dille
  SELECT b|
  CASE 99
    INC l1|
    l1$="‡"
  DEFAULT
    CLR l1|                     ! D‚codage impossible
  ENDSELECT
CASE 106
  l1$="µ"
CASE 122
  l1$="´"
CASE 123
  l1$="ž"
DEFAULT
  CLR l1|                     ! D‚codage impossible
ENDSELECT
RETURN
> PROCEDURE decode_alt
'
' D‚codage d'une page alternative
'
altern_mode&=VAL(LEFT$(l1$))
altern_level&=VAL(MID$(l1$,2,1))
l1&=10
ARRAYFILL nb_alt_page&(),0
FOR l3&=0 TO 17
  l2&=INSTR(l1$,CHR$(0),SUCC(l1&))
  alternative$(l3&)=MID$(l1$,SUCC(l1&),PRED(l2&-l1&))
  IF LEN(alternative$(l3&))
    INC nb_alt_page&(l3&\6)
  ENDIF
  l1&=l2&
NEXT l3&
RETURN
> PROCEDURE decode_page_arbo
'
' Extraction des paramŠtres d'une page arbo
'
FOR l1|=0 TO 80
  l1&=INSTR(l1$,CHR$(0))
  IF l1&=0
    parametre$(l1|)=""
  ELSE
    parametre$(l1|)=LEFT$(l1$,PRED(l1&))
    l1$=MID$(l1$,l1&+1)
  ENDIF
NEXT l1|
RETURN
> PROCEDURE deconnexion
'
' Deconnexion du serveur:
'
OUT 1,20,27,57,103            ! Deco
IF mod_norm!=FALSE AND mi2!   ! Si mode local et M2
  OUT 1,27,57,87,27,57,88       ! LibŠre la ligne
ENDIF
CLR connecte!
~MENU_ICHECK(menu.adr%,connecte|,0) ! Uncheck cnt
m_iena(0,MKI$(deco|))
m_iena(-serveur!,MKI$(m_loc|)+MKI$(m_off|))   ! 520_1040
m_iena(1,MKI$(porteu|))
PAUSE 20
WHILE INP(TRUE)
  ~INP(1)
WEND
RETURN
> PROCEDURE directory(path$,mask$,disp!,shell!)
LOCAL len1&,len2&,pos1&,string$
'
' Lit le contenu d'un dossier:
'
CLR nb_paths&,nb_files%
IF shell!
  PRINT #99;SPC(3);path$;mask$;" ="
ENDIF
~FSETDTA(BASEPAGE+128)
l1&=FSFIRST(path$+mask$,&X10000)
DO UNTIL l1& OR nb_files%=500 OR nb_paths&=100
  l1$=CHAR{BASEPAGE+158}
  IF shell!
    len1&=LEN(l1$)
    pos1&=RINSTR(l1$,"\",PRED(len1&))
    len2&=len1&-pos1&
    string$=MID$(l1$,SUCC(pos1&),len2&)
    PRINT #99;SPC(6);string$;SPC(13-len2&);
  ENDIF
  IF (l1$<>"." AND l1$<>"..") OR shell!
    IF BTST(attrib|,4)                      ! S'il s'agit d'un dossier
      INC nb_paths&
      path$(nb_paths&)=path$+l1$+"\"
      IF shell!
        PRINT #99;" <Folder> ";
      ENDIF
    ELSE                                    ! S'il s'agit d'un fichier
      INC nb_files%
      IF disp!                                ! Si on doit afficher le nb
        set_vlstring(10,nb_files%,4)
        ~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
      ELSE IF shell!
        string$=STR$(longueur%)
        len1&=LEN(string$)
        PRINT #99;SPC(9-len1&);string$;" ";
      ENDIF
      file$(nb_files%)=l1$
      length%(nb_files%)=longueur%
    ENDIF
    IF shell!
      PRINT #99
    ENDIF
  ENDIF
  l1&=FSNEXT()
LOOP
RETURN
> PROCEDURE duree_tel(long%)
'
' Calcul dur‚e t‚l‚chargement:
' selon F. PLANQUE et non selon P. SAUCOURT-HARMEL
'
l1$=RIGHT$("  "+STR$((long%+6130)\6131),3)+" mn"
RETURN
'
> FUNCTION edit$(a|)
RETURN CHAR{{OB_SPEC(adr%,a|)}}
ENDFUNC
> PROCEDURE editarbo_noyau(long&,exit&,p.obj&)
LOCAL l_no&,l_param&,l_str&
'
LOCAL l.obj1&
l.obj1&=SUCC(p.obj&)
'
'
'
FOR l1&=0 TO 19
READ ligne|(l1&)
NEXT l1&
aes_draw
DEFMOUSE 0
DO
b%=FORM_DO(adr%,0)
b%=b% AND &H7FFF            ! 17/8/93: d‚gage MSBit
EXIT IF b%=>exit&
l_no&=TRUE
FOR l1&=0 TO 4
  IF b%=ligne|(l1&)
    l_no&=l1&
  ENDIF
NEXT l1&
IF l_no&=>0                  ! Si Demande de fileselect
  l_param&=ligne|(5+l_no&)
  l_str&=ligne|(15+l_no&)
  l1$=parametre$(l_param&)
  IF ligne|(10+l_no&)=FALSE
    l2$=""
    f_titre$="CHOIX DU DOSSIER"
  ELSE
    l2$="*.*"
    f_titre$="CHOIX DU MODULE"
  ENDIF
  l1|=RINSTR(l1$,"\")
  FILESELECT #f_titre$,LEFT$(l1$,l1|)+l2$,MID$(l1$,SUCC(l1|)),l1$
  l1|=RINSTR(l1$,"\")
  IF l2$=""
    IF LEN(l1$)
      parametre$(l_param&)=LEFT$(l1$,l1|)
      IF RIGHT$(parametre$(l_param&),2)=".\"
        parametre$(l_param&)=LEFT$(l1$,l1|-2)+"\"
      ENDIF
    ENDIF
  ELSE
    IF EXIST(l1$)
      parametre$(l_param&)=l1$
    ENDIF
  ENDIF
  l1|=LEN(parametre$(l_param&))
  IF l1|<=long&
    set_edit(l_str&,parametre$(l_param&)+SPACE$(long&-l1|))
  ELSE
    set_edit(l_str&,LEFT$(parametre$(l_param&),long&))
  ENDIF
  IF tt!
    l1&=0
  ELSE
    l1&=l_str&
  ENDIF
  ~OBJC_DRAW(adr%,l1&,6,x%,y%,w%,h%)
ENDIF
SELECT b%
CASE p.obj&
  edit_pagemem(adr%)
CASE l.obj1&
  edit_msgsys(adr%)
ENDSELECT
~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,32,1)
LOOP
aes_erase
'
RETURN
> PROCEDURE enable_maj(type&)
'
' enable maj
'
modify!(0)=TRUE               ! On a modifi‚ qqch ds le serv
modify!(type&)=TRUE           ! On a modifi‚ tel ou tel type d'objet
m_iena(1,MKI$(maj|))          ! Autorise clik  520_1040
RETURN
> PROCEDURE envoi_chaine(t$)
'
' Envoi au mntl une chaine de car accentu‚s:
'
l2&=LEN(t$)                   ! Long (sert parfois aussi au retour)
FOR l3&=1 TO l2&
l1$=MID$(t$,l3&,1)
l1|=ASC(l1$)
IF l1|>127
  IF mixt!                      ! 80 col
    accent_80(l1|)
  ELSE                          ! 40 col
    code_accent(l1|)
  ENDIF
ENDIF
PRINT #99;l1$;
NEXT l3&
RETURN
> PROCEDURE erreur
'
' Traitement des erreurs:
'
LOCAL err_msg$,err_type&
'  OUT 2,7
erreur&=ERR
SELECT erreur&                ! Selon l'erreur
CASE -6,-13                   ! Disk r‚pond pas,Disk prot‚g‚
err_choix&=1                  ! On a choisi d'annuler
CASE -33
err_msg$="[1][|Fichier introuvable!][Annuler|Recommencer]"
CASE -36
err_msg$="[3][AccŠs impossible:|Fichier prot‚g‚ en ‚criture,|ou dossier existe d‚j…!][Annuler]"
CASE -46
err_msg$="[2][|L'unit‚ de disque sollicit‚e|n'existe pas!][Annuler]"
CASE 26                       ! Fin de fichier atteinte EOF
err_msg$="[3][Format de fichier|non reconnu par|cette version|du logiciel!][Annuler]"
CASE 37
err_msg$="[1][Le disque est satur‚!|Effacez les fichiers inutiles|ou bien utilisez une|disquette viŠrge formatt‚e...][Annuler|Recommencer]"
DEFAULT
IF serveur! AND modify!(0)
  ' 520_1040...  mise … jour impossible dans USE ONE
  err_msg$="[3][Il s'est produit une erreur|impr‚vue! Le programme est|interrompu, mais vous pouvez|tenter de sauver le serveur|sur disque...][Sauver|Interrompre]"
  err_type&=1
ELSE
  err_msg$="[3][Il s'est produit une erreur|impr‚vue! Le programme est|interrompu, mais vous aviez|enregistr‚ toutes les|modifications... (OUF!)][Interrompre]"
  err_type&=2
ENDIF
ENDSELECT
IF err_choix&=FALSE
err_choix&=FORM_ALERT(1,err_msg$)     ! Dialogue avec utilisateur
ELSE IF err_choix&=10
err_choix&=11
ENDIF
IF err_type&                          ! Si erreur fatale
IF err_type&=1 AND err_choix&=1
  maj                           ! 520_1040
ENDIF
CLOSE                         ! Ferme tous les canaux ouverts
' -- 520_1040 ---------------------
IF teaser_down!               ! Si on ‚tait en plein t‚l‚chargement
  libere                        ! LibŠre les mallocs de TransTeaser
ENDIF
IF teaser_upl!                ! Idem pour upload
  libere_tel_inv
ENDIF
' ---------------------------------
IF window!
  ~WIND_CLOSE(handle%)          ! Ferme fenetre
  ~WIND_DELETE(handle%)         ! Efface fenetre de la ram
ENDIF
~MFREE(screen.zone%)
~RSRC_FREE()                  ! Efface les rsrc de la ram
RESERVE                       ! Restore ram allou‚e
IF inter!                     ! Si on est sous interpr‚teur GfA BASIC
  RESUME                        ! on va retourner … la ligne pour avoir l'erreur pour de vrai
ELSE
  EDIT
ENDIF
ELSE                          ! Si erreur disk on du genre...
ON ERROR GOSUB erreur
SELECT err_resume&
CASE 1
  RESUME err_1
CASE 2
  RESUME err_2
CASE 3
  RESUME err_3
CASE 4
  RESUME err_4
CASE 5
  RESUME err_5
CASE 6
  RESUME err_6
CASE 7
  RESUME err_7
CASE 8
  RESUME err_8
CASE 9
  RESUME err_9
CASE 10
  RESUME err_10
CASE 11
  RESUME err_11
CASE 12
  RESUME err_12
CASE 13
  RESUME err_13
CASE 14
  RESUME err_14
CASE 15
  RESUME err_15
DEFAULT
  RESUME NEXT
ENDSELECT
ENDIF
RETURN
> PROCEDURE espaces
'
' Aff m‚moires libres:
'
titre("M‚moires libres")
adr%=espaces.adr%
DEFMOUSE 2
set_vstring(7,nbn_vdt&,4)
set_vstring(8,nbn_arbo&,4)
set_vstring(9,nbn_alt&,4)
set_vstring(10,nb_msgsys&,4)
set_vstring(19,nb_mots&,4)
set_vstring(20,nbn_rub&,4)
set_vstring(21,nbn_aff&,4)
set_vstring(22,nb_pseudos&,4)
FOR l1&=29 TO 35 STEP 2
set_string(l1&,"")
NEXT l1&
set_vstring(37,FRE(0),7)
~FORM_CENTER(adr%,x%,y%,w%,h%)
DEC x%
DEC y%
ADD w%,4
ADD h%,4
~FORM_DIAL(0,0,0,0,0,x%,y%,w%,h%)
~OBJC_DRAW(adr%,0,7,x%,y%,w%,h%)
FOR l1&=0 TO 3
l2&=29+2*l1&
IF l1&
  FOR l3&=0 TO PRED(l1&)
    IF ASC(chemin$(l1&))=ASC(chemin$(l3&))
      set_string(l2&,CHAR{OB_SPEC(adr%,29+2*l3&)})
      EXIT IF TRUE
    ENDIF
  NEXT l3&
ELSE
  l3&=l1&
ENDIF
IF l3&=l1&
  l1%=DFREE(ASC(chemin$(l1&))-64)
  set_vstring(l2&,l1%,8)                ! On fixe le DFREE
ENDIF
~OBJC_DRAW(adr%,l2&,1,x%,y%,w%,h%)
NEXT l1&
DEFMOUSE 0
b%=FORM_DO(adr%,0)
set_state(b%,0,0,0)
~FORM_DIAL(3,0,0,0,0,x%,y%,w%,h%)
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE externe
'
' Appel prg externe
'
titre("Appel d'un programme externe")
cur_dir               ! Directory courant\ ==> g1$
f_titre$="APPEL PROG EXT"
g1$=FN file$(1,g1$+"*.PRG","",l1$)
IF LEN(g1$)
DEFMOUSE 2
OPEN "I",#1,g1$
g2%=LOF(#1)
CLOSE #1
~FRE(0)                       ! Garbage Collection
g1%=FRE(0)-512                ! M‚moire dispo pour prg
IF g1%>g2%+512
  RESERVE FRE(0)-g1%            ! Reserve un maximum de RAM pour le module
  EXEC 0,g1$,l1$,""             ! Appel module
  RESERVE FRE(0)+g1%-255        ! R‚cupŠre RAM r‚serv‚e
  fond_bureau
ELSE
  ALERT 3,"M‚moire insuffisante!",1,"   OK   ",l1&
ENDIF
DEFMOUSE 0
ENDIF
~MENU_BAR(menu.adr%,1)                ! Active menu
RETURN
'
> PROCEDURE ferme_def
CLOSE #1
fram
RETURN
> PROCEDURE fram
OUT 1,0,0,0,0,0,13,10,24,15
envoi_chaine("M‚moire libre:")
PRINT #99;'FRE(0)\1024'"Ko"
RETURN
> PROCEDURE fiche_champ
'
' Extrait les params d'un champ d'une fiche
'
l1$=parametre$(13+g1&)
IF g1&<2
l5|=1                         ! Enable Aff
ELSE
l5|=fiches_param&(g0&,g1&-2,0)  ! Champ de fiche Valide ou pas?
ENDIF
l3|=1-l5|                     ! Disable?
l1|=VAL(LEFT$(l1$))*l5|       ! Affichable
'
l6|=-(g1&>1)*l5|              ! Enable edit ?
l4|=1-l6|                     ! Disable Edit ?
l2|=VAL(MID$(l1$,2,1))*l6|    ! Editable
'
l2$=TRIM$(MID$(l1$,3,2))      ! X
l3$=TRIM$(MID$(l1$,5,2))      ! Y
l4$=TRIM$(MID$(l1$,7,2))      ! Lg Min
l5$=TRIM$(MID$(l1$,9,7))      ! Backup to
l1$=MID$(l1$,16)              ! D‚faut
RETURN
> FUNCTION file$(mode&,path$,def$,VAR nom$)
LOCAL file$
'
' Fileselect
'
sel_file:
FILESELECT #f_titre$,path$,def$,file$
IF LEN(file$)
DEFMOUSE 2
l1&=RINSTR(file$,".")
l2&=RINSTR(file$,"\")
curr_path$=LEFT$(file$,l2&) ! Extrait le chemin d'accŠs
INC l2&
IF l1&=l2&
nom$="SANS_NOM"
ELSE
IF l1&<l2&
  l1&=SUCC(LEN(file$))
ENDIF
SUB l1&,l2&
nom$=MID$(file$,l2&,l1&)      ! Extrait le nom
ENDIF
'
l1&=EXIST(file$)
DEFMOUSE 0
l1$="Le fichier "+MID$(file$,l2&)
IF l1&=FALSE AND mode&=1
ALERT 1,l1$+"|n'existe pas ou ne|figure pas dans le|dossier indiqu‚!",1,"   OK   ",l2&
GOTO sel_file
ELSE IF l1&=TRUE AND mode&=2
ALERT 1,l1$+"|va ˆtre ‚cras‚!|Voulez-vous|continuer?",1,"Continue|Abandon",l2&
IF l2&=2
  GOTO sel_file
ENDIF
ENDIF
'
ENDIF
RETURN file$
ENDFUNC
> PROCEDURE file2touch(p.name$,VAR p.op$)
'
' indique fichier … charger:
'
set_string(11,p.name$)        ! Nom
set_string(10,"1")            ! Nombre
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
set_string(6,p.op$)
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
RETURN
> PROCEDURE fin_cs_type
'
' fin chargement ou sauvegarde d'un type d'objet
'
set_string(11,"")
set_string(10,"0")
~OBJC_DRAW(fichiers.adr%,9,3,x%,y%,w%,h%)
RETURN
> PROCEDURE find_base
'
' Trouve une base de donn‚es:
'
base$=parametre$(4)             ! Nom de la base
g0&=0
IF nb_base&                   ! Cherche base
FOR g0&=0 TO PRED(nb_base&)
EXIT IF nom_base$(g0&)=base$ AND info_base|(g0&)<>2
NEXT g0&
ENDIF
RETURN
> FUNCTION find_page(VAR nom$,nbp&,tab$())
'
' Trouve une page VDT/ABR ds la liste
'
IF nbp&                       ! S'il y a des pages
FOR l1&=0 TO PRED(nbp&)       ! Cherch page dem
EXIT IF tab$(l1&)=nom$
NEXT l1&
IF l1&<nbp&
RETURN l1&
ENDIF
ENDIF
RETURN TRUE
ENDFUNC
> PROCEDURE fond_bureau
'
' Dessine le fond du bureau:
'
~FORM_DIAL(3,0,0,0,0,x_desk&,y_desk&,w_desk&,h_desk&)
LINE x_desk&,h_menu&,PRED(x_desk&+w_desk&),h_menu&
RETURN
> PROCEDURE font_restore
'
' Restore les fontes DRCS si elles ‚taient valid‚es:
'
IF drcs0!
OUT 1,27,40,32,66
ENDIF
IF drcs1!
OUT 1,27,41,32,67
ENDIF
RETURN
> PROCEDURE fnct(f|)
'
' Transforme le nø de fnct d'une page arbo en nom de fnct:
'
CLR g2$
SELECT f|
CASE 1
g2$="START"
CASE 2
g2$="IMAGE"
CASE 3
g2$="STOP"
CASE 4
g2$="DIALOGUE"
CASE 5
g2$="TELECHAR"
CASE 6
g2$="PSEUDO"
CASE 7
g2$="MENU"
CASE 8
g2$="TABL_CNX"
CASE 9
g2$="TEL_INV"
CASE 10
g2$="LECT_RUB"
CASE 11
g2$="ECRI_RUB"
CASE 12
g2$="LIST_RUB"
CASE 13
g2$="CREE_BAL"
CASE 14
g2$="BALS_ANN"
CASE 15
g2$="LECT_BAL"
CASE 16
g2$="ECRI_BAL"
CASE 17
g2$="EFFA_BAL"
CASE 18
g2$="EDIT_REP"
CASE 19
g2$="LIST_ENV"
CASE 20
g2$="LIST_REC"
CASE 21
g2$="EFFA_REP"
CASE 22
g2$="EFF_MSGB"
CASE 23
g2$="FICHE_ID"
CASE 24
g2$="INFO_CNT"
CASE 25
g2$="JOURNAL"
'
' 26:RACER retir‚ … partir de la v 2.30
' 27:SCORES retir‚ … partir de la v 2.30
'
CASE 28
g2$="AFFICHE"
CASE 29
g2$="MSG_GUID"
CASE 30
g2$="NEDER"
CASE 31
g2$="FIN"
CASE 32
g2$="ACCES"
CASE 33
g2$="BETA_MOD"
CASE 34
g2$="EDT_FICH"
CASE 35
g2$="TRANSIT"
CASE 36
g2$="SHELL"
CASE 37
g2$="TEXTE"
DEFAULT
g2$=""
ENDSELECT
RETURN
'
> PROCEDURE get_bout(p.param&,p.start_obj&,p.nb_obj&)
'
' Extract bout:
'
CLR l1&
FOR l2&=0 TO p.nb_obj&        ! Extract pm
IF FN selected(p.start_obj&+l2&)
l1&=BSET(l1&,l2&)
ENDIF
NEXT l2&
parametre$(p.param&)=STR$(l1&)
RETURN
> FUNCTION get_radio(p.first&,p.nbb&)
DEC p.nbb&
FOR l1&=0 TO p.nbb&
IF FN selected(p.first&+l1&)
RETURN l1&
ENDIF
NEXT l1&
ENDFUNC
> FUNCTION get_value(p.obj&,p.min%,p.max%)
l1%=VAL(FN edit$(p.obj&))
IF l1%<p.min%
edit_changed!=TRUE          ! On a modifi‚!
RETURN p.min%
ELSE IF l1%>p.max%
edit_changed!=TRUE          ! On a modifi‚!
RETURN p.max%
ENDIF
RETURN l1%
ENDFUNC
'
> PROCEDURE imprime_fenetre
LOCAL confirm|
'
IF BIOS(8,0)                ! Si imprimante prˆte:
ALERT 2,"|Imprimer le contenu|de cette fenˆtre?",2,"Imprimer|Annuler",confirm|
IF confirm|=1               ! Si confirmation de l'impression
LPRINT "Listing:"'w_name$
LPRINT "Date:"'DATE$'"  Heure:"'TIME$
LPRINT
FOR l1%=0 TO nbl%
LPRINT editor$(l1%)       ! Imprime une ligne
NEXT l1%
LPRINT
LPRINT
LPRINT
LPRINT
LPRINT
ENDIF
ELSE                ! Si imprimante pas prˆte
ALERT 1,"|L'imprimante n'est|pas prˆte … recevoir|des donn‚es...",1,"Annuler",confirm|
ENDIF
RETURN
> PROCEDURE infos_cop
'
' Aff infos/copyright:
'
titre("Informations")
adr%=cr.adr%
affiche_rsc
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE init_edit_520_1040
'
' Editeur dem:
'
DIM edit_buff$(3)
'
' Nom des messages systŠme
'
LINE INPUT #1,l1$
DIM nom_msg$(71),no_msg$(71)
RECALL #1,nom_msg$(),72,void
FOR l1&=0 TO 71
no_msg$(l1&)=RIGHT$(nom_msg$(l1&),3)
nom_msg$(l1&)=LEFT$(nom_msg$(l1&),LEN(nom_msg$(l1&))-3)
NEXT l1&
'
' Champs page FICHE_ID
'
DIM fid.champ$(21)
LINE INPUT #1,l1$
RECALL #1,fid.champ$(),22,l1%
'
RETURN
> PROCEDURE init_cnx_520_1040
'
' Traitement inter-pages
'
DIM page_memo$(9)               ! Memoire de pages
'
' Bals:
'
call_value(nb_bal_max&)       ! Nombre de bals maximum
init_pages.memset(26,nb_bal_max&)
DIM pseudo$(nb_bal_max&)      ! Liste des pseudos
DIM code$(nb_bal_max&)        ! Liste des codes
DIM bal_no%(nb_bal_max&)      ! Relations pseudos -> codes.
FOR l1&=0 TO nb_bal_max&      ! Init relations
bal_no%(l1&)=l1&
NEXT l1&
'
DIM info_cnt$(9)                ! Infos sur le cnt
'
DIM msg_envoi$(19)              ! Liste des msgs envoy‚s
DIM msg_bal$(19)                ! Msgs en BAL
DIM msg_disk$(19)               ! Msgs … envoyer
DIM msg_lus$(19)                ! Msgs lus
'
LINE INPUT #1,l1$
INPUT #1,bal_nb_pagemsg|        ! Nb pages par msg par d‚faut
INPUT #1,bal_nb_lignepage|      ! Nb lignes par page par d‚faut
INPUT #1,bal_titre!             ! Il y a un titre aux msgs en BAL par d‚f
INPUT #1,rep_nbl|               ! Nb lignes du rep par d‚f
'
' Messages systŠme / page arbo:
'
DIM nb_msg_arbo&(37),msg_arbo&(37,11)
LINE INPUT #1,l1$,l2$
FOR l1&=1 TO 37                 ! Parcourt pages ARBO
l2&=0
INPUT #1,l1$
WHILE ASC(l1$)>42             ! Si on arrive pas … la page suivante
msg_arbo&(l1&,l2&)=VAL(l1$)     ! Stocke no$ du message
INC l2&                         ! Un msg de plus!
INPUT #1,l1$
WEND
nb_msg_arbo&(l1&)=l2&           ! Nb messages pour la page!
NEXT l1&
'
' Enregistr cnxs:
'
DIM connecte$(19)               ! 20 derniŠres cnxs
FOR l1|=0 TO 19
connecte$(l1|)="}"+CHR$(27)+CHR$(69)+SPACE$(16)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+"     "+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+SPACE$(8)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+"      "+CHR$(27)+CHR$(71)+"{"
NEXT l1|
'
' Divers
'
DIM x|(26),y|(26),lg_max|(26),aff_champ!(26),edit_champ!(26),lg_min|(26),champ$(26)
DIM key|(9)
DIM sextet%(2)                  ! Pour le d‚codage de l'upload
call_value(nb_charpass_max&)    ! Nb passes maximum
DIM file_loc%(nb_charpass_max&) ! Visu enregistrement des cnxs
'
' 50Šmes de seconde n‚cessaires … la validation d'un appel:
'
call_value(n_duree_valid_ring&) ! Dur‚e de validation
RETURN
> PROCEDURE init_totale
'
' Init totale du serveur
'
' Pages vdt:
'
init_totale.pages(nbp_vdt&,page_vdt$(),nom_vdt$(),info_vdt|()) ! init les pages
init_totale.alpha(nbn_vdt&,alpha_vdt$())  ! Init les noms
'
' Pages arbo:
'
init_totale.pages(nbp_arbo&,page_arbo$(),nom_arbo$(),info_arbo|()) ! init les pages
init_totale.alpha(nbn_arbo&,alpha_arbo$())  ! Init les noms
'
' Rub:
'
IF nb_rub&                    ! S'il y a des rub
FOR l1&=0 TO PRED(nb_rub&)    ! On va ttes les effacer
FOR l1|=0 TO nbm_rub_max&     ! Parcourt messages
msg_rub$(l1&,l1|)=""          ! Eff msg
NEXT l1|
nom_rub$(l1&)=""              ! Nom
info_rub|(l1&)=FALSE          ! Infos
NEXT l1&
ARRAYFILL param_rub|(),0
nb_rub&=FALSE                 ! Plus de rub
ENDIF
init_totale.alpha(nbn_rub&,alpha_rub$())  ! Init les noms
'
' Affiches:
'
IF nb_aff&                    ! S'il y a des aff
FOR l1&=0 TO PRED(nb_rub&)    ! On va ttes les effacer
FOR l1|=0 TO nbl_aff_max&     ! Parcourt lignes
ligne_aff$(l1&,l1|)=""        ! lignes
NEXT l1|
nom_rub$(l1&)=""              ! Nom de l'aff
info_aff|(l1&)=FALSE          ! Infos
NEXT l1&
ARRAYFILL param_aff|(),0
nb_aff&=FALSE                 ! Plus d'aff
ENDIF
init_totale.alpha(nbn_aff&,alpha_aff$())  ! Init les noms
'
' Bases de donn‚es:
'
IF nb_base&                    ! S'il y a des bases
FOR l1&=0 TO PRED(nb_base&)    ! On va ttes les effacer
nom_base$(l1&)=""              ! Nom de la base
info_base|(l1&)=FALSE          ! Infos base
FOR l2&=0 TO 24
fiches_nom$(l1&,l2&)=""
NEXT l2&
NEXT l1&
ARRAYFILL base_param%(),0
ARRAYFILL fiches_param&(),0
ARRAYFILL nb_fiches_base%(),0
nb_base&=FALSE                 ! Plus de base
ENDIF
init_totale.alpha(nbn_base&,alpha_base$())  ! Init les noms
'
' Pages alt:
'
init_totale.pages(nbp_alt&,page_alt$(),nom_alt$(),info_alt|()) ! init les pages
init_totale.alpha(nbn_alt&,alpha_alt$())  ! Init les noms
'
' Pages START/STOP
'
start_page$=""
stop_page$=""
error_page$=""
FOR l1&=0 TO 9
off_vdt$(l1&)=""               ! 10 Pages vdt
NEXT l1&
sysop_page$=""
sysop_maxlong&=30
'
' Mots clef:
'
IF nb_mots&                   ! S'il y a des mots clef
FOR l1&=0 TO PRED(nb_mots&)   ! On va tous les ‚ffacer
mot$(l1&)=""                  ! Eff mot
page$(l1&)=""                 ! Eff page corresp
NEXT l1&
nb_mots&=FALSE                ! Plus de mot clef
ENDIF
'
' Messages systŠme:
'
FOR l1&=0 TO nb_msgsys&
msgsys$(l1&)=""
NEXT l1&
nb_msgsys&=0
'
' Liste des bals:
'
FOR l1&=0 TO nb_bal_max&      ! On va ‚ffacer la liste
pseudo$(l1&)=""               ! Pseudo
code$(l1&)=""                 ! Code
bal_no%(l1&)=l1&              ! Nø des BALS
NEXT l1&
info_list|=FALSE              ! Pas de modif
nb_pseudos&=FALSE             ! Plus de BAL
nb_nums&=FALSE                ! Plus de nø de BAL
'
bal_nb_pagemsg|=5             ! Nb pag/msg
bal_nb_lignepage|=15          ! Nb lignes/pag
bal_titre!=TRUE               ! Il y a un titre
rep_nbl|=15                   ! Nb lignes du rep
'
' Tableau des connexions:
'
nb_appels%=0                  ! Chargement du nb d'appels
d_totale%=0                   ! Chargement de la dur‚e totale
FOR l1|=0 TO 19
connecte$(l1|)="}"+CHR$(27)+CHR$(69)+SPACE$(16)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+"     "+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+SPACE$(8)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+"      "+CHR$(27)+CHR$(71)+"{"
NEXT l1|
'
'
' -- MAKE_ONE ----------------
'
first_vdt&=FALSE
first_arbo&=FALSE
first_alt&=FALSE
first_rub&=FALSE
first_aff&=FALSE
first_base&=FALSE
RETURN
> PROCEDURE init_totale.alpha(VAR p.nbn&,p.alpha$())
'
' Init les noms d'une certaine cat‚gorie
'
IF p.nbn&                   ! S'il y a des noms dans la liste
FOR l1&=0 TO PRED(p.nbn&)   ! On va tous les ‚ffacer
p.alpha$(l1&)=""            ! Eff nom
NEXT l1&
p.nbn&=FALSE                ! Plus de nom
ENDIF
RETURN
> PROCEDURE init_totale.pages(VAR p.nbp&,p.page$(),p.nom$(),p.info|())
'
' Init les pages d'une certaine cat‚gorie
'
IF p.nbp&                     ! S'il y a des pages
FOR l1&=0 TO PRED(p.nbp&)     ! On va ttes les effacer
p.page$(l1&)=""               ! Page compact‚e
p.nom$(l1&)=""                ! Nom
p.info|(l1&)=FALSE            ! Infos
NEXT l1&
p.nbp&=FALSE                  ! Plus de pages vdt
ENDIF
RETURN
> PROCEDURE init_pages
'
' Init des Pages:
'
DIM modify!(10)                  ! Modification pages
'
' Pages vid‚otex:
'
call_value(nbp_vdt_max&)        ! Nb pages VDT max
init_pages.memset(11,nbp_vdt_max&)
last_v&=SUCC(nbp_vdt_max&)
DIM page_vdt$(last_v&)          ! Pages VDT
DIM nom_vdt$(nbp_vdt_max&)      ! Noms des pages
DIM alpha_vdt$(nbp_vdt_max&)    ! Liste des pages
DIM info_vdt|(nbp_vdt_max&)     ! Info sur chaque page
'
' Pages arbo:
'
call_value(nbp_arbo_max&)       ! Nb pages arbo max
init_pages.memset(12,nbp_arbo_max&)
DIM page_arbo$(nbp_arbo_max&)   ! Pages arbo
DIM nom_arbo$(nbp_arbo_max&)    ! Nom des pages
DIM alpha_arbo$(nbp_arbo_max&)  ! Liste des pages
DIM info_arbo|(nbp_arbo_max&)   ! Info sur chaque page
'
' Rubriques:
'
call_value(nb_rub_max&)
init_pages.memset(24,nb_rub_max&)
call_value(nbm_rub_max&)
DIM msg_rub$(nb_rub_max&,nbm_rub_max&) ! Messages des rubs
DIM nom_rub$(nb_rub_max&)     ! Noms des rubs
DIM alpha_rub$(nb_rub_max&)   ! Liste des rubs
DIM info_rub|(nb_rub_max&)    ! Info sur chaque rub
DIM param_rub|(nb_rub_max&,5) ! ParamŠtres de chaque rub
'
' Affiches:
'
call_value(nb_aff_max&)
init_pages.memset(25,nb_aff_max&)
call_value(nbl_aff_max&)
DIM ligne_aff$(nb_aff_max&,nbl_aff_max&) ! Lignes des aff
DIM nom_aff$(nb_aff_max&)     ! Noms des aff
DIM alpha_aff$(nb_aff_max&)   ! Liste des aff
DIM info_aff|(nb_aff_max&)    ! Info sur chaque aff
DIM param_aff|(nb_aff_max&,3) ! ParamŠtres de chaque aff
'
' Bases de donn‚es:
'
call_value(nb_base_max&)
last_base&=SUCC(nb_base_max&)
'  init_pages.memset(25,nb_aff_max&)
DIM base_param%(last_base&,2)       ! ParamŠtres pour chaque base
DIM fiches_param&(last_base&,24,2)  ! ParamŠtres pour chaque fiche d'une base
DIM fiches_nom$(nb_base_max&,24)    ! Nom de chaque champ...
DIM nb_fiches_base&(nb_base_max&)   ! Nb fiches dans chaquse base
DIM nom_base$(nb_base_max&)     ! Noms des bases
DIM alpha_base$(nb_base_max&)   ! Liste des bases
DIM info_base|(nb_base_max&)    ! Info sur chaque base
'
LINE INPUT #1,l1$
INPUT #1,nbf_base_max%        ! Nb fiches max/base
'
' Pages alternatives:
'
call_value(nbp_alt_max&)      ! Nb pages ALT max
init_pages.memset(13,nbp_alt_max&)
DIM page_alt$(nbp_alt_max&)   ! Pages alt
DIM nom_alt$(nbp_alt_max&)    ! Nom des pages
DIM alpha_alt$(nbp_alt_max&)  ! Liste des pages
DIM info_alt|(nbp_alt_max&)   ! Info sur chaque page
'
' Mots clef:
'
call_value(nb_mc_max&)        ! Nb de mots clefs maximum
init_pages.memset(23,nb_mc_max&)
DIM mot$(nb_mc_max&)          ! Mots clef
DIM page$(nb_mc_max&)         ! Page & infos correspondantes
call_value(mc_long&)          ! Longueur max des mots clefs
'
' Messages systŠme:
'
call_value(nb_msgsys_max&)    ! Nb de msgs systŠme maximum
init_pages.memset(14,nb_msgsys_max&)
DIM msgsys$(nb_msgsys_max&)   ! Messages systŠme
call_value(msgsys_long&)      ! Longueur max des messages sys
'
' Attente en mode off_line:
'
DIM off_vdt$(9)               ! 10 Pages vdt
RETURN
> PROCEDURE init_pages.memset(p.obj&,p.val&)
'
CHAR{{OB_SPEC(espaces.adr%,p.obj&)}}="/"+LEFT$(STR$(SUCC(p.val&))+"   ",4)
RETURN
> PROCEDURE init_rs_520_1040
RESTORE vit_init
FOR l1|=1 TO 3
READ l2|
~XBIOS(15,l2|,0,174,-1,-1,-1)
PAUSE l1|
OUT 1,&H1B,&H3A,&H6B,&H76     ! Passage du minitel en 4800 Bds
PAUSE l2|
NEXT l1|
vit_init:
DATA 1,7,9
~XBIOS(15,2,0,174,-1,-1,-1)     ! RS 232 … 4800 Bds.
OPEN "O",#99,"AUX:"             ! Ouvre canal minitel
vitesse|=2                      ! 4800 Bds
PAUSE 1
OUT 1,20
videotex                        ! 40 col
page                            ! Rouleau OFF
veille_off                      ! Sort du mode veille
loc(1,0)
OUT 1,24,12
PRINT #99;"STUT ONE ";version$  ! 520_1040
OUT 1,27,69
PRINT #99;"(c)"'default_date%\10000'
envoi_chaine("by Fran‡ois PLANQUE.")
l1$=INPAUX$
RETURN
> PROCEDURE init_rs_2
~MENU_ICHECK(menu.adr%,menu_vit|+vitesse|,1) ! Valide vitesse ds menu
PAUSE 20
rs_in.adr%=LPEEK(XBIOS(14,0))   ! Adresse du tampon d'entr‚e
rs_out.adr%=LPEEK(XBIOS(14,0)+14) ! Adresse du tampon de sortie
rs_out(rs_out.adr%,5)           ! Tampon de sortie r‚duit … 5 octets
RETURN
> PROCEDURE init_serv
'
' Init du serv:
'
titre("Initialisation du serveur")
IF modify!(0)                 ! Si serv a ‚t‚ modif
ALERT 2,"Le serveur a ‚t‚ modifi‚ !|Etes vous sur de vouloir|l'initialiser sans sauver|votre travail ?",2,"Init.|Annuler",l1|
ELSE                          ! Si serv n'a pas ‚t‚ modif
ALERT 2,"Etes vous s–r de|vouloir initialiser|le serveur ?",1,"Init.|Annuler",l1|
ENDIF
IF l1|=1                      ! Si on veut vraiment init
DEFMOUSE 2
'
init_totale
'
FOR l1|=0 TO 10              ! Rien n'est modifi‚
modify!(l1|)=FALSE
NEXT l1|
serveur!=FALSE              ! Serv n'est pas charg‚
real_load&=FALSE
m_iena(1,MKI$(c_serv|)+MKI$(create_new|)+MKI$(chemins|)+MKI$(par_load|))
m_iena(0,MKI$(maj|)+ent_edit$+MKI$(m_loc|)+MKI$(m_off|))  ! 520_1040
OUT 1,31,64,65,24,12
DEFMOUSE 0
fram                                  ! Affiche Free RAM
ENDIF
~FRE(0)                       ! Garbage collection
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE init_supp
'
' Variables suppl‚mentaires:
'
call_value(nb_sec_veille&)    ! Nb passes maximum
'
' ParamŠtres de filtrage des BAL par d‚faut
'
date_filtre$=DATE$
levels_filtre$="AAAAAAAAAA"
RETURN
> PROCEDURE init_var_global
' M‚moire … laisser libre
LINE INPUT #1,l1$
INPUT #1,l1%                  ! Charge taille m‚moire … laisser libre
RESERVE FRE(0)-l1%
'
' Ecran de travail
'
LINE INPUT #1,l1$
INPUT #1,l1%                  ! Charge taille ‚cran virtuel ST
LINE INPUT #1,l1$
INPUT #1,l2%                  ! Charge taille ‚cran virtuel TT
IF tt!
l1%=l2%
ENDIF
RESERVE FRE(0)-l1%
screen.zone%=MALLOC(l1%)
IF tt!=FALSE
screen.adr%=(screen.zone%+255) AND &HFFFF00
ELSE
screen.adr%=screen.zone%
ENDIF
'
' Chaines de caractŠres:
'
DIM tpage$(6)
FOR l1|=0 TO 6                ! 0 bouffe le #nianiania
LINE INPUT #1,tpage$(l1|)
NEXT l1|
'
LINE INPUT #1,char$
LINE INPUT #1,maj$
LINE INPUT #1,gestion_tel$
LINE INPUT #1,enr_dispo$
LINE INPUT #1,nregistr$
'
DIM key_pos&(11),key_name$(11)
LINE INPUT #1,l1$
FOR l1|=0 TO 11
INPUT #1,key_pos&(l1|),key_name$(l1|)
NEXT l1|
'
' Tampons de gestion d'‚venements:
'
DIM message&(7)               ! Tampon event
mes.adr%=V:message&(0)        ! Adresse du tampon event
ABSOLUTE evt&,mes.adr%        ! Indicateur permanent d'event menu
ABSOLUTE titre&,mes.adr%+6    ! Id du titre choisi
ABSOLUTE selection&,mes.adr%+8 ! Id de l'entr‚e choisie
'
' Op‚rations sur disquette:
'
DIM chemin$(3)
LINE INPUT #1,l1$
FOR l1&=0 TO 3
LINE INPUT #1,chemin$(l1&)
NEXT l1&
inout_path$=chemin$(0)        ! Path pour Import/Export de pages = path systŠme
call_value(nb_path_max&)      ! Nb max de dossiers
DIM path$(nb_path_max&)       ! Pour le disk directory
call_value(nb_file_max&)      ! Nb max fichiers
DIM file$(nb_file_max&),length%(nb_file_max&)
ABSOLUTE attrib|,BASEPAGE+149
ABSOLUTE date&,BASEPAGE+152
ABSOLUTE longueur%,BASEPAGE+154
'
' Tri alphab‚tique:
'
DIM sort|(255)
LINE INPUT #1,l1$
FOR l1&=0 TO 255
sort|(l1&)=ASC(UPPER$(CHR$(l1&)))
NEXT l1&
DO
INPUT #1,l1$,l2$
EXIT IF l1$="0"
sort|(ASC(l1$))=ASC(l2$)
LOOP
'
' Couleurs curseur:
'
DIM cursor.f$(1),cursor.c$(1),normal.f$(1)
IF couleur!                     ! Moyenne r‚solution
cursor.c$(0)=CHR$(27)+"b"+CHR$(1)   ! C Rouge
cursor.c$(1)=""
cursor.f$(0)=CHR$(27)+"c"+CHR$(2)   ! F Vert
cursor.f$(1)=CHR$(27)+"c"+CHR$(0)   ! F Blanc
normal.c$=CHR$(27)+"b"+CHR$(15)
normal.f$(0)=CHR$(27)+"c"+CHR$(0)   ! F Blanc
normal.f$(1)=CHR$(27)+"c"+CHR$(2)   ! F Vert
ELSE                            ! haute r‚solution
cursor.c$(0)=""
cursor.c$(1)=""
cursor.f$(0)=CHR$(27)+"p"
cursor.f$(1)=""
normal.c$=""
normal.f$(0)=CHR$(27)+"q"
normal.f$(1)=CHR$(27)+"p"
ENDIF
'
' Vid‚otex:
'
e80$=CHR$(27)+"["
DIM topline|(3)                 ! Params de la ligne 0
'
' Editeur GEM:
'
call_value(nbl_max&)
DIM editor$(nbl_max&)
SUB nbl_max&,19                 ! Nombre de lignes max des fenˆtres GEM
'
' Editeur de message:
'
DIM ligne$(39)                  ! Msg en cours
DIM ligne|(28)                  ! Long des lignes
'
' Divers:
'
DIM parametre$(85)              ! ParamŠtres de la page courante
DIM alternative$(27)            ! Pages alternatives
DIM nb_alt_page&(2)
sysop_maxlong&=30
'
RETURN
'
> FUNCTION last_c(VAR a$)
'
' Trouve longueur du mot:
'
FOR l1|=LEN(a$) DOWNTO 1
EXIT IF MID$(a$,l1|,1)<>" "
NEXT l1|
RETURN l1|
ENDFUNC
> PROCEDURE libere_texte
FOR l1%=0 TO nbl%
editor$(l1%)=""
NEXT l1%
RETURN
> PROCEDURE loc(x|,y|)
'
' Pos csr mntl:
'
IF mixt! AND y|>0             ! En 80 col
OUT 1,27,91
PRINT #99;STR$(y|);
OUT 1,59
PRINT #99;STR$(x|);
OUT 1,72
ELSE                          ! En 40 col
OUT 1,31,64+y|,64+x|
ENDIF
RETURN
'
> PROCEDURE maj.kill(p.ext$,VAR p.nom$(),p.info|(),p.nb&)
'
' D‚truit un fichier et supprime accŠs objet de la RAM
'
IF EXIST(m1$+l1$+p.ext$)        ! Si fichier existe
KILL m1$+l1$+p.ext$             ! Efface
ENDIF
DELETE p.nom$(m1&)              ! Efface son nom
DELETE p.info|(m1&)             ! Efface ‚tat
DEC p.nb&                       ! 1 page de -
RETURN
> PROCEDURE menu_p_520_1040
'
' Menu principal
'
~FRE(0)                       ! Garbage collection
~MENU_BAR(menu.adr%,1)        ! Installation du menu
DO
g0&=EVNT_MULTI(&X110001,0,0,0,0,0,0,0,0,0,0,0,0,0,mes.adr%,250,g1&,g2&,g3&,g4&,g5&,g6&)
IF BTST(g0&,0)                  ! Event clavier
'        GRAPHMODE 0
'        PRINT AT(60,2);"Code touche:";g5&'
IF g5&=14624                    ! Espace
DEFMOUSE 2
OUT 1,31,64,65,24,12
DEFMOUSE 0
ENDIF
'      PRINT AT(10,10);g4&'
'
' -- MAKE ONE -----------------
'
IF g4&=1                      ! Shift droit
SELECT @ascii(g5&)              ! On va tester la touche
CASE 65                         ! [A]
test_serv
IF serveur!
export_arbo
ENDIF
CASE 86                         ! [V]
test_serv
IF serveur!
export_vdt
ENDIF
ENDSELECT
ELSE IF g4&=2                 ! Shift gauche
SELECT @ascii(g5&)              ! On va tester la touche
CASE 65                         ! [A]
import_arbo
CASE 86                         ! [V]
import_vdt
ENDSELECT
ELSE IF g4&=4                 ! Touche Control active
SELECT BYTE(g5&)              ! On teste le code de la touche
CASE 3                          ! [Ctrl C]
IF serveur!=FALSE
charge_serv                     ! Chargement du serv
ELSE
ALERT 1,"Le serveur est d‚ja charg‚ !",1,"   OK   ",void
ENDIF
CASE 4                          ! [Ctrl D]
IF connecte!=TRUE
@deco                           ! Deco phys
ELSE
ALERT 1,"Le minitel n'est pas connect‚ !|(Ou alors le soft n'en est pas|inform‚, cliquez sur CONNECTE|pour le lui faire comprendre!)",1,"   OK   ",void
ENDIF
CASE 5                          ! [Ctrl E]
externe
CASE 6                          ! [Ctrl F]
select_fic
CASE 9                          ! [Ctrl I]
IF serveur!
init_serv                       ! Init du serv
ELSE
ALERT 1,"Le serveur est d‚ja|initialis‚.",1,"   OK   ",void
ENDIF
CASE 16                         ! [Ctrl P]
IF connecte!=FALSE
porteuse                        ! Envoi porteuse et att cnx
ELSE
ALERT 1,"Le minitel est d‚ja connect‚ !|(Ou alors le soft n'en est pas|inform‚, cliquez sur CONNECTE|pour le lui faire comprendre!)",1,"   OK   ",void
ENDIF
CASE 17                         ! [Ctrl Q]
@quitter
EXIT IF l1|=1                   ! Sortie si confirm
~MENU_BAR(menu.adr%,1)          ! Activation menu
'
' -- MAKE_ONE -------------
'
CASE 1                          ! [Ctrl A]
test_serv
IF serveur!
editer_arbo                     ! Edition d'une page arbo
ENDIF
CASE 2                          ! [Ctrl B]
test_serv
IF serveur!
editer_base
ENDIF
CASE 7                          ! [Ctrl G]
infos_tel                       ! Infos sur fichiers tel
CASE 11                         ! [Ctrl K]
test_serv
IF serveur!
editer_mots                     ! Edition mcl‚
ENDIF
CASE 13                           ! [Ctrl M]
IF modify!(0)
maj                             ! Mise … jour du serv
ELSE
ALERT 3,"|Le serveur n'a pas ‚t‚ modifi‚|depuis la derniŠre sauvegarde!",1,"   OK   ",void
ENDIF
CASE 18                         ! [Ctrl R]
test_serv
IF serveur!
editer_rub                      ! Edition d'une rub
ENDIF
CASE 19                         ! [Ctrl S]
test_serv
IF serveur!
editer_msgs                       ! Edition des messages systŠme
ENDIF
CASE 20                         ! [Ctrl T]
test_serv
IF serveur!
tester_vdt(alpha_vdt$(),first_vdt&) ! Test page VDT
ENDIF
CASE 22                         ! [Ctrl V]
test_serv
IF serveur!
editer_vdt                      ! Editer page VDT
ENDIF
CASE 24                         ! [Ctrl X]
para_mod                        ! ParamŠtrage module ext
CASE 25                         ! [Ctrl Y]
test_serv
IF serveur!
editer_altern
ENDIF
CASE 26                         ! [Ctrl Z]
test_serv
IF serveur!
editer_aff
ENDIF
'
' -- USE_ONE -------------
'
CASE 12,15                      ! [Ctrl L,O]
IF connecte!
ALERT 2,"Pour utiliser cette option,|vous devez ˆtre d‚connect‚.|Voulez-vous vous d‚connecter|maintenant ?",1,"D‚co.|Annuler",m1|
IF m1|=1
@deco
ENDIF
ENDIF
IF connecte!=FALSE
test_serv
IF serveur!
IF BYTE(g5&)=15
  off_line                        ! Mode Off-Line
ELSE
  local                           ! Mode local
ENDIF
ENDIF
ENDIF
CASE 14                         ! [Ctrl N]
test_serv
IF serveur!
normal
ENDIF
ENDSELECT
'
'
'
ELSE IF g4&=5                   ! [Ctrl] + [Shift D]
'
' -- MAKE ONE -----------------
'
m1|=@ascii(g5&)              ! On va tester la touche
SELECT m1|
CASE 65,66,82,86,89,90
test_serv
IF serveur!
SELECT m1|
CASE 65                         ! [Ctrl ShiftD A]
supp_arbo                       ! Supprimer page ARBO
CASE 66                         ! [Ctrl ShiftD A]
supp_base                       ! Supprimer base
CASE 82                         ! [Ctrl ShiftD R]
supp_rub                        ! Supprimer rubrique
CASE 86                         ! [Ctrl ShiftD V]
supp_vdt                        ! Supprimer page VDT
CASE 89                         ! [Ctrl ShiftD Y]
supp_altern                     ! Supprimer page altern
CASE 90                         ! [Ctrl ShiftD Z]
supp_aff                        ! Supprimer affiche
ENDSELECT
ENDIF
ENDSELECT
'
'
'
ELSE IF g4&=8                   ! Touche Alternate active
SELECT @ascii(g5&)              ! On va tester la touche
CASE 49                         ! [Alt 1]
vitesse(12)
CASE 51                         ! [ALT 3]
vitesse(3)
CASE 52                         ! [ALT 4]
vitesse(48)
CASE 57                         ! [ALT 9]
vitesse(96)
CASE 67                         ! [Alt C]
connecte                        ! Connect‚ <=> D‚connect‚
CASE 72                         ! [Alt H]
regler_heure                    ! R‚glage heure
CASE 73                         ! [Alt I]
infos_cop                       ! Affiche la boite d'infos
CASE 76                         ! [Alt L]
espaces                         ! M‚moires libres
CASE 77                         ! [Alt M]
veille_off                      ! Sortie du mode veille
CASE 80                         ! [Alt P]
parametres                      ! Param g‚n‚raux
CASE 83                         ! [Alt S]
IF serveur!
ALERT 3,"Vous ne pouvez modifier les|chemins d'accŠs aux fichiers|serveur lorsque celui-ci est|charg‚ en m‚moire!",1,"   OK   ",void
ELSE
chemins
ENDIF
CASE 86                         ! [Alt V]
veille_on                       ! Mode veille
'
' -- USE_ONE -------------
'
CASE 69                         ! [Alt E]
param_enregistr
ENDSELECT
'
'
'
ELSE IF g4&=12                  ! [Ctrl] + [Alt]
SELECT @ascii(g5&)              ! On va tester la touche
CASE 65                         ! [A]
test_serv
IF serveur!
copier_arbo
ENDIF
CASE 86                         ! [V]
test_serv
IF serveur!
copier_vdt
ENDIF
ENDSELECT
ENDIF
'
'
'
ELSE IF BTST(g0&,4)             ! Event
IF evt&=10                      ! Si une option menu a ‚t‚ cliqu‚e
~MENU_TNORMAL(menu.adr%,titre&,1) ! Extinction de l'inverse vid‚o
l5|=menu_vit|+1
l6|=menu_vit|+2
l7|=menu_vit|+3
SELECT selection&
CASE infos_menu|
infos_cop
CASE c_serv|
charge_serv
CASE create_new|
create_new
CASE maj|                       ! 520_1040
maj
CASE init|
init_serv
CASE select_f|
select_fic
CASE prg_ext|
externe
CASE fin|
@quitter
EXIT IF l1|=1                   ! Sortie si confirm
~MENU_BAR(menu.adr%,1)          ! Activation du menu
CASE chemins|
chemins
CASE params|
parametres
CASE par_load|
charge_conf2
CASE par_save|
sauve_param
CASE dispo|
espaces
CASE heure|
regler_heure
CASE connecte|
connecte
CASE menu_vit|
vitesse(3)
CASE l5|
vitesse(12)
CASE l6|
vitesse(48)
CASE l7|
vitesse(96)
CASE porteu|
porteuse
CASE deco|
@deco
CASE marche|
veille_off
CASE veille|
veille_on
'
' -- MAKE_ONE -------------
'
CASE edit_vdt|
editer_vdt
CASE test_vdt|
tester_vdt(alpha_vdt$(),first_vdt&)
CASE copy_vdt|
copier_vdt
CASE effa_vdt|
supp_vdt
CASE import_vdt|
import_vdt
CASE export_vdt|
export_vdt
CASE edit_arbo|
editer_arbo
CASE copy_arbo|
copier_arbo
CASE supp_arbo|
supp_arbo
CASE import_arbo|
import_arbo
CASE export_arbo|
export_arbo
CASE edit_rub|
editer_rub
CASE supp_rub|
supp_rub
CASE edit_aff|
editer_aff
CASE supp_aff|
supp_aff
CASE edit_base|
editer_base
CASE supp_base|
supp_base
CASE edit_alt|
editer_altern
CASE effa_alt|
supp_altern
CASE mot_cle|
editer_mots
CASE bals|
para_bals
CASE startstop|
start_stop
CASE msgs_sys|
editer_msgs
CASE infos_tel|
infos_tel
CASE para_mod|
para_mod
'
' -- USE_ONE -------------
'
CASE voir_base|
voir_base(nom_base$(),alpha_base$())
CASE filtrer|
filtrer_bals
CASE m_loc|
local
CASE m_off|
off_line
CASE m_norm|
normal
CASE enregistr|
param_enregistr
CASE voir_enr|
voir_enr
ENDSELECT
evt&=0                          ! On indique la prise en compte
ENDIF
ENDIF
LOOP
RETURN
> PROCEDURE mixte
'
' Passage Mntl(s) en mode mixte:
'
IF mod_norm!
OUT 1,27,58,102,4,27,58,50,125 ! Transp + mixte
ENDIF
OUT 1,27,58,50,125            ! Mixte local
mixt!=TRUE
IF min!=FALSE
IF mod_norm!                  ! Si connect‚
OUT 1,27,58,102,4             ! Transp 4 oct
OUT 1,27,58,106,&H45          ! Min
ENDIF
OUT 1,27,58,106,&H45          ! Min
ENDIF
l0|=FALSE                     ! L0 normale
RETURN
> PROCEDURE m_iena(enable&,no_objcs$)
LOCAL i&
'
' Valide entr‚es menu
'
FOR i&=1 TO LEN(no_objcs$) STEP 2
~MENU_IENABLE(menu.adr%,CVI(MID$(no_objcs$,i&,2)),enable&)
NEXT i&
RETURN
'
> PROCEDURE no_ligne
'
' Aff nø de ligne courant de l'‚diteur GEM:
'
IF l.cursor!
l1&=SUCC(g8&)                 ! ligne csr
ELSE
l1&=g7&+20+l.offset&          ! ligne bas ‚cran
ENDIF
l1$=RIGHT$("000"+STR$(l1&),4)
FOR l1|=1 TO 4
TEXT l.x_no&+l1|*8,28*rez|+2*rm|,CHR$(BCLR(ASC(MID$(l1$,l1|,1)),5))
NEXT l1|
RETURN
'
> PROCEDURE ouvre_def
l1$=stut$+"DEF"
titre(l1$)
OPEN "I",#1,path$+l1$           ! Ouvre fichier .DEF
FOR l1|=1 TO 21                 ! Passe le baratin...
LINE INPUT #1,l1$
NEXT l1|
PRINT #99
PRINT #99
LINE INPUT #1,l1$               ! Personnalisation
PRINT #99;"Personnalisation:"'
envoi_chaine(l1$)
RETURN
'
> PROCEDURE page
'
' Passe les mntls en mode page:
'
IF mod_norm!
OUT 1,27,58,102,4,27,58,106,67        ! Transp + stop rouleau
ENDIF
OUT 1,27,58,106,67                    ! Stop rouleau local
scroll!=FALSE
RETURN
> PROCEDURE page_down
'
' 1 page bas dans l'‚diteur:
'
IF g7&<nbl%-19
ADD g7&,19
IF g7&>nbl%-19
g7&=nbl%-19
ENDIF
g8&=g7&
g9&=1
affiche_texte
ENDIF
RETURN
> PROCEDURE page_up
'
' 1 page haut dans l'‚diteur:
'
IF g7&>0
SUB g7&,19
IF g7&<0
g7&=0
ENDIF
g8&=g7&
g9&=1
affiche_texte
ENDIF
RETURN
> PROCEDURE param_enregistr
'
' R‚glage params enregistrement:
'
titre("Enregistrement des connexions")
adr%=enregistr.adr%
parametre$(0)=STR$(enr&)
set_bout(0,3,2,1)
'
affiche_rsc
'
IF b%=6                               ! Si on a valid‚
get_bout(0,3,2)
enr&=VAL(parametre$(0))
~MENU_ICHECK(menu.adr%,enregistr|,enr&) ! Check Cnt ?
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE parametres
'
' R‚glage params g‚n‚raux:
'
titre("R‚glage des paramŠtres g‚n‚raux")
adr%=params.adr%
FOR l1|=3 TO 5
set_state(l1|,0,0,1)                  ! Efface pr‚selects
NEXT l1|
IF auto_charge|=0                     ! Chargement manuel
set_state(3,1,0,1)
ELSE IF auto_charge|=1                ! Auto
set_state(4,1,0,1)
ELSE                                  ! Charger + Lancer
set_state(5,1,0,1)
ENDIF
FOR l1|=8 TO 10
set_state(l1|,0,0,1)                  ! Efface pr‚selects
NEXT l1|
IF auto_setdate%=-2                   ! Reglage heure
set_state(10,1,0,1)                   ! Toujours
ELSE IF auto_setdate%=-1
set_state(8,1,0,1)                    ! Jamais
ELSE
set_state(9,1,0,1)                    ! Qd date systŠme
ENDIF
affiche_rsc
IF b%=11                              ! Si on a valid‚
IF FN selected(3)
auto_charge|=0                      ! Manuel
ELSE IF FN selected(4)
auto_charge|=1                      ! Auto
ELSE
auto_charge|=3                      ! Charger + executer
ENDIF
IF FN selected(10)
auto_setdate%=-2                    ! Toujours
ELSE IF FN selected(8)
auto_setdate%=-1                    ! Jamais
ELSE
l1$=DATE$
auto_setdate%=VAL(RIGHT$(l1$,4)+MID$(l1$,4,2)+LEFT$(l1$,2)) ! Date min
ENDIF
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE porteuse
'
' Envoi porteuse depuis menu:
'
titre("Envoi de la porteuse")
DEFMOUSE 2
veille_off                    ! Sort du mode veille
attente_cnx
PAUSE 20
l1$=INPAUX$
IF connecte!                  ! Si comm ‚tablie
OUT 1,27,59,97,88,81          ! Installe Clav => Ecr
OUT 1,27,58,102,5,27,59,97,88,81 ! Transp + Installe Clav => Ecr
OUT 1,12,17
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE pos_asc
'
' Fixe et aff new pos asc:
'
IF nbl%<20                    ! - de 20 lignes
l1%=0                         ! On est tout en haut
ELSE                          ! + de 20 l
l1%=g7&*1000/(nbl%-19)        ! Calcul
ENDIF
~WIND_SET(handle%,9,l1%,0,0,0)
RETURN
> PROCEDURE present_520_1040
DEFTEXT 1,0,0,6
BOUNDARY 0
~WIND_GET(0,4,x_desk&,y_desk&,w_desk&,h_desk&) ! Dimensions bureau
h_menu&=PRED(y_desk&)
IF inter!
fond_bureau
ENDIF
DEFTEXT ,,,6+rm|*7
titre(stut$+"PRG")
~FORM_DIAL(0,0,0,0,0,200,72*rez|+rm|*16,239,57*rez|-9*rm|)
DEFFILL 1,1,1
PBOX 202,74*rez|+rm|*16,440,130*rez|+6*rm|
BOUNDARY 1
DEFFILL 1,0
PBOX 200,72*rez|+rm|*16,438,128*rez|+6*rm|
BOUNDARY 0
GRAPHMODE 2
DEFTEXT 1,4+rm|*2,0,26
TEXT 250,101*rez|,"STUT ONE"
DEFTEXT 2,4
TEXT 248,99*rez|,"STUT ONE"
DEFTEXT 1,0,0,4
TEXT 283,108*rez|,"Version "+version$
TEXT 230,116*rez|,"Copyright (c)1993 by F.PLANQUE"
TEXT 215,124*rez|,"Domaine Public, ne peut etre vendu."
DEFTEXT ,,,6+rm|*7
GRAPHMODE 0
DEFFILL 0,1
RETURN
'
> PROCEDURE quitter
'
' Conf de quitter
'
~MENU_BAR(menu.adr%,0)          ! Desactivation du menu
titre("Quitter le serveur")
IF modify!(0)                      ! Si le serv a ‚t‚ modifi‚
ALERT 2,"Le serveur a ‚t‚ modifi‚ !|Etes vous sur de vouloir|quitter sans sauver|votre travail ?",2,"Quitter|Annuler",l1|
ELSE
ALERT 2,"Etes vous sur de|vouloir quitter|le serveur ?",1,"Quitter|Annuler",l1|
ENDIF
RETURN
'
> PROCEDURE regler_heure
'
' Mise … l'heure:
'
titre("R‚glage de l'heure")
adr%=timeset.adr%
m1$=DATE$                     ! Fixe date courante
set_edit(3,LEFT$(m1$,2)+MID$(m1$,4,2)+RIGHT$(m1$,2))
m1$=TIME$                     ! Fixe heure courante
set_edit(4,LEFT$(m1$,2)+MID$(m1$,4,2)+RIGHT$(m1$,2))
affiche_rsc
IF b%=6                       ! Si confirm‚
m1$=FN edit$(3)               ! Extract date
m2$=FN edit$(4)               ! Extract heure
m1$=LEFT$(m1$,2)+"."+MID$(m1$,3,2)+".19"+RIGHT$(m1$,2)
m2$=LEFT$(m2$,2)+":"+MID$(m2$,3,2)+":"+RIGHT$(m2$,2)
SETTIME m2$,m1$               ! Mise … l'heure du ST
IF auto_setdate%=>0           ! Si la new date est prise pour r‚f‚rence
l1$=DATE$
auto_setdate%=VAL(RIGHT$(l1$,4)+MID$(l1$,4,2)+LEFT$(l1$,2)) ! Date r‚f
ENDIF
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE rs_in(adr%,l%)
'
' Fixe adr et taille tampon entr‚e RS 232:
'
l1%=XBIOS(14,0)               ! Adr tampon d'entr‚e
LPOKE l1%,adr%
DPOKE l1%+4,l%
LPOKE l1%+6,0
RETURN
> PROCEDURE rs_out(adr%,l%)
'
' Fixe adr et taille tampon sortie RS 232:
'
l1%=XBIOS(14,0)+14            ! Adr tampon sortie
LPOKE l1%,adr%
DPOKE l1%+4,l%
LPOKE l1%+6,0
RETURN
'
> PROCEDURE sa_noyau(mode|)
'
' Noyau de sauvegarde d'affiches
'
IF nb_aff&
err_resume&=5
REPEAT
err_choix&=FALSE
FOR m1&=0 TO PRED(nb_aff&)    ! Parcourt affs
l1$=nom_aff$(m1&)             ! Nom rub … maj
IF mode|=1
set_string(11,l1$)
set_vlstring(10,nb_rub&-m1&,4)
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
ELSE
m4|=(m1& MOD 10)*(6+rm|*2)+78*rez|
TEXT 24,m4|,STR$(SUCC(m1&))
TEXT 48,m4|,"Affiche: "+l1$
ENDIF
l1|=info_aff|(m1&)            ! Modifs ‚ffectu‚es?
IF l1|=1                      ! Modif du code
OPEN "O",#1,chemin$(1)+l1$+".AFF"
FOR l2|=0 TO 2
PRINT #1;param_aff|(m1&,l2|)
NEXT l2|
l3|=param_aff|(m1&,2)
IF l3|
FOR l4|=0 TO PRED(l3|)
ligne$(l4|)=ligne_aff$(m1&,l4|) ! Stocke msgs
NEXT l4|
STORE #1,ligne$(),l3|         ! Sauve msgs
ENDIF
CLOSE #1
err_resume&=FALSE
FOR l1&=0 TO PRED(nbn_aff&)
l2$=alpha_aff$(l1&)
IF LEFT$(l2$,LEN(l2$)-1)=l1$
alpha_aff$(l1&)=l1$+" "
EXIT IF TRUE
ENDIF
NEXT l1&
ELSE IF l1|=2                  ! S'il faut Effacer rub
maj.kill(".AFF",nom_aff$(),info_aff|(),nb_aff&)
ENDIF
info_aff|(m1&)=FALSE          ! Plus de modif
NEXT m1&
err_5:
CLOSE #1
UNTIL err_choix&<>2
ENDIF
modify!(4)=FALSE              ! Les rubs sont mises … jour
RETURN
> PROCEDURE sauve_param
'
' Sauve paramŠtres:
'
titre("Sauvegarde de la configuration")
ALERT 2,"Cette configuration|devra-t-elle ˆtre|recharg‚e par d‚faut|la prochaine fois?",2,"  Oui  |Non",l1&
IF l1&=1
IF ASC(path$)<67              ! Si path sur A: ou B:
ALERT 3,"Inserez la disquette|de lancement de|STUT ONE ("+LEFT$(path$)+":).",1,"Sauver|Annuler",l1&
ELSE
ALERT 3,"Les paramŠtres vont|ˆtres sauv‚s sur le|disque dur.",1,"Sauver|Annuler",l1&
ENDIF
g1$=path$+stut$+"CNF"
ELSE
cur_dir               ! Directory courant\ ==> g1$
f_titre$="SAUVER LA CONFIG"
g1$=FN file$(2,g1$+"*.CNF",stut$+"CNF",l1$)
IF LEN(g1$)
l1&=1
ENDIF
ENDIF
IF l1&=1                      ! Si confirm
DEFMOUSE 2
OPEN "O",#1,g1$
STORE #1,chemin$(),4
PRINT #1;auto_charge|
PRINT #1;auto_setdate%
PRINT #1;enr&
PRINT #1;vitesse|
CLOSE #1
DEFMOUSE 0
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> FUNCTION scan(keycode&)
l1&=BYTE(SHR(keycode&,8))       ! Code scan
IF l1&>118 THEN                 ! Correction des touches 02-0d
l1&=l1&-118
ENDIF
RETURN l1&
ENDFUNC
> PROCEDURE scroll
'
' Passe mntls en mode rouleau:
'
IF mod_norm!
OUT 1,27,58,102,4,27,58,105,67 ! Transp + rouleau
ENDIF
OUT 1,27,58,105,67            ! Rouleau local
scroll!=TRUE
RETURN
> PROCEDURE scroll_down(a|,a&)
'
' Scroll bas(ligne+1) de la fen ‚dit:
'
' -- 520_1040 -----------------
IF a&<>g8& AND l.cursor!
l1|=LEN(editor$(a&))
IF a|>l1|
a|=l1|
ENDIF
efface_curseur
ENDIF
' ---------------------------
INC g7&                       ! 1 ligne + bas
l1&=g7&+19
'  l1|=-(l1&=>g10& AND l1&<=g11&)        ! Csr dans bloc ou pas
RC_COPY XBIOS(3),l.l_g&,40*rez|,l.w_g&,152*rez|+rm| TO XBIOS(3),l.l_g&,32*rez|
PBOX l.l_g&,184*rez|,l.r_g&,191*rez|+rm|      ! Efface ligne du bas
affiche_lignes(l1&)
'  PRINT AT(2,24);normal.f$(l1|);editor$(l1&);normal.f$(0);  ! New ligne
' -- 520_1040 -----------------
IF l.cursor!
IF a&<>g8&
g8&=a&
g9&=a|
affiche_curseur
no_ligne
ENDIF
ELSE
' ---------------------------
no_ligne
ENDIF
pos_asc
RETURN
> PROCEDURE scroll_up(a|,a&)
'
' Scroll haut(ligne-1) de la fen ‚dit:
'
' -- 520_1040 -----------------
IF a&<>g8& AND l.cursor!
l1|=LEN(editor$(a&))
IF a|>l1|
a|=l1|
ENDIF
efface_curseur
ENDIF
' ---------------------------
DEC g7&                       ! 1 ligne + haut
l1|=-(g7&=>g10& AND g7&<=g11&)        ! Csr dans bloc ou pas
RC_COPY XBIOS(3),l.l_g&,32*rez|,l.w_g&,152*rez| TO XBIOS(3),l.l_g&,40*rez|
PBOX l.l_g&,32*rez|,l.r_g&,39*rez|+rm|    ! Efface ligne du haut
PRINT AT(p.x_car&,5);normal.f$(l1|);editor$(g7&);normal.f$(0);  ! New ligne
' -- 520_1040 -----------------
IF l.cursor!
IF a&<>g8&
g8&=a&
g9&=a|
affiche_curseur
no_ligne
ENDIF
ELSE
' ---------------------------
no_ligne
ENDIF
pos_asc
RETURN
> PROCEDURE select_fic
'
' Aff Item Sel:
'
titre("S‚lecteur de fichiers")
cur_dir               ! Directory courant\ ==> g1$
FILESELECT g1$+"*.*","",l1$
~MENU_BAR(menu.adr%,1)
RETURN
> FUNCTION selected(a|)
RETURN OB_STATE(adr%,a|) AND 1
ENDFUNC
> PROCEDURE set_bout(p.param&,p.firstb&,p.nb_bout&,p.shadow&)
'
' Init boutons:
'
l1&=VAL(parametre$(p.param&)) ! Etat des bout
FOR l2&=0 TO p.nb_bout&       ! Init
set_state(p.firstb&+l2&,-BTST(l1&,l2&),0,p.shadow&)
NEXT l2&
RETURN
> PROCEDURE set_edit(a|,a$)
'
' Fixe un texte ‚dit:
'
CHAR{{OB_SPEC(adr%,a|)}}=a$
RETURN
> PROCEDURE set_insert(mode|)
'
' Insertion/overwrite ‚diteur GEM:
'
l.insert|=mode|
DEFTEXT 2                                     ! Couleur
TEXT l.x_ins&,28*rez|+2*rm|,CHR$(32+mode|*41)  ! I
DEFTEXT 1
RETURN
> PROCEDURE set_loaded
'
' *** Settings dus au chargement du serveur:
'
serveur!=TRUE                         ! Le serv est charg‚
m_iena(0,MKI$(c_serv|)+MKI$(create_new|)+MKI$(chemins|)+MKI$(par_load|))
m_iena(1,ent_edit$)
m_iena(1+connecte!,MKI$(m_loc|)+MKI$(m_off|))  ! 520_1040
RETURN
> PROCEDURE set_radio(p.value&,p.first&,p.nbb&)
DEC p.nbb&
FOR l1&=0 TO p.nbb&
IF p.value&=l1&
set_state(p.first&+l1&,1,0,1)            ! ON
ELSE
set_state(p.first&+l1&,0,0,1)            ! OFF
ENDIF
NEXT l1&
RETURN
> PROCEDURE set_state(a|,select|,disable|,shadow|)
'
' Fixe states: select,disable,shadow:
'
~OBJC_CHANGE(adr%,a|,0,x%,y%,w%,h%,select|+8*disable|+32*shadow|,0)
RETURN
> PROCEDURE set_string(a|,a$)
'
' Fixe str:
'
CHAR{OB_SPEC(adr%,a|)}=a$
RETURN
> PROCEDURE set_vstring(no&,val%,long&)
'
' Fixe valeur ds str:
'
CHAR{OB_SPEC(adr%,no&)}=RIGHT$(SPACE$(long&)+STR$(val%),long&)
RETURN
> PROCEDURE set_vlstring(no&,val&,long&)
'
' Fixe valeur ds str:
'
CHAR{OB_SPEC(adr%,no&)}=LEFT$(STR$(val&)+SPACE$(long&),long&)
RETURN
> PROCEDURE sr_noyau(mode|)
'
' Noyau de sauvegarde de rubrique
'
IF nb_rub&
err_resume&=6
REPEAT
err_choix&=FALSE
FOR m1&=0 TO PRED(nb_rub&)    ! Parcourt rubs
l1$=nom_rub$(m1&)             ! Nom rub … maj
IF mode|=1
set_string(11,l1$)
set_vlstring(10,nb_rub&-m1&,4)
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
ELSE
m4|=(m1& MOD 10)*(6+rm|*2)+78*rez|
TEXT 24,m4|,STR$(SUCC(m1&))
TEXT 48,m4|,"Rubrique: "+l1$+SPACE$(8)
ENDIF
l1|=info_rub|(m1&)            ! Modifs ‚ffectu‚es?
IF l1|=1                      ! Modif du code
OPEN "O",#1,chemin$(1)+l1$+".RUB"
FOR l2|=0 TO 4
PRINT #1;param_rub|(m1&,l2|)
NEXT l2|
l3|=param_rub|(m1&,4)
IF l3|
FOR l4|=0 TO PRED(l3|)
ligne$(l4|)=msg_rub$(m1&,l4|) ! Stocke msgs
NEXT l4|
STORE #1,ligne$(),l3|         ! Sauve msgs
ENDIF
CLOSE #1
err_resume&=FALSE
FOR l1&=0 TO PRED(nbn_rub&)
l2$=alpha_rub$(l1&)
IF LEFT$(l2$,LEN(l2$)-1)=l1$
alpha_rub$(l1&)=l1$+" "
EXIT IF TRUE
ENDIF
NEXT l1&
ELSE IF l1|=2                  ! S'il faut Effacer rub
maj.kill(".RUB",nom_rub$(),info_rub|(),nb_rub&)
ENDIF
info_rub|(m1&)=FALSE          ! Plus de modif
NEXT m1&
err_6:
CLOSE #1
UNTIL err_choix&<>2
IF mode|=2
DEFTEXT ,,,6+rm|*7
ENDIF
ENDIF
modify!(3)=FALSE              ! Les rubs sont mises … jour
RETURN
'
> PROCEDURE taille_asc
'
' Fixe taille et affiche asc en fnct du nbl:
'
IF nbl%<20                    ! Jusqu'… 20 lignes
l1%=1000                      ! Taille max
ELSE
l1%=20000/(nbl%+1)            ! Calcul taille
ENDIF
~WIND_SET(handle%,16,l1%,0,0,0) ! Affiche asc
RETURN
> PROCEDURE test_serv
'
' Teste si serv est charg‚:
'
IF serveur!=FALSE
ALERT 2,"Pour utiliser cette fonction,|le serveur doit ˆtre charg‚.|Voulez-vous le charger|maintenant ?",1,"Charger|Annuler",l1|
IF l1|=1
charge_serv
ENDIF
ENDIF
RETURN
> PROCEDURE test_rez
rez|=XBIOS(4)
SELECT rez|
CASE 0,7                            ! Si on est en basse r‚soltion
DEFMOUSE 0
ALERT 1,"STUT ONE "+version$+"|ne fonctionne|pas en basse|r‚solution ST/TT.",1,"  OK  ",void
EDIT
CASE 1                              ! ST Moyenne
rez|=1
rm|=0
couleur!=TRUE
CASE 2                              ! ST Haute
rez|=2
rm|=1
CASE 4                              ! TT Moyenne
rez|=2
rm|=1
tt!=TRUE
couleur!=TRUE
CASE 6                              ! TT Haute
DEFMOUSE 0
ALERT 1,"STUT ONE "+version$+"|ne fonctionne|pas en haute|r‚solution TT.",1,"  OK  ",void
EDIT
ENDSELECT
rt|=rm|*8
rc|=3+rm|*4
RETURN
> PROCEDURE titre(titre$)
'
' Aff 1 titre … la place du menu:
'
~MENU_BAR(menu.adr%,0)
IF h_menu&=>8*rez|
DEFFILL 0
PBOX x_desk&,0,PRED(x_desk&+w_desk&),PRED(h_menu&) ! Efface barre de menu
DEFTEXT 1,,,6+rm|*7
TEXT 317-LEN(titre$)*4,7*rez|,titre$ ! Affiche titre
ENDIF
RETURN
> PROCEDURE topline
'
' Aff l0 selon pr‚d‚fs:
'
IF csr!
OUT 1,20
ENDIF
loc(1,0)
font_restore
OUT 1,27,topline|(0),32,24,10 ! Rempli par la couleur choisie
IF topline|(1)                ! Si aff heure dem
loc(2,0)
font_restore
l2$=TIME$
PRINT #99;CHR$(27);"]";LEFT$(l2$,2);CHR$(27);"H:";CHR$(27);"I";MID$(l2$,4,2);
OUT 1,27,92,10
ENDIF
IF topline|(2)
balstate
ENDIF
l0|=FALSE                     ! L0 normale
IF csr!
OUT 1,17
ENDIF
RETURN
> PROCEDURE tpaper
IF l0|=FALSE                  ! Si l0 dispo
loc(1,0)
font_restore
OUT 1,27,l1|,32,24,10       ! Rempli la ligne par la couleur
ENDIF
topline|(0)=l1|
RETURN
'
> PROCEDURE vdt_special
'
' Traite tous les codes VDT sp‚ciaux … STUT ONE:
'
SELECT l1|
CASE 128                      ! *SCROLL
scroll
CASE 129                      ! *PAGE
page
CASE 130                      ! *INTERRUPT ON
interrupt!=TRUE
CASE 131                      ! *INTERRUPT OFF
CLR interrupt!
CASE 132                      ! *CLOCK ON
topline|(1)=1
clock
CASE 133                      ! *CLOCK OFF
topline|(1)=0
clock%=TIMER+17280000         ! Prochain aff pendule ds 24h !
CASE 135                      ! *TOPLINE
IF keypress!=FALSE
IF l0|=FALSE                  ! Si l0 dispo
topline
ENDIF
ENDIF
CASE 136                      ! *PSEUDO
envoi_chaine(pseudo$)
CASE 137                      ! *BALSTATE ON
IF l0|=FALSE                  ! Si l0 dispo
balstate
ENDIF
topline|(2)=1
CASE 138                      ! *RUB
envoi_chaine(rubrique$)
CASE 139                      ! *ID
IF mi2!
IF mod_norm!                  ! Si mode normal
OUT 1,27,58,102,1             ! Transpa 1 octet
ENDIF
OUT 1,5                       ! Identification
ENDIF
CASE 140                      ! *DEFTEXT N
OUT 1,&H1B,&H28,&H40
drcs0!=FALSE
CASE 141                      ! *DEFTEXT D
OUT 1,&H1B,&H28,&H20,&H42
drcs0!=TRUE
CASE 142                      ! *DEFGRAPH N
OUT 1,&H1B,&H29,&H63
drcs1!=FALSE
CASE 143                      ! *DEFGRAPH D
OUT 1,&H1B,&H29,&H20,&H43
drcs1!=TRUE
CASE 144                      ! *MIXTE
mixte
CASE 145                      ! *VIDEOTEX
videotex
CASE 146                      ! *RECALL T
IF drcs0!
OUT 1,&H1B,&H28,&H20,&H42
ELSE
OUT 1,&H1B,&H28,&H40
ENDIF
CASE 147                      ! *RECALL G
IF drcs1!
OUT 1,&H1B,&H29,&H20,&H43
ELSE
OUT 1,&H1B,&H29,&H63
ENDIF
CASE 149                      ! *SYSMSG
loc(1,0)
font_restore                  ! Restore DRCS si valid‚
OUT 1,24
keypress!=TRUE                ! Msg en l0
l0|=1
DEFAULT
OUT 1,7
ENDSELECT
RETURN
> PROCEDURE veille_off
'
' Sort les minitels r‚cents du mode veille:
'
OUT 1,27,59,106,88,65               ! Sortie du mode veille
RETURN
> PROCEDURE veille_on
'
' Met les minitels r‚cents du mode veille:
'
OUT 1,27,59,105,88,65               ! Mise en mode veille
RETURN
> PROCEDURE videotex
'
' Passage Mntl(s) en mode videotex:
'
IF mod_norm!
OUT 1,27,58,102,4,27,58,50,126 ! Transp + vdt
ENDIF
OUT 1,27,58,50,126            ! Vdt local
mixt!=FALSE
scroll!=FALSE
IF min!
OUT 1,27,58,105,69            ! Min
OUT 1,27,59,105,89,65         ! Clavier etendu
IF mod_norm!                  ! Si cnt
OUT 1,27,58,102,9             ! Transp 4 oct
OUT 1,27,58,105,69            ! Min
OUT 1,27,59,105,89,65         ! Clavier etendu
ENDIF
ENDIF
l0|=FALSE                     ! L0 normale
RETURN
> PROCEDURE vitesse(p.v|)
'
' Fixe vitesse minitel/RS:
'
titre("Passage de la liaison ST-Minitel … "+STR$(p.v|)+"00 BAUDS")
DEFMOUSE 2
SELECT p.v|
CASE 3,100
vitesse|=0                    ! 300 Bds
CASE 12,101
vitesse|=1                    ! 1200 Bds
CASE 48,102
vitesse|=2                    ! 4800 Bds
DEFAULT
vitesse|=3                    ! 9600 Bds
ENDSELECT
vit_set
PAUSE 10
l1$=INPAUX$
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE vit_set
FOR l1|=menu_vit| TO menu_vit|+3! EnlŠve checks
~MENU_ICHECK(menu.adr%,l1|,0)
NEXT l1|
SELECT vitesse|
CASE 0
OUT 1,&H1B,&H3A,&H6B,&H52
PAUSE 10
~XBIOS(15,9,0,174,-1,-1,-1)
CASE 1
OUT 1,&H1B,&H3A,&H6B,&H64
PAUSE 10
~XBIOS(15,7,0,174,-1,-1,-1)
CASE 2
OUT 1,&H1B,&H3A,&H6B,&H76
PAUSE 10
~XBIOS(15,2,0,174,-1,-1,-1)
DEFAULT
OUT 1,&H1B,&H3A,&H6B,&H7F
PAUSE 10
~XBIOS(15,1,0,174,-1,-1,-1)
ENDSELECT
~MENU_ICHECK(menu.adr%,menu_vit|+vitesse|,1)
RETURN
'
' ****************************
' *** Proc‚dures d'‚dition ***
' ****************************
'
> PROCEDURE affiche_curseur
'
' Aff csr dans l'‚diteur GEM:
'
l.in_bloc|=-(g8&=>g10& AND g8&<=g11&) ! Csr dans bloc ou pas
PRINT AT(PRED(p.x_car&+g9&),g8&-g7&+5);cursor.f$(l.in_bloc|);cursor.c$(l.insert|);MID$(editor$(g8&),g9&,1);normal.f$(0);normal.c$;
RETURN
'
> PROCEDURE bloc_bas
'
' Fixe bas d'un bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
g11&=PRED(g8&)                ! M‚mo nø ligne bas
bloc_control                  ! Settings menu
affiche_texte
ENDIF
RETURN
> PROCEDURE bloc_clear
'
' Pas de bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
g11&=TRUE                     ! Plus de (fin de) bloc
bloc_control                  ! Settings menu
affiche_texte
ENDIF
RETURN
> PROCEDURE bloc_control
'
' Contr“le si bloc exist + settings:
'
IF g11&=>g10&
l1|=1                         ! Bloc exist
ELSE
l1|=FALSE                     ! Bloc n'exist pas
ENDIF
IF g0!<>-l1|                  ! Si changement d'‚tat
m_iena(l1|,MKI$(27)+MKI$(29)+MKI$(31)+MKI$(32)+MKI$(33)+MKI$(35))
ENDIF
g0!=-l1|
RETURN
> PROCEDURE bloc_find
'
' Trouver un bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
CLR g3!,g5!                   ! Reset modes ins
g7&=g10&-9
IF g7&<0
g7&=0
ENDIF
g8&=g10&
g9&=1
affiche_texte
ENDIF
RETURN
> PROCEDURE bloc_haut
'
' Fixe haut d'un bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
g10&=g8&                      ! M‚mo nø ligne haut
bloc_control                  ! Settings menu
affiche_texte
ENDIF
RETURN
> PROCEDURE buff_clear
'
' Vider buffer:
'
ALERT 2,"Voulez-vous d‚truire|le contenu actuel du|buffer ?",1,"D‚truire|Annuler",l1|
IF l1|=1
edit_buff$(win_ed|)=""        ! Vide buffer
m_iena(0,MKI$(35)+MKI$(36)+MKI$(37))
ENDIF
RETURN
> PROCEDURE buff_copy(a!)
'
' Copie buffer:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
IF nbl%<win_max%
efface_curseur
DEFMOUSE 2
m3&=nbl%                      ! Nbl avant
m1$=edit_buff$(win_ed|)       ! Contenu buff
m1&=g8&                       ! Ligne de d‚part
IF win_ed|=0                  ! Codes vdt
@decode_vdt(m1$,g8&,g8&+PRED(nbl_max&)-nbl%) ! Decodage bloc
ELSE                          ! Mots clefs, Infos tel, Msgs systŠme
DO
l1&=INSTR(m1$,CHR$(0))
EXIT IF l1&=FALSE
INSERT editor$(m1&)=LEFT$(m1$,PRED(l1&)) ! New ligne
m1$=MID$(m1$,SUCC(l1&))       ! Ne garde que la suite
INC nbl%                      ! 1 ligne de +
EXIT IF nbl%=win_max%         ! Si nbl max atteint
INC m1&
LOOP
IF LEN(m1$)
ALERT 3,"Le buffer est|trop long pour ˆtre|entiŠrement d‚cod‚.",1,"   OK   ",void
ENDIF
ENDIF
IF g8&=>g10& AND g8&<=g11&    ! Si csr in bloc
ADD g11&,nbl%-m3&             ! Long bloc augmente
ENDIF
DEFMOUSE 0
g9&=1
g7&=g8&-9
IF g7&<0
g7&=0
ENDIF
taille_asc
affiche_texte
IF a!                         ! S'il fo vider buff
buff_clear
ENDIF
ELSE
ALERT 1,"Il ne reste plus de|ligne disponible afin de|reproduire ce buffer.",1,"   OK   ",void
ENDIF
ENDIF
RETURN
> PROCEDURE buff_fill
'
' Remplit buffer:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
l1|=1
IF LEN(edit_buff$(win_ed|))   ! Si buffer contient d‚ja qque chose
ALERT 2,"Voulez-vous d‚truire|le contenu actuel du|buffer ?",1,"D‚truire|Annuler",l1|
ENDIF
IF l1|=1
efface_curseur
DEFMOUSE 2
m1$=""
IF win_ed|=0                  ! Codes vdt
code_vdt(g10&,g11&,FALSE)     ! Codage bloc
ELSE                          ! Mots clefs, Infos tel, messages systŠme
FOR m1&=g10& TO g11&
m1$=m1$+editor$(m1&)+CHR$(0)
NEXT m1&
ENDIF
edit_buff$(win_ed|)=m1$       ! Stock in buffer
m_iena(1,MKI$(35)+MKI$(36)+MKI$(37))
DEFMOUSE 0
affiche_curseur
ENDIF
ENDIF
RETURN
'
> PROCEDURE code_vdt(a&,b&,p.affiche!)
'
' Code instructs en codes vdt:
'
m1$=""
FOR m2&=a& TO b&
m2$=LEFT$(editor$(m2&),5)
m1|=LEN(editor$(m2&))
IF m2$="BELL "
m3$=CHR$(7)
ELSE IF m2$="CAN "
m3$=CHR$(24)
ELSE IF m2$="CLS "
m3$=CHR$(12)
ELSE IF m2$="CSR  "
IF FN onoff$="N"
m3$=CHR$(17)
ELSE
m3$=CHR$(20)
ENDIF
ELSE IF m2$="CR "
m3$=CHR$(13)
ELSE IF m2$="CODE "
m3$=CHR$(VAL(MID$(editor$(m2&),11,3)))
ELSE IF m2$="DEL.C"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"P"
ELSE IF m2$="DEL.L"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"M"
ELSE IF m2$="DOWN "
m3$=CHR$(10)
ELSE IF m2$="E.LEF"
m3$=e80$+"1K"
ELSE IF m2$="E.LIG"
m3$=e80$+"2K"
ELSE IF m2$="E.PAG"
m3$=e80$+"2J"
ELSE IF m2$="E.PRE"
m3$=e80$+"1J"
ELSE IF m2$="E.SUC"
m3$=e80$+"J"
ELSE IF m2$="FLASH"
IF FN onoff$="N"
m3$=CHR$(27)+CHR$(72)
ELSE
m3$=CHR$(27)+CHR$(73)
ENDIF
ELSE IF m2$="GFONT"
IF FN lettre$="N"
m3$=CHR$(27)+")c"
ELSE
m3$=CHR$(27)+") C"
ENDIF
ELSE IF m2$="GRAPH"
m3$=CHR$(14)
ELSE IF m2$="HOME "
m3$=CHR$(30)
ELSE IF m2$="INK  "
SELECT VAL(FN lettre$)
CASE 0
m3$=CHR$(27)+CHR$(64)
CASE 1
m3$=CHR$(27)+CHR$(68)
CASE 2
m3$=CHR$(27)+CHR$(65)
CASE 3
m3$=CHR$(27)+CHR$(69)
CASE 4
m3$=CHR$(27)+CHR$(66)
CASE 5
m3$=CHR$(27)+CHR$(70)
CASE 6
m3$=CHR$(27)+CHR$(67)
DEFAULT
m3$=CHR$(27)+CHR$(71)
ENDSELECT
ELSE IF m2$="INSER"
m3$=CHR$(27)+CHR$(91)+"4h"
ELSE IF m2$="INSLI"
m3$=CHR$(27)+CHR$(91)+CHR$(76)
ELSE IF m2$="INS.L"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"L"
ELSE IF m2$="INTEN"
IF FN onoff$="N"
m3$=e80$+"1m"
ELSE
m3$=e80$+"22m"
ENDIF
ELSE IF m2$="INVER"
IF FN onoff$="N"
m3$=CHR$(27)+CHR$(93)
ELSE
m3$=CHR$(27)+CHR$(92)
ENDIF
ELSE IF m2$="LEFT "
m3$=CHR$(8)
ELSE IF m2$="LINE "
IF FN onoff$="N"
m3$=CHR$(27)+CHR$(90)
ELSE
m3$=CHR$(27)+CHR$(89)
ENDIF
ELSE IF m2$="LINEM"
IF FN onoff$="N"
m3$=CHR$(27)+CHR$(88)+CHR$(32)
ELSE
m3$=CHR$(27)+CHR$(95)+CHR$(32)
ENDIF
ELSE IF m2$="LOCAT"
l1|=VAL(MID$(editor$(m2&),11,2))
m3$=CHR$(31)+CHR$(VAL(MID$(editor$(m2&),12+LEN(STR$(l1|)),2))+64)+CHR$(l1|+64)
ELSE IF m2$="MASK "
m3$=CHR$(27)+CHR$(35)+CHR$(32)+CHR$(88)
ELSE IF m2$="MCAN "
m3$=e80$+"K"
ELSE IF m2$="MDOWN"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"B"
ELSE IF m2$="MHOME"
m3$=e80$+"H"
ELSE IF m2$="MFLAS"
IF FN onoff$="N"
m3$=e80$+"5m"
ELSE
m3$=e80$+"25m"
ENDIF
ELSE IF m2$="MINVE"
IF FN onoff$="N"
m3$=e80$+"7m"
ELSE
m3$=e80$+"27m"
ENDIF
ELSE IF m2$="MLEFT"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"D"
ELSE IF m2$="MLINE"
IF FN onoff$="N"
m3$=e80$+"4m"
ELSE
m3$=e80$+"24m"
ENDIF
ELSE IF m2$="MLOCA"
l1$=MID$(editor$(m2&),11,INSTR(editor$(m2&),",",12)-11)
m3$=e80$+MID$(editor$(m2&),12+LEN(l1$),m1|-12-LEN(l1$))+";"+l1$+"H"
ELSE IF m2$="MRESE"
m3$=e80$+"m"
ELSE IF m2$="MRIGH"
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"C"
ELSE IF m2$="MUP  "
m3$=e80$+MID$(editor$(m2&),11,m1|-11)+"A"
ELSE IF m2$="NUL "
m3$=CHR$(0)
ELSE IF m2$="OVERW"
m3$=CHR$(27)+CHR$(91)+"4l"
ELSE IF m2$="PAPER"
SELECT VAL(FN lettre$)
CASE 0
m3$=CHR$(27)+CHR$(80)
CASE 1
m3$=CHR$(27)+CHR$(84)
CASE 2
m3$=CHR$(27)+CHR$(81)
CASE 3
m3$=CHR$(27)+CHR$(85)
CASE 4
m3$=CHR$(27)+CHR$(82)
CASE 5
m3$=CHR$(27)+CHR$(86)
CASE 6
m3$=CHR$(27)+CHR$(83)
DEFAULT
m3$=CHR$(27)+CHR$(87)
ENDSELECT
ELSE IF m2$="REPEA"
m3$=CHR$(18)+CHR$(VAL(MID$(editor$(m2&),11,3))+64)
ELSE IF m2$="RIGHT"
m3$=CHR$(9)
ELSE IF m2$="SIZE "
l1$=FN lettre$
IF l1$="H"
m3$=CHR$(27)+CHR$(77)
ELSE IF l1$="W"
m3$=CHR$(27)+CHR$(78)
ELSE IF l1$="D"
m3$=CHR$(27)+CHR$(79)
ELSE
m3$=CHR$(27)+CHR$(76)
ENDIF
ELSE IF m2$="SUPLI"
m3$=CHR$(27)+CHR$(91)+CHR$(77)
ELSE IF m2$="TELCO"
m3$=CHR$(31)+CHR$(35)+CHR$(VAL(MID$(editor$(m2&),11,3)))+CHR$(48)
ELSE IF m2$="TELGR"
m3$=CHR$(31)+"#   CI"
ELSE IF m2$="TELTE"
m3$=CHR$(31)+"#   BI"
ELSE IF m2$="TEXT "
m3$=""
FOR l2|=12 TO LEN(editor$(m2&))-2
l1$=MID$(editor$(m2&),l2|,1)
l3|=ASC(l1$)
IF l3|>127
code_accent(l3|)
ENDIF
m3$=m3$+l1$
NEXT l2|
ELSE IF m2$="TEXTM"
m3$=CHR$(15)
ELSE IF m2$="TFONT"
IF FN lettre$="N"
m3$=CHR$(27)+"(@"
ELSE
m3$=CHR$(27)+"( B"
ENDIF
ELSE IF m2$="UNMAS"
m3$=CHR$(27)+CHR$(35)+CHR$(32)+CHR$(95)
ELSE IF m2$="UP "
m3$=CHR$(11)
ELSE IF m2$="*BALS"
m3$=CHR$(137)
ELSE IF m2$="*CLOC"
IF FN onoff$="N"
m3$=CHR$(132)
ELSE
m3$=CHR$(133)
ENDIF
ELSE IF m2$="*DEFG"
IF FN lettre$="N"
m3$=CHR$(142)
ELSE
m3$=CHR$(143)
ENDIF
ELSE IF m2$="*DEFT"
IF FN lettre$="N"
m3$=CHR$(140)
ELSE
m3$=CHR$(141)
ENDIF
ELSE IF m2$="*ID "
m3$=CHR$(139)
ELSE IF m2$="*INTE"
IF FN onoff$="N"
m3$=CHR$(130)
ELSE
m3$=CHR$(131)
ENDIF
ELSE IF m2$="*MIXT"
m3$=CHR$(144)
ELSE IF m2$="*PAGE"
m3$=CHR$(129)
ELSE IF m2$="*PAUS"
m3$=CHR$(148)+CHR$(64+VAL(MID$(editor$(m2&),11,3)))
ELSE IF m2$="*PSEU"
m3$=CHR$(136)
ELSE IF m2$="*RECA"
IF FN lettre$="T"
m3$=CHR$(146)
ELSE
m3$=CHR$(147)
ENDIF
ELSE IF m2$="*RUB "
m3$=CHR$(138)
ELSE IF m2$="*SCRO"
m3$=CHR$(128)
ELSE IF m2$="*SYSM"
m3$=CHR$(149)
ELSE IF m2$="*TOPL"
m3$=CHR$(135)
ELSE IF m2$="*TPAP"
SELECT VAL(FN lettre$)
CASE 0
m3$=CHR$(134)+CHR$(80)
CASE 1
m3$=CHR$(134)+CHR$(84)
CASE 2
m3$=CHR$(134)+CHR$(81)
CASE 3
m3$=CHR$(134)+CHR$(85)
CASE 4
m3$=CHR$(134)+CHR$(82)
CASE 5
m3$=CHR$(134)+CHR$(86)
CASE 6
m3$=CHR$(134)+CHR$(83)
DEFAULT
m3$=CHR$(134)+CHR$(87)
ENDSELECT
ELSE IF m2$="*VIDE"
m3$=CHR$(145)
ELSE
OUT 2,7
ENDIF
'
IF p.affiche!                 ! Mode TEST
l1|=ASC(m3$)
SELECT l1|
CASE 0 TO 127
PRINT #99;m3$;                ! Envoi au minitel
CASE 134                      ! *TPAPER x
l1|=ASC(RIGHT$(m3$))          ! Extraction code couleur
tpaper
CASE 148                      ! *PAUSE x
pause%=TIMER+(ASC(RIGHT$(m3$))-65)*100 ! Timer de sortie
WHILE TIMER<pause%            ! En attente
EXIT IF INP(-2)
WEND
DEFAULT
vdt_special
ENDSELECT
'
IF INP(-2)
~INP(2)
EXIT IF TRUE
ENDIF
ELSE                          ! Mode CODAGE
m1$=m1$+m3$
ENDIF
NEXT m2&
RETURN
> PROCEDURE control_x(a|)
'
' Controle et r‚ctifie 1 param contenant une coord X:
'
'
l1&=VAL(parametre$(a|))
IF l1&<1
l1&=1
ELSE IF l1&>40
l1&=40
ENDIF
parametre$(a|)=STR$(l1&)
RETURN
> PROCEDURE control_y(a|)
'
' Control et r‚ctifie 1 param contenant 1 coord Y:
'
l1&=VAL(parametre$(a|))
IF l1&<0
l1&=0
ELSE IF l1&>24
l1&=24
ENDIF
parametre$(a|)=STR$(l1&)
RETURN
> PROCEDURE control(a|,b|,a%)
'
' Control & r‚ctifie 1 param contenant 1 val comprise entre b et c:
'
l1%=VAL(parametre$(a|))
IF l1%<b|
l1%=b|
ELSE IF l1%>a%
l1%=a%
ENDIF
parametre$(a|)=STR$(l1%)
RETURN
> PROCEDURE copier_arbo
copier_page(2,arbo$,nbp_arbo_max&,nbn_arbo&,nbp_arbo&,nom_arbo$(),info_arbo|(),page_arbo$(),alpha_arbo$(),first_arbo&)
RETURN
> PROCEDURE copier_page(type&,VAR nom$,p.max&,nbn&,nbp&,nom$(),info|(),page$(),alpha$(),first_obj&)
'
' Copy page:
'
titre("Copie d'une "+tpage$(type&))
copy:
DEFMOUSE 0
select(tpage$(type&)+" SOURCE",nom$,nbn&)
DEFMOUSE 2
IF b%=27                      ! Confirmation
g1$=FN edit$(26)              ! Nom page
g0&=FN find_page(g1$,nbp&,nom$()) ! Nø page
IF g0&=>0                     ! Si page dem exist
IF info|(g0&)=2               ! Si page ‚ffac‚e
ALERT 1,"Cette page … ‚t‚|‚ffac‚e !",1,"   OK   ",l1&
GOTO copy
ENDIF
'
' Page destination
'
dest:
DEFMOUSE 0
select(tpage$(type&)+" DESTINATION",nom$,nbn&)
DEFMOUSE 2
IF b%=27                      ! Confirmation
nom$=FN edit$(26)             ! Nom page
IF LEN(nom$)=FALSE
nom$="SANS_NOM"
ENDIF
g1&=FN find_page(nom$,nbp&,nom$()) ! Nø page
'
IF g1&<0                      ! Si page n'exist pas encore
IF FN free_page(p.max&," page",nbn&,nbp&)
g1&=nbp&
nom$(g1&)=nom$                ! Nom page
INC nbp&                      ! 1 de +
new_page(g1&,nom$)            ! Fixe noms
ELSE
GOTO fin_copy
ENDIF
ELSE IF info|(g1&)=2        ! Si page ‚ffac‚e
new_page(g1&,nom$)            ! Fixe noms
ELSE                          ! Si page existait d‚j…
ALERT 2,"La page "+nom$+"|va ˆtre ‚cras‚e!|Voulez-vous|continuer?",1,"Continue|Abandon",l1&
IF l1&=2
GOTO dest
ENDIF
modif_page(g1&,nom$)          ! Signale modif ds liste
ENDIF
page$(g1&)=page$(g0&)         ! Stocke page cod‚e
enable_maj(type&)
ENDIF
ELSE
ALERT 1,"La page demand‚e|n'existe pas...",1,"   OK   ",void
GOTO copy
ENDIF
ENDIF
fin_copy:
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE copier_vdt
copier_page(1,vdt$,nbp_vdt_max&,nbn_vdt&,nbp_vdt&,nom_vdt$(),info_vdt|(),page_vdt$(),alpha_vdt$(),first_vdt&)
RETURN
> PROCEDURE copy_bloc
'
' Copie bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
l1&=g11&-g10&                 ! Long bloc-1
IF nbl%+l1&<win_max%          ! Si assez de place
IF g8&<=g10& OR g8&>g11&      ! Si csr hors bloc
DEFMOUSE 2
efface_curseur
FOR l2&=0 TO l1&
l1$=editor$(g11&-l2&)
INSERT editor$(g8&)=l1$
IF g8&<=g10&
INC g10&
INC g11&
ENDIF
NEXT l2&
ADD nbl%,SUCC(l1&)            ! nb lignes de +
g9&=1
g7&=g8&-9
IF g7&<0
g7&=0
ENDIF
taille_asc
affiche_texte
DEFMOUSE 0
ELSE
ALERT 1,"Vous ne pouvez pas|copier ce bloc dans|lui-mˆme!",1,"   OK   ",void
ENDIF
ELSE
ALERT 1,"Il ne reste plus assez de|lignes disponibles pour|reproduire ce bloc.",1,"   OK   ",void
ENDIF
ENDIF
RETURN
> PROCEDURE create_new
LOCAL l.folder&
'
' Cr‚er un nouveau serveur:
'
titre("Cr‚ation d'une base pour un nouveau serveur")
adr%=create_new.adr%
affiche_rsc
IF b%=16              ! Si on veut continuer
l1&=FORM_ALERT(2,"[0][Vous allez choisir un|emplacement sur disque  |o— nous pourrons cr‚er|le nouveau serveur...][Continuer|Annuler]")
IF l1&=1
cur_dir               ! Directory courant=>g1$
f_titre$="CHOIX DESTINATION"
set_dir               ! S‚lectionne un directory
DEFMOUSE 2
IF LEN(g1$)             ! Si on a un directory correct
adr%=fichiers.adr%
set_edit(1,"Cr‚ation d'un nouveau serveur")
aff_charsauve
~FRE(0)                       ! Garbage collect
create_new:
DATA SYSTEME,DATA,BALS,SERVEUR
m1&=1
'
' Cr‚ation des dossiers
'
err_resume&=11
REPEAT
err_choix&=FALSE      ! Pas d'erreur pour l'instant
RESTORE create_new
IF m1&>1
FOR l1&=2 TO m1&
READ l1$              ! Nom du dossier d‚j… cr‚‚
NEXT l1&
ENDIF
FOR m1&=m1& TO 4
READ m1$              ! Nom du dossier … cr‚er
control_folder(1,m1$,g1$+m1$+"\")
IF l.folder&=TRUE
l1&=FORM_ALERT(2,"[3][|ATTENTION: Le dossier|"+m1$+" existe d‚j…!|Est-ce voulu?][Continuer|Annuler]")
IF l1&=2                ! Si on veut ANNULER
err_choix&=1            ! Il s'est produit une erreur!
EXIT IF TRUE
ENDIF
ELSE
set_string(6,"Cr‚ation")
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
MKDIR g1$+m1$         ! Cr‚ation dossier
ENDIF
chemin$(PRED(m1&))=g1$+m1$+"\"
NEXT m1&
err_11:
UNTIL err_choix&<>2
err_resume&=FALSE
'
' Chargement STUT_ONE.NEW
'
IF err_choix&=FALSE
set_string(5,"Fichier "+stut$+"NEW")
set_string(6,"Chargement")
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
IF ASC(path$)<67              ! Si path sur A: ou B:
ALERT 3,"Inserez la disquette|de lancement de|STUT ONE ("+LEFT$(path$)+":).",1,"   OK   ",void
ENDIF
g2$=path$+stut$+"NEW"
REPEAT
IF EXIST(g2$)
l1&=FALSE
ELSE
ALERT 3,"|Le fichier "+stut$+"NEW|est introuvable!",1,"Retry|Abandon",l1&
ENDIF
UNTIL l1&<>1
IF l1&=FALSE          ! Si pas d'erreur
OPEN "I",#1,g2$
'
' Pages vid‚otex
'
charge_pages("",nbp_vdt&,nom_vdt$(),info_vdt|(),page_vdt$(),nbn_vdt&,alpha_vdt$())
IF err_choix&=FALSE
set_loaded            ! le serveur sera charg‚!
enable_maj(1)         ! On a modifi‚ les pages VDT
'
' Pages arborescence:
'
charge_pages("",nbp_arbo&,nom_arbo$(),info_arbo|(),page_arbo$(),nbn_arbo&,alpha_arbo$())
IF err_choix&=FALSE
modify!(2)=TRUE       ! On a modifi‚ les pages ARBO
'
' Messages systŠme:
'
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
charge_messages(TRUE)
IF err_choix&=FALSE
modify!(8)=TRUE       ! On a modifi‚ les msgs sys
'
' Divers:
'
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%) ! Affiche
charge_divers(TRUE)
IF err_choix&=FALSE
  modify!(10)=TRUE       ! On a modifi‚ les params divers
  '
  CLOSE #1
  '
  real_load&=TRUE       ! Tout s'est bien pass‚!
  '
  set_string(5,"Dossier SYSTEME")
  set_string(6,"Mise … jour")
  ~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
  IF ASC(path$)<67 AND ASC(chemin$(0))<67
    ALERT 3,"Inserez la disquette|pr‚vue pour recevoir|le nouveau serveur("+LEFT$(chemin$(0))+":).",1,"   OK   ",void
  ENDIF
  sauve_systeme       ! Sauvegarde!
  IF err_choix&=FALSE
    modify!(0)=FALSE              ! Plus de modifs
    ~MENU_IENABLE(menu.adr%,maj|,0) ! Disable maj
  ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF err_choix&>0 AND real_load&=FALSE ! S'il s'est produit une erreur de chargement
init_totale         ! Efface tout ce qui a ‚t‚ charg‚
ENDIF
ENDIF
'
ENDIF
~FRE(0)                       ! Garbage collect
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%) ! LibŠre zone ‚cran
fram
ENDIF
ENDIF
ENDIF
~MENU_BAR(menu.adr%,1)
DEFMOUSE 0
RETURN
'
> PROCEDURE decode_vdt(a$,a&,b&)
'
' D‚codage d'une page vdt:
'
g1%=LEN(a$)                   ! Longueur page
FOR g2%=1 TO g1%              ! On d‚code code par code
CLR m1|                       ! Nb codes ayant const instruction
m2|=ASC(MID$(a$,g2%,1))       ! 1er code de l'instruction
SELECT m2|
CASE 0
m1$="NUL "
CASE 7
m1$="BELL "
CASE 8
m1$="LEFT "
CASE 9
m1$="RIGHT "
CASE 10
m1$="DOWN "
CASE 11
m1$="UP "
CASE 12
m1$="CLS "
CASE 13
m1$="CR "
CASE 14
m1$="GRAPHMODE "
CASE 15
m1$="TEXTMODE "
CASE 24
m1$="CAN "
CASE 17
m1$="CSR       ON "
CASE 18
m2|=ASC(MID$(a$,g2%+1,1))
IF m2|>63                             ! Si code suivant correct
m1$="REPEAT    "+STR$(m2|-64)+" "
INC m1|                               ! 1 code de + pour l'instruction
ELSE                                  ! Si code suivant incorrect
m1$="CODE      18 "
ENDIF
CASE 20
m1$="CSR       OFF "
CASE 22,25
m5|=ASC(MID$(a$,g2%+1,1))
m3|=ASC(MID$(a$,g2%+2,1))
@decode_accent(m5|,m3|)
IF l1|                                ! Si on a pu d‚coder accent
m1$="TEXT      >"+l1$
m1|=l1|                               ! Nb de codes dans l'instruction
GOTO ins_text
ELSE
m1$="CODE      "+STR$(m2|)+" "
ENDIF
CASE 27
INC m1|
m2|=ASC(MID$(a$,g2%+1,1))
SELECT m2|
CASE 35
IF MID$(a$,g2%+2,1)=" "
l2|=ASC(MID$(a$,g2%+3,1))
IF l2|=88
ADD m1|,2
m1$="MASK "
ELSE IF l2|=95
ADD m1|,2
m1$="UNMASK "
ELSE
m1|=FALSE
ENDIF
ELSE
m1|=FALSE
ENDIF
CASE 40
IF MID$(a$,g2%+2,1)="@"
m1$="TFONT     N "
INC m1|
ELSE IF MID$(a$,g2%+2,2)=" B"
m1$="TFONT     D "
m1|=3
ELSE
m1$="CODE      27 "
m1|=FALSE
ENDIF
CASE 41
IF MID$(a$,g2%+2,1)="c"
m1$="GFONT     N "
INC m1|
ELSE IF MID$(a$,g2%+2,2)=" C"
m1$="GFONT     D "
m1|=3
ELSE
m1$="CODE      27 "
m1|=FALSE
ENDIF
CASE 64
m1$="INK       0 "
CASE 65
m1$="INK       2 "
CASE 66
m1$="INK       4 "
CASE 67
m1$="INK       6 "
CASE 68
m1$="INK       1 "
CASE 69
m1$="INK       3 "
CASE 70
m1$="INK       5 "
CASE 71
m1$="INK       7 "
CASE 72
m1$="FLASH     ON "
CASE 73
m1$="FLASH     OFF "
CASE 76
m1$="SIZE      N "
CASE 77
m1$="SIZE      H "
CASE 78
m1$="SIZE      W "
CASE 79
m1$="SIZE      D "
CASE 80
m1$="PAPER     0 "
CASE 81
m1$="PAPER     2 "
CASE 82
m1$="PAPER     4 "
CASE 83
m1$="PAPER     6 "
CASE 84
m1$="PAPER     1 "
CASE 85
m1$="PAPER     3 "
CASE 86
m1$="PAPER     5 "
CASE 87
m1$="PAPER     7 "
CASE 88
IF MID$(a$,g2%+2,1)=" "
INC m1|
m1$="LINEMASK  ON "
ELSE
m1|=FALSE
ENDIF
CASE 90
m1$="LINE      ON "
CASE 89
m1$="LINE      OFF "
CASE 91
INC m1|
l1$=MID$(a$,g2%+2,1)
IF l1$="J"
m1$="E.SUCC "
ELSE IF l1$="K"
m1$="MCAN "
ELSE IF l1$="H"
m1$="MHOME "
ELSE IF l1$="L"
m1$="INSLINE "
ELSE IF l1$="M"
m1$="SUPLINE "
ELSE IF l1$="m"
m1$="MRESET "
ELSE
INC m1|
l2$=MID$(a$,g2%+2,2)
IF l2$="0J"
m1$="E.SUCC "
ELSE IF l2$="1J"
m1$="E.PRED "
ELSE IF l2$="1K"
m1$="E.LEFT "
ELSE IF l2$="2K"
m1$="E.LIGNE "
ELSE IF l2$="2J"
m1$="E.PAGE "
ELSE IF l2$="0m"
m1$="MRESET "
ELSE IF l2$="1m"
m1$="INTENSE   ON "
ELSE IF l2$="4m"
m1$="MLINE     ON "
ELSE IF l2$="5m"
m1$="MFLASH    ON "
ELSE IF l2$="7m"
m1$="MINVERSE  ON "
ELSE IF l2$="4h"
m1$="INSERT"
ELSE IF l2$="4l"
m1$="OVERWRITE"
ELSE
INC m1|
l3$=MID$(a$,g2%+2,3)
IF l3$="22m"
m1$="INTENSE   OFF "
ELSE IF l3$="24m"
m1$="MLINE     OFF "
ELSE IF l3$="25m"
m1$="MFLASH    OFF "
ELSE IF l3$="27m"
m1$="MINVERSE  OFF "
ELSE
l4$=""
FOR l1|=1 TO 3
l2|=ASC(MID$(l3$,l1|,1))
IF l2|=59 OR (l2|>64 AND l2|<69) OR l2|=76 OR l2|=77 OR l2|=80
SUB m1|,3-l1|
IF l1|=1
  l3|=1                         ! 1 car min
ELSE
  l3|=VAL(LEFT$(l3$,PRED(l1|))) ! nb MOVEs
ENDIF
IF l3|>0
  SELECT l2|
  CASE 59                         ! Si ca ressemble … locate
    IF l3|<25
      l5$=MID$(a$,g2%+2+l1|,3)
      FOR l4|=2 TO 3
        l5|=ASC(MID$(l5$,l4|,1))
        IF l5|=72
          l6|=VAL(LEFT$(l5$,PRED(l4|))) ! y
          IF l6|>0 AND l6|<81
            ADD m1|,l4|
            l4$="MLOCATE   "+STR$(l6|)+","+STR$(l3|)+" "
            EXIT IF TRUE
          ENDIF
        ENDIF
      NEXT l4|
    ENDIF
  CASE 65
    IF l3|<24
      l4$="MUP       "+STR$(l3|)+" "
    ENDIF
  CASE 66
    IF l3|<24
      l4$="MDOWN     "+STR$(l3|)+" "
    ENDIF
  CASE 67
    IF l3|<80
      l4$="MRIGHT    "+STR$(l3|)+" "
    ENDIF
  CASE 68
    IF l3|<80
      l4$="MLEFT     "+STR$(l3|)+" "
    ENDIF
  CASE 76
    IF l3|<25
      l4$="INS.L     "+STR$(l3|)+" "
    ENDIF
  CASE 77
    IF l3|<25
      l4$="DEL.L     "+STR$(l3|)+" "
    ENDIF
  CASE 80
    IF l3|<81
      l4$="DEL.C     "+STR$(l3|)+" "
    ENDIF
  ENDSELECT
ENDIF
ENDIF
EXIT IF LEN(l4$)
NEXT l1|
IF LEN(l4$)
m1$=l4$
ELSE
m1$="CODE      27 "
m1|=FALSE
ENDIF
ENDIF
ENDIF
ENDIF
CASE 92
m1$="INVERSE   OFF "
CASE 93
m1$="INVERSE   ON "
CASE 95
IF MID$(a$,g2%+2,1)=" "
INC m1|
m1$="LINEMASK  OFF "
ELSE
m1|=FALSE
m1$="CODE      27 "
ENDIF
DEFAULT
m1|=FALSE
ENDSELECT
IF m1|=FALSE                  ! Si s‚quence incorrecte
m1$="CODE      27 "
ENDIF
CASE 30
m1$="HOME "
CASE 31
m2|=ASC(MID$(a$,g2%+1,1))
m3|=ASC(MID$(a$,g2%+2,1))
IF m2|>63 AND m3|>64          ! Si les coord sont correctes
m1$="LOCATE    "+STR$(m3|-64)+","+STR$(m2|-64)+" "
ADD m1|,2
ELSE IF m2|=35                ! Si d‚but de chargement DRCS
l1$=MID$(a$,g2%+2,5)
IF l1$="   BI"
m1$="TELTEXT "
ADD m1|,6
ELSE IF l1$="   CI"
m1$="TELGRAPH "
ADD m1|,6
ELSE IF ASC(MID$(a$,g2%+3,1))=48 AND m3|>32 AND m3|<127
m1$="TELCODE   "+STR$(m3|)+" "
ADD m1|,3
ELSE
m1$="CODE      31 "
ENDIF
ELSE
m1$="CODE      31 "
ENDIF
CASE 32 TO 126
m1$="TEXT      >"+CHR$(m2|)
ins_text:
ADD g2%,1+m1|
CLR m4|
WHILE g2%<=g1% AND m4|<39
CLR m1|
m2|=ASC(MID$(a$,g2%,1))
IF m2|=22 OR m2|=25
m2|=ASC(MID$(a$,g2%+1,1))
m3|=ASC(MID$(a$,g2%+2,1))
@decode_accent(m2|,m3|)
EXIT IF l1|=0
m1$=m1$+l1$
m1|=l1|
ELSE
EXIT IF m2|<32 OR m2|>126
m1$=m1$+CHR$(m2|)
ENDIF
ADD g2%,1+m1|
INC m4|
WEND
SUB g2%,1+m1|
m1$=m1$+"< "
CASE 128
m1$="*SCROLL "
CASE 129
m1$="*PAGE "
CASE 130
m1$="*INTER    ON "
CASE 131
m1$="*INTER    OFF "
CASE 132
m1$="*CLOCK    ON "
CASE 133
m1$="*CLOCK    OFF "
CASE 134
INC m1|
m2|=ASC(MID$(a$,g2%+1,1))
SELECT m2|
CASE 80
m1$="*TPAPER   0 "
CASE 81
m1$="*TPAPER   2 "
CASE 82
m1$="*TPAPER   4 "
CASE 83
m1$="*TPAPER   6 "
CASE 84
m1$="*TPAPER   1 "
CASE 85
m1$="*TPAPER   3 "
CASE 86
m1$="*TPAPER   5 "
CASE 87
m1$="*TPAPER   7 "
DEFAULT
CLR m1|
m1$="*TPAPER   0 "
ENDSELECT
CASE 135
m1$="*TOPLINE "
CASE 136
m1$="*PSEUDO "
CASE 137
m1$="*BALSTATE "
CASE 138
m1$="*RUB "
CASE 139
m1$="*ID "
CASE 140
m1$="*DEFTEXT  N "
CASE 141
m1$="*DEFTEXT  D "
CASE 142
m1$="*DEFGRAPH N "
CASE 143
m1$="*DEFGRAPH D "
CASE 144
m1$="*MIXTE "
CASE 145
m1$="*VIDEOTEX "
CASE 146
m1$="*RECALL   T "
CASE 147
m1$="*RECALL   G "
CASE 148
INC m1|
m2|=ASC(MID$(a$,g2%+1,1))-64
m1$="*PAUSE    "+STR$(m2|)+" "
CASE 149
m1$="*SYSMSG "
DEFAULT
m1$="CODE      "+STR$(m2|)+" "
ENDSELECT
IF a&=nbl%                    ! Si on ajoute en fin de page
editor$(a&)=m1$
ADD g2%,m1|
INC nbl%
INC a&
EXIT IF PRED(a&)=b&           ! Si nbl max atteint
ELSE                          ! Si on insŠre cette ligne
INSERT editor$(a&)=m1$
ADD g2%,m1|
INC nbl%
INC a&
EXIT IF PRED(a&)=b&           ! Si nbl max atteint
ENDIF
NEXT g2%
IF g2%<SUCC(g1%)              ! Si la page n'est pas entiŠrement d‚col‚e
ALERT 3,"Cette page est trop|longue pour ˆtre|entiŠrement d‚cod‚e.",1,"   OK   ",void
ENDIF
IF nbl%=a&
editor$(nbl%)=" "
ENDIF
RETURN
> PROCEDURE deplace_curseur(p.x&,p.y&)
'
' D‚place csr dans l'‚diteur GEM:
'
l1|=LEN(editor$(p.y&))
IF p.x&>l1|
p.x&=l1|
ENDIF
efface_curseur
g8&=p.y&
g9&=p.x&
affiche_curseur
RETURN
'
> PROCEDURE editarbo_acces
'
' Edit page ACCES:
'
acces_dat:
DATA 4,0,5,9,6,10,18,2,19,3,20,4,21,5,22,6,23,7,24,8,0,0
'
adr%=acces.adr%
set_string(2,nom$)            ! Init NOM PAGE
'
RESTORE acces_dat
set_edits
'
set_bout(1,9,8,0)
'
editer_arbo_noyau(29)         ! FORM_DO etc...
'
IF b%=31
validation|=2
RESTORE acces_dat
extract_edits
control(6,0,9999)
control(7,0,9999)
control(8,0,9999)
FOR l1|=2 TO 3
parametre$(38)=LEFT$(parametre$(l1|),2)
parametre$(39)=MID$(parametre$(l1|),3,2)
control(38,0,23)
control(39,0,59)
parametre$(l1|)=RIGHT$("0"+parametre$(38),2)+RIGHT$("0"+parametre$(39),2)
NEXT l1|
get_bout(1,9,8)
ENDIF
RETURN
> PROCEDURE editarbo_aff
'
' Edit page AFFICHE:
'
aff_dat:
DATA 3,4,5,0,6,1,7,2,8,3,27,5,28,6,29,7,30,8,10,9,11,10,12,11,14,13,15,14
DATA 16,15,17,16,21,20,23,21,24,22,25,23,0,0
'
adr%=affiche.adr%
set_string(2,nom$)            ! Init NOM PAGE
RESTORE aff_dat
set_edits
set_state(31,VAL(parametre$(12)),0,1)
l1&=VAL(parametre$(19))
set_state(19,-(l1&=0),0,1)
set_state(20,-(l1&=1),0,1)
set_state(22,-(l1&=2),0,1)
'
editer_arbo_noyau(33)         ! FORM_DO etc...
'
IF b%=35
validation|=2
RESTORE aff_dat
extract_edits
control(9,0,16)
IF LEN(parametre$(10))
control(10,32,127)
ENDIF
control(11,32,127)
parametre$(12)=STR$(FN selected(31))
IF FN selected(19)
parametre$(19)="0"
ELSE IF FN selected(20)
parametre$(19)="1"
ELSE
parametre$(19)="2"
ENDIF
control(20,1,nbl_aff_max&)
control(21,0,9)
ENDIF
RETURN
> PROCEDURE editarbo_dialogue
'
' Edit page DIALOGUE:
'
dialogue_dat:
DATA 3,0,5,1,6,2,7,3,13,5,14,6,15,7,16,8,17,9,18,10,0,0
DATA 8,4,9,12,0,0
'
adr%=dialogue.adr%
set_string(2,nom$)            ! Init NOM PAGE
RESTORE dialogue_dat
set_edits
set_selecteds
'
editer_arbo_noyau(21)         ! FORM_DO etc...
'
IF b%=23
validation|=2
RESTORE dialogue_dat
extract_edits
control(5,1,24)
control(6,1,10)
control(8,1,24)
control(9,1,10)
extract_selecteds
ENDIF
RETURN
> PROCEDURE editarbo_ecriture
'
' Edit page ECRI_RUB(11),ECRI_BAL(16),EDIT_REP(18):
'
ecrilir_dat:
DATA 04,%110100,06,%000010,07,%000010,08,%000010
DATA 09,%000010,10,%000010,11,%000010,12,%000010,13,%000010
DATA 14,%000010,15,%000010,16,%001011,18,%000110
DATA 22,%000111,26,%111000,27,%010000,28,%010000
DATA 29,%011000,30,%011000,32,%010000,33,%010000,34,%010000
DATA 47,%011111,48,%011111,49,%111110,50,%111110,51,%111110
DATA 52,%111110,53,%111110,54,%111110,55,%010111,56,%010111,57,%010000,58,%010000,59,%011110,60,%011110,61,%011110
DATA 62,%111110,63,%111110,64,%111110,66,%111110,67,%111110,70,%000111,72,%011000,0,0
'
ecriture_dat:
DATA 4,41,6,0,7,11,8,12,9,13,10,15,11,1,12,14,13,16,14,2,15,42
DATA 18,45,19,81,20,43,21,4,22,5,23,7,25,8,26,41,27,41,28,41,29,41,30,41,31,9
DATA 32,41,33,41,34,41,47,20,48,21,49,22,50,23,51,24,52,25,53,26,54,27
DATA 55,28,56,29,57,41,58,41,59,30,60,31,61,32,62,33,63,34,64,35,65,17
DATA 66,36,67,44,68,37,70,38,71,18,72,41,0,0
DATA 6,41,7,41,8,41,9,41,10,41,11,41,13,41,14,41,15,41,16,41,0,0
'
adr%=ecrilir.adr%
set_string(2,nom$)            ! Init NOM PAGE
IF fnct|=11
set_edit(3,"Ecriture d'un message en rubrique:")
ELSE IF fnct|=16
set_edit(3,"Ecriture d'un message en BAL      ")
ELSE
set_edit(3,"Edition du r‚pondeur de sa BAL    ")
ENDIF
'
' Settings g‚n‚raux pour l'‚criture
set_string(36,"  TEXT  ")
set_string(37,"VIDEOTEX")
RESTORE ecrilir_dat
SELECT fnct|
CASE 11
m1&=2
CASE 16
m1&=1
CASE 18
m1&=0
ENDSELECT
enable_ecrilir
set_state(44,0,1,1)           ! Pas de r‚p poss alors que msg pas encore ‚crit
'
parametre$(42)=TRIM$(LEFT$(parametre$(10),8))
parametre$(43)=TRIM$(MID$(parametre$(10),9,8))
parametre$(44)=TRIM$(RIGHT$(parametre$(10),2))
IF fnct|=18
parametre$(81)=parametre$(3)
ELSE
parametre$(45)=TRIM$(LEFT$(parametre$(3),8))
parametre$(81)=MID$(parametre$(3),9)
ENDIF
set_edits
IF fnct|<>16                  ! Si pas ECRI_BAL
set_edits                     ! Init encore des champs
ENDIF
IF fnct|=11
set_edit(4,parametre$(6))     ! Rubrique
ELSE
IF fnct|=18
set_template(16,"ARBO Error:________")
ELSE
set_template(16,"ARBO Guide:________")
ENDIF
set_edit(16,parametre$(6))    ! GUIDE PSEUDO ou ERREUR
ENDIF
set_template(19,"Ecrit VDT:  ________")
set_template(21,"Conf VDT:   ________")
'
l1&=VAL(parametre$(39))       ! Text/Vid‚otex
set_state(36,l1&,0,1)
set_state(37,1-l1&,0,1)
set_bout(19,40,3,1)           ! Infos s‚l‚ctionn‚es
l1&=VAL(parametre$(19))       ! Etat boutons
set_state(69,-BTST(l1&,6),0,1)
IF fnct|=18                   ! Page EDIT_REP
set_state(41,0,1,1)
set_state(42,0,1,1)
set_state(45,0,1,1)
set_state(81,0,1,1)
ELSE
set_state(45,-BTST(l1&,4),0,1)
set_state(81,-BTST(l1&,5),0,1)
ENDIF
'
editer_arbo_noyau(74)         ! FORM_DO etc...
'
IF b%=76
validation|=2
RESTORE ecriture_dat
extract_edits
IF fnct|=16                   ! ECRI_BAL
control_x(11)
control_y(12)
control(13,32,127)
control_y(14)
parametre$(6)=FN edit$(16)    ! Page de guide
ELSE
IF fnct|=11
parametre$(6)=FN edit$(4)     ! Rubrique
ELSE
parametre$(6)=FN edit$(16)    ! Page d'Erreur
ENDIF
FOR l1&=11 TO 14
parametre$(l1&)=""
NEXT l1&
ENDIF
IF fnct|=18                     ! EDIT_REP
FOR l1&=22 TO 27
parametre$(l1&)=""
parametre$(l1&+8)=""
NEXT l1&
parametre$(36)=""             ! Pas de titre
parametre$(44)=""
ELSE
control_x(22)
control_y(23)
control(24,1,3)
control_x(25)
control_y(26)
control(27,1,2)
control_x(30)
control_y(31)
control(32,1,2)
control_x(33)
control_y(34)
control(35,1,2)
control(36,1,21)              ! Titre X
control_y(44)                 ! Titre Y
ENDIF
control_x(20)
control_y(21)
control_x(28)
control_y(29)
control(37,1,24)
control(38,32,127)
IF fnct|=18
parametre$(3)=parametre$(81)
ELSE
parametre$(3)=LEFT$(parametre$(45)+SPACE$(8),8)+parametre$(81)
ENDIF
parametre$(10)=LEFT$(parametre$(42)+SPACE$(8),8)+LEFT$(parametre$(43)+SPACE$(8),8)+LEFT$(parametre$(44)+" ",2)
parametre$(39)=STR$(FN selected(36))
l1&=0
FOR l2&=0 TO 3
IF FN selected(40+l2&)
l1&=BSET(l1&,l2&)
ENDIF
NEXT l2&
IF FN selected(45)
l1&=BSET(l1&,4)
ENDIF
IF FN selected(81)
l1&=BSET(l1&,5)
ENDIF
IF FN selected(69)
l1&=BSET(l1&,6)
ENDIF
parametre$(19)=STR$(l1&)
ENDIF
RETURN
> PROCEDURE editarbo_editfiche
'
' Edit page EDT_FICH:
'
editfiche_dat:
DATA 4,4,5,0,20,5,21,6,22,7,23,8,24,9,26,11,28,42,29,43,30,44,0,0
'
adr%=editfiche.adr%
set_string(2,nom$)            ! Init NOM PAGE
parametre$(42)=TRIM$(LEFT$(parametre$(12),3))
parametre$(43)=TRIM$(MID$(parametre$(12),4,5))
parametre$(44)=TRIM$(RIGHT$(parametre$(12),5))
RESTORE editfiche_dat
set_edits
set_radio(VAL(LEFT$(parametre$(2))),33,3) ! Quelle fiche
set_bout(3,38,2,1)            ! Sortie vers
set_state(25,VAL(parametre$(10)),0,1) ! Envoi -> Validation ?
'
g1&=0                         ! Nø de case
g2&=0                         ! On est en train d'‚diter le champ 0
file$(0)="Num‚ro absolu"
file$(1)="Date de cr‚ation"
editfiche.reset               ! Fixe nøbase (g0&) et nom des champs
'
' gestion
'
editfiche.set
aes_draw
'
DEFMOUSE 0
REPEAT
b%=FORM_DO(adr%,g2&)
g2&=14               ! Champ en cours
edit_changed!=FALSE  ! On a pas modifi‚ pour l'instant...
editfiche.get        ! Sauve le champ en cours de la fiche
SELECT b%
CASE 4                        ! S‚lection d'une base
editfiche.selbase(adr%)
set_edit(4,parametre$(4))
set_state(4,0,0,1)
~OBJC_DRAW(adr%,4,1,x%,y%,w%,h%)
CASE 10                       ! Ascenseur
l1%=GRAF_SLIDEBOX(adr%,9,10,1) ! Gest slide
g1&=l1%/1001*27               ! Calcul obj en 1ere ligne
edit_changed!=TRUE          ! On a modifi‚!
CASE 7                        ! Mont‚e d'un cran
IF g1&>0                      ! Si pas en haut
DEC g1&                       ! Monte
edit_changed!=TRUE          ! On a modifi‚!
ENDIF
CASE 8                        ! Descente d'un cran
IF g1&<26                     ! Si pas en bas
INC g1&                       ! Descend
edit_changed!=TRUE          ! On a modifi‚!
ENDIF
CASE 9                        ! D‚place d'un cran
MOUSE void,l1&,void           ! Saisit coord Y
~OBJC_OFFSET(adr%,10,l3&,l2&)
IF l1&<l2&                    ! Mont‚e
DEC g1&                       ! Monte
ELSE                          ! Descente
INC g1&                       ! Descend
ENDIF
edit_changed!=TRUE          ! On a modifi‚!
CASE 41
edit_pagemem(adr%)
~OBJC_CHANGE(adr%,41,0,x%,y%,w%,h%,32,1)
CASE 42
edit_msgsys(adr%)
~OBJC_CHANGE(adr%,42,0,x%,y%,w%,h%,32,1)
ENDSELECT
IF edit_changed!
editfiche.set
~OBJC_DRAW(adr%,6,7,x%,y%,w%,h%)
ENDIF
UNTIL b%=>43
DEFMOUSE 2
'
aes_erase
'
IF b%=43
validation|=2
RESTORE editfiche_dat
extract_edits
control(42,32,127)
l1$=SPACE$(13)
MID$(l1$,1,3)=parametre$(42)
MID$(l1$,4,5)=parametre$(43)
MID$(l1$,9,5)=parametre$(44)
parametre$(12)=l1$              ! Fond et couleurs edit
parametre$(2)=STR$(FN get_radio(33,3))
get_bout(3,38,2)            ! Sortie vers ?
parametre$(10)=STR$(FN selected(25)) ! Envoi -> Validation ?
ENDIF
RETURN
> PROCEDURE editfiche.reset
'
' Trouve une base et sort les noms des champs:
'
find_base
IF g0&<nb_base&               ! Si la base existe
FOR l1&=2 TO 26
file$(l1&)=fiches_nom$(g0&,l1&-2)
NEXT l1&
ELSE                          ! Si base n'existe pas
FOR l1&=2 TO 26
file$(l1&)="Champ configurable Nø"+STR$(l1&-1)
NEXT l1&
ENDIF
RETURN
> PROCEDURE editfiche.set
set_edit(10,STR$(SUCC(g1&)))
fiche_champ                   ! Extrait les paramŠtres du champ concern‚
set_state(11,l1|,l3|,1)       ! Affichable?
set_state(12,l2|,l4|,1)       ! Editable?
set_string(13,file$(g1&))     ! Nom du champ
set_state(13,0,l3|,0)
set_edit(14,l2$)              ! X
set_state(14,0,l3|,0)
set_edit(15,l3$)              ! Y
set_state(15,0,l3|,0)
set_edit(16,l4$)              ! Lg
set_state(16,0,l4|,0)
set_edit(17,l5$)              ! Copy
set_state(17,0,l3|,0)
set_edit(18,l1$)              ! Defa
set_state(18,0,l4|,0)
OB_Y(adr%,10)=g1&*16*rez|/26
RETURN
> PROCEDURE editfiche.get
l1|=FN selected(11)           ! Afficher
l2|=FN selected(12)           ! Editable
l2%=FN get_value(14,1,40)     ! X
l3%=FN get_value(15,0,24)     ! Y
l4%=FN get_value(16,0,40)     ! Lg
l1$=FN edit$(17)              ! Copy
l2$=FN edit$(18)              ! D‚faut
parametre$(13+g1&)=STR$(l1|)+STR$(l2|)+STR$(l2%,2)+STR$(l3%,2)+STR$(l4%,2)+LEFT$(l1$+SPACE$(7),7)+l2$
RETURN
> PROCEDURE editfiche.selbase(p.adr%)
LOCAL adr%,x%,y%,w%,h%,b%
'
adr%=defarbo.adr%
set_edit(1,"Choix de la base … utiliser")
set_template(2,"Base    : ________")
set_edit(2,parametre$(4))     ! Init champ
affiche_rsc                   ! Affich boite de d‚f
~OBJC_DRAW(p.adr%,0,7,x%,y%,w%+2,h%+2)
IF b%=3
parametre$(4)=FN edit$(2)           ! Nom de la base
editfiche.reset
edit_changed!=TRUE                  ! On … modifi‚ la fenˆtre d'‚dition
ENDIF
RETURN
> PROCEDURE editarbo_fiche
'
' Edit page FICHE_ID:
'
fiche_dat:
DATA 17,1,18,2,19,3,20,35,21,4,23,5,24,6,25,7,0,0
'
adr%=fiche.adr%
set_string(2,nom$)            ! Init NOM PAGE
RESTORE fiche_dat
set_edits
set_state(5,0,-(fnct|=23),0)  ! Disable PSEU si F-ID
set_state(21,0,-(fnct|<>23),0) ! Disable ERREUR si pas F-ID
IF fnct|=23                   ! fiche identit‚
set_edit(3,"  Gestion de sa fiche d'identit‚ ")
set_edit(5,"")                ! Init PSEU
set_edit(6,parametre$(0))     ! Init PAGE VDT
ELSE                          ! Fiche connect‚
set_edit(3,"Consultation d'une fiche-connect‚")
set_edit(5,parametre$(0))     ! Init PSEU
set_edit(6,parametre$(28))    ! Init PAGE VDT
ENDIF
'
g1&=1                         ! Nø de case
g2&=0                         ! champ portant le curseur
g2%=VAL(parametre$(27))       ! Editables
g3%=VAL(parametre$(25))       ! selected
g4%=VAL(parametre$(26))       ! selected
b%=FALSE                      ! Pas encore d'action sur les boutons
REPEAT
'
' extractø parametres
'
SELECT g1&
CASE 1 TO 6
m1&=g1&+7                     ! nø paramŠtre
m2%=g3%                        ! param "selected"
m3&=PRED(g1&)
CASE 7 TO 16
m1&=g1&+8                     ! nø paramŠtre
m2%=g4%                       ! param "selected"
m3&=g1&-7
DEFAULT
m1&=g1&+12                    ! nø paramŠtre
m2%=g4%                       ! param "selected"
m3&=g1&-7
ENDSELECT
l1$=STR$(VAL(LEFT$(parametre$(m1&),2))) ! Coord X
l2$=STR$(VAL(MID$(parametre$(m1&),3,2))) ! Y
l3$=STR$(VAL(RIGHT$(parametre$(m1&),2))) ! Long
IF g1&<13                       ! Si pas de chmp lg
l3$=""
ENDIF
'
' fixe objets ds form
'
set_string(10,STR$(g1&))        ! Nø
set_state(10,-BTST(m2%,m3&),0,1)
set_string(12,fid.champ$(PRED(g1&))) ! Nom du champ
IF g1&<7                        ! si non ‚ditable
set_state(11,0,1,1)
ELSE
set_state(11,-BTST(g2%,m3&),0,1)
ENDIF
' changer nom du champ!
set_edit(13,l1$)
set_edit(14,l2$)
set_edit(15,l3$)
set_state(15,0,-(g1&<13),0)     ! Enable-Disable Lg
'
' affichage
'
IF b%=FALSE
aes_draw
DEFMOUSE 0
ELSE
~OBJC_DRAW(adr%,7,1,x%,y%,w%,h%)
ENDIF
'
' gestion
'
REPEAT
b%=FORM_DO(adr%,g2&)
SELECT b%
CASE 27
edit_pagemem(adr%)
~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,32,1)
CASE 28
edit_msgsys(adr%)
~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,32,1)
DEFAULT                                 ! S'il fo sauver les donn‚es
IF (b%=8 AND g1&=1) OR (b%=9 AND g1&=22)
b%=FALSE
ELSE
parametre$(42)=FN edit$(13)
parametre$(43)=FN edit$(14)
control_x(42)
control_y(43)
parametre$(m1&)=RIGHT$("0"+parametre$(42),2)+RIGHT$("0"+parametre$(43),2)
IF g1&>12
parametre$(44)=FN edit$(15)
control_x(44)
parametre$(m1&)=parametre$(m1&)+RIGHT$("0"+parametre$(44),2)
ENDIF
IF FN selected(10)        ! selected
m2%=BSET(m2%,m3&)
ELSE
m2%=BCLR(m2%,m3&)
ENDIF
IF g1&>6
IF @selected(11)          ! ‚ditable
g2%=BSET(g2%,m3&)
ELSE
g2%=BCLR(g2%,m3&)
ENDIF
ENDIF
IF g1&<7
g3%=m2%
ELSE
g4%=m2%
ENDIF
IF b%=8
DEC g1&
ELSE IF b%=9
INC g1&
ENDIF
g2&=13                        ! champ portant le curseur
ENDIF
ENDSELECT
UNTIL b%=8 OR b%=9 OR b%=>29
UNTIL b%=>29
aes_erase
DEFMOUSE 2
'
IF b%=29
validation|=2
parametre$(27)=STR$(g2%)      ! Editables
parametre$(25)=STR$(g3%)      ! Selected
parametre$(26)=STR$(g4%)      ! Selected
RESTORE fiche_dat
extract_edits
IF fnct|=23
parametre$(0)=FN edit$(6)
ELSE
parametre$(0)=FN edit$(5)
parametre$(28)=FN edit$(6)
parametre$(4)=""
ENDIF
control(5,32,127)
parametre$(14)=""           ! ‚limine r‚sidus de version 2.24
ENDIF
RETURN
> PROCEDURE editarbo_image
'
' Edit page START,IMAGE,TABL_CNX,EFFA_REP,EFFA_BAL:
'
image_dat:
DATA 4,0,6,39,7,39,10,1,11,2,12,3,13,4,14,5,15,6,16,7,17,8,18,39,19,9,20,20
DATA 22,10,23,11,24,12,25,13,26,14,27,15,28,16,29,17,30,18,31,19
DATA 33,21,34,22,35,23,36,24,37,25,38,26,39,27,40,28,41,29,42,30,0,0
DATA 10
efface_dat:
DATA 4,0,6,36,7,37,10,2,11,3,12,4,13,5,14,6,15,7,16,8,17,9,18,10,19,11,20,22
DATA 22,12,23,13,24,14,25,15,26,16,27,17,28,18,29,19,30,20,31,21
DATA 33,23,34,24,35,25,36,26,37,27,38,28,39,29,40,30,41,31,42,32,0,0
DATA 12
image_disable:
DATA 5,1,6,0,7,0,8,1,18,0
'
adr%=image.adr%
l1$=LEFT$(FN edit$(1),22)
SELECT fnct|
CASE 1,2
l1$=l1$+"Ecran simple avec gestion clavier"
CASE 8
l1$=l1$+"Tableau des derniŠres connexions "
CASE 17
l1$=l1$+"Destruction de sa boŒte … lettres"
CASE 21
l1$=l1$+"Destruction du r‚pondeur         "
CASE 22
l1$=l1$+"Effacement des messages en BAL   "
ENDSELECT
set_edit(1,l1$)
set_string(2,nom$)            ! Init NOM PAGE
'
IF fnct|=8                    ! Si fnct TABL_CNX
set_state(4,0,1,0)            ! Disable PAGE_VDT
parametre$(0)=""
ELSE
set_state(4,0,0,0)            ! Enable PAGE_VDT
ENDIF
'
RESTORE image_disable
IF fnct|=17 OR fnct|=22       ! EFFA_BAL, EFF_MSGB
FOR l1&=1 TO 3
READ l2&,l2|
set_state(l2&,0,1,l2|)        ! Disable
NEXT l1&
parametre$(36)=""
parametre$(37)=""
ELSE IF fnct|=21              ! EFFA_REP
FOR l1&=1 TO 5
READ l2&,l2|
set_state(l2&,0,0,l2|)        ! Enable
NEXT l1&
set_state(5,VAL(parametre$(33)),0,1)
ELSE                          ! START,IMAGE ou TABL_CNX
FOR l1&=1 TO 5
READ l2&,l2|
set_state(l2&,0,1,l2|)        ! Disable
NEXT l1&
parametre$(39)=""             ! Dummy
ENDIF
'
IF fnct|=1 OR fnct|=2 OR fnct|=8
set_state(19,VAL(parametre$(36)),0,1)
RESTORE image_dat
ELSE
set_state(8,VAL(parametre$(34)),0,1)
set_state(18,0,0,0)             ! Enable Erreur
set_state(19,VAL(parametre$(38)),0,1)
RESTORE efface_dat
ENDIF
set_edits
'
editer_arbo_noyau(44)         ! FORM_DO etc...
'
IF b%=46
validation|=2
IF fnct|=1 OR fnct|=2 OR fnct|=8
RESTORE image_dat
ELSE
RESTORE efface_dat
ENDIF
extract_edits
'
IF fnct|=8                    ! TABL_CNX
parametre$(0)=""
ENDIF
'
IF fnct|=1 OR fnct|=2 OR fnct|=8
parametre$(39)=""
parametre$(36)=STR$(FN selected(19))
control(9,0,999)
ELSE                          ! EFFA_BAL,EFF_BMSG,EFFA_REP
IF fnct|=21                   ! EFFA_REP
control_y(36)
parametre$(33)=STR$(FN selected(5))
ELSE
parametre$(36)=""
parametre$(37)=""
ENDIF
parametre$(34)=STR$(FN selected(8))
parametre$(38)=STR$(FN selected(19))
control(11,0,999)
ENDIF
'
READ l2|
FOR l1|=l2| TO l2|+9
IF parametre$(l1|)<>""
control(l1|,1,127)
ENDIF
NEXT l1|
ENDIF
RETURN
> PROCEDURE editarbo_journal
'
' Edit page JOURNAL:
'
journal_dat:
DATA 5,0,6,1,7,2,8,3,9,4,10,5,11,6,12,7,13,8,14,9,15,11,16,10,18,15,19,16
DATA 20,17,21,18,22,19,23,20,24,21,0,0
DATA 16,22,25,12,26,13,27,14,0,0
'
adr%=journal.adr%
set_string(2,nom$)            ! Init NOM PAGE
RESTORE journal_dat
set_edits
set_selecteds
set_state(19,0,-(fnct|=29),0)
set_state(22,0,-(fnct|=29),0)
'
editer_arbo_noyau(29)         ! FORM_DO etc...
'
IF b%=31
validation|=2
RESTORE journal_dat
extract_edits
IF fnct|=29                 ! Msg_guid
parametre$(16)=""
parametre$(19)=""
ENDIF
control(11,0,9)
control(10,0,999)
extract_selecteds
ENDIF
RETURN
> PROCEDURE editarbo_lecture
'
' Edit page LECT_RUB(10),LECT_BAL(15),TEXTE(37):
'
lecture_dat:
DATA 4,41,6,41,7,41,8,41,9,41,10,41,11,41,12,41,13,41,14,41,15,41,16,41
DATA 18,41,19,0,20,42,21,43,22,41,23,2,25,3,26,4,27,5,28,6,29,7,30,8,31,11,32,9
DATA 33,10,34,12,47,18,48,19,49,20,50,21,51,22,52,23,53,24,54,25,55,26,56,27
DATA 57,28,58,29,59,30,60,31,61,32,62,33,63,34,64,35,65,13,66,36,67,38,68,37
DATA 70,41,71,14,72,15,0,0
'
adr%=ecrilir.adr%
set_string(2,nom$)            ! Init NOM PAGE
SELECT fnct|
CASE 10
set_edit(3," Lecture des messages en rubrique:")
CASE 15
set_edit(3,"Lecture des messages en BAL       ")
CASE 37
set_edit(3,"           Lecture du texte ASCII:")
ENDSELECT
'
' Settings g‚n‚raux pour la lecture
set_string(36,"2>Suit>1")
set_string(37,"1>Suit>2")
'
RESTORE ecrilir_dat
SELECT fnct|
CASE 10
m1&=4
CASE 15
m1&=3
CASE 37
m1&=5
ENDSELECT
enable_ecrilir
'
set_state(69,0,1,1)
'
parametre$(42)=TRIM$(LEFT$(parametre$(39),8)) ! Pg sui VDT
parametre$(43)=TRIM$(RIGHT$(parametre$(39),8)) ! Msg sui VDT
RESTORE lecture_dat
set_edits
SELECT fnct|
CASE 10,37
set_edit(4,parametre$(1))     ! Rubrique/texte
CASE 15
set_template(16,"ARBO Error:________")
set_edit(16,parametre$(1))    ! Page ERREUR
ENDSELECT
set_template(19,"Lect VDT:   ________")
set_template(21,"Msg sui VDT:________")
'
IF fnct|=37
set_state(36,0,1,1)
set_state(37,0,1,1)
ELSE
l1&=VAL(parametre$(16))       ! 1>2 ou 1<2
set_state(36,l1&,0,1)
set_state(37,1-l1&,0,1)
ENDIF
'
set_bout(17,40,6,1)           ! Infos s‚l‚ctionn‚es
IF fnct|=15 OR fnct|=37
set_state(43,0,1,1)           ! Pas de r‚ponses
set_state(44,0,1,1)
ENDIF
IF fnct|=37
set_state(40,0,1,1)
set_state(45,0,1,1)
ENDIF
'
'
editer_arbo_noyau(74)         ! FORM_DO etc...
'
'
IF b%=76
validation|=2
RESTORE lecture_dat
extract_edits
'
parametre$(16)=STR$(FN selected(36)) ! Ext gest SUIT/RET
control_x(18)
control_y(19)
control_x(20)
control_y(21)
control(22,1,3)
control_x(23)
control_y(24)
control(25,1,2)
control_x(30)
control_y(31)
control(32,1,2)
control_x(33)
control_y(34)
control(35,1,2)
control(36,1,21)
control(37,1,24)
control_y(38)
parametre$(39)=LEFT$(parametre$(42)+SPACE$(8),8)+LEFT$(parametre$(43)+SPACE$(8),8)
get_bout(17,40,6)
'
SELECT fnct|
CASE 10                       ! LECT_RUB
parametre$(1)=FN edit$(4)     ! Rubrique
control_x(26)
control_y(27)
control_x(28)
control_y(29)
control(15,1,nbm_rub_max&)
CASE 15                       ! LECT_BAL
parametre$(1)=FN edit$(16)    ! Page d'Erreur
parametre$(5)=""
parametre$(6)=""
parametre$(9)=""
parametre$(10)=""
parametre$(12)=""
FOR l1&=26 TO 29
parametre$(l1&)=""
NEXT l1&
control(15,1,20)
CASE 37                       ! TEXTE
parametre$(1)=FN edit$(4)     ! texte
FOR l1&=5 TO 8
parametre$(l1&)=""
NEXT l1&
parametre$(9)=""
parametre$(10)=""
parametre$(12)=""
parametre$(18)=""
parametre$(19)=""
FOR l1&=26 TO 32
parametre$(l1&)=""
NEXT l1&
parametre$(15)=""
ENDSELECT
ENDIF
RETURN
> PROCEDURE editarbo_liste
'
' Edit page RUB_LIST(12),BALS_ANN(14),LIST_ENV(19),LIST_REC(20):
'
lis_dat:
DATA 4,1,5,0,34,2,35,3,36,4,37,5,38,6,8,19,9,20,10,21,11,22,12,10,16,23,17,24
DATA 19,12,20,7,22,13,23,8,25,14,26,9,27,15,28,18,29,17,30,16,0,0
DATA 31,25,32,26,0,0
DATA 21,24,7,14,15
'
adr%=liste.adr%
SELECT fnct|
CASE 12
l1$="Liste des messages en rubrique:"
CASE 14
l1$="Annuaire des boŒtes … lettres  "
CASE 19
l1$="Liste des msgs envoy‚s en BAL  "
CASE 20
l1$="Liste des msgs re‡us en BAL    "
ENDSELECT
set_edit(3,l1$)
set_string(2,nom$)            ! Init NOM PAGE
RESTORE lis_dat
set_edits
set_selecteds
IF fnct|=12                   ! Si fnct LIST_RUB
set_state(4,0,0,0)            ! Enable RUB
ELSE                          ! Si fnct BALS_ANN,LIST_ENV ou LIST_REC
set_state(4,0,1,0)            ! Disable RUB
ENDIF
set_state(38,0,-(fnct|<>20),0) ! Page ERREUR
set_state(37,0,-(fnct|=19),0) ! Lect/Ecrit
set_state(26,0,-(fnct|=14),0) ! Att X2
set_state(16,0,-(fnct|<>14),0) ! Pr‚fixe
set_state(17,0,-(fnct|<>14),0) ! Pr‚fixe
l1&=VAL(parametre$(11))       ! Etat boutons
FOR l1|=0 TO 4                ! Init
READ l2|
IF fnct|=14 OR l1|<4
set_state(l2|,-BTST(l1&,l1|),0,1)
ELSE
set_state(l2|,0,1,1)
ENDIF
NEXT l1|
IF fnct|=14
set_state(31,0,1,1)
set_state(32,0,1,1)
ENDIF
'
editer_arbo_noyau(40)         ! FORM_DO etc...
'
IF b%=42
validation|=2
RESTORE lis_dat
extract_edits
extract_selecteds
IF fnct|=14                   ! Fnct BALS_ANN
parametre$(9)=""
ELSE IF fnct|=19              ! Fnct ENV_LIST
parametre$(5)=""
ENDIF
IF fnct|<>20
parametre$(6)=""
ENDIF
l1&=0
FOR l1|=0 TO 4                ! Init
READ l2|
IF @selected(l2|)
l1&=BSET(l1&,l1|)
ENDIF
NEXT l1|
parametre$(11)=STR$(l1&)
control_x(12)
control_x(13)
control_x(14)
control_y(15)
control(16,1,24)
control(17,1,9)
IF fnct|=14
control(18,1,2)
ELSE IF fnct|=12              ! Liste de msgs en rub
IF parametre$(18)<>"D"
control(18,1,nbm_rub_max&)
ENDIF
ELSE
control(18,1,20)
ENDIF
control_x(19)
control_y(20)
control_x(21)
control(22,32,127)
IF fnct|<>14
parametre$(23)=""
parametre$(24)=""
ENDIF
ENDIF
RETURN
> PROCEDURE editarbo_menu
'
' Edit page MENU:
'
adr%=clef.adr%
set_string(2,nom$)            ! Init NOM PAGE
set_edit(3,parametre$(0))     ! Init PAGE VDT
set_state(12,VAL(parametre$(37)),0,1)
FOR l1|=1 TO 9
set_edit(4+l1|,parametre$(l1|))
NEXT l1|
set_state(36,VAL(parametre$(38)),0,1)
set_state(37,VAL(parametre$(39)),0,1)
FOR l1|=10 TO 29
set_edit(5+l1|,parametre$(l1|))
NEXT l1|
set_state(39,VAL(parametre$(30)),0,1)
FOR l1|=31 TO 36
set_edit(9+l1|,parametre$(l1|))
NEXT l1|
'
editer_arbo_noyau(47)         ! FORM_DO etc...
'
IF b%=49
validation|=2
parametre$(0)=FN edit$(3)
parametre$(37)=STR$(FN selected(12))
FOR l1|=1 TO 9
parametre$(l1|)=FN edit$(4+l1|)
NEXT l1|
parametre$(38)=STR$(FN selected(36))
parametre$(39)=STR$(FN selected(37))
FOR l1|=10 TO 29
parametre$(l1|)=UPPER$(FN edit$(5+l1|))   ! UPPER$ pour les mots clefs
NEXT l1|
control(8,0,999)
parametre$(30)=STR$(FN selected(39))
FOR l1|=31 TO 36
parametre$(l1|)=FN edit$(9+l1|)
NEXT l1|
control_x(31)
control_y(32)
control_x(33)
control(34,32,127)
control(35,32,127)
ENDIF
RETURN
> PROCEDURE editarbo_module
'
' Edit page MODULE:
'
module_dat:
DATA 13,0,14,1,16,5,17,6,18,7,19,8,20,9,21,10,22,11,23,12,24,13,28,15,30,16
DATA 33,18,35,19,37,20,39,21,40,22,0,0
beta_mod_dat:
DATA 13,0,14,41,16,41,17,41,18,41,19,41,20,41,21,41,22,41,23,41,24,13
DATA 28,41,30,41,33,41,35,41,37,41,39,41,40,41,0,0
mod_disable_dat:
DATA 12,1,14,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,28,0,30,0
DATA 32,1,33,0,34,1,35,0,36,0,37,0,38,0,39,0,40,0,0,0
module_noyau:
DATA 7,8,0,0,0,3,4,0,0,0,1,0,0,0,0,9,10,0,0,0
'
adr%=module.adr%
set_string(3,nom$)            ! Init NOM PAGE
set_string(5,g2$)             ! Init FNCT
IF LEN(parametre$(3))<3       ! Adapataion sommaire du path
parametre$(3)=chemin$(3)
ENDIF
set_edit(9,parametre$(3))
IF LEN(parametre$(4))<3       ! Adapataion sommaire du path
parametre$(4)=chemin$(3)
ENDIF
set_edit(10,parametre$(4))
'
RESTORE mod_disable_dat
l1&=-(fnct|=33)              ! 1 s'il faut "disable"
DO
READ l2&,l3&
EXIT IF l2&=FALSE
set_state(l2&,0,l1&,l3&)
LOOP
'
l1|=VAL(parametre$(14))       ! Init Nø SYS
set_state(27,l1|,0,1)
set_state(29,1-l1|,0,1)
IF fnct|=33
set_string(27,"Direct")
set_string(29,"Longueur")
RESTORE beta_mod_dat
ELSE
set_string(27,"Nø Sys:")
set_string(29,"Lvl Pos:")
set_state(12,VAL(parametre$(2)),0,1) ! Selected
l1|=VAL(parametre$(17))       ! Init NIV TEL
set_state(32,l1|,0,1)
set_state(34,1-l1|,0,1)
RESTORE module_dat
ENDIF
set_edits
'
RESTORE module_noyau
editarbo_noyau(61,44,42)
'
IF b%=44
validation|=2
parametre$(14)=STR$(FN selected(27)) ! Choix Nø SYS
IF fnct|=33                   ! BETA_MOD
RESTORE beta_mod_dat
extract_edits
ELSE                          ! NEDER
RESTORE module_dat
extract_edits
control(15,0,9)
control(16,0,9)
control(18,0,9)
control(19,0,9)
control(22,0,9999999)
parametre$(20)=FN edit$(37)
parametre$(21)=FN edit$(39)
parametre$(2)=STR$(FN selected(12)) ! Valid PAGE TRANS
parametre$(17)=STR$(FN selected(32)) ! Choix NIV TEL
ENDIF
ENDIF
RETURN
> PROCEDURE editarbo_pseudo
'
' Edit page PSEUDO(6),CREE_BAL(13):
'
pseudo_dat:
DATA 5,0,6,1,7,2,9,3,10,4,11,6,12,5,13,7,14,9,15,21,16,8,17,10
DATA 19,13,20,14,21,15,23,16,24,24,25,17,26,18,27,19,29,20,30,25
DATA 32,41,33,41,34,41,36,41,37,41,39,41,0,0
DATA 22,11,28,12,0,0
cree_bal_dat:
DATA 5,0,6,20,7,21,9,1,10,2,11,22,12,23,13,3,14,4,15,41,16,41,17,5,19,6,20,7,21,8,23,28
DATA 24,24,25,9,26,10,27,11,29,12,30,25,32,13,33,14,34,15,36,16,37,26,39,30,0,0
DATA 22,27,28,17,31,18,35,19,0,0
pseu_enable_dat:
DATA 15,&X01,16,&X01,32,&X10,33,&X10,34,&X10,36,&X10,37,&X10,39,&X10,0,0
'
adr%=pseudo.adr%
set_string(2,nom$)            ! Init NOM PAGE
IF fnct|=6                    ! Page PSEUDO
set_edit(3,"Demande de pseudo")
RESTORE pseudo_dat
m1&=0
set_state(31,0,1,1)
set_state(35,0,1,1)
set_template(6,"Code VDT:  ________")
set_template(7,"Retry VDT: ________")
set_template(14,"ARBO Msg:    ________")
ELSE                          ! Page CREE_BAL
set_edit(3," Cr‚ation de BAL ")
RESTORE cree_bal_dat
m1&=1
set_template(6,"Code 1 VDT:________")
set_template(7,"Code 2 VDT:________")
set_template(14,"ARBO Cr‚atø: ________")
IF parametre$(30)=""
parametre$(30)="B000000000"               ! Levels aprŠs cr‚ation
ENDIF
ENDIF
set_edits
set_selecteds
RESTORE pseu_enable_dat
enable_ecrilir                ! Enable/disable certains champs
'
editer_arbo_noyau(41)         ! FORM_DO etc...
'
IF b%=43
validation|=2
IF fnct|=6                    ! PSEUDO
RESTORE pseudo_dat
ELSE                          ! CREE_BAL
RESTORE cree_bal_dat
ENDIF
extract_edits
extract_selecteds
IF fnct|=6
control_x(13)
control_y(14)
control(15,32,127)
control(16,32,127)
control_x(17)
control_y(18)
control(19,32,127)
control(20,32,127)
ELSE
control_x(6)
control_y(7)
control(8,32,127)
control(28,32,127)
control_x(9)
control_y(10)
control(11,32,127)
control(12,32,127)
control_x(13)
control_y(14)
control(15,32,127)
control(16,32,127)
ENDIF
ENDIF
RETURN
> PROCEDURE editarbo_stop
'
' Edit page STOP(3), FIN(31), SHELL(36) :
'
adr%=stop.adr%
set_string(2,nom$)            ! Init NOM PAGE
IF fnct|=3
set_edit(3,"   D‚connexion")
ELSE IF fnct|=31
set_edit(3,"Fin de session")
ELSE
set_edit(3,"Shell commande")
parametre$(0)=""
ENDIF
set_state(4,0,-(fnct|=36),1)  ! Disabled si SHELL
set_edit(4,parametre$(0))     ! Init PAGE VDT
set_state(5,0,-(fnct|=3),1)   ! Disabled si STOP
set_edit(5,parametre$(2))     ! Page suivante
'
editer_arbo_noyau(7)          ! FORM_DO etc...
'
IF b%=9
validation|=2
IF fnct|<>36                  ! Si pas SHELL
parametre$(0)=FN edit$(4)
ENDIF
IF fnct|<>3                   ! Si pas STOP
parametre$(2)=FN edit$(5)
ENDIF
ENDIF
RETURN
> PROCEDURE editarbo_telechar
LOCAL obj&
'
' Edit page TELECHAR:
'
telechar_dat:
DATA 7,0,8,1,9,2,10,3,11,4,12,5,13,6,15,7,16,8,17,9,40,12,22,19,23,18,24,27
DATA 26,20,27,28,28,21,29,22,30,29,32,30,34,24,35,23,36,26,37,25,38,31,0,0
DATA 18,10,41,13,42,16,33,15,0,0
DATA 21,25,31,19
telechar_noyau:
DATA 4,0,0,0,0,32,0,0,0,0,0,0,0,0,0,5,0,0,0,0
'
adr%=telechar.adr%
set_string(3,nom$)            ! Init NOM PAGE
IF LEN(parametre$(32))<3
parametre$(32)=chemin$(3)
ENDIF
set_edit(5,parametre$(32))
'
RESTORE telechar_dat
set_edits
set_selecteds
FOR l1&=0 TO 3
READ obj&
set_state(obj&,-BTST(VAL(parametre$(17)),l1&),0,1)
NEXT l1&
'
RESTORE telechar_noyau
editarbo_noyau(59,46,44)
'
IF b%=46
validation|=2
RESTORE telechar_dat
extract_edits
control_x(18)
control_y(19)
control(20,1,23)
control(21,1,24)
control(22,1,24)
control_x(23)
control_y(24)
control_x(25)
control(26,32,127)
extract_selecteds
m1&=0
FOR l1&=0 TO 3
READ obj&
IF FN selected(obj&)
m1&=BSET(m1&,l1&)
ENDIF
NEXT l1&
parametre$(17)=STR$(m1&)
ENDIF
RETURN
> PROCEDURE editarbo_tel_inv
'
' Edit page TEL_INV:
'
tel_inv_dat:
DATA 7,0,8,1,10,3,11,4,13,5,0,0
tel_inv_noyau:
DATA 4,0,0,0,0,6,0,0,0,0,0,0,0,0,0,5,0,0,0,0
'
adr%=tel_inv.adr%
set_string(3,nom$)            ! Init NOM PAGE
IF LEN(parametre$(6))<3       ! Adapataion sommaire du path
parametre$(6)=chemin$(3)
ENDIF
set_edit(5,parametre$(6))
RESTORE tel_inv_dat
set_edits
set_state(14,VAL(parametre$(9)),0,1)
'
RESTORE tel_inv_noyau
editarbo_noyau(50,18,16)
'
IF b%=18
validation|=2
RESTORE tel_inv_dat
extract_edits
parametre$(9)=STR$(FN selected(14))
ENDIF
RETURN
> PROCEDURE editarbo_transit
'
' Edit page TRANSIT:
'
transit_dat:
DATA 4,0,5,1,6,2,7,3,8,4,9,5,10,6,11,7,12,8,13,13,0,0
'
adr%=transit.adr%
set_string(2,nom$)            ! Init NOM PAGE
'
'
RESTORE transit_dat
set_edits
'
editer_arbo_noyau(15)         ! FORM_DO etc...
'
IF b%=17
validation|=2
RESTORE transit_dat
extract_edits
ENDIF
RETURN
> PROCEDURE editer_altern
POKE select_valid%,ASC("p")           ! Sp‚cial pour page alternative
editer_page(5,altern$,nbp_alt_max&,nbn_alt&,nbp_alt&,nom_alt$(),info_alt|(),alpha_alt$(),first_alt&)
POKE select_valid%,ASC("f")
RETURN
> PROCEDURE editer_arbo
editer_page(2,arbo$,nbp_arbo_max&,nbn_arbo&,nbp_arbo&,nom_arbo$(),info_arbo|(),alpha_arbo$(),first_arbo&)
RETURN
> PROCEDURE editer_arbo_noyau(p.obj&)
LOCAL l.obj1&,l.exobj&
l.obj1&=SUCC(p.obj&)
l.exobj&=p.obj&+2
'
aes_draw
DEFMOUSE 0
DO
b%=FORM_DO(adr%,0)
EXIT IF b%=>l.exobj&
SELECT b%
CASE p.obj&
edit_pagemem(adr%)
CASE l.obj1&
edit_msgsys(adr%)
ENDSELECT
~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,32,1)
LOOP
DEFMOUSE 2
aes_erase
RETURN
> PROCEDURE editer_aff
editer_page(4,aff$,nb_aff_max&,nbn_aff&,nb_aff&,nom_aff$(),info_aff|(),alpha_aff$(),first_aff&)
RETURN
> PROCEDURE editer_base
editer_page(6,base$,nb_base_max&,nbn_base&,nb_base&,nom_base$(),info_base|(),alpha_base$(),first_base&)
RETURN
> PROCEDURE editer_infos(p.fich$,p.info$)
LOCAL validation|
'
' Edit infos t‚l‚chargement:
'
DEFMOUSE 2
IF EXIST(p.fich$)             ! Si des infos existent d‚ja
OPEN "I",#1,p.fich$
RECALL #1,editor$(),39,nbl%   ! Charge infos
CLOSE #1
FOR l1|=0 TO nbl%
editor$(l1|)=editor$(l1|)+" "
NEXT l1|
ELSE                          ! Si pas encore d'infos
editor$(0)=" "
nbl%=0
ENDIF
'
w_name$=p.fich$+CHR$(0)
w_info$=p.info$               ! Info sera print‚e
window_edit(2,39,FALSE,19,38) ! Edit du texte
'
IF validation|=2      ! Si valid‚
m1|=0                         ! Nø de la 1Šre ligne vide
FOR l1|=0 TO nbl%
l1$=editor$(l1|)
l2|=LEN(TRIM$(l1$))
IF l2|
m1|=SUCC(l1|)
l3|=PRED(INSTR(l1$," ",SUCC(l2|)))
ELSE
CLR l3|
ENDIF
editor$(l1|)=LEFT$(l1$,l3|)
NEXT l1|
IF g6!=FALSE                    ! S'il n'y a pas de fichier \INFOS\
l1|=PRED(RINSTR(p.fich$,"\"))
MKDIR LEFT$(p.fich$,l1|)        ! On cr‚e le dossier
g6!=TRUE                        ! Dossier existe
ENDIF
OPEN "O",#1,p.fich$             ! Ouvre le fichier infos
STORE #1,editor$(),m1|          ! Sauve les infos
CLOSE #1
ENDIF
libere_texte                  ! LibŠre ram text
DEFMOUSE 0
RETURN
> PROCEDURE editer_mots
LOCAL validation|
'
' Edit mots clef:
'
s_title$="Edition des mots clef"
titre(s_title$)
DEFMOUSE 2
nbl%=nb_mots&
CLR l1|
IF nbl%
FOR l1|=0 TO PRED(nbl%)       ! Parcourt tous les mots
l1$=SPACE$(mc_long&)          ! x car pour mc
LSET l1$=mot$(l1|)            ! Inscrit mc
l2$=page$(l1|)
l3$=LEFT$(l2$,8)              ! Page arbo
IF LEN(l2$)>8                 ! S'il y a paramŠtres
l1$=l1$+" "+l3$+" Ý"+MID$(l2$,9,1)+":"+MID$(l2$,10)
ELSE                          ! Si pas de paramŠtres
l1$=l1$+" "+TRIM$(l3$)
ENDIF
editor$(l1|)=l1$+" "
NEXT l1|
editor$(l1|)=" "
ELSE
editor$(0)=" "
ENDIF
l1&=mc_long&+21
'
w_name$="Mot.Clef Page.Arbo ParamŠtre"+CHR$(0)
w_info$=""                    ! Ifo sera print‚e
window_edit(1,nb_mc_max&,FALSE,38-l1&\2,l1&) ! Edition des mc
'
IF validation|=2              ! Si on a valid‚
IF nbl%                       ! S'il y a des mc
SSORT editor$() WITH sort|(),nbl% ! On trie
FOR l1|=0 TO PRED(nbl%)       ! On parcourt les mc
l1$=editor$(l1|)              ! Extract ligne
mot$(l1|)=TRIM$(LEFT$(l1$,mc_long&))   ! Extract mot
l2$=MID$(l1$,mc_long&+2,8) ! Extract page
IF MID$(l1$,mc_long&+11,1)="Ý"
l2$=l2$+MID$(l1$,mc_long&+12,1)+TRIM$(MID$(l1$,mc_long&+14))
ENDIF
page$(l1|)=l2$
NEXT l1|
ENDIF
nb_mots&=nbl%                 ! M‚mo nb mc
enable_maj(9)                 ! Autorise mise … jour des mots clefs!
ENDIF
libere_texte                  ! LibŠre RAM text
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE editer_msgs
LOCAL validation|
'
' Edit messages systŠme:
'
s_title$="Edition des messages systŠme"
titre(s_title$)
DEFMOUSE 2
nbl%=nb_msgsys&
CLR l1|,l2|
l1&=msgsys_long&+13
IF nbl%
FOR l1|=0 TO PRED(nbl%)       ! Parcourt tous les msgs
editor$(l1|)=LEFT$(msgsys$(l1|),l1&)+" "
NEXT l1|
editor$(l1|)=" "
ELSE
editor$(0)=" "
ENDIF
'
w_name$="No Page.Vdt Message"+CHR$(0)
w_info$=""                    ! Info sera print‚e
window_edit(3,nb_msgsys_max&,FALSE,38-l1&\2,l1&)  ! Edition des msgs sys
'
IF validation|=2              ! Si on a valid‚
IF nbl%                       ! S'il y a des mc
SSORT editor$() WITH sort|(),nbl% ! On trie
FOR l1|=0 TO PRED(nbl%)       ! On parcourt les ms
msgsys$(l1|)=TRIM$(editor$(l1|))       ! Extract ligne
NEXT l1|
ENDIF
nb_msgsys&=nbl%               ! M‚mo nb ms
enable_maj(8)
ENDIF
libere_texte                  ! LibŠre RAM text
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE editer_page(type&,VAR def_nom$,max&,nbn&,nbp&,nom$(),info|(),alpha$(),first_obj&)
LOCAL no_page&,mode&,nom$,type$
LOCAL validation|
'
' Edit page VDT/ARBO/ALTERN , param RUB,AFF,BASE:
'
IF type&<3 OR type&=5
s_title$="Edition d'une "+tpage$(type&)
type$=" page"
ELSE
s_title$="ParamŠtrage d'une "+tpage$(type&)
SELECT type&
CASE 3
type$=" rubrique"
CASE 4
type$=" affiche"
CASE 6
type$=" base"
ENDSELECT
ENDIF
titre(s_title$)
'
edit:
mode&=FALSE
REPEAT
DEFMOUSE 0
select(s_title$,def_nom$,nbn&)
DEFMOUSE 2
IF b%=28                      ! [ANNULER]
GOTO fin_edit
ENDIF
nom$=FN edit$(26)
IF type&=5                    ! Si page altern
IF LEN(nom$)=FALSE
nom$="\SANSNOM"
ELSE IF LEFT$(nom$)<>"\"
IF LEN(nom$)<8
nom$="\"+nom$
ELSE
ALERT 3,"Le nom d'une page|alternative doit|toujours commencer|par un backslash(\)!",1,"   OK   ",void
GOTO edit
ENDIF
ENDIF
ELSE IF LEN(nom$)=FALSE       ! Sinon, si pas de nom de page
nom$="SANS_NOM"
ENDIF
no_page&=FN find_page(nom$,nbp&,nom$()) ! Nø page
IF no_page&<0
l1!=FN free_page(max&,type$,nbn&,nbp&)
ELSE
l1!=TRUE
ENDIF
UNTIL l1!
def_nom$=nom$
'
' D‚codage:
'
editor$(0)=" "
nbl%=FALSE                    ! 0 lignes par d‚f
IF no_page&=>0                ! Si page ‚xist
IF info|(no_page&)=2          ! Si page ‚ffac‚e
ALERT 3,"Cette"+type$+" … ‚t‚ ‚ffac‚e !|1: Reprendre"+type$+"|2: Nouvelle"+type$+"|3: Annuler la demande",2," 1 | 2 | 3 ",mode&
IF mode&=3
GOTO edit
ELSE IF mode&=2
GOTO new_page
ENDIF
ENDIF
SELECT type&
CASE 1
'
' D‚cod VDT
'
IF LEN(page_vdt$(no_page&))
@decode_vdt(page_vdt$(no_page&),0,PRED(nbl_max&))
ENDIF
CASE 2
'
' D‚cod ARBO
'
l1$=page_arbo$(no_page&)
fnct|=VAL(LEFT$(l1$,2))       ! D‚compacte page
fnct(fnct|)                   ! Extract fnct
l1&=INSTR(l1$,CHR$(0))
IF l1&>0
l1$=MID$(l1$,l1&+1)
ELSE
l1$=""
ENDIF
@decode_page_arbo             ! Extract params
CASE 3
'
' D‚cod RUB
'
FOR l1|=0 TO 4
parametre$(l1|)=STR$(param_rub|(no_page&,l1|))
NEXT l1|
CASE 4
'
' D‚cod AFF
'
FOR l1|=0 TO 2
parametre$(l1|)=STR$(param_aff|(no_page&,l1|))
NEXT l1|
CASE 5
'
' D‚cod ALTERNATE
'
l1$=page_alt$(no_page&)
@decode_alt
CASE 6
'
' D‚cod BASE
'
FOR l1&=0 TO 24
parametre$(l1&)=fiches_nom$(no_page&,l1&)   ! Copie noms
FOR l2&=0 TO 2            ! Copie paramŠtres pour chaque fiche
fiches_param&(last_base&,l1&,l2&)=fiches_param&(no_page&,l1&,l2&)
NEXT l2&
NEXT l1&
FOR l1&=0 TO 2            ! Copie paramŠtres g‚n‚raux
base_param%(last_base&,l1&)=base_param%(no_page&,l1&)
NEXT l1&
nb_fiches_base&=nb_fiches_base&(no_page&)
ENDSELECT
ELSE                          ! Page n'existant pas
new_page:                     ! ><= Page ‚ffac‚e=>nlle page
SELECT type&
CASE 2
'
' New ARBO
'
adr%=defarbo.adr%
set_edit(1,"D‚finition d'une page arborescence")
set_template(2,"Fonction: ________")
set_edit(2,"")                ! Init FNCT
CLR fnct|
DO                            ! D‚finition fnct page:
affiche_rsc                   ! Affich boite de d‚f
DEFMOUSE 2
IF b%=4                       ! [ANNULER]
GOTO edit
ENDIF
g2$=FN edit$(2)               ! Fnct
RESTORE fnct_arbo
FOR fnct|=1 TO 37             ! Cherche nø fonction
READ l1$
EXIT IF l1$=g2$               ! Si fnct trouv‚e
NEXT fnct|
EXIT IF fnct|<38 AND l1$<>"³"   ! Si fnct introuv‚e ou invalide
ALERT 3,"La fonction: "+g2$+"|n'est pas reconnue|par Stut One "+version$+".|Veuillez modifier.",1,"   OK   ",l1&
fnct_arbo:
DATA START,IMAGE,STOP,DIALOGUE,TELECHAR,PSEUDO,MENU,TABL_CNX
DATA TEL_INV,LECT_RUB,ECRI_RUB,LIST_RUB,CREE_BAL,BALS_ANN,LECT_BAL
DATA ECRI_BAL,EFFA_BAL,EDIT_REP,LIST_ENV,LIST_REC,EFFA_REP
DATA EFF_MSGB,FICHE_ID,INFO_CNT,JOURNAL,³,³,AFFICHE,MSG_GUID
DATA NEDER,FIN,ACCES,BETA_MOD,EDT_FICH,TRANSIT,SHELL,TEXTE
LOOP
parametre$(0)=nom$            ! Nom page
FOR l1|=1 TO 80               ! Init param
parametre$(l1|)=""
NEXT l1|
CASE 3
'
' Nlle RUB
'
parametre$(0)="30"            ! Nb msg/rub
parametre$(1)="5"             ! Nb pag/msg
parametre$(2)="15"            ! Nb l/pag
parametre$(3)="1"             ! Titre?
parametre$(4)="0"
CASE 4
'
' Nlle aff
'
parametre$(0)="23"            ! Nbl max
parametre$(1)="1"             ! 80 col
parametre$(2)="0"             ! Nbl existantes
CASE 5
'
' New Alternate
'
altern_mode&=0
altern_level&=0
l1&=10
FOR l3&=0 TO 17
alternative$(l3&)=""
NEXT l3&
CASE 6
'
' New Base
'
FOR l1&=0 TO 24
parametre$(l1&)="Champ Nø"+STR$(SUCC(l1&)) ! Nom
fiches_param&(last_base&,l1&,0)=0       ! Non valid‚
fiches_param&(last_base&,l1&,1)=20      ! Longueur max
fiches_param&(last_base&,l1&,0)=0       ! Type: Libre
NEXT l1&
base_param%(last_base&,0)=nbf_base_max%   ! Nb fiches maxi
base_param%(last_base&,1)=0               ! Stockage ds fichier
base_param%(last_base&,2)=0               ! AccŠs s‚quentiel
nb_fiches_base&=0         ! Aucune fiche dans la base
ENDSELECT
ENDIF
'
' Edition:
'
validation|=1                 ! Par d‚faut, on ne valide pas
SELECT type&
CASE 1
'
' Edit VDT
'
w_name$=nom$+".VDT"+CHR$(0)
w_info$=""                  ! Info ser aprint‚e
window_edit(0,nbl_max&,TRUE,12,52)  ! Edition de la page
'
CASE 2
'
' Edit ARBO
'
'    g1$=nom$                      ! Pour les PRO editarbo_xxx
SELECT fnct|
CASE 1,2,8,17,21,22           ! START,IMAGE,TABL_CNX,EFFA_BAL,EFFA_REP,EFF_MSGB
editarbo_image
CASE 3,31                     ! STOP,FIN
editarbo_stop
CASE 4                        ! DIALOGUE
editarbo_dialogue
CASE 5                        ! TELECHAR
editarbo_telechar
CASE 6                        ! PSEUDO
editarbo_pseudo
CASE 7                        ! MENU
editarbo_menu
CASE 9                        ! TEL_INV
editarbo_tel_inv
CASE 10,15,37                 ! LECT_RUB,LECT_BAL,TEXTE
editarbo_lecture
CASE 12,14,19,20              ! LIST_RUB,BALS_ANN,LIST_ENV ou LIST_REC
editarbo_liste
CASE 13                       ! CREE_BAL
editarbo_pseudo
CASE 11,16,18                 ! ECRI_RUB,ECRI_BAL ou EDIT_REP
editarbo_ecriture
CASE 23,24                    ! FICHE_ID et INFO_CNT
editarbo_fiche
CASE 25,29                    ! JOURNAL
editarbo_journal
'
' 26:RACER supprim‚e depuis v2.30
' 27:SCORES supprim‚e depuis v2.30
'
CASE 28                       ! AFFICHE
editarbo_aff
CASE 30                       ! NEDER
editarbo_module
CASE 32                       ! ACCES
editarbo_acces
CASE 33                       ! BETA_MOD
editarbo_module
CASE 34                       ! EDT_FICH
editarbo_editfiche
CASE 35                       ! TRANSIT
editarbo_transit
CASE 36                       ! SHELL
editarbo_stop
DEFAULT
ALERT 3,"Cette page arbo|(Fonction: "+STR$(fnct|)+")|n'est pas reconnue|par Stut One "+version$+"!",1,"   OK   ",l1&
g1|=1                         ! Pas de validation
ENDSELECT
' effacement des variables intermediaires
FOR l1&=41 TO 45
parametre$(l1&)=""             ! IMPORTANT pour pro get_command
NEXT l1&
FOR l1&=81 TO 85
parametre$(l1&)=""             ! IMPORTANT pour pro get_command
NEXT l1&
CASE 3
'
' Edit RUB
'
adr%=pararub.adr%
l1$=SPACE$(8)
RSET l1$=nom$
set_string(4,l1$)             ! Nom
set_string(6,parametre$(4))   ! Nb msg exist
set_state(7,0,0,1)            ! Reset OFF
FOR l1|=0 TO 2
set_edit(10+l1|,parametre$(l1|))
NEXT l1|
set_bout(3,13,1,1)
affiche_rsc
DEFMOUSE 2
IF b%=8
validation|=2
FOR l1|=0 TO 2
parametre$(l1|)=FN edit$(10+l1|)
NEXT l1|
control(0,1,nbm_rub_max&)
control(1,1,8)
control(2,1,20)
get_bout(3,13,1)
g1!=-FN selected(7)
ENDIF
CASE 4
'
' Edit AFF
'
adr%=paraff.adr%
l1$=SPACE$(8)
RSET l1$=nom$
set_string(4,l1$)             ! Nom
set_string(6,parametre$(2))   ! Nb msg exist
set_state(7,0,0,1)            ! Reset OFF
set_edit(10,parametre$(0))
set_state(11,1-VAL(parametre$(1)),0,1) ! 40 col ?
set_state(12,VAL(parametre$(1)),0,1) ! 80 col ?
affiche_rsc
DEFMOUSE 2
'
IF b%=8
validation|=2
parametre$(0)=FN edit$(10)
control(0,23,nbl_aff_max&)
parametre$(1)=STR$(FN selected(12))
g1!=FN selected(7)
ENDIF
CASE 5
'
' Edit ALTERNAT
'
adr%=altern.adr%
set_string(2,nom$)            ! Nom
FOR l1&=0 TO 17
set_edit(11+l1&,alternative$(l1&))
NEXT l1&
FOR l1&=0 TO 2                ! Mode
set_state(29+l1&,-(altern_mode&=l1&),0,1)
NEXT l1&
set_edit(31,STR$(altern_level&))
affiche_rsc
DEFMOUSE 2
'
IF b%=32
validation|=2
FOR l1&=0 TO 17
alternative$(l1&)=FN edit$(11+l1&)
NEXT l1&
altern_level&=VAL(FN edit$(31))
IF FN selected(29)
altern_mode&=0
ELSE IF FN selected(30)
altern_mode&=1
ELSE
altern_mode&=2
ENDIF
ENDIF
CASE 6
'
' Edit BASE
'
adr%=para_base.adr%
set_string(2,nom$)            ! Nom
set_string(6,STR$(nb_fiches_base&))   ! Nb fiches exist
set_state(8,0,0,1)            ! Reset OFF
set_edit(7,STR$(base_param%(last_base&,0)))
set_radio(base_param%(last_base&,1),25,3)
set_radio(base_param%(last_base&,2),29,2)
'
g1&=0
g2&=0               ! Champ o— on va positionner le csr
edit_base.fiche
aes_draw
'
DEFMOUSE 0
REPEAT
b%=FORM_DO(adr%,g2&)
g2&=16               ! New Champ o— on va positionner le csr
edit_changed!=FALSE  ! On a pas modifi‚ pour l'instant...
edit_base.getfiche        ! Sauve le champ en cours de la fiche
SELECT b%
CASE 14                       ! Ascenseur
l1%=GRAF_SLIDEBOX(adr%,13,14,1) ! Gest slide
g1&=l1%/1001*25               ! Calcul obj en 1ere ligne
edit_changed!=TRUE
CASE 11                       ! Mont‚e d'un cran
IF g1&>0                      ! Si pas en haut
DEC g1&                       ! Monte
edit_changed!=TRUE
ENDIF
CASE 12                       ! Descente d'un cran
IF g1&<24                     ! Si pas en bas
INC g1&                       ! Descend
edit_changed!=TRUE
ENDIF
CASE 13                       ! D‚place de 9 lignes
MOUSE void,l1&,void           ! Saisit coord Y
~OBJC_OFFSET(adr%,14,l3&,l2&)
IF l1&<l2&                    ! Mont‚e
DEC g1&                       ! Monte
ELSE                          ! Descente
INC g1&                       ! Descend
ENDIF
edit_changed!=TRUE
ENDSELECT
IF edit_changed!
edit_base.fiche
~OBJC_DRAW(adr%,10,7,x%,y%,w%,h%)
ENDIF
UNTIL b%=>31
DEFMOUSE 2
'
IF b%=31
validation|=2
ENDIF
aes_erase
'
ENDSELECT
'
' Validation
'
IF validation|=2              ! Si validation OK
IF no_page&<0                 ! Si page n'exist pas encore
no_page&=nbp&
nom$(no_page&)=nom$           ! Nom page
INC nbp&                      ! 1 de +
new_page(no_page&,nom$)       ! Fixe noms
ELSE IF info|(no_page&)=2     ! Si page ‚ffac‚e
new_page(no_page&,nom$)       ! Fixe noms
ELSE                          ! Si simple update
modif_page(no_page&,nom$)     ! Signale modif ds liste
ENDIF
SELECT type&
CASE 1
'
' Valid VDT
'
code_vdt(0,PRED(nbl%),FALSE)  ! Codage page
page_vdt$(no_page&)=m1$       ! Stocke page cod‚e
CASE 2
'
' Valid ARBO
'
m1$=STR$(fnct|)+CHR$(0)
FOR l1|=0 TO 80
m1$=m1$+parametre$(l1|)+CHR$(0)
NEXT l1|
page_arbo$(no_page&)=m1$      ! Stocke page cod‚e
CASE 3
'
' Valid RUB
'
FOR l1|=0 TO 3
param_rub|(no_page&,l1|)=VAL(parametre$(l1|))
NEXT l1|
IF g1!
param_rub|(no_page&,4)=0
FOR l1&=0 TO nbm_rub_max&
msg_rub$(no_page&,l1&)=""
NEXT l1&
ENDIF
CASE 4
'
' Valid AFF
'
FOR l1|=0 TO 1                  ! Params
param_aff|(no_page&,l1|)=VAL(parametre$(l1|))
NEXT l1|
IF g1!                          ! Si reset
param_aff|(no_page&,2)=0
FOR l1&=0 TO nbl_rub_max&
ligne_aff$(no_page&,l1&)=""
NEXT l1&
ENDIF
CASE 5
'
' Valid ALTERN
'
l1$=STR$(altern_mode&)+STR$(altern_level&)+SPACE$(8)
FOR l1&=0 TO 17
l1$=l1$+alternative$(l1&)+CHR$(0)
NEXT l1&
page_alt$(no_page&)=l1$
CASE 6
'
' Valid BASE
'
FOR l1&=0 TO 24
fiches_nom$(no_page&,l1&)=parametre$(l1&)
FOR l2&=0 TO 2            ! Copie paramŠtres pour chaque fiche
fiches_param&(no_page&,l1&,l2&)=fiches_param&(last_base&,l1&,l2&)
NEXT l2&
NEXT l1&
adr%=para_base.adr%
base_param%(no_page&,0)=FN get_value(7,1,nbf_base_max%) ! Nb fiches max!
base_param%(no_page&,1)=FN get_radio(25,3) ! Stockage
base_param%(no_page&,2)=FN get_radio(29,2) ! AccŠs
ENDSELECT
'
modify!(type&)=TRUE           ! Signale modif d'un fichier
enable_maj(type&)
ENDIF
'
fin_edit:
IF type&=1
libere_texte                  ! LibŠre ram text
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE edit_base.fiche
set_edit(14,STR$(SUCC(g1&)))
set_state(15,fiches_param&(last_base&,g1&,0),0,1) ! Valide?
set_edit(16,STR$(fiches_param&(last_base&,g1&,1)))
set_edit(17,parametre$(g1&))
set_radio(fiches_param&(last_base&,g1&,2),19,3)
OB_Y(adr%,14)=g1&*32*rez|/24
RETURN
> PROCEDURE edit_base.getfiche
fiches_param&(last_base&,g1&,0)=FN selected(15)
fiches_param&(last_base&,g1&,1)=FN get_value(16,1,40)
parametre$(g1&)=FN edit$(17)
fiches_param&(last_base&,g1&,2)=FN get_radio(19,3)
RETURN
> PROCEDURE editer_rub
editer_page(3,rub$,nb_rub_max&,nbn_rub&,nb_rub&,nom_rub$(),info_rub|(),alpha_rub$(),first_rub&)
RETURN
> PROCEDURE editer_vdt
editer_page(1,vdt$,nbp_vdt_max&,nbn_vdt&,nbp_vdt&,nom_vdt$(),info_vdt|(),alpha_vdt$(),first_vdt&)
RETURN
> PROCEDURE edit_msgsys(p.adr%)
LOCAL adr%,x%,y%,w%,h%,b%
'
adr%=msgsys.adr%
FOR l1&=3+nb_msg_arbo&(fnct|) TO 14
OB_FLAGS(adr%,l1&)=0           ! Non ‚ditable
~OBJC_DELETE(adr%,l1&)         ! EnlŠve objet
NEXT l1&
'
ctrl_msgsys
'
FOR l1&=0 TO PRED(nb_msg_arbo&(fnct|))
l1$=SPACE$(22)
LSET l1$=nom_msg$(msg_arbo&(fnct|,l1&))   ! Fixe nom du message
l1$=l1$+"___"
set_template(3+l1&,l1$)
set_edit(3+l1&,parametre$(61+l1&))
NEXT l1&
'
affiche_rsc
~OBJC_DRAW(p.adr%,0,7,x%,y%,w%+4,h%+4)
'
IF b%=15
FOR l1&=3 TO nb_msg_arbo&(fnct|)+2
parametre$(58+l1&)=FN edit$(l1&)
NEXT l1&
ENDIF
'
FOR l1&=3+nb_msg_arbo&(fnct|) TO 14
~OBJC_ADD(adr%,2,l1&)          ! Ajoute objet
OB_FLAGS(adr%,l1&)=8           ! ‚ditable
NEXT l1&
'
RETURN
> PROCEDURE edit_pagemem(p.adr%)
LOCAL adr%,x%,y%,w%,h%,b%
'
adr%=pagemem.adr%
ctrl_pagemem(nom$)            ! Controle si PM au bon format
set_bout(40,4,9,1)            ! Valide PM
FOR l1&=14 TO 23
set_edit(l1&,parametre$(36+l1&))    ! Fixe PM
NEXT l1&
l1&=VAL(parametre$(47))       ! Etat des boutons suppl‚mentaires
set_state(27,-BTST(l1&,0),0,1) ! Valide Cnx/Fin
set_edit(28,parametre$(48))   ! Fixe page Cnx/Fin
set_state(30,-BTST(l1&,1),0,1) ! Valide Fatal Error
set_edit(31,parametre$(49))   ! Fixe page Fatal Error
affiche_rsc
~OBJC_DRAW(p.adr%,0,7,x%,y%,w%+4,h%+4)
IF b%=24
get_bout(40,4,9)
FOR l1&=14 TO 23
parametre$(36+l1&)=FN edit$(l1&)  ! Extrait PM
NEXT l1&
l1&=FALSE
IF FN selected(27)
l1&=BSET(l1&,0)
ENDIF
parametre$(48)=FN edit$(28) ! Extrait Cnx/Fin
IF FN selected(30)
l1&=BSET(l1&,1)
ENDIF
parametre$(47)=STR$(l1&)    ! Etat des boutons supp
parametre$(49)=FN edit$(31) ! Extrait Fatal/Error
ENDIF
RETURN
> PROCEDURE effa_bloc
'
' Efface bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
efface_curseur
l2&=SUCC(g11&-g10&)
FOR l1&=SUCC(g11&) TO nbl%    ! D‚place lignes
editor$(l1&-l2&)=editor$(l1&)
NEXT l1&
FOR l1&=SUCC(nbl%-l2&) TO PRED(nbl%)      ! Efface les derniŠres lignes
editor$(l1&)=""
NEXT l1&
SUB nbl%,l2&                  ! nb lignes de -
g8&=g10&                      ! Ligne curseur
g9&=1
g11&=TRUE                     ! Plus de bloc
g7&=g8&-9
IF g7&<0
g7&=0
ENDIF
taille_asc
affiche_texte
bloc_control                  ! Settings menu
ENDIF
RETURN
> PROCEDURE efface_curseur
'
' Efface csr ‚diteur GEM:
'
l1|=-(g8&=>g10& AND g8&<=g11&)        ! Csr dans bloc ou pas
PRINT AT(PRED(p.x_car&+g9&),g8&-g7&+5);normal.f$(l1|);MID$(editor$(g8&),g9&,1);normal.f$(0);
RETURN
> PROCEDURE effacement_ligne
'
' Efface une ligne de l'‚diteur GEM:
'
IF g8&=nbl%                   ! Si derniŠre ligne
INC nbl%
editor$(nbl%)=" "
ENDIF
'
DELETE editor$(g8&)           ! Efface ligne
DEC nbl%                      ! 1 ligne de -
taille_asc                    ! New taille asc
'
IF l.in_bloc|                 ! Si dans le bloc
DEC g11&                      ! Dern ligne du bloc
ELSE IF g8&<g10&              ! si avant le bloc
DEC g10&                      ! Bloc remonte
DEC g11&
ENDIF
'
g9&=1                         ! Pos X csr
pos_asc                       ! New pos asc
'
l1&=((g8&-g7&)*8+32)*rez|
PBOX l.l_g&,l1&,l.r_g&,191*rez|+rm| ! Efface fenetre depuis ligne ‚ffac‚e
affiche_lignes(g8&)
affiche_curseur
CLR g1!                       ! Ligne valide (puisk'‚ffac‚e)
bloc_control                  ! Settings menu
RETURN
> PROCEDURE enable_ecrilir
DO
READ l1&,l2&
EXIT IF l1&=FALSE
set_state(l1&,0,1+BTST(l2&,m1&),0)
LOOP
RETURN
> PROCEDURE export_arbo
export(2,"ABR",nbp_arbo&,nom_arbo$(),nbn_arbo&,page_arbo$(),alpha_arbo$(),first_arbo&)
RETURN
> PROCEDURE export_vdt
export(1,"VDT",nbp_vdt&,nom_vdt$(),nbn_vdt&,page_vdt$(),alpha_vdt$(),first_vdt&)
RETURN
> PROCEDURE export(type&,ext$,VAR nbp&,nom$(),nbn&,page$(),alpha$(),first_obj&)
LOCAL file$,void&,l%,nom$,mode&,no_page&
'
' Exporter une page vdt/arbo
'
s_title$="Export d'une "+tpage$(type&)
titre(s_title$)
sel_exp:
REPEAT
mode&=FALSE
select(s_title$,"",nbn&)
IF b%=27                      ! Si valid
nom$=FN edit$(26)             ! Nom page
no_page&=FN find_page(nom$,nbp&,nom$())
IF no_page&=>0                ! Si page existe
IF info_vdt|(no_page&)=2      ! Si page dem non ‚ffac‚e
ALERT 2,"La page "+nom$+"|… ‚t‚ ‚ffac‚e! Voulez-|vous l'exporter|quand mˆme?",1,"Exporter|Abandon",mode&
ENDIF
ELSE                          ! Page n'existe pas
ALERT 1,"La page "+nom$+"|n'existe pas!",1,"   OK   ",mode&
mode&=2
ENDIF
ENDIF
UNTIL mode&<2
'
IF b%=27
f_titre$="EXPORT DE PAGE"
file$=FN file$(2,inout_path$+"*."+ext$,nom$+"."+ext$,nom$)
IF LEN(file$)
inout_path$=curr_path$          ! Chge path par defaut
DEFMOUSE 2
OPEN "O",#1,file$             ! Ouvre fichier
l%=LEN(page$(no_page&))       ! Long page
~FRE(0)                       ! Garbage collection
BPUT #1,V:page$(no_page&),l%  ! Sauve page
IF type&=2                    ! Page arbo
OUT #1,13,10
ENDIF
CLOSE #1
DEFMOUSE 0
ENDIF
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE extract_edits
LOCAL obj&,param&
'
' S‚rie de extract_edit
'
DO
READ obj&,param&
EXIT IF obj&=FALSE
parametre$(param&)=FN edit$(obj&)
LOOP
RETURN
> PROCEDURE extract_selecteds
LOCAL obj&,param&
'
' S‚rie de extract_selected
'
DO
READ obj&,param&
EXIT IF obj&=FALSE
parametre$(param&)=STR$(FN selected(obj&))
LOOP
RETURN
'
> PROCEDURE fillsel_obj
'
' Rempli selecteur:
'
FOR l1|=0 TO 8                ! Inscrit 9 aff
l1&=l1|+first_obj&
IF l1&<nbn&                   ! Si encore des aff
l1$=alpha$(l1&)
set_string(13+l1|,LEFT$(l1$,PRED(LEN(l1$))))
set_string(4+l1|,RIGHT$(l1$))
ELSE
set_string(13+l1|,"")
set_string(4+l1|,"")
ENDIF
NEXT l1|
RETURN
> PROCEDURE fillsel_tel
'
' Rempli s‚lecteur d'objet pour les infos tel:
'
FOR l1|=0 TO 7                ! Inscrit 8 noms
l1&=l1|+m1&
IF l1&<nb_files%              ! Si encore des fichiers
set_string(7+l1|,file$(l1&))
ELSE                          ! Si plus de fichier
set_string(7+l1|,"")
ENDIF
NEXT l1|
RETURN
> FUNCTION free_page(max&,type$,VAR nbn&,nbp&)
'
' Teste place pour new page VDT/arbo
'
INC max&
IF nbp&=>max&                 ! Si d‚ja maximum de pages
IF nbn&<max&                  ! Si certaines sont ‚ffac‚es
ALERT 3,"Vous devez mettre … jour|sur le disque les"+type$+"s|‚ffac‚es de la RAM avant|d'en cr‚er d'autres...",1,"   OK   ",l1&
ELSE
ALERT 3,"Il y a d‚ja "+STR$(max&)+type$+"s.|Pour en cr‚er une nouvelle,|vous devez en ‚ffacer une|ancienne...",1,"   OK   ",l1&
ENDIF
RETURN FALSE
ENDIF
RETURN TRUE
ENDFUNC
'
> PROCEDURE import_arbo
import(2,"ABR",arbo$,nbp_arbo_max&,nbp_arbo&,nom_arbo$(),info_arbo|(),nbn_arbo&,page_arbo$(),alpha_arbo$(),first_arbo&)
RETURN
> PROCEDURE import_vdt
import(1,"VDT",vdt$,nbp_vdt_max&,nbp_vdt&,nom_vdt$(),info_vdt|(),nbn_vdt&,page_vdt$(),alpha_vdt$(),first_vdt&)
RETURN
> PROCEDURE import(type&,ext$,VAR def_nom$,p.max&,nbp&,nom$(),info|(),nbn&,page$(),alpha$(),first_obj&)
LOCAL file$,void&,l%,nom$,mode&,no_page&
'
' Importer une page vdt/arbo
'
titre("Import d'une "+tpage$(type&))
IF FN free_page(p.max&," page",nbn&,nbp&)
f_titre$="IMPORTER 1 PAGE"
file$=FN file$(1,inout_path$+"*."+ext$,"",nom$)
IF LEN(file$)
inout_path$=curr_path$          ! Chge path par defaut
REPEAT
mode&=FALSE
no_page&=FN find_page(nom$,nbp&,nom$())
IF no_page&=>0                ! Si page existe
IF info|(no_page&)<>2         ! Si page dem non ‚ffac‚e
ALERT 2," | |La page "+nom$+" existe d‚ja!",1,"Renommer|Ecraser|Abandon",mode&
IF mode&=1                    ! SI renommer
select("Nom de la page import‚e",nom$,nbn&)
IF b%=28                      ! Si abandon
mode&=3
ENDIF
nom$=FN edit$(26)             ! Nouveau nom
ENDIF
ENDIF
ELSE                          ! Page n'existe pas
no_page&=nbp&
nom$(no_page&)=nom$           ! Nom page
INC nbp&                      ! 1 de + (nbp est une "VAR")
ENDIF
UNTIL mode&<>1                  ! Si on a chang‚ de nom==>nouveau test
IF mode&<3                    ! Si pas abandon
IF mode&<2                    ! Si pas ‚crasement
new_page(no_page&,nom$)       ! enregistre page
ELSE                          ! ‚crasement
modif_page(no_page&,nom$)     ! Signale modif ds la liste
ENDIF
'
DEFMOUSE 2
OPEN "I",#1,file$             ! Ouvre fichier
l%=LOF(#1)                    ! Long page
IF l%>32767
l%=32767
ENDIF
IF type&=2 AND l%>3           ! Page arbo
SUB l%,2                      ! EnlŠve le CR LF
ENDIF
page$(no_page&)=SPACE$(l%)    ! Pr‚pare chaine (page$() est une "VAR")
~FRE(0)                       ! Garbage collection
BGET #1,V:page$(no_page&),l%  ! Charge page
CLOSE #1
'
def_nom$=nom$                 ! 2.62: Nouveau nom par d‚faut
set_loaded                    ! On suppose serv charg‚
enable_maj(type&)
DEFMOUSE 0
ENDIF
ENDIF
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE infos_tel
LOCAL l.range_asc&,l.taille_range&
'
' Gest infos tel:
'
s_title$=gestion_tel$
titre(s_title$)
IF info_tel_path$=""
info_tel_path$=chemin$(3)     ! dossier par d‚faut
ENDIF
IF RIGHT$(info_tel_path$)<>"\"
info_tel_path$=info_tel_path$+"\"
ENDIF
REPEAT
FILESELECT #"SEL. DOSSIER TEL",info_tel_path$,"",g1$
IF LEN(g1$)
l2|=RINSTR(g1$,"\")
IF l2|=>3
info_tel_path$=LEFT$(g1$,PRED(l2|))
l1|=2
ELSE
ALERT 1,"Chemin incorrect.",1,"   OK   ",l1|
ENDIF
ELSE
l1|=3
ENDIF
UNTIL l1|=>2
IF l1|=2
g4$="\"                       ! Commence … la base du dossier
g2|=0                         ! Niveau 0
infos_tel:
adr%=infos_tel.adr%
CLR m2&                       ! Pas d'objet s‚lect
set_string(3,"")
FOR l1|=0 TO 7                ! On inscrit 8 noms
set_string(7+l1|,"")
NEXT l1|
OB_H(infos_tel.adr%,18)=72*rez| ! Fixe taille bout
OB_Y(infos_tel.adr%,18)=0     ! Fixe sa pos
~FORM_CENTER(infos_tel.adr%,x%,y%,w%,h%) ! Coord boite
DEC x%
DEC y%
ADD w%,4
ADD h%,4
~FORM_DIAL(0,160,100,0,0,x%,y%,w%,h%) ! R‚serve zone pour boite
~OBJC_DRAW(infos_tel.adr%,0,7,x%,y%,w%,h%) ! Aff boite
tel_directory:
DEFMOUSE 2
CLR nb_files%,g6!             ! D‚but dir dossier courant
~FSETDTA(BASEPAGE+128)
m1$=info_tel_path$+g4$+"*.*"             ! Param de recherch
m1&=FSFIRST(m1$,&X10000)
DO UNTIL m1&                  ! On va ‚xaminer tous les noms
l1$=CHAR{BASEPAGE+158}        ! Att un nom de fich/doss
l2$=RIGHT$("0"+STR$(date& AND 31),2)+"/"+RIGHT$("0"+STR$((date& AND 480)/32),2)+"/"+RIGHT$(STR$(80+(date& AND 65024)/512),2)
IF l1$<>"." AND l1$<>".."
IF BTST(attrib|,4)            ! Si doss
IF l1$="INFOS"                ! Si doss INFOS
g6!=TRUE                      ! Signale son ‚xistance
ELSE                          ! Si doss banal
file$(nb_files%)=CHR$(7)+"   "+l1$+SPACE$(13-LEN(l1$))+l2$+" Dossier..."
INC nb_files%                 ! Un nom de +
ENDIF
ELSE                          ! Si fich
length%(nb_files%)=longueur%
file$(nb_files%)="    "+l1$+SPACE$(13-LEN(l1$))+l2$+RIGHT$("   "+STR$((length%(nb_files%)+1023)\1024),4)+" "
duree_tel(longueur%)
file$(nb_files%)=file$(nb_files%)+l1$
INC nb_files%                 ! Un nom de +
ENDIF
ENDIF
m1&=FSNEXT()
LOOP
IF nb_files%>1
l1$="S"
ELSE
l1$=""
ENDIF
m1$=RIGHT$(g4$+"("+STR$(nb_files%)+" OBJET"+l1$+")",65)
set_string(3,m1$)
~OBJC_DRAW(infos_tel.adr%,2,7,x%,y%,w%,h%) ! Aff path
IF nb_files%
QSORT file$() WITH sort|(),nb_files% ! Tri alpha
ENDIF
IF g6!                        ! Si doss INFOS exist
~FSETDTA(BASEPAGE+128)        ! dir INFOS
m1$=info_tel_path$+g4$+"INFOS\*.*"
m1&=FSFIRST(m1$,&X10000)
DO UNTIL m1&                  ! Recherche des noms
l1$=CHAR{BASEPAGE+158}
IF l1$<>"." AND l1$<>".."     ! Si pas fichier systŠme
IF BTST(attrib|,4)=FALSE      ! Si pas doss
FOR l1%=0 TO nb_files%        ! Cherch nom dans list
l1|=LEN(l1$)
IF MID$(file$(l1%),5,l1|)=l1$ ! S'il y est
MID$(file$(l1%),3,1)="*"      ! Signale pr‚sence des infos
ENDIF
NEXT l1%
ENDIF
ENDIF
m1&=FSNEXT()
LOOP
ENDIF
CLR m1&                       ! Fich en 1ere ligne
fillsel_tel                   ! Rempli selecteur
IF nb_files%<9                ! Si - de 9 objc
m1%=72*rez|                   ! Taill asc max
l.range_asc&=0
ELSE
m1%=576*rez|/nb_files%        ! Calcul taill asc
l.range_asc&=nb_files%-8      ! Latitude de mouvement
ENDIF
l.taille_range&=72*rez|-m1%   ! Taille de la zone de mvt
OB_H(infos_tel.adr%,18)=m1%   ! Fixe taill asc
infos_tel.pos_asc             ! Fixe pos asc
DEFMOUSE 0
'
~OBJC_DRAW(infos_tel.adr%,5,7,x%,y%,w%,h%) ! Aff boite
DO
b%=FORM_DO(infos_tel.adr%,0)
SELECT b%                     ! En fnct du bout
CASE -32761 TO -32754         ! Double click sur obj
l1|=b%+32768                  ! Calc nø objc s‚lect
l1$=CHAR{OB_SPEC(infos_tel.adr%,l1|)}
IF LEFT$(l1$)=CHR$(7)
set_state(l1|,0,0,0)          ! D‚s‚lect
CLR m2&
l1$=TRIM$(MID$(l1$,5,13))     ! Extract nom s‚lect
g4$=g4$+l1$+"\"               ! Change path
INC g2|
GOTO tel_directory
ENDIF
CASE 7 TO 14                  ! S‚lect d'une page
m2&=b%                        ! Objc s‚l‚ct
CASE 15                       ! Mont‚e d'un cran
IF m1&>0                      ! Si pas en haut
DEC m1&                       ! Monte 1 ligne
infos_tel.pos_asc             ! Fixe pos asc
IF m2&                        ! Si 1 objc ‚tait s‚lect
~OBJC_CHANGE(infos_tel.adr%,m2&,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
CLR m2&
ENDIF
fillsel_tel                   ! Rempli sel
~OBJC_DRAW(infos_tel.adr%,5,7,x%,y%,w%,h%) ! Aff
ENDIF
CASE 16                       ! Descente d'un cran.
IF m1&<l.range_asc&           ! Si pas en bas
INC m1&                       ! Descend 1 ligne
infos_tel.pos_asc             ! Fixe pos asc
IF m2&                        ! Si 1 objc ‚tait s‚lect
~OBJC_CHANGE(infos_tel.adr%,m2&,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
CLR m2&
ENDIF
fillsel_tel                   ! Rempli sel
~OBJC_DRAW(infos_tel.adr%,5,7,x%,y%,w%,h%) ! Aff
ENDIF
CASE 17                       ! D‚place de 8 lignes
MOUSE void,l1&,void           ! Saisit coord Y
~OBJC_OFFSET(adr%,18,l3&,l2&)
IF l1&<l2&                    ! Mont‚e
SUB m1&,8
IF m1&<FALSE
m1&=FALSE
ENDIF
ELSE                          ! Descente
ADD m1&,8
IF m1&>l.range_asc&
m1&=l.range_asc&
ENDIF
ENDIF
infos_tel.pos_asc             ! Fixe pos asc
fillsel_tel                   ! Fixe objets
~OBJC_DRAW(infos_tel.adr%,5,7,x%,y%,w%,h%) ! Aff
CASE 18                       ! Ascenseur
l1%=GRAF_SLIDEBOX(infos_tel.adr%,17,18,1) ! Gest asc par GEM
IF nb_files%>8                ! Si + de 8 noms
m1&=l1%*(nb_files%-8)/1000    ! Calc nom en 1ere ligne
infos_tel.pos_asc             ! Fixe pos asc
IF m2&                        ! Si 1 objc ‚tait s‚lect
~OBJC_CHANGE(infos_tel.adr%,m2&,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
CLR m2&
ENDIF
fillsel_tel                   ! Rempli sel
~OBJC_DRAW(infos_tel.adr%,5,7,x%,y%,w%,h%) ! Aff
ENDIF
CASE 20                       ! Retour au niv sup
l1!=(g2|=0)
~OBJC_CHANGE(infos_tel.adr%,20,0,x%,y%,w%,h%,0,-l1!) ! D‚s‚lect
IF g2|
l1|=RINSTR(g4$,"\",PRED(LEN(g4$)))
g4$=LEFT$(g4$,l1|)
DEC g2|                     ! Remonte dans les doss
IF m2&                      ! Si 1 objc ‚tait s‚lect
~OBJC_CHANGE(infos_tel.adr%,m2&,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
CLR m2&
ENDIF
GOTO tel_directory
ENDIF
CASE 22                       ! On veut ‚diter un fich inf
~OBJC_CHANGE(infos_tel.adr%,22,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
IF m2&                        ! Si un fic … ‚t‚ s‚lect
l1$=MID$(CHAR{OB_SPEC(infos_tel.adr%,m2&)},5) ! Ligne du fich
l2$=TRIM$(LEFT$(l1$,13))      ! Nom fichier
IF LEN(l2$)                   ! Si c pas une ligne blanche
set_state(m2&,0,0,0)          ! D‚s‚lect
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%) ! LibŠre la zone
editer_infos(info_tel_path$+g4$+"INFOS\"+l2$,l1$) ! Edit infos
GOTO infos_tel
ENDIF
ENDIF
CASE 23                       ! On veut ‚ffacer un fich infos
IF m2&                        ! Si un fich … ‚t‚ s‚lect
l1$=CHAR{OB_SPEC(infos_tel.adr%,m2&)} ! Ligne du fich
IF MID$(l1$,3,1)="*"
l2$=TRIM$(MID$(l1$,5,13))     ! Nom fich
ALERT 3,"Effacer les|informations|sur le fichier:|"+l2$,1,"Effacer|Annuler",l1|
IF l1|=1
DEFMOUSE 2
KILL info_tel_path$+g4$+"INFOS\"+l2$
~OBJC_CHANGE(infos_tel.adr%,m2&,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
~OBJC_CHANGE(infos_tel.adr%,23,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
DEFMOUSE 0
GOTO infos_tel
ENDIF
ENDIF
ENDIF
~OBJC_CHANGE(infos_tel.adr%,23,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
CASE 24
set_state(24,0,0,0)           ! D‚s‚lect
IF m2&                        ! Si 1 objc ‚tait s‚lect
set_state(m2&,0,0,0)          ! D‚s‚lect
ENDIF
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%) ! LibŠre zone
EXIT IF TRUE
ENDSELECT
LOOP
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE infos_tel.pos_asc
IF l.range_asc&
OB_Y(infos_tel.adr%,18)=m1&*l.taille_range&/l.range_asc&   ! Fixe position
ELSE
OB_Y(infos_tel.adr%,18)=0  ! Fixe position
ENDIF
RETURN
> PROCEDURE insertion_ligne
'
' Insert ligne dans texte ‚ditabl:
'
INSERT editor$(g8&)=" "       ! On insŠre une ligne
INC nbl%                      ! 1 ligne de +
taille_asc                    ! New taille asc
'
IF l.in_bloc|                 ! Si dans le bloc
INC g11&                      ! Dern ligne du bloc
ELSE IF g8&<g10&              ! si avant le bloc
INC g10&                      ! Bloc descend
INC g11&
ENDIF
'
g9&=1                         ! Csr en d‚but de ligne
pos_asc                       ! Pos asc
'
l1&=((g8&-g7&)*8+32)*rez|
PBOX l.l_g&,l1&,l.r_g&,191*rez|+rm|   ! Efface les lignes ayant boug‚
affiche_lignes(g8&)
affiche_curseur
g1!=TRUE                      ! Ligne en cours … ‚t‚ modif
g5!=TRUE                      ! Mode insert ligne
bloc_control
RETURN
'
> FUNCTION lettre$
RETURN MID$(editor$(m2&),11,1)
ENDFUNC
'
> PROCEDURE maj
LOCAL l_error!,l.folder&
'
' Mise … jour du serv:
'
DEFMOUSE 2
m1$=maj$+" du serveur"
titre(m1$)
IF real_load&>TRUE
ALERT 3,"Le serveur n'a pas ‚t‚|charg‚ entierement! Vous|risquez d'en d‚truire une|partie en continuant!",2,"Continuer|Abandon",real_load&
IF real_load&=1
ALERT 2,"Etes-vous s–r de|vouloir ‚craser le|serveur figurant|sur le disque?",2,"Ecraser|Annuler",real_load&
SUB real_load&,2
ENDIF
ENDIF
IF real_load&=TRUE
'
adr%=fichiers.adr%
set_edit(1,m1$)
aff_charsauve
'
sauve_systeme               !!!!!!!!
'
IF l.folder&                  ! Si pas abandon
control_folder(0,"rubs/affs",chemin$(1))
IF l.folder&=TRUE
m1$=chemin$(1)
'
' Rubs:
'
IF modify!(3)
set_string(5,"Rubriques")
set_string(6,maj$)
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
sr_noyau(1)                           ! Sauvegarde
fin_cs_type                           ! Fin de l'op‚ration
ENDIF
'
' Affs:
'
IF modify!(4)
set_string(5,"Affiches")
set_string(6,maj$)
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
sa_noyau(1)                           ! Sauvegarde
fin_cs_type                           ! Fin de l'op‚ration
ENDIF
'
' Bases:
'
IF modify!(6)
set_string(5,"Bases de donn‚es")
set_string(6,maj$)
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
'
IF nb_base&
err_resume&=12
REPEAT
err_choix&=FALSE
FOR m1&=0 TO PRED(nb_base&)   ! Parcourt affs
l1$=nom_base$(m1&)            ! Nom base … maj
set_string(11,l1$)
set_vlstring(10,nb_base&-m1&,4)
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
l1|=info_base|(m1&)           ! Modifs ‚ffectu‚es?
IF l1|=1                      ! Modif du code
OPEN "O",#1,chemin$(1)+l1$+".DBD"
PRINT #1;3                    ! 3 Params g‚n‚raux
FOR l2|=0 TO 2                ! Params g‚n‚raux
PRINT #1;base_param%(m1&,l2|)
NEXT l2|
PRINT #1;25                   ! 25 Fiches
PRINT #1;1                    ! 1 Chaine de texte
PRINT #1;3                    ! 3 paramŠtres
FOR l2|=0 TO 24               ! Parcourt fiches
PRINT #1,fiches_nom$(m1&,l2|)
FOR l3|=0 TO 2                ! Parcourt params
PRINT #1,fiches_param&(m1&,l2|,l3|)
NEXT l3|
NEXT l2|
CLOSE #1
err_resume&=FALSE
FOR l1&=0 TO PRED(nbn_base&)
l2$=alpha_base$(l1&)
IF LEFT$(l2$,LEN(l2$)-1)=l1$
alpha_base$(l1&)=l1$+" "
EXIT IF TRUE
ENDIF
NEXT l1&
info_base|(m1&)=FALSE          ! Plus de modif
ELSE IF l1|=2                  ! S'il faut Effacer rub
maj.kill(".DBD",nom_base$(),info_base|(),nb_base&)
IF EXIST(m1$+l1$+".DBF")       ! Si donn‚es exist
KILL m1$+l1$+".DBF"            ! Efface
ENDIF
ENDIF
NEXT m1&
err_12:
CLOSE #1
UNTIL err_choix&<>2
ENDIF
fin_cs_type                           ! Fin de l'op‚ration
modify!(6)=FALSE
ENDIF
ELSE
l_error!=TRUE
ENDIF
'
IF l_error!=FALSE             ! Si sauvegarde complŠte
modify!(0)=FALSE              ! Plus de modifs
~MENU_IENABLE(menu.adr%,maj|,0) ! Disable maj
ENDIF
ENDIF
'
FOR l1&=0 TO nb_file_max&     ! Efface le tableau file$
file$(l1&)=""
NEXT l1&
FOR l1|=0 TO 39               ! Efface le tableau ligne$
ligne$(l1|)=""
NEXT l1|
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%) ! LibŠre zone ‚cran
fram                          ! Garbage collect+affichage
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE modif_page(no&,nom$)
'
' signale modif d'une page vdt/arbo/aff ds la liste
'
info|(no&)=1
FOR l1&=0 TO PRED(nbn&)
l1$=alpha$(l1&)
IF LEFT$(l1$,PRED(LEN(l1$)))=nom$
alpha$(l1&)=nom$+"*"
EXIT IF TRUE
ENDIF
NEXT l1&
RETURN
> PROCEDURE move_bloc
'
' D‚place bloc:
'
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
l1&=g11&-g10&                 ! Long bloc-1
IF g8&<=g10& OR g8&>g11&      ! Si csr hors bloc
efface_curseur
IF g8&<g10&                   ! D‚place vers l'amont
l3&=SUCC(g11&)
l4&=g11&
ELSE
l3&=g10&
l4&=g10&
ENDIF
FOR l2&=0 TO l1&
l1$=editor$(l4&)
INSERT editor$(g8&)=l1$
DELETE editor$(l3&)
NEXT l2&
SUB g8&,-(g8&>g11&)*SUCC(l1&)
g10&=g8&
g11&=g8&+l1&
g9&=1
g7&=g8&-9
IF g7&<0
g7&=0
ENDIF
affiche_texte
ELSE
ALERT 1,"Vous ne pouvez pas|d‚placer ce bloc|vers lui-mˆme!",1,"   OK   ",void
ENDIF
ENDIF
RETURN
'
> PROCEDURE new_line_sets
'
' Voir editeur GEM
'
CLR g3!,g5!                   ! Reset modes ins
RETURN
> PROCEDURE new_page(no&,nom$)
'
' enregiste noms nlle page vdt/arbo,aff
'
info|(no&)=1
alpha$(nbn&)=nom$+"*"
INC nbn&
SSORT alpha$() WITH sort|(),nbn& ! Tri noms
RETURN
'
> FUNCTION onoff$
RETURN MID$(editor$(m2&),12,1)
ENDFUNC
'
> PROCEDURE para_bals
'
' Edit bals:
'
titre("ParamŠtrage des Bals")
parametre$(0)=STR$(bal_nb_pagemsg|) ! Nb pag/msg
parametre$(1)=STR$(bal_nb_lignepage|) ! Nb lignes/page
parametre$(3)=STR$(rep_nbl|)  ! Nbl rep
'
' Edition:
'
adr%=parabal.adr%
set_edit(3,parametre$(0))
set_edit(4,parametre$(1))
set_state(5,-bal_titre!,0,1)
set_edit(10,parametre$(3))
affiche_rsc
DEFMOUSE 2
IF b%=7                       ! Si on a confirm‚
parametre$(0)=FN edit$(3)
parametre$(1)=FN edit$(4)
bal_titre!=-FN selected(5)
parametre$(3)=FN edit$(10)
control(0,1,8)
control(1,1,20)
control(3,1,20)
bal_nb_pagemsg|=VAL(parametre$(0))
bal_nb_lignepage|=VAL(parametre$(1))
rep_nbl|=VAL(parametre$(3))
enable_maj(10)               ! On a modifi‚ le fichier DIVERS
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE para_mod
'
' Param module NEDER
'
titre("ParamŠtrage d'un Module externe")
REPEAT
cur_dir               ! Directory courant=>g1$
ALERT 2,"Le chemin courant est:|"+g1$+"|Voulez-vous le red‚finir?",2,"Red‚finir|Garder",l1|
IF l1|=1
f_titre$="CHOIX DU DOSSIER"
set_dir
ENDIF
UNTIL l1|=2
l1$=""
f_titre$="CHOIX DU MODULE"
g1$=FN file$(1,g1$+"*.*","",l1$)
IF LEN(g1$)
DEFMOUSE 2
OPEN "I",#1,g1$
g3%=LOF(#1)
CLOSE #1
g2|=184
g2$=CHR$(g2|)+"NEDER"+neder_ver$+MKL$(1024)+SPACE$(16)+MKI$(0)+SPACE$(10)+CHR$(0)+SPACE$(4)+STRING$(7,0)+DATE$+TIME$+"STUT ONE v"+version$+" "+SPACE$(15)+MKI$(0)+MKL$(0)+MKI$(nb_appels%)+STRING$(13,0)+SPACE$(56)+STRING$(7,0)
g1%=FRE(0)-512               ! M‚moire dispo pour module
IF g1%>g3%+512
~FRE(0)                       ! Garbage Collection
RESERVE FRE(0)-g1%            ! Reserve un maximum de RAM pour le module
g2%=MALLOC(300)               ! Zone de com (mini:257)
l1$=STR$(g2%)
l1$=CHR$(LEN(l1$))+l1$
~FRE(0)                       ! Garbage Collection
BMOVE V:g2$,g2%,g2|           ! TransfŠre ligne de com dans zone
EXEC 0,g1$,l1$,""             ! Appel module
~MFREE(g2%)                   ! LibŠre zone de com
RESERVE FRE(0)+g1%-255        ! R‚cupŠre RAM r‚serv‚e
fond_bureau
ELSE
ALERT 3,"M‚moire insuffisante!",1,"   OK   ",l1&
ENDIF
DEFMOUSE 0
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
'
> PROCEDURE sauve_pages(fichier$,VAR nbp&,nom$(),info|(),page$(),nbn&,alpha$())
'
' Sauves pages VDT/ABR
'
set_string(6,maj$)
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
err_resume&=1
REPEAT
err_choix&=FALSE      ! Pas d'erreur pour l'instant
OPEN "O",#1,m1$+fichier$
PRINT #1;MKI$(nbn&);CHR$(255); ! Nombre de pages
IF nbp&
FOR m1&=PRED(nbp&) DOWNTO 0   ! Parcourt les pages
l1$=nom$(m1&)                 ! Nom page … maj
set_string(11,l1$)
set_vlstring(10,SUCC(m1&),4)
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
l1|=info|(m1&)              ! Modifs ‚ffectu‚es
IF l1|<2                      ! Si page non ‚ffac‚e
PRINT #1;l1$;CHR$(0);MKI$(LEN(page$(m1&)));page$(m1&);CHR$(255);
info|(m1&)=FALSE              ! Plus de modif
ELSE                          ! Page ‚ffac‚e
DELETE page$(m1&)             ! Efface page
DELETE nom$(m1&)              ! Efface son nom
DELETE info|(m1&)             ! Efface ‚tat
DEC nbp&                      ! 1 page de - (VAR)
ENDIF
NEXT m1&
ENDIF
err_1:
CLOSE #1
UNTIL err_choix&<>2
err_resume&=FALSE
fin_cs_type                           ! Fin de l'op‚ration
IF nbn&
FOR l1&=0 TO PRED(nbn&)
MID$(alpha$(l1&),LEN(alpha$(l1&)),1)=" "
NEXT l1&
ENDIF
RETURN
> PROCEDURE sauve_systeme
err_choix&=FALSE
control_folder(0,"systŠme",chemin$(0))
IF l.folder&=TRUE AND err_choix&=FALSE
m1$=chemin$(0)                ! Path … utiliser
'
' Pages vdt:
'
IF modify!(1)
set_string(5,"Pages vid‚otex")
sauve_pages("VIDEOTEX.STU",nbp_vdt&,nom_vdt$(),info_vdt|(),page_vdt$(),nbn_vdt&,alpha_vdt$())
modify!(1)=FALSE
ENDIF
'
' Pages arbo:
'
IF err_choix&=FALSE
IF modify!(2)
set_string(5,"Pages arborescence")
sauve_pages("ARBO.STU",nbp_arbo&,nom_arbo$(),info_arbo|(),page_arbo$(),nbn_arbo&,alpha_arbo$())
modify!(2)=FALSE
ENDIF
'
' Pages alternatives:
'
IF err_choix&=FALSE
IF modify!(5)
set_string(5,"Pages alternatives")
sauve_pages("ALTERN.STU",nbp_alt&,nom_alt$(),info_alt|(),page_alt$(),nbn_alt&,alpha_alt$())
modify!(5)=FALSE
ENDIF
'
' Mots clef:
'
IF err_choix&=FALSE
IF modify!(9)
set_string(5,"Mots clef")
file2touch("MOTS_CLE.STU",maj$)  ! Affiche nom+op‚ration
IF nb_mots&=0                 ! Si pas de mot clef
IF EXIST(m1$+"MOTS_CLE.STU")  ! Si fichier exist
KILL m1$+"MOTS_CLE.STU"       ! On ‚fface
ENDIF
ELSE                          ! S'il y a des mots clef
err_resume&=4
REPEAT
err_choix&=FALSE      ! Pas d'erreur pour l'instant
OPEN "O",#1,m1$+"MOTS_CLE.STU" ! Ouvre fichier
PRINT #1;nb_mots&             ! Nb mots
STORE #1,mot$(),nb_mots&      ! Sauve mots clef
STORE #1,page$(),nb_mots&     ! Sauve pages arbo corresp
err_4:
CLOSE #1
UNTIL err_choix&<>2
err_resume&=FALSE
ENDIF
fin_cs_type                           ! Fin de l'op‚ration
modify!(9)=FALSE
ENDIF
'
' Messages systŠme:
'
IF err_choix&=FALSE
IF modify!(8)
set_string(5,"Messages systŠme")
file2touch("MSGS_SYS.STU",maj$)  ! Affiche nom+op‚ration
err_resume&=9
REPEAT
err_choix&=FALSE      ! Pas d'erreur pour l'instant
OPEN "O",#1,m1$+"MSGS_SYS.STU" ! Ouvre fichier
PRINT #1;nb_msgsys&           ! Nb msgs
STORE #1,msgsys$(),nb_msgsys& ! Sauve msgs
err_9:
CLOSE #1
UNTIL err_choix&<>2
err_resume&=FALSE
fin_cs_type                           ! Fin de l'op‚ration
modify!(8)=FALSE
ENDIF
'
' ParamŠtres divers:
'
IF err_choix&=FALSE
err_resume&=3
REPEAT
err_choix&=FALSE      ! Pas d'erreur pour l'instant
IF modify!(10) OR RANDOM(7)<1
set_string(5,"ParamŠtres divers")
file2touch("DIVERS.STU",maj$)  ! Affiche nom+op‚ration
OPEN "O",#1,m1$+"DIVERS.STU"  ! Ouvre fichier
PRINT #1;bal_nb_pagemsg|
PRINT #1;bal_nb_lignepage|
PRINT #1;bal_titre!
PRINT #1;rep_nbl|
PRINT #1;start_page$
PRINT #1;stop_page$
PRINT #1;error_page$
STORE #1,off_vdt$(),10
PRINT #1;off_vdt_mode|
PRINT #1;"+";sysop_page$      ! Ajout‚ depuis v2.4
PRINT #1;sysop_maxlong&
PRINT #1;"-";date_filtre$         ! Ajout‚ depuis v2.6
PRINT #1;levels_filtre$
fin_cs_type                           ! Fin de l'op‚ration
modify!(10)=FALSE
err_3:
CLOSE #1
ENDIF
UNTIL err_choix&<>2
err_resume&=FALSE
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
l_error!=TRUE
ENDIF
RETURN
> PROCEDURE select(titre$,select$,nbn&)
LOCAL l.taille_asc&
LOCAL l.asc_range&
LOCAL l.taille_range&
'
' Select objet ram:
'
adr%=select.adr%
set_edit(1,titre$)            ! Fixe titre
set_edit(26,select$)          ! Fixe pr‚sel
IF nbn&<10                    ! Si moins de 10 obj
l.taille_asc&=72*rez|         ! Taille asc maxi
l.range_asc&=0
ELSE
l.taille_asc&=648*rez|/nbn& ! Fixe taille asc
IF l.taille_asc&<16
l.taille_asc&=16
ENDIF
l.range_asc&=nbn&-9           ! Latitude de mouvement
ENDIF
l.taille_range&=72*rez|-l.taille_asc& ! Taille de la zone de mouvement possible
OB_H(adr%,25)=l.taille_asc&    ! Fixe taille
IF nbn&>9
IF first_obj&>l.range_asc&
first_obj&=l.range_asc&
ENDIF
ELSE
first_obj&=FALSE              ! Fenˆtre depuis le tout d‚but
ENDIF
select.pos_asc                ! Fixe pos asc
fillsel_obj                   ! Fixe objets
aes_draw
REPEAT
b%=FORM_DO(adr%,0)
SELECT b%
CASE 25                       ! Ascenseur
l1%=GRAF_SLIDEBOX(adr%,24,25,1) ! Gest slide
IF nbn&>9                     ! Si + de 9 obj
first_obj&=l1%*(nbn&-9)/1000  ! Calcul obj en 1ere ligne
select.pos_asc                ! Fixe pos asc
fillsel_obj                   ! Fixe objets
~OBJC_DRAW(adr%,2,7,x%,y%,w%,h%)
ENDIF
CASE 13 TO 21                 ! S‚lection obj
set_edit(26,CHAR{OB_SPEC(adr%,b%)}) ! Fixe obj sel
~OBJC_CHANGE(adr%,b%,0,x%,y%,w%,h%,0,1) ! D‚s‚lect
~OBJC_DRAW(adr%,26,7,x%,y%,w%,h%)
CASE 22                       ! Mont‚e d'un cran
IF first_obj&>0               ! Si pas en haut
DEC first_obj&                ! Monte
select.pos_asc                ! Fixe pos asc
fillsel_obj                   ! Fixe noms
~OBJC_DRAW(adr%,2,7,x%,y%,w%,h%)
ENDIF
CASE 23                       ! Descente d'un cran
IF first_obj&<l.range_asc&    ! Si pas en bas
INC first_obj&                ! Descend
select.pos_asc                ! Fixe pos asc
fillsel_obj                   ! Fixe noms
~OBJC_DRAW(adr%,2,7,x%,y%,w%,h%)
ENDIF
CASE 24                       ! D‚place de 9 lignes
MOUSE void,l1&,void           ! Saisit coord Y
~OBJC_OFFSET(adr%,25,l3&,l2&)
IF l1&<l2&                    ! Mont‚e
SUB first_obj&,9
IF first_obj&<FALSE
first_obj&=FALSE
ENDIF
ELSE                          ! Descente
ADD first_obj&,9
IF first_obj&>l.range_asc&
first_obj&=l.range_asc&
ENDIF
ENDIF
select.pos_asc                ! Fixe pos asc
fillsel_obj                   ! Fixe objets
~OBJC_DRAW(adr%,2,7,x%,y%,w%,h%)
ENDSELECT
UNTIL b%=27 OR b%=28
aes_erase
RETURN
> PROCEDURE select.pos_asc
IF l.range_asc&
OB_Y(adr%,25)=first_obj&*l.taille_range&/l.range_asc&   ! Fixe position
ELSE
OB_Y(adr%,25)=0   ! Fixe position
ENDIF
RETURN
> PROCEDURE set_dir
FILESELECT #f_titre$,g1$,"",g1$
IF LEN(g1$)
l2|=RINSTR(g1$,"\")
IF l2|=>3
CHDRIVE LEFT$(g1$)
g1$=LEFT$(g1$,l2|)
CHDIR g1$
l1|=2
ELSE
ALERT 1,"Chemin incorrect.",1,"   OK   ",void
ENDIF
ENDIF
RETURN
> PROCEDURE set_edits
LOCAL obj&,param&
'
' S‚rie de set edit
'
DO
READ obj&,param&
EXIT IF obj&=FALSE
set_edit(obj&,parametre$(param&))
LOOP
RETURN
> PROCEDURE set_selecteds
LOCAL obj&,param&
'
' S‚rie de set state(selected)
'
DO
READ obj&,param&
EXIT IF obj&=FALSE
set_state(obj&,VAL(parametre$(param&)),0,1)
LOOP
RETURN
> PROCEDURE set_template(p.obj&,p.temp$)
CHAR{{OB_SPEC(adr%,p.obj&)+4}}=p.temp$
RETURN
> PROCEDURE start_stop
'
' R‚glage des pages START/STOP
'
titre("D‚finition des pages START & STOP")
adr%=startstop.adr%
set_edit(3,start_page$)
set_edit(4,stop_page$)
set_edit(5,error_page$)       ! Fatal error
set_edit(8,sysop_page$)       ! Page VDT sysop
set_edit(9,STR$(sysop_maxlong&)) ! Longueur max messages sysop!
FOR l1&=0 TO 9
set_edit(12+l1&,off_vdt$(l1&))
NEXT l1&
set_state(22,off_vdt_mode|,0,1)
set_state(23,1-off_vdt_mode|,0,1)
affiche_rsc
IF b%=24                      ! Si confirm‚
start_page$=FN edit$(3)
stop_page$=FN edit$(4)
error_page$=FN edit$(5)
sysop_page$=FN edit$(8)
sysop_maxlong&=VAL(FN edit$(9))
IF sysop_maxlong&>38
sysop_maxlong&=38         ! Longueur max max!
ENDIF
FOR l1&=0 TO 9
off_vdt$(l1&)=FN edit$(12+l1&)
NEXT l1&
off_vdt_mode|=FN selected(22)
enable_maj(10)                 ! On a modifi‚ le fichier DIVERS
ENDIF
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE supp_aff
supp_page(4,aff$,nbn_aff&,nb_aff&,nom_aff$(),info_aff|(),alpha_aff$(),first_aff&)
RETURN
> PROCEDURE supp_arbo
supp_page(2,arbo$,nbn_arbo&,nbp_arbo&,nom_arbo$(),info_arbo|(),alpha_arbo$(),first_arbo&)
RETURN
> PROCEDURE supp_altern
POKE select_valid%,ASC("p")
supp_page(5,altern$,nbn_alt&,nbp_alt&,nom_alt$(),info_alt|(),alpha_alt$(),first_alt&)
POKE select_valid%,ASC("f")
RETURN
> PROCEDURE supp_base
supp_page(6,base$,nbn_base&,nb_base&,nom_base$(),info_base|(),alpha_base$(),first_base&)
RETURN
> PROCEDURE supp_page(type&,VAR nom$,nbn&,nbp&,nom$(),info|(),alpha$(),first_obj&)
LOCAL type$
'
' Supp page
'
s_title$="Suppression d'une "+tpage$(type&)
SELECT type&
CASE 3
type2$="a rubrique"
type$=" rubrique"
CASE 4
type2$="'affiche"
type$=" affiche"
CASE 6
type2$="a base"
type$=" base"
DEFAULT
type2$="a page"
type$=" page"
ENDSELECT
titre(s_title$)
sel_page_sup:
DEFMOUSE 0
select(s_title$,nom$,nbn&)
DEFMOUSE 2
IF b%=27                      ! Confirmation
g1$=FN edit$(26)              ! Nom page
g0&=FN find_page(g1$,nbp&,nom$()) ! Nø page
IF g0&=>0                     ! Si page dem exist
IF info|(g0&)=2               ! S'il page d‚ja ‚ffac‚e
ALERT 1,"Cette"+type$+" … d‚ja ‚t‚|‚ffac‚e !",1,"   OK   ",l1&
GOTO sel_page_sup
ENDIF
ALERT 2,"Voulez-vous vraiment|supprimer l"+type2$+":|"+g1$+" ?",2,"Effacer|Abandon",l1&
IF l1&=1                      ! Si valid
DEFMOUSE 2
info|(g0&)=2                  ! Signale ‚ffacement
FOR g0&=0 TO PRED(nbn&)
l1$=alpha$(g0&)
IF LEFT$(l1$,PRED(LEN(l1$)))=g1$
DELETE alpha$(g0&)
DEC nbn&
EXIT IF TRUE
ENDIF
NEXT g0&
enable_maj(type&)
ENDIF
ELSE
ALERT 1,"Cette"+type$+"|n'existe pas!",1,"   OK   ",void
GOTO sel_page_sup
ENDIF
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE supp_rub
supp_page(3,rub$,nbn_rub&,nb_rub&,nom_rub$(),info_rub|(),alpha_rub$(),first_rub&)
RETURN
> PROCEDURE supp_vdt
supp_page(1,vdt$,nbn_vdt&,nbp_vdt&,nom_vdt$(),info_vdt|(),alpha_vdt$(),first_vdt&)
RETURN
> PROCEDURE syntax_on_off(a$)
'
' V‚rif syntax ligne *** ON/OFF:
'
m1$=UPPER$(m1$)               ! Ligne en MAJ
l1|=INSTR(SUCC(m2|),m1$,"O")  ! Cherch un "O"
IF l1|=0                      ! Si aucun O
m1!=TRUE                      ! Erreur
m3|=m2|+2
m1$="Sp‚cifiez: "+a$+" ON / OFF"
ELSE                          ! Si on a trouv‚ un O
l1$=MID$(m1$,l1|+1,1)
IF l1$="N"                    ! Si ON
m1$=a$+SPACE$(10-LEN(a$))+"ON "
ELSE IF l1$="F"               ! Si OFF
m1$=a$+SPACE$(10-LEN(a$))+"OFF "
ELSE                          ! Sinon
m1!=TRUE                      ! Erreur
m3|=l1|
m1$="Sp‚cifiez: "+a$+" ON / OFF"
ENDIF
ENDIF
RETURN
> PROCEDURE syntax_n_d(a$)
'
' V‚rif syntax ligne *** N/D:
'
m1$=UPPER$(m1$)
l1|=RINSTR(m1|-1,m1$," ")
IF l1|=0
m1!=TRUE
m3|=m2|+2
m1$="Sp‚cifiez: "+a$+" Normal / Drcs"
ELSE
l1$=MID$(m1$,l1|+1,1)
IF l1$="N" OR l1$="D"
m1$=a$+SPACE$(10-LEN(a$))+l1$+" "
ELSE
m1!=TRUE
m3|=l1|
m1$="Sp‚cifiez: "+a$+" Normal / Drcs"
ENDIF
ENDIF
RETURN
> PROCEDURE syntax_val(a$,a|,b|)
'
' V‚rif syntax ligne *** nb:
'
l1$=RIGHT$(m1$,m1|-m2|-1)
l1=INT(VAL(l1$))
IF l1<a| OR l1>b|
m1!=TRUE
m3|=m2|+2
m1$="Valeur hors limites: "+STR$(a|)+"<x<"+STR$(b|)
ELSE
m1$=a$+SPACE$(10-LEN(a$))+STR$(l1)+" "
ENDIF
RETURN
> PROCEDURE syntax_xy(p.inst$,p.x_m&)
'
' V‚rif syntax ligne *** nb:
'
l1|=INSTR(SUCC(m2|),m1$,",")
IF l1|=0
m1!=TRUE                      ! Erreur.
m3|=m2|+2
m1$="Syntaxe obligatoire: "+p.inst$+" xx,yy"
ELSE
l1$=MID$(m1$,m2|+2,l1|-m2|-2)
l1%=VAL(l1$)
l1$=RIGHT$(m1$,m1|-l1|)
l2%=VAL(l1$)
IF l1%>0 AND l1%<=p.x_m& AND l2%=>0 AND l2%<25
m1$="LOCATE    "+STR$(l1%)+","+STR$(l2%)+" "
m1$=p.inst$+SPACE$(10-LEN(p.inst$))+STR$(l1%)+","+STR$(l2%)+" "
ELSE
m1!=TRUE                      ! Erreur.
m3|=m2|+2
m1$="Valeur hors limites: 1<x<"+STR$(p.x_m&)+" et 0<y<24"
ENDIF
ENDIF
RETURN
'
> PROCEDURE tester_vdt(VAR alpha$(),first_obj&)
'
' Test page VDT:
'
s_title$="Test d'une "+tpage$(1)
titre(s_title$)
test_vdt:
DEFMOUSE 0
select(s_title$,vdt$,nbn_vdt&)
DEFMOUSE 2
IF b%=27                      ! Si confirm
g1$=FN edit$(26)
g0&=FN find_page(g1$,nbp_vdt&,nom_vdt$()) ! Nø page dem
IF g0&=>0                     ! Si page dem exist
IF info_vdt|(g0&)=2         ! S'il s'agit d'une page ‚ffac‚e
ALERT 3,"Cette page … ‚t‚ ‚ffac‚e!|Voulez vous la voir ?",1,"Voir|Annuler",l1|
IF l1|=2
GOTO test_vdt
ENDIF
ENDIF
ptr&=1
vdt_test!=TRUE                ! Mode test
affiche_vdt(g0&)
vdt_test!=FALSE               ! Mode normal
l1$=INPAUX$
ELSE
ALERT 1,"La page demand‚e|n'existe pas...",1,"   OK   ",void
GOTO test_vdt
ENDIF
ENDIF
DEFMOUSE 0
~MENU_BAR(menu.adr%,1)
RETURN
'
> PROCEDURE verify_line
'
' V‚rif syntax ligne:
'
IF g1!                        ! Si ligne … ‚t‚ modifi‚e
m1!=FALSE                     ! Pas d'erreur
IF g8&<win_max%               ! Si on est pas sur la ligne max
IF g8&=nbl%
INC nbl%
editor$(nbl%)=" "
taille_asc
ENDIF
m1$=editor$(g8&)
m1|=LEN(m1$)
SELECT win_ed|
CASE 0                      ! V‚rif syntax pour vdt
IF m1$=" "                  ! Si ligne vide
effacement_ligne
CLR g1!                     ! Ligne valid‚e
g3!=TRUE                    ! Ligne ‚ffac‚e
ELSE
m3|=1
m2|=INSTR(m1$," ")-1
m2$=UPPER$(LEFT$(m1$,m2|))
IF m2$=""
m1!=TRUE
m1$="Le 1er caractŠre ne peut ˆtre un espace."
ELSE IF m2$=LEFT$("BELL",m2|) ! BELL
m1$="BELL "
ELSE IF m2$=LEFT$("CAN",m2|)  ! CAN
m1$="CAN "
ELSE IF m2$=LEFT$("CODE",m2|) ! CODE x
syntax_val("CODE",0,127)
ELSE IF m2$=LEFT$("CLS",m2|)  ! CLS
m1$="CLS "
ELSE IF m2$=LEFT$("CR",m2|)   ! CR
m1$="CR "
ELSE IF m2$=LEFT$("CSR",m2|)  ! CSR
syntax_on_off("CSR")
ELSE IF m2$=LEFT$("DOWN",m2|) ! DOWN
m1$="DOWN "
ELSE IF m2$=LEFT$("DEL.L",m2|) ! DEL.L
syntax_val("DEL.L",1,24)
ELSE IF m2$=LEFT$("DEL.C",m2|) ! DEL.C
syntax_val("DEL.C",1,80)
ELSE IF m2$=LEFT$("E.LIGNE",m2|) ! E.LIGNE
m1$="E.LIGNE "
ELSE IF m2$=LEFT$("E.LEFT",m2|) ! E.LEFT
m1$="E.LEFT "
ELSE IF m2$=LEFT$("E.PAGE",m2|) ! E.PAGE
m1$="E.PAGE "
ELSE IF m2$=LEFT$("E.PRED",m2|) ! E.PRED
m1$="E.PRED "
ELSE IF m2$=LEFT$("E.SUCC",m2|) ! E.SUCC
m1$="E.SUCC "
ELSE IF m2$=LEFT$("FLASH",m2|) ! FLASH
syntax_on_off("FLASH")
ELSE IF m2$=LEFT$("GRAPHMODE",m2|) ! GRAPHMODE
m1$="GRAPHMODE "
ELSE IF m2$=LEFT$("GFONT",m2|) ! GFONT
syntax_n_d("GFONT")
ELSE IF m2$=LEFT$("HOME",m2|) ! HOME
m1$="HOME "
ELSE IF m2$=LEFT$("INK",m2|)  ! INK
syntax_val("INK",0,7)
ELSE IF m2$=LEFT$("INSERT",m2|) ! INSERT
m1$="INSERT "
ELSE IF m2$=LEFT$("INSLINE",m2|) ! INSLINE
m1$="INSLINE "
ELSE IF m2$=LEFT$("INS.L",m2|) ! INS.L
syntax_val("INS.L",1,24)
ELSE IF m2$=LEFT$("INTENSE",m2|) ! INTENSE
syntax_on_off("INTENSE")
ELSE IF m2$=LEFT$("INVERSE",m2|) ! INVERSE
syntax_on_off("INVERSE")
ELSE IF m2$=LEFT$("LEFT",m2|) ! LEFT
m1$="LEFT "
ELSE IF m2$=LEFT$("LINE",m2|) ! LINE
syntax_on_off("LINE")
ELSE IF m2$=LEFT$("LINEMASK",m2|) ! LINEMASK
syntax_on_off("LINEMASK")
ELSE IF m2$=LEFT$("LOCATE",m2|) ! LOCATE
syntax_xy("LOCATE",40)
ELSE IF m2$=LEFT$("MASK",m2|) ! MASK
m1$="MASK "
ELSE IF m2$=LEFT$("MCAN",m2|) ! MCAN
m1$="MCAN "
ELSE IF m2$=LEFT$("MDOWN",m2|) ! MDOWN
syntax_val("MDOWN",1,23)
ELSE IF m2$=LEFT$("MFLASH",m2|) ! MFLASH
syntax_on_off("MFLASH")
ELSE IF m2$=LEFT$("MHOME",m2|) ! MHOME
m1$="MHOME "
ELSE IF m2$=LEFT$("MINVERSE",m2|) ! MINVERSE
syntax_on_off("MINVERSE")
ELSE IF m2$=LEFT$("MLEFT",m2|) ! MLEFT
syntax_val("MLEFT",1,79)
ELSE IF m2$=LEFT$("MLINE",m2|) ! MLINE
syntax_on_off("MLINE")
ELSE IF m2$=LEFT$("MLOCATE",m2|) ! MLOCATE
syntax_xy("MLOCATE",80)
ELSE IF m2$=LEFT$("MRESET",m2|) ! MRESET
m1$="MRESET "
ELSE IF m2$=LEFT$("MRIGHT",m2|) ! MRIGHT
syntax_val("MRIGHT",1,79)
ELSE IF m2$=LEFT$("MUP",m2|)  ! MUP
syntax_val("MUP",1,23)
ELSE IF m2$=LEFT$("NUL",m2|)  ! NUL
m1$="NUL "
ELSE IF m2$=LEFT$("OVERWRITE",m2|) ! OVERWRITE
m1$="OVERWRITE "
ELSE IF m2$=LEFT$("PAPER",m2|) ! PAPER
syntax_val("PAPER",0,7)
ELSE IF m2$=LEFT$("RIGHT",m2|) ! RIGHT
m1$="RIGHT "
ELSE IF m2$=LEFT$("REPEAT",m2|) ! REPEAT
syntax_val("REPEAT",0,63)
ELSE IF m2$=LEFT$("SIZE",m2|) ! SIZE
m1$=UPPER$(m1$)
l1|=RINSTR(m1|-1,m1$," ")
IF l1|=0
m1!=TRUE
m3|=m2|+2
m1$="Sp‚cifiez: SIZE Normal / High / Wide / Double"
ELSE
l1$=MID$(m1$,l1|+1,1)
IF l1$="N" OR l1$="H" OR l1$="W" OR l1$="D"
m1$="SIZE      "+l1$+" "
ELSE
m1!=TRUE
m3|=l1|
m1$="Sp‚cifiez: SIZE Normal / High / Wide / Double"
ENDIF
ENDIF
ELSE IF m2$=LEFT$("SUPLINE",m2|) ! SUPLINE
m1$="SUPLINE "
ELSE IF m2$=LEFT$("TEXT",m2|) ! TEXT
l1|=INSTR(SUCC(m2|),m1$,">")
IF l1|=0
m1!=TRUE                      ! Erreur
m3|=m2|+2
m1$="Syntaxe obligatoire: TEXT >blablabla<"
ELSE
l1$=MID$(m1$,l1|,42)
m1$="TEXT      "+l1$
IF RIGHT$(m1$,2)<>"< "
m1$=LEFT$(m1$,LEN(m1$)-1)+"< "
ENDIF
ENDIF
ELSE IF m2$=LEFT$("TELCODE",m2|) ! TELCODE
syntax_val("TELCODE",33,126)
ELSE IF m2$=LEFT$("TELGRAPH",m2|) ! TELGRAPH
m1$="TELGRAPH "
ELSE IF m2$=LEFT$("TELTEXT",m2|) ! TELTEXT
m1$="TELTEXT "
ELSE IF m2$=LEFT$("TFONT",m2|) ! TFONT
syntax_n_d("TFONT")
ELSE IF m2$=LEFT$("TEXTMODE",m2|) ! TEXTMODE
m1$="TEXTMODE "
ELSE IF m2$=LEFT$("UP",m2|)   ! UP
m1$="UP "
ELSE IF m2$=LEFT$("UNMASK",m2|) ! UNMASK
m1$="UNMASK "
ELSE IF m2$=LEFT$("*BALSTATE",m2|) ! BALSTATE
m1$="*BALSTATE "
ELSE IF m2$=LEFT$("*CLOCK",m2|) ! CLOCK
syntax_on_off("*CLOCK")
ELSE IF m2$=LEFT$("*DEFTEXT",m2|) ! DEFTEXT
syntax_n_d("*DEFTEXT")
ELSE IF m2$=LEFT$("*DEFGRAPH",m2|) ! DEFGRAPH
syntax_n_d("*DEFGRAPH")
ELSE IF m2$=LEFT$("*INTER",m2|) ! INTER
syntax_on_off("*INTER")
ELSE IF m2$=LEFT$("*ID",m2|)  ! ID
m1$="*ID "
ELSE IF m2$=LEFT$("*MIXTE",m2|) ! MIXTE
m1$="*MIXTE "
ELSE IF m2$=LEFT$("*PAGE",m2|) ! PAGE
m1$="*PAGE "
ELSE IF m2$=LEFT$("*PAUSE",m2|) ! PAUSE x
syntax_val("*PAUSE",0,60)
ELSE IF m2$=LEFT$("*PSEUDO",m2|) ! PSEUDO
m1$="*PSEUDO "
ELSE IF m2$=LEFT$("*RECALL",m2|) ! RECALL
m1$=UPPER$(m1$)
l1|=RINSTR(m1|-1,m1$," ")
IF l1|=0
m1!=TRUE
m3|=m2|+2
m1$="Sp‚cifiez: RECALL Text / Graphic"
ELSE
l1$=MID$(m1$,l1|+1,1)
IF l1$="T" OR l1$="G"
m1$="*RECALL   "+l1$+" "
ELSE
m1!=TRUE
m3|=l1|
m1$="Sp‚cifiez: RECALL Text / Graphic"
ENDIF
ENDIF
ELSE IF m2$=LEFT$("*RUB",m2|) ! RUB
m1$="*RUB "
ELSE IF m2$=LEFT$("*SCROLL",m2|) ! SCROLL
m1$="*SCROLL "
ELSE IF m2$=LEFT$("*SYSMSG",m2|) ! MIXTE
m1$="*SYSMSG "
ELSE IF m2$=LEFT$("*TOPLINE",m2|) ! TOPLINE
m1$="*TOPLINE "
ELSE IF m2$=LEFT$("*TPAPER",m2|) ! TPAPER
syntax_val("*TPAPER",0,7)
ELSE IF m2$=LEFT$("*VIDEOTEX",m2|) ! VIDEOTEX
m1$="*VIDEOTEX "
ELSE                          ! Commande inconnue
m1!=TRUE                      ! Erreur
m1$="Instruction inconnue!"
ENDIF
verify_line.aff
ENDIF
CASE 2                        ! V‚rif longueur <=38 car
verify_line.aff
CASE 1,3                        ! V‚rification syntaxe message systŠme
IF win_ed|=1
l3|=mc_long&+2
ELSE
l3|=5
ENDIF
l3$=TRIM$(m1$)
IF l3$=""                     ! Si ligne vide
effacement_ligne
CLR g1!                       ! Ligne valid‚e
g3!=TRUE                      ! Ligne ‚ffac‚e
ELSE
m2|=INSTR(l3$," ")
m3|=m2|
IF m2|=0                      ! Si on a trouv‚ aucun espace
m1!=TRUE
IF win_ed|=1                  ! mot clef
IF LEN(l3$)>mc_long&
m3|=SUCC(mc_long&)
m1$="S‚parez cl‚ et arbo!"
ELSE
m3|=mc_long&+2
m1$="Page Arbo obligatoire!"
ENDIF
ELSE                          ! message
IF LEN(l3$)>3
m3|=4
m1$="S‚parez le Nø et la page Vdt"
ELSE
m3|=5
m1$="Page Vid‚otex obligatoire!"
ENDIF
ENDIF
ELSE                            ! S'il y a des espaces ds la ligne!
m2$=UPPER$(LEFT$(l3$,PRED(m2|))) ! Num‚ro/mot clef
l1$=MID$(l3$,SUCC(m2|))          ! Suite de la ligne
l1|=LEN(m2$)
IF (l1|>3 AND win_ed|=3) OR l1|>mc_long&
m1!=TRUE                        ! Erreur
IF win_ed|=1
m1$="Mot cl‚: "+STR$(mc_long&)+" car max!"
ELSE
m1$="Num‚ro: 3 car maximum!"
ENDIF
ELSE
IF win_ed|=1
m1$=SPACE$(mc_long&+9)
ELSE
m1$=SPACE$(12)
ENDIF
LSET m1$=m2$                  ! Fixe nø
'
l2|=LEN(l1$)
l1$=TRIM$(l1$)
m2|=INSTR(l1$," ")
ADD m3|,m2|+l2|-LEN(l1$)
IF m2|=0                      ! Si plus d'espace!
l1|=LEN(l1$)
IF l1|>8
ADD m3|,SUCC(l1|)
m1!=TRUE
IF win_ed|=1
m1$="Nom page Arbo:8 car max!"
ELSE
m1$="Nom page Vdt: 8 car max!"
ENDIF
ELSE
MID$(m1$,l3|)=UPPER$(l1$)
m1$=TRIM$(m1$)+" "
ENDIF
ELSE                           ! Si encore des mots aprŠs
IF m2|>9
m1!=TRUE
IF win_ed|=1
m1$="Nom page Arbo:8 car max!"
ELSE
m1$="Nom page Vdt: 8 car max!"
ENDIF
ELSE
MID$(m1$,l3|)=UPPER$(LEFT$(l1$,PRED(m2|)))
l2$=TRIM$(MID$(l1$,SUCC(m2|)))
IF win_ed|=1 AND LEN(l2$)
m1!=TRUE
m3|=SUCC(RINSTR(l3$," "))
l3$=MID$(l2$,2,1)      ! Nø param
IF LEFT$(l2$)<>"Ý" OR MID$(l2$,3,1)<>":"
m1$="Format param: Ýx:..."
ELSE IF l3$<"0" OR l3$>"9"
INC m3|
m1$="Nø m‚moire entre 0 et 9!"
ELSE
m1!=FALSE         ! Pas d'erreur!
m1$=LEFT$(m1$+" "+LEFT$(l2$,3)+UPPER$(TRIM$(MID$(l2$,4))),p.w_car&)+" "
ENDIF
ELSE
m1$=LEFT$(m1$+" "+l2$,p.w_car&)+" "
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
verify_line.aff
ENDIF
ENDSELECT
ENDIF
ENDIF
RETURN
> PROCEDURE verify_line.aff
IF m1!                        ! Si erreur
deplace_curseur(m3|,g8&)
OUT 2,7
DEFTEXT 2                   ! Text rouge
TEXT l.x_g&,28*rez|+2*rm|,m1$
DEFTEXT 1
g2!=TRUE
ELSE
editor$(g8&)=m1$
PRINT AT(p.x_car&,g8&-g7&+5);normal.f$(l.in_bloc|);m1$;normal.f$(0);SPC(SUCC(p.w_car&-LEN(m1$)));
CLR g1!                     ! Ligne valid‚e
ENDIF
RETURN
'
> PROCEDURE window_edit(win_ed|,win_max%,p.test!,p.x_car&,p.w_car&)
LOCAL l.in_bloc|,l.screen.adr%,l.dirasc|,l.cursor!,l.exit!
LOCAL l.x_g&,l.l_g&,l.w_g&,l.r_g&,l.x_no&,l.x_ins&
'
' Edition d'une page, d'un texte...
'
handle%=WIND_CREATE(&X111000011,10,10,100,100) ! Cr‚ation fenetre
l1%=V:w_name$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
SWAP menu.adr%,edit_menu.adr%
~MENU_BAR(menu.adr%,1)
'
cls_2nd
DEFMOUSE 0
'
g7&=0                         ! Nø ligne en haut ‚cran
l.cursor!=TRUE                ! Curseur existe
l.insert|=1                   ! Mode insertion
g8&=0                         ! Pos Y csr
g9&=1                         ! Pos X csr
CLR g1!                       ! Mode LISTE
CLR g2!                       ! Pas de msg en haut ‚cran
CLR g3!                       ! Ligne n'a pas ‚t‚ ‚ffac‚e
CLR g5!                       ! Mode overligne
g10&=0                        ! Haut du bloc
g11&=TRUE                     ! Bas du bloc
g0!=TRUE                      ! On va "disable"
bloc_control
m_iena(-(edit_buff$(win_ed|)<>""),MKI$(33)+MKI$(34)+MKI$(35))
~MENU_IENABLE(menu.adr%,18,-p.test!) ! Disable/Enable Test
'
~WIND_CALC(0,&X111000011,l.l_g&,21*rez|+rm|*2,l.w_g&,172*rez|-rm|*2,x%,y%,w%,h%)
~WIND_OPEN(handle%,x%,y%,w%,h%) ! Dessine fen
window!=TRUE                  ! On a ouvert une fenˆtre
taille_asc                    ! Taille ascens
REPEAT                        ! Gest fenetre:
g0&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,mes.adr%,250,g1&,g2&,g3&,g4&,g5&,g6&)
l.dirasc|=BYTE(g5&)
IF BTST(g0&,4)           ! Event
SELECT evt&
CASE 10                       ! S‚lect menu
SELECT selection&
CASE 9                        ! Infos
ALERT 0,"Taille totale:   "+RIGHT$("   "+STR$(nbl%),4)+" lignes  |Taille bloc:     "+RIGHT$("   "+STR$(SUCC(g11&-g10&)),4)+" lignes  |Taille buffer:  "+RIGHT$("    "+STR$(LEN(edit_buff$(win_ed|))),5)+" octets  ",1,"   OK   ",void
CASE 18                       ! Tester
win_ed.test_page              ! Test page vdt
CASE 19                       ! Imprimer
imprime_fenetre
CASE 21 TO 23                 ! Valid,Aband,Sortir
verify_line                   ! V‚rif syntax ligne
l.exit!=NOT g1!               ! Sort si lifgne OK
validation|=23-selection&
CASE 25                       ! Haut
bloc_haut
CASE 26                       ! Bas
bloc_bas
CASE 27                       ! Pas de bloc
bloc_clear
CASE 29                       ! Rep‚rer
bloc_find
CASE 31                       ! Copier bloc
copy_bloc
CASE 32                       ! D‚placer
move_bloc
CASE 33                       ! Effacer
effa_bloc
CASE 35                       ! Remplir buff
buff_fill
CASE 36                       ! Copier buff
buff_copy(0)
CASE 37                       ! Sortir buff
buff_copy(1)
CASE 38                       ! Vider buff
buff_clear
ENDSELECT
~MENU_TNORMAL(menu.adr%,titre&,1) ! Efface titre s‚lect
CASE 20                       ! Redraw
affiche_texte                 ! Affich text et csr
CASE 21                       ! Demande activation fen
~WIND_SET(handle%,10,0,0,0,0)
CASE 22                       ! Bouton de sortie
verify_line                   ! V‚rif syntax ligne
l.exit!=NOT g1!               ! Sort si lifgne OK
validation|=FALSE
CASE 24                       ! FlŠches de d‚placement
SELECT message&(4)
CASE 0                        ! Page haut
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si la ligne est valide...
new_line_sets
page_up
ENDIF
CASE 1                        ! Page bas
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si la ligne est valide...
new_line_sets
page_down
ENDIF
CASE 2                        ! Ligne haut
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
IF g7&>0                      ! Si est pas au min
IF g8&=g7&+19                 ! Si csr hors ‚cran
scroll_up(1,PRED(g8&))
ELSE
scroll_up(g9&,g8&)
ENDIF
ENDIF
ENDIF
CASE 3                        ! Ligne bas
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
IF g7&<nbl%-19                ! Si on est pas au max
IF g8&=g7&                    ! Si csr hors ‚cran
scroll_down(1,SUCC(g8&))
ELSE
scroll_down(g9&,g8&)
ENDIF
ENDIF
ENDIF
ENDSELECT
CASE 26                       ! D‚placement de l'ascenseur...
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
g7&=message&(4)*(nbl%-19)/1000
g8&=g7&
g9&=1
affiche_texte
ENDIF
ENDSELECT
evt&=FALSE                    ! Evenement pris en compte
ENDIF
'
IF BTST(g0&,1)           ! Click de la souris
IF g6&=1                      ! Si bout gauch … ‚t‚ click‚
CLR g6&
IF g2&=>32*rez| AND g2&<192*rez| AND g1&=>l.x_g& AND g1&<=l.r_g&
g2&=g7&+g2&\(8*rez|)-4      ! Calcul pos Y csr
IF g2&>nbl%
g2&=nbl%
ENDIF
g1&=g1&\8-p.x_car&+2        ! Calcul pos X
l3&=LEN(editor$(g2&))
IF g1&>l3&
g1&=l3&
ENDIF
IF g2&<>g8&                 ! Si pos Y dem a chang‚
verify_line
IF g1!=FALSE                ! Si ligne ok
new_line_sets
deplace_curseur(g1&,g2&)
no_ligne
ENDIF
ELSE IF g1&<>g9&            ! Si pos X dem a chang‚
deplace_curseur(g1&,g2&)
ENDIF
ENDIF
ENDIF
ENDIF
'
IF BTST(g0&,0)                ! Event clavier (+ timer)
IF g4&=4                      ! Touche Ctrl active
SELECT l.dirasc|
CASE 1                        ! [Ctrl A]
validation|=1                 ! Abandon
l.exit!=TRUE
CASE 2                        ! [Ctrl B]
bloc_bas
CASE 8                        ! [Ctrl H]
bloc_haut
CASE 16                       ! [Ctrl P]
imprime_fenetre
CASE 19                       ! [Ctrl S]
verify_line                   ! V‚rif syntax ligne
l.exit!=NOT g1!               ! Sort si lifgne OK
CASE 20                       ! [Ctrl T]
IF p.test!
win_ed.test_page              ! Test page vdt
ENDIF
CASE 22                       ! [Ctrl V]
verify_line                   ! V‚rif syntax ligne
l.exit!=NOT g1!               ! Sort si lifgne OK
validation|=2                 ! Validation
DEFAULT
SELECT @scan(g5&)
CASE &H48                     ! [Ctrl F haut]
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
page_up
ENDIF
CASE &H50                     ! [Ctrl F bas]
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
page_down
ENDIF
CASE &H52                     ! [Ctrl Ins]
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
IF g8&<>nbl%                  ! Si pas sur dern ligne
IF nbl%<win_max%              ! Si ins possible
insertion_ligne
ELSE
ALERT 1,"Le nombre maximal|de lignes est atteint!",1,"   OK   ",void
ENDIF
ENDIF
ENDIF
CASE &H53                     ! [Ctrl Del]
win_ed.no_error
new_line_sets
effacement_ligne
CASE &H73                     ! [Ctrl F gauch]
deplace_curseur(1,g8&)
CASE &H74                     ! [Ctrl F droit]
deplace_curseur(LEN(editor$(g8&)),g8&)
DEFAULT                       ! Peut-ˆtre fnct bloc
IF g11&=>g10&                 ! Si bloc exist
SELECT l.dirasc|
CASE 3                        ! [Ctrl C]
copy_bloc
CASE 4                        ! [Ctrl D]
move_bloc
CASE 5                        ! [Ctrl E]
effa_bloc
CASE 14                       ! [Ctrl N]
bloc_clear
CASE 18                       ! [Ctrl R]
bloc_find
ENDSELECT
ELSE
SELECT l.dirasc|
CASE 3,4,5,14,18
ALERT 1,"Vous n'avez pas d‚fini|de bloc pour cette|op‚ration.",1,"  OUPS  ",void
ENDSELECT
ENDIF
ENDSELECT
ENDSELECT
ELSE IF g4&=8 AND l.dirasc|<>64 AND (l.dirasc|<91 OR l.dirasc|>93) ! Alt actif sans @,[,\,]
SELECT @ascii(g5&)
CASE 67                     ! [Alt C]
IF LEN(edit_buff$(win_ed|))
buff_copy(0)
ELSE
ALERT 1,"Le buffer est vide!",1,"  OUPS  ",void
ENDIF
CASE 73                     ! [Alt I]
ALERT 0,"Taille totale:   "+RIGHT$("   "+STR$(nbl%),4)+" lignes  |Taille bloc:     "+RIGHT$("   "+STR$(SUCC(g11&-g10&)),4)+" lignes  |Taille buffer:  "+RIGHT$("    "+STR$(LEN(edit_buff$(win_ed|))),5)+" octets  ",1,"   OK   ",void
CASE 82                     ! [Alt R]
IF g11&=>g10&
buff_fill
ELSE
ALERT 1,"Vous n'avez pas d‚fini|de bloc pour cette|op‚ration.",1,"  OUPS  ",void
ENDIF
CASE 83                     ! [Alt S]
IF LEN(edit_buff$(win_ed|))
buff_copy(1)
ELSE
ALERT 1,"Le buffer est vide!",1,"  OUPS  ",void
ENDIF
CASE 86                     ! [Alt V]
IF LEN(edit_buff$(win_ed|))
buff_clear
ELSE
ALERT 1,"Le buffer est vide!",1,"  OUPS  ",void
ENDIF
ENDSELECT
ELSE
SELECT @scan(g5&)
CASE &HE                      ! Backsp
l1$=editor$(g8&)
l1|=LEN(l1$)
IF g9&<>1
win_ed.no_error
l2$=RIGHT$(l1$,l1|-g9&+1)
PRINT AT(p.x_car&+g9&-2,g8&-g7&+5);normal.f$(l.in_bloc|);l2$;normal.f$(0)'
editor$(g8&)=LEFT$(l1$,g9&-2)+l2$
DEC g9&
affiche_curseur
g1!=TRUE
ENDIF
CASE &H1C,&H72                ! Return ou enter.
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE AND g8&<nbl%       ! Si ligne ok
IF g3!=FALSE
l1&=SUCC(g8&)
IF l1&<g7&+20                   ! Si pas hors ‚cran
deplace_curseur(1,l1&)
no_ligne
ELSE                            ! Si hors ‚cran
scroll_down(1,l1&)
ENDIF
IF g5!
IF nbl%<win_max%
insertion_ligne
ELSE
ALERT 1,"Le nombre maximal|de lignes est atteint!",1,"   OK   ",void
CLR g5!
ENDIF
ENDIF
ELSE
CLR g3!,g5!
ENDIF
ENDIF
CASE &H48                     ! FlŠch haut
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                ! Si ligne ok
new_line_sets
IF g8&>0                    ! Si pas ligne min
l1&=PRED(g8&)               ! On monte d'une ligne
IF l1&=>g7&                 ! Si pas hors ‚cran
deplace_curseur(g9&,l1&)
no_ligne
ELSE                        ! Si hors ‚cran
scroll_up(g9&,l1&)
ENDIF
ENDIF
ENDIF
CASE &H4B                     ! FlŠch gauch
l1|=PRED(g9&)
IF l1|>0
deplace_curseur(l1|,g8&)
ENDIF
CASE &H4D                     ! FlŠche droit
l1|=SUCC(g9&)
IF l1|<=LEN(editor$(g8&))
deplace_curseur(l1|,g8&)
ENDIF
CASE &H50                     ! FlŠch bas
verify_line                   ! V‚rif syntax ligne
IF g1!=FALSE                  ! Si ligne ok
new_line_sets
IF g8&<nbl%                   ! Si pas sur ligne max
l1&=SUCC(g8&)                 ! On descend d'une ligne
IF l1&<g7&+20                 ! Si pas hors ‚cran
deplace_curseur(g9&,l1&)
no_ligne
ELSE                          ! Si hors ‚cran
scroll_down(g9&,l1&)
ENDIF
ENDIF
ENDIF
CASE &H52                     ! Ins
IF l.insert|
set_insert(FALSE)
ELSE
set_insert(1)
ENDIF
affiche_curseur
CASE &H53                     ! Del
l1$=editor$(g8&)
l1|=LEN(l1$)
IF g9&<>l1|
win_ed.no_error
l2$=RIGHT$(l1$,l1|-g9&)
PRINT AT(PRED(p.x_car&+g9&),g8&-g7&+5);normal.f$(l.in_bloc|);l2$;normal.f$(0)'
editor$(g8&)=LEFT$(l1$,g9&-1)+l2$
affiche_curseur
g1!=TRUE
ENDIF
DEFAULT                       ! Edit ligne
win_ed.no_error
l1$=editor$(g8&)
l2|=LEN(l1$)                   ! Long ligne
IF g8&<win_max% AND (l2|<=p.w_car& OR l.insert|=FALSE) ! Si pas sur ligne max ou ligne pleine
SELECT l.dirasc|
CASE 32 TO 126,129 TO 133,135 TO 140,144,146 TO 148,150,151,153 TO 155,156,158,171,172,180,181,221,225,241,246,248
IF g9&=l2|                     ! Si bout de ligne
IF l2|<=p.w_car&               ! Si on peut rajouter
editor$(g8&)=LEFT$(l1$,l2|-1)+CHR$(l.dirasc|)+" "
g1!=TRUE                       ! Mode ‚dit
ENDIF
ELSE                           ! Si int‚rieur de ligne
IF l.insert|                   ! Si mode ins
'
l2$=RIGHT$(l1$,l2|-g9&+1)
PRINT AT(PRED(p.x_car&+g9&),g8&-g7&+5);normal.f$(l.in_bloc|);CHR$(l.dirasc|);l2$;normal.f$(0);
editor$(g8&)=LEFT$(l1$,g9&-1)+CHR$(l.dirasc|)+l2$
'
ELSE
MID$(editor$(g8&),g9&,1)=CHR$(l.dirasc|)
ENDIF
g1!=TRUE                        ! Mode ‚dition.
ENDIF
deplace_curseur(g9&+1,g8&)
ENDSELECT
ENDIF
ENDSELECT
ENDIF
ENDIF
UNTIL l.exit!
IF validation|=FALSE          ! Si validation non pr‚cis‚e
ALERT 2,"|Voulez-vous valider|les modifications?",1,"Valider|Abandon",l1|
validation|=3-l1|
ENDIF
DEFMOUSE 2
~WIND_CLOSE(handle%)          ! Ferme la fenetre.
~WIND_DELETE(handle%)         ! Efface la fenetre de la m‚moire.
window!=FALSE                 ! Il n'y a plus de fenˆtre
titre(s_title$)
SWAP menu.adr%,edit_menu.adr%
RETURN
> PROCEDURE win_ed.no_error
IF g2!
TEXT l.x_g&,28*rez|+2*rm|,SPACE$(p.w_car&-5)
CLR g2!
ENDIF
RETURN
> PROCEDURE win_ed.test_page
'
' Code & Teste simultan‚ment une page VDT:
'
verify_line                   ! V‚rif syntax ligne
efface_curseur
DEFMOUSE 2
IF g1!=FALSE                  ! Si ligne ok
code_vdt(0,PRED(nbl%),TRUE)   ! Codage & Test page
ENDIF
DEFMOUSE 0
affiche_curseur
RETURN
'
' *********************************
' *** Proc‚dures d'exploitation ***
' *********************************
'
> PROCEDURE acces
'
' Gest page ACCES:
'
PRINT AT(29,7);"Fonction: Image";
PRINT AT(3,14);"En cours:"'
aff_page_1(page_v&,TRUE)      ! Aff page VDT
PRINT AT(13,14);"Contr“le d'accŠs.";SPC(20);
g1!=FALSE                     ! Pour l'instant, pas de refus
m1&=VAL(parametre$(1))        ! Etat bout validation
IF BTST(m1&,0)                ! Heure
l1$=TIME$
l1%=VAL(LEFT$(l1$,2))*60+VAL(MID$(l1$,4,2))
l2%=VAL(LEFT$(parametre$(2),2))*60+VAL(MID$(parametre$(2),3,2))
l3%=VAL(LEFT$(parametre$(3),2))*60+VAL(MID$(parametre$(3),3,2))
IF l2%<=l3%
IF l2%>l1% OR l3%<l1%
g1!=TRUE
ENDIF
ELSE
IF l1%>l3% AND l1%<l2%
g1!=TRUE
ENDIF
ENDIF
IF g1!=TRUE
page_msgsys(6)                 ! Tranche horaire incorrecte.
ENDIF
ENDIF
IF BTST(m1&,1)                ! Lvls min
IF g1!=FALSE
test_level(parametre$(4))
IF m1|<11
page_msgsys(5)                 ! Levels insuffisants
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,2)                ! Lvls definis
IF g1!=FALSE
IF levels$<>parametre$(5)
page_msgsys(4)                 ! Levels incorrects
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,3)                ! Tps cnx min
IF g1!=FALSE
IF (TIMER-debut%)\12000<VAL(parametre$(6))
page_msgsys(3)                 ! Dur‚e de cnx insuffisante.
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,4)                ! Tps cnx total min
IF g1!=FALSE
IF nb_sec%/60+(TIMER-debut%)/12000<VAL(parametre$(7))
page_msgsys(2)                 ! Tps total cnxs insuffisant
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,5)                ! Nb cnx min
IF g1!=FALSE
IF nb_cnx%<VAL(parametre$(8))
page_msgsys(1)                 ! Nb de cnxs insuffisant
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,6)                ! Minitel 2
IF g1!=FALSE
IF mi2!=FALSE
page_msgsys(10)                 ! Minitel 2 obligatoire
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,7)                ! Minitel bistandard
IF g1!=FALSE
IF bi!=FALSE
page_msgsys(10)                 ! Minitel bistandard obligat
g1!=TRUE
ENDIF
ENDIF
ENDIF
IF BTST(m1&,8)                ! Accord sysop
IF g1!=FALSE
l0|=1
page_msgsys(7)                  ! Demande d'accŠs en cours
PRINT AT(3,17);"Accord du sysop: 10";
OUT 1,27,59,96,90,83                  ! Stoppe prise => modem
WHILE LEN(INKEY$)                     ! Vide buff clavier
WEND
g1!=TRUE
FOR m1&=9 DOWNTO 0                    ! Boucle d'appel sys
OUT 1,7                               ! BEEP local
m1%=TIMER
REPEAT                                ! Boucle de tempo 1 sec
IF LEN(INKEY$)>0
g1!=FALSE
ENDIF
UNTIL TIMER-m1%>200 OR g1!=FALSE
EXIT IF g1!=FALSE
PRINT AT(20,17);m1&'
NEXT m1&
OUT 1,27,59,97,90,83        ! Installe prise => modem
IF g1!                      ! Si on a r‚pondu … l'appel
page_msgsys(8)                ! AccŠs refus‚
ELSE
page_msgsys(9)                ! AccŠs accord‚
ENDIF
ENDIF
ENDIF
IF g1!
page_a$=parametre$(10)        ! Page de refus
enregistre(52,"Refus‚")
ELSE
page_a$=parametre$(9)         ! Page accŠs autoris‚
enregistre(52,"Accord‚")
ENDIF
RETURN
> PROCEDURE add_car_msg
'
' Addition d'un caractŠre au message en cours d'‚dition:
'
MID$(ligne$(g3|),g2|,1)=l1$
m2|=ligne|(g3|)
IF g2|>m2|                    ! Si on allonge la ligne
ligne|(g3|)=g2|               ! long
IF g2|>m2|+1 AND g1!          ! S'il y a des Fills … ‚ffacer
loc(SUCC(m2|),y|(7)+g3|)
PRINT #99,g5$;
envoi_chaine(MID$(ligne$(g3|),SUCC(m2|),g2|-m2|))
ELSE
PRINT #99;l2$;
ENDIF
ELSE                          ! Si on est dans la ligne
PRINT #99;l2$;
ENDIF
IF g2|=40                   ! Si on est en bout de ligne normale
IF g3|<nb_lignepage|
INC g3|
g2|=1
ELSE IF g3&<nb_pagemsg|     ! Si derniŠre ligne et pas dern page
IF edimod!                  ! SI mode TDT
l2|=RINSTR(ligne$(g3|)," ")   ! Position dern espace ligne
IF l2|<40 AND l2|<>0          ! Si il faut d‚caler mot
l3|=40-l2|                    ! Longr du mot
word_trans$=MID$(ligne$(g3|),l2|+1,l3|) ! mot … reporter
loc(l2|,y|(7)+g3|)            ! Pos csr sur ce mot
PRINT #99;g5$;g1$;            ! Effacement du 1er car...
OUT 1,18,64+l3|,8             ! ...jusqu'en fin de ligne
MID$(ligne$(g3|),l2|+1,l3|)=SPACE$(l3|) ! Efface logiquemt
ligne|(g3|)=PRED(l2|)         ! New long ligne du haut
ENDIF
ENDIF
cd$="SUITE"                 ! Page suivante
ELSE                        ! Si derniŠre page
OUT 1,8
ENDIF
ELSE
INC g2|
ENDIF
RETURN
> PROCEDURE aff_attente
PRINT AT(19,6);CHR$(27);"p ATTENTE DE CONNEXION ";
PRINT AT(13,19);" Appuyez sur CONTROL+S pour Sortir ";CHR$(27);"q";
RETURN
> PROCEDURE aff_compteurs
l1&=59*rez|+rm|
l2&=92*rez|+rm|
l3&=99*rez|+rm|
l4&=132*rez|+rm|
BOX 112,l1&,351,l2&
BOX 112,l3&,351,l4&
LOCATE 16,9
PRINT USING "Nombre d'appels:       #####",today_nbapp%
LOCATE 16,11
PRINT USING "Nombre de connexions:  #####",today_nbcnx%
LOCATE 16,14
PRINT USING "Total des connexions:  #####",nb_appels%
LOCATE 16,16
PRINT USING "Dur‚e totale:  ##### h ## mn",d_totale%\3600,(d_totale% MOD 3600)\60
RETURN
> PROCEDURE aff_down
'
' Descend 1 ligne dans aff:
'
loc(1,24)
aff_ligne(g2&-22)
IF LEN(m2$)<g1| OR mixt!
OUT 1,10
ENDIF
RETURN
> PROCEDURE aff_expl_mc
'
' Aff mot clef lors d'explore:
'
IF INP(-1)=FALSE
OUT 1,20
loc(1,2)
OUT 1,27,93
PRINT #99;SUCC(expl1&);
OUT 1,27,92,24,13,10,27,93
PRINT #99;mot$(expl1&);
OUT 1,27,92,24,13,10,27,93
PRINT #99;page$(expl1&);
OUT 1,27,92,24
ENDIF
RETURN
> PROCEDURE aff_expl_pa
'
' Affi page arbo lors d'explore:
'
IF INP(-1)=FALSE
OUT 1,20
loc(1,2)
OUT 1,27,93
PRINT #99;SUCC(expl1&);
IF info_arbo|(expl1&)=2
PRINT #99;" (Deleted!)";
ENDIF
OUT 1,27,92,24,13,10,27,93
PRINT #99;nom_arbo$(expl1&);
OUT 1,27,92,24,13,10,27,93
fnct(VAL(LEFT$(page_arbo$(expl1&),2))) ! Extract nø fnct
PRINT #99;g2$;
OUT 1,27,92,24
ENDIF
RETURN
> PROCEDURE aff_id
loc(1,1)
OUT 1,24
PRINT #99;"-SUP- ID:";
FOR l1&=1 TO 7
PRINT #99;CHR$(PRED(ASC(MID$(util_no2$,l1&,1))));
NEXT l1&
RETURN
> PROCEDURE aff_ligne(a|)
'
' Affiche 1 ligne d'aff:
'
IF a|<g4|
m1$=ligne_aff$(aff|,a|)       ! ligne … afficher
PRINT #99;ligne$(g5|);
envoi_chaine(LEFT$(m1$,g3|))  ! Aff pseudo
PRINT #99;g2$;ligne$(2+g5|);
m2$=MID$(m1$,17,g1|)
envoi_chaine(m2$)             ! Aff texte
IF LEN(m2$)<g1| OR mixt!
can
ENDIF
ELSE
m2$=""
can
ENDIF
IF g5|=FALSE
g5|=1
ELSE
g5|=0
ENDIF
RETURN
> PROCEDURE aff_up
'
' Monte 1 ligne dans aff:
'
loc(1,1)
IF mixt!
OUT 1,27,91,76
ELSE
OUT 1,11
ENDIF
aff_ligne(g2&)
RETURN
> PROCEDURE aff_temps_cnx
l1%=(TIMER-phys_deb%)\200     ! Total sec depuis d‚but cnx
l1|=l1%\3600                  ! Heures
l2|=(l1%\60) MOD 60           ! Minutes
l3|=l1% MOD 60                ! Secondes
PRINT AT(60,4);l1|;"h ";RIGHT$("0"+STR$(l2|),2);"mn ";RIGHT$("0"+STR$(l3|),2);
RETURN
> PROCEDURE affiche
'
' Gest page AFFICHE:
'
PRINT AT(29,7);"Fonction: Fond";
PRINT AT(3,14);"En cours: [paramŠtres].";
PRINT AT(3,12);"Affiche:  ";
affiche$=parametre$(4)        ! Nom aff
IF affiche$=""                ! Si pas d'aff
exit|=6                       ! Erreur: aff n'exist pas
ELSE
IF nb_aff&                    ! S'il exist des aff
FOR aff|=0 TO PRED(nb_aff&)   ! Cherche l'aff
EXIT IF nom_aff$(aff|)=affiche$ AND info_aff|(aff|)<>2
NEXT aff|
IF aff|=nb_aff&                 ! Si aff n'exist pas
exit|=6                         ! Erreur
ENDIF
ELSE
exit|=6                         ! Erreur
ENDIF
ENDIF
IF exit|
GOTO fin_aff
ENDIF
PRINT affiche$;               ! Affich nom aff
g6|=SUCC(param_aff|(aff|,1))*40 !Nb col
IF g6|>40 AND bi!=FALSE         ! Si 80 col & minitel pas bistandard
page_msgsys(2)                 ! Minitel bistandard obligat
page_a$=parametre$(8)         ! Error page
GOTO fin_aff
ENDIF
test_level(parametre$(22))    ! Test lvl min ‚crit
IF m1|=11
g1!=TRUE                      ! Ecrit autoris‚e
ELSE
g1!=FALSE                     ! ecrit interdit
ENDIF
test_level(parametre$(23))    ! Test lvls min censure
IF m1|=11
g3!=TRUE                      ! Ecrit autoris‚e
ELSE
g3!=FALSE                     ! ecrit interdit
ENDIF
g2!=-VAL(parametre$(12))      ! Scroll autoris‚.
g1$=CHR$(VAL(parametre$(11))) ! Filler
IF LEN(parametre$(10))
g2$=CHR$(VAL(parametre$(10))) ! S‚parateur
ELSE
g2$=""
ENDIF
l1|=VAL(parametre$(19))       ! Type de limitation de nb de lignes
SELECT l1|
CASE 1
g6&=VAL(parametre$(20))       ! Nb lignes
CASE 2
g6&=VAL(MID$(levels$,SUCC(VAL(parametre$(21))),1)) ! Nbl d‚fini ds levels
DEFAULT
g6&=TRUE                      ! Illimit‚
ENDSELECT
g3|=VAL(parametre$(9))        ! Long pseu
g1|=g6|-g3|-LEN(g2$)+(g6|=80) ! Long edit
g2|=param_aff|(aff|,0)        ! Nb lignes max
g4|=param_aff|(aff|,2)        ! Nb lignes existantes
g5|=0                         ! Couleur 0/1
x|(1)=g3|+LEN(g2$)+1
IF g6|=40                     ! Si 40 col
decode_attrib(0,parametre$(13))
ligne$(0)=l1$
decode_attrib(0,parametre$(15))
ligne$(1)=l1$
decode_attrib(0,parametre$(14))
ligne$(2)=l1$
decode_attrib(0,parametre$(16))
ligne$(3)=l1$
scroll                        ! Mode rouleau
ELSE                          ! Si 80 col
ligne$(0)=e80$+"7m"
ligne$(1)=e80$+"7m"
ligne$(2)=e80$+"27m"
ligne$(3)=e80$+"27m"
PRINT AT(13,14);"Passage du minitel en mode mixte.   ";
mixte
ENDIF
aff_page_1(page_v&,FALSE)
PRINT AT(14,8);"nø2: ";
g3&=-2
page_v$=parametre$(1)         ! Nom page vdt lect
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_aff
ENDIF
PRINT AT(29,8);"Fonction: Lecture."
g3&=page_v&
PRINT AT(14,9);"nø3: ";
g4&=-2
page_v$=parametre$(2)         ! Nom page vdt ecri
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_aff
ENDIF
PRINT AT(29,9);"Fonction: Ecriture."
g4&=page_v&
PRINT AT(14,10);"nø4: ";
g5&=-2
page_v$=parametre$(3)         ! Nom page vdt scroll
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_aff
ENDIF
PRINT AT(29,10);"Fonction: Scroll."
g5&=page_v&
g2&=22                        ! Ligne en haut de l'‚cran
PRINT AT(13,14);"Affichage de l'affiche.";SPC(12);
FOR m1&=1 TO 23
l1|=23-m1&
loc(1,m1&)
aff_ligne(l1|)
NEXT m1&
'
aff_page_1(g3&,FALSE)
'
DO
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,TIMER,0,5,6,41,41,41,41,7,41,41,"","")
EXIT IF LEN(page_a$)
IF cd$="ANNULATION"           ! Effacement d'une ligne
IF g3!                        ! Si censure autoris‚e
IF g2&<g4|+22
INC g2&
aff_up
DEC g2&
IF g4|>1
FOR l1|=g2&-22 TO g4|-2       ! D‚cale lignes
ligne_aff$(aff|,l1|)=ligne_aff$(aff|,SUCC(l1|))
NEXT l1|
ENDIF
ligne_aff$(aff|,PRED(g4|))=""
info_aff|(aff|)=1
DEC g4|                       ! 1 ligne de -
DEC param_aff|(aff|,2)
aff_page_1(g5&,FALSE)
ELSE
page_msgsys(9)                 ! Il n'y a pas de ligne
ENDIF
ELSE
page_msgsys(8)                 ! Commande r‚serv‚e
ENDIF
ELSE IF cd$="RETOUR"
IF g2!                        ! Si scroll aut
IF g2&<g4|+21
INC g2&
aff_up
aff_page_1(g5&,FALSE)
ELSE
page_msgsys(3)                 ! PremiŠre ligne
ENDIF
ENDIF
ELSE IF cd$="SUITE"
IF g2!                        ! Si scroll aut
IF g2&>22
DEC g2&
aff_down
IF g2&=22                     ! si on est sur dern ligne
l1&=g3&                       ! page lecture
ELSE
l1&=g5&                       ! page scroll
ENDIF
aff_page_1(l1&,FALSE)
ELSE
page_msgsys(4)                 ! DerniŠre ligne
ENDIF
ENDIF
ELSE IF cd$="ENVOI"           ! Ecriture d'une ligne
IF g1!                        ! Si les levels suffisent
IF g2&=22                     ! Si on est bien sur la derniŠr ligne
m2!=FALSE                     ! Rien a r‚afficher
DO
IF g6&=TRUE OR param_aff|(aff|,3)<g6& ! Si on … le droit d'‚crire
m2!=TRUE                      ! Il faudra r‚afficher
y|(1)=24
loc(1,24)
PRINT #99;ligne$(g5|);
envoi_chaine(LEFT$(pseudo$+SPACE$(16),g3|))  ! Aff pseudo
PRINT #99;g2$;ligne$(2+g5|);
init_champ(1,ligne$(2+g5|),g1|) ! Init + scroll(40 col)
IF g6|=80
OUT 1,32,10           ! Fill+Scroll (80 col)
ENDIF
y|(1)=23              ! On a mont‚
aff_page_1(g4&,FALSE)
DO                    ! Edit 1 ligne
loc(x|(1)+PRED(g0|),23)
PRINT #99;ligne$(2+g5|);
PRINT AT(13,14);"Ecriture d'une ligne dans l'affiche.";
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,TIMER,1,5,6,41,41,41,41,7,41,41,g1$,"")
EXIT IF LEN(page_a$)
IF cd$="ENVOI" OR cd$="SUITE"
'
' Valid d'une ligne:
'
IF LEN(TRIM$(g0$))            ! Si pas ligne vide
l1&=FN last_c(g0$)
IF l1&<g1|                    ! S'il fo bourrer
loc(x|(1)+l1&,23)
PRINT #99;ligne$(2+g5|);      ! Attrib
can                           ! Bourrage ligne
ENDIF
FOR l1|=PRED(g2|) DOWNTO 1    ! D‚cale lignes.
ligne_aff$(aff|,l1|)=ligne_aff$(aff|,PRED(l1|))
NEXT l1|
ligne_aff$(aff|,0)=LEFT$(pseudo$+SPACE$(15),16)+LEFT$(g0$,l1&)
info_aff|(aff|)=1
IF g4|<g2|                    ! Si aff pas encore pleine
INC g4|                       ! 1 ligne de +
INC param_aff|(aff|,2)
ENDIF
INC param_aff|(aff|,3)        ! Cnt … ‚crit 1 ligne de +
IF g5|=FALSE                  ! Permutation de couleur
g5|=1
ELSE
g5|=0
ENDIF
EXIT IF TRUE
ENDIF
ELSE IF cd$="RETOUR"          ! Annule ligne
IF g5|=FALSE
g5|=1
ELSE
g5|=0
ENDIF
aff_up
EXIT IF TRUE
ELSE IF cd$="ANNULATION"
init_champ(1,ligne$(2+g5|),g1|)
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
ELSE                          ! Pas le droit d'‚crire
page_msgsys(7)                 ! Nb maximum lignes atteint
EXIT IF TRUE
ENDIF
LOOP WHILE cd$="SUITE"
IF LEN(page_a$)=FALSE AND m2! ! Si on doit aff page lect
aff_page_1(g3&,FALSE)
ENDIF
ELSE
page_msgsys(5)                 ! Descendez sur la derniŠre ligne
ENDIF
ELSE                          ! lvls insuffisants
page_msgsys(6)                 ! Levels insuffisants
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
'
fin_aff:
IF g6|=80                     ! Si 80 col
PRINT AT(13,14);"Passage du minitel en mode vid‚otex.";
videotex
font_restore
ELSE                          ! Si 40 col
page
ENDIF
RETURN
> PROCEDURE affiche_msg(msg$,x_msg|,y_msg|,nbl|,width|,attrib$)
'
' Affichage d'un message:
'
' Notes:
' Lors de l'affichage d'un message rubrique/bal, le msg commence par
' un car nul ce qui provoque un positionnement.?
'
' 01.06.94: fplanque: modifi‚ pour traitement des textes ASCII
' 02.06.94: fplanque: d‚bugu‚ test de fin de message
' 10.06.94: fplanque: ajout‚ paramŠtres pour Xpos et Width
'
FOR ptr_msg&=ptr_msg& TO LEN(msg$)    ! Affiche cod/cod
EXIT IF INP(TRUE) AND msg_int!
IF INP(-2)                    ! Si clavier ST
l1$=INKEY$
l1|=ASC(l1$)
SELECT l1|
CASE 0                         ! Si touche de fnct
l2|=ASC(RIGHT$(l1$))
function_keys                 ! Touches g‚n‚rales
IF l2!=FALSE AND clav!        ! Si pas reconnue et emul clavier
key_trans$=key_trans$+CHR$(0)+CHR$(l2|)
EXIT IF msg_int!              ! Interruption d'aff
ENDIF
CASE 2,4,6,16                     ! Si touche pour ‚mulateur
key_trans$=key_trans$+CHR$(l1|)
EXIT IF msg_int!              ! Interruption d'aff
DEFAULT
IF clav!
key_trans$=key_trans$+CHR$(l1|)
EXIT IF msg_int!              ! Interruption d'aff
ELSE
kbd_l0_break                  ! Gest touches g‚n‚rales
ENDIF
ENDSELECT
ENDIF
'
l1|=ASC(MID$(msg$,ptr_msg&,1)) ! Code … afficher
'
IF l1|<=9 OR l1|=13            ! S'il faut positionner ( Ceci vaut pour 8 ou 9 pages MAXI, … voir )
affiche_msg_cr(x_msg|,y_msg|,nbl|,width|,attrib$)   ! Saute … la ligne
EXIT IF ptr_msg&=TRUE
ELSE IF l1|>=32                ! CaractŠre trŠs probablement affichable
IF car_count|=>width|
affiche_msg_cr(x_msg|,y_msg|,nbl|,width|,attrib$)   ! Saute … la ligne
EXIT IF ptr_msg&=TRUE
ENDIF
IF l1|<127                      ! CaractŠres standards
IF l1|=35 AND ptr_msg&<LEN(msg$)  ! Si on tombe sur un #: s‚quence ESC
l2|=ASC(MID$(msg$,ptr_msg&+1,1))
IF (l2|>63 AND l2|<74) OR (l2|>75 AND l2|<96 AND l2|<>91 AND l2|<>94)
OUT 1,27
INC ptr_msg&
l1|=l2|
ENDIF
ENDIF
OUT 1,l1|
INC car_count|
ELSE                            ! CaractŠres accentu‚s
code_accent(l1|)
PRINT #99;l1$;
INC car_count|
ENDIF
ENDIF
NEXT ptr_msg&
IF ptr_msg&=LEN(msg$)+1         ! Si on est arriv‚ … la fin du msg
old_ptr_msg&=TRUE             ! Sauve position
ptr_msg&=TRUE
ENDIF
RETURN
> PROCEDURE affiche_msg_cr(x_msg|,y_msg|,nbl|,width|,attrib$)
'
' 10.06.94: adapt‚ effacement de ligne … sa longueur effective
'
IF ptr_line&<nbl|             ! S'il fo pos dans le msg
loc(x_msg|,y_msg|+ptr_line&)
PRINT #99;attrib$;
IF width|=40
OUT 1,24
ELSE
OUT 1,32,18,63+width|
loc(x_msg|,y_msg|+ptr_line&)
PRINT #99;attrib$;
ENDIF
INC ptr_line&
car_count|=0                  ! Pour l'instant, 0 caractŠres sur la ligne
ELSE                          ! Si la ligne ne peut plus ˆtre affich‚e
old_ptr_msg&=ptr_msg&         ! Sauve position
ptr_msg&=TRUE
ENDIF
RETURN
> PROCEDURE alignement
'
' Test et alignement … gauche d'un mot coup‚:
'
m3$=CHR$(l1|)
IF l1|=32 AND edimod! AND g3|>1 ! Si Espace susceptible d'aligner(!)
m1$=ligne$(g3|)               ! M‚mo ligne courante
IF INSTR(m1$," ")=>g2|        ! Si c'est le 1er espace de la l.
m2|=ligne|(g3|)               ! Long ligne courante
m2$=ligne$(PRED(g3|))         ! M‚mo ligne du dessus
l2|=RINSTR(m2$," ")           ! Position espace au dessus
IF l2|<40 AND l2|<>0          ! Si il faut d‚caler mot
l3|=40-l2|                    ! Longr de partie haute
IF l3|+g2|<41                 ! S'il y a la place
l3$=MID$(m2$,l2|+1,l3|)       ! Partie haute
loc(l2|,y|(7)+PRED(g3|))      ! Pos csr en haut … droite
PRINT #99;g5$;g1$;            ! Effacement du 1er car...
OUT 1,18,64+l3|               ! ...jusqu'en fin de ligne
MID$(ligne$(PRED(g3|)),l2|+1,l3|)=SPACE$(l3|) ! Efface logiquemt
ligne|(PRED(g3|))=PRED(l2|)   ! New long ligne du haut
m1$=LEFT$(l3$+m1$,40)         ! Compo ligne du bas
m2|=m2|+l3|                   ! Long
envoi_chaine(LEFT$(m1$,m2|))  ! Aff ligne du bas
ligne$(g3|)=m1$
ligne|(g3|)=m2|
ADD g2|,l3|
loc(g2|,y|(7)+g3|)
PRINT #99;g5$;
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
'
> PROCEDURE bal_info
'
' Aff infos sur la BAL cnt:
'
PRINT AT(62,7);LEFT$(last_date$,6);RIGHT$(last_date$,2);" … ";LEFT$(last_time$,5);
PRINT AT(71,9);LEFT$(cree_date$,6);RIGHT$(cree_date$,2);
PRINT AT(71,11);nb_cnx%;      ! Affiche nb cnxs total
l1&=nb_sec%\3600              ! Heures
l1|=(nb_sec%\60) MOD 60       ! Minutes
PRINT AT(71,12);RIGHT$("000"+STR$(l1&),4);"h ";RIGHT$("0"+STR$(l1|),2);
PRINT AT(67,14);levels$;      ! Levels
PRINT AT(68,15);credits%'     ! Credits
LOCATE 77,17
SELECT info_rep|              ! Statut r‚p
CASE 0
PRINT "N";
CASE 1
PRINT "O";
CASE 2
PRINT "F";
CASE 3
PRINT "T";
ENDSELECT
PRINT AT(63,18);report_pseudo$; ! Report de BAL
RETURN
> PROCEDURE bals_ann
LOCAL l.mc_valid!
'
' Gest annuaire des bals:
'
PRINT AT(29,7);"Fonction: Fond de liste";
PRINT AT(3,14);"En cours: [paramŠtres].";
decode_attrib(1,parametre$(7))        ! Attributs x1
g3$=l1$
g1!=l1!
decode_attrib(1,parametre$(8))        ! Attributs x1'
g4$=l1$
decode_attrib(0,parametre$(10))       ! Attributs commande
g5$=l1$
l1&=VAL(parametre$(11))               ! Etat des boutons
x|(1)=VAL(parametre$(12))             ! Coord. X1 liste
IF BTST(l1&,0)                        ! Si x1' existe
x|(3)=VAL(parametre$(13))
ELSE
x|(3)=FALSE
ENDIF
IF BTST(l1&,1)                        ! Si x2 existe
x|(2)=VAL(parametre$(14))
g4|=2                                 ! 2 Colonnes
ELSE
x|(2)=FALSE
g4|=1                                 ! 1 Colonne
ENDIF
y|(1)=VAL(parametre$(15))             ! Coord. Y haut de liste
g2|=VAL(parametre$(16))               ! Nombre de lignes
g3|=VAL(parametre$(17))               ! Interligne
g1&=PRED(VAL(parametre$(18)))         ! Start
g2&=TRUE                              ! Aucun pseudo marqu‚
IF BTST(l1&,2)                        ! Si champ editable existe
x|(4)=VAL(parametre$(19))             ! Coord. X mot clef
y|(4)=VAL(parametre$(20))             ! Y
g1|=VAL(parametre$(21))               ! Longueur ‚ditable
g1$=CHR$(VAL(parametre$(22)))         ! Filler
g7$=parametre$(23)                    ! Pr‚fixe mot clef
IF BTST(l1&,3)                        ! Si valide
l.mc_valid!=TRUE
g7|=LEN(g7$)                          ! Longueur pr‚fixe
ELSE
g7|=FALSE
ENDIF
g8$=parametre$(24)                    ! Pr‚fixe ‚criture
IF BTST(l1&,4)                        ! Si valide
g8|=LEN(g8$)                          ! Longueur pr‚fixe
ELSE
g8|=FALSE
ENDIF
ELSE                                  ! S'il n'y a pas de champ d'entr‚e
x|(4)=FALSE
ENDIF
aff_page_1(page_v&,FALSE)
g0$=SPACE$(g1|)
g0|=1
g5|=1
g6|=0
g0!=FALSE
IF g1&=1                                ! Si on veut commencer sur le pseudo
IF info_bal|>1
m1$=UPPER$(pseudo$)
m1|=LEN(m1$)
GOTO cherche_pseu
ELSE
CLR g1&
ENDIF
ENDIF
DO
IF g5|<=g4| OR g6|<g2| AND g0!=FALSE  ! Si il faut afficher.
PRINT AT(13,14);"Affichage des pseudos         ";
FOR g5|=g5| TO g4|                    ! Parcourt les colonnes
FOR g6|=g6| TO PRED(g2|)              ! Parcourt les lignes
EXIT IF INP(TRUE)                       ! Sort si touche
l1&=g1&+g6|+(PRED(g5|))*g2|           ! Calcule num‚ro pseudo
IF x|(3)                              ! Si affichage num‚ros
loc(x|(g5|)-x|(3),y|(1)+g6|*g3|)
PRINT #99;g4$;RIGHT$("  "+STR$(l1&+1),3);
ENDIF
loc(x|(g5|),y|(1)+g6|*g3|)
PRINT #99;g3$;
OUT 1,32,18,79                        ! Efface l'emplacement
IF l1&<=nb_pseudos&                   ! Si on a pas d‚pass‚ la fin
loc(x|(g5|),y|(1)+g6|*g3|)
PRINT #99;g3$;
IF l1&=g2&                            ! Si le pseudo est "marqu‚"
OUT 1,27,93+g1!                       ! On le passe en vid‚o inver
ENDIF
envoi_chaine(pseudo$(l1&))            ! Affiche pseudo.
ENDIF
NEXT g6|
IF g6|=g2| AND g5|<g4|                ! Si on est en bas de colonne
g6|=FALSE                             ! On remonte
ENDIF
EXIT IF INP(TRUE)                     ! On sort si touche
NEXT g5|
IF x|(4)                              ! S'il y a un champ ‚ditable...
init_champ(4,g5$,g1|)
ENDIF
ENDIF
CLR g0!
loc(x|(4)+PRED(g0|),y|(4))
PRINT #99;g5$;
PRINT AT(13,14);"Attente d'une commande.       ";
PRINT AT(3,15);"Commande: ";
IF x|(4)
get_command(TRUE,TRUE,t%,1,2,3,41,41,41,41,4,41,41,g1$,"")
ELSE
get_command(TRUE,TRUE,0,0,2,3,41,41,41,41,4,41,41,"","")
ENDIF
EXIT IF LEN(page_a$)
IF cd$="RETOUR"               ! [RETOUR]
IF g1&>0                                ! Si on est pas sur le 1er pseudo
SUB g1&,g2|*g4|                         !
IF g1&<0                                ! Si on est avant le 1er pseudo
g1&=0
ENDIF
g5|=1                                   ! On reprend en d‚but de page
g6|=FALSE
ELSE                                    ! Si on est sur la 1Šre page
page_msgsys(4)                           ! PremiŠre page
ENDIF
ELSE IF cd$="SUITE"                     ! [SUITE]
IF g1&+g2|*g4|<nb_pseudos&              ! Si il reste des pseudos aprŠs
ADD g1&,g2|*g4|
g5|=1                                   ! On reprend en haut de page
g6|=FALSE
ELSE
page_msgsys(5)                           ! DerniŠre page
ENDIF
ELSE IF x|(4)
IF cd$="ANNULATION"
init_champ(4,g5$,g1|)
ELSE IF cd$="ENVOI"
g0$=TRIM$(g0$)
l1&=VAL(g0$)
IF l1&>0 AND l1&<=nb_pseudos& AND LEN(g0$)=LEN(STR$(l1&))
m1$=pseudo$(PRED(l1&))                      ! Destinataire
page_a$=parametre$(5)
ENDIF
IF g8| AND LEFT$(g0$,g8|)=g8$               ! Si on a demand‚ l'‚criture
m1$=MID$(g0$,g8|+1)                         ! Destinataire
page_a$=parametre$(5)
ENDIF
IF LEN(page_a$)
PRINT AT(3,17);"Destinataire demand‚: ";m1$;
trans$=CHR$(1)+m1$                          ! A transmettre
exit|=3
ELSE IF g7| AND LEFT$(g0$,g7|)=g7$          ! Si on a entr‚ un mot clef
g0$=MID$(g0$,g7|+1)
PRINT AT(3,17);"Mot clef dem.: ";g0$;SPC(40-LEN(g0$));
reco_clef(0)
ELSE
m1$=UPPER$(TRIM$(g0$))
m1|=LEN(m1$)
cherche_pseu:
PRINT AT(3,17);"Pseudo dem.: ";m1$;SPC(40-m1|);
l1&=nb_pseudos&
IF nb_pseudos&                      ! S'il y a des pseudos
WHILE m1|                           ! Tant qu'il y a une longueur
FOR l1&=0 TO PRED(nb_pseudos&)
EXIT IF m1$=UPPER$(LEFT$(pseudo$(l1&),m1|))
NEXT l1&
EXIT IF l1&<>nb_pseudos&
DEC m1|
m1$=LEFT$(m1$,m1|)
WEND
ELSE                                ! Si pas de pseudos
l1&=0                               ! On commence en haut
ENDIF
IF l1&<>nb_pseudos&
g2&=l1&
ELSE
l1&=0
g2&=TRUE
ENDIF
g1&=l1&
g5|=1
g6|=FALSE
ENDIF
IF page_a$=""
init_champ(4,g5$,g1|)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE break
'
' Affiche la boite de validation break:
'
adr%=break.adr%
IF info_bal|                  ! Si le connect‚ a (eu) une BAL
set_state(5,1,0,1)            ! Sauve BAL valide
set_state(6,0,0,1)
ELSE
set_state(5,0,1,1)            ! Sauve BAL imossible
set_state(6,0,1,1)
ENDIF
set_state(9,1,0,1)            ! Sauve rub valide
set_state(10,0,0,1)
~FORM_CENTER(break.adr%,x%,y%,w%,h%)
DEC x%
DEC y%
ADD w%,4
ADD h%,4
l.screen.adr%=XBIOS(3)        ! Ecran logique
RC_COPY l.screen.adr%,x%,y%,w%,h% TO screen.adr%,x%,y%
~OBJC_DRAW(break.adr%,0,7,x%,y%,w%,h%)
b%=FORM_DO(break.adr%,0)
RC_COPY screen.adr%,x%,y%,w%,h% TO l.screen.adr%,x%,y%
set_state(b%,0,0,0)
RETURN
'
> PROCEDURE change_key(p.ord&,p.specif&)
'
' Change l'affichage de la derniŠre touche utilis‚e
'
PRINT AT(key_pos&(key_ord&),21);key_name$(key_ord&);
key_ord&=p.ord&
IF p.ord&=10
key_name$(10)="<"+CHR$(p.specif&)+">"
ENDIF
IF p.ord&=9
PRINT AT(key_pos&(key_ord&)+p.specif&,21);cursor.c$(0);cursor.f$(0);CHR$(48+p.specif&);
ELSE
PRINT AT(key_pos&(key_ord&),21);cursor.c$(0);cursor.f$(0);key_name$(key_ord&)
ENDIF
PRINT normal.c$;normal.f$(0);
RETURN
> FUNCTION code_date(p.date$)
LOCAL l1%,l2%
l2%=(VAL(RIGHT$(p.date$,2))-80) MOD 100
l1%=SHL(l2%,9)
l2%=VAL(MID$(p.date$,4,2))
ADD l1%,SHL(l2%,5)
l2%=VAL(LEFT$(p.date$,2))
ADD l1%,l2%
RETURN (l1% AND &HFFFF)
ENDFUNC
> FUNCTION code_heure(p.heure$)
LOCAL l1%,l2%
l2%=VAL(LEFT$(p.heure$,2))
l1%=SHL(l2%,11)
l2%=VAL(MID$(p.heure$,4,2))
ADD l1%,SHL(l2%,5)
l2%=VAL(RIGHT$(p.heure$,2))
ADD l1%,SHR(l2%,1)
RETURN (l1% AND &HFFFF)
ENDFUNC
> PROCEDURE compact_msgpag
'
' Compact une page msg bal ou rub:
'
m1$=""
FOR m1|=1 TO nb_lignepage|    ! Parcourt lignes
m1$=m1$+LEFT$(ligne$(m1|),ligne|(m1|))+CHR$(0)
NEXT m1|
file$(g3&)=m1$                ! M‚mo de la page du msg
RETURN
> PROCEDURE cond_no_effect
'
' Signale une touche sans effet!
'
IF LEN(page_a$)=FALSE AND cd$<>"???" AND noeff_disable!=FALSE
page_msgsys(1)                 ! Touche sans effet
ENDIF
RETURN
'
> PROCEDURE decode_attrib(type|,string$)
'
' D‚code attributs:
'
l1$=""                                ! Re‡oit les atts format‚s
l1!=FALSE
IF LEN(string$)
FOR l1|=1 TO LEN(string$)               ! Formatage
l2$=MID$(string$,l1|,1)
l2|=ASC(l2$)
IF (l2|=>64 AND l2|<=73) OR l2|=76 OR l2|=77 OR l2|=92 OR l2|=93 OR ((l2|=77 OR l2|=78) AND type|=1)
l1$=l1$+CHR$(27)+l2$
IF l2|=93
l1!=TRUE
ENDIF
ENDIF
NEXT l1|
ENDIF
RETURN
> PROCEDURE delai
'
' Contr“le delai sans appui de touche
'
l1%=TIMER-deco%
IF l1%>36000 AND stade|=2
PRINT AT(78,4);"3";
msgsys("102")               ! D‚connexion
l0|=1
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
cd$="DELAI"
page_a$="x"
exit|=1
@deconnexion
ELSE IF l1%>30000 AND stade|=1
PRINT AT(78,4);"2";
msgsys("101")               ! D‚connexion ds 30 sec
stade|=2
l0|=1
ELSE IF l1%>24000 AND stade|=0
PRINT AT(78,4);"1";
msgsys("100")               ! Appuyez sur une touche!
stade|=1
keypress!=TRUE
l0|=1
ENDIF
RETURN
> PROCEDURE detruit_bal
'
' Destruction d'une BAL:
'
page_msgsys(3)                ! Destruction de BAL en cours
FOR l1&=0 TO PRED(nb_pseudos&)
EXIT IF pseudo$=pseudo$(l1&)
NEXT l1&
DELETE pseudo$(l1&)           ! Efface pseudo
DELETE code$(l1&)             ! Efface code
DEC nb_pseudos&               ! 1 pseu en -
info_list!=TRUE               ! On a modifi‚ list
DELETE bal_no%(l1&)           ! Efface nø BAL
INSERT bal_no%(nb_pseudos&)=bal_no& ! R‚serve ce nø pour proch BAL
info_bal|=1                   ! Statut BAL=effac‚e
raz_bal                       ! Init BAL
RETURN
> PROCEDURE dialogue
'
' Gest page DIALOGUE:
'
PRINT AT(29,7);"Fonction: Dialogue";  ! Fonction page VDT
PRINT AT(3,14);"En cours: [paramŠtres].";
PRINT AT(3,15);"Commande: ";
PRINT AT(60,24);"ES"
g1!=-VAL(parametre$(4))               ! GUIDE = APPEL SYS
y|(0)=VAL(parametre$(5))              ! Coord sys
y|(1)=VAL(parametre$(8))              ! Coord cnt
y|(2)=PRED(VAL(parametre$(6)))        ! Nb lignes sys
y|(3)=PRED(VAL(parametre$(9)))        ! Nb lignes cnt
decode_attrib(0,parametre$(7))        ! Atts sys
g4$=l1$
decode_attrib(0,parametre$(10))       ! Atts cnt
g5$=l1$
aff_page_1(page_v&,FALSE)
loc(1,y|(0))                          ! Aff csr sys
PRINT #99;g4$;                        ! Atts
OUT 1,127
loc(1,y|(1))                          ! Aff csr cnt
PRINT #99;g5$;                        ! Atts
OUT 1,127
g1|=1                                 ! Position csr cnt
g2|=0                                 ! Ligne cnt
g3|=1                                 ! Position csr sys
g4|=0                                 ! Ligne sys
g0|=2                                 ! Dernier aff: fenˆtre cnt
FOR l1|=0 TO 19
ligne$(l1|)=SPACE$(40)
ligne|(l1|)=0
NEXT l1|
IF VAL(parametre$(12))
GOTO appel_sys
ENDIF
DO
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
get_dialog(y|(1),y|(3),g5$,y|(0),y|(2),g4$)
PRINT AT(13,15);cd$;SPC(7);
EXIT IF LEN(page_a$)
IF cd$="SOMMAIRE"
page_a$=parametre$(1)
ELSE IF cd$="GUIDE"
IF g1!                        ! Si on veut appeller sys
appel_sys:
IF sysop|=1                   ! Si mode Appel
page_msgsys(2)                ! Appel du sysop en cours...")
PRINT AT(3,17);"Appel du sysop: 10";
OUT 1,27,59,96,90,83                  ! Stoppe prise => modem
WHILE LEN(INKEY$)                     ! Vide buff clavier
WEND
CLR m1!                               ! Pas encore r‚pondu … l'appel
FOR m1&=9 DOWNTO 0                    ! Boucle d'appel sys
OUT 1,7                               ! BEEP local
m1%=TIMER
REPEAT                                ! Boucle de tempo 1 sec
IF INP(TRUE)
get_command(TRUE,TRUE,deco%,0,1,41,41,41,41,41,2,41,41,"","")
EXIT IF LEN(page_a$)
IF cd$="GUIDE"
IF g1!=FALSE                          ! Si c pas pour appeller
page_a$=parametre$(3)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
ENDIF
IF LEN(INKEY$)>0 OR LEN(page_a$)
m1!=TRUE
ENDIF
UNTIL TIMER-m1%>200 OR m1!
EXIT IF m1!
PRINT AT(19,17);m1&'
NEXT m1&
OUT 1,27,59,97,90,83        ! Installe prise => modem
EXIT IF LEN(page_a$)
ELSE                          ! Mode Absent ou Pr‚sent
PRINT AT(3,17);"Test pr‚sence sys.";
m1!=(sysop|=2)
ENDIF
IF m1!
page_msgsys(3)                 ! Le sysop est l…
PRINT AT(22,17);"=> Pr‚sent.";
ELSE
page_msgsys(4)                 ! Le sysop est absent
PRINT AT(22,17);"=> Absent.";
ENDIF
g0|=0
ELSE
page_a$=parametre$(3)
ENDIF
ELSE IF cd$="REPETITION"
page_a$=parametre$(2)
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
upd_sys
RETURN
> PROCEDURE download(t1$,t2$)
'
' Emission prog
' adapt‚ de P. SAUCOURT-HAMMEL
'
IF topline|(1)                ! Si pendule active
clock%=TIMER+17280000         ! Prochain aff pendule ds 24h !
ENDIF
PRINT AT(13,14);"Attente de synchronisation.";SPC(17);
PRINT AT(3,15);"Nom du fichier    : ";t2$;
PRINT AT(3,16);"Taille du fichier :"
PRINT AT(3,17);"Temps de transfert:           Reste:";
PRINT AT(3,18);"Nombre de bloc(s) :           Reste:";
PRINT AT(3,19);"Nombre d'erreur(s): 0";
enregistre(10,"T‚l‚chargement de "+t2$)
key|(0)=65                    ! Ack
key|(1)=78                    ! Nack
m9%=FALSE                     ! Nb erreurs
teaser_down!=TRUE             ! On fait des allocations de m‚m download
rs232.adr%=MALLOC(1442)       ! Alloue 1442 oct pour RS
PAUSE 2
rs_out(rs232.adr%,1442)       ! Taille tampon RS out
tamp1.adr%=MALLOC(1080)
tamp2.adr%=MALLOC(1080)
OPEN "I",#1,t1$+t2$
m1%=LOF(#1)
IF m1%>0
PRINT AT(13,14);"Vidage du buffer de r‚ception.       ";
m2|=FALSE
WHILE INP(TRUE)               ! Vide buffer r‚ception
reception
EXIT IF m2|>2
WEND
m8%=TIMER
IF m2|<=2
PRINT AT(13,14);"Attente de synchronisation.";SPC(17);
REPEAT                        ! Attente synchro
OUT 1,1
reception
UNTIL m2|=1 OR m2|>2
IF m2|=1                      ! Si synchro
m8%=TIMER
PRINT AT(13,14);"Pr‚paration du header.     ";
PRINT AT(23,16);m1%;          ! Affich long fichier
duree_tel(m1%)
PRINT AT(23,17);TRIM$(l1$);   ! Affich dur‚e de t‚l‚char
PRINT AT(40,17);TRIM$(l1$);   ! Affich dur‚e restante
m2%=m1% MOD 1080
m3%=(m1%+1079)\1080
PRINT AT(23,18);m3%;          ! Affich nb blocs
PRINT AT(40,18);m3%;          ! Affich nb blocs restants
m1!=TRUE
PRINT AT(13,14);"Emission du header.     ";
header:
CLR m4%
emission_nom
emission(m3%/64)
emission(m3%)
emission(m2%/64)
emission(m2%)
m5%=m4%
emission(m5%/64)
emission(m5%)
IF m1!
m6%=(1080 AND (m2%=0 OR m3%>1))+(m2% AND m3%=1)
BGET #1,tamp1.adr%,m6%
ENDIF
PRINT AT(13,14);"Attente d'aquitement. ";
REPEAT
reception
UNTIL m2|
IF m2|=2                      ! Recep Nack
CLR m1!
INC m9%                       ! 1 erreur de +
PRINT AT(23,19);m9%;          ! Affich nb erreurs
GOTO header
ENDIF
IF m2|<=2                 ! Si pas d'Interrupt tel
m1!=TRUE
WHILE m3%>0 AND m2|<3
CLR m4%
PRINT AT(13,14);"Emission d'un bloc.   ";
PRINT AT(40,18);m3%'          ! Nb blocs restants
IF m2%
duree_tel((PRED(m3%))*1080+m2%)
ELSE
duree_tel(m3%*1080)           ! Calcul dur‚e restante
ENDIF
PRINT AT(40,17);TRIM$(l1$)'
emet_bloc(m6%,tamp1.adr%)
m5%=m4%
emission(m5%/64)
emission(m5%)
IF m3%>1 AND m1!
m7%=(1080 AND (m2%=0 OR m3%>2))+(m2% AND m3%=2)
BGET #1,tamp2.adr%,m7%
ENDIF
PRINT AT(13,14);"Attente d'aquitement. ";
REPEAT
reception
UNTIL INP(TRUE)=FALSE AND m2|   ! Attend acq et fin de buffer entr‚e
IF m2|=2                        ! Si re‡u Nack
CLR m1!
INC m9%                         ! 1 erreur de +
PRINT AT(23,19);m9%;            ! Affich nb erreurs
ELSE IF m2|=1
DEC m3%
IF m3%
BMOVE tamp2.adr%,tamp1.adr%,m7%
m6%=m7%
m1!=TRUE
ENDIF
ENDIF
WEND
ENDIF
m8%=(TIMER-m8%)\200
IF m2|=1
PRINT AT(40,18);0'
PRINT AT(40,17);"0:00 mn"'
enregistre(52,"OK (Dur‚e: "+STR$(m8%\60)+" mn)")
ELSE
enregistre(52,"Interrupt ("+STR$(m8%\60)+" mn)")
ENDIF
ELSE
enregistre(52,"Pas de synchro")
ENDIF
ELSE
enregistre(52,"Inter. imm‚diate")
ENDIF
ENDIF
CLOSE #1
libere
key|(0)=255                   ! no Ack
key|(1)=255                   ! no Nack
PRINT AT(3,13);SPC(40)
PRINT AT(13,14);SPC(45);
FOR l1|=15 TO 19
PRINT AT(3,l1|);SPC(50);
NEXT l1|
IF topline|(1)                ! Si pendule active
l2$=TIME$
clock%=TIMER+12000-VAL(RIGHT$(l2$,2))*200 ! Calcule prochain aff
ENDIF
RETURN
'
> PROCEDURE ecri_bal
LOCAL destinat$,text_msg$,nbpg_msg&
'
' Gest page ECRI_BAL:
'
PRINT AT(29,7);"Fonction: Demande pseudo"; ! Fnct page VDT
PRINT AT(3,14);"En cours: [paramŠtres].";
IF bal_envois|=20                     ! Si le cnt a d‚ja exp‚di‚ 20 msgs
page_msgsys(6)                        ! Maxi par cnx: 20 messages!
page_a$=parametre$(7)                 ! Page d'erreur
GOTO fin_ecri_bal                     ! On s'en va
ENDIF
IF LEFT$(trans$)=CHR$(6)              ! Si retour de guide
g2&=ASC(MID$(trans$,2,1))             ! Nø dest
dat$=MID$(trans$,3,10)
tim$=MID$(trans$,13,8)
g3&=ASC(MID$(trans$,21,1))            ! Page en cours
edimod!=PRED(ASC(MID$(trans$,22)))    ! Mode ‚dit
g2|=ASC(MID$(trans$,23,1))            ! Coord X csr
g3|=ASC(MID$(trans$,24,1))            ! Coord Y csr
g2$=MID$(trans$,25)                   ! Pseudo dest
GOTO bal_ecri
ENDIF
g0&=-2                                ! Nø pag r‚p
g1&=-2                                ! Nø pag new demande
x|(0)=VAL(parametre$(11))             ! Coord X pseu
y|(0)=VAL(parametre$(12))             ! Coord Y
g1|=16                                ! Long ‚dit
g1$=CHR$(VAL(parametre$(13)))         ! Filler
decode_attrib(0,parametre$(15))       ! Attrbs pseu
g4$=l1$
y|(1)=VAL(parametre$(14))             ! Coord y r‚p
decode_attrib(0,parametre$(16))       ! Attrbs r‚p
g5$=l1$
parametre$(42)=TRIM$(LEFT$(parametre$(10),8)) ! Sommaire
'
input_dest:
inp_aut_pseu(x|(0),y|(0),42,6,0)      ! Entr‚e du destinataire
'
IF LEN(page_a$)
GOTO fin_ecri_bal
ENDIF
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
g2$=pseudo$(m1&)                      ! Pseud destinataire
enregistre(10,"Destinataire: "+g2$)
IF g0&=-2                             ! Si on ne connait pas le nø de page rep
PRINT AT(14,8);"nø2: ";
page_v$=parametre$(1)                 ! Nom page rep
find_page                             ! Cherche  nø page
IF exit|                              ! Si erreur
GOTO fin_ecri_bal                     ! On s'en va
ENDIF
PRINT AT(29,8);"Fonction: Affiche r‚pondeur"; ! Fonction page VDT
g0&=page_v&                           ! M‚mo nø page
ELSE
IF g0&=TRUE
ptr&=TRUE
ELSE
ptr&=1
ENDIF
ENDIF
g2&=bal_no%(m1&)
IF g2&=bal_no&                        ! Si le destinataire est soi-mˆme
m3|=info_rep|
text_msg$=CHR$(0)+repondeur$+CHR$(2)+STRING$(rep_nbl|,CHR$(0))! R‚p affichable
m2$=report_pseudo$                  ! Pseudo de la BAL de report
ELSE
PRINT AT(13,14);"Chargement du r‚pondeur destinataire";
page_msgsys(5)                     ! Un instant S.V.P.
l1$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(g2&),4)
OPEN "I",#1,l1$                       ! Ouvre fichier BAL destin
SEEK #1,112
RECALL #1,file$(),3,void
CLOSE #1
m3|=VAL(file$(0))
text_msg$=CHR$(0)+file$(2)+CHR$(2)+STRING$(rep_nbl|,CHR$(0))! R‚p affichable
m2$=file$(1)
ENDIF
PRINT AT(3,17);"Status r‚p dest: ";
SELECT m3|                            ! Affichage du status r‚p
CASE 0
PRINT "N    ";
CASE 1
PRINT "O    ";
CASE 2
PRINT "F    ";
CASE 3
PRINT "T To:";
ENDSELECT
PRINT " ";m2$;                ! Report en BAL...
topline                       ! R‚affiche l0
IF m3|>0
aff_page_1(g0&,FALSE)
affiche_repondeur:            ! Affichage r‚p
'
PRINT AT(52,24);"I";          ! Impression possible
imprim_rep!=TRUE              ! En cas d'impression: imprimer r‚pondeur
nbpg_msg&=1                   ! 1 seule page
expedit$=g2$
destinat$="son r‚pondeur"
'
ptr_msg&=1                    ! Ptr d'affichage rep
ptr_line&=FALSE
msg_int!=TRUE                 ! Msg inter par d‚f
DO
IF ptr_msg&>0
PRINT AT(13,14);"Affichage du r‚pondeur destinataire.";
affiche_msg(1,text_msg$,y|(1),rep_nbl|,40,g5$)
ENDIF
PRINT AT(13,14);"Demande de confirmation d'‚criture. ";
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,0,0,42,41,41,41,41,41,41,41,41,"","")
IF cd$="ENVOI"
IF m3|=2                              ! Bal ferm‚e
page_msgsys(10)                       ! Cette BAL est ferm‚e
ELSE IF m3|=3                         ! Report de bal
FOR m1&=0 TO PRED(nb_pseudos&)        ! Recherche nø bal de report
EXIT IF UPPER$(pseudo$(m1&))=m2$
NEXT m1&
IF m1&<>nb_pseudos&                   ! Si BAL existe on s'en va
g2$=pseudo$(m1&)                    ! Pseud
g2&=bal_no%(m1&)
EXIT IF TRUE
ELSE
page_msgsys(11)                      ! Ecriture impossible
ENDIF
ELSE
EXIT IF TRUE
ENDIF
ELSE IF cd$="ANNULATION" OR cd$="CORRECTION" OR cd$="RETOUR"
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
IF g1&=-2                             ! Si on connait pas le nø de page
PRINT AT(14,9);"nø3: ";
page_v$=parametre$(2)                 ! Nom de la page vdt ‚criture
find_page                             ! Cherche nø de cette page
IF exit|                              ! Si erreur
GOTO fin_ecri_bal                     ! On s'en va
ENDIF
PRINT AT(29,9);"Fonction: Demande autre pseu"; ! Fnct page vdt
g1&=page_v&                           ! M‚mo nø de page
ELSE
page_v&=g1&
IF g1&=TRUE
ptr&=TRUE
ELSE
ptr&=1
ENDIF
ENDIF
PRINT AT(52,24);"-";          ! Impression impossible
imprim_rep!=FALSE
GOTO input_dest                         ! Demande d'un new pseud
ELSE IF cd$="SUITE"
ELSE IF cd$="REPETITION"
GOTO affiche_repondeur
ENDIF
IF LEN(page_a$)
PRINT AT(52,24);"-";          ! Impression impossible
imprim_rep!=FALSE
GOTO fin_ecri_bal
ENDIF
LOOP
PRINT AT(52,24);"-";          ! Impression impossible
imprim_rep!=FALSE
ENDIF
'
'
' *** Partie d'‚criture du message:
'
'
enregistre(10,"Ecriture d'un message")
dat$=DATE$
tim$=TIME$
edimod!=-VAL(parametre$(39))  ! Mode ‚dit
g3&=1                         ! Page en cours
FOR l1|=1 TO bal_nb_pagemsg|  ! Init pages
file$(l1|)=""
NEXT l1|
g2|=255                       ! Coord csr reste … d‚finir
bal_ecri:                     ! Arriv‚e lors d'un retour de guide
'
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
nb_maxmsg|=20                 ! Nb msg max qu'on peut envoyer
nb_pagemsg|=bal_nb_pagemsg|
nb_lignepage|=bal_nb_lignepage|
titre!=bal_titre!
no_msg$=RIGHT$("0"+STR$(SUCC(bal_envois|)),2) ! Nø du msg
destinat$="BAL "+g2$
'
edit_msg(0,g2$)               ! Edition du msg
'
IF page_a$=""                 ! S'il fo envoyer
page_msgsys(4)                ! Envoi du message en cours
g3$=pseudo$+CHR$(0)+dat$+CHR$(0)+tim$+CHR$(0)+STR$(nbpg_msg&)+file$(0) ! Header du msg
g3$=g3$+text_msg$
IF info_bal|=2                        ! Si le cnt … une bal
info_bal|=3                           ! La BAL aura ‚t‚ modifi‚e
ENDIF
INC bal_envois|                       ! le connect‚ a exp‚di‚ 1 msg de +
SUB nb_envoimsg|,(nb_envoimsg|<20)    ! Nombre de messages envoy‚s dans LST
INSERT msg_envoi$(0)=dat$+tim$+g2$+CHR$(0)+file$(0) ! R‚f msg envoy‚ dans LST
IF g2&=bal_no&                        ! Si le message est destin‚ … soi-mˆme
envoistate$=RIGHT$(envoistate$,19)+"R" ! Message re‡u
IF nb_balmsg|=20                      ! Si la BAL est pleine
DELETE msg_bal$(19)                   ! On efface le plus ancien msg
ELSE                                  ! S'il reste de la place en BAL
INC nb_balmsg|                        ! Un msg de plus en BAL
ENDIF
msg_bal$(PRED(nb_balmsg|))=g3$        ! Stocke msg en BAL
ELSE                                  ! Si le msg est destin‚ … un autre
envoistate$=RIGHT$(envoistate$,19)+"E" ! Msg envoy‚
msg_disk$(PRED(bal_envois|))=g3$       ! Msg … envoyer
ENDIF
page_a$=parametre$(9)
topline
ENDIF
fin_ecri_bal:
RETURN
> PROCEDURE ecri_rub
LOCAL destinat$,text_msg$,nbpg_msg&
'
' Gest page ECRI_RUB:
'
PRINT AT(3,14);"En cours: [paramŠtres].";
PRINT AT(3,8);"Rubrique: ";
rubrique$=parametre$(6)               ! Nom rub o— on ‚crit
real_name(rubrique$)          ! Si r‚f … une m‚m de page
enregistre(10,"Ecriture en rubrique: "+rubrique$)
find_rub                              ! Cherch nø rub
IF exit|                              ! Erreur
GOTO fin_ecri_rub
ENDIF
destinat$="rubrique "+rubrique$       ! Destinataire
nb_maxmsg|=param_rub|(rub|,0)         ! Nb msg max dans rub
nb_pagemsg|=param_rub|(rub|,1)        ! Nb pag max par msg
nb_lignepage|=param_rub|(rub|,2)      ! Nb lignes par pag
titre!=-BTST(param_rub|(rub|,3),0)    ! Titre?
nb_rubmsg|=param_rub|(rub|,4)         ! Nb msgs existants dans rub
'
IF LEFT$(trans$)=CHR$(8)              ! Si retour de guide
dat$=MID$(trans$,3,10)
tim$=MID$(trans$,13,8)
g3&=ASC(MID$(trans$,21,1))            ! Page en cours
edimod!=PRED(ASC(MID$(trans$,22)))    ! Mode ‚dit
g2|=ASC(MID$(trans$,23,1))            ! Coord X csr
g3|=ASC(MID$(trans$,24,1))            ! Coord Y csr
ELSE
dat$=DATE$
tim$=TIME$
edimod!=-VAL(parametre$(39))  ! Mode ‚dit
g3&=1                         ! Page en cours
FOR l1|=1 TO nb_pagemsg|     ! Init pages
file$(l1|)=""
NEXT l1|
g2|=255                       ! Coord csr reste … d‚finir
ENDIF
'
l2|=SUCC(nb_rubmsg|)          ! Nø qu'aura msg en ‚criture
IF l2|>nb_maxmsg|             ! Si nø sup au maxi
DEC l2|                       ! On effacera le 1er
ENDIF
no_msg$=RIGHT$("0"+STR$(l2|),2)
g2&=0                         ! Params ne servant que pour BAL
g2$=""
'
'
'
edit_msg(1,pseudo$)           ! Edition du msg
'
'
'
IF page_a$=""                 ! S'il fo envoyer
IF LEFT$(trans$)=CHR$(3) AND MID$(trans$,4)=rubrique$  ! S'il s'agit d'une r‚ponse
page_msgsys(5)                        ! Envoi de la r‚ponse
m1|=VAL(MID$(trans$,2,2))             ! Nø msg auquel on r‚pond
m1$=msg_rub$(rub|,m1|)                ! Msg auquel on r‚pond
m2|=VAL(MID$(m1$,19,2))               ! Nb r‚p … ce msg
MID$(msg_rub$(rub|,m1|),19,2)=RIGHT$("0"+STR$(SUCC(m2|)),2) ! 1 de plus
m2|=INSTR(m1$,CHR$(0),21)             ! Cherch fin du pseud
IF m2|                                ! Si on a trouv‚
INC m2|
ELSE
m2|=21
ENDIF
g3$=MID$(m1$,m2|,18)                  ! En-tˆte du message r‚ponse
trans$=""
ELSE                                  ! Si ce msg n'est pas une r‚ponse
page_msgsys(4)                        ! Envoi du message en cours
g3$=SPACE$(18)                        ! En-tˆte classique
ENDIF
g3$=g3$+"00"+pseudo$+CHR$(0)+dat$+tim$+STR$(nbpg_msg&)+file$(0) ! Header msg
g3$=g3$+text_msg$
'
IF nb_rubmsg|>nb_maxmsg|                ! S'il y a trop de msg dans rub
nb_rubmsg|=nb_maxmsg|                   ! On fait comme s'il y en avait -
param_rub|(rub|,4)=nb_maxmsg|           ! NEW
ENDIF
'
IF nb_rubmsg|<nb_maxmsg|              ! Si la rub n'est pas encore pleine
INC param_rub|(rub|,4)              ! Un msg de +
ENDIF
'
IF param_rub|(rub|,3)=3               ! Si on doit trier les messages
m1&=PRED(nb_rubmsg|)
FOR l1&=0 TO m1&
l2&=INSTR(msg_rub$(rub|,l1&),CHR$(0),21)+20
l3&=INSTR(msg_rub$(rub|,l1&),CHR$(1),l2&)
l1$=MID$(msg_rub$(rub|,l1&),l2&,l3&-l2&)  ! Titre du message
EXIT IF l1$>file$(0)
NEXT l1&
IF l1&<nb_rubmsg|                 ! S'il faut ins‚rer
FOR l2&=nb_rubmsg| DOWNTO SUCC(l1&)
msg_rub$(rub|,l2&)=msg_rub$(rub|,PRED(l2&))
NEXT l2&
ENDIF
msg_rub$(rub|,l1&)=g3$               ! Ecrit msg en rub
ELSE                                  ! S'il suffit d'ajouter … la fin
IF nb_rubmsg|=nb_maxmsg|              ! Si la rub est pleine
DEC nb_rubmsg|
FOR m1|=1 TO nb_rubmsg|               ! On ‚fface 1er msg
SWAP msg_rub$(rub|,PRED(m1|)),msg_rub$(rub|,m1|)   ! et on d‚cale
NEXT m1|
ENDIF
msg_rub$(rub|,nb_rubmsg|)=g3$         ! Ecrit msg en rub
ENDIF
'
'
info_rub|(rub|)=1                     ! Rub … ‚t‚ modif
page_a$=parametre$(9)
topline
ENDIF
fin_ecri_rub:
RETURN
> PROCEDURE edit_rep
LOCAL text_msg$,nbpg_msg&
'
' Gest page EDIT_REP:
'
IF info_bal|<2                ! Si cnt n'a pas de BAL
page_msgsys(6)                ! Vous n'avez pas de BAL
page_a$=parametre$(6)         ! Error page
GOTO fin_edi_rep
ENDIF
PRINT AT(3,14);"En cours: [paramŠtres].";
destinat$="son r‚pondeur"     ! Destinataire
IF LEFT$(trans$)=CHR$(10)     ! Si retour de guide
edimod!=PRED(ASC(MID$(trans$,22))) ! Mode ‚dit
g2|=ASC(MID$(trans$,23,1))    ! Coord X csr
g3|=ASC(MID$(trans$,24,1))    ! Coord Y csr
ELSE
edimod!=-VAL(parametre$(39))  ! Mode ‚dit
file$(1)=repondeur$
g2|=255                       ! Coord csr reste … d‚finir
ENDIF
dat$=SPACE$(10)
tim$=SPACE$(8)
g3&=1                         ! Page en cours
nb_pagemsg|=1                 ! Nb pag max par msg
nb_lignepage|=rep_nbl|        ! Nb lignes par pag
titre!=FALSE                  ! Pas de titre
g2&=0                         ! Params ne servant que pour BAL
g2$=""
'
edit_msg(2,pseudo$)           ! Edition du msg
'
IF page_a$=""                 ! S'il fo envoyer
IF info_rep|=0
page_msgsys(4)                ! Cr‚ation du r‚p en cours
info_rep|=1
PRINT AT(77,17);"O";          ! Signale cr‚ation rep … l'‚cran
ELSE
page_msgsys(5)                ! Modif du r‚pondeur en cours
ENDIF
repondeur$=file$(1)
info_bal|=3                   ! BAL modifi‚e
page_a$=parametre$(9)
topline
ENDIF
fin_edi_rep:
RETURN
> PROCEDURE edit_msg(a|,a$)
LOCAL l.page_ecri&,l.page_ecri2&,l.page_suiv&
LOCAL expedit$,no_msg_cour&,titre_msg$
no_msg_cour&=0                ! Bidon n‚cessaire pour "imprimer_msg"
'
' Edition d'un message Bal,Rub ou Rep:
' a|= 0:bal 1:rub 2:rep
'
edit_msg.parametres
expedit$=pseudo$
IF exit|=FALSE
'
' Pr‚pare ‚cran:
'
edit_msg_titre:
aff_page_1(l.page_ecri&,FALSE) ! Affiche ‚cran
PRINT AT(13,14);"Formatage message.";SPC(18);
FOR l2|=0 TO 5                ! Affichage des infos
IF x|(l2|)
loc(x|(l2|),y|(l2|))
PRINT #99;g4$;
SELECT l2|
CASE 0
envoi_chaine(a$)
CASE 1
PRINT #99;m1$;
CASE 2
PRINT #99;m2$;
CASE 3
IF edimod!
OUT 1,84
ELSE
OUT 1,86
ENDIF
CASE 4
PRINT #99;no_msg$;
CASE 5
PRINT #99;no_page$;
ENDSELECT
ENDIF
NEXT l2|
'
' Input du titre:
'
IF x|(6)                      ! S'il doit y avoir un titre
IF g2|=255                    ! Si pas encore d‚fini
init_champ(6,g5$,20)
g1|=20                        ! Longueur du titre
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
DO
loc(x|(6)+g0|-1,y|(6))
PRINT #99;g5$;
get_command(TRUE,TRUE,0,1,7,41,41,41,41,41,41,41,41,g1$,"")
EXIT IF cd$="ENVOI" OR LEN(page_a$)
IF cd$="REPETITION"
GOTO edit_msg_titre
ELSE IF cd$="ANNULATION"
init_champ(6,g5$,20)
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP
IF g2|
FOR l1&=20 DOWNTO 2
EXIT IF MID$(g0$,l1&,1)<>" " ! Sort qd on a trouv‚ fin de ligne
NEXT l1&
file$(0)=LEFT$(g0$,l1&)       ! M‚mo titre principal
ENDIF
ENDIF
IF LEN(page_a$)=FALSE
loc(x|(6),y|(6))
PRINT #99;g5$;
envoi_chaine(g0$)               ! Affiche titre
ENDIF
ELSE
file$(0)=" "                ! titre vide
ENDIF
'
IF LEN(page_a$)=FALSE
'
' Aff page de msg … ‚diter:
'
aff_page_1(l.page_ecri2&,FALSE) ! Affiche ‚cran
PRINT AT(13,14);"Affichage page de message.    ";
input_msg:
FOR l1|=1 TO nb_lignepage|    ! Init lignes msg
ligne$(l1|)=SPACE$(40)
ligne|(l1|)=0
NEXT l1|
m1$=file$(g3&)                ! Message compact‚
m1&=1                       ! 1er car 1Šre l
FOR m1|=1 TO nb_lignepage|    ! Parcourt lignes
m2&=INSTR(m1$,CHR$(0),m1&)    ! Cherch fin ligne
l1&=m2&-m1&
IF l1&<0
l1&=0
m2&=PRED(m1&)
ENDIF
IF LEN(word_trans$)            ! Si un mot saute d'1 page … l'autre
ligne$(1)=LEFT$(MID$(m1$,m1&,l1&)+word_trans$+SPACE$(39),40)
ligne|(1)=l1&+LEN(word_trans$)
IF ligne|(1)>40
ligne|(1)=40
ENDIF
word_trans$=""
ELSE
ligne$(m1|)=MID$(m1$,m1&,l1&)+SPACE$(40-l1&)
ligne|(m1|)=l1&
ENDIF
m1&=SUCC(m2&)
loc(1,y|(7)+m1|)
PRINT #99;g5$;                ! Attrbs
OUT 1,24                      ! Efface ligne
envoi_chaine(LEFT$(ligne$(m1|),ligne|(m1|))) ! Aff ligne
IF g1!                        ! Si filler
fill_champ(ligne|(m1|),40,g1$)
ENDIF
NEXT m1|
'
' Input message:
'
PRINT AT(13,14);"Edition du message.";SPC(18);
IF g2|=>254                   ! S'il fo d‚finir coord csr
IF g2|=255
g3|=1                         ! Coord Y
ELSE
g3|=nb_lignepage|
ENDIF
g2|=ligne|(g3|)+1             ! Coord X
ADD g2|,g2|=41
ENDIF
PRINT AT(3,15);"Commande:";
REPEAT
get_message
PRINT AT(13,15);cd$;SPC(10);
compact_msgpag                ! Compactage de la page
EXIT IF cd$="ENVOI" OR LEN(page_a$)
IF cd$="SOMMAIRE"
page_a$=parametre$(7)
ELSE IF cd$="GUIDE"
IF LEN(parametre$(8))
trans$=CHR$(5+2*a|)+curpage_a$+CHR$(0)+CHR$(g2&)+dat$+tim$+CHR$(g3&)+CHR$(1+edimod!)+CHR$(g2|)+CHR$(g3|)+g2$
page_a$=parametre$(8)
exit|=3
ENDIF
ELSE IF cd$="SUITE"
IF g3&<nb_pagemsg|
INC g3&
edit_msg.no_page
aff_page_1(l.page_suiv&,TRUE) ! Aff page VDT "SUIVANT"
g2|=255                       ! Il faut relocaliser le curseur
GOTO input_msg
ELSE
page_msgsys(3)                ! Nb Maximum de pages atteint
ENDIF
ELSE IF cd$="RETOUR"
IF g3&>1
DEC g3&
edit_msg.no_page
aff_page_1(l.page_suiv&,TRUE) ! Aff page VDT "SUIVANT"
g2|=254                       ! Il faut reloc curseur en bas de pg
GOTO input_msg
ELSE
page_msgsys(2)                ! PremiŠre page
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
UNTIL LEN(page_a$)
'
IF LEN(page_a$)=FALSE
'
' Demande conf:
'
PRINT AT(52,24);"I";            ! Impression possible
aff_page_1(g0&,FALSE)
'
ptr_msg&=1
ptr_line&=FALSE
msg_int!=TRUE
'
' Recherche du nombre de pages
FOR nbpg_msg&=nb_pagemsg| DOWNTO 2
EXIT IF LEN(file$(nbpg_msg&))>nb_lignepage| ! Sort dŠs qu'une page contient du texte
NEXT nbpg_msg&
'
titre_msg$=file$(0)
text_msg$=""
FOR m1|=1 TO nbpg_msg&
text_msg$=text_msg$+CHR$(m1|)+file$(m1|)          ! Composition msg total
NEXT m1|
text_msg$=text_msg$+CHR$(m1|)                     ! Fin msg
'
REPEAT
IF ptr_msg&>0
PRINT AT(13,14);"Affichage du message avant confirm. ";
affiche_msg(CHR$(0)+file$(g3&)+STRING$(20,0),1,SUCC(y|(7)),nb_lignepage|,40,g5$)
ENDIF
PRINT AT(13,14);"Demande de confirmation.";SPC(15);
get_command(TRUE,TRUE,0,0,7,41,41,41,41,41,41,41,41,"","")
EXIT IF cd$="ENVOI" OR LEN(page_a$)
IF cd$="ANNULATION" OR cd$="CORRECTION"
modif_msg:
aff_page_1(g1&,FALSE)
PRINT AT(52,24);"-";            ! Impression impossible
GOTO input_msg                ! Retourne … l'‚dition
ELSE IF cd$="RETOUR"
IF g3&>1
DEC g3&
edit_msg.no_page
aff_page_1(l.page_suiv&,TRUE) ! Aff page VDT "SUIVANT"
ptr_msg&=1
ptr_line&=FALSE
g2|=255                       ! Il faudra relocaliser le curseur
ELSE
page_msgsys(2)                ! PremiŠre page
ENDIF
ELSE IF cd$="SUITE"
IF g3&<nb_pagemsg|
INC g3&
edit_msg.no_page
aff_page_1(l.page_suiv&,TRUE) ! Aff page VDT "SUIVANT"
ptr_msg&=1
ptr_line&=FALSE
g2|=255                       ! Il faudra relocaliser le curseur
ELSE
page_msgsys(3)                ! Nb maximum pages atteint
ENDIF
ELSE IF cd$="REPETITION"
ptr_msg&=1
ptr_line&=FALSE
ELSE
no_effect                 ! Touche sans effet
ENDIF
UNTIL LEN(page_a$)
ENDIF
ENDIF
ENDIF
PRINT AT(52,24);"-";            ! Impression impossible
fin_edit_msg:
RETURN
> PROCEDURE edit_msg.no_page
IF x|(5)
MID$(no_page$,1,1)=STR$(g3&)  ! Nø de page msg
loc(x|(5),y|(5))
PRINT #99;g4$;no_page$;
ENDIF
RETURN
> PROCEDURE edit_msg.parametres
'
' ParamŠtres avant ‚dition de message:
'
IF fnct|<>18                  ! Si pas EDIT_REP
PRINT AT(14,9);"nø3: ";
page_v$=TRIM$(LEFT$(parametre$(3),8)) ! Nom page vdt ‚crit
find_page                     ! Cherche nø
IF exit|=FALSE
PRINT AT(29,9);"Fonction: Titre";
l.page_ecri&=page_v&
page_v$=MID$(parametre$(3),9) ! Page ecriture
ENDIF
ELSE
page_v$=parametre$(3)       ! page ecriture
ENDIF
IF exit|=FALSE
PRINT AT(14,10);"nø5: ";
find_page                     ! Cherche nø
IF exit|=FALSE
PRINT AT(29,10);"Fonction: Ecriture";
IF fnct|=18
l.page_ecri&=page_v&
l.page_ecri2&=TRUE              ! Pas d'autre page!
ELSE
l.page_ecri2&=page_v&
ENDIF
'
PRINT AT(14,11);"nø5: ";
page_v$=TRIM$(MID$(parametre$(10),9,8)) ! Nom page SUIVANT
find_page                     ! Cherch nø
IF exit|=FALSE
PRINT AT(29,11);"Fonction: Msg suivant";
l.page_suiv&=page_v&          ! Nø page SUIVANT
'
PRINT AT(14,12);"nø6: ";
page_v$=parametre$(4)         ! Nom page vdt confirm
find_page                     ! Cherch nø
IF exit|=FALSE
PRINT AT(29,12);"Fonction: Confirmation";
g0&=page_v&                   ! M‚mo nø page
'
PRINT AT(14,13);"nø7: ";
page_v$=parametre$(5)         ! Nom vdt modif
find_page                     ! Cherch nø de cette page
IF exit|=FALSE
PRINT AT(29,13);"Fonction: R‚ecriture";
g1&=page_v&                   ! M‚mo nø page
'
decode_attrib(1,parametre$(17)) ! Att infos
g4$=l1$
decode_attrib(0,parametre$(18)) ! Att msg
g5$=l1$
'
m1&=VAL(parametre$(19))         ! Settings
IF BTST(m1&,0)
x|(0)=VAL(parametre$(20))       ! Coords pseu destin
y|(0)=VAL(parametre$(21))
ELSE
x|(0)=FALSE                     ! Pas de pseu dest
ENDIF
'
IF BTST(m1&,1)
x|(1)=VAL(parametre$(22))       ! Coords Date d'envoi
y|(1)=VAL(parametre$(23))
ELSE
x|(1)=FALSE                     ! Pas de date d'envoi
ENDIF
l1|=VAL(parametre$(24))         ! Type date
IF l1|=1
m1$=LEFT$(dat$,2)+"/"+MID$(dat$,4,2)+"/"+RIGHT$(dat$,4)
ELSE IF l1|=2
m1$=LEFT$(dat$,2)+"/"+MID$(dat$,4,2)+"/"+RIGHT$(dat$,2)
ELSE
m1$=LEFT$(dat$,2)+"/"+MID$(dat$,4,2)
ENDIF
'
IF BTST(m1&,2)
x|(2)=VAL(parametre$(25))     ! Coords Heure d'envoi
y|(2)=VAL(parametre$(26))
ELSE
x|(2)=FALSE                   ! Pas d'heure d'envoi
ENDIF
l1|=VAL(parametre$(27))       ! Type Heure
IF l1|=1
m2$=tim$
ELSE
m2$=LEFT$(tim$,5)
ENDIF
'
IF BTST(m1&,3)
x|(3)=VAL(parametre$(28))     ! Coords mode ‚dit
y|(3)=VAL(parametre$(29))
ELSE
x|(3)=FALSE                   ! Pas de mode ‚dit
ENDIF
'
IF BTST(m1&,4)
x|(4)=VAL(parametre$(30))     ! Coords nø msg
y|(4)=VAL(parametre$(31))
ELSE
x|(4)=FALSE                   ! Pas de nø
ENDIF
IF VAL(parametre$(32))=1      ! Type de nø
no_msg$=no_msg$+"/"+RIGHT$("0"+STR$(nb_maxmsg|),2)
ENDIF
'
IF BTST(m1&,5)
x|(5)=VAL(parametre$(33))     ! Coords nø pag
y|(5)=VAL(parametre$(34))
ELSE
x|(5)=FALSE                   ! Pas de nø
ENDIF
l1|=VAL(parametre$(35))       ! Type de nø
IF l1|=1
no_page$=STR$(g3&)+"/"+STR$(nb_pagemsg|)
ELSE
no_page$=STR$(g3&)
ENDIF
'
IF titre!
x|(6)=VAL(parametre$(36))     ! Coords titre
y|(6)=VAL(RIGHT$(parametre$(10),2))
ELSE
x|(6)=FALSE                   ! Pas de titre
ENDIF
'
y|(7)=PRED(VAL(parametre$(37))) ! Coord Y msg
'
IF BTST(m1&,6)                ! Si Filler
g1!=TRUE
g1$=CHR$(VAL(parametre$(38))) ! Filler
ELSE
g1!=FALSE
g1$=" "                       ! Correction: espace
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
> PROCEDURE edt_fiche
'
' Gest page EDT_FICH:
'
PRINT AT(29,7);"Fonction: Fiche";
PRINT AT(3,9);"Base de donn‚es: ";
find_base             ! Trouve base
IF g0&=>nb_base&      ! Si pas trouv‚e
enregistre(52,"Base n'existe pas!")
exit|=8
ELSE
PRINT base$;
PRINT AT(3,14);"En cours: [paramŠtres].";
enregistre(10,"Edition d'une fiche de la base: "+base$)
'
g1$=CHR$(VAL(LEFT$(parametre$(12),3)))  ! Filler.
decode_attrib(0,MID$(parametre$(12),4,5)) ! Atts ‚dit
g4$=l1$
decode_attrib(1,MID$(parametre$(12),9,5)) ! Atts non-‚dit
g5$=l1$
'
g6&=VAL(parametre$(2))      ! Quelle fiche?
'
g2&=0                       ! Nombre de champs affichables
g3&=0                       ! Nombre de champs ‚ditables
g4&=TRUE                    ! Nø du premier ‚ditable
FOR g1&=0 TO 26             ! Parcourt champs!
fiche_champ                 ! Extrait les paramŠtres du champ concern‚
x|(g1&)=VAL(l2$)            ! X
y|(g1&)=VAL(l3$)            ! Y
lg_min|(g1&)=VAL(l4$)       ! Lg min
IF g1&>1                    ! Si champs susceptibles d'‚dition
lg_max|(g1&)=fiches_param&(g0&,g1&-2,1) ! Lg max
IF g6&=0 OR LEN(l1$)        ! Si NOUVELLE fiche ou demande de modification
champ$(g1&)=LEFT$(TRIM$(l1$),lg_max|(g1&)) ! Init champ avec "d‚faut"
ELSE IF g6&=2               ! Si on veut voir fiche SELECTIONNEE
ENDIF
ENDIF
aff_champ!(g1&)=l1|         ! Affichage valide
ADD g2&,l1|                 ! 1 champ affichable de + ?
edit_champ!(g1&)=l2|        ! Editable
IF l2|
INC g3&                   ! 1 champ ‚ditable de +
IF g4&=TRUE                 ! Si on avait pas encore rencontr‚ d'‚ditable
g4&=g1&                     ! Premier ‚ditable
ENDIF
g5&=g1&                     ! Dernier champ ‚ditable
ENDIF
NEXT g1&
champ$(0)="123456"          ! Nø absolu
champ$(1)=DATE$+" "+TIME$   ! Date de cr‚ation
PRINT AT(3,10);"Champs: øAffich‚s:"'g2&'"  ùEditables:"'g3&;
'
aff_page_1(page_v&,FALSE)   ! Aff page non interruptible
PRINT AT(13,14);"Affichage des informations.";SPC(9);
FOR g1&=0 TO 26             ! Parcourt champs
IF aff_champ!(g1&)          ! Si Affichage valide
loc(x|(g1&),y|(g1&))
IF edit_champ!(g1&)         ! Si ‚ditable
PRINT #99;g4$;                ! Att edit
envoi_chaine(champ$(g1&))     ! Affiche champ
fill_champ(l2&,lg_max|(g1&),g1$) ! Rempli avec filler
ELSE
PRINT #99;g5$;                ! Att non_edit
envoi_chaine(champ$(g1&))        ! Affiche champ
ENDIF
ENDIF
NEXT g1&
'
IF g3&
g1&=g4&                       ! Champ en cours d'‚dit (1er ‚ditable)
edt_fiche.init_champ
ENDIF
'
PRINT AT(3,15);"Commande: ";
REPEAT
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
IF g3&                      ! Si on peut ‚diter
loc(x|(g1&)+PRED(g0|),y|(g1&))
PRINT #99;g4$;              ! Atts
get_command(TRUE,TRUE,0,1,5,6,41,41,41,41,7,41,41,g1$,"")
champ$(g1&)=LEFT$(g0$,FN last_c(g0$)) ! Sauve champ en cours
EXIT IF LEN(page_a$)
IF cd$="RETOUR"
noeff_disable!=TRUE           ! Signale que touche reconnue
IF g1&>g4&                    ! Si pas sur la 1Šre ligne
FOR g1&=PRED(g1&) DOWNTO g4&  ! Va sur champ edit pr‚c‚dent
EXIT IF edit_champ!(g1&)
NEXT g1&
edt_fiche.init_champ
ENDIF
ELSE IF cd$="SUITE"
noeff_disable!=TRUE           ! Signale que touche reconnue
IF g1&<g5&                    ! Si pas sur la derniŠre ligne
FOR g1&=SUCC(g1&) TO g5&      ! Va sur champ edit suivant
EXIT IF edit_champ!(g1&)
NEXT g1&
edt_fiche.init_champ
ENDIF
ELSE IF cd$="ANNULATION"
noeff_disable!=TRUE           ! Signale que touche reconnue
init_champ(g1&,g4$,lg_max|(g1&))
ELSE IF cd$="ENVOI"
'
' 1Šre partie
'
IF parametre$(10)="1"           ! S'il faut contr“ler
noeff_disable!=TRUE           ! Signale que touche reconnue
FOR m1&=g4& TO g5&              ! Parcourt champs entre 1er et dern ‚ditable
IF edit_champ!(m1&)             ! Si ce champ est ‚ditable
IF LEN(champ$(m1&))<lg_min|(m1&) ! Si longueur insuffisante
page_msgsys(4)                   ! Champ incomplet!
g1&=m1&                          ! Champ concern‚
edt_fiche.init_champ
cd$=""                           ! Envoi ne peut ˆtre trait‚
EXIT IF TRUE
ENDIF
ENDIF
NEXT m1&
ENDIF
ENDIF
ELSE                      ! Si on ne peut pas ‚diter
get_command(TRUE,TRUE,0,0,1,2,41,41,41,41,3,41,41,"","")
EXIT IF LEN(page_a$)
ENDIF
IF cd$="ENVOI"            ! Touche [Envoi]
'
' 2e partie (sortie sur fichier/imprimante)
'
m1&=VAL(parametre$(3))    ! Type de sauvegarde
IF m1&
noeff_disable!=TRUE       ! Signale que touche reconnue
IF BTST(m1&,0)            ! Si on veut une sauvegarde disque
PRINT AT(13,14);"Sauvegarde de la fiche sur disque...";
page_msgsys(7)            ! Sauvegarde en cours...
sauve_fiche               ! Sauve la fiche courante
page_msgsys(8)            ! Fiche enregistr‚e
ENDIF
ENDIF
page_a$=parametre$(8)     ! Page ENVOI
IF LEN(page_a$)=FALSE     ! Si pas de renvoi … une page arbo
no_effect
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
UNTIL LEN(page_a$)
ENDIF
RETURN
> PROCEDURE edt_fiche.init_champ
g0$=SPACE$(lg_max|(g1&))
LSET g0$=champ$(g1&)          ! Texte du champ
g1|=lg_max|(g1&)              ! Long ligne
g0|=SUCC(LEN(champ$(g1&)))    ! Pos csr
RETURN
> PROCEDURE effacement_arbo(a&,a$)
'
' Eff page arbo de la list:
'
info_arbo|(a&)=2              ! M‚mo ‚ffa
FOR l1&=0 TO nbn_arbo&
l1$=alpha_arbo$(l1&)
l1|=LEN(l1$)-1
IF LEFT$(l1$,l1|)=a$
DELETE alpha_arbo$(l1&)
DEC nbn_arbo&
EXIT IF TRUE
ENDIF
NEXT l1&
enable_maj(2)
RETURN
> PROCEDURE emet_bloc(a%,b%)
'
' Emet un bloc par Transteaser:
'
IF a% MOD 3
ADD a%,3-(a% MOD 3)
ENDIF
l1%=a%/3
FOR l2%=1 TO l1%
CLR l3%
l5%=1
REPEAT
l4%=PEEK(b%)
ADD l3%,(l4%\64)*l5%
emission(l4%)
INC b%
ADD l5%,l5%
ADD l5%,l5%
UNTIL l5%>16
emission(l3%)
NEXT l2%
RETURN
> PROCEDURE emission(a%)
'
' Emet octet par Transteaser:
'
a%=a% AND 63
OUT 1,a%+32
ADD m4%,a%
RETURN
> PROCEDURE emission_nom
'
' Emet nom de fichier par TransTeaser:
'
l1|=LEN(t2$)
emission(l1|)
FOR l2|=1 TO l1|
l3|=ASC(MID$(t2$,l2|,1))
OUT 1,l3|+32
ADD m4%,l3|
NEXT l2|
RETURN
> PROCEDURE enregistre(p.x&,p.chaine$)
'
' Enregistre les actions du connect‚ ds fichier correspondant
'
IF p.enr!
IF l_xenr&>p.x&               ! Si csr aprŠs le x demand‚
PRINT #98                     ! Passe … la ligne
l_xenr&=1
ENDIF
IF l_xenr&<p.x&               ! Si csr avant le x demand‚
PRINT #98;SPC(p.x&-l_xenr&);
l_xenr&=p.x&
ENDIF
PRINT #98;p.chaine$;
ADD l_xenr&,LEN(p.chaine$)    ! Nlle colonne
ENDIF
RETURN
> PROCEDURE envoi_prog(t1$,t2$)
'
' Emission d'un fichier par proto TRANSTEASER:
'
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
IF g2&=-2                     ! Si on connait pas le nø page ‚mit
PRINT AT(14,10);"nø4: ";
page_v$=parametre$(3)         ! Nom page vdt d'‚mit
find_page                     ! Cherch nø page
IF exit|                      ! Si erreur
GOTO fin_envoi_prog
ENDIF
PRINT AT(29,10);"Fonction: Emission.";
g2&=page_v&
ENDIF
IF g3&=-2                      ! Si on connaŒt le nø page retour
PRINT AT(14,11);"nø5: ";
page_v$=parametre$(4)          ! Nom vdt de retour
find_page                      ! Cherche nø page
IF exit|                       ! Si erreur
GOTO fin_envoi_prog
ENDIF
PRINT AT(29,11);"Fonction: Retour d'‚mission.";
g3&=page_v&
ENDIF
topline                       ! 2.62 ANTI-BUG "keypress". Ceci dit, je ne sais pk un msg peut etre affich‚ sur cette page!
aff_page_1(g2&,FALSE)
IF g7!                        ! Si mode rouleau demand‚
scroll
ENDIF
'
download(t1$,t2$)
'
IF g7!                        ! Si on est en mode rouleau.
page
ENDIF
IF m2|<3 AND g8!              ! Si cr‚dits … d‚cr‚menter
SUB credits%,g4%
PRINT AT(68,15);LEFT$(STR$(credits%)+"     ",6);
ENDIF
IF m2|<>4                     ! Si pas d‚co
aff_page_1(g3&,FALSE)
ENDIF
t%=TIMER
deco%=TIMER
fin_envoi_prog:
RETURN
'
> PROCEDURE fenetre_serv
'
' Dessine fenˆtre serv:
'
fen_serv_open
GRAPHMODE 0
PBOX 11,23*rez|+rm|,627,191+rm|*194  ! Vide fenetre
PRINT AT(3,4);CHR$(27);"qCd:             M         le          …           Dur‚e:           s  Std:";
PRINT AT(59,6);"DerniŠre connexion";
PRINT AT(59,7);"le          …";
PRINT AT(59,9);"BAL cr‚e le";
PRINT AT(59,11);"Nb de cnxs:";
PRINT AT(59,12);"Dur‚e cnxs:";
PRINT AT(59,14);"Levels:";
PRINT AT(59,15);"Cr‚dits:";
PRINT AT(59,17);"Statut repondeur:";
PRINT AT(59,18);"To:";
PRINT AT(3,21);"Fin Sommair Guide Annul Correc Retour Suite R‚p‚t Envoi 0123456789 < > Autre";
DEFTEXT ,,,4
TEXT 16,174*rez|," 0:........  1:........  2:........  3:........  4:........  Cnx/Fin:........"
TEXT 16,180*rez|," 5:........  6:........  7:........  8:........  9:........  Fatal-E:........"
PRINT AT(3,24);"LIGNE 0: ";
FOR l1|=1 TO sys_pos|
l1$=MID$(sysop$,l1|,1)
l2|=ASC(l1$)
IF l2|=7
PRINT cursor.c$(0);cursor.f$(0);"B";normal.c$;normal.f$(0);
ELSE IF l2|=27
PRINT cursor.c$(0);cursor.f$(0);"E";normal.c$;normal.f$(0);
ELSE
PRINT l1$;
ENDIF
NEXT l1|
PRINT cursor.f$(0)'normal.f$(0);
PRINT AT(52,24);"- Clav:     Sysop:";
l1&=23*rez|+rm|
l2&=32*rez|+rm|
l3&=158*rez|+rm|
l4&=182*rez|+rm|
l5&=192*rez|+rm|
l6&=169*rez|+rm|
LINE 136,l1&,136,l2&
LINE 216,l1&,216,l2&
LINE 408,l1&,408,l2&
LINE 568,l1&,568,l2&
LINE 11,l2&,627,l2&
LINE 456,l2&,456,l3&
LINE 11,l3&,627,l3&
LINE 11,l4&,627,l4&
FOR l1&=1 TO 11
l2&=key_pos&(l1&)*8-12
LINE l2&,l3&,l2&,l6&
NEXT l1&
LINE 11,l6&,627,l6&
LINE 404,l4&,404,l5&
LINE 420,l4&,420,l5&
LINE 500,l4&,500,l5&
RETURN
> PROCEDURE fen_serv_open
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
~WIND_OPEN(handle%,10,12+rm|*16,619,181+rm|*178) ! Dessine fenetre
window!=TRUE                  ! On a ouvert une fenˆtre
RETURN
> PROCEDURE fiche_id.params
PRINT AT(3,14);"En cours: [paramŠtres].";
decode_attrib(0,parametre$(6)) ! Atts ‚dit
g4$=l1$
decode_attrib(1,parametre$(7)) ! Atts non-‚dit
g5$=l1$
g1$=CHR$(VAL(parametre$(5)))  ! Filler.
'
RESTORE info_cnt_champs
info_cnt_champs:
DATA 0,5,8,6,15,9,16,21,13
FOR l2|=1 TO 3                ! init champs
READ l1&,l2&,l3&
FOR l1|=l1& TO l2&
l1$=parametre$(l3&+l1|)
x|(l1|)=VAL(LEFT$(l1$,2))     ! Coord X
y|(l1|)=VAL(MID$(l1$,3,2))    ! Coord Y
lg_max|(l1|)=VAL(MID$(l1$,5,2))  ! Long
NEXT l1|
NEXT l2|
'
lg_max|(6)=16
lg_max|(7)=16
lg_max|(8)=1
lg_max|(9)=16
lg_max|(10)=10
lg_max|(11)=6
g1&=VAL(parametre$(25))       ! Bits 'exist' non-‚dit
g2%=VAL(parametre$(26))       ! Bits 'exist' ‚dit
g3%=VAL(parametre$(27))       ! Bits 'edit'
g4&=TRUE                      ! pas de (1er) champ ‚dit par d‚faut
g5&=TRUE                      ! Dernier champ ‚dit
'
FOR l1|=0 TO 15
EXIT IF BTST(g3%,l1|)
NEXT l1|
IF l1|<16                     ! S'il existe des ‚ditables
g4&=l1|
FOR l2|=15 DOWNTO 0
EXIT IF BTST(g3%,l2|)
NEXT l2|
g5&=l2|                       ! Nø du dernier ‚ditable
ENDIF
g6&=g4&                       ! Champ en cours d'‚dit (1er ‚ditable)
RETURN
> PROCEDURE fiche_id(p.etranger!)
'
' Gest page FICHE_ID:
'
IF p.etranger!
PRINT AT(29,7);"Fonction: Demande pseudo";
fiche_id.params
'
g1|=16
inp_aut_pseu(x|(6),y|(6),1,2,3) ! Dem pseudo cnt … analyser
'
IF LEN(page_a$)=FALSE           ! Si on a pas demand‚ de quitter
g0&=bal_no%(m1&)
g8$=pseudo$(m1&)
g9$=code$(m1&)
PRINT AT(14,8);"nø2: ";
page_v$=parametre$(28)        ! Nom page vdt ‚dit
find_page                     ! Cherch nø page
IF exit|=FALSE
PRINT AT(29,8);"Fonction: Informations";
IF g0&=bal_no&                  ! Si on s'int‚resse … sa propre fiche
fiche_perso
ELSE
fiche_etranger
ENDIF
ENDIF
ENDIF
ELSE
PRINT AT(29,7);"Fonction: Fiche";
IF info_bal|<2                ! Si cnt n'a pas de BAL
page_msgsys(2)                ! Vous n'avez pas de BAL!
page_a$=parametre$(4)         ! Page erreur
ELSE
fiche_id.params
fiche_perso
ENDIF
ENDIF
RETURN
> PROCEDURE fiche_etranger
'
' Edit fiche infos ‚tranger:
'
PRINT AT(13,14);"Chargement des infos sur pseudo dem.";
page_msgsys(2)                ! Un instant S.V.P.
l1$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(g0&),4)
OPEN "I",#1,l1$               ! Ouvre BAL concern‚e
RECALL #1,file$(),64,g0%
CLOSE #1
topline
aff_page_1(page_v&,FALSE)
PRINT AT(13,14);"Affichage des informations.         ";
FOR m1|=0 TO 5                ! Aff champs non-‚dit
IF BTST(g1&,m1|)              ! Si champ exist
loc(x|(m1|),y|(m1|))
PRINT #99;g5$;                ! Att
SELECT m1|                    ! Selon contenu du champ
CASE 0                        ! Date cr‚at BAL
PRINT #99;file$(4);
CASE 1                        ! Date derniŠre cnx.
PRINT #99;file$(2);
CASE 2                        ! Heure ...
PRINT #99;file$(3);
CASE 3                        ! Nb cnxs
PRINT #99;VAL(file$(5));
CASE 4                        ! Dur‚e tot cnx
l1%=VAL(file$(6))
PRINT #99;RIGHT$("00"+STR$(l1%\3600),3);"h ";RIGHT$("0"+STR$((l1% MOD 3600)\60),2);"mn ";RIGHT$("0"+STR$(l1% MOD 60),2);"s";
CASE 5                        ! Nb msgs en BAL
l1|=VAL(file$(22))
PRINT #99;file$(23+l1|);
ENDSELECT
ENDIF
NEXT m1|
FOR m1|=0 TO 15               ! Aff champs ‚dit
IF BTST(g2%,m1|)              ! Si champ exist
loc(x|(6+m1|),y|(6+m1|))
IF BTST(g3%,m1|)              ! Si champ est ‚dit
PRINT #99;g4$;                ! Att ‚dit
ELSE                          ! Si champ est fig‚ par le sysop
PRINT #99;g5$;                ! Att non-‚dit
ENDIF
SELECT m1|                    ! D'aprŠs le champ
CASE 0                          ! Pseudo
envoi_chaine(g8$)
IF BTST(g3%,0)
fill_champ(l2&,16,g1$)
ligne$(0)=g8$+SPACE$(16-l2&)
ligne|(0)=l2&
ENDIF
CASE 1                          ! Code.
envoi_chaine(g9$)
IF BTST(g3%,1)
fill_champ(l2&,16,g1$)
ligne$(1)=g9$+SPACE$(16-l2&)
ligne|(1)=l2&
ENDIF
CASE 2                          ! Mode rep
SELECT VAL(file$(9))
CASE 0
ligne$(2)="N"
CASE 1
ligne$(2)="O"
CASE 2
ligne$(2)="F"
CASE 3
ligne$(2)="T"
DEFAULT
ligne$(2)="?"
ENDSELECT
PRINT #99;ligne$(2);
ligne|(2)=1
CASE 3                          ! Pseud report
envoi_chaine(file$(10))
IF BTST(g3%,3)
fill_champ(l2&,16,g1$)
ligne$(3)=file$(10)+SPACE$(16-l2&)
ligne|(3)=l2&
ENDIF
CASE 4                          ! Levels
envoi_chaine(file$(7))
ligne$(4)=file$(7)
ligne|(4)=10
CASE 5                          ! Cr‚dits
l1%=VAL(file$(8))
envoi_chaine(STR$(l1%))
IF BTST(g3%,5)
fill_champ(l2&,6,g1$)
ligne|(5)=l2&
ligne$(5)=STR$(l1%)+SPACE$(6-l2&)
ENDIF
CASE 6 TO 15
envoi_chaine(LEFT$(file$(m1|+6),lg_max|(m1|+6)))
IF BTST(g3%,m1|)
fill_champ(l2&,lg_max|(m1|+6),g1$)
ligne$(m1|)=LEFT$(file$(m1|+6)+SPACE$(lg_max|(6+m1|)),lg_max|(6+m1|))
IF l2&>lg_max|(6+m1|)
ligne|(m1|)=lg_max|(6+m1|)
ELSE
ligne|(m1|)=l2&
ENDIF
ENDIF
ENDSELECT
ENDIF
NEXT m1|
'                             ! Traitement cd:
PRINT AT(13,14);"Traitement des commandes.";SPC(11);
PRINT AT(3,15);"Commande: ";
IF g6&<>TRUE
g7&=g6&+6
g0$=ligne$(g6&)               ! Texte ligne en cours
g0|=ligne|(g6&)+1             ! Pos csr
g1|=lg_max|(g7&)                 ! Long ligne
ENDIF
DO
IF g6&<>TRUE                  ! Si on peut ‚diter
l1|=x|(g7&)+PRED(g0|)
l2|=y|(g7&)
IF l1|>40
SUB l1|,40
INC l2|
ENDIF
loc(l1|,l2|)
PRINT #99;g4$;                ! Atts
get_command(TRUE,TRUE,0,1,1,2,41,41,41,41,3,41,41,g1$,"")
ELSE                          ! Si on ne peut pas ‚diter
get_command(TRUE,TRUE,0,0,1,2,41,41,41,41,3,41,41,"","")
ENDIF
EXIT IF LEN(page_a$)
IF cd$="RETOUR"
IF g6&>g4&                  ! Si on est pas sur la prem ligne
ligne$(g6&)=g0$
ligne|(g6&)=FN last_c(g0$)
FOR g6&=PRED(g6&) DOWNTO g4&
EXIT IF BTST(g3%,g6&)
NEXT g6&
g7&=6+g6&
g0$=ligne$(g6&)             ! New ligne … ‚dit
g1|=lg_max|(g7&)               ! Long ligne
g0|=SUCC(ligne|(g6&))       ! Pos csr
ENDIF
ELSE IF cd$="SUITE"
IF g6&<g5&                  ! Si on est pas sur la dern ligne
ligne$(g6&)=g0$
ligne|(g6&)=FN last_c(g0$)
FOR g6&=SUCC(g6&) TO g5&
EXIT IF BTST(g3%,g6&)
NEXT g6&
g7&=6+g6&
g0$=ligne$(g6&)              ! M‚morise
g1|=lg_max|(g7&)                ! Long ligne
g0|=SUCC(ligne|(g6&))        ! Pos csr
ENDIF
ELSE IF cd$="ENVOI"
'                             ! Modif des infos:
IF g6&<>TRUE                  ! S'il y avait des champs ‚dit
ligne$(g6&)=g0$               ! M‚mo l en cours
ligne|(g6&)=FN last_c(g0$)    ! M‚mo long
IF BTST(g3%,0)                ! Si ‚dit du pseu
m1$=LEFT$(ligne$(0),ligne|(0))! Extract pseu
IF UPPER$(m1$)<>UPPER$(g8$)   ! S'il a ‚t‚ modif
IF m1$=""                     ! Si pseu invalid
page_msgsys(3)                ! Pseudo invalide
ELSE                          ! Si pseu valid
l1$=UPPER$(m1$)
FOR l1&=0 TO PRED(nb_pseudos&) ! Recherche d'‚xistence
EXIT IF l1$=UPPER$(pseudo$(l1&))
NEXT l1&
IF l1&<>nb_pseudos&           ! Si pseu exist d‚ja
page_msgsys(4)                ! Ce pseudo existe d‚ja!
ELSE                          ! Si pseu n'exist pas encore
GOTO modify_fiche2            ! Pseu OK
ENDIF
ENDIF
ELSE
GOTO modify_fiche2            ! Pseu OK
ENDIF
ELSE                          ! Si pseu OK
modify_fiche2:
m3$=UPPER$(ligne$(2))         ! Statut r‚p dem
IF BTST(g3%,2)=TRUE AND m3$<>"O" AND m3$<>"N" AND m3$<>"F" AND m3$<>"T"
page_msgsys(5)                ! Statut r‚pondeur incorrect
ELSE                          ! Si statut r‚p OK
page_msgsys(10)               ! Sauvegarde des modifs cours
FOR m1&=0 TO PRED(nb_pseudos&)
EXIT IF g8$=pseudo$(m1&)
NEXT m1&
IF BTST(g3%,0)                ! Si on a modif pseud
IF m1$<>g8$
file$(0)=LEFT$(m1$+SPACE$(16),16)
ENDIF
ENDIF
FOR m1|=2 TO 15
IF BTST(g3%,m1|)
SELECT m1|
CASE 2                        ! Statut r‚p
IF m3$="O"
l1|=1
ELSE IF m3$="F"
l1|=2
ELSE IF m3$="T"
l1|=3
ELSE
l1|=0
ENDIF
file$(9)=STR$(l1|)
CASE 3                        ! Pseud transfert
file$(10)=UPPER$(LEFT$(ligne$(3),ligne|(3)))
CASE 4                        ! Levels
file$(7)=ligne$(4)
CASE 5                        ! Cr‚dits
l1%=VAL(LEFT$(ligne$(5),ligne|(5)))
IF l1%<0
l1%=0
ENDIF
file$(8)=RIGHT$("00000"+STR$(l1%),6)
CASE 6 TO 9
file$(m1|+6)=LEFT$(ligne$(m1|),ligne|(m1|))
ENDSELECT
ENDIF
NEXT m1|
l1$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(g0&),4)
OPEN "O",#1,l1$               ! Ouvre BAL concern‚e
STORE #1,file$(),g0%
CLOSE #1
IF BTST(g3%,1)                ! Si on ‚dite code
m2$=UPPER$(TRIM$(ligne$(1)))
IF g9$<>m2$
g9$=m2$
code$(m1&)=m2$
info_list!=TRUE             ! Liste modifi‚e
ENDIF
ENDIF
IF BTST(g3%,0)
IF g8$<>m1$
g8$=m1$
pseudo$(m1&)=m1$
FOR l1&=0 TO PRED(nb_pseudos&) ! On place les pseu
editor$(l1&)=pseudo$(l1&)+CHR$(0)+code$(l1&) ! dans Editor$
NEXT l1&
SSORT editor$() WITH sort|(),nb_pseudos&,bal_no%()
FOR l1&=0 TO PRED(nb_pseudos&) ! Parcourt les pseu
l1$=editor$(l1&)
editor$(l1&)=""
l1|=INSTR(l1$,CHR$(0))
pseudo$(l1&)=LEFT$(l1$,PRED(l1|))
code$(l1&)=MID$(l1$,l1|+1)
NEXT l1&
info_list!=TRUE             ! Liste modifi‚e
ENDIF
ENDIF
page_msgsys(6)               ! Les modifs sont faites
ENDIF
ENDIF
ENDIF
page_a$=parametre$(35)
ELSE IF cd$="ANNULATION"
IF g6&<>TRUE
loc(x|(g7&),y|(g7&))
PRINT #99;g4$;g1$;            ! Att + fill
OUT 1,18,63+lg_max|(g7&)
g0$=SPACE$(lg_max|(g7&))
ligne$(g6&)=SPACE$(lg_max|(g7&))
ligne|(g6&)=0
g0|=1
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE fiche_perso
'
' Edit fiche d'infos personelle:
'
aff_page_1(page_v&,FALSE)
PRINT AT(13,14);"Affichage des informations.         ";
FOR m1|=0 TO 5                ! Aff infos non-‚dit
IF BTST(g1&,m1|)              ! Si info exist
loc(x|(m1|),y|(m1|))
PRINT #99;g5$;                ! Att
SELECT m1|                    ! Selon fnct du champ
CASE 0                        ! Date cr‚ation bal
PRINT #99;cree_date$;
CASE 1                        ! Date derniŠre cnx
PRINT #99;last_date$;
CASE 2                        ! Heure " "
PRINT #99;last_time$;
CASE 3                        ! Nb cnxs
PRINT #99;nb_cnx%;
CASE 4                        ! Dur‚e tot cnx
PRINT #99;RIGHT$("00"+STR$(nb_sec%\3600),3);"h ";RIGHT$("0"+STR$((nb_sec% MOD 3600)\60),2);"mn ";RIGHT$("0"+STR$(nb_sec% MOD 60),2);"s";
CASE 5                        ! Nb msgs en BAL
PRINT #99;nb_balmsg|;
ENDSELECT
ENDIF
NEXT m1|
FOR m1|=0 TO 15               ! Aff champs ‚dit
IF BTST(g2%,m1|)              ! Si champ exist
loc(x|(6+m1|),y|(6+m1|))
IF BTST(g3%,m1|)            ! Champ ‚dit
PRINT #99;g4$;              ! Att ‚dit
ELSE                        ! Champ fig‚ par sys
PRINT #99;g5$;              ! Att non-‚dit
ENDIF
SELECT m1|                  ! Selon nature du champ
CASE 0                      ! Pseudo
envoi_chaine(pseudo$)
IF BTST(g3%,0)              ! Si ‚dit
fill_champ(l2&,16,g1$)
ligne$(0)=pseudo$+SPACE$(16-l2&)
ligne|(0)=l2&
ENDIF
CASE 1                      ! Code
envoi_chaine(code$)
IF BTST(g3%,1)
fill_champ(l2&,16,g1$)
ligne$(1)=code$+SPACE$(16-l2&)
ligne|(1)=l2&
ENDIF
CASE 2                      ! Mode repondeur.
SELECT info_rep|
CASE 0
ligne$(2)="N"
CASE 1
ligne$(2)="O"
CASE 2
ligne$(2)="F"
CASE 3
ligne$(2)="T"
DEFAULT
ligne$(2)="?"
ENDSELECT
PRINT #99;ligne$(2);
ligne|(2)=1
CASE 3                        ! Pseudo de report
envoi_chaine(report_pseudo$)
IF BTST(g3%,3)
fill_champ(l2&,16,g1$)
ligne$(3)=report_pseudo$+SPACE$(16-l2&)
ligne|(3)=l2&
ENDIF
CASE 4                        ! Lvls
envoi_chaine(levels$)
ligne$(4)=levels$
ligne|(4)=10
CASE 5                        ! Cr‚ds
envoi_chaine(STR$(credits%))
IF BTST(g3%,5)
fill_champ(l2&,6,g1$)
ligne|(5)=l2&
ligne$(5)=STR$(credits%)+SPACE$(6-l2&)
ENDIF
CASE 6 TO 15                  ! Lignes d'infos 5 et 6
envoi_chaine(LEFT$(info_cnt$(m1|-6),lg_max|(m1|+6)))
IF BTST(g3%,m1|)
fill_champ(l2&,lg_max|(m1|+6),g1$)
ligne$(m1|)=LEFT$(info_cnt$(m1|-6)+SPACE$(lg_max|(6+m1|)),lg_max|(6+m1|))
IF l2&>lg_max|(6+m1|)
ligne|(m1|)=lg_max|(6+m1|)
ELSE
ligne|(m1|)=l2&
ENDIF
ENDIF
ENDSELECT
ENDIF
NEXT m1|
'
' Traitement cd:
'
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
IF g6&<>TRUE
g7&=g6&+6
g0$=ligne$(g6&)               ! Texte ligne en cours
g0|=ligne|(g6&)+1             ! Pos csr
g1|=lg_max|(g7&)                 ! Long ligne
ENDIF
DO
IF g6&<>TRUE                  ! Si on peut ‚diter
l1|=x|(g7&)+PRED(g0|)
l2|=y|(g7&)
IF l1|>40
SUB l1|,40
INC l2|
ENDIF
loc(l1|,l2|)
PRINT #99;g4$;                ! Atts
get_command(TRUE,TRUE,0,1,1,2,41,41,41,41,3,41,41,g1$,"")
ELSE                          ! Si on ne peut pas ‚diter
get_command(TRUE,TRUE,0,0,1,2,41,41,41,41,3,41,41,"","")
ENDIF
EXIT IF LEN(page_a$)
IF cd$="RETOUR"
IF g6&>g4&                    ! Si pas sur la 1Šre ligne
ligne$(g6&)=g0$
ligne|(g6&)=FN last_c(g0$)
FOR g6&=PRED(g6&) DOWNTO g4&
EXIT IF BTST(g3%,g6&)
NEXT g6&
g7&=6+g6&
g0$=ligne$(g6&)
g1|=lg_max|(g7&)                 ! Long ligne
g0|=SUCC(ligne|(g6&))         ! Pos csr
ENDIF
ELSE IF cd$="SUITE"
IF g6&<g5&                    ! Si pas sur la dern ligne
ligne$(g6&)=g0$
ligne|(g6&)=FN last_c(g0$)
FOR g6&=SUCC(g6&) TO g5&
EXIT IF BTST(g3%,g6&)
NEXT g6&
g7&=6+g6&
g0$=ligne$(g6&)
g1|=lg_max|(g7&)                    ! Long ligne
g0|=SUCC(ligne|(g6&))            ! Pos csr
ENDIF
ELSE IF cd$="ENVOI"
IF g6&<>TRUE                 ! S'il y avait des champs ‚dit...
ligne$(g6&)=g0$              ! On va m‚mo l en cours
ligne|(g6&)=FN last_c(g0$)   ! M‚mo long
IF BTST(g3%,0)               ! Si pseudo ‚ditable
m1$=LEFT$(ligne$(0),ligne|(0)) ! Extract pseu
IF UPPER$(m1$)<>UPPER$(pseudo$)! S'il a ‚t‚ modifi‚
IF m1$=""                   ! Si pseudo invalide
page_msgsys(3)              ! Pseudo invalide
ELSE                        ! Si pseudo valid
l1$=UPPER$(m1$)
FOR l1&=0 TO PRED(nb_pseudos&) ! Recherche d'‚xistence
EXIT IF l1$=UPPER$(pseudo$(l1&))
NEXT l1&
IF l1&<>nb_pseudos&         ! Si pseu exist d‚ja
page_msgsys(4)              ! Ce pseudo existe d‚ja
ELSE                        ! Si pseu n'exist pas
GOTO modify_fiche           ! Pseudo OK
ENDIF
ENDIF
ELSE
GOTO modify_fiche           ! Pseudo OK
ENDIF
ELSE                          ! Si pseudo OK
modify_fiche:
m3$=UPPER$(ligne$(2))         ! Statut r‚p dem
IF BTST(g3%,2)=TRUE AND m3$<>"O" AND m3$<>"N" AND m3$<>"F" AND m3$<>"T"
page_msgsys(5)                ! Statut r‚pondeur incorrect
ELSE                          ! Statut r‚p OK
FOR m1&=0 TO PRED(nb_pseudos&)
EXIT IF pseudo$=pseudo$(m1&)
NEXT m1&
IF BTST(g3%,1)                ! Si code ‚ditable
m2$=UPPER$(TRIM$(ligne$(1)))
code$=m2$
code$(m1&)=m2$
info_list!=TRUE               ! liste modifi‚e
ENDIF
IF BTST(g3%,0)                ! Si pseudo ‚ditable
pseudo$=m1$
pseudo$(m1&)=m1$
FOR l1&=0 TO PRED(nb_pseudos&) ! Parcourt les pseu
file$(l1&)=pseudo$(l1&)+CHR$(0)+code$(l1&)
NEXT l1&
SSORT file$() WITH sort|(),nb_pseudos&,bal_no%()
FOR l1&=0 TO PRED(nb_pseudos&) ! Parcourt les pseu
l1$=file$(l1&)
l1|=INSTR(l1$,CHR$(0))
pseudo$(l1&)=LEFT$(l1$,PRED(l1|))
code$(l1&)=MID$(l1$,l1|+1)
NEXT l1&
l1$=pseudo$+CHR$(0)         ! Titre fenetre: new pseu
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
info_list!=TRUE             ! On a modifi‚ la list
ENDIF
FOR m1|=2 TO 15
IF BTST(g3%,m1|)
SELECT m1|
CASE 2                      ! Statut r‚p
IF m3$="O"
info_rep|=1
ELSE IF m3$="F"
info_rep|=2
ELSE IF m3$="T"
info_rep|=3
ELSE
info_rep|=0
ENDIF
PRINT AT(77,17);m3$;
CASE 3                      ! Pseu transfert
report_pseudo$=UPPER$(LEFT$(ligne$(3),ligne|(3)))
PRINT AT(63,18);SPC(16);
PRINT AT(63,18);report_pseudo$;
CASE 4                      ! Levels
levels$=ligne$(4)
PRINT AT(67,14);levels$;
CASE 5                      ! Cr‚dits
credits%=VAL(LEFT$(ligne$(5),ligne|(5)))
IF credits%<0
credits%=0
ENDIF
PRINT AT(68,15);SPC(6);
PRINT AT(68,15);credits%;
CASE 6 TO 15
info_cnt$(m1|-6)=LEFT$(ligne$(m1|),ligne|(m1|))
ENDSELECT
ENDIF
NEXT m1|
info_bal|=3                 ! La BAL … ‚t‚ modifi‚e
page_msgsys(6)              ! Les modifs sont faites
ENDIF
ENDIF
ENDIF
page_a$=parametre$(35)
ELSE IF cd$="ANNULATION"
IF g6&<>TRUE
loc(x|(g7&),y|(g7&))
PRINT #99;g4$;g1$;            ! Att+fill
OUT 1,18,63+lg_max|(g7&)
g0$=SPACE$(lg_max|(g7&))
ligne$(g6&)=SPACE$(lg_max|(g7&))
ligne|(g6&)=0
g0|=1
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE filtrer_bals
'
' Filtrage des BALs:
'
titre$="Filtrage des BoŒtes-…-lettres"
titre(titre$)
adr%=filtrer.adr%
m1$=LEFT$(date_filtre$,2)+MID$(date_filtre$,4,2)+RIGHT$(date_filtre$,2)
set_edit(3,m1$)
set_edit(4,levels_filtre$)
'
affiche_rsc
'
IF b%=6
DEFMOUSE 2
m1$=FN edit$(3)
date_filtre$=LEFT$(m1$,2)+"."+MID$(m1$,3,2)+".19"+RIGHT$(m1$,2)
g1%=VAL(MID$(date_filtre$,7,4))*10000+VAL(MID$(date_filtre$,4,2))*100+VAL(LEFT$(date_filtre$,2))
levels_filtre$=FN edit$(4)
g1!=FN selected(5)          ! Demande conf ?
'
ALERT 2,"|ATTENTION: Tout|effacement de BAL|est irr‚versible!",2,"Confirmer|Annuler",l1|
'
IF l1|=1
enable_maj(10)               ! On a modifi‚ le fichier DIVERS
'
adr%=fichiers.adr%
set_edit(1,titre$)
aff_charsauve
set_string(5,"BoŒtes-…-lettres")
set_string(6,"Filtrage")
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
'
CHDRIVE chemin$(2)            ! Dossier BALs
CHDIR "\"
'
g1&=nb_pseudos&
FOR m1&=PRED(g1&) DOWNTO 0
m3$=pseudo$(m1&)
set_string(11,m3$)
set_vlstring(10,SUCC(m1&),4)
~OBJC_DRAW(fichiers.adr%,9,7,x%,y%,w%,h%)
m1%=bal_no%(m1&)                  ! Nø du fichier BAL
m4$="BAL_"+RIGHT$("000"+STR$(m1%),4)
m1$=chemin$(2)+m4$
'
IF EXIST(m1$)
OPEN "I",#1,m1$
RECALL #1,ligne$(),8,void         ! Charge qques infos
CLOSE #1
'
levels$=ligne$(7)                 ! levels
test_level(levels_filtre$)
IF m1|<11                         ! Si levels inf … barriŠre
m2$=ligne$(2)                     ! date
g2%=VAL(MID$(m2$,7,4))*10000+VAL(MID$(m2$,4,2))*100+VAL(LEFT$(m2$,2))
IF (g2%<g1%)                      ! Si derniŠre visite inf … date limite
l1$="Effacer BAL: "+m3$+"|DerniŠre cnx le: "+m2$+"|Levels: "+levels$+"|(Nø"+STR$(m1%)+")"
IF g1!
ALERT 2,l1$,2,"Effacer|Passer|Annuler",l1|
EXIT IF l1|=3
ELSE
l1|=1
ENDIF
IF l1|=1                      ! S'il faut effacer
filtrer_supplist              ! Supp r‚f de la liste
KILL m1$                      ! D‚truit fichier
ENDIF
ENDIF
ENDIF
ELSE            ! Fichier n'existe pas!
ALERT 2,"Le fichier: "+m4$+"|de: "+m3$+"|est introuvable!|Supprimer r‚f‚rence?",3,"Supprimer|Passer|Annuler",l1|
EXIT IF l1|=3
IF l1|=1
filtrer_supplist              ! Supp r‚f de la liste
ENDIF
ENDIF
NEXT m1&
fin_cs_type
IF info_list!
set_string(6,"Mise-…-jour liste")
~OBJC_DRAW(fichiers.adr%,4,7,x%,y%,w%,h%)
sauve_bal.info_list               ! Sauve les modifs de la liste
ENDIF
~FORM_DIAL(3,160,100,0,0,x%,y%,w%,h%)
ENDIF
DEFMOUSE 0
ENDIF
'
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE filtrer_supplist
DELETE pseudo$(m1&)           ! Efface pseudo
DELETE code$(m1&)             ! Efface code
DEC nb_pseudos&               ! 1 pseu en -
info_list!=TRUE               ! On a modifi‚ list
bal_no&=bal_no%(m1&)          ! Nø BAL du CNT >>> Corrige le bug de la v 2.60 <<<
DELETE bal_no%(m1&)           ! Efface nø BAL
INSERT bal_no%(nb_pseudos&)=bal_no& ! R‚serve ce nø pour proch BAL
RETURN
> PROCEDURE fill_champ(a|,b|,filler$)
'
' Affiche fin de champ en filler:
'
IF a|<b|
PRINT #99;filler$;
OUT 1,18,63+b|-a|
ENDIF
RETURN
> PROCEDURE fin
'
' Gest page FIN:
'
PRINT AT(3,14);"En cours:";
aff_page_1(page_v&,FALSE)
sauve_bal                     ! Sauvegarde bal courante
l1$="[CONNECTE]"+CHR$(0)      ! Titre fenˆtre
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
IF new_cnx!
DELETE connecte$(0)
g1%=(TIMER-debut%)\200
ADD d_totale%,g1%
l1&=g1%\60
l1|=g1% MOD 60
connecte$(19)="}"+CHR$(27)+CHR$(69)+SPACE$(16)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+LEFT$(cnx_dat$,5)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+cnx_tim$+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+RIGHT$("00"+STR$(l1&),3)+":"
connecte$(19)=connecte$(19)+RIGHT$("0"+STR$(l1|),2)+CHR$(27)+CHR$(71)+"{"
MID$(connecte$(19),4,16)=pseudo$+SPACE$(15)
cnx_dat$=DATE$
cnx_tim$=TIME$
new_cnx!=FALSE
ENDIF
init_bal                      ! Init bal courante
cd$="PAGE SUIV"
page_a$=parametre$(2)         ! Page suiv
deco%=TIMER
RETURN
> PROCEDURE find_altern(VAR page$)
LOCAL type&,i&,lvl$
'
' S‚lectionne une alternative:
'
PRINT page$;                  ! AFF nom de la page alternative!
FOR i&=1 TO LEN(page$)
OUT 2,8                     ! Retour en arriŠre sur l'‚cran
NEXT i&
IF nbp_alt&                   ! S'il exist des pages alternatives
FOR i&=0 TO PRED(nbp_alt&)
EXIT IF nom_alt$(i&)=page$ AND info_alt|(i&)<>2
NEXT i&
ELSE
i&=nbp_alt&
ENDIF
IF i&<nbp_alt&
l1$=page_alt$(i&)
@decode_alt
IF mi2!                       ! D‚termination de la colonne!
type&=2                       ! Choisir page parmi: minitel 2
ELSE IF bi!
type&=1                       ! Choisir page parmi: bistandard
ENDIF
SELECT altern_mode&           ! Selon mode de s‚lection
CASE 0                        ! Premier
page$=alternative$(type&*6)   ! 1er elt colonne
CASE 1                        ! Random
IF nb_alt_page&(type&)        ! S'il existe des pages ds la colonne choisie
REPEAT
page$=alternative$(type&*6+RANDOM(6))  ! Choix al‚atoire ds colonne
UNTIL LEN(page$)
ELSE
page$=""
ENDIF
DEFAULT                       ! Level
lvl$=MID$(levels$,altern_level&,1) ! CritŠre!
IF lvl$<"1"
page$=alternative$(type&*6)
ELSE IF lvl$>"4"
page$=alternative$(type&*6+5)
ELSE
page$=alternative$(type&*6+VAL(lvl$))
ENDIF
ENDSELECT
ELSE
PRINT AT(3,19);cursor.c$(0);"ERREUR: Page alternative: ";page$;" introuvable.";normal.c$;
msgsys("003")          ! Page alternative introuvable
cd$="ERREUR ALT"
exit|=7
page_a$="x"
ENDIF
RETURN
> PROCEDURE find_page
'
' Trouve nø de page en fnct du nom:
'
real_name(page_v$)            ! Si r‚f … une m‚m de page
IF LEFT$(page_v$)="\"
find_altern(page_v$)
ENDIF
IF exit|=FALSE
IF page_v$=""                 ! Si pas de page
page_v$="/"
ptr&=TRUE
page_v&=TRUE
ELSE
ptr&=1
IF nbp_vdt&                   ! S'il exist des pages
FOR page_v&=0 TO PRED(nbp_vdt&)
EXIT IF nom_vdt$(page_v&)=page_v$ AND info_vdt|(page_v&)<>2
NEXT page_v&
ELSE
page_v&=TRUE
ptr&=TRUE
ENDIF
IF page_v&=nbp_vdt&            ! Si la page n'exist pas
page_a$="x"                    ! Erreur !
exit|=2                        ! Type d'erreur
ENDIF
ENDIF
PRINT page_v$;SPC(8-LEN(page_v$)); ! Affiche nom page
ENDIF
RETURN
> PROCEDURE find_rub
'
' Trouve nø de rub en fnct du nom:
'
IF nb_rub&                    ! S'il exist des rub
FOR rub|=0 TO PRED(nb_rub&)   ! Cherche la rub
EXIT IF nom_rub$(rub|)=rubrique$ AND info_rub|(rub|)<>2
NEXT rub|
ENDIF
IF rub|=>nb_rub&
exit|=4
enregistre(52,"Rub n'existe pas!")
ELSE
PRINT rubrique$;              ! Affich nom rub
ENDIF
RETURN
> PROCEDURE fixe_veille
'
' Fixe l'‚ch‚ance o— le minitel se met en mode veille.
'
IF nb_sec_veille&=>0
veille%=TIMER+nb_sec_veille&*200
ENDIF
RETURN
> PROCEDURE function_keys
'
' Gest touches de fnct dans get_com, get_dia, get_msg, normal, Reception.2
'
l2!=TRUE
SELECT l2|
CASE 59                       ! [F1]
clav!=FALSE                   ! Mode l0
upd_sys
CASE 60                       ! [F2]
clav!=TRUE                    ! Mode Emul
upd_sys
CASE 71                       ! [Clr/Home]
PRINT AT(12,24);SPC(SUCC(sysop_maxlong&));
PRINT AT(12,24);cursor.f$(0)'normal.f$(0);
sysop$=""
CLR sys_pos|
CASE 84                       ! [Shift F1]
sysop|=FALSE                  ! Mode Absent
upd_sys
CASE 85                       ! [Shift F2]
sysop|=1                      ! Mode Appel
upd_sys
CASE 86                       ! [Shift F3]
sysop|=2                      ! Mode Pr‚sent
upd_sys
CASE 92                       ! [Shift F9]
IF credits%>0 AND mode|<>10
DEC credits%                  ! 1 cr‚dit de -
PRINT AT(68,15);credits%'
ENDIF
CASE 93                       ! [Shift F10]
IF credits%<999999 AND mode|<>10
INC credits%                  ! 1 cr‚dit de +
PRINT AT(68,15);credits%;
ENDIF
CASE 97                       ! [Undo]
IF mode|<2 OR mode|=>10
topline
ENDIF
DEFAULT
l2!=FALSE
ENDSELECT
l1!=FALSE                     ! Ce n'est pas 1 touch emulat qui a ‚t‚ press‚e
RETURN
'
> PROCEDURE get_com_bas
'
' Csr bas
'
IF mode|=1                    ! Si ‚dit
g0|=g1|
g0!=TRUE                      ! Pas de r‚af
cd$="POSITION"
ELSE                          ! Si non-edit
cd$="BAS"
ENDIF
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
RETURN
> PROCEDURE get_com_corr
'
' Touche Correction dans get comm:
'
change_key(4,TRUE)
IF mode|=1                    ! Si ‚dition possible
IF g0|>1
DEC g0|
MID$(g0$,g0|,1)=" "
OUT 1,8
PRINT #99;filler$;
OUT 1,8
ELSE IF g0|=1
MID$(g0$,1,1)=" "
PRINT #99;filler$;
OUT 1,8
ENDIF
ELSE
cd$="CORRECTION"
page_a$=parametre$(corr|)
g0$=" "
ENDIF
RETURN
> PROCEDURE get_com_droite
'
' Csr droite
'
IF mode|=1
IF g0|<g1|
INC g0|
IF mixt!
OUT 1,27,91,67
ELSE
OUT 1,9
ENDIF
ENDIF
ELSE                          ! Si non-edit
cd$="DROITE"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
ENDIF
RETURN
> PROCEDURE get_com_gauche
'
' Csr gauche
'
IF mode|=1
IF g0|>1
DEC g0|
OUT 1,8
ENDIF
ELSE                          ! Si non-edit
cd$="GAUCHE"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
ENDIF
RETURN
> PROCEDURE get_com_haut
'
' Csr haut
'
IF mode|=1                    ! Si ‚dit
g0|=1
g0!=TRUE                      ! Pas de r‚aff
cd$="POSITION"
ELSE                          ! Si non-edit
cd$="HAUT"
ENDIF
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
RETURN
> PROCEDURE get_com_tab
IF mode|=1                    ! Si ‚dit
g0|=SUCC(FN last_c(g0$))
g0!=TRUE                      ! Pas de r‚aff
cd$="POSITION"
ELSE                          ! Si non-edit
cd$="TAB"
ENDIF
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
RETURN
> PROCEDURE get_command(aff!,tempo&,t%,mode|,somm|,guid|,annul|,corr|,retour|,suite|,repet|,envoi|,i|,filler$,mask$)
'
' Gest saisie des cds au mntl:
' i|:1ere TOUCHE
'
noeff_disable!=FALSE          ! Ce sera peut etre un no effect!
IF mode|=1
OUT 1,17                      ! Allume csr
csr!=TRUE
ENDIF
CLR cd$
keyacq!=keypress!
DO                            ! Attente de car
IF LEN(key_trans$)            ! Si on a un code clavier ST en attente
l1|=1-(ASC(key_trans$)=0)
l1$=LEFT$(key_trans$,l1|)
key_trans$=MID$(key_trans$,SUCC(l1|))
GOTO key_trans.1
ENDIF
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! Mise en m‚moire
get_command:
keypress
SELECT l1|                    ! En fnct du code re‡u
CASE 9                        ! [Tab]
get_com_tab
CASE 13                       ! [CR]
IF mode|=1                    ! Si ‚dit
g0|=1
g0!=TRUE                      ! Pas de r‚aff
cd$="POSITION"
ELSE                          ! Si non-edit
cd$="CR"
ENDIF
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
CASE 19                       ! Si c'est une touche de fnct
'        LPRINT "SEP"'
DO                            ! Attente prochain car
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! Mise en m‚moire
'           LPRINT l1|
keypress
SELECT l1|
CASE 65
change_key(8,TRUE)
cd$="ENVOI"
page_a$=parametre$(envoi|)
CASE 66
change_key(5,TRUE)
cd$="RETOUR"
page_a$=parametre$(retour|)
CASE 67
change_key(7,TRUE)
cd$="REPETITION"
page_a$=parametre$(repet|)
CASE 68
change_key(2,TRUE)
cd$="GUIDE"
page_a$=parametre$(guid|)
CASE 69
change_key(3,TRUE)
cd$="ANNULATION"
page_a$=parametre$(annul|)
CASE 70
change_key(1,TRUE)
cd$="SOMMAIRE"
page_a$=parametre$(somm|)
CASE 71                       ! [CORRECTION]
get_com_corr
EXIT IF TRUE
CASE 72
change_key(6,TRUE)
cd$="SUITE"
page_a$=parametre$(suite|)
CASE 73 TO 77,80,81,83,86,87,88,89,91,92,94,112,113,114
proto_keys
DEFAULT
change_key(11,TRUE)
cd$="???"
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 25                       ! Si car accentu‚
CLR m0|
change_key(11,TRUE)
DO                            ! Attente prochain car
IF INP(TRUE)                    ! Si code en entr‚e
l2|=INP(1)                    ! Mise en m‚moire
keypress
IF m0|=FALSE                  ! Si on connait pas le type d'acc
SELECT l2|
CASE 65 TO 67,72,75           ! Accents,tr‚ma,c‚dille
m0|=l2|
CASE 35,39,48,49,56,60,62,106,122,123 ! CaractŠres sp‚ciaux.
@decode_accent(l2|,0)
IF l1|=FALSE                  ! Si on a pas pu d‚coder
cd$="???"
ELSE                          ! Si car d‚cod‚
IF mode|=1
IF g0|<=g1|                   ! Si on a la place
MID$(g0$,g0|,1)=l1$           ! On le m‚mo
INC g0|                       ! Avance csr
IF mask$=""
OUT 1,25,m0|,l2|
ELSE
PRINT #99;mask$;
ENDIF
EXIT IF TRUE
ENDIF
ELSE
g0$=l1$
ENDIF
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ELSE                          ! Si on connait le type d'accent
SELECT l2|
CASE 97,99,101,105,111,117    ! Si voyelle minuscule
@decode_accent(m0|,l2|)       ! D‚codage car
IF l1|=FALSE                  ! Si on a pas pu d‚coder
cd$="???"
ELSE                          ! Si car d‚cod‚
IF mode|=1
IF g0|<=g1|                   ! Si on a la place
MID$(g0$,g0|,1)=l1$           ! On le m‚mo
INC g0|                       ! Avance csr
IF mask$=""
OUT 1,25,m0|,l2|
ELSE
PRINT #99;mask$;
ENDIF
EXIT IF TRUE
ENDIF
ELSE
g0$=l1$
ENDIF
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ENDIF
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 27                       ! S'il s'agit d'un Esc
change_key(11,TRUE)
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
SELECT l1|
CASE 57
@deconnexion
cd$="PRO 1"
page_a$="x"
exit|=1
CASE 58
PAUSE 7
IF INP(TRUE)
l2|=INP(1)
IF l2|=113 OR l2|=115
IF INP(TRUE)
~INP(1)
ENDIF
cd$="ACQUIT."
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
EXIT IF TRUE
ENDIF
ENDIF
@deconnexion
cd$="PRO 2"
page_a$="x"
exit|=1
CASE 59
PAUSE 7
IF INP(TRUE)
l2|=INP(1)
IF l2|=99 OR l2|=115
FOR l3|=1 TO 2
IF INP(TRUE)
~INP(1)
ENDIF
NEXT l3|
cd$="ACQUIT."
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
EXIT IF TRUE
ENDIF
ENDIF
@deconnexion
cd$="PRO 3"
page_a$="x"
exit|=1
CASE 74
cd$="19 75 (???)"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
EXIT IF TRUE
CASE 91
DO
IF INP(TRUE)                    ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
keypress
SELECT l1|
CASE 63                       ! Passage en 80 col
@deconnexion
cd$="PRO 80 COL"
page_a$="x"
exit|=1
CASE 65                       ! [haut]
get_com_haut
CASE 66                       ! [bas]
get_com_bas
CASE 67                       ! [droite]
get_com_droite
EXIT IF LEN(cd$)=FALSE
CASE 68                       ! [gauche]
get_com_gauche
EXIT IF LEN(cd$)=FALSE
CASE 52                       ! [Ins.C]
ins.car
l1%=TIMER
REPEAT
UNTIL INP(TRUE) OR TIMER-l1%>200
IF INP(TRUE)
~INP(1)
ENDIF
cd$="INSERE.C"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
CASE 80                       ! [Sup.C]
sup.car
cd$="SUPPRIME.C"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
DEFAULT
GOTO get_command
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF TRUE
DEFAULT
GOTO get_command
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 30                       ! [Home]
change_key(11,TRUE)
IF mode|=1                    ! Si ‚dit
g0|=1
g0!=TRUE                      ! Pas de r‚aff
cd$="POSITION"
ELSE                          ! Si non-edit
cd$="HOME"
ENDIF
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
CASE 127                      ! [Del]
change_key(11,TRUE)
sup.car
cd$="DELETE"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
DEFAULT                       ! Autre touche
FOR l2|=0 TO 9                ! On va parcourir les touches
IF key|(l2|)=l1| OR key|(l2|)=ASC(UPPER$(CHR$(l1|))) ! Si touche correspond
change_key(9,l2|)
cd$="TOUCHE "+STR$(l2|)       ! Informe la pro sup
IF i|<41
page_a$=parametre$(i|+l2|)
ENDIF
EXIT IF TRUE                  ! On sort
ENDIF
NEXT l2|
IF l2|=10                     ! Si le code n'est pas reconnu
IF mode|<>1                   ! Si pas en mode ‚dit
change_key(11,TRUE)
cd$="???"
g0$=CHR$(l1|)
ELSE                          ! Si on est en mode edit
IF l1|>31 AND l1|<123         ! Si le car est valide
change_key(10,l1|)
IF g0|<=g1|                   ! Si on a la place d'‚crire
MID$(g0$,g0|,1)=CHR$(l1|)
INC g0|
IF mask$=""
OUT 1,l1|
ELSE
PRINT #99;mask$;
ENDIF
ENDIF
ELSE                          ! Si code ASCII incorrect
change_key(11,TRUE)
cd$="???"
ENDIF
ENDIF
ENDIF
ENDSELECT
ELSE IF INP(-2)               ! Si touche ST en entr‚e
l1$=INKEY$
key_trans.1:
l1|=ASC(l1$)
SELECT l1|
CASE 0
l1!=TRUE
l2|=ASC(RIGHT$(l1$))
IF clav!
IF l2|=>61 AND l2|<=68
change_key(l2|-60,TRUE)
ELSE IF l2|=>72 AND l2|<=82
change_key(11,TRUE)
ENDIF
SELECT l2|
CASE 61                       ! [F3]
cd$="SOMMAIRE"
page_a$=parametre$(somm|)
CASE 62                       ! [F4]
cd$="GUIDE"
page_a$=parametre$(guid|)
CASE 63                       ! [F5]
cd$="ANNULATION"
page_a$=parametre$(annul|)
CASE 64                       ! [F6]
get_com_corr
CASE 65                       ! [F7]
cd$="RETOUR"
page_a$=parametre$(retour|)
CASE 66                       ! [F8]
cd$="SUITE"
page_a$=parametre$(suite|)
CASE 67                       ! [F9]
cd$="REPETITION"
page_a$=parametre$(repet|)
CASE 68                       ! [F10]
cd$="ENVOI"
page_a$=parametre$(envoi|)
CASE 72                       ! [haut]
get_com_haut
CASE 75                       ! [gauche]
get_com_gauche
CASE 77                       ! [droite]
get_com_droite
CASE 80                       ! [bas]
get_com_bas
CASE 82                       ! [Ins]
ins.car
cd$="INSERT"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
DEFAULT
function_keys
ENDSELECT
IF l1!                        ! Si une touche clavier … ‚t‚ press‚e
keypress
ENDIF
ELSE
function_keys
ENDIF
DEFAULT
IF clav! AND l1|<>2 AND l1|<>4 AND l1|<>6 AND l1|<>16 ! si emul clavier et pas break ou deco
keypress
SELECT l1|
CASE 8                        ! [Backsp]
get_com_corr
CASE 9                        ! [Tab]
get_com_tab
CASE 13                       ! [Return]
change_key(8,TRUE)
cd$="ENVOI"
page_a$=parametre$(envoi|)
DEFAULT                       ! Autre touche
FOR l2|=0 TO 9                ! On va parcourir les touches
IF key|(l2|)=l1|              ! Si touche correspond
change_key(9,l2|)
cd$="TOUCHE "+STR$(l2|)       ! Informe la pro sup
IF i|<41
page_a$=parametre$(i|+l2|)
ENDIF
EXIT IF TRUE                  ! On sort
ENDIF
NEXT l2|
IF l2|=10                     ! Si le code n'est pas reconnu
IF mode|<>1                   ! Si pas en mode ‚dit
change_key(11,TRUE)
cd$="???"
g0$=CHR$(l1|)
ELSE                          ! Si on est en mode edit
SELECT l1|
CASE 32 TO 126,129 TO 133,135 TO 140,147,148,150,151,156,158,171,172,180,181,221,225,241,246,248
change_key(10,l1|)
IF g0|<=g1|                   ! Si on a la place d'‚crire
MID$(g0$,g0|,1)=CHR$(l1|)
INC g0|
IF mask$=""
IF l1|>127
IF mixt!
accent_80(l1|)
ELSE
code_accent(l1|)
ENDIF
PRINT #99;l1$;
ELSE
OUT 1,l1|
ENDIF
ELSE
PRINT #99;mask$;
ENDIF
ENDIF
CASE 127                      ! [Del]
change_key(11,TRUE)
sup.car
cd$="DELETE"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
DEFAULT                       ! Si code ASCII incorrect
change_key(11,TRUE)
cd$="???"
ENDSELECT
ENDIF
ENDIF
ENDSELECT
ELSE
kbd_l0_break                  ! Gest touches g‚n‚rales
ENDIF
ENDSELECT
ELSE                          ! Si pas de touche … traiter
aff_temps_cnx
ENDIF
IF tempo&<>TRUE AND LEN(cd$)=FALSE
IF TIMER-t%>200*tempo&
cd$="TEMPO"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
ENDIF
ENDIF
delai
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
IF clock%<TIMER
clock
ENDIF
LOOP UNTIL LEN(cd$)
IF aff!                       ! S'il fo aff commande
PRINT AT(13,15);cd$;SPC(7);
ENDIF
IF LEN(page_a$)
enregistre(10,cd$)
ENDIF
IF mode|=1
OUT 1,20                      ! Eteind csr
csr!=FALSE
ENDIF
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
RETURN
> PROCEDURE get_dialog(yc|,nblc|,att1$,ys|,nbls|,attrib$)
'
' Gest dialogue connect‚<=>sysop:
'
CLR cd$
keyacq!=keypress!
mode|=1                       ! Pour pro function_keys
DO                            ! Attente car
IF LEN(key_trans$)            ! Si on a un code clav ST en attente
l1|=1-(ASC(key_trans$)=0)
l1$=LEFT$(key_trans$,l1|)
key_trans$=MID$(key_trans$,SUCC(l1|))
GOTO key_trans.2
ENDIF
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
get_dia_c:
keypress
SELECT l1|                    ! En fnct du code re‡u
CASE 13
change_key(11,TRUE)
restore_ccsr                  ! R‚tablit car sous csr
OUT 1,13,127                  ! Retour … la ligne+csr
g1|=1
g0|=2
CASE 19                       ! Touche de fnct
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
keypress
SELECT l1|
CASE 66                       ! [RETOUR]
change_key(5,TRUE)
IF g2|>0
restore_ccsr                ! R‚tablit car sous csr
DEC g2|
g1|=SUCC(ligne|(10+g2|))
IF g1|=41
g1|=40
ENDIF
loc(g1|,yc|+g2|)
PRINT #99;att1$;            ! Atts
OUT 1,127
g0|=2
ENDIF
EXIT IF TRUE
CASE 67
change_key(7,TRUE)
cd$="REPETITION"
CASE 68
change_key(2,TRUE)
cd$="GUIDE"
CASE 69                       ! [ANNULATION]
change_key(3,TRUE)
IF g0|=2                      ! Si csr plac‚
OUT 1,8,13
ELSE                          ! Si csr ailleurs
loc(1,yc|+g2|)
PRINT #99;att1$;              ! Att
ENDIF
OUT 1,24,127                  ! Efface ligne + csr
ligne$(10+g2|)=SPACE$(40)     ! Ligne vierge
ligne|(10+g2|)=FALSE          ! Long nulle
g1|=1                         ! Pos csr
g0|=2                         ! Csr dans Fenˆtre cnt
EXIT IF TRUE
CASE 70
change_key(1,TRUE)
cd$="SOMMAIRE"
CASE 71                       ! [CORRECTION]
change_key(4,TRUE)
IF g1|>1 OR g2|>0
restore_ccsr                  ! R‚tablit car sous csr
DEC g1|                       ! On va au car pr‚c‚dent
IF g1|=0
DEC g2|
g1|=SUCC(ligne|(10+g2|))
IF g1|=41
OUT 1,8,8
g1|=40
ELSE
loc(g1|,yc|+g2|)
PRINT #99;att1$;            ! Att
ENDIF
ELSE
OUT 1,8,8
ENDIF
OUT 1,127                   ! Efface car et aff csr
MID$(ligne$(10+g2|),g1|,1)=" "
IF ligne|(10+g2|)=g1|
ligne|(10+g2|)=PRED(g1|)
ENDIF
g0|=2
ENDIF
EXIT IF TRUE
CASE 72                       ! [SUITE]
change_key(6,TRUE)
IF g2|<nblc|
restore_ccsr                  ! R‚tablit car sous csr
INC g2|
g1|=SUCC(ligne|(10+g2|))
IF g1|=41
g1|=40
ENDIF
loc(g1|,yc|+g2|)
PRINT #99;att1$;              ! Att
OUT 1,127
g0|=2
ELSE
GOTO cls_cnt
ENDIF
EXIT IF TRUE
CASE 65                       ! [ENVOI]
change_key(8,TRUE)
cls_cnt:
loc(1,yc|)                    ! Pos en haut fenˆtre
FOR l1|=0 TO nblc|            ! Efface fen
ligne$(10+l1|)=SPACE$(40)
ligne|(10+l1|)=FALSE
PRINT #99;att1$;
OUT 1,24,10
NEXT l1|
loc(1,yc|)                    ! Pos en haut fenˆtre
PRINT #99;att1$;              ! Att
OUT 1,127
g2|=0                         ! Ligne csr
g1|=1                         ! Pos csr
g0|=2
EXIT IF TRUE
CASE 73 TO 77,80,81,83,86,87,88,89,91,92,94,112,113,114
proto_keys
DEFAULT
change_key(11,TRUE)
cd$="???"
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 25                       ! Si car accentu‚
CLR m0|
change_key(11,TRUE)
DO
IF INP(TRUE)                  ! Si code en entr‚e
l2|=INP(1)                    ! M‚mo
keypress
IF m0|=FALSE                  ! Si on ne connait pas le type
SELECT l2|
CASE 65 TO 67,72,75           ! Accents,tr‚ma,c‚dille.
m0|=l2|
CASE 35,39,48,49,56,60,62,106,122,123 ! CaractŠres sp‚ciaux.
@decode_accent(l2|,0)
IF l1|=FALSE                  ! Si on a pas pu d‚coder
cd$="???"
ELSE                            ! Si car d‚cod‚
IF g1|=40 AND g2|=nblc|         ! Si on est sur dern car fen
loc(1,yc|)                      ! Pos en haut fenˆtre
FOR l1|=0 TO nblc|              ! Efface fen
ligne$(10+l1|)=SPACE$(40)
ligne|(10+l1|)=FALSE
PRINT #99;att1$;
OUT 1,24,10
NEXT l1|
loc(1,yc|)                      ! Pos en haut fenˆtre
PRINT #99;att1$;                ! Att
g2|=0                           ! 1Šre ligne
g1|=1                           ! 1ere col
ELSE IF g0|=2                   ! Si csr plac‚
OUT 1,8                         ! On va aff sur csr
ELSE                            ! Si csr ailleurs
loc(g1|,yc|+g2|)                ! On le place … l'end voulu
PRINT #99;att1$;                ! Att
ENDIF
OUT 1,25,m0|,l2|,127            ! Affiche car + csr
MID$(ligne$(10+g2|),g1|,1)=l1$    ! M‚mo new ligne
IF ligne|(10+g2|)<g1|             ! Si new long
ligne|(10+g2|)=g1|                ! M‚mo long ligne
ENDIF
INC g1|                           ! Avance csr
IF g1|=41                         ! Si hors ligne
INC g2|                           ! Ligne suiv
g1|=1                             ! 1er car
ENDIF
g0|=2                             ! Le csr est dans fen cnt
EXIT IF TRUE
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ELSE                          ! Si on connait le type d'accent
SELECT l2|
CASE 97,99,101,105,111,117    ! Si voyelle minuscule
@decode_accent(m0|,l2|)       ! D‚codage car
IF l1|=FALSE                  ! Si on a pas pu d‚coder
cd$="???"
ELSE                        ! Si car d‚cod‚
IF g1|=40 AND g2|=nblc|     ! Si on est sur dern car fen
loc(1,yc|)                  ! Pos en haut fenˆtre
FOR l1|=0 TO nblc|          ! Efface fen
ligne$(10+l1|)=SPACE$(40)
ligne|(10+l1|)=FALSE
PRINT #99;att1$;            ! Att
OUT 1,24,10
NEXT l1|
loc(1,yc|)                  ! Pos en haut fenˆtre
PRINT #99;att1$;            ! Att
g2|=0                       ! 1Šre ligne
g1|=1                       ! 1ere col
ELSE IF g0|=2               ! Si csr plac‚
OUT 1,8                     ! On va aff sur csr
ELSE                        ! Si csr ailleurs
loc(g1|,yc|+g2|)            ! On le place … l'end voulu
PRINT #99;att1$;            ! Att
ENDIF
OUT 1,25,m0|,l2|,127        ! Aff car + csr
MID$(ligne$(10+g2|),g1|,1)=l1$ ! M‚mo new ligne
IF ligne|(10+g2|)<g1|       ! Si new long
ligne|(10+g2|)=g1|        ! M‚mo long ligne
ENDIF
INC g1|                     ! Avance csr
IF g1|=41                   ! Si hors ligne
INC g2|                     ! Ligne suiv
g1|=1                       ! 1er car ligne
ENDIF
g0|=2                       ! Le csr est dans fen cnt
EXIT IF TRUE
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ENDIF
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 27                       ! S'il c'est un Esc
change_key(11,TRUE)
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
SELECT l1|
CASE 57
@deconnexion
cd$="PRO 1"
page_a$="x"
exit|=1
CASE 58
@deconnexion
cd$="PRO 2"
page_a$="x"
exit|=1
CASE 59                       ! PRO 3
IF INP(TRUE)
l1|=INP(1)
IF l1|=99 OR l1|=115          ! Si aquit
WHILE INP(TRUE)
~INP(1)
WEND
IF l0|=1
keypress!=TRUE
ENDIF
EXIT IF TRUE
ELSE
@deconnexion
cd$="PRO 3"
page_a$="x"
exit|=1
ENDIF
ELSE
@deconnexion
cd$="PRO 3"
page_a$="x"
exit|=1
ENDIF
CASE 91
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
keypress
SELECT l1|
CASE 63                       ! Passage en 80 col
@deconnexion
cd$="PRO 80 COL"
page_a$="x"
exit|=1
CASE 65                       ! FlŠch haut
IF g2|>0
restore_ccsr                  ! R‚tablit car sous csr
OUT 1,8,11,127
DEC g2|
g0|=2
ENDIF
EXIT IF TRUE
CASE 66                       ! FlŠch bas
IF g2|<nblc|
restore_ccsr                  ! R‚tablit car sous csr
OUT 1,8,10,127
INC g2|
g0|=2
ENDIF
EXIT IF TRUE
CASE 67                       ! FlŠch droite
IF g1|<40 OR g2|<nblc|
restore_ccsr                  ! R‚tablit car sous csr
OUT 1,127
INC g1|
IF g1|=41
INC g2|
g1|=1
ENDIF
g0|=2
ENDIF
EXIT IF TRUE
CASE 68                       ! FlŠch gauche
IF g1|>1 OR g2|>0
restore_ccsr                  ! R‚tablit car sous csr
OUT 1,8,8,127
DEC g1|
IF g1|=0
DEC g2|
g1|=40
ENDIF
g0|=2
ENDIF
EXIT IF TRUE
CASE 52                       ! Ins.C
l2|=10+g2|
l3|=ligne|(l2|)
IF g1|<=l3|
l2$=ligne$(l2|)
l1$=" "+MID$(l2$,g1|,40-g1|)
ligne$(l2|)=LEFT$(l2$,g1|-1)+l1$
IF l3|<40
INC ligne|(l2|)
ENDIF
IF g0|=2                      ! Si csr plac‚
OUT 1,8                       ! On va aff sur csr
ELSE                          ! Si csr ailleurs
loc(g1|,yc|+g2|)              ! On le place
PRINT #99;att1$;              ! Att
ENDIF
envoi_chaine(l1$)
loc(g1|,yc|+g2|)              ! On replace le csr
PRINT #99;att1$;              ! Att
OUT 1,127
g0|=2
ENDIF
l1%=TIMER
REPEAT
UNTIL INP(TRUE) OR TIMER-l1%>200
IF INP(TRUE)
~INP(1)
ENDIF
EXIT IF TRUE
CASE 80                       ! Sup.C
GOTO del_cnt
DEFAULT
GOTO get_dia_c
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF TRUE
DEFAULT
GOTO get_dia_c
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 127                      ! Del
change_key(11,TRUE)
del_cnt:
l2|=10+g2|
l3|=ligne|(l2|)
IF g1|<=l3|
l2$=ligne$(l2|)
l1$=MID$(l2$,SUCC(g1|))+" "
ligne$(l2|)=LEFT$(l2$,PRED(g1|))+l1$
IF l3|
DEC ligne|(l2|)
ENDIF
IF g0|=2                      ! Si csr plac‚
OUT 1,8                       ! On va aff sur scr
ELSE                          ! Si csr ailleurs
loc(g1|,yc|+g2|)              ! On le place … l'end voulu
PRINT #99;att1$;              ! Att
ENDIF
envoi_chaine(l1$)
loc(g1|,yc|+g2|)              ! On replace csr
PRINT #99;att1$;              ! Att
OUT 1,127
g0|=2
ENDIF
CASE 32 TO 126                ! Autre touche
change_key(10,l1|)
IF g1|=40 AND g2|=nblc|       ! Si sur dern car fenetre
loc(1,yc|)                    ! Pos en haut fenˆtre
FOR l2|=0 TO nblc|            ! Efface fen
ligne$(10+l2|)=SPACE$(40)
ligne|(10+l2|)=FALSE
PRINT #99;att1$;
OUT 1,24,10
NEXT l2|
loc(1,yc|)                    ! Pos en haut fenˆtre
PRINT #99;att1$;              ! Att
g2|=0                         ! 1Šre ligne
g1|=1                         ! 1Šre col
ELSE IF g0|=2                 ! Si csr plac‚
OUT 1,8                       ! On va aff sur csr
ELSE                          ! Si csr ailleurs
loc(g1|,yc|+g2|)              ! On le place … l'end voulu
PRINT #99;att1$;              ! Att
ENDIF
OUT 1,l1|,127                 ! Aff car + csr
MID$(ligne$(10+g2|),g1|,1)=CHR$(l1|) ! M‚mo new ligne
IF ligne|(10+g2|)<g1|         ! Si new long
ligne|(10+g2|)=g1|          ! M‚mo new long ligne
ENDIF
INC g1|                       ! Avance csr
IF g1|=41                     ! Si hors-ligne
INC g2|                       ! Ligne suiv
g1|=1                         ! 1Šre col
ENDIF
g0|=2                         ! Csr dans fen cnt
ENDSELECT
ELSE IF INP(-2)               ! Si on touche ST en entr‚e
l1$=INKEY$
key_trans.2:
l1|=ASC(l1$)
SELECT l1|
CASE 0                        ! Touche sp‚ciale
l2|=ASC(RIGHT$(l1$))
SELECT l2|
CASE 61                       ! [F3] (sommaire)
change_key(1,TRUE)
cd$="SOMMAIRE"
keypress
CASE 62                       ! [F4] (guide)
change_key(2,TRUE)
cd$="GUIDE"
keypress
CASE 63                       ! [F5] (annulation)
IF g0|=1                      ! Si csr plac‚
OUT 1,8,13
ELSE                          ! Si csr ailleurs
loc(1,ys|+g4|)
PRINT #99;attrib$;            ! Att
ENDIF
OUT 1,24,127                  ! Efface ligne + csr
ligne$(g4|)=SPACE$(40)        ! Ligne vierge
ligne|(g4|)=0                 ! Long nul
g3|=1                         ! Pos csr
g0|=1                         ! Csr dans Fen cnt
CASE 64                       ! [F6] (correction)
GOTO cor_sys
CASE 65                       ! [F7] (retour)
IF g4|>0
restore_scsr                  ! R‚tablit car sous csr
DEC g4|
g3|=SUCC(ligne|(g4|))
IF g3|=41
g3|=40
ENDIF
loc(g3|,ys|+g4|)
PRINT #99;attrib$;             ! Att
OUT 1,127
g0|=1
ENDIF
CASE 66                       ! [F8] (suite)
IF g4|<nbls|
GOTO suite_sys
ELSE
GOTO cls_sys
ENDIF
CASE 67                       ! [F9] (r‚p‚tition)
change_key(7,TRUE)
cd$="REPETITION"
keypress
CASE 68                       ! [F10] (envoi)
cls_sys:
loc(1,ys|)                    ! Pos en haut fenˆtre
FOR l1|=0 TO nbls|            ! Eff fen
ligne$(l1|)=SPACE$(40)
ligne|(l1|)=FALSE
PRINT #99;attrib$;            ! Att
OUT 1,24,10
NEXT l1|
loc(1,ys|)                    ! Pos en haut fenˆtre
PRINT #99;attrib$;            ! Att
OUT 1,127
g4|=0                         ! 1Šre ligne
g3|=1                         ! 1Šre col
g0|=1
CASE 72                       ! FlŠch haut
IF g4|>0
restore_scsr                  ! R‚tablit car sous csr
OUT 1,8,11,127
DEC g4|
g0|=1
ENDIF
CASE 75                       ! FlŠch gauche
IF g3|>1 OR g4|>0
restore_scsr                  ! R‚tablit car sous csr
OUT 1,8,8,127
DEC g3|
IF g3|=0
DEC g4|
g3|=40
ENDIF
g0|=1
ENDIF
CASE 77                       ! FlŠch droite
IF g3|<40 OR g4|<nbls|
restore_scsr                  ! R‚tablit car sous csr
OUT 1,127
INC g3|
IF g3|=41
INC g4|
g3|=1
ENDIF
g0|=1
ENDIF
CASE 80                       ! FlŠch bas
IF g4|<nbls|
restore_scsr                  ! R‚tablit car sous csr
OUT 1,8,10,127
INC g4|
g0|=1
ENDIF
CASE 82                       ! [Insert]
l3|=ligne|(g4|)
IF g3|<=l3|
l2$=ligne$(g4|)
l1$=" "+MID$(l2$,g3|,40-g3|)
ligne$(g4|)=LEFT$(l2$,PRED(g3|))+l1$
IF l3|<40
INC ligne|(g4|)
ENDIF
IF g0|=1                      ! Si csr plac‚
OUT 1,8                       ! On va aff sur csr
ELSE                          ! Si csr ailleurs
loc(g3|,ys|+g4|)              ! On le place … l'end voulu
PRINT #99;attrib$;            ! Att
ENDIF
envoi_chaine(l1$)
loc(g3|,ys|+g4|)              ! Replace le csr
PRINT #99;attrib$;            ! Att
OUT 1,127
g0|=1
ENDIF
DEFAULT
function_keys
PRINT AT(60,24);"ES";
ENDSELECT
CASE 8                          ! [Backspace]
cor_sys:
IF g3|>1 OR g4|>0
restore_scsr                    ! R‚tablit car sous csr
DEC g3|                         ! Retourne au car pr‚c
IF g3|=0
DEC g4|
g3|=SUCC(ligne|(g4|))
IF g3|=41
OUT 1,8,8
g3|=40
ELSE
loc(g3|,ys|+g4|)
PRINT #99;attrib$;              ! Att
ENDIF
ELSE
OUT 1,8,8
ENDIF
OUT 1,127                       ! Efface car et aff csr
MID$(ligne$(g4|),g3|,1)=" "
IF ligne|(g4|)=g3|
ligne|(g4|)=PRED(g3|)
ENDIF
g0|=1
ENDIF
CASE 13                         ! [Return]
IF g4|<nbls|
suite_sys:
restore_scsr                    ! R‚tablit car sous csr
INC g4|
g3|=SUCC(ligne|(g4|))
IF g3|=41
g3|=40
ENDIF
loc(g3|,ys|+g4|)
PRINT #99;attrib$;              ! Att
OUT 1,127
g0|=1
ELSE
GOTO cls_sys
ENDIF
CASE 32 TO 126,129 TO 133,135 TO 140,147,148,150,151,156,158,171,172,180,181,221,225,241,246,248
IF g3|=40 AND g4|=nbls|       ! Si on est sur dern car fenetre
loc(1,ys|)                    ! Pos en haut fenˆtre
FOR l2|=0 TO nbls|            ! Efface fenˆtre
ligne$(l2|)=SPACE$(40)
ligne|(l2|)=FALSE
PRINT #99;attrib$;            ! Att
OUT 1,24,10
NEXT l2|
loc(1,ys|)                    ! Pos en haut fenˆtre
PRINT #99;attrib$;            ! Att
g4|=0                         ! 1Šre ligne
g3|=1                         ! 1Šre col
ELSE IF g0|=1                 ! Si csr plac‚
OUT 1,8                       ! On va aff sur csr
ELSE                          ! Si csr ailleurs
loc(g3|,ys|+g4|)              ! On le place … l'end voulu
PRINT #99;attrib$;            ! Att
ENDIF
IF l1|>127
IF mixt!
accent_80(l1|)
ELSE
code_accent(l1|)
ENDIF
PRINT #99;l1$;
ELSE
OUT 1,l1|
ENDIF
OUT 1,127                     ! Aff csr
MID$(ligne$(g4|),g3|,1)=CHR$(l1|) ! M‚mo new ligne
IF ligne|(g4|)<g3|            ! Si new long
ligne|(g4|)=g3|                 ! Fixe long ligne
ENDIF
INC g3|                       ! Avance csr
IF g3|=41                     ! Si hors-ligne
INC g4|                       ! Ligne suiv
g3|=1                         ! 1er car de la ligne
ENDIF
g0|=1                         ! Csr dans fen sys
CASE 127                      ! [Delete]
l3|=ligne|(g4|)
IF g3|<=l3|
l2$=ligne$(g4|)
l1$=MID$(l2$,SUCC(g3|))+" "
ligne$(g4|)=LEFT$(l2$,PRED(g3|))+l1$
IF l3|
DEC ligne|(g4|)
ENDIF
IF g0|=1                      ! Si csr plac‚
OUT 1,8                       ! On va aff sur csr
ELSE                          ! Si csr ailleurs
loc(g3|,ys|+g4|)              ! On le place … l'end voulu
PRINT #99;attrib$;            ! Att
ENDIF
envoi_chaine(l1$)
loc(g3|,ys|+g4|)              ! Replace csr
PRINT #99;attrib$;            ! Att
OUT 1,127
g0|=1
ENDIF
DEFAULT
kbd_l0_break
ENDSELECT
ELSE                          ! Si pas de touche … traiter
aff_temps_cnx
ENDIF
delai
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
IF clock%<TIMER
clock
ENDIF
LOOP UNTIL LEN(cd$)
IF LEN(page_a$)
enregistre(10,cd$)
ENDIF
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
RETURN
> PROCEDURE get_message
'
' Gest ‚dition d'un message au minitel:
'
CLR cd$
noeff_disable!=FALSE          ! Ce sera peut etre un no effect!
keyacq!=keypress!
loc(g2|,y|(7)+g3|)            ! Pos csr
PRINT #99,g5$;                ! Atts
mode|=1                       ! Pour pro function_keys
OUT 1,17                      ! Csr ON
csr!=TRUE
DO                            ! Attente car
IF LEN(key_trans$)            ! Si on a un code clav ST en attente
l1|=1-(ASC(key_trans$)=0)
l1$=LEFT$(key_trans$,l1|)
key_trans$=MID$(key_trans$,SUCC(l1|))
GOTO key_trans.3
ENDIF
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
get_message:
keypress
SELECT l1|
CASE 9,12,13,20,22,24,27,30,127
change_key(11,TRUE)
ENDSELECT
SELECT l1|                    ! En fonction du code recu.
CASE 9                        ! [Tab]
msg_tab
CASE 12                       ! [E.Page]
msg_e.page
CASE 13                       ! [CR]
g2|=1
IF g3|=0
loc(g2|,y|(7))                 ! Pos csr
PRINT #99,g5$;                 ! Atts
ELSE
OUT 1,13
ENDIF
CASE 19                       ! Si touche de fnct
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
keypress
SELECT l1|
CASE 65
change_key(8,TRUE)
cd$="ENVOI"
CASE 66               ! [Retour]
msg_up
EXIT IF TRUE
CASE 67               ! [Repetition]
msg_repet
EXIT IF TRUE
CASE 68
change_key(2,TRUE)
cd$="GUIDE"
CASE 69               ! [Annulation]
msg_annul
EXIT IF TRUE
CASE 70
change_key(1,TRUE)
cd$="SOMMAIRE"
CASE 71               ! [Correction]
msg_corr
EXIT IF TRUE
CASE 72               ! [Suite]
msg_down
EXIT IF TRUE
CASE 73 TO 77,80,81,83,86,87,88,89,91,92,94,112,113,114
proto_keys
DEFAULT
change_key(11,TRUE)
cd$="???"
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 20                       ! [Ctrl + T]
IF x|(3)
OUT 1,20
loc(x|(3),y|(3))
PRINT #99;g4$;"T";
loc(g2|,y|(7)+g3|)
PRINT #99,g5$;CHR$(17);
ENDIF
edimod!=TRUE                  ! Mode texte
CASE 22                       ! [Ctrl + V]
IF x|(3)
OUT 1,20
loc(x|(3),y|(3))
PRINT #99;g4$;"V";
loc(g2|,y|(7)+g3|)
PRINT #99,g5$;CHR$(17);
ENDIF
edimod!=FALSE                 ! Mode vid‚otex
CASE 24                       ! [Can]
MID$(ligne$(g3|),g2|)=SPACE$(40)
ligne|(g3|)=PRED(g2|)
IF g1!                        ! Si filler
fill_champ(PRED(g2|),40,g1$)
loc(g2|,y|(7)+g3|)            ! Pos csr
PRINT #99;g5$;                ! Atts
ELSE                          ! Pas de filler
can
ENDIF
CASE 25                           ! Si car acc
change_key(11,TRUE)
CLR m0|
DO
IF INP(TRUE)                      ! Si code en entr‚e
l2|=INP(1)                      ! M‚mo
keypress
IF m0|=FALSE                    ! Si on connait pas le type
SELECT l2|
CASE 65 TO 67,72,75             ! Accents,tr‚ma,c‚dille
m0|=l2|
CASE 35,39,48,49,56,60,62,106,122,123 ! Car sp‚ciaux
@decode_accent(l2|,0)
IF l1|=FALSE                    ! Si on a pas pu d‚coder
cd$="???"
ELSE                            ! Si car d‚cod‚
l2$=CHR$(25)+CHR$(l2|)
add_car_msg
EXIT IF TRUE
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ELSE                          ! Si on connait le type
SELECT l2|
CASE 97,99,101,105,111,117    ! Si voyelle min
@decode_accent(m0|,l2|)       ! D‚codage car
IF l1|=FALSE                  ! Si on a pas pu d‚coder
cd$="???"
ELSE                          ! Si car d‚cod‚
l2$=CHR$(25)+CHR$(m0|)+CHR$(l2|)
add_car_msg
EXIT IF TRUE
ENDIF
DEFAULT
cd$="???"
ENDSELECT
ENDIF
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 27                       ! [Esc]
DO
IF INP(TRUE)                ! Si code en entr‚e
l1|=INP(1)                  ! M‚mo
SELECT l1|
CASE 57
@deconnexion
cd$="PRO 1"
page_a$="x"
exit|=1
CASE 58
@deconnexion
cd$="PRO 2"
page_a$="x"
exit|=1
CASE 59
PAUSE 7
IF INP(TRUE)
l2|=INP(1)
IF l2|=99 OR l2|=115
FOR l3|=1 TO 2
IF INP(TRUE)
~INP(1)
ENDIF
NEXT l3|
cd$="ACQUIT."
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
EXIT IF TRUE
ENDIF
ENDIF
@deconnexion
cd$="PRO 3"
page_a$="x"
exit|=1
CASE 91
DO
IF INP(TRUE)                    ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
keypress
SELECT l1|
CASE 50                       ! [E.Page]
msg_e.page
l1%=TIMER
REPEAT
UNTIL INP(TRUE) OR TIMER-l1%>200
IF INP(TRUE)
~INP(1)
ENDIF
EXIT IF TRUE
CASE 52                       ! [Ins.C]
msg_ins.c
l1%=TIMER
REPEAT
UNTIL INP(TRUE) OR TIMER-l1%>200
IF INP(TRUE)
~INP(1)
ENDIF
EXIT IF TRUE
CASE 63                       ! Passage en 80 col
@deconnexion
cd$="PRO 80 COL"
page_a$="x"
exit|=1
CASE 65                       ! [FlŠch haut]
msg_haut
EXIT IF TRUE
CASE 66                       ! [FlŠch bas]
msg_bas
EXIT IF TRUE
CASE 67                       ! [FlŠch droit]
msg_droite
EXIT IF TRUE
CASE 68                       ! [FlŠch gauch]
msg_gauche
EXIT IF TRUE
CASE 72                       ! [Home]
g2|=1
g3|=1
loc(1,SUCC(y|(7)))            ! Pos csr
PRINT #99,g5$;                ! Atts
CASE 76                       ! [Ins.L]
IF g3|>0
INSERT ligne$(g3|)=SPACE$(40)
INSERT ligne|(g3|)=0
OUT 1,20
FOR m2|=nb_lignepage| DOWNTO g3|
l2|=ligne|(m2|)
l1$=LEFT$(ligne$(m2|),l2|)
loc(1,y|(7)+m2|)
PRINT #99;g5$;
OUT 1,24
envoi_chaine(l1$)
IF g1!
fill_champ(l2|,40,g1$)
ENDIF
NEXT m2|
g2|=1
loc(1,y|(7)+g3|)
OUT 1,17
PRINT #99,g5$;
ENDIF
EXIT IF TRUE
CASE 77                       ! [Sup.L]
IF g3|>0
DELETE ligne$(g3|)
DELETE ligne|(g3|)
ligne$(nb_lignepage|)=SPACE$(40)
ligne|(nb_lignepage|)=0
OUT 1,20
FOR m2|=g3| TO nb_lignepage|
l2|=ligne|(m2|)
l1$=LEFT$(ligne$(m2|),l2|)
loc(1,y|(7)+m2|)
PRINT #99;g5$;
OUT 1,24
envoi_chaine(l1$)
IF g1!
fill_champ(l2|,40,g1$)
ENDIF
NEXT m2|
g2|=ligne|(g3|)+1
ADD g2|,g2|=41
loc(g2|,y|(7)+g3|)
OUT 1,17
PRINT #99,g5$;
ENDIF
EXIT IF TRUE
CASE 80                       ! [Sup.C]
msg_sup.c
EXIT IF TRUE
DEFAULT
GOTO get_message
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF TRUE
DEFAULT
GOTO get_message
ENDSELECT
ENDIF
delai
LOOP UNTIL LEN(cd$)
EXIT IF LEN(cd$)
CASE 30                       ! [Home]
g2|=1
g3|=1
loc(1,SUCC(y|(7)))            ! Pos csr
PRINT #99,g5$;                ! Atts
CASE 127                      ! [Del]
msg_sup.c
DEFAULT                        ! Autre touche
IF l1|>31 AND l1|<127
change_key(10,l1|)
alignement
l1$=m3$
l2$=m3$
add_car_msg
ELSE
change_key(11,TRUE)
cd$="???"
ENDIF
ENDSELECT
ELSE IF INP(-2)               ! Si touche ST en entr‚e
l1$=INKEY$
key_trans.3:
l1|=ASC(l1$)
SELECT l1|
CASE 0
l1!=TRUE
l2|=ASC(RIGHT$(l1$))
IF clav!
IF l2|=>61 AND l2|<=68
change_key(l2|-60,TRUE)
ELSE IF l2|=>72 AND l2|<=82
change_key(11,TRUE)
ENDIF
SELECT l2|
CASE 61                       ! [F3]
cd$="SOMMAIRE"
CASE 62                       ! [F4]
cd$="GUIDE"
CASE 63                       ! [F5] (Annulation)
msg_annul
CASE 64                       ! [F6] (Correction)
msg_corr
CASE 65                       ! [F7] (Retour)
msg_up
CASE 66                       ! [F8] (Suite)
msg_down
CASE 67                       ! [F9] (Repetition)
msg_repet
CASE 68                       ! [F10]
cd$="ENVOI"
CASE 72                       ! [haut]
msg_haut
CASE 75                       ! [gauche]
msg_gauche
CASE 77                       ! [droite]
msg_droite
CASE 80                       ! [bas]
msg_bas
CASE 82                       ! [Ins]
msg_ins.c
DEFAULT
function_keys
ENDSELECT
IF l1!                        ! Si une touche clavier … ‚t‚ press‚e
keypress
ENDIF
ELSE
function_keys
ENDIF
DEFAULT
IF clav! AND l1|<>2 AND l1|<>4 AND l1|<>6 AND l1|<>16 ! Si ‚mul clav et pas break ni deco
keypress
SELECT l1|
CASE 8
msg_corr
CASE 9                        ! [Tab]
msg_tab
CASE 13
msg_down
CASE 32 TO 126,129 TO 133,135 TO 140,147,148,150,151,156,158,171,172,180,181,221,225,241,246,248
change_key(10,l1|)
IF l1|>127
IF mixt!
accent_80(l1|)
ELSE
code_accent(l1|)
ENDIF
l2$=l1$
ELSE
l2$=CHR$(l1|)
ENDIF
alignement
l1$=m3$
add_car_msg
CASE 127                      ! [Del]
change_key(11,TRUE)
msg_sup.c
DEFAULT
change_key(11,TRUE)
cd$="???"
ENDSELECT
ELSE                          ! Gest touches g‚n‚rales
kbd_l0_break
ENDIF
ENDSELECT
ELSE                          ! Si pas de touche … traiter
aff_temps_cnx
ENDIF
delai
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
IF clock%<TIMER
clock
ENDIF
LOOP UNTIL LEN(cd$)
IF LEN(page_a$)
enregistre(10,cd$)
ENDIF
OUT 1,20                      ! Csr OFF
csr!=FALSE
IF l0|=1 AND keypress!=FALSE
topline
ENDIF
RETURN
' Voir aussi Reception.2 et Normal (partie ST seulement)
'
> PROCEDURE id_term
'
' Id type mntl selon terminal$:
'
bi!=TRUE                      ! Bistandard par d‚faut
mi2!=FALSE                    ! Pas un M2 par d‚faut
l1$=LEFT$(terminal$,2)
IF l1$="Bb" OR l1$="Br" OR l1$="Cb" OR l1$="Cc" OR l1$="Ce" OR l1$="Cr" OR l1$="Cs"
minitel$=" 1 "
bi!=FALSE
ELSE IF l1$="Au" OR l1$="Bu" OR l1$="Cu"
minitel$=" 1B"
ELSE IF l1$="Bf"
minitel$=" 1C"
bi!=FALSE
ELSE IF l1$="Br"
minitel$=" 1D"
bi!=FALSE
ELSE IF l1$="Bv" OR l1$="Cv"
minitel$=" 2 "
mi2!=TRUE
ELSE IF l1$="Ay"
minitel$=" 5 "
ELSE IF l1$="Bd" OR l1$="Cd" OR l1$="Cf"
minitel$=" 10"
bi!=FALSE
ELSE IF l1$="Cw"
minitel$="10B"
ELSE IF l1$="Cz"
minitel$=" 12"
ELSE IF l1$="Bz"
minitel$="12+"
mi2!=TRUE           ! DRCS ok
ELSE IF l1$="Pv"
minitel$="Phot"     ! Minitel photo!
mi2!=TRUE           ! DRCS ok
ELSE
minitel$="odem"
ENDIF
RETURN
> PROCEDURE image(type|)
'
' Gest page selon type|:
' 0 : START, IMAGE
' 1 : TABL_CNX
' 4 : EFFA_BAL
' 5 : EFF_MSGB
' 6 : EFFA_REP
'
PRINT AT(29,7);"Fonction: Image de fond";
PRINT AT(3,14);"En cours: [paramŠtres].";
IF type|=4 OR type|=5 AND info_bal|<2    ! Si cnt n'a pas de BAL
page_msgsys(2)                ! Vous n'avez pas de BAL
page_a$=parametre$(10)        ! Page erreur
ELSE IF type|=5 AND nb_balmsg|=FALSE
page_msgsys(3)                ! Votre BAL est d‚ja vide!
page_a$=parametre$(10)        ! Page erreur
ELSE IF type|=6 AND info_rep|<>1
SELECT info_rep|
CASE 0                        ! Si cnt n'a pas de r‚p
page_msgsys(2)                ! Vous n'avez pas de r‚p
CASE 2
page_msgsys(3)                ! BAL ferm‚e,r‚p obligatoire
CASE 3
page_msgsys(4)                ! TRANSFERT, r‚p obligatoire
ENDSELECT
page_a$=parametre$(10)        ! Page erreur
ELSE
IF type|=1                    ! Aff tabl cnxs
tabl_cnx                      ! Cr‚ation du tableau des connexions
ENDIF
IF type|<4
IF parametre$(36)<>"1"
g0&=TRUE                      ! Pas de tempo.
ELSE
g0&=VAL(parametre$(9))        ! Tempo en sec
ENDIF
l2&=10
ELSE
IF parametre$(38)<>"1"
g0&=TRUE                      ! Pas de tempo.
ELSE
g0&=VAL(parametre$(11))       ! Tempo en sec
ENDIF
l2&=12
ENDIF
FOR l1|=0 TO 9                  ! Touches de sortie
IF parametre$(l2&+l1|)=""
key|(l1|)=255
ELSE
key|(l1|)=VAL(parametre$(l2&+l1|))
ENDIF
NEXT l1|
IF parametre$(33)="1"
x|(0)=1
y|(0)=VAL(parametre$(36))
decode_attrib(0,parametre$(37)) ! Att pseud
g2$=l1$
ELSE
x|(0)=FALSE
ENDIF
CLR g1$
ptr_msg&=1               ! Ptr d'aff r‚p
ptr_line&=FALSE
interrupt!=TRUE
msg_int!=TRUE
DO
IF ptr&>0
PRINT AT(13,14);"Affichage de la page vid‚otex.      ";
affiche_vdt(page_v&)
t%=TIMER
ENDIF
IF type|=6 AND ptr&=TRUE
IF x|(0)
IF ptr_msg&>0
PRINT AT(13,13);"Affichage du r‚pondeur.             ";
affiche_msg(CHR$(0)+repondeur$+STRING$(20,CHR$(0)),1,y|(0),rep_nbl|,40,g2$)
ENDIF
IF ptr_msg&=TRUE
ptr&=-2
ENDIF
ELSE
ptr&=-2
ENDIF
ENDIF
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
IF type|<4 OR parametre$(34)<>"1"
PRINT AT(3,15);"Commande: ";
IF type|<4
get_command(TRUE,g0&,t%,0,1,2,3,4,5,6,7,8,21,"","")
ELSE
get_command(TRUE,g0&,t%,0,2,3,4,5,6,7,8,41,23,"","")
ENDIF
ELSE
PRINT AT(3,15);"Commande: Effacement automatique";
cd$="ENVOI"
ENDIF
EXIT IF LEN(page_a$)
IF cd$="ENVOI"
IF type|<4                    ! IMAGE, TABL_CNX...
' Si on est l… c'est qu'il n'y a pas eu de branchement vers une autre arbo
no_effect                 ! Touche sans effet
ELSE
SELECT type|
CASE 4
detruit_bal
CASE 5
page_msgsys(4)                ! Vidage de BAL en cours!
CLR nb_balmsg|                ! Nb msgs en BAL
FOR l1|=0 TO 19               ! Init msgs (full)
msg_bal$(l1|)=STRING$(24,CHR$(0))
NEXT l1|
info_bal|=3                   ! La BAL … ‚t‚ modifi‚e.
CASE 6
page_msgsys(5)                ! Suppression du r‚pondeur
PRINT AT(77,17);"N";          ! Signale la supp … l'‚cran
info_bal|=3                   ! Statut BAL=modifi‚e
info_rep|=FALSE               ! Pas de rep
repondeur$=""
ENDSELECT
page_a$=parametre$(9)
topline
ENDIF
ELSE IF cd$="TEMPO"
IF type|<4
page_a$=parametre$(20)
ELSE
page_a$=parametre$(22)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
ENDIF
RETURN
> PROCEDURE imprime_msg
LOCAL confirm|,l.p1&,l.p2&
'
PRINT AT(52,24);cursor.c$(0);cursor.f$(0);"I";normal.c$;normal.f$(0); ! Impression en cours
msgsys("121")               ! Clavier d‚sactiv‚
IF no_msg_cour&=TRUE
ALERT 1,"|Il n'y a pas de message|… imprimer!",1,"Annuler",confirm|
ELSE
IF BIOS(8,0)                ! Si imprimante prˆte:
ALERT 2,"Imprimer le message|affich‚ … l'‚cran|du minitel?",2,"Imprimer|Annuler",confirm|
IF confirm|=1             ! Si confirmation de l'impression
LPRINT "Message de:"'expedit$
LPRINT "Pour"'destinat$
IF fnct|<>18 AND imprim_rep!=FALSE ! Si pas r‚pondeur
LPRINT "Date:"'dat$'"  Heure:"'tim$
LPRINT "Titre:"'titre_msg$
ENDIF
l.p1&=1
FOR l1&=1 TO nbpg_msg&
LPRINT
IF fnct|<>18 AND imprim_rep!=FALSE
LPRINT "Page:"'l1&
ENDIF
l.p2&=INSTR(text_msg$,CHR$(SUCC(l1&)),l.p1&)
'
FOR l.p1&=SUCC(l.p1&) TO PRED(l.p2&)
l1|=ASC(MID$(text_msg$,l.p1&,1)) ! Code … afficher
IF l1|<=5                     ! Si retour … la ligne
LPRINT
ELSE IF l1|=35 AND l.p1&<PRED(l.p2&)
l2|=ASC(MID$(text_msg$,SUCC(l.p1&),1))
IF (l2|>63 AND l2|<74) OR (l2|>75 AND l2|<96 AND l2|<>91 AND l2|<>94)
INC l.p1&
ELSE
LPRINT CHR$(l1|);
ENDIF
ELSE
LPRINT CHR$(l1|);
ENDIF
'
NEXT l.p1&
'          l.p1&=l.p2&   (automatique)
NEXT l1&
LPRINT
LPRINT
LPRINT
LPRINT
LPRINT
ENDIF
ELSE                ! Si imprimante pas prˆte
ALERT 1,"|L'imprimante n'est|pas prˆte … recevoir|des donn‚es...",1,"Annuler",confirm|
ENDIF
ENDIF
msgsys("120")                 ! Clavier activ‚
PRINT AT(52,24);"I";          ! Impression possible
RETURN
> PROCEDURE init_bal
'
' Init BAL courante:
'
pseudo$=""
info_bal|=FALSE               ! Staut BAL
raz_bal                       ! THE PROCEDURE
CLR bal_envois|               ! Pas encore envoy‚ de msg
CLR bal_lus|                  ! Pas encore lu de msg
FOR l1|=0 TO 19               ! Init msgs
msg_envoi$(l1|)=""            ! List msgs envoy‚s
msg_disk$(l1|)=""             ! Msgs … ‚crire sur disk
msg_lus$(l1|)=""              ! Msgs lus
NEXT l1|
RETURN
> PROCEDURE init_champ(p.no_coord&,attrib$,p.long&)
'
' Init d'un champ ‚ditable:
'
loc(x|(p.no_coord&),y|(p.no_coord&))
PRINT #99;attrib$;
repeat_fill(p.long&)
g0$=SPACE$(p.long&)
g0|=1
RETURN
> PROCEDURE inp_aut_pseu(x|,y|,a|,b|,c|)
'
' Entr‚e d'un pseu auxiliaire:
'
g0!=FALSE
DO
IF g0!=FALSE
locate_ptr(page_v&)
IF ptr&>0
interrupt!=FALSE
PRINT AT(13,14);"Affichage de la page Demande pseudo.";
affiche_vdt(page_v&)
t%=TIMER
GOTO dem_pseu_init
ENDIF
IF page_v&=TRUE
page_v&=-2
dem_pseu_init:
loc(x|,y|)
PRINT #99;g4$;g1$;
OUT 1,18,79
g0$=SPACE$(16)
g0|=1
ENDIF
ENDIF
CLR g0!
loc(x|+PRED(g0|),y|)
PRINT #99;g4$;
PRINT AT(13,14);"Demande du pseudo du destinataire.  ";
PRINT AT(3,15);"Commande: ";
IF LEN(trans$) AND LEFT$(trans$)=CHR$(1)
l2$=MID$(trans$,2,16)
envoi_chaine(l2$)
l2|=LEN(l2$)
MID$(g0$,1,l2|)=l2$
g0|=l2|+1
trans$=""
cd$="TRANSMIT"
ELSE
get_command(TRUE,TRUE,t%,1,a|,b|,41,41,41,41,41,41,41,g1$,"")
ENDIF
IF cd$="REPETITION"
IF c|
page_a$=parametre$(c|)
ENDIF
ELSE IF cd$="ENVOI" OR cd$="TRANSMIT"
PRINT AT(3,16);"Destinataire: ";
IF nb_pseudos&=FALSE          ! S'il n'y a pas de bal
page_msgsys(7)               ! Il n'y a aucune bal
ELSE
m1$=TRIM$(g0$)
IF LEN(m1$)=FALSE             ! Si pseu invalid
page_msgsys(8)                ! Pseudo invalide
ELSE
PRINT m1$;SPC(16);            ! Affich dest
m1$=UPPER$(m1$)
FOR m1&=0 TO PRED(nb_pseudos&) ! Recherch nø de BAL
EXIT IF UPPER$(pseudo$(m1&))=m1$
NEXT m1&
EXIT IF m1&<>nb_pseudos&      ! Si BAL exist on s'en va
page_msgsys(9)                ! Cette BAL n'existe pas
ENDIF
ENDIF
ELSE IF cd$="ANNULATION"
IF ptr&=TRUE
loc(x|,y|)
PRINT #99;g4$;g1$;
OUT 1,18,79
g0$=SPACE$(16)
g0|=1
ENDIF
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE ins.car
'
' Ins car ds get_com
'
IF mode|=1
IF g0|<=g1|
l1$=" "+MID$(g0$,g0|,g1|-g0|)
g0$=LEFT$(g0$,PRED(g0|))+l1$
FOR l1|=LEN(l1$) DOWNTO 1
IF MID$(l1$,l1|,1)<>" "
EXIT IF LEN(mask$)=FALSE
MID$(l1$,l1|,1)=mask$
ELSE
MID$(l1$,l1|,1)=filler$
ENDIF
NEXT l1|
envoi_chaine(l1$)
ENDIF
g0!=TRUE                      ! Pas de r‚aff
ENDIF
RETURN
'
> PROCEDURE journal
'
' Gest page JOURNAL:
'
PRINT AT(29,7);"Fonction: Image en cours";
PRINT AT(3,14);"En cours: [paramŠtres].";
g1!=-VAL(parametre$(12))      ! -1 si Suit/Ret actifs
g2!=-VAL(parametre$(13))      ! -1 si mode num
g3!=-VAL(parametre$(14))      ! -1 si mode cyclique
g4!=FALSE                     ! A priori on est pas mode "guide edit"
FOR g1&=0 TO 9                ! Plus petite page
EXIT IF LEN(parametre$(g1&))
NEXT g1&
FOR g2&=9 DOWNTO 0            ! Plus grande page
EXIT IF LEN(parametre$(g2&))
NEXT g2&
IF VAL(parametre$(22))        ! Si tempo
g0&=VAL(parametre$(10))       ! Tempo (s)
ELSE
g0&=TRUE                      ! Pas de tempo
ENDIF
g0|=VAL(parametre$(11))       ! Page de start
IF g0|>0                      ! S'il faut rechercher la page
PRINT AT(14,7);SPC(8);
LOCATE 19,7                   ! Pos CSR pour nom de page
page_v$=parametre$(g0|)         ! Nom de la page vdt dem
find_page                       ! Cherche son nø
ENDIF
FOR l1|=0 TO 9                  ! Attrib des touches de sortie
key|(l1|)=48+l1|
NEXT l1|
IF fnct|=29                   ! Si page MSG_GUID
l1|=ASC(LEFT$(trans$))        ! Type de paramŠtre
IF l1|=5 OR l1|=7 OR l1|=9 OR l1|=11 OR l1|=13 ! Si param d'arriv‚e OK
l2|=INSTR(trans$,CHR$(0),2)
l1$=MID$(trans$,2,l2|-2)      ! Page d'arriv‚e
parametre$(16)=l1$            ! Guide
parametre$(19)=l1$            ! Retour
trans$=CHR$(SUCC(l1|))+MID$(trans$,SUCC(l2|)) ! Chaine … retourner
g4!=TRUE                      ! On passe en mode "Guide edit"
ENDIF
ENDIF
CLR g1$
interrupt!=TRUE
DO
IF ptr&>0
PRINT AT(13,14);"Affichage de la page vid‚otex nø";g0|;
affiche_vdt(page_v&)
t%=TIMER
ENDIF
PRINT AT(13,14);"Traitement des commandes.";SPC(8);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,g0&,t%,0,15,16,17,18,41,41,41,21,41,"","")
EXIT IF LEN(page_a$)
IF cd$="RETOUR"
IF g1!                        ! Si Suit\Ret actifs
IF g0|>0 OR g3!               ! Si pas page 0 ou si cycle actif
IF g0|<=g1& AND g3!
l1&=9
ELSE
l1&=PRED(g0|)
ENDIF
FOR l1&=l1& DOWNTO 0
EXIT IF parametre$(l1&)<>""
NEXT l1&
IF l1&=>0
g0|=l1&
LOCATE 19,7                   ! Pos CSR pour nom de page
page_v$=parametre$(g0|)       ! Nom page vdt dem
find_page                     ! Installe page
ELSE
GOTO jour_prem
ENDIF
ELSE                          ! Plus de page aprŠs
jour_prem:
IF LEN(parametre$(19))        ! S'il faut partir
page_a$=parametre$(19)
ELSE
page_msgsys(2)              ! PremiŠre page
locate_ptr(page_v&)
ENDIF
ENDIF
ELSE
page_a$=parametre$(19)
cond_no_effect                  ! No effect conditionnel si len(page)=0
ENDIF
ELSE IF cd$="SUITE" OR cd$="TEMPO"
IF g1! OR cd$="TEMPO"          ! Si Suit\Ret actifs
IF g0|<9 OR g3!                ! Si pas page 9 ou si cycle actif
IF g0|=>g2& AND g3!
l1&=0
ELSE
l1&=SUCC(g0|)
ENDIF
FOR l1&=l1& TO 9
EXIT IF parametre$(l1&)<>""
NEXT l1&
IF l1&<10
g0|=l1&
LOCATE 19,7                     ! Pos CSR pour nom de page
page_v$=parametre$(g0|)       ! Nom page vdt dem
find_page                     ! Installe page
ELSE
GOTO jour_dern
ENDIF
ELSE                            ! Plus de page aprŠs
jour_dern:
IF LEN(parametre$(20))          ! S'il faut partir
page_a$=parametre$(20)
ELSE
page_msgsys(3)                ! DerniŠre page
locate_ptr(page_v&)
IF cd$="TEMPO"                  ! S'il faut bloquer la TEMPO
ADD t%,120000                 ! Ajoute 10 mn (!) au compteur
ENDIF
ENDIF
ENDIF
ELSE
page_a$=parametre$(20)
cond_no_effect                  ! No effect conditionnel si len(page)=0
ENDIF
ELSE IF cd$="REPETITION"
IF page_v&>-1
ptr&=1                    ! Ptr en d‚but de page
ELSE
page_msgsys(4)              ! Pas de page … r‚afficher
ENDIF
ELSE IF LEFT$(cd$,2)="TO" AND g2! ! Cd TOUCHE x et autorisation
l1|=VAL(RIGHT$(cd$))        ! Nø de touche
IF LEN(parametre$(l1|))     ! S'il y a une page corresp
g0|=l1|
LOCATE 19,7                 ! Pos CSR pour nom de page
page_v$=parametre$(g0|)     ! Nom page vdt dem
find_page                   ! Installe page
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
IF g4! AND exit|=FALSE        ! Si mode "guide edit"
exit|=3                       ! il y a des params dans trans$
ENDIF
RETURN
'
> PROCEDURE kbd_l0_break
LOCAL l.page_v&,ptr&,interrupt!
'
' Gestion clavier ST
'
noeff_disable!=FALSE          ! Ce sera peut etre un no effect!
SELECT l1|
CASE 2                        ! [Ctrl B]
cd$="DEM.BREAK"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
IF mode|<2
msgsys("121")                 ! Clavier d‚sactiv‚
break
IF b%=11
cd$="BREAK"
page_a$="x"
exit|=5
ELSE
msgsys("120")                 ! Clavier activ‚
ENDIF
ENDIF
CASE 4                        ! [Ctrl D]
msgsys("110")                 ! D‚connexion!
cd$="DECO"
page_a$="x"
exit|=1
l0|=2
@deconnexion
CASE 6                        ! [Ctrl F]
change_key(0,TRUE)
cd$="FIN"
page_a$=page_cnxfin$
CASE 8                        ! [Backspace]
IF sys_pos|>0
PRINT AT(11+sys_pos|,24);cursor.f$(0)'normal.f$(0)'
DEC sys_pos|
sysop$=LEFT$(sysop$,sys_pos|)
ENDIF
CASE 13                       ! [Return]
IF (mode|<2 OR mode|=10) AND msg_sysop!=FALSE ! Si on est pas au t‚l‚ch ou d‚j… en train d'afficher
IF csr!                       ! Si curseur
OUT 1,20                      ! Eteind
ENDIF
loc(1,0)
font_restore                  ! Restore DRCS si valid‚
OUT 1,24
IF nbp_vdt&                   ! S'il exist des pages VDT
FOR l.page_v&=0 TO PRED(nbp_vdt&)
EXIT IF nom_vdt$(l.page_v&)=sysop_page$ AND info_vdt|(l.page_v&)<>2
NEXT l.page_v&
ENDIF
IF l.page_v&<nbp_vdt& AND LEN(page_vdt$(l.page_v&))>0
interrupt!=FALSE
ptr&=1
msg_sysop!=TRUE
affiche_vdt(l.page_v&)          ! Affiche page vid‚otex
msg_sysop!=FALSE
ENDIF
envoi_chaine(sysop$)   ! texte du message
OUT 1,10
l0|=2                         ! Signale msg sys
IF csr!                       ! Si curseur
OUT 1,17                      ! Allume
ENDIF
ENDIF
CASE 16                       ! [Ctrl P]
cd$="DEM.PRINT"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
IF mode|=0
SELECT fnct|
CASE 10,11,15,16,18
imprime_msg                   ! Imprimer message
DEFAULT                       ! Impossible d'imprimer
OUT 2,7
ENDSELECT
ELSE IF mode|<>10              ! Impossible d'imprimer et pas att cnx
OUT 2,7
ENDIF
CASE 7,27,32 TO 126,129 TO 133,135 TO 140,147,148,150,151,156,158,171,172,180,181,221,225,241,246,248
IF sys_pos|<sysop_maxlong&
INC sys_pos|
sysop$=sysop$+l1$
IF l1|=7
l1$=cursor.c$(0)+cursor.f$(0)+"B"+normal.c$
ELSE IF l1|=27
l1$=cursor.c$(0)+cursor.f$(0)+"E"+normal.c$
ENDIF
PRINT AT(11+sys_pos|,24);l1$;cursor.f$(0)'normal.f$(0);
ENDIF
ENDSELECT
RETURN
> PROCEDURE keypress
'
' A chaque touche:
'
deco%=TIMER
stade|=FALSE
keypress!=FALSE
PRINT AT(78,4);"0";           ! Stade=0
RETURN
'
> PROCEDURE lect_msg(p.mode&)
LOCAL l.page_fond&,l.page_suiv&,l.msg_suiv&
LOCAL l.old!                  ! Si message date de la v2.24
LOCAL expedit$,destinat$,no_msg_cour&,titre_msg$,nbpg_msg&,text_msg$
'
' Lecture des msgs en BAL/RUB:
'
PRINT AT(29,7);"Fonction: Fond lecture";
PRINT AT(3,14);"En cours: [paramŠtres].";
IF p.mode&=FALSE              ! Si lecture BAL
enregistre(10,"Lecture messages en BAL")
IF info_bal|<2                ! Si cnt n'a pas de BAL
page_msgsys(3)                ! Pas de BAL
enregistre(52,"Pas de BAL!")
page_a$=parametre$(1)
GOTO fin_lect_msg
ENDIF
g7|=nb_balmsg|                ! Nb msgs … lire
g8|=bal_nb_lignepage|         ! Nb lignes/page
g5!=bal_titre!                ! titre?
destinat$="BAL "+pseudo$      ! Destinataire
ELSE                          ! Si lecture rub
PRINT AT(3,11);"Rubrique: ";
rubrique$=parametre$(1)       ! Nom rub
real_name(rubrique$)          ! Si r‚f … une m‚m de page
enregistre(10,"Lecture rubrique: "+rubrique$)
find_rub                      ! Cherch nø rub
IF exit|
GOTO fin_lect_msg
ENDIF
g7|=param_rub|(rub|,4)        ! Nb msgs … lire
IF g7|>param_rub|(rub|,0)     ! Si trop de msgs
g7|=param_rub|(rub|,0)        ! On fait comme si il y en avait -
ENDIF
g8|=param_rub|(rub|,2)        ! Nb lignes/page
g5!=-BTST(param_rub|(rub|,3),0) ! Titre ?
destinat$="rubrique "+rubrique$
ENDIF
l.page_fond&=page_v&          ! Nø page Fond
'
PRINT AT(14,8);"nø2: ";
page_v$=TRIM$(LEFT$(parametre$(39),8)) ! Nom page SUIVANT
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_lect_msg
ENDIF
PRINT AT(29,8);"Fonction: Page suivante";
l.page_suiv&=page_v&          ! Nø page SUIVANT
'
PRINT AT(14,9);"nø3: ";
page_v$=TRIM$(RIGHT$(parametre$(39),8)) ! Nom page MSG SUIV
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_lect_msg
ENDIF
PRINT AT(29,9);"Fonction: Msg suivant";
l.msg_suiv&=page_v&           ! Nø page SUIVANT
'
IF LEN(parametre$(5))         ! Car avant ENVOI pour r‚pondre ?
CLR g3!
ELSE
g3!=TRUE
ENDIF
IF LEN(parametre$(7))         ! Car. av. ENVOI pour r‚pondre en BAL ?
CLR g4!
ELSE
g4!=TRUE
ENDIF
decode_attrib(1,parametre$(13)) ! Att infos
g4$=l1$
decode_attrib(0,parametre$(14)) ! Att msg
g5$=l1$
l1|=ASC(trans$)
IF (l1|=4 OR l1|=14) AND p.mode&=1 ! Si nø de start msg rub transmis
l1&=INSTR(trans$,CHR$(0),2)
IF MID$(trans$,2,l1&-2)=rubrique$
no_msg_cour&=ASC(MID$(trans$,SUCC(l1&),1))
IF l1$=CHR$(4)                ! Si on a pas transmis nø de page
trans$=""
ENDIF
ENDIF
ELSE IF (l1|=2 OR l1|=12) AND p.mode&=FALSE ! Si nø de start msg bal transmis
no_msg_cour&=ASC(MID$(trans$,2,1))
IF l1$=CHR$(2)                ! Si on a pas transmit nø de page
trans$=""
ENDIF
ELSE
no_msg_cour&=VAL(parametre$(15))       ! Nø start msg par d‚faut
ENDIF
IF no_msg_cour&>g7|                    ! Si nø de start trop ‚lev‚
no_msg_cour&=g7|
ENDIF
DEC no_msg_cour&
g1!=-VAL(parametre$(16))      ! Mode gest SUITE/RETOUR
IF g1!
g6$="SUITE"
g7$="RETOUR"
ELSE
g6$="RETOUR"
g7$="SUITE"
ENDIF
m1&=VAL(parametre$(17))
IF BTST(m1&,0)
x|(0)=VAL(parametre$(18))     ! Coord pseu exp
y|(0)=VAL(parametre$(19))
ELSE
x|(0)=FALSE
ENDIF
IF BTST(m1&,1)
x|(1)=VAL(parametre$(20))     ! Coord Date d'envoi
y|(1)=VAL(parametre$(21))
g1|=VAL(parametre$(22))       ! Type de date
ELSE
x|(1)=FALSE
ENDIF
IF BTST(m1&,2)
x|(2)=VAL(parametre$(23))     ! Coord Heure d'envoi
y|(2)=VAL(parametre$(24))
g2|=VAL(parametre$(25))       ! Type d'heure
ELSE
x|(2)=FALSE
ENDIF
IF BTST(m1&,3)
x|(3)=VAL(parametre$(26))     ! Coord Mode lect
y|(3)=VAL(parametre$(27))
ELSE
x|(3)=FALSE
ENDIF
IF LEFT$(trans$)=CHR$(14)
lectmod!=ASC(MID$(trans$,5+LEN(rubrique$),1))-1
g10$=MID$(trans$,6+LEN(rubrique$))
ELSE
lectmod!=0                    ! Mode par d‚faut (chronologique)
g10$=""
ENDIF
g8$=parametre$(9)             ! Lettre pour mode R‚ponses
g9$=parametre$(10)            ! Lettre pour mode Normal
IF BTST(m1&,4)
x|(4)=VAL(parametre$(28))     ! Coord nb r‚p
y|(4)=VAL(parametre$(29))
ELSE
x|(4)=FALSE
ENDIF
IF BTST(m1&,5)
x|(5)=VAL(parametre$(30))     ! Coord nø msg
y|(5)=VAL(parametre$(31))
g3|=VAL(parametre$(32))       ! Type de nø
IF g3|=1
no_msg$="00/"+RIGHT$("0"+STR$(g7|),2)
ELSE
no_msg$="00"
ENDIF
ELSE
x|(5)=FALSE
ENDIF
IF BTST(m1&,6)
x|(6)=VAL(parametre$(33))     ! Coord nø page
y|(6)=VAL(parametre$(34))
g4|=VAL(parametre$(35))       ! Type de nø
IF g4|=1
no_page$="0/0"
ELSE
no_page$="0"
ENDIF
ELSE
x|(6)=FALSE
ENDIF
IF g5!                         ! Si titre
x|(7)=VAL(parametre$(36))     ! Coord X titre.
y|(7)=VAL(parametre$(38))     ! Coord Y titre.
ELSE
x|(7)=FALSE
ENDIF
y|(8)=VAL(parametre$(37))     ! Coord msg
'
PRINT AT(52,24);"I";            ! Impression possible
aff_page_1(l.page_fond&,FALSE)
g0$=" "
g2!=TRUE                      ! On va changer de msg
msg_int!=TRUE
DO                            ! Boucle de lecture
IF g2!                        ! Si on veut changer de msg
PRINT AT(13,14);"Affichage du message nø: ";SUCC(no_msg_cour&);SPC(10);
g2!=FALSE                     ! On aura chang‚
g6|=1                         ! On va changer de page
IF no_msg_cour&=>0            ! S'il y a un msg … afficher
IF p.mode&                    ! rub
g1$=msg_rub$(rub|,no_msg_cour&)  ! Msg complet
ELSE                          ! bal
g1$=msg_bal$(no_msg_cour&)    ! Msg complet
ENDIF
ELSE                          ! Si pas de msg
g1$=SPACE$(40)
ENDIF
l1|=20*p.mode&+1              ! Offset bal/rub
g3&=INSTR(g1$,CHR$(0),l1|)
IF g3&
expedit$=MID$(g1$,l1|,g3&-l1|)     ! Pseudo exp
ELSE
expedit$=""
ENDIF
IF x|(0)                      ! S'il fo l'aff
loc(x|(0),y|(0))
PRINT #99;g4$;
envoi_chaine(expedit$)
fill_champ(LEN(expedit$),16," ")
ENDIF
'
INC g3&                       ! On passe … la date
dat$=MID$(g1$,g3&,10)         ! Extract date
IF x|(1)                      ! S'il fo l'aff
IF no_msg_cour&=TRUE          ! Si pas de msg
l2$=" "
ELSE                          ! si msg
l2$="/"
ENDIF
IF g1|=1
l1$=LEFT$(dat$,2)+l2$+MID$(dat$,4,2)+l2$+RIGHT$(dat$,4)
ELSE IF g1|=2
l1$=LEFT$(dat$,2)+l2$+MID$(dat$,4,2)+l2$+RIGHT$(dat$,2)
ELSE
l1$=LEFT$(dat$,2)+l2$+MID$(dat$,4,2)
ENDIF
loc(x|(1),y|(1))
PRINT #99;g4$;l1$;
ENDIF
'
ADD g3&,11-p.mode&            ! On passe … l'heure
tim$=MID$(g1$,g3&,8)          ! Extract heure
IF x|(2)                      ! S'il fo afficher
IF g2|=1
l1$=tim$
ELSE
l1$=LEFT$(tim$,5)
ENDIF
loc(x|(2),y|(2))
PRINT #99;g4$;l1$;
ENDIF
'
IF p.mode&                    ! Si rub
IF x|(3)                      ! Si aff mode de lecture demand‚
loc(x|(3),y|(3))
PRINT #99;g4$;
IF lectmod!
PRINT #99;g8$;
ELSE
PRINT #99;g9$;
ENDIF
ENDIF
IF x|(4)
loc(x|(4),y|(4))
PRINT #99;g4$;MID$(g1$,19,2); ! Nb r‚ponses
ENDIF
ELSE                          ! Si bal
ADD g3&,8                     ! On passe … l'accus‚ de lect
IF MID$(g1$,g3&,1)=CHR$(0)    ! Pas encore lu
l1$=MID$(g1$,g3&-19,10)+MID$(g1$,g3&-8,8)+pseudo$
MID$(msg_bal$(no_msg_cour&),g3&,1)=CHR$(1) ! Msg aura ‚t‚ lu
info_bal|=3                   ! On a modifi‚ la BAL
IF expedit$=pseudo$           ! Si msg de soi-mˆme
l1|=LEN(l1$)
FOR l3|=0 TO PRED(nb_envoimsg|)
IF LEFT$(msg_envoi$(l3|),l1|)=l1$
MID$(envoistate$,20-l3|,1)="L"
EXIT IF TRUE
ENDIF
NEXT l3|
ELSE                          ! Si msg est d'un autre
msg_lus$(bal_lus|)=expedit$+CHR$(0)+l1$ ! M‚mo Exp‚diteur + Date
INC bal_lus|                  ! 1 message de plus … "accuser"
ENDIF
ENDIF
ENDIF
'
IF x|(5)                      ! Si on veut le nø du msg
IF g3|=1
no_msg$=RIGHT$("0"+STR$(SUCC(no_msg_cour&)),2)+"/"+RIGHT$("0"+STR$(g7|),2)
ELSE
no_msg$=RIGHT$("0"+STR$(SUCC(no_msg_cour&)),2)
ENDIF
loc(x|(5),y|(5))
PRINT #99;g4$;no_msg$;
ENDIF
ADD g3&,1+7*p.mode&           ! On passe au nb de pages
nbpg_msg&=VAL(MID$(g1$,g3&,1))
'                          extraction du titre
INC g3&
l1&=INSTR(g1$,CHR$(1),g3&)    ! fin titre
IF l1&=g3&                    ! Si message date de STUT ONE 2.24
INC g3&
l2&=INSTR(g1$,CHR$(0),g3&)    ! fin titre
titre_msg$=LEFT$(MID$(g1$,g3&,l2&-g3&)+SPACE$(20),20) ! Titre
l.old!=TRUE
ELSE IF l1&>g3&                 ! Message STUT ONE 2.30
titre_msg$=MID$(g1$,g3&,l1&-g3&)       ! Titre
l.old!=FALSE
ELSE
titre_msg$=SPACE$(20)
l.old!=FALSE
ENDIF
text_msg$=MID$(g1$,l1&)       ! Texte effectif
'
IF x|(7)                      ! S'il faut afficher le titre
loc(x|(7),y|(7))
PRINT #99;g5$;SPC(20);
loc(x|(7),y|(7))
PRINT #99;g5$;
envoi_chaine(titre_msg$)
ENDIF
'
g3&=1
IF nbpg_msg&=0                ! Si aucune page
g2&=0                         ! Page 0
ELSE                          ! S'il y a des pages
IF LEFT$(trans$)=CHR$(12) AND p.mode&=FALSE ! Si nø de page bal transmis
g2&=ASC(MID$(trans$,3,1))
trans$=""
g4&=INSTR(text_msg$,CHR$(g2&)) ! Fin page pr‚c‚dente
ELSE IF LEFT$(trans$)=CHR$(14) AND p.mode&=1 ! Si nø de page rub transmis
g2&=ASC(MID$(trans$,4+LEN(rubrique$),1))
trans$=""
g4&=INSTR(text_msg$,CHR$(g2&))      ! Fin page pr‚c‚dente
ELSE
g2&=1                         ! Page 1
g4&=1                         ! Fin page pr‚c‚dente
ENDIF
ENDIF
ENDIF
IF g6|                        ! Si on veut changer de page
PRINT AT(13,14);"Affichage du message nø: ";SUCC(no_msg_cour&);SPC(10);
IF x|(6)                      ! Si on veut le nø de page
IF g4|=1
no_page$=STR$(g2&)+"/"+STR$(nbpg_msg&)
ELSE
no_page$=STR$(g2&)
ENDIF
loc(x|(6),y|(6))
PRINT #99;g4$;no_page$;
ENDIF
IF g6|=1                        ! Si on veut aller sur la page suiv
l1&=INSTR(text_msg$,CHR$(SUCC(g2&)),g4&)
IF l1&
' On inclue le codes de contr“le DEBUT … la page!
g2$=MID$(text_msg$,g4&,PRED(l1&-g4&))+STRING$(20,CHR$(0))
g3&=g4&                       ! D‚but page
g4&=l1&                       ! Fin page
ELSE
g2$=STRING$(20,CHR$(0))
ENDIF
ELSE                            ! Si on veut la page pr‚c
l1&=RINSTR(text_msg$,CHR$(g2&),g3&)
IF l1&
' On inclue le codes de contr“le DEBUT … la page!
g2$=MID$(text_msg$,l1&,PRED(g3&-l1&))+STRING$(20,CHR$(0))
g4&=g3&                       ! Fin page
g3&=l1&                       ! D‚but page
ELSE
g2$=STRING$(20,CHR$(0))
ENDIF
ENDIF
g6|=0
IF l.old! AND x|(7)           ! Si msg STUT ONE 2.24 et qu'il fo virer le titre
ptr_msg&=INSTR(g2$,CHR$(0))
ELSE                          ! STUT ONE 2.30
ptr_msg&=1
ENDIF
ptr_line&=0
ENDIF
'
locate_ptr_msg(g2$)
IF ptr_msg&>0
PRINT AT(13,14);"Affichage du message nø: ";SUCC(no_msg_cour&);SPC(10);
affiche_msg(g2$,1,y|(8),g8|,40,g5$)
ENDIF
'
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,0,0,2,41,41,4,41,41,41,41,41,"","")
EXIT IF LEN(page_a$)
IF cd$="SOMMAIRE" OR cd$="CORRECTION" OR cd$="REPETITION"
g0$=" "                       ! Eff car tampon
ELSE IF cd$="GUIDE"
IF LEN(parametre$(3))
IF p.mode&                         ! Si rub
trans$=CHR$(13)+curpage_a$+CHR$(0)+rubrique$+CHR$(0)+CHR$(SUCC(no_msg_cour&))+CHR$(g2&)+CHR$(lectmod!+1)+g10$
ELSE
trans$=CHR$(11)+curpage_a$+CHR$(0)+CHR$(SUCC(no_msg_cour&))+CHR$(g2&)
ENDIF
page_a$=parametre$(3)
exit|=3
ENDIF
ELSE IF cd$="ANNULATION"
IF p.mode&                         ! si rub
test_level(parametre$(12))
ELSE
m1|=11
ENDIF
IF m1|=11
IF g7|
page_msgsys(7)                   ! Annulation en cours
IF p.mode&                       ! Si rub
m2|=SUCC(no_msg_cour&)
m3|=PRED(g7|)
IF m2|<g7|
FOR m1|=m2| TO m3|
msg_rub$(rub|,PRED(m1|))=msg_rub$(rub|,m1|)
NEXT m1|
ENDIF
msg_rub$(rub|,m3|)=""
DEC g7|
DEC param_rub|(rub|,4)        ! 1 msg de - dans la rub
info_rub|(rub|)=1             ! Rub … ‚t‚ modifi‚e
ELSE                          ! Si bal
DELETE msg_bal$(no_msg_cour&)          ! Efface msg
DEC nb_balmsg|                ! 1 msg de - en BAL
DEC g7|
info_bal|=3                   ! On a modifi‚ la BAL
ENDIF
IF no_msg_cour&=>g7|                     ! Si nø de msg invalide
DEC no_msg_cour&                       ! On va sur msg pr‚c‚dent
ENDIF
g2!=TRUE                      ! On veut changer de msg
topline
ELSE
page_msgsys(2)                ! Il n'y a pas de message
g0$=" "
ENDIF
ELSE
page_msgsys(3)                ! Commande reserv‚e
g0$=" "
ENDIF
ELSE IF cd$=g6$               ! [RETOUR/SUITE]
IF g7|
IF g1!=TRUE AND g2&<nbpg_msg& AND g0$<>"*" ! Si pas sur derniere page
INC g2&                       ! Page suiv
g6|=1                         ! On veut changer de page
ELSE IF g1!=FALSE AND g2&>1 AND g0$<>"*" ! Si pas sur 1Šre page
DEC g2&                       ! Page pr‚c
g6|=2
ELSE IF no_msg_cour&>0                 ! Sinon si pas sur le 1er msg
IF lectmod!                   ! Si on est en mode r‚ponses
FOR m1&=PRED(no_msg_cour&) DOWNTO 0    ! Recherche r‚ponse
EXIT IF LEFT$(msg_rub$(rub|,m1&),18)=g10$
NEXT m1&
IF m1&=TRUE
page_msgsys(9)                ! Pas de r‚ponse ant‚rieure
ELSE
no_msg_cour&=m1&
g2!=TRUE                      ! On veut changer de msg
ENDIF
ELSE                          ! Si on est en mode chronologik
DEC no_msg_cour&                       ! Msg pr‚c
g2!=TRUE                      ! On veut changer de msg
ENDIF
ELSE                          ! Si on ne peut plus avancer
page_msgsys(4)                ! Premier msg
ENDIF
ELSE                          ! Si plus de msgs
page_msgsys(2)                ! Il n'y a pas de message
ENDIF
g0$=" "                       ! Efface car tampon
ELSE IF cd$=g7$               ! [SUITE/RETOUR]
IF g7|
IF g1!=TRUE AND g2&>1 AND g0$<>"*" ! Si pas sur 1Šre page
DEC g2&                       ! Page pr‚c
g6|=2                         ! On change de page
ELSE IF g1!=FALSE AND g2&<nbpg_msg& AND g0$<>"*" ! Si pas sur derniere page
INC g2&                       ! Page suiv
g6|=1
ELSE IF SUCC(no_msg_cour&)<g7|         ! Sinon si pas sur le der msg
IF lectmod!                   ! Si on est en mode r‚ponses
m2|=PRED(g7|)
FOR m1|=SUCC(no_msg_cour&) TO m2|      ! Recherche r‚ponse
EXIT IF LEFT$(msg_rub$(rub|,m1|),18)=g10$
NEXT m1|
IF m1|>m2|
page_msgsys(10)               ! Pas de r‚ponse plus r‚cente
ELSE
no_msg_cour&=m1|
g2!=TRUE                      ! On veut changer de msg
ENDIF
ELSE                          ! Si on est en mode chronologik
INC no_msg_cour&                       ! Message suiv
g2!=TRUE                      ! On veut changer de msg
ENDIF
ELSE                          ! Si on ne peut plus avancer
page_msgsys(5)                ! Dernier message
ENDIF
ELSE                          ! Si plus de msgs
page_msgsys(2)                ! Il n'y a pas de message
ENDIF
g0$=" "
ELSE IF cd$="ENVOI"           ! [ENVOI]
g0$=UPPER$(g0$)
IF g0$=parametre$(5) AND LEN(parametre$(6)) ! r‚pondre en rub
repond_bal:
IF g7|                        ! S'il y a un msg auquel r‚pondre
PRINT AT(3,17);"R‚ponse …: ";expedit$;
page_a$=parametre$(6)
trans$=CHR$(3)+RIGHT$("0"+STR$(no_msg_cour&),2)+rubrique$ ! A transmettre
exit|=3
ELSE                          ! S'il n'y a pas de msg
page_msgsys(6)                ! Vous ne pouvez pas r‚pondre
ENDIF
ELSE IF g0$=parametre$(7) AND LEN(parametre$(8)) ! R‚p en BAL
repond_rub:
IF g7|
PRINT AT(3,17);"Destinataire demand‚: ";expedit$;
page_a$=parametre$(8)
IF LEN(page_a$)
trans$=CHR$(1)+expedit$            ! A transmettre.
exit|=3
ENDIF
ELSE                          ! Si aucun msg
page_msgsys(6)                ! Vous ne pouvez pas r‚pondre
ENDIF
ELSE IF g0$=g8$               ! Mode r‚ponses
IF no_msg_cour&<>TRUE
g10$=dat$+tim$
m2|=PRED(g7|)
FOR m1|=no_msg_cour& TO m2|            ! Recherch 1Šre r‚p
EXIT IF LEFT$(msg_rub$(rub|,m1|),18)=g10$
NEXT m1|
IF m1|>m2|
page_msgsys(8)                ! Ce msg n'a pas de r‚ponse
g0$=""
ELSE
loc(x|(3),y|(3))
PRINT #99;g4$;g8$;            ! Affich mode
lectmod!=TRUE                 ! Mode r‚ponses
no_msg_cour&=m1|
g2!=TRUE                      ! On veut changer de msg
ENDIF
ELSE
page_msgsys(2)                ! Il n'y a pas de message
ENDIF
ELSE IF g0$=g9$               ! Mode chrono
loc(x|(3),y|(3))
PRINT #99;g4$;g9$;            ! Affich mode
lectmod!=FALSE                ! Mode chrono
g10$=""
ELSE IF g3!=TRUE AND LEN(parametre$(6)) ! R‚pondre en BAL
GOTO repond_bal
ELSE IF g4!=TRUE AND LEN(parametre$(8)) ! R‚pondre en RUB
GOTO repond_rub
ELSE
page_a$=parametre$(11)
IF LEN(page_a$)=FALSE
page_msgsys(1)                 ! Touche sans effet
ENDIF
ENDIF
g0$=" "
ELSE
no_effect                 ! Touche sans effet
ENDIF
IF g2!                        ! Si chgt de message
aff_page_1(l.msg_suiv&,TRUE) ! Aff page VDT "MSG SUIV"
ELSE IF g6|                   ! Si chgt de page
aff_page_1(l.page_suiv&,TRUE) ! Aff page VDT "PAG SUIV"
ENDIF
LOOP UNTIL LEN(page_a$)
PRINT AT(52,24);"-";            ! Impression impossible
fin_lect_msg:
RETURN
> PROCEDURE lect_texte
LOCAL l.page_fond&,l.page_suiv&,l.page_prec&
LOCAL l.nom_texte$,l.no_texte&
LOCAL l.page&
'
' Lecture d'un texte ASCII:
'
' Algo:
' pour stocker les positions, on
' utilise DIM file_loc%(nb_charpass_max&)
'
PRINT AT(29,7);"Fonction: Fond lecture";
PRINT AT(3,14);"En cours: [paramŠtres].";
'
l.page_fond&=page_v&          ! Nø page Fond
'
PRINT AT(3,11);"Texte   : ";
l.nom_texte$=parametre$(1)       ! Nom texte
real_name(l.nom_texte$)          ! Si r‚f … une m‚m de page
enregistre(10,"Lecture texte ASCII: "+l.nom_texte$)
page_v$=l.nom_texte$             ! Nom texte...!
find_page                        ! Cherch nø texte parmi les pages VDT!
IF exit|
GOTO fin_lect_texte
ENDIF
l.no_texte&=page_v&
'
PRINT AT(14,8);"nø2: ";
page_v$=TRIM$(LEFT$(parametre$(39),8)) ! Nom page SUIVANT
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_lect_texte
ENDIF
PRINT AT(29,8);"Fonction: Page suivante";
l.page_suiv&=page_v&          ! Nø page SUIVANT
'
PRINT AT(14,9);"nø3: ";
page_v$=TRIM$(RIGHT$(parametre$(39),8)) ! Nom page PRECEDENT
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_lect_texte
ENDIF
PRINT AT(29,9);"Fonction: Page pr‚c‚dente";
l.page_prec&=page_v&           ! Nø page SUIVANT
'
decode_attrib(1,parametre$(13)) ! Att infos
g4$=l1$
decode_attrib(0,parametre$(14)) ! Att msg
g5$=l1$
'
x|(0)=VAL(parametre$(36))     ! Coord X titre.
y|(0)=VAL(parametre$(38))     ! Coord Y titre.
y|(1)=VAL(parametre$(37))     ! Coord msg
'
m1&=VAL(parametre$(17))
IF BTST(m1&,6)
x|(2)=VAL(parametre$(33))     ! Coord nø page
y|(2)=VAL(parametre$(34))
'   g4|=VAL(parametre$(35))       ! Tupe
ELSE
x|(2)=FALSE
ENDIF
'
aff_page_1(l.page_fond&,FALSE)
'
' lecture … partir de la page 1:
'
old_ptr_msg&=TRUE             ! Sauve la position en fin d'affichage
l.page&=0                     ! Commence par la page 1
ptr_msg&=1                    ! Position en cours d'affichage
file_loc%(l.page&)=ptr_msg&   ! Sauve ptr sur d‚but de page
'
msg_int!=TRUE
g0$=" "
g2!=TRUE                      ! On va changer de page
DO                            ! Boucle de lecture
IF g2!=TRUE                   ! Si on change de page
IF x|(2)>TRUE                 ! Si on demande l'affichage du no de page
loc(x|(2),y|(2))
PRINT #99;g4$;(l.page&+1);
ENDIF
' On se positionne pour le texte
ptr_line&=0                      ! Commence sur hypoth‚tique ligne 0
affiche_msg_cr(x|(0),y|(0),y|(1),34,g5$)  ! Saute … la ligne 1
g2!=FALSE
ENDIF
IF ptr_msg&>TRUE
PRINT AT(13,14);"Affichage d'une page de texte.";SPC(5);
affiche_msg(page_vdt$(l.no_texte&),x|(0),y|(0),y|(1),34,g5$)
ENDIF
'
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,0,0,2,41,41,4,41,41,41,41,41,"","")
EXIT IF LEN(page_a$)
IF cd$="SUITE"
IF l.page&<nb_charpass_max& AND old_ptr_msg&>TRUE
INC l.page&                      ! Passe … la page suivante.
ptr_msg&=old_ptr_msg&            ! recommence l… o— on s'‚tait arrˆt‚
file_loc%(l.page&)=ptr_msg&    ! Sauve ptr sur d‚but de page
g2!=TRUE
aff_page_1(l.page_suiv&,TRUE)
ENDIF
ELSE IF cd$="RETOUR"
IF l.page&>0
DEC l.page&                      ! Passe … la page pr‚c‚dente
ptr_msg&=file_loc%(l.page&)    ! Met ptr sur d‚but de page
g2!=TRUE
aff_page_1(l.page_prec&,TRUE)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
'
'
fin_lect_texte:
RETURN
> PROCEDURE libere
'
' Lib‚re mallocs pour TransTeaser:
'
~MFREE(rs232.adr%)
~MFREE(tamp1.adr%)
~MFREE(tamp2.adr%)
rs_out(rs_out.adr%,5)
teaser_down!=FALSE            ! On a rendu la m‚m download
RETURN
> PROCEDURE libere_tel_inv
'
' LibŠre mallocs pour r‚cept TransTeaser:
'
~MFREE(rs232.adr%)
~MFREE(tamp1.adr%)
rs_in(rs_in.adr%,256)
teaser_upl!=FALSE             ! On a rendu la m‚m upload
RETURN
> PROCEDURE liste_msg_env
'
' Affiche liste des msgs envoy‚s:
'
PRINT AT(13,14);"Affichage des r‚f msg envoy‚s.";
FOR g6|=g6| TO PRED(g2|)      ! Parcourt lignes
EXIT IF INP(TRUE)             ! Sort si touche
IF g2!                        ! Mode + r‚cent => + ancien
l1&=g1&+g6|                   ! Calcul nø msg
ELSE                          ! Mode chrono
l1&=19-g1&-g6|
ENDIF
loc(x|(1),y|(1)+g6|*g3|)
PRINT #99;g3$;
OUT 1,32,18,81                ! Efface emplacement
IF x|(2)
loc(x|(2),y|(1)+g6|*g3|)
PRINT #99;g4$;
OUT 1,32,18,81                ! Efface emplacement
ENDIF
IF x|(3)
loc(x|(3),y|(1)+g6|*g3|+1)
PRINT #99;g5$;
OUT 1,32,18,83                ! Efface emplacement
ENDIF
IF l1&=>FALSE AND l1&<20      ! Si on a pas d‚pass‚ la fin
loc(x|(1),y|(1)+g6|*g3|)      ! Pos sur pseudo
PRINT #99;g3$;
PRINT #99;MID$(envoistate$,20-l1&,1);" ";
l2$=MID$(msg_envoi$(l1&),19)
m1|=INSTR(l2$,CHR$(0))
IF m1|
envoi_chaine(LEFT$(l2$,PRED(m1|))) ! Affiche pseudo
ENDIF
l3$=LEFT$(msg_envoi$(l1&),18)
l2|=3+g1!
IF x|(l2|)
loc(x|(l2|),y|(1)+g6|*g3|+1+g1!)
PRINT #99;g4$;LEFT$(l3$,6)+MID$(l3$,9,2)+"  "+MID$(l3$,11);
ENDIF
l2|=2-g1!
IF x|(l2|)
loc(x|(l2|),y|(1)+g6|*g3|-g1!)
PRINT #99;g5$;
envoi_chaine(MID$(l2$,m1|+1))
ENDIF
ENDIF
NEXT g6|
RETURN
> PROCEDURE liste_msg_rec
'
' Affiche liste msgs re‡us:
'
PRINT AT(13,14);"Affichage des r‚f msg re‡us.  ";
FOR g6|=g6| TO PRED(g2|)      ! Parcourt lignes
EXIT IF INP(TRUE)             ! Sort si touche
IF g2!                        ! Mode + r‚cent => + ancien
l1&=19-g1&-g6|                ! Calcul nø msg
ELSE                          ! Mode chrono
l1&=g1&+g6|
ENDIF
loc(x|(1),y|(1)+g6|*g3|)
PRINT #99;g3$;
OUT 1,32,18,81
IF x|(2)
loc(x|(2),y|(1)+g6|*g3|)
PRINT #99;g4$;
OUT 1,32,18,81
ENDIF
IF x|(3)
loc(x|(3),y|(1)+g6|*g3|+1)
PRINT #99;g5$;
OUT 1,32,18,83
ENDIF
IF l1&=>0 AND l1&<20          ! Si on a pas d‚pass‚ la fin
loc(x|(1),y|(1)+g6|*g3|)      ! Pos sur pseudo
PRINT #99;g3$;
PRINT #99;RIGHT$(" "+STR$(l1&+1),2)' ! Affiche nø
l2$=msg_bal$(l1&)
m1|=INSTR(l2$,CHR$(0))
IF m1|
envoi_chaine(LEFT$(l2$,PRED(m1|))) ! Affiche pseu
ENDIF
l2|=3+g1!
IF x|(l2|)                    ! Affiche Date et Heure
loc(x|(l2|),y|(1)+g6|*g3|+1+g1!)
PRINT #99;g4$;MID$(l2$,SUCC(m1|),6)+MID$(l2$,m1|+9,2)+"  "+MID$(l2$,m1|+12,8);
ENDIF
l2|=2-g1!
ADD m1|,22
IF MID$(l2$,m1|,1)=CHR$(1)    ! Si msg STUT ONE 2.24
INC m1|
m2|=INSTR(l2$,CHR$(0),m1|)
ELSE                          ! STUT ONE 2.30
m2|=INSTR(l2$,CHR$(1),m1|)
ENDIF
IF x|(l2|)<>0 AND m2|<>0      ! Affiche titre
loc(x|(l2|),y|(1)+g6|*g3|-g1!)
PRINT #99;g5$;
envoi_chaine(MID$(l2$,m1|,m2|-m1|))
ENDIF
ENDIF
NEXT g6|
RETURN
> PROCEDURE liste_rub
'
' Affiche liste des msgs d'une rub:
'
PRINT AT(13,14);"Affichage des r‚f‚rences msg. ";
FOR g6|=g6| TO PRED(g2|)      ! Parcourt lignes
EXIT IF INP(TRUE)             ! Sort si touche
IF g2!                          ! Mode + r‚cent => + ancien
l1&=PRED(nb_rubmsg|-g1&-g6|)  ! Calcule le nø msg
ELSE                            ! Mode chrono
l1&=g1&+g6|
ENDIF
loc(x|(1),y|(1)+g6|*g3|)
PRINT #99;g3$;
OUT 1,32,18,82
IF x|(2)
loc(x|(2),y|(1)+g6|*g3|)
IF g1!
PRINT #99;g4$;
ELSE
PRINT #99;g5$;
ENDIF
OUT 1,32,18,83+g1!*2          ! Efface emplacement
ENDIF
IF x|(3)
loc(x|(3),y|(1)+g6|*g3|+1)
IF g1!
PRINT #99;g5$;
ELSE
PRINT #99;g4$;
ENDIF
OUT 1,32,18,81-g1!*2          ! Efface emplacement
ENDIF
IF l1&<nb_rubmsg| AND l1&=>FALSE ! Si pas hors-limites
loc(x|(1),y|(1)+g6|*g3|)      ! Pos sur pseu
PRINT #99;g3$;
PRINT #99;RIGHT$(" "+STR$(SUCC(l1&)),2)' ! Aff nø
l2$=msg_rub$(rub|,l1&)
m1|=INSTR(l2$,CHR$(0),21)
IF m1|
envoi_chaine(MID$(l2$,21,m1|-21)) ! Aff pseud
ENDIF
l2|=3+g1!
IF x|(l2|)
loc(x|(l2|),y|(1)+g6|*g3|+1+g1!)
PRINT #99;g4$;MID$(l2$,SUCC(m1|),6)+MID$(l2$,m1|+9,2)+"  "+MID$(l2$,m1|+11,8);
ENDIF
l2|=2-g1!
ADD m1|,20
IF MID$(l2$,m1|,1)=CHR$(1)    ! Si msg STUT ONE 2.24
INC m1|
m2|=INSTR(l2$,CHR$(0),m1|)
ELSE                          ! STUT ONE 2.30
m2|=INSTR(l2$,CHR$(1),m1|)
ENDIF
IF x|(l2|)<>0 AND m2|<>0
loc(x|(l2|),y|(1)+g6|*g3|-g1!)
PRINT #99;g5$;
envoi_chaine(MID$(l2$,m1|,m2|-m1|))
ENDIF
ENDIF
NEXT g6|
RETURN
> PROCEDURE local
'
' Lancement serv en mode local:
'
titre("Serveur en mode local")
HIDEM
OUT 1,20,27,59,96,91,81       ! Stp Clav => pri
handle%=WIND_CREATE(&X1,10,10,100,100) ! Cr‚at fenˆtre
l1$="[CONNECTE]"+CHR$(0)      ! Titre
fenetre_serv                  ! Dessine fenˆtre
clav!=TRUE                    ! Clav emulateur
PRINT AT(60,24);cursor.c$(0);"Em";normal.c$;
sysop|=2                      ! Mode Pr‚sent
PRINT AT(71,24);cursor.c$(0);"Pr‚sent";normal.c$;
PRINT AT(20,4);SPC(7);
PAUSE 5-vitesse|
l1$=INPAUX$
OUT 1,27,57,123               ! Id term
PAUSE 20-vitesse|*6
IF INP(TRUE)                  ! 1 code superflu
~INP(1)
ENDIF
terminal$=""
FOR l1|=1 TO 3                ! Lecture id term
IF INP(TRUE)
terminal$=terminal$+CHR$(INP(1))
ENDIF
NEXT l1|
PRINT AT(24,4);terminal$;
id_term                       ! Identif type de mntl
PRINT AT(20,4);minitel$;
aiguil_loc
OUT 1,31,64,65,24,12          ! Efface ‚cran mntl
PAUSE 15-vitesse|*4
l1$=INPAUX$
cnx_dat$=DATE$
cnx_tim$=TIME$
'
serveur(FALSE,FALSE,BTST(enr&,0)) ! Serveur
'
~WIND_CLOSE(handle%)          ! Ferme fenetre
~WIND_DELETE(handle%)         ! Efface de la ram
window!=FALSE                 ! Plus de fenˆtre
SHOWM
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE locate_ptr(page&)
'
' Repositionne csr aprŠs interruption page:
'
IF ptr&>1
l1$=page_vdt$(page&)
l2$=MID$(l1$,ptr&,1)
IF l2$<>CHR$(12) AND l2$<>CHR$(30) AND l2$<>CHR$(31) ! Si on est pas d‚j… "bien plac‚"
FOR l1&=PRED(ptr&) DOWNTO 1       ! Recherche la bonne position pr‚c‚dente
l2$=MID$(l1$,l1&,1)
IF l2$=CHR$(12)
OUT 1,30
IF ptr&=LEN(l1$)
ptr&=TRUE
ELSE
ptr&=l1&+1
ENDIF
EXIT IF TRUE
ELSE IF l2$=CHR$(30) OR l2$=CHR$(31)
ptr&=l1&
EXIT IF TRUE
ENDIF
NEXT l1&
ENDIF
ENDIF
RETURN
> PROCEDURE locate_ptr_msg(VAR msg$)
'
' Repos csr aprŠs interruption msg:
'
IF ptr_msg&>1
IF MID$(msg$,ptr_msg&,1)<>CHR$(0)
FOR l1&=ptr_msg& DOWNTO 1
EXIT IF MID$(msg$,l1&,1)=CHR$(0)
NEXT l1&
IF l1&=FALSE
ptr_msg&=1
ELSE
ptr_msg&=l1&
ENDIF
DEC ptr_line&
ENDIF
ENDIF
RETURN
'
> PROCEDURE menu
LOCAL l.mc_valid!
'
' Gest page MENU:
'
PRINT AT(29,7);"Fonction: Fond";
PRINT AT(3,14);"En cours: [paramŠtres].";
IF parametre$(37)<>"1"
g0&=TRUE                      ! Pas de tempo
ELSE
g0&=VAL(parametre$(8))        ! Tempo
ENDIF
l.mc_valid!=VAL(parametre$(38)) ! Validit‚ mots clef g‚n‚raux
mc_chain!=VAL(parametre$(39))    ! Chainage des mots clefs
x|(1)=VAL(parametre$(31))       ! X mc
y|(1)=VAL(parametre$(32))       ! Y mc
g1|=VAL(parametre$(33))         ! Long ‚dit
g1$=CHR$(VAL(parametre$(34)))   ! Filler
IF VAL(parametre$(30))          ! Si mask
g2$=CHR$(VAL(parametre$(35)))   ! Mask
ELSE
CLR g2$                         ! Pas de mask
ENDIF
decode_attrib(0,parametre$(36)) ! Atts mot clef
g5$=l1$
g0!=FALSE
interrupt!=TRUE
'
DO
IF g0!=FALSE
locate_ptr(page_v&)
IF ptr&>0
PRINT AT(13,14);"Affichage de la page vid‚otex.      ";
affiche_vdt(page_v&)
t%=TIMER
IF mc_chain!
l1$=LEFT$(g0$,g1|)
g0$=SPACE$(g1|)
LSET g0$=l1$
IF g0|>SUCC(g1|)
g0|=SUCC(g1|)
ENDIF
loc(x|(1),y|(1))
FOR l1&=g1| DOWNTO 1
EXIT IF MID$(g0$,l1&,1)<>" "
NEXT l1&
PRINT #99;g5$;LEFT$(g0$,l1&);
IF l1&<g1|            ! SI chaine n'est pas pleine!
repeat_fill(g1|-l1&)
ENDIF
mc_chain!=FALSE
ELSE
GOTO clef_init
ENDIF
ENDIF
IF page_v&=TRUE
page_v&=-2
clef_init:
init_champ(1,g5$,g1|)
ENDIF
ENDIF
'
CLR g0!
loc(x|(1)+g0|-1,y|(1))
PRINT #99;g5$;
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,g0&,t%,1,41,4,41,41,5,6,7,41,41,g1$,g2$)
'
EXIT IF LEN(page_a$)
IF cd$="SOMMAIRE"
IF LEFT$(g0$)=parametre$(2)
page_a$=parametre$(3)
ELSE
page_a$=parametre$(1)
ENDIF
cond_no_effect
ELSE IF cd$="ENVOI"
reco_clef(10)
PRINT AT(3,17);"Mot clef dem: ";g0$;SPC(40-LEN(g0$));
IF page_a$="" AND ptr&=-1
init_champ(1,g5$,g1|)
ENDIF
ELSE IF cd$="ANNULATION"
IF ptr&=-1
init_champ(1,g5$,g1|)
ENDIF
ELSE IF cd$="TEMPO"
page_a$=parametre$(9)
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE message_list(type|)
LOCAL l.mc_valid!
'
' List msgs tous usages:
'
PRINT AT(29,7);"Fonction: Fond de liste";
IF type|=2 AND info_bal|<2    ! Si pas de BAL
page_msgsys(6)                ! Vous n'avez pas de BAL
page_a$=parametre$(6)         ! Page d'erreur
ENDIF
IF LEN(page_a$)
GOTO fin_msg_list
ENDIF
PRINT AT(3,14);"En cours: [paramŠtres].";
IF type|=3                    ! Si besoin du nom rub
PRINT AT(3,9);"Rubrique: ";
rubrique$=parametre$(1)       ! Nom rub
real_name(rubrique$)          ! Si r‚f … une m‚m de page
find_rub                      ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_msg_list
ENDIF
nb_maxmsg|=param_rub|(rub|,0)
nb_rubmsg|=param_rub|(rub|,4)
IF nb_rubmsg|>nb_maxmsg|      ! S'il trop de msgs
nb_rubmsg|=nb_maxmsg|         ! On fait comme si il y en avait -
ENDIF
ENDIF
g1!=-VAL(parametre$(25))      ! DATE (/TITRE) en X1'
g2!=-VAL(parametre$(26))      ! Ordre chrono
decode_attrib(1,parametre$(7)) ! Att x1
g3$=l1$
decode_attrib(1,parametre$(8)) ! Att x1'
IF g1!
g4$=l1$
ELSE
g5$=l1$
ENDIF
decode_attrib(1,parametre$(9)) ! Att x2
IF g1!
g5$=l1$
ELSE
g4$=l1$
ENDIF
decode_attrib(0,parametre$(10)) ! Att cd
g6$=l1$
l1&=VAL(parametre$(11))       ! Etat bouts
x|(1)=VAL(parametre$(12))     ! X1 list
IF BTST(l1&,0)                ! Si x1' exist
x|(2)=VAL(parametre$(13))
ELSE
x|(2)=FALSE
ENDIF
IF BTST(l1&,1)                ! Si x2 exist
x|(3)=VAL(parametre$(14))
ELSE
x|(3)=FALSE
ENDIF
y|(1)=VAL(parametre$(15))     ! Y haut de list
g2|=VAL(parametre$(16))       ! Nbl
g3|=VAL(parametre$(17))       ! Interligne (STEP)
IF parametre$(18)="D"         ! Si on a demand‚ dernier msg
IF type|=3                    ! Si on est en lst rub
IF g2!                        ! Mode + r‚cent => + ancien
g1&=0
ELSE                          ! Mode chrono
g1&=nb_rubmsg|-g2|
IF g1&<0
g1&=0
ENDIF
ENDIF
ELSE
g1&=0
ENDIF
ELSE
g1&=VAL(parametre$(18))-1     ! Nø start msg
IF type|=3                    ! Si on est sur une lst rub
IF g1&=>nb_rubmsg|            ! Si msg dem n'exist pas
g1&=PRED(nb_rubmsg|)
ENDIF
IF g2!=TRUE                   ! Si mode + r‚cent => + ancien
g1&=PRED(nb_rubmsg|)-g1&
ENDIF
ENDIF
ENDIF
IF BTST(l1&,2)                ! Si champ edit exist
x|(4)=VAL(parametre$(19))     ! X mot clef
y|(4)=VAL(parametre$(20))     ! Y mc
g1|=VAL(parametre$(21))       ! Long ‚dit
g1$=CHR$(VAL(parametre$(22))) ! Fill
ELSE                          ! S'il n'y a pas de champ d'entr‚e
x|(4)=FALSE                   ! On signale par X=0
ENDIF
l.mc_valid!=BTST(l1&,3)       ! validit‚ mots clef
aff_page_1(page_v&,FALSE)
g0$=SPACE$(g1|)
g0|=1                         ! Pos d‚part sur ligne ‚dit
g5|=1
g6|=0
g0!=FALSE
DO
IF g6|<g2| AND g0!=FALSE      ! S'il fo aff list
SELECT type|
CASE 1
@liste_msg_env
CASE 2
@liste_msg_rec
CASE 3
@liste_rub
ENDSELECT
IF x|(4)                      ! Si champ ‚dit exist
init_champ(4,g6$,g1|)
ENDIF
ENDIF
CLR g0!
PRINT AT(13,14);"Attente d'une commande.       ";
PRINT AT(3,15);"Commande: ";
IF x|(4)
loc(x|(4)+g0|-1,y|(4))
PRINT #99;g6$;
get_command(TRUE,TRUE,0,1,2,3,41,41,41,41,4,41,41,g1$,"")
ELSE
get_command(TRUE,TRUE,0,0,2,3,41,41,41,41,4,41,41,"","")
ENDIF
EXIT IF LEN(page_a$)
IF cd$="RETOUR"
IF g1&>0                      ! Si pas sur 1ere ligne
SUB g1&,g2|                   ! Recule
IF g1&<0                      ! Si on est avant 1Šre ligne
g1&=0                         ! On s'y place
ENDIF
g6|=FALSE
ELSE                          ! Si 1Šre page
page_msgsys(4)                ! PremiŠre page
ENDIF
ELSE IF cd$="SUITE"
IF type|=3                    ! List msgs rub
l1|=nb_rubmsg|
ELSE                          ! List msgs bal
l1|=20
ENDIF
IF g1&+g2|<l1|                ! S'il reste des msgs aprŠs
ADD g1&,g2|                   ! Avance
g6|=FALSE
ELSE                          ! Si dern page
page_msgsys(5)                ! DerniŠre page
ENDIF
ELSE IF x|(4)                 ! S'il y a un champ ‚ditable
IF cd$="ANNULATION"
init_champ(4,g6$,g1|)
ELSE IF cd$="ENVOI"
IF type|=2                    ! Si on veut lire un msg
l1&=INT(VAL(TRIM$(g0$)))
IF l1&>0 AND l1&<=nb_balmsg|  ! Si nø valide
PRINT AT(3,17);"Message demand‚: ";l1&;
trans$=CHR$(2)+CHR$(l1&)      ! A transmettre
exit|=3
page_a$=parametre$(5)
ENDIF
ELSE IF type|=3
l1&=INT(VAL(TRIM$(g0$)))
IF l1&>0 AND l1&<=nb_rubmsg|  ! Si nø valide
PRINT AT(3,17);"Message demand‚: ";l1&;
trans$=CHR$(4)+rubrique$+CHR$(0)+CHR$(l1&) ! A transmettre
exit|=3
page_a$=parametre$(5)
ENDIF
ENDIF
IF LEN(page_a$)=FALSE           ! AND l.mc_valid!
reco_clef(0)
PRINT AT(3,17);"Mot clef dem.: ";g0$;SPC(40-LEN(g0$));
ENDIF
IF LEN(page_a$)=FALSE
init_champ(4,g6$,g1|)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
fin_msg_list:
RETURN
> PROCEDURE mod_redraw
'
' Redessine ‚cran aprŠs module
'
fond_bureau
l2$="Serveur en mode "
IF mod_norm!=FALSE
IF off_line!
titre(l2$+"off-line")
ELSE
titre(l2$+"local")
ENDIF
ELSE
titre(l2$+"normal")
ENDIF
IF LEN(pseudo$)
l1$=pseudo$+CHR$(0)           ! Titre
ELSE
l1$="[CONNECTE]"+CHR$(0)
ENDIF
fenetre_serv
PRINT AT(24,4);terminal$;
PRINT AT(20,4);minitel$;
PRINT AT(32,4);LEFT$(cnx_dat$,6);RIGHT$(cnx_dat$,2);
PRINT AT(43,4);cnx_tim$;
bal_info
DEFTEXT ,,,4
FOR l1|=0 TO 9                ! Parcourt pm
TEXT (l1| MOD 5)*72+34,(174+(l1|\5)*6)*rez|,page_memo$(l1|)+SPACE$(8-LEN(page_memo$(l1|)))
NEXT l1|
PRINT AT(78,4);"0";           ! Stade=0
upd_sys                       ! Aff statuts clav & sys
RETURN
> PROCEDURE module(p.neder!)
LOCAL l_nom_mod$
'
' Gest page MODULE:
'
PRINT AT(29,7);"Fonction: Chargement";
PRINT AT(3,14);"En cours: [paramŠtres].";
g1&=page_v&                   ! Nø Page de chargement
g2&=-1                        ! Nø page a transmettre
IF parametre$(2)="1"
PRINT AT(14,8);"nø2: ";
page_v$=parametre$(1)         ! Nom page vdt
find_page                     ! Cherche nø
IF exit|
GOTO fin_module
ENDIF
PRINT AT(29,8);"Fonction: Module";
g2&=page_v&
ENDIF
l_nom_mod$=parametre$(3)      ! Path complet du module
PRINT AT(3,10);"Module:"'l_nom_mod$;
PRINT AT(3,11);"Chemin:"'parametre$(4);
'
' Composition parametres
'
IF p.neder!
g2|=184
g2$=CHR$(g2|)+"NEDER"+neder_ver$ ! Header
IF mod_norm!                  ! Mode normal
l1%=1
ELSE                          ! Mode local
l1%=vitesse|+2                ! Indique vitesse
ENDIF
IF info_bal|>1                ! Si cnt … une BAL
l1%=BSET(l1%,3)
ENDIF
IF mixt!                      ! Si 80 col
l1%=BSET(l1%,4)
ENDIF
' Bal binaire: non
l1%=BSET(l1%,6)               ! Upload g‚n‚ral ok
l1%=BSET(l1%,7)               ! Upload en bb ok
IF drcs0!                     ! Si G0' valid‚
l1%=BSET(l1%,8)
ENDIF
IF drcs1!                     ! Si G1' valid‚
l1%=BSET(l1%,9)
ENDIF
l1%=BSET(l1%,10)              ! Serv tourne sous GEM
IF sysop|=2                   ! Si mode pr‚sent
l1%=BSET(l1%,11)              ! Serv tourne sous GEM
ENDIF
g2$=g2$+MKL$(l1%)+pseudo$+SPACE$(16-LEN(pseudo$))
IF info_bal|>1                ! S'il y a une BAL
g2$=g2$+MKI$(SUCC(bal_no&))   ! Nø BAL 1<=x<=nb_bal_max&+1
ELSE
g2$=g2$+MKI$(0)               ! Pas de nø BAL: 0
ENDIF
g2$=g2$+levels$
IF parametre$(14)="1"         ! Type de Nø SYS
g2$=g2$+CHR$(VAL(parametre$(15)))
ELSE
g2$=g2$+CHR$(VAL(MID$(levels$,VAL(parametre$(16)),1)))
ENDIF
g2$=g2$+terminal$+SPACE$(4-LEN(terminal$)) ! Type de mntl
IF parametre$(17)="1"         ! Type de NIV TEL
g2$=g2$+CHR$(VAL(parametre$(18)))
ELSE
g2$=g2$+CHR$(VAL(MID$(levels$,VAL(parametre$(19)),1)))
ENDIF
g2$=g2$+MKL$(credits%*1000)+MKI$(&H7FFF)+cnx_dat$+cnx_tim$+"STUT ONE v"+LEFT$(version$+"     ",5)+parametre$(20)+SPACE$(15-LEN(parametre$(20)))
g2$=g2$+MKI$(nb_cnx%)+MKL$(nb_sec%\60)+MKI$(nb_appels%)+MKL$(0)+MKL$(VAL(parametre$(22)))
g2$=g2$+MKL$(0)               ! Adresse chaine sp‚cifique
g2$=g2$+CHR$(1)               ! DerniŠre touche press‚e: ENVOI
g2$=g2$+parametre$(21)+SPACE$(16-LEN(parametre$(21)))+g0$+SPACE$(40-LEN(g0$))
ENDIF
'
aff_page_1(g1&,FALSE)
'
PRINT AT(13,14);"Test pr‚sence module.";SPC(15);
CHDRIVE LEFT$(parametre$(4))
CHDIR parametre$(4)
IF EXIST(l_nom_mod$)
OPEN "I",#1,l_nom_mod$
g3%=LOF(#1)+2048              ! 2048 de r‚serve
CLOSE #1
g1%=FRE(0)-512                ! M‚moire dispo pour module
IF g1%>g3%+512
PRINT AT(3,12);"M‚moire module:"'g1%'"octets"
~FRE(0)                       ! Garbage Collection
RESERVE FRE(0)-g1%            ! Reserve un maximum de RAM pour le module
'
IF p.neder!
g2%=MALLOC(300)               ! Zone de com (mini:257)
l1$=STR$(g2%)
l1$=CHR$(LEN(l1$))+l1$
~FRE(0)                       ! Garbage Collection
IF g2&>0
g2$=g2$+MKL$(V:page_vdt$(g2&))+MKI$(LEN(page_vdt$(g2&)))+CHR$(0)
ELSE
g2$=g2$+MKL$(0)+MKI$(0)+CHR$(0) ! Adr et long page vdt + fin de chaine
ENDIF
BMOVE V:g2$,g2%,g2|           ! TransfŠre ligne de com dans zone
PRINT AT(13,14);"Chargement et lancement du module.  ";
ELSE
IF parametre$(14)="1"           ! Mode Direct
l1$=pseudo$
ELSE                            ! Mode Longueur
l1$=CHR$(LEN(pseudo$))+pseudo$
ENDIF
ENDIF
'
l.screen.adr%=XBIOS(3)                ! Ecran logique
~XBIOS(5,L:screen.adr%,L:-1,L:-1)     ! On va sur l'autre ‚cran
~WIND_CLOSE(handle%)          ! Ferme fenetre
~XBIOS(5,L:l.screen.adr%,L:-1,L:-1)   ! On va sur l'‚cran physique
'
EXEC 0,l_nom_mod$,l1$,""
'
IF p.neder!
g3|=73
g3$=SPACE$(g3|)               ! Contiendra chaine de retour
~FRE(0)                       ! Garbage collect
BMOVE g2%+g2|+1,V:g3$,g3|     ! R‚cupŠre chaine de retour
scroll!=FALSE                 ! On a rendu le mntl en mode page
IF MID$(g3$,1,6)="NEDER"+LEFT$(neder_ver$)
credits%=CVL(MID$(g3$,65,4))\1000 ! New val cr‚dits
m1|=ASC(MID$(g3$,71,8))
IF BTST(m1|,0)                ! S'il fo redessiner ‚cran ST
mod_redraw
ELSE
'
l.screen.adr%=XBIOS(3)                ! Ecran logique
~XBIOS(5,L:screen.adr%,L:-1,L:-1)     ! On va sur l'autre ‚cran
IF LEN(pseudo$)
l1$=pseudo$+CHR$(0)           ! Titre
ELSE
l1$="[CONNECTE]"+CHR$(0)
ENDIF
fen_serv_open
~XBIOS(5,L:l.screen.adr%,L:-1,L:-1)   ! On va sur l'‚cran physique
'
PRINT AT(68,15);SPC(6);       ! R‚aff cr‚dits
PRINT AT(68,15);credits%'
ENDIF
IF BTST(m1|,2)                ! Si 80 col
videotex
ENDIF
drcs0!=BTST(m1|,3)            ! Jeu G0' actif
drcs1!=BTST(m1|,4)            ! Jeu G1' actif
m1|=ASC(MID$(g3$,8,1))        ! Code derniŠre touche
ELSE
PRINT CHR$(7);
mod_redraw                    ! Redessine ‚cran
m1|=13                        ! Code derniŠre touche inconnu
ENDIF
~MFREE(g2%)                   ! LibŠre zone de com
HIDEM                         ! Cache souris
RESERVE FRE(0)+g1%-255        ! R‚cupŠre RAM r‚serv‚e
SELECT m1|
CASE 1                        ! [Envoi]
cd$="ENVOI"
g0$=MID$(g3$,25,40)           ! Dern mot clef tap‚
reco_clef(0)
PRINT AT(3,17);"Mot clef dem: ";g0$;SPC(40-LEN(g0$));
IF page_a$=""
page_a$=parametre$(12)
ENDIF
CASE 2                        ! [Retour]
cd$="RETOUR"
page_a$=parametre$(9)
CASE 3                        ! [R‚p‚tition]
cd$="REPETITION"
page_a$=parametre$(11)
CASE 4                        ! [Guide]
cd$="GUIDE"
page_a$=parametre$(6)
CASE 5                        ! [Annulation]
cd$="ANNULATION"
page_a$=parametre$(7)
CASE 6                        ! [Sommaire]
cd$="SOMMAIRE"
page_a$=parametre$(5)
CASE 7                        ! [Correction]
cd$="CORRECTION"
page_a$=parametre$(8)
CASE 8                        ! [Suite]
cd$="SUITE"
page_a$=parametre$(10)
CASE 9                        ! [Fin]
cd$="FIN"
page_a$=page_cnxfin$
CASE 10                       ! Inaction
cd$="DELAI"
PRINT AT(78,4);"3";
msgsys("102")               ! D‚connexion
l0|=1
@deconnexion
page_a$="x"
exit|=1
CASE 11                       ! Pro x
cd$="PRO x"
page_a$="x"
exit|=1
CASE 12                       ! Deco
cd$="DECO"
@deconnexion
page_a$="x"
exit|=1
CASE 13                       ! Break
cd$="BREAK"
page_a$="x"
exit|=5
DEFAULT
cd$="RETOUR MOD"
ENDSELECT
PRINT AT(3,15);"Commande:"'cd$;
ELSE
RESERVE FRE(0)+g1%-255        ! R‚cupŠre RAM r‚serv‚e
HIDEM
mod_redraw
PRINT AT(3,15);"Commande: RETOUR DE MODULE";
ENDIF
deco%=TIMER
aff_temps_cnx                 ! Affiche temps de connexion
ELSE
page_msgsys(1)                ! M‚moire insuffisante
ENDIF
ELSE
page_msgsys(2)                ! Module introuvable
m1|=FALSE
ENDIF
IF page_a$=""
page_a$=parametre$(13)        ! Page par d‚faut
ENDIF
fin_module:
RETURN
> PROCEDURE msgsys(p.no_msg$)
LOCAL l.no_msg&,l.entete$,l.page_v&
LOCAL interrupt!,ptr&
'
' Aff msg systŠme en l0:
'
IF csr!                       ! Si curseur
OUT 1,20                      ! Eteind
ENDIF
loc(1,0)
font_restore                  ! Restore DRCS si valid‚
OUT 1,24
'
IF nb_msgsys&
FOR l.no_msg&=0 TO PRED(nb_msgsys&) ! Cherche message concern‚
EXIT IF LEFT$(msgsys$(l.no_msg&),3)=p.no_msg$
NEXT l.no_msg&
ENDIF
IF l.no_msg&=nb_msgsys&             ! Si pas trouv‚
PRINT #99;"LIB"'p.no_msg$;
ELSE                                ! Si message trouv‚
l.entete$=TRIM$(MID$(msgsys$(l.no_msg&),5,8)) ! Nom entˆte VDT
IF nbp_vdt&                   ! S'il exist des pages
FOR l.page_v&=0 TO PRED(nbp_vdt&)
EXIT IF nom_vdt$(l.page_v&)=l.entete$ AND info_vdt|(l.page_v&)<>2
NEXT l.page_v&
ENDIF
IF l.page_v&=nbp_vdt&           ! SI page VDT introuvable
envoi_chaine(MID$(msgsys$(l.no_msg&),5))
ELSE                            ! Si trouv‚ page VDT
IF LEN(page_vdt$(l.page_v&))
interrupt!=FALSE
ptr&=1
msg_sysop!=TRUE
affiche_vdt(l.page_v&)          ! Affiche page vid‚otex
msg_sysop!=FALSE
ENDIF
envoi_chaine(MID$(msgsys$(l.no_msg&),14))   ! texte du message
ENDIF
ENDIF
'
OUT 1,10
keypress!=TRUE                ! Msg en l0
l0|=1
'  l0|=FALSE                     ! Pour l'instant l0 dispo mais ch poss aprŠs RETURN
IF csr!
OUT 1,17                      ! Rallume csr
ENDIF
RETURN
> PROCEDURE msg_annul
'
' Vide ligne ds ed msg:
'
change_key(3,TRUE)
IF g1!
PRINT #99;CHR$(13);g1$;
OUT 1,18,103,11
ELSE
OUT 1,13,24
ENDIF
ligne$(g3|)=SPACE$(40)
ligne|(g3|)=0                 ! Ligne vide
g2|=1                         ! Csr en col 1
RETURN
> PROCEDURE msg_bas
'
' csr bas
'
IF g3|<nb_lignepage|
INC g3|
OUT 1,10
ELSE IF g2|<40
g2|=40
loc(40,y|(7)+g3|)
PRINT #99,g5$;
ENDIF
RETURN
> PROCEDURE msg_corr
'
' Corr 1 car ds ed msg:
'
change_key(4,TRUE)
m2|=ligne|(g3|)
IF g2|=1                      ! Si on est en col 1
IF g3|>1                      ! mais pas en ligne 1
DEC g3|                       ! On monte
m2|=ligne|(g3|)               ! Long ligne
g2|=SUCC(m2|)                 ! On se place … la fin
ADD g2|,g2|=41
loc(g2|,y|(7)+g3|)            ! Pos
PRINT #99,g5$;                ! Atts
ELSE IF g3&>1                 ! Si ligne 1 mais pas page 1
cd$="RETOUR"
ENDIF
ELSE
DEC g2|
OUT 1,8
ENDIF
IF g2|<m2|
OUT 1,32
ELSE
PRINT #99;g1$;
ENDIF
OUT 1,8
MID$(ligne$(g3|),g2|,1)=" "
IF g2|=m2|
DEC ligne|(g3|)
ENDIF
RETURN
> PROCEDURE msg_down
'
' Monte 1 ligne ds ed msg:
'
change_key(6,TRUE)
IF g3|<nb_lignepage|
INC g3|
g2|=ligne|(g3|)+1
ADD g2|,g2|=41
loc(g2|,y|(7)+g3|)         ! Pos csr
PRINT #99,g5$;             ! Atts
ELSE
cd$="SUITE"
ENDIF
RETURN
> PROCEDURE msg_droite
'
' csr droite
'
IF g2|<40+20*(g3|=0)
INC g2|
OUT 1,9
ELSE IF g3|<nb_lignepage|
INC g3|
g2|=1
IF g3|=1                      ! Si on arrive du titre
OUT 1,10,13
ELSE                          ! En normal
OUT 1,9
ENDIF
ENDIF
RETURN
> PROCEDURE msg_e.page
'
' Efface page ‚dit:
'
OUT 1,20
FOR m2|=1 TO nb_lignepage|
ligne$(m2|)=SPACE$(40)
ligne|(m2|)=0
loc(1,y|(7)+m2|)
PRINT #99;g5$;
OUT 1,24
IF g1!
fill_champ(0,40,g1$)
ENDIF
NEXT m2|
g2|=1
g3|=1
loc(1,SUCC(y|(7)))            ! Pos csr
OUT 1,17
PRINT #99,g5$;                ! Atts
RETURN
> PROCEDURE msg_gauche
'
' csr gauche
'
IF g2|>1
DEC g2|
OUT 1,8
ELSE IF g3|>1
DEC g3|
g2|=40
OUT 1,8
ENDIF
RETURN
> PROCEDURE msg_haut
'
' Csr haut
'
IF g3|>1
DEC g3|
OUT 1,11
ELSE IF g2|>1                 ! si on peut aller … gauche
g2|=1                         ! CR
OUT 1,13
ENDIF
RETURN
> PROCEDURE msg_ins.c
'
' Ins car ds msg
'
m2|=ligne|(g3|)
IF g2|<=m2|                   ! Si on est sur texte
l1$=ligne$(g3|)               ! Ligne d'origine
l2$=LEFT$(" "+MID$(l1$,g2|,m2|-g2|+1),41-g2|)
envoi_chaine(l2$)             ! Affichage de 
loc(g2|,y|(7)+g3|)            ! Pos csr
PRINT #99,g5$;                ! Atts
MID$(ligne$(g3|),g2|,LEN(l2$))=l2$ ! New ligne
ADD ligne|(g3|),1+(m2|=40)    ! New long
ENDIF
RETURN
> PROCEDURE msg_repet
'
' R‚aff msg dans ed:
'
change_key(7,TRUE)
OUT 1,20              ! Csr OFF
FOR m2|=1 TO nb_lignepage|
loc(1,y|(7)+m2|)             ! pos sur texte
PRINT #99;g5$;
OUT 1,24
m1|=ligne|(m2|)
envoi_chaine(LEFT$(ligne$(m2|),m1|))
IF g1!
fill_champ(m1|,40,g1$)
ENDIF
NEXT m2|
loc(g2|,y|(7)+g3|)
PRINT #99,g5$;                ! Atts
OUT 1,17                      ! Csr ON
RETURN
> PROCEDURE msg_sup.c
'
' Supprime car dans msg:
'
m2|=ligne|(g3|)
IF g2|<=m2|                   ! Si on est sur texte
l1$=ligne$(g3|)               ! Ligne d'origine
l2$=MID$(l1$,g2|+1,m2|-g2|)   ! Partie … d‚caler
envoi_chaine(l2$+g1$)         ! Affichage
loc(g2|,y|(7)+g3|)            ! Pos csr
PRINT #99,g5$;                ! Atts
MID$(ligne$(g3|),g2|,LEN(l2$)+1)=l2$+" " ! New ligne
DEC ligne|(g3|)               ! New long
ENDIF
RETURN
> PROCEDURE msg_tab
g2|=SUCC(ligne|(g3|))
ADD g2|,g2|=41
loc(g2|,y|(7)+g3|)            ! Pos csr
PRINT #99;g5$;                ! Atts
RETURN
> PROCEDURE msg_up
'
' Monte 1 ligne dans ed msg:
'
IF g3|>1
change_key(5,TRUE)
DEC g3|
g2|=ligne|(g3|)+1
ADD g2|,g2|=41
loc(g2|,y|(7)+g3|)      ! Pos csr
PRINT #99,g5$;          ! Atts
ELSE
cd$="RETOUR"
ENDIF
RETURN
'
> PROCEDURE normal
LOCAL l.vit_o|
LOCAL today_nbapp%,today_nbcnx%
LOCAL veille%
'
' Serv en mode normal:
'
titre("Serveur en mode normal")
HIDEM
'
l.vit_o|=vitesse|
IF vitesse|<>1
vitesse|=1
vit_set                     ! Passe … 1200 Bauds
ENDIF
'
handle%=WIND_CREATE(&X1,10,10,100,100) ! Cr‚at fenˆtre
l1$="[CONNECTE]"+CHR$(0)      ! Titre
fenetre_serv                  ! Dessine fenˆtre
clav!=FALSE                   ! Clav ligne0
PRINT AT(60,24);"L0";
sysop|=1                      ! Mode Appel
PRINT AT(71,24);"Appel";
topline|(0)=80                ! Fond noir
topline|(1)=FALSE             ! Pas d'horloge
IF connecte!=FALSE
aff_attente
aff_compteurs
fixe_veille                   ! Fixe ‚ch‚ance pour passer en veille
ENDIF
OUT 1,&H1B,&H5B,&H3F,&H7B     ! Sort du mode t‚l‚inf au cas ou
DO
l1!=FALSE                     ! On a pas d‚tect‚ d'appel pour l'instant
IF INP(TRUE)
IF INP(1)=19                  ! Si re‡u code SEP
PAUSE 7
IF INP(TRUE)
IF INP(1)=108                 ! Si re‡u code d‚tection d'appel m2
l1!=TRUE                      ! On signale l'appel
ENDIF
ENDIF
ENDIF
ENDIF
IF l1!=TRUE OR MOUSEK=2 OR connecte! ! Si detecte appel(FIRE) ou si on a d‚ja un cnt
IF connecte!=FALSE            ! Si detect appel(FIRE ou minitel)
IF l1!=FALSE                  ! Si la detec est faite par FIRE
PAUSE n_duree_valid_ring&     ! Attend le d‚lai n‚ccessaire … la validation
IF MOUSEK=2                   ! Si la d‚tection est toujours pr‚sente
l1!=TRUE                      ! On a d‚tect‚ un APPEL
ENDIF
ENDIF
IF l1!=TRUE                   ! Si on est s–r d'avoir d‚tect‚ un appel
veille_off                    ! Sort du mode veille
OUT 1,&H1B,&H5B,&H3F,&H7B     ! Sort du mode t‚l‚inf au cas ou
INC today_nbapp%              ! Un appel de plus
LOCATE 39,9
PRINT USING "#####",today_nbapp%
attente_cnx                   ! Envoi porteuse & Attente cnx
IF NOT connecte!
fixe_veille                   ! Fixe ‚ch‚ance pour passer en veille
ENDIF
ENDIF
ENDIF
IF connecte!                  ! Si cnt
loc(1,22)                     ! Pour les acquitements … venir
OUT 1,20,27,64,27,58,102,5,27,59,96,90,81 ! Transp+stp Clav => Mod
l1$="[CONNECTE]"+CHR$(0)      ! Titre fenˆtre
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
PRINT AT(20,4);SPC(7);
PAUSE 22
l1$=INPAUX$
OUT 1,27,58,102,3,27,57,123   ! Transpa + Id term
INC today_nbcnx%              ! Une connexion de plus
PAUSE 50
FOR l1|=1 TO 3
IF INP(TRUE)                  ! Si code superflu
~INP(1)
ENDIF
NEXT l1|
terminal$=""
FOR l1|=1 TO 3                ! Lect codes Id term
IF INP(TRUE)
terminal$=terminal$+CHR$(INP(1))
ENDIF
NEXT l1|
PRINT AT(24,4);terminal$;
id_term
PRINT AT(20,4);minitel$;
aiguil_loc
OUT 1,27,64                   ! Noir
OUT 1,27,58,102,13            ! transp 13
OUT 1,27,57,127               ! Reset
OUT 1,27,59,97,90,81          ! Inst Clav => Mod
OUT 1,27,58,105,69            ! Minuscules
OUT 1,27,59,105,89,65         ! Clavier etendu
cnx_dat$=DATE$
cnx_tim$=TIME$
INC nb_appels%
PAUSE 30
l1$=INPAUX$
'
serveur(TRUE,FALSE,BTST(enr&,2)) ! Traitement cnx
'
IF new_cnx!
DELETE connecte$(0)
g1%=(TIMER-debut%)\200
l1&=g1%\60
l1|=g1% MOD 60
connecte$(19)="}"+CHR$(27)+CHR$(69)+SPACE$(16)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+LEFT$(cnx_dat$,5)+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+cnx_tim$+CHR$(27)+CHR$(71)+"|"+CHR$(27)+CHR$(69)+RIGHT$("00"+STR$(l1&),3)+":"
connecte$(19)=connecte$(19)+RIGHT$("0"+STR$(l1|),2)+CHR$(27)+CHR$(71)+"{"
MID$(connecte$(19),4,16)=pseudo$+SPACE$(15)
ENDIF
'
ADD d_totale%,g1%
OPEN "O",#1,chemin$(3)+"TABLEAU.CNX"
PRINT #1;nb_appels%
PRINT #1;d_totale%
FOR l1|=0 TO 19
PRINT #1;connecte$(l1|)
NEXT l1|
CLOSE #1
OUT 1,&H1B,&H5B,&H3F,&H7B     ! Sort du mode t‚l‚inf au cas ou
EXIT IF exit|=5               ! On sort en cas de break
aff_attente
aff_compteurs
fixe_veille                   ! Fixe ‚ch‚ance pour passer en veille
ENDIF
ENDIF
IF INP(-2)                    ! Si touche ST
mode|=10                      ! Pas de modif credits
l1$=INKEY$
l1|=ASC(l1$)
SELECT l1|
CASE 0
l2|=ASC(RIGHT$(l1$))
function_keys
CASE 4,6                        ! Pas de deco ni FIN
CASE 19                       ! [Ctrl S]
EXIT IF TRUE
DEFAULT
IF l1|=13
veille_off
fixe_veille                   ! Fixe ‚ch‚ance pour passer en veille
ENDIF
IF clav!=FALSE                ! Si edition l0
kbd_l0_break
ENDIF
ENDSELECT
ENDIF
'
IF veille% AND TIMER=>veille%       ! S'il est temps de passer en veille
veille_on
veille%=0                         ! On ne s'en occupe plus!
ENDIF
LOOP
'
~WIND_CLOSE(handle%)          ! Ferme fen
~WIND_DELETE(handle%)         ! Efface fen de la RAM
window!=FALSE                 ! Plus de fenˆtre
'
IF l.vit_o|<>1 AND connecte!=FALSE
vitesse|=l.vit_o|
vit_set                       ! Restore vitesse originale
ENDIF
'
veille_off
'
SHOWM
~MENU_BAR(menu.adr%,1)
RETURN
> PROCEDURE no_effect
'
' Signale une touche sans effet!
'
IF cd$<>"???" AND noeff_disable!=FALSE
page_msgsys(1)                 ! Touche sans effet
ENDIF
RETURN
'
> PROCEDURE off_line
LOCAL off_vdt_ptr&
LOCAL today_nbcnx%
'
' Lancement serv en mode off-line:
'
titre("Serveur en mode off-line")
HIDEM
OUT 1,20,27,59,96,91,81       ! Stp Clav => pri
handle%=WIND_CREATE(&X1,10,10,100,100) ! Cr‚at fenˆtre
l1$="[CONNECTE]"+CHR$(0)      ! Titre
fenetre_serv                  ! Dessine fenˆtre
clav!=TRUE                    ! Clav emulateur
PRINT AT(60,24);"Em";
sysop|=0                      ! Mode Absent
PRINT AT(71,24);"Absent";
PRINT AT(20,4);SPC(7);
PAUSE 5-vitesse|
l1$=INPAUX$
OUT 1,27,57,123               ! Id term
PAUSE 20-vitesse|*6
IF INP(TRUE)                  ! 1 code superflu
~INP(1)
ENDIF
terminal$=""
FOR l1|=1 TO 3                ! Lecture id term
IF INP(TRUE)
terminal$=terminal$+CHR$(INP(1))
ENDIF
NEXT l1|
PRINT AT(24,4);terminal$;
id_term                       ! Identif type de mntl
PRINT AT(20,4);minitel$;
'
DO
aff_attente
l1&=60*rez|+rm|
l2&=100*rez|+rm|
l3&=115*rez|+rm|
l4&=132*rez|+rm|
BOX 112,l1&,351,l2&
BOX 112,l3&,351,l4&
PRINT AT(21,8);" Sur le minitel: ";
PRINT AT(16,12);"Appuyez sur Connexion/Fin...";
LOCATE 16,16
PRINT USING "Nombre de connexions:  #####",today_nbcnx%
'
OUT 1,27,59,96,88,82          ! Stp Mod => Ecr
OUT 1,31,64,65,24,12          ! Efface ‚cran mntl
PRINT #99;"Appuyez sur Connexion/Fin...";
g1|=254
g2|=254
off_vdt_ptr&=0
ptr&=TRUE
mode|=10                      ! Pas de modif credits
DO
IF ptr&=TRUE
exit|=FALSE
PRINT AT(16,10);"Page Vid‚otex Nø"+STR$(off_vdt_ptr&)+":"'
page_v$=off_vdt$(off_vdt_ptr&) ! Page vid‚otex
find_page                     ! Cherche cette page
ENDIF
IF exit|
key_trans$=INKEY$
ENDIF
IF page_v&>0
interrupt!=TRUE
affiche_vdt(page_v&)
ENDIF
IF ptr&=TRUE
IF off_vdt_mode|              ! Mode RANDOM
off_vdt_ptr&=RANDOM(10)
ELSE                          ! Mode CYCLE
off_vdt_ptr&=(off_vdt_ptr&+1) MOD 10
ENDIF
ENDIF
'
IF INP(-1)
l2|=INP(1)
IF l2|=19
g1|=89
g2|=91
ELSE IF l2|=g1| OR l2|=g2|    ! Cnx
@deconnexion
EXIT IF TRUE
ELSE
g1|=254
g2|=254
ENDIF
ELSE IF INP(-2)
IF INP(2)=19
GOTO fin_off_line
ENDIF
ENDIF
WHILE LEN(key_trans$)
l1$=LEFT$(key_trans$)
key_trans$=MID$(key_trans$,2)
l1|=ASC(l1$)
IF l1|=19
GOTO fin_off_line
ENDIF
WEND
LOOP
INC today_nbcnx%
OUT 1,31,64,65,24,12        ! Efface ecran minitel
loc(1,0)
PRINT #99;"Logiciel Serveur STUT ONE ";version$
envoi_chaine("Communication ‚tablie.")
aiguil_loc
PAUSE 20
l1$=INPAUX$
cnx_dat$=DATE$
cnx_tim$=TIME$
'
serveur(FALSE,TRUE,BTST(enr&,1)) ! Serveur
'
LOOP
'
fin_off_line:
~WIND_CLOSE(handle%)          ! Ferme fenetre
~WIND_DELETE(handle%)         ! Efface de la ram
window!=FALSE                 ! Plus de fenˆtre
SHOWM
~MENU_BAR(menu.adr%,1)
RETURN
'
> PROCEDURE page_msgsys(p.no_msg&)
LOCAL l.no_msg$
'
' Affiche un message systŠme d‚fini en paramŠtre sur une page ARBO:
'
l.no_msg$=parametre$(60+p.no_msg&)
IF LEN(l.no_msg$)             ! S'il faut afficher un message
msgsys(l.no_msg$)
ENDIF
RETURN
> PROCEDURE proto_keys
'
' Traite touches de gestion protocole
'
noeff_disable!=FALSE          ! Ce sera peut etre un no effect!
IF l1|=73 OR l1|=91
change_key(0,TRUE)
ELSE
change_key(11,TRUE)
ENDIF
'  LPRINT 19'l1|
SELECT l1|
CASE 73,91                    ! Fin
PAUSE 3
'   WHILE INP(TRUE)
'  ~INP(1)
'  WEND
IF mod_norm!=FALSE
@deconnexion
aiguil_loc
ENDIF
cd$="FIN"
page_a$=page_cnxfin$
CASE 83 !,89                    ! Deco physique
'    LPRINT "DECO:"'l1|
'    OUT 2,7
cd$="DECO"
page_a$="x"
exit|=1
@deconnexion
' 89 en dessous
CASE 81,87,88,94,108,112,113,89      ! Aquitements
cd$="ACQUIT."
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
CASE 86                       ! Min/MAJ
min!=min! XOR TRUE
cd$="Min/MAJ."
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
CASE 74 TO 77,80
@deconnexion
cd$="S-INTERDIT"
page_a$="x"
exit|=1
CASE 92                       ! Copie ‚cran
aiguil_loc
cd$="SCREENCOPY"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
CASE 114                      ! On/Off
cd$="M2 OFF"
noeff_disable!=TRUE           ! Ce n'est pas un no effect!
keypress!=keyacq!
PAUSE 7
IF INP(TRUE)
IF INP(1)=19
IF INP(TRUE)
IF INP(1)=94
aiguil_loc
cd$="M2 ON-INIT"
ENDIF
ENDIF
ENDIF
ENDIF
ENDSELECT
RETURN
> PROCEDURE pseudo(p.type&)
LOCAL l.confcode!,l.error!
'
' Gest page PSEUDO:
'
PRINT AT(29,7);"Fonction: Demande pseudo";
PRINT AT(3,14);"En cours: [paramŠtres].";
IF p.type&                    ! CREE_BAL
IF info_bal|>1                        ! Si le cnt a d‚ja une BAL
page_msgsys(2)                        ! Vous avez d‚ja une BAL
page_a$=parametre$(5)                 ! Page d'erreur
l.error!=TRUE
ELSE IF nb_pseudos&=>SUCC(nb_bal_max&) ! Si nb BALs maxi atteint
page_msgsys(3)                        ! Saturation: nb Bals maxi atteint
page_a$=parametre$(5)                 ! Page d'erreur
l.error!=TRUE
ENDIF
l.confcode!=-VAL(parametre$(18))
RESTORE pseudo_1
ELSE                          ! PSEUDO
IF pseudo$<>""                ! Si cnt a d‚ja un pseu
page_msgsys(6)                ! D‚j… identifi‚
page_a$=parametre$(10)
l.error!=TRUE
ENDIF
RESTORE pseudo_0
ENDIF
IF l.error!=FALSE
g4!=FALSE                   ! On se casse pas encore
pseudo_0:
DATA 13,14,15,11,16,24
DATA 17,18,19,12,20,25
pseudo_1:
DATA 6,7,8,27,28,24
DATA 9,10,11,17,12,25
DATA 13,14,15,19,16,26
FOR m1&=1 TO 2+p.type&
READ l1&,l2&,l3&,l4&,l5&,l6&
x|(m1&)=VAL(parametre$(l1&))    ! X pseu
y|(m1&)=VAL(parametre$(l2&))    ! Y pseu
ligne$(m1&)=CHR$(VAL(parametre$(l3&)))! Filler
IF VAL(parametre$(l4&))       ! Si mask
ligne$(3+m1&)=CHR$(VAL(parametre$(l5&))) ! Mask
ELSE
ligne$(3+m1&)=""              ! Pas de mask
ENDIF
decode_attrib(0,parametre$(l6&)) ! Atts mot clef
ligne$(6+m1&)=l1$
NEXT m1&
'
g1|=16                        ! Long ‚dit
g2|=1
g1$=ligne$(1)                 ! Filler
g2$=ligne$(4)                 ! Mask
g5$=ligne$(7)                 ! attributs
interrupt!=TRUE
g0!=FALSE
g3|=0                         ! Pour l'instant, on veut pas de nlle pg VDT
DO
IF g0!=FALSE                  ! Si on a le droit de continuer l'affichage
locate_ptr(page_v&)
IF ptr&>0
PRINT AT(13,14);"Affichage de la page vid‚otex.      ";
affiche_vdt(page_v&)
GOTO pseudo_init
ENDIF
IF page_v&=TRUE
page_v&=-2
pseudo_init:
IF p.type&=1 AND g2|=1
loc(x|(1),y|(1))
PRINT #99;g5$;
envoi_chaine(pseudo$)         ! Aff pseudo
fill_champ(LEN(pseudo$),16,g1$)
g0$=SPACE$(16)                ! Ligne ‚ditable
LSET g0$=pseudo$
g0|=LEN(pseudo$)+1
ELSE
init_champ(g2|,g5$,16)
ENDIF
ENDIF
ENDIF
CLR g0!                       ! On pourra continuer … afficher la page
loc(x|(g2|)+g0|-1,y|(g2|))
PRINT #99;g5$;
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
PRINT AT(3,15);"Commande: ";
IF p.type&                    ! Cree BAL
get_command(TRUE,TRUE,0,1,1,2,41,41,22,23,3,41,41,g1$,g2$)
ELSE                          ! Pseudo
get_command(TRUE,TRUE,0,1,3,4,41,41,6,5,7,41,41,g1$,g2$)
ENDIF
EXIT IF LEN(page_a$)
IF cd$="ENVOI"
m1$=TRIM$(g0$)                ! Texte entr‚
m1|=LEN(m1$)                  ! Long
'
IF g2|=1                      ! Si on demandait le pseu
'
PRINT AT(3,17);"Pseudo entr‚: ";m1$;SPC(16-m1|);
enregistre(10,"Pseudo: "+m1$)
IF m1|=FALSE                  ! Si pseu invalide
page_msgsys(4)                ! Pseudo invalide
init_champ(1,g5$,16)
ELSE                          ! Si pseu valide
IF nb_pseudos&                ! S'il y a des pseu en RAM
m2$=UPPER$(m1$)
FOR l1&=0 TO PRED(nb_pseudos&)
EXIT IF UPPER$(pseudo$(l1&))=m2$ ! sort si pseudo trouv‚
NEXT l1&
ELSE                          ! Si pas de pseu en RAM
l1&=nb_pseudos&               ! Pseudo demand‚ n'exist pas
' BUG corrig‚ grƒce … JM COINUS
ENDIF
IF l1&=nb_pseudos&            ! Si pseu n'exist pas
IF p.type&                    ! CREE BAL
g4$=m1$                       ! M‚mo pseudo
'
pseudo_demcode
'
ELSE                          ! PSEUDO
pseudo$=TRIM$(g0$)            ! Att du pseudo au cnt
page_a$=parametre$(8)         ! Page pas de message
g4!=TRUE                      ! On va se casser
ENDIF
ELSE                          ! Si pseu existe
IF p.type&                    ! CREE BAL
page_msgsys(5)                ! Ce pseudo ‚xiste d‚ja
ELSE                          ! PSEUDO
g3$=code$(l1&)                ! M‚mo code … demander
g4$=pseudo$(l1&)              ! M‚mo pseu
g4&=bal_no%(l1&)              ! M‚mo nø BAL
PRINT AT(3,18);"Code demand‚: ";g3$;SPC(16-LEN(g3$));
'
pseudo_demcode
'
ENDIF
ENDIF
ENDIF
'
ELSE                          ! Si on demandait le code
'
enregistre(10,"Code:   "+m1$)
IF p.type& AND g2|<3          ! CREE BAL et pas confirm code
PRINT AT(3,18);"Code entr‚:   ";m1$;
g3$=UPPER$(m1$)               ! M‚morise code
IF l.confcode!=FALSE          ! Si on ne veut pas de confirmation
GOTO cree_bal
ENDIF
'
g2|=3                         ! On va demander le code 2
g1$=ligne$(3)                 ! Filler
g2$=ligne$(6)                 ! Mask
g5$=ligne$(9)                 ! attributs
'
g3|=1                         ! On demande une new page vdt
PRINT AT(29,9);"Fonction: Demande confirm cd";
PRINT AT(14,9);"nø3: ";
ELSE                          ! PSEUDO ou code2:confirm code1
PRINT AT(3,19);"Code entr‚:   ";m1$;SPC(16-m1|);
IF UPPER$(m1$)<>UPPER$(g3$)   ! Si code incorrect
IF p.type&                    ! CREE_BAL
page_msgsys(7)                ! Code incorrect
ELSE
page_msgsys(2)                ! Code incorrect
ENDIF
enregistre(52,"Incorrect")
'
IF p.type&=FALSE              ! Si pseudo
g2|=1                         ! On va redemander le pseudo
g1$=ligne$(1)                 ! Filler
g2$=ligne$(4)                 ! Mask
g5$=ligne$(7)                 ! attributs
'
g3|=1                         ! On demande une new page vdt
PRINT AT(29,9);"Fonction: Demande autre pseu";
PRINT AT(14,9);"nø3: ";
ENDIF
'
init_champ(g2|,g5$,16)        ! Efface le code
ELSE                          ! Si code correct
IF p.type&                    ! CREE_BAL
cree_bal:
page_msgsys(6)              ! Cr‚ation de BAL en cours
enregistre(10,"Cr‚ation de la BAL: "+g4$)
pseudo$=g4$                   ! new pseud
code$=g3$                     ! new code
' On va trier
IF nb_pseudos&
FOR l1&=0 TO PRED(nb_pseudos&)  ! On parcourt les pseu
file$(l1&)=pseudo$(l1&)+CHR$(0)+code$(l1&)
NEXT l1&
ENDIF
file$(nb_pseudos&)=pseudo$+CHR$(0)+code$
bal_no&=bal_no%(nb_pseudos&)  ! Nø BAL du CNT
IF nb_nums&=nb_pseudos&
INC nb_nums&
ENDIF
INC nb_pseudos&
SSORT file$() WITH sort|(),nb_pseudos&,bal_no%()
FOR l1&=0 TO PRED(nb_pseudos&) ! On parcourt les pseudos
l1$=file$(l1&)
l1|=INSTR(l1$,CHR$(0))
pseudo$(l1&)=LEFT$(l1$,PRED(l1|))
code$(l1&)=MID$(l1$,l1|+1)
NEXT l1&
l1$=pseudo$+CHR$(0)           ! Titre de la fenetre
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
cree_date$=DATE$              ! Date de cr‚ation
PRINT AT(71,9);LEFT$(cree_date$,6);RIGHT$(cree_date$,2);
levels$=LEFT$(parametre$(30)+SPACE$(10),10) ! Fixe Levels
PRINT AT(67,14);levels$;      ! Aff Levels
info_list!=TRUE               ! On a modifi‚ la liste
info_bal|=3                   ! Le cnt a cr‚‚ une BAL
topline
page_a$=parametre$(4)         ! Page aprŠs creation
g4!=TRUE                      ! On va se casser
'
ELSE                          ! PSEUDO
page_msgsys(5)                ! un instant SVP
enregistre(52,"OK")
IF bal_envois|                ! S'il y a d‚j… eu des messages d'envoy‚s
enregistre(10,"Sauvegarde des messages d‚j… envoy‚s")
sauve_bal.envois              ! Sauve messages envoy‚s
ENDIF
pseudo$=g4$                   ! Att pseudo au cnt
IF mod_norm!
new_cnx!=TRUE                ! 1 nouveau cnt pour le tableau
ENDIF
m1$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(g4&),4)
CHDRIVE chemin$(2)
CHDIR "\"
IF EXIST(m1$)                 ! Si le fichier BAL exist
pseudo_openbal                ! Charge fichier BAL
IF nb_balmsg|                 ! S'il y a des msgs en BAL
m1$=msg_bal$(PRED(nb_balmsg|)) ! Dernier msg
m1|=INSTR(m1$,CHR$(0))
l1%=@code_date(last_date$)
l2%=@code_date(MID$(m1$,SUCC(m1|),10))
l3%=@code_heure(last_time$)
l4%=@code_heure(MID$(m1$,m1|+12,8))
IF l1%<l2% OR (l1%=l2% AND l3%<l4%)
page_a$=parametre$(21)        ! New msgs
ELSE
page_a$=parametre$(9)
ENDIF
ELSE
page_a$=parametre$(8)         ! Page suiv
ENDIF
topline
g4!=TRUE                      ! On va se casser
ELSE                          ! Si fichier BAL n'existe pas
page_msgsys(3)                ! Le fichier BAL n'existe pas!
enregistre(52,"ERREUR fichier BAL")
keypress!=TRUE
l0|=1
pseudo$=""
init_champ(1,g5$,16)          ! Efface code
'
g2|=1                         ! On va redemander pseudo
g1$=ligne$(1)                 ! Filler
g2$=ligne$(4)                 ! Mask
g5$=ligne$(7)                 ! attributs
'
g3|=1
PRINT AT(29,9);"Fonction: Demande autre pseu";
PRINT AT(14,9);"nø3: ";
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF g3|                        ! Si on demande une new page vdt
IF p.type&                    ! CREE_BAL
page_v$=parametre$(18+g2|)
ELSE                          ! PSEUDO
page_v$=parametre$(3-g2|)     ! Nom
ENDIF
find_page                     ! Cherch nø
CLR g3|                       ! On a chang‚ de page
ENDIF
IF LEN(pseudo$)               ! Si cnt a d‚fini un pseu
l1$=pseudo$+CHR$(0)           ! Titre de la fenetre
l1%=V:l1$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
bal_info                      ! Aff infos sur la BAL
ENDIF
EXIT IF g4!                   ! Si on doit se casser
ELSE IF cd$="ANNULATION"
IF ptr&=-1
init_champ(g2|,g5$,16)
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
ENDIF
RETURN
> PROCEDURE pseudo_openbal
code$=g3$                     ! Att du code
info_bal|=2                   ! Le CNT a une BAL
bal_no&=g4&                   ! Att du nø BAL
OPEN "I",#1,m1$               ! Ouvre fichier BAL
RECALL #1,file$(),12,void     ! Charge
envoistate$=file$(1)          ! Statut msgs envoy‚s
last_date$=file$(2)           ! Date derniŠre cnx
last_time$=file$(3)           ! Heure
cree_date$=file$(4)           ! Date de cr‚at BAL
nb_cnx%=VAL(file$(5))+1       ! Nb cnxs
nb_sec%=VAL(file$(6))         ! Sec de cnx
levels$=file$(7)              ! Levels
credits%=VAL(file$(8))        ! Cr‚dits
info_rep|=VAL(file$(9))       ! Statut rep
report_pseudo$=file$(10)      ! Report de BAL
repondeur$=file$(11)          ! R‚p
RECALL #1,info_cnt$(),10,void ! Charge infos sur CNT
INPUT #1,nb_envoimsg|         ! Nb msgs envoy‚s
RECALL #1,msg_envoi$(),nb_envoimsg|,void ! Infos msgs envoy‚s
INPUT #1,nb_balmsg|           ! Nb de msgs en BAL
RECALL #1,msg_bal$(),nb_balmsg|,void ! Msgs en BAL
CLOSE #1
RETURN
> PROCEDURE pseudo_demcode
'
g2|=2                         ! On va demander le code
g1$=ligne$(2)                 ! Filler
g2$=ligne$(5)                 ! Mask
g5$=ligne$(8)                 ! attributs
'
g3|=1                         ! Demande une new page vdt
PRINT AT(29,8);"Fonction: Demande code";
PRINT AT(14,8);"nø2: ";
RETURN
'
> PROCEDURE raz_bal
'
' RAZ BAL courante:
'
' Init ‚cran:
PRINT AT(62,7);"--.--.-- … --:--";
PRINT AT(71,9);"--.--.--";
PRINT AT(71,11);"1    ";
PRINT AT(71,12);"0000h 00";
PRINT AT(67,14);"0000000000";
PRINT AT(68,15);"0     ";
PRINT AT(77,17);"-";
PRINT AT(63,18);SPC(16);
' Init BAL courante:
code$=""
bal_no&=TRUE                  ! Pas de nø BAL
envoistate$=SPACE$(20)        ! Statut msgs envoy‚s
last_date$="--.--.----"       ! DerniŠre cnx
last_time$="--:--:--"
cree_date$="--.--.----"       ! Date cr‚at BAL
nb_cnx%=1                     ! Nb cnxs
nb_sec%=0                     ! Dur‚e totale de cnxs
debut%=TIMER                  ! Timer en d‚but de cnx
levels$=STRING$(10,"0")       ! Levels … 0
CLR credits%                  ! Pas de creds
CLR info_rep|                 ! Pas de rep
report_pseudo$=""
repondeur$=""
FOR l1|=0 TO 9
info_cnt$(l1|)=""             ! Pas d'infos sur cnt
NEXT l1|
CLR nb_envoimsg|              ! Nb msgs envoy‚s
CLR nb_balmsg|                ! Nb msgs en BAL
FOR l1|=0 TO 19               ! Init msgs
msg_bal$(l1|)=""              ! Msgs en BAL
NEXT l1|
RETURN
> PROCEDURE real_name(VAR page$)
'
' InterprŠte les variables dans un nom de page/rub:
'
IF LEFT$(page$)="#" OR LEFT$(page$)="Ý"  ! Si nom commence par # ou Ý
page$=page_memo$(VAL(MID$(page$,2,1)))   ! Fixe new nom de page
ENDIF
RETURN
> PROCEDURE reception
LOCAL enr_sauve!
'
' Routine de recept de TransTeaser:
'
enr_sauve!=p.enr!
p.enr!=FALSE                  ! On n'enregistre pas
CLR m2|
deco%=TIMER
get_command(FALSE,15,deco%,2,41,41,41,41,41,41,41,41,41,"","")
IF cd$="SOMMAIRE" OR cd$="ANNULATION" OR cd$="RETOUR" OR cd$="TEMPO"
enregistre(10,cd$)
m2|=3
ELSE IF LEFT$(cd$,2)="TO"
l1|=VAL(RIGHT$(cd$))
IF l1|=0 OR l1|=1
m2|=SUCC(l1|)
ENDIF
ELSE IF cd$="FIN" OR cd$="DECO" OR cd$="DELAI" OR cd$="PRO 1" OR cd$="PRO 2" OR cd$="PRO 3" OR cd$="PRO 80 COL" OR cd$="S-INTERDIT"
enregistre(10,cd$)
m2|=4
ENDIF
p.enr!=enr_sauve!
RETURN
> PROCEDURE reception.2
'
' R‚cept car pdt upload Transteaser:
'
CLR cd$
CLR m2|
t%=TIMER
DO
IF LEN(key_trans$)            ! Si on a un code clav ST en attente
l1|=1-(ASC(key_trans$)=0)
l1$=LEFT$(key_trans$,l1|)
key_trans$=MID$(key_trans$,SUCC(l1|))
GOTO key_trans.4
ENDIF
IF INP(TRUE)                   ! Si code en entr‚e
l1|=INP(1)                     ! M‚mo
deco%=TIMER
SELECT l1|
CASE 19                        ! Si touche de fonct
DO
IF INP(TRUE)                  ! Si code en entr‚e
l1|=INP(1)                    ! M‚mo
deco%=TIMER
SELECT l1|
CASE 66,69,70                 ! Retour au somm
cd$="SOMMAIRE"
m2|=3
CASE 73,83,89,91              ! Protocole (D‚co,etc..)
proto_keys
m2|=4
CASE 74 TO 77,80,92
@deconnexion
cd$="S-INTERDIT"
page_a$="x"
CASE 114                      ! On/Off
PAUSE 7
IF INP(TRUE)
IF INP(1)=19
IF INP(TRUE)
IF INP(1)=94
aiguil_loc
ENDIF
ENDIF
ENDIF
ENDIF
EXIT IF TRUE
DEFAULT
EXIT IF TRUE
ENDSELECT
ENDIF
LOOP UNTIL m2|
EXIT IF m2|
CASE 27                       ! Si Esc
cd$="ESCAPE"
@deconnexion
page_a$="x"
exit|=1
m2|=4
DEFAULT                       ! Autre touche
m2|=1                         ! On a un code
l1%=l1|-32
ADD m1%,l1%
ENDSELECT
ELSE IF INP(-2)             ! Si touche ST en entr‚e
l1$=INKEY$
key_trans.4:
l1|=ASC(l1$)
SELECT l1|
CASE 0
l1!=TRUE
l2|=ASC(RIGHT$(l1$))
IF l2|=61 OR l2|=63 OR l2|=65 ! [F3],[F5],[F7]
cd$="SOMMAIRE"
m2|=3
deco%=TIMER
ELSE
function_keys
ENDIF
CASE 2,13                     ! Pas de break ni de msg sysop
DEFAULT
IF clav!=FALSE OR l1|=4 OR l1|=6      ! Si ed l0 ou deco ou FIN
kbd_l0_break
ENDIF
ENDSELECT
ELSE                          ! Si pas de touche … traiter
aff_temps_cnx
ENDIF
IF TIMER-t%>3000
cd$="TEMPO"
m2|=3
ENDIF
LOOP UNTIL m2|
RETURN
> PROCEDURE reco_clef(page_0&)
'
' Reco d'un mot clef:
'
g0$=TRIM$(g0$)
IF LEFT$(g0$)="*"             ! Si cnt a mis un * devant
g0$=MID$(g0$,2)               ! On l'enlŠve
ENDIF
g0$=UPPER$(TRIM$(g0$))
'
IF page_0&>0                  ! Si on a des mots clef locaux
FOR l1|=0 TO 9                ! On va les tester
IF g0$=parametre$(page_0&+l1|) ! Si le choix correspond
page_a$=parametre$(page_0&+l1|+10)
EXIT IF TRUE
ENDIF
NEXT l1|
ENDIF
'
IF LEN(g0$) AND page_a$="" AND l.mc_valid! ! Si mot clef valide
'                                        ! Si on a pas pu associer de page
'                                        ! Si validit‚ des mc_g‚n‚raux!
FOR l1&=0 TO PRED(nb_mots&)   ! Comparer avec liste des mc
IF mot$(l1&)=g0$              ! Si on a trouv‚ le bon mot
page_a$=TRIM$(LEFT$(page$(l1&),8))
l1$=MID$(page$(l1&),9)
IF LEN(l1$)                   ! S'il y a un paramŠtre...
l1|=VAL(LEFT$(l1$))           ! Num‚ro de la PM … attribuer
parametre$(50+l1|)=MID$(l1$,2)  ! Attribution PM se fera en fin de page (procedure SEVEUR)!
pm_enabled&=BSET(pm_enabled&,l1|) ! Signale PM
TEXT (l1| MOD 5)*72+16,(174+(l1|\5)*6)*rez|,"*" ! Affiche PM
ENDIF
EXIT IF TRUE
ENDIF
NEXT l1&
ENDIF
'
IF LEN(page_a$)
enregistre(10,"Mot clef: "+g0$)
ELSE                          ! Si entr‚e erronn‚e
IF LEN(STR$(VAL(g0$)))=>LEN(g0$) OR l.mc_valid!=FALSE
page_msgsys(3)                ! Choix non propos‚
ELSE
page_msgsys(2)                ! Mot clef inconnu
ENDIF
ENDIF
RETURN
> PROCEDURE recoit_bloc(a%,b%)
'
' R‚cept d'un bloc par TransTeaser:
'
IF (a% MOD 3)<>0
ADD a%,3-(a% MOD 3)
ENDIF
l2%=a%/3
FOR l3%=1 TO l2%
FOR l4%=0 TO 2
reception.2
EXIT IF m2|>2
sextet%(l4%)=l1%
NEXT l4%
EXIT IF m2|>2
reception.2
EXIT IF m2|>2
l5%=64
l6%=3
FOR l4%=0 TO 2
POKE b%,sextet%(l4%)+(l1% AND l6%)*l5%
INC b%
DIV l5%,4
ADD l6%,l6%
ADD l6%,l6%
NEXT l4%
NEXT l3%
RETURN
> PROCEDURE restore_ccsr
'
' R‚tablit car ss csr cnt (DIA):
'
IF g0|=2                      ! Si csr est chez cnt
OUT 1,8                       ! On affiche sur csr
ELSE                          ! Si csr ailleurs
loc(g1|,yc|+g2|)              ! Pos
PRINT #99;att1$;              ! Atts
ENDIF
l1|=ASC(MID$(ligne$(10+g2|),g1|,1)) ! Car … r‚tablir
IF l1|>127
IF mixt!
accent_80(l1|)
ELSE
code_accent(l1|)
ENDIF
PRINT #99;l1$;
ELSE
OUT 1,l1|
ENDIF
RETURN
> PROCEDURE restore_scsr
'
' R‚tablit car ss csr sys:
'
IF g0|=1                      ! Si csr est chez sys
OUT 1,8                       ! Affiche sur csr
ELSE                          ! Si csr ailleurs
loc(g3|,ys|+g4|)              ! Pos
PRINT #99;attrib$;            ! Atts
ENDIF
l1|=ASC(MID$(ligne$(g4|),g3|,1)) ! Car … r‚tablir
IF l1|>127
code_accent(l1|)
PRINT #99;l1$;
ELSE
OUT 1,l1|
ENDIF
RETURN
> PROCEDURE repeat_fill(p.long&)
PRINT #99;g1$;              ! Filler
IF p.long&>1                  ! S'il fo r‚p‚ter car
IF mixt!                      ! 80 col
FOR l1|=2 TO p.long&
PRINT #99;g1$;
NEXT l1|
ELSE                          ! 40 col
OUT 1,18,63+p.long&
ENDIF
ENDIF
RETURN
'
> PROCEDURE sauve_bal
'
' Sauve ops en BAL aprŠs d‚co:
'
sauve_bal.envois              ! Sauve messages envoy‚s
'
PBOX l.x1&,l.y1&,l.x2&,l.y2&  ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DES ACCUSES DE LECTURE"
PRINT AT(3,8);"Nombre de messages … accuser: ";bal_lus|;
BOX 14,68*rez|,452,139*rez|
IF bal_lus|<>0 AND nb_pseudos&<>0 ! S'il y a des accus‚s de lect
DEFTEXT ,,,4+rm|*2
FOR m1|=1 TO bal_lus|
m4|=(PRED(m1|) MOD 10)*(6+rm|*2)+78*rez|
TEXT 24,m4|,STR$(m1|)
m1$=msg_lus$(PRED(m1|))
l1|=INSTR(m1$,CHR$(0))
IF l1|
m2$=LEFT$(m1$,PRED(l1|))      ! Pseudo exp‚diteur
TEXT 48,m4|,"Accuse a: "+m2$+SPACE$(20)
m3$=MID$(m1$,SUCC(l1|))       ! R‚f msg en question
FOR m1&=0 TO PRED(nb_pseudos&)  ! Recherch nø BAL exp
EXIT IF pseudo$(m1&)=m2$
NEXT m1&
IF m1&<>nb_pseudos&           ! Si BAL exist
m2&=bal_no%(m1&)
TEXT 280,m4|,"Bal nø: "+STR$(m2&)
m2$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(m2&),4)
IF EXIST(m2$)                 ! Si fichier exist
OPEN "U",#1,m2$               ! Ouvre fichier BAL
SEEK #1,115                   ! Pos sur r‚p
RECALL #1,file$(),33,void     ! Charge r‚f msgs envoy‚s (13 blabla + 20 ref)
l1|=VAL(file$(12))
IF l1|
l3|=LEN(m3$)                  ! Long chaine
FOR l2|=1 TO l1|
IF LEFT$(file$(12+l2|),l3|)=m3$ ! Si r‚f correspondent
SEEK #1,38-l2|                ! Pos sur statut corresp
PRINT #1;"L";                 ! Indique Lu
EXIT IF TRUE
ENDIF
NEXT l2|
IF l2|=SUCC(l1|)              ! Pas trouv‚
OUT 2,7
TEXT 376,m4|,"Pas trouv‚!"
ELSE
TEXT 376,m4|,"Recu."
ENDIF
ENDIF
CLOSE #1
ELSE
TEXT 376,m4|,"Fichier introuvable."
ENDIF
ELSE
TEXT 280,m4|,"Pseudo n'existe pas."
ENDIF
ELSE
TEXT 48,m4|,"Deja traite."
ENDIF
NEXT m1|
DEFTEXT ,,,6+rm|*7
ENDIF
'
PBOX l.x1&,l.y1&,l.x2&,l.y2& ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DE LA BAL DU CONNECTE"
PRINT AT(3,8);"Type de sauvegarde: ";
IF info_bal|
IF info_bal|=1                ! Si BAL a ‚t‚ ‚ffac‚e
bal_no&=bal_no%(nb_pseudos&)  ! Ancien Nø BAL du CNT
ENDIF
m1$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(bal_no&),4)
SELECT info_bal|
CASE 1                      ! Si BAL a ‚t‚ ‚ffac‚e
PRINT "Effacement.";
CHDRIVE chemin$(2)
CHDIR "\"
IF EXIST(m1$)                 ! Si BAL existait sur le disk
KILL m1$
ENDIF
CASE 2                      ! Si BAL n'a pas de modifs majeures
PRINT "Mise … jour des paramŠtres.";
OPEN "U",#1,m1$               ! On va modifier le fichier
SEEK #1,40
sauve_balpinf                 ! Sauve infos primaires
CLOSE #1
CASE 3                      ! Si BAL a ‚t‚ modifi‚e
PRINT "Sauvegarde complŠte.";
OPEN "O",#1,m1$               ! R‚ecrit fich BALS
PRINT #1;LEFT$(pseudo$+SPACE$(16),16)
PRINT #1;envoistate$          ! Statut msgs envoy‚s
sauve_balpinf                 ! Sauve infos primaires
PRINT #1;info_rep|            ! Statut rep
PRINT #1;report_pseudo$       ! Report BAL
PRINT #1;repondeur$           ! R‚p
STORE #1,info_cnt$(),10
PRINT #1;nb_envoimsg|         ! Nb msgs envoy‚s
STORE #1,msg_envoi$(),nb_envoimsg| ! List msgs envoy‚s
PRINT #1;nb_balmsg|           ! Nb msgs en BAL
STORE #1,msg_bal$(),nb_balmsg| ! Msgs en BAL
CLOSE #1
ENDSELECT
ELSE
PRINT "Aucune.";
ENDIF
'
PBOX l.x1&,l.y1&,l.x2&,l.y2&  ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DES MODIFICATIONS EN MEMOIRE";
PRINT AT(3,8);"Sauvegarde de la liste des bals: ";
IF info_list!                 ! Si list des bals modifi‚e
PRINT "Oui.";
sauve_bal.info_list
ELSE
PRINT "Non.";
ENDIF
RETURN
> PROCEDURE sauve_bal.info_list
OPEN "O",#1,chemin$(2)+"BALS.LST"
PRINT #1;nb_pseudos&          ! Nb pseu
STORE #1,pseudo$(),nb_pseudos&
STORE #1,code$(),nb_pseudos&
PRINT #1;nb_nums&             ! Nb nø
IF nb_nums&
FOR l1&=0 TO PRED(nb_nums&)
PRINT #1;bal_no%(l1&)
NEXT l1&
ENDIF
CLOSE #1
CLR info_list!                ! Modifs OK
RETURN
> PROCEDURE sauve_bal.envois
PBOX l.x1&,l.y1&,l.x2&,l.y2& ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DES MESSAGES ENVOYES";
PRINT AT(3,8);"Nombre de messages envoy‚s: ";bal_envois|;
BOX 14,68*rez|,452,139*rez|
IF bal_envois|                ! Si on a envoy‚ des msgs aux autres
DEFTEXT ,,,4+rm|*2
FOR m1|=bal_envois| DOWNTO 1  ! Parcourt msgs
m4|=((bal_envois|-m1|) MOD 10)*(6+rm|*2)+78*rez|
TEXT 24,m4|,STR$(bal_envois|-m1|+1)
IF MID$(envoistate$,21-m1|,1)="E" ! S'il faut en envoyer un
m1$=msg_envoi$(PRED(m1|))     ! R‚f msg
m2|=INSTR(m1$,CHR$(0),19)     ! Cherch fin du pseudo
IF m2|<>0 AND nb_pseudos&<>0  ! Si on a trouv‚
m1$=MID$(m1$,19,m2|-19)       ! Pseudo dest
TEXT 48,m4|,"Envoi a: "+m1$+SPACE$(20)
FOR m1&=0 TO PRED(nb_pseudos&) ! Recherch nø de BAL dest
EXIT IF pseudo$(m1&)=m1$
NEXT m1&
IF m1&<>nb_pseudos&           ! Si BAL exist
m2&=bal_no%(m1&)              ! Nø BAL
TEXT 272,m4|,"Bal nø: "+STR$(m2&)
m2$=chemin$(2)+"BAL_"+RIGHT$("000"+STR$(m2&),4)
IF EXIST(m2$)                 ! Si fichier exist
OPEN "U",#1,m2$               ! Ouvre fichier BAL
SEEK #1,115                   ! Pos sur r‚p
RECALL #1,file$(),54,m1%
l1|=VAL(file$(12))            ! Nb msgs envoy‚s
m3|=13+l1|                    ! Position nb_balmsg
l1|=VAL(file$(m3|))           ! Nb msgs en BAL
IF l1|=20
DELETE file$(SUCC(m3|))
DEC m1%
ELSE
INC l1|
file$(m3|)=STR$(l1|)
ENDIF
file$(m1%)=msg_disk$(bal_envois|-m1|) ! Ajoute msg … la fin
SEEK #1,115                   ! Pos sur r‚p
STORE #1,file$(),SUCC(m1%)    ! Sauve modifs
CLOSE #1                      ! Ferme fichier BAL
MID$(envoistate$,21-m1|,1)="R" ! Msg … ‚t‚ re‡u
TEXT 368,m4|,"Recu."
ENDIF
ELSE
TEXT 48,m4|,"Pseudo n'existe pas.     "
ENDIF
ELSE
TEXT 48,m4|,"Pseudo invalide.         "
ENDIF
ELSE
TEXT 48,m4|,"Deja traite.             "
ENDIF
NEXT m1|
DEFTEXT ,,,6+rm|*7
ENDIF
RETURN
> PROCEDURE sauve_balpinf
'
' Sauve infos primaires:
'
PRINT #1;cnx_dat$             ! Date dern cnx
PRINT #1;cnx_tim$             ! Heure
PRINT #1;cree_date$           ! Date cr‚e bal
PRINT #1;RIGHT$("0000"+STR$(nb_cnx%),5) ! Nb cnxs
PRINT #1;RIGHT$("00000000"+STR$(nb_sec%+g1%),9) ! Sec de cnx
PRINT #1;levels$              ! Levels
PRINT #1;RIGHT$("00000"+STR$(credits%),6) ! Cr‚dits
RETURN
> PROCEDURE sauve_fiche
'
' Sauve la fiche courante de la base courante sur le disque:
'
l1$=chemin$(1)+nom_base$(g0&)+".DBF"
err_resume&=13
REPEAT
err_choix&=FALSE
IF EXIST(l1$)                 ! Si ce fichier existe
OPEN "A",#1,l1$               ! Append
ELSE
OPEN "O",#1,l1$               ! Open new
OUT #1,9,13,10                ! Marque d‚but du fichier!
ENDIF
PRINT #1;champ$(0)              ! Num‚ro
PRINT #1;champ$(1)              ! Date
FOR l1&=0 TO 24                 ! Parcourt champs
IF fiches_param&(g0&,l1&,0)=1   ! Si le champ est valid‚
PRINT #1;STR$(l1&,2);":";champ$(l1&+2)
ENDIF
NEXT l1&
OUT #1,13,10,9,13,10            ! Saute ligne et s‚pare champ
err_13:
CLOSE #1
UNTIL err_choix&<>2
RETURN
> PROCEDURE sauve_rub
'
' Sauve rubs et affs aprŠs d‚co:
'
PBOX l.x1&,l.y1&,l.x2&,l.y2&  ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DES RUBRIQUES"
PRINT AT(3,8);"Nombre de rubriques: ";nb_rub&;
BOX 14,68*rez|,452,139*rez|
DEFTEXT ,,,4+rm|*2
sr_noyau(2)                   ! Sauve rubriques
'
PBOX l.x1&,l.y1&,l.x2&,l.y2&  ! Efface fenetre
PRINT AT(3,6);"SAUVEGARDE DES AFFICHES"
PRINT AT(3,8);"Nombre d'affiches: ";nb_aff&;
BOX 14,68*rez|,452,139*rez|
DEFTEXT ,,,4+rm|*2
sa_noyau(2)                   ! Sauve affiches
'
RETURN
> PROCEDURE serveur(mod_norm!,off_line!,p.enr!)
LOCAL l_xenr&
LOCAL l.x1&,l.y1&,l.x2&,l.y2&
l.x1&=11
l.y1&=33*rez|+rm|
l.x2&=455
l.y2&=157*rez|+rm|
'
' Gest cnx:
'
OUT 1,20
PRINT AT(32,4);LEFT$(cnx_dat$,6);RIGHT$(cnx_dat$,2); ! Affiche date
PRINT AT(43,4);cnx_tim$;
PRINT AT(60,4);"0h 00mn 00s";
PRINT AT(78,4);0;
'
init_bal
'
IF nb_aff&
FOR l1|=0 TO PRED(nb_aff&)    ! Init flag:"nbl ‚crites ds affiches"
param_aff|(l1|,3)=FALSE
NEXT l1|
ENDIF
'
DEFTEXT ,,,4
FOR l1|=0 TO 9
page_memo$(l1|)=""
TEXT (l1| MOD 5)*72+34,(174+(l1|\5)*6)*rez|,SPACE$(8)
NEXT l1|
page_cnxfin$=stop_page$       ! Page Cnx/fin par d‚faut
TEXT 430,174*rez|,page_cnxfin$+SPACE$(8-LEN(page_cnxfin$))
page_fatalerr$=error_page$    ! Page Fatal Error par d‚faut
TEXT 430,180*rez|,page_fatalerr$+SPACE$(8-LEN(page_fatalerr$))
'
csr!=FALSE                    ! Csr OFF
scroll!=FALSE                 ! Mode rouleau OFF
mixt!=FALSE                   ! 40 col
min!=TRUE                     ! Minuscules
topline|(0)=80                ! Fond noir
topline|(1)=FALSE             ! Pas d'horloge
drcs0!=FALSE                  ! Jeux de car standards
drcs1!=FALSE
page_a$=start_page$           ! On commence par la start_page
cd$="DEBUT CNX"
keypress!=FALSE               ! Pas d'attente touche
exit|=FALSE                   ! Type de fin de cnx
stade|=FALSE                  ! Stade de d‚co auto
l0|=FALSE                     ! Pas de msg en ligne 0
'
' "M‚moires"
'
rub$=""                       ! Pas de rub courante
trans$=""                     ! Params … transmettre a la page suiv
word_trans$=""                ! transmission d'un mot d'une page … l'autre!
FOR l1&=0 TO 26
champ$(l1&)=""                ! Champs d'une fiche!
NEXT l1&
'
phys_deb%=TIMER               ! D‚but physique de la connexion
clock%=TIMER+17280000         ! Prochain aff pendule ds 24h !
deco%=TIMER
IF mod_norm!
new_cnx!=TRUE                ! 1 nouveau cnt pour le tableau
ENDIF
'
IF p.enr!
l1$=chemin$(3)+"CNXS.LST"
IF NOT EXIST(l1$)
OPEN "O",#98,l1$
CLOSE #98
ENDIF
OPEN "A",#98,l1$                ! Ouvre le fichier enregistrement
PRINT #98;STRING$(75,"-")
PRINT #98;"Connexion en mode"'
IF mod_norm!
PRINT #98;"NORMAL"'
ELSE IF off_line!
PRINT #98;"OFF-LINE"'
ELSE
PRINT #98;"LOCAL"'
ENDIF
PRINT #98;"le"'DATE$'"…"'TIME$;"."
PRINT #98;STRING$(75,"-")
PRINT #98;enr_dispo$
l_xenr&=1                     ! x enregistrement
ENDIF
'
' Boucle de gestion:
'
DO
PBOX l.x1&,l.y1&,l.x2&,l.y2& ! Efface fenetre
PRINT AT(7,4);cd$;SPC(10-LEN(cd$));
PRINT AT(3,6);"Page arbo: Nom: ";
IF LEFT$(page_a$)="\"         ! Si page aternative
find_altern(page_a$)
ENDIF
FOR page_a&=0 TO PRED(nbp_arbo&) ! Cherche nø page dem
EXIT IF nom_arbo$(page_a&)=page_a$ AND info_arbo|(page_a&)<>2
NEXT page_a&
IF page_a&<>nbp_arbo&         ! Si on a trouv‚ page arbo dem
PRINT page_a$;
enregistre(1,page_a$)         ! Enregistre une donn‚e ds le fichier
curpage_a$=page_a$
PRINT AT(29,6);"Fonction: ";
l1$=page_arbo$(page_a&)       ! Stock page arbo
fnct|=VAL(LEFT$(l1$,2))       ! Extract nø fnct
fnct(fnct|)                   ! On va en donner la d‚signation
IF g2$=""                     ! Si nø de fnct inconnu
PRINT AT(3,19);cursor.c$(0);"ERREUR: Num‚ro de fonction: ";fnct|;" non reconnu.";normal.c$;
msgsys("006")               ! Num‚ro de fonction inconnu
cd$="ERREUR ABR"
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
ELSE                          ! Si on connait nø fnct
PRINT g2$'"(";fnct|;")";
l1$=MID$(l1$,LEN(STR$(fnct|))+2) ! EnlŠve fnct de la chaine
@decode_page_arbo             ! Extrac params
'
' on considŠre le D‚but de page arbo ici
'
ctrl_msgsys                   ! Controle la compatibilit‚
ctrl_pagemem(curpage_a$)      ! Controle la compatibilit‚
pm_enabled&=VAL(parametre$(40)) ! Contient les PM … attribuer
DEFTEXT ,,,4
FOR l1|=0 TO 9                ! Parcourt PM
TEXT (l1| MOD 5)*72+16,(174+(l1|\5)*6)*rez|,CHR$(32-BTST(pm_enabled&,l1|)*62)
NEXT l1|
'
l1&=VAL(parametre$(47))       ! Contient les mem suppl … attribuer
IF BTST(l1&,0)                ! Si on doit fixer page Cnx/Fin
l1$=parametre$(48)
page_cnxfin$=l1$
TEXT 430,174*rez|,l1$+SPACE$(8-LEN(l1$))
ENDIF
IF BTST(l1&,1)                ! Si on doit fixer page Fatal Error
l1$=parametre$(49)
page_fatalerr$=l1$
TEXT 430,180*rez|,l1$+SPACE$(8-LEN(l1$))
ENDIF
'
ARRAYFILL key|(),255          ! Init touches de sortie
'
' Recherche page VDT
'
PRINT AT(3,7);"Pages vdt: nø1: "; ! Extract nom page VDT
page_v$=parametre$(0)         ! Nom page vdt demand‚e
find_page                     ! Cherche cette page
IF exit|=FALSE                ! Si page trouv‚e
CLR cd$
CLR page_a$
SELECT fnct|                  ! selon fnct de page
CASE 1,2                      ! START,IMAGE
image(0)
CASE 3                        ! STOP
enregistre(10,"Fin de connexion")
@stop
CASE 4                        ! DIALOGUE
enregistre(10,"Dialogue avec le sysop")
dialogue
CASE 5                        ! TELECHAR
telechar
CASE 6                        ! PSEUDO
enregistre(10,"Demande d'identification")
pseudo(0)
CASE 7                        ! MENU
menu
CASE 8                        ! TABL_CNX
enregistre(10,"Visu du tableau des connexions")
ptr&=1
image(1)
CASE 9                        ! TEL_INV
enregistre(10,"Attente de r‚ception d'un fichier")
tel_inv
CASE 10                       ! LECT_RUB
lect_msg(1)
CASE 11                       ! ECRI_RUB
ecri_rub
CASE 12                       ! RUB_LIST
message_list(3)
CASE 13                       ! CREE_BAL
pseudo(1)
CASE 14                       ! BALS_ANN
enregistre(10,"Visu de l'annuaire des BAL")
bals_ann
CASE 15                       ! LECT_BAL
enregistre(10,"Lecture de la BAL")
lect_msg(0)
CASE 16                       ! ECRI_BAL
ecri_bal
CASE 17                       ! EFFA_BAL
image(4)
CASE 18                       ! EDIT_REP
enregistre(10,"Edition du r‚pondeur de la BAL")
edit_rep
CASE 19                       ! ENV_LIST
enregistre(10,"Visu de la liste des messages envoy‚s")
message_list(1)
CASE 20                       ! REC_LIST
enregistre(10,"Visu de la liste des messages re‡us")
message_list(2)
CASE 21                       ! EFFA_REP
image(6)
CASE 22                       ! EFF_MSGB
image(5)
CASE 23                       ! FICHE_ID
enregistre(10,"Fiche personnelle d'informations")
fiche_id(FALSE)
CASE 24                       ! INFO_CNT
fiche_id(TRUE)
CASE 25,29                    ! JOURNAL,MSG_GUID
enregistre(10,"Journal vid‚otex")
journal
' 26,27 supprim‚s depuis v2.30
CASE 28                       ! AFFICHE
affiche
CASE 30                       ! NEDER
module(TRUE)
CASE 31                       ! FIN
enregistre(10,"Fin de service")
fin
CASE 32                       ! ACCES
enregistre(10,"Test d'accŠs")
acces
CASE 33                       ! BETA_MOD
module(FALSE)
CASE 34                       ! EDT_FICH
edt_fiche
CASE 35                       ! TRANSIT
transition
CASE 36                       ! SHELL
shell(FALSE)
CASE 37                       ! TEXTE
lect_texte
ENDSELECT
'
' Teste fin de communication/poursuite...
'
SELECT exit|
CASE 2
GOTO erreur_vdt
CASE 3
exit|=FALSE
CASE 4
PRINT AT(3,19);cursor.c$(0);"ERREUR: Rubrique: ";rubrique$;" introuvable.";normal.c$;
msgsys("005")          ! Rubrique introuvable
cd$="ERREUR RUB"
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
CASE 6
PRINT AT(3,19);cursor.c$(0);"ERREUR: Affiche: ";affiche;" introuvable.";normal.c$;
msgsys("004")          ! Affiche introuvable
cd$="ERREUR AFF"
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
CASE 7                ! Page altern introuvable
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
CASE 8                ! Base introuvable
PRINT AT(3,19);cursor.c$(0);"ERREUR: Base: ";base$;" introuvable.";normal.c$;
msgsys("007")          ! Base introuvable
cd$="ERREUR BAS"
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
DEFAULT                       ! Inclus: Break  (utile ou pas?)
CLR trans$
ENDSELECT
topline|(2)=FALSE             ! Indication balstate temporaire
'
' Page memories:
'
'       FOR l1&=1 TO 2                ! Profondeur d'interpr‚tation des Ý
real_name(page_a$)            ! InterprŠte les noms de variables!
'       NEXT l1&
'
DEFTEXT ,,,4
FOR l1|=0 TO 9                ! Parcourt PM
IF BTST(pm_enabled&,l1|)      ! Si on doit fixer la PM
l1$=parametre$(50+l1|)
real_name(l1$)                ! InterprŠte les noms de variables!
page_memo$(l1|)=l1$
TEXT (l1| MOD 5)*72+34,(174+(l1|\5)*6)*rez|,l1$+SPACE$(8-LEN(l1$))
ENDIF
NEXT l1|
'
EXIT IF exit|                 ! En particulier si break!
aff_temps_cnx
ELSE                          ! Si pas trouv‚ la page VDT
IF exit|=2
erreur_vdt:
PRINT AT(3,19);cursor.c$(0);"ERREUR: Page vid‚otex: ";page_v$;" introuvable.";normal.c$;
msgsys("002")          ! Page vid‚otex introuvable
cd$="ERREUR VDT"
ENDIF
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
ENDIF
ENDIF
ELSE                          ! Si pas trouv‚ la page arbo
IF exit|<>7
PRINT AT(3,19);cursor.c$(0);"ERREUR: Page arborescence: ";page_a$;" introuvable.";normal.c$;
msgsys("001")          ! Page arbo introuvable
cd$="ERREUR ABR"
ENDIF
serveur.fatal          ! Ya une erreur FATALE
IF l1!                 ! Si ultra-fatal!
GOTO fin_serveur
ENDIF
ENDIF
LOOP
fin_serveur:
PRINT AT(7,4);cd$;SPC(10-LEN(cd$));
g1%=(TIMER-debut%)\200
'
IF p.enr!
IF exit|=5
enregistre(10,"Break … "+TIME$+".")
ELSE
enregistre(10,"D‚connexion … "+TIME$+".")
ENDIF
PRINT #98
PRINT #98
CLOSE #98
ENDIF
'
IF exit|<>5 OR FN selected(5) ! Si pas de (break sans sauve des bals)
sauve_bal
ENDIF
IF exit|<>5 OR FN selected(9) ! Si pas de (break sans sauve des rubs)
sauve_rub
ELSE
enable_maj(3)               ! Permet maj, ... rub
modify!(4)=TRUE             ! Permet maj aff
ENDIF
IF exit|=5 AND mod_norm!      ! Si break en mode normal
loc(1,0)
OUT 1,24
PRINT #99;"Break."
OUT 1,12
OUT 1,27,59,97,88,81          ! Installe Clav => Ecr
OUT 1,27,58,102,5,27,59,97,88,81 ! Transp + Installe Clav => Ecr
OUT 1,27,59,97,90,81          ! Installe Clav => Mod
OUT 1,27,59,97,88,82          ! Installe Mod => Ecr
OUT 1,12,17
ENDIF
PBOX l.x1&,l.y1&,l.x2&,l.y2&  ! Efface fenetre
topline|(0)=80                ! Fond noir
topline|(1)=FALSE             ! Pas d'horloge
l0|=FALSE                     ! L0 dispo
RETURN
> PROCEDURE serveur.fatal
'
' S'il se produit une erreur fatale:
'
IF page_fatalerr$=curpage_a$ OR LEN(page_fatalerr$)=FALSE OR LEN(curpage_a$)=FALSE ! Si FATAL dans FATAL !!!
IF mod_norm!                  ! Si mode normal
@deconnexion
ELSE                          ! Si mode local
REPEAT
UNTIL INP(-2) OR MOUSEK
IF INP(-2)
~INP(2)
ENDIF
ENDIF
l1!=TRUE                      ! Ultra_fatal
ELSE
page_a$=page_fatalerr$        ! Renvoie sur page d'erreur
l1!=FALSE                     ! On va tenter de sauver la situation
exit|=FALSE
ENDIF
RETURN
> PROCEDURE shell(discret!)
LOCAL drvmap%,path$
'
' Gest page SHELL:
'
PRINT AT(3,14);"En cours: [paramŠtres].";
IF bi!=FALSE         ! Si minitel pas bistandard
IF discret!=FALSE
OUT 1,7
ELSE
page_msgsys(1)                 ! Minitel bistandard obligat
ENDIF
ELSE
drvmap%=BIOS(10)          ! Drvmap
IF DPEEK(&H4A6)<2
drvmap%=BCLR(drvmap%,1)     ! Pas de drive B
ENDIF
path$=chemin$(3)            ! Chemin serveur
CHDRIVE LEFT$(path$)
CHDIR path$
shell_init_path       !Nouveau path courant
PRINT AT(13,14);"Passage du minitel en mode mixte.   ";
mixte
topline
PRINT AT(13,14);"Affichage de l'en-tˆte du shell.";SPC(5);
loc(1,24)
PRINT #99;e80$;"1mStut One ";version$;" - Remote Command Shell 1.0";e80$;"22m"
l1%=FRE(0)\1024
PRINT #99;l1%;" Kbytes free."'
IF l1%<35
PRINT #99;"CRITICAL!"
ELSE
PRINT #99;"OK."
ENDIF
PRINT #99;"Type HELP if you need assistance."
PRINT #99
directory(path$,"*.*",FALSE,TRUE)
PRINT #99
shell_init_ligne
g2$=""      ! Ligne pr‚c‚dente
'
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
DO
loc(g2|+1+g0|,24)         ! Positionne csr
get_command(TRUE,TRUE,t%,1,41,41,41,41,41,41,41,41,41," ","")
EXIT IF LEN(page_a$) OR cd$="SOMMAIRE"
IF cd$="ENVOI"
PRINT #99;e80$;"22m"
'
g0$=UPPER$(TRIM$(g0$))        ! passe en MAJUSCULES
g2$=g0$                         ! Sauve ligne
g0$=g0$+" "
'
g3|=INSTR(g0$," ")
g1$=LEFT$(g0$,PRED(g3|))         ! Commande
'
INC g3|
g0$=TRIM$(MID$(g0$,g3|))+" "           ! ParamŠtres
'
EXIT IF g1$="EXIT"
IF g1$="CD"
'
' CD
'
l1|=INSTR(g0$," ")
l1$=LEFT$(g0$,PRED(l1|))
l2$=path$+l1$+"\"
FOR l1&=1 TO nb_paths&
EXIT IF path$(l1&)=l2$
NEXT l1&
IF l1&<=nb_paths&     ! SI ce dossier existe
CHDIR l1$
shell_init_path       !Nouveau path courant
directory(path$,"*.*",FALSE,TRUE)
ELSE
PRINT #99;"   Unknown Folder: [";l1$;"]"
ENDIF
ELSE IF g1$="CHDRV"
'
' CHDRV
'
l1$=LEFT$(g0$)
IF BTST(drvmap%,ASC(l1$)-65)  ! SI lecteur existe
CHDRIVE l1$
shell_init_path       !Nouveau path courant
directory(path$,"*.*",FALSE,TRUE)
ELSE
PRINT #99;"   Unknown Drive: [";l1$;"]"
ENDIF
ELSE IF g1$="COPY"
'
' COPY
'
m1|=INSTR(g0$," ")
m1$=LEFT$(g0$,PRED(m1|))
IF INSTR(m1$,"\")=0
m2$=path$+m1$
ELSE
m2$=m1$
ENDIF
PRINT #99;SPC(3);"Source: ";m2$
'
g0$=TRIM$(MID$(g0$,SUCC(m1|)))+" "
m1|=INSTR(g0$," ")
m1$=LEFT$(g0$,PRED(m1|))
IF INSTR(m1$,"\")=0
m3$=path$+m1$
m2!=TRUE                    ! Dest ds doss courant
ELSE
m3$=m1$
m2!=FALSE                   ! Dest ailleurs
ENDIF
PRINT #99;SPC(3);"Dest  : ";m3$
'
IF m2$=m3$
PRINT #99;SPC(3);"<Source> and <Dest> must be different"
ELSE IF NOT EXIST(m2$)
PRINT #99;SPC(3);"Source file: [";m2$;"] Not found"
ELSE
IF EXIST(m3$)
g3$="Overwrite Dest file: ["+m3$+"] ([Y]es/[N]o)"  ! Entˆte de la ligne
m1!=@shell_dem_conf            !Demande confirmation
EXIT IF LEN(page_a$)
ELSE
m1!=TRUE                  ! OK pour cr‚ation
ENDIF
IF m1!                      ! Si on a le droit de cr‚er
RESERVE FRE(0)-32000
m1%=MALLOC(32000)
'
erreur&=0
err_choix&=10
err_resume&=14
'
OPEN "O",#2,m3$   ! Ouvre dest
OPEN "I",#1,m2$   ! Ouvre source
m2%=LOF(#1)       ! Longueur fichier source
PRINT #99;SPC(3);"Copying ";m2%;" bytes..."
m3%=m2%           ! Long restante
WHILE m3%
IF m3%>32000
m4%=32000
ELSE
m4%=m3%        ! Longueur … charger
ENDIF
BGET #1,m1%,m4%  ! Charge
BPUT #2,m1%,m4%  ! Sauve
SUB m3%,m4%      ! Reste a charger
WEND
err_14:
IF erreur&
shell_aff_erreur
ENDIF
CLOSE #1
CLOSE #2
~MFREE(m1%)
RESERVE FRE(0)+32000
IF erreur&=0
IF m2!            ! Si dest dans dossier courant
directory(path$,"*.*",FALSE,TRUE)
ENDIF
ENDIF
ENDIF
ENDIF
ELSE IF g1$="DEL"
'
' DEL
'
m1|=INSTR(g0$," ")
m1$=LEFT$(g0$,PRED(m1|))
IF EXIST(m1$)
g3$="Delete: ["+path$+m1$+"] ([Y]es/[N]o)"  ! Entˆte de la ligne
m1!=@shell_dem_conf            !Demande confirmation
EXIT IF LEN(page_a$)
IF m1!
erreur&=0
err_choix&=10
err_resume&=15
KILL m1$
directory(path$,"*.*",FALSE,TRUE)
err_15:
IF erreur&
shell_aff_erreur
ENDIF
ENDIF
ELSE
PRINT #99;SPC(3);"File: [";m1$;"] Not found"
ENDIF
ELSE IF g1$="DIR"
'
' DIR
'
directory(path$,"*.*",FALSE,TRUE)
ELSE IF g1$="DOWNLOAD"
'
' DOWNLOAD
'
m1|=INSTR(g0$," ")
m1$=LEFT$(g0$,PRED(m1|))
IF EXIST(m1$)
PRINT #99;SPC(3);"Source: ";path$;m1$
PRINT #99;SPC(3);"Download in progress... ";
download(path$,m1$)                 ! Emission fichier
PRINT #99;
IF m2|=1
PRINT #99;SPC(3);"OK"
ELSE
PRINT #99;SPC(3);"Abort"
ENDIF
topline
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
ELSE
PRINT #99;SPC(3);"Source file: [";m1$;"] Not found"
ENDIF
ELSE IF g1$="DRVMAP"
'
' DRVMAP
'
PRINT #99;SPC(3);
FOR l1&=0 TO 31
IF BTST(drvmap%,l1&)
PRINT #99;CHR$(65+l1&)'
ENDIF
NEXT l1&
PRINT #99
ELSE IF g1$="HELP"
'
' HELP
'
PRINT #99;SPC(3);"Command  Param 1        Param 2      Action"
PRINT #99;SPC(3);"---------------------------------------------"
PRINT #99;SPC(3);"CD       <Folder>                    Change current Directory"
PRINT #99;SPC(3);"CHDRV    <Drive>                     CHange current DRiVe"
PRINT #99;SPC(3);"COPY     <[Path]Source> <[Path]Dest> COPY Source file to Dest"
PRINT #99;SPC(3);"DEL      <File>                      DELete file"
PRINT #99;SPC(3);"DIR                                  list files in current DIRectory"
PRINT #99;SPC(3);"DOWNLOAD <Source>                    DOWNLOAD file (master->slave)"
PRINT #99;SPC(3);"DRVMAP                               MAP connected DRiVe units"
PRINT #99;SPC(3);"EXIT                                 EXIT this command shell"
PRINT #99;SPC(3);"HELP                                 get some HELP..."
PRINT #99;SPC(3);"UPLOAD                               UPLOAD file (slave->master)"
PRINT #99;SPC(3);"---------------------------------------------"
PRINT #99;SPC(3);"[Retour] displays preceding command"
ELSE IF g1$="UPLOAD"
'
' UPLOAD
'
PRINT #99;SPC(3);"Please wait... ";
'
upload(2,path$)                 ! Mode 2,on appelle depuis le shell
'
PAUSE 10
PRINT #99
IF m2|=10
PRINT #99;SPC(3);"File too big"
ELSE IF m2|=11
PRINT #99;SPC(3);"Destination file: [";m1$;"] already exists"
ELSE IF m2|>2
PRINT #99;SPC(3);"Abort"
ELSE
PRINT #99;SPC(3);"OK"
ENDIF
topline
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
ELSE
PRINT #99;"   Unknown Keyword: [";g1$;"]"
ENDIF
PRINT #99
shell_init_ligne
ELSE IF cd$="RETOUR"
'
' Retour
'
l1$=UPPER$(TRIM$(g0$))  ! sauve ligne courante
g0$=SPACE$(g1|)
LSET g0$=LEFT$(g2$,g1|)   ! Ligne pr‚c‚dente
loc(g2|+2,24)
can
PRINT #99;LEFT$(g2$,g1|);
g0|=SUCC(LEN(g2$))       ! Pos curseur
IF g0|>SUCC(g1|)
g0|=SUCC(g1|)
ENDIF
g2$=l1$                 ! Ancienne ligne
ELSE IF cd$="ANNULATION" OR cd$="ACQUIT."
PRINT #99;e80$;"22m";
OUT 1,13
shell_init_ligne
ENDIF
LOOP
PRINT AT(13,14);"Passage du minitel en mode vid‚otex.";
videotex
ENDIF
IF LEN(page_a$)=0 AND discret!=FALSE
page_a$=parametre$(2)         ! Page suivante
ENDIF
RETURN
> PROCEDURE shell_init_ligne
PRINT #99;g3$;">";e80$;"1m";
can
g0$=SPACE$(g1|)
g0|=1
RETURN
> PROCEDURE shell_init_path
'
' Fournit path courant
'
path$=CHR$(65+GEMDOS(&H19))+":"+DIR$(0)+"\" ! Path courant
g3$=path$                   ! Entˆte de la ligne
g2|=LEN(g3$)
g1|=78-g2|                  ! Longueur ligne ‚ditable
RETURN
> FUNCTION shell_dem_conf
g2|=LEN(g3$)
g1|=78-g2|                  ! Longueur ligne ‚ditable
shell_init_ligne
DO
loc(g2|+1+g0|,24)         ! Positionne csr
get_command(TRUE,TRUE,t%,1,2,41,41,41,41,41,41,41,41," ","")
EXIT IF LEN(page_a$)
IF cd$="ENVOI"
PRINT #99;e80$;"22m"
'
g0$=TRIM$(UPPER$(g0$))
'
EXIT IF g0$="Y" OR g0$="N"
'
shell_init_ligne
ENDIF
LOOP
'
g3$=path$                   ! Entˆte de la ligne
g2|=LEN(g3$)
g1|=78-g2|                  ! Longueur ligne ‚ditable
RETURN (g0$="Y")
ENDFUNC
> PROCEDURE shell_aff_erreur
PRINT #99;SPC(3);"Erreur ";erreur&
RETURN
> PROCEDURE stop
'
' Gest page STOP:
'
PRINT AT(3,14);"En cours:";
aff_page_1(page_v&,TRUE)
PRINT AT(13,14);"D‚connexion";SPC(25);
@deconnexion
cd$="STOP"
exit|=1
RETURN
> PROCEDURE sup.car
'
' Suppression d'un car ds get_comm
'
IF mode|=1
IF g0|<=g1|
l1$=MID$(g0$,g0|+1)+" "
g0$=LEFT$(g0$,PRED(g0|))+l1$
FOR l1|=LEN(l1$) DOWNTO 1
IF MID$(l1$,l1|,1)<>" "
EXIT IF LEN(mask$)=FALSE
MID$(l1$,l1|,1)=mask$
ELSE
MID$(l1$,l1|,1)=filler$
ENDIF
NEXT l1|
envoi_chaine(l1$)
ENDIF
g0!=TRUE                      ! Pas de r‚aff
ELSE
g0$=" "
ENDIF
RETURN
'
> PROCEDURE tabl_cnx
'
' Aff tabl derniŠres cnxs sur le mntl:
'
loc(1,0)
OUT 1,24,12
loc(9,0)
font_restore
topline|(1)=0               ! Pas de clock
clock%=TIMER+17280000       ! Prochain aff pendule ds 24h !
topline|(0)=80              ! L0 noire
g1$=CHR$(27)+"Z TABLEAU DES CONNEXIONS"+CHR$(27)+"Y "
g1$=g1$+CHR$(31)+"AB_"+CHR$(18)+"e"+CHR$(31)+"BA"
FOR l1|=0 TO 19
g1$=g1$+connecte$(l1|)
NEXT l1|
g1$=g1$+CHR$(27)+"Z ~"+CHR$(18)+"e"+CHR$(27)+"Y "
g1$=g1$+"}TOTAL CNX:"+CHR$(27)+"E"+RIGHT$("0000"+STR$(nb_appels%),5)+CHR$(27)+"G"
g1$=g1$+" TOTAL DUREE:"+CHR$(27)+"E"+RIGHT$("0000"+STR$(d_totale%\3600),5)+CHR$(27)+CHR$(71)+"h"+CHR$(27)+CHR$(69)+RIGHT$("0"+STR$((d_totale%\60) MOD 60),2)+CHR$(27)+"Gmn{"
g1$=g1$+CHR$(31)+CHR$(88)+"B~"+CHR$(18)+"e"
page_v&=last_v&
page_vdt$(page_v&)=g1$
ptr&=1
g1$=""
RETURN
> PROCEDURE telechar
LOCAL l.mc_valid!
'
' Gest page TELECHAR:
'
PRINT AT(29,7);"Fonction: Choix prog.";
PRINT AT(3,14);"En cours: [paramŠtres].";
test_level(parametre$(12))    ! Test lvls cnt
IF m1|=11                     ! Si lvls OK
g4!=TRUE
ELSE                          ! Si lvls insuff
g4!=FALSE
ENDIF
g5!=-VAL(parametre$(15))      ! Fichiers HID_*.* en Hidden?
g6!=-VAL(parametre$(10))      ! Infos?
g7!=-VAL(parametre$(16))      ! Mode scroll?
g8!=-VAL(parametre$(13))      ! Decrease des cr‚ds?
l1&=VAL(parametre$(17))       ! Etat options
IF BTST(l1&,0)                ! Si aff nb cr‚dd demand‚
x|(0)=VAL(parametre$(18))     ! X cr‚ds
y|(0)=VAL(parametre$(19))     ! Y
decode_attrib(1,parametre$(27)) ! Atts cr‚dits
g2$=l1$
ELSE
x|(0)=FALSE
ENDIF
x|(1)=VAL(parametre$(23))     ! X input
y|(1)=VAL(parametre$(24))     ! Y
g1|=VAL(parametre$(25))       ! Long input
g1$=CHR$(VAL(parametre$(26))) ! Filler
decode_attrib(0,parametre$(31)) ! Atts input
g5$=l1$
l.mc_valid!=BTST(l1&,3)       ! Mots clefs autoris‚s?
y|(2)=VAL(parametre$(21))     ! Y fenˆtre
g3|=PRED(VAL(parametre$(22))) ! Nbl fenˆtre
decode_attrib(0,parametre$(28)) ! Atts dossier
g6$=l1$
decode_attrib(0,parametre$(29)) ! Atts fichier
g7$=l1$
g3!=BTST(l1&,2)               ! Ligne d'infos liste?
decode_attrib(0,parametre$(30)) ! Atts infos list
g8$=l1$
IF LEN(parametre$(32))
g3$=LEFT$(parametre$(32),PRED(LEN(parametre$(32)))) ! Fichiers sont dans ce dossier
ELSE
g3$=chemin$(3)
ENDIF
g4$="\"                       ! On commence … la racine
IF BTST(l1&,1)                ! Si aff path demand‚
y|(3)=VAL(parametre$(20))     ! Y path
ELSE
y|(3)=FALSE
ENDIF
g2&=-2                        ! Nø page t‚l inconnu
g3&=-2                        ! page retour-tel
g4&=-2                        ! page infos
g5&=-2                        ! page retour-infos
g6&=-2                        ! page refus
g7&=-2                        ! page retour-refus
aff_page_1(page_v&,FALSE)
t%=TIMER
g0!=FALSE                     ! Affichage ok
IF x|(0)                      ! Si aff des cr‚ds dem
loc(x|(0),y|(0))
PRINT #99;g2$;RIGHT$("     "+STR$(credits%),6);
ENDIF
g2|=0                         ! On est au niveau 0
enregistre(10,"Visu de la liste t‚l‚chargement")
'
chemin:
CLR nb_files%,g1!             ! D‚but dir du dossier courant
g1%=0                         ! Ligne du haut de la fenetre
~FSETDTA(BASEPAGE+128)
m1$=g3$+g4$+"*.*"             ! Param de recherch
m1&=FSFIRST(m1$,&X10000)
DO UNTIL m1&                  ! On va ‚xaminer tous les noms
l1$=CHAR{BASEPAGE+158}        ! Nom de fichier/dossier
l2$=RIGHT$("0"+STR$(date& AND 31),2)+"/"+RIGHT$("0"+STR$((date& AND 480)/32),2)+"/"+RIGHT$(STR$(80+(date& AND 65024)/512),2)
IF l1$<>"." AND l1$<>".." AND (g5!=FALSE OR LEFT$(l1$,4)<>"HID_")
IF BTST(attrib|,4)            ! Si dossier
IF l1$="INFOS" AND g6!        ! Si dossier INFOS
g1!=TRUE                      ! M‚mo ‚xist infos
ELSE                          ! Si dossier normal
file$(nb_files%)="DDD   "+l1$+SPACE$(13-LEN(l1$))+l2$+" Dossier..."
INC nb_files%                 ! 1 nom de +
ENDIF
ELSE                          ! Si fichier
length%(nb_files%)=longueur%
file$(nb_files%)="FFF   "+l1$+SPACE$(13-LEN(l1$))+l2$+RIGHT$("   "+STR$((length%(nb_files%)+1023)\1024),4)+" "
duree_tel(longueur%)
file$(nb_files%)=file$(nb_files%)+l1$
INC nb_files%                 ! 1 nom de +
ENDIF
ENDIF
m1&=FSNEXT()
LOOP
IF y|(3)                      ! Si aff du path dem
IF nb_files%>1
l1$="S"
ELSE
l1$=""
ENDIF
m1$="("+STR$(nb_files%)+" OBJET"+l1$+")"
m2$=LEFT$(g4$,38)
l1|=LEN(m2$)
IF l1|<38
m2$=g6$+m2$+g7$+LEFT$(m1$,38-l1|)
l1&=l1|+LEN(m1$)-38
IF l1&>0
m3$=g7$+RIGHT$(m1$,l1&)
ELSE
m3$=""
ENDIF
ELSE
m2$=g6$+m2$
m3$=MID$(g4$,39,38)
l2|=LEN(m3$)
IF l2|<38
m3$=g6$+m3$+g7$+LEFT$(m1$,38-l2|)
ENDIF
ENDIF
loc(2,y|(3))                  ! Aff 1Šre ligne du path
OUT 1,24
PRINT #99;m2$;
loc(2,y|(3)+1)                ! 2Šme ligne
OUT 1,24
PRINT #99;m3$;
ENDIF
IF nb_files%
QSORT file$() WITH sort|(),nb_files% ! Tri alpha de la list
FOR l1%=0 TO nb_files%        ! Attribue un nø … chak nom
MID$(file$(l1%),1,3)=RIGHT$("  "+STR$(SUCC(l1%)),3)
NEXT l1%
ENDIF
FOR l1|=0 TO g3|              ! Efface les noms qui suivent...
file$(nb_files%+l1|)=""
NEXT l1|
IF g1!                        ! Si infos existent
~FSETDTA(BASEPAGE+128)        ! Directory
m1$=g3$+g4$+"INFOS\*.*"
m1&=FSFIRST(m1$,&X10000)
DO UNTIL m1&                  ! Recherche des noms
l1$=CHAR{BASEPAGE+158}
IF l1$<>"." AND l1$<>".."     ! Si pas un fichier systŠme
IF BTST(attrib|,4)=FALSE      ! Si pas un dossier
FOR l1%=0 TO nb_files%        ! On cherche le nom dans la liste
l1|=LEN(l1$)
IF MID$(file$(l1%),7,l1|)=l1$ ! S'il y est
MID$(file$(l1%),5,1)="*"      ! Signale la pr‚sence des infos
ENDIF
NEXT l1%
ENDIF
ENDIF
m1&=FSNEXT()
LOOP
ENDIF
g0!=FALSE                     ! Affichage ok
g1&=0
g2%=0                         ! On est pas sur les infos
DO
IF g0!=FALSE
IF g1&=>0
IF g2%
PRINT AT(13,14);"Affichage des infos.";SPC(15);
FOR g1&=g1& TO g3|            ! Parcourt les lignes
EXIT IF INP(TRUE)             ! Sort si action clavier
loc(2,y|(2)+g1&)              ! Pos en d‚but de ligne
l1%=g1%+g1&
IF l1%=0
PRINT #99;g7$;
ELSE
PRINT #99;g6$;
ENDIF
OUT 1,24                      ! Efface ligne
IF l1%<nb_files%
envoi_chaine(ligne$(l1%))     ! Affiche ligne
ENDIF
NEXT g1&
ELSE
PRINT AT(13,14);"Affichage directory.";SPC(15);
FOR g1&=g1& TO g3|            ! Parcourt les lignes
EXIT IF INP(TRUE)             ! Sort si action clavier
loc(2,y|(2)+g1&)              ! Pos en d‚but de ligne
OUT 1,24                      ! Efface ligne
l1$=file$(g1%+g1&)            ! ChaŒne … aff
IF MID$(l1$,29,1)="D"         ! Si dossier
PRINT #99;g6$;
ELSE                          ! Si fichier
PRINT #99;g7$;
ENDIF
PRINT #99;l1$;                ! Aff nom
NEXT g1&
ENDIF
IF g1&=SUCC(g3|) AND g3!=TRUE ! S'il fo aff les infos liste
loc(2,y|(2)+g1&)              ! Pos
OUT 1,24                      ! Efface ligne
PRINT #99;g8$;                ! Atts
IF g1%+g3|+1<nb_files%        ! S'il reste des lignes aprŠs
PRINT #99;"[SUITE]";CHR$(9);
ENDIF
IF g1%>0                      ! S'il y a des lignes avant
PRINT #99;"[RETOUR]";
ENDIF
g1&=TRUE                      ! Affichage fenˆtre termin‚
ENDIF
ENDIF
init_champ(1,g5$,g1|)
ENDIF
CLR g0!                       ! R‚affichage autoris‚
loc(x|(1)+g0|-1,y|(1))
PRINT #99;g5$;
PRINT AT(13,14);"Traitement des commandes.";SPC(10);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,TRUE,t%,1,41,41,41,41,41,41,9,41,41,g1$,"")
EXIT IF LEN(page_a$)
IF cd$="SOMMAIRE"
IF TRIM$(g0$)="*"
page_a$=parametre$(7)
ELSE IF g2%
nb_files%=g2%
CLR g2%
g1%=g3%
g1&=0
aff_page_1(g5&,FALSE)
IF x|(0)                      ! Si on demande les cr‚dits
loc(x|(0),y|(0))
PRINT #99;g2$;RIGHT$("     "+STR$(credits%),6);
ENDIF
IF y|(3)
m2$=m4$
m3$=m5$
loc(2,y|(3))                  ! Aff 1Šre ligne du path
OUT 1,24
PRINT #99;m2$;
loc(2,y|(3)+1)                ! 2Šme
OUT 1,24
PRINT #99;m3$;
ENDIF
ELSE IF g2|>0                 ! Si on veut fermer un dossier
l1|=RINSTR(g4$,"\",LEN(g4$)-1)
g4$=LEFT$(g4$,l1|)
DEC g2|                       ! On remonte dans les dossiers
GOTO chemin
ELSE
page_a$=parametre$(7)
ENDIF
ELSE IF cd$="GUIDE"
m1=ABS(INT(VAL(g0$)))         ! Nø dem
IF g6! AND m1>0 AND m1<=nb_files% ! Si valide
IF g2%=FALSE                  ! Si pas d‚ja infos … l'‚cran
l1%=PRED(m1)
IF MID$(file$(l1%),5,1)="*"   ! Si le fichier … des infos...
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
enregistre(10,"Lecture des infos sur "+MID$(file$(l1%),7,12))
IF g4&=-2                     ! Si nø page inconnu
PRINT AT(14,8);"nø2: ";
page_v$=parametre$(1)         ! Nom page vdt infos
find_page                     ! Cherch nø de cette page
EXIT IF exit|
PRINT AT(29,8);"Fonction: Infos.";
g4&=page_v&
ENDIF
IF g5&=-2                     ! Si nø page retour inconnu
PRINT AT(14,9);"nø3: ";
page_v$=parametre$(2)         ! Nom page vdt retour
find_page                     ! Cherch nø de cette page
EXIT IF exit|
PRINT AT(29,9);"Fonction: Retour d'infos.";
g5&=page_v&
ENDIF
aff_page_1(g4&,FALSE)
g2%=nb_files%                 ! Stock nb fichiers actuel
g3%=g1%                       ! Stocke ligne en haut actuelle
l1$=MID$(file$(l1%),7,INSTR(file$(l1%)," ",7)-7)
IF y|(3)                      ! Si on veut voir le path
m4$=m2$                       ! Stocke path
m5$=m3$
m2$=LEFT$(g4$,38)
l1|=LEN(m2$)
IF l1|<38
m2$=g6$+m2$+g7$+LEFT$(l1$,38-l1|)
l1&=l1|+LEN(l1$)-38
IF l1&>0
m3$=g7$+RIGHT$(l1$,l1&)
ELSE
m3$=""
ENDIF
ELSE
m2$=g6$+m2$
m3$=MID$(g4$,39,38)
l2|=LEN(m3$)
IF l2|<38
m3$=g6$+m3$+g7$+LEFT$(l1$,38-l2|)
ENDIF
ENDIF
loc(2,y|(3))                  ! Aff 1Šre ligne du path
OUT 1,24
PRINT #99;m2$;
loc(2,y|(3)+1)                ! 2Šme
OUT 1,24
PRINT #99;m3$;
ENDIF
OPEN "I",#1,g3$+g4$+"INFOS\"+l1$
RECALL #1,ligne$(),39,nb_files% ! Charge infos
CLOSE #1
INSERT ligne$(0)=file$(l1%)
INC nb_files%                 ! Nbl
g1%=0                         ! Ligne en haut
g1&=0                         ! Ptr d'affichage
ENDIF
ENDIF
ELSE                          ! Si on n'a pas indiqu‚ de nø
page_a$=parametre$(8)
ENDIF
ELSE IF cd$="RETOUR"
IF g1%-g3|>0
SUB g1%,g3|+1
g1&=0
ELSE
page_msgsys(4)                ! PremiŠre page
ENDIF
ELSE IF cd$="SUITE"
IF g1%+g3|+1<nb_files%
ADD g1%,g3|+1
g1&=0
ELSE
page_msgsys(5)                ! DerniŠre page
ENDIF
ELSE IF cd$="ENVOI"
m1=ABS(INT(VAL(g0$)))         ! Nø dem
IF g2%                        ! Si on est sur page d'infos
IF TRIM$(g0$)="" OR TRIM$(g0$)="*"
l1$=TRIM$(MID$(ligne$(0),7,13)) ! Extract nom s‚lect
m1=1
IF MID$(ligne$(0),29,1)="D"    ! Si dossier
g4$=g4$+l1$+"\"               ! Change path
INC g2|                       ! Descend dans les dossiers
GOTO chemin                   ! New dir
ELSE                          ! Si on veut t‚l‚charger
GOTO envoi_prog
ENDIF
ELSE
reco_clef(0)
PRINT AT(3,17);"Mot clef dem: ";g0$;SPC(40-LEN(g0$));
ENDIF
ENDIF
IF m1>0 AND m1<=nb_files%     ! Si nø valide
l1$=TRIM$(MID$(file$(PRED(m1)),7,13)) ! Extract nom s‚lectionn‚
IF MID$(file$(PRED(m1)),29,1)="D" ! Si dossier
g4$=g4$+l1$+"\"               ! Change path
INC g2|                       ! On descend dans les dossiers
GOTO chemin                   ! New dir
ELSE                          ! Si on veut t‚l‚charger
envoi_prog:
IF g4!                        ! Si tel autoris‚
g4%=VAL(MID$(file$(PRED(m1)),29,4))
IF g8!=FALSE OR g4%<=credits%
envoi_prog(g3$+g4$,l1$)
ELSE
tel_interdit
ENDIF
ELSE                          ! Si tel interdit
tel_interdit
ENDIF
EXIT IF LEN(page_a$)
enregistre(10,"Visu de la liste t‚l‚chargement")
t%=TIMER
IF x|(0)                      ! Si on demande les cr‚dits
loc(x|(0),y|(0))
PRINT #99;g2$;RIGHT$("     "+STR$(credits%),6);
ENDIF
IF y|(3)                      ! Si on veut voir le path
loc(2,y|(3))                  ! Aff 1Šre ligne du path
OUT 1,24
PRINT #99;m2$;
loc(2,y|(3)+1)                ! 2Šme
OUT 1,24
PRINT #99;m3$;
ENDIF
CLR g1&                       ! Ptr d'affichage … 0
ENDIF
ELSE IF g2%=FALSE   ! si pas sur page d'infos! IF l.mc_valid!           ! Peut ˆtre un mot clef
reco_clef(0)
PRINT AT(3,17);"Mot clef dem: ";g0$;SPC(40-LEN(g0$));
ENDIF
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
RETURN
> PROCEDURE tel_interdit
'
' Affiche 1 ‚cran si t‚l refus‚:
'
PRINT AT(13,14);"[ParamŠtres].";SPC(23);
IF g6&=-2                     ! Si nø page inconnu
PRINT AT(14,12);"nø6: ";
page_v$=parametre$(5)         ! Nom page vdt de refus
find_page                     ! Cherche nø
IF exit|                      ! Si erreur
GOTO fin_tel_interdit         ! Pas d'affichage de page "interdit"
ENDIF
PRINT AT(29,12);"Fonction: Refus t‚l‚ch.";
g6&=page_v&
ENDIF
IF g7&=-2                     ! Si nø page retour inconnu
PRINT AT(14,13);"nø7: ";
page_v$=parametre$(6)         ! Nom page
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO fin_tel_interdit         ! Pas d'affichage de page "interdit"
ENDIF
PRINT AT(29,13);"Fonction: Retour de refus.";
g7&=page_v&
ENDIF
IF g6&=>0
ptr&=1
ELSE
ptr&=TRUE
ENDIF
interrupt!=TRUE
DO
IF ptr&>0
PRINT AT(13,14);"Affichage de la page de refus.     ";
affiche_vdt(g6&)
t%=TIMER
ENDIF
PRINT AT(13,14);"Traitement des commandes.";SPC(12);
PRINT AT(3,15);"Commande: ";
get_command(TRUE,g0&,t%,0,41,8,41,41,41,41,9,41,41,"","")
IF cd$="SOMMAIRE" OR cd$="ANNULATION" OR cd$="RETOUR"
aff_page_1(g7&,FALSE)
EXIT IF TRUE
ELSE
no_effect                 ! Touche sans effet
ENDIF
LOOP UNTIL LEN(page_a$)
fin_tel_interdit:
RETURN
> PROCEDURE tel_inv
'
' Gest page TEL_INV:
'
PRINT AT(29,7);"Fonction: Contr“le."
PRINT AT(3,14);"En cours: [paramŠtres].";
test_level(parametre$(12))    ! Test lvls cnt
IF m1|<11                     ! Si insuffisants
page_a$=parametre$(4)
GOTO no_tel_inv
ENDIF
g1&=page_v&                   ! Nø page CONTROLE
PRINT AT(14,8);"nø2: ";
page_v$=parametre$(1)         ! Nom page RECEPTION
find_page                     ! Cherch nø
IF exit|                      ! Si erreur
GOTO no_tel_inv
ENDIF
PRINT AT(29,8);"Fonction: R‚ception.";
g2&=page_v&                   ! Nø page RECEPTION
g1!=VAL(parametre$(9))        ! Mode rouleau ?
IF parametre$(6)=""
parametre$(6)=chemin$(3)
ENDIF
aff_page_1(g1&,FALSE)
'
CHDRIVE LEFT$(parametre$(6))  ! On va sur l'unit‚ de r‚ception
'
upload(1,parametre$(6))       ! Mode normal
'
SELECT m2|              ! Aff message erreur s'il y a!
CASE 10
PAUSE 3
page_msgsys(2)                ! Fichier trop long
PAUSE 5
CASE 11
PAUSE 3
page_msgsys(3)                ! Ce fichier existe d‚ja!
PAUSE 5
ENDSELECT
IF m2|<4 OR m2|>=10
page_a$=parametre$(3)         ! Page de retour
ENDIF
no_tel_inv:
RETURN
> PROCEDURE test_level(a$)
'
' Test si lvls cnt sont suffisants:
'
FOR m1|=1 TO 10
EXIT IF MID$(a$,m1|,1)>MID$(levels$,m1|,1)
NEXT m1|
RETURN
> PROCEDURE transition
'
' Gest page TRANSIT:
'
LOCATE 29,7
FOR m1&=1 TO 9
PRINT AT(3,17);"En cours: Affichage de la page vid‚otex nø";STR$(m1&);
interrupt!=FALSE
IF ptr&>0
affiche_vdt(page_v&)
ENDIF
EXIT IF m1&=9
PRINT AT(14,7+m1&);"nø";STR$(SUCC(m1&));": ";
page_v$=parametre$(m1&)         ! Nom page vdt suivante
find_page                       ! Installe page
EXIT IF exit|
NEXT m1&
page_a$=parametre$(13)                ! Page arbo suiv
RETURN
'
> PROCEDURE upload(shell_mode|,path$)
'
key|(0)=1                     ! Signal de d‚but de d‚but d'envoi
key|(1)=66                    ! Signal de test
m2|=0                         ! A priori, pas d'erreur ni rien
'
PRINT AT(13,14);"Test de la place dispo sur le disk.";
PRINT AT(3,11);"Path:"'path$;
PRINT AT(3,10);"Place disponible en r‚ception: ";
g1%=DFREE(0)                  ! Place disp
PRINT g1%'"octets."
PRINT AT(13,14);"Analyse des op‚rations du connect‚.";
PRINT AT(3,15);"Commande:"'
WHILE INP(TRUE)
get_command(TRUE,TRUE,deco%,0,3,41,3,41,3,41,41,41,41,"","")
IF cd$="SOMMAIRE" OR cd$="ANNULATION" OR cd$="RETOUR" OR cd$="FIN" OR cd$="DECO" OR cd$="DELAI" OR cd$="PRO 1" OR cd$="PRO 2" OR cd$="PRO 3" OR cd$="PRO 80 COL" OR cd$="S-INTERDIT"
m2|=3
GOTO fin_tel_inv
ELSE IF shell_mode|=1
no_effect                 ! Touche sans effet
ENDIF
WEND
rs232.adr%=MALLOC(1442)       ! Alloc 1442 octets pour RS IN
tamp1.adr%=MALLOC(1080)       ! Alloc 1080 octets pour DSK OUT
rs_in(rs232.adr%,1442)        ! Mise en place du buffer RS IN
IF shell_mode|=1              ! Si page UPLOAD
aff_page_1(g2&,FALSE)
IF g1!                        ! Si on dem mode rouleau
scroll
ENDIF
ELSE IF shell_mode|=2
PRINT #99;
PRINT #99;SPC(3);"Upload in progress... ";
ENDIF
PRINT AT(3,13);"R‚ception en cours.";
PRINT AT(13,14);"ParamŠtrage des minitels.          ";
PRINT AT(3,15);"Nom du fichier    :"
PRINT AT(3,16);"Taille du fichier :"
PRINT AT(3,17);"Temps de transfert:           Reste:";
PRINT AT(3,18);"Nombre de bloc(s) :           Reste:";
PRINT AT(3,19);"Nombre d'erreur(s): 0";
IF topline|(1)                ! Si pendule active
clock%=TIMER+17280000         ! Prochain aff pendule ds 24h !
ENDIF
OUT 1,27,59,97,88,82          ! Inst Modem => Ecran
OUT 1,27,58,102,5,27,59,97,88,83 ! Tranp 5 + Inst Prise => Ecran
OUT 1,&H1B,&H3A,&H6F,&H31,&H1B,&H3A,&H66,&H3,&H1B,&H39,&H6C  ! Inv vitesses
PRINT AT(13,14);"Attente de synchronisation.        ";
REPEAT
CLR m2|
deco%=TIMER
get_command(FALSE,TRUE,deco%,0,41,41,41,41,41,41,41,41,41,"","")
EXIT IF LEN(page_a$)
IF cd$="SOMMAIRE" OR cd$="ANNULATION" OR cd$="RETOUR"
m2|=3
GOTO fin_reception
ELSE IF LEFT$(cd$,2)="TO"
l1|=VAL(RIGHT$(cd$))
IF l1|=0 OR l1|=1
m2|=SUCC(l1|)
ENDIF
ELSE IF cd$="FIN" OR cd$="DECO" OR cd$="DELAI" OR cd$="PRO 1" OR cd$="PRO 2" OR cd$="PRO 3" OR cd$="PRO 80 COL" OR cd$="S-INTERDIT"
m2|=4
GOTO fin_reception
ELSE IF shell_mode|=1
no_effect                 ! Touche sans effet
ENDIF
UNTIL m2|
OUT 1,65                      ! Ack
PRINT AT(13,14);"R‚ception du header.";SPC(10);
CLR m9%                       ! Pas d'erreurs pour l'instant
header.2:
CLR m1%,m1$
REPEAT                        ! R‚cep longueur du nom
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
UNTIL l1%>0 AND l1%<13
m4%=l1%
FOR m3|=1 TO m4%              ! R‚cep nom du fichier
reception.2
EXIT IF m2|>2
m1$=m1$+CHR$(l1%)
NEXT m3|
PRINT AT(23,15);m1$;SPC(12);
IF m2|>2
GOTO fin_reception
ENDIF
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
m5%=l1%*64                    ! Octet fort nb blocs
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
ADD m5%,l1%                   ! Octet faible nb blocs
PRINT AT(23,18);SPC(10);
PRINT AT(23,18);m5%;
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
m6%=l1%*64                    ! Octet fort ajout
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
ADD m6%,l1%                   ! Octet faible ajout
m7%=(m5%-1)*1080+m6%          ! Taille du fichier
PRINT AT(23,16);m7%'''''''
m2%=m1% AND 4095              ! Calcul checksum
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
m3%=l1%*64                    ! Octet fort checksum re‡u
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
IF m3%+l1%<>m2%               ! Si le checksum est incorrect
OUT 1,78                      ! Aquitement -
INC m9%                       ! 1 erreur de +
PRINT AT(23,19);m9%;          ! Affiche nb erreurs
GOTO header.2                 ! Recommence r‚cep header
ENDIF
PRINT AT(13,14);"Contr“le des informations.";
duree_tel(m7%)
PRINT AT(23,17);TRIM$(l1$);
PRINT AT(40,17);TRIM$(l1$);
IF m7%>g1%-1024               ! Control place disque
m2|=10
GOTO fin_reception
ENDIF
l1$=path$+m1$                 ! Path & Nom fichier
IF EXIST(l1$)                 ! Contr“le d'existence
m2|=11
GOTO fin_reception
ENDIF
OUT 1,65                      ! Ack
PRINT AT(13,14);"Ouverture du fichier de r‚ception. ";
OPEN "O",#1,l1$               ! Cr‚‚ fichier
WHILE m5%>0                   ! Tant qu'il y a des blocs
m8%=(1080 AND (m6%=0 OR m5%>1))+(m6% AND m5%=1)
bloc:
PRINT AT(13,14);"R‚ception d'un bloc.";SPC(15);
CLR m1%
PRINT AT(40,18);m5%'
IF m6%
duree_tel((m5%-1)*1080+m6%) ! Calcul dur‚e restante
ELSE
duree_tel(m5%*1080)         ! Calcul dur‚e restante
ENDIF
PRINT AT(40,17);TRIM$(l1$)'
recoit_bloc(m8%,tamp1.adr%)   ! R‚cept bloc
IF m2|>2
GOTO fin_reception
ENDIF
m2%=m1% AND 4095              ! Calcul checksum
PRINT AT(13,14);"Contr“le du checksum.";SPC(14);
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
m3%=l1%*64                    ! Octet fort check re‡u
reception.2
IF m2|>2
GOTO fin_reception
ENDIF
IF m3%+l1%<>m2%               ! Si les 2 checksums sont diff‚rents
OUT 1,78                      ! Nack
INC m9%                       ! 1 erreur de +
PRINT AT(23,19);m9%;          ! Aff nb erreurs
GOTO bloc
ENDIF
DEC m5%
OUT 1,65                      ! Ack
PRINT #1;"";                  ! Anti-bug en compil‚!
BPUT #1,tamp1.adr%,m8%        ! Sauve bloc sur le disque
WEND
PRINT AT(40,18);0'            ! Aff nb blocs restants
duree_tel(0)                  ! Calcul dur‚‚e restante
PRINT AT(40,17);TRIM$(l1$)'
fin_reception:                ! En fin de r‚cept ou en cas d'interr
PRINT AT(13,14);"Fermeture du fichier de r‚ception. ";
CLOSE #1
PRINT AT(13,14);"ParamŠtrage des minitels.          ";
PAUSE 5
OUT 1,&H1B,&H39,&H6C          ! Remise … normal des vitesses
PAUSE 2
OUT 1,27,59,96,88,82          ! Supp Modem => Ecran
PAUSE 2
OUT 1,27,58,102,5,27,59,96,88,83 ! Transp 5 + Supp Prise => Ecran
IF g1! AND shell_mode|=1      ! Si on s'est mis en mode rouleau
page
ENDIF
IF topline|(1)                ! Si pendule active
l2$=TIME$
clock%=TIMER+12000-VAL(RIGHT$(l2$,2))*200 ! Calcule prochain aff
ENDIF
libere_tel_inv
fin_tel_inv:
FOR l1|=10 TO 13
PRINT AT(3,l1|);SPC(50);
NEXT l1|
PRINT AT(13,14);SPC(30);
FOR l1|=15 TO 19
PRINT AT(3,l1|);SPC(50);
NEXT l1|
key|(0)=255
key|(1)=255
RETURN
> PROCEDURE upd_sys
'
' R‚affiche inf statut clav et pr‚sence sys:
'
IF clav!
PRINT AT(60,24);cursor.c$(0);"Em";normal.c$;
ELSE
PRINT AT(60,24);"L0";
ENDIF
IF sysop|=FALSE               ! Mode Absent
PRINT AT(71,24);"Absent ";
ELSE IF sysop|=1              ! Mode Appel
PRINT AT(71,24);"Appel  ";
ELSE                          ! Mode Pr‚sent
PRINT AT(71,24);cursor.c$(0);"Pr‚sent";normal.c$;
ENDIF
RETURN
'
> PROCEDURE voir_base(VAR nom$(),alpha$())
LOCAL l.more!,l.offset&,l.back!,l.loc&,l.fichier$
'
' Visu base de donn‚es
'
titre("Consultation d'une base de donn‚es")
s_title$="Consultation d'une base"
type&=6
visu_type&=1                  ! Type de donn‚es visualis‚es
'
DO
DEFMOUSE 0
select(s_title$,base$,nbn_base&)
DEFMOUSE 2
EXIT IF b%=28                      ! [ANNULER]
nom$=FN edit$(26)
IF LEN(nom$)=FALSE       ! Sinon, si pas de nom de page
nom$="SANS_NOM"
ENDIF
no_base&=FN find_page(nom$,nb_base&,nom$()) ! Nø page
'
IF no_base&<0
ALERT 1,"|La base: "+nom$+"|n'existe pas!",1,"   OK   ",void
ELSE
l.fichier$=chemin$(1)+nom$+".DBF"
REPEAT
DEFMOUSE 2
IF EXIST(l.fichier$)
base$=nom$                    ! Nouveau nom par d‚faut
OPEN "I",#1,l.fichier$
voir_texte.charge_tranche     ! Charge le d‚but
'
handle%=WIND_CREATE(&X111000011,10,10,100,100) ! Cr‚ation fenetre
w_name$="Consultation de la base "+nom$+CHR$(0)
l1%=V:w_name$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
voir_texte("",3,72)   ! Visu du texte
CLOSE #1
libere_texte                  ! LibŠre ram text
l1|=4                         ! On va sortir des boucles
ELSE
DEFMOUSE 0
ALERT 2,"|Le fichier: "+nom$+".DBF|ne peut ˆtre trouv‚!",2,"Abandon|Retry",l1|
ENDIF
UNTIL l1|<>2
EXIT IF l1|=4
ENDIF
LOOP
'
~MENU_BAR(menu.adr%,1)        ! Active menu
DEFMOUSE 0
RETURN
> PROCEDURE voir_enr
LOCAL l.more!,l.offset&,l.back!,l.loc&,l.fichier$
'
' Visu enregistr des cnxs:
'
titre("Visualisation de l'e"+nregistr$) ! Aff titre
visu_type&=0                  ! Type de donn‚es visualis‚es
'
l.fichier$=chemin$(3)+"CNXS.LST"
REPEAT
DEFMOUSE 2
IF EXIST(l.fichier$)
OPEN "I",#1,l.fichier$
voir_texte.charge_tranche     ! Charge le d‚but
'
handle%=WIND_CREATE(&X111000011,10,10,100,100) ! Cr‚ation fenetre
w_name$="E"+nregistr$+CHR$(0)
l1%=V:w_name$
~WIND_SET(handle%,2,CARD(SWAP(l1%)),CARD(l1%),0,0)
voir_texte(enr_dispo$,2,74)   ! Visu du texte
CLOSE #1
libere_texte                  ! LibŠre ram text
l1|=1                         ! On va sortir de la boucle
ELSE
DEFMOUSE 0
ALERT 2,"Le fichier: CNXS.LST n'existe|pas ou ne figure dans le|r‚pertoire indiqu‚ dans le|champ: SERVEUR.",2,"Abandon|Retry",l1|
ENDIF
UNTIL l1|=1
'
~MENU_BAR(menu.adr%,1)        ! Active menu
RETURN
> PROCEDURE voir_texte(w_info$,p.x_car&,p.w_car&)
LOCAL l.screen.adr%,l.dirasc|,l.cursor!,l.exit!
LOCAL l.x_g&,l.l_g&,l.w_g&,l.r_g&,l.x_no&,l.x_ins&
'
' Visu d'un texte
'
cls_2nd                       ! Eff 2Šme ‚cran
~MENU_IENABLE(menu_voir.adr%,17,0) ! D‚but
~MENU_IENABLE(menu_voir.adr%,18,0) ! Retour
IF l.more!=0 AND visu_type&=0
~MENU_IENABLE(menu_voir.adr%,25,1) ! Couper ici
ELSE
~MENU_IENABLE(menu_voir.adr%,25,0) ! Couper ici
ENDIF
~MENU_BAR(menu_voir.adr%,1)
DEFMOUSE 0
'
l.cursor!=FALSE               ! Pas de curseur
g8&=1                         ! Coord csr (n'apparait pas)
g9&=0
g10&=0                        ! Haut du bloc
g11&=TRUE                     ! Bas du bloc
'
~WIND_CALC(0,&X111000011,l.l_g&,21*rez|+rm|*2,l.w_g&,172*rez|-rm|*2,x%,y%,w%,h%)
~WIND_OPEN(handle%,x%,y%,w%,h%) ! Dessine fen
window!=TRUE                  ! On a ouvert une fenˆtre
taille_asc                    ! Taille ascens
'
REPEAT                        ! Gest fenetre:
g0&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,mes.adr%,250,g1&,g2&,g3&,g4&,g5&,g6&)
l.dirasc|=BYTE(g5&)
IF BTST(g0&,4)           ! Event fenetre
SELECT evt&
CASE 10                       ! S‚lect menu
SELECT selection&
CASE 8                        ! Infos
voir_texte.infos
CASE 17                       ! D‚but
voir_texte.debut
CASE 18                       ! Retour
voir_texte.retour
CASE 19                       ! Suite
voir_texte.suite
CASE 21                       ! Imprimer
imprime_fenetre
CASE 23                       ! Sortir
l.exit!=TRUE
CASE 25                       ! Couper ici
voir_texte.couper(FALSE)
CASE 26                       ! Initialiser
voir_texte.couper(TRUE)
ENDSELECT
~MENU_TNORMAL(menu_voir.adr%,titre&,1) ! Efface titre s‚lect
CASE 20                       ! Redraw
affiche_texte                 ! Affich text et csr
CASE 21                       ! Demande activation fen
~WIND_SET(handle%,10,0,0,0,0)
CASE 22                       ! Bouton de sortie
l.exit!=TRUE
CASE 24                       ! FlŠches de d‚placement
SELECT message&(4)
CASE 0                        ! Page haut
page_up
CASE 1                        ! Page bas
page_down
CASE 2                        ! Ligne haut
IF g7&>0                      ! Si est pas au min
scroll_up(1,FALSE)
ENDIF
CASE 3                        ! Ligne bas
IF g7&<nbl%-19                ! Si on est pas au max
scroll_down(1,FALSE)
ENDIF
ENDSELECT
CASE 26                       ! D‚placement de l'ascenseur...
g7&=message&(4)*(nbl%-19)/1000
g8&=g7&
affiche_texte
ENDSELECT
CLR evt&
ENDIF
'
IF BTST(g0&,0)                ! Event clavier (+ timer)
IF g4&=4                      ! Touche Ctrl active
SELECT l.dirasc|
CASE 1                        ! Abandon
l.exit!=TRUE
CASE 3                        ! couper
IF l.more!=FALSE AND visu_type&=0
voir_texte.couper(FALSE)
ENDIF
CASE 4                        ! D‚but
IF l.back!
voir_texte.debut
ENDIF
CASE 9                        ! Init
voir_texte.couper(TRUE)
CASE 16                       ! [Ctrl P]
imprime_fenetre               ! Impression du contenu de la fenˆtre
CASE 18                       ! Retour
IF l.more!
voir_texte.retour
ENDIF
CASE 19                       ! Suite
IF l.more!
voir_texte.suite
ENDIF
ENDSELECT
ELSE IF g4&=8 AND l.dirasc|<>64 AND (l.dirasc|<91 OR l.dirasc|>93) ! Alt actif sans @,[,\,]
IF @ascii(g5&)=73             ! [Alt I]
voir_texte.infos
ENDIF
ENDIF
ENDIF
UNTIL l.exit!
'
~WIND_CLOSE(handle%)          ! Ferme fenetre
~WIND_DELETE(handle%)         ! Efface fenetre de la ram
window!=FALSE                 ! Plus de fenˆtre
'
~MENU_BAR(menu_voir.adr%,0)
RETURN
> PROCEDURE voir_texte.charge_tranche
LOCAL l.pred_nbl%
'
file_loc%(l.loc&)=LOC(#1)     ! Position pointeur avant chargement
INC l.loc&                    ! On avance d'une tranche
l.pred_nbl%=nbl%              ! Nombre de lignes pr‚c‚demment en m‚moire.
RECALL #1,editor$(),nbl_max&,nbl%
IF l.pred_nbl%<(nbl%+19)
l.pred_nbl%=nbl%+19
ENDIF
FOR l1&=nbl% TO l.pred_nbl%   ! Efface les lignes inutiles, et au minimum 20 lignes
editor$(l1&)=""
NEXT l1&
IF nbl%>0
DEC nbl%
IF visu_type&=1              ! Si on affiche une base de donn‚es
l2&=0
FOR l1&=0 TO nbl%            ! Parcourt lignes
l1$=editor$(l1&)
IF MID$(l1$,3,1)=":"         ! Champ
editor$(l1&)=fiches_nom$(no_base&,VAL(LEFT$(l1$,2)))+":  "+MID$(l1$,4)
ELSE IF l1$=CHR$(9)          ! D‚but fiche
l2&=1
ELSE IF l2&=1                ! No d'identification
editor$(l1&)="Fiche Nø:  "+l1$
l2&=2
ELSE IF l2&=2                ! Date
editor$(l1&)="Date de cr‚ation:  "+l1$
l2&=0
ENDIF
NEXT l1&
ENDIF
ENDIF
l.more!=EOF(#1)=FALSE AND l.loc&<nb_charpass_max& ! Si pas fin de fich ou capa max atteinte
IF nbl%>0 AND l.more!=FALSE
DEC nbl%                    ! Ajuste nbl
ENDIF
~MENU_IENABLE(menu_voir.adr%,19,-l.more!)
g7&=0                         ! on se place sur 1Šre ligne
RETURN
> PROCEDURE voir_texte.couper(p.mode!)
IF p.mode!
ALERT 2,"Etes-vous s–r|de vouloir|initialiser|l'enregistrement?",2,"Init.|Annuler",l1|
ELSE
ALERT 2,"Etes-vous s–r|de vouloir couper|l'enregistrement|ici?",2,"Couper|Annuler",l1|
ENDIF
IF l1|=1
DEFMOUSE 2
CLOSE #1
OPEN "O",#1,l.fichier$
IF p.mode!=FALSE
FOR l1&=g7& TO SUCC(nbl%)
PRINT #1;editor$(l1&)
NEXT l1&
ELSE IF visu_type&=1        ! Si fichier .DBF
OUT #1,9,13,10                ! Marque d‚but du fichier!
ENDIF
CLOSE #1
DEFMOUSE 0
l.exit!=TRUE
ENDIF
RETURN
> PROCEDURE voir_texte.debut
l.loc&=0                      ! 1Šre tranche
l.back!=FALSE                 ! On ne peut pas retourner en arriŠre
SEEK #1,0                     ! D‚but fichier
voir_texte.charge_tranche
l.offset&=0                   ! D‚but: ligne 0
voir_texte.reaff
RETURN
> PROCEDURE voir_texte.infos
IF l.more!
ALERT 1,"ATTENTION: La longueur de|l'enregistrement d‚passe|"+STR$(nbl_max&)+" lignes! Cliquez sur|Suite pour continuer.",1,"   OK   ",void
ELSE
ALERT 0,"La totalit‚ de|l'enregistrement  |a ‚t‚ charg‚e.",1,"   OK   ",void
ENDIF
RETURN
> PROCEDURE voir_texte.reaff
~MENU_IENABLE(menu_voir.adr%,17,-l.back!) ! D‚but
~MENU_IENABLE(menu_voir.adr%,18,-l.back!) ! Retour
~MENU_IENABLE(menu_voir.adr%,25,1+l.more!) ! Couper ici
taille_asc
affiche_texte
RETURN
> PROCEDURE voir_texte.retour
SUB l.loc&,2                  ! Retourne en d‚but de tranche pr‚c‚d
IF l.loc&=FALSE               ! Si d‚but de fichier
l.back!=FALSE
ENDIF
SEEK #1,file_loc%(l.loc&)
voir_texte.charge_tranche
SUB l.offset&,nbl_max&        ! lignes en moins
voir_texte.reaff
RETURN
> PROCEDURE voir_texte.suite
l.back!=TRUE                  ! On doit pouvoir retourner en arriŠre
voir_texte.charge_tranche
ADD l.offset&,nbl_max&        ! lignes de plus
voir_texte.reaff
RETURN
'
