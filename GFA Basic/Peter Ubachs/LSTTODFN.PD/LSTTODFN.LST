' LSTTODFN pu 29/9/90 u. 12/10/91 (free Images ergÑnzt)
' wandelt vom DRI-RCS 2.1 fÅr GfA-Basic erzeugte .LST-Datei in
' das fÅr das RCS lesbare .DFN-Format um
'
' Das Listing habe ich geschrieben, als mir zum zweiten Mal
' bei einem umfangreichen RCS-File das DFN-File verloren ging
' (Das RCS schreibt nÑmlich die Namen sequentiell in die DFN-
' Datei, die erst geschlossen wird, wenn das RCS korrekt
' verlassen wird. Bei einem Absturz -oder man schaltet, statt
' das RCS korrekt zu verlassen den Rechner aus (mir alles
' schon passiert...)- geht die DFN-Datei verloren.).
'
' ZusÑtzlich wird bei der Gelegenheit das DFN-File sortiert,
' was wirklich nicht Schaden kann, da das RCS die Namen
' einfach in der Reihenfolge abspeichert, wie sie vergeben
' werden.
'
' Probleme: In der LST-Datei ist nicht vermerkt, ob ein
' Baum nun ein MenÅ ist oder nicht. Deshalb werden alle
' BÑume als DialogbÑume in die DFN-Datei geschrieben, das
' mu· man dann im RCS eben selber korrigieren.
'
' Das Format der DFN-Datei ist (allerdings falsch) in
' ST-Computer 7/8/90 S.104 angegeben. Besser selber Filemonitor
' verwenden oder weiter unten in diesem Listing nachschauen.
' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Dieses Listing ist vermutlich nicht fehlerfrei, da ich keine
' vollstÑndigen Unterlagen zum DFN-Format besitze. Aber bis jetzt
' hat es bei all meinen RSC-Files funktioniert.
' Zu beachten ist insbesondere:
' ####################################################
' # VORSICHT !!!!!!!                                 #
' # funktioniert z.Zt. nur bis 255 Objekte pro Baum  #
' #                                                  #
' # bei mehr Objekten muû nachgearbeitet werden !    #
' ####################################################
' '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' POST:
' ˇˇˇˇ
' Wer mir schreibt und eine Antwort erwartet, sollte ausreichend
' RÅckporto beilegen.
'
' FÅr dieses kurze Listing wird kein Obulus erwartet und auch
' keiner entgegen genommen.
'
' Wer sich revanchieren will, darf mir ein eigendes Listing
' (GFA-B. bevorzugt) zusenden.
'
' Wer dieses Listing ergÑnzt bzw. verbessert, darf mir die verbesserte
' bzw. ergÑnzte Version mit einer Beschreibung, was ergÑnzt oder
' verbessert wurde, zuschicken.
'
' Peter Ubachs, Schlenkestr.54, 4620 Castrop-Rauxel, den 13.9.92
' ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ
max_lst_zeilen&=5000  ! gro·zÅgig
max_baume&=100        ! bemessen
max_obj_pro_baum&=256 ! .
DIM lst$(max_lst_zeilen&)
pfad$=""
dateiname$="DEFAULT"
extender$="LST"
'
REPEAT
  ERASE prior%(),index%()
  abbruch!=NOT FN fsel(".LST-Datei zur Umwandlung ?",pfad$+"\*.LST",dateiname$+"."+extender$,lstfile$)
  IF NOT abbruch!
    split_pfadname(lstfile$,pfad$,dateiname$,extender$)
    IF EXIST(lstfile$)
      OPEN "I",#1,lstfile$
      RECALL #1,lst$(),-1,anz_lst%
      ' ------------Sortieren--------------------------------------------
      DIM prior%(anz_lst%) !PrioritÑtsfaktor zum Sortieren
      DIM index%(anz_lst%) !Indexfeld, wird mit QSORT sortiert
      FOR i&=0 TO anz_lst%-1
        index%(i&)=i& !Indexfeld belegen
        lst$=lst$(i&)
        IF INSTR(lst$,"RSC_TREE") !BÑume zuerst
          prior%(i&)=FN rsc_tree_baum_nr(lst$)
        ELSE IF INSTR(lst$,"#") !dann die Objekte
          prior%(i&)=max_baume&+1 !mehr als alle BÑume
          ADD prior%(i&),FN obj_baum_nr(lst$)*max_obj_pro_baum&+FN obj_nr(lst$)
        ELSE IF INSTR(lst$,"free String") !dann die freien Strings
          prior%(i&)=(max_baume&+1)+max_baume&*max_obj_pro_baum&+max_obj_pro_baum&+1
          ADD prior%(i&),FN obj_nr(lst$)
        ELSE IF INSTR(lst$,"free Image") !zuletzt die freien Images
          prior%(i&)=(max_baume&+1)+max_baume&*max_obj_pro_baum&+max_obj_pro_baum&+max_obj_pro_baum&+1
          ADD prior%(i&),FN obj_nr(lst$)
        ENDIF
      NEXT i&
      QSORT prior%(),anz_lst%,index%()
      ' ----------------Ausgabe--------------------------------------------
      OPEN "O",#2,pfad$+"\"+dateiname$+".DFN"
      ' im ersten Datensatz Anzahl schreiben
      OUT #2,BYTE(anz_lst%),PEEK(V:anz_lst%+2) !Anzahl DatensÑtze (INTELformat)
      OUT #2,FN rsc_tree_baum_nr(lst$(0)),0,3,0
      @name_bestimmen_und_eintragen(lst$(0))
      ' und dann die restlichen DatensÑtze
      FOR i&=1 TO anz_lst%-1
        lst$=lst$(index%(i&))
        OUT #2,0,0 !nun keine Anzahl mehr
        IF INSTR(lst$,"RSC_TREE") !BÑume
          ' Baumindex,0,0=Baum,typcode=3=Formularbaum
          OUT #2,FN rsc_tree_baum_nr(lst$),0,3,0
        ELSE IF INSTR(lst$,"#") !Objekte
          ' Objektindex,Index des zugehîrigen Baumes,typcode=0=Objekt,1=Objekt
          OUT #2,FN obj_nr(lst$),FN obj_baum_nr(lst$),0,1
        ELSE IF INSTR(lst$,"free String") !freie Strings
          ' Objektindex,0,typcode=1=free String,1=Objekt
          OUT #2,FN obj_nr(lst$),0,1,1
        ELSE IF INSTR(lst$,"free Image") !freie Images
          ' Objektindex,0,typcode=2=free Image,1=Objekt
          OUT #2,FN obj_nr(lst$),0,2,1
        ENDIF
        @name_bestimmen_und_eintragen(lst$)
      NEXT i&
      CLOSE #1
      CLOSE #2
    ELSE
      ALERT 1,"Datei existiert nicht",1,"Neu|Abbruch",antw&
      IF antw&=2
        abbruch!=TRUE
      ENDIF
    ENDIF
  ENDIF
UNTIL abbruch!
EDIT
'
> PROCEDURE name_bestimmen_und_eintragen(lst$)
  LOCAL nam$,z&
  nam$=MID$(lst$,5) !nach LET
  nam$=LEFT$(nam$,INSTR(nam$,"&")-1) !vor &
  nam$=nam$+STRING$(8,CHR$(0)) !auffÅllen mit Nullen
  FOR z&=1 TO 8
    OUT #2,ASC(MID$(nam$,z&,1))
  NEXT z&
RETURN
DEFFN rsc_tree_baum_nr(lst$)=VAL(MID$(lst$,INSTR(lst$,"=")+1))
DEFFN obj_baum_nr(lst$)=VAL(MID$(lst$,INSTR(lst$,"#")+1))
DEFFN obj_nr(lst$)=VAL(MID$(lst$,INSTR(lst$,"=")+1))
' ----------------------------------------------------------------------------
DEFFN dgetdrv=GEMDOS(25)                    !aktuelles Laufwerk
DEFFN akt_laufw$=CHR$(ASC("A")+FN dgetdrv)  !=A,B...
> PROCEDURE split_pfadname(gesamtpfad$,VAR pfad$,dateiname$,extender$)
  ' zerlegt Gesamtpfad$, wie bei Fileselect erhalten in den Pfad- u. Dateinamen
  ' (sucht nach letztem \ und trennt dort den String)
  ' wenn keine Laufwerkskennung vorhanden ist, wird sie vorangestellt
  ' +Extender
  gesamtpfad$=FN pfad_vervollstendigen$(gesamtpfad$)
  pfad$=LEFT$(gesamtpfad$,RINSTR(gesamtpfad$,"\")-1) !ohne abschlie·enden \
  dateiname$=MID$(gesamtpfad$,RINSTR(gesamtpfad$,"\")+1)
  IF RIGHT$(dateiname$)="."
    dateiname$=LEFT$(dateiname$,LEN(dateiname$)-1)
  ENDIF
  IF INSTR(dateiname$,".")
    extender$=MID$(dateiname$,INSTR(dateiname$,".")+1)
    dateiname$=LEFT$(dateiname$,INSTR(dateiname$,".")-1)
  ELSE
    extender$=""
  ENDIF
RETURN
> FUNCTION pfad_vervollstendigen$(pfad$)
IF MID$(pfad$,2,1)=":"                    !Pfad mit Laufwerk
  voller_pfad$=pfad$
ELSE IF LEFT$(pfad$,1)="\"                !Wurzeldirektory
  voller_pfad$=FN akt_laufw$+":"+pfad$
ELSE                                      !aktuelles Direktory
  voller_pfad$=FN akt_laufw$+":"+DIR$(0)+"\"+pfad$
ENDIF
IF RIGHT$(voller_pfad$)="\"
  voller_pfad$=LEFT$(voller_pfad$,LEN(voller_pfad$)-1) !ohne abschlie·enden \
ENDIF
RETURN voller_pfad$
ENDFUNC
> FUNCTION fsel(meldung$,pfad_mit_suchmuster$,dateiname$,VAR gewehlter_pfad$)
$%F
' fÅhrt Dateiauswahl mit Fileselector durch,
' gibt TRUE zurÅck, wenn Datei ausgewÑhlt,
' FALSE wenn ABBRUCH angewÑhlt wurde
pfad_mit_suchmuster$=FN pfad_vervollstendigen$(pfad_mit_suchmuster$)
abbruch!=FALSE
ausgewehlt!=FALSE
WHILE NOT (abbruch! OR ausgewehlt!)
FILESELECT #meldung$,pfad_mit_suchmuster$,dateiname$,gewehlter_pfad$
IF RIGHT$(gewehlter_pfad$)="\"
  ALERT 1,"Kein Dateiname eingegeben!",1,"Neu|Abbruch",antw&
  IF antw&=2
    abbruch!=TRUE
  ENDIF
ELSE IF LEN(gewehlter_pfad$)
  ausgewehlt!=TRUE
  gewehlter_pfad$=FN pfad_vervollstendigen$(gewehlter_pfad$)
ELSE
  abbruch!=TRUE
ENDIF
WEND
RETURN ausgewehlt!
ENDFUNC
