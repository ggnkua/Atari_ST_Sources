----------------------------------------------------------------------------


                                 ### # # ###
                                  #  # # #
                                  #  ### ###
                                  #  # # #
                                  #  # # ###

                   #######   ####    ####### ##      #######
                   ##       ##  ##  ##       ##      ##
                   ####### ######## ##  #### ##      #######
                   ##      ##    ## ##    ## ##      ##
                   ####### ##    ##  ####### ####### #######


                             ---> EXTENSION <---


                                 Version 0.8


                          written by David Haylett

                                "BLACK EAGLE"

_____________________________________________________________________________
_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_
ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ

This is the unregistered version of the EAGLE extension. It currently only
contains the interpreter extension. See the end of this document for
instructions on how to register for the complete version.

First of all, here is a brief list of all of the commands and functions
available to you when this extension is installed into your STOS system, in
alphabetical order. [NB] commands with an 'x=' before are functions, that is,
'x=AVERAGE()' or 'print ELAPSED'. The words after some commands refer to the
parameters that must be passed onto it.

<--------------------------------------------------------------------------->

x= ACTIVE
   ALL          n
   APR          sad,sdd,n
x= AREA
x= AVERAGE     (arradr,n)
   BAKWARD      sadr,dadr
x= BOOLEAN     (n)
   BOOT THIS    adr
   BYTE TEXT
x= COMPARE     (adr1,adr2,len)
   CONNECT      n,adr
x= COUNTER     (n)
   DELAY        n
x= DISABLE     (adr,x1,y1,x2,y2)
   DUMPASCII    adr,len
x= EAGLE
x= EAGLE MFPS OFF
x= EAGLE MFPS ON (n)
x= ELASPED
x= ENLARGE     (adr,len)
x= ENSMALL     (adr,len)
x= EVEN        (n)
x= FCT         (n)
x= FILEN       (f$)
   GARBAGE
x= GIMME       (bnk/adr)
x= HOWMANYS    (adr,res)
x= HOWMANYI    (adr)
x= HRDPAL      (x)
x= INIT BLOCS  (sadr,n,dadr)
x= INIT BOOLEAN(adr,n)
   INIT MFP     num,typ,adr
   INIT TEXT    adr,spd
   INIT VERT    sadr,dadr,dx,dy,len
   INSLINE      n$
   INVERT       s,e
   INVERT ALL
   INVERT ONE   n
x= ISBANKIC    (adr)
x= ISBANKMU    (adr)
x= ISBANKSP    (adr)
   ITERFERANCE
   LIGHTS       n
   MAGRITE      n
   MESSAGE      text$,adrfont,x,y,adrdest
   MFP OFF      n
   MFP ON       n
x= MFP WHAT IS (n)
   MOUSEGOTO    x,y
   MTUBE
x= OCCUR       (s$,c)
x= ODD         (n)
   PALRES
   PALSAV
   PLACE        x,y,i
x= POSITION    (adr/bnk,x,y)
   PULL         adr,len,n,c
   PUSH         adr,len,n,c
   QUICK PAL    adr
x= RAINBOW
x= REDY        (n)
x= RELEASED
   RES_RESV
x= RGB COL     (adr,x,y)
x= RGB VALUE   (r,g,b)
x= RGN         (bwl)
   SCNRM
   SCRMOD       x
x= _SCRMOD
   SCROFF       x
x= _SCROFF
   SCRWDT       x
x= _SCRWDT
x= SEEK
x= SET BOOLEAN (n,v)
   SET COUNTER  n,v
   SET CRSTHK   n
   SET HRDPAL   x,y
   SET ICONADR  x
   SET MTUBE    sadr,sx,sy,dadr,dy,len
   SET SEEK     mode,dev
   SET TICKS    n
   SET TUBE     sadr,sy,dadr,dy,len
   SHATTER      sadr,sy1,sy2,dadr,dy,n
x= SHOVE BLOC  (n,x,y,dadr)
   SOUND        n
x= SQU         (x)
   SUBVERT      adr,len
x= SUICIDE
x= TICKS
   TMRCD        n
   TUBE
   USE PAK      adrpak,n,adrparams
   VBLTEST      -1
   VBLTEST      $rgb
   VERT
   VIEWCOLS
   VIEWSET
   VIEWSPRI     st,en
   VISION MIX   sadr,dadr,type,speed
   WATE         n
   WATESPACE
x= WHAT IS     (adr)
x= WHATKEY

[---------------------------------------------------------------------------]

     Here is the detailed list of commands, in the order shown above...

[---------------------------------------------------------------------------]


x=ACTIVE

This function will return a value, depending upon whether the current drive
is active or not (ie. whether it is still whirring). If the value returned is
33 or greater, then the drive is active, and if the value is 32 or less, then
the drive is silent.


ALL n

This command will fill the whole palette with a certain preset colour. 'n'
can range from 0 to 10, and the various values are:
0 = black, 1 = red, 2 = orange, 3 = yellow, 4 = green, 5 = cyan, 6 = blue,
7 = purple, 8 = white, 9 = brown, 10 = grey.


APR sad,dad,n

This command is exactly the same as the STOS "appear" command, except a
destination screen can be specified. With the "appear" command, one screen is
always appeared to the physical screen. This command allows you to appear to
any area of memory. 'sad' is the source address, and 'dad' is the destination
address. The 'n' is the type of appear, from 1 to 79.


x=AREA

This extension has one kilobyte (1024 bytes) of memory reserved for your own
use. AREA points to the start of this memory, which you can use for whatever
you like. You can treat this exactly like a normal memory bank, but it's real
use is to save you wasting a whole memory bank just for those small POKEing
operations. Examples of it's use are: POKE AREA+800,20 : ? PEEK(AREA+800)
The handy thing about the AREA is that it always remains unchanged, like when
you load a different program from STOS (not when compiled, unfortunately) so
you can easily pass information between .BAS files.


x=AVERAGE(arradd,n)

This function will allow you to find the average of a list of integers. It is
important to note that this command will not deal with real numbers
(decimals) either as input data or as a result. 'arradd' is the address of
element 0 of the array containing the numbers to find the average of. To find
out the address of an array NUMBERS, use ADD=VARPTR(NUMBERS(0)). The 'n' is
the number of elements in the array.


BAKWARD sadr,dadr

This command will simply take the screen at SADR and draw it backwards at
DADR (32000 bytes-worth). Note however that the resulting effect is not
exactly 'backward', because of the way the screen is stored in memory (never
mind.)


x=BOOLEAN(n)

Once you have used x=INIT BOOLEAN to set up a boolean array, you can use this
command to retrieve the contents of a particular element. 'n' is the number
of this element, and either a 0 or 1 is returned.


BOOT THIS adr

By using this command, you can force the computer to execute another program
once the reset button has been pressed. 'adr' points to the address of a
machine code program. Note however, that some programs (most programs more
like!) may not work completely (eg. you cannot use GEMDOS, AES, VDI.).


BYTE TEXT

This simple instruction will carry out the next command from the INIT TEXT
instruction.


x=COMPARE(adr1,adr2,len)

This function will compare two areas of memory, pointed at by 'adr1' and
'adr2' for 'len' number of bytes. The number returned is the number of
differences between the two memory areas. A result of 0 would mean both areas
are exactly the same. A result of 3 would mean that there are three
occurances when the two bytes don't match. This command is pretty fast, and
can compare 65535 bytes of data in a third of a second!


CONNECT n,adr

This command is used in conjunction with MFPs. See INIT MFP below. It will
take a copy of the 10 data longwords used by MFP routine number 'n' and place
them at address 'adr', (so 'adr' must point to just over 40 bytes of free
memory). This command is useful in that it keeps track of what is happening
with any one particular MFP. See the CONNECT table near the end of this
manual. For example, if we had an MFP scrolltext (type 6) running, we could
see where abouts we are in it by typing CONNECT 1,AREA : PRINT LEEK(AREA+8)
See CONNECT.BAS with the registration disk.


x=COUNTER(n)

This function will return the value of counter 'n' where 'n' ranges from 1 to
10. See SET COUNTER for more information.


DELAY n

This command is similar to WAIT except the delay time is shorter. It is good
if you want tiny delays in your program that need to be faster than WAIT 1.
You could interpret this as FOR DLY=1 to 50 : NEXT DLY. Just so you get an
idea, DELAY 25 is approximately equal to WAIT 1.


x=DISABLE(adr,x1,y1,x2,y2)

This command will allow you to 'shade out' or disable a rectangular block on
the screen. It simply fills the area at address 'adr' from x1,y1 to x2,y2
with black dots. The co-ordinates can be any values on the screen.


DUMPASCII adr,len

This command will take any area of memory, specified as 'adr' and list it out
as ASCII characters, up to a length of 'len'. This is useful if you have
BLOADed a document into memory and want to quickly read through it. You can
use the ESC key to break the listing and SPACE to pause.


x=EAGLE

This command will list out all of the commands in the EAGLE extension. It is
there for on-line support. The value returned does not mean anything. Use the
SPACE bar to pause and resume the listing, and ESC to quit.


x=EAGLE MFPS OFF

This function will disable the global EAGLE MFP handler, and return STOS to
it's usual state. Any MFP routines that were running prior to the execution
of this program (say from GEM) should work OK afterwards, but they are
switched OFF while my MFP routine is active. The value returned is equal to
the number of MFPs initialised with ? EAGLE MFPS ON(). See x=EAGLE MFPS ON
below for further info.


x=EAGLE MFPS ON(n)

This function will set up and invoke the global EAGLE MFP interrupt handler.
The value returned is simply the number of user slots initialized ('n'). See
INIT MFP for further info. Note: please be careful when using EAGLE MFPS ON
and EAGLE MFPS OFF. You should simply place an EAGLE MFPS ON command at the
start of your program, and an EAGLE MFPS OFF command at the end. My MFP
routine is 'invisible' and does not hamper any other operations (you don't
even know it's there). The value you give as 'n' is the number of user slots
that will be set up. Obviously, the more slots, the slower things get, so
start off with a value of '20' and modify that up or down later on in your
program as necessary, although there is very little difference in
performance.

One important thing to note, however, is that if you enter x=EAGLE MFPS ON
more than once without using x=EAGLE MFPS OFF, then you will not be able to
recover the original values (as long as you use this command proporly, this
does not apply). See MFPS.DOC for more information (on registration disk).


x=ELAPSED

This function will reset the timer and wait for a keypress. It will then
return the length of time (in 50ths of a second) it took you to press a key.
You can use this to do things like see how long a piece of music takes before
you get to a specific point.


x=ENLARGE(adr,len)

This function will capitalise bytes between 'adr' and 'adr+len'. It is like
UPPER$, but can be used on memory itself (instead of strings). Ignore the
value returned. It only works on characters between 'a' to 'z'.


x=ENSMALL(adr,len)

This function will set to lower case any bytes between 'adr' and 'adr+len'.
It is like LOWER$, but can be used on memory itself (instead of strings).
Ignore the value returned. It only works on characters between 'A' to 'Z'.


x=EVEN(n)

This function will return a '1' if 'n' is an even number, or a '0' if 'n' is
an odd number.


x=FCT(n)

This function will return the factorial of 'n'. The factorial of a number is
that number multiplied by each number below it down to 1. For example, the
factorial of 4 is 4x3x2x1 = 24, the factorial of 6 is 6x5x4x3x2x1 = 720.
Factorials are mathematically represented as 4!, 6! etc. Note, 'n' must be
between 1 and 17, as numbers greater than that are outside the legal range of
a longword.


x=FILEN(f$)

This command will return the length of the file in f$. For example,
PRINT FILEN("PROTECT.BAS") will return the length of that file, without you
having to open or close that file.


GARBAGE

This command will fill the physical screen with rubbish (clever eh?).


x=GIMME(adr/bnk)

This command will copy the picture data at 'adr' or in bank 'bnk' onto the
physical and background screens (a DEGAS picture), hide the mouse, stop the
cursor glow and all other FLASHes. The value returned is the address of the
data. By the way, GIMME is short for GIVE ME (as in, "oy gimme that!")


x=HOWMANYI(adr)

This function will return how many icons there are at address 'adr'. Use
START(2) to find the location of the icon bank (unless you used SETICONADR,
in which case substitute the 2 with the bank number).


x=HOWMANYS(add,r)

This function will return how many sprites there are in resolution 'r'. 'add'
is simply the start of the sprite bank, using START(1). Substitute 'r' with 0
to 2, denoting the resolution the sprites were designed for (usually low-res)


x=HRDPAL(c)

This function is identical to x=COLOUR(c). 'c' is the colour register from 0
to 15. Returned in 'x' is the current RGB value of that register. HRDPAL
allows you to read STE colours (eg. $8AE) whereas COLOUR would return values
between $000 and $777.


x=INIT BLOCS(sadr,n,dadr)

This function will set up a list of addresses for 16x16 blocs. Say you had a
screen filled with 16x16 squares (for parts of a map or room, for example).
Using INIT BLOCS and SHOVE BLOC will enable you to quickly and easily paste
any bloc to a screen location. 'sadr' points to the screen with the blocs on.
'n' is the number of blocs you wish to set up. 'dadr' points to some reserved
memory where the data will go (it needs 4 bytes per bloc).

The blocs must by 16x16, in steps of 16. INIT BLOCS will assume that, from
the starting location at 0 X co-ordinate, the blocs are spread across the
screen up to 320 (so there are 20 blocs per screen width).


x=INIT BOOLEAN(adr,n)

This command, linked with x=SET BOOLEAN and x=BOOLEAN, allows you to have an
array of boolean values (eg. TRUE/FALSE). Normally, you would have an integer
array, with either a 0 or 1 to specify whether something was true or not.
Using EAGLE BOOLEANs, you can do this, but only using one eighth of the
memory it would take to use the above method. 'adr' points to some reserved
memory to place this array at. 'n' is the number of elements/cells to set up.
'adr' has to be one eighth (rounded up) of 'n', so if you wanted 100 spaces,
'adr' would have to point to 13 free bytes. The value returned is simply the
number of bytes that were required (n/8 rounded up).


INIT MFP num,typ,adr

This is one of the most powerful (and probably most complicated) features of
the EAGLE extension. It makes use of the 68901 Multi-Function Processor. In
English, it allows you to set up small pre-defined routines which will run in
the background, regardless of what is happening in the foreground. One
example of a currently-used MFP is the cursor glow (no matter what you are
doing, it still continues to glow).

The EAGLE extension allows you to have up to 100 MFPs running at the same
time (although you will rarely use over three or four of them - unless you
are using them for a demo or something). 'num' identifies which MFP you are
going to use. 'typ' is a number which refers to what TYPE of MFP it will be
(see later). Finally, 'adr' points to a list of 10 longwords which the MFP
will use as data. The user could have entered the parameters along with the
INIT MFP command, but I was sure that one day I would create a new MFP that
would use more parameters than available. This list of 10 longwords can
simply be in the form of an array, or LOKEd into a memory area. This list
holds some numbers which you enter to modify the MFP.

WARNING: Be extremely careful when using MFPs. If you have too much happening
in one go, the MFP handler will come "full circle" and completely lock up the
whole system. Always save before experimenting, and DON'T MESS ABOUT! (told)

The first type of MFP (type 1) is the "GLOW COLOUR REGISTER". It allows you
to continually change the value of one colour register, just like the cursor.
The first value pointed to by 'adr' is the number of the colour register
(from 0 to 15). The second value is the address of where the colour data is
kept (in the form of continuous words). The third value is the speed at which
the register will change colour (1=every 50th of a sec). The fourth value is
the total number of colours in the list (or you can terminate the list with a
-1 and set this to 99999). Let's have an example:

Say we wanted the background to glow a nice dark blue. We can pass these
parameters into an array:

5 erase 5 : reserve as work 5,512
10 dim D(10)
20 D(1)=0 : rem '0'=the background register
30 D(2)=start(5) : rem Bank 5 will hold the colour data (set up on line 5)
40 D(3)=5 : rem Speed of glow (the smaller the faster) in 50ths of a sec
50 D(4)=999 : rem We will put a -1 at the end of the data instead of counting
                  how many values there are!
60 restore 80 : S=start(5)
70 repeat : read RGB : doke S,RGB : S=S+2 : until deek(S-2)=-1
80 data 0,1,2,3,4,3,2,1,-1
90 x=eagle mfps on(20) : init mfp 1,1,varptr(d(1)) : mfp on 1
100 waitkey : mfp off 1 : x=eagle mfps off

Remember, VARPTR(D(1)) points to the address of the first array element.

The second type of MFP is quite a simple one. It requires no parameters, so
you can simply place a 0 for the 'adr' value. It will play one of my
favourite MAD MAX tunes (it accompanied my very first decent demo screen) and
is very (sniff, sniff) special to me (sniff).

The third MFP is like an alarm clock. After a set delay, it will start
playing some music and flash the screen until you press either mouse
button. The first data value states for how long the delay will be (in
seconds). The second value holds the programme number. Programme 0 will flash
the screen, play the music, and wait for a mouse keypress before returning
it. Stating a programme number of over 50 will simply call that address (so
you can place your own routine there, as long as it is terminated with an
'rts', and it takes less than 1/50th of a sec, and it doesn't corrupt any
registers, and, and,). IMPORTANT: This MFP is SELF-ERASING, in that once the
alarm has been stopped by a mousekey press, EAGLE will automatically MFP OFF
that particular MFP routine so you don't have to do it yourself. Clever eh?

The fourth MFP is a simple executer for your own programs. Simply place the
address of your executable program as the first data value. The program must
end with an RTS or it will not work proporly. It also cannot take more than
50Hz to complete one cycle, and it must not have any external delays (such as
waiting for a keypress etc.) It should also save all used registers and
restore tham before the end.

The fifth MFP is an automated version of the INIT TEXT and BYTE TEXT
commands. The first longword is the delay in 50ths of a second. The second
longword is the address of the start of the text. See INIT TEXT for more
information. Please note that it is a bad idea to execute this MFP from the
editor because it is difficult to type anything in afterwards!

The sixth MFP is identical to VERT and INIT VERT, in that it scrolls some
ASCII text upwards along the screen. The first longword value is the source
address of the scrolltext, in simple ASCII format. This can be stored in a
bank, or string, or whatever, and must be ended with a CHR$(0). The second
parameter is the destination address, usually PHYSIC. The third parameter is
the X co-ordinate of the scrolltext, in multiples of 16. The fourth parameter
is the Y co-ordinate of the top of the scrolltext. Finally, the fifth
parameter is the height of the scrolltext, divided by 8 (eg. 23). See also
INIT VERT for more information.

The seventh MFP is identical to TUBE and SET TUBE, in that it wraps an image
around a barrel shape and rotates it round. The first longword value is the
address of the image (usually in a screen), and the next one is the
destination address (usually PHYSIC). The third parameter is the 'y' co-
ordinate on the destination screen to put the barrel, the fourth parameter is
the number of times the barrel rolls before it starts at the top of the
source screen again. The last parameter is the delay in 50ths of a second.
See also SET TUBE for more information.

The eighth MFP is identical to MTUBE and SET MTUBE. The first longword points
to the source screen to 'barrel', and the second longword points to the
screen to put the barrel on. The third value is the y co-ordinate on the
destination screen to put the top of the barrels at, the fourth value is the
number of scanlines to move before restarting, and the fifth value is the
delay, in 50ths of a second. See SET MTUBE for more information.

The ninth MFP is called TRACE, and will gradually move the mouse from it's
current position on the screen to a destination X,Y. The first two longwords
are simply the X and Y co-ordinates on the screen to move the mouse to. Once
the mouse reaches this point, the MFP will self-terminate (like MFP routines
3 and 19). Unfortunately, for reasons beyond my control, you cannot have the
X co-ordinate as the very right-hand or bottom of the screen (eg. 319,199).

The tenth MFP is an on-line clock. The first two longwords define the co-
ordinates of the text. It refreshes every two seconds, and is written in the
current STOS pen and paper colours (plus any INVERSE, UNDERLINE, and SHADE).

The eleventh MFP is an on-line date readout. The first two longwords define
the co-ordinates, and the third longword is the update frequency. This is how
many 50ths of a second will elapse before it is refreshed again. This figure
should ideally be about 100. As above, it is written using the current pen,
paper, and text style attributes.

The thirteenth MFP wraps the mouse around a border. Normally, if you move the
mouse to the extreme side of the screen, it just stays there. Now, you can
make the mouse jump off and appear at the opposite side of the screen. There
are four longwords in all, defining the co-ordinates of the left-hand, right-
hand, top and bottom edges of the window. Note however that if the co-
ordinates are within a couple of pixels of the edge of the screen, the
pointer will not wrap (so in low-res, they should be 3,316,3,196). I don't
know why this is (maybe because it's the THIRTEENTH MFP!) Cue TWILIGHT ZONE
theme tune: "doo doo doo doo doo doo doo doo".....

The fourteenth MFP is like the SUBVERT command. The first value is how many
bytes to NOT every 50th of a second. The second value is the start address.
The third value is the number of times to NOT (so, if the third value is 50
and the first value is 10, then 500 bytes will be NOTted before resetting).

The seventeenth MFP allows you to animate the mouse pointer just like a
normal STOS sprite. It basically flicks between a list of images in the
sprite bank, so load in a bank of pictures first. Parameter number one is the
number of the first image. If this is set to 1, then it will be the normal
mouse pointer. If it is 2, then it will be the hand, and 3, the clock. To
point to a sprite, enter the number of the sprite and add three. The second
parameter is the total number of images before wrapping to the beginning. The
final longword is the delay in 50ths of a second. So, to flick between the
first image up to the fifth image at a speed of one image per second, the
parameters would be 4,5,50

The eighteenth MFP is an automated version of SCREENCOPY, in that it copies a
block of screen from one place to another. The first longword is the source
address, and the second one is the destination address. The third and fourth
values are the X and Y co-ordinates of the top-left hand corner of the source
block to copy. The fifth and sixth values are the WIDTH and HEIGHT of the
block (NOT the co-ordinates of the bottom-right corner!). The seventh and
eighth values are the destination X and Y co-ordinates, and finally the ninth
value is the delay in 50ths of a second (eg. how often to do it). Warning:
having a block too large will lock the system up completely! ALWAYS SAVE
BEFORE EXPERIMENTING! (told)

The nineteenth MFP is an automated VISION MIX. You can mix two screens
together in the background, using the same patterns as VISION MIX. The
first and second longwords are the addresses of the source and destination
screens to mix. The third one is the type of mix, and the fourth one is the
number of steps to do every 50th of a second. This value should be about 10.
IMPORTANT: like MFP type 3, this MFP is SELF-ERASING, in that once the
routine has finished appearing the screen on, it will perform an MFP OFF on
itself, so you don't have to do it yourself. I still say it's clever.

There is also an MFP number 99. This is mainly for test purposes. What it
does is simply display a horizontal line of colour (a palette split) at
wherever the television scanner is on the screen at that time. The main
purpose of this is to see how much processor time you have left. The lower
down the line is on the screen, the less time you have left. Once the line
just about disappears off the bottom border, any further MFP routines are
likely to lock the system up! Note that it is important to place MFP 99 as
the VERY LAST MFP in the queue - because MFPs are executed in the order of
their number, MFP 99 will only display the time it takes to execute the MFPs
BEFORE that, so any MFPs after type 99 cannot be tested. Given this, you CAN
see how much time any one MFP takes, simply by putting a SCANLINE TESTER
immediately BEFORE and AFTER that particular MFP, and noting the distance
between the two.

If you specify the MFP type as zero, then you will be initializing an MFP
MAK. See "PAKs and MAKs" later on.

Also note that it is a good idea to use the AREA command to pass your
parameters to the MFPs. For example: LOKE AREA,1000 : LOKE AREA+4,10. See
AREA above. Do not use INIT MFP if that particular MFP is already active. For
example, if you had MFP number 3 running (from MFP ON 3) and then typed INIT
MFP 3,2,X the EAGLE will tell you to either switch it off, or use a different
MFP number.

If you need more information about the MFP routines, there is a seperate
tutorial supplied with the registered package. See REGISTERING further on.


INIT TEXT adr,spd

This command, along with BYTE TEXT, can be used to create a simple text
display facility. 'adr' points to the start of an address which holds this
text data, and 'spd' controls the speed (10=fast, 400=slow). The data
referred to is simply a list of ASCII characters. So, you can BLOAD a
document into memory (or set it up in a string), initialize the text with
this command, then use BYTE TEXT to output each individual character. There
are, however, a number of additions. If you place the ASCII character 96 in
your text (the ` to the left of backspace), then this signifies a control
code. The character immediately following this 96 refers to what special
function needs doing. These functions may also need additional parameters.
These functions are:

A - change pen colour (next byte = colour)
B - change paper colour (next byte = colour)
C - carriage return
D - relocate cursor (next byte = x co-ord, following byte = y co-ord)
E - clear screen
F - enable inversed text
G - enable shaded text
H - enable underlined text
I - shift all text above cursor up one line
0 - end of text - begin at start again

So, for example, if you wanted to alter the cursor position halfway through
your text, then it would look like this:

I WILL NOW ALTER THE CURSOR POSITION... 'D[5][17] ... Clever eh?

The values in [ ] refer to ASCII characters (eg. chr$(5), chr$(17) )

As a simpler example, you can use INIT TEXT on strings - using VARPTR to
address the start of the string.

m$="ALTER CURSOR POS 'D"+chr$(5)+chr$(17)+" etc'+chr$(0)
INIT TEXT varptr(m$),10
repeat : BYTE TEXT : until mousekey

Note that for functions like A,B, and D (change color and locate), you
specify the colour or co-ordinates as a character, not as text. For example,
to change paper colour to 15, you type "`B"+chr$(15) NOT "`B15".


INIT VERT sadr,dadr,dx,dy,len

This command, used in conjunction with VERT, will allow you to create a
vertically-scrolling text with ease. This command is required first to
initialize the data. 'sadr' is the address of the text to scroll. It can
point to anything, say an ASCII bank, or a string. So:

MESSAGE$="THIS IS A SCROLLTEXT!  "+chr$(0) : sadr=varptr(MESSAGE$)

Remember, VARPTR is used to find the ADDRESS of a variable in memory. 'dadr'
points to the destination address, usually a screen. 'dx' is the x co-
ordinate to put the scrolltext. It can only be in steps of 16 (as usual), but
see the note below. 'dy' is the y co-ordinate to put the top of the
scrolltext. It can be of any value from 0 to 200. Finally, 'len' is how long
the scrolltext is downwards. A length of '1' will result in an '8' pixel-down
scrolltext. So, a full-screen scroller is 24 long. Should the scroller go off
the bottom of the screen, it will start to scroll garbage.

eg. INIT VERT varptr(A$),physic,128,0,24

Note: this scroller is over only one bitplane. This means that it will be in
colour 1, and will not affect any graphics 'below' it of even colour value
(ie if you had a block of colour 10 and 12, it would be unaffected). The
scroller also moves up in steps of 2. One feature of the 'dx' parameter is
that if you add the numbers 4, 8, or 12 to the x co-ordinate, you can shift
the colours to registers 2, 4, and 8 respectively. This is all demonstrated
in the example files (IF you register).

The format of the scrolltext: The text to be scrolled can be of any ASCII
value between 32 and 90 (capital A-Z, and most punctuation). Any value above
90 will result in garbage. Any result below 32 is treated as an ASCII
carriage return, and will display a SPACE instead (for word-processed
scrolltexts). Use a CHR$(0) to start the scroller all over again (or 'wrap'
as it is commonly called).


INSLINE char

This command will insert a single character into a line, shifting the
characters afterwards to the right by one space. The 'char' is a standard
ASCII number, so placing a 65 will give a capital A.


INVERT s,e

This command will take two parameters which refer to the start and end colour
registers (inclusive) to invert - that is, change white to black, red to
cyan, green to purple, etc. The equation to invert is simply
$777-hex(colour).


INVERT ALL

This command is similar to INVERT, except all colour registers will be
inverted (from 0 to 15)


INVERT ONE n

This command is similar to INVERT, except only one specified colour register
is inverted.


x=ISBANKIC(adr)

This function will return whether the bank pointed to in 'adr' is a standard
STOS icon bank or not. 'adr' is to be set to START(2). A 1 is returned if it
is an icon bank, and a 0 is returned if not.


x=ISBANKMU(adr)

This function will return whether the bank pointed to in 'adr' is a standard
STOS music bank or not. 'adr' is to be set to START(3). A 1 is returned if it
is a music bank, and a 0 is returned if not.


x=ISBANKSP(adr)

This function will return whether the bank pointed to in 'adr' is a standard
STOS sprite bank or not. 'adr' is to be set to START(1). A 1 is returned if
it is a sprite bank, and a 0 is returned if not.


ITERFERANCE

This command will simply fill the background with various colours for a short
duration. Handy for a quick error warning or whatever.


LIGHTS n

This command will allow you to alter the state of the disk drive lights. 'n'
is any value between 0 and 255. Various values will set various combinations
of drive A, drive B, and probably modem etc. For example, '1' switches on the
internal drive light, and '55' switches it off.


MAGRITE n

This simple command allows you to access the EAGLE extension's in-built
palettes. Specifying 'n' between 1 and 14 will set the current colour palette
to various colours. The command, by the way, is named after the French
artist, R‚n‚ Magrite (and for those of you who are reading this document
after messing about with the font, there are two 'e's with aigut accents over
them - which now probably look like little spacemen or something).


MESSAGE txt$,adrfont,x,y,adrdest

This command is similar to PRINT, except it uses a specially-made 16x16 font
in one bitplane. 'txt$' is a string of text, no more than 20 characters in
length. 'adrfont' is the address of the font data. With this command, you can
specify the bank number alone, instead of using START(). 'x' and 'y' are the
actual screen co-ordinates, but 'x' must be a multiple of 16. Finally,
'adrdest' is the address of the destination screen, like 'physic'. Similar to
VERT, if you specify the 'x' co-ordinate as a multiple of 16, and then add
either 0, 4, 8, or 12, then you can offset the plane to which the text is
placed, and therefore get it in a different colour (1, 2, 4, or 8). If you
write an identical message at the same location, but with a different offset,
you can access any colour in the palette - experiment.


MFP OFF n

This command will disable MFP number 'n'. 'n' can be between 1 and the
maximum number of MFPs that you specified with x=EAGLE MFPS ON(). If you
specify a '0' then all MFPs will be switched off. See INIT MFP.


MFP ON n

This command will activate MFP number 'n'. 'n' can be between 1 and the
maximum number of MFPs that you specified with x=EAGLE MFPS ON(). See INIT
MFP. The MFP will only work if you have executed ? EAGLE MFPS ON() prior
to this command.


x=MFP WHAT IS(n)

This function will print out what type MFP 'n' is. For example, after using
INIT MFP to set up a routine, and you later forget what it is, you simply
type PRINT MFP WHAT IS(n), where 'n' is the MFP number (ie. the first value
in the INIT MFP command). It will write to the screen a short string which
will identify what routine it is, and it will return (either on-screen, or in
the X= integer) that MFP number (ie. the second value in the INIT MFP
command).


MOUSEGOTO x,y

This command will reposition the mouse pointer anywhere on the screen you
specify, with the normal 'x' and 'y' co-ordinates. Note, though, that you
cannot put it at either of the very far edges of the screen. That means at
co-ordinate X=319 or Y=199 in low res, and so on (don't ask why, just don't!)


MTUBE

This command is used in conjunction with SET MTUBE. It will perform the next
rotation of the tubes.


x=OCCUR(s$,c)

This function will return how many occurences of ASCII character 'c' there
were in string 's$'. So, print OCCUR("HELLO",asc("L")) will return 2.


x=ODD(n)

This function will return a '1' if 'n' is an odd number, or a '0' if 'n' is
an even number.


PALRES

This single command will return the palette back to the state it was in when
PALSAV was called.


PALSAV

This single command will save the current palette. The palette can then be
changed to your heart's content, until PALRES is called, when it will then
restore the palette to the colours that existed when PALSAV was called.


PLACE x,y,i

This command will allow you to place a single sprite image permanently on the
screen. This command is identical to SPRITE n,x,y,i except it is not
'temporary'. PLACE 50,50,6 will put sprite image number 6 at 50,50. This
command simulates: SPRITE 1,50,50,6 : PUTSPRITE 1 : SPRITE OFF 1
Note also that, unlike PUTSPRITE, PLACE allows you to put a sprite ANYWHERE
on the screen, for example at 0 x co-ordinate, and also at any negative co-
ordinate.


x=POSITION(adr/bnk,x,y)

This function returns the exact address in memory of particular co-ordinates
on the screen. The first parameter is either the address, or a bank number.
The last two parameters are the co-ordinates. So, x=POSITION(physic,160,100)
will return 'physic'+16080. Note that the 'x' co-ordinate must be on a 16-
pixel boundary (surprise surprise).


PULL adr,len,n,c

This command, similar to PUSH, will shift an area of memory to the left. It
is handy for not only deleting a number of bytes, but 'pulling' the number of
bytes after it to fill in the gap. 'adr' points to the area of memory that
the block to be shifted will rest at. 'len' is the number of bytes to move
(the length of the block). 'n' is the number of bytes to shift the block to
the left by. 'c' is a value of either 1 or 0. If it is '1' then the duplicate
bytes at the end (the fringe) will remain, if it is '0' then the duplicate
bytes will be cleared. To help outline this command, examine below:

                     adr
BEFORE:       1   2   3   4   5   6   7   8   9
AFTER:        3   4   5   6   7   8   9   8   9

Above is the result of a 'PULL adr,7,2,1' command, where 'adr' points to the
3. It shifts the seven bytes following the 3 to the left by two places, and
leaves the fringe (the bits on the right) as it is. 'PULL adr,7,2,0' will
look like this:

                     adr
BEFORE:       1   2   3   4   5   6   7   8   9
AFTER:        3   4   5   6   7   8   9   0   0
                                         [fringe has been cleared]


PUSH adr,len,n,c

This command is almost identical to PULL, except it shoves bytes to the
right, instead of pulling them to the left. 'adr' points to the start of the
block to be pushed, 'len' is the number of bytes to be pushed, 'n' is the
distance (in bytes) that the block will pushed, and finally 'c' is the clear
keyword. If 'c' is zero, then the bytes that have been left along on the left
(the fringe) will be cleared. If 'c' is one, then the fringe will be left as
it is. See the diagram below:

             adr
BEFORE:       1   2   3   4   5   6   7   8   9
AFTER:        1   2   3   1   2   3   4   5   6

That was an example of 'PUSH adr,9,3,1'. 'PUSH adr,9,3,0' looks like this:

             adr
BEFORE:       1   2   3   4   5   6   7   8   9
AFTER:        0   0   0   1   2   3   4   5   6
  [fringe has been cleared]

Here is an example of 'PUSH adr,3,2,0' (where three bytes, at 'adr', have
been pushed to the right by two spaces, clearing the original ones):

                     adr
BEFORE:       1   2   3   4   5   6   7   8   9
AFTER:        1   2   0   0   3   4   5   8   9


QUICK PAL adr

This command will set the palette with sixteen words of data found at address
'adr'. So, if you had some palette data halfway through a memory bank, you
could use QUICK PAL start(5)+8870 to set the palette from there.


x=RAINBOW

Contained within the EAGLE extenion is a small list of colours ready for you
to use. The value returned from this function will point to the start of this
list. The list is in words, and terminates with a -1 (or 65535).


x=REDY(n)

This function will return whether a port is ready for data or not. It will
return either a 0 for not ready, or a 1 for ready. 'n' refers to the port
number: 0 = printer (parallel port), 1 = serial port (usually modem),
2 = console, 3 = MIDI, 4 = IKBD keyboard device.


x=RELEASED

This function will return a -1 if the mouse button (left, right, or both) has
been clicked and released, otherwise it returns 0. This differs from MOUSEKEY
in that it only returns true if the button has been pressed and let go. This
is handy for programs that require mouse clicks, but one click seems to skip
through several screens. A simple example of this is REPEAT : UNTIL RELEASED


RES_RESV

This command simply clears the reset vector (and the longword before that),
effectively removing any memory-resident viruses (hopefully).


x=RGB COL(adr,x,y)

This function will return the colour value of the register at location x,y on
screen 'adr'. This is the same as: x=COLOUR(POINT(x,y)). If you specify 'adr'
as '0' then the physical screen is used.


x=RGB VALUE(r,g,b)

This function will take three seperate colour values (each from 0 to 7) and
return one colour value. The formula for this is R*256+G*16+B. So, you can do
COLOUR 0,RGB VALUE(7,0,0). It's use is to take one red value, one green
value, and one blue value, and convert them into one single hexadecimal value
which you can use as a colour.


x=RGN(t)

This function is similar to the RND command in that it generates a random
number. This one, however, will generate either a byte-number (0 - 255), a
word-number (0 - 65535), or a longword-number (0 - 2.17 billion). Enter 't'
as 1 for a byte, 2 for a word, or 4 for a longword. I think that this method
of generation is different from that of STOS's rather predictable method.


SCNRM

This single command will return the screen to normal, cancelling out any
SCROFF, SCRMOD or SCRWDT changes.


{Be careful when using the following SCROFF, SCRMOD and SCRWDT commands,
 because they 'may' damage your telly. I shouldn't think they will, but
 just be careful. You have been warned, so don't blame me if anything
 nasty happens!}


SCRMOD x

This command will allow you to set the screen mode.


x=_SCRMOD

This function, linked to the one above, will return the current screen mode.
However, the value returned may well be different from the one that you
entered. This may be because the screen mode alters itself to fit the correct
value. Or something.


SCROFF x

This command will allow you to set the screen offset.


x=_SCROFF

This function, linked to the one above, will return the current screen
offset.


SCRWDT x

This command will allow you to set the screen width.


x=_SCRWDT

This function, linked to the one above, will return the current screen width.


x=SEEK

This function will return the current seek rate of the active drive. See
SET SEEK below. I think that this only works on TOS 1.4 and under.


x=SET BOOLEAN(n,v)

Once you have used x=INIT BOOLEAN to initialise an array of boolean bits, you
can use this command to set a particular bit to either 0 or 1. 'n' is the
number of the element, and 'v' is either 0 or 1. Ignore the value returned.


SET COUNTER n,v

Some programmers may find it useful to have more than one timer at the same
time. Except from the native TIMER command, the MISTY extension allowed
another RTIM to be accessed. The SET COUNTER command allows you to define and
access up to ten seperate timers. 'n' is the timer number, from 1 to 10, and
'v' is the value to set it at. As normal, timers increment at a rate of once
every 50th of a second. Note that if you change the TIMER value, all COUNTER
values will be upset. The same goes for any programs or whatever, which seem
to corrupt the TIMER. See also 'x=COUNTER' earlier on.


SET CRSTHK n

This command will set the cursor thickness. If 'n' is set to 0, the cursor
will be single height, and a 1 will set the cursor to double height. This is
exactly like pressing the INSERT key during the STOS editor, except the
insert/overwrite mode is not affected.


SET HRDPAL c,$rgb

This command is identical to COLOUR c,$rgb except that it is faster. 'c' is
the colour register from 0 to 15 and RGB is the value to change it to.


SET ICON ADR adr

This command allows you to relocate an icon bank. Normally, STOS icons can
only be loaded and used from bank 2, the icon bank. But what if your bank 2
is already used for something else? Simply specify the start of any bank from
1 to 15 in 'adr' and you can use STOS icons normally from any bank. eg.
"SETICONADR start(5)". Note that they have to be LOADed in as normal, and
cannot be BLOADed into memory.


SET MTUBE sadr,sy,dadr,dy,len

This command is linked with MTUBE. It is similar to SET TUBE (below) in that
it allows you to wrap some graphics around a barrel shape and then rotate it.
The difference here, however, is that there are five tubes across the screen,
which are 100 pixels high, and 32 pixels wide. MTUBE also wraps one bitplane
around the tube, but the tubes themselves consist of two bitplanes. One
bitplane is the 'underneath' and the other is the 'overhead'. See SET TUBE
for a more detailed description of this command.


SET SEEK mode,dev

This instruction allows you to alter the seek rate of device 'dev' (which is
either 0 or 1, for drives A and B). 'mode' ranges from 0 to 3 (see below). I
have found that, simply by setting the seek rate to 0 or 1, you can add a
really professional side to your programs when they access the disk. I think
that this instruction only works on TOS 1.4 and upwards, but I could be
wrong.

Steprates: a value of 0 gives 6ms
                      1       12ms
                      2       2ms
                      3       3ms


SET TICKS n

This instruction will set the raw 200hz timer with the value specified in
'n'. See TICKS for more information.


SET TUBE sadr,sy,dadr,dy,len

This command, linked with TUBE, allows the user to wrap a portion of screen
around a barrel shape. This can then be rotated to give the impression that
the screen is wrapped like a cylinder. 'sadr' is the address of the screen
with the normal data (say a DEGAS screen), 'sy' is the number of lines down
the source screen to start (usually 0). 'dadr' is the address of the
destination screen, usually PHYSIC or LOGIC. 'dy' is the number of lines down
the destination screen the barrel will be placed at. Finally, 'len' is the
number of lines the tube will rotate before it starts again at the top. One
barrel is 68 pixels deep and a full screen wide. Also note that only the
first bit-plane is wrapped (meaning only colour 0 and 1 pixels)


SHATTER sadr,sy1,sy2,dadr,dy,n

This command will vertically seperate the screen. 'sadr' is the address of
the screen (eg. physic). 'sy1' and 'sy2' are the top and bottom co-ordinates
of the lines to shatter. 'dadr' is the address of the screen to put the
'fragments' on, and 'dy' is the y co-ordinate of the top line. 'n' is the
shatter value (how many lines are seperated) and can range from 2 onwards.
Note however that if you shatter too much, any graphics going over the bottom
edge of the screen will OVERWRITE any data proceeding after the destination
address.


x=SHOVE BLOC(n,x,y,dadr)

This command is used with INIT BLOC. Once some blocs are set up, SHOVE BLOC
is used to paste them to the screen. 'n' is the number of the bloc you wish
to paste. 'x' and 'y' are real screen co-ordinates (naturally, 'x' needs to
be on a 16-pixel boundary), and 'dadr' is the address of the screen you wish
the bloc to go to.


SOUND n

This extension contains an extra 30 sound effects for you to use. Just
specify 'n' as a value from 1 to 30. The sound effects range from laser guns
to explosions, clicks, the famous GEM beep, and even an ambulance! Now PLEASE
stop using bell, shoot, and boom, PLEASE!


x=SQU(n)

This function will return the square of the number 'n' in the parentheses.
So, "print SQU(7)" will return 49. The highest value that this function can
accept is 32767.


SUBVERT adr,len

This command will NOT 'len' bytes, starting from 'adr'. What NOT does is to
take each byte in turn, convert the number into binary, and swaps the 0's for
1's and the 1's for 0's. So, say you started with a decimal value of 20, or
00010100 in binary. After being NOTted, it will become 11101011, or 235. It
is handy for inverting the colours of something, and typing -
SUBVERT physic,32000 will give interesting results. (Note: the original value
and the NOTted value always add up to 255.) If you have tried typing
? NOT(20) into STOS, found that it gives -21 and not 235, and called me
something horrible because I was wrong, it is because that STOS has
recognised the most significant bit and set the value to negative (2's
compliment and all that, you know).


x=SUICIDE

This command will clear the physical and background screens, set the whole
palette to black, hide the mouse, reset all zones. Ignore the value returned.


x=TICKS

This function will return the contents of the raw 200hz timer located at
address $4bc. This timer is far faster than the frame counter at 50hz, and
can reach tens of thousands in a split second! (yes, that's right, it IS
useless).


TMRCD n

This command will allow you to either turn on or off timer C/D. If you have
used a raster program recently, or have run a program which displays moving
colours, you may have noticed there is an invisible line which casually runs
down the screen, shifting colours up as it does so. This is the visual effect
of timer C/D, so switching it off will remove the line. Simply specify a 1 or
0 when using the command to switch the timer on or off. Always return timer
C/D to ON once the program has finished. NOTE: When timer C/D is off,
CONTROL-C will not work (amongst other things)!


TUBE

This command is used in conjunction with SET TUBE. It will perform one
rotation of the barrel.


USE PAK adrpak,n,adrparams

This command makes use of any command PAKs that you may have loaded into
memory. See later on for details of what PAKs are. The first parameter points
to the address of the start of the PAK in memory. The second parameter is the
number of the command you wish to use (the documentation which comes with
each PAK should detail which numbers refer to which commands). The final
parameter points to free area of memory containing any parameters which you
may wish to pass to the new commands. These are as consecutive longwords. The
documentation for each PAK should state what each parameter will be, and also
any parameters which are returned (yes, you can have more that one!) See the
seperate PAK tutorial when (if) you register.


VBLTEST -1

This command will, in a fraction of a second, inverse the background colour.
This is useful when writing programs (usually demos) where the programmer
needs to know how much 'space' he has left before the next vertical blank
occurs. Placing a VBLTEST -1 just before your WAIT VBL will show you how much
processor time there is left. This command will replace the more familiar
"DOKE $FF8240,$777 : DOKE $FF8240,0"


VBLTEST $rgb

This is identical to the VBLTEST command above, except you can specify what
colour the line is to turn into. Simply specify a hexadecimal value. The
background colour is restored as normal after the switch. Note that this is
marginally faster than VBLTEST -1 because it does not need to calculate the
inverse of the background colour.


VERT

This command is used in conjunction with INIT VERT. It will do the next cycle
of the scrolltext. This scroller is vertical, and is VERY fast! The font is
preset (and quite nice).


VIEWCOLS

This single command will list out each of the current 16 colours. This is
handy if you want to pick a colour for, say, some text, and can't remember
which register blue was. Each colour will list down the screen, along with a
hexadecimal value denoting the actual colour. Note that the hexadecimal
colours that will be listed may give values of greater than $777 (eg. $9EA)
if the palette contains such a value.


VIEWSET

This command will list across the screen all ASCII characters between 32 and
255 in the current font.


VIEWSPRI st,en

This command will browse through a sprite bank, between sprite numbers 'st'
and 'en' - handy if you can't remember which sprite was which. The current
sprite number will be displayed at the top of the screen, and press any key
during each sprite to go onto the next one.


VISION MIX sadr,dadr,type,speed

This command is like APPEAR, but gives you more different types of appear.
SADR and DADR are the source and destination addresses. TYPE can vary from 1
to 15, and SPEED is the delay of the appear - 5 is very fast, 100 is slow.


WATE n

This command will wait until HARDKEY number 'n' has been pressed. For
example, WATE 57 will wait for a space key.


WATESPACE

This command will wait until the space bar has been pressed.


x=WHAT IS (adr)

This function will try and identify what is pointed to by 'adr'. So, if you
had a character set and an icon bank loaded in, and forgot what was where,
just type ? WHAT IS(5) or whatever, and it will tell you. It identifies
most normal STOS banks, plus the MISSING LINK banks. The value returned is
meaningless. Also note that this command will recognise bank numbers, so you
do not have to use START() for values between 1 and 15.


x=WHATKEY

This function will wait for a keypress, then return the HARDKEY code of that
key. KBSHIFT keys, such as control, alternate, and shift, are not recognised.

----------------------------------------------------------------------------

EAGLE PAKs AND MAKs
~~~~~~~~~~~~~~~~~~~

The EAGLE extension allows for more commands and MFP routines to be added on
later. These add-ons exist as seperate files which can be loaded into a
memory bank, the AREA (if the PAK is small enough), or a string, and can then
be used similar to normal commands. The advantage of these is that the EAGLE
extension itself doesn't have to be upgraded every time an interesting new
command is invented, and also you only need to include the extra commands
that you need (instead of the whole lot as with normal extensions).

Files with a .PAK extension are command add-ons and can contain any number of
new commands. Files with a .MAK extension are MFP add-ons, but each MAK file
can only contain one new MFP routine.

Using PAK routines
------------------

To use a PAK, follow this standard procedure:

* load the PAK file in as a binary file:
  RESERVE AS DATA 5,FILEN("MORECOMS.PAK") : BLOAD "MORECOMS.PAK",5

* naturally, some PAK commands will require additional parameters. These need
  to be placed in some memory as longwords (either in memory banks, AREA,
  strings, arrays, and so on.)

* The USE PAK command is there to fire off a command. See the USE PAK
  definition in the command list way above somewhere.


I have also described how you can create your own command PAK routines. They
have to be written in machine code (naturally...), but they are quite simple
to create and use. See the seperate tutorial that you get when (if?) you
register.


Using MAK routines
------------------

To use a MAK, follow this standard procedure:

* load the MAK file in as a binary file:
  RESERVE AS DATA 5,FILEN("EXAMPLE.MAK") : BLOAD "EXAMPLE.MAK",5

* if you haven't already done so, fire off the global MFP handler:
  ZZZ=EAGLE MFPS ON(20)

* all MAKs need to have the address of the start of the MAK as the first
  longword parameter which is passed to the INIT MFP command:
  X=AREA : LOKE X,START(5)

* initialize the MFP as type 0:
  INIT MFP 1,0,X

* and off you go:
  MFP ON 1

MAK routines may also require parameters, as with most other normal MFP
routines. They can be passed as normal, starting with the SECOND parameter
slot (the FIRST is used to pass the address of the routine as described
above). eg. LOKE AREA,[adr] : LOKE AREA+4,[param1] : LOKE AREA+8,[param2]...

I have also described how you can create your own MAK MFP routines. They have
to be written in machine code (naturally...), but they are quite simple to
create and use. See the seperate tutorial that you get when (if?) you
register.

----------------------------------------------------------------------------

SUMMARISED INFORMATION
~~~~~~~~~~~~~~~~~~~~~~

MFP TABLE:

MFP0 =  CUSTOMISED MFP MAK
        I(1)=Address of MAK routine in memory
        I(2)...I(19)=Detailed in MAK documentation.
MFP1 =  GLOW COLOUR REGISTER
        I(1)=Register number to glow
        I(2)=Address of colour data
        I(3)=Speed of glow (50ths/sec)
        I(4)=Number of colours (or set to 99999 and terminate with -1)
MFP2 =  MUSIC
MFP3 =  ALARM
        I(1)=Delay before trigger (seconds)
        I(2)=Programme number or address
             PROG0=Blank and wait for input
             PROG1=Play music
             PROG>50=Execute code at that address once
MFP4 =  OTHER PROGRAM
        I(1)=Address of your program
MFP5 =  TEXT
        I(1)=Delay (50ths/sec)
        I(2)=Address of text
MFP6 =  VERTICAL SCROLLER
        I(1)=Address of text
        I(2)=Destination address
        I(3)=X Co-ordinate (16-pixel boundary)
        I(4)=Y Co-ordinate
        I(5)=Height (divided by 8)
MFP7 =  TUBE
        I(1)=Source address
        I(2)=Destination address
        I(3)=Destination 'y' Co-ordinate
        I(4)=Maximum number of scanlines before restarting
        I(5)=Delay (50ths/sec)
MFP8 =  MTUBE
        I(1)=Source address
        I(2)=Destination address
        I(3)=Destination y co-ordinate
        I(4)=Maximum depth before restart
        I(5)=Delay (50ths/sec)
MFP9 =  TRACE
        I(1)=X destination co-ord
        I(2)=Y destination co-ord
MFP10 = CLOCK
        I(1)=X co-ordinate
        I(2)=Y co-ordinate
MFP11 = DATE
        I(1)=X co-ordinate
        I(2)=Y co-ordinate
        I(3)=frequency of update (50ths/sec)
MFP13 = WRAP MOUSE
        I(1)=co-ordinates of left-hand edge
        I(2)=co-ordinates of right-hand edge
        I(3)=co-ordinates of top edge
        I(4)=co-ordinates of bottom edge
MFP14 = SUBVERSION
        I(1)=Number of bytes to NOT per call
        I(2)=Start address
        I(3)=Number of calls before resetting
MFP17 = ANIMATE MOUSE
        I(1)=Start image
        I(2)=Total number of images
        I(3)=Delay (50ths/sec)
MFP18 = SCREEN COPY
        I(1)=Source address
        I(2)=Destination address
        I(3)=Source x co-ordinate
        I(4)=Source y co-ordinate
        I(5)=Width of block
        I(6)=Height of block
        I(7)=Destination x co-ordinate
        I(8)=Destination y co-ordinate
        I(9)=Delay (50ths/sec)
MFP19 = VISION MIX
        I(1)=Source address
        I(2)=Destination address
        I(3)=Appear type
        I(4)=Number of cycles per call


CONNECT TABLE:

MFP type      Offset from 'adr'      Data

    0                  0             Address of MAK routine
                       4-76          See MAK documentation
    1                  0             Current delay counter
                       4             Current colour address
                       8             Colour counter
    2                  -
    3                  0             Current delay counter
    4                  -
    5                  0             Current delay counter
                       4             Current text address
    6                  0             Address of top of scrolltext
                       4             Current address of location in font
                       8             Position in scroll message
                       12            Number of scrolls before next character
    7                  0             Current delay counter
                       4             Current scanline
    8                  0             Current delay counter
                       4             Current scanline
    9                  -
    10                 -
    11                 0             Delay before next update
    13                 -
    14                 0             Current NOT address
                       4             Counter before reset
    17                 0             Current delay counter
                       4             Current image
    18                 0             Current delay counter
    19                 0             Current source address
                       4             Current destination address
                       12            Counter before end
----------------------------------------------------------------------------

GENERAL NOTES
-------------

i) For some reason or another, you may not use most EAGLE functions as part
   of another command. For example, you cannot say SETHRDPAL 0,HRDPAL(1). You
   must instead say X=HRDPAL(1) : SETHRDPAL 0,X. This applies to AREA and
   various others too.

ii) Quite a few of these commands require addresses - usually screen
    addresses. If you want to, say, SUBVERT a screen in memory bank 6, you
    need to put START(6) instead of just 6 - START() refers to the ADDRESS of
    the screen. See the STOS manual for more details.

iii) Unfortunately, you cannot enter any 'real' values as parameters. For
     example, PRINT SQU(2.75) will return a TYPE MISMATCH error. Say you had
     a real value in X#, you can still use the functions by saying X=X#, and
     then using X instead of X#. All numerical values must be integer
     expressions. Sorry.

iv) If your program has it's own MFP calls, or if you have an MFP routine
    that may interfere with the routines within this extension, here is a
    breakdown of how my routines are constructed. As 98% of you will be
    unaffected by this, you might as well skip it...

A list of longword addresses is pointed to by a longword at $456. The first
MFP call is used by STOS - the cursor glow (which you can actually redefine).
As soon as you enter x=EAGLE MFPS ON() it creates it's own MFP queue in a
reserved area of memory. It then copies this MFP over, and any others as
well, until it hits a '0'. Then, it will skip two slots (which you may use).
Finally, the remaining hundred-odd slots are used by the extension. Messing
about with these slots will SERIOUSLY affect the performance of the MFP
routines available from my extension. So, to add your own routines, simply
start at the address pointed to by the contents of $456 and keep searching
for a null. As I said, I very much doubt that you will need to know this, and
it is not necessary to understand it to use the INIT MFP/MFP ON/MFP OFF
commands.

If you use $4D2 in your routines (to play music for example), then you may
notice that the music will not play while EAGLE MFPS are ON. Solving this
problem is relatively simple. Instead of typing LOKE $4D2,[music], type:

x=LEEK($456) : x=x+8 : loke x,[music]  (x holds the address instead of $4D2)

See 4D2.DOC for more information (on the registration disk).

v) Yes, I know the messages you get while you are programming are very
   annoying (thanks to the Missing Link extension for that idea!) but I hope
   that it will be that extra incentive to register. By the way, there's a
   good joke at about message twenty, so keep going for a while 'till you
   find it! These messages do not exist with the registered version.

vi) The COMPILER extension does not make any error checks. For example, if
    you entered MAGRITE 999 from the editor, you would get an ILLEGAL
    FUNCTION CALL error. After compilation, the executable version will not
    check to see if any parameters are within range, and continue regardless.
    This should not matter, as I work on the basis that programmers actually
    test their program from STOS before compiling it and running it. The
    advantage though, is that there should be a fairly considerable speed
    increase.

vii) The EAGLE MFP queue for the interpreter and compiler versions of the
     same program are both TOTALLY DIFFERENT. That is to say, if you compile
     your program in STOS form (which sets up a queue and MFPs), you CANNOT
     access those MFPs from the interpreter (although you CAN switch them
     off with ? EAGLE MFPS OFF. This should not cause a problem, as long as
     you behave yourself.

viii) Although MFPs and the AREA remain constant and unchanged between
      loadings of two BAS files within STOS, unfortunately this is not so
      when it comes to compiled programs. If you were to have a compiled
      program with a RUN "WHATEVER.PRG" at the end, the whole of the
      program's memory will be cleared by STOS for the next program, which
      will over-write it (including your memory-banks with the MFP data in
      them). If you still have an MFP active when you attempt to run another
      program, it will almost certainly crash in an incredibly nasty way.
      Never mind.

----------------------------------------------------------------------------

VERSION 0.8 NOTE
----------------

Please note again that this is the unregistered version, and not everything
may work perfectly. You may also notice that every now and again, you will
get nasty messages appearing on your screen. The registered version of the
extension, of course, omits these. You may also look worried at the many
complicated commands, like the MFPs and the BYTE TEXT and VERT and so on. If
you register, you will get plenty of example files and a few tutorials to
show you just how it's done.


REGISTERING FOR THE FULL VERSION
--------------------------------

Yes, you only have Version 0.8 at the moment, and therefore less than half of
the actual extension. If you wish to register for the full version, please
send a cheque made payable to DAVID HAYLETT for the sum of TEN ENGLISH
POUNDS STERLING. There is no need for SAEs or disks or whatever. In return,
you will receive:

The complete INTERPRETER extension (updated)
The complete COMPILER extension
The rather attractive installer program (with raytraced piccie)
A few example files to show you how it's all done
Plenty of seperate tutorial files to cover the more complicated commands
A few odds and sods just to fill the disk up, including a nice article about
how to master STOS Compiler extensions (yes, I mean the DATA AREA!)

And I promise I will try and return your registrations as soon as possible
(unless I'm dead, in which case you may have to wait a few weeks)

IMPORTANT ("not MORE important stuff!"):  If you register for the complete
version of the EAGLE EXTENSION, the disk you receive will NOT be freeware and
you MUST NOT DISTRIBUTE IT (although you can make a back-up for personal
use). There IS such a thing as P.D. piracy you know! (read ST FORMAT 66)
Having said that, version 0.8 of the extension (ie. the UNREGISTERED .EXU and
.EXV files) can be thrown about wherever you want AS LONG AS THIS DOCUMENT
ACCOMPANIES IT IN AN UNCHANGED FORM. I don't want to have to lose my
temper...


DISCLAIMER...
-------------

The author of this extension (ie. me) cannot be held responsible for any
damage caused by the use or misuse of this extension. You use the commands in
this extension entirely at your own risk, and you should ensure that you are
careful when experimenting and that you SAVE any quantities of work before
executing them. So there. (Just in case something does go wrong and someone
decides to sue my ass into the ground)

      This document, and the four parts of the EAGLE extension, are all
           (c) COPYRIGHT 1995 DAVID HAYLETT  (whatever that means)


USELESS BIT...
--------------

There, another 105 commands for your STOS system. Some of them are pretty
useless, but I am sure that there are some here and there that may be just
what you wanted, like the, erm, oh what's it called?...

Thanks must go to some people:

EDDIE for adapting the source for the TUBE and MTUBE commands.
FRANK CHARLTON for the bit in ST FORMAT.
AULD BASTID for his article about headers (for the WHAT IS command).
THE STOSSER TEAM for shedding some light upon the dark world of STOS (?).
BUDGIE UK for the sound parameters.

Special thanks must go to the following (without these guy's help, you would
not be using the EAGLE extension):

STEPHEN HILL for his chapter about extensions in the GAMEMAKER'S MANUAL.
TONY GREENWOOD for his help, support, advice, and "play"-testing.
MARTIN CUBITT for his help with the compiler extension.
ASA BURROWS for his help with the compiler extension.
BLACK EAGLE for writing the EAGLE extension. Oh, that's me, isn't it? Yes,
well done Dave, go and have a lie down and a biscuit.

You may also notice that the extension comes in two seperate parts. This is
not my fault. Extensions normally allow 128 commands, but for some reason,
you can only have 64 in the compiler extension, thus the two seperate
extensions. Sorry, and all that.

Please could everyone use .EXU and .EXV as the filename extension for this
extension (?) as it would make everything so much simpler. I don't think that
'U' and 'V' are used yet, but if they are...well...erm, that's it then
really, isn't it, eh?

I apologize for the spelling of some of the commands, such as WATE, BAKWARD,
ITERFERANCE and REDY, but STOS will not allow for the propor spelling because
WAIT is already reserved, BACK is already reserved, INTERFERANCE is
interpreted as 'int ERFERANCE' and READY is interpreted as 'read Y', so
there. (By the way, this isn't my fault either so stop shouting).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Here is my address...
                                DAVID HAYLETT
                               6 BALDWIN ROAD
                                WEST KNIGHTON
                                  LEICESTER
                                   LE2 6HA
                                   ENGLAND

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And if you are registering, write 'EAGLE REG' or something on the envelope so
I can deal with it quickly (oh, and don't forget to fill in the EAGLEREG form
so I can find out more about YOU as well!) If you are sending a letter bomb
or poisonous spiders, please write "DAVID, DON'T OPEN IT" at the top. Thanks.


FINAL WORDS
-----------

Many may feel that STOS Basic is slowly dying out. This idea is supported by
the fact that Mandarin don't seem to give a toss about STOS any more, and the
way that some magazine writers (don't worry, not you Frank) enjoy writing
hate-articles about STOS (although that appears to be slowly changing).

All I can say is that the more programs and games there are that are written
with STOS, the more it should recover, and I hope that this extension
provides the incentive to you programmers out there to keep on writing
software with STOS Basic.

                        >> WE'RE NOT FINISHED YET! <<

(and take a look at H.E.R.O. to see what can really be done)

Well, now I've calmed down, I do hope you enjoy using the EAGLE Extension,
and that you find it useful in your STOS programming. I started it in March
of 1994 and have been working extremely hard on it since that time. If you
release a program or game which makes use of my extension to some extent,
maybe you could say 'hi' to BLACK EAGLE in the credits or something.

Shameless plugs: why don't you check out some of my other stuff, like the
VEXIRIK MEGADEMO, the MUCH STOS GIGAZINE, MONEYMANIA 1 and 2, and if you've
got SPEEDBALL 2 or ISHAR 2, you'll want to get my SAVED GAME EDITORS to get
those character stats up! See the main PD libraries for these, or take a look
at the DISKS.DOC file.

Yours,

             David Haylett
                      BLACK EAGLE


PS. right, now I'm off down the pub to get sloshed...
    (while I'm doing that, buy STOSSER and H.E.R.O., and support STOS!)


BLACK EAGLE's top 2 Silly quotations:

"the eyes that do not behold STOS are not truly open..."

"and the stranger did walk into the mist, giving little notice to the STOS
package lying on the floor, and the stranger did walk over a cliff..."

_____________________________________________________________________________
_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_
ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ-_-ÿ
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
