Der  im  volksFORTH-83  fr den Atari  520  ST  enthaltene  68000-
Assembler entspricht im Wesentlichen dem von Michael Perry fr das 
F83  entwickelten.  Daher bringen wir hier eine šbersetzung  eines 
Artikels aus 'Dr. Dobbs Journal', Nr.83 vom September 1983, in dem 
Michael  Perry seinen Assembler beschrieben hat.  Abweichungen des 
volksFORTH-Assemblers werden besonders erw„hnt. Im Anschlu an die 
šbersetzung  werden  die zus„tzlichen Funktionen  des  volksFORTH- 
Assemblers beschrieben.

Ein 68000 Forth Assembler
In  diesem  Artikel werde ich die Eigenarten eines  Assemblers  in 
FORTH,  seinen  Gebrauch  und die Implementation  eines  Beispiels 
beschreiben:  Ein  FORTH  Assembler fr den 68000.  Ich hoffe,  die 
Leistungsf„higkeit  eines solchen Assemblers darlegen  zu  k”nnen, 
einige  der  damit verbundenen Eigenarten,  und,  warum er so  und 
nicht anders programmiert wurde.  Um den Leser nicht zu verwirren, 
verzichte  ich  auf Verallgemeinerungen.  Ich  werde  gelegentlich 
Dinge  darstellen,  die sich speziell auf mein System beziehen und 
auf anderen Systemen leicht abweichen k”nnen.
Kurz    gesagt    ist   ein    FORTH-System    eine    interaktive 
Programmierumgebung,  in der einzelne Module,  'Worte' genannt, in 
einer   Datenstruktur  namens  Dictionary  abgelegt  werden.   Der 
Programmierer  kann  neue  Worte  hinzufgen,   die  entweder  aus 
vorhanden   FORTH-Worten   oder   aus    Maschinencodedefinitionen 
bestehen. Ein Assembler in einem FORTH-System ist ein Werkzeug, um 
Coderoutinen   zu  definieren.   Er  ist  nicht  dazu  vorgesehen, 
eigenst„ndige Applikationen in Maschinensprache zu schreiben.  Ein 
FORTH Cross-Assembler ist ganz „hnlich aufgebaut. Mit ihm kann man 
Code erzeugen, der auf einem anderen System l„uft, eventuell sogar 
auf  einem anderen Prozessor.  Dieser Artikel bezieht sich nur auf 
'normale' FORTH-Assembler.  FORTH-Assembler sind kurz,  da sie auf 
vorhandene FORTH-Worte zurckgreifen k”nnen; dieser Assembler z.B. 
ben”tigt nur ca.  3 kByte, dazu kommt das System mit 12 kByte. Zum 
Vergleich:  Der  Assembler,  der  zum CPM 68k geh”rt,  ben”tigt 44 
kByte, zus„tzlich etwa 6 kByte fr die Symboltabelle.
Wenn  man  Applikationen  in FORTH schreibt,  wird  der  Assembler 
selten  eingesetzt,  bevor  die einzelnen Programmteile  nicht  in 
High-Level geschrieben und ausgetestet sind. In den Anfangsstadien 
einer  Entwicklung  ist die Zeit,  die der Programmierer  braucht, 
wesentlich wertvoller als die der Maschine.  Wenn eine Applikation 
lauff„hig ist, mag es sich herausstellen, da sie in High-Level zu 
langsam ist. In diesem Falle mu man herausfinden, welche Routinen 
zeitkritisch sind und dann nur diese in Code neu schreiben. Diesen 
Vorgang  wiederholt man so lange,  bis das Programm schnell  genug 
ist.  Vermeiden  Sie mehr Coderoutinen als erforderlich,  da diese 
die   šbertragbarkeit  Ihres  Programms  stark  einschr„nken.   In 
seltenen  F„llen,  wenn man eine sehr zeitkritische Anwendung  vor 
sich hat, wird man letztlich fast alles in Code schreiben.
Sogar  in  solchen  F„llen  wird  die  Entwicklung  in  der   oben 
bschriebenen  Reihenfolge  am schnellsten zu  Resultaten  und  zur 
fertigen  Anwendung  fhren.   Seien  Sie  immer  bereit,  frhere 
Entwrfe  ber den Haufen zu werfen und von vorn zu beginnen.  Der 
Schlssel  zum  Erfolg ist schrittweise  Ann„herung  :  Schreiben, 
Testen, šberarbeiten bis Sie endgltig zufrieden sind. Das ist der 
Grund,  warum es so wichtig ist, zun„chst eine einfache Version zu 
entwickeln, um zu sehen, ob die Grundidee richtig und durchfhrbar 
ist.
Der  Name  eines  FORTH-Wortes kann aus bis  zu  31  Ascii-Zeichen 
bestehen,  ausgenommen  Leerzeichen.  Worte  im Dictionary sind in 
Gruppen zusammengefat,  die man Vocabularys nennt.  Der Assembler 
ist  ein solches Vocabulary namen ASSEMBLER.  Die meisten Worte im 
Assembler  haben die Namen der blichen Mnemonics des  Prozessors, 
in unserem Falle des 68000. Wenn so ein Wort ausgefhrt wird, legt 
es  die  zugeh”rige Bytefolge im Dictionary ab.  Andere  Worte  im 
Assembler  behandlen  die  Adressierungsart,   Kontrollstrukturen, 
Makros  und m”glicherweise andere Erweiterungen.  H„lt man sich an 
eine FORTH-bliche Syntax, ist es mit wenig Aufwand m”glich, einen 
sehr leistungsf„higen Assembler zu implementieren.
Die  zwei  wichtigsten  Einschr„nkungen sind die  Syntax  und  der 
Verzicht   auf  Vorw„rtsreferenzen.   Wie  in  FORTH  blich  sind 
Vorw„rtsreferenzen  nicht  erlaubt.  Das heit,  ein Wort mu  vor 
seinem ersten Aufruf definiert sein. Ich bin der šberzeugung, dies 
ist eine gute Sache, aber diese Meinung beschw”rt endlose Debatten 
herauf,  und ich werde sie hier nicht beeenden k”nnen. Es ist sehr 
viel einfacher (und damit auch erheblich schneller), wenn man eine 
Syntax verwendet, bei der der Operator hinten steht. Das bedeutet, 
die Befehle werden in folgender Form geschrieben:
     Source Destination Operation
Wenn  auch  ungebr„uchlich  ist dieses Format  sehr  flexibel  und 
einfach   zu  verwenden.   Ein  Pre-Prozessor,   der  die  bliche 
Schreibweise  verarbeiten  kann,  k”nnte relativ leicht  eingebaut 
werden, wenn man die Geschwindigkeitsnachteile in Kauf nimmt.
Das  Dictionary w„chst in Richtung steigender Adressen,  wenn neue 
Worte  hinzugefgt  werden.  Die  meisten  Datenstrukturen  werden 
ebenfalls im Dictionary abgelegt.  Die Systemvariable DP zeigt auf 
die n„chste freie Adresse.  Das Wort HERE bergibt den Wert von DP 
auf  dem  Stack.  Das Wort ,  (comma) tr„gt einen 16-Bit-Wert  ins 
Dictionary ein, das Wort c, (c-comma) einen 8-Bit-Wert (ein Byte). 
Der Assmbler ist nur auf comma und c-comma aufgebaut.

Fehlerbehandlung
Wenn  ich  einen  Assembler benutze,  erwarte ich von  ihm  einige 
wichtige  Leistungsmerkmale.  An erster Stelle steht natrlich die 
richtige  šbersetzung:   Richtige  Eingaben  mssen  zu  richtigen 
Ausgaben fhren.  Das zweite ist die Geschwindigkeit.  Ich m”chte, 
da  der Assembler seine Arbeit so schnell wie  m”glich  erledigt. 
Das   dritte  ist  die  Genauigkeit  der  šbersetzung:   Wenn  ich 
Assemblercode  schreibe,  m”chte  ich ihn selbst  optimieren.  Ich 
m”chte  keinen  optimierenden  Assembler  benutzen  -  ich   hasse 
šberraschungen.  Schlielich  verwende ich ungern allzu  'schlaue' 
Operatoren,  d.h. solche, die mir ein gewisses Ma an Denkfaulheit 
erlauben,  wenn z.B.  ADD manchmal ADDI,  manchmal auch ADDQ, ADDA 
oder sonst etwas assembliert. Solche Operatoren sind langsamer und 
ihr Verhalten weniger durchsichtig. Da FORTH-Assembler erweiterbar 
sind,  kann jeder Benutzer eigene 'schlaue' Operatoren hinzufgen, 
wenn er m”chte.
Mit   Fehlerbehandlung  kann  im  Assembler   beliebiger   Aufwand 
getrieben  werden.  Im Idealfall sollte ein Assembler nur korrekte 
Eingaben  akzeptieren.  Es kann allerdings vor allem in Bezug  auf 
die   Geschwindigkeit   teuer  werden,   wenn   man   bertriebene 
Fehlerkontrolle einbaut. Zum Glck k”nnen viele Fehler sehr leicht 
entdeckt werden.  Es ist einfach zu prfen, ob sich die Stacktiefe 
w„hrend    einer   Definition   ver„ndert   (kein   Wert    bleibt 
unzul„ssigerweise   brig   bzw.    wird   verbraucht),   ob   die 
Kontrollstrukturen ausgeglichen sind usw.
Die n„chste Stufe der Fehlererkennung ist die Prfung auf erlaubte 
Adressierungsarten  bei jedem Befehl.  Bei einer sehr geradlinigen 
Prozessorarchitektur ist das sehr einfach.  Unglcklicherweise ist 
der  68000 nicht ganz dazu geeignet,  auch wenn oft das  Gegenteil 
behauptet  wird.  Trotzdem k”nnen viele Befehle einfach  berprft 
werden.  Obwohl  ich  so etwas gew”hnlich nicht benutze,  habe ich 
einige  Worte eingebaut,  die nachprfen,  ob den Befehlen gltige 
Adressierungsarten  zugeordnet  sind.  ??DN bricht ab,  wenn keine 
direkte Adressirung eines Datenregisters vorliegt.  ??AN fhrt das 
gleiche  fr ein Adreregister durch.  ??JMP bricht ab,  wenn beim 
JMP-Befehl eine ungltige Adressierung benutzt wurde.
Fr  weitergehende  Fehlererkennung mu  zunehmender  Aufwand  bei 
abnehmender Wirkung getrieben werden.

Gebrauchsanleitung fr den Assembler
Eine  detaillierte und ziemlich genaue Beschreibung  des  Motorola 
MC68000  findet  man  im  User's  Manual.  Als  Beispiel  fr  die 
Benutzung  des  Assemblers  nehmen Sie bitte  die  Definition  des 
Wortes FILL, das einen Speicherbereich mit einem vorgegebenen Byte 
fllt. Es wird folgendermaen benutzt:
     adresse l„nge byte  FILL
Beachten  Sie,  da  FILL  drei Parameter vom Stack  ben”tigt  und 
nichts brig l„t.

Code fill   ( adr len val -- )
 SP )+ D0 move         \ Wert nach D0
 SP )+ D1 move         \ L„nge nach D1
 SP )+ D7 move         \ Adresse nach D7, dessen obere 16 Bit die
                       \ Adresse der Speicherbank ($0005 bei
                       \ volksFORTH) enth„lt
 D7 A0 lmove           \ 32-Bit lange Verschiebung
 1 D1 subq             \ decrement D1; dbra l„uft bis -1, nicht 0
 D1 DO   .b D0 A0 )+ move   LOOP
     \ Schleife bis D1 = -1; jedesmal wird ein Byte in die
     \ Adresse, die in A0 steht, geschrieben und A0 incrementiert.
 Next                  \ ein Makro
 end-code              \ beendet die Definition

Das  Wort CODE ist ein defining word.  Es baut einen Kopf fr  das 
neue Wort FILL und setzt dessen Codefeld auf das Parameterfeld. Das 
System  bleibt im interpretierenden Modus.  Der Assembler  benutzt 
den  FORTH-Compiler nicht,  wie h„ufig f„lschlich angenommen wird. 
Der  Kopf ist so etwas wie ein Eintrag in eine Symboltabelle.  Das 
Codefeld  eines jeden Wortes zeigt auf den Code,  den dieses  Wort 
ausgefhren  soll.   Normalerweise  zeigen  alle  Worte,  die  mit 
denselben  defining  words erzeugt worden sind,  auf den  gleichen 
Code.  Worte,  die  mit  CODE  erzeugt werden,  bestehen aus einem 
einzigartigen  Code-Segment,  das immer auf das Parameterfeld eben 
dieses Wortes zeigt. Die brigen Worte der Codedefinition erzeugen 
eine Bytefolge im Parameterfeld des Wortes.
Assembler  Opcode-Worte wie MOVE benutzen das Wort comma,  um  der 
Reihe nach Bytes ins Parameterfeld einzutragen. Wenn das neue Wort 
nach seiner Ausfhrung in den FORTH-Interpreter zurckkehren soll, 
mu die letzte Anweisung NEXT sein.  Next ist ein Makro, das einen 
Sprung  in  den FORTH-Interpreter  assembliert.  Seine  Definition 
lautet:
     : Next     >Next mempage L#) jmp ;  (volksFORTH-83)
wobei  >Next  die  Adresse  des  Adreinterpreters,   mempage  das 
Highbyte  der 64k-Bank und L#) der 'long absolute indirect'  Modus 
ist.  JMP  benutzt comma,  um den richtigen Opcode und die Adresse 
einzutragen.  END-CODE  markiert  das Ende,  prft auf Fehler  und 
r„umt ein bichen auf.
SP  ist der Name des Stackpointers der virtuellen  FORTH-Maschine. 
Das Wort SP hinterl„t einen Wert auf dem Stack,  der den 'direct-
adressing'  Modus mit Register A6 (volksFORTH-83)  darstellt.  Das 
Wort  A6  hat  genau die gleiche  Wirkung;  beides  sind  einfache 
Konstanten. Das Wort )+ modifiziert den Wert auf dem Stack, den SP 
hinterlassen   hat,   um   die   'indirect   mit   auto-increment' 
Adressierung  anzuzeigen.   Wie  das  funktioniert,   wird  sp„ter 
erkl„rt. Das Wort D0 stellt Datenregister 0 dar.
Das  Wort  MOVE assembliert einen 68000 move-Befehl.  Es  ben”tigt 
zwei  Werte,  die  jeweils  eine Adressierungsart  beinhalten.  In 
unserem  Beispiel  wird  der  assemblierte Code  16  Bit  aus  der 
Adresse,  auf die SP zeigt, nach D0 transportieren und dabei SP um 
zwei  erh”hen.  Die  L„nge der Operation wird festgelegt  von  der 
Variablen SIZE, die auf 16-Bit voreingestellt ist. SIZE wird durch 
.B (Byte), .W (Word) und .L (Long) gesetzt.
Das  Wort  CODE schaltet das Assembler-Vocabulary ein,  damit  bei 
gleichen Worten im Assembler und im brigen System (z.B. SWAP) das 
richtige gefunden wird.  Das Wort LMOVE wurde zus„tzlich definiert 
als   Spezialfall   von   MOVE   fr   die   oben    angesprochene 
Registerverschiebung.  LMOVE  assembliert  immer einen Long  move, 
ohne dabei SIZE zu ver„ndern. Beachten Sie den Gebrauch von DO und 
LOOP im Assembler. DO erh„lt ein Datenregister zugeordnet, das den 
Schleifenz„hler fr die Ausfhrungsphase enth„lt. DO bergibt HERE 
und  das  Register  an  LOOP,  welches einen dbra  zurck  auf  DO 
assembliert, bei dem das angegebene Datenregister benutzt wird.

Implementation
Es  gibt  viele m”gliche und darunter zwei  h„ufiger  beschrittene 
Wege,  um einen Assembler in FORTH zu schreiben. Eine Methode ist, 
viele   Variable   mit  Status-Informationen  zu   benutzen,   die 
ihrerseits  von  den  Mnemonic-Worten  verwendet  werden,  um  den 
Assembliervorgang  zu steuern.  Nach jeder Instruktion werden  sie 
gel”scht,  um von der n„chsten Instruktion wieder verwendet werden 
zu  k”nnen.  Bei diesem Assembler ist eine weiter verbreitete  und 
auch  wnschenswertere  Methode  gew„hlt  worden.  Fast  s„mtliche 
Informationen  werden  auf  dem Stack bergeben,  der  auch  nicht 
initialisiert werden mu.
Ebenso gibt es zwei verbreitete Arten, die Adressierungsart an das 
assemblierende  Wort  zu bergeben.  Eine M”glichkeit  besteht  in 
einer Art geschachtelter IF...ELSE Strukturen, die aus einer Folge 
von M”glichkeiten die richtige herauszusucht. Der andere Weg, hier 
eingesetzt, besteht darin, da die Worte, die die Adressierungsart 
bestimmen,  die Werte,  die ihnen bergeben wurden, in irgendeiner 
Form  ver„ndern.  Dies  geschieht durch Ausmaskieren mit  AND  und 
Setzen  einzelner  Bits mit OR.  Solche Logikoperationen  arbeiten 
bekanntlich viel schneller als Verzweigungen,  soda der Assembler 
insgesamt mit solchen Operationen schneller wird.
Wenn Sie die folgenden Beschreibungen lesen,  sollten Sie sich den 
Quelltext  des  Assemblers zur Hand nehmen.  Er befindet sich  auf 
Ihrer Diskette (dir list).
Die  Grundidee,  die  hinter  diesem  Assembler  steckt,  ist  die 
Betrachtung  einer  Maschinencodeinstruktion als  Reihe  von  Bit-
Feldern.  Diese  Bit-Felder  sind im Manual der  CPU  beschrieben. 
Einige  sind  fr  viele  Instruktionen  gltig  wie  source   und 
destination, mode und register Felder.

     | op-code | dest reg | dest mode | source mode | source reg |
     |15     12|11       9|8         6|5           3|2          0|

Wie  bereits  erw„hnt benutzen Instruktionen,  die die  Datenl„nge 
kennen mssen,  die Variable SIZE. Die Position des Bit-Felds, das 
die  Datenl„nge bestimmt,  wechselt von Befehl zu Befehl mehr  als 
alle  anderen.  Fast  immer  werden  die benutzten  Werte  in  die 
Variable SIZE bergeben,  und zwar durch .B,  .W oder .L. Beachten 
Sie, da ich an diesem Punkt BASE auf OCTAL umgeschaltet habe. Die 
68000-Befehle  enthalten  viele  3-Bit-Felder  und  k”nnen   daher 
besonders  bersichtlich als Oktalzahlen dargestellt  werden.  Ich 
war   gezwungen,   meine   Vorliebe   fr   Hexzahlen   zeitweilig 
zurckzustellen.
Bei der Definition der Worte,  die Register und Adressierungsarten 
festlegen, habe ich zu einem kleinen Trick gegriffen. Ich benutzte 
ein  'Multi-defining  word' REGS,  das in einer Schleife  CONSTANT 
ausfhrt,  um  „hnliche  Konstanten  zu erzeugen.  REGS  wird  nur 
zweimal   benutzt.   Einmal  fr  Datenregister  und  einmal   fr 
Adreregister, die Modus 0 bzw. 1 darstellen.
     Modus  0  ist  'data  register direct',  daher  ist  D5  eine 
     Konstante mit dem Wert 5005.
     Modus  1  ist  'adress register direct',  daher ist  A3  eine 
     Konstante mit dem Wert 3113.
Worte,   die   mit  MODE  definiert  wurden,   werden  nach  einem 
Adreregister  benutzt  und  ersetzen die  zwei  Modusziffern  (in 
unserem  Fall 1) mit den neuen Modus-Werten.  Dies geschieht durch 
Ausmaskieren der alten Werte mit AND und Setzen der neuen mit  OR. 
Alle MODE-Worte sind 'adress register indirect' mit Zus„tzen.
     Modus 2 ist 'adress register indirect',
     daher ergibt A6 )    6226.
     Modus 3 ist dasselbe mit 'post-increment',
     daher ergibt A7 )+   7337.
     Modus 4 ist dasselbe mit 'pre-decrement',
     daher ergibt A7 -)   7447.
     Modus 5 ist dasselbe mit 'displacement',
     daher  ergibt 123 A1 D)   1551
     mit  dem 'displacement' Wert von 123,  der zun„chst unter dem 
     Register/Modus Wert auf dem Stack liegt.
     Modus 6 ist dasselbe mit index und displacement,
     daher ergibt 123 D4 A1 DI)    1661.
     Auf dem Stack liegen darunter 4004 und 123.
Modus  7 wird fr alle brigen Adressierungsarten  verwendet,  die 
sich durch ihre Registerfelder unterscheiden.  Diese Modi sind als 
Konstanten definiert.
     #)  ist  0770 und stellt die absolute  (16-Bit)  Adressierung 
     dar.  Der  Name  bedeutet 'immediate indirect'.  (Denken  Sie 
     darber nach!)
     L#)  ist 1771 und stellt die absolute  (32-Bit)  Adressierung 
     dar.
     PCD)  ist 2772 und stellt den 'program counter  relative  mit 
     displacement'  Modus dar.  123 PCD) ergibt 2772 und  darunter 
     liegt 123 auf dem Stack.
     PCDI)  ist  3773  und stellt den  'program  counter  relative 
     displaced,  indexed' Modus dar.  123 D4 PCDI) ergibt 3773 und 
     darunter 4004 und 123 auf dem Stack.
     # ist 4774 und stellt den 'immediate data' Modus fr 16  oder 
     32 Bit dar. 456 # ist 4774, darunter liegt 456.

(Anmerkung d.  šbers.:  Zus„tzlich haben wir ins volksFORTH-83 die 
Adressierungsart  R#) (relative immediate  indirect)  aufgenommen. 
Sie wirkt wie L#),  legt aber zus„tzlich die High-Adresse der 64k-
Speicherbank  auf  den  Stack.   Damit  ist  Zugriff  auf  normale 
Datenstrukturen m”glich.)
Beachten  Sie,  da  immer  1  bis 3 16-Bit-Werte  auf  dem  Stack 
hinterlassen werdenm,  die die Adressierungsart kennzeichnen.  Der 
oberste  Wert  wird  normalerweise Teil der ersten  16  Bit  eines 
Befehls zusammen mit dem Opcode. Falls zus„tzliche Werte vorhanden 
sind, werden sie im Anschlu an den Opcode assembliert.
Manche   3-Bit-Felder   werden  h„ufiger   (durch   Ausmaskierung) 
selektiert als andere. Das Wort FIELD erzeugt Worte, mit denen man 
solche  Felder selektieren kann.  RS und RD w„hlen die source  und 
destination register Felder (s.  Bild oben) aus. MS selektiert das 
source  mode  Feld.  Der erzeugende Ausdruck fr eine  vollst„ndig 
festgelegt  Adressierungsart ist eine effektive Adresse (EA).  Das 
Wort  EAS w„hlt die 'source effective adress',  die aus den source 
mode  und register Feldern besteht.  LOW selektiert die unteren  8 
Bits. Das Opcode-Wort enth„lt oft ein EAS Feld. Das Wort SRC fhrt
        OVER EAS OR
aus,  womit es dieses Feld ins Opcode-Wort bertr„gt. Das Wort DST 
baut das destination register Feld ein.
Die  virtuelle  FORTH-Maschine enth„lt fnf Register.  Diese  sind 
einzelnen 68000 Registern zugeordnet. Es ist im Assembler m”glich, 
sowohl  die 68000 Register-Namen als auch die Namen  der  Register 
der  virtuellen  Maschine zu benutzen.  (Bemerkung d.  šbers.:  Sie 
sollten die 68000 Registernamen nur dann benutzen,  wenn sie keine 
FORTH-Register    meinen.    Sie   vermeiden   so    unerkl„rliche 
Systemabstrze, falls die Registerzuordnung sich „ndert.)
Adressierungsarten,    die   nach   dem   Opcode   weitere   Werte 
assemblieren,    nennt    man    'extended   adressing'.    Solche 
Adressierungsarten  werden  mit  sechs  Worten  und  einem  Buffer 
abgehandelt.  DOUBLE? hinterl„t ein Flag, das wahr ist, falls der 
Modus,  der oben auf dem Stack liegt, zus„tzliche 32 Bit verlangt. 
INDEX?  sucht  nach  einer  Adressierungsart und  ver„ndert  seine 
zus„tzlichen  Werte  in  das passende Format,  falls  es  sich  um 
'indexed'  Adressierung handelt.  MORE?  hinterl„t ein True-Flag, 
wenn  die Adressierungsart weitere Werte ben”tigt.  MORE tr„gt alle 
zus„tzlichen Werte hinter dem Opcode-Wort ins Dictionary ein.
Einige  Instruktionen brauchen zwei Adressierungsarten,  eine  fr 
source  und  eine fr destination.  Der source Modus  wird  zuerst 
festgelegt,  soda  er  unter dem destination Modus auf dem  Stack 
liegt.  Jede Adressierungsart besteht aus ein bis drei Werten, die 
auf  dem Stack liegen.  Der source Modus wird vor dem  destination 
Modus  verarbeitet,  daher  mssen die Werte fr  den  destination 
Modus so lange in einem Buffer abgelegt werden. EXTRA? rettet alle 
zus„tzlichen Werte in einen Buffer namens EXTRA und hinterl„t nur 
den Wert fr die Adressierungsart.  ,EXTRA  nimmt die zus„tzlichen 
Werte aus dem Buffer und tr„gt sie ins Dictionary ein.
Fast  der ganze Rest des Assemblers besteht aus  Definitionen  und 
der  Anwendung  von  defining words,  die  Gruppen  von  Mnemonics 
erstellen.  Zwei  Beispiele  werden  gengen.  Wenn  Sie  mit  dem 
Genrauch  von defining words nicht vertraut sind - Sie sollten  es 
sein; sie sind die leistungsf„higste Struktur in FORTH.
Das Wort IMM erzeugt Worte,  die 'immediate' Befehle assemblieren. 
Ich werde die Definition hier wiederholen und genau erl„utern.
      : IMM     CONSTANT
          DOES>  @ >R  EXTRA?  EAS  R>  OR
                 SZ3 ,  LONG?  ?,  ,EXTRA ;

Gebrauch bei der Definition:   3000 IMM ADDI
Gebrauch im Assembler:         n ea ADDI
Beispiel:                      123 A5 ) ADDI

Jedes  Mal,   wenn  mit  IMM  ein  Mnemonic-Wort  definiert  wird, 
speichert es einen konstanten Wert in der Definition dieses Wortes 
ab,  der  es von anderen 'immediate' Worten unterscheidet.  Dieser 
Wert  ist  der Opcode des Befehls.  Immediate  Befehle  beinhalten 
folgende Bit-Felder.

     | op-code |  size  |  mode  |   reg  |
     |15      8|7      6|5      3|2      0|

Diesen  folgen  16  oder  32  Bit  Daten.   Wenn  das  Befehlswort 
ausgefhrt  wird,  fhrt es den Code nach DOES> in IMM aus mit der 
Adresse  seines eigenen Parameterfeldes auf dem Stack.  An  dieser 
Adresse  ist  die Konstante (der Opcode) kompiliert.  Das  Wort  @ 
liest diesen Wert und rettet ihn mit >R auf den Returnstack.  ADDI 
erh„lt die 'immediate' Daten auf dem Stack unterhalb der Werte fr 
die Adressierungsart.  EXTRA?  rettet alle zus„tzlichen Werte, EAS 
selektiert  die  mode  und register  Felder,  die  benutzt  werden 
sollen.  Dann  wird  der Opcode vom Returnstack mit R> geholt  und 
durch  OR mit EAS verknpft.  SZ3 setzt die zugeh”rigen L„ngenbits 
aus SIZE,  und das Wort comma tr„gt das Opcode-Wort ins Dictionary 
ein.  Jetzt  liegen  nur noch die Daten auf dem Stack,  und  LONG? 
entscheidet,  ob ?,  16 oder 32 Bit anh„ngen soll. Zum Schlu holt 
,EXTRA die geretteten zus„tzlichen Werte,  falls vorhanden, zurck 
und h„ngt sie ebenfalls an.
Zahlreiche   andere  „hnlich  aufgebaute  defining  words   werden 
benutzt,  um  die  meisten  brigen Befehle zu  definieren.  Viele 
dieser Wort bilden fr sich eine Gruppe und sind deswegen mit  dem 
Wort :  definiert,  gerade so wie Makros.  Die conditional Befehle 
sind  so  regelm„ig,  da  ich  noch ein  'trick  defining  word' 
benutze.  SETCLASS  verwendet wiederholt ein vorhandenes  defining 
word,  jedesmal  mit einem anderen Argument,  um mehrere Mnemonic-
Worte auf einmal zu definieren. Alle 46 conditional Befehle werden 
definiert,  indem  jedes der drei defining words 16 mal aufgerufen 
wird.  Dabei  entsteht  auch zwei ungltige Mnemonics,  die  nicht 
weiter  benutzt werden.  Vielleicht w„re es in diesem Falle besser 
gewesen,  alle  46 Befehle einzeln zu definieren,  aber ich wollte 
zeigen, was alles machbar ist.
Zum  Schlu kommen wir zu den structured conditionals.  Betrachten 
Sie folgendes Beispiel:

            A3 )+ D1 CMP  0<
     IF     D0 A7 )  MOVE
     ELSE   A7 ) D0  MOVE
     THEN


     BEGIN  A3 D2 CMP  0=
     WHILE  A0 )+ D0 MOVE
     REPEAT

Im   ersten  Beispiel  beeinflut  das  Ergebnis  des   Vergleichs 
bestimmte Flags im Status-Register. IF assembliert einen bedingten 
Sprung,  dessen  Opcode  (mit Bedingung) durch 0< festgelegt  ist. 
Dieser assembliert also den Wert fr einen BGE (Branch greater  or 
equal).  ELSE  berechnet  den Sprungoffset fr IF und  assembliert 
einen unbedingten Sprung; THEN berechnet dessen Offset.
Ebenso  berechnet  WHILE  einen bedingten  Sprung  hinter  REPEAT, 
welches  wiederum  einen  unbedingten  Sprung  zurck  auf   BEGIN 
assembliert.
Beachten Sie,  da keine Labels n”tig sind.  Der meiste Wirrwarr in 
normalen  Assembler Quelltexten entsteht durch die riesige  Anzahl 
an bedeutungslosen Labelnamen fr Sprungziele.  Beachten Sie auch, 
da die structured conditionals, die wir hier definiert haben, nur 
1-Byte   Offsets  benutzen.   Da  der  Assembler  nur  einen  Pass 
durchl„uft,  mu  der  Platz  fr den Sprungoffset  frei  gehalten 
werden,  bevor  seine Gr”e bekannt ist.  Da Coderoutinen in FORTH 
immer sehr kurz sind,  gengt ein Byte fr den Offset.  Sollte das 
nicht  ausreichen,  ersetze  ich einfach diese Definitionen  durch 
sehr „hnliche, die einen 16-Bit Offset benutzen.
Sclielich  sollte  bemerkt  werden,  da es keine Worte  fr  die 
Einrichtung von Datenstrukturen in diesem Assembler geben braucht. 
Ein  FORTH-Assembler ist Teil einer FORTH-Umgebung;  und auf  alle 
Datenstrukturen,  die  mit  normalen FORTH-Worten erzeugt  wurden, 
kann der Assembler zugreifen.
Ein Beispiel:

     VARABLE  FOO
     CODE BAR    FOO R#) NEG  NEXT END-CODE

BAR negiert den Inhalt der Variablen FOO.



Im  Unterschied  zu dem Assembler von Michael  Perry  verfgt  der 
volksFORTH-83 Assembler ber einige Zus„tze.

;c:  Schaltet  den Assembler ab und den FORTH-Compiler  an.  Damit 
     ist  es m”glich,  von Maschinencode in FORTH  berzuwechseln. 
     Ein Gegenstck ist nicht vorhanden.
Ein Beispiel fr die Verwendung von ;c: ist:
     .... 0< IF  ;c: ." Fehler" ; Assembler  THEN
Ist irgendwas kleiner als Null, so wird Fehler ausgedruckt und die 
Ausfhrung des Wortes abgebrochen, sonst geht es weiter im Code.

Sclielich gibt es noch die Worte >LABEL und LABEL. >LABEL erzeugt 
ein  Label im Heap,  wobei es den Wert des Labels vom Stack nimmt. 
LABEL erzeugt ein Label mit dem Wert von HERE.  Beispiel:
     LABEL  SCHLEIFE   1 D0 subq  SCHLEIFE BNE
Von  der Verwendung solcher Labels kann allerdings  nur  abgeraten 
werden,   wenn  wie  im  obigen  Beispiel  ebensogut  strukturiert 
programmiert werden k”nnte.

