NVDI 4.1 Programmer's Guide
============================

05.03.96 (preliminary draft)

(c) 1995-96 by Wilfried Behne

Prologue
--------

This preliminary documentation of NVDI 4 is divided into the parts

-  Data Types and Structures
-  NVDI Version
-  List of VDI functions
-  Drivers and Management
-  Color Settings
-  Writing Modes and Clipping
-  Lines and unfilled Graphic Primitives
-  Filled Graphic Primitives
-  Markers
-  Text Output with Bitmap and Vector Fonts
-  Raster Operations
-  Input functions
-  Text Mode and VT52
-  Printer specific functions
-  Sample Bindings

No responsibility or liability is taken for errors or inaccuracies in this 
documentation. 

Terms
-----
This documentation is public domain, you can copy it freely and use it. 
Commercial distribution is forbidden.

NVDIGUID.LZH consists of the following files:

   - NVDIGUID.TXT
   - MAPPING\MAPLIKE4.MAP     (SPDCHAR.MAP for Speedo 4.2)
   - MAPPING\MAPPIN01.IMG     (Mapping in NVDI 4.1, page 1 - 300 dpi)
   - MAPPING\MAPPIN02.IMG     (Mapping in NVDI 4.1, page 2 - 300 dpi)
   - MAPPING\MAPPIN03.IMG     (Mapping in NVDI 4.1, page 3 - 300 dpi)
   - MAPPING\MAPPIN04.IMG     (Mapping in NVDI 4.1, page 4 - 300 dpi)
   - MAPPING\MAPPIN05.IMG     (Mapping in NVDI 4.1, page 5 - 300 dpi)
   - MAPPING\MAPPIN06.IMG     (Mapping in NVDI 4.1, page 6 - 300 dpi)
   - PATCH\PATCH_NV.TTP       (Fixes for NVDI 3.x)
   - DRUCKEN.TC\...           (Example for true color printing)

The archive may only be copied including these files. You are allowed to modify 
the files for your own demands, but you are not allowed to spread the modified 
files.

Trademarks
----------
Speedo is a registered trademark of Bitstream Inc., TrueType and TrueType GX are 
registered Trademarks of Apple Computer, Inc, PostScript ist a registered 
Trademark of Adobe Systems Inc. Most products mentioned in this text are usually 
registered trademarks. The lack of explicit references does not mean that these 
products are free from rights of third parties.




Data Types and Structures
=========================

ù Used Data Types

The subsequent declarations and descriptions work with the following data types:

BYTE     8 bits, signed, from -128 to 127
UBYTE    8 bits, unsigned, from 0 to 255
WORD     16 bits, signed, from -32768 to 32767
UWORD    16 bits, unsigned, from 0 to 65535
LONG     32 bits, signed, from -2147483648 to 2147483647
ULONG    32 bits, unsigned, from 0 to 4294967295
fix31    32 bits, signed, from -2147483648 to 2147483647

Most C bindings use BYTEs for input and output of strings. Since most VDI 
functions expect WORD or UWORD strings as input and output, the bindings coerce 
BYTE into WORD and clear the high byte, which means that in this case BYTE is 
treated as UBYTE.

The standard data type of the VDI is WORD. The arrays contrl, intin, ptsin, 
intout and ptsout are WORD[]. In spite of this the interpretation of the values 
depends on the VDI call. Coordinates in ptsin are usually regarded as signed, 
values in intin are often considered to be unsigned.

The type fix31 is used for outline fonts, where characters positions and widths 
are fractional values in 1/65536 (1 pixel is equivalent to 65536 units).

hex.        dec.
$00010000   65536    1.0  pixels
$0001c000  114688    1.75 pixels
$fffec000  -81920   -1.25 pixels
$fffe4000 -114688   -1.75 pixels

If you add advance widths (returned by vqt_advance32()) and you would like to  
determine the discrete coordinate for cursor placement, you should use the 
following code: 

WORD  fix31_to_pixel( fix31 a )
{
   WORD  b;

   b = (WORD) (( a + 32768L ) >> 16 ); /* round */
   return( b );
}

Do not truncate!


ù Structures and Arrays for VDI calls

The following arrays and structures are required for VDI calls:

WORD  contrl[12];

Input Parameters:

contrl[0]:     opcode
contrl[1]:     number of vertices (in ptsin)
contrl[3]:     number of integers (in intin)
contrl[5]:     sub-opcode
contrl[6]:     workstation handle
contrl[7..n]:  depending on the function

Output Parameters:

contrl[2]:     number of vertices (in ptsout)
contrl[4]:     number of integers (in intout)
contrl[6]:     workstation handle (only v_opnwk()/v_opnvwk()/v_opnbm())

The arrays ptsin and ptsout are used to store vertices or widths and heights in 
pixels (e.g. the width of a line or the height of a character). The size of the 
arrays depends on the functions you want to call. Usually the following 
declaration for ptsin and ptsout is sufficient:

WORD  ptsin[1024];   /* up to 512 input vertices */
WORD  ptsout[256];   /* up to 128 output vertices */

Words like the index of a character or a color index are stored in intin and 
intout. 

WORD  intin[1024];   /* up to 1024 input integers */
WORD  intout[512];   /* up to 512 output integers */

Before you call the VDI you must store the array addresses in a parameter block 
(VDIPB). The address of the VDIPB is loaded in Register d1.l and d0.w is set to 
115. Then call the OS with a trap #2 mnemonic.

typedef struct
{
   WORD  *contrl;
   WORD  *intin;
   WORD  *ptsin;
   WORD  *intout;
   WORD  *ptsout;
} VDIPB;

Setting colors:

vs_color(), vq_color() and vs_calibrate() use RGB intensities in per mille. Use 
the following structure to store RGB values:

typedef struct
{
   WORD  red;        /* red intensity in per mille */
   WORD  green;      /* green intensity in per mille */
   WORD  blue;       /* blue intensity in per mille */
} RGB1000;

Raster Operations:

VDI functions, which perform logic operations on bitmaps, require a raster 
definition called MFDB, "Memory Form Definition Block".

typedef struct
{
   void  *fd_addr;   /* address of the bitmap or 0 for screen/offscreen bitmap 
   WORD  fd_w;       /* width in pixels */
   WORD  fd_h;       /* height in pixels */
   WORD  fd_wdwidth; /* width of a line in words (per plane) */
   WORD  fd_stand;   /* 0: device specific format, 1: standard format */
   WORD  fd_nplanes; /* number of planes */
   WORD  fd_r1;      /* reserved, must be 0 */
   WORD  fd_r2;      /* reserved, must be 0 */
   WORD  fd_r3;      /* reserved, must be 0 */
} MFDB;

If fd_addr is 0L, vrt_cpyfm() and vro_cpyfm() refer to the screen (or the device 
bitmap, e.g. if the device is a printer) as source or destination of the 
operation. The reserved words must be zero1!

fd_wdwidth is the width of a line in bytes (including all planes) divided by the 
number of planes and again divided by 2 (to the number of words):

   fd_wdwidth = bytes_per_line / planes / 2;

   or
   
   fd_wdwidth = ( width + 15 ) / 16;

This definition implies that a raster line's width in pixels can be divided by 
16 without remainder.


Metafiles:

A metafile starts with the following header:

typedef struct
{
   WORD  mf_header;     /* -1 */
   WORD  mf_length;     /* length of the header in words (usually 24) */
   WORD  mf_version;    /* version number, 101 fr 1.01 */
   WORD  mf_ndcrcfl;    /* NDC/RC flag, usually 2 (raster coordinates) */
   WORD  mf_extents[4]; /* optional */
   WORD  mf_pagesz[2];  /* optional - page size in 1/10 mm */
   WORD  mf_coords[4];  /* optional - coordinate system */
   WORD  mf_imgflag;    /* flag for v_bit_image() */
   WORD  mf_resvd[9];
} METAHDR;

The parameters mf_extents, mf_pagesz and mf_coords are optional. If a program 
has not specified these values, they contain zeros. The IMG flag indicates, if 
v_bit_image()-calls are stored in the metafile.

The function vqt_xfntinfo() uses an XFNT_INFO structure to store information 
about a font:

typedef struct
{
   LONG  size;             /* length of the structure, initialize this entry before calling vqt_xfntinfo() */
   WORD  format;           /* font format, e.g. 4 for TrueType */
   WORD  id;               /* font ID, e.g. 6059 */
   WORD  index;            /* index */
   BYTE  font_name[50];    /* font name, e.g. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* name of the font family, e.g. "Century725 BT" */
   BYTE  style_name[50];   /* name of the font style, e.g. "Italic" */
   BYTE  file_name1[200];  /* name of the first font file, e.g. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* name of the 2nd font file */
   BYTE  file_name3[200];  /* name of the 3rd font file */
   WORD  pt_cnt;           /* number of available point sizes (vst_point()), e.g. 10 */
   WORD  pt_sizes[64];     /* available point sizes,
                              e.g. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;


ù Strings

Generally, the VDI passes strings in intin and intout and uses one word per 
character. This convention has the advantage, that the VDI is capable of using 
character encodings with more than 256 characters per font.

Most C bindings for functions like v_ftext(), vqt_name(), vqt_extent() and so on 
use ordinary C strings and convert them for the VDI. The length of such a string 
is stored in contrl[3] respectively contrl[4]. Please note that the string is 
not terminated with a zero byte or word.

If you want to coerce a string in intout into a C string, you have to copy 
contrl[4] elements, truncate the upper 8 bits of every word and append a 
termination byte.

void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE) *src++;   /* only low byte */
      len--;
   }
   *des++ = 0;                   /* EOS */
}

WORD c_str_to_vdi( UBYTE *src, UWORD *des )
{
   WORD  len;

   len = 0;
   
   while (( *des++ = *src++ ) != 0 )
      len++;

   return( len );                /* length of the string */
}




NVDI Version
============

To determine the NVDI version, you have to search the "NVDI" cookie which 
contains the version number in BCD format (e.g. 0x0301 for NVDI 3.01 and 0x0410 
for 4.10).

If you want to use offscreen bitmaps, you should search the "EdDI" cookie. The 
long word following the cookie id the address of a function dispatcher. The 
dispatcher expects the function number in d0.w (Pure C conventions: registers 
d0-d2/a0-a1 are used for parameters). Function 0 returns the EdDI version number 
in BCD format (0x0110 means version 1.10).

typedef struct
{
  BYTE   id[4];         /* e.g. 0x4e564449 = 'NVDI' */
  LONG   value;         /* points to NVDI_STRUC */
} COOKIE;

typedef struct
{
   UWORD nvdi_version;  /*  e.g. 0x0301 for version 3.01 */
   ULONG nvdi_datum;    /*  e.g. 0x18061990L for 18.06.1990 */
} NVDI_STRUC;




List of VDI functions
=====================

The following list contains the supported VDI functions and since when they are 
available.

contrl[0]   contrl[5]   function name           availability

Drivers and Management:

   1           0        v_opnwk();
   2           0        v_clswk();
   100         0        v_opnvwk();
   101         0        v_clsvwk();
   3           0        v_clrwk();
   4           0        v_updwk();
   5           22       v_clear_disp_list();
   100         1        v_opnbm();              since EdDI 1.00
   101         1        v_clsbm();              since EdDI 1.00
   102         0        vq_extnd();
   102         1        vq_scrninfo();          since EdDI 1.00
   248         0        vq_devinfo();           since NVDI 3.00
   248         4242     vq_ext_devinfo();       since NVDI 3.00

Color Settings:

   5           76       vs_calibrate();         depends on the driver
   5           77       vq_calibrate();         depends on the driver
   14          0        vs_color();
   26          0        vq_color();

Writing Modes and Clipping:

   32          0        vswr_mode();
   129         0        vs_clip();

Lines and unfilled Graphic Primitives:

   5           99       v_bez_qual();           since NVDI 2.10
   6           0        v_pline();
   6           13       v_bez();                since NVDI 2.10
   11          2        v_arc();
   11          6        v_ellarc();
   11          8        v_rbox();
   11          13       v_bez_on();             since NVDI 2.10
   11          13       v_bez_off();            since NVDI 2.10
   15          0        vsl_type();
   16          0        vsl_width();
   17          0        vsl_color();
   35          0        vql_attributes();
   108         0        vsl_ends();
   113         0        vsl_udsty();

Filled Graphic Primitives:

   9           0        v_fillarea();
   9           13       v_bez_fill();           since NVDI 2.10
   11          1        v_bar();
   11          3        v_pieslice();
   11          4        v_circle();
   11          5        v_ellipse();
   11          7        v_ellpie();
   11          9        v_rfbox();
   23          0        vsf_interior();
   24          0        vsf_style();
   25          0        vsf_color();
   37          0        vqf_attributes();
   103         0        v_contourfill();
   104         0        vsf_perimeter();
   112         0        vsf_udpat();
   114         0        vr_recfl();

Markers:

   7           0        v_pmarker();
   18          0        vsm_type();
   19          0        vsm_height();
   20          0        vsm_color();
   36          0        vqm_attributes();

Text Output:

   8           0        v_gtext();
   11          10       v_justified();
   12          0        vst_height();
   13          0        vst_rotation();
   21          0        vst_font();
   22          0        vst_color();
   38          0        vqt_attributes();
   39          0        vst_alignment();
   106         0        vst_effects();
   107         0        vst_point();
   116         0        vqt_extent();
   117         0        vqt_width();
   119         0        vst_load_fonts();
   120         0        vst_unload_fonts();
   130         0        vqt_name();             extended since NVDI 3.00
   131         0        vqt_fontinfo();
   190         0        vqt_char_index();       since NVDI 4.00
   229         0        vqt_xfntinfo();         since NVDI 3.02
   230         0        vst_name();             since NVDI 3.02
   230         100      vqt_name_and_id();      since NVDI 3.02
   231         0        vst_width();            since NVDI 3.00
   232         0        vqt_fontheader();       since NVDI 3.00
   234         0        vqt_trackkern();        since NVDI 3.00
   235         0        vqt_pairkern();         since NVDI 3.00
   236         0        vst_charmap();          since NVDI 3.00
   237         0        vst_kern();             since NVDI 3.00
   237         0        vst_track_offset();     since NVDI 3.00
   239         0        v_getbitmap_info();     since NVDI 3.00
   240         0        vqt_f_extent();         since NVDI 3.00
   240         4200     vqt_real_extent()       since NVDI 3.00
   241         0        v_ftext();              since NVDI 3.00
   241         0        v_ftext_offset();       since NVDI 3.00
   243         0        v_getoutline();         since NVDI 3.00
   246         0        vst_arbpt32();          since NVDI 3.00
   247         0        vqt_advance32();        since NVDI 3.00
   252         0        vst_setsize32();        since NVDI 3.00
   253         0        vst_skew();             since NVDI 3.00

Raster Operations:

   105         0        v_get_pixel();          screen drivers only
   109         0        vro_cpyfm();            extended since NVDI 4.10
   110         0        vr_trnfm();
   121         0        vrt_cpyfm();            extended since NVDI 4.10

Input functions:

   33          0        vsin_mode();
   28          0        vrq_locator();
   28          0        vsm_locator();
   30          0        vrq_choice();
   30          0        vsm_choice();
   31          0        vrq_string();
   31          0        vsm_string();
   111         0        vsc_form();
   115         0        vqin_mode();
   128         0        vex_timv();
   122         0        v_show_c();
   123         0        v_hide_c();
   124         0        vq_mouse();
   125         0        vex_butv();
   126         0        vex_motv();
   127         0        vex_curv();
   128         0        vq_key_s();

Text Mode and VT52:

   5           1        vq_chcells();
   5           2        v_exit_cur();
   5           3        v_enter_cur();
   5           4        v_curup();
   5           5        v_curdown();
   5           6        v_curright();
   5           7        v_curleft();
   5           8        v_curhome();
   5           9        v_eeos();
   5           10       v_eeol();
   5           11       v_curaddress();
   5           12       v_curtext();
   5           13       v_rvon();
   5           14       v_rvoff();
   5           15       vq_curaddress();

Printer specific functions:

   5           23       v_bit_image();
   5           27       v_orient();             depends on the driver
   5           28       v_copies();             depends on the driver
   5           29       v_trays();              depends on the driver
   5           36       vq_tray_names()         depends on the driver
   5           37       v_page_size()           depends on the driver
   5           38       vq_page_name()          depends on the driver
   5         2000       v_escape2000()          depends on the driver



Device Driver and Offscreen Bitmaps
===================================

ù OPEN WORKSTATION (VDI 1)

This function loads a device driver and opens a physical workstation. The 
driver is loaded according to ASSING.SYS and the device is initialized with 
parameters in the input array.

If the driver is able to open the device, the VDI returns a device handle 
in contrl[6]. A zero in contrl[6] indicates an error.

Important:  The screen driver is opened by the AES after all programs in the
            AUTO folder have been executed. Therefore applications have to 
            call OPEN VIRTUAL WORKSTATION (VDI 100).

Decl.:  void v_opnwk( WORD *work_in, WORD *handle, WORD *work_out );
Call:   v_opnwk( work_in, &handle, work_out );

Variable         Arguments           Meaning
Input:

contrl[0]        1                   v_opnwk
contrl[1]        0                   entries in ptsin
contrl[3]        11                  entries in intin
contrl[6]        0 or 1
intin[0..10]     work_in[0..10]

Output:

contrl[2]        6                   entries in ptsout
contrl[4]        45                  entries in intout
contrl[6]        handle
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Meaning of work_in[0..10]:
work_in[0]: Device ID number. This value determines which
            device driver will be opened.

            1-10: Screen
            1:    current resolution
            2:    320*200,  16 colors
            3:    640*200,  4 colors
            4:    640*400,  monochrome
            6:    640*480,  16 colors  (TT)
            8:    1280*960, monochrome (TT)
            9:    320*480,  256 colors (TT)

            ab 11: Plotter
            ab 21: Printer
            ab 31: Metafile
            ab 41: Kamera
            ab 51: Tablet
            ab 61: Memory

work_in[1]: Line type
work_in[2]: Line color index
work_in[3]: Marker type
work_in[4]: Marker color index
work_in[5]: font id
work_in[6]: text color index
work_in[7]: fill interior style
work_in[8]: fill style index
work_in[9]: fill color index
work_in[10]:transformation flag 0: NDC , 2: RC

Meaning of work_out[0..56]:
work_out[0]:  Maximum addressable width (0 - xmax)
work_out[1]:  Maximum addressable height (0 - ymax)
work_out[2]:  Device Coordinate units fla
              0: Device capable of producing a precisely scaled
                 image (e.g. screen)
              1: Device not capable of producing a precisely scaled 
                 image (e.g. film recorder)
work_out[3]:  Pixel width in microns
work_out[4]:  Pixel height in microns
work_out[5]:  Number of character heights (0: continous scaling)
work_out[6]:  Number of line types
work_out[7]:  Number of line widths (0: continous scaling)
work_out[8]:  Number of marker types
work_out[9]:  Number of marker heights (0: continous scaling)
work_out[10]: Number of accessible fonts
work_out[11]: Number of patterns
work_out[12]: Number of hatch styles
work_out[13]: Number of simultaneously displayed colors
              (e.g. 256 on an 8 bit screen)
work_out[14]: Number of GDPs
work_out[15] to work_out[24]:
              List of the supported GDPs. -1 indicates the end 
              of the list.
work_out[25] to work_out[34]:
              List of attributes associated with each GDP:
              0: Line
              1: Marker
              2: Text
              3: Fill area
              4: no attributes
work_out[35]: Color capability flag
work_out[36]: Text rotation capability flag
work_out[37]: Fill area capability falg
work_out[38]: CELLARRAY flag
work_out[39]: Number of color levels (0: more than 32767)
work_out[40]: Number of locator devices available
              1: Keyboard
              2: Keyboard and mouse (or other devices)
work_out[41]: Number of valuator devices available
              1: Keyboard
              2: another device is available
work_out[42]: Number of choice devices available
              1: Function keys
              2: another button pad
work_out[43]: Number of string devices available
              1: Keyboard
work_out[44]: Device type
              0: Output only
              1: Input only
              2: Input and Output
              4: Metafile output
work_out[45]: minimum character width
work_out[46]: minimum character height
work_out[47]: maximum character width
work_out[48]: maximum character height
work_out[49]: minimum line with
work_out[50]: 0
work_out[51]: maximum line width
work_out[52]: 0
work_out[53]: minimum marker width
work_out[54]: minimum marker height
work_out[55]: maximum marker width
work_out[56]: maximum marker height

If you open a NVDI printer or IMG driver, you can set the page size and
the GEMDOS output device. The Metafile driver ignores the page size
(it should be 0) but it uses the device name.

Variable         Arguments           Meaning
Input:

contrl[0]        1                   v_opnwk
contrl[1]        0                   entries in ptsin
contrl[3]        16                  entries in intin
contrl[6]        0 or 1
intin[0..15]     work_in[0..15]

Output:
as described above

Meaning of work_in[11..15]:
work_in[11]:   page size
               #define  PAGE_DEFAULT   0     /* use default setting */
               #define  PAGE_A3        1     /* DIN A3 */
               #define  PAGE_A4        2     /* DIN A4 */
               #define  PAGE_A5        3     /* DIN A5 */
               #define  PAGE_B5        4     /* DIN B5 */

               #define  PAGE_LETTER    16    /* Letter size */
               #define  PAGE_HALF      17    /* Half size */
               #define  PAGE_LEGAL     18    /* Legal size */
               #define  PAGE_DOUBLE    19    /* Double size */
               #define  PAGE_BROAD     20    /* Broad sheet size */

work_in[12/13]: pointer to a GEMDOS file name (C string) or 0L
work_in[14]:    0, reserved
work_in[15]:    0, reserved


ù CLOSE WORKSTATION (VDI 2)

"CLOSE WORKSTATION" closes a physical workstation.

If you call v_clswk() for a printer driver and if you have not called v_updwk() 
or v_clear_disp_list() before, buffered commands will be executed and sent to 
the printer.

Decl.:  void v_clswk( WORD handle );
Call:   v_clswk( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        2                   v_clswk
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù OPEN VIRTUAL SCREEN WORKSTATION (VDI 100)

"OPEN VIRTUAL SCREEN WORKSTATION" opens a virtual workstation on an already 
opened physical device (the screen). The attributes for each (virtual) 
workstation are maintained separately.

To open a virtual workstation you have call this function with the handle 
of the AES workstation which is returned by graf_handle:

  aes_handle = graf_handle(&gr_hwchar,&gr_hhchar,&gr_hwbox,&gr_hhbox);
  handle = aes_handle;

Decl.:  void v_opnvwk( WORD *work_in, WORD *handle, WORD *work_out );
Call:   v_opnvwk( work_in, &handle, work_out );

Variable         Arguments           Meaning
Input:

contrl[0]        100                 v_opnvwk
contrl[1]        0                   entries in ptsin
contrl[3]        11                  entries in intin
contrl[6]        handle              handle of the physical workstation
intin[0..10]     work_in[0..10]

Output:

contrl[2]        6                   entries in ptsout
contrl[4]        45                  entries in intout
contrl[6]        handle              handle of the virtual workstation
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

For a description of the input and output parameters see "OPEN WORKSTATION".


ù CLOSE VIRTUAL SCREEN WORKSTATION (VDI 101)

This function closes a virtual workstation.

Decl.:  void v_clsvwk( WORD handle );
Call:   v_clsvwk( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        101                 v_clsvwk
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:
contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù CLEAR WORKSTATION (VDI 3)

This function erases the screen or - if the device is a printer or 
plotter - advances the page and clears the printing buffer.

Deklaration: void v_clrwk( WORD handle );
Call:        v_clrwk( handle);

Variable         Arguments           Meaning
Input:

contrl[0]        3                   v_clrwk
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù CLEAR DISPLAY LIST (VDI 5, Escape 22)

This function for printer or plotter drivers clears the printing buffer 
(and deletes all previos commands). In contrast to CLEAR WORKSTATION it does 
not advance the page.
This function should be called if the user interrupts printing while your 
application generates the page.

Deklaration: void v_clear_disp_list( WORD handle );
Call:        v_clear_disp_list( handle);

Variable         Arguments           Meaning
Input:

contrl[0]        5                   v_escape
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        22                  v_clear_disp_list
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù UPDATE WORKSTATION (VDI 4)

"UPDATE WORKSTATION" starts output on devices like printers or plotters, which 
buffer VDI commands in a display list and do not execute them immediately.

The screen driver executes VDI commands immediately and therefore you do not 
have to call "UPDATE WORKSTATION".

Decl.:  void v_updwk( WORD handle );
Call:   v_updwk( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        4                   v_updwk
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù OPEN BITMAP (VDI 100, 1)

This function creates an offscreen bitmap on which can draw with VDI functions.
You can pass a pointer to a bitmap or otherwise the VDI will allocate the memory 
for it. The pixel sizes will be used to scale vector fonts, so that the aspect 
ratio and the proportions will be correct.

If your redraw (of a window region) is very complex or time consuming and causes 
a flickering on the screen, you should use an offscreen bitmap to create an image 
and then you should copy it to the screen via vrt_cpyfm() or vro_cpyfm().

Decl.:  void v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out );
Call:   v_opnbm( work_in, &bitmap, &handle, work_out );

Variable         Arguments           Meaning
Input:

contrl[0]        100                 v_opnbm
contrl[1]        0                   entries in ptsin
contrl[3]        20                  entries in intin
contrl[5]        1                   v_opnbm
contrl[6]        handle              handle of the physical workstation
contrl[7..8]     bitmap              pointer to the MFDB of the bitmap
intin[0..19]     work_in[0..19]

Output:

contrl[2]        6                   entries in ptsout
contrl[4]        45                  entries in intout
contrl[6]        handle              handle of the bitmap
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Meaning of work_in:
work_in[0..10]:   see v_opnwk()/v_opnvwk()
work_in[11]:      width -1 (e.g. 1279)
work_in[12]:      height -1 (e.g. 959)
work_in[13]:      pixel width in microns
work_in[14]:      pixel height in microns
work_in[15..19]:  must be 0 (!!) if you want to create a bitmap in 
                  device specific format

Meaning of <bitmap>:
<bitmap> is a pointer to a MFDB. If bitmap->fd_addr is zero, the VDI will 
allocate memory for the bitmap according to the width an height in work_on
(and the bitmap will be erased).

To create a bitmap in device specific format, bitmap->fd_nplanes has to be 
zero or the number of planes of the screen (returned by vq_extnd() in
work_out[4]). If bitmap->fd_nplanes is 1, the VDI creates a monochrome 
bitmap.

The structure members of the MFDB (fd_addr, fd_w, fd_h, fd_wdwidth, fd_stand, 
fd_nplanes) will be initialized by the VDI driver and returned to the calling 
application. If there is not enough memory for the bitmap, the MFDB will not
be changed and a zero-handle will be returned.

If bitmap->fd_addr is a nonzero value, the VDI will use it as a poninter to 
a bitmap and if the bitmap is in standard format, it will be transformed to 
the device specific format.
If v_opnbm() does not support the requested format of the bitmap (that means 
the number of colors, planes and the organisation), a zero-handle will 
indicate an error.

If the EdDI cookie has version number 1.1 or newer, v_opnbm() takes 
additional arguments in work_in[15..19] into account:
Ab EdDI 1.1 kann v_opnbm() mit zus„tzlichen Parametern in work_in[15..19]
aufgerufen werden. Es wird dann versucht, eine Bitmap in dem durch diese
Parameter beschriebenen Format zu ”ffnen. Sollte fr das angegebene Format kein
Treiber vorhanden sein, kann die Bitmap nicht erzeugt werden.

work_in[15..16]:  number of simultaneously displayable colors
work_in[17]:      number of planes
work_in[18]:      pixel format
work_in[19]:      bit order

For a more detailed description of the pixel format and bit order see vq_scrninfo().


ù CLOSE BITMAP (VDI 101, 1)

This function closes an offscreen bitmap. If the VDI has allocated the memory
for the bitmap, this call frees the memory.

Decl.:  void v_clsbm( WORD handle );
Call:   v_clsbm( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        101                 v_clsbm
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        1                   v_clsbm()
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù EXTENDED INQUIRE FUNCTION (VDI 102)

This function either returns the output arguments of v_opnwk()/v_opnvwk() or 
additional device-specific information.

Decl.:  void vq_extnd( WORD handle, WORD flag, WORD *work_out );
Call:   vq_extnd( handle, owflag, work_out );

Variable         Arguments           Meaning
Input:

contrl[0]        102                 vq_extnd
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         flag                information type

Output:

contrl[2]        6                   entries in ptsout
contrl[4]        45                  entries in intout
intout[0..44]    work_out[0..44]
ptsout[0..11]    work_out[45..56]

Meaning of flag:
0: return v_opnwk()/v_opnvwk() values
1: return additional information

Meaning of work_out:
work_out[0]:  type of screen
              0: no screen
              1: separate alpha and graphic controllers and
                 separate video memory
              2: separate alpha and graphic controllers with
                 shared video memory
              3: common video an graphic controller with 
                 separate video memory
              4: common alpha and graphic controller with
                 shared video memory
work_out[1]:  number of color levels (refers to the CLUT)
work_out[2]:  supported text effects
work_out[3]:  raster scaling flag
              0: scaling impossible
              1: scaling possible
work_out[4]:  number of planes
work_out[5]:  CLUT flag
              0: no CLUT
              1: CLUT or pseudo-CLUT (true color) exists
work_out[6]:  performance factor
work_out[7]:  contour fill capability (v_contourfill)
              0: not supported
              1: contour fill supported
work_out[8]:  text rotation ability
              0: none
              1: in steps of 90 degree only
              2: in steps of 1/10 degree
work_out[9]:  number of writing modes
work_out[10]: available input levels
              0: none
              1: request
              2: request and sample
work_out[11]: text alignment flag
              0: not available
              1: available
work_out[12]: inking capability flag
              0: device cannot ink
              1: device can ink
work_out[13]: rubberbanding capability flag
              0: no
              1: capable of rubberband lines
              2: capable of rubberband lines and rectangles
work_out[14]: maximum number of input vertices or -1 (unlimited)
work_out[15]: maximum number of intin arguments or -1 (no limit)
work_out[16]: number of mouse keys
work_out[17]: line types for wide lines
              0: no
              1: yes
work_out[18]: number fo writing modes for wide lines
work_out[19]: clipping flag
              0: clipping off
              1: clipping on
work_out[20]: 0: extend precision pixel size information is not available
              1: pixel size is in 1/10 microns
              2: pixel size is in 1/100 microns
              3: pixel size is in 1/1000 microns

work_out[21]: pixel width in 1/10, 1/100 or 1/1000 microns
work_out[22]: pixel height in 1/10, 1/100 or 1/1000 microns
work_out[23]: horizontal resolution in dpi
work_out[24]: vertical resolution in dpi
work_out[28]: bezier flag (bit 1)
              0: driver has not bezier capability
              1: driver has bezier capability

work_out[30]: raster flag (bit 0)
              0: no scaling              
              1: vrt/vro_cpyfm() is capable of scaling bitmaps

work_out[40]: not imprintable left border in pixels (printers/plotters)
work_out[41]: not imprintable upper border in pixels (printers/plotters)
work_out[42]: not imprintable right border in pixels (printers/plotters)
work_out[43]: not imprintable lower border in pixels (printers/plotters)

work_out[44]: page size (printers etc.), see v_opnwk()/vs_page_size()

work_out[45..48]: clipping rectangle

Note:
If work_out[20] contains a nonzero value, work_out[21..24] and work_out[40..43] 
will contain extended information about pixel size and not imprintable borders.
Usually margins only are returned for printer drivers due to mechanical 
limitations of the printer. Applications should take the margins into account 
to center the document correctly and they should display the margins on screen.

The addressable raster size returned by v_opnwk() (work_in[0/1]) is the area 
that can be imprinted. That means the upper left corner (0,0) of the imprintable 
page has a distance of (work_out[40], work_out[41]) pixels from the upper left 
corner of the physical sheet of paper.

If a driver returns more precise pixel sizes, this information should be used 
to calculate the position of graphic objects for printing. In worst case using
the values from v_opnwk() in work_out[3/4] can result in a positioning inaccuracy 
of 2 or 3 mm (for output on a DIN A4 page).

The original ATARI VDI does not return the clipping flag (work_out[19]), but it
returns the clipping rectangle.

You should not use the bezier flag (work_out[28]) to determine if the driver 
is capable of generating bezier curves because some drivers have bezier 
support but do not return the bezier flag. We recommend to use v_bez_on()!


ù INQUIRE SCREEN INFORMATION (VDI 102, 1)

"INQUIRE SCREEN INFORMATION" returns extended information about the bitmap 
format of the device (the device-specific format).

Decl.:  void vq_scrninfo( WORD handle, WORD *work_out );
Call:   vq_scrninfo( handle, work_out );

Variable         Arguments           Meaning
Input:

contrl[0]        102                 vq_scrninfo
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[5]        1                   vq_scrninfo()
contrl[6]        handle
intin[0]         2                   erweiterte Informationen ausgeben

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        272                 entries in intout
intout[0..272]   work_out[0..272]    erweiterte Informationen

Meaning of work_out:
work_out[0]:   pixel format
               0: interleaved planes, organized in words (ATARI)
               1: standard format (whole planes)
               2: packed pixels
               -1: unknown format; not accessible
work_out[1]:   CLUT flag
               0: no CLUT (e.g. TTM 194)
               1: hardware CLUT
               2: software CLUT (HiColor or TrueColor)
work_out[2]:   number of planes (bits) per pixel
work_out[3/4]: number of colors or 0L (more than 2*10^31 colors)
work_out[5]:   line width in bytes (since EdDI 1.1)
work_out[6/7]: address of the bitmap (since EdDI 1.1)
work_out[8]:   number of bits for red levels
work_out[9]:   number of bits for green levels
work_out[10]:  number of bits for blue levels
work_out[11]:  number of bits for alpha channel
work_out[12]:  number of bits for genlock
work_out[13]:  number of unused bits
work_out[14]:  bit order (since EdDI 1.1)

               2-256 colors:

               bit number| description
               ----------|--------------------------------------------------
                  0      | usual bit order

               32768 colors (16 planes):

               bit number| description
               ----------|--------------------------------------------------
                  0      | usual bit order: 1 bit overlay (or unused),
                         | 5 bits red, 5 bits green, 5 bits blue
                         | (xrrrrrgg-gggbbbbb)
                         |
                  1      | Falcon bit order: 5 bits red, 5 bits green,
                         | 1 bit overlay, 5 bits blue
                         | (rrrrrggg-ggxbbbbb)
                         |
                  7      | swapped bytes (intel order)
                         | e.g. Crazy Dots (gggbbbbb-xrrrrrgg)

               65536 colors (16 planes):

               bit number| description
               ----------|--------------------------------------------------
                  0      | usual bit order: 5 bits red, 6 bits green, 
                         | 5 bits blue (rrrrrggg-gggbbbbb)
                         |
                  7      | swapped bytes (intel order)
                         | e.g. Crazy Dots 2 (gggbbbbb-rrrrrggg)

               16777216 colors (24 planes):

               bit number| description
               ----------|--------------------------------------------------
                  0      | usual bit order: 8 bits red, 8 bits green,
                         | 8 bits blue (rrrrrrrr-gggggggg-bbbbbbbb)
                         |
                  7      | swapped bytes (intel order)
                         | (bbbbbbbb-gggggggg-rrrrrrrr)

               16777216 colors (32 Planes):

               bit number| description
               ----------|--------------------------------------------------
                  0      | usual bit order, 8 bits overlay or unused, 
                         | 8 bits red, 8 bits green, 8 bits blue
                         | (xxxxxxxx-rrrrrrrr-gggggggg-bbbbbbbb)
                         |
                  7      | swapped bytes (intel order)
                         | (bbbbbbbb-gggggggg-rrrrrrrr-xxxxxxxx)

If a hardware CLUT (intout[1] == 1) exists:
work_out[16-271]: pixel value of the corresponding VDI color index (0-255)

In case of HiColor, TrueColor...:
work_out[16..31]:    bit number of the pixel associated with the bit number of 
                     the intensity level of red
work_out[32..47]:    bit number of the pixel associated with the bit number of 
                     the intensity level of green
work_out[48..63]:    bit number of the pixel associated with the bit number of 
                     the intensity level of blue
work_out[64..79]:    bit numbers for alpha channel
work_out[80..95]:    bit numbers for genlock
work_out[96..127]:   unused bits
work_out[128..271]:  reserved (0)

   Examples:
   ----------

   256 colors on the Falcon:

   work_out | value  | description
   ---------|--------|-----------------------------------------------------
      0     |   0    | interleaved Planes, (words)
      1     |   1    | hardware CLUT
      2     |   8    | 8 bits per pixel
      3/4   | 256    | 256 simultaneously displayable colors
      5     | xxxx   | width of the bitmap in bytes (since EdDI 1.1)
      6/7   | xxxxL  | address of the bitmap (since EdDI 1.1)
      8     |   6    | CLUT has 6 bits for red intensity
      9     |   6    | CLUT has 6 bits for green intensity
     10     |   6    | CLUT has 6 bits for blue intensity
     11     |   0    | no alpha channel
     12     |   0    | no genlock
     13     |   0    | no unused bits
     14     |   1    | usual bit order (since EdDI 1.1)
            |        |
     16     |   0    | pixel value for VDI color index 0
     17     | 255    | pixel value for VDI color index 1
     18     |   2    | pixel value for VDI color index 2
     ...    | ...    |
    271     |  15    | pixel value for VDI color index 255

   HiColor on the Falcon:

   work_out | value  | description
   ---------|--------|-----------------------------------------------------
      0     |   2    | packed pixels
      1     |   2    | HiColor (TrueColor:-) => pseudo CLUT
      2     |  16    | 16 bits per pixel
      3/4   | 32768  | 32768 colors
      5     | xxxx   | width of the bitmap in bytes (since EdDI 1.1)
      6/7   | xxxxL  | address of the bitmap (since EdDI 1.1)
      8     |   5    | 5 bits for red intensity
      9     |   5    | 5 bits for green intensity 
     10     |   5    | 5 bits for blue intensity
     11     |   0    | no alpha channel
     12     |   1    | 1 bit for genlock (overlay)
     13     |   0    | no unused bits
     14     |   2    | Falcon bit order (rrrrrggg-ggxbbbbb ; since EdDI 1.1)
            |        |
     16     |  11    | bit 0 of the red intensity (least significant bit)
            |        | is bit 11 of the pixel
     17     |  12    | bit 1 of the red intensity ist bit 12 of the pixel
     18     |  13    | ...
     19     |  14    | ...
     20     |  15    | bit 4 of the red intensity (most significant bit)
            |        | is bit 15 of the pixel
     21..31 |  -1    | bits are not used
            |        |
            |        |
     32     |   6    | bit 0 of the green intensity (least significant bit)
            |        | is bit 6 of the pixel
     33     |   7    | bit 1 of the green intensity ist bit 7 of the pixel
     34     |   8    | ...
     35     |   9    | ...
     36     |  10    | bit 4 of the green intensity (most significant bit)
            |        | is bit 10 of the pixel
     37..37 |  -1    | bits are not used
            |        |
            |        |
     48     |   0    | bit 0 of the blue intensity (least significant bit)
            |        | is bit 0 of the pixel
     49     |   1    | bit 1 of the blue intensity is bit 1 of the pixel
     50     |   2    | ...
     51     |   3    | ...
     52     |   4    | bit 4 of the blue intensity (most significant bit)
            |        | is bit 4 of the pixel
     53..63 |  -1    | bits are not used
            |        |
            |        |
     64..79 |  -1    | no alpha channel
            |        |
            |        |
     80     |   5    | bit for genlock/overlay
     81..95 |  -1    | not used
            |        |
            |        |
     96..127|  -1    | no unused bits
            |        |

   HiColor on a VGA graphic card (e.g. Crazy Dots):

   work_out | Wert   | Meaning
   ---------|--------|-----------------------------------------------------
      0     |   2    | packed pixels
      1     |   2    | HiColor => pseudo CLUT
      2     |  16    | 16 bits per pixel
      3/4   | 32768  | 32768 colors
      5     | xxxx   | width of the bitmap in bytes (since EdDI 1.1)
      6/7   | xxxxL  | address of the bitmap (since EdDI 1.1)
      8     |   5    | 5 bits for red intensity
      9     |   5    | 5 bits for green intensity 
     10     |   5    | 5 bits for blue intensity
     11     |   0    | no alpha channel
     12     |   1    | no genlock/overlay
     13     |   0    | 1 unused bits
     14     |  129   | swapped bit order (gggbbbbb-xrrrrrgg; since EdDI 1.1)
            |        |
     16     |   2    | bit 0 of the red intensity (least significant bit)
            |        | is bit 2 of the pixel
     17     |   3    | bit 1 of the red intensity is bit 3 of the pixel
     18     |   4    | ...
     19     |   5    | ...
     20     |   6    | bit 4 of the red intensity (most significant bit)
            |        | is bit 6 of the pixel
     21..31 |  -1    | bits are not used
            |        |
            |        |
     32     |  13    | bit 0 of the green intensity (least significant bit)
            |        | is bit 13 of the pixel
     33     |  14    | bit 1 of the green intensity is bit 14 of the pixel
     34     |  15    | ...
     35     |   0    | ...
     36     |   1    | bit 4 of the green intensity (most significant bit)
            |        | is bit 1 of the pixel
     37..37 |  -1    | bits are not used
            |        |
            |        |
     48     |   8    | bit 0 of the blue intensity (least significant bit)
            |        | is bit 8 of the pixel
     49     |   9    | bit 1 of the blue intensity is bit 9 of the pixel
     50     |  10    | ...
     51     |  11    | ...
     52     |  12    | bit 4 of the green intensity (most significant bit)
            |        | is bit 12 of the pixel
     53..63 |  -1    | bits are not used
            |        |
            |        |
     64..79 |  -1    | no alpha channel
            |        |
            |        |
     80..95 |  -1    | no genlock/overlay
            |        |
            |        |
     96     |   7    | bit 7 is an unused bit
     97..127|  -1    | no further unused bits
            |        |

Note:
The output in work_out[5..7/14] only exist since EdDI 1.1. Check the cookie 
version before you use them.


ù INQUIRE DEVICE STATUS INFORMATION (VDI 248)

Vq_devinfo() reports back, if a driver exists and if he has been opened.
Besides the name of the driver (e.g. "XVGA256.SYS") and the 'readable' name 
("VGA 256 colors") are returned. If the file name is empty, there is no 
driver with the given id <device>.

Decl.:  void  vq_devinfo( WORD handle, WORD device, WORD *dev_open,
                          BYTE *file_name, BYTE *device_name );
Call:   vq_devinfo( handle, device, &dev_open, file_name, device_name );

Variable         Arguments           Meaning
Input:

contrl[0]        248                 vq_devinfo
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         device              device id (0-99)

Output:

contrl[2]        p                   number of _WORDS_ in ptsout
contrl[4]        i                   number of words in intout

ptsout[0]        dev_open            0: driver is closed
                                     1: driver is already open
ptsout[1..p-1]   device_name         readable device name
intout[0..i-1]   file_name           file name

Note:
The file name is returned with one word per character and contrl[4] is the 
length of the string. The readable name is a C string terminated with a 
zero and contrl[2] contains the number of words in ptsout.


ù INQUIRE EXTENDED DEVICE STATUS INFORMATION (VDI 248, 4242)

Similar to vq_devinfo() the function vq_ext_devinfo() returns information 
about the driver.

Decl.:  WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                              BYTE *file_path, BYTE *file_name, BYTE *name );

Call:   dev_open = vq_ext_devinfo( handle, device, &dev_exists, file_path,
                                   file_name, name );

Variable         Arguments           Meaning
Input:

contrl[0]        248                 vq_devinfo
contrl[1]        0                   entries in ptsin
contrl[3]        7                   entries in intin
contrl[5]        4242                sub-opcode
contrl[6]        handle
intin[0]         device              device id (0-99)
intin[1/2]       file_path           pointer to the file path
intin[3/4]       file_name           pointer to the file name
intin[5/6]       name                pointer to the device name

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        dev_exists          0: no driver
                                     != 0: driver exists
intout[1]:       dev_open            0: driver is closed
                                     != 0: driver is already open

All strings are C strings!


Particularities of certain Drivers
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
ù Change of Printer name, type or resolution

   If a driver's settings have been changed, the driver CPX sends an AES message 
   called PRN_CHANGED.

   #define  PRN_CHANGED 82

   mbuf[0] = PRN_CHANGED;
   mbuf[1] = app_id;
   mbuf[2] = 0;
   mbuf[3] = id;              /* Device ID */
   mbuf[4] = 1;               /* change */
   mbuf[5] = 0;
   mbuf[6] = 0;
   mbuf[7] = 0;

ù Printer Drivers - Device ID 21 - 30

   If you open a NVDI printer driver via v_opnwk() you can specify the page size 
   and the gemdos device. The following parameters have to changed:

   contrl[3]   16

   intin[11]         page size
                     #define  PAGE_DEFAULT   0     /* use default setting */
                     #define  PAGE_A3        1     /* DIN A3 */
                     #define  PAGE_A4        2     /* DIN A4 */
                     #define  PAGE_A5        3     /* DIN A5 */
                     #define  PAGE_B5        4     /* DIN B5 */

                     #define  PAGE_LETTER    16    /* Letter size */
                     #define  PAGE_HALF      17    /* Half size */
                     #define  PAGE_LEGAL     18    /* Legal size */
                     #define  PAGE_DOUBLE    19    /* Double size */
                     #define  PAGE_BROAD     20    /* Broad sheet size */

   intin[12/13]      pointer to a GEMDOS file name (C string) or 0L
   intin[14]   0     reserved
   intin[15]   0     reserved

   To determine, if the page size was set to the specified value, you can call 
   vq_extnd().

   NOT A GOOD A IDEA:   
   You can set width and height of the printer bitmap by storing (width-1)/ 
   (height-1) in ptsin[0/1] and 1 in contrl[1]. A subsequent call of v_opnwk() 
   or vq_extnd() (if you have already opened the printer driver) will change the 
   bitmap size. This method is not to be recommended because an application is 
   not able to determine, if the printer is able to print a page with the 
   specified size.

   Printing Bitmaps
   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
   Use the functions vrt/vro_cpyfm() to print (color-) bitmaps. With a NVDI 
   printer driver (and IMG driver, ...) you can use in the same way as with the 
   screen driver. The sole difference is, that you cannot move rasters within 
   the printer bitmap (source- and destination-MFDB with fd_addr == 0L). Since 
   moving within the device bitmap does not make sense if you want to print 
   something, this difference is not a restcriction.
   
   If necessary (not enough memory) the printer driver will buffer the bitmap in 
   the display list. Therefore you do not have to keep the bitmap in memory 
   until you call v_updwk().

   If you have to scale a bitmap, you should not do it on your own - let 
   vrt/vro_cpyfm() do the work for you. If vrt/vro_cpyfm() does the scaling, the 
   output quality can be increased, less data has to be spooled onto your hard 
   disk and printing becomes faster. Drivers capable of scaling bitmaps signify 
   this ability at vq_extnd().
   
   In 8-color-mode you should use a color correction function for bitmaps before 
   you start dithering. The easiest (and usually sufficient) way is to use a 
   gamma function with an exponent between 0,3 and 0,4 which prevents the image 
   from looking too dark and too gray.

   In true color mode the driver performs color correction, black separation and 
   other quality improvements for you - bitmaps should be sent to driver without 
   color transformation and without quantization or rasterization.
 
   Bitmap Format
   ÿÿÿÿÿÿÿÿÿÿÿÿÿ
   vq_scrninfo() returns the format of the printer bitmap as well as the format 
   for the screen. In general, there are only 3 different formats for printers:
   
      (1) Monochrome bitmap, if the drivers has 2 colors.
      
      (2) Three planes after another, if the driver has 8 colors.

      (3) Packed pixels with 32 bits, if driver runs in true color mode.
   
   While formats (1) and (3) do not have to be explained, format (2) will be 
   explained in the following lines:
   
   A bitmap with eight colors consists of three complete planes, one after 
   another in memory. In this case the device specific format is the same as the 
   standard format. The mapping of VDI index to pixel value is done according to 
   the standard mapping, which all VDI drivers use for the first 8 or 16 colors:
   
   VDI color index   Pixel value       Color
   0                 0 (000)           white
   1                 7 (111)           black
   2                 1 (001)           red
   3                 2 (010)           green
   4                 4 (100)           blue
   5                 6 (110)           cyan
   6                 3 (011)           yellow
   7                 5 (101)           magenta
   
   Pixel value       VDI color index   Color
   0 (000)           0                 white
   1 (001)           2                 red
   2 (010)           3                 green
   3 (011)           6                 yellow
   4 (100)           4                 blue
   5 (101)           7                 magenta
   6 (110)           5                 cyan
   7 (111)           1                 black

   vrt/vro_cpyfm() and older printer drivers
   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
   In older printer drivers, vrt/vro_cpyfm() has a bug which eventually prevents 
   the output of bitmaps with a height of one line. Therefore a bitmap should 
   consist of at least two lines.


ù META.SYS - Device ID 31

   The metafile driver saves all VDI calls with its handle in a metafile, which 
   is placed in the application's active path and has the default name 
   GEMFILE.GEM. To change the name you should call vm_filename() directly after 
   v_opnwk() and pass a file name with absolute path to it. 
   Do not forget to call v_meta_extents(), vm_pagesize() and vm_coords() to 
   set the size and resolution of page - otherwise programs might have problems 
   to display the metafile correctly.

ù MEMORY.SYS - Device ID 61

   The memory driver is rather more a monochrome bitmap than a special device. 
   You specify the bitmap's size when you call v_opnwk(). Width - 1 and Height - 1
   are stored in ptsin[0/1] and contrl[1] must be 1. If there is enough memory 
   a valid handle will be returned and contrl[0/1] will contain the bitmap address.
   To change the resolution you can call vq_extnd(). If you want to use your 
   own buffer for the bitmap, you should store 3 in contrl[3] and the buffer's 
   address in intin[1/2].
   
   We recommend to use offscreen bitmaps instead of the memory driver because 
   they offer more possibilities and higher flexibility.
   
ù IMG.SYS - Device ID 91 - 99

   As well as the NVDI printer drivers the image driver allows you to set the 
   page size and the file name.

   An additional way to set the file name is to call vq_extnd:

   contrl[1] = 4;
   ptsin[2] = 1157;
   ptsin[3/4] = pointer to the file name (BYTE *);
   ptsin[5/6] = pointer to an error variable (WORD *);
   ptsin[7] = 0;

ù  Fax Drivers - usually ID 81 - 90

   Fax drivers work similar to printer drivers, but you are not able to change 
   the page size nor the GEMDOS device. You should not try to change their 
   bitmap's size either.




Color Settings
==============

ù SET COLOR REPRESENTATION (VDI 14)

This function sets the RGB color associated with a color index. The intensity 
of red, green and blue is set in per mille (0-1000). If the device driver has 
a CLUT, the new setting will immediately change the color of all pixels with 
color index <index>.

If a device has more than 256 simultaneously displayable colors, it usually 
does not have a CLUT. In this case the pixels do not contain a color value or 
index but a direct color value in RGB (e.g. a pixel with 32 bits has 8 unused 
bits, 8 bits for red, 8 bits for green and 8 bits for blue). This means that
the VDI creates a pseudo CLUT with 256 pens and calling vs_color() for one of 
these pens will not change the color of the pixels which have been drawn with 
this pen, but it will change the color of new pixels drawn with this pen. 
Note that the palettes are handled per workstation which means, that each 
workstation has its own palette (pseudo CLUT) and changing the RGB value for 
a color index on one workstation will not change the value of the same pen 
in another workstation. 

Decl.:  void vs_color( WORD handle, WORD index, RGB1000 *rgb_in );
Call:   vs_color( handle, index, &rgb_in );

Variable         Arguments           Meaning
Input:

contrl[0]        14                  vs_color
contrl[1]        0                   entries in ptsin
contrl[3]        4                   entries in intin
contrl[6]        handle
intin[0]         index               color index (pen)
intin[1..3]      rgb_in              intensity of red, green, blue

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù INQUIRE COLOR REPRESENTATION (VDI 26)

"INQUIRE COLOR REPRESENTATION" returns the RGB color intensity for a color
index. You can either request the realized intensities or you can get the 
intensities you tried to set with vs_color().

Decl.:  WORD vq_color( WORD handle, WORD color_index, WORD flag,
                       RGB1000 *rgb_out );
Call:   valid = vq_color( handle, color_index, set_flag, &rgb_out );

Variable         Arguments           Meaning
Input:

contrl[0]        26                  vq_color
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         color_index         color index (pen)
intin[1]         flag                flag

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        4                   entries in intout
intout[0]        valid               color index
intout[1..3]     rgb_out             intensity of red, green, blue

Meaning of flag:
0: return color values requested at vs_color()
1: return realized color values

Note:
The color value you try to set via vs_color() can differ form the realized 
color value because a CLUT usually has less than 1000 levels per color 
component (e.g. 8 bit - 256 levels - per component).
Most drivers for direct color devices return only the realized RGB value 
because the number of levels is sufficient.


ù SET CALIBRATION (VDI 5, ESCAPE 76)

SET CALIBRATION switcher color calibration on or off and can be used to set 
a calibration table.
Before you call this function you should check if it exists (call 
vq_calibrate()).

Decl.:  WORD vs_calibrate( WORD handle, WORD flag, RGB1000 *table );
Call:   cal_flag = vs_calibrate( handle, flag, &table );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   v_escape()
contrl[1]        0                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[5]        76                  sub-opcode vs_calibrate()
contrl[6]        handle
intin[0..1]      table               pointer to calibration table or 0L
intin[2]         flag                calibration off (0) or on (1)
Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        cal_flag            calibration off (0) or on (1)

Note:
The calibration table is used for each workstation of the device driver. 
Therefore the calibration should only be changed by CPX modules or accessories.


ù INQUIRE CALIBRATION (VDI 5, ESCAPE 77)

This function reporst back, if vs_calibrate() exists and if calibration is 
switched on. If contrl[4] is zero, vs_calibrate() is not supported by the 
driver.

Decl.:  WORD vq_calibrate( WORD handle, WORD *flag );
Call:   exists = vq_calibrate( handle, &flag );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   v_escape()
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        77                  sub-opcode vq_calibrate()
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        exists              entries in intout (0 or 1)
intout[0]        flag                calibration aus (0) or ein (1)





Writing Modes and Clipping
==========================

ù SET WRITING MODE (VDI 32)

This function selects the writing mode for graphic operations. If you try to 
select a mode number which is out of range, mode 1 (REPLACE) will be selected.

Decl.:  WORD vswr_mode( WORD handle, WORD mode );
Call:   set_mode = vswr_mode( handle, mode );

Variable         Arguments           Meaning
Input:

contrl[0]        32                  vswr_mode
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         mode                requested writing mode

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_mode            selected writing mode

Meaning of mode:
1, REPLACE:          
2, TRANSPARENT:
3, XOR:
4, REV. TRANSPARENT:


ù SET CLIPPING RECTANGLE (VDI 129)

You can limit the area for graphic operations by calling this function. If 
you enable clipping graphic operations will only take place in the clipping 
rectangle.

Decl.:  void vs_clip( WORD handle, WORD clip_flag, WORD *area );
Call:   vs_clip( handle, clip_flag, area );

Variable         Arguments           Meaning
Input:

contrl[0]        129                 vs_clip
contrl[1]        2                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         clip_flag           0: clipping off, 1: clipping on
ptsin[0..3]      area[0..3]          clipping rectangle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Note:
Do not switch off clipping because a graphic object which is drawn outside 
of the visible screen area will overwrite memory or cause a bus error.




Lines and unfilled Graphic Primitives
=====================================

ù POLYLINE (VDI 6)

"POLYLINE" connects all points in <xyarr> with lines.

Decl.:  void v_pline( WORD handle, WORD count, WORD *xyarr );
Call:   v_pline( handle, count, xyarr );

Variable         Arguments           Meaning
Input:

contrl[0]        6                   v_pline
contrl[1]        n                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù OUTPUT BEZIER (VDI 6, 13)

This function draws an unfilled bezier curve.

Decl.:  void v_bez( WORD handle, WORD count, WORD *xyarr, char *bezarr,
                    WORD *extent,int *totpts, WORD *totmoves );

Call:   v_bez( handle, count, xyarr, bezarr, extent, totpts, totmoves );

Variable         Arguments           Meaning
Input:

contrl[0]        6                   v_bez
contrl[1]        n                   entries in ptsin
contrl[3]        (n+1)/2             entries in intin
contrl[5]        13                  sub-opcode v_bez
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      coordinates
intin[0..(n+1)/2-1] bezarr[0..n-1]   point-type flags

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        6                   entries in intout

intout[0]        totpts              number of points in the resulting polygon
intout[1]        totmoves            number of moves in the polygon
intout[2..5]                         reserved
ptsout[0..3]     extent[0..3]        coordinates of the bounding box

Meaning of the point-type flags:
bit 0:   first point in a 4-point bezier curve (two anchor points and two
         direction points). The last point of a bezier segment can be the 
         first point of the next bezier curve (or it can be a jump point).

bit 1:   jump point - this point and the previous one will not be connected.

Bit 2-7 are reserved. If bit 0 is 0, v_bez() works like v_pline() and draws 
a straight line between two points.

Note:
The binding for this function has to swap the bytes in intin because 
unfortunately this function is compatible with PC-GEM.
=> bezarr[0] is the low byte of intin[0] bezarr[1] is the high byte of
intin[0]...


ù ARC (VDI 11, GDP 2)

"ARC" draws an arc, whose start and end angle can be set in tenths of 
degrees from 0 to 3600.

Decl.:  void v_arc( WORD handle, WORD x, WORD y, WORD radius,
                    WORD begang, WORD endang );
Call:   v_arc( handle, x, y, radius, begang, endang );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        4                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        2                   v_arc
contrl[6]        handle
intin[0]         begang              start angle
intin[1]         endang              end angle
ptsin[0]         x
ptsin[1]         y
ptsin[6]         radius              radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ELLIPTICAL ARC (VDI 11, GDP 6)

This function draw an elliptical arc, whose start and end angle can be set
in tenths of degrees from 0 to 3600.

Decl.:  void v_ellarc( WORD handle, WORD x, WORD y, WORD x_radius,
                       WORD y_radius, WORD begang, WORD endang );
Call:   v_ellarc( handle, x, y, x_radius, y_radius, begang, endang );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        6                   v_ellarc
contrl[6]        handle
intin[0]         begang              start angle
intin[1]         endang              end angle
ptsin[0]         x
ptsin[1]         y
ptsin[2]         xradius             horizontal radius
ptsin[3]         yradius             vertical radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ROUNDED RECTANGLE (VDI 11, GDP 8)

This function draws an unfilled rectangle with rounded corners.

Decl.:  void v_rbox( WORD handle, WORD *rect );
Call:   v_rbox( handle, rect );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        8                   v_rbox
contrl[6]        handle
ptsin[0..3]      rect[0..3]          coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ENABLE BEZIER CAPABILITIES (VDI 11, GDP 13)


After calling v_bez_on(), you can call v_bez()/v_bez_fill() without a 
sub-opcode in contrl[5]. This function exists only for compatibility reasons 
and usually it is only used in old GEM/3 metafiles.

Applications should only use this call to determine, if the driver is able
to draw bezier curves (clear intout[0] before you call v_bez_on() and check 
if the return value indicates bezier support).

Decl.:  WORD v_bez_on( WORD handle );
Call:   retval = v_bez_on( handle );

Variable         Arguments        Meaning
Input:

contrl[0]        11               GDP
contrl[1]        1                entries in ptsin - v_bez_on
contrl[3]        0                entries in intin
contrl[5]        13               v_bez_on
contrl[6]        handle

Output:

intout[0]        retval           bezier depth

Meaning of retval:
<retval> ist a value between 0 (no beziers) and 7 (maximum quality) and 
represents the bezier depth. You should only use this value to determine if 
the driver is able to draw bezier curves.


ù DISABLE BEZIER CAPABILITIES (VDI 11, GDP 13)

This function exists only for compatibility reasons. It switches off the 
special treatment of v_bez()/v_bez_fill().

Decl.:  void v_bez_off( WORD handle );
Call:   v_bez_off( handle );

Variable         Arguments        Meaning
Input:

contrl[0]        11               GDP
contrl[1]        0                entries in ptsin - v_bez_off
contrl[3]        0                entries in intin
contrl[5]        13               v_bez_off
contrl[6]        handle

Output:

-


ù SET BEZIER QUALITY (VDI 5, ESCAPE 99)

This call specifies the  quality and accuracy of the bezier curves. You can 
select the quality in a range between 0 and 100 per cent. 

Decl.:  WORD v_bez_qual( WORD handle, WORD qual, WORD *set_qual );
Call:   v_bez_qual( handle, qual, &set_qual );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[5]        99
contrl[6]        handle
intin[0]         32                  intin[0..1] signaliseren v_bez_qual()
intin[1]         1
intin[2]         qual                requested bezier quality

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_qual            realized bezier quality


ù SET POLYLINE LINE TYPE (VDI 15)

"SET POLYLINE LINE TYPE" sets the line type for polyline operations. If the 
requested line type is not available, line type 1 will be selected (solid).

Decl.:  WORD vsl_type( WORD handle, WORD type );
Call:   set_type = vsl_type( handle, type );

Variable         Arguments           Meaning
Input:

contrl[0]        15                  vsl_type
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         type                requested line type

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_type            realized line type

Meaning of type:
1: %1111111111111111  (solid line)
2: %1111111111110000  (long dash)
3: %1110000011100000  (dots)
4: %1111111100011000  (dash, dot)
5: %1111111100000000  (dash)
6: %1111000110011000  (dash, dot, dot)
7: user-defined, via vsl_udsty()


ù SET POLYLINE LINE WIDTH (VDI 16)

This call sets the width of lines for polyline operations. The realized line 
width is always an odd value (1, 3, 5 or ...) which means that even values are 
rounded down. Most device drivers ignore the line type and draw solid lines 
if the line is more than one pixel wide.

Decl.:  WORD vsl_width( WORD handle, WORD width );
Call:   set_width = vsl_width( handle, width );

Variable         Arguments           Meaning
Input:

contrl[0]        16                  vsl_width
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0]         width               requested line width

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0]        set_width           selected line width

Note:
The line width is always in relation to the horizontal pixel size
(if the aspect ratio is not 1:1, the height is corrected so that a
horizontal and a vertical line seem to have the same width, though 
horizontal and vertical pixel size are different - e.g. in ST mid ). 


ù SET POLYLINE COLOR INDEX (VDI 17)

...sets the color index for lines. If the index is invalid, color index 1
will be selected.

Decl.:  WORD vsl_color( WORD handle, WORD color_index );
Call:   set_color = vsl_color( handle, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        17                  vsl_color
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         color_index         requested line color

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_color           realized line color


ù INQUIRE CURRENT POLYLINE ATTRIBUTES (VDI 35)

This function returns the current line attributes.

Decl.:  void vql_attributes( WORD handle, WORD *attrib );
Call:   vql_attributes( handle, attrib );

Variable         Arguments           Meaning
Input:

contrl[0]        35                  vql_attributes
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        5                   entries in intout
intout[0]        attrib[0]           line type
intout[1]        attrib[1]           line color
intout[2]        attrib[2]           writing mode
intout[3]        attrib[4]           end style for first point
intout[4]        attrib[5]           end style for last point
ptsout[0]        attrib[3]           line width


ù SET POLYLINE END STYLES (VDI 108)

The style of the line ends is changed by calling "SET POLYLINE END STYLES".
If the requested style does not exist, the line end will be squared.

Decl.:  void vsl_ends( WORD handle, WORD beg_style, WORD end_style );
Call:   vsl_ends( handle, beg_style, end_style );

Variable         Arguments           Meaning
Input:

contrl[0]        108                 vsl_ends
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         beg_style           end style for the first point
intin[1]         end_style           end style for the last point

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of beg_style and end_style:
0: squared
1: arrow
2: rounded


ù SET USER-DEFINED LINE STYLE PATTERN (VDI 113)

You can set the pattern for the user-defined line type of vsl_type() with
this function.

Decl.:  void vsl_udsty( WORD handle, WORD pattern );
Call:   vsl_udsty( handle, pattern );

Variable         Arguments           Meaning
Input:

contrl[0]        113                 vsl_udsty
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         pattern             user-defined line pattern

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout




Filled Graphic Primitives
=========================

ù FILLED AREA (VDI 9)

This call draws a filled area, for example a complex polygon.

Decl.:  void v_fillarea( WORD handle, WORD count, WORD *xyarr );
Call:   v_fillarea( handle, count, xyarr );

Variable         Arguments           Meaning
Input:

contrl[0]        9                   v_fillarea
contrl[1]        n                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù OUTPUT FILLED BEZIER (VDI 9, 13)

This call draws a filled polygon with bezier curves.

Decl.:  void v_bez_fill( WORD handle, WORD count, WORD *xyarr, UBYTE *bezarr,
                         WORD *extent, WORD *totpts, WORD *totmoves );
Call:   v_bez_fill( handle, count, xyarr, bezarr, extent, totpts, totmoves );

Variable         Arguments           Meaning
Input:

contrl[0]        9                   v_bez_fill
contrl[1]        n                   entries in ptsin
contrl[3]        (n+1)/2             entries in intin
contrl[5]        13                  signalisiert v_bez_fill
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      Koordinaten
intin[0..(n+1)/2-1] bezarr[0..n-1]   Punkttypen

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        6                   entries in intout

intout[0]        totpts              number of points in the resulting polygon
intout[1]        totmoves            number of moves in the polygon
intout[2..5]                         reserved
ptsout[0..3]     extent[0..3]        coordinates of the bounding box

Meaning of the point-type flags:
bit 0:   first point in a 4-point bezier curve (two anchor points and two
         direction points). The last point of a bezier segment can be the 
         first point of the next bezier curve (or it can be a jump point).

bit 1:   jump point - this point and the previous one will not be connected.

Bit 2-7 are reserved. If bit 0 is 0, v_bez_fill() works like v_fillarea() and 
fills the area limited by a line between two points.

Note:
The binding for this function has to swap the bytes in intin because 
unfortunately this function is compatible with PC-GEM.
=> bezarr[0] is the low byte of intin[0] bezarr[1] is the high byte of
intin[0]...


ù BAR (VDI 11, GDP 1)

This function draws a filled rectangle. In contrast to "FILLED RECTANGLE" a 
border is drawn.

Decl.:  void v_bar( WORD handle, WORD *rect );
Call:   v_bar( handle, rect );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        1                   v_bar
contrl[6]        handle
ptsin[0..3]      rect[0..3]          coordinates of the rectangle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù PIE (VDI 11, GDP 3)


This function draws a filled arc, whose start and end angle can be set in
tenths of degrees from 0 to 3600.

Decl.:  void v_pieslice( WORD handle, WORD x, WORD y, WORD radius,
                         WORD begang, WORD endang );
Call:   v_pieslice( handle, x, y, radius, begang, endang );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        4                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        3                   v_pieslice
contrl[6]        handle
intin[0]         begang              start angle
intin[1]         endang              end angle
ptsin[0]         x
ptsin[1]         y
ptsin[6]         radius              radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù CIRCLE (VDI 11, GDP 4)

This call draws a filled circle.

Decl.:  void v_circle( WORD handle, WORD x, WORD y, WORD radius );
Call:   v_circle( handle, x, y, radius );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        3                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        4                   v_circle
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y
ptsin[4]         radius              radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ELLIPSE (VDI 11, GDP 5)

...

Decl.:  void v_ellipse( WORD handle, WORD x, WORD y,
                        WORD x_radius, WORD y_radius  );
Call:   v_ellipse( handle, x, y, x_radius, y_radius );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        5                   v_ellipse
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y
ptsin[2]         x_radius            horizontal radius
ptsin[3]         y_radius            vertical radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ELLIPTICAL PIE (VDI 11, GDP 7)

"ELLIPTICAL PIE" draws a filled elliptical arc, whose start and end angle 
can be selected in tenths of degrees from 0 to 3600.

Decl.:  void v_ellpie( WORD handle, WORD x, WORD y, WORD x_radius,
                       WORD y_radius, WORD begang, WORD endang );
Call:   v_ellpie( handle, x, y, x_radius, y_radius, begang, endang );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        7                   v_ellpie
contrl[6]        handle
intin[0]         begang              start angle
intin[1]         endang              end angle
ptsin[0]         x
ptsin[1]         y
ptsin[2]         x_radius            horizontal radius
ptsin[3]         y_radius            vertical radius

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù FILLED ROUNDED RECTANGLE (VDI 11, GDP 9)

A filled rectangle with rounded corners is drawn by this function.

Decl.:  void v_rfbox( WORD handle, WORD *rect );
Call:   v_rfbox( handle, rect );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        9                   v_rfbox
contrl[6]        handle
ptsin[0..3]      rect[0..3]          Koordinaten

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù SET FILL INTERIOR INDEX (VDI 23)

This function selects the fill type for filled graphic objects. If the 
requested type is invalid, type 0 (hollow) will be selected.

Decl.:  WORD vsf_interior( WORD handle, WORD interior );
Call:   set_interior = vsf_interior( handle, interior );

Variable         Arguments           Meaning
Input:

contrl[0]        23                  vsf_interior
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         interior            requested fill type

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_interior        selected fill type

Meaning of interior:
0: hollow
1: solid
2: pattern
3: hatch
4: user-defined style


ù SET FILL STYLE INDEX (VDI 24)

This call sets the style index which is corresponding to the type.

Decl.:  WORD vsf_style( WORD handle, WORD style_index );
Call:   set_style = vsf_style( handle, style_index );

Variable         Arguments           Meaning
Input:

contrl[0]        24                  vsf_style
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         style_index         requested index

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_sytle           selected index


ù SET FILL COLOR INDEX (VDI 25)

...sets the color index for filled areas. If the index is invalid, color 
index 1 will be selected. If you use a colored pattern (see vsf_udpat) the 
color index will be ignored; you should set it to 1.

Decl.:  WORD vsf_color( WORD handle, WORD color_index );
Call:   set_color = vsf_color( handle, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        25                  vsf_color
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         color_index         requested fill color

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_color           realized color


ù INQUIRE CURRENT FILL AREA ATTRIBUTES (VDI 37)

This function reports back the current attributes for filled objects.

Decl.:  void vqf_attributes( WORD handle, WORD *attrib );
Call:   vqf_attributes( handle, attrib );

Variable         Arguments           Meaning
Input:

contrl[0]        37                  vqm_attributes
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        5                   entries in intout
intout[0]        attrib[0]           fill type
intout[1]        attrib[1]           fill color
intout[2]        attrib[2]           fill style index
intout[3]        attrib[3]           writing mode
intout[4]        attrib[4]           perimeter flag


ù CONTOUR FILL (VDI 103)

This call fills an area which is limited by another color or the edges of 
the display. Use this function on the screen only!

Decl.:  void v_contourfill( WORD handle, WORD x, WORD y, WORD color_index );
Call:   v_contourfill( handle, x, y, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        103                 v_contourfill
contrl[1]        1                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         color_index         color index
ptsin[0]         x
ptsin[1]         y

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù SET FILL PERIMETER VISIBILITY (VDI 104)

This function turns the outline of a filled area (rectangle, polygone, ellipse, ...)
on or off.

Decl.:  WORD vsf_perimeter( WORD handle, WORD flag );
Call:   set_perimeter = vsf_perimter( handle, flag );

Variable         Arguments           Meaning
Input:

contrl[0]        104                 vsf_perimeter
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         flag                perimeter flag

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_perimeter       perimeter flag

Meaning of flag:
0: invisible
1: visible

ù SET USER-DEFINED FILL PATTERN (VDI 112)

"SET USER-DEFINED FILL PATTERN" is the function which allows you to set a 
user-defined 16*16 pixel pattern. Patterns with multiple colors have to be 
stored in standard format and must have the same number of planes as the 
device. Exception: If the device is a Hicolor or Truecolor device (direct 
color mapping) you always pass a pattern width 32-bit pixels (xrgb).

Decl.:  void vsf_udpat( WORD handle, WORD *pattern, WORD planes );
Call:   vsf_udpat( handle, pattern, planes );

Variable         Arguments           Meaning
Input:

contrl[0]        112                 vsf_udpat
contrl[1]        0                   entries in ptsin
contrl[3]        16n                 entries in intin (planes * 16)
contrl[6]        handle
intin[0..16n-1]  pattern[0..16n-1]   planes

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Note:
If you use a pattern with multiple colors you should select color index 1 and 
writing mode 1.


ù FILLED RECTANGLE (VDI 114)

"FILLED RECTANGLE" draw a filled rectangle (without outline).

Decl.:  void vr_recfl( WORD handle, WORD *rect );
Call:   vr_recfl( handle, rect );

Variable         Arguments           Meaning
Input:

contrl[0]        114                 vr_recfl
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0..3]      rect[0..3]          coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout




Marker
======

ù POLYMARKER (VDI 7)

This function draws markers.

Decl.:  void v_pmarker( WORD handle, WORD count, WORD *xyarr );
Call:   v_pmarker( handle, count, xyarr );

Variable         Arguments           Meaning
Input:

contrl[0]        7                   v_pmarker
contrl[1]        n                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0..2n-1]   xyarr[0..2n-1]      coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù SET POLYMARKER TYPE (VDI 18)

"SET POLYMARKER TYPE" selects the kind of marker for v_pmarker(). If the 
requested marker kind is not available, type 3 is used.

Decl.:  WORD vsm_type( WORD handle, WORD type );
Call:   set_type = vsm_type( handle, type );

Variable         Arguments           Meaning
Input:

contrl[0]        18                  vsm_type
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         type                requested marker type

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_type            selected marker type

Meaning of type:
1: dot
2: plus
3: asterisk
4: square
5: diagonal cross
6: diamond


ù SET POLYMARKER HEIGHT (VDI 19)

This call sets the marker height. If the requested height does not exist, the 
next smaller height will be selected. Marker type 1 (dot) is always 1 pixel high.

Decl.:  WORD vsm_height( WORD handle, WORD height );
Call:   set_height = vsm_height( handle, height );

Variable         Arguments           Meaning
Input:

contrl[0]        19                  vsm_height
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[1]         height              marker height

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0]        set_width           realized marker width
ptsout[1]        set_height          realized marker height


ù SET POLYMARKER COLOR INDEX (VDI 20)

The color index for markers is set by this call. If the index is invalid, 
color index 1 will be selected.

Decl.:  WORD vsm_color( WORD handle, WORD color_index );
Call:   set_color = vsm_color( handle, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        20                  vsm_color
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         color_index         marker color

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_color           selected color


ù INQUIRE CURRENT POLYMARKER ATTRIBUTES (VDI 36)

"INQUIRE CURRENT POLYMARKER ATTRIBUTES" reports back the current 
marker attributes

Decl.:  void vqm_attributes( WORD handle, WORD *attrib );
Call:   vqm_attributes( handle, attrib );

Variable         Arguments           Meaning
Input:

contrl[0]        36                  vqm_attributes
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        3                   entries in intout
intout[0]        attrib[0]           marker type
intout[1]        attrib[1]           marker color
intout[2]        attrib[2]           writing mode
ptsout[0]        attrib[4]           marker width
ptsout[1]        attrib[3]           marker height



Text Output with Bitmap and Vector Fonts
========================================

First of all some basics about text...

Font ID and Index:

The index of a font is a number between 1 and the number of available fonts. 
Depending on the number of installed fonts, a font like "Swiss 721" has a 
different index (supposing that Swiss 721 is one of the installed fonts).
In contrast to the index the id of a font is a fix number which is (with 
a few exceptions) not depending on the number of installed fonts or the used 
system - e.g. the id of "Swiss 721" is always 5003.
Of course there are exceptions from this rule: Some TrueType and Type 1 fonts 
do not have an id and therefore NVDI creates a unique id based on the name. 
This id can depend on the ids of the other installed fonts and therefore the 
same font might have another id on another computer with other fonts. To avoid 
problems like selecting the wrong font and to facilate replacing not existing 
fonts, you should save the id and the name of a font.

Vector or Bitmap Font?

If a font is a vector font, vqt_name() reports back at least 34 entries in 
intout and intout[33] contains a nonzero value. If intout[33] is zero or only 
33 entries are returned, the font is a bitmap font.

Monospaced Fonts:

Some applications can only run with monospaced fonts or they can run faster 
when they recognize that a font is monospaced. The appropriate proceeding is 
the following one:

a) If an extended version of vqt_name() exists (35 entries in intout), you 
   should check the monospace-bit in intout[34].
b) If vqt_name() returns only 34 entries, you should call vqt_fontheader() 
   if it is a vector font and check bit 1 of FH_CLFGS.
c) If the font is not a vector font (and vqt_name() returns less than 35 
   entries) you have to call vqt_width() and compare the character widths.

If you use v_ftext() to display characters of a monospaced vector font, the 
width of the string can not be calculated with the return values of vqt_width() 
or vst_height() but width vqt_advance32(), because characters of a vector 
font can have fractional widths - even if the font is monospaced - and 
v_ftext() uses these fractional width to place the characters.

Height and Width of Vector Fonts:

You can set the height and the width of a vector font with the functions 
vst_arbpt32() and vst_setsize32() in 1/65536 pt (1 pt ÷ 1/72" ÷ 353æm). If the 
specified width or height is negative, the text is mirrored on the corresponding 
axis.

Pair and Track Kerning:

Pair as well as track kerning are switched off when you open a workstation. To 
get a higher quality text output, you should call vst_kern() and switch on 
pair kerning.

Placement of Vector Font Characters:

When the VDI displays a vector font, the VDI uses a resolution of 1/65536 
pixels to guarantee exact character placement and string width independent 
from the used device and the device resolution. To give out a character bitmap, 
the VDI adds 32768 to the the pixel coordinate (a 16.16 signed fixed-point 
number) and divides by 65536 to get a discrete pixel coordinate.

If track kerning is switched on, the track kerning offset is added to the 
advance width of each character.

If pair kerning is switched on, the offset returned by vqt_pairkern() is 
added to the advance with of a character.

Pair and track kerning and character placement in 1/65536 pixels are only 
used, if you call v_ftext(). If you call v_gtext(), vector fonts behave like 
bitmap fonts - the advance widths are the ones returned by vqt_width() and 
kerning is not available.

Pixel Size and Size of Vector Fonts:

Most screen drivers report back a resolution of ÷ 91 dpi and NVDI uses the
returned pixel size to scale the vector fonts. Since there are a few screen 
drivers that return other resolutions, applications should suppose that the 
screen resolution is always 91 dpi, because this would lead to wrong 
proportions of text and other graphic objects. 

Adding and Removing fonts during Runtime:

"Fontname" is able to add or remove vector fonts during runtime. The AES 
message FNT_CHANGED is sent when you quit Fontname and informs other 
applications about the number of added and removed fonts.

   #define  FNT_CHANGED 83

   mbuf[0] = FNT_CHANGED;
   mbuf[1] = app_id;          /* application id */
   mbuf[2] = 0;
   mbuf[3] = fonts_removed;   /* number of removed fonts */
   mbuf[4] = fonts_added;     /* number of added fonts */
   mbuf[5] = 0;
   mbuf[6] = 0;
   mbuf[7] = 0;

If fonts have been removed, you should call vst_unload_fonts() and vst_load_fonts().
Then you should check, if the fonts you are using in open documents are still
available.

If fonts have been added, you should call vst_(un)load_fonts(), too. Update your 
font selector if necessary.

Font Selector:

Dont't waste your time with developing a font selector. Use the one that is 
included in MagiC and WDIALOG. See DOC_WDLG.TXT and the accompanied examples.


ù TEXT (VDI 8)

"TEXT" draws a string with the selected text attributes. If you have 
selected a vector font, neither pair nor track kerning are used and the 
character widths are non-fractional (that means the widths returned by 
vqt_width()).

Decl.:  void v_gtext( WORD handle, WORD x, WORD y, BYTE *string );
Call:   v_gtext( handle, x, y, string );

Variable         Arguments           Meaning
Input:

contrl[0]        8                   v_gtext
contrl[1]        1                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      string
ptsin[0]         x
ptsin[1]         y

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù JUSTIFIED GRAPHICS TEXT (VDI 11, GDP 10)

"JUSTIFIED GRAPHICS TEXT" outputs graphic text and lengthens or shortens 
the string by modifying the interword or intercharacter spacing. If you 
use a vector font, the requested width of the string refers to the sum 
of the character widths - characters extending beyond the left or right 
edge of the em square are ot taken into account.
~
Decl.:  void v_justified( WORD handle,int x, WORD y, BYTE *string, WORD length,
                          WORD word_space, WORD char_space );
Call:   v_justified( handle, x, y, string, length, word_space, char_space );

Variable         Arguments           Meaning
Input:

contrl[0]        11                  GDP
contrl[1]        2                   entries in ptsin
contrl[3]        n+2                 entries in intin
contrl[5]        10                  v_justified
contrl[6]        handle
intin[0]         word_space          <> 0: Wortzwischenr„ume dehnen
intin[1]         char_space          <> 0: Zeichenzwischenr„ume dehnen
intin[2..n+1]    string[0..n-1]      string
ptsin[0]         x
ptsin[1]         y
ptsin[2]         length              length in pixels

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù SET CHARACTER HEIGHT, ABSOLUTE MODE (VDI 12)

This call sets the character height in pixels. The height is specified as the 
distance between baseline and the top of the character cell. If the font is a 
bitmap and the requested height does not exist, the VDI scales the bitmap. If 
the font is a vector font, <char_width> and <cell_width> are not the exact 
character widths but only rounded values.

Decl.:  void vst_height( WORD handle, WORD height, WORD *char_width,
                         WORD *char_height, WORD *cell_width, WORD *cell_height );
Call:   vst_height( handle, height, &char_width, &char_height, &cell_width,
                    &cell_height );

Variable         Arguments           Meaning
Input:

contrl[0]        12                  vst_height
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[1]         height              requested character height

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0]        char_width          selected character width
ptsout[1]        char_height         selected character height
ptsout[2]        cell_width          selected character cell width
ptsout[3]        cell_height         selected character cell height


ù SET CHARACTER BASELINE VECTOR (VDI 13)

This function enables text rotation in 1/10 of degrees. If the selected font 
is a bitmap font, rotation works only in steps of 90 degrees

Decl.:  WORD vst_rotation( WORD handle, WORD angle );
Call:   set_angle = vst_rotation( handle, angle );

Variable         Arguments           Meaning
Input:

contrl[0]        13                  vst_rotation
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         angle               requested angle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_angle           realized angle


ù SET TEXT FACE (VDI 21)

"SET TEXT FACE" selects a font for text output. If a font with the requested 
does not exist, the system font will be chosen.

Decl.:  WORD vst_font( WORD handle, WORD font );
Call:   set_font = vst_font( handle, font);

Variable         Arguments           Meaning
Input:

contrl[0]        21                  vst_font
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         font                requested font

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_font            selected font


ù SET GRAPHIC TEXT COLOR INDEX (VDI 22)

...sets the color index for text output. If the index is invalid, color 
index 1 will be selected.

Decl.:  WORD vst_color( WORD handle, WORD color_index );
Call:   set_color = vst_color( handle, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        22                  vst_color
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         color_index         requested color index

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_color           selected color index


ù INQUIRE CURRENT GRAPHIC TEXT ATTRIBUTES (VDI 38)

This function returns the current graphic text attributes.

Decl.:  void vqt_attributes( WORD handle, WORD *attrib );
Call:   vqt_attributes( handle, attrib );

Variable         Arguments           Meaning
Input:

contrl[0]        38                  vqt_attributes
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        6                   entries in intout
intout[0]        attrib[0]           font id
intout[1]        attrib[1]           text color index
intout[2]        attrib[2]           text rotation in 1/10 of degrees
intout[3]        attrib[3]           horizontal alignment
intout[4]        attrib[4]           vertical alignment
intout[5]        attrib[5]           writing mode
ptsout[0]        attrib[6]           character width
ptsout[1]        attrib[7]           character height
ptsout[2]        attrib[8]           character cell width
ptsout[3]        attrib[9]           character cell height

Note:
Some version of the ATARI-VDI return the writing mode - 1 in intout[5].


ù SET GRAPHIC TEXT ALIGNMENT (VDI 39)

This call sets the horizontal and vertical alignment for graphic text. If an 
invalid horizontal alignment is requested, the text will be left justified. 
If an invalid vertical alignment is requested, the text will be aligned to 
the baseline.

Decl.:  void vst_alignment( WORD handle, WORD hor_in, WORD vert_in,
                            WORD *hor_out, WORD *vert_out );
Call:   vst_alignment( handle, hor_in, vert_in, &hor_out, &vert_out );

Variable         Arguments           Meaning
Input:

contrl[0]        39                  vst_alignment
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         hor_in              requested horizontal alignment
intin[1]         vert_in             requested vertical alignment

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        hor_out             selected horizontal alignment
intout[1]        vert_out            selected vertical alignment

Meaning of hor_in:
0: left justified
1: centered
2: right justified

Meaning of vert_in:
0: baseline
1: half line
2: ascent line
3: bottom
4: descent
5: top


ù SET GRAPHIC TEXT SPECIAL EFFECTS (VDI 106)

"SET GRAPHIC TEXT SPECIAL EFFECTS" sets special text effects (really?).

Decl.:  WORD vst_effects( WORD handle, WORD effect );
Call:   set_effect = vst_effects( handle, effect );

Variable         Arguments           Meaning
Input:

contrl[0]        106                 vst_effects
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         effect              requested text effects

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_effect          selected text effects

Meaning of effect (bit number):
0: bold
1: light
2: skewed
3: underlined
4: outlined


ù SET CHARACTER HEIGHT, POINTS MODE (VDI 107)

This function sets the character cell height in points (1 pt  = 1/72").
For bitmap font this function selects the closest height which is smaller or 
equal to the requested size. If the font is a vector font, only predefined 
heights can be selected (usually 8, 9, 10, 11, 12, 14, 18, 24, 36, and 48 pt).

Decl.:  WORD vst_point( WORD handle, WORD point,
                        WORD *char_width, WORD *char_height,
                        WORD *cell_width, WORD *cell_height );
Call:   set_point = vst_point( handle, point, &char_width, &char_height,
                               &cell_width, &cell_height );

Variable         Arguments           Meaning
Input:

contrl[0]        107                 vst_point
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         point               requested character cell height (1/72")

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_point           selected character cell height (1/72")
ptsout[0]        char_width          selected character width
ptsout[1]        char_height         selected character height
ptsout[2]        cell_width          selected character cell width
ptsout[3]        cell_height         selected character cell height


ù INQUIRE TEXT EXTENT (VDI 116)

If the selected font is a bitmap font, this function returns the minimal 
bounding box of a string. If the selected font is a vector font, the character 
widths (vqt_width()) will be added and the string (especially the leftmost and 
the rightmost character) might exceed the returned rectangle.
The coordinates of the rectangle are given relative to a coordinate system, 
where the extent rectangle touches both, the x and y axes, and the string is 
in the first quadrant.

Decl.:  void vqt_extent( WORD handle, BYTE *string, WORD *extent );
Call:   vqt_extent( handle, string, extent );

Variable         Arguments           Meaning
Input:

contrl[0]        116                 vqt_extent
contrl[1]        0                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      string

Output:

contrl[2]        4                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0..7]     extent[0..7]        coordinates of the rectangle


ù INQUIRE CHARACTER CELL WIDTH (VDI 117)

This call reports back the cell width for the specified character. If you 
have selected a vector font, the returned cell width is a rounded value. 
You can use this advance width for determing a character position when you 
use v_gtext() but you cannot use it for v_ftext() output.

Decl.:  WORD vqt_width( WORD handle, WORD index,
                        WORD *cell_width, WORD *left_delta, WORD *right_delta );
Call:   status = vqt_width( handle, index,
                            &cell_width, &left_delta, &right_delta );

Variable         Arguments           Meaning
Input:

contrl[0]        117                 vqt_width
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         character           character index

Output:

contrl[2]        3                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        status              character index or -1 (error)
ptsout[0]        cell_width          character cell width
ptsout[2]        left_delta          left character alignment delta
ptsout[4]        right_delta         right character alignment delta

Note:
To determine the width of a string, you should always call vqt_extent(), 
vqt_f_extent() or vqt_real_extent().
If you try to check whether a font is monospaced or proportional, you should 
test if vqt_name() returns extend information.


ù LOAD FONTS (VDI 119)

This function loads the fonts for the device specified by <handle> and returns
the number of additional fonts.

Before you call vst_load_fonts(), call vq_gdos() and make sure that the VDI can 
load additional fonts.

Decl.:  WORD vst_load_fonts( WORD handle, WORD select );
Call:   additional = vst_load_fonts( handle, 0 );

Variable         Arguments           Meaning
Input:

contrl[0]        119                 vst_load_fonts
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         select              0 (reserved)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        additional          number of additional fonts


ù UNLOAD FONTS (VDI 120)

The memory for the additional fonts is freed.

Decl.:  void vst_unload_fonts( WORD handle, WORD select );
Call:   vst_unload_fonts( handle, 0);

Variable         Arguments           Meaning
Input:

contrl[0]        120                 vst_unload_fonts
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         select              0 (reserved)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù INQUIRE FACE NAME AND INDEX (VDI 130)

In NVDI there is an extended version of vqt_name():

Decl.:  WORD vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format,
                           UWORD *flags );
Call:   id = vqt_ext_name( handle, index, name, &font_format, &flags );

Variable         Arguments           Meaning
Input:

contrl[0]        130                 vqt_name/vqt_ext_name
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        1                   return additional information
contrl[6]        handle
intin[0]         index               index (1 - number of fonts)
intin[1]         0                   reserved

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        35                  entries in intout
intout[0]        id                  font id
intout[1..32]    name[0..31]         font name
intout[33]       name[32]            0: bitmap font, 1: vector font
intout[34]       flags/font_format

The high byte of intout[34] contains <flags>:
0: proportional font
1: monospaced font

The low byte of intout[34] contains <font_format>:
1: bitmap font
2: Speedo font
4: TrueType font
8: Type 1 font

Note:
Check contrl[4] before you use the additional information.


ù INQUIRE CURRENT FACE INFORMATION (VDI 131)

This function returns size information for the current font. Special effects and 
enlargment are taken into account.

Decl.:  void vqt_fontinfo( WORD handle, WORD *minADE, WORD *maxADE,
                           WORD *distances, WORD *maxwidth, WORD *effects );
Call:   vqt_fontinfo( handle, &minADE, &maxADE, distances, &max_width, effects );

Variable         Arguments           Meaning
Input:

contrl[0]        131                 vqt_fontinfo
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        5                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        minADE              minimum character index
intout[1]        maxADE              maximum character index
ptsout[0]        maxwidth            maximum character cell width
ptsout[1]        distances[0]
ptsout[2]        effects[0]
ptsout[3]        distances[1]
ptsout[4]        effects[1]
ptsout[5]        distances[2]
ptsout[6]        effects[2]
ptsout[7]        distances[3]
ptsout[9]        distances[4]

Meaning of distances:
distances[0]: distance of bottom line and baseline
distances[1]: distance of descent line and baseline
distances[2]: distance of half line and baseline
distances[3]: distance of ascent line and basline
distances[4]: distance of top line and baseline

Meaning of effects:
effects[0]: additional character width due to text effects
effects[1]: left offset of skewed text
effects[2]: right offset of skewed text


ù INQUIRE EXTENDED FONT INFORMATION (VDI 229)

This function returns extended font information specified by <flags> in a
XFNT_INFO structure. If the index is a nonzero value vqt_xfntinfo() searches 
the correspoding font and returns the requested information. If <index> is zero, 
vqt_xfntinfo() searches the font specified by <id>. If <index> and <id> are 
zero, this function returns information about the current font.

Before you call this function, you have to set the length of the structure in 
the element <size>.

Decl.:  WORD vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index,
                           XFNT_INFO *info );
Call:   id = vqt_xfntinfo( handle, flags, id, index, &info );

Variable         Arguments           Meaning
Input:

contrl[0]        229                 vqt_xfntinfo
contrl[1]        0                   entries in ptsin
contrl[3]        5                   entries in intin
contrl[5]        0
contrl[6]        handle
intin[0]         flag                kind of requested information
intin[1]         id                  font id or 0 (current font)
intin[2]         index               font index or 0 (use id)
intin[3..4]      info                pointer to the XFNT_INFO structure

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        3                   entries in intout
intout[0]        font_format         font format
intout[1]        font_id             font id
intout[2]        index               font index

Meaning of flags (bit number):
0:    return the full font name (font_name)
1:    return the name of the family (family_name)
2:    return the style name (style_name)
3:    return the file name (file_name1)
4:    return the 2. optional file name (file_name2)
5:    return the 3. optional file name (file_name3)
8:    return the available pt sizes (without enlargment) (pt_cnt, pt_sizes)
9:    return the available pt sizes (with enlargment) (pt_cnt, pt_sizes)

Meaning of font_format:
1: bitmap font
2: Speedo font
4: TrueType font
8: Type 1 font

Description of the XFNT_INFO structure:

typedef struct
{
   LONG  size;             /* length, initialize this element before you call vqt_xfntinfo()! */
   WORD  format;           /* font format, e.g. 4 for TrueType */
   WORD  id;               /* font id, e.g. 6059 */
   WORD  index;            /* index */
   BYTE  font_name[50];    /* full font name, e.g. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* family name, e.g. "Century725 BT" */
   BYTE  style_name[50];   /* style name, e.g. "Italic" */
   BYTE  file_name1[200];  /* file name, e.g. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* 2. optional file name */
   BYTE  file_name3[200];  /* 3. optinal file name */
   WORD  pt_cnt;           /* number of available point sizes (vst_point()), e.g. 10 */
   WORD  pt_sizes[64];     /* available point sizes,
                              e.g. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;

All strings in this structure are C strings which are terminated with 0.


ù SET TEXT FACE BY NAME (VDI 230, 0)

This function selects the font specified by <font_name> and <font_format>. 
Missing or extra spaces in the font name are ignored. If the requested font 
is not available, the system font is selected.

Decl.:  WORD vst_name( WORD handle, WORD font_format,
                       BYTE *font_name, BYTE *ret_name );
Call:   id = vst_name( handle, font_format, font_name, ret_name );

Variable         Arguments           Meaning
Input:

contrl[0]        230                 vst_name
contrl[1]        0                   entries in ptsin
contrl[3]        n + 1               entries in intin
contrl[5]        0                   sub-opcode: set font
contrl[6]        handle
intin[0]         font_format         possible font formats
intin[1..n]      font_name[0..n-1]   font name

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        m + 1               entries in intout
intout[0]        id                  selected font id
intout[1..m]     ret_name[0..m-1]    name of the selected font

Meaning of font_format:
1: bitmap font
2: Speedo font
4: TrueType font
8: Type 1 font




ù INQUIRE CHARACTER INDEX (VDI 190, 0)

vqt_char_index() converts <src_index> according to the encodings <src_mode> 
and <dst_mode>. If it is not possible to convert an index, <dst_index> will 
be 0xffff. For example, to determine if the font contains a character with 
unicode 0x201e ("quotedblbase", DOUBLE LOW-9 QUOTATION MARK ), you should 
use the following function:

WORD  is_char_available( WORD handle, UWORD unicode )
{
   UWORD direct_index;
   
   /* translate <unicode> into a direct index */
   direct_index = vqt_char_index( handle, unicode, 2, 0 );
   
   if ( direct_index == 0xffff )
      return( 0 );                     /* character is available */
   else
      return( 1 );                     /* not available */
}


Decl.:  UWORD vqt_char_index( WORD handle, UWORD src_index, WORD src_mode, 
                             WORD dst_mode );
Call:   dst_index = vqt_char_index( handle, src_index, src_mode, dst_mode );

Variable         Arguments           Meaning
Input:

contrl[0]        190                 vqt_char_index
contrl[1]        0                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[5]        0                   sub-opcode (must be zero)
contrl[6]        handle

intin[0]         src_index
intin[1]         src_mode            Mapping of <src_index>
intin[2]         dst_mode            Mapping of <dst_index>

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout

intout[0]        dst_index

Meaning of <src_mode>:
0: <src_index> is a direct index
1: <src_index> is an ASCII index 
2: <src_index> is a unicode index

Meaning of <dst_mode>:
0: <dst_index> is a direct index
1: <dst_index> is an ASCII index 
2: <dst_index> is a unicode index

Note:
If you want to convert an index from ASCII to ASCII, only the range from 32 
to 255 is used. The control codes are not translated, e.g. a call like 
vqt_char_index( handle, 10, 1, 0 ) returns 0xffff.


ù INQUIRE FACE NAME AND ID BY NAME (VDI 230, 100)

This function searches the font specified by <font_name> and <font_format>. 
Missing or extra spaces in the font name are ignored. If the font cannot be 
found, intout[0] is zero.

Decl.:  WORD vqt_name_and_id( WORD handle, WORD font_format,
                              BYTE *font_name, BYTE *ret_name );
Call:   id = vqt_name_and_id( handle, font_format, font_name, ret_name );

Variable         Arguments           Meaning
Input:

contrl[0]        230                 vst_name
contrl[1]        0                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[5]        100                 sub-opcode: search font
contrl[6]        handle
intin[0]         font_format         possible font formats
intin[1..n]      font_name[0..n-1]   font name

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        m                   entries in intout
intout[0]        id                  font id or 0
intout[1..m]     ret_name[0..m-1]    font name

Meaning of font_format:
1: bitmap font
2: Speedo font
4: TrueType font
8: Type 1 font


ù SET CHARACTER WIDTH, ABSOLUTE MODE (VDI 231)

This function sets the character width in pixels. The next call of vst_height(), 
vst_point() or vst_arbpt32() resets the width.

Decl.:  void vst_width( WORD handle, WORD width, WORD *char_width,
                        WORD *char_height, WORD *cell_width, WORD *cell_height );
Call:   vst_width( handle, width, &char_width, &char_height,
                   &cell_width, &cell_height );

Variable         Arguments           Meaning
Input:

contrl[0]        231                 vst_width
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0]         width               requested width

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0]        char_width          selected character width
ptsout[1]        char_height         selected character height
ptsout[2]        cell_width          selected character cell width
ptsout[3]        cell_height         selected character cell height

Note:
You should use vst_setsize32() instead of vst_width() because vst_width() uses 
only an integer value as relative width and it therefore does not offer the 
necessary accuracy.


ù INQUIRE SPEEDO HEADER INFORMATION (VDI 232)

vqt_fontheader() copies the header of a speedo font file into <buffer> and 
returns a pointer to the TDF file. The buffer should have a size of 1 Kb, 
because the header size depends on the font and extensions of the font format.

If the selected (vector) font is not a Speedo font (TrueType, ...) the VDI 
tries to create a virtual header with the important information.

You should consider that each vqt_fontheader()-call can lead to several disk 
accesses (depending on the font format) - if a user has installed 300 or more 
fonts (which can happen very easily if you use high quality fonts with a lot 
of font styles), this will take a few seconds. If necessary, save font 
information and load (and update) it when your program is started.


Decl.:  void vqt_fontheader( WORD handle, void *buffer, BYTE *tdf_name );
Call:   vqt_fontheader( handle, buffer, tdf_name );

Variable         Arguments           Meaning
Input:

contrl[0]        232                 vqt_fontheader
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0..1]      buffer              font header

Output:
contrl[2]        0                   entries in ptsout
contrl[4]        n                   length of the TDF name
intout[0..n-1]   tdf_name[0..n-1]    name of the TDF

Note:

Usually the following elements of the font header are the most interesting 
ones for programmers:

Name      Offset  Length  Description
FH_FNTNM    24     70     font name (siehe auch vqt_name()),
                          e.g. "Century 725 Italic BT"
FH_NKTKS   258      2     number of kerning tracks
FH_NKPRS   260      2     number of kerining pairs, (see vst_kern())
FH_CLFGS   263      1     classification (Italic and Monospace)
FH_SFNTN   266     32     name of the corresponding Postscript font,
                          e.g. "Century725BT-Italic"
FH_SFACN   298     16     short name of the family, e.g. "Century725 BT"
FH_FNTFM   314     14     style, e.g. "Italic"
FH_ITANG   328      2     skew in 1/256 of degrees (if it is an italic font),
                          e.g 4480 (17,5 degree)
FH_ORUPM   330      2     number of ORUs per em, e.g. 2048


ù INQUIRE TRACK KERNING INFORMATION (VDI 234)

This function returns the adjustment vector per character for track kerning.

Decl.:  void vqt_trackkern( WORD handle, fix31 *x_offset, fix31 *y_offset );
Call:   vqt_trackkern( handle, &x_offset, &y_offset );

Variable         Arguments           Meaning
Input:

contrl[0]        234                 vqt_trackkern
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:
contrl[2]        0                   entries in ptsout
contrl[4]        4                   entries in intout
intout[0..1]     x_offset            x-adjustment in 1/65536 pixels
intout[2..3]     y_offset            y-adjustment in 1/65536 pixels


ù INQUIRE PAIR KERNING INFORMATION (VDI 235)

This function returns the adjustment vector for pair kerning.

Decl.:  void vqt_pairkern( WORD handle, WORD index1, WORD index2,
                           fix31 *x_offset, fix31 *y_offset );
Call:   vqt_pairkern( handle, index1, index2, &x_offset, &y_offset );

Variable         Arguments           Meaning
Input:

contrl[0]        235                 vqt_pairkern
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         index1              first character
intin[1]         index2              following character

Output:
contrl[2]        0                   entries in ptsout
contrl[4]        4                   entries in intout
intout[0..1]     x_offset            x-adjustment in 1/65536 pixels
intout[2..3]     y_offset            y-adjustment in 1/65536 pixels

Note:
If you want call vqt_pairkern() from Pure C, you might have to write your own 
binding, because some releases of the PCGEMLIB return ptsout[0-3] instead of 
intout[0-3].


ù SET CHARACTER MAPPING MODE (VDI 236)

This call switches from ASCII-mapping to direct mapping, which means that you 
can access all characters of a font (e.g. if the user wants to select a special 
non-ASCII character), but an index like 65 does not stand for 'A' anymore but 
for another character. If you switch to direct mapping, the number of characters 
per font (minADE and maxADE/vqt_fontinfo()) is changed to the number of really 
existing characters.  

Decl.:  void vst_charmap( WORD handle, WORD mode );
Call:   void vst_charmap( handle, mode );

Variable         Arguments           Meaning
Input:

contrl[0]        236                 vst_charmap
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         mode                mapping mode

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of mode:
0: direct mapping
1: ASCII mapping

Note:
If you want to switch on ASCII-mapping, you should use 1 as <mode> and not 
any other nonzero value, because other mapping might exist in future 
(e.g. Unicode).

Note:
Since NVDI 4 is able to use Unicode for mapping characters, there is an extended 
Binding to select Unicode.

Decl.:  WORD vst_map_mode( WORD handle, WORD mode );
Call:   set_mode = vst_map_mode( handle, mode );

Variable         Arguments           Meaning
Input:

contrl[0]        236                 vst_map_mode
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         mode                mapping mode
intin[1]         1                   return mapping

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_mode            set mapping mode

Meaning of mode:
0: direct mapping
1: ASCII mapping
2: Unicode mapping

If you select Unicode and if you want to determine whether a certain character
exists, you should call vqt_width(). If the index returned by vqt_width() is -1, 
the character does not exist. Instead of vqt_width() you can also call 
vqt_char_index() and map the Unicode index into a direct index.


ù SET KERNING MODE (VDI 237)

This function can be used to set the track and pair kerning mode. Most Speedo 
fonts have 3 kerning tracks. Ordinary TrueType fonts do not have any kerning 
tracks, but some GX TrueTypes do.

Decl.:  void vst_kern( WORD handle, WORD track_mode, WORD pair_mode,
                       WORD *tracks, WORD *pairs );
Call:   vst_kern( handle, track_mode, pair_mode, &track, &pairs );

Variable         Arguments           Meaning
Input:

contrl[0]        237                 vst_kern
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         track_mode          requested track kerning mode
intin[1]         pair_mode           pair kerning on (1) or off (0)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        track               track kerning mode
intout[1]        pairs               number of kerning pairs

Meaning of track_mode:
0: no track kerning
1: normal
2: tight
3: very tight

Meaning of pair_mode:
0: no pair kerning
1: do pair kerning

Note:
NVDI allows the caller to set a user-defined track kerning. The track kerning 
mode must be 255 (track_mode) and intin[2..3] contain the offset in 1/65536 
pixels.

Decl.:  void vst_track_offset( WORD handle, fix31 offset, WORD pair_mode,
                               WORD *tracks, WORD *pairs );
Call:   vst_track_offset( handle, offset, pair_mode, &tracks, &pairs );

Variable         Arguments           Meaning
Input:

contrl[0]        237                 vst_kern
contrl[1]        0                   entries in ptsin
contrl[3]        4                   entries in intin
contrl[6]        handle
intin[0]         255                 user-defined offset
intin[1]         pair_mode           pair kerning on (1) or off (0)
intin[2..3]      offset              offset

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        track               track kerning mode
intout[1]        pairs               number of kerning pairs


ù GET CHARACTER BITMAP INFORMATION (VDI 239)

This function returns a pointer to a character's bitmap and provides information 
about the character placement and its size.

Decl.:  void v_getbitmap_info( WORD handle, WORD index,
                               fix31 *x_advance, fix31 *y_advance,
                               fix31 *x_offset, fix31 *y_offset,
                               WORD *width, WORD *height,  WORD *bitmap );
Call:   v_getbitmap_info( handle, index, &x_advance, &y_advance,
                          &x_offset, &y_offset, &width, &height, bitmap );

Variable         Arguments           Meaning
Input:

contrl[0]        239                 v_getbitmap_info
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         index               Zeichen-Index

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        12                  entries in intout
intout[0]        width               bitmap width in pixels
intout[1]        height              bitmap height in pixels
intout[2..3]     x_advance           x advance in 1/65536 pixels
intout[4..5]     y_advance           y advance in 1/65536 pixels
intout[6..7]     x_offset            x offset in 1/65536 pixels
intout[8..9]     y_offset            y offset in 1/65536 pixels
intout[10..11]   bitmap              pointer to the bitmap

Meaning of x_advance, y_advance:
The advance vector represents the offset for the placement of the next character.

Meaning of x_offset, y_offset:
x_offset and y_offset are the offset of the bitmap relative to the position of 
the character cell. This offset is necessary because most bitmaps are smaller than 
the character cell.

Note:
You should switch off text effects before you call v_getbitmap_info().

In general the pointer to the bitmap points into the character cache and therefore 
you should immediately copy the bitmap (and lock the aes context switch by calling 
wind_update()) - otherwise the pointer could be invalid.

You should not use this function to write your own text output function - this 
function would not be faster than v_ftext() and you would not be able to do pair 
kerning. Use v_ftext()!


ù INQUIRE OUTLINE FONT TEXT EXTENT (VDI 240)

As well as vqt_extent() this function adds the character widths of a string, but 
this function takes track and pair kerning into account and works with a resolution 
of 1/65536 pixels. Text effects like skewing (vst_skew()) and characters which are 
extending beyond the em square are ignored.

Decl.:  void vqt_f_extent( WORD handle, BYTE *string, WORD *extent );
Call:   vqt_f_extent( handle, string, extent );

Variable         Arguments           Meaning
Input:

contrl[0]        240                 vqt_fextent
contrl[1]        0                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      Zeichenkette

Output:

contrl[2]        4                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0..7]     extent[0..7]        coordinates of the rectangle

Important:
If the text is rotated by 90, 180 or 270 degrees, this function works as senseless 
as vqt_extent(): It changes the reference point of the coordinate system. In all 
other cases it works as you would expect it.

Note:
This function does not return the bounding box of the string. It adds only the 
advance widths of the characters. You should use this function to determine the 
position of the text cursor.
If you would like to use it to determine the maximum size of the redraw area 
you should add the maximum character width to the leftmost and rightmost coordinates 
of the rectangle (if the text is skewed you should also add the skewing offset).
To determine a more exact bounding box you should call vqt_real_extent().


ù INQUIRE REAL OUTLINE FONT TEXT EXTENT (VDI 240, 4200)

This function is only available if you use NVDI.
It returns the bounding box (eventually a quadrilateral, not a rectangle) for 
text output at <x>,<y>. This function considers all text effects, rotation, 
skewing, pair kerning, track kerning, characters which are extending beyond the 
em square, horizontal and vertical alignment.

Decl.:  void vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string,
                              WORD *extent );
Call:   vqt_real_extent( handle, x, y, string, extent )

Variable         Arguments           Meaning
Input:

contrl[0]        240                 vqt_fextent
contrl[1]        1                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[5]        4200                sub-opcode
contrl[6]        handle
ptsin[0]         x                   x-coordinate
ptsin[1]         y                   y-coordinate
intin[0..n-1]    string[0..n-1]      string

Output:

contrl[2]        4                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0..7]     extent[0..7]        coordinates of the bounding box.


ù OUTLINE  FONT TEXT (VDI 241)

This text function uses track and pair kerning and works with an internal 
resolution of 1/65536 pixels to maintain accurate character placement.

Decl.:  void v_ftext( WORD handle, WORD x, WORD y, BYTE *string );
Call:   v_ftext( handle, x, y, string );

Variable         Arguments           Meaning
Input:

contrl[0]        241                 v_ftext
contrl[1]        1                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      string
ptsin[0]         x
ptsin[1]         y

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

There is another variant of v_ftext() which allows your application to specifiy 
the offset of each character relative to the previous one:

Decl.:  void v_ftext_offset( WORD handle, WORD x, WORD y, BYTE *string, WORD *offset );
Call:   v_ftext_offset( handle, x, y, string, offset );

Variable         Arguments           Meaning
Input:

contrl[0]        241                 v_ftext
contrl[1]        1+n                 entries in ptsin
contrl[3]        n                   entries in intin
contrl[6]        handle
intin[0..n-1]    string[0..n-1]      string
ptsin[0]         x
ptsin[1]         y
ptsin[2]         offset[0]           x-offset of the first character
ptsin[3]         offset[1]           y-offset of the first character
ptsin[4..2*n+1]  xyoff[2..(2*n)-1]   x-offset, y-offset of the next characters

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù GET CHARACTER OUTLINE (VDI 243)

This function generates a bezier curve of the specified character, which can be 
used to call v_bez() or v_bez_fill().

Decl.:  void v_getoutline( WORD handle, WORD index, WORD *xyarr, BYTE *bezarr,
                           WORD max_pts, WORD *count );
Call:   v_getoutline( handle, index, xyarr, bezarr, max_pts, &count );

Variable         Arguments           Meaning
Input:

contrl[0]        243                 v_getoutline
contrl[1]        0                   entries in ptsin
contrl[3]        6                   entries in intin
contrl[6]        handle
intin[0]         index               character index
intin[1]         max_pts             maximum number of points
intin[2..3]      xyarray             coordinate buffer
intin[4..5]      bezarray            point-type buffer (jump, bez)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout
intout[0]        count               number of points

Note:
If you want to use the outline returned by v_getoutline() as vector graphic 
(e.g. as part of a Metafile), you should select a sufficient character height.
Otherwise the quality of the outline will be very poor, because v_getoutline() 
has to round the internal fixed-point coordinates and returns only integer 
values. The character height should refer to the resolution of the font outline 
(returned by vqt_fontheader() in FH_ORUPM, e.g. 2048).


ù SET CHARACTER HEIGHT BY ARBITRARY POINTS (VDI 246)

Similar to vst_point() this function sets the character height in points, but 
you are able to change the size in steps of 1/65536 points. If you request a 
negative height, the characters are mirrored along the x-axis.

Decl.:  fix31 vst_arbpt32( WORD handle, fix31 height,
                           WORD *char_width, WORD *char_height,
                           WORD *cell_width, WORD *cell_height );
Call:   set_point = vst_arbpt32( handle, height, &char_width, &char_height,
                                 &cell_width, &cell_height );

Variable         Arguments           Meaning
Input:

contrl[0]        246                 vst_arbpt32
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0..1]      height              requested height in 1/65536 pts

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0..1]     set_point           selected height in 1/65536 pts
ptsout[0]        char_width          selected character width
ptsout[1]        char_height         selected character height
ptsout[2]        cell_width          selected character cell width
ptsout[3]        cell_height         selected character cell height

Note:
The returned character widths are rounded values which cannot be used for 
precise character placement.


ù INQUIRE OUTLINE FONT TEXT ADVANCE PLACEMENT VECTOR (VDI 247)

This call returns the advance vector of a character which can be used to place 
the next one (the advance width is not the width of the character bitmap!).

Decl.:  void  vqt_advance32( WORD handle, WORD index,
                             fix31 *x_advance, fix31 *y_advance );
Call:   vqt_advance32( handle, index, &x_advance, &y_advance );

Variable         Arguments           Meaning
Input:

contrl[0]        247                 vqt_advance32
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         index               character index

Output:

contrl[2]        4                   entries in ptsout
contrl[4]        0                   entries in intout
ptsout[0]        x_adv_old           x advance in pixels
ptsout[1]        y_adv_old           y advance in pixels
ptsout[2]        x_rem_old           x remainder (mod 16384)
ptsout[3]        y_rem_old           y remainder (mod 16384)
ptsout[4..5]     x_advance           x advance in 1/65536 pixels
ptsout[6..7]     y_advance           y advance in 1/65536 Pixels

Note:
The values in ptsout[0..3] are returned for compatibility's sake only. Do 
not use them! You should use <x_advance> and <y_advance>.
Remember that <x_advance> and <y_advance> are only offsets used to place 
the next character - they do not include parts of the character which extend 
beyond the em square.


ù FLUSH OUTLINE FONT CACHE (VDI 251)

This function flusher the font caches.


ù SET CHARACTER CELL WIDTH BY ARBITRARY POINTS (VDI 252)

This call sets the character width in 1/65536 points (pt). The next call of 
vst_height(), vst_point() or vst_arbpt32() will reset the character width. If 
the width is negative the characters will be mirrored along the y-axis.

Decl.:  fix31 vst_setsize32( WORD handle, fix31 width,
                             WORD *char_width, WORD *char_height,
                             WORD *cell_width, WORD *cell_height );
Call:   set_width = vst_setsize32( handle, width, &char_width, &char_height,
                                   &cell_width, &cell_height );

Variable         Arguments           Meaning
Input:

contrl[0]        252                 vst_setsize32
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0..1]      width               relative width in 1/65536 points

Output:

contrl[2]        2                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0..1]     set_width           selected width in 1/65536 points
ptsout[0]        char_width          selected character width
ptsout[1]        char_height         selected character height
ptsout[2]        cell_width          selected character cell width
ptsout[3]        cell_height         selected character cell height


ù SET OUTLINE FONT SKEW (VDI 253)

This function sets the skew of vector font characters in steps of 1/10 degrees. 
The skewing angle is independent from vst_effects() and must be in a range 
between -90 and +90 degrees. Positive angles will lean the characters to the 
left whereas negative angles will lean them to the right.

Decl.:  WORD  vst_skew( WORD handle, WORD skew );
Call:   set_skew = vst_skew( handle, skew );

Variable         Arguments           Meaning
Input:

contrl[0]        253                 vst_skew
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         skew                angle in 1/10 degrees

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_skew            selected angle in 1/10 degrees




Raster Operations
=================

ù COPY RASTER, OPAQUE (VDI 109)

"COPY RASTER, OPAQUE" copies a rectangular raster onto another rectangular 
raster and performs the specified logic operations. Both rasters must be in 
device-specific format or they must have only one plane.

If the screen (or the device specified by <handle>) is the source or destination 
of a raster operation, the MFDB structure element fd_addr should be zero!

The clipping rectangle for the destination raster is enabled only if fd_addr of 
the destination MFDB is zero.

The source rectangle will not be clipped (it must be within the raster area).

Decl.:  void vro_cpyfm( WORD handle, WORD vr_mode, WORD *xyarr,
                        MFDB *src_MFDB, MFDB *des_MFDB );
Call:   vro_cpyfm( handle, wr_mode, xyarr, &src_MFDB, &des_MFDB );

Variable         Arguments           Meaning
Input:

contrl[0]        109                 vro_cpyfm
contrl[1]        4                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
contrl[7..8]     src_MFDB            pointer to the source MFDB
contrl[9..10]    des_MFDB            pointer to the destination MFDB
intin[0]         wr_mode             logical operation
ptsin[0..7]      xyarr[0..7]         coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of wr_mode (logical operations):
0:  result=0
1:  result=source and destination
2:  result=source and (not destination)
3:  result=source
4:  result=(not source) and destination
5:  result=destination (!)
6:  result=source xor destination
7:  result=source or destination
8:  result=not (source or destination)
9:  result=not (source xor destination)
10: result=not destination
11: result=source or (not destination)
12: result=not source
13: result=(not source) or destination
14: result=not (source and destination)
15: result=1

Meaning of xyarr:
xyarr[0..3]: coordinates of the source rectangle
xyarr[4..7]: coordinates of the destination rectangle

Note:
Usually vro_cpyfm() ignores the height and width of the destination rectangle 
and uses the size of the source. If you want to scale a bitmap, you have to 
set the most significant bit in the transfer mode (wr_mode | 0x8000). In this
case vro_cpyfm() scales the bitmap according to the size of the destination 
rectangle. Wheter the driver is able to scale or not is returned by vq_extnd() 
in work_out[30] (you are only allowed to set the upper bit of the mode if it 
is able to).


ù COPY RASTER, TRANSPARENT (VDI 121)

This function expands a monochrome raster (one plane) considering the 
foreground and background color and copies the raster onto the destination 
raster using the specified writing mode.

If the screen is the destination raster, fd_addr should be zero!

Decl.:  void vrt_cpyfm( WORD handle, WORD wr_mode, WORD *xyarr,
                        MFDB *src_MFDB, MFDB *des_MFDB, WORD *color_index );
Call:   vrt_cpyfm( handle, wr_mode, xyarr, &src_MFDB, &des_MFDB, color_index );

Variable         Arguments           Meaning
Input:

contrl[0]        121                 vrt_cpyfm
contrl[1]        4                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[6]        handle
contrl[7..8]     src_MFDB            pointer to the source MFDB
contrl[9..10]    des_MFDB            pointer to the destination MFDB
intin[0]         wr_mode             writing mode
intin[1]         color_index[0]      color index for "black" points
intin[2]         color_index[1]      color index for "white" points
ptsin[0..7]      xyarr[0..7]         coordinates

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of xyarr:
xyarr[0..3]: coordinates of the source rectangle
xyarr[4..7]: coordinates of the destination rectangle

Note:
Usually vrt_cpyfm() ignores the height and width of the destination rectangle 
and uses the size of the source. If you want to scale a bitmap, you have to 
set the most significant bit in the transfer mode (wr_mode | 0x8000). In this
case vrt_cpyfm() scales the bitmap according to the size of the destination 
rectangle. Wheter the driver is able to scale or not is returned by vq_extnd() 
in work_out[30] (you are only allowed to set the upper bit of the mode if it 
is able to).


ù TRANSFORM FORM (VDI 110)

This function transforms a raster from standard format to device-specific format 
and vice-versa. The transformation can be "in place" which means that both MFDBs 
point to the same address. In this case transforming a big bitmap takes ages...

Decl.:  void vr_trnfm( WORD handle, MFDB *src_MFDB, MFDB *des_MFDB );
Call:   vr_trnfm( handle, &src_MFDB, &des_MFDB );

Variable         Arguments           Meaning
Input:

contrl[0]        110                 vr_trnfm
contrl[1]        0                   entries in ptsin
contrl[2]        0                   entries in ptsout
contrl[3]        0                   entries in intin
contrl[4]        0                   entries in intout
contrl[6]        handle
contrl[7..8]     src_MFDB            pointer to the source MFDB
contrl[9..10]    des_MFDB            pointer to the destination MFDB


ù GET PIXEL (VDI 105)

On a device with up to 8 planes (256 simultaneously displayable colors) this 
function returns the value and the color index of a pixel.

In HiColor (15 or 16 bits) <pel> contains the pixel value and index is 
usually -1.

In TrueColor <pel> ist the low word and <index> the high word of the pixel value.

Decl.:  void v_get_pixel( WORD handle, WORD x, WORD y, WORD *pel, WORD *index );
Call:   v_get_pixel( handle, x, y, &pel, & index );

Variable         Arguments           Meaning
Input:

contrl[0]        105                 v_get_pixel
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0]         x
ptsin[1]         y

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        pel                 pixel value
intout[1]        index               color index


Raster Operations and Offscreen Bitmaps
ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
Copying rasters from screen to bitmap and vice versa should be done in device 
specific format.

If the destination of a call is the offscreen bitmap and if the used handle is
the handle of the bitmap, the raster will be clipped according to the rectangle 
specified by vs_clip().

If the destination is the screen, you should use the screen's handle as input 
parameter and the raster will be clipped according to the clipping rectangle of 
this screen workstation. 




Input Functions
===============

The input functions allow user interactions with the application program. 

The input function are designed for use by the owner of the physical screen 
workstation - the AES. As long as there is no particular reason, an application 
should always use the event calls of the AES. Otherwise you might steal other 
applcations' events.


ù SET INPUT MODE (VDI 33)

This functions sets the input mode for the specified device <dev_type>.

Decl.:  void vsin_mode( WORD handle, WORD dev_type, WORD mode );
Call:   vsin_mode( handle, dev_type, mode );

Variable         Arguments           Meaning
Input:

contrl[0]        33                  vsin_mode
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         dev_type            input device
intin[1]         mode                requested input mode

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_mode            selected input mode

Meaning of dev_type:
1: Mouse
2: Cursor
3: Function keys
4: Keyboard

Meaning of mode:
REQUEST MODE   1: wait until input data is available
SAMPLE MODE    2: return device status and input data (if available)


ù INPUT LOCATOR, REQUEST MODE (VDI 28)

"INPUT LOCATOR" returns the position of the mouse. You can use this function to 
change the position of the mouse cursor (but you should not because it will only 
irritate the user). This functions waits until a mouse button is pressed.

Decl.:  void vrq_locator( WORD handle, WORD x, WORD y, WORD *xout,
                               WORD *yout, WORD *term );
Call:   vrq_locator( handle, x, y, &xout, &yout, &term );

Variable         Arguments           Meaning
Input:

contrl[0]        28                  vrq_locator
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0]         x                   new x-coordinate of the mouse cursor
ptsin[1]         y                   new y-coordinate of the mouse cursor

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        term                Maustastenstatus+31
ptsout[0]        xout                old x-coordinate of the mouse cursor
ptsout[1]        yout                old x-coordinate of the mouse cursor


ù INPUT LOCATOR, SAMPLE MODE (VDI 28)

This functions returns the coordinates of the mouse cursor and sets new 
coordinates. contrl[2] and contrl[4] specifiy if the mouse has been moved or a 
button has been pressed.

Decl.:  WORD vsm_locator( WORD handle,  WORD x,  WORD y,  WORD *xout,
                          WORD *yout, WORD *term );
Call:   status = vsm_locator( handle, x, y, &xout, &yout, &term );

Variable         Arguments           Meaning
Input:

contrl[0]        28                  vsm_locator
contrl[1]        1                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
ptsin[0]         x                   new x-coordinate of the mouse cursor
ptsin[1]         y                   new y-coordinate of the mouse cursor

Output:

contrl[2]        0 or 1              entries in ptsout
contrl[4]        0 or 1              entries in intout
intout[0]        term                mouse button + 31
ptsout[0]        xout                old x-coordinate of the mouse cursor
ptsout[1]        yout                old y-coordinate of the mouse cursor

Meaning of status (is (contrl[4]<<1)|contrl[2])):
0: mouse movement
1: button pressed


ù INPUT CHOICE, REQUEST MODE (VDI 30)

This function returns the number of the function key pressed.

Decl.:  void vrq_choice( WORD handle, WORD ch_in, WORD *ch_out );
Call:   vrq_choice( handle, ch_in, &ch_out );

Variable         Arguments           Meaning
Input:

contrl[0]        30                  vrq_choice
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         ch_in               initialisierende Taste (0)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        ch_out              ausgew„hlte Funktionstaste


ù INPUT CHOICE, SAMPLE MODE (VDI 30)

If a function key has been pressed "INPUT CHOICE" returns its number.

Decl.:  WORD vsm_choice( WORD handle, WORD *choice );
Call:   status = vsm_choice( handle, &choice );

Variable         Arguments           Meaning
Input:

contrl[0]        30                  vsm_choice
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0 or 1              entries in intout
intout[0]        choice              key number (1-10)

Meaning of status (contrl[4]):
0: no key
1: key pressed


ù INPUT STRING,REQUEST MODE (VDI 31)

This function returns a string from the keyboard. "INPUT STRING, REQUEST MODE" 
returns if the maximum string length is reached or if the user has pressed 
RETURN.

Decl.:  void vrq_string( WORD handle, WORD max_length, WORD echo_mode,
                              WORD *echo_xy, BYTE *string );
Call:   vrq_string( handle, max_length, echo_mode, echo_xy, string );

Variable         Arguments           Meaning
Input:

contrl[0]        31                  vrq_string
contrl[1]        1                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         max_length          maximum string length
intin[1]         echo_mode           0: no output 1: echo
ptsin[0]         echo_xy[0]
ptsin[1]         echo_xy[1]

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        n                   entries in intout
intout[0..n-1]   string[0..n-1]      input buffer

Meaning of max_length:
max_length is the maximum length of the string returned in intout. If max_length 
is negative, the absolute value is considered to be the maximum length and scan 
codes are returned instead of ASCII values.


ù INPUT STRING,SAMPLE MODE (VDI 31)

This function returns a string from the keyboard. "INPUT STRING, SAMPLE MODE" 
returns if the maximum string length is reached, if the user has pressed RETURN 
or if the user has not pressed a key.

Decl.:  WORD vsm_string( WORD handle, WORD max_length, WORD echo_mode,
                             WORD *echo_xy, BYTE *string );
Call:   status = vsm_string( handle,  max_length, echo_mode, echo_xy, string );

Variable         Arguments           Meaning
Input:

contrl[0]        31                  vsm_string
contrl[1]        1                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[6]        handle
intin[0]         max_length          maximum string length
intin[1]         echo_mode           0: no output 1: echo
ptsin[0]         echo_xy[0]
ptsin[1]         echo_xy[1]

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        n                   entries in intout
intout[0..n-1]   string[0..n-1]      input buffer

Meaning of max_length:
max_length is the maximum length of the string returned in intout. If max_length 
is negative, the absolute value is considered to be the maximum length and scan 
codes are returned instead of ASCII values.
Codes werden Scan-Codes bergeben.

Meaning of status (contrl[4]):
0:    no input
<> 0: length of the string


ù SET MOUSE FORM (VDI 111)

This function modifies the appearance of the mouse cursor.

Decl.:  void vsc_form( WORD handle, WORD *cursor );
Call:   vsc_form( handle, cursor );

Variable         Arguments           Meaning
Input:

contrl[0]        111                 vsc_form
contrl[1]        0                   entries in ptsin
contrl[3]        37                  entries in intin
contrl[6]        handle
intin[0..36]     cursor[0..36]       cursor data

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of cursor:
pcur_form[0]:       x-coordinate of hot spot
pcur_form[1]:       y-coordinate of hot spot
pcur_form[2]:       must be 1 (REPLACE)
pcur_form[3]:       background color
pcur_form[4]:       foreground color
pcur_form[5..20]:   background mask
pcur_form[21..36]:  foreground mask

Note:
Use graf_mouse() to change the mouse cursor!

Inquire cursor form:

Variable         Arguments           Meaning
Input:

contrl[0]        111                 vgc_form
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        37                  entries in intout
intout[0..36]    cursor[0..36]       cursor data


ù INQUIRE INPUT MODE (VDI 115)

"INQUIRE INPUT MODE" inquires the input mode of the specified device.

Decl.:  void vqin_mode( WORD handle, WORD dev_type, WORD *input_mode );
Call:   vqin_mode( handle, dev_type, &input_mode );

Variable         Arguments           Meaning
Input:

contrl[0]        115                 vqin_mode
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         dev_type            input device (see vsin_mode)

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[1]        input_mode          mode


ù EXCHANGE TIMER INTERRUPT VECTOR (VDI 118)

You can use this function to establish a function in the timer interrupt 
(etv_timer). The subroutine has to save and restore modified registers and call 
the old timer routine.

Decl.:  void vex_timv( WORD handle, void *tim_addr, void **otim_addr,
                       WORD *tim_conv );
Call:   vex_timv( handle, tim_addr, &otim_addr, &tim_conv );

Variable         Arguments           Meaning
Input:

contrl[0]        118                 vex_timv
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
contrl[7..8]     tim_addr            address of the new timer routine

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
contrl[9..10]    otim_addr           address of the old timer routine
intout[0]        tim_conv            interrupt interval in ms


ù SHOW CURSOR (VDI 122)

"SHOW CURSOR" 'neutralizes' a preceding call of "HIDE CURSOR". If you want to 
display the mouse cursor immediately without regard to the hide counter, the 
paramter <reset> has to be zero.                               

Decl.:  void v_show_c( WORD handle, WORD reset );
Call:   v_show_c( handle, reset );

Variable         Arguments           Meaning
Input:

contrl[0]        122                 v_show_c
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[6]        handle
intin[0]         reset

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Meaning of reset:
0:    display cursor immediately
<> 0: decrement hide counter and display cursor if necessary

Note:
Use graf_mouse() to switch the cursor on or off.


ù HIDE CURSOR (VDI 123)

This function switches the mouse cursor off.

Decl.:  void v_hide_c( WORD handle );
Call:   v_hide_c( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        123                 v_hide_c
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Note:
Use graf_mouse() to switch the cursor on or off.


ù SAMPLE MOUSE BUTTON STATE (VDI 124)

This function returns the state of the mouse buttons and the mosue position.

Decl.:  void vq_mouse( WORD handle, WORD *status, WORD *x, WORD *y );
Call:   vq_mouse( handle, &status, &x, &y );

Variable         Arguments           Meaning
Input:

contrl[0]        124                 vq_mouse
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        1                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        status              button status
ptsout[0]        x
ptsout[1]        y

Note:
Use graf_mkstate() or the event functions of the AES.


ù EXCHANGE BUTTON CHANGE VECTOR (VDI 125)

"EXCHANGE BUTTON CHANGE VECTOR" installs a routine which is called when a mouse 
button is pressed. Register d0.w contains the button state. The subroutine must 
save and restore modified registers and call the old status routine.

Decl.:  void vex_butv( WORD handle, void *pusrcode, void **psavcode );
Call:   vex_butv( handle, pusrcode, &psavcode );

Variable         Arguments           Meaning
Input:

contrl[0]        125                 vex_butv
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
contrl[7..8]     pusrcode            address of the new routine

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout
contrl[9..10]    psavcode            address of the old routine


ù EXCHANGE MOUSE MOVEMENT VECTOR (VDI 126)

This function establishes a routine in the mouse interrupt. The routine will be
called if the mouse is moved and d0.w/d1.w contain the coordinates of the mouse 
cursor. The subroutine must save and restore modified registers and call the old 
interrupt routine. 

Decl.:  void vex_motv( WORD handle, void *pusrcode, void **psavcode );
Call:   vex_motv( handle, pusrcode, &psavcode );

Variable         Arguments           Meaning
Input:

contrl[0]        126                 vex_motv
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
contrl[7..8]     pusrcode            Adresse der neuen Routine

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout
contrl[9..10]    psavcode            Adresse der alten Routine


ù EXCHANGE CURCOR CHANGE VECTOR (VDI 127)

This function establishes a routine in the mouse interrupt. The routine will be
called if the mouse is moved and d0.w/d1.w contain the coordinates of the mouse 
cursor. The subroutine must save and restore modified registers and call the old 
interrupt routine. 

Please note that this interrupt routine is called after the one installed by 
vex_motv(). In contrast to the preceding routine, the mouse coordinates have 
been clipped.

Decl.:  void vex_curv( WORD handle, void *pusrcode, void **psavcode );
Call:   vex_curv( handle, pusrcode, &psavcode );

Variable         Arguments           Meaning
Input:

contrl[0]        127                 vex_curv
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle
contrl[7..8]     pusrcode            address of the new routine

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout
contrl[9..10]    psavcode            address of the old routine


ù SAMPLE KEYBOARD STATE INFORMATION (VDI 128)

"SAMPLE KEYBOARD STATE INFORMATION" returns the state of CONTROL, ALTERNATE 
and the SHIFT key(s).

Decl.:  void vq_key_s( WORD handle, WORD *status );
Call:   vq_key_s( handle, &status );

Variable         Arguments           Meaning
Input:

contrl[0]        128                 vq_key_s
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        pstatus             keyboard state

Meaning of pstatus (bit numbers):
0: Shift right
1: Shift left
2: Control
3: Alternate

Note:
Use the AES event functions to inquire the keyboard state.




Text Mode and VT52
==================

ù INQUIRE ADDRESSABLE ALPHA CHARACTER CELLS (VDI 5, ESCAPE 1)

This call returns the number of columns and rows/lines of the text screen. If 
<rows> and <columns> are 0, the device does not support text mode.

Decl.:  void vq_chcells( WORD handle, WORD *rows, WORD *columns );
Call:   vq_chcells( handle, &rows, &columns );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        1                   vq_chcells
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        rows                number of lines
intout[1]        columns             number of columns


ù EXIT ALPHA MODE (VDI 5, ESCAPE 2)

"EXIT ALPHA MODE" switches back to graphics mode.

Decl.:  void v_exit_cur( WORD handle );
Call:   v_exit_cur( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        2                   v_exit_cur
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ENTER ALPHA MODE (VDI 5, ESCAPE 3)

This function enables text mode. The screen is cleared and the text cursor is 
displayed in the upper left cell of the screen.

Decl.:  void v_enter_cur( WORD handle );
Call:   v_enter_cur( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        3                   v_enter_cur
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ALPHA CURSOR UP (VDI 5, ESCAPE 4)

The cursor is moved up one row. If the cursor is already in the first row, 
nothing happens.

Decl.:  void v_curup( WORD handle );
Call:   v_curup( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        4                   v_curup
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ALPHA CURSOR DOWN (VDI 5, ESCAPE 5)

"ALPHA CURSOR DOWN" moves the cursor down one row. If the cursor is already in 
the last row, nothing happens.

Decl.:  void v_curdown( WORD handle );
Call:   v_curdown( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        5                   v_curdown
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ALPHA CURSOR RIGHT (VDI 5, ESCAPE 6)

"ALPHA CURSOR RIGHT" moves the cursor right. If the cursor is already in the 
last column, nothing happens.

Decl.:  void v_curright( WORD handle );
Call:   v_curright( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        6                   v_curright
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ALPHA CURSOR LEFT (VDI 5, ESCAPE 7)

The cursor is moved left. If it is already in the first column, nothing happens.

Decl.:  void v_curleft( WORD handle );
Call:   v_curleft( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        7                   v_curleft
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù HOME ALPHA CURSOR (VDI 5, ESCAPE 8)

This function moves the cursor to the upper left character cell.

Decl.:  void v_curhome( WORD handle );
Call:   v_curhome( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        8                   v_curhome
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ERASE TO END OF ALPHA SRCEEN (VDI 5, ESCAPE 9)

The screen is erased from the cursor position to the end of the screen.

Decl.:  void v_eeos( WORD handle );
Call:   v_eeos( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        9                   v_eeos
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù ERASE TO END OF ALPHA TEXT LINE (VDI 5, ESCAPE 10)

This function erases the screen from the cursor position to the end of line.

Decl.:  void v_eeol( WORD handle );
Call:   v_eeol( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        10                  v_eeol
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù DIRECT ALPHA CURSOR ADDRESS (VDI 5, ESCAPE 11)

"DIRECT ALPHA CURSOR ADDRESS" moves the cursor to <row> and <column>.

Decl.:  void v_curaddress( WORD handle, WORD row, WORD column );
Call:   v_curadress( handle, row, column );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        11                  v_curaddress
contrl[6]        handle
intin[0]         row
intin[1]         column

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù OUTPUT CURSOR ADDRESSABLE ALPHA TEXT (VDI 5, ESCAPE 12)

This function displays a string. The string starts at the current cursor 
position.

Decl.:  void v_curtext( WORD handle, BYTE *string );
Call:   v_curtext( handle, string );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[5]        12                  v_curtext
contrl[6]        handle
intin[0..n-1]    string[0..n-1]

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù REVERSE VIDEO ON (VDI 5, ESCAPE 13)

After calling this function text will be displayed reverse.

Decl.:  void v_rvon( WORD handle );
Call:   v_rvon( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        13                  v_rvon
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù REVERSE VIDEO OFF (VDI 5, ESCAPE 14)

This call switches reverse text output off.

Decl.:  void v_rvoff( WORD handle );
Call:   v_rvoff( handle );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        14                  v_rvoff
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù INQUIRE CURRENT ALPHA CURCOR ADDRESS (VDI 5, ESCAPE 15)

This call returns the current cursor position.

Decl.:  void vq_curaddress( WORD handle, WORD *row, WORD *column );
Call:   vq_curaddress( handle, &row, &column );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        15                  vq_curaddress
contrl[6]        handle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        row                 Zeile
intout[1]        column              Spalte




Printer specific functions
==========================


The following functions do not exist on every printer. Before you make
use of their return values, you should check, if there are any 
(contrl[2] and contrl[4]).

Functions like v_orient() or v_page_size() might have to allocate memory 
from the OS. If there is not enough memory which is indicated by a 
corresponding return value, you should close the driver via v_clswk(). 


ù OPEN WORKSTATION (VDI 1)

This call can be used to set the page size and the GEMDOS device:

See "Device Drivers and Offscreen Bitmaps".


ù EXTENDED INQUIRE FUNCTION (VDI 102)

NVDI drivers return the page size and the size of the unprintable margins.
Refer to "Device Drivers and Offscreen Bitmaps" for more information.


ù OUTPUT BIT IMAGE FILE (VDI 5, ESCAPE 23)

Decl.:  void v_bit_image( WORD handle, BYTE *name, WORD aspect, 
                          WORD x_scale, WORD y_scale, WORD h_align,
                          WORD v_align, WORD *xyarray );

Call:   void v_bit_image( handle, name, aspect, x_scale, y_scale,
                          h_align, v_align, xyarray );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        5 + n               entries in intin
contrl[5]        23                  v_bit_image
contrl[6]        handle
intin[0]         aspect              
intin[1]         x_scale             
intin[2]         y_scale             
intin[3]         h_align             horizontal alignment
intin[4]         v_align             vertical alignment
intin[5..n+4]    file_name[...]      file name
ptsin[0..3]      xyarray[0..3]       output rectangle

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù SET ORIENTATION (VDI 5, ESCAPE 27)

This function is used for switching between portrait and landscape 
output of a page. If <orient> is -1, the current orientation is returned.

If there is not enough memory to change the orientation, v_orient returns -1.
If that is the case you have to close the driver via v_clswk().

The function is not supported if contrl[4] is 0.

Decl.:  WORD v_orient( WORD handle, WORD orient );
Call:   set_orient = v_orient( handle, orient );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[5]        27                  v_orient
contrl[6]        handle
intin[0]         orient              requested orientation

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_orient          realized orientation

Meaning of <orient>:
-1: just return orientation
0:  set to portrait
1:  set to landscape

Meaning of <set_orient>:
-1: error (not enough memory) => close the driver
0:  portrait
1:  landscape


ù SET NUMBER OF COPIES (VDI 5, ESCAPE 28)

Use v_copies() to set the number of copies of a page. If <copies> is 
-1, the number of copies is returned.

The function is not supported if contrl[4] is 0.

Decl.:  WORD v_copies( WORD handle, WORD copies );
Call:   set_copies = v_copies( handle, copies );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[5]        28                  v_copies
contrl[6]        handle
intin[0]         copies              number of copies (including the "original one")

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_copies


ù SET INPUT AND OUTPUT TRAY (VDI 5, ESCAPE 29)

SET INPUT AND OUTPUT TRAY to specify the paper trays. If the requested 
tray does not exist, the standard tray will be selected (input 0 and 
output 0).

Call vq_tray_names() to inquire their names.

The function is not supported if contrl[4] is 0.

Decl.:  void v_trays( WORD handle, WORD input, WORD output,
                      WORD *set_input, WORD *set_output );
Call:   v_trays( handle, input, output, &set_input, &set_output );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        2                   entries in intin
contrl[5]        29                  v_tray
contrl[6]        handle
intin[0]         input               requested input tray
intin[1]         output              requested output tray

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        set_input           input tray
intout[1]        set_output          output tray

Meaning of <input>:
-1: manual input
0:  default input (tray 1)
1:  tray 2
...

Meaning of <output>:
0: standard output (usually front)
1: output 2
...


ù INQUIRE TRAY NAMES (VDI 5, ESCAPE 36)

INQUIRE TRAY NAMES returns the names of the current input and output tray.
If <input_name> or <output_name> are 0L, they will not be returned.

The function is not supported if contrl[4] is 0.

Decl.:  void vq_tray_names( WORD handle, BYTE *input_name, BYTE *output_name,
                            WORD *input, WORD *output );
Call:   vq_tray_names( handle, input_name, output_name, &input, &output );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        4                   entries in intin
contrl[5]        36                  vq_tray_names
contrl[6]        handle
intin[0/1]       input_name          pointer to the name of the input tray
intin[2/3]       output_name         pointer to the name of the output tray

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        2                   entries in intout
intout[0]        input               number of the input tray
intout[1]        output              number of the output tray


ù SET PAGE SIZE (VDI 5, ESCAPE 37)

v_page_size() sets the requested page size (if the page size is defined). 
If the requested size does not exist, the default setting will be used.

If the return value <set_page> is -1, you have to close the driver because 
there is not enough memory.

The function is not supported if contrl[4] is 0.

Decl.:  WORD v_page_size( WORD handle, WORD page_id );
Call:   set_page = v_page_size( handle, page_id );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[5]        37                  v_page_size
contrl[6]        handle
intin[0]         page_id             page size

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        1                   entries in intout
intout[0]        set_page            set page size

Meaning of <page_id>:
0:  PAGE_DEFAULT
1:  PAGE_A3, DIN A3
2:  PAGE_A4, DIN A4
3:  PAGE_A5, DIN A5
4:  PAGE_B5, DIN B5

16: PAGE_LETTER, Letter size
17: PAGE_HALF, Half size
18: PAGE_LEGAL, Legal size
19: PAGE_DOUBLE, Double size
20: PAGE_BROAD, Broad sheet size

Meaning of <set_page>:
-1: error (not enough memory) => close the driver
else <page_size>


ù INQUIRE PAGE NAME (VDI 5, ESCAPE 38)

INQURIE PAGE NAME can be used to determine the name of a paper format and 
its physical size (height and width including the non-printable margins).

If <set_page> is -1, the paper format is not defined and its size cannot 
be returned.

The function is not supported if contrl[4] is 0.

Decl.:  WORD vq_page_name( WORD handle, WORD page_id, BYTE *page_name,
                           LONG *page_width, LONG *page_height );
Call:   set_page = vq_page_name( handle, page_id, page_name,
                                 &page_width, &page_height );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[5]        38                  vq_page_name
contrl[6]        handle
intin[0]         page_id             paper format
intin[1/2]       page_name           pointer to the name

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        5                   entries in intout
intout[0]        set_page            paper format or -1 (error)
intout[1/2]      page_width          width in micro meters
intout[3/4]      page_height         height in micro meters.


ù ESCAPE 2000 (VDI 5, ESCAPE 2000)

In contrast to v_copies() (ESCAPE 28) this function sets the number of 
copies additional to the "original" page.

Decl.:  void v_escape2000( WORD handle, WORD times );
Call:   v_escape2000( handle, times );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        1                   entries in intin
contrl[5]        2000                v_escape2000
contrl[6]        handle
intin[0]         times               number of additional copies

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Note:
Not every printer driver supports this call and since it has no return 
values, you cannot inquire if it exists. Use v_copies()...




Metafile specific functions
===========================

ù OUTPUT BIT IMAGE FILE (VDI 5, ESCAPE 23)

The name of an IMG is saved in the metafile:

See "Printer specific functions"


ù UPDATE METAFILE EXTENTS (VDI 5, ESCAPE 98)

This call updates the extent of the metafile graphic and saves it in the 
metafile header.

Decl.:  void v_meta_extents( WORD handle, WORD x_min, WORD y_min,
                             WORD x_max, WORD y_max );
Call:   v_meta_extents( handle, x_min, y_min, x_max, y_max );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        2                   entries in ptsin
contrl[3]        0                   entries in intin
contrl[5]        98                  v_meta_extents
contrl[6]        handle
ptsin[0]         x_min
ptsin[1]         y_min
ptsin[2]         x_max
ptsin[3]         y_max

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù WRITE METAFILE ITEM (VDI 5, ESCAPE 99)

WRITE METAFILE ITEM allows you to save application specific opcodes in a 
metafile. Opcodes 0 to 100 are reserved, the range above it can be used.

The opcode is stored in a_intin[0].

Decl.:  void v_write_meta( WORD handle, WORD num_intin, WORD *a_intin,
                           WORD num_ptsin, WORD *a_ptsin );
Call:   void v_write_meta( handle, num_intin, a_intin, num_ptsin, a_ptsin );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        num_ptsin           entries in ptsin
contrl[3]        num_intin           entries in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         a_intin[0]          opcode
intin[1..num_intin - 1] a_intin[..]  application specific information
ptsin[0..num_ptsin - 1] a_ptsin[..]  application specific information

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù PHYSICAL PAGE SIZE (VDI 5, ESCAPE 99, Opcode 0)

...is a sub-opcode of WRITE METAFILE ITEM and sets the page size in 1/10 mm.

Decl.:  void vm_pagesize( WORD handle, WORD pgwidth, WORD pgheight );
Call:   vm_pagesize( handle, pgwidth, pgheight );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        3                   entries in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         0                   vm_pagesize
intin[1]         pgwidth             width in 1/10 mm
intin[2]         pgheight            height in 1/10 mm

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù COORDINATE WINDOW (VDI 5, ESCAPE 99, Opcode 1)

...is a sub-opcode of WRITE METAFILE ITEM and sets the used coordinate system.

Decl.:  void vm_coords( WORD handle, WORD llx, WORD lly,
                        WORD urx, WORD ury );
Call:   vm_coords( handle, llx, lly, urx, ury );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        5                   entries in intin
contrl[5]        99                  v_write_meta
contrl[6]        handle
intin[0]         1                   vm_coords
intin[1]         llx                 x-Koordinate links unten
intin[2]         lly                 y-Koordinate links unten
intin[3]         urx                 x-Koordinate rechts oben
intin[4]         ury                 y-Koordinate rechts oben

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout


ù CHANGE GEM VDI FILE NAME (VDI 5, ESCAPE 100)

This function should be used to change the name of the metafile. The 
name <filename> must be an absolute path like "E:\PICS\FLIWATšT.GEM".

The metafile in the current directory created by v_opnwk() ("GEMFILE.GEM")
will be closed (and deleted by NVDI). Therefore vm_filename() should be 
called after v_opnwk().

Decl.:  void vm_filename( WORD handle, BYTE *filename );
Call:   vm_filename( handle, filename );

Variable         Arguments           Meaning
Input:

contrl[0]        5                   ESCAPE
contrl[1]        0                   entries in ptsin
contrl[3]        n                   entries in intin
contrl[5]        100                 vm_filename
contrl[6]        handle
intin[0..n - 1]  filename[0..n-1]    file name

Output:

contrl[2]        0                   entries in ptsout
contrl[4]        0                   entries in intout

Note:
Old metafile driver may not delete the default file "GEMFILE.GEM" when 
you call vm_filename(). That means that you are on the safe side if you 
call Fdelete() after vm_filename() and try to delete GEMFILE.GEM.




Sample Bindings
===============

These bindings assume, that <pb>, <contrl>, <intin>, <ptsin>, <intout> and
<ptsout> are global variables. The function vdi() is defined as 
void vdi( VDIPB *pb ). WORD, UWORD etc. are usually defined in PORTAB.H, 
fix31 should ebe defined as LONG.

/* structure definitions */

typedef struct
{
   void  *fd_addr;   /* address of the bitmap or 0 for screen/offscreen bitmap 
   WORD  fd_w;       /* width in pixels */
   WORD  fd_h;       /* height in pixels */
   WORD  fd_wdwidth; /* width of a line in words (per plane) */
   WORD  fd_stand;   /* 0: device specific format, 1: standard format */
   WORD  fd_nplanes; /* number of planes */
   WORD  fd_r1;      /* reserved, must be 0 */
   WORD  fd_r2;      /* reserved, must be 0 */
   WORD  fd_r3;      /* reserved, must be 0 */
} MFDB;

typedef struct
{
   WORD  red;        /* red intensity in per mille */
   WORD  green;      /* green intensity in per mille */
   WORD  blue;       /* blue intensity in per mille */
} RGB1000;

typedef struct
{
   LONG  size;             /* length of the structure, initialize this entry before calling vqt_xfntinfo() */
   WORD  format;           /* font format, e.g. 4 for TrueType */
   WORD  id;               /* font ID, e.g. 6059 */
   WORD  index;            /* index */
   BYTE  font_name[50];    /* font name, e.g. "Century 725 Italic BT" */
   BYTE  family_name[50];  /* name of the font family, e.g. "Century725 BT" */
   BYTE  style_name[50];   /* name of the font style, e.g. "Italic" */
   BYTE  file_name1[200];  /* name of the first font file, e.g. "C:\FONTS\TT1059M_.TTF" */
   BYTE  file_name2[200];  /* name of the 2nd font file */
   BYTE  file_name3[200];  /* name of the 3rd font file */
   WORD  pt_cnt;           /* number of available point sizes (vst_point()), e.g. 10 */
   WORD  pt_sizes[64];     /* available point sizes,
                              e.g. { 8, 9, 10, 11, 12, 14, 18, 24, 36, 48 } */
} XFNT_INFO;

/* prototypes */
void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len );
WORD  c_str_to_vdi( UBYTE *src, UWORD *des );
WORD  fix31_to_pixel( fix31 a );
void  vs_color( WORD handle, WORD index, RGB1000 *rgb_in );
WORD  vq_color( WORD handle, WORD color_index, WORD flag, RGB1000 *rgb_out );
WORD  vs_calibrate( WORD handle, WORD flag, RGB1000 *table );
WORD  vq_calibrate( WORD handle, WORD *flag );
void  v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out );
void  v_clsbm( WORD handle );
void  vq_scrninfo( WORD handle, WORD *work_out );
WORD  vq_devinfo2( WORD handle, WORD device, WORD *dev_exists, BYTE *file_name, BYTE *real_name );
WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                      BYTE *file_path, BYTE *file_name, BYTE *name );
WORD  vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format, UWORD *flags );
void  vst_width( WORD handle, WORD width, WORD *char_width, WORD *char_height,
                 WORD *cell_width, WORD *cell_height );
void  vst_track_offset( WORD handle, fix31 offset, WORD pair_mode, WORD *tracks, WORD *pairs );
void  vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string, WORD *extent );
WORD  vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index, XFNT_INFO *info );
WORD  vst_name( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name );
WORD  vqt_name_and_id( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name );

/* VDI-String in einen C-String umwandeln */
void  vdi_str_to_c( UWORD *src, UBYTE *des, WORD len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE) *src++;   /* nur das Low-Byte kopieren */
      len--;
   }
   *des++ = 0;                   /* Ende des Strings */
}

/* C-String in einen VDI-String umwandeln */
WORD  c_str_to_vdi( UBYTE *src, UWORD *des )
{
   WORD  len;

   len = 0;
   
   while (( *des++ = *src++ ) != 0 )
      len++;

   return( len );                /* L„nge des Strings ohne Null-Byte */
}

/* Positionsangabe in fix31-Darstellung in Pixel-Koordinate umrechnen */
WORD  fix31_to_pixel( fix31 a )
{
   WORD  b;

   b = (WORD) (( a + 32768L ) >> 16 ); /* runden !! */
   return( b );                        /* Pixelwert zurckgeben */
}

void  vs_color( WORD handle, WORD index, RGB1000 *rgb_in )
{
   intin[0] = index;
   intin[1] = rgb_in->red;
   intin[2] = rgb_in->green;
   intin[3] = rgb_in->blue;

   contrl[0] = 14;
   contrl[1] = 0;
   contrl[3] = 4;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );
}

WORD  vq_color( WORD handle, WORD color_index, WORD flag, RGB1000 *rgb_out )
{
   intin[0] = color_index;
   intin[1] = flag;

   contrl[0] = 26;
   contrl[1] = 0;
   contrl[3] = 2;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   *rgb_out = *(RGB1000 *) (intout + 1);
   return( intout[0] );
}

WORD  vs_calibrate( WORD handle, WORD flag, RGB1000 *table )
{
   *(RGB1000 **)intin = table;
   intin[2] = flag;

   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 3;
   contrl[5] = 76;
   contrl[6] = handle;

   vdi( &pb );

   return( intout[0] );
}

WORD  vq_calibrate( WORD handle, WORD *flag )
{
   contrl[0] = 5;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 77;
   contrl[6] = handle;

   vdi( &pb );

   if ( contrl[4] > 0 )
   {
      *flag = intout[0];
      return( 1 );
   }
   else
   {
      *flag = 0
      return( 0 );
   }
}

void  v_opnbm( WORD *work_in, MFDB *bitmap, WORD *handle, WORD *work_out )
{
   /* Wenn work_in[15..19] 0 enthalten, wird eine Bitmap im ger„tespezifischen
      Format or mit nur 1 Ebene erzeugt (h„ngt vom MFDB ab). Anderfalls wird
      versucht eine Bitmap mit der Farbanzahl <work_in[15..16]>, <work_in[17]>
      Ebenen, dem Pixelformat <work_in[18]> and der Bitreihenfolge <work_in[19]>
      anzulegen. Falls kein passender Offscreen-Treiber vorhanden ist, kann die
      Bitmap nicht ge”ffnet werden.
   */

   pb[1] = work_in;
   pb[3] = work_out;
   pb[4] = work_out + 45;

   contrl[0] = 100;
   contrl[1] = 0;
   contrl[3] = 20;
   contrl[5] = 1;
   *(MFDB **)&contrl[7] = bitmap;

   vdi( &pb );

   *handle = contrl[6];
   pb[1] = intin;
   pb[3] = intout;
   pb[4] = ptsout;
}

void  v_clsbm( WORD handle )
{
   contrl[0] = 101;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 1;
   contrl[6] = handle;
   vdi( &pb );
}

void  vq_scrninfo( WORD handle, WORD *work_out )
{
   pb[3] = work_out;

   intin[0] = 2;
   contrl[0] = 102;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi( &pb );

   pb[3] = intout;
}

WORD  vq_devinfo2( WORD handle, WORD device, WORD *dev_exists, BYTE *file_name, BYTE *real_name )
{
   contrl[0] = 248;                 /* opcode */
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[5] = 0;
   contrl[6] = handle;
   intin[0] = device;

   vdi( &pb );

   *dev_exists = 0;                 /* driver does not exist */
   *file_name = 0;
   *real_name = 0;

   if ( contrl[4] && intout[0] )    /* driver exists? */
   {
      WORD  i;
      WORD  len;

      *dev_exists = 1;              /* driver exists! */

      for ( i = 0; i < contrl[4]; i++ )
      {
         *file_name = (BYTE) intout[i];
         if ( *file_name == ' ' )    /* separated by space? */
         {
            /* letztes Leerzeichen? */
            if (( i < contrl[4] ) && ( intout[i+1] != ' ' ))
            {
               *file_name = '.';    /* replace space */
               file_name++;
            }
         }
         else
            file_name++;
      }
      *file_name++ = 0;             /* ... */

      if (( contrl[2] == 1 ) && ( contrl[1] > 0 )) /* !?+*~"Ý)%&#/(^= */
         len = contrl[1];
      else
         len = contrl[2] - 1;

      for ( i = 1; i <= len; i++ )  /* copy real name */
         *((WORD *)real_name)++ = ptsout[i];
      *real_name++ = 0;             /* terminate */
   }

   return( ptsout[0] );             /* driver open or not */
}

WORD  vq_ext_devinfo( WORD handle, WORD device, WORD *dev_exists,
                      BYTE *file_path, BYTE *file_name, BYTE *name )
{
   intin[0] = device;
   *(BYTE **)&intin[1] = file_path;
   *(BYTE **)&intin[3] = file_name;
   *(BYTE **)&intin[5] = name;

   contrl[0] = 248;
   contrl[1] = 0;
   contrl[3] = 7;
   contrl[5] = 4242;
   contrl[6] = handle;

   vdi( &pb );

   *dev_exists = intout[0];
   return( intout[1] );
}

WORD  vqt_ext_name( WORD handle, WORD index, BYTE *name, UWORD *font_format, UWORD *flags )
{
   intin[0] = index;
   intin[1] = 0;

   contrl[0] = 130;
   contrl[1] = 0;
   contrl[3] = 2;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi( &pb );

   vdi_str_to_c( (UWORD *)&intout[1], (UBYTE *) name, 31 );

   if ( contrl[4] <= 34 )
   {
      *flags = 0;
      *font_format = 0;
      if ( contrl[4] == 33 )
         name[32] = 0;
      else
         name[32] = (BYTE) intout[33];
   }
   else
   {
      name[32] = (BYTE) intout[33];
      *flags = (intout[34] >> 8) & 0xff;
      *font_format = intout[34] & 0xff;
   }

   return( intout[0] );
}

void  vst_width( WORD handle, WORD width, WORD *char_width, WORD *char_height,
                 WORD *cell_width, WORD *cell_height );
{
   ptsin[0] = width;

   contrl[0] = 231;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   *char_width = ptsout[0];
   *char_height = ptsout[1];
   *cell_width = ptsout[2];
   *cell_height = ptsout[3];
}

void  vst_track_offset( WORD handle, fix31 offset, WORD pair_mode, WORD *tracks, WORD *pairs )
{
   contrl[0] = 237;
   contrl[1] = 0;
   contrl[3] = 4;
   contrl[6] = handle;

   intin[0] = 255;
   intin[1] = pair_mode;
   *(fix31 *)&intin[2] = offset;

   vdi( &pb );

   *tracks = intout[0];
   *pairs = intout[1];
}

void  vqt_real_extent( WORD handle, WORD x, WORD y, BYTE *string, WORD *extent )
{
   WORD  len;
   WORD  i;

   ptsin[0] = x;
   ptsin[1] = y;

   len = c_str_to_vdi( (UBYTE *) string, (UWORD *) intin );

   contrl[0] = 240;
   contrl[1] = 1;
   contrl[3] = len;
   contrl[5] = 4200;
   contrl[6] = handle;

   vdi( &pb );

   for ( i = 0; i < 8; i++ )
      *extent++ = ptsout[i];
}

WORD  vqt_xfntinfo( WORD handle, WORD flags, WORD id, WORD index, XFNT_INFO *info )
{
   info->size = (LONG) sizeof( XFNT_INFO );

   intin[0] = flags;
   intin[1] = id;
   intin[2] = index;
   *(XFNT_INFO **)&intin[3] = info;

   contrl[0] = 229;
   contrl[1] = 0;
   contrl[3] = 5;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   return( intout[1] );
}

WORD  vst_name( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name )
{
   WORD  len;

   intin[0] = font_format;
   len = c_str_to_vdi( (UBYTE *) font_name, (UWORD *)&intin[1] );

   contrl[0] = 230;
   contrl[1] = 0;
   contrl[3] = 1 + len;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi( &pb );

   if ( ret_name )
      vdi_str_to_c( (UWORD *)&intout[1], ret_name, contrl[4] );

   return( intout[0] );
}

WORD  vqt_name_and_id( WORD handle, WORD font_format, BYTE *font_name, BYTE *ret_name )
{
   WORD  len;

   intin[0] = font_format;
   len = c_str_to_vdi( (UBYTE *) font_name, (UWORD *) intin + 1 );

   contrl[0] = 230;
   contrl[1] = 0;
   contrl[3] = 1 + len;
   contrl[5] = 100;
   contrl[6] = handle;

   vdi( &pb );

   if ( ret_name )
      vdi_str_to_c( (UWORD *)&intout[1], ret_name, contrl[4] );

   return( intout[0] );
}


