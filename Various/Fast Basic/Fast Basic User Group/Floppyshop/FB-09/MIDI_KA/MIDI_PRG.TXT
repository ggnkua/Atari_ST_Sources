                     Midi Programming in FAST BASIC
                    --------------------------------

                                 by
                             Kevin Adams 
                              
                            27th June 1988

     The reason I'm writing this article is that although I  don't 
consider  myself to be an expert by any means,there is  so  little 
written  about midi programming.  Learning to program to the  midi 
ports  has largely been by trial and error,so if I  can  encourage 
anybody  else  to have a go then hopefully they will  share  their 
experiences as well.
     There  are  plenty  of sources of  information  on  the  midi 
standard  (types of midi message etc) or setting up a midi  system 
but next to nothing on programming using midi.
     I  bought  my ST a little over a  year ago and  keen  to  get  
started   I   bought  the  Abacus  book  "Introduction   to   Midi 
Programming".  I'm  sure  that  this is  an  excellent  source  of 
examples to anyone conversant with 'C',but as I had a fairly  good 
backround knowledge of midi and my only programming experience was 
with 'Sinclair Basic' on the spectrum the book was of little use.
The fact I struggled on with 'ST Basic ' for a while  didn't  help 
either !
     So  I  went to a few different shops  asking  which  language 
would best suit programming to the midi ports. You can imagine the 
help  I got from the enthusiastic,well informed and eager to  help 
sales assistants we all know and love!  Yes exactly ,so eventually 
I decided I had to get FAST BASIC to make the most of the enormous 
number of articles and listings in different ST magazines.
     If only somone had told me sooner.  The FAST BASIC statements 
INP(3) and OUT 3,....   can be used for a lot of applications with 
little noticeable delay. Where speed is more critical the built in 
assembler means that those routines can be as fast as is possible.
     Just  try doing the same in ST Basic and you'll know  what  I 
mean.
     Anyway  enough waffling and down to a couple of  examples.  I 
wont  go too much into midi theory as there are plenty of  sources 
of  reference  around already.  Also I'll  assume  that  everybody 
reading this is familiar with hexadecimal as this often makes it a 
lot easier to work out what is going on.  The first issue of  FAST 
contains an explanation of hexadecimal in the machine code article 
by  William Hearn,so if you aren't familiar with it yet  then  how 
come you missed it the first time around !
     There are two main types of  midi message:  channel  messages 
and system  messages. Channel messages are,put simply the note and 
control messages which cause changes in the sound we actually hear 
ie  note  on or off,pitch bend,patch changes  etc.  Whilst  system 
messages consist of three types: system common,system realtime and 
system exclusive.  I wont be considering them here but briefly the 
first  two are used for such things as timing and  synchronization 
between devices  such as sequencers (including sequencing software 
on the ST of course),drum machines etc.  System exclusive messages 
are a way of transmitting machine specific data over midi  between 
two  compatible devices.  In other words it could be used to  send 
information for a particular sound from one synthesiser to another 
of  the  same type or to a computer for  editing,storage  etc.  Of 
course  there  are  plenty of other applications  which  use  this 
facility to send information over midi.  Sequencer or drum machine 
sequences for example.
     Back  to channel messages,as I said for the most  part  these 
messages  are  used to transmit information that will  affect  the 
sound actualy produced by a midi device. So if a note is played on 
a  midi keyboard it will send a channel message called, believe it 
or not a NOTE ON message to its midi out port.  As with most other 
channel messages this consists of three bytes.  The first byte  is 
called  the status byte and as well as telling any receiving  midi 
device  what type of message it is,also contains the midi  channel 
number for which it is intended.  There are sixteen possible  midi 
channels and receiving devices are set up to accept either channel 
messages for specific channels or all channels at once.
     Devices set up to receive on all channels are in OMNI ON mode
by  the way and any device receiving on just one specific  channel  
could  be in OMNI OFF mode (or one of several special manufacturer 
specific   modes  used  to  receive  on  one  or   more   selected 
channels).So much for the midi standard !
     A  midi note on message could consist of the following  three 
bytes (in hexadecimal): 90 3C 40
The  first byte is as said previously the status byte and as  well 
as the type of message contains the midi channel number. The 'type 
of message' is contained in the upper nibble (upper four bits) and 
the midi channel number in the lower nibble (lower four bits). The 
Note  On  status  byte can be translated to:
     9         0    Hex   
     1001      0000 Binary
     note on   midi channel
Midi  channels 1 - 16 are represented as 0 - 15 (or 0 - F in  Hex) 
so  a note on status byte for midi channel 16 would be  $9F  (from 
now on I'll use the FAST BASIC $ to denote hexadecimal).  The same 
value  would  be  159 in decimal which is  obviously  a  lot  more 
cryptic than its hexadecimal representation.
     The  next two bytes are called the data bytes and the  second 
byte  of  a  note on message is the  midi  note  value.  From  the 
previous  example  this was $3C (60 decimal) which happens  to  be 
middle  C often refered to on a keyboard as C3.  Midi note  values 
can  range  from  0 - 127 ($0 - $7F) but  a  typical  five  octave 
keyboard  might only send  note values 36 - 96 ($24 -  $60)  which 
correspond to C1 to C6.  So far then,from the example we know that 
$90 $3C $40 means a note on event,on midi channel 1 (remember  '0' 
equates to channel '1') to play middle C.  The last byte  contains 
the velocity (or 'loudness') information. This depends on how hard 
or  fast the key was hit from a keyboard which  produces  velocity 
information. Or defaults to a value of $40 (64 decimal)  from  one 
which doesn't. Again it can vary between 0 - 127 ($0 - $7F).
     To write the example to the midi port just use:
     
     OUT 3,$90,$3C,$40   (The three denotes the midi port).

If a suitable midi device is connected to the midi out port of the 
ST  and set to midi channel 1 (or OMNI ON) then it should play  C3 
at  a  velocity  level  of 64  ($40).  Any  device  which  doesn't 
recognise  differing  velocity  levels will play  the  same  level 
regardless of the velocity value sent to it (apart from '0'  which 
is a special case).
     Anyone impulsive enough to have gone ahead and tried out  the 
above without reading any further should be driven mad by now  (if 
you  used a synthesiser with a sustained sound) as the  note  will 
continue  to  sound until it receives a Note Off message  for  the 
same note value.  The note off message can take two forms and  I'd 
better give you one first just in case you're being driven mad :
     $90,$3C,$0
As  you  can see this is just a note on message  with  a  velocity 
value  of zero.  The other form a note off can take is to  send  a 
Note  Off  status byte followed by note value  and  then  velocity 
value as before. So to end the example use : $80,$3C,$40
Similarly  to the note on status byte the note off  byte  contains 
the  midi  channel  in its lower nibble.  Also  as  with  note  on 
velocity  some  keyboards  will not  transmit  note  off  velocity 
information  (how fast a key is released) and will send a  default 
value of 64 ($40).
     To  demonstrate the basic principals I've just explained, two 
simple programs follow.  The first plays a chromatic scale from C1 
to  C6 on midi channel 1.  A chromatic scale means every  note  is 
played  by  the  way,for anyone even more musically ignorant  than 
myself. The second program plays random notes at random levels for 
different  durations.   It  should  be  quite  easy  to  vary  the 
ranges,midi channel,levels etc and it will help you  to understand
what is possible via midi even with this little information.

\** Program to play a chromatic scale from C1 - C6  
\** (midi notes 36 - 96) on midi channel 1.

FOR note%=36 TO 96
\ Note on message
        OUT 3,$90,note%,$40
\ Short delay
        time%=TIME
        REPEAT
        UNTIL TIME > time%+20
\ Note off message                
        OUT 3,$80,note%,$40
NEXT note%
        
END
        

\** Program to generate random notes on midi ch 1
\** with a random level and duration

REPEAT
        FOR i%=1 TO 400
\ Set midi note value C1-C6 (36-96)
        note%=RND(60)+36
\ Set velocity value
        volume%=RND(127)
\ Set delay 
        delay%=RND(1500)
\ Set velocity to zero second time ie send midi note off 
                FOR on%=1 TO 0 STEP -1
                OUT 3,144,note%,volume%*on% 
                        FOR time%=1 TO delay%
                        NEXT time%
                NEXT on%
        NEXT i%
        PRINT "AGAIN y/n "
        ans$=GET$
        CLS 
UNTIL  NOT(ans$="Y" OR ans$="y")
END

 
     Armed with this information it should be possible to write  a 
program  to  play a piece of music,providing that  you  dont  mind 
working  out  the midi note values,velocities and  delays  between 
notes etc.  Far more useful though (to me at any rate ) would be a 
program  which  accepts note entry in another  form.  For  example 
notes  could  be entered graphically with the mouse  or  from  the 
keyboard.  More  useful still would be the ability to enter  notes 
from  a midi keyboard connected to the midi in port of the  ST.   
     I've included a program which records midi notes played  into 
the midi in port of the ST and can then play them back at variable
speeds.  It records midi data in one element of a two  dimensional 
array and a counter value to set timing duration in the other.  It 
is  meant more as a demonstration than a useable sequencer but  it 
does have its uses.  I have deliberately filtered  aftertouch  and
active   sensing  (from  any  keyboard  which  might   send   this 
information) as they are both very memory hungry.  Aftertouch data 
is  sent by some keyboards by pressing down on a key after a  note 
has been played. Active sensing is sent by some devices  (at least
every   300  milliseconds)  to  ensure  that  it   hasn't   become 
disconnected.
     It  would be relatively easy to add the facility to save  and
load sequences to and from disk or to display and  edit  the  midi
note values recorded. I'll leave that to somone else though as for 
real applications it is really necassary to use assembly  language 
to prevent audible delays ocasionally ocurring.  Particularly when 
you  consider  that  a  realistic sequencer  must  be  capable  of 
recording  onto several different midi channels and  playing  them 
back at once. Or play a previous recording  while recording  a new
one.
     I'm not trying to put anyone off though as outside sequencing 
there are many uses for FAST BASIC midi programmes which only need 
a  little assembly language if any.  Such things as librarians  or 
editors  which fetch sound information from a particular  type  of 
synthesiser to graphically edit and/or store the sound information
on disk.
     There  are several useful midi utilities written  using  FAST 
BASIC such as Five Pin Din's excellent DXPERT (a YAMAHA DX7  voice 
editor),which although it is not available in source code form but
as a commercial editor shows what can be done with FAST BASIC. 

 


    
      
