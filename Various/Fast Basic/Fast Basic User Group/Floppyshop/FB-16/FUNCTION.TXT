
 FUNCT.BSC is written in Fast Basic

It can plot the graph of a function
or produce a table which you can use
to plot your own graph, but really
it is designed for finding the roots
of algebraic expressions by a simple
numerical method known as 'bisection'

 To show how it works lets look at 
an example.



 PROBLEM :
    Find the smallest positive root
of :-

           tSIN(t)=1


Not an easy task by traditional
mathematics, so start up Fast Basic
load FUNCTION.BSC and run it.



  
   You will be prompted to enter a 
function; the programme expects the
form   F(t)=0 so we must re-arrange
the problem from it's original
form to :

           tSIN(t)-1=0

    Now enter it.

Remember that every Basic (including
Fast Basic) needs to see all the *'s,
you can't leave any out   else Basic
won't understand what you mean !
  So you actually key in :-
   
           t*SIN(t)-1

  and press "RETURN"

(Quite painless so far isn't it ?)



    The next step is to see what the
 function looks like.

Press P to select option "plot"

   You will be prompted to enter a
lower limit, this time enter 0.

   The next prompt asks for an upper
limit, enter 10.

( you have chosen to plot the graph 
from t=0 to t=10)

 You are next asked for a scale,
enter 1 for a trial run.

 Hey Presto,    the graph is plotted
as soon as you press "RETURN"



 The wriggles at the start are
not shown very clearly,  don't worry
just press S to change the scale
make it equal 10 and see a new graph



This time it is clear that there is
a root (shown by the graph crossing
the zero axis just a little past
t=1.

 To confirm this press R to go back
 to the options, then T to tabulate
 (or list) the function.



We don't need much of a tabulation
this time, just try from a lower
limit of 0.5 to an upper limit of
2.0 using an interval of 0.5.

You can straight away see from the
table that at t=1 F(t)=-0.15....
and at t=1.5 F(t)=0.496.....

It's not the values that matter in
this instance, just the signs.

A - value for F(t) at t=1
followed by a + value at t=1.5
indicates that there is a root
between t=1 and t=1.5.

 Any change of sign in F(t) shows
that there is at least one root
between the corresponding values
 of t. 
  


So now we are ready for the final
act !  Press R to return to the
options, and R again to refine the
root.
  On the prompts enter 1 for the
first root and 1.5 for the second.
  A useful value for the number of
iterations is 10.
 Almost immediately you are told
that the root lies between :-
   1.11377 and 1.114258
Press I to get even closer,this
time the display says that there is
a root at 1.114157.

This response tells you that the
root has been found to the maximum
accuracy that the ST can manage
(well using normal length values
  anyway).
   





If you want to see better how this
programme converges to a root, try
again from t=1 and t=1.5 but using
only one iteration.  You will have
to keep on pressing I and the roots
shown will get closer and closer
together each time.
 Of course you could get there in
 one by selecting say 20 iterations
to begin with !
  Experiment and enjoy yourself
Solving equations this way is a lot
faster than most other methods, and
does't require a great depth of math
knowhow. But beware, the method can 
slip up if there is more than one
root between the start values that
you enter. You have been warned !
        Have fun
                           Argee 

