DEFINITION MODULE BTree;


CONST  Order = 84;   (* 42 =^ 512 k *)
       (* Mit dieser Ordnung erhÑlt man TSIZE(PageType) von 1024 k *)
       nn = Order;
       n = (nn DIV 2);
       Empty= -1D;
       TreeRoot=0D;


TYPE (* TYPEn fÅr den Bayer Baum *)


     FileType = ( TheData, NumIndex, GerIndex, PorIndex );  
     (* Unterscheidung zwischen Daten und IndexFiles             *)
     (* und den verschiedenen IndexArten. Dieser AufzÑhlungsTyp  *)
     (* wird vor allem fÅr die Querverweisliste bei multiplen    *)
     (* SchlÅsseln gebraucht (-> BaseType) => FileType so ordnen *)
     (* daû bei Next : ARRAY [FileType] keine unnîtigen EintrÑge *)
     (* entstehen, d.h. zuerst alle IndexTypen die keine doppelten *)
     (* SchlÅssel zulassen und dann die anderen (oder so ... ) *)
     

     KeyType = LONGCARD; (* Um diesen Typ zu Ñndern sind auch Anpassungen *)
       			 (* im  IMPLEMENTATION MODULE nîtig !!! *)

     EntryType = ARRAY [0..43] OF CHAR;
     
     DataType = RECORD
		   Inhalt : ARRAY[0..4] OF EntryType;
		   Flags  : ARRAY [0..5] OF CHAR; 
		(* 0..3 werden verwendet, 4,5 sind nur FÅllBytes *)
		(* um auf TSIZE(PageType) von 256 Bytes zu kommen *)
		END(*RECORD*);

     DataPtr = LONGINT; (* Zeigt auf die Lage der Daten im File *)
     
                        (* Wenn man DataPtr bzw. PagePtr auf INTEGER *)
                        (* Ñndern mîchte sind einige énderungen im  *)
                        (* IMPLEMENTATION MODULE notwendig! *)
                        
     PagePtr = LONGINT; (* Position einer Seite im File *)

     KeyArray =  ARRAY [NumIndex..PorIndex] OF KeyType;
     
     BaseType = RECORD
		  Flag : BOOLEAN;
		  Next : ARRAY [GerIndex..PorIndex] OF DataPtr;
		  (* Querverweisliste (doppelt verkettet) fÅr die Verwendung *)
		  (* von mehreren EintrÑgen pro SchlÅssel *)
		  Prev : ARRAY [GerIndex..PorIndex] OF DataPtr;
		  Key  : KeyArray;
		  (*Key  : ARRAY [NumIndex..PorIndex] OF KeyType;*)
		  (* In diesem Feld werden sÑmtliche SchlÅssel untergebracht *)
		  Data : DataType;
		END(*RECORD*);

     ItemType = RECORD
		   Key	    : KeyType;  (* 32 Bit *)
		   RecordNr : DataPtr;  (* 32 Bit *)
		   Ptr	    : PagePtr;  (* 32 Bit *)
		END(*RECORD*);

     PageType = RECORD
		   Flag : BOOLEAN;  (* 8 Bit *)
		   Anz	: CARDINAL;  (* 8 Bit *)
		   Ptr0 : PagePtr;   (* 32 Bit *)
		   Item : ARRAY [1..nn] OF ItemType; (* nn * 3 * 32 Bit *)
		   Filler1 : LONGCARD; (* Um auf 1024 zu kommen *)
		   Filler2 : LONGCARD; 
		END(*RECORD*);


     FileOf = RECORD 
(* Dieser Typ schleppt so ziemlich alles mit sich rum *)
(* was fÅr die Verwaltung der Datei interressant ist *)
		 Name : ARRAY [0..127] OF CHAR; 
		 (* Datei-Name *)
		 Handle : INTEGER; 
		 (* GEMDOS- Filehandle *)
		 CASE Type : FileType OF 
		 (* Je Nachdem ob es sich um ein Daten oder IndexFile *)
		 (* handelt Pointer auf unterschiedliche Typen        *)
		 (* Auûerdem werden durch den Eintrag im TAG-Feld die *)
		 (* verschiedenen Querverweislisten verwaltet         *)
				    TheData : RecordPtr : POINTER TO BaseType;
				    ELSE     RecordPtr1 : POINTER TO PageType;
			       END(*CASE*);
		 RecordSize : LONGINT; (* LONG(TSIZE(Inhalt)) *) 
		 (* LÑnge eines Records *)
		 Current : LONGINT; (* zeigt auf den augenblicklichen RECORD *)
		 Last : LONGINT; (* PagePtr bzw DataPtr *) 
		 (* Letzter Eintrag in der Datei                  *) 
		 (* gibt gleichzeitig die Dateigrîûe in Records an *)
                 MultipleKeys : BOOLEAN; 
                 (* Flag ob mehrere EintrÑge unter einem SchlÅssel erlaubt sind *)
	     END(*RECORD*);

	PrintDataProc = PROCEDURE( DataType);     

(* for internal use only :   *)

PROCEDURE Get( VAR File : FileOf; Pos : LONGINT);
PROCEDURE Put( VAR File : FileOf; Pos : LONGINT);
(*
PROCEDURE FileLength(FileName : ARRAY OF CHAR; length : LONGINT) :BOOLEAN;
  *)
  
  

PROCEDURE Create(VAR File : FileOf); (* Eine neue Datei anlegen. Ist eine Datei dieses Namens schon vorhanden wird sie gelîscht *)
PROCEDURE Start(VAR File : FileOf); (* Datei ôfnen. Die Datei muû vorhanden sein !!! *)
PROCEDURE Close(VAR File: FileOf);  (* Datei Schlieûen. Wichtig sonst gehen alle Daten verloren !!*)

PROCEDURE PutData(VAR DataBase : FileOf; Data : DataType;  Reference : DataPtr);
PROCEDURE GetData(VAR DataBase : FileOf; VAR Data : DataType; VAR Keys : KeyArray; Reference :DataPtr);

PROCEDURE AddKey(VAR Index, DataBase : FileOf; NewKey : KeyType; Reference : DataPtr): BOOLEAN;
PROCEDURE AddData( VAR DataBase : FileOf; NewData : DataType) : DataPtr;

PROCEDURE Delete(VAR Index, DataBase : FileOf; Key : KeyType; VAR DataPointer : DataPtr): BOOLEAN;

PROCEDURE SearchPtr(VAR Index, DataBase : FileOf; Page : PagePtr; Key : KeyType; VAR found : BOOLEAN) : DataPtr;

PROCEDURE SearchFirst(VAR Index, DataBase : FileOf; Key : KeyType; VAR Data : DataType; VAR Keys : KeyArray): BOOLEAN;

PROCEDURE SearchNext(VAR Index, DataBase : FileOf; VAR Data : DataType; VAR Keys : KeyArray) : BOOLEAN;
PROCEDURE SearchPrevious(VAR Index, DataBase : FileOf; VAR Data : DataType;VAR Keys : KeyArray) : BOOLEAN;
(*   Suche bei SchlÅsselgleichheit  *)

PROCEDURE First(VAR Index, DataBase : FileOf; VAR Key : KeyType; VAR Data : DataType; VAR Keys : KeyArray);
PROCEDURE Last (VAR Index, DataBase : FileOf; VAR Key : KeyType; VAR Data : DataType; VAR Keys : KeyArray);

PROCEDURE Next(VAR Index, DataBase : FileOf; Key : KeyType; VAR NextKey : KeyType; VAR NextData: DataType; VAR Keys : KeyArray) : BOOLEAN;
PROCEDURE Previous(VAR Index, DataBase : FileOf;  Key : KeyType; VAR NextKey : KeyType; VAR NextData: DataType; VAR Keys : KeyArray) : BOOLEAN;

PROCEDURE PrintTree(VAR Index, DataBase : FileOf; Tree : PagePtr; Tiefe : CARDINAL; OutProc : PrintDataProc);

PROCEDURE Browse(Index,DataBase : FileOf; Tree : PagePtr; 
                 From, To : KeyType; OutProc : PrintDataProc);

END BTree.
