
 
PlugIns fÅr GEMAR 																			æ Steffen Engel 1992,93

17.12.93


ALLGEMEINES

	In dieser Datei werden alle nîtigen Informationen zu PlugIns gegeben, der 
	aktuelle Stand der von GEMAR installierten PlugIn-Calls, die Liste der aktuell 
	existierenden PlugIns und der aktuelle Stand der PlugIns und ihrer 
	Programmierung.

	Die mit GEMAR gelieferten PlugIns sind grundsÑtzlich alle deaktiviert, indem
	die Namen mit PLX enden.

	Bitte beurteilen Sie selbst, welche PlugIns fÅr Sie sinnvoll sind.


WAS SIND PLUGINS?

	Um GEMAR mit weiteren FÑhigkeiten auszustatten, wurde ein Konzept entworfen, 
	mit dem externe Programme als Erweiterung hinzugeladen werden kînnen.

	Dabei wird von GEMAR an bestimmten Stellen einfach kontrolliert, ob ein zu 
	diesem Zweck gehîrendes PlugIn existiert, und ruft es gegebenenfalls auf.

	GrundsÑtzlich wurde das Konzept relativ einfach gehalten, da es dadurch 
	einerseits einfach zu verstehen und programmieren ist und andererseits kein 
	vollstÑndig modulares Programmierungssystem entworfen werden sollte.

	Mit diesem Konzept sind nur kleine Erweiterungen oder Ersetzungen von Teilen 
	von GEMAR mîglich.

	PlugIns sind vor allem dann sinnvoll, wenn kleine Erweiterungen an GEMAR 
	gemacht werden sollen, die fÅr bestimmte Probleme sinnvoll sind, aber zu 
	speziell sind, um allgemein in GEMAR eingebaut zu werden.

	PlugIns werden von GEMAR grundsÑtzlich im Ordner PLUGIN im GEMAR-Pfad
	gesucht.


EXISTIERENDE PLUGINS

	Zur Zeit existieren drei PlugIns:
	-REQSENSE prÑzisiert die Fehlermeldungen des Streamers, die in den Request 
						Sense Daten Åbergeben werden.
	-INDEX		wird nach jedem Backup aufgerufen und kann entweder den Inhalt eines 
						Bandes ausdrucken, oder in eine Datei schreiben.
	-SCANINDE wird beim Indexscanning aufgerufen. Damit kann eine Datei auf einem 
						Band gesucht werden.
	-SPACE		wird bei Space-Operationen des Streamers gerufen, um ein
						modifziertes Spacing durchzufÅhren
	-QFA			wird bei eingeschaltetem Quick File Access fÅr die Funktionen 
						benutzt.
						Dabei ist egal, welche Art eingeschaltet ist (Seek oder Locate)

	SCANINDE und INDEX besitzen gleiche Aufrufe, daû heiût, Sie kînnen INDEX.PLG 
	in SCANINDE.PLG umbenennen und damit per 'Scannen' nachtrÑglich den Inhalt des 
	Bandes in eine Datei schreiben lassen.


EXISTIERENDE PLUGIN-AUFRUFE

	-REQSENSE:
		Aufruf		: Nach einem Scsi-Fehler (Check Condition auf Streamerzugriff).
		Name			: REQSENSE.PLG
		Parameter : Zeiger auf Request-Sense-Daten, die vorher vom SCSI-GerÑt geholt 
								wurden.
		Antwort 	: Zeiger auf einen (nullterminierten) String, der in die Alertbox 
								eingesetzt wird ('Check Condition(%s)')

	-INDEX:
		Aufruf		: Nach einem Backup
		Name			: INDEX.PLG
		Parameter : Rumpf belkommt in private einen Zeiger auf den Index-Header.
								Ein Aufruf des Calls mit Parameter NIL zeigt an, daû
								eine neuer Index gelesen wurde und der Header mit den Daten
								gefÅllt ist.
								Ansonsten bekommt der Call Zeiger auf Index-EintrÑge, jeweils
								einen Ordner alphabetisch durchlaufen, danach den nÑchst-
								tieferen Ordner.
								Auf dieser Basis wÑre zB ein Exporter in eine Datenbank mîglich. 
								Åbergebene Struktur: s. INDEX.M

	-SCANINDEX:
		Aufruf		: bei Index-Scanning
		Name			: SCANINDE.PLG
		Parameter : wie INDEX, retour = 1 bricht Scanning ab und wÑhlt den
								aktuellen Index

	-SPACE:
		Aufruf		: Anstelle eines SCSI-Cmds Space
		Name			: SPACE.PLG
		Parameter : Zeiger auf die Struktur
								RECORD
									Code	: SHORTCARD;	 (* Opcode fÅr das Space-Kommando *)
									Count : LONGINT;		 (* Anzahl davon									*)
								END;

		private 	: Zeiger auf
								RECORD
									Version : SHORTCARD;	 (* = 0101H = 1.01 *)
									ScsiIn	: PROCEDURE ((* Cmd 				*) ADDRESS,
																			 (* CmdLen			*) SHORTCARD,
																			 (* Buffer			*) ADDRESS,
																			 (* Transferlen *) LONGCARD,
																			 (* Timeout 		*) LONGCARD) : SHORTCARD;
									ScsiOut : PROCEDURE ((* Cmd 				*) ADDRESS,
																			 (* CmdLen			*) SHORTCARD,
																			 (* Buffer			*) ADDRESS,
																			 (* Transferlen *) LONGCARD,
																			 (* CmdTimeout	*) LONGCARD,
																			 (* DataTimeout *) LONGCARD) : SHORTCARD;
								END;


	-QFA:
		Aufruf		: Anstelle eines SCSI-Cmds fÅr Quick File Access
		Zweck 		: Anpassung von Streamern mit Problemen/EinschrÑnkungen bei 
								Quick File Access, oder auch zur Anpassung an Streamer, die
								andere QFA-Befehle als Seek/Locate haben.
		Name			: QFA.PLG
		Parameter : Zeiger auf die Struktur
								RECORD
									Opcode		: SHORTCARD;				(* 1 = Position lesen
																								 * 2 = Position ansteuern *)
									Imed			: SHORTCARD;
									BlockAdr	: POINTER TO LONGCARD;
								END;

		private 	: Zeiger auf
								RECORD
									Version : SHORTCARD;	 (* = 0101H = 1.01 *)
									ScsiIn	: PROCEDURE ((* Cmd 				*) ADDRESS,
																			 (* CmdLen			*) SHORTCARD,
																			 (* Buffer			*) ADDRESS,
																			 (* Transferlen *) LONGCARD,
																			 (* Timeout 		*) LONGCARD) : SHORTCARD;
									ScsiOut : PROCEDURE ((* Cmd 				*) ADDRESS,
																			 (* CmdLen			*) SHORTCARD,
																			 (* Buffer			*) ADDRESS,
																			 (* Transferlen *) LONGCARD,
																			 (* CmdTimeout	*) LONGCARD,
																			 (* DataTimeout *) LONGCARD) : SHORTCARD;
								END;



	Weitere Aufrufe richte ich gerne ein, Ideen sind immer willkommen.


PROGRAMMIERUNG VON PLUGINS

	PlugIns werden grundsÑtzlich als Pozeduren aufgerufen. Als Methode wurde der 
	gleiche Weg gewÑhlt wie bei CPX-Modulen.

	PlugIns werden von GEMAR geladen und danach wird der Rumpf des PlugIns mit
	einem Zeiger auf folgende Struktur aufgerufen:

	tPlugEnvironment
		= RECORD
				(* aktuelle Parameterversion = 1.00 = 0100H *)
				Version  : sINTEGER;													(* Version zeigt Umfang der Parameter an	 *)
				Private  : ADDRESS; 													(* spezielle Parameter fÅr den Rumpf			 *)
				ApplId	 : sINTEGER;													(* Applikationsid des rufenden Programmes  *)
				VDIHandle : sINTEGER; 												(* Workstation des Hauptprogrammes				 *)
				PlugPath : POINTER TO ARRAY[0..512] OF CHAR;	(* Name und Pfad des PlugIn, kann auch
																												 relativ sein 													 *)
				Alert 	 : PROCEDURE((* def *) sINTEGER, VAR (* msg *) STRING) : sINTEGER;
			END;

	Die Struktur wird grundsÑtzlich abwÑrtskompatibel sein, d.h. bei erweiterten 
	Versionen kommen zusÑtzliche Parameter hinzu und die Versionsnummer wird 
	erhîht.

	Nach einer evtl. nîtigen Initialisierung (zB Abfragen, ob das Modul Åberhaupt 
	aktiviert werden soll) muû das PlugIn mit der Einsprungadresse der 
	Aktionsprozedur antworten.

	Diese Aktionsprozedur wird dann zur eigentlichen Verwendung ein- oder mehrmals 
	aufgerufen. Als Parameter wird ein Zeiger Åbergeben, der auf die zu 
	bearbeitenden Daten zeigt.

	Bitte beachten Sie, daû UNBEDINGT aller Speicher bei der Deinitialisierung 
	des PlugIns freigegeben wird, da der Speicher nicht durch das freigeben des 
	PlugIn freigeben wird!

	Als Beispiel sollten Sie sich die beiliegenden PlugIns ansehen, insbesondere
	PLUGPARMS.D


Steffen Engel
				